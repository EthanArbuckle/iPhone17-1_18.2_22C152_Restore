uint64_t CI::SurfaceImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  OSType __src;

  __src = *(_DWORD *)(a1 + 168);
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = *(_DWORD *)(a1 + 176);
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = *(_DWORD *)(a1 + 180);
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = *(_DWORD *)(a1 + 184);
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = *(unsigned __int8 *)(a1 + 188);
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = *(_DWORD *)(a1 + 172);
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = IOSurfaceGetPixelFormat(*(IOSurfaceRef *)(a1 + 112));
  return XXH64_update(a2, (char *)&__src, 4uLL);
}

uint64_t CI::ColorMatchImage::add_args_to_hash(uint64_t a1, CI::XXHashHelper *this)
{
  CI::XXHashHelper::add(this, *(CGColorSpaceRef *)(a1 + 120));
  CI::XXHashHelper::add(this, *(CGColorSpaceRef *)(a1 + 128));
  int __src = *(unsigned __int8 *)(a1 + 136);
  XXH64_update((uint64_t)this, (char *)&__src, 4uLL);
  int v6 = *(unsigned __int8 *)(a1 + 137);
  return XXH64_update((uint64_t)this, (char *)&v6, 4uLL);
}

uint64_t CI::ColorKernelImage::ColorKernelImage(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, int a5, int a6, double a7, double a8, double a9, double a10, float a11)
{
  *(double *)&long long v36 = a7;
  *((double *)&v36 + 1) = a8;
  *(double *)&long long v37 = a9;
  *((double *)&v37 + 1) = a10;
  CI::Image::Image((__n128 *)a1);
  *(void *)(v18 + 104) = &unk_1EE45AA08;
  *(void *)(v18 + 112) = a2;
  atomic_fetch_add(&dword_1EB466E78[9], 1u);
  *(void *)uint64_t v18 = &unk_1EE45BAC0;
  *(void *)(v18 + 104) = &unk_1EE45BC18;
  *(_DWORD *)(v18 + 176) = 0;
  if (a2 && *(unsigned char *)(a2 + 12)) {
    CI::Object::ref(a2);
  }
  *(void *)(a1 + 120) = a3;
  long long v19 = v37;
  *(_OWORD *)(a1 + 128) = v36;
  *(_OWORD *)(a1 + 144) = v19;
  *(void *)(a1 + 160) = _Block_copy(a4);
  *(unsigned char *)(a1 + 168) = a5;
  if (a6 && (CI::format_has_alpha(a6) & 1) == 0) {
    *(unsigned char *)(a1 + 168) = 1;
  }
  *(_DWORD *)(a1 + 172) = a6;
  *(float *)(a1 + 176) = a11;
  *(_DWORD *)(a1 + 72) = 0;
  int v20 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (v20 >= 1)
  {
    uint64_t v21 = 0;
    unsigned int v22 = *(_DWORD *)(a1 + 72);
    do
    {
      if (v22 <= *(_DWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 48))(a1, v21) + 72) + 1) {
        unsigned int v22 = *(_DWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 48))(a1, v21) + 72) + 1;
      }
      else {
        unsigned int v22 = *(_DWORD *)(a1 + 72);
      }
      *(_DWORD *)(a1 + 72) = v22;
      uint64_t v21 = (v21 + 1);
    }
    while (v20 != v21);
  }
  XXH64_reset(v35, 0);
  int __src = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  (*(void (**)(uint64_t, int64x2_t *))(*(void *)a2 + 64))(a2, v35);
  v23 = *(int **)(a1 + 120);
  if (*v23 >= 1)
  {
    unint64_t v24 = 0;
    uint64_t v25 = 6;
    do
    {
      if (v24 > 9) {
        v26 = (CI::XXHashHelper **)(*((void *)v23 + 2) + 8 * (v24 - 10));
      }
      else {
        v26 = (CI::XXHashHelper **)&v23[v25];
      }
      CI::Kernel::add_argument_to_digest((CI::Kernel *)v35, *v26, 0);
      ++v24;
      v23 = *(int **)(a1 + 120);
      v25 += 2;
    }
    while ((uint64_t)v24 < *v23);
  }
  XXH64_update((uint64_t)v35, (char *)&v36, 0x20uLL);
  int __src = a5;
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  int __src = a6;
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  *(void *)(a1 + 80) = XXH64_digest((uint64_t)v35);
  XXH64_reset(v35, 0);
  int __src = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  (*(void (**)(uint64_t, int64x2_t *))(*(void *)a2 + 64))(a2, v35);
  v27 = *(int **)(a1 + 120);
  if (*v27 >= 1)
  {
    unint64_t v28 = 0;
    uint64_t v29 = 6;
    do
    {
      if (v28 > 9) {
        v30 = (CI::XXHashHelper **)(*((void *)v27 + 2) + 8 * (v28 - 10));
      }
      else {
        v30 = (CI::XXHashHelper **)&v27[v29];
      }
      CI::Kernel::add_argument_to_digest((CI::Kernel *)v35, *v30, (const CI::Object *)1);
      ++v28;
      v27 = *(int **)(a1 + 120);
      v29 += 2;
    }
    while ((uint64_t)v28 < *v27);
  }
  XXH64_update((uint64_t)v35, (char *)&v36, 0x20uLL);
  int __src = a5;
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  int __src = a6;
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  *(void *)(a1 + 88) = XXH64_digest((uint64_t)v35);
  *(unsigned char *)(a1 + 96) = *(void *)(a2 + 48) != 0;
  if (v20 >= 1)
  {
    uint64_t v31 = 0;
    do
    {
      if (*(unsigned char *)((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 48))(a1, v31) + 96)) {
        BOOL v32 = *(unsigned char *)(a1 + 96) == 0;
      }
      else {
        BOOL v32 = 1;
      }
      char v33 = !v32;
      *(unsigned char *)(a1 + 96) = v33;
      uint64_t v31 = (v31 + 1);
    }
    while (v20 != v31);
  }
  *(unsigned char *)(a1 + 97) = 0;
  return a1;
}

void CI::Kernel::add_argument_to_digest(CI::Kernel *this, CI::XXHashHelper *a2, const CI::Object *a3)
{
  int v3 = (int)a3;
  int v6 = (*(uint64_t (**)(CI::XXHashHelper *))(*(void *)a2 + 16))(a2);
  switch(v6)
  {
    case ';':
      XXH64_update((uint64_t)this, (char *)a2 + 24, 0x10uLL);
      v8 = (CGColorSpace *)*((void *)a2 + 5);
      CI::XXHashHelper::add(this, v8);
      break;
    case ':':
      uint64_t v9 = *((int *)a2 + 6);
      if (v9)
      {
        XXH64_update((uint64_t)this, (char *)a2 + 28, 4 * v9);
      }
      break;
    case '9':
      CFDataRef v7 = (const __CFData *)*((void *)a2 + 3);
      CI::XXHashHelper::add(this, v7);
      break;
    default:
      int v10 = (*(uint64_t (**)(CI::XXHashHelper *))(*(void *)a2 + 16))(a2);
      if (CI::is_any_TypeImage(v10))
      {
        if (v3) {
          uint64_t v11 = *((void *)a2 + 11);
        }
        else {
          uint64_t v11 = *((void *)a2 + 10);
        }
        uint64_t __src = v11;
        XXH64_update((uint64_t)this, (char *)&__src, 8uLL);
      }
      break;
  }
}

uint64_t CI::ColorKernelImage::child_count(CI::ColorKernelImage *this)
{
  uint64_t v1 = **((unsigned int **)this + 15);
  if ((int)v1 < 1) {
    return 0;
  }
  unint64_t v3 = 0;
  LODWORD(v4) = 0;
  uint64_t v5 = 24;
  do
  {
    uint64_t v6 = *((void *)this + 15);
    if (v3 > 9) {
      uint64_t v7 = *(void *)(v6 + 16) + 8 * (v3 - 10);
    }
    else {
      uint64_t v7 = v6 + v5;
    }
    int v8 = (*(uint64_t (**)(void))(**(void **)v7 + 16))();
    uint64_t v4 = (v4 + CI::is_any_TypeImage(v8));
    ++v3;
    v5 += 8;
  }
  while (v1 != v3);
  return v4;
}

BOOL CI::is_any_TypeImage(int a1)
{
  return (a1 - 2) < 0x18;
}

uint64_t CI::ColorKernelNode::child_count(CI::ColorKernelNode *this)
{
  uint64_t v1 = **((unsigned int **)this + 7);
  if ((int)v1 < 1) {
    return 0;
  }
  unint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v5 = 24;
  do
  {
    uint64_t v6 = *((void *)this + 7);
    if (v3 > 9) {
      uint64_t v7 = (void *)(*(void *)(v6 + 16) + 8 * (v3 - 10));
    }
    else {
      uint64_t v7 = (void *)(v6 + v5);
    }
    uint64_t v8 = *v7;
    if ((*(int (**)(void))(*(void *)*v7 + 16))(*v7) >= 27)
    {
      if ((*(int (**)(uint64_t))(*(void *)v8 + 16))(v8) >= 53) {
        uint64_t v4 = v4;
      }
      else {
        uint64_t v4 = (v4 + 1);
      }
    }
    ++v3;
    v5 += 8;
  }
  while (v1 != v3);
  return v4;
}

uint64_t CI::Vector::type(CI::Vector *this)
{
  return 58;
}

uint64_t CI::ColorKernelNode::child(CI::ColorKernelNode *this, int a2)
{
  uint64_t v2 = **((unsigned int **)this + 7);
  if ((int)v2 >= 1)
  {
    unint64_t v5 = 0;
    int v6 = 0;
    uint64_t v7 = 24;
    do
    {
      uint64_t v8 = *((void *)this + 7);
      if (v5 > 9) {
        uint64_t v9 = (void *)(*(void *)(v8 + 16) + 8 * (v5 - 10));
      }
      else {
        uint64_t v9 = (void *)(v8 + v7);
      }
      uint64_t v10 = *v9;
      if ((*(int (**)(void))(*(void *)*v9 + 16))(*v9) >= 27
        && (*(int (**)(uint64_t))(*(void *)v10 + 16))(v10) <= 52)
      {
        if (v6 == a2) {
          return v10;
        }
        ++v6;
      }
      ++v5;
      v7 += 8;
    }
    while (v2 != v5);
  }
  return 0;
}

uint64_t CI::AffineNode::type(CI::AffineNode *this)
{
  return 28;
}

uint64_t CI::ColorKernelNode::type(CI::ColorKernelNode *this)
{
  return 49;
}

uint64_t CI::Color::type(CI::Color *this)
{
  return 59;
}

uint64_t CI::ColorKernelImage::child(CI::ColorKernelImage *this, int a2)
{
  uint64_t v2 = **((unsigned int **)this + 15);
  if ((int)v2 >= 1)
  {
    unint64_t v5 = 0;
    int v6 = 0;
    uint64_t v7 = 24;
    do
    {
      uint64_t v8 = *((void *)this + 15);
      if (v5 > 9) {
        uint64_t v9 = (void *)(*(void *)(v8 + 16) + 8 * (v5 - 10));
      }
      else {
        uint64_t v9 = (void *)(v8 + v7);
      }
      uint64_t v10 = *v9;
      int v11 = (*(uint64_t (**)(void))(*(void *)*v9 + 16))(*v9);
      if (CI::is_any_TypeImage(v11))
      {
        if (v6 == a2) {
          return v10;
        }
        ++v6;
      }
      ++v5;
      v7 += 8;
    }
    while (v2 != v5);
  }
  return 0;
}

uint64_t CI::ColorKernelImage::type(CI::ColorKernelImage *this)
{
  return 11;
}

uint64_t CI::CropImage::type(CI::CropImage *this)
{
  return 6;
}

void CI::XXHashHelper::add(CI::XXHashHelper *this, CGColorSpaceRef space)
{
  if (!space)
  {
    uint64_t __src = "nilCGColorSpaceRef";
LABEL_12:
    XXH64_update((uint64_t)this, (char *)&__src, 8uLL);
    return;
  }
  if (CGColorSpaceGetName(space))
  {
    CFStringRef Name = CGColorSpaceGetName(space);
    CI::XXHashHelper::add(this, Name);
    return;
  }
  CFDataRef v5 = CGColorSpaceCopyICCData(space);
  if (!v5)
  {
    uint64_t __src = (const char *)space;
    goto LABEL_12;
  }
  CFDataRef v6 = v5;
  CI::XXHashHelper::add(this, v5);

  CFRelease(v6);
}

uint64_t CI::ClampImage::type(CI::ClampImage *this)
{
  return 7;
}

uint64_t CI::Kernel::add_to_digest(CI::Kernel *this, CI::XXHashHelper *a2)
{
  unint64_t v3 = (char *)*((void *)this + 4);
  if (!v3)
  {
    unint64_t v3 = (char *)*((void *)this + 5);
    if (!v3) {
      unint64_t v3 = (char *)*((void *)this + 3);
    }
  }
  return CI::XXHashHelper::addstr((uint64_t)a2, v3);
}

uint64_t CI::XXHashHelper::add(CI::XXHashHelper *this, CFStringRef theString)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (theString)
  {
    CStringPtr = (char *)CFStringGetCStringPtr(theString, 0x8000100u);
    if (!CStringPtr)
    {
      if (CFStringGetCString(theString, buffer, 1024, 0x8000100u)) {
        CStringPtr = buffer;
      }
      else {
        CStringPtr = 0;
      }
    }
    return CI::XXHashHelper::addstr((uint64_t)this, CStringPtr);
  }
  else
  {
    *(_DWORD *)buffer = 0;
    return XXH64_update((uint64_t)this, buffer, 4uLL);
  }
}

uint64_t CI::XXHashHelper::addstr(uint64_t this, char *__s)
{
  if (__s)
  {
    uint64_t v3 = this;
    this = strlen(__s);
    if (this)
    {
      return XXH64_update(v3, __s, this);
    }
  }
  return this;
}

uint64_t CI::ImageToNodeMap::add(uint64_t *a1, uint64_t a2, uint64_t a3, CI::Object *this)
{
  CI::ImageToNodeMap::add_ImageDigest_to_node(a1, *(void *)(a3 + 80), this);
  unsigned int v8 = *(_DWORD *)(a3 + 100);
  unsigned int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3);
  uint64_t result = CI::is_raster_TypeImage(v9);
  if ((result & 1) != 0
    || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3), result == 13)
    || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3), result == 12)
    || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3), result == 17))
  {
    uint64_t v13 = *(void *)(a2 + 8);
    uint64_t v12 = a2 + 8;
    uint64_t v11 = v13;
    if (v13)
    {
      uint64_t v14 = v12;
      do
      {
        unsigned int v15 = *(_DWORD *)(v11 + 32);
        BOOL v16 = v15 >= v8;
        if (v15 >= v8) {
          v17 = (uint64_t *)v11;
        }
        else {
          v17 = (uint64_t *)(v11 + 8);
        }
        if (v16) {
          uint64_t v14 = v11;
        }
        uint64_t v11 = *v17;
      }
      while (*v17);
      if (v14 != v12 && v8 >= *(_DWORD *)(v14 + 32))
      {
        unint64_t v18 = *(void *)(v14 + 40);
        return (uint64_t)CI::ImageToNodeMap::add_ImageDigestForRG_to_node(a1, v18, this);
      }
    }
  }
  return result;
}

uint64_t CI::AffineImage::type(CI::AffineImage *this)
{
  return 2;
}

uint64_t CI::is_raster_TypeImage(unsigned int a1)
{
  return (a1 < 0x1A) & (0x20C0008u >> a1);
}

uint64_t CI::ColorMatchImage::type(CI::ColorMatchImage *this)
{
  return 4;
}

uint64_t *CI::ImageToNodeMap::add_ImageDigest_to_node(uint64_t *result, unint64_t a2, CI::Object *this)
{
  uint64_t v3 = (uint64_t **)result;
  unint64_t v10 = a2;
  uint64_t v4 = (void *)result[1];
  if (!v4) {
    goto LABEL_12;
  }
  CFDataRef v5 = result + 1;
  do
  {
    unint64_t v6 = v4[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      unsigned int v8 = v4;
    }
    else {
      unsigned int v8 = v4 + 1;
    }
    if (v7) {
      CFDataRef v5 = v4;
    }
    uint64_t v4 = (void *)*v8;
  }
  while (*v8);
  if (v5 == result + 1 || v5[4] > a2)
  {
LABEL_12:
    if (this) {
      uint64_t v9 = CI::Object::ref((uint64_t)this);
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v11 = &v10;
    uint64_t result = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v3, &v10, (uint64_t)&std::piecewise_construct, (uint64_t **)&v11);
    result[5] = v9;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  BOOL v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        BOOL v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        BOOL v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void CI::ProgramNode::roiKeys_of_child(CI::ProgramNode *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, uint64_t a3@<X1>, void *a4@<X8>)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  if ((int)CI::Node::rois_count(this) < 1) {
    goto LABEL_16;
  }
  uint64_t v10 = 0;
  do
  {
    uint64_t v11 = (void *)CI::Node::rois(this);
    v41 = 0;
    uint64_t v42 = 0;
    v40 = 0;
    uint64_t v12 = *v11 + 120 * v10;
    int v13 = *(_DWORD *)(v12 + 80);
    long long v14 = *(_OWORD *)(v12 + 16);
    long long v36 = *(_OWORD *)v12;
    long long v37 = v14;
    CI::SerialRectArray::recurseSubdivide((double *)&v36, v13, (void **)&v40);
    unsigned int v15 = v41;
    if (v41 == v40)
    {
LABEL_9:
      char v20 = 0;
      if (!v15) {
        goto LABEL_11;
      }
LABEL_10:
      v41 = v15;
      operator delete(v15);
      goto LABEL_11;
    }
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    unsigned int v15 = v40;
    while (1)
    {
      v43.origin.CGFloat x = x;
      v43.origin.CGFloat y = y;
      v43.size.CGFloat width = width;
      v43.size.CGFloat height = height;
      if (CGRectEqualToRect(v43, *(CGRect *)&v15[v16])) {
        break;
      }
LABEL_8:
      ++v17;
      unsigned int v15 = v40;
      v16 += 32;
      if (v17 >= (v41 - v40) >> 5) {
        goto LABEL_9;
      }
    }
    *(void *)&long long v36 = this;
    *((void *)&v36 + 1) = __PAIR64__(v17, v10);
    long long v37 = a3 | 0xFFFFFFFF00000000;
    uint64_t v38 = 0;
    int v39 = 0;
    unint64_t v18 = (CI::Node *)(*(uint64_t (**)(CI::ProgramNode *, uint64_t))(*(void *)this + 48))(this, a3);
    long long v19 = (uint64_t **)CI::Node::rois(v18);
    CI::SerialRectArray::findParentROI(v19, (uint64_t)&v36, (uint64_t)&__block_literal_global_26_0, (uint64_t)&v33);
    if (!v35)
    {
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v33, v34);
      goto LABEL_8;
    }
    CI::roiKeyVec::roiKeyVec(a4, (uint64_t)v18, &v33);
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v33, v34);
    char v20 = 1;
    unsigned int v15 = v40;
    if (v40) {
      goto LABEL_10;
    }
LABEL_11:
    if (v20) {
      return;
    }
    ++v10;
  }
  while (v10 < (int)CI::Node::rois_count(this));
LABEL_16:
  if ((int)CI::Node::rois_count(this) < 1) {
    goto LABEL_31;
  }
  uint64_t v21 = 0;
  do
  {
    unsigned int v22 = (void *)CI::Node::rois(this);
    v41 = 0;
    uint64_t v42 = 0;
    v40 = 0;
    uint64_t v23 = *v22 + 120 * v21;
    int v24 = *(_DWORD *)(v23 + 80);
    long long v25 = *(_OWORD *)(v23 + 16);
    long long v36 = *(_OWORD *)v23;
    long long v37 = v25;
    CI::SerialRectArray::recurseSubdivide((double *)&v36, v24, (void **)&v40);
    v26 = v41;
    if (v41 == v40)
    {
LABEL_24:
      char v31 = 0;
      if (!v26) {
        goto LABEL_26;
      }
LABEL_25:
      v41 = v26;
      operator delete(v26);
      goto LABEL_26;
    }
    uint64_t v27 = 0;
    unint64_t v28 = 0;
    v26 = v40;
    while (1)
    {
      v44.origin.CGFloat x = x;
      v44.origin.CGFloat y = y;
      v44.size.CGFloat width = width;
      v44.size.CGFloat height = height;
      if (CGRectEqualToRect(v44, *(CGRect *)&v26[v27])) {
        break;
      }
LABEL_23:
      ++v28;
      v26 = v40;
      v27 += 32;
      if (v28 >= (v41 - v40) >> 5) {
        goto LABEL_24;
      }
    }
    *(void *)&long long v36 = this;
    *((void *)&v36 + 1) = __PAIR64__(v28, v21);
    long long v37 = a3 | 0xFFFFFFFF00000000;
    uint64_t v38 = 0;
    int v39 = 0;
    uint64_t v29 = (CI::Node *)(*(uint64_t (**)(CI::ProgramNode *, uint64_t))(*(void *)this + 48))(this, a3);
    v30 = (uint64_t **)CI::Node::rois(v29);
    CI::SerialRectArray::findRetiredParentROI(v30, (uint64_t)&v36, (uint64_t)&__block_literal_global_30_0, (uint64_t)&v33);
    if (!v35)
    {
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v33, v34);
      goto LABEL_23;
    }
    CI::roiKeyVec::roiKeyVec(a4, (uint64_t)v29, &v33);
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v33, v34);
    char v31 = 1;
    v26 = v40;
    if (v40) {
      goto LABEL_25;
    }
LABEL_26:
    if (v31) {
      return;
    }
    ++v21;
  }
  while (v21 < (int)CI::Node::rois_count(this));
LABEL_31:
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
}

void std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t CI::_traverse_dag(CI::SerialStringArray **a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12 = (char *)a8;
  *(unsigned char *)(a8 + (int)a4) = a5 + 48;
  uint64_t v19 = (int)a4;
  uint64_t v37 = (int)a4 + 1;
  *(unsigned char *)(a8 + v37) = 0;
  uint64_t IndexOfString = CI::SerialStringArray::firstIndexOfString(a1[7], (const char *)(a8 + 1));
  if (IndexOfString != -1) {
    a2 = (*((uint64_t (**)(CI::SerialStringArray **, uint64_t))*a1 + 6))(a1, IndexOfString);
  }
  int v38 = IndexOfString;
  unint64_t v21 = CI::hash_dag_node_id(a2, a7, v12);
  uint64_t result = a12;
  if (a12)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(a12 + 16))(a12, a2);
    int v23 = result ^ 1;
  }
  else
  {
    int v23 = 0;
  }
  int v24 = *(void **)(a9 + 8);
  if (!v24) {
    goto LABEL_19;
  }
  long long v25 = (void *)(a9 + 8);
  do
  {
    unint64_t v26 = v24[4];
    BOOL v27 = v26 >= v21;
    if (v26 >= v21) {
      unint64_t v28 = v24;
    }
    else {
      unint64_t v28 = v24 + 1;
    }
    if (v27) {
      long long v25 = v24;
    }
    int v24 = (void *)*v28;
  }
  while (*v28);
  if (v25 == (void *)(a9 + 8)) {
    goto LABEL_19;
  }
  if (v21 < v25[4]) {
    int v23 = 1;
  }
  if (v23 == 1)
  {
LABEL_19:
    v42[0] = v21;
    uint64_t result = (uint64_t)std::__tree<char const*>::__emplace_unique_key_args<char const*,char const* const&>((uint64_t **)a9, (unint64_t *)v42, v42);
    if (a10) {
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, char *, int))(a10 + 16))(a10, a2, a3, a4, a5, a6, a7, v12, v38);
    }
    uint64_t v36 = a4;
    uint64_t v41 = a7;
    v40 = a1;
    if (v38 == -1)
    {
      uint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 40))(a2);
      if ((int)result >= 1)
      {
        int v29 = result;
        uint64_t v30 = 0;
        do
        {
          uint64_t v31 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)a2 + 48))(a2, v30);
          BOOL v32 = v12;
          if ((*(unsigned int (**)(unint64_t))(*(void *)a2 + 232))(a2)) {
            unint64_t v33 = a2;
          }
          else {
            unint64_t v33 = a6;
          }
          if ((*(unsigned int (**)(unint64_t))(*(void *)a2 + 232))(a2)) {
            unint64_t v34 = v21;
          }
          else {
            unint64_t v34 = v41;
          }
          unint64_t v35 = v33;
          uint64_t v12 = v32;
          uint64_t result = CI::_traverse_dag(v40, v31, a2, v37, v30, v35, v34, v32, a9, a10, a11, a12);
          uint64_t v30 = (v30 + 1);
        }
        while (v29 != v30);
      }
    }
    if (a11) {
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, void, unint64_t, uint64_t, char *, int))(a11 + 16))(a11, a2, a3, v36, a5, a6, v41, v12, v38);
    }
  }
  v12[v19] = 0;
  return result;
}

uint64_t CI::SerialStringArray::firstIndexOfString(CI::SerialStringArray *this, const char *__s2)
{
  uint64_t v2 = *(unsigned int *)this;
  if ((int)v2 < 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = 0;
  uint64_t v5 = *((void *)this + 4);
  while (strcmp(*(const char **)(v5 + 8 * v4), __s2))
  {
    if (v2 == ++v4) {
      return 0xFFFFFFFFLL;
    }
  }
  return v4;
}

uint64_t CI::Node::is_warp(CI::Node *this)
{
  return 0;
}

unint64_t CI::hash_dag_node_id(unint64_t result, uint64_t a2, char *a3)
{
  if (result)
  {
    unint64_t v5 = result;
    XXH64_reset(v6, 0);
    LODWORD(__src) = *(_DWORD *)(v5 + 36);
    XXH64_update((uint64_t)v6, (char *)&__src, 4uLL);
    uint64_t __src = a2;
    XXH64_update((uint64_t)v6, (char *)&__src, 8uLL);
    if ((int)(-286331153 * ((*(void *)(*(void *)(v5 + 16) + 8) - **(void **)(v5 + 16)) >> 3)) >= 2) {
      CI::XXHashHelper::addstr((uint64_t)v6, a3);
    }
    return XXH64_digest((uint64_t)v6);
  }
  return result;
}

uint64_t XXH64_reset(int64x2_t *a1, unint64_t a2)
{
  a1[1] = vaddq_s64(vdupq_n_s64(a2), (int64x2_t)xmmword_19395AC10);
  a1[2].i64[0] = a2;
  a1[2].i64[1] = a2 + 0x61C8864E7A143579;
  a1->i64[0] = 0;
  a1->i64[1] = a2;
  a1[5].i32[0] = 0;
  return 0;
}

unint64_t XXH64_digest(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 48);
  uint64_t v2 = *(unsigned int *)(a1 + 80);
  unint64_t v3 = a1 + 48 + v2;
  if (*(void *)a1 < 0x20uLL) {
    uint64_t v4 = *(void *)(a1 + 8) + 0x27D4EB2F165667C5;
  }
  else {
    uint64_t v4 = 0x85EBCA77C2B2AE63
  }
       - 0x61C8864E7A143579
       * ((0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579
         * ((0x85EBCA77C2B2AE63
           - 0x61C8864E7A143579
           * ((0x85EBCA77C2B2AE63
             - 0x61C8864E7A143579
             * ((__ROR8__(*(void *)(a1 + 24), 57)
               + __ROR8__(*(void *)(a1 + 16), 63)
               + __ROR8__(*(void *)(a1 + 32), 52)
               + __ROR8__(*(void *)(a1 + 40), 46)) ^ (0x9E3779B185EBCA87
                                                      * ((0x93EA75A780000000 * *(void *)(a1 + 16)) | ((0xC2B2AE3D27D4EB4FLL * *(void *)(a1 + 16)) >> 33))))) ^ (0x9E3779B185EBCA87 * ((0x93EA75A780000000 * *(void *)(a1 + 24)) | ((0xC2B2AE3D27D4EB4FLL * *(void *)(a1 + 24)) >> 33))))) ^ (0x9E3779B185EBCA87 * ((0x93EA75A780000000 * *(void *)(a1 + 32)) | ((0xC2B2AE3D27D4EB4FLL * *(void *)(a1 + 32)) >> 33))))) ^ (0x9E3779B185EBCA87 * ((0x93EA75A780000000 * *(void *)(a1 + 40)) | ((0xC2B2AE3D27D4EB4FLL * *(void *)(a1 + 40)) >> 33))));
  unint64_t v5 = v4 + *(void *)a1;
  if (a1 + 56 <= v3)
  {
    do
    {
      unint64_t v6 = (unsigned int *)(v1 + 1);
      unint64_t v5 = 0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579
         * __ROR8__((0x9E3779B185EBCA87 * ((0x93EA75A780000000 * *v1) | ((0xC2B2AE3D27D4EB4FLL * *v1) >> 33))) ^ v5, 37);
      BOOL v7 = (unint64_t)(v1 + 2) > v3;
      ++v1;
    }
    while (!v7);
  }
  else
  {
    unint64_t v6 = (unsigned int *)(a1 + 48);
  }
  if ((unint64_t)(v6 + 1) <= v3) {
    unint64_t v5 = 0x165667B19E3779F9 - 0x3D4D51C2D82B14B1 * __ROR8__((0x9E3779B185EBCA87 * *v6++) ^ v5, 41);
  }
  if ((unint64_t)v6 < v3)
  {
    uint64_t v8 = a1 + v2 - (void)v6 + 48;
    do
    {
      unsigned int v9 = *(unsigned __int8 *)v6;
      unint64_t v6 = (unsigned int *)((char *)v6 + 1);
      unint64_t v5 = 0x9E3779B185EBCA87 * __ROR8__((0x27D4EB2F165667C5 * v9) ^ v5, 53);
      --v8;
    }
    while (v8);
  }
  unint64_t v10 = 0x165667B19E3779F9
      * ((0xC2B2AE3D27D4EB4FLL * (v5 ^ (v5 >> 33))) ^ ((0xC2B2AE3D27D4EB4FLL * (v5 ^ (v5 >> 33))) >> 29));
  return v10 ^ HIDWORD(v10);
}

uint64_t *std::__tree<char const*>::__emplace_unique_key_args<char const*,char const* const&>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  unint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        unint64_t v5 = *v8;
        unint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        unint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    unint64_t v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

uint64_t *std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  unint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      unint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), unint64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            unint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            unint64_t v9 = (uint64_t **)v2[1];
            unint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              unint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *unint64_t v9 = v2;
            v2[2] = (uint64_t)v9;
            unint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *unint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (int v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            unint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          unint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *unint64_t v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

CI::CGRectArray *CI::CGRectArray::CGRectArray(CI::CGRectArray *this, const CGRect *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  uint64_t v4 = (CGSize *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>((uint64_t)this + 16, 1uLL);
  int v6 = &v4[2 * v5];
  CGSize size = a2->size;
  *uint64_t v4 = (CGSize)a2->origin;
  v4[1] = size;
  int v8 = v4 + 2;
  unint64_t v10 = *(char **)this;
  unint64_t v9 = (char *)*((void *)this + 1);
  if (v9 != *(char **)this)
  {
    do
    {
      CGSize v11 = (CGSize)*((_OWORD *)v9 - 1);
      v4[-2] = *((CGSize *)v9 - 2);
      v4[-1] = v11;
      v4 -= 2;
      v9 -= 32;
    }
    while (v9 != v10);
    unint64_t v9 = *(char **)this;
  }
  *(void *)this = v4;
  *((void *)this + 1) = v8;
  *((void *)this + 2) = v6;
  if (v9) {
    operator delete(v9);
  }
  *((void *)this + 1) = v8;
  return this;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(32 * a2);
}

uint64_t XXH64_update(uint64_t a1, char *__src, size_t __n)
{
  int v3 = __n;
  uint64_t v4 = __src;
  *(void *)a1 += __n;
  uint64_t v6 = *(unsigned int *)(a1 + 80);
  if (v6 + __n <= 0x1F)
  {
    memcpy((void *)(a1 + v6 + 48), __src, __n);
    LODWORD(v7) = *(_DWORD *)(a1 + 80) + v3;
LABEL_11:
    *(_DWORD *)(a1 + 80) = v7;
    return 0;
  }
  int v8 = &__src[__n];
  if (v6)
  {
    memcpy((void *)(a1 + 48 + v6), __src, (32 - v6));
    uint64_t v9 = __ROR8__(*(void *)(a1 + 24) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 56), 33);
    *(void *)(a1 + 16) = 0x9E3779B185EBCA87
                         * __ROR8__(*(void *)(a1 + 16) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 48), 33);
    *(void *)(a1 + 24) = 0x9E3779B185EBCA87 * v9;
    unint64_t v10 = 0x9E3779B185EBCA87 * __ROR8__(*(void *)(a1 + 40) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 72), 33);
    *(void *)(a1 + 32) = 0x9E3779B185EBCA87
                         * __ROR8__(*(void *)(a1 + 32) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 64), 33);
    *(void *)(a1 + 40) = v10;
    v4 += (32 - *(_DWORD *)(a1 + 80));
    *(_DWORD *)(a1 + 80) = 0;
  }
  if (v4 + 32 <= v8)
  {
    unint64_t v11 = *(void *)(a1 + 16);
    unint64_t v12 = *(void *)(a1 + 24);
    unint64_t v14 = *(void *)(a1 + 32);
    unint64_t v13 = *(void *)(a1 + 40);
    do
    {
      unint64_t v11 = 0x9E3779B185EBCA87 * __ROR8__(v11 - 0x3D4D51C2D82B14B1 * *(void *)v4, 33);
      unint64_t v12 = 0x9E3779B185EBCA87 * __ROR8__(v12 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 1), 33);
      unint64_t v14 = 0x9E3779B185EBCA87 * __ROR8__(v14 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 2), 33);
      unint64_t v13 = 0x9E3779B185EBCA87 * __ROR8__(v13 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 3), 33);
      v4 += 32;
    }
    while (v4 <= v8 - 32);
    *(void *)(a1 + 16) = v11;
    *(void *)(a1 + 24) = v12;
    *(void *)(a1 + 32) = v14;
    *(void *)(a1 + 40) = v13;
  }
  if (v4 < v8)
  {
    size_t v7 = v8 - v4;
    memcpy((void *)(a1 + 48), v4, v7);
    goto LABEL_11;
  }
  return 0;
}

uint64_t CI::ColorKernelNode::is_warp(CI::ColorKernelNode *this)
{
  return 0;
}

uint64_t CI::ProgramNode::child(CI::ProgramNode *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  if ((*(int (**)(CI::ProgramNode *))(*(void *)this + 40))(this) <= (int)a2) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 8);
  if (a2 > 9) {
    uint64_t v5 = *(void *)(v4 + 16) + 8 * (a2 - 10);
  }
  else {
    uint64_t v5 = v4 + 8 * a2 + 24;
  }
  return *(void *)v5;
}

uint64_t CI::ProgramNode::child_count(CI::ProgramNode *this)
{
  return **((unsigned int **)this + 8);
}

uint64_t CI::Node::rois(CI::Node *this)
{
  return *((void *)this + 2);
}

uint64_t CI::AffineNode::is_warp(CI::AffineNode *this)
{
  return 1;
}

void CI::SerialRectArray::recurseSubdivide(double *a1, int a2, void **a3)
{
  if (a2 == 1)
  {
    unint64_t v5 = (unint64_t)a3[2];
    uint64_t v6 = a3[1];
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v16 = ((char *)v6 - (unsigned char *)*a3) >> 5;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 59) {
        abort();
      }
      uint64_t v18 = v5 - (void)*a3;
      if (v18 >> 4 > v17) {
        unint64_t v17 = v18 >> 4;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v19 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19) {
        char v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>((uint64_t)(a3 + 2), v19);
      }
      else {
        char v20 = 0;
      }
      unsigned int v22 = &v20[32 * v16];
      int v23 = &v20[32 * v19];
      long long v24 = *((_OWORD *)a1 + 1);
      *(_OWORD *)unsigned int v22 = *(_OWORD *)a1;
      *((_OWORD *)v22 + 1) = v24;
      int v8 = v22 + 32;
      unint64_t v26 = (char *)*a3;
      long long v25 = (char *)a3[1];
      if (v25 != *a3)
      {
        do
        {
          long long v27 = *((_OWORD *)v25 - 1);
          *((_OWORD *)v22 - 2) = *((_OWORD *)v25 - 2);
          *((_OWORD *)v22 - 1) = v27;
          v22 -= 32;
          v25 -= 32;
        }
        while (v25 != v26);
        long long v25 = (char *)*a3;
      }
      *a3 = v22;
      a3[1] = v8;
      a3[2] = v23;
      if (v25) {
        operator delete(v25);
      }
    }
    else
    {
      long long v7 = *((_OWORD *)a1 + 1);
      *uint64_t v6 = *(_OWORD *)a1;
      v6[1] = v7;
      int v8 = v6 + 2;
    }
    a3[1] = v8;
  }
  else
  {
    float v9 = a1[2];
    float v10 = a1[3];
    if (v9 <= v10)
    {
      long long v21 = *(_OWORD *)a1;
      long long v29 = *((_OWORD *)a1 + 1);
      long long v30 = v21;
      double v31 = a1[2];
      double v32 = floor(v10 * 0.5 * 0.25) * 4.0;
      long long v28 = *(_OWORD *)a1;
      *((double *)&v28 + 1) = v32 + *((double *)&v28 + 1);
      *((double *)&v29 + 1) = v10 - v32;
      uint64_t v14 = (a2 >> 1);
      CI::SerialRectArray::recurseSubdivide(&v28, v14, a3);
      unsigned int v15 = &v30;
    }
    else
    {
      double v11 = v9;
      long long v12 = *((_OWORD *)a1 + 1);
      long long v30 = *(_OWORD *)a1;
      double v32 = *((double *)&v12 + 1);
      double v31 = floor(v11 * 0.5 * 0.25) * 4.0;
      long long v13 = *((_OWORD *)a1 + 1);
      long long v28 = *(_OWORD *)a1;
      *((void *)&v29 + 1) = *((void *)&v13 + 1);
      *(double *)&long long v28 = v31 + *(double *)&v28;
      *(double *)&long long v29 = v11 - v31;
      uint64_t v14 = (a2 >> 1);
      CI::SerialRectArray::recurseSubdivide(&v30, v14, a3);
      unsigned int v15 = &v28;
    }
    CI::SerialRectArray::recurseSubdivide(v15, v14, a3);
  }
}

uint64_t ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_7(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a2 + 232))(a2) ^ 1;
}

void ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_6(uint64_t a1, CI::Object *this, int a3, int a4, int a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  if (a9 == -1)
  {
    uint64_t v15 = *(void *)(a1 + 48);
    v65 = this;
    uint64_t v66 = 0;
    if (this) {
      CI::Object::ref((uint64_t)this);
    }
    uint64_t v16 = (*(uint64_t (**)(CI::Object *, void))(*(void *)this + 320))(this, *(void *)(v15 + 24));
    uint64_t v66 = v16;
    if (!v16) {
      uint64_t v16 = (uint64_t)v65;
    }
    uint64_t v63 = v16;
    if ((*(unsigned int (**)(void))(*(void *)v16 + 16))() == 49)
    {
      uint64_t v17 = *(void *)(v63 + 48);
      if (a6)
      {
        unint64_t v64 = CI::hash_dag_node_id(a6, a7, 0);
        v67 = &v64;
        uint64_t v18 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 104), &v64, (uint64_t)&std::piecewise_construct, (uint64_t **)&v67)+ 5;
      }
      else
      {
        uint64_t v18 = (uint64_t *)(a1 + 56);
      }
      uint64_t v21 = *v18;
      int v60 = *(_DWORD *)(v17 + 16);
      if (v60 == 3) {
        unsigned __int8 v22 = *(unsigned char *)(v17 + 161) | 2;
      }
      else {
        unsigned __int8 v22 = *(unsigned char *)(v17 + 161);
      }
      unint64_t v62 = CI::hash_dag_node_id((unint64_t)this, a7, a8);
      CI::MetalDAGHelper::add_function_info(v15, *(CI::SerialStringArray ***)(a1 + 64), (const CI::Kernel **)v63, *(void *)(a1 + 72), v21, a4, a7, a8, 0, (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v22);
      uint64_t v23 = a7;
      char v24 = v22;
      uint64_t v25 = CI::MetalDAGHelper::color_output_for_kernel((CI::MetalDAGHelper *)v15, (const CI::Kernel *)v17, v22, (unint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      uint64_t v58 = v26;
      uint64_t v27 = v25;
      uint64_t v28 = v15;
      long long v29 = a8;
      uint64_t v30 = v28;
      double v31 = (uint64_t **)(v28 + 128);
      unint64_t v64 = v62;
      v67 = &v64;
      double v32 = std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v28 + 128), &v64, (uint64_t)&std::piecewise_construct, (uint64_t **)&v67);
      v32[5] = v27;
      v32[6] = v58;
      uint64_t v33 = 1;
      for (uint64_t i = 58; i != 64; i += 2)
      {
        uint64_t v35 = *(void *)(*(void *)(a1 + 40) + 8);
        if (*(_WORD *)(v35 + i - 8) || *(_WORD *)(v35 + i))
        {
          CI::MetalDAGHelper::add_function_info(v30, *(CI::SerialStringArray ***)(a1 + 64), (const CI::Kernel **)v63, *(void *)(a1 + 72), v21, a4, v23, v29, v33, (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v24);
          unint64_t v64 = v62;
          v67 = &v64;
          uint64_t v36 = std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v31, &v64, (uint64_t)&std::piecewise_construct, (uint64_t **)&v67);
          uint64_t v37 = *(void *)(*(void *)(a1 + 32) + 8);
          uint64_t v38 = *(void *)(v37 + 24);
          *(void *)(v37 + 24) = v38 + 1;
          if (v60 == 3)
          {
            *(_WORD *)((char *)v36 + i - 8) = v38;
            int v39 = (_WORD *)((char *)v36 + i - 16);
          }
          else
          {
            *(_WORD *)((char *)v36 + i - 16) = v38;
            int v39 = (_WORD *)v36 + v33 + 24;
          }
          *int v39 = 0;
        }
        ++v33;
      }
    }
    else
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v63 + 16))(v63) != 51
        || !(*(unsigned int (**)(uint64_t))(*(void *)v63 + 296))(v63))
      {
        goto LABEL_26;
      }
      uint64_t v19 = *(void *)(v63 + 48);
      if (a6)
      {
        unint64_t v64 = CI::hash_dag_node_id(a6, a7, 0);
        v67 = &v64;
        char v20 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 104), &v64, (uint64_t)&std::piecewise_construct, (uint64_t **)&v67)+ 5;
      }
      else
      {
        char v20 = (uint64_t *)(a1 + 56);
      }
      uint64_t v40 = *v20;
      int v61 = *(_DWORD *)(v19 + 16);
      if (v61 == 3) {
        unsigned __int8 v41 = *(unsigned char *)(v19 + 161) | 2;
      }
      else {
        unsigned __int8 v41 = *(unsigned char *)(v19 + 161);
      }
      unint64_t v62 = CI::hash_dag_node_id((unint64_t)this, a7, a8);
      CI::MetalDAGHelper::add_function_info(v15, *(CI::ProgramNode **)(a1 + 64), v63, *(CI::SerialObjectPtrArray **)(a1 + 72), v40, a4, a7, a8, 0, (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v41);
      char v42 = v41;
      uint64_t v43 = CI::MetalDAGHelper::color_output_for_kernel((CI::MetalDAGHelper *)v15, (const CI::Kernel *)v19, v41, (unint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      uint64_t v57 = v44;
      uint64_t v59 = v43;
      uint64_t v45 = v15;
      uint64_t v46 = a7;
      v47 = a8;
      uint64_t v48 = v45;
      double v31 = (uint64_t **)(v45 + 128);
      unint64_t v64 = v62;
      v67 = &v64;
      v49 = std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v45 + 128), &v64, (uint64_t)&std::piecewise_construct, (uint64_t **)&v67);
      v49[5] = v59;
      v49[6] = v57;
      uint64_t v50 = 1;
      for (uint64_t j = 58; j != 64; j += 2)
      {
        uint64_t v52 = *(void *)(*(void *)(a1 + 40) + 8);
        if (*(_WORD *)(v52 + j - 8) || *(_WORD *)(v52 + j))
        {
          CI::MetalDAGHelper::add_function_info(v48, *(CI::ProgramNode **)(a1 + 64), v63, *(CI::SerialObjectPtrArray **)(a1 + 72), v40, a4, v46, v47, v50, (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v42);
          unint64_t v64 = v62;
          v67 = &v64;
          v53 = std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v31, &v64, (uint64_t)&std::piecewise_construct, (uint64_t **)&v67);
          uint64_t v54 = *(void *)(*(void *)(a1 + 32) + 8);
          uint64_t v55 = *(void *)(v54 + 24);
          *(void *)(v54 + 24) = v55 + 1;
          if (v61 == 3)
          {
            *(_WORD *)((char *)v53 + j - 8) = v55;
            v56 = (_WORD *)((char *)v53 + j - 16);
          }
          else
          {
            *(_WORD *)((char *)v53 + j - 16) = v55;
            v56 = (_WORD *)v53 + v50 + 24;
          }
          _WORD *v56 = 0;
        }
        ++v50;
      }
    }
    unint64_t v64 = v62;
    v67 = &v64;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) = *(_OWORD *)(std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v31, &v64, (uint64_t)&std::piecewise_construct, (uint64_t **)&v67)+ 5);
LABEL_26:
    CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)&v65);
  }
}

void sub_19367583C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_5(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a2 + 232))(a2) ^ 1;
}

unint64_t ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_4(unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  if (a9 != -1)
  {
    unint64_t v13 = result;
    uint64_t v14 = *(void *)(result + 32);
    if (!a3 || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 192))(a3, a5), result))
    {
      uint64_t result = CI::hash_dag_node_id(a2, a7, a8);
      uint64_t v15 = (void *)result;
      uint64_t v16 = *(void **)(v14 + 136);
      if (!v16) {
        goto LABEL_15;
      }
      uint64_t v17 = (void *)(v14 + 136);
      do
      {
        unint64_t v18 = v16[4];
        BOOL v19 = v18 >= result;
        if (v18 >= result) {
          char v20 = v16;
        }
        else {
          char v20 = v16 + 1;
        }
        if (v19) {
          uint64_t v17 = v16;
        }
        uint64_t v16 = (void *)*v20;
      }
      while (*v20);
      if (v17 == (void *)(v14 + 136) || result < v17[4])
      {
LABEL_15:
        int v21 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 16))(a2);
        uint64_t v22 = *(void *)a2;
        if (v21 == 46)
        {
          unint64_t v45 = (*(int (**)(unint64_t))(v22 + 208))(a2);
          BOOL v43 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 304))(a2) == 1;
          int v23 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 408))(a2);
        }
        else
        {
          if ((*(unsigned int (**)(unint64_t))(v22 + 16))(a2) != 44)
          {
            int v41 = 0;
            BOOL v43 = 0;
            unint64_t v45 = 0;
LABEL_21:
            unint64_t v55 = CI::hash_image_node_id(a2, (const CI::Node *)a9);
            v49.__r_.__value_.__r.__words[0] = (std::string::size_type)&v55;
            char v24 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)(v14 + 176), &v55, (uint64_t)&std::piecewise_construct, &v49);
            uint64_t v26 = v24[5];
            uint64_t v25 = v24[6];
            uint64_t v27 = v24[7];
            uint64_t v28 = v24[8];
            long long v29 = v24[10];
            char v42 = v24[9];
            char v44 = *((unsigned char *)v24 + 88);
            if (a6)
            {
              uint64_t v30 = (void *)CI::hash_dag_node_id(a6, a7, 0);
              uint64_t v31 = v14;
              uint64_t v52 = v30;
              v49.__r_.__value_.__r.__words[0] = (std::string::size_type)&v52;
              double v32 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v14 + 104), (unint64_t *)&v52, (uint64_t)&std::piecewise_construct, (uint64_t **)&v49)+ 5;
            }
            else
            {
              uint64_t v31 = v14;
              double v32 = (uint64_t *)(v13 + 40);
            }
            uint64_t v33 = *v32;
            if (v45 < 2)
            {
              uint64_t v37 = operator new(0x20uLL);
              v53 = v37 + 4;
              uint64_t v54 = v37 + 4;
              *uint64_t v37 = v26;
              v37[1] = v25;
              v37[2] = v33;
              v37[3] = v27;
              uint64_t v52 = v37;
              std::string::basic_string[abi:nn180100]<0>(v47, "_ci_read_pixel");
              CI::MetalDAGHelper::TextureReadFunction::TextureReadFunction(&v49, (long long *)v47, (uint64_t)&v52);
              uint64_t v35 = v31;
              uint64_t v46 = v15;
              v56[0] = &v46;
              uint64_t v38 = std::__tree<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v31 + 152, (unint64_t *)&v46, (uint64_t)&std::piecewise_construct, v56);
              CI::DAGHelper::TextureReadFunction::operator=((std::string *)(v38 + 5), &v49);
            }
            else
            {
              unint64_t v34 = operator new(0x38uLL);
              v53 = v34 + 7;
              uint64_t v54 = v34 + 7;
              void *v34 = v26;
              v34[1] = v25;
              v34[2] = v33;
              v34[3] = v27;
              v34[4] = v28;
              v34[5] = v42;
              v34[6] = v29;
              uint64_t v52 = v34;
              if (v43)
              {
                uint64_t v35 = v31;
                if (v41 && (*(unsigned char *)(*(void *)(v31 + 24) + 456) & 1) == 0)
                {
                  std::string::basic_string[abi:nn180100]<0>(v47, "_ci_read_pixel_420_packed");
                  CI::MetalDAGHelper::TextureReadFunction::TextureReadFunction(&v49, (long long *)v47, (uint64_t)&v52);
                  uint64_t v46 = v15;
                  v56[0] = &v46;
                  uint64_t v36 = std::__tree<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v31 + 152, (unint64_t *)&v46, (uint64_t)&std::piecewise_construct, v56);
                  CI::DAGHelper::TextureReadFunction::operator=((std::string *)(v36 + 5), &v49);
                  CI::DAGHelper::TextureReadFunction::~TextureReadFunction((CI::DAGHelper::TextureReadFunction *)&v49);
LABEL_36:
                  if (v48 < 0) {
                    operator delete(v47[0]);
                  }
                  if (v52)
                  {
                    v53 = v52;
                    operator delete(v52);
                  }
                  uint64_t v52 = v15;
                  v49.__r_.__value_.__r.__words[0] = (std::string::size_type)&v52;
                  uint64_t result = (unint64_t)std::__tree<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v35 + 152, (unint64_t *)&v52, (uint64_t)&std::piecewise_construct, &v49);
                  *(unsigned char *)(result + 88) = v44 & 1;
                  return result;
                }
                std::string::basic_string[abi:nn180100]<0>(v47, "_ci_read_pixel_420_r_rg");
                CI::MetalDAGHelper::TextureReadFunction::TextureReadFunction(&v49, (long long *)v47, (uint64_t)&v52);
                uint64_t v46 = v15;
                v56[0] = &v46;
                uint64_t v40 = std::__tree<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v31 + 152, (unint64_t *)&v46, (uint64_t)&std::piecewise_construct, v56);
                CI::DAGHelper::TextureReadFunction::operator=((std::string *)(v40 + 5), &v49);
              }
              else
              {
                std::string::basic_string[abi:nn180100]<0>(v47, "_ci_read_pixel_420");
                uint64_t v35 = v31;
                CI::MetalDAGHelper::TextureReadFunction::TextureReadFunction(&v49, (long long *)v47, (uint64_t)&v52);
                uint64_t v46 = v15;
                v56[0] = &v46;
                int v39 = std::__tree<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v31 + 152, (unint64_t *)&v46, (uint64_t)&std::piecewise_construct, v56);
                CI::DAGHelper::TextureReadFunction::operator=((std::string *)(v39 + 5), &v49);
              }
            }
            if (__p)
            {
              v51 = __p;
              operator delete(__p);
            }
            if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v49.__r_.__value_.__l.__data_);
            }
            goto LABEL_36;
          }
          unint64_t v45 = (*(int (**)(unint64_t))(*(void *)a2 + 208))(a2);
          BOOL v43 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 304))(a2) == 1;
          int v23 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 408))(a2);
        }
        int v41 = v23;
        goto LABEL_21;
      }
    }
  }
  return result;
}

void sub_193675E7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a27) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_3(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a2 + 232))(a2) ^ 1;
}

unint64_t ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_2_45(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  if (a9 != -1)
  {
    uint64_t v12 = *(void *)(result + 32);
    (*(void (**)(void, void))(**(void **)(result + 40) + 48))(*(void *)(result + 40), a9);
    if (a3 && !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a3 + 192))(a3, a5)) {
      unint64_t v13 = 0;
    }
    else {
      unint64_t v13 = (const CI::Node *)(int)a9;
    }
    uint64_t result = CI::hash_image_node_id(a2, v13);
    unint64_t v20 = result;
    uint64_t v14 = *(void **)(v12 + 184);
    if (!v14) {
      goto LABEL_17;
    }
    uint64_t v15 = v12 + 184;
    do
    {
      unint64_t v16 = v14[4];
      BOOL v17 = v16 >= result;
      if (v16 >= result) {
        unint64_t v18 = v14;
      }
      else {
        unint64_t v18 = v14 + 1;
      }
      if (v17) {
        uint64_t v15 = (uint64_t)v14;
      }
      uint64_t v14 = (void *)*v18;
    }
    while (*v18);
    if (v15 == v12 + 184 || result < *(void *)(v15 + 32)) {
LABEL_17:
    }
      CI::MetalDAGHelper::add_arguments_for_image_node(v12, &v19);
  }
  return result;
}

uint64_t ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a2 + 232))(a2) ^ 1;
}

void ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke(void *a1, CI::Object *this, int a3, int a4, int a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  if (a9 == -1)
  {
    uint64_t v14 = a1[5];
    uint64_t v27 = this;
    uint64_t v28 = 0;
    if (this) {
      CI::Object::ref((uint64_t)this);
    }
    uint64_t v15 = (*(uint64_t (**)(CI::Object *, void))(*(void *)this + 320))(this, *(void *)(v14 + 24));
    uint64_t v28 = v15;
    if (v15) {
      unint64_t v16 = (CI::ColorKernelNode *)v15;
    }
    else {
      unint64_t v16 = v27;
    }
    if ((*(unsigned int (**)(CI::ColorKernelNode *))(*(void *)v16 + 16))(v16) == 50)
    {
      BOOL v17 = (const CI::Kernel *)*((void *)v16 + 6);
      if (a6)
      {
        unint64_t v26 = CI::hash_dag_node_id(a6, a7, 0);
        long long v29 = &v26;
        unint64_t v18 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v14 + 104), &v26, (uint64_t)&std::piecewise_construct, (uint64_t **)&v29)+ 5;
      }
      else
      {
        unint64_t v18 = a1 + 6;
      }
      uint64_t v19 = *v18;
      CI::MetalDAGHelper::add_function_for_kernel((CI::MetalDAGHelper *)v14, v17);
      CI::MetalDAGHelper::add_function_info(v14, v20, v16, a1[8], v19, v21, 0);
      unint64_t v22 = CI::hash_dag_node_id((unint64_t)this, a7, a8);
      unint64_t v23 = CI::hash_dag_node_id((unint64_t)this, v22, 0);
      uint64_t v24 = *(void *)(a1[4] + 8);
      uint64_t v25 = *(void *)(v24 + 24);
      *(void *)(v24 + 24) = v25 + 1;
      unint64_t v26 = v23;
      long long v29 = &v26;
      std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v14 + 104), &v26, (uint64_t)&std::piecewise_construct, (uint64_t **)&v29)[5] = v25;
    }
    CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)&v27);
  }
}

void sub_1936762A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)va);
  _Unwind_Resume(a1);
}

uint64_t CI::Node::convert_to_kernel_node()
{
  return 0;
}

uint64_t CI::MetalDAGHelper::color_output_for_kernel(CI::MetalDAGHelper *this, const CI::Kernel *a2, unsigned int a3, unint64_t *a4)
{
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    char v5 = a3;
    if (*((void *)a2 + 16) == 2 && *((void *)a2 + 17) == 2)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      ++*a4;
      uint64_t v12 = &CI::MetalDAGHelper::color_output_for_kernel(CI::Kernel const*,unsigned char,unsigned long &)::sGroupOutputFunctions[(a3 >> 1) & 1];
      do
      {
        CI::MetalDAGHelper::add_function_with_name(this, v12[v10], 0);
        CI::MetalDAGHelper::add_colour_inout_function_info((uint64_t)this);
        unint64_t v13 = (*a4)++;
        uint64_t v14 = (_WORD *)((char *)&v17 + v10);
        if ((v5 & 2) != 0)
        {
          v14[4] = v13;
          uint64_t v15 = (_WORD *)&v17 + v11;
        }
        else
        {
          *uint64_t v14 = v13;
          uint64_t v15 = v14 + 4;
        }
        *uint64_t v15 = 0;
        ++v11;
        v10 += 2;
      }
      while (v10 != 8);
    }
    else
    {
      unint64_t v7 = (*a4)++;
      if ((a3 & 2) != 0)
      {
        LOWORD(v18) = v7;
        int v8 = &v17;
      }
      else
      {
        LOWORD(v17) = v7;
        int v8 = &v18;
      }
      *(_WORD *)int v8 = 0;
    }
  }
  return v17;
}

void *CI::roiKeyVec::roiKeyVec(void *a1, uint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = a3 + 1;
  char v5 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    unint64_t v7 = 0;
    int v8 = a1 + 2;
    do
    {
      int v9 = *((_DWORD *)v5 + 7);
      if ((unint64_t)v7 >= *v8)
      {
        uint64_t v10 = (uint64_t)&v7[-*a1] >> 4;
        if ((unint64_t)(v10 + 1) >> 60) {
          abort();
        }
        uint64_t v11 = *v8 - *a1;
        uint64_t v12 = v11 >> 3;
        if (v11 >> 3 <= (unint64_t)(v10 + 1)) {
          uint64_t v12 = v10 + 1;
        }
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v13 = v12;
        }
        if (v13) {
          uint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)(a1 + 2), v13);
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v15 = &v14[16 * v10];
        *(void *)uint64_t v15 = a2;
        *((_DWORD *)v15 + 2) = v9;
        uint64_t v17 = (char *)*a1;
        unint64_t v16 = (char *)a1[1];
        uint64_t v18 = v15;
        if (v16 != (char *)*a1)
        {
          do
          {
            *((_OWORD *)v18 - 1) = *((_OWORD *)v16 - 1);
            v18 -= 16;
            v16 -= 16;
          }
          while (v16 != v17);
          unint64_t v16 = (char *)*a1;
        }
        unint64_t v7 = v15 + 16;
        *a1 = v18;
        a1[1] = v15 + 16;
        a1[2] = &v14[16 * v13];
        if (v16) {
          operator delete(v16);
        }
      }
      else
      {
        *(void *)unint64_t v7 = a2;
        *((_DWORD *)v7 + 2) = v9;
        v7 += 16;
      }
      a1[1] = v7;
      uint64_t v19 = (void *)v5[1];
      if (v19)
      {
        do
        {
          uint64_t v20 = v19;
          uint64_t v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          uint64_t v20 = (void *)v5[2];
          BOOL v21 = *v20 == (void)v5;
          char v5 = v20;
        }
        while (!v21);
      }
      char v5 = v20;
    }
    while (v20 != v4);
  }
  return a1;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(16 * a2);
}

uint64_t **CI::SerialRectArray::findParentROI@<X0>(uint64_t **result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)a4 = a4 + 8;
  unsigned int v15 = 0;
  uint64_t v6 = *result;
  char v5 = result[1];
  if (v5 != *result)
  {
    int v9 = result;
    int v10 = 0;
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = &v6[15 * v11];
      uint64_t v13 = v12[4];
      uint64_t v14 = v12[5];
      if (v13 != v14)
      {
        do
        {
          if (*(void *)v13 == *(void *)a2
            && *(_DWORD *)(a2 + 16) == *(_DWORD *)(v13 + 16)
            && *(_DWORD *)(a2 + 12) == *(_DWORD *)(v13 + 12)
            && *(_DWORD *)(a2 + 8) == *(_DWORD *)(v13 + 8))
          {
            (*(void (**)(uint64_t, uint64_t, void))(a3 + 16))(a3, v13, v15);
            uint64_t result = std::__tree<int>::__emplace_unique_key_args<int,int const&>((uint64_t **)a4, (int *)&v15, &v15);
          }
          v13 += 48;
        }
        while (v13 != v14);
        int v10 = v15;
        uint64_t v6 = *v9;
        char v5 = v9[1];
      }
      unsigned int v15 = ++v10;
      uint64_t v11 = v10;
    }
    while (0xEEEEEEEEEEEEEEEFLL * (v5 - v6) > v10);
  }
  return result;
}

uint64_t **std::__tree<int>::__emplace_unique_key_args<int,int const&>(uint64_t **a1, int *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  char v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        char v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      char v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v8 = a1 + 1;
LABEL_10:
    int v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void CI::AffineNode::convert_to_kernel_node(CI::AffineNode *this, CI::Context *a2)
{
  long long v2 = *(_OWORD *)((char *)this + 72);
  v3[0] = *(_OWORD *)((char *)this + 56);
  v3[1] = v2;
  v3[2] = *(_OWORD *)((char *)this + 88);
  CI::Affine::inverse((CI::Affine *)v3, (double *)&v4);
  operator new();
}

CI::SerialObjectPtrArray *CI::SerialObjectPtrArray::SerialObjectPtrArray(CI::SerialObjectPtrArray *this, CI::Object *a2, CI::Object *a3, CI::Object *a4)
{
  *(void *)this = 0;
  *((_OWORD *)this + 2) = 0u;
  int v7 = (void *)((char *)this + 32);
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  *(void *)((char *)this + 4) = 0x30000000ALL;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = a2;
  if (a2) {
    CI::Object::ref((uint64_t)a2);
  }
  *int v7 = a3;
  if (a3) {
    CI::Object::ref((uint64_t)a3);
  }
  *((void *)this + 5) = a4;
  if (a4) {
    CI::Object::ref((uint64_t)a4);
  }
  *(_DWORD *)this = 3;
  return this;
}

void CI::WarpKernelNode::WarpKernelNode(CI::Node *a1)
{
}

void CI::NodeWithChild::NodeWithChild(CI::NodeWithChild *this, CI::Node *a2)
{
}

void CI::ColorKernelNode::ColorKernelNode(CI::Node *a1)
{
}

void CI::Node::Node(CI::Node *this)
{
  *((_DWORD *)this + 2) = 1;
  *(void *)this = &unk_1EE45D890;
  operator new();
}

uint64_t CI::ClampToAlphaImage::type(CI::ClampToAlphaImage *this)
{
  return 8;
}

uint64_t CI::SwizzleImage::type(CI::SwizzleImage *this)
{
  return 23;
}

uint64_t CI::SRGBNode::convert_to_kernel_node(CI::SRGBNode *this, CI::Context *a2)
{
  long long v2 = (int *)((char *)this + 56);
  if ((*((_DWORD *)this + 14) + 1) < 3) {
    operator new();
  }
  int v3 = ci_logger_render();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
    CI::SRGBNode::convert_to_kernel_node(v2, v3);
  }
  return 0;
}

uint64_t CI::PremultiplyNode::convert_to_kernel_node(CI::PremultiplyNode *this, CI::Context *a2)
{
  int v3 = (int *)((char *)this + 56);
  int v2 = *((_DWORD *)this + 14);
  if (v2 == 1 || v2 == -1) {
    operator new();
  }
  long long v4 = ci_logger_render();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
    CI::PremultiplyNode::convert_to_kernel_node(v3, v4);
  }
  return 0;
}

__n128 CI::Image::Image(__n128 *this)
{
  this->n128_u32[2] = 1;
  uint64_t v1 = (__n128 *)MEMORY[0x1E4F1DB20];
  this->n128_u64[0] = (unint64_t)&unk_1EE45DAA8;
  __n128 result = v1[1];
  this[1] = *v1;
  this[2] = result;
  this[3].n128_u64[1] = 0;
  this[4].n128_u64[0] = 0;
  this[3].n128_u64[0] = 0;
  this[4].n128_u32[2] = 0;
  this[5].n128_u64[0] = 0;
  this[5].n128_u64[1] = 0;
  this[6].n128_u16[0] = 0;
  this[6].n128_u32[1] = atomic_fetch_add(&CI::gImageCounter, 1u) + 1;
  return result;
}

uint64_t *std::__tree<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v6 = (uint64_t **)(a1 + 8);
  char v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        char v5 = (uint64_t *)*v8;
        uint64_t v6 = (uint64_t **)v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      char v5 = (uint64_t *)v8[1];
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v8 + 1);
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v8 = (uint64_t *)(a1 + 8);
LABEL_10:
    std::__tree<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a1, a4, (uint64_t)v11);
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v8, v6, v11[0]);
    int v8 = v11[0];
    v11[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>>>>::reset[abi:nn180100]((uint64_t)v11, 0);
  }
  return v8;
}

void CI::ClampToAlphaNode::convert_to_kernel_node(CI::ClampToAlphaNode *this, CI::Context *a2)
{
}

uint64_t CI::ColorMatrixImage::type(CI::ColorMatrixImage *this)
{
  return 5;
}

uint64_t **std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (char *)operator new(0x60uLL);
    *((void *)v11 + 4) = **a4;
    *((void *)v11 + 11) = 0;
    *(_OWORD *)(v11 + 72) = 0u;
    *(_OWORD *)(v11 + 56) = 0u;
    *(_OWORD *)(v11 + 40) = 0u;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

BOOL CI::NodeWithChild::child_type_is_image(CI::NodeWithChild *this, int a2)
{
  return a2 == 0;
}

uint64_t CI::hash_image_node_id(uint64_t this, const CI::Node *a2)
{
  if (this)
  {
    if ((int)(-286331153 * ((*(void *)(*(void *)(this + 16) + 8) - **(void **)(this + 16)) >> 3)) <= 1) {
      uint64_t v2 = 0;
    }
    else {
      uint64_t v2 = (void)a2 << 32;
    }
    return v2 | *(unsigned int *)(this + 36);
  }
  return this;
}

void *std::__tree<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, void **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x60uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  v6[4] = **a2;
  __n128 result = std::string::basic_string[abi:nn180100]<0>(v6 + 5, "");
  v6[8] = 0;
  v6[9] = 0;
  *((unsigned char *)v6 + 88) = 0;
  v6[10] = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_193677308(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>>>>::reset[abi:nn180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>>>>::reset[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,CI::DAGHelper::TextureReadFunction>,0>((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t CI::SurfaceNode::output_is_packed(CI **this, __IOSurface *a2)
{
  int v2 = CI::format_from_IOSurface(this[7], a2);

  return CI::format_is_packed(v2);
}

uint64_t CI::SurfaceNode::output_depth(CI **this, __IOSurface *a2)
{
  int v2 = CI::format_from_IOSurface(this[7], a2);
  if (CI::format_is_deep(v2)) {
    return 1;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

std::string *CI::MetalDAGHelper::TextureReadFunction::TextureReadFunction(std::string *this, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  std::vector<unsigned long>::vector(this[1].__r_.__value_.__r.__words, a3);
  this[2].__r_.__value_.__s.__data_[0] = 0;
  return this;
}

void sub_193677434(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::list<CI::attached_surface_t *>::remove(void *a1, void *a2)
{
  v9[0] = (uint64_t)v9;
  v9[1] = (uint64_t)v9;
  uint64_t v10 = 0;
  int v2 = (void *)a1[1];
  if (v2 == a1)
  {
    uint64_t v7 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v6 = (void *)v2[1];
      uint64_t v5 = v2[2];
      if (v5 == *a2) {
        break;
      }
LABEL_8:
      int v2 = v6;
      if (v6 == a1) {
        goto LABEL_11;
      }
    }
    while (v6 != a1)
    {
      if (v6[2] != v5)
      {
        std::list<CI::attached_surface_t *>::splice((uint64_t)v9, v9, (uint64_t)a1, v2, v6);
        uint64_t v6 = (void *)v6[1];
        goto LABEL_8;
      }
      uint64_t v6 = (void *)v6[1];
    }
    std::list<CI::attached_surface_t *>::splice((uint64_t)v9, v9, (uint64_t)a1, v2, a1);
LABEL_11:
    uint64_t v7 = v10;
  }
  std::__list_imp<CI::attached_surface_t *>::clear(v9);
  return v7;
}

void *std::__list_imp<CI::attached_surface_t *>::clear(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    __n128 result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        long long v4 = (void *)result[1];
        operator delete(result);
        __n128 result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

void sub_193677B94(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40AA91B0B9);
  _Unwind_Resume(a1);
}

BOOL ___ZN2CI14MetalDAGHelper15analyze_kernelsEPKNS_11ProgramNodeEPU19objcproto9MTLDevice11objc_object_block_invoke(uint64_t a1, CI::Object *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a6 == -1)
  {
    uint64_t v10 = *(void *)(a1 + 104);
    uint64_t v24 = this;
    uint64_t v25 = 0;
    if (this) {
      CI::Object::ref((uint64_t)this);
    }
    uint64_t v11 = (*(uint64_t (**)(CI::Object *, void))(*(void *)this + 320))(this, *(void *)(v10 + 24));
    uint64_t v25 = v11;
    if (v11) {
      uint64_t v13 = (CI *)v11;
    }
    else {
      uint64_t v13 = v24;
    }
    if (!a3
      && (*(unsigned int (**)(CI::Object *))(*(void *)this + 16))(this) == 51
      && (HIDWORD(*((void *)this + 17)) && *((void *)this + 17) && *((_DWORD *)this + 36)
       || HIDWORD(*(void *)((char *)this + 148))
       && *(void *)((char *)this + 148)
       && *((_DWORD *)this + 39)))
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    }
    uint64_t v15 = CI::kernel_for_node(v13, v12);
    if (v15)
    {
      if ((CI::is_kernel_metalstitchable_linkable(*(CI **)(v10 + 24), (const CI::MetalContext *)v15, v14) & 1) == 0) {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
      }
      if ((CI::is_kernel_metalextern_linkable(*(CI **)(v10 + 24), (const CI::MetalContext *)v15, v16) & 1) == 0) {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0;
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 16))(v15) == 62 && *(unsigned char *)(v15 + 176)) {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 1;
      }
      if ((*(uint64_t (**)(uint64_t))(*(void *)v15 + 72))(v15) && !*(void *)(v15 + 32)) {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 1;
      }
      if ((*(uint64_t (**)(uint64_t))(*(void *)v15 + 72))(v15))
      {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = 0;
        if (CI_HARVESTING_SPECIFIC_LIBRARY_LIST())
        {
          uint64_t v17 = (NSString *)[NSString stringWithCString:CI_HARVESTING_SPECIFIC_LIBRARY_LIST() encoding:1];
          uint64_t v18 = (id *)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 72))(v15);
          if (CI::MetalKernel::isFromLibrary(v18, v17)) {
            *(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = 1;
          }
        }
      }
      uint64_t v19 = *(void *)(*(void *)(a1 + 96) + 8);
      unint64_t v20 = *(void *)(v19 + 48);
      if (v20 <= *(void *)(v15 + 128)) {
        unint64_t v20 = *(void *)(v15 + 128);
      }
      *(void *)(v19 + 48) = v20;
      uint64_t v21 = *(void *)(*(void *)(a1 + 96) + 8);
      unint64_t v22 = *(void *)(v21 + 56);
      if (v22 <= *(void *)(v15 + 136)) {
        unint64_t v22 = *(void *)(v15 + 136);
      }
      *(void *)(v21 + 56) = v22;
    }
    CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)&v24);
  }
  else
  {
    uint64_t v7 = (unsigned char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 112) + 48))(*(void *)(a1 + 112), a6);
    if (*(unsigned int (**)(unsigned char *))(*(void *)v7 + 16))(v7) == 52 && (v7[144]) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    }
  }
  return !*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)
      && *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) == 0;
}

void sub_193677F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t CI::Kernel::metal_kernel(CI::Kernel *this)
{
  return 0;
}

void CI::ConvertedNodeRAII::~ConvertedNodeRAII(CI::ConvertedNodeRAII *this)
{
  uint64_t v2 = (CI::Object *)*((void *)this + 1);
  if (v2) {
    CI::Object::unref(v2);
  }
  if (*(void *)this) {
    CI::Object::unref(*(CI::Object **)this);
  }
}

uint64_t CI::ColorKernel::type(CI::ColorKernel *this)
{
  return 62;
}

void CI::SerialObjectPtrArray::~SerialObjectPtrArray(CI::SerialObjectPtrArray *this)
{
  int v2 = *(_DWORD *)this;
  if (*(int *)this >= 1)
  {
    unint64_t v3 = 0;
    long long v4 = (CI::Object **)((char *)this + 24);
    do
    {
      uint64_t v5 = v4;
      if (v3 >= 0xA) {
        uint64_t v5 = (CI::Object **)(*((void *)this + 2) + 8 * (v3 - 10));
      }
      if (*v5)
      {
        CI::Object::unref(*v5);
        int v2 = *(_DWORD *)this;
      }
      ++v3;
      ++v4;
    }
    while ((uint64_t)v3 < v2);
  }
  uint64_t v6 = (void *)*((void *)this + 2);
  if (v6) {
    free(v6);
  }
}

void CI::Object::unref(CI::Object *this)
{
  atomic_load((unsigned int *)this + 2);
  if (atomic_fetch_add((atomic_uint *volatile)this + 2, 0xFFFFFFFF) == 1)
  {
    v1[0] = MEMORY[0x1E4F143A8];
    v1[1] = 0x40000000;
    v1[2] = ___ZNK2CI6Object5unrefEv_block_invoke;
    v1[3] = &__block_descriptor_tmp_4_3;
    v1[4] = this;
    CI::Object::performDeferred(v1);
  }
}

void CI::Object::performDeferred(void *a1)
{
  specific = dispatch_get_specific(&CI::Object::_queueKey);
  unint64_t v3 = dispatch_get_specific(&CI::Object::_groupKey);
  if (specific) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    uint64_t v5 = (void (*)(void *))a1[2];
    v5(a1);
  }
  else
  {
    dispatch_group_async(v3, specific, a1);
  }
}

uint64_t ___ZNK2CI6Object5unrefEv_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CI::Vector::~Vector(CI::Vector *this)
{
  *((void *)this + 2) = &unk_1EE45B0E8;
  atomic_fetch_add(dword_1EB466F58, 0xFFFFFFFF);
  JUMPOUT(0x1997023B0);
}

{
  *((void *)this + 2) = &unk_1EE45B0E8;
  atomic_fetch_add(dword_1EB466F58, 0xFFFFFFFF);
}

uint64_t CI::kernel_for_node(CI *this, const CI::Node *a2)
{
  if ((*(unsigned int (**)(CI *, const CI::Node *))(*(void *)this + 16))(this, a2) == 49
    || (*(unsigned int (**)(CI *))(*(void *)this + 16))(this) == 50
    || (*(unsigned int (**)(CI *))(*(void *)this + 16))(this) == 51)
  {
    return *((void *)this + 6);
  }
  else
  {
    return 0;
  }
}

uint64_t CI::is_kernel_metalstitchable_linkable(CI *this, const CI::MetalContext *a2, const CI::Kernel *a3)
{
  uint64_t result = 0;
  if (this && a2)
  {
    uint64_t v6 = *((void *)this + 242);
    if (v6
      && (uint64_t v7 = *((void *)a2 + 3),
          dispatch_sync(*(dispatch_queue_t *)(v6 + 56), &__block_literal_global_167_0),
          (objc_msgSend(*(id *)(v6 + 40), "containsObject:", objc_msgSend(NSString, "stringWithUTF8String:", v7)) & 1) != 0))
    {
      return 1;
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(const CI::MetalContext *))(*(void *)a2 + 72))(a2);
      if (result) {
        return *(unsigned char *)((*(uint64_t (**)(const CI::MetalContext *))(*(void *)a2 + 72))(a2) + 48) != 0;
      }
    }
  }
  return result;
}

uint64_t CI::is_kernel_metalextern_linkable(CI *this, const CI::MetalContext *a2, const CI::Kernel *a3)
{
  uint64_t result = 0;
  if (this && a2)
  {
    uint64_t v6 = *((void *)this + 241);
    if (v6
      && (uint64_t v7 = *((void *)a2 + 3),
          dispatch_sync(*(dispatch_queue_t *)(v6 + 56), &__block_literal_global_167_0),
          (objc_msgSend(*(id *)(v6 + 40), "containsObject:", objc_msgSend(NSString, "stringWithUTF8String:", v7)) & 1) != 0))
    {
      return 1;
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(const CI::MetalContext *))(*(void *)a2 + 72))(a2);
      if (result) {
        return *(unsigned char *)((*(uint64_t (**)(const CI::MetalContext *))(*(void *)a2 + 72))(a2) + 48) == 0;
      }
    }
  }
  return result;
}

void CI::ColorKernelNode::~ColorKernelNode(CI::ColorKernelNode *this)
{
  CI::ColorKernelNode::~ColorKernelNode(this);

  JUMPOUT(0x1997023B0);
}

{
  CI::Object *v2;
  CI::SerialObjectPtrArray *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EE45A4C0;
  *((void *)this + 5) = &unk_1EE45A668;
  int v2 = (CI::Object *)*((void *)this + 6);
  if (v2 && *((unsigned char *)v2 + 12)) {
    CI::Object::unref(v2);
  }
  *((void *)this + 6) = 0;
  unint64_t v3 = (CI::SerialObjectPtrArray *)*((void *)this + 7);
  if (v3)
  {
    CI::SerialObjectPtrArray::~SerialObjectPtrArray(v3);
    MEMORY[0x1997023B0]();
  }
  *((void *)this + 7) = 0;
  _Block_release(*((const void **)this + 12));
  *((void *)this + 12) = 0;
  *((void *)this + 5) = &unk_1EE45AFA8;
  atomic_fetch_add(&dword_1EB466E78[47], 0xFFFFFFFF);

  CI::Node::~Node(this);
}

void CI::Node::~Node(CI::Node *this)
{
  *(void *)this = &unk_1EE45D890;
  uint64_t v1 = *((void *)this + 2);
  if (v1)
  {
    int v2 = (void **)*((void *)this + 2);
    std::vector<CI::SerialRectArray::roiData>::__destroy_vector::operator()[abi:nn180100](&v2);
    MEMORY[0x1997023B0](v1, 0x20C40960023A9);
  }
}

void std::vector<CI::SerialRectArray::roiData>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    BOOL v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 15;
        std::__destroy_at[abi:nn180100]<CI::SerialRectArray::roiData,0>(v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

__CFString *classNameFromTypeEncoding(__CFString *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = (__CFString *)[(__CFString *)result length];
    if (result)
    {
      int v2 = result;
      int v3 = [(__CFString *)v1 characterAtIndex:0];
      if ((unint64_t)v2 >= 4 && v3 == 64)
      {
        return (__CFString *)-[__CFString substringWithRange:](v1, "substringWithRange:", 2, (char *)&v2[-1].length + 5);
      }
      else if (v2 == (__CFString *)1 && ([@"iIsSlLqQBfdcC" containsString:v1] & 1) != 0)
      {
        return @"__WrappedNSNumber";
      }
      else if ([(__CFString *)v1 isEqualToString:@"@"])
      {
        return @"NSObject";
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t getStdAttrsForKey(NSString *a1)
{
  v20[6] = *MEMORY[0x1E4F143B8];
  if ([(NSString *)a1 isEqualToString:@"inputIntensity"])
  {
    v19[0] = @"CIAttributeMin";
    v19[1] = @"CIAttributeSliderMin";
    v20[0] = &unk_1EE4A8B70;
    v20[1] = &unk_1EE4A8B70;
    v19[2] = @"CIAttributeSliderMax";
    v19[3] = @"CIAttributeDefault";
    v20[2] = &unk_1EE4A8B80;
    v20[3] = &unk_1EE4A8B80;
    v19[4] = @"CIAttributeIdentity";
    v19[5] = @"CIAttributeType";
    v20[4] = &unk_1EE4A8B70;
    v20[5] = @"CIAttributeTypeScalar";
    int v2 = (void *)MEMORY[0x1E4F1C9E8];
    int v3 = (__CFString **)v20;
    BOOL v4 = (__CFString **)v19;
    uint64_t v5 = 6;
    return [v2 dictionaryWithObjects:v3 forKeys:v4 count:v5];
  }
  if ([(NSString *)a1 isEqualToString:@"inputTime"])
  {
    v17[0] = @"CIAttributeMin";
    v17[1] = @"CIAttributeMax";
    v18[0] = &unk_1EE4A8B70;
    v18[1] = &unk_1EE4A8B80;
    v17[2] = @"CIAttributeSliderMin";
    v17[3] = @"CIAttributeSliderMax";
    v18[2] = &unk_1EE4A8B70;
    v18[3] = &unk_1EE4A8B80;
    v17[4] = @"CIAttributeDefault";
    v17[5] = @"CIAttributeIdentity";
    v18[4] = &unk_1EE4A8B70;
    v18[5] = &unk_1EE4A8B70;
    v17[6] = @"CIAttributeType";
    v18[6] = @"CIAttributeTypeTime";
    int v2 = (void *)MEMORY[0x1E4F1C9E8];
    int v3 = (__CFString **)v18;
    BOOL v4 = (__CFString **)v17;
    uint64_t v5 = 7;
    return [v2 dictionaryWithObjects:v3 forKeys:v4 count:v5];
  }
  if ([(NSString *)a1 isEqualToString:@"inputAngle"])
  {
    v15[0] = @"CIAttributeSliderMin";
    v15[1] = @"CIAttributeSliderMax";
    v16[0] = &unk_1EE4A8B90;
    v16[1] = &unk_1EE4A8BA0;
    v15[2] = @"CIAttributeDefault";
    v15[3] = @"CIAttributeIdentity";
    v16[2] = &unk_1EE4A8B70;
    v16[3] = &unk_1EE4A8B70;
    v15[4] = @"CIAttributeType";
    v16[4] = @"CIAttributeTypeAngle";
    int v2 = (void *)MEMORY[0x1E4F1C9E8];
    int v3 = (__CFString **)v16;
    BOOL v4 = (__CFString **)v15;
    uint64_t v5 = 5;
    return [v2 dictionaryWithObjects:v3 forKeys:v4 count:v5];
  }
  if ([(NSString *)a1 isEqualToString:@"inputImage"]
    || [(NSString *)a1 isEqualToString:@"inputMaskImage"]
    || [(NSString *)a1 isEqualToString:@"inputBackgroundImage"]
    || [(NSString *)a1 isEqualToString:@"inputShadingImage"]
    || [(NSString *)a1 isEqualToString:@"inputTargetImage"])
  {
    uint64_t v13 = @"CIAttributeType";
    uint64_t v14 = @"CIAttributeTypeImage";
    int v2 = (void *)MEMORY[0x1E4F1C9E8];
    int v3 = &v14;
    BOOL v4 = &v13;
LABEL_13:
    uint64_t v5 = 1;
    return [v2 dictionaryWithObjects:v3 forKeys:v4 count:v5];
  }
  if ([(NSString *)a1 isEqualToString:@"inputGradientImage"])
  {
    uint64_t v11 = @"CIAttributeType";
    uint64_t v12 = @"CIAttributeTypeGradient";
    int v2 = (void *)MEMORY[0x1E4F1C9E8];
    int v3 = &v12;
    BOOL v4 = &v11;
    goto LABEL_13;
  }
  if ([(NSString *)a1 isEqualToString:@"inputCenter"])
  {
    v9[0] = @"CIAttributeDefault";
    v9[1] = @"CIAttributeType";
    v10[0] = +[CIVector vectorWithX:150.0 Y:150.0];
    v10[1] = @"CIAttributeTypePosition";
    int v2 = (void *)MEMORY[0x1E4F1C9E8];
    int v3 = (__CFString **)v10;
    BOOL v4 = (__CFString **)v9;
  }
  else
  {
    if (![(NSString *)a1 isEqualToString:@"inputExtent"]) {
      return 0;
    }
    v7[0] = @"CIAttributeDefault";
    v7[1] = @"CIAttributeType";
    v8[0] = +[CIVector vectorWithX:0.0 Y:0.0 Z:640.0 W:80.0];
    v8[1] = @"CIAttributeTypeRectangle";
    int v2 = (void *)MEMORY[0x1E4F1C9E8];
    int v3 = (__CFString **)v8;
    BOOL v4 = (__CFString **)v7;
  }
  uint64_t v5 = 2;
  return [v2 dictionaryWithObjects:v3 forKeys:v4 count:v5];
}

NSUInteger mergeDictionaries(NSUInteger result, NSDictionary *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    if (a2)
    {
      int v3 = (void *)result;
      long long v15 = 0u;
      long long v16 = 0u;
      long long v13 = 0u;
      long long v14 = 0u;
      uint64_t result = [(NSDictionary *)a2 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (result)
      {
        NSUInteger v4 = result;
        uint64_t v5 = *(void *)v14;
        do
        {
          uint64_t v6 = 0;
          do
          {
            if (*(void *)v14 != v5) {
              objc_enumerationMutation(a2);
            }
            uint64_t v7 = *(void **)(*((void *)&v13 + 1) + 8 * v6);
            if (([v7 isEqualToString:kCIConstructorKey] & 1) == 0)
            {
              uint64_t v8 = [v3 objectForKey:v7];
              id v9 = [(NSDictionary *)a2 objectForKey:v7];
              objc_opt_class();
              if (objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass()))
              {
                uint64_t v10 = (void *)[MEMORY[0x1E4F1CA60] dictionaryWithDictionary:v8];
                [v10 addEntriesFromDictionary:v9];
                uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithDictionary:v10];
                uint64_t v12 = v3;
              }
              else
              {
                if (!v9) {
                  goto LABEL_15;
                }
                uint64_t v12 = v3;
                uint64_t v11 = (uint64_t)v9;
              }
              [v12 setObject:v11 forKey:v7];
            }
LABEL_15:
            ++v6;
          }
          while (v4 != v6);
          uint64_t result = [(NSDictionary *)a2 countByEnumeratingWithState:&v13 objects:v17 count:16];
          NSUInteger v4 = result;
        }
        while (result);
      }
    }
  }
  return result;
}

uint64_t CI::WarpKernelNode::type(CI::WarpKernelNode *this)
{
  return 50;
}

uint64_t verify_argument_type(void *a1, int a2, int a3)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    unint64_t v6 = [a1 count];
  }
  else {
    unint64_t v6 = 0;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v7 = [a1 count];
  }
  else {
    uint64_t v7 = 0;
  }
  char isKindOfClass = 0;
  switch(a2)
  {
    case 1:
    case 2:
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        goto LABEL_50;
      }
      goto LABEL_45;
    case 4:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_48;
      }
      uint64_t v15 = [a1 _internalRepresentation];
      unsigned int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 16))(v15);
      if ((CI::is_raster_TypeImage(v16) & 1) == 0) {
        goto LABEL_48;
      }
      goto LABEL_50;
    case 5:
    case 12:
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass() | (v6 == 1);
      return isKindOfClass & 1;
    case 6:
    case 13:
      BOOL v9 = v6 > 1;
      goto LABEL_42;
    case 7:
    case 14:
      BOOL v9 = v6 > 2;
LABEL_42:
      char isKindOfClass = v9;
      return isKindOfClass & 1;
    case 8:
    case 15:
      if (v6 - 3 < 2) {
        goto LABEL_50;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        goto LABEL_50;
      }
      if (a3)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          [a1 extent];
          if (fabs(v10 * v11 + -1.0) < 1.0e-10) {
            goto LABEL_50;
          }
        }
      }
      goto LABEL_48;
    case 9:
    case 16:
      BOOL v12 = v6 == 4;
      goto LABEL_23;
    case 10:
    case 17:
      BOOL v12 = v6 == 9 || v6 == 6;
      goto LABEL_23;
    case 11:
    case 18:
      BOOL v12 = v6 == 16;
LABEL_23:
      char isKindOfClass = v12;
      return isKindOfClass & 1;
    case 19:
    case 23:
    case 28:
    case 29:
      goto LABEL_45;
    case 20:
    case 24:
      if (v7 == 2)
      {
        [a1 objectAtIndex:0];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          char isKindOfClass = 1;
          [a1 objectAtIndex:1];
          objc_opt_class();
          if (objc_opt_isKindOfClass()) {
            return isKindOfClass & 1;
          }
        }
      }
      goto LABEL_48;
    case 21:
    case 25:
      if (v7 != 3) {
        goto LABEL_48;
      }
      [a1 objectAtIndex:0];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_48;
      }
      [a1 objectAtIndex:1];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_48;
      }
      long long v13 = a1;
      uint64_t v14 = 2;
      goto LABEL_39;
    case 22:
    case 26:
      if (v7 != 4) {
        goto LABEL_48;
      }
      [a1 objectAtIndex:0];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_48;
      }
      [a1 objectAtIndex:1];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_48;
      }
      [a1 objectAtIndex:2];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        goto LABEL_48;
      }
      long long v13 = a1;
      uint64_t v14 = 3;
LABEL_39:
      [v13 objectAtIndex:v14];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
LABEL_50:
      }
        char isKindOfClass = 1;
      else {
LABEL_48:
      }
        char isKindOfClass = 0;
      break;
    case 27:
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        goto LABEL_50;
      }
LABEL_45:
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();
      break;
    default:
      return isKindOfClass & 1;
  }
  return isKindOfClass & 1;
}

uint64_t object_for_argument(void *a1, int a2)
{
  uint64_t v2 = 0;
  switch(a2)
  {
    case 1:
    case 2:
    case 4:
      uint64_t v2 = [a1 _internalRepresentation];
      CI::Object::ref(v2);
      return v2;
    case 5:
    case 12:
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        operator new();
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        operator new();
      }
      goto LABEL_38;
    case 6:
    case 13:
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        operator new();
      }
      goto LABEL_38;
    case 7:
    case 14:
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        operator new();
      }
      goto LABEL_38;
    case 8:
    case 15:
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        operator new();
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        operator new();
      }
      goto LABEL_38;
    case 9:
    case 16:
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        operator new();
      }
      goto LABEL_38;
    case 10:
    case 11:
    case 17:
    case 18:
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        [a1 count];
        operator new();
      }
      goto LABEL_38;
    case 19:
    case 23:
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        operator new();
      }
      goto LABEL_38;
    case 20:
    case 24:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0 && [a1 count] == 2) {
        operator new();
      }
      goto LABEL_38;
    case 21:
    case 25:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0 && [a1 count] == 3) {
        operator new();
      }
      goto LABEL_38;
    case 22:
    case 26:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0 && [a1 count] == 4) {
        operator new();
      }
      goto LABEL_38;
    case 27:
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        if ((unint64_t)[a1 count] >= 4) {
          [a1 W];
        }
        operator new();
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        operator new();
      }
      goto LABEL_38;
    case 28:
    case 29:
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        operator new();
      }
LABEL_38:
      uint64_t v2 = 0;
      break;
    default:
      return v2;
  }
  return v2;
}

void sub_19367A4B4(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10A1C405FB94D4BLL);
  _Unwind_Resume(a1);
}

NSUInteger getCustomAttributes(objc_class *a1)
{
  if (![(objc_class *)a1 isSubclassOfClass:objc_opt_class()]) {
    return 0;
  }
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x3052000000;
  unsigned int v16 = __Block_byref_object_copy__8;
  uint64_t v17 = __Block_byref_object_dispose__8;
  uint64_t v18 = 0;
  uint64_t v2 = filterRegistryIsolationQueue();
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZL19getCustomAttributesP10objc_class_block_invoke;
  block[3] = &unk_1E5771C38;
  block[4] = a1;
  block[5] = &v13;
  dispatch_sync(v2, block);
  SEL v3 = NSSelectorFromString(&cfstr_Customattribut.isa);
  uint64_t v4 = [(objc_class *)a1 methodForSelector:v3];
  uint64_t v5 = +[CIFilter methodForSelector:v3];
  uint64_t v6 = [(objc_class *)a1 instanceMethodForSelector:v3];
  uint64_t v7 = +[CIFilter instanceMethodForSelector:v3];
  if (v4 == v5)
  {
    if (v6 != v7)
    {
      double v10 = NSStringFromClass(a1);
      NSLog(&cfstr_Customattribut_0.isa, v10);
    }
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = (NSDictionary *)[(objc_class *)a1 customAttributes];
  }
  NSUInteger v9 = [MEMORY[0x1E4F1CA60] dictionary];
  mergeDictionaries(v9, v8);
  mergeDictionaries(v9, (NSDictionary *)v14[5]);

  _Block_object_dispose(&v13, 8);
  return v9;
}

void sub_19367A704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19367A8E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t filterRegistryIsolationQueue(void)
{
  unint64_t v0 = 0x1EB466000uLL;
  {
    unint64_t v0 = 0x1EB466000;
    if (v2)
    {
      SEL v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      filterRegistryIsolationQueue(void)::isolationQueue = (uint64_t)dispatch_queue_create("com.apple.coreimage.CIFilterRegistryIsolation", v3);
      unint64_t v0 = 0x1EB466000;
    }
  }
  return *(void *)(v0 + 3448);
}

uint64_t CI::WarpKernel::type(CI::WarpKernel *this)
{
  return 63;
}

void CI::WarpKernelNode::~WarpKernelNode(CI::WarpKernelNode *this)
{
  CI::WarpKernelNode::~WarpKernelNode(this);

  JUMPOUT(0x1997023B0);
}

{
  CI::Object *v2;
  CI::SerialObjectPtrArray *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EE45A2F0;
  *((void *)this + 5) = &unk_1EE45A498;
  int v2 = (CI::Object *)*((void *)this + 6);
  if (v2 && *((unsigned char *)v2 + 12)) {
    CI::Object::unref(v2);
  }
  *((void *)this + 6) = 0;
  SEL v3 = (CI::SerialObjectPtrArray *)*((void *)this + 7);
  if (v3)
  {
    CI::SerialObjectPtrArray::~SerialObjectPtrArray(v3);
    MEMORY[0x1997023B0]();
  }
  *((void *)this + 7) = 0;
  _Block_release(*((const void **)this + 12));
  *((void *)this + 12) = 0;
  *((void *)this + 5) = &unk_1EE45AFF8;
  atomic_fetch_add(&dword_1EB466E78[48], 0xFFFFFFFF);

  CI::Node::~Node(this);
}

CI::SerialObjectPtrArray *CI::SerialObjectPtrArray::SerialObjectPtrArray(CI::SerialObjectPtrArray *this, int a2)
{
  *((_DWORD *)this + 2) = 0;
  *(void *)this = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  if (a2 > 10)
  {
    *((_DWORD *)this + 1) = a2;
    uint64_t v4 = malloc_type_calloc((a2 - 10), 8uLL, 0x80040B8603338uLL);
  }
  else
  {
    uint64_t v4 = 0;
    *((_DWORD *)this + 1) = 10;
  }
  *((void *)this + 2) = v4;
  if (a2 <= 1) {
    int v5 = 1;
  }
  else {
    int v5 = a2;
  }
  *((_DWORD *)this + 2) = v5;
  return this;
}

__n64 CI::Vector::Vector(CI::Vector *this, __n64 result, float a3)
{
  *(void *)this = &unk_1EE45DF30;
  *((_DWORD *)this + 2) = 1;
  *((void *)this + 2) = &unk_1EE45B0E8;
  atomic_fetch_add(dword_1EB466F58, 1u);
  *(void *)this = &unk_1EE45DF68;
  *((void *)this + 2) = &unk_1EE45DFA0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *((_DWORD *)this + 6) = 2;
  *((_DWORD *)this + 7) = result.n64_u32[0];
  *((float *)this + 8) = a3;
  result.n64_f32[1] = a3;
  *((__n64 *)this + 12) = result;
  return result;
}

uint64_t CI::Kernel::num_apply_arguments(CI::Kernel *this)
{
  if (*((unsigned char *)this + 12)) {
    int v2 = CI::KernelArguments::count((CI::Kernel *)((char *)this + 144));
  }
  else {
    int v2 = *((_DWORD *)this + 5);
  }
  if (v2 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = v2;
    while (1)
    {
      if (*((unsigned char *)this + 12))
      {
        int type = CI::KernelArguments::get_type((CI::Kernel *)((char *)this + 144), v3);
      }
      else
      {
        if (v3 >= *((int *)this + 5)) {
          goto LABEL_11;
        }
        int type = *(_DWORD *)(*((void *)this + 9) + 4 * v3);
      }
      if (type <= 29) {
LABEL_11:
      }
        uint64_t v4 = (v4 + 1);
      if (v5 == ++v3) {
        return v4;
      }
    }
  }
  return 0;
}

float32x2_t *CI::Color::Color(float32x2_t *this, CGColorRef color)
{
  *this = (float32x2_t)&unk_1EE45DF30;
  this[1].i32[0] = 1;
  this[2] = (float32x2_t)&unk_1EE45B110;
  atomic_fetch_add(&dword_1EB466F58[1], 1u);
  *this = (float32x2_t)&unk_1EE45DA38;
  this[2] = (float32x2_t)&unk_1EE45DA80;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  if (color)
  {
    ColorSpace = CGColorGetColorSpace(color);
    CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
    Components = (float64x2_t *)CGColorGetComponents(color);
    if (Model == kCGColorSpaceModelRGB)
    {
      this[3] = vcvt_f32_f64(*Components);
      float32_t v9 = Components[1].f64[0];
      this[4].f32[0] = v9;
      uint64_t v8 = 3;
      goto LABEL_6;
    }
    if (Model == kCGColorSpaceModelMonochrome)
    {
      float32_t v7 = Components->f64[0];
      this[3].f32[1] = v7;
      this[4].f32[0] = v7;
      this[3].f32[0] = v7;
      uint64_t v8 = 1;
LABEL_6:
      float32_t v10 = Components->f64[v8];
      this[4].f32[1] = v10;
      this[5] = (float32x2_t)CGColorSpaceRetain(ColorSpace);
    }
  }
  return this;
}

uint64_t CI::Vector::Vector(uint64_t this, float a2)
{
  *(void *)this = &unk_1EE45DF30;
  *(_DWORD *)(this + 8) = 1;
  *(void *)(this + 16) = &unk_1EE45B0E8;
  atomic_fetch_add(dword_1EB466F58, 1u);
  *(void *)this = &unk_1EE45DF68;
  *(void *)(this + 16) = &unk_1EE45DFA0;
  *(void *)(this + 96) = 0;
  *(_OWORD *)(this + 32) = 0u;
  *(_OWORD *)(this + 48) = 0u;
  *(_OWORD *)(this + 64) = 0u;
  *(_OWORD *)(this + 76) = 0u;
  *(_DWORD *)(this + 24) = 1;
  *(float *)(this + 28) = a2;
  return this;
}

void CI::ColorMatrixNode::~ColorMatrixNode(CI::ColorMatrixNode *this)
{
  *((void *)this + 6) = &unk_1EE45AD50;
  atomic_fetch_add(&dword_1EB466E78[31], 0xFFFFFFFF);
  CI::NodeWithChild::~NodeWithChild(this);

  JUMPOUT(0x1997023B0);
}

{
  *((void *)this + 6) = &unk_1EE45AD50;
  atomic_fetch_add(&dword_1EB466E78[31], 0xFFFFFFFF);
  CI::NodeWithChild::~NodeWithChild(this);
}

void CI::NodeWithChild::~NodeWithChild(CI::NodeWithChild *this)
{
  *(void *)this = &unk_1EE459288;
  int v2 = (CI::Object *)*((void *)this + 5);
  if (v2) {
    CI::Object::unref(v2);
  }
  *((void *)this + 5) = 0;

  CI::Node::~Node(this);
}

void CI::SwizzleImage::~SwizzleImage(CI::SwizzleImage *this)
{
  *(void *)this = &unk_1EE458C60;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 14) = &unk_1EE45ABE8;
  atomic_fetch_add(&dword_1EB466E78[21], 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);

  JUMPOUT(0x1997023B0);
}

{
  *(void *)this = &unk_1EE458C60;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 14) = &unk_1EE45ABE8;
  atomic_fetch_add(&dword_1EB466E78[21], 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);
}

void CI::Color::~Color(CI::Color *this)
{
  *(void *)this = &unk_1EE45DA38;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = &unk_1EE45DA80;
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 5));
  *((void *)this + 5) = 0;
  *((void *)this + 2) = &unk_1EE45B110;
  atomic_fetch_add(&dword_1EB466F58[1], 0xFFFFFFFF);

  JUMPOUT(0x1997023B0);
}

{
  *(void *)this = &unk_1EE45DA38;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = &unk_1EE45DA80;
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 5));
  *((void *)this + 5) = 0;
  *((void *)this + 2) = &unk_1EE45B110;
  atomic_fetch_add(&dword_1EB466F58[1], 0xFFFFFFFF);
}

void CI::ClampToAlphaImage::~ClampToAlphaImage(CI::ClampToAlphaImage *this)
{
  *((void *)this + 14) = &unk_1EE45B2A0;
  atomic_fetch_add(&dword_1EB466E78[6], 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);

  JUMPOUT(0x1997023B0);
}

{
  *((void *)this + 14) = &unk_1EE45B2A0;
  atomic_fetch_add(&dword_1EB466E78[6], 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);
}

void CI::ColorMatrixImage::~ColorMatrixImage(CI::ColorMatrixImage *this)
{
  *((void *)this + 14) = &unk_1EE45B138;
  atomic_fetch_add(&dword_1EB466E78[3], 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);

  JUMPOUT(0x1997023B0);
}

{
  *((void *)this + 14) = &unk_1EE45B138;
  atomic_fetch_add(&dword_1EB466E78[3], 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);
}

void CI::CropImage::~CropImage(CI::CropImage *this)
{
  *((void *)this + 14) = &unk_1EE45B188;
  atomic_fetch_add(&dword_1EB466E78[4], 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);

  JUMPOUT(0x1997023B0);
}

{
  *((void *)this + 14) = &unk_1EE45B188;
  atomic_fetch_add(&dword_1EB466E78[4], 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);
}

uint64_t classNameIsSystemFilter(NSString *a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  char v7 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZL23classNameIsSystemFilterP8NSString_block_invoke;
  _OWORD v3[3] = &unk_1E5771C88;
  v3[4] = a1;
  v3[5] = &v4;
  register_more_builtins((uint64_t)v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_19367BECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CI::tile_node_graph(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, CGRect *a6)
{
  if (a1)
  {
    if (a4)
    {
      if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 248))(a1))
      {
        v13.origin.CGFloat x = (*(double (**)(uint64_t))(*(void *)a4 + 160))(a4);
        CGRect v14 = CGRectInset(v13, 0.00100000005, 0.00100000005);
        CGRect v17 = CGRectIntegral(v14);
        CGRect v15 = CGRectIntersection(*a6, v17);
        CGFloat x = v15.origin.x;
        CGFloat y = v15.origin.y;
        CGFloat width = v15.size.width;
        CGFloat height = v15.size.height;
        CGRect v12 = v15;
        if (CGRectIsEmpty(v15)) {
          operator new();
        }
        v16.origin.CGFloat x = x;
        v16.origin.CGFloat y = y;
        v16.size.CGFloat width = width;
        v16.size.CGFloat height = height;
        CGRectIsInfinite(v16);
        operator new();
      }
      operator new();
    }
    operator new();
  }
  operator new();
}

uint64_t CI::Context::abortflag(CI::Context *this)
{
  return *((unsigned __int8 *)this + 44);
}

unint64_t CI::programNodeMemoryLoad(CI *this, CGFloat *a2, const CGRect *a3, const CGRect *a4, unint64_t a5, int a6)
{
  double width = a3->size.width;
  double height = a3->size.height;
  if (width <= height) {
    double v8 = a3->size.height;
  }
  else {
    double v8 = a3->size.width;
  }
  double v9 = (double)(unint64_t)a4;
  if (v8 <= (double)(unint64_t)a4)
  {
    int v16 = *((_DWORD *)this + 35);
    unint64_t v17 = a5;
    if (v16)
    {
      unint64_t v17 = (int)CI::format_bytes_per_pixel(v16);
      double width = a3->size.width;
      double height = a3->size.height;
    }
    unint64_t v10 = (unint64_t)(width * height * (double)v17);
    int v19 = (*(uint64_t (**)(CI *))(*(void *)this + 40))(this);
    v54[0] = 0;
    v54[1] = 0;
    v53 = (uint64_t *)v54;
    if (v19)
    {
      int v20 = v19;
      unint64_t v48 = v10;
      size_t v47 = a5;
      uint64_t v21 = 0;
      do
      {
        uint64_t v52 = 0;
        uint64_t v52 = (*(uint64_t (**)(CI *, uint64_t))(*(void *)this + 48))(this, v21);
        std::string v49 = &v52;
        unint64_t v22 = std::__tree<std::__value_type<CI::Node *,CI::roiList>,std::__map_value_compare<CI::Node *,std::__value_type<CI::Node *,CI::roiList>,std::less<CI::Node *>,true>,std::allocator<std::__value_type<CI::Node *,CI::roiList>>>::__emplace_unique_key_args<CI::Node *,std::piecewise_construct_t const&,std::tuple<CI::Node * const&>,std::tuple<>>(&v53, (unint64_t *)&v52, (uint64_t)&std::piecewise_construct, &v49);
        CGFloat v23 = *a2;
        CGFloat v24 = a2[1];
        CGFloat v26 = a2[2];
        CGFloat v25 = a2[3];
        int v28 = a6
           && (uint64_t v27 = v52, (*(unsigned int (**)(uint64_t))(*(void *)v52 + 16))(v52) == 52)
           && *(_DWORD *)(v27 + 152) > 1;
        v55.origin.CGFloat x = v23;
        v55.origin.CGFloat y = v24;
        v55.size.double width = v26;
        v55.size.double height = v25;
        CI::ProgramNode::compute_regions_of_child((CI::Node **)this, v55, v21, (unint64_t)a4, 0, v28, (uint64_t *)&v49);
        long long v29 = (CGRect *)v49;
        uint64_t v30 = v50;
        if (v49 != v50)
        {
          uint64_t v31 = (CI::roiList *)(v22 + 5);
          do
            CI::roiList::_insertROI(v31, v29++);
          while (v29 != (CGRect *)v30);
          long long v29 = (CGRect *)v49;
        }
        if (v29)
        {
          uint64_t v50 = (uint64_t *)v29;
          operator delete(v29);
        }
        uint64_t v21 = (v21 + 1);
      }
      while (v21 != v20);
      double v32 = v53;
      if (v53 != (uint64_t *)v54)
      {
        unint64_t v10 = v48;
        while (1)
        {
          std::string v49 = (uint64_t *)v32[4];
          std::vector<CGRect>::vector(&v50, (uint64_t)(v32 + 5));
          uint64_t v33 = v51;
          if (v51 != v50) {
            break;
          }
LABEL_39:
          if (v33)
          {
            v51 = v33;
            operator delete(v33);
          }
          BOOL v43 = (uint64_t *)v32[1];
          if (v43)
          {
            do
            {
              char v44 = v43;
              BOOL v43 = (uint64_t *)*v43;
            }
            while (v43);
          }
          else
          {
            do
            {
              char v44 = (uint64_t *)v32[2];
              BOOL v45 = *v44 == (void)v32;
              double v32 = v44;
            }
            while (!v45);
          }
          double v32 = v44;
          if (v44 == (uint64_t *)v54) {
            goto LABEL_50;
          }
        }
        uint64_t v34 = 0;
        unint64_t v35 = 0;
        uint64_t v33 = v50;
        while (1)
        {
          double v36 = *(double *)&v33[v34 + 2];
          double v37 = *(double *)&v33[v34 + 3];
          if (v36 <= v37) {
            double v38 = *(double *)&v33[v34 + 3];
          }
          else {
            double v38 = *(double *)&v33[v34 + 2];
          }
          if (v38 > v9)
          {
            v51 = v33;
            operator delete(v33);
            unint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
            goto LABEL_50;
          }
          if ((*(unsigned int (**)(uint64_t *))(*v49 + 16))(v49) != 46) {
            break;
          }
LABEL_38:
          ++v35;
          uint64_t v33 = v50;
          v34 += 4;
          if (v35 >= ((char *)v51 - (char *)v50) >> 5) {
            goto LABEL_39;
          }
        }
        double v39 = v36 * v37;
        if ((*(unsigned int (**)(uint64_t *))(*v49 + 16))(v49) == 29)
        {
          size_t v40 = CGImageGetBitsPerPixel((CGImageRef)v49[13]) >> 3;
        }
        else
        {
          if ((*(unsigned int (**)(uint64_t *))(*v49 + 16))(v49) == 44)
          {
            int v41 = *((_DWORD *)v49 + 12);
          }
          else
          {
            (*(void (**)(uint64_t *))(*v49 + 16))(v49);
            int v42 = (*(uint64_t (**)(uint64_t *))(*v49 + 16))(v49);
            size_t v40 = v47;
            if (v42 != 52) {
              goto LABEL_37;
            }
            int v41 = *((_DWORD *)v49 + 35);
            size_t v40 = v47;
            if (!v41) {
              goto LABEL_37;
            }
          }
          size_t v40 = (int)CI::format_bytes_per_pixel(v41);
        }
LABEL_37:
        unint64_t v10 = (unint64_t)((double)v10 + v39 * (double)v40);
        goto LABEL_38;
      }
      unint64_t v10 = v48;
    }
LABEL_50:
    std::__tree<std::__value_type<CI::Node *,CI::roiList>,std::__map_value_compare<CI::Node *,std::__value_type<CI::Node *,CI::roiList>,std::less<CI::Node *>,true>,std::allocator<std::__value_type<CI::Node *,CI::roiList>>>::destroy((uint64_t)&v53, v54[0]);
    return v10;
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

void std::__tree<std::__value_type<CI::Node *,CI::roiList>,std::__map_value_compare<CI::Node *,std::__value_type<CI::Node *,CI::roiList>,std::less<CI::Node *>,true>,std::allocator<std::__value_type<CI::Node *,CI::roiList>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<CI::Node *,CI::roiList>,std::__map_value_compare<CI::Node *,std::__value_type<CI::Node *,CI::roiList>,std::less<CI::Node *>,true>,std::allocator<std::__value_type<CI::Node *,CI::roiList>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<CI::Node *,CI::roiList>,std::__map_value_compare<CI::Node *,std::__value_type<CI::Node *,CI::roiList>,std::less<CI::Node *>,true>,std::allocator<std::__value_type<CI::Node *,CI::roiList>>>::destroy(a1, a2[1]);
    uint64_t v4 = (void *)a2[5];
    if (v4)
    {
      a2[6] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<CI::Node *,CI::roiList>,std::__map_value_compare<CI::Node *,std::__value_type<CI::Node *,CI::roiList>,std::less<CI::Node *>,true>,std::allocator<std::__value_type<CI::Node *,CI::roiList>>>::__emplace_unique_key_args<CI::Node *,std::piecewise_construct_t const&,std::tuple<CI::Node * const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  char v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        double v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        char v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        char v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    double v9 = a1 + 1;
LABEL_10:
    double v11 = (uint64_t *)operator new(0x40uLL);
    uint64_t v12 = **a4;
    v11[6] = 0;
    v11[7] = 0;
    v11[4] = v12;
    v11[5] = 0;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void CI::roiList::_insertROI(CI::roiList *this, const CGRect *a2)
{
  uint64_t v4 = (char *)*((void *)this + 1);
  if (v4 == *(char **)this)
  {
    unint64_t v12 = *((void *)this + 1);
LABEL_7:
    unint64_t v13 = *((void *)this + 2);
    if (v12 >= v13)
    {
      uint64_t v16 = (uint64_t)(v12 - (void)v4) >> 5;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 59) {
        abort();
      }
      uint64_t v18 = v13 - (void)v4;
      if (v18 >> 4 > v17) {
        unint64_t v17 = v18 >> 4;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v19 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19) {
        int v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>((uint64_t)this + 16, v19);
      }
      else {
        int v20 = 0;
      }
      CGFloat v23 = (CGSize *)&v20[32 * v16];
      CGFloat v24 = &v20[32 * v19];
      CGSize size = a2->size;
      CGSize *v23 = (CGSize)a2->origin;
      v23[1] = size;
      CGRect v15 = (char *)&v23[2];
      uint64_t v27 = *(char **)this;
      CGFloat v26 = (char *)*((void *)this + 1);
      if (v26 != *(char **)this)
      {
        do
        {
          CGSize v28 = (CGSize)*((_OWORD *)v26 - 1);
          v23[-2] = *((CGSize *)v26 - 2);
          v23[-1] = v28;
          v23 -= 2;
          v26 -= 32;
        }
        while (v26 != v27);
        CGFloat v26 = *(char **)this;
      }
      *(void *)this = v23;
      *((void *)this + 1) = v15;
      *((void *)this + 2) = v24;
      if (v26) {
        operator delete(v26);
      }
    }
    else
    {
      CGSize v14 = a2->size;
      *(CGPoint *)unint64_t v12 = a2->origin;
      *(CGSize *)(v12 + 16) = v14;
      CGRect v15 = (char *)(v12 + 32);
    }
    *((void *)this + 1) = v15;
  }
  else
  {
    unint64_t v5 = 0;
    double width = a2->size.width;
    double height = a2->size.height;
    uint64_t v8 = 32;
    uint64_t v4 = *(char **)this;
    while (1)
    {
      CGFloat x = a2->origin.x;
      CGFloat y = a2->origin.y;
      CGRect v30 = CGRectUnion(*(CGRect *)(&width - 2), *(CGRect *)&v4[v8 - 32]);
      CGRect v29 = v30;
      v30.origin.CGFloat x = v30.size.height * v30.size.width;
      double width = a2->size.width;
      double height = a2->size.height;
      uint64_t v4 = *(char **)this;
      double v11 = (double *)(*(void *)this + v8);
      if (v30.origin.x < (height * width + *(v11 - 1) * *(v11 - 2)) * 1.1) {
        break;
      }
      ++v5;
      unint64_t v12 = *((void *)this + 1);
      v8 += 32;
      if (v5 >= (uint64_t)(v12 - (void)v4) >> 5) {
        goto LABEL_7;
      }
    }
    uint64_t v21 = (double *)*((void *)this + 1);
    uint64_t v22 = (char *)v21 - v4 - v8;
    if (v11 != v21) {
      memmove(v11 - 4, v11, (char *)v21 - v4 - v8);
    }
    *((void *)this + 1) = &v4[v8 - 32 + (v22 & 0xFFFFFFFFFFFFFFE0)];
    CI::roiList::_insertROI(this, &v29);
  }
}

uint64_t CI::AffineNode::output_is_r(CI::AffineNode *this)
{
  uint64_t result = (*(uint64_t (**)(CI::AffineNode *))(*(void *)this + 264))(this);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(**((void **)this + 5) + 280);
    return v3();
  }
  return result;
}

uint64_t CI::AffineNode::alpha_one(CI::AffineNode *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 5) + 264))(*((void *)this + 5));
  if (!result) {
    return result;
  }
  v9.origin.double x = (*(double (**)(CI::AffineNode *))(*(void *)this + 160))(this);
  double x = v9.origin.x;
  double y = v9.origin.y;
  double width = v9.size.width;
  double height = v9.size.height;
  if (CGRectIsInfinite(v9))
  {
    *(int64x2_t *)&v8.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v8.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    double height = 1.79769313e308;
    double width = 1.79769313e308;
    goto LABEL_11;
  }
  v10.origin.double x = x;
  v10.origin.double y = y;
  v10.size.double width = width;
  v10.size.double height = height;
  if (CGRectIsNull(v10))
  {
    *(int64x2_t *)&v8.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_OWORD *)&v8.var2 = 0uLL;
  }
  else
  {
    v8.var0 = x;
    v8.var1 = y;
    v8.var2 = width;
    v8.var3 = height;
    if (x == -8.98846567e307 && y == -8.98846567e307)
    {
LABEL_11:
      if (width == 1.79769313e308 && height == 1.79769313e308) {
        return 1;
      }
    }
  }
  return (fabs(*((double *)this + 8)) < 0.0001 && fabs(*((double *)this + 9)) < 0.0001
       || fabs(*((double *)this + 7)) < 0.0001 && fabs(*((double *)this + 10)) < 0.0001)
      && Rectangle::isNearIntegral(&v8, 0.00001);
}

BOOL CI::SurfaceNode::alpha_one(CI::SurfaceNode *this)
{
  return *((_DWORD *)this + 24) == 1;
}

uint64_t CI::ColorMatrixNode::alpha_one(CI::ColorMatrixNode *this, const double (*a2)[4])
{
  uint64_t v3 = (CI::ColorMatrixNode *)((char *)this + 56);
  if (CI::ColorMatrixNode::is_alpha_one((CI::ColorMatrixNode *)((char *)this + 56), a2)) {
    return 1;
  }
  uint64_t result = CI::ColorMatrixNode::is_alpha_preserving(v3, v4);
  if (result)
  {
    uint64_t v6 = *(uint64_t (**)(void))(**((void **)this + 5) + 264);
    return v6();
  }
  return result;
}

BOOL CI::ColorMatrixNode::is_alpha_preserving(CI::ColorMatrixNode *this, const double (*a2)[4])
{
  return fabs(*((double *)this + 12)) < 0.0003
      && fabs(*((double *)this + 13)) < 0.0003
      && fabs(*((double *)this + 14)) < 0.0003
      && fabs(*((double *)this + 15) + -1.0) < 0.0003
      && fabs(*((double *)this + 19)) < 0.0003;
}

BOOL CI::ColorMatrixNode::is_alpha_one(CI::ColorMatrixNode *this, const double (*a2)[4])
{
  return fabs(*((double *)this + 12)) < 0.0003
      && fabs(*((double *)this + 13)) < 0.0003
      && fabs(*((double *)this + 14)) < 0.0003
      && fabs(*((double *)this + 15)) < 0.0003
      && fabs(*((double *)this + 19) + -1.0) < 0.0003;
}

void CI::AffineImage::extent_unclamped(CI::AffineImage *this)
{
  uint64_t v1 = (CI::AffineImage *)((char *)this + 120);
  if ((fabs(*((double *)this + 16)) >= 0.0001 || fabs(*((double *)this + 17)) >= 0.0001)
    && (fabs(*(double *)v1) >= 0.0001 || fabs(*((double *)this + 18)) >= 0.0001))
  {
    (*(void (**)(CI::AffineImage *))(*(void *)this + 88))(this);
  }
  else
  {
    v2.origin.double x = (*(double (**)(void))(**((void **)this + 13) + 96))(*((void *)this + 13));
    CI::Affine::applyToRect(v1, v2);
  }
}

void CI::ColorKernelImage::extent_unclamped(CI::ColorKernelImage *this)
{
  int v2 = CI::Kernel::num_image_arguments(*((CI::Kernel **)this + 14));
  int v3 = v2;
  if (v2 < 2)
  {
    if (!v2) {
      return;
    }
  }
  else
  {
    CGRectIsInfinite(*((CGRect *)this + 4));
  }
  if (CGRectIsInfinite(*((CGRect *)this + 4)) && *(unsigned char *)(*((void *)this + 14) + 165))
  {
    CGFloat x = *MEMORY[0x1E4F1DB20];
    CGFloat y = *(double *)(MEMORY[0x1E4F1DB20] + 8);
    CGFloat width = *(double *)(MEMORY[0x1E4F1DB20] + 16);
    CGFloat height = *(double *)(MEMORY[0x1E4F1DB20] + 24);
    if (v3 >= 1)
    {
      for (int i = 0; i != v3; ++i)
      {
        int v9 = CI::Kernel::index_of_nth_image_argument(*((CI::Kernel **)this + 14), i);
        uint64_t v10 = *((void *)this + 15);
        if (v9 > 9) {
          double v11 = (uint64_t **)(*(void *)(v10 + 16) + 8 * (v9 - 10));
        }
        else {
          double v11 = (uint64_t **)(v10 + 8 * v9 + 24);
        }
        unint64_t v12 = *v11;
        v19.origin.CGFloat x = (*(double (**)(uint64_t *))(**v11 + 88))(*v11);
        BOOL IsInfinite = CGRectIsInfinite(v19);
        uint64_t v14 = *v12;
        if (IsInfinite)
        {
          (*(void (**)(uint64_t *))(v14 + 96))(v12);
        }
        else
        {
          v20.origin.CGFloat x = (*(double (**)(uint64_t *))(v14 + 88))(v12);
          *(CGRect *)&CGFloat v15 = CGRectInset(v20, -1.0, -1.0);
        }
        v26.origin.CGFloat x = v15;
        v26.origin.CGFloat y = v16;
        v26.size.CGFloat width = v17;
        v26.size.CGFloat height = v18;
        v21.origin.CGFloat x = x;
        v21.origin.CGFloat y = y;
        v21.size.CGFloat width = width;
        v21.size.CGFloat height = height;
        CGRect v22 = CGRectUnion(v21, v26);
        CGFloat x = v22.origin.x;
        CGFloat y = v22.origin.y;
        CGFloat width = v22.size.width;
        CGFloat height = v22.size.height;
      }
    }
    v23.origin.CGFloat x = x;
    v23.origin.CGFloat y = y;
    v23.size.CGFloat width = width;
    v23.size.CGFloat height = height;
    if (!CGRectIsNull(v23))
    {
      v24.origin.CGFloat x = x;
      v24.origin.CGFloat y = y;
      v24.size.CGFloat width = width;
      v24.size.CGFloat height = height;
      if (!CGRectIsEmpty(v24))
      {
        v25.origin.CGFloat x = x;
        v25.origin.CGFloat y = y;
        v25.size.CGFloat width = width;
        v25.size.CGFloat height = height;
        if (!CGRectIsInfinite(v25))
        {
          v27.origin.CGFloat x = x;
          v27.origin.CGFloat y = y;
          v27.size.CGFloat width = width;
          v27.size.CGFloat height = height;
          CGRectIntersection(*((CGRect *)this + 4), v27);
        }
      }
    }
  }
}

double CI::ProgramNode::compute_regions_of_child@<D0>(CI::Node **this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, int a3@<W1>, unint64_t a4@<X2>, int a5@<W3>, int a6@<W4>, uint64_t *a7@<X8>)
{
  CGRect v45 = a2;
  if (a3 < 0
    || (*((int (**)(CI::Node **))*this + 5))(this) <= a3
    || (unint64_t v12 = *(const char **)(*((void *)this[7] + 4) + 8 * a3), (v13 = strlen(v12)) == 0))
  {
    uint64_t v31 = (const CGRect *)MEMORY[0x1E4F1DB20];
    CI::CGRectArray::CGRectArray((CI::CGRectArray *)a7, v31);
  }
  else
  {
    size_t v14 = v13;
    unsigned int v34 = a3;
    uint64_t v33 = (CI::ProgramNode *)this;
    CGFloat v15 = this[6];
    double v39 = 0;
    uint64_t v40 = -1;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    unint64_t v41 = -1;
    int v44 = 0;
    CI::CGRectArray::CGRectArray((CI::CGRectArray *)a7, &v45);
    for (uint64_t i = 0; i != v14; ++i)
    {
      if (a5)
      {
        CGFloat v17 = (double *)*a7;
        CGFloat v18 = (double *)a7[1];
        while (v17 != v18)
        {
          (*(void (**)(CI::Node *, void, unint64_t, CI::Node **, double, double, double, double))(*(void *)v15 + 344))(v15, 0, a4, &v39, *v17, v17[1], v17[2], v17[3]);
          v17 += 4;
        }
      }
      uint64_t v19 = (v12[i] - 48);
      std::vector<CGRect>::vector(&v36, (uint64_t)a7);
      a7[1] = *a7;
      CGRect v21 = *(double **)&v36.origin.x;
      CGFloat y = v36.origin.y;
      while (v21 != *(double **)&y)
      {
        (*(void (**)(void **__return_ptr, CI::Node *, uint64_t, double, double, double, double))(*(void *)v15 + 368))(__p, v15, v19, *v21, v21[1], v21[2], v21[3]);
        std::vector<CGRect>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CGRect const*>,std::__wrap_iter<CGRect const*>>((uint64_t)a7, a7[1], (char *)__p[0], (char *)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 5);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        v21 += 4;
      }
      unsigned int v22 = CI::Node::rois_count(v15);
      uint64_t v42 = 0;
      uint64_t v43 = 0;
      int v44 = 0;
      double v39 = v15;
      uint64_t v40 = v22;
      unint64_t v41 = v19 | 0xFFFFFFFF00000000;
      CGFloat v15 = (CI::Node *)(*(uint64_t (**)(CI::Node *, uint64_t))(*(void *)v15 + 48))(v15, v19);
      if (*(void *)&v36.origin.x)
      {
        v36.origin.CGFloat y = v36.origin.x;
        operator delete(*(void **)&v36.origin.x);
      }
    }
    uint64_t v23 = (*(uint64_t (**)(CI::ProgramNode *, void))(*(void *)v33 + 48))(v33, v34);
    (*(void (**)(uint64_t))(*(void *)v23 + 168))(v23);
    if (v24 <= v25) {
      double result = v25;
    }
    else {
      double result = v24;
    }
    if (result < (double)a4 && (*(unsigned int (**)(uint64_t))(*(void *)v23 + 16))(v23) == 46)
    {
      (*(void (**)(uint64_t))(*(void *)v23 + 168))(v23);
    }
    else
    {
      if (!a6) {
        return result;
      }
      v47.origin.CGFloat x = (*(double (**)(uint64_t))(*(void *)v23 + 168))(v23);
      if (CGRectIsInfinite(v47)) {
        return result;
      }
      v48.origin.CGFloat x = (*(double (**)(uint64_t))(*(void *)v23 + 168))(v23);
      CGRect v49 = CGRectInset(v48, -1.0, -1.0);
      CGRect v50 = CGRectInset(v49, 0.001, 0.001);
      *(CGRect *)&CGFloat v27 = CGRectIntegral(v50);
    }
    v36.origin.CGFloat x = v27;
    v36.origin.CGFloat y = v28;
    v36.size.CGFloat width = v29;
    v36.size.CGFloat height = v30;
    CI::CGRectArray::CGRectArray((CI::CGRectArray *)__p, &v36);
    double v32 = (void *)*a7;
    if (*a7)
    {
      a7[1] = (uint64_t)v32;
      operator delete(v32);
    }
    double result = *(double *)__p;
    *(_OWORD *)a7 = *(_OWORD *)__p;
    a7[2] = v38;
  }
  return result;
}

uint64_t CI::Node::rois_count(CI::Node *this)
{
  return -286331153 * ((*(void *)(*((void *)this + 2) + 8) - **((void **)this + 2)) >> 3);
}

void *std::vector<CGRect>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<CGRect>::__vallocate[abi:nn180100](a1, v5 >> 5);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<CGRect>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    abort();
  }
  double result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

char *std::vector<CGRect>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CGRect const*>,std::__wrap_iter<CGRect const*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  int64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  char v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 5)
  {
    size_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 5);
    if (v14 >> 59) {
      abort();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 5;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 4 > v14) {
      unint64_t v14 = v16 >> 4;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v17 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v39 = v9;
    if (v17) {
      CGFloat v18 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(v9, v17);
    }
    else {
      CGFloat v18 = 0;
    }
    CGFloat v29 = &v18[32 * v15];
    __p = v18;
    CGRect v36 = v29;
    uint64_t v38 = &v18[32 * v17];
    uint64_t v30 = 32 * a5;
    uint64_t v31 = &v29[32 * a5];
    do
    {
      long long v32 = *(_OWORD *)v7;
      long long v33 = *((_OWORD *)v7 + 1);
      v7 += 32;
      *(_OWORD *)CGFloat v29 = v32;
      *((_OWORD *)v29 + 1) = v33;
      v29 += 32;
      v30 -= 32;
    }
    while (v30);
    double v37 = v31;
    int64_t v5 = (char *)std::vector<CGRect>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v37 != v36) {
      v37 += (v36 - v37 + 31) & 0xFFFFFFFFFFFFFFE0;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 5;
  if (v20 >= a5)
  {
    CGRect v21 = &__src[32 * a5];
    uint64_t v23 = *(char **)(v9 - 8);
LABEL_17:
    double v24 = &v5[32 * a5];
    double v25 = &v23[-32 * a5];
    CGRect v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      CGRect v26 = v23;
      do
      {
        long long v27 = *(_OWORD *)v25;
        long long v28 = *((_OWORD *)v25 + 1);
        v25 += 32;
        *(_OWORD *)CGRect v26 = v27;
        *((_OWORD *)v26 + 1) = v28;
        v26 += 32;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-32 * ((v23 - v24) >> 5)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  CGRect v21 = &__src[32 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[32 * v20], a4 - v21);
  }
  uint64_t v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

CI::CGRectArray *CI::Node::regions_of_child@<X0>(CI::Node *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, uint64_t a3@<X1>, CI::CGRectArray *a4@<X8>)
{
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_40;
  }
  double height = a2.size.height;
  double width = a2.size.width;
  double y = a2.origin.y;
  double x = a2.origin.x;
  if (CGRectIsEmpty(a2)) {
    goto LABEL_40;
  }
  memset(&v54, 0, sizeof(v54));
  double v11 = (*(double (**)(CI::Node *, uint64_t, double, double, double, double))(*(void *)this + 80))(this, a3, x, y, width, height);
  double v13 = v12;
  double v15 = v14;
  double v17 = v16;
  CGFloat v18 = (unsigned char *)(*(uint64_t (**)(CI::Node *, uint64_t))(*(void *)this + 48))(this, a3);
  uint64_t v19 = (*(uint64_t (**)(void))(*(void *)v18 + 352))();
  if (v19 * v20)
  {
    unint64_t v21 = v19;
    unint64_t v22 = v20;
    v56.origin.double x = v11;
    v56.origin.double y = v13;
    v56.size.double width = v15;
    v56.size.double height = v17;
    if (CGRectIsNull(v56))
    {
      unint64_t v23 = 0;
      unint64_t v24 = 0;
      int v25 = 0x7FFFFFFF;
LABEL_6:
      if (v25 != 0x7FFFFFFF || v23)
      {
        int v26 = 0x7FFFFFFF;
      }
      else
      {
        int v26 = 0x7FFFFFFF;
        if (!v24)
        {
          long long v27 = (double *)MEMORY[0x1E4F1DB20];
LABEL_29:
          double v11 = *v27;
          double v13 = v27[1];
          double v15 = v27[2];
          double v17 = v27[3];
          goto LABEL_32;
        }
      }
      goto LABEL_31;
    }
    v57.origin.double x = v11;
    v57.origin.double y = v13;
    v57.size.double width = v15;
    v57.size.double height = v17;
    if (CGRectIsInfinite(v57))
    {
      unint64_t v24 = 0xFFFFFFFFLL;
      unint64_t v23 = 0xFFFFFFFFLL;
      int v25 = -2147483647;
      int v26 = -2147483647;
    }
    else
    {
      v58.origin.double x = v11;
      v58.origin.double y = v13;
      v58.size.double width = v15;
      v58.size.double height = v17;
      CGRect v59 = CGRectInset(v58, 0.000001, 0.000001);
      CGRect v60 = CGRectIntegral(v59);
      int v26 = (int)v60.origin.x;
      int v25 = (int)v60.origin.y;
      unint64_t v23 = (unint64_t)v60.size.width;
      unint64_t v24 = (unint64_t)v60.size.height;
    }
    if (v26 == -2147483647 && v25 == -2147483647 && v23 == 0xFFFFFFFF)
    {
      int v25 = -2147483647;
      unint64_t v23 = 0xFFFFFFFFLL;
      if (!v24 || v24 == 0xFFFFFFFF) {
        goto LABEL_25;
      }
    }
    else if (!v23 || !v24)
    {
LABEL_22:
      if (v26 != -2147483647)
      {
        if (v26 != 0x7FFFFFFF) {
          goto LABEL_31;
        }
        goto LABEL_6;
      }
LABEL_25:
      int v26 = -2147483647;
      if (v25 == -2147483647 && v23 == 0xFFFFFFFF && v24 == 0xFFFFFFFF)
      {
        long long v27 = (double *)MEMORY[0x1E4F1DB10];
        goto LABEL_29;
      }
LABEL_31:
      double v11 = (double)v26;
      double v13 = (double)v25;
      double v15 = (double)v23;
      double v17 = (double)v24;
      goto LABEL_32;
    }
    int v28 = v21 + v26 + v23 - 1;
    int v29 = v22 + v24 + v25 - 1;
    int v26 = v26 / v21 * v21;
    int v25 = v25 / v22 * v22;
    unint64_t v23 = (int)(v28 - v26 - v28 % v21);
    unint64_t v24 = (int)(v29 - v25 - v29 % v22);
    goto LABEL_22;
  }
LABEL_32:
  CGFloat v30 = (*(double (**)(unsigned char *))(*(void *)v18 + 160))(v18);
  CGFloat v32 = v31;
  CGFloat v34 = v33;
  CGFloat v36 = v35;
  CGFloat v37 = (*(double (**)(unsigned char *))(*(void *)v18 + 168))(v18);
  CGFloat v51 = v38;
  CGFloat v52 = v37;
  CGFloat v49 = v40;
  CGFloat v50 = v39;
  if ((*(int (**)(unsigned char *))(*(void *)v18 + 16))(v18) >= 41
    && (*(int (**)(unsigned char *))(*(void *)v18 + 16))(v18) <= 42)
  {
    v61.origin.double x = v30;
    v61.origin.double y = v32;
    v61.size.double width = v34;
    v61.size.double height = v36;
    if (!CGRectIsInfinite(v61) && !v18[139])
    {
      v54.origin.double x = v30;
      v54.origin.double y = v32;
      double v17 = v36;
      double v15 = v34;
      double v13 = v32;
      double v11 = v30;
      v54.size.double width = v34;
      v54.size.double height = v36;
    }
  }
  v62.origin.double x = v30;
  v62.origin.double y = v32;
  v62.size.double width = v34;
  v62.size.double height = v36;
  if (CGRectIsInfinite(v62))
  {
    v63.origin.double y = v51;
    v63.origin.double x = v52;
    v63.size.double height = v49;
    v63.size.double width = v50;
    BOOL IsInfinite = CGRectIsInfinite(v63);
    if (!IsInfinite)
    {
      v68.origin.double x = v11;
      v68.origin.double y = v13;
      v68.size.double width = v15;
      v68.size.double height = v17;
      v73.origin.double y = v51;
      v73.origin.double x = v52;
      v73.size.double height = v49;
      v73.size.double width = v50;
      CI::ClampNode::adjust_roi_for_clamp_rect((CI::ClampNode *)IsInfinite, v68, v73);
      CGRect v53 = CGRectIntegral(v69);
      CGRect v48 = &v53;
      return CI::CGRectArray::CGRectArray(a4, v48);
    }
  }
  v64.origin.double x = v30;
  v64.origin.double y = v32;
  v64.size.double width = v34;
  v64.size.double height = v36;
  CGRect v72 = CGRectInset(v64, -1.0, -1.0);
  v65.origin.double x = v11;
  v65.origin.double y = v13;
  v65.size.double width = v15;
  v65.size.double height = v17;
  CGRect v66 = CGRectIntersection(v65, v72);
  CGFloat v42 = v66.origin.x;
  CGFloat v43 = v66.origin.y;
  CGFloat v44 = v66.size.width;
  CGFloat v45 = v66.size.height;
  if (!CGRectIsEmpty(v66))
  {
    v67.origin.double x = v42;
    v67.origin.double y = v43;
    v67.size.double width = v44;
    v67.size.double height = v45;
    if (CGRectIsInfinite(v67))
    {
      uint64_t v46 = (const CGRect *)MEMORY[0x1E4F1DB10];
      goto LABEL_41;
    }
    v70.origin.double x = v42;
    v70.origin.double y = v43;
    v70.size.double width = v44;
    v70.size.double height = v45;
    CGRect v71 = CGRectInset(v70, 0.001, 0.001);
    CGRect v54 = CGRectIntegral(v71);
    CGRect v48 = &v54;
    return CI::CGRectArray::CGRectArray(a4, v48);
  }
LABEL_40:
  uint64_t v46 = (const CGRect *)MEMORY[0x1E4F1DB20];
LABEL_41:

  return CI::CGRectArray::CGRectArray(a4, v46);
}

uint64_t CI::NodeWithChild::extent(CI::NodeWithChild *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 160))();
}

void CI::ColorKernelNode::extent_unclamped(CI::ColorKernelNode *this)
{
  int v2 = CI::Kernel::num_image_arguments(*((CI::Kernel **)this + 6));
  int v3 = v2;
  if (v2 < 2)
  {
    if (!v2) {
      return;
    }
  }
  else
  {
    CGRectIsInfinite(*((CGRect *)this + 2));
  }
  if (CGRectIsInfinite(*((CGRect *)this + 2)) && *(unsigned char *)(*((void *)this + 6) + 165))
  {
    CGFloat x = *MEMORY[0x1E4F1DB20];
    CGFloat y = *(double *)(MEMORY[0x1E4F1DB20] + 8);
    CGFloat width = *(double *)(MEMORY[0x1E4F1DB20] + 16);
    CGFloat height = *(double *)(MEMORY[0x1E4F1DB20] + 24);
    if (v3 >= 1)
    {
      for (int i = 0; i != v3; ++i)
      {
        int v9 = CI::Kernel::index_of_nth_image_argument(*((CI::Kernel **)this + 6), i);
        uint64_t v10 = *((void *)this + 7);
        if (v9 > 9) {
          double v11 = (uint64_t **)(*(void *)(v10 + 16) + 8 * (v9 - 10));
        }
        else {
          double v11 = (uint64_t **)(v10 + 8 * v9 + 24);
        }
        double v12 = *v11;
        v19.origin.CGFloat x = (*(double (**)(uint64_t *))(**v11 + 160))(*v11);
        BOOL IsInfinite = CGRectIsInfinite(v19);
        uint64_t v14 = *v12;
        if (IsInfinite)
        {
          (*(void (**)(uint64_t *))(v14 + 168))(v12);
        }
        else
        {
          v20.origin.CGFloat x = (*(double (**)(uint64_t *))(v14 + 160))(v12);
          *(CGRect *)&CGFloat v15 = CGRectInset(v20, -1.0, -1.0);
        }
        v26.origin.CGFloat x = v15;
        v26.origin.CGFloat y = v16;
        v26.size.CGFloat width = v17;
        v26.size.CGFloat height = v18;
        v21.origin.CGFloat x = x;
        v21.origin.CGFloat y = y;
        v21.size.CGFloat width = width;
        v21.size.CGFloat height = height;
        CGRect v22 = CGRectUnion(v21, v26);
        CGFloat x = v22.origin.x;
        CGFloat y = v22.origin.y;
        CGFloat width = v22.size.width;
        CGFloat height = v22.size.height;
      }
    }
    v23.origin.CGFloat x = x;
    v23.origin.CGFloat y = y;
    v23.size.CGFloat width = width;
    v23.size.CGFloat height = height;
    if (!CGRectIsNull(v23))
    {
      v24.origin.CGFloat x = x;
      v24.origin.CGFloat y = y;
      v24.size.CGFloat width = width;
      v24.size.CGFloat height = height;
      if (!CGRectIsEmpty(v24))
      {
        v25.origin.CGFloat x = x;
        v25.origin.CGFloat y = y;
        v25.size.CGFloat width = width;
        v25.size.CGFloat height = height;
        if (!CGRectIsInfinite(v25))
        {
          v27.origin.CGFloat x = x;
          v27.origin.CGFloat y = y;
          v27.size.CGFloat width = width;
          v27.size.CGFloat height = height;
          CGRectIntersection(*((CGRect *)this + 2), v27);
        }
      }
    }
  }
}

double CI::ColorKernelNode::extent(CI::ColorKernelNode *this)
{
  return *((double *)this + 8);
}

uint64_t CI::Kernel::num_image_arguments(CI::Kernel *this)
{
  if (*((unsigned char *)this + 12)) {
    int v2 = CI::KernelArguments::count((CI::Kernel *)((char *)this + 144));
  }
  else {
    int v2 = *((_DWORD *)this + 5);
  }
  if (v2 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = v2;
    while (1)
    {
      if (*((unsigned char *)this + 12))
      {
        int type = CI::KernelArguments::get_type((CI::Kernel *)((char *)this + 144), v3);
      }
      else
      {
        if (v3 >= *((int *)this + 5)) {
          goto LABEL_13;
        }
        int type = *(_DWORD *)(*((void *)this + 9) + 4 * v3);
      }
      if (type == 1) {
        goto LABEL_16;
      }
      if (*((unsigned char *)this + 12))
      {
        int v7 = CI::KernelArguments::get_type((CI::Kernel *)((char *)this + 144), v3);
        goto LABEL_15;
      }
LABEL_13:
      if (v3 >= *((int *)this + 5)) {
        goto LABEL_17;
      }
      int v7 = *(_DWORD *)(*((void *)this + 9) + 4 * v3);
LABEL_15:
      if (v7 == 2) {
LABEL_16:
      }
        uint64_t v4 = (v4 + 1);
LABEL_17:
      if (v5 == ++v3) {
        return v4;
      }
    }
  }
  return 0;
}

uint64_t CI::SurfaceNode::type(CI::SurfaceNode *this)
{
  return 46;
}

uint64_t CI::Kernel::index_of_nth_image_argument(CI::Kernel *this, int a2)
{
  if (*((unsigned char *)this + 12)) {
    int v4 = CI::KernelArguments::count((CI::Kernel *)((char *)this + 144));
  }
  else {
    int v4 = *((_DWORD *)this + 5);
  }
  if (v4 >= 1)
  {
    uint64_t v5 = 0;
    int v6 = 0;
    uint64_t v7 = v4;
    do
    {
      if (*((unsigned char *)this + 12))
      {
        int type = CI::KernelArguments::get_type((CI::Kernel *)((char *)this + 144), v5);
      }
      else
      {
        if (v5 >= *((int *)this + 5)) {
          goto LABEL_13;
        }
        int type = *(_DWORD *)(*((void *)this + 9) + 4 * v5);
      }
      if (type == 1) {
        goto LABEL_16;
      }
      if (*((unsigned char *)this + 12))
      {
        int v9 = CI::KernelArguments::get_type((CI::Kernel *)((char *)this + 144), v5);
        goto LABEL_15;
      }
LABEL_13:
      if (v5 >= *((int *)this + 5)) {
        goto LABEL_18;
      }
      int v9 = *(_DWORD *)(*((void *)this + 9) + 4 * v5);
LABEL_15:
      if (v9 == 2)
      {
LABEL_16:
        if (v6 == a2) {
          return v5;
        }
        ++v6;
      }
LABEL_18:
      ++v5;
    }
    while (v7 != v5);
  }
  return 0xFFFFFFFFLL;
}

uint64_t CI::NodeWithChild::extent_unclamped(CI::NodeWithChild *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 168))();
}

double CI::SurfaceNode::extent_unclamped(CI::SurfaceNode *this)
{
  return 0.0;
}

uint64_t CI::Node::roiAlignment(CI::Node *this)
{
  return 0;
}

uint64_t CI::ColorMatrixNode::type(CI::ColorMatrixNode *this)
{
  return 33;
}

double CI::AffineNode::extent(CI::AffineNode *this)
{
  uint64_t v1 = (CI::AffineNode *)((char *)this + 56);
  (*(void (**)(void))(**((void **)this + 5) + 160))(*((void *)this + 5));

  return CI::Affine::applyToRect(v1, *(CGRect *)&v2);
}

uint64_t CI::ColorMatrixNode::extent(uint64_t this)
{
  if (fabs(*(double *)(this + 208)) < 0.0003) {
    return (*(uint64_t (**)(void))(**(void **)(this + 40) + 160))(*(void *)(this + 40));
  }
  return this;
}

_DWORD *CI::SurfaceNode::extent(_DWORD *this)
{
  if (!this[25]) {
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)this + 168))(this);
  }
  return this;
}

uint64_t CI::SwizzleNode::type(CI::SwizzleNode *this)
{
  return 47;
}

void CI::ClampNode::adjust_roi_for_clamp_rect(CI::ClampNode *this, CGRect a2, CGRect a3)
{
  CGFloat height = a3.size.height;
  CGFloat width = a3.size.width;
  CGFloat y = a3.origin.y;
  CGFloat x = a3.origin.x;
  CGFloat v7 = a2.size.height;
  CGFloat v8 = a2.size.width;
  CGFloat v9 = a2.origin.y;
  CGFloat v10 = a2.origin.x;
  CGRectGetMinX(a3);
  v11.origin.CGFloat x = x;
  v11.origin.CGFloat y = y;
  v11.size.CGFloat width = width;
  v11.size.CGFloat height = height;
  CGRectGetMinY(v11);
  v12.origin.CGFloat x = x;
  v12.origin.CGFloat y = y;
  v12.size.CGFloat width = width;
  v12.size.CGFloat height = height;
  CGRectGetMaxX(v12);
  v13.origin.CGFloat x = x;
  v13.origin.CGFloat y = y;
  v13.size.CGFloat width = width;
  v13.size.CGFloat height = height;
  CGRectGetMaxY(v13);
  v14.origin.CGFloat x = v10;
  v14.origin.CGFloat y = v9;
  v14.size.CGFloat width = v8;
  v14.size.CGFloat height = v7;
  CGRectGetMinX(v14);
  v15.origin.CGFloat x = v10;
  v15.origin.CGFloat y = v9;
  v15.size.CGFloat width = v8;
  v15.size.CGFloat height = v7;
  CGRectGetMinY(v15);
  v16.origin.CGFloat x = v10;
  v16.origin.CGFloat y = v9;
  v16.size.CGFloat width = v8;
  v16.size.CGFloat height = v7;
  CGRectGetMaxX(v16);
  v17.origin.CGFloat x = v10;
  v17.origin.CGFloat y = v9;
  v17.size.CGFloat width = v8;
  v17.size.CGFloat height = v7;
  CGRectGetMaxY(v17);
}

void CI::Node::add_roi(CI::Node *this, unint64_t a2, unint64_t a3, CGRect a4, const CI::parentROI *a5)
{
  double y = a4.origin.y;
  double rect = a4.size.height;
  double width = a4.size.width;
  double x = a4.origin.x;
  __p = 0;
  __dst = 0;
  v81 = 0;
  CGFloat v10 = std::__allocate_at_least[abi:nn180100]<std::allocator<CI::parentROI>>((uint64_t)&v81, 1uLL);
  long long v13 = *((_OWORD *)a5 + 1);
  long long v12 = *((_OWORD *)a5 + 2);
  *CGFloat v10 = *(_OWORD *)a5;
  v10[1] = v13;
  void v10[2] = v12;
  __p = v10;
  v81 = &v10[3 * v11];
  __dst = v10 + 3;
  *(double *)&long long v12 = x;
  *(double *)&long long v13 = y;
  double v14 = width;
  double v15 = rect;
  IsEmptdouble y = CGRectIsEmpty(*(CGRect *)((char *)&v13 - 8));
  CGRect v17 = (uint64_t *)*((void *)this + 2);
  uint64_t v18 = *v17;
  uint64_t v19 = v17[1];
  int v20 = -286331153 * ((unint64_t)(v19 - *v17) >> 3);
  if (!IsEmpty)
  {
    if (v20 < 1) {
      goto LABEL_85;
    }
    int v23 = 0;
    double v24 = (double)a3;
    while (1)
    {
      int v25 = -286331153 * ((unint64_t)(v19 - v18) >> 3);
      if (v23 < v25)
      {
        uint64_t v26 = v23;
        uint64_t v27 = 120 * v23 + 40;
        do
        {
          CGFloat v28 = *(double *)(v18 + v27 - 40);
          CGFloat v29 = *(double *)(v18 + v27 - 32);
          double v30 = *(double *)(v18 + v27 - 24);
          double v31 = *(double *)(v18 + v27 - 16);
          v82.origin.double x = v28;
          v82.origin.double y = v29;
          v82.size.double width = v30;
          v82.size.double height = v31;
          if (!CGRectIsEmpty(v82))
          {
            v83.origin.double x = v28;
            v83.origin.double y = v29;
            v83.size.double width = v30;
            v83.size.double height = v31;
            v97.origin.double x = x;
            v97.origin.double y = y;
            v97.size.double width = width;
            v97.size.double height = rect;
            CGRect v84 = CGRectUnion(v83, v97);
            if (v84.size.width <= v24 && v84.size.height <= v24)
            {
              double v33 = (void *)(**((void **)this + 2) + v27);
              uint64_t v34 = *(v33 - 1);
              if (*v33 != v34 && __dst != __p)
              {
                double v35 = v84.size.width;
                double height = v84.size.height;
                if (CI::parentROI::operator==(v34, (uint64_t)__p) && v35 * height < (width * rect + v30 * v31) * 1.1)
                {
                  std::vector<CI::parentROI>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CI::parentROI const*>,std::__wrap_iter<CI::parentROI const*>>((uint64_t)&__p, (uint64_t)__dst, *(char **)(**((void **)this + 2) + v27 - 8), *(char **)(**((void **)this + 2) + v27), 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(*(void *)(**((void **)this + 2) + v27)- *(void *)(**((void **)this + 2) + v27 - 8)) >> 4));
                  v85.origin.double x = x;
                  v85.origin.double y = y;
                  v85.size.double width = width;
                  v85.size.double height = rect;
                  v98.origin.double x = v28;
                  v98.origin.double y = v29;
                  v98.size.double width = v30;
                  v98.size.double height = v31;
                  CGRect v86 = CGRectUnion(v85, v98);
                  double x = v86.origin.x;
                  double y = v86.origin.y;
                  double width = v86.size.width;
                  double rect = v86.size.height;
                  CI::SerialRectArray::remove(*((CI::SerialRectArray **)this + 2), v26);
                  int v23 = 0;
                  CGRect v17 = (uint64_t *)*((void *)this + 2);
                  uint64_t v18 = *v17;
                  uint64_t v19 = v17[1];
                  int v25 = -286331153 * ((unint64_t)(v19 - *v17) >> 3);
                  goto LABEL_23;
                }
              }
            }
          }
          ++v26;
          CGRect v17 = (uint64_t *)*((void *)this + 2);
          uint64_t v18 = *v17;
          uint64_t v19 = v17[1];
          int v25 = -286331153 * ((v19 - *v17) >> 3);
          v27 += 120;
        }
        while (v26 < v25);
        int v23 = v26;
      }
LABEL_23:
      if (v23 >= v25)
      {
        if (v25 < 1) {
          goto LABEL_85;
        }
        int v37 = 0;
        do
        {
          int v38 = -286331153 * ((unint64_t)(v19 - v18) >> 3);
          if (v37 >= v38) {
            continue;
          }
          uint64_t v39 = v37;
          uint64_t v40 = 120 * v37;
          while (1)
          {
            CGFloat v41 = *(double *)(v18 + v40);
            CGFloat v42 = *(double *)(v18 + v40 + 8);
            double v43 = *(double *)(v18 + v40 + 16);
            double v44 = *(double *)(v18 + v40 + 24);
            v87.origin.double x = v41;
            v87.origin.double y = v42;
            v87.size.double width = v43;
            v87.size.double height = v44;
            if (!CGRectIsEmpty(v87))
            {
              v88.origin.double x = v41;
              v88.origin.double y = v42;
              v88.size.double width = v43;
              v88.size.double height = v44;
              v99.origin.double x = x;
              v99.origin.double y = y;
              v99.size.double width = width;
              v99.size.double height = rect;
              CGRect v89 = CGRectUnion(v88, v99);
              if (v89.size.width <= v24 && v89.size.height <= v24)
              {
                double v46 = v43 * v44;
                if (v43 * v44 >= width * rect) {
                  double v46 = width * rect;
                }
                if (v89.size.width * v89.size.height < v46 * 1.1) {
                  break;
                }
              }
            }
            ++v39;
            CGRect v17 = (uint64_t *)*((void *)this + 2);
            uint64_t v18 = *v17;
            uint64_t v19 = v17[1];
            int v38 = -286331153 * ((v19 - *v17) >> 3);
            v40 += 120;
            if (v39 >= v38)
            {
              int v37 = v39;
              goto LABEL_42;
            }
          }
          std::vector<CI::parentROI>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CI::parentROI const*>,std::__wrap_iter<CI::parentROI const*>>((uint64_t)&__p, (uint64_t)__dst, *(char **)(**((void **)this + 2) + v40 + 32), *(char **)(**((void **)this + 2) + v40 + 40), 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(*(void *)(**((void **)this + 2) + v40 + 40) - *(void *)(**((void **)this + 2) + v40 + 32)) >> 4));
          v90.origin.double x = x;
          v90.origin.double y = y;
          v90.size.double width = width;
          v90.size.double height = rect;
          v100.origin.double x = v41;
          v100.origin.double y = v42;
          v100.size.double width = v43;
          v100.size.double height = v44;
          CGRect v91 = CGRectUnion(v90, v100);
          double x = v91.origin.x;
          double y = v91.origin.y;
          double width = v91.size.width;
          double rect = v91.size.height;
          CI::SerialRectArray::remove(*((CI::SerialRectArray **)this + 2), v39);
          int v37 = 0;
          CGRect v17 = (uint64_t *)*((void *)this + 2);
          uint64_t v18 = *v17;
          uint64_t v19 = v17[1];
          int v38 = -286331153 * ((unint64_t)(v19 - *v17) >> 3);
LABEL_42:
          ;
        }
        while (v37 < v38);
        if (v38 < 1) {
          goto LABEL_85;
        }
        LODWORD(v47) = 0;
LABEL_45:
        LODWORD(v48) = -286331153 * ((unint64_t)(v19 - v18) >> 3);
        if ((int)v47 >= (int)v48) {
          goto LABEL_84;
        }
        double v75 = width * rect;
        uint64_t v47 = (int)v47;
        while (1)
        {
          CGFloat v49 = (CGFloat *)(v18 + 120 * v47);
          CGFloat v50 = *v49;
          CGFloat v51 = v49[1];
          double v52 = v49[2];
          double v53 = v49[3];
          v92.origin.double x = *v49;
          v92.origin.double y = v51;
          v92.size.double width = v52;
          v92.size.double height = v53;
          if (!CGRectIsEmpty(v92))
          {
            v93.origin.double x = v50;
            v93.origin.double y = v51;
            v93.size.double width = v52;
            v93.size.double height = v53;
            v101.origin.double x = x;
            v101.origin.double y = y;
            v101.size.double width = width;
            v101.size.double height = rect;
            CGRect v94 = CGRectUnion(v93, v101);
            BOOL v54 = v94.size.width <= v24 && v94.size.height <= v24;
            if (v54 && a2 != 0)
            {
              double v56 = v94.size.width;
              double v57 = v94.size.height;
              if ((*(unsigned int (**)(CI::Node *, CGPoint, __n128))(*(void *)this + 312))(this, v94.origin, *(__n128 *)&v94.origin.y))
              {
                CGRect v58 = __p;
                if (__p == __dst)
                {
LABEL_66:
                  double v63 = width * rect;
                  if (v75 >= v52 * v53) {
                    double v63 = v52 * v53;
                  }
                  double v74 = v63;
                  int v64 = (*(uint64_t (**)(CI::Node *))(*(void *)this + 312))(this);
                  int v65 = CI::format_bytes_per_pixel(v64);
                  CGRect v66 = (int *)__p;
                  if (__p == __dst)
                  {
                    unint64_t v67 = 0;
                  }
                  else
                  {
                    unint64_t v67 = 0;
                    do
                    {
                      if (v67 <= *(void *)(**(void **)(*(void *)v66 + 16) + 120 * v66[2] + 88)) {
                        unint64_t v67 = *(void *)(**(void **)(*(void *)v66 + 16) + 120 * v66[2] + 88);
                      }
                      v66 += 12;
                    }
                    while (v66 != __dst);
                  }
                  uint64_t v68 = **((void **)this + 2) + 120 * v47;
                  CGRect v69 = *(char **)(v68 + 32);
                  CGRect v70 = *(char **)(v68 + 40);
                  CGRect v71 = (int *)v69;
                  if (v69 != v70)
                  {
                    do
                    {
                      if (v67 <= *(void *)(**(void **)(*(void *)v71 + 16) + 120 * v71[2] + 88)) {
                        unint64_t v67 = *(void *)(**(void **)(*(void *)v71 + 16) + 120 * v71[2] + 88);
                      }
                      v71 += 12;
                    }
                    while (v71 != (int *)v70);
                  }
                  double v72 = v56 * v57;
                  double v73 = width * rect;
                  if (v75 < v52 * v53) {
                    double v73 = v52 * v53;
                  }
                  if (v72 < v73 * 1.1 && (v72 - v74) * (double)v65 + (double)v67 < (double)a2)
                  {
                    std::vector<CI::parentROI>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CI::parentROI const*>,std::__wrap_iter<CI::parentROI const*>>((uint64_t)&__p, (uint64_t)__dst, v69, v70, 0xAAAAAAAAAAAAAAABLL * ((v70 - v69) >> 4));
                    v95.origin.double x = x;
                    v95.origin.double y = y;
                    v95.size.double width = width;
                    v95.size.double height = rect;
                    v102.origin.double x = v50;
                    v102.origin.double y = v51;
                    v102.size.double width = v52;
                    v102.size.double height = v53;
                    CGRect v96 = CGRectUnion(v95, v102);
                    double x = v96.origin.x;
                    double y = v96.origin.y;
                    double width = v96.size.width;
                    double rect = v96.size.height;
                    CI::SerialRectArray::remove(*((CI::SerialRectArray **)this + 2), v47);
                    LODWORD(v47) = 0;
                    CGRect v17 = (uint64_t *)*((void *)this + 2);
                    uint64_t v18 = *v17;
                    uint64_t v19 = v17[1];
                    LODWORD(v48) = -286331153 * ((unint64_t)(v19 - *v17) >> 3);
LABEL_84:
                    if ((int)v47 >= (int)v48)
                    {
LABEL_85:
                      CI::SerialRectArray::append(v17, (uint64_t)&__p, x, y, width, rect);
                      goto LABEL_86;
                    }
                    goto LABEL_45;
                  }
                }
                else
                {
                  uint64_t v59 = **((void **)this + 2) + 120 * v47;
                  CGRect v60 = *(void **)(v59 + 32);
                  CGRect v61 = *(void **)(v59 + 40);
                  while (v60 == v61)
                  {
LABEL_65:
                    v58 += 6;
                    if (v58 == __dst) {
                      goto LABEL_66;
                    }
                  }
                  CGRect v62 = v60;
                  while (*v58 != *v62)
                  {
                    v62 += 6;
                    if (v62 == v61) {
                      goto LABEL_65;
                    }
                  }
                }
              }
            }
          }
          ++v47;
          CGRect v17 = (uint64_t *)*((void *)this + 2);
          uint64_t v18 = *v17;
          uint64_t v19 = v17[1];
          unint64_t v48 = 0xEEEEEEEEEEEEEEEFLL * ((v19 - *v17) >> 3);
          if (v47 >= (int)v48) {
            goto LABEL_84;
          }
        }
      }
    }
  }
  if (v20 < 1) {
    goto LABEL_85;
  }
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  while (!CGRectIsEmpty(*(CGRect *)(v18 + v21)))
  {
    ++v22;
    CGRect v17 = (uint64_t *)*((void *)this + 2);
    uint64_t v18 = *v17;
    v21 += 120;
    if (v22 >= (int)(-286331153 * ((unint64_t)(v17[1] - *v17) >> 3))) {
      goto LABEL_85;
    }
  }
  std::vector<CI::parentROI>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CI::parentROI const*>,std::__wrap_iter<CI::parentROI const*>>((uint64_t)&__p, (uint64_t)__dst, *(char **)(**((void **)this + 2) + v21 + 32), *(char **)(**((void **)this + 2) + v21 + 40), 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(*(void *)(**((void **)this + 2) + v21 + 40) - *(void *)(**((void **)this + 2) + v21 + 32)) >> 4));
  CI::SerialRectArray::replace(*((void **)this + 2), (uint64_t)&__p, v22, *MEMORY[0x1E4F1DB20], *(double *)(MEMORY[0x1E4F1DB20] + 8), *(double *)(MEMORY[0x1E4F1DB20] + 16), *(double *)(MEMORY[0x1E4F1DB20] + 24));
LABEL_86:
  if (__p)
  {
    __dst = __p;
    operator delete(__p);
  }
}

void CI::SerialRectArray::append(uint64_t *a1, uint64_t a2, double a3, double a4, double a5, double a6)
{
  long long v13 = 0u;
  *(_OWORD *)long long v12 = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  *(_OWORD *)__p = 0u;
  long long v16 = 0u;
  CGRect v17 = CGRectStandardize(*(CGRect *)&a3);
  *(CGFloat *)&long long v8 = v17.origin.x;
  *((void *)&v8 + 1) = *(void *)&v17.origin.y;
  CGFloat width = v17.size.width;
  CGFloat height = v17.size.height;
  int v14 = 1;
  if (v11 != (void **)a2) {
    std::vector<CI::parentROI>::__assign_with_size[abi:nn180100]<CI::parentROI*,CI::parentROI*>((char *)v11, *(char **)a2, *(void *)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4));
  }
  std::vector<CI::SerialRectArray::roiData>::push_back[abi:nn180100](a1, &v8);
  if (__p[1])
  {
    *(void **)&long long v16 = __p[1];
    operator delete(__p[1]);
  }
  if (v12[1])
  {
    *(void **)&long long v13 = v12[1];
    operator delete(v12[1]);
  }
  if (v11[0])
  {
    v11[1] = v11[0];
    operator delete(v11[0]);
  }
}

char *std::vector<CI::parentROI>::__assign_with_size[abi:nn180100]<CI::parentROI*,CI::parentROI*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  CGFloat v7 = result;
  uint64_t v8 = *((void *)result + 2);
  CGFloat v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 4) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *CGFloat v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 > 0x555555555555555) {
      abort();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 4);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x555555555555555;
    }
    else {
      unint64_t v12 = v11;
    }
    double result = std::vector<CI::parentROI>::__vallocate[abi:nn180100](v7, v12);
    int v14 = (char *)v7[1];
    long long v13 = (void **)(v7 + 1);
    CGFloat v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  long long v13 = (void **)(result + 8);
  double v15 = (unsigned char *)*((void *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 4) >= a4) {
    goto LABEL_16;
  }
  long long v16 = &__src[16 * ((v15 - v9) >> 4)];
  if (v15 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v15 - v9);
    CGFloat v9 = (char *)*v13;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    double result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *long long v13 = &v9[v17];
  return result;
}

uint64_t std::vector<CI::SerialRectArray::roiData>::push_back[abi:nn180100](uint64_t *a1, _OWORD *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    unint64_t v10 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v7 - *a1) >> 3);
    if (v10 + 1 > 0x222222222222222) {
      abort();
    }
    unint64_t v11 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v5 - *a1) >> 3);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= v10 + 1) {
      uint64_t v12 = v10 + 1;
    }
    if (v11 >= 0x111111111111111) {
      unint64_t v13 = 0x222222222222222;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      int v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SerialRectArray::roiData>>(v4, v13);
    }
    else {
      int v14 = 0;
    }
    double v15 = v14;
    long long v16 = &v14[120 * v10];
    uint64_t v18 = &v14[120 * v13];
    std::construct_at[abi:nn180100]<CI::SerialRectArray::roiData,CI::SerialRectArray::roiData&,CI::SerialRectArray::roiData*>((uint64_t)v16, a2);
    size_t v17 = v16 + 120;
    std::vector<CI::SerialRectArray::roiData>::__swap_out_circular_buffer(a1, &v15);
    uint64_t v9 = a1[1];
    uint64_t result = std::__split_buffer<CI::SerialRectArray::roiData>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    uint64_t result = std::construct_at[abi:nn180100]<CI::SerialRectArray::roiData,CI::SerialRectArray::roiData&,CI::SerialRectArray::roiData*>(*(void *)(v4 - 8), a2);
    uint64_t v9 = v7 + 120;
  }
  a1[1] = v9;
  return result;
}

uint64_t std::construct_at[abi:nn180100]<CI::SerialRectArray::roiData,CI::SerialRectArray::roiData&,CI::SerialRectArray::roiData*>(uint64_t a1, _OWORD *a2)
{
  long long v4 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v4;
  std::vector<CI::parentROI>::vector((void *)(a1 + 32), (uint64_t)(a2 + 2));
  std::vector<CI::parentROI>::vector((void *)(a1 + 56), (uint64_t)a2 + 56);
  *(_OWORD *)(a1 + 80) = a2[5];
  std::vector<unsigned long>::vector((void *)(a1 + 96), (uint64_t)(a2 + 6));
  return a1;
}

void *std::vector<CI::parentROI>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  long long v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<CI::parentROI>::__vallocate[abi:nn180100](a1, 0xAAAAAAAAAAAAAAABLL * (v5 >> 4));
    unint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<CI::parentROI>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::parentROI>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::parentROI>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(48 * a2);
}

void *std::vector<unsigned long>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<unsigned long>::__vallocate[abi:nn180100](a1, v5 >> 3);
    unint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

void CI::AffineNode::extent_unclamped(CI::AffineNode *this)
{
  uint64_t v1 = (CI::AffineNode *)((char *)this + 56);
  if ((fabs(*((double *)this + 8)) >= 0.0001 || fabs(*((double *)this + 9)) >= 0.0001)
    && (fabs(*(double *)v1) >= 0.0001 || fabs(*((double *)this + 10)) >= 0.0001))
  {
    (*(void (**)(CI::AffineNode *))(*(void *)this + 160))(this);
  }
  else
  {
    v2.origin.double x = (*(double (**)(void))(**((void **)this + 5) + 168))(*((void *)this + 5));
    CI::Affine::applyToRect(v1, v2);
  }
}

double CI::Affine::applyToRect(CI::Affine *this, CGRect a2)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double y = a2.origin.y;
  double x = a2.origin.x;
  if (!CGRectIsNull(a2))
  {
    v34.origin.double x = x;
    v34.origin.double y = y;
    v34.size.double width = width;
    v34.size.double height = height;
    if (!CGRectIsInfinite(v34) && !CI::Affine::isIdentity(this))
    {
      double v7 = *((double *)this + 2);
      double v8 = *((double *)this + 3);
      double v9 = y * v7;
      double v11 = *(double *)this;
      double v10 = *((double *)this + 1);
      double v13 = *((double *)this + 4);
      double v12 = *((double *)this + 5);
      *(float *)&uint64_t v14 = v13 + y * v7 + *(double *)this * x;
      double v15 = y * v8;
      float v16 = v12 + y * v8 + v10 * x;
      double v17 = x + width;
      double v18 = (y + height) * v7;
      float v19 = v13 + v18 + *(double *)this * (x + width);
      BOOL v20 = v19 < *(float *)&v14;
      BOOL v21 = v19 <= *(float *)&v14;
      *((float *)&v14 + 1) = v16;
      uint64_t v32 = v14;
      uint64_t v33 = v14;
      double v22 = (y + height) * v8;
      float v23 = v12 + v22 + v10 * (x + width);
      if (v20)
      {
        *(float *)&uint64_t v33 = v19;
      }
      else if (!v21)
      {
        *(float *)&uint64_t v32 = v19;
      }
      if (v16 <= v23)
      {
        if (v16 >= v23) {
          goto LABEL_14;
        }
        unint64_t v24 = (unint64_t)&v32;
      }
      else
      {
        unint64_t v24 = (unint64_t)&v33;
      }
      *(float *)(v24 | 4) = v23;
LABEL_14:
      float v25 = v13 + v9 + v11 * v17;
      float v26 = v12 + v15 + v10 * v17;
      if (*(float *)&v33 <= v25)
      {
        if (*(float *)&v32 < v25) {
          *(float *)&uint64_t v32 = v25;
        }
      }
      else
      {
        *(float *)&uint64_t v33 = v25;
      }
      if (*((float *)&v33 + 1) <= v26)
      {
        if (*((float *)&v32 + 1) >= v26) {
          goto LABEL_23;
        }
        unint64_t v27 = (unint64_t)&v32;
      }
      else
      {
        unint64_t v27 = (unint64_t)&v33;
      }
      *(float *)(v27 | 4) = v26;
LABEL_23:
      float v28 = v13 + v18 + v11 * x;
      float v29 = v12 + v22 + v10 * x;
      if (*(float *)&v33 <= v28)
      {
        if (*(float *)&v32 < v28) {
          *(float *)&uint64_t v32 = v28;
        }
      }
      else
      {
        *(float *)&uint64_t v33 = v28;
      }
      if (*((float *)&v33 + 1) <= v29)
      {
        if (*((float *)&v32 + 1) >= v29) {
          return *(float *)&v33;
        }
        unint64_t v30 = (unint64_t)&v32;
      }
      else
      {
        unint64_t v30 = (unint64_t)&v33;
      }
      *(float *)(v30 | 4) = v29;
      return *(float *)&v33;
    }
  }
  return x;
}

BOOL CI::Affine::isIdentity(CI::Affine *this)
{
  return *(double *)this == 1.0
      && *((double *)this + 1) == 0.0
      && *((double *)this + 2) == 0.0
      && *((double *)this + 3) == 1.0
      && *((double *)this + 4) == 0.0
      && *((double *)this + 5) == 0.0;
}

uint64_t CI::ClampToAlphaNode::type(CI::ClampToAlphaNode *this)
{
  return 31;
}

uint64_t CI::PremultiplyNode::type(CI::PremultiplyNode *this)
{
  return 40;
}

uint64_t CI::SRGBNode::type(CI::SRGBNode *this)
{
  return 38;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SerialRectArray::roiData>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(120 * a2);
}

void std::vector<CI::SerialRectArray::roiData>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 120;
    v4 -= 120;
    std::construct_at[abi:nn180100]<CI::SerialRectArray::roiData,CI::SerialRectArray::roiData,CI::SerialRectArray::roiData*>(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

uint64_t std::__split_buffer<CI::SerialRectArray::roiData>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 120;
    std::__destroy_at[abi:nn180100]<CI::SerialRectArray::roiData,0>((void *)(i - 120));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void CI::AffineNode::roi_of_child(CI::AffineNode *this, CGRect a2)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  CI::Affine::inverse((CI::AffineNode *)((char *)this + 56), v6);
  v7.origin.CGFloat x = x;
  v7.origin.CGFloat y = y;
  v7.size.CGFloat width = width;
  v7.size.CGFloat height = height;
  CI::Affine::applyToRect((CI::Affine *)v6, v7);
}

double CI::Affine::inverse@<D0>(CI::Affine *this@<X0>, double *a2@<X8>)
{
  double v3 = *((double *)this + 1);
  double v4 = *((double *)this + 2);
  double v5 = *((double *)this + 3);
  double v6 = *(double *)this * v5 - v3 * v4;
  if (fabs(v6) >= 1.0e-10)
  {
    double v8 = 1.0 / v6;
    double v9 = v5 * v8;
    double v10 = *(double *)this * v8;
    double v12 = *((double *)this + 4);
    double v11 = *((double *)this + 5);
    *a2 = v9;
    a2[1] = v8 * -v3;
    a2[2] = -(v4 * v8);
    a2[3] = v10;
    double result = v3 * v8 * v12 - v10 * v11;
    a2[4] = v4 * v8 * v11 - v9 * v12;
    a2[5] = result;
  }
  else
  {
    x_log("Singular matrix cannot be inverted!\n");
    double result = 0.0;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
  }
  return result;
}

double CI::ColorKernelNode::roi_of_child(CI::ColorKernelNode *this, CGRect a2, uint64_t a3)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double y = a2.origin.y;
  double x = a2.origin.x;
  if ((a3 & 0x80000000) == 0 && **((_DWORD **)this + 7) > (int)a3)
  {
    if (!(*(unsigned int (**)(CI::ColorKernelNode *, uint64_t))(*(void *)this + 192))(this, a3))
    {
      uint64_t v11 = (*(uint64_t (**)(CI::ColorKernelNode *, uint64_t))(*(void *)this + 48))(this, a3);
      unsigned int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
      if (!CI::is_image_type(v12)) {
        return *MEMORY[0x1E4F1DB10];
      }
      return (*(double (**)(uint64_t))(*(void *)v11 + 168))(v11);
    }
    uint64_t v9 = *((void *)this + 12);
    if (v9)
    {
      (*(void (**)(uint64_t, uint64_t, double, double, double, double))(v9 + 16))(v9, a3, x, y, width, height);
      return v10;
    }
  }
  return x;
}

BOOL CI::ColorKernelNode::child_type_is_image(CI::ColorKernelNode *this, int a2)
{
  uint64_t v2 = **((unsigned int **)this + 7);
  if ((int)v2 < 1) {
    return 0;
  }
  unint64_t v5 = 0;
  int v6 = 0;
  for (uint64_t i = 24; ; i += 8)
  {
    uint64_t v8 = *((void *)this + 7);
    if (v5 > 9) {
      uint64_t v9 = (void *)(*(void *)(v8 + 16) + 8 * (v5 - 10));
    }
    else {
      uint64_t v9 = (void *)(v8 + i);
    }
    uint64_t v10 = *v9;
    if ((*(int (**)(void))(*(void *)*v9 + 16))(*v9) < 27
      || (*(int (**)(uint64_t))(*(void *)v10 + 16))(v10) > 52)
    {
      goto LABEL_10;
    }
    if (v6 == a2) {
      break;
    }
    ++v6;
LABEL_10:
    if (v2 == ++v5) {
      return 0;
    }
  }
  uint64_t v12 = *((void *)this + 6);
  if (*(unsigned char *)(v12 + 12)) {
    int v13 = CI::KernelArguments::count((CI::KernelArguments *)(v12 + 144));
  }
  else {
    int v13 = *(_DWORD *)(v12 + 20);
  }
  if (v13 <= (int)v5) {
    return 1;
  }
  uint64_t v14 = *((void *)this + 6);
  if (*(unsigned char *)(v14 + 12))
  {
    int type = CI::KernelArguments::get_type((CI::KernelArguments *)(v14 + 144), v5);
  }
  else if (*(_DWORD *)(v14 + 20) <= (int)v5)
  {
    int type = 0;
  }
  else
  {
    int type = *(_DWORD *)(*(void *)(v14 + 72) + 4 * v5);
  }
  return type != 4;
}

uint64_t CI::SurfaceNode::roiAlignment(CI::SurfaceNode *this)
{
  return 4;
}

uint64_t CI::CropImage::extent_unclamped(CI::CropImage *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 88))();
}

char *std::vector<unsigned long>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  double result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a2);
}

BOOL CI::parentROI::operator==(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2
      && *(_DWORD *)(a2 + 16) == *(_DWORD *)(a1 + 16)
      && *(_DWORD *)(a2 + 12) == *(_DWORD *)(a1 + 12)
      && *(_DWORD *)(a2 + 8) == *(_DWORD *)(a1 + 8)
      && *(_DWORD *)(a2 + 20) == *(_DWORD *)(a1 + 20);
}

char *std::vector<CI::parentROI>::__insert_with_size[abi:nn180100]<std::__wrap_iter<CI::parentROI const*>,std::__wrap_iter<CI::parentROI const*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  unint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  CGRect v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v12) >> 4)) < a5)
  {
    int v13 = *(void **)a1;
    unint64_t v14 = a5 - 0x5555555555555555 * ((uint64_t)(v12 - *(void *)a1) >> 4);
    if (v14 > 0x555555555555555) {
      abort();
    }
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((__dst - (uint64_t)v13) >> 4);
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v10 - (uint64_t)v13) >> 4);
    uint64_t v17 = 2 * v16;
    if (2 * v16 <= v14) {
      uint64_t v17 = v14;
    }
    if (v16 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v18 = 0x555555555555555;
    }
    else {
      unint64_t v18 = v17;
    }
    uint64_t v39 = v9;
    if (v18) {
      float v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::parentROI>>(v9, v18);
    }
    else {
      float v19 = 0;
    }
    float v29 = &v19[48 * v15];
    __p = v19;
    CGFloat v36 = v29;
    int v38 = &v19[48 * v18];
    unint64_t v30 = &v29[48 * a5];
    uint64_t v31 = 48 * a5;
    do
    {
      long long v32 = *(_OWORD *)v7;
      long long v33 = *((_OWORD *)v7 + 2);
      *((_OWORD *)v29 + 1) = *((_OWORD *)v7 + 1);
      *((_OWORD *)v29 + 2) = v33;
      *(_OWORD *)float v29 = v32;
      v29 += 48;
      v7 += 48;
      v31 -= 48;
    }
    while (v31);
    int v37 = v30;
    unint64_t v5 = (char *)std::vector<CI::parentROI>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v37 != v36) {
      int v37 = &v36[(v37 - v36 - 48) % 0x30uLL];
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v20 = v12 - __dst;
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - __dst) >> 4)) >= a5)
  {
    BOOL v21 = &__src[48 * a5];
    float v23 = *(char **)(v9 - 8);
LABEL_17:
    unint64_t v24 = &v5[48 * a5];
    float v25 = &v23[-48 * a5];
    float v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      float v26 = v23;
      do
      {
        long long v27 = *(_OWORD *)v25;
        long long v28 = *((_OWORD *)v25 + 2);
        *((_OWORD *)v26 + 1) = *((_OWORD *)v25 + 1);
        *((_OWORD *)v26 + 2) = v28;
        *(_OWORD *)float v26 = v27;
        v26 += 48;
        v25 += 48;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v5[48 * a5], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  BOOL v21 = &__src[16 * ((uint64_t)(v12 - __dst) >> 4)];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[16 * ((uint64_t)(v12 - __dst) >> 4)], a4 - v21);
  }
  float v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v20 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void *std::vector<CI::parentROI>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  unint64_t v5 = *(void **)(a2 + 8);
  int v6 = (char *)*a1;
  CGRect v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      long long v10 = *((_OWORD *)v8 - 3);
      long long v11 = *((_OWORD *)v8 - 1);
      CGRect v7 = (void *)(v9 - 48);
      *(_OWORD *)(v9 - 32) = *((_OWORD *)v8 - 2);
      *(_OWORD *)(v9 - 16) = v11;
      *(_OWORD *)(v9 - 48) = v10;
      v8 -= 48;
      v9 -= 48;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  unint64_t v12 = a1[1];
  uint64_t v13 = *(void *)(a2 + 16);
  int64_t v14 = v12 - __src;
  if (v12 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v12 - __src);
    CGRect v7 = *(void **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v13 + v14;
  unint64_t v15 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v15;
  unint64_t v16 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v16;
  uint64_t v17 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v17;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void CI::SerialRectArray::remove(CI::SerialRectArray *this, int a2)
{
  std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<CI::SerialRectArray::roiData *,CI::SerialRectArray::roiData *,CI::SerialRectArray::roiData *>((uint64_t)&v6, *(void *)this + 120 * a2 + 120, *((void *)this + 1), (_OWORD *)(*(void *)this + 120 * a2));
  uint64_t v4 = v3;
  unint64_t v5 = (void *)*((void *)this + 1);
  if (v5 != v3)
  {
    do
    {
      v5 -= 15;
      std::__destroy_at[abi:nn180100]<CI::SerialRectArray::roiData,0>(v5);
    }
    while (v5 != v4);
  }
  *((void *)this + 1) = v4;
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<CI::SerialRectArray::roiData *,CI::SerialRectArray::roiData *,CI::SerialRectArray::roiData *>(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    long long v7 = *(_OWORD *)(v5 + 16);
    *a4 = *(_OWORD *)v5;
    a4[1] = v7;
    std::vector<CI::KernelArgumentType>::__move_assign((uint64_t)(a4 + 2), (__n128 *)(v5 + 32));
    std::vector<CI::KernelArgumentType>::__move_assign((uint64_t)a4 + 56, (__n128 *)(v5 + 56));
    a4[5] = *(_OWORD *)(v5 + 80);
    std::vector<CI::KernelArgumentType>::__move_assign((uint64_t)(a4 + 6), (__n128 *)(v5 + 96));
    a4 = (_OWORD *)((char *)a4 + 120);
    v5 += 120;
  }
  while (v5 != v6);
  return v6;
}

double CI::ClampImage::extent(CI::ClampImage *this)
{
  return *MEMORY[0x1E4F1DB10];
}

uint64_t CI::NodeWithChild::alpha_one(CI::NodeWithChild *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 264))();
}

uint64_t CI::ColorKernelNode::alpha_one(CI::ColorKernelNode *this)
{
  if (*((unsigned char *)this + 104)) {
    return 1;
  }
  if (!*(unsigned char *)(*((void *)this + 6) + 162)) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(CI::ColorKernelNode *, void))(*(void *)this + 48))(this, 0);
  if (result)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)result + 264);
    return v2();
  }
  return result;
}

double CI::ClampImage::extent_unclamped(CI::ClampImage *this)
{
  return *((double *)this + 15);
}

uint64_t CI_PRINT_TREE_graphviz()
{
  if (CI_PRINT_TREE_graphviz::didCheck != -1) {
    dispatch_once(&CI_PRINT_TREE_graphviz::didCheck, &__block_literal_global_61_0);
  }
  return CI_PRINT_TREE_graphviz::v;
}

void sub_193680D70(_Unwind_Exception *a1)
{
  CI::Object::unref(v1);
  _Unwind_Resume(a1);
}

void CI::GraphObject::traverse_stoppable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v21 = a1;
  if (a1)
  {
    unint64_t v18 = 0;
    float v19 = 0;
    uint64_t v20 = 0;
    *(void *)&long long v15 = 0;
    LODWORD(v14) = 0;
    unsigned int v17 = 0;
    std::stack<CI::TraverseVisit,std::vector<CI::TraverseVisit>>::emplace[abi:nn180100]<CI::GraphObject *&,decltype(nullptr),int,int>((void **)&v18, &v21, (uint64_t)&v15, (int *)&v14, (int *)&v17);
    uint64_t v8 = v19;
    while (v8 != v18)
    {
      long long v9 = *(v8 - 1);
      long long v15 = *(v8 - 2);
      long long v16 = v9;
      if (BYTE8(v9))
      {
        (*(void (**)(uint64_t, void, void, void, void))(a6 + 16))(a6, v15, *((void *)&v15 + 1), v9, DWORD1(v9));
        long long v10 = v19;
      }
      else
      {
        char v11 = (*(uint64_t (**)(uint64_t, void, void, void, void))(a5 + 16))(a5, v15, *((void *)&v15 + 1), v9, DWORD1(v9));
        long long v10 = v19;
        if ((v11 & 1) == 0)
        {
          *((unsigned char *)v19 - 8) = 1;
          unsigned int v17 = 0;
          if ((*(int (**)(void))(*(void *)v15 + 40))(v15) >= 1)
          {
            do
            {
              uint64_t v14 = 0;
              uint64_t v14 = (*(uint64_t (**)(void, void))(*(void *)v15 + 48))(v15, v17);
              int v13 = v16 + 1;
              std::stack<CI::TraverseVisit,std::vector<CI::TraverseVisit>>::emplace[abi:nn180100]<CI::GraphObject *&,CI::GraphObject *&,int &,int &>((void **)&v18, &v14, (uint64_t *)&v15, &v13, (int *)&v17);
              int v12 = ++v17;
            }
            while (v12 < (*(int (**)(void))(*(void *)v15 + 40))(v15));
          }
          uint64_t v8 = v19;
          continue;
        }
      }
      uint64_t v8 = v10 - 2;
      float v19 = v10 - 2;
    }
    if (v8)
    {
      float v19 = v8;
      operator delete(v8);
    }
  }
}

uint64_t CI::NodeWithChild::child_count(CI::NodeWithChild *this)
{
  return 1;
}

uint64_t CI::ImageWithChild::child_count(CI::ImageWithChild *this)
{
  return 1;
}

uint64_t CI::ImageWithChild::child(CI::ImageWithChild *this, int a2)
{
  if (a2) {
    return 0;
  }
  else {
    return *((void *)this + 13);
  }
}

uint64_t ___ZN2CI4Node15traverse_uniqueEU13block_pointerFvPS0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN2CI11GraphObject15traverse_uniqueEPS0_U13block_pointerFvS1_iE_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return (*(uint64_t (**)(uint64_t))(v1 + 16))(v1);
}

BOOL ___ZN2CI11GraphObject15traverse_uniqueEPS0_U13block_pointerFvS1_iE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  double v3 = std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), &v5);
  if (!v3) {
    std::__hash_table<CI::Node const*,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,std::allocator<CI::Node const*>>::__emplace_unique_key_args<CI::Node const*,CI::Node const* const&>(*(void *)(*(void *)(a1 + 32) + 8) + 40, &v5, &v5);
  }
  return v3 != 0;
}

void *std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  uint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<CI::Node const*,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,std::allocator<CI::Node const*>>::__emplace_unique_key_args<CI::Node const*,CI::Node const* const&>(uint64_t a1, void *a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    char v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x18uLL);
  *uint64_t i = 0;
  i[1] = v8;
  i[2] = *a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>(a1, v19);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v20 = *(void *)a1;
  uint64_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *uint64_t i = *v21;
LABEL_38:
    *uint64_t v21 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9) {
        v22 %= v9;
      }
    }
    else
    {
      v22 &= v9 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

uint64_t ___ZN2CI11GraphObject15traverse_uniqueEPKS0_U13block_pointerFvS2_iE_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return (*(uint64_t (**)(uint64_t))(v1 + 16))(v1);
}

BOOL ___ZN2CI11GraphObject15traverse_uniqueEPKS0_U13block_pointerFvS2_iE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  unint64_t v3 = std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), &v5);
  if (!v3) {
    std::__hash_table<CI::Node const*,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,std::allocator<CI::Node const*>>::__emplace_unique_key_args<CI::Node const*,CI::Node const* const&>(*(void *)(*(void *)(a1 + 32) + 8) + 40, &v5, &v5);
  }
  return v3 != 0;
}

void CI::Node::clear_rois(CI::Node *this)
{
  uint64_t v1 = (void *)*((void *)this + 2);
  unint64_t v3 = (void *)*v1;
  for (uint64_t i = (void *)v1[1]; i != v3; std::__destroy_at[abi:nn180100]<CI::SerialRectArray::roiData,0>(i))
    i -= 15;
  v1[1] = v3;
}

uint64_t CI::SurfaceNode::child_count(CI::SurfaceNode *this)
{
  return 0;
}

uint64_t ___ZNK2CI5Image15traverse_uniqueEU13block_pointerFvPKS0_iE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

unint64_t ___ZN2CIL37traverse_node_graph_gathering_digestsEPKNS_7ContextEPNS_4NodeE_block_invoke(uint64_t a1, void *a2)
{
  XXH64_reset(v13, 0);
  LOBYTE(__src[0]) = (*(uint64_t (**)(void *))(*a2 + 16))(a2);
  XXH64_update((uint64_t)v13, (char *)__src, 1uLL);
  __src[0] = (*(double (**)(void *))(*a2 + 160))(a2);
  __src[1] = v4;
  __src[2] = v5;
  __src[3] = v6;
  XXH64_update((uint64_t)v13, (char *)__src, 0x20uLL);
  (*(void (**)(void *, int64x2_t *, void))(*a2 + 376))(a2, v13, *(void *)(*(void *)(a1 + 32) + 152));
  int v7 = (*(uint64_t (**)(void *))(*a2 + 40))(a2);
  if (v7 >= 1)
  {
    int v8 = v7;
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(void *)(*(uint64_t (**)(void *, uint64_t))(*a2 + 48))(a2, v9);
      __src[0] = (*(uint64_t (**)(void))(v10 + 384))();
      XXH64_update((uint64_t)v13, (char *)__src, 8uLL);
      uint64_t v9 = (v9 + 1);
    }
    while (v8 != v9);
  }
  unint64_t result = XXH64_digest((uint64_t)v13);
  a2[3] = result;
  return result;
}

void ___ZN2CIL30_gather_rois_for_program_graphEPNS_7ContextEPKcPNS_11ProgramNodeE6CGRecttRm_block_invoke(int a1, CI::Node *this)
{
}

uint64_t CI::Node::add_args_to_hash(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 88))();
}

uint64_t CI::Node::digest(CI::Node *this)
{
  return *((void *)this + 3);
}

uint64_t ___ZNK2CI5Image18traverse_stoppableEU13block_pointerFbPKS0_S2_EU13block_pointerFvS2_S2_E_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZNK2CI5Image18traverse_stoppableEU13block_pointerFbPKS0_S2_EU13block_pointerFvS2_S2_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN2CI21prepare_initial_graphEPNS_7ContextEPKcPNS_5ImageEPKNS_17RenderDestinationE6CGRectP12CGColorSpaceNS_11PixelFormatENS_19output_swizzle_infoERKNS_6AffineEbPNS_17TextureDescriptorE_block_invoke_4(void *a1, void *a2)
{
  return CI::Image::render_graph_early_out(a2, (uint64_t)(a1 + 4), a1[7] + 56, a1[8], a1[9]);
}

void ___ZN2CI21prepare_initial_graphEPNS_7ContextEPKcPNS_5ImageEPKNS_17RenderDestinationE6CGRectP12CGColorSpaceNS_11PixelFormatENS_19output_swizzle_infoERKNS_6AffineEbPNS_17TextureDescriptorE_block_invoke_22(uint64_t *a1, void *a2)
{
}

void CI::Image::add_render_graph_to_map(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  char v11 = *(void **)(a6 + 8);
  uint64_t v9 = (void *)(a6 + 8);
  uint64_t v10 = v11;
  if (!v11) {
    goto LABEL_12;
  }
  unint64_t v12 = a1[10];
  unint64_t v13 = v9;
  do
  {
    unint64_t v14 = v10[4];
    BOOL v15 = v14 >= v12;
    if (v14 >= v12) {
      BOOL v16 = v10;
    }
    else {
      BOOL v16 = v10 + 1;
    }
    if (v15) {
      unint64_t v13 = v10;
    }
    uint64_t v10 = (void *)*v16;
  }
  while (*v16);
  if (v13 != v9 && v12 >= v13[4]) {
    uint64_t v17 = *((unsigned int *)v13 + 10);
  }
  else {
LABEL_12:
  }
    uint64_t v17 = 0;
  unint64_t v18 = (CI::Object *)(*(uint64_t (**)(void *, uint64_t, uint64_t *, uint64_t, uint64_t, void *))(*a1 + 176))(a1, a2, a4, a5, v17, v9);
  if (CI_DISABLE_MERGING()) {
    CI::NoopNode::append_to_tree_and_unref();
  }
  if ((int)v17 < 2)
  {
    CI::ImageToNodeMap::add(a4, a3, (uint64_t)a1, v18);
    if (!v18) {
      return;
    }
  }
  else
  {
    (*(void (**)(CI::Object *))(*(void *)v18 + 184))(v18);
    CI::ImageToNodeMap::add(a4, a3, (uint64_t)a1, v18);
  }

  CI::Object::unref(v18);
}

uint64_t CI::Image::render_graph_early_out(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = *(void **)(a3 + 8);
  if (v8)
  {
    unint64_t v9 = a1[10];
    uint64_t v10 = (void *)(a3 + 8);
    do
    {
      unint64_t v11 = v8[4];
      BOOL v12 = v11 >= v9;
      if (v11 >= v9) {
        unint64_t v13 = v8;
      }
      else {
        unint64_t v13 = v8 + 1;
      }
      if (v12) {
        uint64_t v10 = v8;
      }
      int v8 = (void *)*v13;
    }
    while (*v13);
    if (v10 != (void *)(a3 + 8) && v10[4] <= v9) {
      return 1;
    }
  }
  double v14 = CI::Image::lookup_union_roi((uint64_t)a1, a4);
  uint64_t v20 = *(void **)(a5 + 8);
  size_t v19 = (void *)(a5 + 8);
  unint64_t v18 = v20;
  if (!v20) {
    goto LABEL_23;
  }
  unint64_t v21 = a1[10];
  unint64_t v22 = v19;
  do
  {
    unint64_t v23 = v18[4];
    BOOL v24 = v23 >= v21;
    if (v23 >= v21) {
      float v25 = v18;
    }
    else {
      float v25 = v18 + 1;
    }
    if (v24) {
      unint64_t v22 = v18;
    }
    unint64_t v18 = (void *)*v25;
  }
  while (*v25);
  if (v22 != v19 && v21 >= v22[4]) {
    BOOL v26 = *((_DWORD *)v22 + 10) != 0;
  }
  else {
LABEL_23:
  }
    BOOL v26 = 0;
  if (CGRectIsEmpty(*(CGRect *)&v14) || !v26) {
LABEL_29:
  }
    operator new();
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 264))(a1);
  if (result)
  {
    if ((*(unsigned int (**)(void *))(*a1 + 40))(a1) == 1)
    {
      BOOL v28 = CI::Image::roi_of_child_intersects_extent((uint64_t)a1, a4, 0);
      uint64_t result = 0;
      if (!v28) {
        goto LABEL_29;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

double CI::Image::lookup_union_roi(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a2 + 8);
  int8x8_t v2 = (void *)(a2 + 8);
  unint64_t v3 = v4;
  uint64_t v5 = (void *)MEMORY[0x1E4F1DB20];
  if (v4)
  {
    unint64_t v6 = *(void *)(a1 + 80);
    int v7 = v2;
    do
    {
      unint64_t v8 = v3[4];
      BOOL v9 = v8 >= v6;
      if (v8 >= v6) {
        uint64_t v10 = v3;
      }
      else {
        uint64_t v10 = v3 + 1;
      }
      if (v9) {
        int v7 = v3;
      }
      unint64_t v3 = (void *)*v10;
    }
    while (*v10);
    if (v7 != v2 && v6 >= v7[4]) {
      uint64_t v5 = v7 + 5;
    }
  }
  return *(double *)v5;
}

uint64_t CI_DISABLE_MERGING()
{
  {
    CI_DISABLE_MERGING::v = get_BOOL("CI_DISABLE_MERGING", 0);
  }
  return CI_DISABLE_MERGING::v;
}

void sub_193681B1C(_Unwind_Exception *a1)
{
}

BOOL CI::Image::roi_of_child_intersects_extent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v5 = CI::Image::lookup_union_roi(a1, a2);
  CGFloat v6 = (*(double (**)(uint64_t, uint64_t, double))(*(void *)a1 + 80))(a1, a3, v5);
  CGFloat v8 = v7;
  CGFloat v10 = v9;
  CGFloat v12 = v11;
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 48))(a1, a3);
  v20.origin.double x = (*(double (**)(uint64_t))(*(void *)v13 + 88))(v13);
  v20.origin.double y = v14;
  v20.size.double width = v15;
  v20.size.double height = v16;
  v18.origin.double x = v6;
  v18.origin.double y = v8;
  v18.size.double width = v10;
  v18.size.double height = v12;
  CGRect v19 = CGRectIntersection(v18, v20);
  return !CGRectIsEmpty(v19);
}

void CI::Image::region_of_child(CI::Image *this, CGRect a2, uint64_t a3)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double y = a2.origin.y;
  double x = a2.origin.x;
  if (!CGRectIsEmpty(a2))
  {
    v36.origin.double x = (*(double (**)(CI::Image *, uint64_t, double, double, double, double))(*(void *)this
                                                                                                  + 80))(this, a3, x, y, width, height);
    v36.origin.double y = v9;
    v36.size.double width = v10;
    v36.size.double height = v11;
    uint64_t v12 = (*(uint64_t (**)(CI::Image *, uint64_t))(*(void *)this + 48))(this, a3);
    CGFloat v13 = (*(double (**)(uint64_t))(*(void *)v12 + 88))(v12);
    CGFloat v15 = v14;
    CGFloat v17 = v16;
    CGFloat v19 = v18;
    CGFloat v20 = (*(double (**)(uint64_t))(*(void *)v12 + 96))(v12);
    CGFloat v22 = v21;
    CGFloat v24 = v23;
    CGFloat v26 = v25;
    v37.origin.double x = v13;
    v37.origin.double y = v15;
    v37.size.double width = v17;
    v37.size.double height = v19;
    if (CGRectIsInfinite(v37)
      && (v38.origin.double x = v20,
          v38.origin.double y = v22,
          v38.size.double width = v24,
          v38.size.double height = v26,
          !(BOOL IsInfinite = CGRectIsInfinite(v38))))
    {
      v44.origin.double x = v20;
      v44.origin.double y = v22;
      v44.size.double width = v24;
      v44.size.double height = v26;
      CI::ClampNode::adjust_roi_for_clamp_rect((CI::ClampNode *)IsInfinite, v36, v44);
    }
    else
    {
      v39.origin.double x = v13;
      v39.origin.double y = v15;
      v39.size.double width = v17;
      v39.size.double height = v19;
      CGRect v43 = CGRectInset(v39, -1.0, -1.0);
      CGRect v40 = CGRectIntersection(v36, v43);
      CGFloat v28 = v40.origin.x;
      CGFloat v29 = v40.origin.y;
      CGFloat v30 = v40.size.width;
      CGFloat v31 = v40.size.height;
      if (CGRectIsEmpty(v40)) {
        return;
      }
      v41.origin.double x = v28;
      v41.origin.double y = v29;
      v41.size.double width = v30;
      v41.size.double height = v31;
      if (CGRectIsInfinite(v41)) {
        return;
      }
      v42.origin.double x = v28;
      v42.origin.double y = v29;
      v42.size.double width = v30;
      v42.size.double height = v31;
      *(CGRect *)&uint64_t v32 = CGRectInset(v42, 0.001, 0.001);
    }
    CGRectIntegral(*(CGRect *)&v32);
  }
}

uint64_t **___ZN2CIL26traverse_gathering_digestsEPKNS_7ContextEPNS_5ImageERNSt3__13mapINS_10ImageIndexENS_30ImageDigestForRenderGraphCacheENS5_4lessIS7_EENS5_9allocatorINS5_4pairIKS7_S8_EEEEEE_block_invoke(uint64_t a1, _DWORD *a2, int a3)
{
  XXH64_reset(v26, 0);
  LOBYTE(v25[0]) = (*(uint64_t (**)(_DWORD *))(*(void *)a2 + 16))(a2);
  XXH64_update((uint64_t)v26, (char *)v25, 1uLL);
  v25[0] = COERCE__DWORD_((*(double (**)(_DWORD *))(*(void *)a2 + 88))(a2));
  v25[1] = v6;
  v25[2] = v7;
  v25[3] = v8;
  XXH64_update((uint64_t)v26, (char *)v25, 0x20uLL);
  LODWORD(v25[0]) = (*(uint64_t (**)(_DWORD *))(*(void *)a2 + 40))(a2);
  XXH64_update((uint64_t)v26, (char *)v25, 4uLL);
  LODWORD(v25[0]) = a3;
  XXH64_update((uint64_t)v26, (char *)v25, 4uLL);
  (*(void (**)(_DWORD *, int64x2_t *, uint64_t))(*(void *)a2 + 104))(a2, v26, 1);
  int v9 = (*(uint64_t (**)(_DWORD *))(*(void *)a2 + 40))(a2);
  if (v9 >= 1)
  {
    int v10 = v9;
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v13 = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)a2 + 48))(a2, v11);
      uint64_t v16 = *(void *)(v12 + 8);
      uint64_t v15 = v12 + 8;
      uint64_t v14 = v16;
      if (!v16) {
        goto LABEL_14;
      }
      unsigned int v17 = *(_DWORD *)(v13 + 100);
      uint64_t v18 = v15;
      do
      {
        unsigned int v19 = *(_DWORD *)(v14 + 32);
        BOOL v20 = v19 >= v17;
        if (v19 >= v17) {
          double v21 = (uint64_t *)v14;
        }
        else {
          double v21 = (uint64_t *)(v14 + 8);
        }
        if (v20) {
          uint64_t v18 = v14;
        }
        uint64_t v14 = *v21;
      }
      while (*v21);
      if (v18 == v15 || v17 < *(_DWORD *)(v18 + 32)) {
LABEL_14:
      }
        uint64_t v18 = v15;
      v25[0] = *(_DWORD **)(v18 + 40);
      XXH64_update((uint64_t)v26, (char *)v25, 8uLL);
      uint64_t v11 = (v11 + 1);
    }
    while (v11 != v10);
  }
  unint64_t v22 = XXH64_digest((uint64_t)v26);
  double v23 = *(uint64_t ***)(a1 + 32);
  v25[0] = a2 + 25;
  uint64_t result = std::__tree<std::__value_type<CI::NodeIndex,unsigned long>,std::__map_value_compare<CI::NodeIndex,std::__value_type<CI::NodeIndex,unsigned long>,std::less<CI::NodeIndex>,true>,std::allocator<std::__value_type<CI::NodeIndex,unsigned long>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v23, a2 + 25, (uint64_t)&std::piecewise_construct, v25);
  result[5] = (uint64_t *)v22;
  return result;
}

uint64_t **std::__tree<std::__value_type<CI::NodeIndex,unsigned long>,std::__map_value_compare<CI::NodeIndex,std::__value_type<CI::NodeIndex,unsigned long>,std::less<CI::NodeIndex>,true>,std::allocator<std::__value_type<CI::NodeIndex,unsigned long>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  double v7 = a1 + 1;
  CGFloat v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        CGFloat v6 = *v9;
        double v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      CGFloat v6 = v9[1];
      if (!v6)
      {
        double v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    v11[8] = **a4;
    *((void *)v11 + 5) = 0;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

double CI::CropImage::extent(CI::CropImage *this)
{
  (*(void (**)(void))(**((void **)this + 13) + 88))(*((void *)this + 13));
  uint64_t v6 = *((void *)this + 15);
  uint64_t v7 = *((void *)this + 16);
  uint64_t v8 = *((void *)this + 17);
  uint64_t v9 = *((void *)this + 18);

  *(void *)&double result = (unint64_t)CGRectIntersection(*(CGRect *)&v2, *(CGRect *)&v6);
  return result;
}

double CI::AffineImage::extent(CI::AffineImage *this)
{
  uint64_t v1 = (CI::AffineImage *)((char *)this + 120);
  (*(void (**)(void))(**((void **)this + 13) + 88))(*((void *)this + 13));

  return CI::Affine::applyToRect(v1, *(CGRect *)&v2);
}

double CI::ColorKernelImage::extent(CI::ColorKernelImage *this)
{
  return *((double *)this + 16);
}

uint64_t CI::ImageWithChild::extent(CI::ImageWithChild *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 88))();
}

_DWORD *CI::SurfaceImage::extent(_DWORD *this)
{
  if (!this[46]) {
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)this + 96))(this);
  }
  return this;
}

double CI::SurfaceImage::extent_unclamped(IOSurfaceRef *this)
{
  return 0.0;
}

uint64_t ___ZN2CIL22prune_input_sRGB_nodesEPKNS_7ContextEPNS_4NodeE_block_invoke(uint64_t a1, CI::Object *a2)
{
  uint64_t v4 = (unsigned int *)(*(uint64_t (**)(CI::Object *))(*(void *)a2 + 400))(a2);
  if (v4
    && (*(unsigned int (**)(void, void, uint64_t))(**(void **)(a1 + 56) + 584))(*(void *)(a1 + 56), *v4, 1))
  {
    uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    return CI::SerialObjectPtrArray::append(v5, a2);
  }
  BOOL v7 = (*(unsigned int (**)(CI::Object *))(*(void *)a2 + 16))(a2) == 38 && *((_DWORD *)a2 + 14) == -1;
  uint64_t result = (*(uint64_t (**)(CI::Object *))(*(void *)a2 + 40))(a2);
  if ((int)result >= 1)
  {
    int v8 = result;
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = (*(uint64_t (**)(CI::Object *, uint64_t))(*(void *)a2 + 48))(a2, v9);
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
      if (result != 47) {
        goto LABEL_26;
      }
      uint64_t v11 = *(unsigned int **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)v10 + 48))(v10, 0);
      uint64_t v12 = *v11;
      if ((int)v12 < 1) {
        goto LABEL_26;
      }
      unint64_t v13 = 0;
      uint64_t v14 = v11 + 6;
      while (1)
      {
        uint64_t v15 = v14;
        if (v13 >= 0xA) {
          uint64_t v15 = (unsigned int *)(*((void *)v11 + 2) + 8 * (v13 - 10));
        }
        if (*(void *)v15 == result) {
          break;
        }
        ++v13;
        v14 += 2;
        if (v12 == v13) {
          goto LABEL_26;
        }
      }
      if ((v13 & 0x80000000) != 0)
      {
LABEL_26:
        BOOL v17 = 0;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 408))(v10);
        BOOL v17 = result == 1 || (result & 0xFFFFFFFE) == 10;
      }
      uint64_t v18 = *(unsigned int **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      uint64_t v19 = *v18;
      if ((int)v19 < 1)
      {
LABEL_33:
        BOOL v23 = 0;
      }
      else
      {
        unint64_t v20 = 0;
        double v21 = v18 + 6;
        while (1)
        {
          unint64_t v22 = v21;
          if (v20 >= 0xA) {
            unint64_t v22 = (unsigned int *)(*((void *)v18 + 2) + 8 * (v20 - 10));
          }
          if (*(void *)v22 == v10) {
            break;
          }
          ++v20;
          v21 += 2;
          if (v19 == v20) {
            goto LABEL_33;
          }
        }
        BOOL v23 = (v20 & 0x80000000) == 0;
      }
      if (!v17 && !v23) {
        goto LABEL_56;
      }
      if (v7)
      {
        uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        uint64_t v24 = *(unsigned int *)result;
        if ((int)v24 >= 1)
        {
          unint64_t v25 = 0;
          CGFloat v26 = (CI::Object **)(result + 24);
          while (1)
          {
            long long v27 = v26;
            if (v25 >= 0xA) {
              long long v27 = (CI::Object **)(*(void *)(result + 16) + 8 * (v25 - 10));
            }
            if (*v27 == a2) {
              break;
            }
            ++v25;
            ++v26;
            if (v24 == v25) {
              goto LABEL_52;
            }
          }
          if ((v25 & 0x80000000) == 0) {
            goto LABEL_56;
          }
        }
LABEL_52:
        uint64_t v32 = a2;
      }
      else
      {
        uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
        uint64_t v28 = *(unsigned int *)result;
        if ((int)v28 >= 1)
        {
          unint64_t v29 = 0;
          CGFloat v30 = (void *)(result + 24);
          while (1)
          {
            CGFloat v31 = v30;
            if (v29 >= 0xA) {
              CGFloat v31 = (void *)(*(void *)(result + 16) + 8 * (v29 - 10));
            }
            if (*v31 == v10) {
              break;
            }
            ++v29;
            ++v30;
            if (v28 == v29) {
              goto LABEL_54;
            }
          }
          if ((v29 & 0x80000000) == 0) {
            goto LABEL_56;
          }
        }
LABEL_54:
        uint64_t v32 = (CI::Object *)v10;
      }
      uint64_t result = CI::SerialObjectPtrArray::append(result, v32);
LABEL_56:
      uint64_t v9 = (v9 + 1);
    }
    while (v9 != v8);
  }
  return result;
}

uint64_t CI::Node::texture_bindable(CI::Node *this)
{
  return 0;
}

uint64_t CI::SurfaceImage::child_count(CI::SurfaceImage *this)
{
  return 0;
}

uint64_t CI::ImageWithChild::render_graph_core(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void **)(a3 + 8);
  unint64_t v3 = (void *)(a3 + 8);
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  unint64_t v6 = *(void *)(a1[13] + 80);
  BOOL v7 = v3;
  do
  {
    unint64_t v8 = v4[4];
    BOOL v9 = v8 >= v6;
    if (v8 >= v6) {
      uint64_t v10 = v4;
    }
    else {
      uint64_t v10 = v4 + 1;
    }
    if (v9) {
      BOOL v7 = v4;
    }
    uint64_t v4 = (void *)*v10;
  }
  while (*v10);
  if (v7 != v3 && v7[4] <= v6) {
    uint64_t v11 = v7[5];
  }
  else {
LABEL_12:
  }
    uint64_t v11 = 0;
  return (*(uint64_t (**)(void *, uint64_t, uint64_t))(*a1 + 320))(a1, a2, v11);
}

uint64_t ___ZN2CI28traverse_releasing_resourcesEPNS_4NodeE_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 216))(a2);
}

uint64_t CI::ImageWithChild::is_empty_if_regions_of_children_are_empty(CI::ImageWithChild *this)
{
  return 1;
}

void CI::GraphObject::traverse_preorder_stoppable(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  uint64_t v22 = a2;
  uint64_t v23 = a1;
  int v20 = a4;
  int v21 = a3;
  if (a1)
  {
    BOOL v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    std::vector<CI::TraverseVisit>::reserve(&v17, 0x40uLL);
    std::vector<CI::TraverseVisit>::vector(&v15, (uint64_t)&v17);
    std::stack<CI::TraverseVisit,std::vector<CI::TraverseVisit>>::emplace[abi:nn180100]<CI::GraphObject *&,CI::GraphObject *&,int &,int &>((void **)&v15, &v23, &v22, &v21, &v20);
    for (uint64_t i = v16; v16 != v15; uint64_t i = v16)
    {
      long long v7 = *((_OWORD *)i - 1);
      long long v13 = *((_OWORD *)i - 2);
      long long v14 = v7;
      uint64_t v16 = i - 32;
      if (((*(uint64_t (**)(uint64_t, void, void, void, void))(a5 + 16))(a5, v13, *((void *)&v13 + 1), v7, DWORD1(v7)) & 1) == 0)
      {
        int v12 = 0;
        int v8 = (*(uint64_t (**)(void))(*(void *)v13 + 40))(v13);
        int v12 = v8 - 1;
        if (v8 >= 1)
        {
          do
          {
            uint64_t v11 = (*(uint64_t (**)(void))(*(void *)v13 + 48))(v13);
            int v10 = v14 + 1;
            std::stack<CI::TraverseVisit,std::vector<CI::TraverseVisit>>::emplace[abi:nn180100]<CI::GraphObject *&,CI::GraphObject *&,int &,int &>((void **)&v15, &v11, (uint64_t *)&v13, &v10, &v12);
            int v9 = v12--;
          }
          while (v9 > 0);
        }
      }
    }
    if (i)
    {
      uint64_t v16 = i;
      operator delete(i);
    }
    if (v17)
    {
      uint64_t v18 = v17;
      operator delete(v17);
    }
  }
}

uint64_t CI::NodeWithChild::child(CI::NodeWithChild *this, int a2)
{
  if (a2) {
    return 0;
  }
  else {
    return *((void *)this + 5);
  }
}

char *std::stack<CI::TraverseVisit,std::vector<CI::TraverseVisit>>::emplace[abi:nn180100]<CI::GraphObject *&,CI::GraphObject *&,int &,int &>(void **a1, void *a2, uint64_t *a3, int *a4, int *a5)
{
  int v12 = a1[2];
  uint64_t v10 = (uint64_t)(a1 + 2);
  uint64_t v11 = v12;
  unint64_t v13 = *(void *)(v10 - 8);
  if (v13 >= (unint64_t)v12)
  {
    uint64_t v18 = (uint64_t)(v13 - (void)*a1) >> 5;
    unint64_t v19 = v18 + 1;
    if ((unint64_t)(v18 + 1) >> 59) {
      abort();
    }
    uint64_t v20 = v11 - (unsigned char *)*a1;
    if (v20 >> 4 > v19) {
      unint64_t v19 = v20 >> 4;
    }
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v21 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v21 = v19;
    }
    uint64_t v22 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(v10, v21);
    uint64_t v23 = &v22[32 * v18];
    unint64_t v25 = &v22[32 * v24];
    uint64_t v26 = *a3;
    int v27 = *a4;
    int v28 = *a5;
    *(void *)uint64_t v23 = *a2;
    *((void *)v23 + 1) = v26;
    *((_DWORD *)v23 + 4) = v27;
    *((_DWORD *)v23 + 5) = v28;
    v23[24] = 0;
    BOOL v17 = v23 + 32;
    CGFloat v30 = (char *)*a1;
    unint64_t v29 = (char *)a1[1];
    if (v29 != *a1)
    {
      do
      {
        long long v31 = *((_OWORD *)v29 - 2);
        *(_OWORD *)(v23 - 23) = *(_OWORD *)(v29 - 23);
        *((_OWORD *)v23 - 2) = v31;
        v23 -= 32;
        v29 -= 32;
      }
      while (v29 != v30);
      unint64_t v29 = (char *)*a1;
    }
    *a1 = v23;
    a1[1] = v17;
    a1[2] = v25;
    if (v29) {
      operator delete(v29);
    }
  }
  else
  {
    uint64_t v14 = *a3;
    int v15 = *a4;
    int v16 = *a5;
    *(void *)unint64_t v13 = *a2;
    *(void *)(v13 + 8) = v14;
    *(_DWORD *)(v13 + 16) = v15;
    *(_DWORD *)(v13 + 20) = v16;
    *(unsigned char *)(v13 + 24) = 0;
    BOOL v17 = (char *)(v13 + 32);
  }
  a1[1] = v17;
  return v17 - 32;
}

uint64_t ___ZN2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPS0_PKS0_iiE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZNK2CI11ProgramNode33traverse_graph_preorder_stoppableEU13block_pointerFbPNS_4NodeEPKS1_iiiE_block_invoke(void *a1, uint64_t a2, uint64_t a3, int a4, char a5)
{
  uint64_t v6 = a1[6];
  *(unsigned char *)(*(void *)(*(void *)(a1[5] + 8) + 24) + a4) = a5 + 48;
  *(unsigned char *)(*(void *)(*(void *)(a1[5] + 8) + 24) + a4 + 1) = 0;
  int IndexOfString = CI::SerialStringArray::firstIndexOfString(*(CI::SerialStringArray **)(v6 + 56), (const char *)(*(void *)(*(void *)(a1[5] + 8) + 24) + 1));
  LODWORD(result) = (*(uint64_t (**)(void))(a1[4] + 16))();
  if (IndexOfString == -1) {
    return result;
  }
  else {
    return 1;
  }
}

uint64_t ___ZNK2CI5Image27traverse_preorder_stoppableEU13block_pointerFbPKS0_S2_iiE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZNK2CI5Image27traverse_preorder_stoppableEU13block_pointerFbPKS0_S2_iiE_block_invoke_0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZNK2CI11ProgramNode21compute_kernel_digestEPKNS_7ContextE_block_invoke(void *a1, CI::Node *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v9 = (void *)a1[7];
  uint64_t v10 = *(void *)(a1[4] + 8);
  uint64_t v11 = (uint64_t *)((char *)a2 + 36);
  uint64_t v14 = *(void *)(v10 + 48);
  uint64_t v12 = v10 + 48;
  uint64_t v13 = v14;
  if (!v14) {
    goto LABEL_12;
  }
  unsigned int v15 = *(_DWORD *)v11;
  uint64_t v16 = v12;
  do
  {
    unsigned int v17 = *(_DWORD *)(v13 + 32);
    BOOL v18 = v17 >= v15;
    if (v17 >= v15) {
      unint64_t v19 = (uint64_t *)v13;
    }
    else {
      unint64_t v19 = (uint64_t *)(v13 + 8);
    }
    if (v18) {
      uint64_t v16 = v13;
    }
    uint64_t v13 = *v19;
  }
  while (*v19);
  if (v16 != v12 && v15 >= *(_DWORD *)(v16 + 32))
  {
    unint64_t v21 = *(uint64_t **)(v16 + 40);
  }
  else
  {
LABEL_12:
    uint64_t v20 = *(void *)(a1[5] + 8);
    unint64_t v21 = (uint64_t *)(*(void *)(v20 + 24) + 1);
    *(void *)(v20 + 24) = v21;
    uint64_t v22 = (uint64_t **)(*(void *)(a1[4] + 8) + 40);
    uint64_t __src = v11;
    std::__tree<std::__value_type<CI::NodeIndex,unsigned long>,std::__map_value_compare<CI::NodeIndex,std::__value_type<CI::NodeIndex,unsigned long>,std::less<CI::NodeIndex>,true>,std::allocator<std::__value_type<CI::NodeIndex,unsigned long>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v22, (unsigned int *)v11, (uint64_t)&std::piecewise_construct, (_DWORD **)&__src)[5] = v21;
  }
  uint64_t v23 = *(void *)(a1[6] + 8) + 40;
  uint64_t __src = v21;
  XXH64_update(v23, (char *)&__src, 8uLL);
  if (a6 != -1)
  {
    unint64_t v24 = (*(uint64_t (**)(void *, uint64_t))(*v9 + 48))(v9, a6);
    unint64_t v25 = (CI::Node *)v24;
    int v28 = (void *)v9[11];
    int v27 = v9 + 11;
    uint64_t v26 = v28;
    if (!v28) {
      goto LABEL_25;
    }
    unint64_t v29 = v27;
    do
    {
      unint64_t v30 = v26[4];
      BOOL v31 = v30 >= v24;
      if (v30 >= v24) {
        uint64_t v32 = v26;
      }
      else {
        uint64_t v32 = v26 + 1;
      }
      if (v31) {
        unint64_t v29 = v26;
      }
      uint64_t v26 = (void *)*v32;
    }
    while (*v32);
    if (v29 == v27 || v24 < v29[4]) {
LABEL_25:
    }
      unint64_t v29 = v27;
    uint64_t v33 = *(void *)(a1[6] + 8) + 40;
    uint64_t __src = (uint64_t *)v29[5];
    XXH64_update(v33, (char *)&__src, 8uLL);
    uint64_t v34 = *(void *)(a1[6] + 8) + 40;
    LODWORD(__src) = CI::Node::rois_count(v25);
    XXH64_update(v34, (char *)&__src, 4uLL);
    int v35 = (*(uint64_t (**)(CI::Node *))(*(void *)v25 + 16))(v25);
    uint64_t v36 = *(void *)(a1[6] + 8) + 40;
    if (v35 == 52) {
      LODWORD(__src) = *((unsigned char *)v25 + 144) & 1;
    }
    else {
      LODWORD(__src) = 0;
    }
    XXH64_update(v36, (char *)&__src, 4uLL);
    if ((*(unsigned int (**)(CI::Node *))(*(void *)a2 + 16))(a2) == 46)
    {
      uint64_t v41 = *(void *)(a1[6] + 8) + 40;
    }
    else
    {
      int v42 = (*(uint64_t (**)(CI::Node *))(*(void *)a2 + 16))(a2);
      uint64_t v41 = *(void *)(a1[6] + 8) + 40;
      if (v42 != 44)
      {
        LODWORD(__src) = 1;
        goto LABEL_36;
      }
    }
    LODWORD(__src) = (*(uint64_t (**)(CI::Node *))(*(void *)a2 + 208))(a2);
LABEL_36:
    uint64_t v39 = v41;
    size_t v40 = 4;
    goto LABEL_37;
  }
  uint64_t v37 = *(void *)(a1[6] + 8) + 40;
  LODWORD(__src) = CI::Node::rois_count(a2);
  XXH64_update(v37, (char *)&__src, 4uLL);
  (*(void (**)(CI::Node *, uint64_t))(*(void *)a2 + 392))(a2, *(void *)(a1[6] + 8) + 40);
  uint64_t v38 = *(void *)(a1[6] + 8) + 40;
  uint64_t __src = (uint64_t *)CI::Node::unique_child_count(a2);
  uint64_t v39 = v38;
  size_t v40 = 8;
LABEL_37:
  XXH64_update(v39, (char *)&__src, v40);
  return 0;
}

uint64_t ___ZN2CI11ProgramNode19build_program_graphEPNS_4NodeEPNS_7ContextERNS_13NodeToNodeMapEb_block_invoke(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  LODWORD(v61) = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  HIDWORD(v61) = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  int v10 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  signed int v11 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 16))(a2);
  *(unsigned char *)(*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) + a4) = a5 + 48;
  *(unsigned char *)(*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) + a4 + 1) = 0;
  *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) += (*(uint64_t (**)(unint64_t))(*(void *)a2 + 336))(a2);
  if ((*(int (**)(unint64_t))(*(void *)a2 + 40))(a2) < 1)
  {
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)a2 + 48))(a2, v14);
      v13 += (*(int (**)(uint64_t))(*(void *)v15 + 208))(v15);
      uint64_t v14 = (v14 + 1);
    }
    while ((int)v14 < (*(int (**)(unint64_t))(*(void *)a2 + 40))(a2));
  }
  *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) += v13;
  if (v11 == 49 || v11 == 50)
  {
    int v17 = 0;
    uint64_t v16 = *(void *)(a2 + 48);
  }
  else if (v11 == 51)
  {
    uint64_t v16 = *(void *)(a2 + 48);
    if (HIDWORD(*(void *)(a2 + 136)) && *(void *)(a2 + 136) && *(_DWORD *)(a2 + 144)
      || (int v17 = 0, HIDWORD(*(void *)(a2 + 148))) && *(void *)(a2 + 148) && *(_DWORD *)(a2 + 156))
    {
      int v17 = 1;
    }
  }
  else
  {
    int v17 = 0;
    uint64_t v16 = 0;
  }
  uint64_t v18 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
  if (v18 && v18 == a3) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 408))(a3, a5);
  }
  BOOL v19 = v10 != 0;
  if (v16)
  {
    uint64_t v20 = *(CI **)(a1 + 144);
    if (v20)
    {
      int is_kernel_metalextern_linkable = CI::is_kernel_metalextern_linkable(v20, (const CI::MetalContext *)v16, v12);
      int v23 = HIDWORD(v61);
      if (!is_kernel_metalextern_linkable) {
        int v23 = 0;
      }
      HIDWORD(v61) = v23;
      int is_kernel_metalstitchable_linkable = CI::is_kernel_metalstitchable_linkable(*(CI **)(a1 + 144), (const CI::MetalContext *)v16, v22);
      int v26 = v61;
      if (!is_kernel_metalstitchable_linkable) {
        int v26 = 0;
      }
      LODWORD(v61) = v26;
      BOOL is_kernel_metalfosl_linkable = CI::is_kernel_metalfosl_linkable(v16, v25);
      if (v10) {
        BOOL v19 = is_kernel_metalfosl_linkable;
      }
      else {
        BOOL v19 = 0;
      }
    }
  }
  char v60 = v19;
  uint64_t v63 = 0;
  int v64 = &v63;
  uint64_t v65 = 0x2000000000;
  char v66 = 0;
  if (!v16)
  {
    CFDictionaryRef v29 = 0;
    goto LABEL_36;
  }
  CFDictionaryRef v28 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(*(void *)v16 + 40))(v16);
  CFDictionaryRef v29 = v28;
  if (!v28)
  {
LABEL_36:
    char v59 = 1;
    goto LABEL_37;
  }
  uint64_t v30 = *(void *)(a1 + 96);
  if (*(void *)(*(void *)(v30 + 8) + 24))
  {
    v62[0] = MEMORY[0x1E4F143A8];
    v62[1] = 0x40000000;
    v62[2] = ___ZN2CI11ProgramNode19build_program_graphEPNS_4NodeEPNS_7ContextERNS_13NodeToNodeMapEb_block_invoke_2;
    v62[3] = &unk_1E57754F0;
    v62[4] = v30;
    v62[5] = &v63;
    __CFDictionary::for_each(v28, v62);
  }
  char v59 = 0;
LABEL_37:
  if (v11 == 47 || v11 == 33)
  {
    uint64_t v31 = (*(uint64_t (**)(unint64_t, void))(*(void *)a2 + 48))(a2, 0);
    unsigned int v32 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 16))(v31);
    is_image_int type = CI::is_image_type(v32);
    if (!a3) {
      goto LABEL_140;
    }
  }
  else
  {
    is_image_int type = 0;
    if (!a3) {
      goto LABEL_140;
    }
  }
  int v34 = *(_DWORD *)(a1 + 192);
  if ((v34 - 41) <= 1)
  {
    if (v34 == 41) {
      int v35 = "this is a Processor";
    }
    else {
      int v35 = "this is a Convert";
    }
LABEL_46:
    *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = v35;
    goto LABEL_55;
  }
  if (v11 == 51 && *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24))
  {
    uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
    uint64_t v37 = "program can only contain one General Kernel node";
    goto LABEL_54;
  }
  if (v17)
  {
    uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
    uint64_t v37 = "child sets threadgroup dimensions";
    goto LABEL_54;
  }
  if (*((unsigned char *)v64 + 24))
  {
    uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
    uint64_t v37 = "child contains conflicting kernel constants";
    goto LABEL_54;
  }
  if ((v11 - 41) <= 1)
  {
    int v35 = "child is a Convert";
    if (v11 == 41) {
      int v35 = "child is a Processor";
    }
    goto LABEL_46;
  }
  if (v11 == 39)
  {
    switch((*(unsigned int (**)(unint64_t))(*(void *)a2 + 408))(a2))
    {
      case 1u:
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "child is a Noop full_intermediate";
        break;
      case 2u:
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "child is a Noop intermediate_uncached";
        break;
      case 3u:
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "child is a Noop intermediate_cached";
        break;
      case 4u:
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "child is a Noop affine";
        break;
      case 5u:
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "child is a Noop multiuse";
        break;
      case 6u:
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "child is a Noop samplemode";
        break;
      case 7u:
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "child is a Noop disablemerging";
        break;
      default:
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "child is a Noop intermediate";
        break;
    }
    goto LABEL_54;
  }
  if (CI::is_image_type(v11))
  {
    uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
    uint64_t v37 = "child is a raster leaf";
    goto LABEL_54;
  }
  uint64_t v41 = *(void **)(*(void *)(a1 + 152) + 16);
  if (!v41)
  {
LABEL_81:
    if (v11 != 45)
    {
      if (((*(uint64_t (**)(unint64_t))(*(void *)a2 + 280))(a2) & 1) != 0
        || (*(unsigned int (**)(unint64_t))(*(void *)a2 + 272))(a2))
      {
        int v43 = *(_DWORD *)(a1 + 196);
        if (v43 <= 1024) {
          int v43 = 1024;
        }
      }
      else
      {
        int v43 = *(_DWORD *)(a1 + 196);
      }
      if (v43 < a4)
      {
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "beyond CI_MAX_PROGRAM_DEPTH";
        goto LABEL_54;
      }
    }
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 160) + 16))(*(void *)(a1 + 160)) == 74)
    {
      unint64_t v44 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
      if (v44 > (int)CI_MAX_CL_COMPLEXITY()
        && ((*(uint64_t (**)(unint64_t))(*(void *)a2 + 232))(a2) & 1) == 0)
      {
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "beyond CI_MAX_CL_COMPLEXITY";
        goto LABEL_54;
      }
    }
    if (v16 && !*(_DWORD *)(v16 + 16))
    {
      if (a4 != 1
        || *(_DWORD *)(a1 + 192) != 28
        || !CI::Affine::isOrientationWithIntegralTranslation((CI::Affine *)(*(void *)(a1 + 168) + 56)))
      {
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "child is a kernel with ReturnTypeNone";
        goto LABEL_54;
      }
      goto LABEL_140;
    }
    if (*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) > *(void *)(a1 + 176))
    {
      uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
      uint64_t v37 = "beyond max_texture_units";
      goto LABEL_54;
    }
    char v45 = v60;
    if (v61) {
      char v45 = 1;
    }
    if ((v45 & 1) == 0)
    {
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
      {
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "program with non-Metal-extern kernels can't be linked with a Metal-extern kernels";
      }
      else if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
      {
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "program with non-Metal-stitchable kernels can't be linked with a Metal-stitchable kernels";
      }
      else
      {
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
          uint64_t v37 = "program with non-CIKL kernels can't be linked with a CIKL kernel";
        }
        else {
          uint64_t v37 = "program can't be linked with the child's kernel";
        }
      }
      goto LABEL_54;
    }
    if (!*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24)
      || !*(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24))
    {
      if (v11 != 51) {
        goto LABEL_140;
      }
      BOOL v47 = *(unsigned char *)(*(void *)(*(void *)(a1 + 112) + 8) + 24) != 0;
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 112) + 8) + 24)) {
        *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = "child is a GeneralKernel";
      }
      if (CI_DISABLE_MERGING_POST_GENERAL())
      {
        uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
        uint64_t v37 = "CI_DISABLE_MERGING_POST_GENERAL";
        goto LABEL_54;
      }
      goto LABEL_139;
    }
    if (v11 > 44)
    {
      if (v11 != 45)
      {
        if (v11 != 47) {
          goto LABEL_130;
        }
        int v48 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 408))(a2);
        if (!SwizzlerMask(v48)
          && (*(unsigned int (**)(unint64_t))(*(void *)a2 + 408))(a2) - 27 > 9)
        {
          double v46 = "descendent of GeneralKernel is non-trivial Swizzle";
          goto LABEL_136;
        }
        uint64_t v49 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
        if ((*(int (**)(uint64_t))(*(void *)v49 + 40))(v49) > 1)
        {
          double v46 = "descendent of multi-child GeneralKernel is a Swizzle";
          goto LABEL_136;
        }
        if (*(void *)(a1 + 184))
        {
          double v46 = "descendent of SW GeneralKernel is a Swizzle";
          goto LABEL_136;
        }
        if (CI_ENABLE_METAL_DAG())
        {
          double v57 = *(CI **)(a1 + 144);
          if (v57)
          {
            if (CI::is_kernel_metalstitchable_linkable(v57, *(const CI::MetalContext **)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) + 48), v56) & 1) != 0|| (CI::is_kernel_metalextern_linkable(*(CI **)(a1 + 144), *(const CI::MetalContext **)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) + 48), v58))
            {
              double v46 = "descendent of precompiled GeneralKernel is a Swizzle";
              goto LABEL_136;
            }
          }
        }
      }
    }
    else
    {
      if (v11 != 28)
      {
        if (v11 == 30)
        {
          double v46 = "descendent of GeneralKernel is a Clamp";
LABEL_136:
          BOOL v47 = 0;
          *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = v46;
LABEL_137:
          if (CI_DISABLE_MERGING_PRE_GENERAL())
          {
            uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
            uint64_t v37 = "CI_DISABLE_MERGING_PRE_GENERAL";
            goto LABEL_54;
          }
LABEL_139:
          if (!v47) {
            goto LABEL_55;
          }
LABEL_140:
          *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) -= (*(int (**)(unint64_t))(*(void *)a2 + 208))(a2);
          if ((*(unsigned int (**)(unint64_t))(*(void *)a2 + 16))(a2) == 51) {
            *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = CI::Object::ref(a2);
          }
          if ((v59 & 1) == 0)
          {
            uint64_t v50 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24);
            if (!v50)
            {
              *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              uint64_t v50 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24);
            }
            v67[0] = MEMORY[0x1E4F143A8];
            v67[1] = 0x40000000;
            v67[2] = ___ZN14__CFDictionary9setValuesEPS_PKS__block_invoke;
            v67[3] = &__block_descriptor_tmp_211;
            v67[4] = v50;
            __CFDictionary::for_each(v29, v67);
          }
          if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24)
            || !*(unsigned char *)(*(void *)(*(void *)(a1 + 112) + 8) + 24))
          {
            goto LABEL_147;
          }
          if (a4 || v11 != 28)
          {
            if (((*(uint64_t (**)(unint64_t))(*(void *)a2 + 232))(a2) & 1) == 0)
            {
              int v52 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 40))(a2);
              uint64_t v53 = *(void *)(*(void *)(a1 + 112) + 8);
              BOOL v55 = v52 == 1 && *(unsigned char *)(v53 + 24) != 0;
              *(unsigned char *)(v53 + 24) = v55;
              if (!v16
                || (*(unsigned int (**)(uint64_t))(*(void *)v16 + 16))(v16) != 62
                || !*(unsigned char *)(v16 + 176))
              {
                goto LABEL_147;
              }
              goto LABEL_166;
            }
            if (v11 != 30) {
LABEL_166:
            }
              *(unsigned char *)(*(void *)(*(void *)(a1 + 112) + 8) + 24) = 0;
          }
          else if (!CI::Affine::isOrientationWithIntegralTranslation((CI::Affine *)(a2 + 56)))
          {
            goto LABEL_166;
          }
LABEL_147:
          uint64_t v40 = 0;
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = HIDWORD(v61) != 0;
          *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v61 != 0;
          *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v60;
          goto LABEL_148;
        }
LABEL_130:
        double v46 = "this program contains a GeneralKernel";
        goto LABEL_136;
      }
      if (!CI::Affine::isOrientationWithIntegralTranslation((CI::Affine *)(a2 + 56)))
      {
        double v46 = "descendent of GeneralKernel is a resampling Affine";
        goto LABEL_136;
      }
    }
    BOOL v47 = 1;
    goto LABEL_137;
  }
  while (1)
  {
    unint64_t v42 = v41[4];
    if (v42 <= a2) {
      break;
    }
LABEL_71:
    uint64_t v41 = (void *)*v41;
    if (!v41) {
      goto LABEL_81;
    }
  }
  if (v42 < a2)
  {
    ++v41;
    goto LABEL_71;
  }
  if (is_image_type) {
    goto LABEL_81;
  }
  uint64_t v36 = *(void *)(*(void *)(a1 + 104) + 8);
  uint64_t v37 = "child is a previously seen program";
LABEL_54:
  *(void *)(v36 + 24) = v37;
LABEL_55:
  uint64_t v38 = (CI::Object *)(*(uint64_t (**)(unint64_t, void, void, void))(*(void *)a2 + 328))(a2, *(void *)(a1 + 160), *(void *)(a1 + 152), 0);
  CI::SerialObjectPtrArray::append(*(void *)(*(void *)(*(void *)(a1 + 120) + 8) + 24), v38);
  CI::SerialStringArray::append(*(CI::SerialStringArray **)(*(void *)(*(void *)(a1 + 128) + 8) + 24), (const char *)(*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) + 1), a4);
  if (v38) {
    CI::Object::unref(v38);
  }
  size_t v39 = strlen(*(const char **)(*(void *)(*(void *)(a1 + 104) + 8) + 24));
  CI::SerialStringArray::append(*(CI::SerialStringArray **)(*(void *)(*(void *)(a1 + 136) + 8) + 24), *(const char **)(*(void *)(*(void *)(a1 + 104) + 8) + 24), v39);
  *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) -= v13;
  uint64_t v40 = 1;
LABEL_148:
  _Block_object_dispose(&v63, 8);
  return v40;
}

uint64_t CI::MetalContext::type(CI::MetalContext *this)
{
  return 77;
}

uint64_t CI::Node::plane_count(CI::Node *this)
{
  return 1;
}

uint64_t CI::is_image_type(unsigned int a1)
{
  return (a1 < 0x31) & (0x1500020000000uLL >> a1);
}

uint64_t CI::Node::unique_child_count(CI::Node *this)
{
  unsigned int v2 = (*(uint64_t (**)(CI::Node *))(*(void *)this + 40))(this);
  uint64_t v3 = v2;
  if (v2 >= 2)
  {
    uint64_t v4 = 0;
    int v8 = 0;
    uint64_t v9 = 0;
    long long v7 = (uint64_t *)&v8;
    do
    {
      uint64_t v6 = (*(uint64_t (**)(CI::Node *, uint64_t))(*(void *)this + 48))(this, v4);
      std::__tree<char const*>::__emplace_unique_key_args<char const*,char const* const&>(&v7, (unint64_t *)&v6, &v6);
      uint64_t v4 = (v4 + 1);
    }
    while (v3 != v4);
    uint64_t v3 = v9;
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v7, v8);
  }
  return v3;
}

uint64_t ___ZN2CI5Image18BuildMapToUseCountEPS0_PNS_7ContextE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t v6 = *(void *)(a2 + 80);
  unint64_t v18 = v6;
  if (!a3
    || (*(unsigned int (**)(uint64_t))(*(void *)a3 + 16))(a3) != 22
    || (uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 320))(*(void *)(a1 + 40)),
        (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a3 + 320))(a3, v9) == a5))
  {
    uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    signed int v11 = *(void **)(v10 + 8);
    if (!v11) {
      goto LABEL_15;
    }
    uint64_t v12 = (void *)(v10 + 8);
    do
    {
      unint64_t v13 = v11[4];
      BOOL v14 = v13 >= v6;
      if (v13 >= v6) {
        uint64_t v15 = v11;
      }
      else {
        uint64_t v15 = v11 + 1;
      }
      if (v14) {
        uint64_t v12 = v11;
      }
      signed int v11 = (void *)*v15;
    }
    while (*v15);
    if (v12 == (void *)(v10 + 8) || v6 < v12[4])
    {
LABEL_15:
      BOOL v19 = &v18;
      uint64_t v16 = std::__tree<std::__value_type<CI::ImageDigest,int>,std::__map_value_compare<CI::ImageDigest,std::__value_type<CI::ImageDigest,int>,std::less<CI::ImageDigest>,true>,std::allocator<std::__value_type<CI::ImageDigest,int>>>::__emplace_unique_key_args<CI::ImageDigest,std::piecewise_construct_t const&,std::tuple<CI::ImageDigest const&>,std::tuple<>>((uint64_t **)v10, &v18, (uint64_t)&std::piecewise_construct, &v19);
      uint64_t result = 0;
      *((_DWORD *)v16 + 10) = 1;
      return result;
    }
    ++*((_DWORD *)v12 + 10);
  }
  return 1;
}

uint64_t ___ZN2CI5Image18BuildMapToUnionRoiEPS0_6CGRect_block_invoke(double *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    uint64_t v7 = *(void *)(*(void *)(*((void *)a1 + 4) + 8) + 24);
    uint64_t v10 = *(void **)(v7 + 8);
    uint64_t v9 = (double *)(v7 + 8);
    int v8 = v10;
    signed int v11 = (double *)MEMORY[0x1E4F1DB20];
    if (v10)
    {
      unint64_t v12 = a3[10];
      unint64_t v13 = v9;
      do
      {
        unint64_t v14 = v8[4];
        BOOL v15 = v14 >= v12;
        if (v14 >= v12) {
          uint64_t v16 = v8;
        }
        else {
          uint64_t v16 = v8 + 1;
        }
        if (v15) {
          unint64_t v13 = (double *)v8;
        }
        int v8 = (void *)*v16;
      }
      while (*v16);
      int v17 = (double *)(MEMORY[0x1E4F1DB20] + 24);
      unint64_t v18 = (double *)(MEMORY[0x1E4F1DB20] + 16);
      BOOL v19 = (double *)(MEMORY[0x1E4F1DB20] + 8);
      if (v13 != v9)
      {
        BOOL v20 = v12 >= *((void *)v13 + 4);
        unint64_t v21 = v13 + 5;
        uint64_t v22 = v13 + 6;
        int v23 = v13 + 7;
        unint64_t v24 = v13 + 8;
        if (v20) {
          signed int v11 = v21;
        }
        if (v20) {
          BOOL v19 = v22;
        }
        if (v20) {
          unint64_t v18 = v23;
        }
        if (v20) {
          int v17 = v24;
        }
      }
    }
    else
    {
      int v17 = (double *)(MEMORY[0x1E4F1DB20] + 24);
      unint64_t v18 = (double *)(MEMORY[0x1E4F1DB20] + 16);
      BOOL v19 = (double *)(MEMORY[0x1E4F1DB20] + 8);
    }
    CGFloat v25 = (*(double (**)(void *, uint64_t, double, double, double, double))(*a3 + 256))(a3, a5, *v11, *v19, *v18, *v17);
    CGFloat v26 = v29;
    CGFloat v27 = v30;
    CGFloat v28 = v31;
  }
  else
  {
    CGFloat v25 = a1[5];
    CGFloat v26 = a1[6];
    CGFloat v27 = a1[7];
    CGFloat v28 = a1[8];
  }
  uint64_t v32 = *(void *)(*(void *)(*((void *)a1 + 4) + 8) + 24);
  unint64_t v33 = *(void *)(a2 + 80);
  int v34 = *(void **)(v32 + 8);
  if (!v34) {
    goto LABEL_38;
  }
  int v35 = (double *)(v32 + 8);
  do
  {
    unint64_t v36 = v34[4];
    BOOL v37 = v36 >= v33;
    if (v36 >= v33) {
      uint64_t v38 = v34;
    }
    else {
      uint64_t v38 = v34 + 1;
    }
    if (v37) {
      int v35 = (double *)v34;
    }
    int v34 = (void *)*v38;
  }
  while (*v38);
  if (v35 != (double *)(v32 + 8) && v33 >= *((void *)v35 + 4))
  {
    CGFloat v41 = v35[5];
    CGFloat v42 = v35[6];
    CGFloat v43 = v35[7];
    CGFloat v44 = v35[8];
    v47.origin.double x = v41;
    v47.origin.double y = v42;
    v47.size.double width = v43;
    v47.size.double height = v44;
    v50.origin.double x = v25;
    v50.origin.double y = v26;
    v50.size.double width = v27;
    v50.size.double height = v28;
    if (CGRectContainsRect(v47, v50))
    {
      return 1;
    }
    else
    {
      v48.origin.double x = v25;
      v48.origin.double y = v26;
      v48.size.double width = v27;
      v48.size.double height = v28;
      v51.origin.double x = v41;
      v51.origin.double y = v42;
      v51.size.double width = v43;
      v51.size.double height = v44;
      CGRect v49 = CGRectUnion(v48, v51);
      uint64_t result = 0;
      *(CGRect *)(v35 + 5) = v49;
    }
  }
  else
  {
LABEL_38:
    unint64_t v45 = v33;
    double v46 = &v45;
    size_t v39 = std::__tree<std::__value_type<CI::ImageDigest,CGRect>,std::__map_value_compare<CI::ImageDigest,std::__value_type<CI::ImageDigest,CGRect>,std::less<CI::ImageDigest>,true>,std::allocator<std::__value_type<CI::ImageDigest,CGRect>>>::__emplace_unique_key_args<CI::ImageDigest,std::piecewise_construct_t const&,std::tuple<CI::ImageDigest&&>,std::tuple<>>((uint64_t **)v32, &v45, (uint64_t)&std::piecewise_construct, &v46);
    uint64_t result = 0;
    *((CGFloat *)v39 + 5) = v25;
    *((CGFloat *)v39 + 6) = v26;
    *((CGFloat *)v39 + 7) = v27;
    *((CGFloat *)v39 + 8) = v28;
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<CI::ImageDigest,int>,std::__map_value_compare<CI::ImageDigest,std::__value_type<CI::ImageDigest,int>,std::less<CI::ImageDigest>,true>,std::allocator<std::__value_type<CI::ImageDigest,int>>>::__emplace_unique_key_args<CI::ImageDigest,std::piecewise_construct_t const&,std::tuple<CI::ImageDigest const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    signed int v11 = operator new(0x30uLL);
    v11[4] = **a4;
    *((_DWORD *)v11 + 10) = 0;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t **std::__tree<std::__value_type<CI::ImageDigest,CGRect>,std::__map_value_compare<CI::ImageDigest,std::__value_type<CI::ImageDigest,CGRect>,std::less<CI::ImageDigest>,true>,std::allocator<std::__value_type<CI::ImageDigest,CGRect>>>::__emplace_unique_key_args<CI::ImageDigest,std::piecewise_construct_t const&,std::tuple<CI::ImageDigest&&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    signed int v11 = (char *)operator new(0x48uLL);
    *((void *)v11 + 4) = **a4;
    *(_OWORD *)(v11 + 56) = 0u;
    *(_OWORD *)(v11 + 40) = 0u;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t CI::Node::code_complexity(CI::Node *this)
{
  return 1;
}

void *std::vector<CI::TraverseVisit>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<CGRect>::__vallocate[abi:nn180100](a1, v5 >> 5);
    unint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5 - 7);
    a1[1] = &v6[v5];
  }
  return a1;
}

void std::vector<CI::TraverseVisit>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 5)
  {
    if (a2 >> 59) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    unint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(v3, a2);
    uint64_t v7 = &v6[v5];
    uint64_t v9 = &v6[32 * v8];
    signed int v11 = (char *)*a1;
    unint64_t v10 = (char *)a1[1];
    unint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 2);
        *(_OWORD *)(v12 - 23) = *(_OWORD *)(v10 - 23);
        *((_OWORD *)v12 - 2) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      unint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

char *std::stack<CI::TraverseVisit,std::vector<CI::TraverseVisit>>::emplace[abi:nn180100]<CI::GraphObject *&,decltype(nullptr),int,int>(void **a1, void *a2, uint64_t a3, int *a4, int *a5)
{
  signed int v11 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (v12 >= (unint64_t)v11)
  {
    uint64_t v16 = (uint64_t)(v12 - (void)*a1) >> 5;
    unint64_t v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 59) {
      abort();
    }
    uint64_t v18 = v10 - (unsigned char *)*a1;
    if (v18 >> 4 > v17) {
      unint64_t v17 = v18 >> 4;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v19 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v17;
    }
    BOOL v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(v9, v19);
    unint64_t v21 = &v20[32 * v16];
    int v23 = &v20[32 * v22];
    int v24 = *a4;
    int v25 = *a5;
    *(void *)unint64_t v21 = *a2;
    *((void *)v21 + 1) = 0;
    *((_DWORD *)v21 + 4) = v24;
    *((_DWORD *)v21 + 5) = v25;
    v21[24] = 0;
    BOOL v15 = v21 + 32;
    CGFloat v27 = (char *)*a1;
    CGFloat v26 = (char *)a1[1];
    if (v26 != *a1)
    {
      do
      {
        long long v28 = *((_OWORD *)v26 - 2);
        *(_OWORD *)(v21 - 23) = *(_OWORD *)(v26 - 23);
        *((_OWORD *)v21 - 2) = v28;
        v21 -= 32;
        v26 -= 32;
      }
      while (v26 != v27);
      CGFloat v26 = (char *)*a1;
    }
    *a1 = v21;
    a1[1] = v15;
    a1[2] = v23;
    if (v26) {
      operator delete(v26);
    }
  }
  else
  {
    int v13 = *a4;
    int v14 = *a5;
    *(void *)unint64_t v12 = *a2;
    *(void *)(v12 + 8) = 0;
    *(_DWORD *)(v12 + 16) = v13;
    *(_DWORD *)(v12 + 20) = v14;
    *(unsigned char *)(v12 + 24) = 0;
    BOOL v15 = (char *)(v12 + 32);
  }
  a1[1] = v15;
  return v15 - 32;
}

uint64_t CI::ColorKernelNode::add_to_kernel_hash(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 64))();
}

size_t CI::SurfaceNode::plane_count(IOSurfaceRef *this)
{
  if ((int)IOSurfaceGetPlaneCount(this[7]) < 2) {
    return 1;
  }
  else {
    return IOSurfaceGetPlaneCount(this[7]);
  }
}

void std::__destroy_at[abi:nn180100]<CI::SerialRectArray::roiData,0>(void *a1)
{
  unsigned int v2 = (void *)a1[12];
  if (v2)
  {
    a1[13] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[7];
  if (v3)
  {
    a1[8] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[4];
  if (v4)
  {
    a1[5] = v4;
    operator delete(v4);
  }
}

uint64_t ___ZNK2CI11ProgramNode18make_function_nameER15x_stream_struct_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a6 == -1)
  {
    uint64_t v7 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
    if (*v7 != 95) {
      x_stream_write(*(void *)(a1 + 32), "_", 1uLL);
    }
    size_t v8 = strlen(v7);
    x_stream_write(*(void *)(a1 + 32), v7, v8);
  }
  return 0;
}

uint64_t x_stream_write(uint64_t a1, void *__src, size_t __n)
{
  unint64_t v6 = *(void **)(a1 + 8);
  if ((unint64_t)v6 + __n >= *(void *)(a1 + 16))
  {
    uint64_t result = x_stream_grow((char **)a1, __n);
    if (!result) {
      return result;
    }
    unint64_t v6 = *(void **)(a1 + 8);
  }
  uint64_t result = (uint64_t)memcpy(v6, __src, __n);
  *(void *)(a1 + 8) += __n;
  return result;
}

BOOL CI::ColorKernelNode::output_is_rg(CI::ColorKernelNode *this)
{
  int v2 = *((_DWORD *)this + 30);
  BOOL result = 1;
  if (!v2 || (CI::format_is_rg(v2) & 1) == 0)
  {
    if (!*(unsigned char *)(*((void *)this + 6) + 160)) {
      return 0;
    }
    if (!(*(uint64_t (**)(CI::ColorKernelNode *, void))(*(void *)this + 48))(this, 0)) {
      return 0;
    }
    uint64_t v3 = (*(uint64_t (**)(CI::ColorKernelNode *, void))(*(void *)this + 48))(this, 0);
    v6.origin.double x = (*(double (**)(uint64_t))(*(void *)v3 + 160))(v3);
    if (!CGRectIsInfinite(v6)) {
      return 0;
    }
    uint64_t v4 = *(void *)(*(uint64_t (**)(CI::ColorKernelNode *, void))(*(void *)this + 48))(this, 0);
    if (((*(uint64_t (**)(void))(v4 + 272))() & 1) == 0) {
      return 0;
    }
  }
  return result;
}

BOOL CI::ColorKernelNode::output_is_r(CI::ColorKernelNode *this)
{
  int v2 = *((_DWORD *)this + 30);
  BOOL result = 1;
  if (!v2 || (CI::format_is_r(v2) & 1) == 0)
  {
    if (!*(unsigned char *)(*((void *)this + 6) + 160)) {
      return 0;
    }
    if (!(*(uint64_t (**)(CI::ColorKernelNode *, void))(*(void *)this + 48))(this, 0)) {
      return 0;
    }
    uint64_t v3 = (*(uint64_t (**)(CI::ColorKernelNode *, void))(*(void *)this + 48))(this, 0);
    v6.origin.double x = (*(double (**)(uint64_t))(*(void *)v3 + 160))(v3);
    if (!CGRectIsInfinite(v6)) {
      return 0;
    }
    uint64_t v4 = *(void *)(*(uint64_t (**)(CI::ColorKernelNode *, void))(*(void *)this + 48))(this, 0);
    if (((*(uint64_t (**)(void))(v4 + 280))() & 1) == 0) {
      return 0;
    }
  }
  return result;
}

uint64_t CI::ImageWithChild::extent_unclamped(CI::ImageWithChild *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 96))();
}

void CI::AffineImage::roi_of_child(CI::AffineImage *this, CGRect a2)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  CI::Affine::inverse((CI::AffineImage *)((char *)this + 120), v6);
  v7.origin.CGFloat x = x;
  v7.origin.CGFloat y = y;
  v7.size.CGFloat width = width;
  v7.size.CGFloat height = height;
  CI::Affine::applyToRect((CI::Affine *)v6, v7);
}

uint64_t CI::ColorMatrixImage::extent(CI::ColorMatrixImage *this, const double (*a2)[4])
{
  uint64_t result = CI::ColorMatrixNode::is_alpha_biased((CI::ColorMatrixImage *)((char *)this + 120), a2);
  if (!result) {
    return (*(uint64_t (**)(void))(**((void **)this + 13) + 88))(*((void *)this + 13));
  }
  return result;
}

BOOL CI::ColorMatrixNode::is_alpha_biased(CI::ColorMatrixNode *this, const double (*a2)[4])
{
  return fabs(*((double *)this + 19)) >= 0.0003;
}

uint64_t CI::Node::add_to_kernel_hash(uint64_t a1, uint64_t a2)
{
  char __src = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  return XXH64_update(a2, &__src, 1uLL);
}

uint64_t CI::ColorMatrixNode::output_is_rg(CI::ColorMatrixNode *this)
{
  return 0;
}

uint64_t CI::ColorMatrixNode::output_is_r(CI::ColorMatrixNode *this)
{
  return 0;
}

uint64_t CI::NodeWithChild::output_is_rg(CI::NodeWithChild *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 272))();
}

uint64_t CI::NodeWithChild::output_is_r(CI::NodeWithChild *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 280))();
}

uint64_t ___ZN2CI14MetalDAGHelper15build_constantsEPKNS_11ProgramNodeE_block_invoke(uint64_t a1, CI *this, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a6 == -1)
  {
    v12[7] = v6;
    v12[8] = v7;
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = CI::kernel_for_node(this, this);
    if (v9)
    {
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 72))(v9);
      if (v10)
      {
        v12[0] = MEMORY[0x1E4F143A8];
        v12[1] = 3221225472;
        v12[2] = ___ZN2CI14MetalDAGHelper15build_constantsEPKNS_11ProgramNodeE_block_invoke_2;
        v12[3] = &__block_descriptor_40_e26_v32__0r_v8Q16__NSString_24l;
        v12[4] = v8;
        CI::MetalKernel::iterateOverFunctionConstants(v10, (uint64_t)v12);
      }
    }
  }
  return 0;
}

uint64_t ___ZNK2CI5Image15traverse_uniqueEU13block_pointerFvPKS0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN2CIL28traverse_restoring_resourcesERKNSt3__13mapINS_10ImageIndexENS_30ImageDigestForRenderGraphCacheENS0_4lessIS2_EENS0_9allocatorINS0_4pairIKS2_S3_EEEEEERKNS_14ImageToNodeMapEPNS_5ImageE_block_invoke(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = (*(uint64_t (**)(_DWORD *))(*(void *)a2 + 16))(a2);
  uint64_t result = CI::is_raster_TypeImage(v4);
  if (result)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v9 = *(void *)(v6 + 8);
    uint64_t v7 = v6 + 8;
    uint64_t v8 = v9;
    if (!v9) {
      goto LABEL_13;
    }
    unsigned int v10 = a2[25];
    uint64_t v11 = v7;
    do
    {
      unsigned int v12 = *(_DWORD *)(v8 + 32);
      BOOL v13 = v12 >= v10;
      if (v12 >= v10) {
        int v14 = (uint64_t *)v8;
      }
      else {
        int v14 = (uint64_t *)(v8 + 8);
      }
      if (v13) {
        uint64_t v11 = v8;
      }
      uint64_t v8 = *v14;
    }
    while (*v14);
    if (v11 == v7 || v10 < *(_DWORD *)(v11 + 32)) {
LABEL_13:
    }
      uint64_t v11 = v7;
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v18 = *(void **)(v15 + 32);
    uint64_t v16 = (void *)(v15 + 32);
    unint64_t v17 = v18;
    if (!v18) {
      return result;
    }
    unint64_t v19 = *(void *)(v11 + 40);
    BOOL v20 = v16;
    do
    {
      unint64_t v21 = v17[4];
      BOOL v22 = v21 >= v19;
      if (v21 >= v19) {
        int v23 = v17;
      }
      else {
        int v23 = v17 + 1;
      }
      if (v22) {
        BOOL v20 = v17;
      }
      unint64_t v17 = (void *)*v23;
    }
    while (*v23);
    if (v20 == v16) {
      return result;
    }
    if (v20[4] > v19) {
      return result;
    }
    uint64_t v24 = v20[5];
    if (!v24) {
      return result;
    }
    while (1)
    {
      int v25 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 40))(v24);
      uint64_t v26 = *(void *)v24;
      if (!v25) {
        break;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(v26 + 48))(v24, 0);
      uint64_t v24 = result;
      if (!result) {
        return result;
      }
    }
    unsigned int v27 = (*(uint64_t (**)(uint64_t))(v26 + 16))(v24);
    if (CI::is_image_type(v27)) {
      (*(void (**)(_DWORD *, uint64_t))(*(void *)a2 + 192))(a2, v24);
    }
  }
  uint64_t result = (*(uint64_t (**)(_DWORD *))(*(void *)a2 + 16))(a2);
  if (result == 17)
  {
    uint64_t v28 = *(void *)(a1 + 32);
    uint64_t v31 = *(void *)(v28 + 8);
    uint64_t v29 = v28 + 8;
    uint64_t v30 = v31;
    if (!v31) {
      goto LABEL_43;
    }
    unsigned int v32 = a2[25];
    uint64_t v33 = v29;
    do
    {
      unsigned int v34 = *(_DWORD *)(v30 + 32);
      BOOL v35 = v34 >= v32;
      if (v34 >= v32) {
        unint64_t v36 = (uint64_t *)v30;
      }
      else {
        unint64_t v36 = (uint64_t *)(v30 + 8);
      }
      if (v35) {
        uint64_t v33 = v30;
      }
      uint64_t v30 = *v36;
    }
    while (*v36);
    if (v33 == v29 || v32 < *(_DWORD *)(v33 + 32)) {
LABEL_43:
    }
      uint64_t v33 = v29;
    uint64_t v37 = *(void *)(a1 + 40);
    uint64_t v40 = *(void **)(v37 + 32);
    uint64_t v38 = (void *)(v37 + 32);
    size_t v39 = v40;
    if (v40)
    {
      unint64_t v41 = *(void *)(v33 + 40);
      CGFloat v42 = v38;
      do
      {
        unint64_t v43 = v39[4];
        BOOL v44 = v43 >= v41;
        if (v43 >= v41) {
          unint64_t v45 = v39;
        }
        else {
          unint64_t v45 = v39 + 1;
        }
        if (v44) {
          CGFloat v42 = v39;
        }
        size_t v39 = (void *)*v45;
      }
      while (*v45);
      if (v42 != v38 && v42[4] <= v41)
      {
        uint64_t v46 = v42[5];
        if (v46)
        {
          if ((*(unsigned int (**)(uint64_t))(*(void *)v46 + 16))(v46) == 42) {
            uint64_t v46 = (*(uint64_t (**)(uint64_t, void))(*(void *)v46 + 48))(v46, 0);
          }
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 16))(v46);
          if (result == 41)
          {
LABEL_113:
            CGRect v83 = *(uint64_t (**)(_DWORD *, uint64_t))(*(void *)a2 + 192);
            return v83(a2, v46);
          }
        }
      }
    }
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(_DWORD *))(*(void *)a2 + 16))(a2);
    if (result == 13)
    {
      uint64_t v47 = *(void *)(a1 + 32);
      uint64_t v50 = *(void *)(v47 + 8);
      uint64_t v48 = v47 + 8;
      uint64_t v49 = v50;
      if (!v50) {
        goto LABEL_70;
      }
      unsigned int v51 = a2[25];
      uint64_t v52 = v48;
      do
      {
        unsigned int v53 = *(_DWORD *)(v49 + 32);
        BOOL v54 = v53 >= v51;
        if (v53 >= v51) {
          BOOL v55 = (uint64_t *)v49;
        }
        else {
          BOOL v55 = (uint64_t *)(v49 + 8);
        }
        if (v54) {
          uint64_t v52 = v49;
        }
        uint64_t v49 = *v55;
      }
      while (*v55);
      if (v52 == v48 || v51 < *(_DWORD *)(v52 + 32)) {
LABEL_70:
      }
        uint64_t v52 = v48;
      uint64_t v56 = *(void *)(a1 + 40);
      char v59 = *(void **)(v56 + 32);
      double v57 = (void *)(v56 + 32);
      CGRect v58 = v59;
      if (v59)
      {
        unint64_t v60 = *(void *)(v52 + 40);
        uint64_t v61 = v57;
        do
        {
          unint64_t v62 = v58[4];
          BOOL v63 = v62 >= v60;
          if (v62 >= v60) {
            int v64 = v58;
          }
          else {
            int v64 = v58 + 1;
          }
          if (v63) {
            uint64_t v61 = v58;
          }
          CGRect v58 = (void *)*v64;
        }
        while (*v64);
        if (v61 != v57 && v61[4] <= v60)
        {
          uint64_t v46 = v61[5];
          if (v46)
          {
            if ((*(unsigned int (**)(uint64_t))(*(void *)v46 + 16))(v46) == 47) {
              uint64_t v46 = (*(uint64_t (**)(uint64_t, void))(*(void *)v46 + 48))(v46, 0);
            }
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 16))(v46);
            if (result == 51) {
              goto LABEL_113;
            }
          }
        }
      }
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(_DWORD *))(*(void *)a2 + 16))(a2);
      if (result == 12)
      {
        uint64_t v65 = *(void *)(a1 + 32);
        uint64_t v68 = *(void *)(v65 + 8);
        uint64_t v66 = v65 + 8;
        uint64_t v67 = v68;
        if (!v68) {
          goto LABEL_97;
        }
        unsigned int v69 = a2[25];
        uint64_t v70 = v66;
        do
        {
          unsigned int v71 = *(_DWORD *)(v67 + 32);
          BOOL v72 = v71 >= v69;
          if (v71 >= v69) {
            double v73 = (uint64_t *)v67;
          }
          else {
            double v73 = (uint64_t *)(v67 + 8);
          }
          if (v72) {
            uint64_t v70 = v67;
          }
          uint64_t v67 = *v73;
        }
        while (*v73);
        if (v70 == v66 || v69 < *(_DWORD *)(v70 + 32)) {
LABEL_97:
        }
          uint64_t v70 = v66;
        uint64_t v74 = *(void *)(a1 + 40);
        v77 = *(void **)(v74 + 32);
        double v75 = (void *)(v74 + 32);
        v76 = v77;
        if (v77)
        {
          unint64_t v78 = *(void *)(v70 + 40);
          v79 = v75;
          do
          {
            unint64_t v80 = v76[4];
            BOOL v81 = v80 >= v78;
            if (v80 >= v78) {
              CGRect v82 = v76;
            }
            else {
              CGRect v82 = v76 + 1;
            }
            if (v81) {
              v79 = v76;
            }
            v76 = (void *)*v82;
          }
          while (*v82);
          if (v79 != v75 && v79[4] <= v78)
          {
            uint64_t v46 = v79[5];
            if (v46)
            {
              if ((*(unsigned int (**)(uint64_t))(*(void *)v46 + 16))(v46) == 39) {
                uint64_t v46 = (*(uint64_t (**)(uint64_t, void))(*(void *)v46 + 48))(v46, 0);
              }
              uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 16))(v46);
              if (result == 50) {
                goto LABEL_113;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t CI::Kernel::metalConstants(CI::Kernel *this)
{
  return 0;
}

uint64_t CI::ColorKernelNode::code_complexity(CI::ColorKernelNode *this)
{
  uint64_t v1 = *(unsigned char **)(*((void *)this + 6) + 32);
  if (v1)
  {
    uint64_t result = 0;
    while (1)
    {
      if (*v1 == 59)
      {
        ++result;
      }
      else if (!*v1)
      {
        return result;
      }
      ++v1;
    }
  }
  return 0;
}

BOOL CI::is_kernel_metalfosl_linkable(BOOL this, const CI::Kernel *a2)
{
  if (this) {
    return *(void *)(this + 32) != 0;
  }
  return this;
}

uint64_t CI::Image::is_empty_if_regions_of_children_are_empty(CI::Image *this)
{
  return 0;
}

uint64_t CI::AffineImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  XXH64_update(a2, (char *)(a1 + 120), 0x30uLL);
  int __src = *(char *)(a1 + 168);
  return XXH64_update(a2, (char *)&__src, 4uLL);
}

uint64_t CI::AffineNode::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  return XXH64_update(a2, (char *)(a1 + 56), 0x30uLL);
}

void *CI::SerialStringArray::append(CI::SerialStringArray *this, const char *__src, size_t __n)
{
  int v6 = *(_DWORD *)this;
  uint64_t v7 = *((int *)this + 1);
  uint64_t v8 = (unsigned char *)*((void *)this + 5);
  if (v6 >= (int)v7)
  {
    uint64_t v9 = (unsigned char *)*((void *)this + 3);
  }
  else
  {
    uint64_t v9 = (unsigned char *)*((void *)this + 3);
    if (&v8[__n] < &v9[*((int *)this + 4)]) {
      goto LABEL_11;
    }
  }
  uint64_t v10 = *((int *)this + 3);
  uint64_t v11 = *((int *)this + 2) + v7;
  *((_DWORD *)this + 1) = v11;
  unint64_t v12 = v11 + v11 * v10;
  if (v12 <= (int)v8 + (int)__n - (int)v9 + 1) {
    LODWORD(v12) = v8 + __n - v9 + 1;
  }
  *((_DWORD *)this + 4) = v12;
  int64_t v13 = v8 - v9;
  *((void *)this + 3) = malloc_type_realloc(v9, (int)v12, 0x4F7D7E0EuLL);
  int v14 = malloc_type_realloc(*((void **)this + 4), 8 * *((int *)this + 1), 0x10040436913F5uLL);
  uint64_t v15 = *((void *)this + 3);
  uint64_t v8 = (unsigned char *)(v15 + v13);
  *((void *)this + 4) = v14;
  *((void *)this + 5) = v15 + v13;
  uint64_t v16 = *(unsigned int *)this;
  if ((int)v16 >= 1)
  {
    uint64_t v17 = 0;
    uint64_t v18 = v15 - (void)v9;
    uint64_t v19 = 8 * v16;
    do
    {
      *(void *)(*((void *)this + 4) + v17) += v18;
      v17 += 8;
    }
    while (v19 != v17);
    uint64_t v8 = (unsigned char *)*((void *)this + 5);
  }
LABEL_11:
  uint64_t result = memcpy(v8, __src, __n);
  *(unsigned char *)(*((void *)this + 5) + __n) = 0;
  uint64_t v22 = *((void *)this + 4);
  uint64_t v21 = *((void *)this + 5);
  uint64_t v23 = *(int *)this;
  *(_DWORD *)this = v23 + 1;
  *(void *)(v22 + 8 * v23) = v21;
  *((void *)this + 5) += __n + 1;
  return result;
}

double CI::CropImage::roi_of_child(CI::CropImage *this, CGRect a2)
{
  *(void *)&double result = (unint64_t)CGRectIntersection(a2, *(CGRect *)((char *)this + 120));
  return result;
}

uint64_t ___ZNK2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPKS0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZNK2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPKS0_E_block_invoke_0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN2CI4Node18BuildMapToUseCountEPS0__block_invoke(uint64_t a1, unint64_t a2)
{
  unint64_t v10 = a2;
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  uint64_t v3 = *(void **)(v2 + 8);
  if (!v3) {
    goto LABEL_12;
  }
  unsigned int v4 = (void *)(v2 + 8);
  do
  {
    unint64_t v5 = v3[4];
    BOOL v6 = v5 >= a2;
    if (v5 >= a2) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (v6) {
      unsigned int v4 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v4 != (void *)(v2 + 8) && v4[4] <= a2)
  {
    ++*((_DWORD *)v4 + 10);
    return 1;
  }
  else
  {
LABEL_12:
    uint64_t v11 = &v10;
    uint64_t v8 = std::__tree<std::__value_type<CI::Node const*,CI::useCountDepth>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,CI::useCountDepth>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,CI::useCountDepth>>>::__emplace_unique_key_args<CI::Node const*,std::piecewise_construct_t const&,std::tuple<CI::Node const* const&>,std::tuple<>>((uint64_t **)v2, &v10, (uint64_t)&std::piecewise_construct, (uint64_t **)&v11);
    uint64_t result = 0;
    *((_DWORD *)v8 + 10) = 1;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<CI::Node const*,CI::useCountDepth>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,CI::useCountDepth>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,CI::useCountDepth>>>::__emplace_unique_key_args<CI::Node const*,std::piecewise_construct_t const&,std::tuple<CI::Node const* const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v7 = a1 + 1;
  BOOL v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        BOOL v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      BOOL v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x48uLL);
    v11[4] = **a4;
    v11[5] = 0x100000000;
    v11[8] = 0;
    v11[7] = 0;
    v11[6] = (uint64_t)(v11 + 7);
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t CI::CropImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  return XXH64_update(a2, (char *)(a1 + 120), 0x20uLL);
}

uint64_t CI::ColorMatrixNode::add_to_kernel_hash(CI::ColorMatrixNode *this, const double (*a2)[4])
{
  if (CI::ColorMatrixNode::is_rrra((CI::ColorMatrixNode *)((char *)this + 56), a2))
  {
    unsigned int v4 = "builtin_colormatrix_rrra";
  }
  else if (CI::ColorMatrixNode::is_diagonal(this))
  {
    unsigned int v4 = "builtin_colormatrixdiag";
  }
  else if (CI::ColorMatrixNode::is_diagonal4(this))
  {
    unsigned int v4 = "builtin_colormatrixdiag4";
  }
  else if (CI::ColorMatrixNode::is_3x1(this))
  {
    unsigned int v4 = "builtin_colormatrix3x1";
  }
  else if (CI::ColorMatrixNode::is_3x3(this))
  {
    unsigned int v4 = "builtin_colormatrix3x3";
  }
  else if (CI::ColorMatrixNode::is_3x4(this))
  {
    unsigned int v4 = "builtin_colormatrix3x4";
  }
  else
  {
    unsigned int v4 = "builtin_colormatrix";
  }

  return CI::XXHashHelper::addstr((uint64_t)a2, v4);
}

uint64_t CI::ColorMatrixNode::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  return XXH64_update(a2, (char *)(a1 + 56), 0xA0uLL);
}

uint64_t CI::AffineNode::output_is_rg(CI::AffineNode *this)
{
  uint64_t result = (*(uint64_t (**)(CI::AffineNode *))(*(void *)this + 264))(this);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(**((void **)this + 5) + 272);
    return v3();
  }
  return result;
}

uint64_t ___ZN2CIL22prune_output_sRGB_nodeEPKNS_7ContextEPNS_4NodeEPNS_17TextureDescriptorE_block_invoke(uint64_t a1, CI::Object *a2, uint64_t a3)
{
  if ((*(unsigned int (**)(CI::Object *))(*(void *)a2 + 16))(a2) == 38)
  {
    int v6 = *((_DWORD *)a2 + 14);
    if (v6 == 1)
    {
      if ((*(unsigned int (**)(void, void, uint64_t))(**(void **)(a1 + 40) + 584))(*(void *)(a1 + 40), **(unsigned int **)(a1 + 48), 3))
      {
        *(unsigned char *)(*(void *)(a1 + 48) + 4) = 1;
        goto LABEL_10;
      }
      int v6 = *((_DWORD *)a2 + 14);
    }
    if (!v6)
    {
LABEL_10:
      uint64_t v8 = (*(uint64_t (**)(CI::Object *, void))(*(void *)a2 + 48))(a2, 0);
      if (a3)
      {
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)a3 + 200))(a3, v8, 0);
      }
      else
      {
        if (v8) {
          uint64_t v9 = CI::Object::ref(v8);
        }
        else {
          uint64_t v9 = 0;
        }
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v9;
        CI::Object::unref(a2);
      }
    }
  }
  else if ((*(unsigned int (**)(CI::Object *))(*(void *)a2 + 40))(a2) == 1 {
         && ((*(uint64_t (**)(CI::Object *, uint64_t))(*(void *)a2 + 248))(a2, 3) & 1) != 0)
  }
  {
    return 0;
  }
  return 1;
}

uint64_t ___ZN2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPS0_S1_iiE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

CI::CropNode *CI::CropImage::render_graph_core(uint64_t a1, uint64_t a2, CI::CropNode *a3, uint64_t a4, int a5)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 88))(a1);
  uint64_t v15 = *(void **)(a4 + 8);
  int v14 = (double *)(a4 + 8);
  int64_t v13 = v15;
  if (!v15) {
    goto LABEL_13;
  }
  CGFloat v16 = v9;
  CGFloat v17 = v10;
  CGFloat v18 = v11;
  CGFloat v19 = v12;
  unint64_t v20 = *(void *)(a1 + 80);
  uint64_t v21 = v14;
  do
  {
    unint64_t v22 = v13[4];
    BOOL v23 = v22 >= v20;
    if (v22 >= v20) {
      uint64_t v24 = v13;
    }
    else {
      uint64_t v24 = v13 + 1;
    }
    if (v23) {
      uint64_t v21 = (double *)v13;
    }
    int64_t v13 = (void *)*v24;
  }
  while (*v24);
  if (v21 == v14) {
    goto LABEL_13;
  }
  if (v20 < *((void *)v21 + 4)) {
    goto LABEL_13;
  }
  CGFloat v25 = v21[5];
  CGFloat v26 = v21[6];
  CGFloat v27 = v21[7];
  CGFloat v28 = v21[8];
  v34.origin.CGFloat x = v25;
  v34.origin.CGFloat y = v26;
  v34.size.CGFloat width = v27;
  v34.size.CGFloat height = v28;
  IsEmptCGFloat y = CGRectIsEmpty(v34);
  v35.origin.CGFloat x = v16;
  v35.origin.CGFloat y = v17;
  v35.size.CGFloat width = v18;
  v35.size.CGFloat height = v19;
  v36.origin.CGFloat x = v25;
  v36.origin.CGFloat y = v26;
  v36.size.CGFloat width = v27;
  v36.size.CGFloat height = v28;
  BOOL v30 = CGRectContainsRect(v35, v36);
  if (IsEmpty) {
LABEL_13:
  }
    operator new();
  BOOL v32 = v30;
  if (a3) {
    a3 = (CI::CropNode *)CI::Object::ref((uint64_t)a3);
  }
  if (v32 && !CI_GRAPH_FORCE_CROP()) {
    return a3;
  }
  uint64_t v33 = CI::CropNode::append_to_tree(a3, (CI::Node *)(a5 < 2), *(CGRect *)(a1 + 120));
  if (a3) {
    CI::Object::unref(a3);
  }
  return (CI::CropNode *)v33;
}

uint64_t CI::ColorKernelNode::short_name(CI::ColorKernelNode *this)
{
  return *(void *)(*((void *)this + 6) + 24);
}

uint64_t CI::SurfaceNode::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 64))
  {
    uint64_t __src = *(void *)(a1 + 64);
    uint64_t v4 = a2;
    size_t v5 = 8;
  }
  else
  {
    uint64_t __src = *(void *)(a1 + 56);
    XXH64_update(a2, (char *)&__src, 8uLL);
    LODWORD(__src) = *(_DWORD *)(a1 + 108);
    XXH64_update(a2, (char *)&__src, 4uLL);
    LODWORD(__src) = IOSurfaceGetID(*(IOSurfaceRef *)(a1 + 56));
    XXH64_update(a2, (char *)&__src, 4uLL);
    LODWORD(__src) = IOSurfaceGetSeed(*(IOSurfaceRef *)(a1 + 56));
    uint64_t v4 = a2;
    size_t v5 = 4;
  }
  XXH64_update(v4, (char *)&__src, v5);
  LODWORD(__src) = IOSurfaceGetPixelFormat(*(IOSurfaceRef *)(a1 + 56));
  XXH64_update(a2, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 96);
  XXH64_update(a2, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 100);
  XXH64_update(a2, (char *)&__src, 4uLL);
  LODWORD(__src) = *(unsigned __int8 *)(a1 + 104);
  XXH64_update(a2, (char *)&__src, 4uLL);
  LODWORD(__src) = *(unsigned __int8 *)(a1 + 52);
  return XXH64_update(a2, (char *)&__src, 4uLL);
}

uint64_t CI_GRAPH_FORCE_CROP()
{
  {
    CI_GRAPH_FORCE_CROP::v = get_BOOL("CI_GRAPH_FORCE_CROP", 0);
  }
  return CI_GRAPH_FORCE_CROP::v;
}

void sub_193685CE8(_Unwind_Exception *a1)
{
}

uint64_t CI::SwizzleNode::output_is_rg(CI::SwizzleNode *this)
{
  return (*((unsigned int *)this + 14) < 0x27uLL) & (0x6803000000uLL >> *((_DWORD *)this + 14));
}

uint64_t CI::SwizzleNode::output_is_r(CI::SwizzleNode *this)
{
  return (*((unsigned int *)this + 14) < 0x20uLL) & (0x88C00000 >> *((_DWORD *)this + 14));
}

uint64_t CI::SRGBNode::add_to_kernel_hash(uint64_t this, CI::XXHashHelper *a2)
{
  unsigned int v2 = *(_DWORD *)(this + 56) + 1;
  if (v2 <= 2) {
    return CI::XXHashHelper::addstr((uint64_t)a2, off_1E5775960[v2]);
  }
  return this;
}

uint64_t CI::SRGBNode::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  char __src = *(_DWORD *)(a1 + 56);
  return XXH64_update(a2, &__src, 1uLL);
}

uint64_t CI::SRGBNode::code_complexity(CI::SRGBNode *this)
{
  return 2;
}

uint64_t CI::PremultiplyNode::add_to_kernel_hash(uint64_t this, CI::XXHashHelper *a2)
{
  int v2 = *(_DWORD *)(this + 56);
  if (v2 == 1)
  {
    uint64_t v3 = "builtin_premultiply";
  }
  else
  {
    if (v2 != -1) {
      return this;
    }
    uint64_t v3 = "builtin_unpremultiply";
  }
  return CI::XXHashHelper::addstr((uint64_t)a2, v3);
}

uint64_t CI::PremultiplyNode::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  int __src = *(_DWORD *)(a1 + 56);
  return XXH64_update(a2, (char *)&__src, 4uLL);
}

const char *CI::AffineNode::short_name(CI::AffineNode *this)
{
  return "affine";
}

uint64_t CI::Node::is_rgb_invariant(CI::Node *this)
{
  if ((*(uint64_t (**)(CI::Node *))(*(void *)this + 224))(this)) {
    return 1;
  }
  uint64_t v3 = *(uint64_t (**)(CI::Node *))(*(void *)this + 232);

  return v3(this);
}

uint64_t CI::Context::setAbortflag(uint64_t this, char a2)
{
  *(unsigned char *)(this + 44) = a2;
  return this;
}

uint64_t *CI::ImageToNodeMap::add_ImageDigestForRG_to_node(uint64_t *result, unint64_t a2, CI::Object *this)
{
  uint64_t v3 = (uint64_t)result;
  unint64_t v10 = a2;
  uint64_t v4 = (void *)result[4];
  if (!v4) {
    goto LABEL_12;
  }
  size_t v5 = result + 4;
  do
  {
    unint64_t v6 = v4[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      uint64_t v8 = v4;
    }
    else {
      uint64_t v8 = v4 + 1;
    }
    if (v7) {
      size_t v5 = v4;
    }
    uint64_t v4 = (void *)*v8;
  }
  while (*v8);
  if (v5 == result + 4 || v5[4] > a2)
  {
LABEL_12:
    if (this) {
      uint64_t v9 = CI::Object::ref((uint64_t)this);
    }
    else {
      uint64_t v9 = 0;
    }
    double v11 = &v10;
    uint64_t result = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v3 + 24), &v10, (uint64_t)&std::piecewise_construct, (uint64_t **)&v11);
    result[5] = v9;
  }
  return result;
}

uint64_t CI::SurfaceNode::texture_bindable(CI::SurfaceNode *this)
{
  return (uint64_t)this + 48;
}

uint64_t CI::SwizzleImage::alpha_one(CI::SwizzleImage *this)
{
  int v2 = *((_DWORD *)this + 30);
  uint64_t result = 1;
  switch(v2)
  {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 36:
    case 48:
    case 49:
    case 61:
    case 62:
    case 64:
    case 65:
      return (*(uint64_t (**)(void))(**((void **)this + 13) + 128))();
    case 2:
    case 8:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 29:
    case 30:
    case 33:
    case 34:
    case 39:
      return 0;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 31:
    case 32:
    case 35:
    case 37:
    case 38:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 63:
      return result;
    default:
      if ((v2 - 87) < 2) {
        return (*(uint64_t (**)(void))(**((void **)this + 13) + 128))();
      }
      if (v2 == 84) {
        return 0;
      }
      return result;
  }
}

uint64_t CI::SwizzleImage::is_empty_if_regions_of_children_are_empty(CI::SwizzleImage *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 128))();
}

uint64_t CI::SwizzleNode::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  int __src = *(_DWORD *)(a1 + 56);
  return XXH64_update(a2, (char *)&__src, 4uLL);
}

uint64_t CI::SwizzleNode::code_complexity(CI::SwizzleNode *this)
{
  return 0;
}

void CI::SurfaceNode::release_resources(CI::SurfaceNode *this)
{
  int v2 = (const void *)*((void *)this + 7);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 7) = 0;
}

const char *CI::SRGBNode::short_name(CI::SRGBNode *this)
{
  uint64_t v1 = "linear_to_srgb";
  int v2 = *((_DWORD *)this + 14);
  uint64_t v3 = "srgb_invalid";
  if (!v2) {
    uint64_t v3 = "srgb_noop";
  }
  if (v2 != 1) {
    uint64_t v1 = v3;
  }
  if (v2 == -1) {
    return "srgb_to_linear";
  }
  else {
    return v1;
  }
}

CI::ClampToAlphaNode *CI::ClampToAlphaImage::render_graph_core(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (CI::Node *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 184))(a1);
  if (a3)
  {
    size_t v5 = (CI::ClampToAlphaNode *)CI::Object::ref(a3);
    unint64_t v6 = CI::ClampToAlphaNode::append_to_tree(v5, v4);
    if (v5) {
      CI::Object::unref(v5);
    }
    return v6;
  }
  else
  {
    return CI::ClampToAlphaNode::append_to_tree(0, v4);
  }
}

const char *CI::PremultiplyNode::short_name(CI::PremultiplyNode *this)
{
  uint64_t v1 = "premul";
  int v2 = *((_DWORD *)this + 14);
  uint64_t v3 = "badbremul";
  if (!v2) {
    uint64_t v3 = "nopremul";
  }
  if (v2 != 1) {
    uint64_t v1 = v3;
  }
  if (v2 == -1) {
    return "unpremul";
  }
  else {
    return v1;
  }
}

uint64_t CI::ClampImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  return XXH64_update(a2, (char *)(a1 + 120), 0x20uLL);
}

BOOL CI::AffineNode::is_identity(CI::AffineNode *this)
{
  return CI::Affine::isIdentity((CI::AffineNode *)((char *)this + 56));
}

uint64_t CI::CropImage::alpha_one(CI::CropImage *this)
{
  v9.origin.CGFloat x = (*(double (**)(void))(**((void **)this + 13) + 88))(*((void *)this + 13));
  if (!CGRectContainsRect(v9, *(CGRect *)((char *)this + 120))) {
    return 0;
  }
  CGFloat v2 = *((double *)this + 15);
  CGFloat v3 = *((double *)this + 16);
  CGFloat v4 = *((double *)this + 17);
  CGFloat v5 = *((double *)this + 18);
  v10.origin.CGFloat x = v2;
  v10.origin.CGFloat y = v3;
  v10.size.CGFloat width = v4;
  v10.size.CGFloat height = v5;
  CGRect v12 = CGRectIntegral(v10);
  v11.origin.CGFloat x = v2;
  v11.origin.CGFloat y = v3;
  v11.size.CGFloat width = v4;
  v11.size.CGFloat height = v5;
  if (!CGRectEqualToRect(v11, v12)) {
    return 0;
  }
  unint64_t v6 = *(uint64_t (**)(void))(**((void **)this + 13) + 128);

  return v6();
}

BOOL CI::ColorMatrixImage::is_empty_if_regions_of_children_are_empty(CI::ColorMatrixImage *this, const double (*a2)[4])
{
  return CI::ColorMatrixNode::is_alpha_preserving((CI::ColorMatrixImage *)((char *)this + 120), a2);
}

uint64_t CI::ColorMatrixImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  return XXH64_update(a2, (char *)(a1 + 120), 0xA0uLL);
}

const char *CI::ColorMatrixNode::short_name(CI::ColorMatrixNode *this)
{
  return "colormatrix";
}

uint64_t CI::SwizzleImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  int __src = *(_DWORD *)(a1 + 120);
  return XXH64_update(a2, (char *)&__src, 4uLL);
}

uint64_t CI::SwizzleNode::is_rgb_invariant(CI::SwizzleNode *this, char a2)
{
  unsigned int v2 = *((_DWORD *)this + 14);
  BOOL v3 = v2 == 0;
  BOOL v5 = v2 <= 0xB && ((1 << v2) & 0xC12) != 0 || v2 == 21;
  if (!v2) {
    BOOL v5 = 1;
  }
  BOOL v6 = v5;
  if (a2) {
    BOOL v3 = v6;
  }
  unsigned int v8 = v2 == 22 || v2 == 25 || v3;
  if ((a2 & 2) != 0) {
    return v8;
  }
  else {
    return v3;
  }
}

CGColorSpace *CI::ColorSpace_is_HDR(CGColorSpace *this, CGColorSpace *a2)
{
  if (this) {
    return (CGColorSpace *)CGColorSpaceIsHDR(this);
  }
  return this;
}

uint64_t CI::MetalContext::queue(CI::MetalContext *this)
{
  return *((void *)this + 49);
}

const char *CI::SwizzleNode::short_name(CI::SwizzleNode *this)
{
  return SwizzlerName(*((_DWORD *)this + 14));
}

void CI::ClampImage::roi_of_child(CI::ClampImage *this, CGRect a2)
{
}

BOOL x_stream_grow(char **a1, unint64_t a2)
{
  BOOL v3 = a1[2];
  CGFloat v4 = *a1;
  uint64_t v6 = v3 - v4;
  BOOL v5 = v6 == 0;
  uint64_t v7 = 2 * v6;
  if (v5) {
    uint64_t v7 = 1024;
  }
  do
  {
    size_t v8 = v7;
    CGRect v9 = (char *)(&v4[v7] - a1[1]);
    v7 *= 2;
  }
  while ((unint64_t)v9 < a2);
  CGRect v10 = (char *)malloc_type_realloc(v4, v8, 0x3BB4E2BEuLL);
  if (v10)
  {
    CGRect v11 = &v10[a1[1] - *a1];
    *a1 = v10;
    a1[1] = v11;
    a1[2] = &v10[v8];
  }
  return v10 != 0;
}

uint64_t CI::Node::is_identity(CI::Node *this)
{
  return 0;
}

const char *CI::ClampToAlphaNode::short_name(CI::ClampToAlphaNode *this)
{
  return "clamp_to_alpha";
}

void CI::SurfaceImage::restore_resources(CI::SurfaceImage *this, const void **a2)
{
  if ((*((unsigned int (**)(const void **))*a2 + 2))(a2) == 46)
  {
    CGFloat v4 = (const void *)*((void *)this + 14);
    if (a2[7] != v4)
    {
      int v5 = *((_DWORD *)this + 25);
      uint64_t v6 = *((void *)this + 15);
      CI::SurfaceNode::set_surface((uint64_t)a2, v5, v6, v4);
    }
  }
}

intptr_t CI::RenderTask::waitUntilScheduled(intptr_t this)
{
  uint64_t v1 = *(void *)(this + 144);
  if (v1 != *(void *)(this + 136)) {
    return dispatch_group_wait(*(dispatch_group_t *)(*(void *)(v1 - 8) + 24), 0xFFFFFFFFFFFFFFFFLL);
  }
  return this;
}

CI::ClampNode *CI::ClampImage::render_graph_core(uint64_t a1, int a2, CI::Object *this, uint64_t a4, int a5)
{
  if (this) {
    uint64_t v7 = (CI::ClampNode *)CI::Object::ref((uint64_t)this);
  }
  else {
    uint64_t v7 = 0;
  }
  if ((*(unsigned int (**)(CI::ClampNode *))(*(void *)v7 + 16))(v7) != 35)
  {
    uint64_t v9 = CI::ClampNode::append_to_tree(v7, v8, *(CGRect *)(a1 + 120));
    CI::Object::unref(v7);
    if (a5 >= 2)
    {
      CI::NoopNode::append_to_tree_and_unref();
    }
    return (CI::ClampNode *)v9;
  }
  return v7;
}

uint64_t CI::ClampNode::append_to_tree(CI::ClampNode *this, CI::Node *a2, CGRect a3)
{
  double height = a3.size.height;
  CGFloat width = a3.size.width;
  CGFloat y = a3.origin.y;
  CGFloat x = a3.origin.x;
  while (1)
  {
    while (1)
    {
      size_t v8 = this;
      if ((*(unsigned int (**)(CI::ClampNode *, CI::Node *))(*(void *)this + 16))(this, a2) == 35) {
        goto LABEL_31;
      }
      v52.origin.CGFloat x = (*(double (**)(CI::ClampNode *))(*(void *)this + 160))(this);
      if (CGRectIsInfinite(v52))
      {
        v63.origin.CGFloat x = (*(double (**)(CI::ClampNode *))(*(void *)this + 168))(this);
        v63.origin.CGFloat y = v9;
        v63.size.CGFloat width = v10;
        v63.size.double height = v11;
        v53.origin.CGFloat x = x;
        v53.origin.CGFloat y = y;
        v53.size.CGFloat width = width;
        v53.size.double height = height;
        if (CGRectContainsRect(v53, v63))
        {
LABEL_31:
          unint64_t v41 = this;
          goto LABEL_32;
        }
      }
      CGRect v12 = (CI::ClampNode *)(*(uint64_t (**)(CI::ClampNode *))(*(void *)this + 16))(this);
      if (v12 != 30) {
        break;
      }
      v57.origin.CGFloat x = x;
      v57.origin.CGFloat y = y;
      v57.size.CGFloat width = width;
      v57.size.double height = height;
      CI::ClampNode::adjust_roi_for_clamp_rect(v12, v57, *(CGRect *)((char *)this + 56));
      CGFloat x = v24;
      CGFloat y = v25;
      CGFloat width = v26;
      double height = v27;
      this = (CI::ClampNode *)(*(uint64_t (**)(CI::ClampNode *, void))(*(void *)this + 48))(this, 0);
    }
    if ((*(unsigned int (**)(CI::ClampNode *))(*(void *)this + 16))(this) == 28)
    {
      int64_t v13 = (double *)((char *)this + 56);
      double v14 = *((double *)this + 8);
      if (fabs(v14) < 0.0001 && (double v15 = *((double *)this + 9), fabs(v15) < 0.0001))
      {
        CGFloat v16 = *((double *)this + 7);
        double v17 = *((double *)this + 10);
      }
      else
      {
        CGFloat v16 = *v13;
        if (fabs(*v13) >= 0.0001) {
          goto LABEL_11;
        }
        double v17 = *((double *)this + 10);
        if (fabs(v17) >= 0.0001) {
          goto LABEL_11;
        }
        double v15 = *((double *)this + 9);
      }
      v49.a = v16;
      v49.b = v14;
      v49.c = v15;
      v49.d = v17;
      *(_OWORD *)&v49.tCGFloat x = *(_OWORD *)((char *)this + 88);
      memset(&v50, 0, sizeof(v50));
      CGAffineTransformInvert(&v50, &v49);
      CGAffineTransform v48 = v50;
      v60.origin.CGFloat x = x;
      v60.origin.CGFloat y = y;
      v60.size.CGFloat width = width;
      v60.size.double height = height;
      CGRect v61 = CGRectApplyAffineTransform(v60, &v48);
      CGFloat v42 = v61.origin.x;
      CGFloat v43 = v61.origin.y;
      CGFloat v44 = v61.size.width;
      CGFloat v45 = v61.size.height;
      uint64_t v46 = (CI::ClampNode *)(*(uint64_t (**)(CI::ClampNode *, void))(*(void *)this + 48))(this, 0);
      v62.origin.CGFloat x = v42;
      v62.origin.CGFloat y = v43;
      v62.size.CGFloat width = v44;
      v62.size.double height = v45;
      CI::ClampNode::append_to_tree(v46, v47, v62);
      operator new();
    }
LABEL_11:
    if ((*(unsigned int (**)(CI::ClampNode *))(*(void *)this + 16))(this) != 34) {
      goto LABEL_18;
    }
    this = (CI::ClampNode *)(*(uint64_t (**)(CI::ClampNode *, void))(*(void *)this + 48))(this, 0);
    v64.origin.CGFloat x = (*(double (**)(CI::ClampNode *))(*(void *)v8 + 160))(v8);
    v64.origin.CGFloat y = v18;
    v64.size.CGFloat width = v19;
    v64.size.double height = v20;
    v54.origin.CGFloat x = x;
    v54.origin.CGFloat y = y;
    v54.size.CGFloat width = width;
    v54.size.double height = height;
    if (CGRectEqualToRect(v54, v64))
    {
      v55.origin.CGFloat x = (*(double (**)(CI::ClampNode *))(*(void *)this + 160))(this);
      if (CGRectIsInfinite(v55))
      {
        v65.origin.CGFloat x = (*(double (**)(CI::ClampNode *))(*(void *)this + 168))(this);
        v65.origin.CGFloat y = v21;
        v65.size.CGFloat width = v22;
        v65.size.double height = v23;
        v56.origin.CGFloat x = x;
        v56.origin.CGFloat y = y;
        v56.size.CGFloat width = width;
        v56.size.double height = height;
        if (CGRectEqualToRect(v56, v65)) {
          break;
        }
      }
    }
    v66.origin.CGFloat x = x;
    v66.origin.CGFloat y = y;
    v66.size.CGFloat width = width;
    v66.size.double height = height;
    if (!CGRectContainsRect(*(CGRect *)((char *)v8 + 56), v66))
    {
LABEL_18:
      if ((*(unsigned int (**)(CI::ClampNode *))(*(void *)v8 + 16))(v8) != 28) {
        goto LABEL_30;
      }
      long long v28 = *(_OWORD *)((char *)v8 + 72);
      *(_OWORD *)&v50.a = *(_OWORD *)((char *)v8 + 56);
      *(_OWORD *)&v50.c = v28;
      *(_OWORD *)&v50.tCGFloat x = *(_OWORD *)((char *)v8 + 88);
      uint64_t v29 = (*(uint64_t (**)(CI::ClampNode *, void))(*(void *)v8 + 48))(v8, 0);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v29 + 16))(v29) != 34) {
        goto LABEL_30;
      }
      BOOL v30 = (CI::AffineNode *)(*(uint64_t (**)(uint64_t, void))(*(void *)v29 + 48))(v29, 0);
      unsigned int v31 = (*(uint64_t (**)(CI::AffineNode *))(*(void *)v30 + 16))(v30);
      if (!CI::is_image_type(v31)) {
        goto LABEL_30;
      }
      v67.origin.CGFloat x = (*(double (**)(uint64_t))(*(void *)v29 + 160))(v29);
      v67.origin.CGFloat y = v32;
      v67.size.CGFloat width = v33;
      v67.size.double height = v34;
      v58.origin.CGFloat x = x;
      v58.origin.CGFloat y = y;
      v58.size.CGFloat width = width;
      v58.size.double height = height;
      if (!CGRectEqualToRect(v58, v67)) {
        goto LABEL_30;
      }
      v68.origin.CGFloat x = (*(double (**)(CI::AffineNode *))(*(void *)v30 + 168))(v30);
      v68.origin.CGFloat y = v35;
      v68.size.CGFloat width = v36;
      v68.size.double height = v37;
      v59.origin.CGFloat x = x;
      v59.origin.CGFloat y = y;
      v59.size.CGFloat width = width;
      v59.size.double height = height;
      BOOL v38 = CGRectEqualToRect(v59, v68);
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&v50.a, (float64x2_t)xmmword_19395A440), (int32x4_t)vceqq_f64(*(float64x2_t *)&v50.c, (float64x2_t)xmmword_193953160))))) & 1) != 0|| v50.tx != 0.0)
      {
        goto LABEL_30;
      }
      if (!v38 || v50.ty != height) {
LABEL_30:
      }
        operator new();
      return CI::AffineNode::append_to_tree(v30, (CI::Node *)&v50, 0);
    }
  }
  unint64_t v41 = this;
LABEL_32:

  return CI::Object::ref((uint64_t)v41);
}

void CI::SurfaceNode::set_surface(uint64_t a1, int a2, uint64_t a3, CFTypeRef cf)
{
  *(_DWORD *)(a1 + 108) = a2;
  *(void *)(a1 + 64) = a3;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v6 = *(const void **)(a1 + 56);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(a1 + 56) = cf;
}

void *___ZL19getCustomAttributesP10objc_class_block_invoke(uint64_t a1)
{
  uint64_t result = (void *)[(id)registeredFilterConstructors valueForKey:NSStringFromClass(*(Class *)(a1 + 32))];
  if (result)
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [result mutableCopy];
    BOOL v3 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    uint64_t v4 = kCIConstructorKey;
    return (void *)[v3 removeObjectForKey:v4];
  }
  return result;
}

uint64_t register_more_builtins(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (register_more_builtins(void({block_pointer})(NSString *))::onceToken != -1) {
    dispatch_once(&register_more_builtins(void({block_pointer})(NSString *))::onceToken, &__block_literal_global_1066);
  }
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  unsigned int v2 = (void *)register_more_builtins(void({block_pointer})(NSString *))::moreList;
  uint64_t result = [(id)register_more_builtins(void({block_pointer})(NSString *))::moreList countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)v8;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        (*(void (**)(uint64_t, void))(a1 + 16))(a1, *(void *)(*((void *)&v7 + 1) + 8 * v6++));
      }
      while (v4 != v6);
      uint64_t result = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
      uint64_t v4 = result;
    }
    while (result);
  }
  return result;
}

uint64_t ___ZL23classNameIsSystemFilterP8NSString_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = [*(id *)(a1 + 32) isEqualToString:a2];
  if (result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
  return result;
}

uint64_t CI::MetalDAGHelper::add_write_pixel_function_info(uint64_t this, uint64_t a2)
{
  if (*(void *)(this + 64))
  {
    uint64_t v2 = this;
    if (*(void *)(this + 72))
    {
      uint64_t v4 = (void (***)(void))(***(uint64_t (****)(void, uint64_t))(this + 8))(*(void *)(this + 8), 4);
      (**v4)();
      ((void (*)(void (***)(void), uint64_t, uint64_t, void))**v4)(v4, 7, a2, 0);
      ((void (*)(void (***)(void), uint64_t, void, void))**v4)(v4, 6, 0, 0);
      ((void (*)(void (***)(void), uint64_t, void, void))**v4)(v4, 4, 0, 0);
      uint64_t v5 = *(uint64_t (**)(void))(**(void **)(v2 + 8) + 40);
      return v5();
    }
  }
  return this;
}

uint64_t CI::RenderTask::RenderTask(uint64_t a1, uint64_t a2, uint64_t a3, CI::Object *this, _OWORD *a5, int a6, uint64_t a7)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)a1 = &unk_1EE4577A8;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = *(void *)(a3 + 152);
  if (this)
  {
    uint64_t v11 = CI::Object::ref((uint64_t)this);
    a3 = *(void *)(a1 + 24);
  }
  else
  {
    uint64_t v11 = 0;
  }
  *(void *)(a1 + 40) = v11;
  long long v12 = a5[1];
  *(_OWORD *)(a1 + 48) = *a5;
  *(_OWORD *)(a1 + 64) = v12;
  *(_DWORD *)(a1 + 80) = a6;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 160) = 0;
  CI::Object::ref(a3);
  if (a7)
  {
    int64_t v13 = *(const void **)(a7 + 16);
    *(void *)(a1 + 96) = v13;
    if (v13) {
      CFRetain(v13);
    }
    *(void *)(a1 + 104) = (*(uint64_t (**)(uint64_t))(*(void *)a7 + 40))(a7);
    *(void *)(a1 + 112) = (*(uint64_t (**)(uint64_t))(*(void *)a7 + 48))(a7);
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a7 + 56))(a7);
  }
  else
  {
    uint64_t v14 = 0;
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
  }
  *(void *)(a1 + 120) = v14;
  *(CFAbsoluteTime *)(a1 + 160) = CFAbsoluteTimeGetCurrent();
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 168) = 0;
  if (a7 && !*(_DWORD *)(a1 + 80)) {
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a7 + 32);
  }
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  return a1;
}

void CI::MetalDAGHelper::add_arguments_for_image_node(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = v3 + 1;
  *a2 = v3;
  operator new();
}

void sub_1936886E4(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x1081C40C4ADF1D2);
  _Unwind_Resume(a1);
}

uint64_t CI::MetalDAGHelper::add_function_info(uint64_t a1, uint64_t a2, CI::ColorKernelNode *a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t v11 = *((void *)a3 + 6);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 16))(v11) != 62) {
    (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
  }
  if (*(unsigned char *)(v11 + 12)) {
    int v12 = CI::KernelArguments::count((CI::KernelArguments *)(v11 + 144));
  }
  else {
    int v12 = *(_DWORD *)(v11 + 20);
  }
  if (*(void *)(a1 + 64) && *(void *)(a1 + 72)) {
    int64_t v13 = (void (***)(void, uint64_t, uint64_t, void))(***(uint64_t (****)(void, void))(a1 + 8))(*(void *)(a1 + 8), v12);
  }
  else {
    int64_t v13 = 0;
  }
  signed int v14 = 0;
  while (1)
  {
    signed int v15 = *(unsigned char *)(v11 + 12) ? CI::KernelArguments::count((CI::KernelArguments *)(v11 + 144)) : *(_DWORD *)(v11 + 20);
    if (v14 >= v15) {
      break;
    }
    int v16 = CI::ColorKernelNode::kernel_argument_type(a3, v14);
    int v17 = v16;
    switch(v16)
    {
      case 30:
        if (v13) {
          (**v13)(v13, 7, a5, 0);
        }
        goto LABEL_43;
      case 31:
      case 32:
      case 33:
      case 34:
        goto LABEL_20;
      case 35:
        if (!v13) {
          goto LABEL_43;
        }
        CGFloat v18 = **v13;
        CGFloat v19 = v13;
        uint64_t v20 = 6;
        goto LABEL_36;
      case 36:
        if (!v13) {
          goto LABEL_43;
        }
        CGFloat v18 = **v13;
        CGFloat v19 = v13;
        uint64_t v20 = 4;
        goto LABEL_36;
      case 37:
        unint64_t v21 = CI::MetalDAGHelper::add_argument_type_and_offset(a1, 37, 0);
        if (v13) {
          (**v13)(v13, 4, 0, v21);
        }
        if (a4) {
          CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
        }
        goto LABEL_43;
      case 38:
        if (!v13) {
          goto LABEL_43;
        }
        CGFloat v18 = **v13;
        CGFloat v19 = v13;
        uint64_t v20 = 2;
LABEL_36:
        uint64_t v22 = 0;
        goto LABEL_42;
      case 39:
        if (*(unsigned char *)(v11 + 166))
        {
          uint64_t v22 = *(void *)(a1 + 80);
          *(void *)(a1 + 80) = v22 + 1;
          if (!v13) {
            goto LABEL_43;
          }
        }
        else
        {
          uint64_t v22 = 0;
          if (!v13) {
            goto LABEL_43;
          }
        }
        CGFloat v18 = **v13;
        CGFloat v19 = v13;
        uint64_t v20 = 2;
LABEL_42:
        v18(v19, v20, v22, 0);
LABEL_43:
        ++v14;
        break;
      default:
        if ((v16 - 1) >= 2 && v16 != 4)
        {
LABEL_20:
          CI::KernelArguments::is_uniform(v16);
          if ((a7 & 4) != 0 && *(unsigned char *)(v11 + 165))
          {
            if (v17 > 7)
            {
              if (v17 == 8 || v17 == 27) {
                int v17 = 15;
              }
            }
            else if (v17 == 6)
            {
              int v17 = 13;
            }
            else if (v17 == 7)
            {
              int v17 = 14;
            }
          }
          argument = (CI::Object *)CI::ColorKernelNode::get_argument(a3, v14);
          CI::SerialObjectPtrArray::append(a4, argument);
          unint64_t v24 = CI::MetalDAGHelper::add_argument_type_and_offset(a1, v17, argument);
          if (v13) {
            (**v13)(v13, 4, 0, v24);
          }
        }
        goto LABEL_43;
    }
  }
  double v25 = *(uint64_t (**)(void))(**(void **)(a1 + 8) + 40);

  return v25();
}

uint64_t CI::MetalDAGHelper::add_function_info(uint64_t a1, CI::SerialStringArray **a2, const CI::Kernel **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char *a8, unsigned __int8 a9, void *a10, char a11)
{
  int64_t v13 = (CI::ColorKernelNode *)a3;
  int v16 = a3[6];
  if ((*(unsigned int (**)(const CI::Kernel *))(*(void *)v16 + 16))(v16) != 62) {
    (*(void (**)(const CI::Kernel *))(*(void *)v16 + 16))(v16);
  }
  if (*((unsigned char *)v16 + 12)) {
    int v17 = CI::KernelArguments::count((const CI::Kernel *)((char *)v16 + 144));
  }
  else {
    int v17 = *((_DWORD *)v16 + 5);
  }
  uint64_t v18 = v17;
  if (*(_DWORD *)(a1 + 32) == 1)
  {
    for (signed int i = 0; ; ++i)
    {
      signed int v20 = *((unsigned char *)v16 + 12)
          ? CI::KernelArguments::count((const CI::Kernel *)((char *)v16 + 144))
          : *((_DWORD *)v16 + 5);
      if (i >= v20) {
        break;
      }
      if (CI::ColorKernelNode::kernel_argument_type(v13, i) == 31) {
        v18 += 5;
      }
    }
  }
  CGRect v94 = a2;
  if (*(void *)(a1 + 64) && *(void *)(a1 + 72)) {
    unint64_t v21 = (void (***)(void, uint64_t, void, void))(***(uint64_t (****)(void, uint64_t))(a1 + 8))(*(void *)(a1 + 8), v18);
  }
  else {
    unint64_t v21 = 0;
  }
  signed int v22 = 0;
  char v101 = 0;
  CGFloat v23 = (const CI::Kernel *)((char *)v16 + 144);
  CGRect v92 = v13;
  CGRect v93 = (const CI::ProgramNode *)(a8 + 1);
  CGRect v96 = (uint64_t **)(a1 + 128);
  uint64_t v98 = a6 + 1;
  CGRect v99 = (void *)(a1 + 136);
  uint64_t v95 = a1 + 152;
  CGRect v88 = (uint64_t **)(a1 + 176);
  uint64_t v89 = a6 + 2;
  uint64_t v85 = (uint64_t)&a8[a6 + 3];
  CGRect v100 = (const CI::Kernel *)((char *)v16 + 144);
  CGRect v90 = (CI::MetalDAGHelper *)a1;
  CGRect v86 = a8;
  CGRect v87 = v16;
  while (1)
  {
    signed int v24 = *((unsigned char *)v16 + 12) ? CI::KernelArguments::count(v23) : *((_DWORD *)v16 + 5);
    if (v22 >= v24) {
      break;
    }
    int v25 = CI::ColorKernelNode::kernel_argument_type(v13, v22);
    int v26 = v25;
    if (v25 <= 29)
    {
      switch(v25)
      {
        case 1:
          goto LABEL_34;
        case 2:
          break;
        case 4:
LABEL_34:
          argument = (const char *)CI::ColorKernelNode::get_argument(v13, v22);
          CGFloat v33 = (CI::Node *)argument;
          if (v26 == 4)
          {
            (*(void (**)(const char *))(*(void *)argument + 232))(argument);
            CI::Node::rois_count(v33);
            __p[0] = 0;
            __p[0] = (void *)CI::hash_image_node_id((uint64_t)v33, 0);
            v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
            CGFloat v34 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v88, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, &v106);
            if (v21) {
              (**v21)(v21, 0, v34[5], 0);
            }
          }
          else
          {
            a8[v98] = v101 + 48;
            a8[v89] = 0;
            uint64_t v46 = CI::replaceWithLeaf(v94, v93, argument, v32);
            uint64_t v47 = (void *)CI::hash_dag_node_id((unint64_t)v46, a7, a8);
            if ((*(unsigned int (**)(const char *))(*(void *)v46 + 232))(v46))
            {
              uint64_t v48 = v85;
              do
              {
                CGAffineTransform v49 = (const char *)(*(uint64_t (**)(const char *, void))(*(void *)v46 + 48))(v46, 0);
                *(_WORD *)(v48 - 1) = 48;
                uint64_t v46 = CI::replaceWithLeaf(v94, v93, v49, v50);
                uint64_t v47 = (void *)CI::hash_dag_node_id((unint64_t)v46, (uint64_t)v47, a8);
                ++v48;
              }
              while (((*(uint64_t (**)(const char *))(*(void *)v46 + 232))(v46) & 1) != 0);
            }
            unsigned int v51 = (void *)*v99;
            int64_t v13 = v92;
            a1 = (uint64_t)v90;
            CGFloat v23 = v100;
            CGRect v52 = v96;
            int v16 = v87;
            if (!*v99) {
              goto LABEL_84;
            }
            CGRect v53 = v99;
            do
            {
              unint64_t v54 = v51[4];
              BOOL v55 = v54 >= (unint64_t)v47;
              if (v54 >= (unint64_t)v47) {
                CGRect v56 = v51;
              }
              else {
                CGRect v56 = v51 + 1;
              }
              if (v55) {
                CGRect v53 = v51;
              }
              unsigned int v51 = (void *)*v56;
            }
            while (*v56);
            if (v53 == v99 || (unint64_t)v47 < v53[4])
            {
LABEL_84:
              v105 = v47;
              __p[0] = &v105;
              CGRect v57 = std::__tree<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::MetalDAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v95, (unint64_t *)&v105, (uint64_t)&std::piecewise_construct, (void **)__p);
              CGRect v58 = v57;
              if (*((char *)v57 + 63) < 0) {
                std::string::__init_copy_ctor_external(&v106, (const std::string::value_type *)v57[5], v57[6]);
              }
              else {
                std::string v106 = *(std::string *)(v57 + 5);
              }
              std::vector<unsigned long>::vector(v107, (uint64_t)(v58 + 8));
              char v108 = *((unsigned char *)v58 + 88);
              if (a11)
              {
                if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  size_t size = HIBYTE(v106.__r_.__value_.__r.__words[2]);
                }
                else {
                  size_t size = v106.__r_.__value_.__l.__size_;
                }
                std::string::basic_string[abi:nn180100]((uint64_t)__p, size + 2);
                if (v104 >= 0) {
                  unsigned int v69 = __p;
                }
                else {
                  unsigned int v69 = (void **)__p[0];
                }
                if (size)
                {
                  if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    uint64_t v70 = &v106;
                  }
                  else {
                    uint64_t v70 = (std::string *)v106.__r_.__value_.__r.__words[0];
                  }
                  memmove(v69, v70, size);
                }
                strcpy((char *)v69 + size, "_h");
                if (v104 >= 0) {
                  unsigned int v71 = __p;
                }
                else {
                  unsigned int v71 = (void **)__p[0];
                }
                CI::MetalDAGHelper::add_function_with_name(v90, (const char *)v71, 0);
                CGRect v52 = v96;
                if (v104 < 0) {
                  operator delete(__p[0]);
                }
                std::string::size_type v72 = HIBYTE(v106.__r_.__value_.__r.__words[2]);
                if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  std::string::size_type v72 = v106.__r_.__value_.__l.__size_;
                }
                if (v72 != 14) {
                  goto LABEL_153;
                }
                double v73 = &v106;
                if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  double v73 = (std::string *)v106.__r_.__value_.__r.__words[0];
                }
                std::string::size_type v74 = v73->__r_.__value_.__r.__words[0];
                uint64_t v75 = *(std::string::size_type *)((char *)v73->__r_.__value_.__r.__words + 6);
                if (v74 == 0x646165725F69635FLL && v75 == 0x6C657869705F6461) {
                  CI::MetalDAGHelper::add_read_pixel_function_info((uint64_t)v90, *(void *)v107[0], *((void *)v107[0] + 1), *((void *)v107[0] + 2), *((void *)v107[0] + 3));
                }
                else {
LABEL_153:
                }
                  CI::MetalDAGHelper::add_read_pixel_420_function_info((uint64_t)v90, *(void *)v107[0], *((void *)v107[0] + 1), *((void *)v107[0] + 2), *((void *)v107[0] + 3), *((void *)v107[0] + 4), *((void *)v107[0] + 5), *((void *)v107[0] + 6));
                uint64_t v77 = (*a10)++;
                v105 = v47;
                __p[0] = &v105;
                *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, (unint64_t *)&v105, (uint64_t)&std::piecewise_construct, (uint64_t **)__p)+ 24) = v77;
                if (v108)
                {
                  CI::MetalDAGHelper::add_function_with_name(v90, "_ci_srgb_to_linear_h", 0);
                  v105 = v47;
                  __p[0] = &v105;
                  std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, (unint64_t *)&v105, (uint64_t)&std::piecewise_construct, (uint64_t **)__p);
                  CI::MetalDAGHelper::add_colour_inout_function_info((uint64_t)v90);
                  uint64_t v78 = (*a10)++;
                  v105 = v47;
                  __p[0] = &v105;
                  *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, (unint64_t *)&v105, (uint64_t)&std::piecewise_construct, (uint64_t **)__p)+ 24) = v78;
                }
                v105 = v47;
                __p[0] = &v105;
                CGFloat v23 = v100;
                *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, (unint64_t *)&v105, (uint64_t)&std::piecewise_construct, (uint64_t **)__p)+ 20) = 0;
              }
              else
              {
                if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  CGRect v60 = &v106;
                }
                else {
                  CGRect v60 = (std::string *)v106.__r_.__value_.__r.__words[0];
                }
                CI::MetalDAGHelper::add_function_with_name(v90, (const char *)v60, 0);
                CGRect v52 = v96;
                std::string::size_type v61 = HIBYTE(v106.__r_.__value_.__r.__words[2]);
                if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  std::string::size_type v61 = v106.__r_.__value_.__l.__size_;
                }
                if (v61 != 14) {
                  goto LABEL_124;
                }
                CGRect v62 = &v106;
                if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  CGRect v62 = (std::string *)v106.__r_.__value_.__r.__words[0];
                }
                std::string::size_type v63 = v62->__r_.__value_.__r.__words[0];
                uint64_t v64 = *(std::string::size_type *)((char *)v62->__r_.__value_.__r.__words + 6);
                if (v63 == 0x646165725F69635FLL && v64 == 0x6C657869705F6461) {
                  CI::MetalDAGHelper::add_read_pixel_function_info((uint64_t)v90, *(void *)v107[0], *((void *)v107[0] + 1), *((void *)v107[0] + 2), *((void *)v107[0] + 3));
                }
                else {
LABEL_124:
                }
                  CI::MetalDAGHelper::add_read_pixel_420_function_info((uint64_t)v90, *(void *)v107[0], *((void *)v107[0] + 1), *((void *)v107[0] + 2), *((void *)v107[0] + 3), *((void *)v107[0] + 4), *((void *)v107[0] + 5), *((void *)v107[0] + 6));
                uint64_t v66 = (*a10)++;
                v105 = v47;
                __p[0] = &v105;
                *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, (unint64_t *)&v105, (uint64_t)&std::piecewise_construct, (uint64_t **)__p)+ 20) = v66;
                if (v108)
                {
                  CI::MetalDAGHelper::add_function_with_name(v90, "_ci_srgb_to_linear", 0);
                  v105 = v47;
                  __p[0] = &v105;
                  std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, (unint64_t *)&v105, (uint64_t)&std::piecewise_construct, (uint64_t **)__p);
                  CI::MetalDAGHelper::add_colour_inout_function_info((uint64_t)v90);
                  uint64_t v67 = (*a10)++;
                  v105 = v47;
                  __p[0] = &v105;
                  *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, (unint64_t *)&v105, (uint64_t)&std::piecewise_construct, (uint64_t **)__p)+ 20) = v67;
                }
                v105 = v47;
                __p[0] = &v105;
                CGFloat v23 = v100;
                *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, (unint64_t *)&v105, (uint64_t)&std::piecewise_construct, (uint64_t **)__p)+ 24) = 0;
              }
              __p[0] = v47;
              std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__erase_unique<unsigned long long>(v95, (unint64_t *)__p);
              if (v107[0])
              {
                v107[1] = v107[0];
                operator delete(v107[0]);
              }
              if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v106.__r_.__value_.__l.__data_);
              }
            }
            if (a11)
            {
              __p[0] = v47;
              v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
              if (!*((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v52, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, (uint64_t **)&v106)+ a9+ 24))
              {
                CI::MetalDAGHelper::add_function_with_name(v90, "_ci_float_to_half", 0);
                __p[0] = v47;
                v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
                std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v52, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, (uint64_t **)&v106);
                CI::MetalDAGHelper::add_colour_inout_function_info((uint64_t)v90);
                uint64_t v81 = (*a10)++;
                __p[0] = v47;
                v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
                *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v52, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, (uint64_t **)&v106)+ a9+ 24) = v81;
                CGFloat v23 = v100;
                __p[0] = v47;
                v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
                *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v52, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, (uint64_t **)&v106)+ a9+ 20) = 0;
              }
              __p[0] = v47;
              v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
              uint64_t v80 = *((unsigned __int16 *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v52, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, (uint64_t **)&v106)+ a9+ 24);
              int64_t v13 = v92;
            }
            else
            {
              __p[0] = v47;
              v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
              if (!*((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v52, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, (uint64_t **)&v106)+ a9+ 20))
              {
                CI::MetalDAGHelper::add_function_with_name(v90, "_ci_half_to_float", 0);
                __p[0] = v47;
                v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
                std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v52, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, (uint64_t **)&v106);
                CI::MetalDAGHelper::add_colour_inout_function_info((uint64_t)v90);
                uint64_t v79 = (*a10)++;
                __p[0] = v47;
                v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
                *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v52, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, (uint64_t **)&v106)+ a9+ 20) = v79;
                CGFloat v23 = v100;
                __p[0] = v47;
                v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
                *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v52, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, (uint64_t **)&v106)+ a9+ 24) = 0;
              }
              __p[0] = v47;
              v106.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
              uint64_t v80 = *((unsigned __int16 *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v52, (unint64_t *)__p, (uint64_t)&std::piecewise_construct, (uint64_t **)&v106)+ a9+ 20);
            }
            a8 = v86;
            if (v21) {
              (**v21)(v21, 7, v80, 0);
            }
            v86[v98] = 0;
          }
          ++v101;
          break;
        default:
LABEL_64:
          CI::KernelArguments::is_uniform(v25);
          if ((a11 & 4) != 0 && *((unsigned char *)v16 + 165))
          {
            if (v26 > 7)
            {
              if (v26 == 8 || v26 == 27) {
                int v26 = 15;
              }
            }
            else if (v26 == 6)
            {
              int v26 = 13;
            }
            else if (v26 == 7)
            {
              int v26 = 14;
            }
          }
          CGRect v82 = (CI::Object *)CI::ColorKernelNode::get_argument(v13, v22);
          CI::SerialObjectPtrArray::append(a4, v82);
          unint64_t v83 = CI::MetalDAGHelper::add_argument_type_and_offset(a1, v26, v82);
          if (v21) {
            (**v21)(v21, 4, 0, v83);
          }
          break;
      }
    }
    else
    {
      switch(v25)
      {
        case 30:
          if (!v21) {
            break;
          }
          uint64_t v40 = **v21;
          unint64_t v41 = v21;
          uint64_t v42 = 7;
          uint64_t v43 = a5;
          goto LABEL_107;
        case 31:
        case 32:
          if (*(_DWORD *)(a1 + 32) == 2)
          {
            if (*(void *)(a1 + 64)
              && *(void *)(a1 + 72)
              && (double v27 = (void (***)(void, uint64_t, uint64_t, void))(***(uint64_t (****)(void, uint64_t))(a1 + 8))(*(void *)(a1 + 8), 6)) != 0)
            {
              long long v28 = v27;
              (**v27)(v27, 8, a5, 0);
              (**v28)(v28, 6, 0, 0);
              (**v28)(v28, 4, 0, 0);
              unint64_t v29 = CI::MetalDAGHelper::add_argument_type_and_offset(a1, 37, 0);
              (**v28)(v28, 4, 0, v29);
              char v30 = 0;
            }
            else
            {
              CI::MetalDAGHelper::add_argument_type_and_offset(a1, 37, 0);
              long long v28 = 0;
              char v30 = 1;
            }
            if (a4) {
              CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
            }
            if ((v30 & 1) == 0) {
              (**v28)(v28, 2, 0, 0);
            }
            if (*((unsigned char *)v16 + 166))
            {
              ++*(void *)(a1 + 80);
              if ((v30 & 1) == 0) {
                goto LABEL_93;
              }
            }
            else if ((v30 & 1) == 0)
            {
LABEL_93:
              ((void (*)(void (***)(void, uint64_t, void, unint64_t), uint64_t))**v28)(v28, 2);
            }
            uint64_t v59 = (*(uint64_t (**)(void, void (***)(void, uint64_t, void, unint64_t), BOOL))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), v28, v26 == 32);
            if (v21) {
              ((void (*)(void (***)(void, uint64_t, void, void), uint64_t))(*v21)[1])(v21, v59);
            }
            break;
          }
          if (v21)
          {
            (**v21)(v21, 8, a5, 0);
            (**v21)(v21, 6, 0, 0);
            (**v21)(v21, 4, 0, 0);
            unint64_t v45 = CI::MetalDAGHelper::add_argument_type_and_offset(a1, 37, 0);
            (**v21)(v21, 4, 0, v45);
          }
          else
          {
            CI::MetalDAGHelper::add_argument_type_and_offset(a1, 37, 0);
          }
          if (a4) {
            CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
          }
          if (v21) {
            (**v21)(v21, 2, 0, 0);
          }
LABEL_102:
          if (*((unsigned char *)v16 + 166))
          {
            uint64_t v43 = *(void *)(a1 + 80);
            *(void *)(a1 + 80) = v43 + 1;
            if (!v21) {
              break;
            }
          }
          else
          {
            uint64_t v43 = 0;
            if (!v21) {
              break;
            }
          }
          uint64_t v40 = **v21;
          unint64_t v41 = v21;
          uint64_t v42 = 2;
LABEL_107:
          v40(v41, v42, v43, 0);
          break;
        case 33:
        case 34:
          if (*(void *)(a1 + 64)
            && *(void *)(a1 + 72)
            && (CGFloat v35 = (void (***)(void, uint64_t, uint64_t, void))(***(uint64_t (****)(void, uint64_t))(a1 + 8))(*(void *)(a1 + 8), 5)) != 0)
          {
            CGFloat v36 = v35;
            (**v35)(v35, 7, a5, 0);
            (**v36)(v36, 6, 0, 0);
            (**v36)(v36, 4, 0, 0);
            unint64_t v37 = CI::MetalDAGHelper::add_argument_type_and_offset(a1, 37, 0);
            (**v36)(v36, 4, 0, v37);
            char v38 = 0;
          }
          else
          {
            CI::MetalDAGHelper::add_argument_type_and_offset(a1, 37, 0);
            CGFloat v36 = 0;
            char v38 = 1;
          }
          if (a4) {
            CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
          }
          if ((v38 & 1) == 0) {
            (**v36)(v36, 2, 0, 0);
          }
          uint64_t v39 = (*(uint64_t (**)(void, void (***)(void, uint64_t, void, unint64_t), BOOL))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), v36, v26 == 34);
          if (v21) {
            ((void (*)(void (***)(void, uint64_t, void, void), uint64_t))(*v21)[1])(v21, v39);
          }
          CGFloat v23 = v100;
          break;
        case 35:
          if (!v21) {
            break;
          }
          uint64_t v40 = **v21;
          unint64_t v41 = v21;
          uint64_t v42 = 6;
          goto LABEL_61;
        case 36:
          if (!v21) {
            break;
          }
          uint64_t v40 = **v21;
          unint64_t v41 = v21;
          uint64_t v42 = 4;
          goto LABEL_61;
        case 37:
          unint64_t v44 = CI::MetalDAGHelper::add_argument_type_and_offset(a1, 37, 0);
          if (v21) {
            (**v21)(v21, 4, 0, v44);
          }
          if (a4) {
            CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
          }
          break;
        case 38:
          if (!v21) {
            break;
          }
          uint64_t v40 = **v21;
          unint64_t v41 = v21;
          uint64_t v42 = 2;
LABEL_61:
          uint64_t v43 = 0;
          goto LABEL_107;
        case 39:
          goto LABEL_102;
        default:
          goto LABEL_64;
      }
    }
    ++v22;
  }
  CI::MetalDAGHelper::add_function_for_kernel((CI::MetalDAGHelper *)a1, v16);
  return (*(uint64_t (**)(void, void (***)(void, uint64_t, void, void)))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), v21);
}

void sub_193689F34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  CI::DAGHelper::TextureReadFunction::~TextureReadFunction((CI::DAGHelper::TextureReadFunction *)(v36 - 160));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  long long v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        long long v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        long long v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        long long v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    long long v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x38uLL);
    v11[4] = **a4;
    v11[5] = 0;
    v11[6] = 0;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t CI::ColorKernelNode::kernel_argument_type(CI::ColorKernelNode *this, signed int a2)
{
  uint64_t v4 = *((void *)this + 6);
  if (*(unsigned char *)(v4 + 12))
  {
    uint64_t type = CI::KernelArguments::get_type((CI::KernelArguments *)(v4 + 144), a2);
  }
  else
  {
    if (*(_DWORD *)(v4 + 20) <= a2) {
      return 0;
    }
    uint64_t type = *(unsigned int *)(*(void *)(v4 + 72) + 4 * a2);
  }
  if (type == 15 || type == 8)
  {
    uint64_t v7 = *((void *)this + 7);
    if (a2 > 9) {
      unint64_t v8 = (void *)(*(void *)(v7 + 16) + 8 * (a2 - 10));
    }
    else {
      unint64_t v8 = (void *)(v7 + 8 * a2 + 24);
    }
    uint64_t v9 = *v8;
    if ((*(int (**)(void))(*(void *)*v8 + 16))(*v8) >= 27
      && (*(int (**)(uint64_t))(*(void *)v9 + 16))(v9) < 53)
    {
      return 1;
    }
  }
  return type;
}

uint64_t CI::ColorKernelNode::get_argument(CI::ColorKernelNode *this, unsigned int a2)
{
  uint64_t result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = *((void *)this + 7);
    if (v4)
    {
      if (*(_DWORD *)v4 <= (signed int)a2)
      {
        return 0;
      }
      else
      {
        if (a2 > 9) {
          uint64_t v5 = *(void *)(v4 + 16) + 8 * (a2 - 10);
        }
        else {
          uint64_t v5 = v4 + 8 * a2 + 24;
        }
        return *(void *)v5;
      }
    }
  }
  return result;
}

unint64_t CI::MetalDAGHelper::add_argument_type_and_offset(uint64_t a1, int a2, void *a3)
{
  if (a3 && (*(unsigned int (**)(void *))(*a3 + 16))(a3) == 57)
  {
    unint64_t next_offset = (*(void *)(a1 + 96) + 15) & 0xFFFFFFFFFFFFFFF0;
    CFDataRef Length = (const __CFData *)a3[3];
    if (Length) {
      CFDataRef Length = (const __CFData *)CFDataGetLength(Length);
    }
    *(void *)(a1 + 96) = (char *)Length + next_offset;
  }
  else
  {
    unint64_t next_offset = (int)CI::MetalMainProgram::get_next_offset(a2, (unint64_t *)(a1 + 96));
  }
  unint64_t v8 = *(void ***)(a1 + 64);
  if (v8 && *(void *)(a1 + 72))
  {
    CI::SerialValArray<int>::append(v8, a2);
    CI::SerialValArray<int>::append(*(void ***)(a1 + 72), next_offset);
  }
  return next_offset;
}

uint64_t CI::MetalMainProgram::get_next_offset(int a1, unint64_t *a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  int v4 = a1 - 5;
  unint64_t v5 = *a2;
  switch(v4)
  {
    case 0:
    case 8:
    case 14:
    case 18:
      unint64_t v5 = (v5 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v6 = v5 + 4;
      goto LABEL_14;
    case 1:
    case 9:
    case 10:
    case 15:
    case 19:
      unint64_t v5 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
      goto LABEL_5;
    case 2:
    case 3:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
      unint64_t v5 = (v5 + 15) & 0xFFFFFFFFFFFFFFF0;
      goto LABEL_3;
    case 4:
      unint64_t v5 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
LABEL_3:
      unint64_t v6 = v5 + 16;
      goto LABEL_14;
    case 5:
    case 35:
    case 37:
    case 38:
    case 39:
      unint64_t v5 = (v5 + 15) & 0xFFFFFFFFFFFFFFF0;
      unint64_t v6 = v5 + 48;
      goto LABEL_14;
    case 6:
    case 32:
    case 36:
    case 40:
      unint64_t v5 = (v5 + 15) & 0xFFFFFFFFFFFFFFF0;
      unint64_t v6 = v5 + 64;
      goto LABEL_14;
    case 7:
      unint64_t v5 = (v5 + 1) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v6 = v5 + 2;
      goto LABEL_14;
    case 11:
      unint64_t v5 = (v5 + 3) & 0xFFFFFFFFFFFFFFFCLL;
LABEL_5:
      unint64_t v6 = v5 + 8;
      goto LABEL_14;
    case 12:
      unint64_t v5 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v6 = v5 + 24;
      goto LABEL_14;
    case 13:
      unint64_t v5 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v6 = v5 + 32;
LABEL_14:
      *a2 = v6;
      goto LABEL_15;
    case 41:
    case 42:
LABEL_15:
      uint64_t result = v5;
      break;
    default:
      return result;
  }
  return result;
}

void CI::StitchableFunctionDAGDescriptor::ArgumentInfo::add(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
      unint64_t v8 = objc_opt_new();
      id v13 = v8;
      goto LABEL_7;
    case 4:
    case 5:
      id v13 = (id)objc_opt_new();
      [v13 setByteOffset:a4];
      [v13 setDereference:a2 == 4];
      unint64_t v8 = v13;
LABEL_7:
      [v8 setBindIndex:a3];
      uint64_t v11 = *(void **)(a1 + 16);
      uint64_t v12 = (uint64_t)v13;
      goto LABEL_9;
    case 6:
    case 9:
    case 10:
      uint64_t v12 = objc_opt_new();
      id v13 = (id)v12;
      uint64_t v11 = *(void **)(a1 + 16);
LABEL_9:
      [v11 addObject:v12];

      break;
    case 7:
    case 8:
      uint64_t v9 = *(void **)(a1 + 16);
      uint64_t v10 = [*(id *)(a1 + 24) objectAtIndexedSubscript:*(int *)(**(void **)(a1 + 32) + 4 * a3)];
      [v9 addObject:v10];
      break;
    default:
      abort();
  }
}

BOOL CI::KernelArguments::is_uniform(int a1)
{
  return (a1 - 5) < 0x17;
}

void **CI::SerialValArray<int>::append(void **result, int a2)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)result;
  int v5 = *((_DWORD *)result + 1);
  if (*(_DWORD *)result >= v5)
  {
    int v6 = *((_DWORD *)result + 2) + v5;
    *((_DWORD *)result + 1) = v6;
    uint64_t result = (void **)malloc_type_realloc(result[2], 4 * (v6 - 10), 0x100004052888210uLL);
    v3[2] = result;
    int v4 = *(_DWORD *)v3;
  }
  if (v4 > 9) {
    uint64_t v7 = (char *)v3[2] + 4 * (v4 - 10);
  }
  else {
    uint64_t v7 = (_DWORD *)v3 + v4 + 6;
  }
  *uint64_t v7 = a2;
  ++*(_DWORD *)v3;
  return result;
}

void CI::StitchableFunctionDAGDescriptor::create_function_info(uint64_t a1, uint64_t a2)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
    id v4 = objc_alloc(MEMORY[0x1E4F35260]);
    uint64_t v5 = *(void *)(a1 + 112);
    v20[0] = *(void *)(a1 + 40);
    int v6 = objc_msgSend(v4, "initWithName:arguments:controlDependencies:", v5, v3, objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v20, 1));
    [*(id *)(a1 + 72) addObject:v6];
    unint64_t v7 = *(void *)(a1 + 64);
    int v8 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)(a1 + 80) = v8 + 1;
    uint64_t v9 = *(char **)(a1 + 56);
    if ((unint64_t)v9 >= v7)
    {
      uint64_t v11 = *(char **)(a1 + 48);
      uint64_t v12 = (v9 - v11) >> 2;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 62) {
        abort();
      }
      uint64_t v14 = v7 - (void)v11;
      if (v14 >> 1 > v13) {
        unint64_t v13 = v14 >> 1;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        int v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>(a1 + 64, v15);
        uint64_t v11 = *(char **)(a1 + 48);
        uint64_t v9 = *(char **)(a1 + 56);
      }
      else
      {
        int v16 = 0;
      }
      int v17 = &v16[4 * v12];
      uint64_t v18 = &v16[4 * v15];
      *(_DWORD *)int v17 = v8;
      uint64_t v10 = v17 + 4;
      while (v9 != v11)
      {
        int v19 = *((_DWORD *)v9 - 1);
        v9 -= 4;
        *((_DWORD *)v17 - 1) = v19;
        v17 -= 4;
      }
      *(void *)(a1 + 48) = v17;
      *(void *)(a1 + 56) = v10;
      *(void *)(a1 + 64) = v18;
      if (v11) {
        operator delete(v11);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v9 = v8;
      uint64_t v10 = v9 + 4;
    }
    *(void *)(a1 + 56) = v10;
  }
}

const char *CI::replaceWithLeaf(CI::SerialStringArray **this, const CI::ProgramNode *a2, const char *a3, const CI::Node *a4)
{
  uint64_t IndexOfString = CI::SerialStringArray::firstIndexOfString(this[7], (const char *)a2);
  if (IndexOfString == -1) {
    return a3;
  }
  unint64_t v7 = (uint64_t (*)(CI::SerialStringArray **, uint64_t))*((void *)*this + 6);

  return (const char *)v7(this, IndexOfString);
}

uint64_t CI::MetalDAGHelper::add_function_for_kernel(CI::MetalDAGHelper *this, const CI::Kernel *a2)
{
  if (!*((void *)this + 8) || !*((void *)this + 9)) {
    return 0;
  }
  uint64_t v4 = *((unsigned __int8 *)a2 + 161);
  unsigned __int8 v9 = *((unsigned char *)a2 + 161);
  if (*((_DWORD *)a2 + 4) == 3)
  {
    uint64_t v4 = v4 | 2;
    unsigned __int8 v9 = v4;
  }
  uint64_t v5 = (const CI::MetalKernel *)(*(uint64_t (**)(const CI::Kernel *))(*(void *)a2 + 72))(a2);
  if (v5 && (unique_function = CI::MetalDAGHelper::get_unique_function(this, v5)) != 0)
  {
    unint64_t v7 = unique_function;
    (*(void (**)(void, void *))(**((void **)this + 1) + 104))(*((void *)this + 1), unique_function);
  }
  else
  {
    CI::MetalDAGHelper::add_function_with_name(this, *((const char **)a2 + 3), &v9);
    return v9;
  }
  return v4;
}

void CI::MetalDAGHelper::add_function_with_name(CI::MetalDAGHelper *this, const char *a2, unsigned __int8 *a3)
{
  if (*((void *)this + 8))
  {
    if (*((void *)this + 9))
    {
      uint64_t v4 = CI::MetalDAGHelper::new_function_with_name(this, a2, a3);
      if (v4)
      {
        id v5 = (id)v4;
        (*(void (**)(void))(**((void **)this + 1) + 96))(*((void *)this + 1));
      }
    }
  }
}

void CI::ColorMatrixNode::convert_to_kernel_node(CI::ColorMatrixNode *this, CI::Context *a2)
{
}

uint64_t CI::SerialObjectPtrArray::append(uint64_t this, CI::Object *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)this;
  int v5 = *(_DWORD *)(this + 4);
  if (*(_DWORD *)this >= v5)
  {
    int v6 = *(_DWORD *)(this + 8) + v5;
    *(_DWORD *)(this + 4) = v6;
    this = (uint64_t)malloc_type_realloc(*(void **)(this + 16), 8 * (v6 - 10), 0x2004093837F09uLL);
    *(void *)(v3 + 16) = this;
    int v4 = *(_DWORD *)v3;
  }
  if (v4 > 9) {
    unint64_t v7 = (void *)(*(void *)(v3 + 16) + 8 * (v4 - 10));
  }
  else {
    unint64_t v7 = (void *)(v3 + 8 * v4 + 24);
  }
  *unint64_t v7 = a2;
  if (a2)
  {
    this = CI::Object::ref((uint64_t)a2);
    int v4 = *(_DWORD *)v3;
  }
  *(_DWORD *)uint64_t v3 = v4 + 1;
  return this;
}

uint64_t CI::Object::ref(uint64_t this)
{
  return this;
}

__n128 CI::Vector::Vector(CI::Vector *this, __n128 result, float a3, float a4, float a5)
{
  *(void *)this = &unk_1EE45DF30;
  *((_DWORD *)this + 2) = 1;
  *((void *)this + 2) = &unk_1EE45B0E8;
  atomic_fetch_add(dword_1EB466F58, 1u);
  *(void *)this = &unk_1EE45DF68;
  *((void *)this + 2) = &unk_1EE45DFA0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 6) = 4;
  *((_DWORD *)this + 7) = result.n128_u32[0];
  *((float *)this + 8) = a3;
  *((float *)this + 9) = a4;
  *((float *)this + 10) = a5;
  result.n128_f32[1] = a3;
  result.n128_u64[1] = __PAIR64__(LODWORD(a5), LODWORD(a4));
  *((__n128 *)this + 6) = result;
  return result;
}

BOOL CI::ColorMatrixNode::is_rrra(CI::ColorMatrixNode *this, const double (*a2)[4])
{
  return fabs(*(double *)this + -1.0) < 0.0003
      && fabs(*((double *)this + 1)) < 0.0003
      && fabs(*((double *)this + 2)) < 0.0003
      && fabs(*((double *)this + 3)) < 0.0003
      && fabs(*((double *)this + 4) + -1.0) < 0.0003
      && fabs(*((double *)this + 5)) < 0.0003
      && fabs(*((double *)this + 6)) < 0.0003
      && fabs(*((double *)this + 7)) < 0.0003
      && fabs(*((double *)this + 8) + -1.0) < 0.0003
      && fabs(*((double *)this + 9)) < 0.0003
      && fabs(*((double *)this + 10)) < 0.0003
      && fabs(*((double *)this + 11)) < 0.0003
      && fabs(*((double *)this + 12)) < 0.0003
      && fabs(*((double *)this + 13)) < 0.0003
      && fabs(*((double *)this + 14)) < 0.0003
      && fabs(*((double *)this + 15) + -1.0) < 0.0003
      && fabs(*((double *)this + 16)) < 0.0003
      && fabs(*((double *)this + 17)) < 0.0003
      && fabs(*((double *)this + 18)) < 0.0003
      && fabs(*((double *)this + 19)) < 0.0003;
}

BOOL CI::ColorMatrixNode::is_3x4(CI::ColorMatrixNode *this)
{
  return fabs(*((double *)this + 10)) < 0.0003
      && fabs(*((double *)this + 14)) < 0.0003
      && fabs(*((double *)this + 18)) < 0.0003
      && fabs(*((double *)this + 19)) < 0.0003
      && fabs(*((double *)this + 20)) < 0.0003
      && fabs(*((double *)this + 21)) < 0.0003
      && fabs(*((double *)this + 22) + -1.0) < 0.0003
      && fabs(*((double *)this + 26)) < 0.0003;
}

BOOL CI::ColorMatrixNode::is_3x1(CI::ColorMatrixNode *this)
{
  BOOL result = CI::ColorMatrixNode::is_3x3(this);
  if (result)
  {
    double v3 = *((double *)this + 11);
    if (vabdd_f64(*((double *)this + 7), v3) >= 0.0003) {
      return 0;
    }
    if (vabdd_f64(v3, *((double *)this + 15)) >= 0.0003) {
      return 0;
    }
    double v4 = *((double *)this + 12);
    if (vabdd_f64(*((double *)this + 8), v4) >= 0.0003) {
      return 0;
    }
    if (vabdd_f64(v4, *((double *)this + 16)) >= 0.0003) {
      return 0;
    }
    double v5 = *((double *)this + 13);
    return vabdd_f64(*((double *)this + 9), v5) < 0.0003 && vabdd_f64(v5, *((double *)this + 17)) < 0.0003;
  }
  return result;
}

BOOL CI::ColorMatrixNode::is_3x3(CI::ColorMatrixNode *this)
{
  return fabs(*((double *)this + 10)) < 0.0003
      && fabs(*((double *)this + 14)) < 0.0003
      && fabs(*((double *)this + 18)) < 0.0003
      && fabs(*((double *)this + 19)) < 0.0003
      && fabs(*((double *)this + 20)) < 0.0003
      && fabs(*((double *)this + 21)) < 0.0003
      && fabs(*((double *)this + 22) + -1.0) < 0.0003
      && fabs(*((double *)this + 23)) < 0.0003
      && fabs(*((double *)this + 24)) < 0.0003
      && fabs(*((double *)this + 25)) < 0.0003
      && fabs(*((double *)this + 26)) < 0.0003;
}

BOOL CI::ColorMatrixNode::is_diagonal4(CI::ColorMatrixNode *this)
{
  return fabs(*((double *)this + 8)) < 0.0003
      && fabs(*((double *)this + 9)) < 0.0003
      && fabs(*((double *)this + 10)) < 0.0003
      && fabs(*((double *)this + 11)) < 0.0003
      && fabs(*((double *)this + 13)) < 0.0003
      && fabs(*((double *)this + 14)) < 0.0003
      && fabs(*((double *)this + 15)) < 0.0003
      && fabs(*((double *)this + 16)) < 0.0003
      && fabs(*((double *)this + 18)) < 0.0003
      && fabs(*((double *)this + 19)) < 0.0003
      && fabs(*((double *)this + 20)) < 0.0003
      && fabs(*((double *)this + 21)) < 0.0003
      && fabs(*((double *)this + 23)) < 0.0003
      && fabs(*((double *)this + 24)) < 0.0003
      && fabs(*((double *)this + 25)) < 0.0003
      && fabs(*((double *)this + 26)) < 0.0003;
}

BOOL CI::ColorMatrixNode::is_diagonal(CI::ColorMatrixNode *this)
{
  return fabs(*((double *)this + 8)) < 0.0003
      && fabs(*((double *)this + 9)) < 0.0003
      && fabs(*((double *)this + 10)) < 0.0003
      && fabs(*((double *)this + 11)) < 0.0003
      && fabs(*((double *)this + 13)) < 0.0003
      && fabs(*((double *)this + 14)) < 0.0003
      && fabs(*((double *)this + 15)) < 0.0003
      && fabs(*((double *)this + 16)) < 0.0003
      && fabs(*((double *)this + 18)) < 0.0003
      && fabs(*((double *)this + 19)) < 0.0003
      && fabs(*((double *)this + 20)) < 0.0003
      && fabs(*((double *)this + 21)) < 0.0003
      && fabs(*((double *)this + 22) + -1.0) < 0.0003
      && fabs(*((double *)this + 23)) < 0.0003
      && fabs(*((double *)this + 24)) < 0.0003
      && fabs(*((double *)this + 25)) < 0.0003
      && fabs(*((double *)this + 26)) < 0.0003;
}

uint64_t CI::StitchableFunctionDAGDescriptor::add_function(uint64_t a1, void *a2)
{
  uint64_t v4 = [a2 name];
  uint64_t result = [*(id *)(a1 + 120) member:v4];
  uint64_t v6 = result;
  if (!result)
  {
    [*(id *)(a1 + 128) addObject:a2];
    uint64_t v6 = [NSString stringWithString:v4];
    uint64_t result = [*(id *)(a1 + 120) addObject:v6];
  }
  *(void *)(a1 + 112) = v6;
  return result;
}

uint64_t CI::StitchableFunctionDAGDescriptor::ArgumentInfo::data(CI::StitchableFunctionDAGDescriptor::ArgumentInfo *this)
{
  return *((void *)this + 2);
}

void CI::StitchableFunctionDAGDescriptor::create_argument_info(CI::StitchableFunctionDAGDescriptor *this)
{
}

void sub_19368B748(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C403BD2969FLL);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(4 * a2);
}

uint64_t std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__erase_unique<unsigned long long>(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      unint64_t v7 = v2;
    }
    else {
      unint64_t v7 = v2 + 1;
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4]) {
    return 0;
  }
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__remove_node_pointer((uint64_t **)a1, v4);
  std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,CI::DAGHelper::TextureReadFunction>,0>((uint64_t)(v4 + 4));
  operator delete(v4);
  return 1;
}

void std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,CI::DAGHelper::TextureReadFunction>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 31) < 0)
  {
    unint64_t v3 = *(void **)(a1 + 8);
    operator delete(v3);
  }
}

uint64_t CI::SurfaceNode::chroma_scale_fix(IOSurfaceRef *this)
{
  uint64_t result = (*((uint64_t (**)(IOSurfaceRef *))*this + 26))(this);
  if (result != 2)
  {
    __asm { FMOV            V0.2S, #1.0 }
    return result;
  }
  IOSurfaceGetWidthOfPlane(this[7], 0);
  IOSurfaceGetWidthOfPlane(this[7], 1uLL);
  IOSurfaceGetHeightOfPlane(this[7], 0);
  IOSurfaceGetHeightOfPlane(this[7], 1uLL);
  uint64_t result = equivalent_uncompressed_format(*((unsigned int *)this + 18));
  if ((int)result <= 1936077875)
  {
    if ((int)result <= 1751528499)
    {
      if (result == 875836518) {
        goto LABEL_18;
      }
      int v3 = 875836534;
    }
    else
    {
      if (result == 1751528500 || result == 1882469428) {
        goto LABEL_18;
      }
      int v3 = 1885746228;
    }
LABEL_17:
    if (result != v3) {
      return result;
    }
    goto LABEL_18;
  }
  if ((int)result > 1953903667)
  {
    if (result == 1953903668 || result == 2019963956) {
      goto LABEL_18;
    }
    int v3 = 2016687156;
    goto LABEL_17;
  }
  if (result != 1936077876 && result != 1937126452)
  {
    int v3 = 1952855092;
    goto LABEL_17;
  }
LABEL_18:
  __asm { FMOV            V0.2S, #1.0 }
  return result;
}

CI::TextureSampler *CI::TextureSampler::TextureSampler(CI::TextureSampler *this, CI::Node *a2, int a3)
{
  *(void *)this = &unk_1EE45DF30;
  *((_DWORD *)this + 2) = 1;
  *((void *)this + 2) = &unk_1EE456A30;
  atomic_fetch_add(&dword_1EB466F58[2], 1u);
  *(void *)this = &unk_1EE45A290;
  *((void *)this + 2) = &unk_1EE45A2C8;
  if (a2) {
    uint64_t v5 = CI::Object::ref((uint64_t)a2);
  }
  else {
    uint64_t v5 = 0;
  }
  *((void *)this + 3) = v5;
  *((_DWORD *)this + 8) = a3;
  *((void *)this + 5) = 0x3FF0000000000000;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0x3FF0000000000000;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  CI::set_sampler_modes_for_texture(v5, (_DWORD *)this + 30, (int *)this + 31);
  return this;
}

uint64_t CI::set_sampler_modes_for_texture(uint64_t result, _DWORD *a2, int *a3)
{
  if (result)
  {
    uint64_t v5 = result;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
    if ((int)result > 45)
    {
      if (result == 46)
      {
        *a2 = *(unsigned char *)(v5 + 104) == 0;
        int v6 = *(_DWORD *)(v5 + 100);
        goto LABEL_12;
      }
      if (result == 48)
      {
        *a2 = 1;
        int v6 = *(_DWORD *)(v5 + 84);
        goto LABEL_12;
      }
    }
    else
    {
      if (result == 29)
      {
        *a2 = *(unsigned char *)(v5 + 152) == 0;
        int v6 = *(_DWORD *)(v5 + 148);
        goto LABEL_12;
      }
      if (result == 44)
      {
        *a2 = *(unsigned char *)(v5 + 184) == 0;
        int v6 = *(_DWORD *)(v5 + 180);
LABEL_12:
        *a3 = v6;
        return result;
      }
    }
    int v6 = 1;
    *a2 = 1;
    goto LABEL_12;
  }
  return result;
}

uint64_t CI::MetalDAGHelper::add_read_pixel_420_function_info(uint64_t this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(this + 64))
  {
    uint64_t v8 = this;
    if (*(void *)(this + 72))
    {
      unint64_t v15 = (void (***)(void))(***(uint64_t (****)(void, uint64_t))(this + 8))(*(void *)(this + 8), 7);
      (**v15)();
      ((void (*)(void (***)(void), uint64_t, uint64_t, void))**v15)(v15, 3, a3, 0);
      ((void (*)(void (***)(void), uint64_t, uint64_t, void))**v15)(v15, 7, a4, 0);
      ((void (*)(void (***)(void), uint64_t, void, uint64_t))**v15)(v15, 4, 0, a5);
      ((void (*)(void (***)(void), void, uint64_t, void))**v15)(v15, 0, a6, 0);
      ((void (*)(void (***)(void), uint64_t, uint64_t, void))**v15)(v15, 3, a7, 0);
      ((void (*)(void (***)(void), uint64_t, void, uint64_t))**v15)(v15, 4, 0, a8);
      int v16 = *(uint64_t (**)(void))(**(void **)(v8 + 8) + 40);
      return v16();
    }
  }
  return this;
}

uint64_t CI::RenderToBitmap::pointer(CI::RenderToBitmap *this)
{
  return *(void *)(*((void *)this + 6) + 72);
}

uint64_t CI::RenderToBitmap::height(CI::RenderToBitmap *this)
{
  return *(void *)(*((void *)this + 6) + 88);
}

uint64_t CI::RenderToBitmap::width(CI::RenderToBitmap *this)
{
  return *(void *)(*((void *)this + 6) + 80);
}

uint64_t CI::RenderToSurface::pointer(CI::RenderToSurface *this)
{
  return *((void *)this + 6);
}

size_t CI::RenderToSurface::height(IOSurfaceRef *this)
{
  return IOSurfaceGetHeight(this[6]);
}

size_t CI::RenderToSurface::width(IOSurfaceRef *this)
{
  return IOSurfaceGetWidth(this[6]);
}

void *CI::StitchableFunctionDAGDescriptor::create_priv_dest_coord_builder_function_info(uint64_t a1, uint64_t a2, int a3)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  uint64_t v5 = 152;
  if (a3) {
    uint64_t v5 = 160;
  }
  int v6 = *(void **)(a1 + v5);
  if ((objc_msgSend(*(id *)(a1 + 120), "containsObject:", objc_msgSend(v6, "name")) & 1) == 0)
  {
    [*(id *)(a1 + 128) addObject:v6];
    objc_msgSend(*(id *)(a1 + 120), "addObject:", objc_msgSend(v6, "name"));
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
  id v8 = objc_alloc(MEMORY[0x1E4F35260]);
  uint64_t v9 = [v6 name];
  v12[0] = *(void *)(a1 + 40);
  uint64_t v10 = objc_msgSend(v8, "initWithName:arguments:controlDependencies:", v9, v7, objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v12, 1));
  [*(id *)(a1 + 72) addObject:v10];
  ++*(_DWORD *)(a1 + 80);

  return v10;
}

uint64_t CI::ColorKernelNode::add_args_to_hash(CI::ColorKernelNode *this, CI::XXHashHelper *a2)
{
  (*(void (**)(CI::ColorKernelNode *))(*(void *)this + 392))(this);
  uint64_t v4 = **((unsigned int **)this + 7);
  if ((int)v4 >= 1)
  {
    unint64_t v5 = 0;
    uint64_t v6 = 24;
    do
    {
      uint64_t v7 = *((void *)this + 7);
      if (v5 > 9) {
        id v8 = (CI::XXHashHelper **)(*(void *)(v7 + 16) + 8 * (v5 - 10));
      }
      else {
        id v8 = (CI::XXHashHelper **)(v7 + v6);
      }
      CI::Kernel::add_argument_to_digest(a2, *v8, 0);
      ++v5;
      v6 += 8;
    }
    while (v4 != v5);
  }
  uint64_t __src = (*(uint64_t (**)(void))(**((void **)this + 6) + 56))(*((void *)this + 6));
  return XXH64_update((uint64_t)a2, (char *)&__src, 8uLL);
}

uint64_t CI::ColorKernelImage::add_args_to_hash(uint64_t a1, CI::Kernel *a2)
{
  (*(void (**)(void))(**(void **)(a1 + 112) + 64))(*(void *)(a1 + 112));
  unsigned int __src = **(_DWORD **)(a1 + 120);
  uint64_t v4 = __src;
  XXH64_update((uint64_t)a2, (char *)&__src, 4uLL);
  if ((int)v4 >= 1)
  {
    unint64_t v5 = 0;
    uint64_t v6 = 24;
    do
    {
      uint64_t v7 = *(void *)(a1 + 120);
      if (v5 > 9) {
        id v8 = (CI::XXHashHelper **)(*(void *)(v7 + 16) + 8 * (v5 - 10));
      }
      else {
        id v8 = (CI::XXHashHelper **)(v7 + v6);
      }
      uint64_t v9 = *v8;
      int v10 = (*(uint64_t (**)(CI::XXHashHelper *))(*(void *)*v8 + 16))(*v8);
      if (!CI::is_any_TypeImage(v10)) {
        CI::Kernel::add_argument_to_digest(a2, v9, 0);
      }
      ++v5;
      v6 += 8;
    }
    while (v4 != v5);
  }
  uint64_t v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 56))(*(void *)(a1 + 112));
  return XXH64_update((uint64_t)a2, (char *)&v13, 8uLL);
}

uint64_t CI::Kernel::metalConstantsDigest(CI::Kernel *this)
{
  return 0;
}

uint64_t CI::SwizzleNode::add_to_kernel_hash(CI::SwizzleNode *this, CI::XXHashHelper *a2)
{
  int v3 = (char *)SwizzlerName(*((_DWORD *)this + 14));

  return CI::XXHashHelper::addstr((uint64_t)a2, v3);
}

const char *SwizzlerName(unsigned int a1)
{
  if (a1 > 0x58) {
    return "unknown-swizzle";
  }
  else {
    return off_1E57759B0[a1];
  }
}

__n128 ___ZN2CI14TextureManager14add_to_pendingERKNS_6roiKeyE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(__n128 ***)(a1 + 32);
  uint64_t v2 = *(__n128 **)(a1 + 40);
  int v3 = (__n128 *)operator new(0x20uLL);
  __n128 result = *v2;
  v3[1] = *v2;
  unint64_t v5 = (unint64_t)v1[8];
  v1 += 8;
  v3->n128_u64[0] = v5;
  v3->n128_u64[1] = (unint64_t)v1;
  *(void *)(v5 + 8) = v3;
  *uint64_t v1 = v3;
  v1[2] = (__n128 *)((char *)v1[2] + 1);
  return result;
}

uint64_t ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

BOOL ___ZN2CI19MetalTextureManager14lookup_textureEPv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CI::TextureManager::_lookup_texture(*(CI::TextureManager **)(a1 + 40), *(void **)(a1 + 48));
  BOOL result = CI::allowRemoval(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  if (result)
  {
    uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    ++*(_DWORD *)(v3 + 20);
  }
  return result;
}

BOOL CI::allowRemoval(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(_DWORD *)(result + 20))
    {
      if (*(unsigned char *)(result + 24))
      {
        if (isImageConversionServiceProcess()) {
          int v2 = 1;
        }
        else {
          int v2 = isMobileSlideShowOrCamera();
        }
      }
      else
      {
        int v2 = 0;
      }
      if (*(_DWORD *)(v1 + 16) == 1) {
        int v4 = isQuickLookSideCar();
      }
      else {
        int v4 = 0;
      }
      return (v4 | v2) != 0;
    }
    else
    {
      uint64_t v3 = ci_logger_render();
      BOOL result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
      if (result)
      {
        CI::allowRemoval((uint64_t *)v1, v3);
        return 0;
      }
    }
  }
  return result;
}

uint64_t CI::TextureManager::_lookup_texture(CI::TextureManager *this, void *a2)
{
  int v2 = (void *)*((void *)this + 15);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (void *)((char *)this + 120);
  do
  {
    unint64_t v4 = v2[4];
    BOOL v5 = v4 >= (unint64_t)a2;
    if (v4 >= (unint64_t)a2) {
      uint64_t v6 = v2;
    }
    else {
      uint64_t v6 = v2 + 1;
    }
    if (v5) {
      uint64_t v3 = v2;
    }
    int v2 = (void *)*v6;
  }
  while (*v6);
  if (v3 == (void *)((char *)this + 120) || v3[4] > (unint64_t)a2) {
    return 0;
  }
  uint64_t v7 = v3[5];
  if (v7) {
    CI::TextureManager::mark_usage(this, a2);
  }
  return v7;
}

double CI::ColorKernelImage::roi_of_child(CI::ColorKernelImage *this, CGRect a2, uint64_t a3)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double y = a2.origin.y;
  double x = a2.origin.x;
  if ((a3 & 0x80000000) == 0 && **((_DWORD **)this + 15) > (int)a3)
  {
    char v15 = 0;
    uint64_t v9 = (*(uint64_t (**)(CI::ColorKernelImage *, uint64_t, char *))(*(void *)this + 320))(this, a3, &v15);
    if (v15)
    {
      uint64_t v10 = v9;
      unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
      if (!CI::is_raster_TypeImage(v11)) {
        return *MEMORY[0x1E4F1DB10];
      }
      (*(void (**)(uint64_t))(*(void *)v10 + 96))(v10);
      return v12;
    }
    uint64_t v13 = *((void *)this + 20);
    if (v13) {
      return (*(double (**)(uint64_t, uint64_t, double, double, double, double))(v13 + 16))(v13, a3, x, y, width, height);
    }
  }
  return x;
}

uint64_t CI::ColorKernelImage::child(CI::ColorKernelImage *this, int a2, BOOL *a3)
{
  uint64_t v3 = **((unsigned int **)this + 15);
  if ((int)v3 < 1) {
    return 0;
  }
  unint64_t v7 = 0;
  int v8 = 0;
  for (uint64_t i = 24; ; i += 8)
  {
    uint64_t v10 = *((void *)this + 15);
    if (v7 > 9) {
      unsigned int v11 = (void *)(*(void *)(v10 + 16) + 8 * (v7 - 10));
    }
    else {
      unsigned int v11 = (void *)(v10 + i);
    }
    uint64_t v12 = *v11;
    int v13 = (*(uint64_t (**)(void))(*(void *)*v11 + 16))(*v11);
    if (!CI::is_any_TypeImage(v13)) {
      goto LABEL_9;
    }
    if (v8 == a2) {
      break;
    }
    ++v8;
LABEL_9:
    if (v3 == ++v7) {
      return 0;
    }
  }
  uint64_t v14 = *((void *)this + 14);
  if (*(unsigned char *)(v14 + 12)) {
    int v15 = CI::KernelArguments::count((CI::KernelArguments *)(v14 + 144));
  }
  else {
    int v15 = *(_DWORD *)(v14 + 20);
  }
  if (v15 <= (int)v7)
  {
    BOOL v18 = 0;
  }
  else
  {
    uint64_t v16 = *((void *)this + 14);
    if (*(unsigned char *)(v16 + 12))
    {
      int type = CI::KernelArguments::get_type((CI::KernelArguments *)(v16 + 144), v7);
    }
    else if (*(_DWORD *)(v16 + 20) <= (int)v7)
    {
      int type = 0;
    }
    else
    {
      int type = *(_DWORD *)(*(void *)(v16 + 72) + 4 * v7);
    }
    BOOL v18 = type == 4;
  }
  *a3 = v18;
  return v12;
}

uint64_t ___ZNK2CI16MetalMainProgram16getPipelineStateENS_9NodeIndexE_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (!*(void *)(result + 160) && *(double *)(result + 24) == 0.0) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 80))(result, *(unsigned int *)(a1 + 40));
  }
  return result;
}

void sub_19368D4B8(_Unwind_Exception *a1)
{
}

uint64_t CI_ENABLE_METAL_CAPTURE()
{
  {
    CI_ENABLE_METAL_CAPTURE::v = get_BOOL("CI_ENABLE_METAL_CAPTURE", 0);
  }
  return CI_ENABLE_METAL_CAPTURE::v;
}

void sub_19368D850(_Unwind_Exception *a1)
{
}

void CI::recursive_tile(CI::RenderTask *a1, CI *a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6, double *a7, unsigned int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  if (!*((void *)a1 + 16))
  {
    double v16 = a7[2];
    double v17 = a7[3];
    long long v79 = 0u;
    long long v78 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    *(_OWORD *)__str = 0u;
    long long v49 = 0u;
    *(_OWORD *)((char *)a2 + 200) = *(_OWORD *)a7;
    *((double *)a2 + 27) = v16;
    *((double *)a2 + 28) = v17;
    BOOL v18 = ci_signpost_log_render();
    os_signpost_id_t v19 = (*(uint64_t (**)(CI *))(*(void *)a2 + 272))(a2) << 32;
    if (v19 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v18))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v18, OS_SIGNPOST_INTERVAL_BEGIN, v19, "make_program_graph_if_renderable", "", buf, 2u);
    }
    uint64_t v20 = (*(uint64_t (**)(CI *))(*(void *)a2 + 272))(a2);
    TimerBase::TimerBase((uint64_t)v80, v20, 0, (uint64_t)"make_program_graph_if_renderable", 2);
    double v21 = a7[3];
    double v22 = a7[2] * (double)*(unint64_t *)(a9 + 32);
    (*(void (**)(CI *))(*(void *)a2 + 448))(a2);
    double v23 = (double)(unint64_t)(*(uint64_t (**)(CI *))(*(void *)a2 + 456))(a2);
    if (v22 <= v23 && v21 <= v23)
    {
      if (CI_CACHE_PROGRAM_GRAPH())
      {
        XXH64_reset((int64x2_t *)buf, 0);
        *(_DWORD *)unsigned int __src = a5[9];
        XXH64_update((uint64_t)buf, (char *)__src, 4uLL);
        XXH64_update((uint64_t)buf, (char *)a7, 0x20uLL);
        unint64_t v24 = XXH64_digest((uint64_t)buf);
        int v25 = (CI::Context *)CI::ObjectCache<CI::Node,unsigned long long,false>::find(*((void *)a2 + 40), v24);
        if (v25) {
          CI::gather_rois_for_program_graph(a2, v25, v26, v27, *(CGRect *)a7);
        }
      }
      long long v28 = ci_signpost_log_render();
      os_signpost_id_t v29 = (*(uint64_t (**)(CI *))(*(void *)a2 + 272))(a2) << 32;
      if (v29 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v28))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v28, OS_SIGNPOST_INTERVAL_BEGIN, v29, "make_program_graph", "", buf, 2u);
      }
      uint64_t v30 = (*(uint64_t (**)(CI *))(*(void *)a2 + 272))(a2);
      TimerBase::TimerBase((uint64_t)buf, v30, 0, (uint64_t)"make_program_graph", 35);
      v47[0] = 0;
      v47[1] = 0;
      *(void *)unsigned int __src = &unk_1EE459268;
      uint64_t v46 = v47;
      unsigned int v31 = (CI::Context *)(*(uint64_t (**)(_DWORD *, CI *, uint8_t *, uint64_t))(*(void *)a5 + 328))(a5, a2, __src, 1);
      CI::NodeToNodeMap::~NodeToNodeMap((CI::NodeToNodeMap *)__src);
      CGFloat v32 = ci_signpost_log_render();
      os_signpost_id_t v33 = *(void *)&buf[8];
      if ((unint64_t)(*(void *)&buf[8] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        CGFloat v34 = v32;
        if (os_signpost_enabled(v32))
        {
          *(_WORD *)unsigned int __src = 0;
          _os_signpost_emit_with_name_impl(&dword_193671000, v34, OS_SIGNPOST_INTERVAL_END, v33, "make_program_graph", "", __src, 2u);
        }
      }
      TimerBase::~TimerBase((TimerBase *)buf);
      CI::gather_rois_for_program_graph(a2, v31, v35, v36, *(CGRect *)a7);
    }
    snprintf(__str, 0x200uLL, "destination %dx%d too big", (int)v22, (int)v21);
    unint64_t v37 = ci_signpost_log_render();
    os_signpost_id_t v38 = *(void *)&v80[8];
    if ((unint64_t)(*(void *)&v80[8] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v39 = v37;
      if (os_signpost_enabled(v37))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v39, OS_SIGNPOST_INTERVAL_END, v38, "make_program_graph_if_renderable", "", buf, 2u);
      }
    }
    TimerBase::~TimerBase((TimerBase *)v80);
    if (v16 >= 16.0 || v17 >= 16.0)
    {
      if (v16 <= v17)
      {
        long long v42 = *((_OWORD *)a7 + 1);
        *(_OWORD *)buf = *(_OWORD *)a7;
        double v84 = a7[2];
        double v85 = floor(v17 * 0.5 * 0.25) * 4.0;
        *(_OWORD *)uint64_t v80 = *(_OWORD *)a7;
        double v81 = *(double *)&v42;
        *(double *)&v80[8] = v85 + *(double *)&v80[8];
        double v82 = v17 - v85;
      }
      else
      {
        long long v40 = *(_OWORD *)a7;
        double v85 = a7[3];
        *(_OWORD *)buf = v40;
        double v84 = floor(v16 * 0.5 * 0.25) * 4.0;
        long long v41 = *((_OWORD *)a7 + 1);
        *(_OWORD *)uint64_t v80 = *(_OWORD *)a7;
        double v82 = *((double *)&v41 + 1);
        *(double *)uint64_t v80 = v84 + *(double *)v80;
        double v81 = v16 - v84;
      }
      CI::recursive_tile(a1, a2, a3, a4, a5, a6, buf, a8, a9, a10);
      CI::recursive_tile(a1, a2, a3, a4, a5, a6, v80, a8, a9, a10);
    }
    else
    {
      CI::RenderTask::raise(a1, "Failed to render part of the image because %s", __str);
    }
  }
}

uint64_t CI::Context::index(CI::Context *this)
{
  return *((unsigned int *)this + 36);
}

uint64_t ci_signpost_log_render()
{
  if (ci_signpost_log_render_onceToken != -1) {
    dispatch_once(&ci_signpost_log_render_onceToken, &__block_literal_global_69);
  }
  return ci_signpost_log_render_log;
}

void TimerBase::~TimerBase(TimerBase *this)
{
  int v2 = *((_DWORD *)this + 6);
  if ((v2 - 29) < 2 || v2 == 6 || (v2 - 25) <= 3 || v2) {
    kdebug_trace();
  }
  if (CI_PRINT_TIME())
  {
    double v3 = CFAbsoluteTimeGetCurrent() - *((double *)this + 5);
    if (v3 >= 0.000005)
    {
      int v4 = *((_DWORD *)this + 7);
      if (v4)
      {
        if (v4 < (int)CI_PRINT_TIME())
        {
          BOOL v5 = *((void *)this + 4);
          if (v5) {
            label = dispatch_queue_get_label(*((dispatch_queue_t *)this + 4));
          }
          else {
            label = "";
          }
          if (!strncmp(label, "CI::", 4uLL)) {
            unint64_t v7 = label;
          }
          else {
            unint64_t v7 = "";
          }
          uint64_t v8 = *((int *)this + 7);
          if (*v7) {
            int v9 = 2 * v8 + 16;
          }
          else {
            int v9 = 2 * v8;
          }
          uint64_t v10 = (FILE **)MEMORY[0x1E4F143C8];
          if (v5)
          {
            double v11 = (double)(unint64_t)dispatch_queue_get_specific(v5, (const void *)(v8 + 0x6369746C1))
                / 10000000.0;
            if (v11 > 0.0)
            {
              double v12 = v3 - v11;
              if (v12 >= 0.000001)
              {
                float v13 = v12 * 100.0 / v3;
                if (v13 >= 10.0 && v13 <= 90.0)
                {
                  double v15 = v13;
                  if (v12 <= 1.5) {
                    double v16 = "ms";
                  }
                  else {
                    double v16 = "s ";
                  }
                  double v17 = 1000.0;
                  if (v12 > 1.5) {
                    double v17 = 1.0;
                  }
                  double v18 = v12 * v17;
                  os_signpost_id_t v19 = *v10;
                  uint64_t v20 = _indent_str();
                  fprintf(v19, "CI_PRINT_TIME %9.3f%s %.*s unaccounted(%.1f%%) %s\n", v18, v16, v9 + 2, v20, v15, v7);
                }
              }
            }
          }
          double v21 = 1000.0;
          if (v3 > 1.5) {
            double v21 = 1.0;
          }
          double v22 = v3 * v21;
          if (*((_DWORD *)this + 1))
          {
            double v23 = *v10;
            _indent_str();
            fprintf(v23, "CI_PRINT_TIME %9.3f%s %.*s %s(c:%u, n:%u)  %s\n", *(void *)&v22);
          }
          else
          {
            int v24 = *(_DWORD *)this;
            int v25 = *v10;
            _indent_str();
            if (v24) {
              fprintf(v25, "CI_PRINT_TIME %9.3f%s %.*s %s(c:%u)  %s\n");
            }
            else {
              fprintf(v25, "CI_PRINT_TIME %9.3f%s %.*s %s  %s\n");
            }
          }
          fflush(*v10);
        }
      }
    }
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    TimerBase::add_time_at_level(this, *((_DWORD *)this + 7), Current - *((double *)this + 6));
    double v27 = *((void *)this + 4);
    if (v27)
    {
      int v28 = *((_DWORD *)this + 7);
      if (v28 <= 1) {
        int v28 = 1;
      }
      dispatch_queue_set_specific(v27, "com.apple.coreimage.TimerBase.dispatchQueueKey", (void *)(v28 - 1), 0);
    }
  }
}

uint64_t TimerBase::TimerBase(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(void *)(a1 + 8) = a3 | (unint64_t)(a2 << 32);
  *(void *)(a1 + 16) = a4;
  if (CI_KDEBUG()) {
    int v7 = a5;
  }
  else {
    int v7 = 0;
  }
  *(_DWORD *)(a1 + 24) = v7;
  *(void *)(a1 + 28) = 0;
  *(void *)(a1 + 44) = 0;
  *(void *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  if ((v7 - 29) < 2 || v7 == 6 || (v7 - 25) <= 3 || v7) {
    kdebug_trace();
  }
  if (CI_PRINT_TIME())
  {
    *(CFAbsoluteTime *)(a1 + 48) = CFAbsoluteTimeGetCurrent();
    *(void *)(a1 + 32) = dispatch_get_current_queue();
    signed int v8 = TimerBase::get_and_increment_queue_level((TimerBase *)a1);
    *(_DWORD *)(a1 + 28) = v8;
    int v9 = *(NSObject **)(a1 + 32);
    if (v9) {
      dispatch_queue_set_specific(v9, (const void *)(v8 + 0x6369746C1), 0, 0);
    }
    *(CFAbsoluteTime *)(a1 + 40) = CFAbsoluteTimeGetCurrent();
  }
  return a1;
}

uint64_t CI_PRINT_TIME()
{
  if (CI_PRINT_TIME::didCheck != -1) {
    dispatch_once(&CI_PRINT_TIME::didCheck, &__block_literal_global_15);
  }
  return CI_PRINT_TIME::v;
}

uint64_t CI_KDEBUG()
{
  {
    CI_KDEBUG::v = get_int("CI_KDEBUG", 1);
  }
  return CI_KDEBUG::v;
}

void sub_19368F0B4(_Unwind_Exception *a1)
{
}

uint64_t CI_CACHE_PROGRAM_GRAPH()
{
  if (CI_CACHE_PROGRAM_GRAPH::didCheck != -1) {
    dispatch_once(&CI_CACHE_PROGRAM_GRAPH::didCheck, &__block_literal_global_174);
  }
  return CI_CACHE_PROGRAM_GRAPH::v;
}

CI::Node *CI::Node::program_graph(CI::Node *this, CI::Context *a2, CI::NodeToNodeMap *a3, CI::NodeToNodeMap *a4)
{
  signed int v8 = (CI::Node *)CI::NodeToNodeMap::findAndRef(a3, this);
  if (!v8)
  {
    signed int v8 = CI::ProgramNode::build_program_graph(this, a2, a3, a4);
    CI::NodeToNodeMap::add(a3, this, v8);
  }
  return v8;
}

uint64_t CI::NodeToNodeMap::findAndRef(CI::NodeToNodeMap *this, CI::Node *a2)
{
  int v4 = (void *)*((void *)this + 2);
  int v2 = (char *)this + 16;
  double v3 = v4;
  if (!v4) {
    return 0;
  }
  BOOL v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= (unint64_t)a2;
    if (v6 >= (unint64_t)a2) {
      signed int v8 = v3;
    }
    else {
      signed int v8 = v3 + 1;
    }
    if (v7) {
      BOOL v5 = (char *)v3;
    }
    double v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || *((void *)v5 + 4) > (unint64_t)a2) {
    return 0;
  }
  uint64_t result = *((void *)v5 + 5);
  if (result)
  {
    CI::Object::ref(result);
    return *((void *)v5 + 5);
  }
  return result;
}

uint64_t *CI::NodeToNodeMap::add(CI::NodeToNodeMap *this, CI::Node *a2, CI::Node *a3)
{
  double v12 = a2;
  unint64_t v6 = (void *)*((void *)this + 2);
  uint64_t result = (uint64_t *)((char *)this + 16);
  BOOL v5 = v6;
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v7 = (uint64_t)result;
  do
  {
    unint64_t v8 = v5[4];
    BOOL v9 = v8 >= (unint64_t)a2;
    if (v8 >= (unint64_t)a2) {
      uint64_t v10 = v5;
    }
    else {
      uint64_t v10 = v5 + 1;
    }
    if (v9) {
      uint64_t v7 = (uint64_t)v5;
    }
    BOOL v5 = (void *)*v10;
  }
  while (*v10);
  if ((uint64_t *)v7 == result || *(void *)(v7 + 32) > (unint64_t)a2)
  {
LABEL_12:
    double v11 = (uint64_t **)(result - 1);
    if (a2) {
      CI::Object::ref((uint64_t)a2);
    }
    if (a3) {
      CI::Object::ref((uint64_t)a3);
    }
    float v13 = &v12;
    uint64_t result = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v11, (unint64_t *)&v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v13);
    result[5] = (uint64_t)a3;
  }
  return result;
}

CI::ProgramNode *CI::ProgramNode::build_program_graph(CI::ProgramNode *this, CI::Node *a2, CI::Context *a3, CI::NodeToNodeMap *a4)
{
  unsigned int v6 = (*(uint64_t (**)(CI::ProgramNode *))(*(void *)this + 16))(this);
  if (CI::is_image_type(v6))
  {
LABEL_2:
    CI::Object::ref((uint64_t)this);
    return this;
  }
  if (v6 != 38 || !(*(unsigned int (**)(CI::ProgramNode *))(*(void *)this + 224))(this))
  {
    (*(void (**)(CI::Node *))(*(void *)a2 + 16))(a2);
    (*(void (**)(CI::Node *))(*(void *)a2 + 16))(a2);
    if (v6 - 30 < 9 || (v6 <= 0x33 ? (BOOL v8 = ((1 << v6) & 0xEA70010000000) == 0) : (BOOL v8 = 1), !v8))
    {
      v14[0] = 0;
      v14[1] = v14;
      v14[2] = 0x2000000000;
      double v15 = 0;
      double v15 = malloc_type_calloc(0x400uLL, 1uLL, 0x918803B6uLL);
      v13[0] = 0;
      v13[1] = v13;
      v13[2] = 0x2000000000;
      v13[3] = 0;
      v11[0] = 0;
      v11[1] = v11;
      v11[2] = 0x2000000000;
      char v12 = 0;
      v10[0] = 0;
      v10[1] = v10;
      void v10[2] = 0x2000000000;
      v10[3] = 0;
      operator new();
    }
    goto LABEL_2;
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(CI::ProgramNode *, void))(*(void *)this + 48))(this, 0)+ 328);

  return (CI::ProgramNode *)v7();
}

uint64_t CI::MetalContext::max_texture_image_units(CI::MetalContext *this)
{
  return *((void *)this + 51);
}

uint64_t CI::MetalContext::destination_descriptor@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  *a2 = *(void *)(this + 1848);
  return this;
}

CI::SerialStringArray *CI::SerialStringArray::SerialStringArray(CI::SerialStringArray *this, unsigned int a2, int a3)
{
  *(_DWORD *)this = 0;
  signed int v6 = a2 + a2 * a3;
  *((_DWORD *)this + 4) = v6;
  *((void *)this + 3) = malloc_type_malloc(v6, 0x5AFFD461uLL);
  uint64_t v7 = malloc_type_malloc(8 * (int)a2, 0x10040436913F5uLL);
  if (a2 <= 1) {
    int v8 = 1;
  }
  else {
    int v8 = a2;
  }
  *((_DWORD *)this + 1) = a2;
  *((_DWORD *)this + 2) = v8;
  uint64_t v9 = *((void *)this + 3);
  *((void *)this + 4) = v7;
  *((void *)this + 5) = v9;
  *((_DWORD *)this + 3) = a3;
  return this;
}

void CI::gather_rois_for_program_graph(CI *this, CI::Context *a2, const char *a3, CI::ProgramNode *a4, CGRect a5)
{
  CGFloat height = a5.size.height;
  CGFloat width = a5.size.width;
  CGFloat y = a5.origin.y;
  CGFloat x = a5.origin.x;
  double v11 = ci_signpost_log_render();
  os_signpost_id_t v12 = (*(uint64_t (**)(CI *))(*(void *)this + 272))(this) << 32;
  if (v12 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_193671000, v11, OS_SIGNPOST_INTERVAL_BEGIN, v12, "gather_rois_for_program_graph", "", buf, 2u);
  }
  uint64_t v13 = (*(uint64_t (**)(CI *))(*(void *)this + 272))(this);
  TimerBase::TimerBase((uint64_t)buf, v13, 0, (uint64_t)"gather_rois_for_program_graph", 36);
  CI::Context::bytesLimit(this);
  uint64_t v16 = 0;
  v18.origin.CGFloat x = x;
  v18.origin.CGFloat y = y;
  v18.size.CGFloat width = width;
  v18.size.CGFloat height = height;
  CI::_gather_rois_for_program_graph(this, a2, 0, (CI::ProgramNode *)&v16, v18, v14, v15);
}

uint64_t CI::Context::bytesLimit(CI::Context *this)
{
  uint64_t result = *((void *)this + 46) << 20;
  if (!result)
  {
    if (CI_RENDER_MB_LIMIT())
    {
      return CI_RENDER_MB_LIMIT() << 20;
    }
    else
    {
      double v3 = *(uint64_t (**)(CI::Context *))(*(void *)this + 488);
      return v3(this);
    }
  }
  return result;
}

uint64_t CI_RENDER_MB_LIMIT()
{
  {
    CI_RENDER_MB_LIMIT::v = get_ulong("CI_RENDER_MB_LIMIT", 0);
  }
  return CI_RENDER_MB_LIMIT::v;
}

void sub_193690390(_Unwind_Exception *a1)
{
}

uint64_t CI::MetalContext::max_render_load_bytes(CI::MetalContext *this)
{
  uint64_t v1 = *((void *)this + 45);
  if (v1) {
    return v1 << 20;
  }
  else {
    return 0x8000000;
  }
}

void CI::_gather_rois_for_program_graph(CI *this, CI::Context *a2, const char *a3, CI::ProgramNode *a4, CGRect a5, uint64_t a6, unint64_t *a7)
{
}

void std::__tree<std::__value_type<CI::Node const*,CI::useCountDepth>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,CI::useCountDepth>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,CI::useCountDepth>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<CI::Node const*,CI::useCountDepth>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,CI::useCountDepth>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,CI::useCountDepth>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<CI::Node const*,CI::useCountDepth>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,CI::useCountDepth>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,CI::useCountDepth>>>::destroy(a1, a2[1]);
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(a2 + 6), (void *)a2[7]);
    operator delete(a2);
  }
}

void CI::recurseGraphStats(CI::Node *a1, unint64_t a2, int a3, unint64_t **a4, uint64_t a5)
{
  if (a1)
  {
    if (a2)
    {
      unint64_t v10 = (unint64_t)a4[2];
      double v11 = a4[1];
      if ((unint64_t)v11 >= v10)
      {
        uint64_t v13 = v11 - *a4;
        if ((unint64_t)(v13 + 1) >> 61) {
          abort();
        }
        uint64_t v14 = v10 - (void)*a4;
        uint64_t v15 = v14 >> 2;
        if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
          uint64_t v15 = v13 + 1;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v15;
        }
        if (v16) {
          double v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)(a4 + 2), v16);
        }
        else {
          double v17 = 0;
        }
        CGRect v18 = &v17[8 * v13];
        os_signpost_id_t v19 = &v17[8 * v16];
        *(void *)CGRect v18 = a2;
        os_signpost_id_t v12 = (unint64_t *)(v18 + 8);
        double v21 = *a4;
        uint64_t v20 = (char *)a4[1];
        if (v20 != (char *)*a4)
        {
          do
          {
            uint64_t v22 = *((void *)v20 - 1);
            v20 -= 8;
            *((void *)v18 - 1) = v22;
            v18 -= 8;
          }
          while (v20 != (char *)v21);
          uint64_t v20 = (char *)*a4;
        }
        *a4 = (unint64_t *)v18;
        a4[1] = v12;
        a4[2] = (unint64_t *)v19;
        if (v20) {
          operator delete(v20);
        }
      }
      else
      {
        *double v11 = a2;
        os_signpost_id_t v12 = v11 + 1;
      }
      a4[1] = v12;
    }
    int v24 = (void *)(a5 + 8);
    double v23 = *(void **)(a5 + 8);
    if (!v23) {
      goto LABEL_31;
    }
    int v25 = (void *)(a5 + 8);
    do
    {
      unint64_t v26 = v23[4];
      BOOL v27 = v26 >= (unint64_t)a1;
      if (v26 >= (unint64_t)a1) {
        int v28 = v23;
      }
      else {
        int v28 = v23 + 1;
      }
      if (v27) {
        int v25 = v23;
      }
      double v23 = (void *)*v28;
    }
    while (*v28);
    if (v25 == v24 || v25[4] > (unint64_t)a1) {
LABEL_31:
    }
      int v25 = (void *)(a5 + 8);
    if (!v25[8])
    {
      CI::Node::clear_rois(a1);
      if ((*(int (**)(CI::Node *))(*(void *)a1 + 40))(a1) >= 1)
      {
        uint64_t v29 = 0;
        uint64_t v30 = (a3 + 1);
        do
        {
          uint64_t v31 = (*(uint64_t (**)(CI::Node *, uint64_t))(*(void *)a1 + 48))(a1, v29);
          CI::recurseGraphStats(v31, a1, v30, a4, a5);
          uint64_t v29 = (v29 + 1);
        }
        while ((int)v29 < (*(int (**)(CI::Node *))(*(void *)a1 + 40))(a1));
      }
    }
    if (a2)
    {
      if ((*(unsigned int (**)(CI::Node *))(*(void *)a1 + 40))(a1))
      {
        int v32 = *((_DWORD *)v25 + 10);
        if (v32 >= 2)
        {
          os_signpost_id_t v33 = *a4;
          CGFloat v34 = a4[1];
          if (*a4 == v34)
          {
            unint64_t v35 = 0;
          }
          else
          {
            unint64_t v35 = 0;
            uint64_t v36 = v25 + 7;
            do
            {
              unint64_t v37 = *v33;
              unint64_t v54 = *v33;
              os_signpost_id_t v38 = (void *)*v36;
              if (!*v36) {
                goto LABEL_52;
              }
              uint64_t v39 = v25 + 7;
              do
              {
                unint64_t v40 = v38[4];
                BOOL v41 = v40 >= v37;
                if (v40 >= v37) {
                  long long v42 = v38;
                }
                else {
                  long long v42 = v38 + 1;
                }
                if (v41) {
                  uint64_t v39 = v38;
                }
                os_signpost_id_t v38 = (void *)*v42;
              }
              while (*v42);
              if (v39 != v36 && v37 >= v39[4])
              {
                ++*((_DWORD *)v39 + 10);
              }
              else
              {
LABEL_52:
                long long v55 = &v54;
                *((_DWORD *)std::__tree<std::__value_type<CI::ImageDigest,int>,std::__map_value_compare<CI::ImageDigest,std::__value_type<CI::ImageDigest,int>,std::less<CI::ImageDigest>,true>,std::allocator<std::__value_type<CI::ImageDigest,int>>>::__emplace_unique_key_args<CI::ImageDigest,std::piecewise_construct_t const&,std::tuple<CI::ImageDigest const&>,std::tuple<>>((uint64_t **)v25 + 6, &v54, (uint64_t)&std::piecewise_construct, &v55)+ 10) = 1;
              }
              long long v55 = &v54;
              if (v35 <= *((unsigned int *)std::__tree<std::__value_type<CI::ImageDigest,int>,std::__map_value_compare<CI::ImageDigest,std::__value_type<CI::ImageDigest,int>,std::less<CI::ImageDigest>,true>,std::allocator<std::__value_type<CI::ImageDigest,int>>>::__emplace_unique_key_args<CI::ImageDigest,std::piecewise_construct_t const&,std::tuple<CI::ImageDigest const&>,std::tuple<>>((uint64_t **)v25 + 6, &v54, (uint64_t)&std::piecewise_construct, &v55)+ 10))
              {
                long long v55 = &v54;
                unint64_t v35 = *((unsigned int *)std::__tree<std::__value_type<CI::ImageDigest,int>,std::__map_value_compare<CI::ImageDigest,std::__value_type<CI::ImageDigest,int>,std::less<CI::ImageDigest>,true>,std::allocator<std::__value_type<CI::ImageDigest,int>>>::__emplace_unique_key_args<CI::ImageDigest,std::piecewise_construct_t const&,std::tuple<CI::ImageDigest const&>,std::tuple<>>((uint64_t **)v25 + 6, &v54, (uint64_t)&std::piecewise_construct, &v55)+ 10);
              }
              ++v33;
            }
            while (v33 != v34);
            int v32 = *((_DWORD *)v25 + 10);
          }
          if (v35 == v32)
          {
            uint64_t v43 = (void *)v25[6];
            unint64_t v44 = v25 + 7;
            if (v43 != v25 + 7)
            {
              do
              {
                if (*((_DWORD *)v43 + 10) < v32)
                {
                  unint64_t v45 = (void *)*v24;
                  if (!*v24) {
                    goto LABEL_73;
                  }
                  unint64_t v46 = v43[4];
                  uint64_t v47 = v24;
                  do
                  {
                    unint64_t v48 = v45[4];
                    BOOL v49 = v48 >= v46;
                    if (v48 >= v46) {
                      long long v50 = v45;
                    }
                    else {
                      long long v50 = v45 + 1;
                    }
                    if (v49) {
                      uint64_t v47 = v45;
                    }
                    unint64_t v45 = (void *)*v50;
                  }
                  while (*v50);
                  if (v47 == v24 || v46 < v47[4]) {
LABEL_73:
                  }
                    uint64_t v47 = v24;
                  *((unsigned char *)v47 + 44) = 0;
                }
                long long v51 = (void *)v43[1];
                if (v51)
                {
                  do
                  {
                    long long v52 = v51;
                    long long v51 = (void *)*v51;
                  }
                  while (v51);
                }
                else
                {
                  do
                  {
                    long long v52 = (void *)v43[2];
                    BOOL v53 = *v52 == (void)v43;
                    uint64_t v43 = v52;
                  }
                  while (!v53);
                }
                uint64_t v43 = v52;
              }
              while (v52 != v44);
            }
            std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(v25 + 6), (void *)v25[7]);
            v25[7] = 0;
            v25[8] = 0;
            v25[6] = v44;
            *((unsigned char *)v25 + 44) = 0;
          }
        }
      }
      --a4[1];
    }
  }
}

uint64_t CI::MetalContext::max_texture_size(CI::MetalContext *this)
{
  return *((void *)this + 50);
}

void CI::Node::BuildMapToUseCount(CI::Node *this, CI::Node *a2)
{
  v2[0] = 0;
  v2[1] = v2;
  v2[2] = 0x2000000000;
  v2[3] = 0;
  operator new();
}

void CI::NodeToNodeMap::~NodeToNodeMap(CI::NodeToNodeMap *this)
{
  *(void *)this = &unk_1EE459268;
  int v2 = (char *)this + 8;
  double v3 = (char *)*((void *)this + 1);
  int v4 = (char *)this + 16;
  if (v3 != (char *)this + 16)
  {
    do
    {
      BOOL v5 = (CI::Object *)*((void *)v3 + 4);
      if (v5) {
        CI::Object::unref(v5);
      }
      signed int v6 = (CI::Object *)*((void *)v3 + 5);
      if (v6) {
        CI::Object::unref(v6);
      }
      uint64_t v7 = (char *)*((void *)v3 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          uint64_t v7 = *(char **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (char *)*((void *)v3 + 2);
          BOOL v9 = *(void *)v8 == (void)v3;
          double v3 = v8;
        }
        while (!v9);
      }
      double v3 = v8;
    }
    while (v8 != v4);
  }
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)v2, *((void **)this + 2));
}

{
  uint64_t vars8;

  CI::NodeToNodeMap::~NodeToNodeMap(this);

  JUMPOUT(0x1997023B0);
}

void CI::ProgramNode::ProgramNode(CI::ProgramNode *this, CI::Node *a2, CI::SerialStringArray *a3, CI::SerialObjectPtrArray *a4, const CI::GeneralKernelNode *a5)
{
}

uint64_t *std::__tree<std::__value_type<CI::Object const*,unsigned long>,std::__map_value_compare<CI::Object const*,std::__value_type<CI::Object const*,unsigned long>,std::less<CI::Object const*>,true>,std::allocator<std::__value_type<CI::Object const*,unsigned long>>>::__emplace_unique_key_args<CI::Object const*,std::pair<CI::Object const*,unsigned long>>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  signed int v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        BOOL v5 = *v8;
        signed int v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      BOOL v5 = v8[1];
      if (!v5)
      {
        signed int v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v8 = a1 + 1;
LABEL_10:
    unint64_t v10 = (uint64_t *)operator new(0x30uLL);
    uint64_t v11 = a3[1];
    void v10[4] = *a3;
    v10[5] = v11;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

void std::vector<CI::SerialRectArray::roiData>::__assign_with_size[abi:nn180100]<CI::SerialRectArray::roiData*,CI::SerialRectArray::roiData*>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  signed int v6 = (_OWORD *)a2;
  uint64_t v8 = *a1;
  if (0xEEEEEEEEEEEEEEEFLL * ((a1[2] - *a1) >> 3) >= a4)
  {
    if (0xEEEEEEEEEEEEEEEFLL * ((a1[1] - v8) >> 3) >= a4)
    {
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<CI::SerialRectArray::roiData *,CI::SerialRectArray::roiData *,CI::SerialRectArray::roiData *>((uint64_t)&v19, a2, a3, v8);
      unint64_t v16 = v15;
      double v17 = (void *)a1[1];
      if (v17 != v15)
      {
        do
        {
          v17 -= 15;
          std::__destroy_at[abi:nn180100]<CI::SerialRectArray::roiData,0>(v17);
        }
        while (v17 != v16);
      }
      a1[1] = (uint64_t)v16;
    }
    else
    {
      os_signpost_id_t v12 = (_OWORD *)(a2 + 8 * ((a1[1] - v8) >> 3));
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<CI::SerialRectArray::roiData *,CI::SerialRectArray::roiData *,CI::SerialRectArray::roiData *>((uint64_t)&v18, a2, (uint64_t)v12, v8);
      uint64_t v13 = a1[1];
      if (v12 != (_OWORD *)a3)
      {
        uint64_t v14 = a1[1];
        do
        {
          std::construct_at[abi:nn180100]<CI::SerialRectArray::roiData,CI::SerialRectArray::roiData&,CI::SerialRectArray::roiData*>(v14, v12);
          os_signpost_id_t v12 = (_OWORD *)((char *)v12 + 120);
          v14 += 120;
          v13 += 120;
        }
        while (v12 != (_OWORD *)a3);
      }
      a1[1] = v13;
    }
  }
  else
  {
    std::vector<CI::SerialRectArray::roiData>::__vdeallocate(a1);
    if (a4 > 0x222222222222222) {
      abort();
    }
    unint64_t v9 = 0xDDDDDDDDDDDDDDDELL * ((a1[2] - *a1) >> 3);
    if (v9 <= a4) {
      unint64_t v9 = a4;
    }
    if (0xEEEEEEEEEEEEEEEFLL * ((a1[2] - *a1) >> 3) >= 0x111111111111111) {
      unint64_t v10 = 0x222222222222222;
    }
    else {
      unint64_t v10 = v9;
    }
    std::vector<CI::SerialRectArray::roiData>::__vallocate[abi:nn180100](a1, v10);
    uint64_t v11 = a1[1];
    while (v6 != (_OWORD *)a3)
    {
      std::construct_at[abi:nn180100]<CI::SerialRectArray::roiData,CI::SerialRectArray::roiData&,CI::SerialRectArray::roiData*>(v11, v6);
      signed int v6 = (_OWORD *)((char *)v6 + 120);
      v11 += 120;
    }
    a1[1] = v11;
  }
}

void QueuePool<4>::get(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = 0;
  unint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  int v4 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN9QueuePoolILi4EE3getEP21dispatch_queue_attr_s_block_invoke;
  block[3] = &unk_1E5775778;
  block[4] = &v6;
  block[5] = a1;
  void block[6] = a2;
  dispatch_sync(v4, block);
  *a3 = v7[3];
  a3[1] = dispatch_group_create();
  _Block_object_dispose(&v6, 8);
}

void CI::Node::set_rois(CI::Node *this, const CI::SerialRectArray *a2)
{
  int v2 = (uint64_t *)*((void *)this + 2);
  if (v2 != (uint64_t *)a2) {
    std::vector<CI::SerialRectArray::roiData>::__assign_with_size[abi:nn180100]<CI::SerialRectArray::roiData*,CI::SerialRectArray::roiData*>(v2, *(void *)a2, *((void *)a2 + 1), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 3));
  }
}

uint64_t CI::ProgramNode::queue_pool(CI::ProgramNode *this)
{
  unint64_t v1 = 0x1EB466000uLL;
  {
    unint64_t v1 = 0x1EB466000;
    if (v3) {
      operator new();
    }
  }
  return *(void *)(v1 + 3280);
}

uint64_t CI_MAX_PROGRAM_INPUT_TEXTURES()
{
  {
    CI_MAX_PROGRAM_INPUT_TEXTURES::v = get_int("CI_MAX_PROGRAM_INPUT_TEXTURES", 32);
  }
  return CI_MAX_PROGRAM_INPUT_TEXTURES::v;
}

void sub_19369128C(_Unwind_Exception *a1)
{
}

uint64_t CI_MAX_PROGRAM_DEPTH()
{
  {
    CI_MAX_PROGRAM_DEPTH::v = get_int("CI_MAX_PROGRAM_DEPTH", 128);
  }
  return CI_MAX_PROGRAM_DEPTH::v;
}

void sub_19369130C(_Unwind_Exception *a1)
{
}

uint64_t get_int(const char *a1, uint64_t a2)
{
  int v4 = getenv(a1);
  if (v4)
  {
    return atoi(v4);
  }
  else
  {
    if (userDefaults(void)::didCheck != -1) {
      dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_193);
    }
    uint64_t v6 = objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
    objc_opt_class();
    if (objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass()))
    {
      return [v6 intValue];
    }
    else
    {
      return a2;
    }
  }
}

uint64_t CI_PRINT_TREE_dump_timing()
{
  {
    CI_PRINT_TREE_dump_timing::v = CI_PRINT_TREE_has_string("dump-timing") != 0;
  }
  return CI_PRINT_TREE_dump_timing::v;
}

void sub_193691490(_Unwind_Exception *a1)
{
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<CI::SerialRectArray::roiData *,CI::SerialRectArray::roiData *,CI::SerialRectArray::roiData *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = 0;
  do
  {
    uint64_t v8 = a4 + v7;
    uint64_t v9 = a2 + v7;
    long long v10 = *(_OWORD *)(a2 + v7 + 16);
    *(_OWORD *)uint64_t v8 = *(_OWORD *)(a2 + v7);
    *(_OWORD *)(v8 + 16) = v10;
    if (a2 != a4)
    {
      std::vector<CI::parentROI>::__assign_with_size[abi:nn180100]<CI::parentROI*,CI::parentROI*>((char *)(v8 + 32), *(char **)(v9 + 32), *(void *)(v9 + 40), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v9 + 40) - *(void *)(v9 + 32)) >> 4));
      std::vector<CI::parentROI>::__assign_with_size[abi:nn180100]<CI::parentROI*,CI::parentROI*>((char *)(v8 + 56), *(char **)(v9 + 56), *(void *)(v9 + 64), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v9 + 64) - *(void *)(v9 + 56)) >> 4));
      *(_OWORD *)(v8 + 80) = *(_OWORD *)(v9 + 80);
      std::vector<unsigned long>::__assign_with_size[abi:nn180100]<unsigned long *,unsigned long *>((char *)(v8 + 96), *(char **)(v9 + 96), *(void *)(v9 + 104), (uint64_t)(*(void *)(v9 + 104) - *(void *)(v9 + 96)) >> 3);
    }
    v7 += 120;
  }
  while (a2 + v7 != v6);
  return v6;
}

void CI::Context::endFrame(CI::Context *this)
{
}

void RegularizePriorityForContextEntries(int a1)
{
  if (GetQueue(void)::onceToken != -1) {
    dispatch_once(&GetQueue(void)::onceToken, &__block_literal_global_71);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __RegularizePriorityForContextEntries_block_invoke;
  block[3] = &__block_descriptor_tmp_48_0;
  int v3 = a1;
  dispatch_async((dispatch_queue_t)gSurfaceCacheQueue, block);
}

void std::vector<CI::SerialRectArray::roiData>::__vdeallocate(void *a1)
{
  unint64_t v1 = (void *)*a1;
  if (*a1)
  {
    int v3 = (void *)a1[1];
    int v4 = (void *)*a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 15;
        std::__destroy_at[abi:nn180100]<CI::SerialRectArray::roiData,0>(v3);
      }
      while (v3 != v1);
      int v4 = (void *)*a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<CI::SerialRectArray::roiData>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SerialRectArray::roiData>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[120 * v4];
  return result;
}

unint64_t get_ulong(const char *a1, uint64_t a2)
{
  uint64_t v4 = getenv(a1);
  if (v4)
  {
    return strtoul(v4, 0, 10);
  }
  else
  {
    if (userDefaults(void)::didCheck != -1) {
      dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_193);
    }
    uint64_t v6 = objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
    objc_opt_class();
    if (objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass()))
    {
      return [v6 unsignedLongValue];
    }
    else
    {
      return a2;
    }
  }
}

void ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE6insertES2_PS1_j_block_invoke(void *a1)
{
  int v2 = (void *)a1[4];
  ++v2[1];
  int v3 = a1 + 5;
  uint64_t v4 = std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::find<CI::ProgramDigest>(v2 + 2, a1 + 5);
  if (v4)
  {
    v4[4] = v2[1];
    BOOL v5 = (CI::Object *)a1[6];
    if (v5)
    {
      CI::Object::unref(v5);
    }
  }
  else
  {
    if (v2[5] == *v2) {
      CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::evict((uint64_t)v2);
    }
    *(void *)&long long v7 = a1 + 6;
    *((void *)&v7 + 1) = v2 + 1;
    uint64_t v8 = a1 + 7;
    uint64_t v9 = v3;
    std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__emplace_unique_impl<std::piecewise_construct_t const&,std::tuple<CI::ProgramDigest const&>,std::tuple<CI::MainProgram* const&,unsigned long long &,unsigned int const&>>(v2 + 2, (uint64_t)&std::piecewise_construct, &v9, &v7);
    uint64_t v6 = (CI::Object *)a1[6];
    if (v6) {
      CI::Object::unref(v6);
    }
  }
}

uint64_t ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE4findES2__block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::find<CI::ProgramDigest>((void *)(v2 + 16), a1 + 6);
  if (result)
  {
    uint64_t v4 = *(void *)(v2 + 8) + 1;
    *(void *)(v2 + 8) = v4;
    *(void *)(result + 32) = v4;
    uint64_t result = *(void *)(result + 24);
    if (result) {
      uint64_t result = CI::Object::ref(result);
    }
    *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  }
  return result;
}

uint64_t ___ZN2CI11ObjectCacheINS_4NodeEyLb0EE4findEy_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::find<CI::ProgramDigest>((void *)(v2 + 16), a1 + 6);
  if (result)
  {
    uint64_t v4 = *(void *)(v2 + 8) + 1;
    *(void *)(v2 + 8) = v4;
    *(void *)(result + 32) = v4;
    uint64_t result = *(void *)(result + 24);
    if (result) {
      uint64_t result = CI::Object::ref(result);
    }
    *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::find<CI::ProgramDigest>(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  uint64_t v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  uint64_t result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }
        else
        {
          v8 &= *(void *)&v2 - 1;
        }
        if (v8 != v5) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__emplace_unique_impl<std::piecewise_construct_t const&,std::tuple<CI::ProgramDigest const&>,std::tuple<CI::MainProgram* const&,unsigned long long &,unsigned int const&>>(void *a1, uint64_t a2, void **a3, long long *a4)
{
  long long v7 = a1 + 2;
  unint64_t v8 = operator new(0x30uLL);
  v13[0] = v8;
  v13[1] = v7;
  void *v8 = 0;
  v8[1] = 0;
  uint64_t v9 = *a3;
  long long v15 = *a4;
  uint64_t v16 = *((void *)a4 + 2);
  std::pair<CI::ProgramDigest const,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>::pair[abi:nn180100]<CI::ProgramDigest const&,CI::MainProgram* const&,unsigned long long &,unsigned int const&>((uint64_t)(v8 + 2), v9, (uint64_t)&v15);
  char v14 = 1;
  v8[1] = v8[2];
  inserted = std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique(a1, v8);
  if (v11) {
    v13[0] = 0;
  }
  std::unique_ptr<std::__hash_node<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,void *>>>>::reset[abi:nn180100]((uint64_t)v13, 0);
  return inserted;
}

uint64_t std::pair<CI::ProgramDigest const,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>::pair[abi:nn180100]<CI::ProgramDigest const&,CI::MainProgram* const&,unsigned long long &,unsigned int const&>(uint64_t a1, void *a2, uint64_t a3)
{
  *(void *)a1 = *a2;
  uint64_t v4 = **(void **)a3;
  uint64_t v5 = **(void **)(a3 + 8);
  unsigned int v6 = **(_DWORD **)(a3 + 16);
  if (v4) {
    uint64_t v4 = CI::Object::ref(v4);
  }
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(unsigned char *)(a1 + 24) = v6 > 0x40;
  return a1;
}

void *std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique(void *a1, void *a2)
{
  int8x8_t v2 = a2;
  uint64_t v5 = a2 + 2;
  unint64_t v4 = a2[2];
  *(v5 - 1) = v4;
  unsigned int v6 = std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique_prepare[abi:nn180100]((uint64_t)a1, v4, v5);
  if (v6) {
    return v6;
  }
  std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique_perform[abi:nn180100](a1, v2);
  return v2;
}

void *std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique_prepare[abi:nn180100](uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL) {
      uint64_t v5 = v3 <= a2 ? a2 % v3 : a2;
    }
    else {
      uint64_t v5 = (v3 - 1) & a2;
    }
    unsigned int v6 = *(void **)(*(void *)a1 + 8 * v5);
    if (v6)
    {
      for (uint64_t i = (void *)*v6; i; uint64_t i = (void *)*i)
      {
        unint64_t v8 = i[1];
        if (v8 == a2)
        {
          if (i[2] == *a3) {
            return i;
          }
        }
        else
        {
          if (v4.u32[0] > 1uLL)
          {
            if (v8 >= v3) {
              v8 %= v3;
            }
          }
          else
          {
            v8 &= v3 - 1;
          }
          if (v8 != v5) {
            break;
          }
        }
      }
    }
  }
  float v9 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v10 = *(float *)(a1 + 32);
  if (!v3 || (float)(v10 * (float)v3) < v9)
  {
    uint64_t v11 = 2 * v3;
    BOOL v12 = v3 < 3 || (v3 & (v3 - 1)) != 0;
    size_t v13 = v12 | v11;
    unint64_t v14 = vcvtps_u32_f32(v9 / v10);
    if (v13 <= v14) {
      size_t v15 = v14;
    }
    else {
      size_t v15 = v13;
    }
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>(a1, v15);
  }
  return 0;
}

void *std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique_perform[abi:nn180100](void *result, void *a2)
{
  int8x8_t v2 = (int8x8_t)result[1];
  unint64_t v3 = a2[1];
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(void *)&v2) {
      v3 %= *(void *)&v2;
    }
  }
  else
  {
    v3 &= *(void *)&v2 - 1;
  }
  uint64_t v5 = *(void **)(*result + 8 * v3);
  if (v5)
  {
    *a2 = *v5;
LABEL_13:
    *uint64_t v5 = a2;
    goto LABEL_14;
  }
  *a2 = result[2];
  result[2] = a2;
  *(void *)(*result + 8 * v3) = result + 2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v2) {
        v6 %= *(void *)&v2;
      }
    }
    else
    {
      v6 &= *(void *)&v2 - 1;
    }
    uint64_t v5 = (void *)(*result + 8 * v6);
    goto LABEL_13;
  }
LABEL_14:
  ++result[3];
  return result;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,void *>>>>::reset[abi:nn180100](uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry::~Entry((uint64_t)v2 + 24);
    }
    operator delete(v2);
  }
}

uint64_t CI::Image::baseColorspace(CI::Image *this)
{
  uint64_t v2 = (*(uint64_t (**)(CI::Image *))(*(void *)this + 240))(this);
  uint64_t v3 = *(void *)this;
  if (v2)
  {
    uint8x8_t v4 = *(uint64_t (**)(CI::Image *))(v3 + 240);
    return v4(this);
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(CI::Image *, void))(v3 + 48))(this, 0);
    if (result)
    {
      unint64_t v6 = *(uint64_t (**)(void))(*(void *)result + 248);
      return v6();
    }
  }
  return result;
}

uint64_t CI::ColorKernelImage::colorspace(CI::ColorKernelImage *this)
{
  if (!*(unsigned char *)(*((void *)this + 14) + 164)) {
    return 0;
  }
  unint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(CI::ColorKernelImage *, void))(*(void *)this
                                                                                                  + 48))(this, 0)+ 240);

  return v1();
}

uint64_t CI::AffineImage::colorspace(CI::AffineImage *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 240))();
}

uint64_t CI::CropImage::colorspace(CI::CropImage *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 240))();
}

void *CIMetalDeviceGetFeatures(void *result, unsigned char *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    *a2 = [result supportsFamily:1003];
    a2[1] = [v3 supportsFamily:1004];
    a2[2] = [v3 supportsFamily:1006];
    uint64_t result = (void *)[v3 supportsFamily:1004];
    a2[3] = (_BYTE)result;
  }
  return result;
}

CI::PrecompiledKernels *CI::DAGPrecompiledKernels::DAGPrecompiledKernels(CI::DAGPrecompiledKernels *this, id *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  double v23 = CI::PrecompiledKernels::PrecompiledKernels(this);
  *(void *)double v23 = &unk_1EE45D480;
  uint64_t v3 = CI::MetalContext::device(a2);
  uint64_t v4 = [NSString stringWithUTF8String:a2[240]];
  *((void *)v23 + 3) = (id)[MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  id v5 = +[CIKernelLibrary internalLibraryWithName:@"ci_stdlib" device:v3];
  unint64_t v6 = v5;
  if (v5)
  {
    uint64_t v7 = objc_msgSend((id)objc_msgSend(v5, "externFunctionNames"), "count");
    uint64_t v29 = v7;
    [*((id *)v23 + 3) addObject:v6];
  }
  else
  {
    NSLog(&cfstr_FailedToLoadCi.isa);
    uint64_t v7 = 0;
  }
  id v8 = +[CIKernelLibrary internalLibraryWithName:@"ci_filters" device:v3];
  float v9 = v8;
  if (v8)
  {
    uint64_t v29 = v7 + objc_msgSend((id)objc_msgSend(v8, "externFunctionNames"), "count");
    [*((id *)v23 + 3) addObject:v9];
  }
  else
  {
    NSLog(&cfstr_FailedToLoadCi_0.isa);
  }
  if (CI_ENABLE_HALF_KERNELS() && *((unsigned char *)a2 + 43))
  {
    *((void *)v23 + 4) = (id)[MEMORY[0x1E4F1CA48] array];
    id v10 = +[CIKernelLibrary internalLibraryWithName:@"ci_stdlib_h" device:v3];
    uint64_t v11 = v10;
    if (v10)
    {
      uint64_t v30 = objc_msgSend((id)objc_msgSend(v10, "externFunctionNames"), "count");
      [*((id *)v23 + 4) addObject:v11];
    }
    else
    {
      NSLog(&cfstr_FailedToLoadCi_1.isa);
    }
  }
  else
  {
    *((void *)v23 + 4) = 0;
  }
  uint64_t v12 = 0;
  char v13 = 1;
  do
  {
    char v14 = v13;
    size_t v15 = (char *)v23 + 8 * v12;
    *((void *)v15 + 5) = (id)[MEMORY[0x1E4F1CA80] setWithCapacity:*(&v29 + v12)];
    uint64_t v16 = (id *)(v15 + 40);
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    double v17 = *(v16 - 2);
    uint64_t v18 = [v17 countByEnumeratingWithState:&v24 objects:v28 count:16];
    if (v18)
    {
      uint64_t v19 = *(void *)v25;
      do
      {
        for (uint64_t i = 0; i != v18; ++i)
        {
          if (*(void *)v25 != v19) {
            objc_enumerationMutation(v17);
          }
          double v21 = *(void **)(*((void *)&v24 + 1) + 8 * i);
          [v21 setLabel:v4];
          objc_msgSend(*v16, "addObjectsFromArray:", objc_msgSend(v21, "externFunctionNames"));
        }
        uint64_t v18 = [v17 countByEnumeratingWithState:&v24 objects:v28 count:16];
      }
      while (v18);
    }
    char v13 = 0;
    uint64_t v12 = 1;
  }
  while ((v14 & 1) != 0);
  return v23;
}

void sub_1936929D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CI::PrecompiledKernels *a10)
{
}

uint64_t ___ZN2CI17StitchableKernelsC2EPKNS_12MetalContextE_block_invoke(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = CI::MetalContext::device(*(id **)(a1 + 48));
  id v4 = +[CIKernelLibrary internalLibraryWithName:@"ci_stdlib_stitchable" device:v3];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = objc_msgSend((id)objc_msgSend(v4, "functionNames"), "count");
    uint64_t v28 = v6;
    [*(id *)(v2 + 24) addObject:v5];
  }
  else
  {
    NSLog(&cfstr_FailedToLoadCi_2.isa);
    uint64_t v6 = 0;
  }
  id v7 = +[CIKernelLibrary internalLibraryWithName:@"ci_filters_stitchable" device:v3];
  if (v7)
  {
    id v8 = v7;
    uint64_t v28 = v6 + objc_msgSend((id)objc_msgSend(v7, "functionNames"), "count");
    [*(id *)(v2 + 24) addObject:v8];
  }
  else
  {
    NSLog(&cfstr_FailedToLoadCi_3.isa);
  }
  if (CI_ENABLE_HALF_KERNELS() && *(unsigned char *)(*(void *)(a1 + 48) + 43))
  {
    *(void *)(v2 + 32) = (id)[MEMORY[0x1E4F1CA48] array];
    id v9 = +[CIKernelLibrary internalLibraryWithName:@"ci_stdlib_stitchable_h" device:v3];
    if (v9)
    {
      id v10 = v9;
      uint64_t v29 = objc_msgSend((id)objc_msgSend(v9, "functionNames"), "count");
      [*(id *)(v2 + 32) addObject:v10];
    }
    else
    {
      NSLog(&cfstr_FailedToLoadCi_4.isa);
    }
  }
  else
  {
    *(void *)(v2 + 32) = 0;
  }
  uint64_t v11 = 0;
  char v12 = 1;
  do
  {
    char v13 = v12;
    uint64_t v14 = v2;
    uint64_t v15 = v2 + 8 * v11;
    *(void *)(v15 + 40) = (id)[MEMORY[0x1E4F1CA80] setWithCapacity:*(&v28 + v11)];
    uint64_t v16 = (id *)(v15 + 40);
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    double v17 = *(v16 - 2);
    uint64_t result = [v17 countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (result)
    {
      uint64_t v19 = result;
      uint64_t v20 = *(void *)v24;
      do
      {
        uint64_t v21 = 0;
        do
        {
          if (*(void *)v24 != v20) {
            objc_enumerationMutation(v17);
          }
          uint64_t v22 = *(void **)(*((void *)&v23 + 1) + 8 * v21);
          [v22 setLabel:*(void *)(a1 + 32)];
          objc_msgSend(*v16, "addObjectsFromArray:", objc_msgSend(v22, "functionNames"));
          ++v21;
        }
        while (v19 != v21);
        uint64_t result = [v17 countByEnumeratingWithState:&v23 objects:v27 count:16];
        uint64_t v19 = result;
      }
      while (result);
    }
    char v12 = 0;
    uint64_t v11 = 1;
    uint64_t v2 = v14;
  }
  while ((v13 & 1) != 0);
  return result;
}

uint64_t CI_ENABLE_HALF_KERNELS()
{
  {
    CI_ENABLE_HALF_KERNELS::v = get_BOOL("CI_ENABLE_HALF_KERNELS", 1);
  }
  return CI_ENABLE_HALF_KERNELS::v;
}

void sub_193692FB4(_Unwind_Exception *a1)
{
}

void ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke()
{
  v78[3] = *MEMORY[0x1E4F143B8];
  unint64_t v0 = ci_signpost_log_filter();
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_193671000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LoadMoreFilters", "", buf, 2u);
  }
  unint64_t v1 = (void *)[MEMORY[0x1E4F28CB8] defaultManager];
  int has_internal_content = os_variant_has_internal_content();
  uint64_t v3 = getenv("CI_FILTERS_DIR");
  id v4 = v3;
  if (!v3 || *v3 != 48 || v3[1])
  {
    obuint64_t j = (id)[MEMORY[0x1E4F1CA48] array];
    uint64_t v5 = *MEMORY[0x1E4F1C658];
    v78[0] = *MEMORY[0x1E4F1C6E8];
    v78[1] = v5;
    v78[2] = *MEMORY[0x1E4F1C680];
    uint64_t v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v78 count:3];
    if (v4) {
      int v7 = has_internal_content;
    }
    else {
      int v7 = 0;
    }
    if (v7 == 1)
    {
      long long v70 = 0u;
      long long v71 = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      id v8 = objc_msgSend((id)objc_msgSend(NSString, "stringWithUTF8String:", v4), "componentsSeparatedByString:", @",");
      uint64_t v9 = [v8 countByEnumeratingWithState:&v68 objects:v77 count:16];
      if (v9)
      {
        uint64_t v10 = *(void *)v69;
        do
        {
          for (uint64_t i = 0; i != v9; ++i)
          {
            if (*(void *)v69 != v10) {
              objc_enumerationMutation(v8);
            }
            objc_msgSend(obj, "addObjectsFromArray:", objc_msgSend(v1, "contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:", objc_msgSend(MEMORY[0x1E4F1CB10], "fileURLWithPath:isDirectory:", *(void *)(*((void *)&v68 + 1) + 8 * i), 1), v6, 7, 0));
          }
          uint64_t v9 = [v8 countByEnumeratingWithState:&v68 objects:v77 count:16];
        }
        while (v9);
      }
    }
    objc_msgSend(obj, "addObjectsFromArray:", objc_msgSend(v1, "contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:", objc_msgSend(MEMORY[0x1E4F1CB10], "fileURLWithPath:isDirectory:", objc_msgSend(NSString, "stringWithUTF8String:", "/System/Library/CoreImage"), 1), v6, 7, 0));
    if (has_internal_content)
    {
      uint64_t v12 = objc_msgSend(MEMORY[0x1E4F1CB10], "fileURLWithPath:isDirectory:", objc_msgSend(NSString, "stringWithUTF8String:", "/AppleInternal/Library/CoreImage"), 1);
      if (v12) {
        objc_msgSend(obj, "addObjectsFromArray:", objc_msgSend(v1, "contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:", v12, v6, 7, 0));
      }
    }
    register_more_builtins(void({block_pointer})(NSString *))::moreList = (uint64_t)objc_alloc_init(MEMORY[0x1E4F1CA48]);
    char v13 = (void *)[MEMORY[0x1E4F1CA48] array];
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    uint64_t v14 = [obj countByEnumeratingWithState:&v64 objects:v76 count:16];
    if (v14)
    {
      uint64_t v15 = *(void *)v65;
      uint64_t v41 = *(void *)v65;
      long long v42 = v13;
      do
      {
        uint64_t v16 = 0;
        uint64_t v43 = v14;
        do
        {
          if (*(void *)v65 != v15) {
            objc_enumerationMutation(obj);
          }
          double v17 = *(void **)(*((void *)&v64 + 1) + 8 * v16);
          if (objc_msgSend((id)objc_msgSend(v17, "pathExtension"), "isEqualToString:", @"cifilter"))
          {
            uint64_t v18 = [v17 lastPathComponent];
            if ([v13 containsObject:v18])
            {
              NSLog(&cfstr_AFilterBundleW.isa, [v17 path]);
            }
            else
            {
              [v13 addObject:v18];
              uint64_t v19 = ci_signpost_log_filter();
              if ((unint64_t)v17 + 1 >= 2)
              {
                os_signpost_id_t v38 = v19;
                if (os_signpost_enabled(v19))
                {
                  uint64_t v39 = objc_msgSend((id)objc_msgSend(v17, "lastPathComponent"), "UTF8String");
                  *(_DWORD *)buf = 136446210;
                  uint64_t v75 = v39;
                  _os_signpost_emit_with_name_impl(&dword_193671000, v38, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v17, "LoadFilter", "%{public}s", buf, 0xCu);
                }
              }
              uint64_t v44 = v16;
              v59[0] = MEMORY[0x1E4F143A8];
              v59[1] = 3221225472;
              long long v60 = ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_1084;
              long long v61 = &unk_1E5771C60;
              long long v62 = v17;
              long long v63 = v17;
              uint64_t v20 = (void *)[MEMORY[0x1E4F28B50] bundleWithURL:v17];
              uint64_t v21 = (void *)[v20 objectForInfoDictionaryKey:@"CIFilterList"];
              if ([v21 count])
              {
                long long v57 = 0u;
                long long v58 = 0u;
                long long v55 = 0u;
                long long v56 = 0u;
                uint64_t v22 = [v21 countByEnumeratingWithState:&v55 objects:v73 count:16];
                if (v22)
                {
                  uint64_t v23 = *(void *)v56;
                  do
                  {
                    for (uint64_t j = 0; j != v22; ++j)
                    {
                      if (*(void *)v56 != v23) {
                        objc_enumerationMutation(v21);
                      }
                      long long v25 = *(NSString **)(*((void *)&v55 + 1) + 8 * j);
                      if (([(id)register_more_builtins(void({block_pointer})(NSString *))::moreList containsObject:v25] & 1) != 0|| NSClassFromString(v25))
                      {
                        NSLog(&cfstr_TheFilterInHas.isa, v25, [v17 path]);
                      }
                    }
                    uint64_t v22 = [v21 countByEnumeratingWithState:&v55 objects:v73 count:16];
                  }
                  while (v22);
                }
                long long v26 = ci_signpost_log_filter();
                if ((unint64_t)v17 + 1 >= 2)
                {
                  long long v27 = v26;
                  if (os_signpost_enabled(v26))
                  {
                    uint64_t v28 = objc_msgSend((id)objc_msgSend(v17, "lastPathComponent"), "UTF8String");
                    *(_DWORD *)buf = 136446210;
                    uint64_t v75 = v28;
                    _os_signpost_emit_with_name_impl(&dword_193671000, v27, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v17, "BundleLoad", "%{public}s", buf, 0xCu);
                  }
                }
                v50[0] = MEMORY[0x1E4F143A8];
                v50[1] = 3221225472;
                long long v51 = ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_1091;
                long long v52 = &unk_1E5771C60;
                BOOL v53 = v17;
                unint64_t v54 = v17;
                uint64_t v29 = (const char *)objc_msgSend((id)objc_msgSend(v20, "executablePath"), "UTF8String");
                uint64_t v30 = v29;
                if (v29 && !dlopen(v29, 1))
                {
                  uint64_t v31 = dlerror();
                  int v32 = "";
                  if (v31) {
                    int v32 = v31;
                  }
                  NSLog(&cfstr_TheExecutableF.isa, v30, v32);
                }
                v51((uint64_t)v50);
                long long v48 = 0u;
                long long v49 = 0u;
                long long v46 = 0u;
                long long v47 = 0u;
                uint64_t v33 = [v21 countByEnumeratingWithState:&v46 objects:v72 count:16];
                if (v33)
                {
                  uint64_t v34 = *(void *)v47;
                  do
                  {
                    for (uint64_t k = 0; k != v33; ++k)
                    {
                      if (*(void *)v47 != v34) {
                        objc_enumerationMutation(v21);
                      }
                      uint64_t v36 = *(NSString **)(*((void *)&v46 + 1) + 8 * k);
                      Class v37 = NSClassFromString(v36);
                      if ([(id)register_more_builtins(void({block_pointer})(NSString *))::moreList containsObject:v36])
                      {
                        NSLog(&cfstr_TheFilterInThe.isa, v36, [v17 path]);
                      }
                      else if (v37)
                      {
                        if ([(objc_class *)v37 isSubclassOfClass:objc_opt_class()]) {
                          [(id)register_more_builtins(void({block_pointer})(NSString *))::moreList addObject:v36];
                        }
                        else {
                          NSLog(&cfstr_TheFilterInThe_0.isa, v36, [v17 path]);
                        }
                      }
                      else
                      {
                        NSLog(&cfstr_TheFilterIsNot.isa, v36, [v17 path]);
                      }
                    }
                    uint64_t v33 = [v21 countByEnumeratingWithState:&v46 objects:v72 count:16];
                  }
                  while (v33);
                }
              }
              v60((uint64_t)v59);
              char v13 = v42;
              uint64_t v14 = v43;
              uint64_t v15 = v41;
              uint64_t v16 = v44;
            }
          }
          ++v16;
        }
        while (v16 != v14);
        uint64_t v40 = [obj countByEnumeratingWithState:&v64 objects:v76 count:16];
        uint64_t v14 = v40;
      }
      while (v40);
    }
  }
  ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_1067();
}

void sub_193693798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45)
{
}

uint64_t ci_signpost_log_filter()
{
  if (ci_signpost_log_filter_onceToken != -1) {
    dispatch_once(&ci_signpost_log_filter_onceToken, &__block_literal_global_17_0);
  }
  return ci_signpost_log_filter_log;
}

void ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_1091(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = ci_signpost_log_filter();
  os_signpost_id_t v3 = *(void *)(a1 + 40);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    id v4 = v2;
    if (os_signpost_enabled(v2))
    {
      uint64_t v5 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 32), "lastPathComponent"), "UTF8String");
      int v6 = 136446210;
      uint64_t v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "BundleLoad", "%{public}s", (uint8_t *)&v6, 0xCu);
    }
  }
}

void ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_1084(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = ci_signpost_log_filter();
  os_signpost_id_t v3 = *(void *)(a1 + 40);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    id v4 = v2;
    if (os_signpost_enabled(v2))
    {
      uint64_t v5 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 32), "lastPathComponent"), "UTF8String");
      int v6 = 136446210;
      uint64_t v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "LoadFilter", "%{public}s", (uint8_t *)&v6, 0xCu);
    }
  }
}

void ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_1067()
{
  unint64_t v0 = ci_signpost_log_filter();
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)unint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_193671000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LoadMoreFilters", "", v1, 2u);
  }
}

void CI::ProgramNode::addDestinationTransform(CI::ProgramNode *this, const CI::Context *a2, const CI::Affine *a3)
{
  int v6 = (double *)*((void *)this + 6);
  double v8 = v6[7];
  double v7 = v6[8];
  double v10 = v6[9];
  double v9 = v6[10];
  double v24 = v6[12];
  double v25 = v6[11];
  CI::AffineNode::append_transform((CI::AffineNode *)v6, a3);
  memset(v34, 0, sizeof(v34));
  CGRect v35 = *(CGRect *)*(void *)CI::Node::rois(this);
  long long v11 = *((_OWORD *)a3 + 1);
  *(_OWORD *)&v33.a = *(_OWORD *)a3;
  *(_OWORD *)&v33.c = v11;
  *(_OWORD *)&v33.tdouble x = *((_OWORD *)a3 + 2);
  CGRect v36 = CGRectApplyAffineTransform(v35, &v33);
  double x = v36.origin.x;
  double y = v36.origin.y;
  double width = v36.size.width;
  double height = v36.size.height;
  uint64_t v16 = (void *)CI::Node::rois(this);
  CI::SerialRectArray::replace(v16, (uint64_t)v34, 0, x, y, width, height);
  double v17 = *((double *)a3 + 2);
  double v18 = *((double *)a3 + 3);
  double v19 = *((double *)a3 + 1);
  double v20 = v7 * v17 + v8 * *(double *)a3;
  double v21 = v9 * v17 + v10 * *(double *)a3;
  double v22 = *((double *)a3 + 5);
  double v23 = v24 * v17 + v25 * *(double *)a3 + *((double *)a3 + 4);
  *(double *)uint64_t v31 = v20;
  *(double *)&v31[1] = v7 * v18 + v8 * v19;
  *(double *)&v31[2] = v21;
  *(double *)&v31[3] = v9 * v18 + v10 * v19;
  *(double *)&v31[4] = v23;
  *(double *)&v31[5] = v24 * v18 + v25 * v19 + v22;
  CI::Affine::inverse((CI::Affine *)v31, (double *)v32);
  v26[0] = MEMORY[0x1E4F143A8];
  v26[1] = 1174405120;
  long long v27 = v32[0];
  v26[2] = ___ZN2CI11ProgramNode23addDestinationTransformERKNS_7ContextERKNS_6AffineE_block_invoke;
  v26[3] = &__block_descriptor_tmp_73_0;
  v26[4] = this;
  long long v28 = v32[1];
  long long v29 = v32[2];
  uint64_t v30 = a2;
  CI::ProgramNode::dispatch_main_program_args((uint64_t)this, (uint64_t)a2, v26, 0, 0);
}

void ___ZN2CI11ProgramNode23addDestinationTransformERKNS_7ContextERKNS_6AffineE_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v7.a = *(_OWORD *)(a1 + 40);
  *(_OWORD *)&v7.c = v3;
  *(_OWORD *)&v7.tdouble x = *(_OWORD *)(a1 + 72);
  CI::Vector::Vector((CI::Vector *)v8, &v7);
  id v4 = *(CI::Vector **)(*(void *)(v2 + 128) + 24);
  if ((*(unsigned int (**)(CI::Vector *))(*(void *)v4 + 16))(v4) == 58)
  {
    double v5 = CI::Vector::clone(v4, (const CI::Vector *)v8);
    if ((*(unsigned int (**)(void, double))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88), v5) == 74)
    {
      int v6 = *(CI::Vector **)(*(void *)(v2 + 128) + 32);
      if ((*(unsigned int (**)(CI::Vector *))(*(void *)v6 + 16))(v6) == 58) {
        CI::Vector::clone(v6, (const CI::Vector *)v8);
      }
    }
  }
  double v9 = &unk_1EE45B0E8;
  atomic_fetch_add(dword_1EB466F58, 0xFFFFFFFF);
}

double CI::AffineNode::append_transform(CI::AffineNode *this, const CI::Affine *a2)
{
  long long v3 = (_OWORD *)((char *)this + 56);
  double result = CI::Affine::operator*((double *)this + 7, (double *)a2, (double *)v6);
  if (v3 != v6)
  {
    long long v5 = v6[1];
    *(_OWORD *)((char *)this + 56) = v6[0];
    *(_OWORD *)((char *)this + 72) = v5;
    double result = *(double *)&v7;
    *(_OWORD *)((char *)this + 88) = v7;
  }
  return result;
}

void CI::MetalContext::bind_arguments(CI::MetalContext *this, const CI::ProgramNode *a2, const CGRect *a3, const CGRect *a4, float64x2_t *a5, CI::TileTask *a6)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (CI_VERBOSE_SIGNPOSTS())
  {
    double v9 = ci_signpost_log_render();
    os_signpost_id_t v10 = *((int *)a2 + 9) | (unint64_t)((*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this) << 32);
    if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
    {
      LOWORD(buf.origin.x) = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v9, OS_SIGNPOST_INTERVAL_BEGIN, v10, "bind_arguments", "", (uint8_t *)&buf, 2u);
    }
  }
  uint64_t v11 = (*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this);
  TimerBase::TimerBase((uint64_t)v58, v11, *((_DWORD *)a2 + 9), (uint64_t)"bind_arguments", 11);
  uint64_t v12 = (uint64x2_t *)CI::ProgramNode::mainProgram((dispatch_queue_t *)a2);
  if ((*(int (**)(uint64x2_t *))(v12->i64[0] + 16))(v12) >= 67
    && (*(int (**)(uint64x2_t *))(v12->i64[0] + 16))(v12) < 70)
  {
    char v13 = CIMetalBufferCreate(*((void *)this + 240), (void *)[*((id *)this + 49) device], (v12[6].i64[1] + 15) & 0xFFFFFFFFFFFFFFF0);
    *((void *)this + 223) = v13;
    if (v13)
    {
      long long v47 = (float32x4_t *)[v13 contents];
      if (v47)
      {
        float32x4_t *v47 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)a4->origin), (float64x2_t)a4->size);
        int v14 = CI::MainProgram::num_arguments((CI::MainProgram *)v12);
        if (CI_VERBOSE_SIGNPOSTS())
        {
          uint64_t v15 = ci_signpost_log_render();
          os_signpost_id_t v16 = *((int *)a2 + 9) | (unint64_t)((*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this) << 32);
          if (v16 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v15))
          {
            LOWORD(buf.origin.x) = 0;
            _os_signpost_emit_with_name_impl(&dword_193671000, v15, OS_SIGNPOST_INTERVAL_BEGIN, v16, "render_node_arguments", "", (uint8_t *)&buf, 2u);
          }
        }
        uint64_t v17 = (*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this);
        TimerBase::TimerBase((uint64_t)&buf, v17, *((_DWORD *)a2 + 9), (uint64_t)"render_node_arguments", 0);
        dispatch_sync(*((dispatch_queue_t *)a2 + 13), &__block_literal_global_63);
        uint64_t v46 = *((void *)a2 + 16);
        if (CI_VERBOSE_SIGNPOSTS())
        {
          double v18 = ci_signpost_log_render();
          CGFloat y = buf.origin.y;
          if ((unint64_t)(*(void *)&buf.origin.y - 1) <= 0xFFFFFFFFFFFFFFFDLL)
          {
            double v20 = v18;
            if (os_signpost_enabled(v18))
            {
              LOWORD(v56.origin.x) = 0;
              _os_signpost_emit_with_name_impl(&dword_193671000, v20, OS_SIGNPOST_INTERVAL_END, *(os_signpost_id_t *)&y, "render_node_arguments", "", (uint8_t *)&v56, 2u);
            }
          }
        }
        TimerBase::~TimerBase((TimerBase *)&buf);
        if (v46)
        {
          if (*(_DWORD *)v46 == v14)
          {
            *((void *)this + 218) = 0;
            if (v14 >= 1)
            {
              unint64_t v21 = 0;
              uint64_t v45 = v14;
              double v22 = (unsigned int **)(v46 + 24);
              uint64_t v23 = 6;
              while (2)
              {
                int v24 = (*(uint64_t (**)(uint64x2_t *, unint64_t))(v12->i64[0] + 40))(v12, v21);
                int v25 = v24;
                long long v26 = v22;
                if (v21 >= 0xA) {
                  long long v26 = (unsigned int **)(*(void *)(v46 + 16) + 8 * (v21 - 10));
                }
                long long v27 = (int *)v12[7].i64[0];
                if (v27 && (uint64_t)v21 < *v27)
                {
                  if (v21 > 9) {
                    long long v28 = (int *)(*((void *)v27 + 2) + 4 * (v21 - 10));
                  }
                  else {
                    long long v28 = &v27[v23];
                  }
                  int v29 = *v28;
                }
                else
                {
                  int v29 = -1;
                }
                uint64_t v30 = *v26;
                switch(v24)
                {
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 60)
                    {
                      CI::ProgramNode::roiKeys_of_child(a2, *a3, v30[8], &buf);
                      if (CI::Context::bind_sampler(this, (uint64_t)v30, *(uint64_t *)&buf.origin.x, *((unsigned int *)this + 436), v25, a6))++*((void *)this + 218); {
                      if (*(void *)&buf.origin.x)
                      }
                      {
                        buf.origin.CGFloat y = buf.origin.x;
                        operator delete(*(void **)&buf.origin.x);
                      }
                      goto LABEL_65;
                    }
                    break;
                  case 5:
                  case 6:
                  case 7:
                  case 8:
                  case 9:
                  case 10:
                  case 11:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 58) {
                      goto LABEL_32;
                    }
                    break;
                  case 12:
                  case 13:
                  case 14:
                  case 15:
                  case 16:
                  case 17:
                  case 18:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 58)
                    {
                      CI::Vector::copy_to((CI::Vector *)v30, (unsigned __int16 *)((char *)v47 + v29));
                      goto LABEL_65;
                    }
                    break;
                  case 19:
                  case 23:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 58)
                    {
                      *(__int32 *)((char *)v47->i32 + v29) = (int)*((float *)v30 + 7);
                      goto LABEL_65;
                    }
                    break;
                  case 20:
                  case 24:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 58)
                    {
                      *(int32x2_t *)((char *)v47->f32 + v29) = vcvt_s32_f32(*(float32x2_t *)(v30 + 7));
                      goto LABEL_65;
                    }
                    break;
                  case 21:
                  case 25:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 58)
                    {
                      CGRect v35 = (int32x2_t *)((char *)v47 + v29);
                      *CGRect v35 = vcvt_s32_f32(*(float32x2_t *)(v30 + 7));
                      v35[1].i32[0] = (int)*((float *)v30 + 9);
                      goto LABEL_65;
                    }
                    break;
                  case 22:
                  case 26:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 58)
                    {
                      *(int32x4_t *)((char *)v47 + v29) = vcvtq_s32_f32(*(float32x4_t *)(v30 + 7));
                      goto LABEL_65;
                    }
                    break;
                  case 27:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 58)
                    {
LABEL_32:
                      CI::Vector::copy_to((float *)v30, (float *)((char *)v47->f32 + v29));
                      goto LABEL_65;
                    }
                    break;
                  case 28:
                  case 29:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 57)
                    {
                      CI::Buffer::copy_to((CI::Buffer *)v30, (unsigned __int8 *)v47 + v29);
                      goto LABEL_65;
                    }
                    break;
                  case 37:
                  case 44:
                  case 45:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 58)
                    {
                      CI::Vector::affine((CI::Vector *)v30, &v56.origin.x);
                      CGFloat v31 = a3->origin.x - a4->origin.x;
                      CGFloat v32 = a3->origin.y - a4->origin.y;
                      CGRect v54 = v56;
                      *(double *)&long long v55 = v57[0] + v56.origin.x * v31 + v56.size.width * v32;
                      *((double *)&v55 + 1) = v57[1] + v56.origin.y * v31 + v56.size.height * v32;
                      if (v25 == 37)
                      {
                        CI::Affine::inverse((CI::Affine *)&v54, &buf.origin.x);
                        CGRect v54 = buf;
                        long long v55 = v60;
                      }
                      *(CGPoint *)&v53.a = v54.origin;
                      *(CGSize *)&v53.c = v54.size;
                      *(_OWORD *)&v53.tdouble x = v55;
                      CGAffineTransform v33 = (float *)CI::Vector::Vector((CI::Vector *)&buf, &v53);
                      uint64_t v34 = (float32x2_t *)((char *)v47 + v29);
                      CI::Vector::copy_to(v33, (float *)v34);
                      if (v25 != 44)
                      {
                        v34[6] = vcvt_f32_f64(vcvtq_f64_u64(v12[5]));
                        v34[7] = vcvt_f32_f64(*a5);
                      }
                      *(void *)&buf.size.double width = &unk_1EE45B0E8;
                      goto LABEL_64;
                    }
                    break;
                  case 40:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 60)
                    {
                      memset(&v56, 0, sizeof(v56));
                      v56.origin.double x = CI::Node::region_of_child(a2, *a3);
                      v56.origin.CGFloat y = v36;
                      v56.size.double width = v37;
                      v56.size.double height = v38;
                      CI::TextureSampler::transform((CI::TextureSampler *)v30, this, &v56, (float64x2_t *)&v52);
                      uint64_t v39 = (float *)CI::Vector::Vector((CI::Vector *)&buf, &v52);
                      CI::Vector::copy_to(v39, (float *)((char *)v47->f32 + v29));
                      goto LABEL_63;
                    }
                    break;
                  case 41:
                    if ((*(unsigned int (**)(unsigned int *))(*(void *)v30 + 16))(v30) == 60)
                    {
                      memset(&v54, 0, sizeof(v54));
                      v54.origin.double x = CI::Node::region_of_child(a2, *a3);
                      v54.origin.CGFloat y = v40;
                      v54.size.double width = v41;
                      v54.size.double height = v42;
                      CI::TextureSampler::transform((CI::TextureSampler *)v30, this, &v54, (float64x2_t *)&v56);
                      *(CGPoint *)&v51.a = v56.origin;
                      *(CGSize *)&v51.c = v56.size;
                      *(_OWORD *)&v51.tdouble x = *(_OWORD *)v57;
                      uint64_t v43 = (float *)CI::Vector::Vector((CI::Vector *)&buf, &v51);
                      CI::Vector::copy_to(v43, (float *)((char *)v47->f32 + v29));
                      *(void *)&buf.size.double width = &unk_1EE45B0E8;
                      atomic_fetch_add(dword_1EB466F58, 0xFFFFFFFF);
                      uint64_t v44 = (float *)CI::Vector::Vector((CI::Vector *)&buf, *(CGRect *)(v30 + 22));
                      CI::Vector::copy_to(v44, (float *)((char *)v47[3].f32 + v29));
LABEL_63:
                      *(void *)&buf.size.double width = &unk_1EE45B0E8;
LABEL_64:
                      atomic_fetch_add(dword_1EB466F58, 0xFFFFFFFF);
                      goto LABEL_65;
                    }
                    break;
                  case 42:
                  case 43:
                  case 46:
                  case 47:
                    goto LABEL_65;
                  default:
                    x_log("Unhandled type: %d\n", v24);
LABEL_65:
                    ++v21;
                    ++v23;
                    ++v22;
                    if (v45 == v21) {
                      break;
                    }
                    continue;
                }
                break;
              }
            }
          }
        }
      }
    }
  }
  CI::MetalContext::bind_arguments(CI::ProgramNode const*,CGRect const&,CGRect const&,CGSize const&,CI::TileTask *)::SignpostTimer::~SignpostTimer((TimerBase *)v58);
}

void sub_19369486C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  *(void *)(v50 - 224) = &unk_1EE45B0E8;
  atomic_fetch_add(dword_1EB466F58, 0xFFFFFFFF);
  CI::MetalContext::bind_arguments(CI::ProgramNode const*,CGRect const&,CGRect const&,CGSize const&,CI::TileTask *)::SignpostTimer::~SignpostTimer((TimerBase *)&a50);
  _Unwind_Resume(a1);
}

uint64_t CI::KernelArguments::get_type(CI::KernelArguments *this, unsigned int a2)
{
  uint64_t result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = *(void *)this;
    if (v4)
    {
      if (*(_DWORD *)v4 <= (signed int)a2)
      {
        return 0;
      }
      else
      {
        if (a2 > 9) {
          long long v5 = (unsigned int *)(*(void *)(v4 + 16) + 4 * (a2 - 10));
        }
        else {
          long long v5 = (unsigned int *)(v4 + 4 * a2 + 24);
        }
        return *v5;
      }
    }
  }
  return result;
}

uint64_t CI::MainProgram::argument_type(CI::MainProgram *this, unsigned int a2)
{
  return CI::KernelArguments::get_type((CI::MainProgram *)((char *)this + 64), a2);
}

float *CI::Vector::copy_to(float *this, float *__dst)
{
  uint64_t v2 = *((int *)this + 6);
  if (v2 != 9) {
    return (float *)memcpy(__dst, this + 7, 4 * v2);
  }
  void *__dst = this[7];
  __dst[1] = this[8];
  __dst[2] = this[9];
  __dst[3] = 0.0;
  __dst[4] = this[10];
  __dst[5] = this[11];
  __dst[6] = this[12];
  __dst[7] = 0.0;
  __dst[8] = this[13];
  __dst[9] = this[14];
  __dst[10] = this[15];
  __dst[11] = 0.0;
  return this;
}

uint64_t CI::MetalDAG::type(CI::MetalDAG *this)
{
  return 68;
}

uint64_t CI::TextureSampler::type(CI::TextureSampler *this)
{
  return 60;
}

CI::Vector *CI::Vector::Vector(CI::Vector *this, CGAffineTransform *a2)
{
  *(void *)this = &unk_1EE45DF30;
  *((_DWORD *)this + 2) = 1;
  *((void *)this + 2) = &unk_1EE45B0E8;
  atomic_fetch_add(dword_1EB466F58, 1u);
  *(void *)this = &unk_1EE45DF68;
  *((void *)this + 2) = &unk_1EE45DFA0;
  *((void *)this + 12) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_DWORD *)this + 22) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 6) = 9;
  *(float *)&unsigned int v3 = a2->a;
  *((_DWORD *)this + 7) = v3;
  *(float *)&unsigned int v4 = a2->c;
  *((_DWORD *)this + 8) = v4;
  *(float *)&unsigned int v5 = a2->tx;
  *((_DWORD *)this + 9) = v5;
  *(float *)&unsigned int v6 = a2->b;
  *((_DWORD *)this + 10) = v6;
  *(float *)&unsigned int v7 = a2->d;
  *((_DWORD *)this + 11) = v7;
  *(float *)&unsigned int v8 = a2->ty;
  *((_DWORD *)this + 12) = v8;
  *((void *)this + 7) = 0x3F80000000000000;
  *(void *)&long long v11 = __PAIR64__(v4, v3);
  *((void *)&v11 + 1) = __PAIR64__(v6, v5);
  long long v12 = __PAIR64__(v8, v7);
  LODWORD(v13) = 1065353216;
  HIDWORD(v13) = mat3::type((mat3 *)&v11);
  long long v9 = v12;
  *((_OWORD *)this + 6) = v11;
  *((_OWORD *)this + 7) = v9;
  *((void *)this + 16) = v13;
  return this;
}

BOOL mat3::type(mat3 *this)
{
  float v1 = *((float *)this + 1);
  if (*(float *)this != 1.0
    || v1 != 0.0
    || *((float *)this + 2) != 0.0
    || *((float *)this + 3) != 0.0
    || *((float *)this + 4) != 1.0
    || *((float *)this + 5) != 0.0
    || *((float *)this + 6) != 0.0
    || *((float *)this + 7) != 0.0)
  {
    if (v1 != 0.0) {
      return 0;
    }
    goto LABEL_13;
  }
  float v2 = *((float *)this + 8);
  uint64_t v3 = 2 * (v2 == 1.0);
  if (v2 != 1.0 && v1 == 0.0)
  {
LABEL_13:
    if (*((float *)this + 3) == 0.0 && *((float *)this + 6) == 0.0 && *((float *)this + 7) == 0.0) {
      return *((float *)this + 8) == 1.0;
    }
    return 0;
  }
  return v3;
}

uint64_t CI::Context::bind_sampler(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, CI::TileTask *a6)
{
  long long v12 = (CI::TextureManager *)(*(uint64_t (**)(void *))(*a1 + 112))(a1);
  uint64_t v13 = *(CGImageRef **)(a2 + 24);
  v62.origin.CGFloat x = CI::Node::roi(*(CI::Node **)a3, *(_DWORD *)(a3 + 8));
  CGFloat x = v62.origin.x;
  CGFloat y = v62.origin.y;
  CGFloat width = v62.size.width;
  CGFloat height = v62.size.height;
  CGRect v61 = v62;
  double v59 = 0.0;
  unint64_t v60 = 0;
  if (!CGRectIsEmpty(v62))
  {
    int v18 = (*((uint64_t (**)(CGImageRef *))*v13 + 2))(v13);
    uint64_t v19 = 0;
    switch(v18)
    {
      case ',':
        if (CI::CI_ASSEMBLE_INPUT_TILES(void)::didCheck != -1) {
          dispatch_once(&CI::CI_ASSEMBLE_INPUT_TILES(void)::didCheck, &__block_literal_global_97_0);
        }
        if (!CI::CI_ASSEMBLE_INPUT_TILES(void)::v) {
          goto LABEL_34;
        }
        unint64_t v21 = v13[8];
        CGImageRef v20 = v13[9];
        if (v21 == v20)
        {
          unint64_t v22 = 0;
        }
        else
        {
          unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((v20 - v21) >> 3);
          uint64_t v24 = *(void *)v21;
          uint64_t v23 = *((void *)v21 + 1);
          if (v24 != v23)
          {
            unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((v23 - v24) >> 3);
            goto LABEL_31;
          }
        }
        unint64_t v25 = 0;
LABEL_31:
        if (v25 * v22 < 2)
        {
LABEL_34:
          CGFloat v41 = (__IOSurface *)CI::ProviderNode::surfaceForROI((uint64_t)v13, a1, &v61.origin.x, (uint64_t)&v59);
        }
        else
        {
          v63.origin.CGFloat x = x;
          v63.origin.CGFloat y = y;
          v63.size.CGFloat width = width;
          v63.size.CGFloat height = height;
          if (CGRectIsNull(v63))
          {
            unint64_t v55 = 0;
            long long v54 = IRectNull;
          }
          else
          {
            v65.origin.CGFloat x = x;
            v65.origin.CGFloat y = y;
            v65.size.CGFloat width = width;
            v65.size.CGFloat height = height;
            if (CGRectIsInfinite(v65))
            {
              long long v54 = IRectInfinite;
              unint64_t v55 = 0xFFFFFFFFLL;
            }
            else
            {
              v67.origin.CGFloat x = x;
              v67.origin.CGFloat y = y;
              v67.size.CGFloat width = width;
              v67.size.CGFloat height = height;
              CGRect v68 = CGRectInset(v67, 0.000001, 0.000001);
              CGRect v69 = CGRectIntegral(v68);
              LODWORD(v54) = (int)v69.origin.x;
              DWORD1(v54) = (int)v69.origin.y;
              *((void *)&v54 + 1) = (unint64_t)v69.size.width;
              unint64_t v55 = (unint64_t)v69.size.height;
            }
          }
          uint64_t v43 = (*((uint64_t (**)(CGImageRef *, void))*v13 + 55))(v13, a1[19]);
          CGFloat v41 = CI::Context::assemble_leafTiles(a1, v13 + 7, (uint64_t)&v54, v43, v44, (uint64_t)&v59);
        }
        CI::TextureManager::intermediate(v12, v41, &v61);
      case '-':
      case '/':
      case '1':
      case '2':
      case '3':
        goto LABEL_60;
      case '.':
        BOOL v32 = a5 == 3;
        if (a5 == 3) {
          uint64_t v38 = 1;
        }
        else {
          uint64_t v38 = *(unsigned int *)(a2 + 124);
        }
        CI::SurfaceNode::surfaceForROI((uint64_t)v13, (uint64_t)a1, (uint64_t)&v59, &buffer, x, y, width, height);
        uint64_t v19 = (*(uint64_t (**)(void *, IOSurfaceRef, CGImageRef *, void, void, uint64_t, uint64_t, BOOL))(*a1 + 72))(a1, buffer, v13 + 6, *((unsigned __int8 *)v13 + 106), *(unsigned int *)(a2 + 120), v38, a4, v32);
        IOSurfaceRef v39 = buffer;
        IOSurfaceRef buffer = 0;
        if (!v39) {
          goto LABEL_60;
        }
        goto LABEL_59;
      case '0':
        int v33 = (*((uint64_t (**)(CGImageRef *))*v13 + 53))(v13);
        CGImageRef v34 = *v13;
        if (v33)
        {
          uint64_t v35 = (*((uint64_t (**)(CGImageRef *))v34 + 53))(v13);
          uint64_t v36 = (*(uint64_t (**)(void *, uint64_t, void, void, void, uint64_t))(*a1 + 80))(a1, v35, *((unsigned int *)v13 + 13), *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4);
        }
        else
        {
          if (!(*((uint64_t (**)(CGImageRef *))v34 + 54))(v13))
          {
            uint64_t v19 = 0;
            goto LABEL_60;
          }
          uint64_t v40 = (*((uint64_t (**)(CGImageRef *))*v13 + 54))(v13);
          uint64_t v36 = (*(uint64_t (**)(void *, uint64_t, void, void, uint64_t))(*a1 + 88))(a1, v40, *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4);
        }
        uint64_t v19 = v36;
        goto LABEL_60;
      case '4':
        uint64_t intermediate_for_node = CI::TextureManager::get_intermediate_for_node((uint64_t)v12, a3);
        if (((_BYTE)v13[18] & 4) != 0) {
          (*(void (**)(CI::TextureManager *, uint64_t))(*(void *)v12 + 56))(v12, intermediate_for_node);
        }
        (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)intermediate_for_node + 24))(&v52, intermediate_for_node);
        uint64_t v19 = (*(uint64_t (**)(void *, uint64_t *, void, void, uint64_t))(*a1 + 96))(a1, &v52, *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4);
        uint64_t v52 = 0;
        uint64_t v53 = 0;
        goto LABEL_60;
      default:
        if (v18 != 29) {
          goto LABEL_60;
        }
        if (CI::CI_ASSEMBLE_INPUT_TILES(void)::didCheck != -1) {
          dispatch_once(&CI::CI_ASSEMBLE_INPUT_TILES(void)::didCheck, &__block_literal_global_97_0);
        }
        if (!CI::CI_ASSEMBLE_INPUT_TILES(void)::v) {
          goto LABEL_39;
        }
        long long v27 = v13[8];
        CGImageRef v26 = v13[9];
        if (v27 == v26)
        {
          unint64_t v28 = 0;
          unint64_t v31 = 0;
        }
        else
        {
          unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v27) >> 3);
          uint64_t v30 = *(void *)v27;
          uint64_t v29 = *((void *)v27 + 1);
          unint64_t v31 = v30 == v29 ? 0 : 0xAAAAAAAAAAAAAAABLL * ((v29 - v30) >> 3);
        }
        if (v31 * v28 < 2) {
          goto LABEL_39;
        }
        v64.origin.CGFloat x = x;
        v64.origin.CGFloat y = y;
        v64.size.CGFloat width = width;
        v64.size.CGFloat height = height;
        if (CGRectIsNull(v64))
        {
          unint64_t v57 = 0;
          long long v56 = IRectNull;
        }
        else
        {
          v66.origin.CGFloat x = x;
          v66.origin.CGFloat y = y;
          v66.size.CGFloat width = width;
          v66.size.CGFloat height = height;
          if (CGRectIsInfinite(v66))
          {
            long long v56 = IRectInfinite;
            unint64_t v57 = 0xFFFFFFFFLL;
          }
          else
          {
            v70.origin.CGFloat x = x;
            v70.origin.CGFloat y = y;
            v70.size.CGFloat width = width;
            v70.size.CGFloat height = height;
            CGRect v71 = CGRectInset(v70, 0.000001, 0.000001);
            CGRect v72 = CGRectIntegral(v71);
            LODWORD(v56) = (int)v72.origin.x;
            DWORD1(v56) = (int)v72.origin.y;
            *((void *)&v56 + 1) = (unint64_t)v72.size.width;
            unint64_t v57 = (unint64_t)v72.size.height;
          }
        }
        uint64_t v45 = (*((uint64_t (**)(CGImageRef *, void))v13[7] + 3))(v13 + 7, 0);
        long long v47 = CI::Context::assemble_leafTiles(a1, v13 + 7, (uint64_t)&v56, v45, v46, (uint64_t)&v59);
        if (v47)
        {
          CGFloat v42 = v47;
          CFRetain(v47);
        }
        else
        {
LABEL_39:
          CI::CGNode::surfaceForROI((uint64_t)v13, (uint64_t)a1, &v61.origin.x, (uint64_t)&v59, &buffer);
          CGFloat v42 = buffer;
          if (!buffer) {
            goto LABEL_55;
          }
        }
        if (IOSurfaceGetPlaneCount(v42) <= 1) {
          CI::TextureManager::intermediate(v12, v42, &v61);
        }
LABEL_55:
        CI::CGNode::cgImageForROI(v13, &v61, &buffer);
        uint64_t v19 = (*(uint64_t (**)(void *, IOSurfaceRef, CGImageRef *, void, void, uint64_t))(*a1 + 64))(a1, buffer, v13 + 6, *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4);
        IOSurfaceRef v48 = buffer;
        IOSurfaceRef buffer = 0;
        if (v48) {
          CFRelease(v48);
        }
        if (v42)
        {
          IOSurfaceRef v39 = v42;
LABEL_59:
          CFRelease(v39);
        }
LABEL_60:
        CI::TileTask::incrementFillTimeForNode(a6, (const CI::Node *)v13, v59);
        CI::TileTask::incrementFillPixelsForNode(a6, (const CI::Node *)v13, v60);
        if (CI_LIMIT_SAMPLERS()) {
          break;
        }
        return v19;
    }
  }
  empty_surface = CI::TextureManager::get_empty_surface(v12);
  PixelFormat = (CI *)IOSurfaceGetPixelFormat(empty_surface);
  LODWORD(buffer) = CI::format_from_PixelFormatType(PixelFormat);
  WORD2(buffer) = 0;
  return (*(uint64_t (**)(void *, __IOSurface *, IOSurfaceRef *, void, void, void, uint64_t, void, uint64_t, uint64_t))(*a1 + 72))(a1, empty_surface, &buffer, 0, *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4, 0, v52, v53);
}

uint64_t CI::MetalContext::texture_manager(CI::MetalContext *this)
{
  return *((void *)this + 227);
}

void CI::TileTask::incrementFillPixelsForNode(CI::TileTask *this, const CI::Node *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = *((void *)this + 21);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN2CI8TileTask26incrementFillPixelsForNodeEPKNS_4NodeEy_block_invoke;
    block[3] = &__block_descriptor_tmp_10_3;
    void block[4] = this;
    block[5] = a2;
    void block[6] = a3;
    dispatch_async(v3, block);
  }
}

void CI::TileTask::incrementFillTimeForNode(CI::TileTask *this, const CI::Node *a2, double a3)
{
  if (a3 != 0.0)
  {
    void block[7] = v3;
    block[8] = v4;
    unsigned int v5 = *((void *)this + 21);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN2CI8TileTask24incrementFillTimeForNodeEPKNS_4NodeEd_block_invoke;
    block[3] = &__block_descriptor_tmp_9_5;
    void block[4] = this;
    block[5] = a2;
    *(double *)&void block[6] = a3;
    dispatch_async(v5, block);
  }
}

uint64_t CI::MetalContext::bind_texture(uint64_t a1, CFTypeRef cf, int a3, int a4, int a5)
{
  if (!cf) {
    return 0;
  }
  uint64_t result = 0;
  if (a3 <= 1 && a3 != -1)
  {
    uint64_t result = 0;
    if (a4 <= 1 && a4 != -1)
    {
      uint64_t v9 = a1 + 8 * a5;
      *(void *)(v9 + 1232) = cf;
      CFRetain(cf);
      *(void *)(v9 + 1488) = *(void *)(a1 + 16 * a3 + 8 * a4 + 1752);
      return 1;
    }
  }
  return result;
}

uint64_t CI_LIMIT_SAMPLERS()
{
  {
    CI_LIMIT_SAMPLERS::v = get_BOOL("CI_LIMIT_SAMPLERS", 0);
  }
  return CI_LIMIT_SAMPLERS::v;
}

void sub_1936957AC(_Unwind_Exception *a1)
{
}

void CI::SurfaceNode::surfaceForROI(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, __IOSurface **a4@<X8>, CGFloat a5@<D0>, CGFloat a6@<D1>, CGFloat a7@<D2>, CGFloat a8@<D3>)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (CI_VERBOSE_SIGNPOSTS())
  {
    os_signpost_id_t v16 = ci_signpost_log_render();
    os_signpost_id_t v17 = *(int *)(a1 + 36) | (unint64_t)((*(uint64_t (**)(uint64_t))(*(void *)a2 + 272))(a2) << 32);
    if (v17 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
    {
      *(_DWORD *)CGRect buf = 134218752;
      CGFloat v47 = a5;
      __int16 v48 = 2048;
      CGFloat v49 = a6;
      __int16 v50 = 2048;
      CGFloat v51 = a7;
      __int16 v52 = 2048;
      CGFloat v53 = a8;
      _os_signpost_emit_with_name_impl(&dword_193671000, v16, OS_SIGNPOST_INTERVAL_BEGIN, v17, "surface_for_roi_from_surface", "[%g %g %g %g]", buf, 0x2Au);
    }
  }
  uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 272))(a2);
  TimerBase::TimerBase((uint64_t)buf, v18, *(_DWORD *)(a1 + 36), (uint64_t)"surface_for_roi_from_surface", 24);
  v55.origin.CGFloat x = a5;
  v55.origin.CGFloat y = a6;
  v55.size.CGFloat width = a7;
  v55.size.CGFloat height = a8;
  if (!CGRectIsEmpty(v55))
  {
    v56.origin.CGFloat x = a5;
    v56.origin.CGFloat y = a6;
    v56.size.CGFloat width = a7;
    v56.size.CGFloat height = a8;
    if (!CGRectIsInfinite(v56))
    {
      uint64_t v21 = CI::format_from_IOSurface(*(CI **)(a1 + 56), v20);
      unsigned int v22 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 536))(a2, v21);
      double Current = CFAbsoluteTimeGetCurrent();
      *(void *)(a3 + 8) += (unint64_t)a7 * (unint64_t)a8;
      v57.size.CGFloat width = (double)*(unint64_t *)(a1 + 80);
      v57.size.CGFloat height = (double)*(unint64_t *)(a1 + 88);
      v57.origin.CGFloat x = 0.0;
      v57.origin.CGFloat y = 0.0;
      CGRect v61 = CGRectInset(v57, 2.0, 2.0);
      v58.origin.CGFloat x = a5;
      v58.origin.CGFloat y = a6;
      v58.size.CGFloat width = a7;
      v58.size.CGFloat height = a8;
      if (CGRectContainsRect(v58, v61))
      {
        unint64_t v24 = v22;
        if (SurfaceIsRowBytesAligned(*(__IOSurface **)(a1 + 56), v22))
        {
          CFRetain(*(CFTypeRef *)(a1 + 56));
          *(CFAbsoluteTime *)a3 = CFAbsoluteTimeGetCurrent() - Current + *(double *)a3;
          Surface = *(__IOSurface **)(a1 + 56);
          goto LABEL_30;
        }
      }
      else
      {
        unint64_t v24 = v22;
      }
      if (!SurfaceIsRowBytesAligned(*(__IOSurface **)(a1 + 56), v24))
      {
        unint64_t v25 = ci_logger_performance();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
        {
          uint64_t v26 = *(void *)(a1 + 80);
          uint64_t v27 = *(void *)(a1 + 88);
          *(_DWORD *)uint64_t v40 = 134218496;
          uint64_t v41 = v26;
          __int16 v42 = 2048;
          uint64_t v43 = v27;
          __int16 v44 = 1024;
          unsigned int v45 = v22;
          _os_log_impl(&dword_193671000, v25, OS_LOG_TYPE_INFO, "CI_CONVERSION: Converted %zux%zu input surface to a new surface with required rowbytes alignment (of %d bytes).", v40, 0x1Cu);
        }
      }
      if (CI_ENABLE_METAL_BLIT()
        && (*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) == 77)
      {
        unsigned int v22 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 544))(a2, v21);
      }
      uint64_t PixelFormat = IOSurfaceGetPixelFormat(*(IOSurfaceRef *)(a1 + 56));
      Surface = CreateSurface((__CVBuffer *)a7, (__CVBuffer *)a8, (void *)v22, PixelFormat, 0);
      if (CI_ENABLE_METAL_BLIT())
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) == 77
          && IOSurfaceGetPlaneCount(*(IOSurfaceRef *)(a1 + 56)) <= 1)
        {
          unint64_t v29 = *(void *)(a1 + 80);
          if (v29 <= (*(uint64_t (**)(uint64_t))(*(void *)a2 + 440))(a2))
          {
            unint64_t v30 = *(void *)(a1 + 88);
            if (v30 <= (*(uint64_t (**)(uint64_t))(*(void *)a2 + 440))(a2)
              && SurfaceIsRowBytesAligned(*(__IOSurface **)(a1 + 56), v24))
            {
              unint64_t v31 = (void *)CI::MetalContext::device((id *)a2);
              unsigned int v32 = CIMetalFormatForFormat(*(_DWORD *)(a1 + 48), *(unsigned __int8 *)(a1 + 52));
              int v33 = CIMetalTextureCreateFromIOSurface(*(void *)(a2 + 1920), v31, *(IOSurfaceRef *)(a1 + 56), 0, v32, 1);
              if (v33)
              {
                CGImageRef v34 = CIMetalTextureCreateFromIOSurface(*(void *)(a2 + 1920), v31, Surface, 0, v32, 2);
                if (v34)
                {
                  v59.origin.CGFloat x = a5;
                  v59.origin.CGFloat y = a6;
                  v59.size.CGFloat width = a7;
                  v59.size.CGFloat height = a8;
                  CGRect v60 = CGRectIntegral(v59);
                  uint64_t v35 = *(void **)(a2 + 1792);
                  CIMetalCommandBufferCopyTexture(v35, (uint64_t)v34, (uint64_t)v33, *MEMORY[0x1E4F1DAD8], *(double *)(MEMORY[0x1E4F1DAD8] + 8), v60.origin.x, v60.origin.y, v60.size.width, v60.size.height);
                  v39[0] = MEMORY[0x1E4F143A8];
                  v39[1] = 3221225472;
                  v39[2] = ___ZNK2CI11SurfaceNode13surfaceForROIEPKNS_7ContextE6CGRectRNS_8Tileable5StatsE_block_invoke;
                  v39[3] = &unk_1E5772640;
                  v39[4] = v33;
                  v39[5] = v34;
                  CIMetalCommandBufferAddCompletionHandler(v35, (uint64_t)v39);
                  double v36 = CFAbsoluteTimeGetCurrent();
LABEL_29:
                  *(double *)a3 = v36 - Current + *(double *)a3;
                  goto LABEL_30;
                }
                CFRelease(v33);
              }
            }
          }
        }
      }
      CGFloat v37 = *(__IOSurface **)(a1 + 56);
      v38[0] = MEMORY[0x1E4F143A8];
      v38[1] = 3221225472;
      v38[2] = ___ZNK2CI11SurfaceNode13surfaceForROIEPKNS_7ContextE6CGRectRNS_8Tileable5StatsE_block_invoke_2;
      v38[3] = &__block_descriptor_80_e22_v48__0r_v8Q16Q24Q32Q40l;
      v38[4] = a1;
      v38[5] = Surface;
      *(CGFloat *)&v38[6] = a5;
      *(CGFloat *)&v38[7] = a6;
      *(CGFloat *)&v38[8] = a7;
      *(CGFloat *)&v38[9] = a8;
      SurfaceApplyPlaneReadOnlyBlock(v37, (uint64_t)v38);
      double v36 = CFAbsoluteTimeGetCurrent();
      goto LABEL_29;
    }
  }
  Surface = 0;
LABEL_30:
  *a4 = Surface;
  CI::SurfaceNode::surfaceForROI(CI::Context const*,CGRect,CI::Tileable::Stats &)const::SignpostTimer::~SignpostTimer((TimerBase *)buf);
}

void sub_193695DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t CI::format_from_IOSurface(CI *this, __IOSurface *a2)
{
  uint64_t PixelFormat = (CI *)IOSurfaceGetPixelFormat(this);
  uint64_t v4 = CI::format_from_PixelFormatType(PixelFormat);
  unsigned int v5 = CI::format_with_x_for_format(v4);
  if (v5 != v4)
  {
    unsigned int v6 = v5;
    CFTypeRef v7 = IOSurfaceCopyValue(this, @"IOSurfaceAlphaIsOpaque");
    if (v7 == (CFTypeRef)*MEMORY[0x1E4F1CFD0]) {
      uint64_t v4 = v6;
    }
    else {
      uint64_t v4 = v4;
    }
    if (v7) {
      CFRelease(v7);
    }
  }
  return v4;
}

uint64_t CI::format_from_PixelFormatType(CI *this)
{
  int v1 = equivalent_uncompressed_format((uint64_t)this);
  uint64_t result = 0;
  if (v1 > 1667838823)
  {
    if (v1 > 1919379251)
    {
      if (v1 > 1953903667)
      {
        if (v1 > 2019963439)
        {
          if (v1 > 2033463351)
          {
            switch(v1)
            {
              case 2033463352:
                return 535;
              case 2037741158:
                return 277;
              case 2037741171:
                return 533;
            }
          }
          else
          {
            switch(v1)
            {
              case 2019963440:
                return 786;
              case 2019963442:
                return 790;
              case 2019963956:
                return 787;
            }
          }
        }
        else if (v1 > 2016686639)
        {
          switch(v1)
          {
            case 2016686640:
              return 1042;
            case 2016686642:
              return 1046;
            case 2016687156:
              return 1043;
          }
        }
        else
        {
          switch(v1)
          {
            case 1953903668:
              return 3603;
            case 1999843442:
              return 2567;
            case 1999908961:
              return 2569;
          }
        }
      }
      else if (v1 > 1937126451)
      {
        if (v1 > 1952855091)
        {
          switch(v1)
          {
            case 1952855092:
              return 3347;
            case 1953903152:
              return 3602;
            case 1953903154:
              return 3606;
          }
        }
        else
        {
          switch(v1)
          {
            case 1937126452:
              return 3859;
            case 1952854576:
              return 3346;
            case 1952854578:
              return 3350;
          }
        }
      }
      else if (v1 > 1936077875)
      {
        switch(v1)
        {
          case 1936077876:
            return 1811;
          case 1937125936:
            return 3858;
          case 1937125938:
            return 3862;
        }
      }
      else
      {
        switch(v1)
        {
          case 1919379252:
            return 771;
          case 1936077360:
            return 1810;
          case 1936077362:
            return 1814;
        }
      }
      return result;
    }
    if (v1 > 1751527983)
    {
      if (v1 > 1882468911)
      {
        if (v1 > 1885745711)
        {
          switch(v1)
          {
            case 1885745712:
              return 1298;
            case 1885745714:
              return 1302;
            case 1885746228:
              return 1299;
          }
        }
        else
        {
          switch(v1)
          {
            case 1882468912:
              return 1554;
            case 1882468914:
              return 1558;
            case 1882469428:
              return 1555;
          }
        }
      }
      else if (v1 > 1815162993)
      {
        switch(v1)
        {
          case 1815162994:
            return 784;
          case 1815361650:
            return 1799;
          case 1815491698:
            return 1800;
        }
      }
      else
      {
        switch(v1)
        {
          case 1751527984:
            return 2066;
          case 1751527986:
            return 2070;
          case 1751528500:
            return 2067;
        }
      }
      return result;
    }
    if (v1 <= 1717855599)
    {
      if (v1 > 1667844407)
      {
        switch(v1)
        {
          case 1667844408:
            return 258;
          case 1667844454:
            return 2306;
          case 1667844456:
            return 2050;
        }
      }
      else
      {
        switch(v1)
        {
          case 1667838824:
            return 2055;
          case 1667839024:
            return 3081;
          case 1667844406:
            return 1794;
        }
      }
      return result;
    }
    if (v1 > 1735549491)
    {
      if (v1 != 1735549492)
      {
        if (v1 == 1751410032) {
          return 2051;
        }
        int v4 = 1751411059;
LABEL_134:
        if (v1 != v4) {
          return result;
        }
        return 2051;
      }
      return 771;
    }
    if (v1 == 1717855600 || v1 == 1717856627) {
      return 2307;
    }
    int v3 = 1734505012;
LABEL_88:
    if (v1 != v3) {
      return result;
    }
    return 771;
  }
  if (v1 <= 1093677111)
  {
    if (v1 > 843264303)
    {
      if (v1 > 875704421)
      {
        if (v1 > 875704949)
        {
          switch(v1)
          {
            case 875704950:
              return 534;
            case 875836518:
              return 275;
            case 875836534:
              return 531;
          }
        }
        else
        {
          switch(v1)
          {
            case 875704422:
              return 274;
            case 875704438:
              return 530;
            case 875704934:
              return 278;
          }
        }
      }
      else if (v1 > 845361455)
      {
        switch(v1)
        {
          case 845361456:
            return 1286;
          case 846624102:
            return 276;
          case 846624121:
            return 532;
        }
      }
      else
      {
        switch(v1)
        {
          case 843264304:
            return 774;
          case 843264306:
            return 3334;
          case 843264310:
            return 1798;
        }
      }
    }
    else if (v1 > 826487089)
    {
      if (v1 > 843264055)
      {
        switch(v1)
        {
          case 843264056:
            return 262;
          case 843264102:
            return 2310;
          case 843264104:
            return 2054;
        }
      }
      else
      {
        switch(v1)
        {
          case 826487090:
            return 3333;
          case 826487094:
            return 1797;
          case 828584240:
            return 1285;
        }
      }
    }
    else if (v1 > 826486885)
    {
      switch(v1)
      {
        case 826486886:
          return 2309;
        case 826486888:
          return 2053;
        case 826487088:
          return 773;
      }
    }
    else
    {
      switch(v1)
      {
        case 24:
          return 263;
        case 32:
          return 265;
        case 826486840:
          return 261;
      }
    }
    return result;
  }
  if (v1 <= 1279340599)
  {
    if (v1 <= 1278226487)
    {
      if (v1 > 1093677365)
      {
        switch(v1)
        {
          case 1093677366:
            return 1793;
          case 1094862674:
            return 267;
          case 1111970369:
            return 266;
        }
      }
      else
      {
        switch(v1)
        {
          case 1093677112:
            return 257;
          case 1093677158:
            return 2305;
          case 1093677160:
            return 2049;
        }
      }
      return result;
    }
    if (v1 <= 1278226735)
    {
      if (v1 == 1278226488) {
        return 259;
      }
      if (v1 != 1278226534)
      {
        int v4 = 1278226536;
        goto LABEL_134;
      }
      return 2307;
    }
    if (v1 != 1278226736)
    {
      if (v1 == 1278226738) {
        return 3331;
      }
      if (v1 == 1278226742) {
        return 1795;
      }
      return result;
    }
    return 771;
  }
  if (v1 > 1380410944)
  {
    if (v1 > 1667838255)
    {
      switch(v1)
      {
        case 1667838256:
          return 785;
        case 1667838768:
          return 3079;
        case 1667838822:
          return 2311;
      }
      return result;
    }
    if (v1 == 1380410945) {
      return 2312;
    }
    if (v1 == 1380411457) {
      return 2056;
    }
    int v3 = 1650943796;
    goto LABEL_88;
  }
  if (v1 <= 1279340853)
  {
    if (v1 != 1279340600)
    {
      if (v1 == 1279340646) {
        return 2308;
      }
      if (v1 == 1279340648) {
        return 2052;
      }
      return result;
    }
    return 260;
  }
  switch(v1)
  {
    case 1279340854:
      return 1796;
    case 1279342648:
      return 260;
    case 1380401729:
      return 264;
  }
  return result;
}

uint64_t equivalent_uncompressed_format(uint64_t result)
{
  if ((result & 0xFD000000) == 0x2D000000 || (int)result >> 24 == 124 || (int)result >> 24 == 38)
  {
    int v1 = result & 0xFFFFFF | 0x20000000;
    if (v1 <= 542271552)
    {
      if (v1 <= 540571185)
      {
        if (v1 > 540567087)
        {
          if (v1 > 540567091)
          {
            if (v1 == 540567092) {
              return 875836518;
            }
            if (v1 == 540571184)
            {
              int v2 = 875704422;
              return v2 | 0x10u;
            }
          }
          else
          {
            if (v1 == 540567088) {
              return 875704422;
            }
            if (v1 == 540567090) {
              return 875704934;
            }
          }
          return 0;
        }
        if (v1 == 540160056) {
          return 843264056;
        }
        if (v1 != 540160104)
        {
          if (v1 == 540292208) {
            return 2016687216;
          }
          return 0;
        }
        int v4 = 843264056;
      }
      else
      {
        if (v1 <= 541864039)
        {
          if (v1 > 541214528)
          {
            if (v1 == 541214529) {
              return 1111970369;
            }
            if (v1 == 541863992) {
              return 1278226488;
            }
          }
          else
          {
            if (v1 == 540571186) {
              return 875704950;
            }
            if (v1 == 540571188)
            {
              int v2 = 875836518;
              return v2 | 0x10u;
            }
          }
          return 0;
        }
        if (v1 > 541864241)
        {
          if (v1 == 541864242) {
            return 1278226738;
          }
          if (v1 == 541864246) {
            return 1278226742;
          }
          return 0;
        }
        if (v1 != 541864040)
        {
          if (v1 == 541864240) {
            return 1278226736;
          }
          return 0;
        }
        int v4 = 1278226488;
      }
      return (v4 + 48);
    }
    if (v1 <= 544761391)
    {
      if (v1 > 543712815)
      {
        if (v1 > 544682865)
        {
          if (v1 == 544682866) {
            return 1999843442;
          }
          if (v1 == 544683105) {
            return 1999908961;
          }
        }
        else
        {
          if (v1 == 543712816) {
            return 1751527984;
          }
          if (v1 == 543961458) {
            return 1815162994;
          }
        }
        return 0;
      }
      if (v1 == 542271553) {
        return 1380411457;
      }
      if (v1 == 543306552) {
        return 1647534392;
      }
      if (v1 != 543569008) {
        return 0;
      }
      int v3 = 2016687216;
    }
    else
    {
      if (v1 > 544765489)
      {
        if (v1 > 544830821)
        {
          if (v1 == 544830822) {
            return 2037741158;
          }
          if (v1 == 544830835) {
            return 2037741171;
          }
        }
        else
        {
          if (v1 == 544765490) {
            return 1882468914;
          }
          if (v1 == 544765492) {
            return 1882469428;
          }
        }
        return 0;
      }
      if (v1 > 544761395)
      {
        if (v1 == 544761396) {
          return 1885746228;
        }
        if (v1 == 544765488) {
          return 1882468912;
        }
        return 0;
      }
      if (v1 != 544761392)
      {
        if (v1 == 544761394) {
          return 1885745714;
        }
        return 0;
      }
      int v3 = 1882468912;
    }
    return (v3 + 3276800);
  }
  return result;
}

uint64_t CI::format_with_x_for_format(uint64_t result)
{
  if ((int)result > 783)
  {
    if ((int)result > 2055)
    {
      if (result == 2056)
      {
        return 2060;
      }
      else if (result == 2312)
      {
        return 2316;
      }
    }
    else if (result == 784)
    {
      return 775;
    }
    else if (result == 1800)
    {
      return 1804;
    }
  }
  else
  {
    int v1 = result - 264;
    uint64_t result = 270;
    switch(v1)
    {
      case 0:
        uint64_t result = 268;
        break;
      case 1:
        uint64_t result = 269;
        break;
      case 3:
        uint64_t result = 271;
        break;
      default:
        return result;
    }
  }
  return result;
}

BOOL SurfaceIsRowBytesAligned(__IOSurface *a1, unint64_t a2)
{
  size_t PlaneCount = IOSurfaceGetPlaneCount(a1);
  if (PlaneCount <= 1) {
    unint64_t v5 = 1;
  }
  else {
    unint64_t v5 = PlaneCount;
  }
  unint64_t v6 = 1;
  do
  {
    size_t v7 = IOSurfaceGetBytesPerRowOfPlane(a1, v6 - 1) % a2;
    if (v6 >= v5) {
      break;
    }
    ++v6;
  }
  while (!v7);
  return v7 == 0;
}

void CI::SurfaceNode::surfaceForROI(CI::Context const*,CGRect,CI::Tileable::Stats &)const::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    int v2 = ci_signpost_log_render();
    os_signpost_id_t v3 = *((void *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      int v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)unint64_t v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "surface_for_roi_from_surface", "", v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_193696F70(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::MetalContext::surface_rowbytes_alignment_for_input(uint64_t a1)
{
  return *(void *)(a1 + 424);
}

uint64_t CI::MetalContext::bind_surface(uint64_t *a1, __IOSurface *a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  if (!a2) {
    return 0;
  }
  long long v12 = CI::MetalTextureManager::texture_for_IOSurface(a1[227], a2, a8, a3);
  uint64_t v13 = *(uint64_t (**)(uint64_t *, void *, uint64_t, uint64_t, uint64_t))(*a1 + 88);

  return v13(a1, v12, a5, a6, a7);
}

double CI::Vector::affine@<D0>(CI::Vector *this@<X0>, double *a2@<X8>)
{
  double result = *((float *)this + 7);
  double v3 = *((float *)this + 10);
  double v4 = *((float *)this + 8);
  double v5 = *((float *)this + 11);
  double v6 = *((float *)this + 9);
  double v7 = *((float *)this + 12);
  *a2 = result;
  a2[1] = v3;
  a2[2] = v4;
  a2[3] = v5;
  a2[4] = v6;
  a2[5] = v7;
  return result;
}

double CI::Node::region_of_child(CI::Node *this, CGRect a2)
{
  (*(void (**)(void **__return_ptr, CGPoint, __n128, CGSize, __n128))(*(void *)this + 368))(__p, a2.origin, *(__n128 *)&a2.origin.y, a2.size, *(__n128 *)&a2.size.height);
  CI::CGRectArray::unionRect((CGRect **)__p);
  double v3 = v2;
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v3;
}

double CI::TextureSampler::transform@<D0>(CI::TextureSampler *this@<X0>, const CI::Context *a2@<X1>, const CGRect *a3@<X2>, float64x2_t *a4@<X8>)
{
  if (CGRectIsEmpty(*a3))
  {
    double result = 0.0;
    a4[1] = 0u;
    a4[2] = 0u;
    *a4 = 0u;
  }
  else
  {
    (*(void (**)(const CI::Context *, const CGRect *))(*(void *)a2 + 592))(a2, a3);
    if ((*(unsigned int (**)(void))(**((void **)this + 3) + 16))(*((void *)this + 3)) == 52
      && *(unsigned char *)(*((void *)this + 3) + 148))
    {
      CGFloat MidY = CGRectGetMidY(*a3);
      float64x2_t v10 = a4[1];
      float64x2_t v11 = *a4;
      float64x2_t v12 = vaddq_f64(a4[2], vmlaq_f64(vmulq_n_f64(v10, MidY + MidY), (float64x2_t)0, *a4));
      float64_t v13 = a4->f64[1] + vmuld_lane_f64(0.0, v10, 1);
      a4->f64[0] = a4->f64[0] + 0.0 * v10.f64[0];
      a4->f64[1] = v13;
      a4[1] = vmlaq_f64(vnegq_f64(v10), (float64x2_t)0, v11);
      a4[2] = v12;
    }
    double result = CI::Affine::operator*((double *)this + 5, a4->f64, (double *)v15);
    if (v15 != (_OWORD *)a4)
    {
      float64x2_t v14 = (float64x2_t)v15[1];
      *a4 = (float64x2_t)v15[0];
      a4[1] = v14;
      double result = v16.f64[0];
      a4[2] = v16;
    }
  }
  return result;
}

double CI::Affine::operator*@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v3 = a1[1];
  double v4 = a2[2];
  double v5 = a2[3];
  double v6 = a2[1];
  double v7 = v3 * v4 + *a1 * *a2;
  double result = v3 * v5 + *a1 * v6;
  double v9 = a1[2];
  double v10 = a1[3];
  double v11 = v4 * v10 + v9 * *a2;
  double v12 = v5 * v10 + v9 * v6;
  double v13 = a1[4];
  double v14 = a1[5];
  double v15 = a2[4] + v4 * v14 + v13 * *a2;
  double v16 = v5 * v14 + v13 * v6 + a2[5];
  *a3 = v7;
  a3[1] = result;
  a3[2] = v11;
  a3[3] = v12;
  a3[4] = v15;
  a3[5] = v16;
  return result;
}

double CI::MetalContext::sampler_transform_for_extent@<D0>(const CGRect *a1@<X1>, double *a2@<X8>)
{
  double y = a1->origin.y;
  double v4 = 1.0 / a1->size.height;
  CGFloat v5 = a1->origin.x * -0.0 - y * v4 + 0.0;
  double v6 = 1.0 / a1->size.width;
  double v7 = y * -0.0 - a1->origin.x * v6;
  *a2 = v6 + 0.0;
  a2[1] = v4 * 0.0 + 0.0;
  a2[2] = v6 * 0.0 + 0.0;
  a2[3] = v4 + 0.0;
  double result = v7 + 0.0;
  a2[4] = result;
  a2[5] = v5;
  return result;
}

void CI::ProgramNode::regions_of_child(CI::ProgramNode *this@<X0>, CGRect a2@<0:D0, 8:D1, 16:D2, 24:D3>, uint64_t a3@<X1>, void **a4@<X8>)
{
  CI::ProgramNode::roiKeys_of_child(this, a2, a3, __p);
  CI::roiKeyVec::roi((CI::roiKeyVec *)__p, a4);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void CI::roiKeyVec::roi(CI::roiKeyVec *this@<X0>, void **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *((void *)this + 1);
  if (*(void *)this != v3)
  {
    uint64_t v5 = (uint64_t)(a2 + 2);
    do
    {
      double v6 = CI::Node::roi(*(CI::Node **)v2, *(_DWORD *)(v2 + 8));
      double v10 = v6;
      uint64_t v11 = v7;
      uint64_t v12 = v8;
      uint64_t v13 = v9;
      double v15 = (double *)a2[1];
      double v14 = (double *)a2[2];
      if (v15 >= v14)
      {
        os_signpost_id_t v17 = (double *)*a2;
        uint64_t v18 = ((char *)v15 - (unsigned char *)*a2) >> 5;
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 59) {
          abort();
        }
        uint64_t v20 = (char *)v14 - (char *)v17;
        if (v20 >> 4 > v19) {
          unint64_t v19 = v20 >> 4;
        }
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v21 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21)
        {
          unsigned int v22 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(v5, v21);
          os_signpost_id_t v17 = (double *)*a2;
          double v15 = (double *)a2[1];
        }
        else
        {
          unsigned int v22 = 0;
        }
        uint64_t v23 = &v22[32 * v18];
        *(double *)uint64_t v23 = v10;
        *((void *)v23 + 1) = v11;
        *((void *)v23 + 2) = v12;
        *((void *)v23 + 3) = v13;
        if (v15 == v17)
        {
          uint64_t v26 = &v22[32 * v18];
        }
        else
        {
          unint64_t v24 = &v22[32 * v18];
          do
          {
            long long v25 = *((_OWORD *)v15 - 1);
            uint64_t v26 = v24 - 32;
            *((_OWORD *)v24 - 2) = *((_OWORD *)v15 - 2);
            *((_OWORD *)v24 - 1) = v25;
            v15 -= 4;
            v24 -= 32;
          }
          while (v15 != v17);
        }
        double v16 = v23 + 32;
        *a2 = v26;
        a2[1] = v23 + 32;
        a2[2] = &v22[32 * v21];
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *double v15 = v6;
        *((void *)v15 + 1) = v7;
        double v16 = v15 + 4;
        *((void *)v15 + 2) = v8;
        *((void *)v15 + 3) = v9;
      }
      a2[1] = v16;
      v2 += 16;
    }
    while (v2 != v3);
  }
}

void CI::CGRectArray::unionRect(CGRect **this)
{
  uint64_t v1 = *MEMORY[0x1E4F1DB20];
  uint64_t v2 = *(void *)(MEMORY[0x1E4F1DB20] + 8);
  uint64_t v3 = *(void *)(MEMORY[0x1E4F1DB20] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4F1DB20] + 24);
  uint64_t v5 = *this;
  double v6 = this[1];
  while (v5 != v6)
    *(CGRect *)&uint64_t v1 = CGRectUnion(*(CGRect *)&v1, *v5++);
}

uint64_t CI::KernelArguments::count(CI::KernelArguments *this)
{
  if (*(void *)this) {
    return **(unsigned int **)this;
  }
  else {
    return 0;
  }
}

uint64_t CI::MainProgram::num_arguments(CI::MainProgram *this)
{
  return CI::KernelArguments::count((CI::MainProgram *)((char *)this + 64));
}

void CI::MetalContext::bind_arguments(CI::ProgramNode const*,CGRect const&,CGRect const&,CGSize const&,CI::TileTask *)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v2 = ci_signpost_log_render();
    os_signpost_id_t v3 = *((void *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "bind_arguments", "", v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_193697598(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void *CIMetalBufferCreate(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = (void *)[a2 newBufferWithLength:a3 options:0];
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v4, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  return v4;
}

double CI::Vector::clone(CI::Vector *this, const CI::Vector *a2)
{
  uint64_t v3 = *((int *)a2 + 6);
  *((_DWORD *)this + 6) = v3;
  memcpy((char *)this + 28, (char *)a2 + 28, 4 * v3);
  int v4 = *((_DWORD *)this + 15);
  long long v5 = *(_OWORD *)((char *)this + 44);
  long long v8 = *(_OWORD *)((char *)this + 28);
  long long v9 = v5;
  LODWORD(v10) = v4;
  HIDWORD(v10) = mat3::type((mat3 *)&v8);
  double result = *(double *)&v8;
  long long v7 = v9;
  *((_OWORD *)this + 6) = v8;
  *((_OWORD *)this + 7) = v7;
  *((void *)this + 16) = v10;
  return result;
}

char *CI::SerialRectArray::replace(void *a1, uint64_t a2, int a3, double a4, double a5, double a6, double a7)
{
  CGRect v16 = CGRectStandardize(*(CGRect *)&a4);
  uint64_t v10 = (CGRect *)(*a1 + 120 * a3);
  *uint64_t v10 = v16;
  double result = (char *)&v10[1];
  if (&v10[1] != (CGRect *)a2)
  {
    uint64_t v12 = *(char **)a2;
    uint64_t v13 = *(void *)(a2 + 8);
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v13 - *(void *)a2) >> 4);
    return std::vector<CI::parentROI>::__assign_with_size[abi:nn180100]<CI::parentROI*,CI::parentROI*>(result, v12, v13, v14);
  }
  return result;
}

void sub_193697800(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10F1C40D5E332FALL);
  _Unwind_Resume(a1);
}

void sub_1936978AC(_Unwind_Exception *a1)
{
}

void sub_193697920(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40DBE5A1EELL);
  _Unwind_Resume(a1);
}

__n128 *CI::FillImage::FillImage(__n128 *this)
{
  CI::Image::Image(this);
  v2[13] = &unk_1EE45B2C8;
  atomic_fetch_add(&dword_1EB466E78[7], 1u);
  *uint64_t v2 = &unk_1EE45F178;
  v2[13] = &unk_1EE45F2C8;
  v2[14] = 0;
  XXH64_reset(v5, 0);
  int __src = (*(uint64_t (**)(__n128 *))(this->n128_u64[0] + 16))(this);
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  unint64_t v3 = XXH64_digest((uint64_t)v5);
  this[5].n128_u64[0] = v3;
  this[5].n128_u64[1] = v3;
  this[6].n128_u16[0] = 1;
  return this;
}

uint64_t CI::FillImage::type(CI::FillImage *this)
{
  return 9;
}

void CI::MetalDAG::compile(uint64_t a1, int a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 128));
  if (CI_VERBOSE_SIGNPOSTS())
  {
    int v4 = ci_signpost_log_compile();
    os_signpost_id_t v5 = a2 | ((unint64_t)*(unsigned int *)(a1 + 40) << 32);
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      double v6 = v4;
      if (os_signpost_enabled(v4))
      {
        *(_WORD *)double v15 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v5, "compile_metal_dag", "", v15, 2u);
      }
    }
  }
  TimerBase::TimerBase((uint64_t)v15, *(unsigned int *)(a1 + 40), a2, (uint64_t)"compile_metal_dag", 26);
  v7.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v8 = *(void *)(a1 + 16);
  if (CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE() == 1 && !*(unsigned char *)(*(void *)(a1 + 184) + 8)
    || CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE() == 2 && *(unsigned char *)(*(void *)(a1 + 184) + 8)
    || CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE() == 3 && !*(unsigned char *)(*(void *)(a1 + 184) + 9)
    || CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE() == 4 && *(unsigned char *)(*(void *)(a1 + 184) + 9))
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 184);
  uint64_t v10 = *(void *)(a1 + 136);
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = *(void *)(a1 + 200);
  uint64_t v13 = *(void *)(a1 + 152);
  if (*(unsigned char *)(a1 + 144)) {
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v9 + 72))(v9, v10, v11, v12, v13, v8, *(unsigned int *)(a1 + 148));
  }
  else {
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v9 + 80))(v9, v10, v11, v12, v13, v8);
  }
  *(void *)(a1 + 160) = v14;
  *(double *)(a1 + 24) = (double)(std::chrono::steady_clock::now().__d_.__rep_ - v7.__d_.__rep_) / 1000000000.0;
  CI::MetalDAG::compile(CI::NodeIndex)::SignpostTimer::~SignpostTimer((TimerBase *)v15);
}

void sub_193697C0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE()
{
  {
    CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE::v = get_int("CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE", 0);
  }
  return CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE::v;
}

void sub_193697C88(_Unwind_Exception *a1)
{
}

void CI::MetalDAG::compile(CI::NodeIndex)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v2 = ci_signpost_log_compile();
    os_signpost_id_t v3 = *((void *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      int v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)os_signpost_id_t v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "compile_metal_dag", "", v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_193697D34(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::StitchableFunctionDAGDescriptor::compile(uint64_t a1, uint64_t a2, char *a3, CI::CoreImageDylib *a4, void *a5, uint64_t a6)
{
  dag_descriptor = CI::StitchableFunctionDAGDescriptor::create_dag_descriptor((CI::StitchableFunctionDAGDescriptor *)a1, a3);
  if (*(unsigned char *)(a1 + 25)) {
    uint64_t v13 = CI::CoreImageDylib::get(a4);
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = *(NSObject ***)(a1 + 32);
  if (!v14)
  {
    uint64_t v18 = 0;
    *(unsigned char *)(a1 + 24) = 0;
LABEL_11:
    uint64_t ComputePipelineState = CIMetalComputePipelineStateCreateFromDagDescriptor(a2, (uint64_t)a3, a5, dag_descriptor, v18, v13, a6);
    goto LABEL_12;
  }
  double v15 = (void *)CI::KernelArchive::find(v14, a6, a3);
  *(unsigned char *)(a1 + 24) = v15 != 0;
  if (!v15)
  {
    uint64_t v19 = *(void *)(a1 + 32);
    if (v19) {
      uint64_t v18 = *(void **)(v19 + 80);
    }
    else {
      uint64_t v18 = 0;
    }
    goto LABEL_11;
  }
  uint64_t ComputePipelineState = CreateComputePipelineState(a5, v15, v16, v13);
LABEL_12:
  uint64_t v20 = ComputePipelineState;

  return v20;
}

void *CI::StitchableFunctionDAGDescriptor::create_dag_descriptor(CI::StitchableFunctionDAGDescriptor *this, const char *a2)
{
  int v4 = CI_HARVEST_BIN_ARCHIVE();
  id v5 = objc_alloc(MEMORY[0x1E4F35268]);
  if (v4 == 2) {
    uint64_t v6 = *((void *)this + 17);
  }
  else {
    uint64_t v6 = [NSString stringWithUTF8String:a2];
  }
  std::chrono::steady_clock::time_point v7 = (void *)[v5 initWithFunctionName:v6 nodes:*((void *)this + 9) outputNode:0 attributes:MEMORY[0x1E4F1CBF0]];
  uint64_t v8 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1C978]), "initWithObjects:", v7, 0);

  uint64_t v9 = objc_opt_new();
  [v9 setFunctionGraphs:v8];

  [v9 setFunctions:*((void *)this + 16)];
  uint64_t v10 = *((void *)this + 4);
  if (v10) {
    uint64_t v11 = *(void *)(v10 + 80);
  }
  else {
    uint64_t v11 = 0;
  }
  [v9 setBinaryArchives:v11];
  return v9;
}

uint64_t CI::KernelArchive::find(NSObject **this, uint64_t a2, const char *a3)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = 0;
  double v15 = &v14;
  uint64_t v16 = 0x3052000000;
  os_signpost_id_t v17 = __Block_byref_object_copy__241;
  uint64_t v18 = __Block_byref_object_dispose__242;
  uint64_t v19 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x3052000000;
  uint64_t v11 = __Block_byref_object_copy__241;
  uint64_t v12 = __Block_byref_object_dispose__242;
  uint64_t v13 = 0;
  os_signpost_id_t v3 = *this;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN2CI13KernelArchive4findEyPKc_block_invoke;
  block[3] = &unk_1E5774F38;
  void block[6] = this;
  void block[7] = a2;
  void block[4] = &v14;
  block[5] = &v8;
  block[8] = a3;
  dispatch_sync(v3, block);
  int v4 = v15;
  if (v9[5])
  {
    v20[0] = v9[5];
    [MEMORY[0x1E4F1C978] arrayWithObjects:v20 count:1];
  }
  uint64_t v5 = v4[5];
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v14, 8);
  return v5;
}

void sub_1936980B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t CIMetalComputePipelineStateCreateFromDagDescriptor(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7)
{
  v39[1] = *MEMORY[0x1E4F143B8];
  [a4 setBinaryArchives:a5];
  uint64_t StitchedFunctionFromDescriptor = CreateStitchedFunctionFromDescriptor(a1, a2, a3, a4, a7);
  if (!StitchedFunctionFromDescriptor) {
    return 0;
  }
  double v15 = (void *)StitchedFunctionFromDescriptor;
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v15, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  if (CI_HARVEST_BIN_ARCHIVE() != 1) {
    goto LABEL_14;
  }
  uint64_t v16 = CI_HARVEST_PROCESS_NAME_LIST();
  if (!v16) {
    goto LABEL_9;
  }
  blocuint64_t k = MEMORY[0x1E4F143A8];
  uint64_t v30 = 3221225472;
  unint64_t v31 = __isHarvestingForThisProcess_block_invoke;
  unsigned int v32 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v33 = (uint64_t)v16;
  if (isHarvestingForThisProcess_onceToken != -1) {
    dispatch_once(&isHarvestingForThisProcess_onceToken, &block);
  }
  if (isHarvestingForThisProcess_isListed)
  {
LABEL_9:
    uint64_t v28 = 0;
    os_signpost_id_t v17 = objc_opt_new();
    [v17 setComputeFunction:v15];
    [v17 setBinaryArchives:a5];
    if (a6)
    {
      v39[0] = a6;
      objc_msgSend(v17, "setPreloadedLibraries:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v39, 1));
    }
    if ([a5 count]
      && (uint64_t v18 = [a3 newComputePipelineStateWithDescriptor:v17 options:4 reflection:0 error:&v28]) != 0)
    {
      uint64_t ComputePipelineState = v18;
    }
    else
    {
      [v17 setBinaryArchives:0];
      uint64_t v21 = [NSString stringWithUTF8String:a2];
      if (a7)
      {
        uint64_t v22 = v21;
        uint64_t v23 = (void *)CIGetHarvestingBinaryArchiveDict((uint64_t)a3);
        uint64_t v24 = [v23 objectForKeyedSubscript:@"bin"];
        long long v25 = [v23 objectForKeyedSubscript:@"queue"];
        uint64_t v26 = [v23 objectForKeyedSubscript:@"path"];
        blocuint64_t k = MEMORY[0x1E4F143A8];
        uint64_t v30 = 3221225472;
        unint64_t v31 = __ArchiveLibraryUsingStitchedDagDescriptor_block_invoke;
        unsigned int v32 = &unk_1E5772700;
        uint64_t v33 = v22;
        uint64_t v34 = v24;
        uint64_t v35 = a4;
        double v36 = v17;
        uint64_t v37 = v26;
        uint64_t v38 = a7;
        dispatch_sync(v25, &block);
      }
      uint64_t ComputePipelineState = [a3 newComputePipelineStateWithDescriptor:v17 options:0 reflection:0 error:&v28];

      if (!ComputePipelineState)
      {
        uint64_t v27 = ci_logger_compile();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
          CreateComputePipelineState_cold_1();
        }
        uint64_t ComputePipelineState = 0;
      }
    }
  }
  else
  {
LABEL_14:
    uint64_t ComputePipelineState = CreateComputePipelineState(a3, v15, a5, a6);
  }

  if (!ComputePipelineState) {
    print_stitched_dag(a3, a4);
  }
  return ComputePipelineState;
}

uint64_t CreateStitchedFunctionFromDescriptor(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v17 = 0;
  if ((CI_LOG_BIN_ARCHIVE_MISS() & 2) != 0)
  {
    [a4 setOptions:1];
    uint64_t v10 = (void *)[a3 newLibraryWithDescriptor:a4 error:&v17];
    [a4 setOptions:0];
    if (v10) {
      goto LABEL_6;
    }
    uint64_t v11 = ci_logger_compile();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      CreateStitchedFunctionFromDescriptor_cold_3();
    }
  }
  uint64_t v10 = (void *)[a3 newLibraryWithDescriptor:a4 error:&v17];
LABEL_6:
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v10, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  if (!v10)
  {
    uint64_t v13 = ci_logger_compile();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      CreateFunctionFromSource_cold_1();
    }
    goto LABEL_17;
  }
  if (CI_HARVEST_BIN_ARCHIVE() == 2) {
    uint64_t v12 = @"ciKernelMain";
  }
  else {
    uint64_t v12 = (__CFString *)[NSString stringWithUTF8String:a2];
  }
  uint64_t v14 = [v10 newFunctionWithName:v12];
  ArchiveLibrary(v10, a5, a2);

  if (!v14)
  {
    double v15 = ci_logger_compile();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      CreateStitchedFunctionFromDescriptor_cold_2();
    }
LABEL_17:
    print_stitched_dag(a3, a4);
    return 0;
  }
  return v14;
}

uint64_t CI_LOG_BIN_ARCHIVE_MISS()
{
  {
    CI_LOG_BIN_ARCHIVE_MISS::v = get_int("CI_LOG_BIN_ARCHIVE_MISS", 0);
  }
  return CI_LOG_BIN_ARCHIVE_MISS::v;
}

void sub_193698608(_Unwind_Exception *a1)
{
}

uint64_t CreateComputePipelineState(void *a1, void *a2, void *a3, uint64_t a4)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  uint64_t v15 = 0;
  uint64_t v8 = objc_opt_new();
  [v8 setComputeFunction:a2];
  if (a4)
  {
    v16[0] = a4;
    objc_msgSend(v8, "setPreloadedLibraries:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v16, 1));
  }
  if (a3) {
    [v8 setBinaryArchives:a3];
  }
  if ((CI_LOG_BIN_ARCHIVE_MISS() & 1) == 0)
  {
LABEL_14:
    uint64_t v10 = [a1 newComputePipelineStateWithDescriptor:v8 options:0 reflection:0 error:&v15];

    if (v10) {
      return v10;
    }
    uint64_t v13 = ci_logger_compile();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      CreateComputePipelineState_cold_1();
    }
    return 0;
  }
  if (![a3 count])
  {
    uint64_t v11 = ci_logger_compile();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      CreateComputePipelineState_cold_2(a2, v11);
    }
    goto LABEL_14;
  }
  uint64_t v9 = [a1 newComputePipelineStateWithDescriptor:v8 options:4 reflection:0 error:&v15];
  if (!v9)
  {
    uint64_t v12 = ci_logger_compile();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      CreateComputePipelineState_cold_3(a2, v12);
    }
    goto LABEL_14;
  }
  uint64_t v10 = v9;

  return v10;
}

void ArchiveLibrary(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v6 = CI_HARVEST_BIN_ARCHIVE();
  if (a2 && v6 == 2)
  {
    std::chrono::steady_clock::time_point v7 = (void *)[MEMORY[0x1E4F28CB8] defaultManager];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __ArchiveLibrary_block_invoke;
    block[3] = &unk_1E5771BE8;
    void block[4] = v7;
    if (ArchiveLibrary_onceToken != -1) {
      dispatch_once(&ArchiveLibrary_onceToken, block);
    }
    uint64_t v8 = (void *)[v7 temporaryDirectory];
    uint64_t v9 = [v8 URLByAppendingPathComponent:objc_msgSend(NSString, "stringWithFormat:", @"%s/ci_%016llX.metallib", CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME(), a2)];
    uint64_t v21 = 0;
    int v10 = CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE();
    uint64_t v11 = (void *)[v7 temporaryDirectory];
    uint64_t v12 = NSString;
    uint64_t v13 = CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME();
    if (v10) {
      uint64_t v14 = [v12 stringWithFormat:@"%s/ci_%016llX_%@.txt", v13, a2, objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28F80], "processInfo"), "processName")];
    }
    else {
      uint64_t v14 = objc_msgSend(v12, "stringWithFormat:", @"%s/ci_%016llX.txt", v13, a2, v20);
    }
    uint64_t v15 = objc_msgSend((id)objc_msgSend(v11, "URLByAppendingPathComponent:", v14), "path");
    if (([v7 createFileAtPath:v15, objc_msgSend((id)objc_msgSend(NSString, "stringWithFormat:", @"0x%016llX %s\n", a2, a3), "dataUsingEncoding:", 4), 0 contents attributes] & 1) == 0)
    {
      uint64_t v16 = ci_logger_render();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        ArchiveLibrary_cold_2();
      }
    }
    [a1 serializeToURL:v9 error:&v21];
    uint64_t v17 = v21;
    uint64_t v18 = ci_logger_render();
    uint64_t v19 = v18;
    if (v17)
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        ArchiveLibrary_cold_1();
      }
    }
    else if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)CGRect buf = 138543618;
      uint64_t v24 = v9;
      __int16 v25 = 2082;
      uint64_t v26 = a3;
      _os_log_impl(&dword_193671000, v19, OS_LOG_TYPE_INFO, "CI library serialized to : %{public}@ for %{public}s", buf, 0x16u);
    }
  }
}

uint64_t CI_HARVEST_BIN_ARCHIVE()
{
  {
    CI_HARVEST_BIN_ARCHIVE::v = get_int("CI_HARVEST_BIN_ARCHIVE", 0);
  }
  return CI_HARVEST_BIN_ARCHIVE::v;
}

void sub_193698ABC(_Unwind_Exception *a1)
{
}

uint64_t CI::MetalContext::render_node(CI::MetalContext *this, CI::TileTask *a2, const CI::parentROI *a3, const CGRect *a4, void **a5, __IOSurface **a6, uint64_t a7)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *(void *)a3;
  double v15 = CI::parentROI::roi(a3);
  v68.origin.CGFloat x = v15;
  v68.origin.double y = v16;
  v68.size.CGFloat width = v17;
  v68.size.CGFloat height = v18;
  if (!v14) {
    return 0;
  }
  CGFloat v19 = v15;
  CGFloat v20 = v16;
  CGFloat v21 = v17;
  CGFloat v22 = v18;
  bzero((char *)this + 1232, 0x100uLL);
  bzero((char *)this + 1488, 0x100uLL);
  *((void *)this + 218) = 0;
  uint64_t v23 = *(void *)(v14 + 48);
  if ((*(int (**)(uint64_t))(*(void *)v23 + 16))(v23) >= 41
    && (*(int (**)(uint64_t))(*(void *)v23 + 16))(v23) <= 42)
  {
    uint64_t v24 = *(int **)(v14 + 48);
    if (!*((unsigned char *)v24 + 153)
      || (*(int (**)(int *))(*(void *)v24 + 40))(v24) < 1
      || !*((void *)this + 225))
    {
LABEL_41:
      uint64_t v61 = [*a5 iosurface];
      CGRect v63 = (__IOSurface *)v61;
      if (a6 && !v61) {
        CGRect v63 = *a6;
      }
      if (v63)
      {
        v67[0] = *a5;
        v67[1] = 0;
        v62.var0.var0 = (unint64_t)v67;
        return CI::Context::render_processor_node(this, a2, a3, v63, v62);
      }
      return 0;
    }
    if (CI_VERBOSE_SIGNPOSTS())
    {
      __int16 v25 = ci_signpost_log_render();
      os_signpost_id_t v26 = v24[9] | (unint64_t)((*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this) << 32);
      if (v26 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v25))
      {
        uint64_t v27 = (*(uint64_t (**)(int *))(*(void *)v24 + 24))(v24);
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v27;
        _os_signpost_emit_with_name_impl(&dword_193671000, v25, OS_SIGNPOST_INTERVAL_BEGIN, v26, "processor_syncinputs", "%{public}@", (uint8_t *)&buf, 0xCu);
      }
    }
    uint64_t v59 = (*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this);
    TimerBase::TimerBase((uint64_t)&buf, v59, v24[9], (uint64_t)"processor_syncinputs", 0);
    CGRect v60 = (void *)*((void *)this + 225);
    if (v60 != *((void **)this + 226))
    {
      CIMetalCommandBufferWaitUntilCompleted(v60);
      CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)&buf);
      goto LABEL_41;
    }
    CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)&buf);
    return 0;
  }
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v28 = ci_signpost_log_render();
    os_signpost_id_t v29 = *(int *)(v14 + 36) | (unint64_t)((*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this) << 32);
    if (v29 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v28))
    {
      LOWORD(buf) = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v28, OS_SIGNPOST_INTERVAL_BEGIN, v29, "render_node_mainProgram", "", (uint8_t *)&buf, 2u);
    }
  }
  uint64_t v30 = (*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this);
  TimerBase::TimerBase((uint64_t)&buf, v30, *(_DWORD *)(v14 + 36), (uint64_t)"render_node_mainProgram", 0);
  dispatch_queue_t v31 = CI::ProgramNode::mainProgram((dispatch_queue_t *)v14);
  double v33 = v32;
  if ((*((int (**)(dispatch_queue_t))v31->isa + 2))(v31) < 67
    || (*((int (**)(dispatch_queue_t))v31->isa + 2))(v31) >= 70)
  {
    CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)&buf);
    return 0;
  }
  CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)&buf);
  v75.origin.CGFloat x = v19;
  v75.origin.double y = v20;
  v75.size.CGFloat width = v21;
  v75.size.CGFloat height = v22;
  CGRect v76 = CGRectIntersection(v75, *a4);
  v66.size.CGFloat width = v76.size.width;
  v66.size.CGFloat height = v76.size.height;
  CGFloat height = v76.size.height;
  CGSize v65 = (CGSize)vrndpq_f64(vdivq_f64((float64x2_t)v76.size, vcvtq_f64_u64(*(uint64x2_t *)&v31[10].isa)));
  if (*(unsigned char *)(v14 + 148))
  {
    CGFloat MidY = CGRectGetMidY(*a4);
    v64.b = 0.0;
    v64.c = 0.0;
    v64.a = 1.0;
    *(_OWORD *)&v64.d = xmmword_193951E50;
    v64.tdouble y = MidY + MidY;
    v77.origin.CGFloat x = v19;
    v77.origin.double y = v20;
    v77.size.CGFloat width = v21;
    v77.size.CGFloat height = v22;
    CGRect v78 = CGRectApplyAffineTransform(v77, &v64);
    CGRect v76 = CGRectIntersection(v78, *a4);
    v66.size.CGFloat width = v36;
    v66.size.CGFloat height = -v37;
  }
  CGFloat v38 = v76.origin.y - a4->origin.y;
  v66.origin.CGFloat x = v76.origin.x - a4->origin.x;
  v66.origin.double y = v38;
  CI::MetalContext::bind_arguments(this, (const CI::ProgramNode *)v14, &v68, &v66, (float64x2_t *)&v65, a2);
  if (CI_LIMIT_RENDER())
  {
    __asm { FMOV            V0.2D, #1.0 }
    CGSize v65 = _Q0;
  }
  uint64_t v44 = *(void *)(v14 + 48);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v44 + 16))(v44) == 51)
  {
    unsigned int v45 = *(_DWORD *)(v44 + 144);
    unint64_t v46 = *(void *)(v44 + 148);
    unsigned int v47 = *(_DWORD *)(v44 + 156);
    unint64_t v48 = *(void *)(v44 + 136) & 0xFFFFFFFF00000000;
    uint64_t v49 = *(void *)(v44 + 136);
  }
  else
  {
    uint64_t v52 = *(void *)(v14 + 48);
    if (!v52) {
      goto LABEL_29;
    }
    while (1)
    {
      int v53 = (*(uint64_t (**)(uint64_t))(*(void *)v52 + 16))(v52);
      uint64_t v54 = *(void *)v52;
      if (v53 == 47) {
        break;
      }
      uint64_t v52 = (*(uint64_t (**)(uint64_t, void))(v54 + 48))(v52, 0);
      if (!v52) {
        goto LABEL_29;
      }
    }
    if ((*(unsigned int (**)(uint64_t))(v54 + 408))(v52) == 58
      || (*(unsigned int (**)(uint64_t))(*(void *)v52 + 408))(v52) == 56
      || (*(unsigned int (**)(uint64_t))(*(void *)v52 + 408))(v52) == 59
      || (*(unsigned int (**)(uint64_t))(*(void *)v52 + 408))(v52) == 57)
    {
      int v55 = *(_DWORD *)(v14 + 36);
      isa = v31[16].isa;
      *(void *)&long long buf = MEMORY[0x1E4F143A8];
      *((void *)&buf + 1) = 3221225472;
      CGRect v70 = ___ZNK2CI16MetalMainProgram16getPipelineStateENS_9NodeIndexE_block_invoke;
      CGRect v71 = &__block_descriptor_44_e5_v8__0l;
      dispatch_queue_t v72 = v31;
      int v73 = v55;
      dispatch_sync(isa, &buf);
      Class v57 = v31[20].isa;
      if (([(objc_class *)v57 threadExecutionWidth] & 0xF) == 0) {
        [(objc_class *)v57 threadExecutionWidth];
      }
      unsigned int v45 = 0;
      unint64_t v46 = 0;
      unsigned int v47 = 0;
      unint64_t v48 = 0x1000000000;
      uint64_t v49 = 16;
    }
    else
    {
LABEL_29:
      uint64_t v49 = 0;
      unint64_t v48 = 0;
      unsigned int v45 = 0;
      unint64_t v46 = 0;
      unsigned int v47 = 0;
    }
  }
  uint64_t v50 = CI::MetalContext::compute_quad((uint64_t)this, *(_DWORD *)(v14 + 36), (uint64_t)v31, &v65.width, a5, a7, v48 | v49, v45, v46, v47);
  CI::TileTask::incrementCompileWaitTimeForNode(a2, (const CI::ProgramNode *)v14, v33);
  CI::TileTask::setCompileTimeForNode(a2, (const CI::ProgramNode *)v14, *(double *)&v31[3].isa + *(double *)&v31[4].isa);
  CGRect v58 = (const void *)*((void *)this + 223);
  if (v58)
  {
    CFRelease(v58);
    *((void *)this + 223) = 0;
  }
  return v50;
}

void sub_1936992DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t CI::SwizzleNode::convert_to_kernel_node(CI::SwizzleNode *this, CI::Context *a2)
{
  os_signpost_id_t v3 = CI::Kernel::builtin(*((_DWORD *)this + 14));
  if (v3 && ((unsigned int (*)(void))(*v3)[2])(v3) != 64)
  {
    if ((*(unsigned int (**)(CI::SwizzleNode *))(*(void *)this + 408))(this) == 56) {
      goto LABEL_5;
    }
    if ((*(unsigned int (**)(CI::SwizzleNode *))(*(void *)this + 408))(this) != 57)
    {
      if ((*(unsigned int (**)(CI::SwizzleNode *))(*(void *)this + 408))(this) == 58) {
LABEL_5:
      }
        operator new();
      if ((*(unsigned int (**)(CI::SwizzleNode *))(*(void *)this + 408))(this) != 59) {
        operator new();
      }
    }
    operator new();
  }
  return 0;
}

uint64_t CI::SwizzleNode::swizzletype(CI::SwizzleNode *this)
{
  return *((unsigned int *)this + 14);
}

void (***CI::Kernel::builtin(int a1))(CI::ColorKernel *__hidden this)
{
  if ((a1 - 1) < 0x58) {
    return off_1E5775140[a1 - 1];
  }
  os_signpost_id_t v3 = ci_logger_render();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
    CI::Kernel::builtin(a1, v3);
  }
  return 0;
}

dispatch_queue_t CI::ProgramNode::mainProgram(dispatch_queue_t *this)
{
  return this[15];
}

CI::SerialObjectPtrArray *CI::SerialObjectPtrArray::SerialObjectPtrArray(CI::SerialObjectPtrArray *this, CI::Object *a2, CI::Object *a3)
{
  *(void *)this = 0;
  *((_OWORD *)this + 2) = 0u;
  uint64_t v5 = (void *)((char *)this + 32);
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  *(void *)((char *)this + 4) = 0x20000000ALL;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = a2;
  if (a2) {
    CI::Object::ref((uint64_t)a2);
  }
  *uint64_t v5 = a3;
  if (a3) {
    CI::Object::ref((uint64_t)a3);
  }
  *(_DWORD *)this = 2;
  return this;
}

void CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v2 = ci_signpost_log_render();
    os_signpost_id_t v3 = *((void *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      int v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "render_node_mainProgram", "", v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v2 = ci_signpost_log_render();
    os_signpost_id_t v3 = *((void *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      int v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "processor_syncinputs", "", v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_193699774(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::MetalContext::compute_quad(uint64_t a1, int a2, uint64_t a3, double *a4, void **a5, uint64_t a6, unint64_t a7, unsigned int a8, unint64_t a9, unsigned int a10)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    CGFloat v17 = ci_signpost_log_render();
    os_signpost_id_t v18 = a2 | (unint64_t)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1) << 32);
    if (v18 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v17, OS_SIGNPOST_INTERVAL_BEGIN, v18, "compute_quad", "", buf, 2u);
    }
  }
  uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)buf, v19, a2, (uint64_t)"compute_quad", 14);
  if (CI_NO_RENDER()) {
    goto LABEL_6;
  }
  CGFloat v21 = *(NSObject **)(a3 + 128);
  blocuint64_t k = MEMORY[0x1E4F143A8];
  uint64_t v42 = 3221225472;
  uint64_t v43 = ___ZNK2CI16MetalMainProgram16getPipelineStateENS_9NodeIndexE_block_invoke;
  uint64_t v44 = &__block_descriptor_44_e5_v8__0l;
  uint64_t v45 = a3;
  int v46 = a2;
  dispatch_sync(v21, &block);
  CGFloat v22 = *(void **)(a3 + 160);
  if (!v22 || !*(void *)(a1 + 1784) || !*a5)
  {
LABEL_17:
    uint64_t v20 = 0;
    goto LABEL_18;
  }
  uint64_t v23 = *(void *)(a1 + 1744);
  if (v23)
  {
    uint64_t v24 = (void *)(a1 + 1488);
    while (*(v24 - 32) && *v24)
    {
      ++v24;
      if (!--v23) {
        goto LABEL_15;
      }
    }
    goto LABEL_17;
  }
LABEL_15:
  if (*(unsigned char *)(a3 + 144))
  {
    int v25 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1);
    CIMetalRenderToImageblocks(v25, a2, *(void **)(a1 + 1792), v22, *(void *)(a1 + 1784), *a4, a4[1], a6, a5, *(void *)(a1 + 1744), a1 + 1232, a1 + 1488, *(void *)(a3 + 48));
  }
  else
  {
    blocuint64_t k = a9;
    uint64_t v42 = HIDWORD(a9);
    uint64_t v43 = (uint64_t (*)(uint64_t))a10;
    int v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1);
    uint64_t v28 = *(void **)(a1 + 1792);
    uint64_t v29 = *(void *)(a1 + 1784);
    double v30 = *a4;
    double v31 = a4[1];
    uint64_t v32 = *(void *)(a1 + 1744);
    uint64_t v33 = *(void *)(a3 + 48);
    v39[0] = a7;
    v39[1] = HIDWORD(a7);
    if (a9) {
      BOOL v34 = HIDWORD(a9) == 0;
    }
    else {
      BOOL v34 = 1;
    }
    BOOL v35 = v34 || a10 == 0;
    p_blocuint64_t k = (unint64_t *)&block;
    if (v35) {
      p_blocuint64_t k = 0;
    }
    void v39[2] = a8;
    CIMetalRenderToTextures(v27, a2, v28, v22, v29, a6, (uint64_t)a5, v32, v30, v31, a1 + 1232, a1 + 1488, v33, v39, p_block);
  }
  if (*(void *)(a1 + 1744))
  {
    unint64_t v37 = 0;
    do
      CFRelease(*(CFTypeRef *)(a1 + 1232 + 8 * v37++));
    while (v37 < *(void *)(a1 + 1744));
  }
LABEL_6:
  uint64_t v20 = 1;
LABEL_18:
  CI::MetalContext::compute_quad(CI::NodeIndex,CI::MetalMainProgram const*,CGSize const&,void const**,unsigned long,CI::Dimensions,CI::Dimensions)::SignpostTimer::~SignpostTimer((TimerBase *)buf);
  return v20;
}

void sub_193699AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  CI::MetalContext::compute_quad(CI::NodeIndex,CI::MetalMainProgram const*,CGSize const&,void const**,unsigned long,CI::Dimensions,CI::Dimensions)::SignpostTimer::~SignpostTimer((TimerBase *)va);
  _Unwind_Resume(a1);
}

uint64_t CI_NO_RENDER()
{
  {
    CI_NO_RENDER::v = get_BOOL("CI_NO_RENDER", 0);
  }
  return CI_NO_RENDER::v;
}

void sub_193699B6C(_Unwind_Exception *a1)
{
}

uint64_t CI_LIMIT_RENDER()
{
  {
    CI_LIMIT_RENDER::v = get_int("CI_LIMIT_RENDER", 0);
  }
  return CI_LIMIT_RENDER::v;
}

void sub_193699BEC(_Unwind_Exception *a1)
{
}

uint64_t CIMetalRenderToTextures(uint64_t a1, int a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11, uint64_t a12, uint64_t a13, unint64_t *a14, unint64_t *a15)
{
  CGFloat v22 = objc_opt_new();
  uint64_t v23 = objc_opt_new();
  unint64_t v24 = [a4 maxTotalThreadsPerThreadgroup];
  if (v24 >= 0x100) {
    unint64_t v25 = 256;
  }
  else {
    unint64_t v25 = v24;
  }
  uint64_t v26 = [a4 threadExecutionWidth];
  uint64_t v27 = 32;
  if (v26) {
    uint64_t v27 = v26;
  }
  unint64_t v28 = a14[1];
  if (*a14) {
    unint64_t v29 = *a14;
  }
  else {
    unint64_t v29 = v27;
  }
  if (!v28) {
    unint64_t v28 = v25 / v29;
  }
  if (a14[2] <= 1) {
    uint64_t v30 = 1;
  }
  else {
    uint64_t v30 = a14[2];
  }
  unint64_t v31 = (unint64_t)((a9 + (double)(v29 - 1)) / (double)v29);
  unint64_t v32 = (unint64_t)((a10 + (double)(v28 - 1)) / (double)v28);
  unint64_t v48 = v28;
  unint64_t v49 = v29;
  uint64_t v47 = v30;
  if (a15 && *a15 && a15[1] && a15[2])
  {
    uint64_t v44 = a15[2];
    unint64_t v31 = *a15;
    unint64_t v32 = a15[1];
  }
  else
  {
    uint64_t v44 = 1;
  }
  uint64_t v33 = [a3 label];
  if (a13
    && v33
    && objc_msgSend((id)objc_msgSend(a3, "label"), "isEqualToString:", @"com.apple.CoreImage"))
  {
    [a3 setLabel:objc_msgSend(NSString, "stringWithFormat:", @"%@.%s", objc_msgSend(a3, "label"), a13)];
  }
  if (isImageConversionServiceProcess_onceToken != -1) {
    dispatch_once(&isImageConversionServiceProcess_onceToken, &__block_literal_global_48);
  }
  int v34 = isImageConversionServiceProcess_isICS;
  if (useOneDispatchPerCommandBuffer_onceToken != -1) {
    dispatch_once(&useOneDispatchPerCommandBuffer_onceToken, &__block_literal_global_156);
  }
  if (useOneDispatchPerCommandBuffer_setOverride == 1)
  {
    if (!useOneDispatchPerCommandBuffer_result)
    {
      char v45 = 0;
      goto LABEL_35;
    }
    goto LABEL_33;
  }
  if (v34 && useOneDispatchPerCommandBuffer_result)
  {
LABEL_33:
    uint64_t v35 = [a3 label];
    a3 = objc_msgSend((id)objc_msgSend(a3, "commandQueue"), "commandBuffer");
    [a3 setLabel:v35];
    char v45 = 1;
    goto LABEL_35;
  }
  char v45 = 0;
LABEL_35:
  unint64_t v46 = v31;
  CGFloat v36 = (void *)[a3 computeCommandEncoder];
  if (a13) {
    objc_msgSend(v36, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:"));
  }
  [v36 setComputePipelineState:a4];
  [v22 addObject:a4];
  if (a6)
  {
    uint64_t v37 = 0;
    do
    {
      CGFloat v38 = *(void **)(a7 + 8 * v37);
      if (v38)
      {
        if (![*(id *)(a7 + 8 * v37) iosurfacePlane])
        {
          [v38 width];
          [v38 height];
        }
        if (v37) {
          uint64_t v39 = a8 + v37;
        }
        else {
          uint64_t v39 = 0;
        }
        [v36 setTexture:v38 atIndex:v39];
        [v22 addObject:v38];
      }
      ++v37;
    }
    while (a6 != v37);
  }
  if (a8)
  {
    uint64_t v40 = 0;
    do
    {
      uint64_t v41 = *(void *)(a11 + 8 * v40);
      [v36 setTexture:v41 atIndex:v40 + 1];
      [v23 addObject:v41];
      uint64_t v42 = *(void *)(a12 + 8 * v40);
      [v36 setSamplerState:v42 atIndex:v40];
      [v22 addObject:v42];
      ++v40;
    }
    while (a8 != v40);
  }
  [v36 setBuffer:a5 offset:0 atIndex:0];
  [v22 addObject:a5];
  v58[0] = v46;
  v58[1] = v32;
  v58[2] = v44;
  v57[0] = v49;
  v57[1] = v48;
  v57[2] = v47;
  [v36 dispatchThreadgroups:v58 threadsPerThreadgroup:v57];
  [v36 endEncoding];
  v55[0] = MEMORY[0x1E4F143A8];
  v55[1] = 3221225472;
  v55[2] = __CIMetalRenderToTextures_block_invoke;
  v55[3] = &__block_descriptor_60_e28_v16__0___MTLCommandBuffer__8l;
  *(double *)&v55[4] = a9;
  *(double *)&v55[5] = a10;
  v55[6] = a1;
  int v56 = a2;
  [a3 addScheduledHandler:v55];
  v53[0] = MEMORY[0x1E4F143A8];
  v53[1] = 3221225472;
  v53[2] = __CIMetalRenderToTextures_block_invoke_83;
  v53[3] = &unk_1E5772688;
  *(double *)&v53[6] = a9;
  *(double *)&v53[7] = a10;
  v53[8] = a1;
  int v54 = a2;
  v53[4] = v23;
  v53[5] = v22;
  uint64_t result = [a3 addCompletedHandler:v53];
  if (v45)
  {
    [a3 commit];
    return [a3 waitUntilScheduled];
  }
  return result;
}

void CI::MetalContext::compute_quad(CI::NodeIndex,CI::MetalMainProgram const*,CGSize const&,void const**,unsigned long,CI::Dimensions,CI::Dimensions)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v2 = ci_signpost_log_render();
    os_signpost_id_t v3 = *((void *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      int v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "compute_quad", "", v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_19369A148(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void CI::TileTask::incrementCompileWaitTimeForNode(CI::TileTask *this, const CI::ProgramNode *a2, double a3)
{
  if (a3 != 0.0)
  {
    void block[7] = v3;
    block[8] = v4;
    uint64_t v5 = *((void *)this + 21);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN2CI8TileTask31incrementCompileWaitTimeForNodeEPKNS_11ProgramNodeEd_block_invoke;
    block[3] = &__block_descriptor_tmp_5_5;
    void block[4] = this;
    void block[5] = a2;
    *(double *)&void block[6] = a3;
    dispatch_async(v5, block);
  }
}

void CI::TileTask::setCompileTimeForNode(CI::TileTask *this, const CI::ProgramNode *a2, double a3)
{
  if (a3 != 0.0)
  {
    void block[7] = v3;
    block[8] = v4;
    uint64_t v5 = *((void *)this + 21);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN2CI8TileTask21setCompileTimeForNodeEPKNS_11ProgramNodeEd_block_invoke;
    block[3] = &__block_descriptor_tmp_4_7;
    void block[4] = this;
    void block[5] = a2;
    *(double *)&void block[6] = a3;
    dispatch_async(v5, block);
  }
}

void *CIMetalCommandBufferCreate(uint64_t a1, void *a2, int a3, const void *a4)
{
  if (a3) {
    int v6 = (void *)[a2 commandBufferWithUnretainedReferences];
  }
  else {
    int v6 = (void *)[a2 commandBuffer];
  }
  std::chrono::steady_clock::time_point v7 = v6;
  if (a4)
  {
    uint64_t v8 = (void *)[v6 userDictionary];
    uint64_t v9 = _Block_copy(a4);
    [v8 setObject:v9 forKeyedSubscript:@"RendererStatsPerfCallback"];
    _Block_release(v9);
  }
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v7, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  return v7;
}

void CI::MetalContext::init(CI::MetalContext *this, CFTypeRef cf, const char *a3)
{
  if (cf) {
    CFTypeRef v5 = CFRetain(cf);
  }
  else {
    CFTypeRef v5 = 0;
  }
  *((void *)this + 49) = v5;
  *((void *)this + 240) = a3;
  bzero((char *)this + 1232, 0x208uLL);
  char v6 = 0;
  uint64_t v7 = 0;
  char v8 = 1;
  do
  {
    char v9 = v8;
    int v10 = v6 & 1;
    char v6 = 1;
    uint64_t v11 = (char *)this + 16 * v7;
    *((void *)v11 + 219) = CIMetalSamplerCreate(*((void *)this + 240), (void *)[*((id *)this + 49) device], v10, 1);
    uint64_t v12 = CIMetalSamplerCreate(*((void *)this + 240), (void *)[*((id *)this + 49) device], v10, 0);
    char v8 = 0;
    *((void *)v11 + 220) = v12;
    uint64_t v7 = 1;
  }
  while ((v9 & 1) != 0);
  operator new();
}

void sub_19369A4C0(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40CDAF8E61);
  _Unwind_Resume(a1);
}

_WORD *CI::MetalContext::set_surface_destination(_WORD *result, CI *a2, uint64_t a3, uint64_t a4)
{
  int v5 = *(_DWORD *)a4;
  if (*(_DWORD *)a4)
  {
    char v8 = result;
    result[952] = 257;
    __int16 v9 = 2;
    if (CI::MetalContext::use_imageblocks_for_format((uint64_t)result, v5))
    {
      if (CI_ENABLE_METAL_IMAGEBLOCKS() == 2) {
        __int16 v9 = 4;
      }
      else {
        __int16 v9 = 2;
      }
    }
    *(_OWORD *)(v8 + 916) = *(_OWORD *)a3;
    char v10 = 2 * *(unsigned char *)(a4 + 4);
    *((_DWORD *)v8 + 462) = *(_DWORD *)a4;
    *((unsigned char *)v8 + 1852) = v10;
    if (IOSurfaceGetPlaneCount(a2) == 2)
    {
      int v12 = CI::format_from_IOSurface(a2, v11);
      CI::format_is_ycc_biplanar(v12);
      uint64_t v13 = CI::format_of_plane(v12, 0);
      if (((*(uint64_t (**)(_WORD *, uint64_t))(*(void *)v8 + 424))(v8, v13) & 1) == 0) {
        LODWORD(v13) = CI::format_of_plane_old(v12, 0);
      }
      uint64_t v14 = CI::format_of_plane(v12, 1);
      if (((*(uint64_t (**)(_WORD *, uint64_t))(*(void *)v8 + 424))(v8, v14) & 1) == 0) {
        LODWORD(v14) = CI::format_of_plane_old(v12, 1);
      }
      unsigned int v15 = CIMetalFormatForFormat(v13, 0);
      unsigned int v16 = CIMetalFormatForFormat(v14, 0);
      *((void *)v8 + 233) = CIMetalTextureCreateFromIOSurface(*((void *)v8 + 240), (void *)[*((id *)v8 + 49) device], a2, 0, v15, v9);
      uint64_t result = CIMetalTextureCreateFromIOSurface(*((void *)v8 + 240), (void *)[*((id *)v8 + 49) device], a2, 1uLL, v16, 2);
      *((void *)v8 + 234) = result;
    }
    else
    {
      unsigned int v17 = CIMetalFormatForFormat(*(_DWORD *)a4, *(unsigned __int8 *)(a4 + 4));
      uint64_t result = CIMetalTextureCreateFromPaddedIOSurface((unint64_t)*(double *)a3, (unint64_t)*(double *)(a3 + 8), *((void *)v8 + 240), (void *)[*((id *)v8 + 49) device], (uint64_t)a2, 0, v17, v9);
      *((void *)v8 + 233) = result;
    }
  }
  return result;
}

void *CI::MetalTextureManager::texture_for_IOSurface(uint64_t a1, IOSurfaceRef buffer, size_t a3, int *a4)
{
  if (IOSurfaceGetPlaneCount(buffer) == 2)
  {
    if (a3) {
      int v8 = 3;
    }
    else {
      int v8 = 2;
    }
    int v9 = CI::format_of_plane(*a4, a3);
    if (((*(uint64_t (**)(void))(**(void **)(a1 + 168) + 424))() & 1) == 0) {
      int v9 = CI::format_of_plane_old(*a4, a3);
    }
    if ((v9 - 1285) > 1)
    {
      if (!v9)
      {
        if (a3) {
          uint64_t v11 = "Y";
        }
        else {
          uint64_t v11 = "CbCr";
        }
        int v12 = CI::name_for_format(*a4);
        x_log("Unexpected format requesting a texture for %s plane of format %s\n", v11, v12);
        int v9 = 0;
      }
    }
    else if ((*(unsigned char *)(*(void *)(a1 + 168) + 456) & 1) == 0)
    {
      int v9 = 784;
    }
    int v13 = v9;
    __int16 v14 = 0;
    return CI::MetalTextureManager::create_texture((void *)a1, buffer, a3, v8, (uint64_t)&v13);
  }
  else
  {
    return CI::MetalTextureManager::create_texture((void *)a1, buffer, a3, 2, (uint64_t)a4);
  }
}

uint64_t CI::format_of_plane_old(int a1, int a2)
{
  uint64_t result = CI::format_is_ycc_biplanar(a1);
  if (!result) {
    return result;
  }
  if (a1 <= 1553)
  {
    if (a1 <= 785)
    {
      if ((a1 - 274) > 4 || ((1 << (a1 - 18)) & 0x13) == 0)
      {
        if ((a1 - 530) > 4) {
          return 0;
        }
        uint64_t result = 0;
        if (((1 << (a1 - 18)) & 0x13) == 0) {
          return result;
        }
      }
      BOOL v7 = a2 == 0;
      unsigned int v8 = 261;
LABEL_44:
      if (v7) {
        return v8;
      }
      else {
        return v8 + 1;
      }
    }
    if ((a1 - 786) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0
      || (a1 - 1042) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
    {
      goto LABEL_41;
    }
    if ((a1 - 1298) <= 4)
    {
      uint64_t result = 0;
      if (((1 << (a1 - 18)) & 0x13) == 0) {
        return result;
      }
      goto LABEL_31;
    }
    return 0;
  }
  if (a1 > 3345)
  {
    if ((a1 - 3346) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0
      || (a1 - 3602) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
    {
LABEL_41:
      BOOL v7 = a2 == 0;
      unsigned int v8 = 1797;
      goto LABEL_44;
    }
    if ((a1 - 3858) <= 4)
    {
      uint64_t result = 0;
      if (((1 << (a1 - 18)) & 0x13) == 0) {
        return result;
      }
      goto LABEL_41;
    }
    return 0;
  }
  if ((a1 - 1554) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
  {
LABEL_31:
    BOOL v7 = a2 == 0;
    unsigned int v8 = 1285;
    goto LABEL_44;
  }
  if ((a1 - 1810) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0) {
    goto LABEL_41;
  }
  if (a2) {
    int v5 = 2054;
  }
  else {
    int v5 = 2053;
  }
  if (((1 << (a1 - 18)) & 0x13) != 0) {
    unsigned int v6 = v5;
  }
  else {
    unsigned int v6 = 0;
  }
  if ((a1 - 2066) <= 4) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t CI::MetalContext::format_is_directly_supported_for_input(id *a1, int a2)
{
  if (CI::format_is_ycc_biplanar(a2))
  {
    uint64_t v4 = CI::format_of_plane(a2, 0);
    uint64_t v5 = 1;
    uint64_t v6 = CI::format_of_plane(a2, 1);
    LODWORD(v4) = (*((uint64_t (**)(id *, uint64_t))*a1 + 53))(a1, v4);
    char v7 = (*((uint64_t (**)(id *, uint64_t))*a1 + 53))(a1, v6);
    if (!v4 || (v7 & 1) == 0)
    {
      uint64_t v8 = CI::format_of_plane_old(a2, 0);
      uint64_t v9 = CI::format_of_plane_old(a2, 1);
      LODWORD(v8) = (*((uint64_t (**)(id *, uint64_t))*a1 + 53))(a1, v8);
      return v8 & (*((unsigned int (**)(id *, uint64_t))*a1 + 53))(a1, v9);
    }
    return v5;
  }
  uint64_t v5 = 1;
  if (a2 > 1796)
  {
    if (a2 <= 2308)
    {
      if ((a2 - 1797) <= 3 && a2 != 1799) {
        return v5;
      }
      unsigned int v11 = a2 - 2053;
    }
    else
    {
      if (a2 > 2566)
      {
        if (a2 > 3078)
        {
          if (a2 != 3081 && a2 != 3079) {
            return 0;
          }
        }
        else if (a2 != 2567 && a2 != 2569)
        {
          return 0;
        }
        goto LABEL_33;
      }
      unsigned int v11 = a2 - 2309;
    }
    if (v11 <= 3 && v11 != 2) {
      return v5;
    }
    return 0;
  }
  if (a2 <= 531)
  {
    if ((a2 - 257) <= 0x14 && ((1 << (a2 - 1)) & 0x1802B1) != 0) {
      return v5;
    }
    return 0;
  }
  if (a2 > 783)
  {
    if ((a2 - 784) < 2) {
      goto LABEL_33;
    }
    unsigned int v10 = a2 - 1285;
  }
  else
  {
    if ((a2 - 532) < 2) {
      return v5;
    }
    unsigned int v10 = a2 - 773;
  }
  if (v10 >= 2) {
    return 0;
  }
LABEL_33:
  unsigned int v12 = CIMetalFormatForFormat(a2, 0);

  return CI::MetalContext::formatIsReadable(a1, v12);
}

uint64_t CI::format_is_ycc_biplanar(int a1)
{
  uint64_t result = 1;
  if (a1 <= 1553)
  {
    if (a1 <= 785)
    {
      if ((a1 - 274) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0) {
        return result;
      }
      unsigned int v3 = a1 - 530;
      goto LABEL_15;
    }
    if (((a1 - 786) > 4 || ((1 << (a1 - 18)) & 0x13) == 0)
      && ((a1 - 1042) > 4 || ((1 << (a1 - 18)) & 0x13) == 0))
    {
      unsigned int v3 = a1 - 1298;
      goto LABEL_15;
    }
  }
  else if (a1 > 3345)
  {
    if (((a1 - 3346) > 4 || ((1 << (a1 - 18)) & 0x13) == 0)
      && ((a1 - 3602) > 4 || ((1 << (a1 - 18)) & 0x13) == 0))
    {
      unsigned int v3 = a1 - 3858;
      goto LABEL_15;
    }
  }
  else if (((a1 - 1554) > 4 || ((1 << (a1 - 18)) & 0x13) == 0) {
         && ((a1 - 1810) > 4 || ((1 << (a1 - 18)) & 0x13) == 0))
  }
  {
    unsigned int v3 = a1 - 2066;
LABEL_15:
    if (v3 > 4 || ((1 << v3) & 0x13) == 0) {
      return 0;
    }
  }
  return result;
}

uint64_t CI::format_of_plane(int a1, int a2)
{
  if (((a1 - 786) > 4 || ((1 << (a1 - 18)) & 0x13) == 0)
    && ((a1 - 1042) > 4 || ((1 << (a1 - 18)) & 0x13) == 0))
  {
    return CI::format_of_plane_old(a1, a2);
  }
  if (a2) {
    return 774;
  }
  return 773;
}

void *CI::MetalTextureManager::create_texture(void *a1, IOSurfaceRef buffer, size_t planeIndex, int a4, uint64_t a5)
{
  IOSurfaceRef BaseAddressOfPlane = buffer;
  if (a4 == 3) {
    IOSurfaceRef BaseAddressOfPlane = (IOSurfaceRef)IOSurfaceGetBaseAddressOfPlane(buffer, planeIndex);
  }
  uint64_t v11 = (*(uint64_t (**)(void *, IOSurfaceRef))(*a1 + 8))(a1, BaseAddressOfPlane);
  if (v11) {
    return *(void **)v11;
  }
  unsigned int v13 = CIMetalFormatForFormat(*(_DWORD *)a5, *(unsigned __int8 *)(a5 + 4));
  unsigned int v12 = CIMetalTextureCreateFromIOSurface(*(void *)(a1[21] + 1920), (void *)[*(id *)(a1[21] + 392) device], buffer, planeIndex, v13, 1);
  __int16 v14 = malloc_type_malloc(0x20uLL, 0x10C20408CADBB15uLL);
  *__int16 v14 = v12;
  v14[1] = 0;
  *((_DWORD *)v14 + 4) = a4;
  *((_DWORD *)v14 + 5) = 1;
  *((unsigned char *)v14 + 24) = *(unsigned char *)(a5 + 5);
  CI::TextureManager::append_to_lru((uint64_t)a1, (uint64_t)BaseAddressOfPlane, (uint64_t)v14);
  return v12;
}

uint64_t CIMetalFormatForFormat(int a1, int a2)
{
  if (a1 > 1045)
  {
    if (a1 > 1799)
    {
      if (a1 <= 2309)
      {
        if (a1 <= 2053)
        {
          if (a1 == 1800) {
            return 110;
          }
          if (a1 == 2053) {
            return 25;
          }
        }
        else
        {
          switch(a1)
          {
            case 2054:
              return 65;
            case 2056:
              return 115;
            case 2309:
              return 55;
          }
        }
      }
      else if (a1 > 2568)
      {
        switch(a1)
        {
          case 2569:
            return 553;
          case 3079:
            return 554;
          case 3081:
            return 552;
        }
      }
      else
      {
        switch(a1)
        {
          case 2310:
            return 105;
          case 2312:
            return 125;
          case 2567:
            return 555;
        }
      }
      return 0;
    }
    if (a1 > 1301)
    {
      if (a1 > 1557)
      {
        if (a1 != 1558)
        {
          if (a1 == 1797) {
            return 20;
          }
          if (a1 == 1798) {
            return 60;
          }
          return 0;
        }
      }
      else if (a1 != 1302)
      {
        if (a1 != 1554)
        {
          if (a1 != 1555) {
            return 0;
          }
          return 548;
        }
        return 546;
      }
      return 547;
    }
    if (a1 <= 1285)
    {
      if (a1 == 1046) {
        return 544;
      }
      if (a1 == 1285) {
        return 588;
      }
      return 0;
    }
    if (a1 == 1286) {
      return 589;
    }
    if (a1 != 1298)
    {
      if (a1 != 1299) {
        return 0;
      }
      return 548;
    }
    return 546;
  }
  if (a1 <= 529)
  {
    int v3 = a1 - 257;
    uint64_t result = 1;
    switch(v3)
    {
      case 0:
        return result;
      case 4:
        BOOL v4 = a2 == 0;
        unsigned int v5 = 10;
        goto LABEL_64;
      case 5:
        BOOL v4 = a2 == 0;
        unsigned int v5 = 30;
        goto LABEL_64;
      case 7:
        BOOL v4 = a2 == 0;
        unsigned int v5 = 70;
        goto LABEL_64;
      case 9:
        BOOL v4 = a2 == 0;
        unsigned int v5 = 80;
LABEL_64:
        if (v4) {
          uint64_t result = v5;
        }
        else {
          uint64_t result = v5 + 1;
        }
        break;
      case 17:
LABEL_49:
        uint64_t result = 540;
        break;
      case 18:
LABEL_50:
        uint64_t result = 542;
        break;
      case 19:
LABEL_51:
        uint64_t result = 241;
        break;
      case 20:
LABEL_52:
        uint64_t result = 240;
        break;
      case 21:
LABEL_53:
        uint64_t result = 541;
        break;
      default:
        return 0;
    }
  }
  else if (a1 > 773)
  {
    switch(a1)
    {
      case 784:
        return 94;
      case 785:
        return 90;
      case 786:
      case 788:
      case 789:
        return 0;
      case 787:
        goto LABEL_42;
      case 790:
        return 544;
      default:
        if (a1 == 774)
        {
          uint64_t result = 578;
        }
        else
        {
          if (a1 != 1043) {
            return 0;
          }
LABEL_42:
          uint64_t result = 545;
        }
        break;
    }
  }
  else
  {
    switch(a1)
    {
      case 530:
        goto LABEL_49;
      case 531:
        goto LABEL_50;
      case 532:
        goto LABEL_51;
      case 533:
        goto LABEL_52;
      case 534:
        goto LABEL_53;
      default:
        if (a1 != 773) {
          return 0;
        }
        uint64_t result = 576;
        break;
    }
  }
  return result;
}

void *CIMetalTextureCreateFromIOSurface(uint64_t a1, void *a2, IOSurfaceRef buffer, size_t planeIndex, unsigned int a5, __int16 a6)
{
  size_t WidthOfPlane = IOSurfaceGetWidthOfPlane(buffer, planeIndex);
  size_t HeightOfPlane = IOSurfaceGetHeightOfPlane(buffer, planeIndex);

  return CIMetalTextureCreateFromPaddedIOSurface(WidthOfPlane, HeightOfPlane, a1, a2, (uint64_t)buffer, planeIndex, a5, a6);
}

void CI::TextureManager::append_to_lru(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(NSObject **)(a1 + 104);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI14TextureManager13append_to_lruEPvPNS_13source_info_tE_block_invoke;
  block[3] = &__block_descriptor_tmp_4_8;
  void block[4] = a1;
  void block[5] = a2;
  void block[6] = a3;
  dispatch_sync(v3, block);
}

uint64_t CI::MetalTextureManager::lookup_texture(CI::MetalTextureManager *this, void *a2)
{
  uint64_t v6 = 0;
  char v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  uint64_t v2 = *((void *)this + 13);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN2CI19MetalTextureManager14lookup_textureEPv_block_invoke;
  block[3] = &unk_1E5773BB8;
  void block[4] = &v6;
  void block[5] = this;
  void block[6] = a2;
  dispatch_sync(v2, block);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t CIMetalSamplerCreate(uint64_t a1, void *a2, int a3, int a4)
{
  uint64_t v8 = objc_opt_new();
  uint64_t v9 = v8;
  if (a3)
  {
    [v8 setMinFilter:1];
    [v9 setMagFilter:1];
  }
  if (a4)
  {
    [v9 setSAddressMode:4];
    [v9 setTAddressMode:4];
  }
  [v9 setNormalizedCoordinates:1];
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v9, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  uint64_t v10 = [a2 newSamplerStateWithDescriptor:v9];

  return v10;
}

void *CIMetalTextureCreateFromPaddedIOSurface(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, unsigned int a7, __int16 a8)
{
  if (!a5) {
    return 0;
  }
  uint64_t v9 = 0;
  if (a2)
  {
    if (a1)
    {
      if (a7)
      {
        uint64_t v9 = objc_msgSend(a4, "newTextureWithDescriptor:iosurface:plane:", CreateTextureDescriptor(a7, a1, a2, a8), a5, a6);
        if (v9)
        {
          if (CI_ENABLE_METAL_LABEL()) {
            objc_msgSend(v9, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a3));
          }
        }
      }
    }
  }
  return v9;
}

uint64_t CI_ENABLE_METAL_LABEL()
{
  {
    CI_ENABLE_METAL_LABEL::v = get_BOOL("CI_ENABLE_METAL_LABEL", 1);
  }
  return CI_ENABLE_METAL_LABEL::v;
}

void sub_19369B6BC(_Unwind_Exception *a1)
{
}

void *CreateTextureDescriptor(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  unsigned int v5 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:a1 width:a2 height:a3 mipmapped:0];
  [v5 setUsage:0];
  if (a4)
  {
    objc_msgSend(v5, "setUsage:", objc_msgSend(v5, "usage") | 1);
    if ((a4 & 2) == 0)
    {
LABEL_3:
      if ((a4 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_9:
      objc_msgSend(v5, "setUsage:", objc_msgSend(v5, "usage") | 4);
      if ((a4 & 0x4000) == 0) {
        return v5;
      }
      goto LABEL_5;
    }
  }
  else if ((a4 & 2) == 0)
  {
    goto LABEL_3;
  }
  objc_msgSend(v5, "setUsage:", objc_msgSend(v5, "usage") | 2);
  if ((a4 & 4) != 0) {
    goto LABEL_9;
  }
LABEL_4:
  if ((a4 & 0x4000) != 0) {
LABEL_5:
  }
    objc_msgSend(v5, "setUsage:", objc_msgSend(v5, "usage") | 0x4000);
  return v5;
}

uint64_t *___ZN2CI14TextureManager13append_to_lruEPvPNS_13source_info_tE_block_invoke(uint64_t a1)
{
  uint64_t v3 = (uint64_t *)(a1 + 40);
  uint64_t v2 = *(CGImage **)(a1 + 40);
  uint64_t v4 = *(v3 - 1);
  if (v2)
  {
    switch(*(_DWORD *)(*(void *)(a1 + 48) + 16))
    {
      case 0:
        CI::Object::ref((uint64_t)v2);
        break;
      case 1:
        CGImageRetain(v2);
        break;
      case 2:
        CFRetain(v2);
        break;
      case 4:
        RetainSurfaceFromCache(v2);
        break;
      default:
        break;
    }
  }
  unsigned int v5 = operator new(0x18uLL);
  v5[2] = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(v4 + 32);
  uint64_t v6 = v4 + 32;
  *unsigned int v5 = v7;
  v5[1] = v6;
  *(void *)(v7 + 8) = v5;
  *(void *)uint64_t v6 = v5;
  ++*(void *)(v6 + 16);
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v10 = v3;
  uint64_t result = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v6 + 80), (unint64_t *)v3, (uint64_t)&std::piecewise_construct, &v10);
  result[5] = v8;
  return result;
}

void ___ZN2CI14TextureManager19remove_from_pendingERKNS_6roiKeyE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = v2 + 8;
  uint64_t v4 = v2[9];
  if ((void *)v4 != v2 + 8)
  {
    unsigned int v5 = *(uint64_t **)(a1 + 40);
    uint64_t v6 = *v5;
    int v7 = *((_DWORD *)v5 + 2);
    while (v6 != *(void *)(v4 + 16) || v7 != *(_DWORD *)(v4 + 24))
    {
      uint64_t v4 = *(void *)(v4 + 8);
      if ((uint64_t *)v4 == v3) {
        goto LABEL_8;
      }
    }
    uint64_t v3 = (uint64_t *)v4;
  }
LABEL_8:
  uint64_t v8 = *v3;
  *(void *)(v8 + 8) = v3[1];
  *(void *)v3[1] = v8;
  --v2[10];
  operator delete(v3);
}

void *__isImageConversionServiceProcess_block_invoke()
{
  uint64_t result = (void *)[MEMORY[0x1E4F28F80] processInfo];
  if (result) {
    uint64_t result = objc_msgSend((id)objc_msgSend(result, "processName"), "isEqualToString:", @"com.apple.photos.ImageConversionService");
  }
  isImageConversionServiceProcess_isICS = (char)result;
  return result;
}

uint64_t ___ZNK2CI8TileTask18commandBufferErrorEv_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(*(void *)(result + 40) + 176);
  return result;
}

void ___ZL8GetQueuev_block_invoke_2()
{
}

std::string *CI::DAGHelper::TextureReadFunction::operator=(std::string *a1, const std::string *a2)
{
  std::string::operator=(a1, a2);
  if (a1 != a2) {
    std::vector<unsigned long>::__assign_with_size[abi:nn180100]<unsigned long *,unsigned long *>((char *)&a1[1], a2[1].__r_.__value_.__l.__data_, a2[1].__r_.__value_.__l.__size_, (uint64_t)(a2[1].__r_.__value_.__l.__size_ - a2[1].__r_.__value_.__r.__words[0]) >> 3);
  }
  return a1;
}

char *std::vector<unsigned long>::__assign_with_size[abi:nn180100]<unsigned long *,unsigned long *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *int v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 61) {
      abort();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<unsigned long>::__vallocate[abi:nn180100](v7, v11);
    unsigned int v13 = (char *)v7[1];
    unsigned int v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      os_signpost_id_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unsigned int v12 = (void **)(result + 8);
  __int16 v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  unsigned int v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    os_signpost_id_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *unsigned int v12 = &v9[v17];
  return result;
}

void ___ZN2CI4Node16remove_parentROIERKNS_9parentROIERKNS_6roiKeyEPNS_14TextureManagerEPv_block_invoke(uint64_t a1)
{
  dispatch_group_wait(*(dispatch_group_t *)(a1 + 32), 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

double ___ZN2CI8TileTask24incrementFillTimeForNodeEPKNS_4NodeEd_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32) + 88;
  uint64_t v6 = (unsigned int *)(*(void *)(a1 + 40) + 36);
  std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v2, v6, (uint64_t)&std::piecewise_construct, &v6)[80] = 1;
  double v3 = *(double *)(a1 + 48);
  uint64_t v6 = (unsigned int *)(*(void *)(a1 + 40) + 36);
  uint64_t v4 = std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v2, v6, (uint64_t)&std::piecewise_construct, &v6);
  double result = v3 + *((double *)v4 + 6);
  *((double *)v4 + 6) = result;
  return result;
}

double ___ZN2CI8TileTask31incrementCompileWaitTimeForNodeEPKNS_11ProgramNodeEd_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32) + 88;
  uint64_t v6 = (unsigned int *)(*(void *)(a1 + 40) + 36);
  std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v2, v6, (uint64_t)&std::piecewise_construct, &v6)[80] = 1;
  double v3 = *(double *)(a1 + 48);
  uint64_t v6 = (unsigned int *)(*(void *)(a1 + 40) + 36);
  uint64_t v4 = std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v2, v6, (uint64_t)&std::piecewise_construct, &v6);
  double result = v3 + *((double *)v4 + 5);
  *((double *)v4 + 5) = result;
  return result;
}

char *___ZN2CI8TileTask21setCompileTimeForNodeEPKNS_11ProgramNodeEd_block_invoke(void *a1)
{
  uint64_t v2 = a1[4] + 88;
  unsigned int v5 = (unsigned int *)(a1[5] + 36);
  std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v2, v5, (uint64_t)&std::piecewise_construct, &v5)[80] = 1;
  uint64_t v3 = a1[6];
  unsigned int v5 = (unsigned int *)(a1[5] + 36);
  double result = std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v2, v5, (uint64_t)&std::piecewise_construct, &v5);
  *((void *)result + 4) = v3;
  return result;
}

double ___ZN2CI8TileTask20incrementTimeForNodeEPKNS_11ProgramNodeEd_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32) + 88;
  uint64_t v6 = (unsigned int *)(*(void *)(a1 + 40) + 36);
  std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v2, v6, (uint64_t)&std::piecewise_construct, &v6)[80] = 1;
  double v3 = *(double *)(a1 + 48);
  uint64_t v6 = (unsigned int *)(*(void *)(a1 + 40) + 36);
  uint64_t v4 = std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v2, v6, (uint64_t)&std::piecewise_construct, &v6);
  double result = v3 + *((double *)v4 + 3);
  *((double *)v4 + 3) = result;
  return result;
}

char *___ZN2CI8TileTask26incrementFillPixelsForNodeEPKNS_4NodeEy_block_invoke(void *a1)
{
  uint64_t v2 = a1[4] + 88;
  unsigned int v5 = (unsigned int *)(a1[5] + 36);
  std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v2, v5, (uint64_t)&std::piecewise_construct, &v5)[80] = 1;
  uint64_t v3 = a1[6];
  unsigned int v5 = (unsigned int *)(a1[5] + 36);
  double result = std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(v2, v5, (uint64_t)&std::piecewise_construct, &v5);
  *((void *)result + 7) += v3;
  return result;
}

char *std::__hash_table<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::__unordered_map_hasher<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::hash<CI::NodeIndex>,std::equal_to<CI::NodeIndex>,true>,std::__unordered_map_equal<CI::NodeIndex,std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>,std::equal_to<CI::NodeIndex>,std::hash<CI::NodeIndex>,true>,std::allocator<std::__hash_value_type<CI::NodeIndex,CI::Node::NodeStats>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      unint64_t v11 = (char *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = *((void *)v11 + 1);
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          unint64_t v11 = *(char **)v11;
        }
        while (v11);
      }
    }
  }
  unint64_t v11 = (char *)operator new(0x58uLL);
  *(void *)unint64_t v11 = 0;
  *((void *)v11 + 1) = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *(_OWORD *)(v11 + 72) = 0u;
  *(_OWORD *)(v11 + 56) = 0u;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *(void *)unint64_t v11 = *v20;
LABEL_38:
    *uint64_t v20 = v11;
    goto LABEL_39;
  }
  *(void *)unint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*(void *)v11)
  {
    unint64_t v21 = *(void *)(*(void *)v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

uint64_t __RegularizePriorityForContextEntries_block_invoke(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 32);
  uint64_t v2 = CI::gCacheList;
  if (v1) {
    BOOL v3 = CI::gCacheList == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    uint64_t v4 = *(void *)(CI::gCacheList + 8);
    if (v4 != CI::gCacheList)
    {
      do
      {
        uint64_t v5 = *(void *)(v4 + 16);
        if (*(_DWORD *)(v5 + 56) == v1 && *(int *)(v5 + 96) >= 7) {
          *(_DWORD *)(v5 + 96) = 6;
        }
        uint64_t v4 = *(void *)(v4 + 8);
      }
      while (v4 != v2);
    }
  }
  return result;
}

void sub_19369C46C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40112EC1AALL);
  _Unwind_Resume(a1);
}

id KernelKindAlloc(int a1)
{
  if ((a1 - 1) > 3) {
    return 0;
  }
  uint64_t v2 = (objc_class *)objc_opt_class();
  return [v2 alloc];
}

CI::ColorMatrixNode *CI::ColorMatrixImage::render_graph_core(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (const double (*)[4])(*(uint64_t (**)(uint64_t))(*(void *)a1 + 184))(a1);
  if (a3)
  {
    uint64_t v6 = (CI::ColorMatrixNode *)CI::Object::ref(a3);
    unint64_t v7 = CI::ColorMatrixNode::append_to_tree(v6, (CI::Node *)(a1 + 120), v5);
    if (v6) {
      CI::Object::unref(v6);
    }
    return v7;
  }
  else
  {
    return CI::ColorMatrixNode::append_to_tree(0, (CI::Node *)(a1 + 120), v5);
  }
}

void CI::SurfaceImage::render_graph_core(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = (int *)(a1 + 168);
  uint64_t v9 = CI::Context::swizzler_for_input(a2, *(unsigned int *)(a1 + 168));
  if (v9)
  {
    int v10 = v8;
    if (*(_DWORD *)(a1 + 184) != 1 && (*(_DWORD *)(a1 + 180) | 2) != 6)
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) == 74) {
        goto LABEL_20;
      }
      double v12 = CI::Image::lookup_union_roi(a1, a4);
      CGFloat v14 = v13;
      CGFloat v16 = v15;
      CGFloat v18 = v17;
      v19.origin.CGFloat x = (*(double (**)(uint64_t))(*(void *)a1 + 88))(a1);
      v20.origin.CGFloat x = v12;
      v20.origin.double y = v14;
      v20.size.CGFloat width = v16;
      v20.size.CGFloat height = v18;
      if (!CGRectContainsRect(v19, v20))
      {
LABEL_20:
        if ((*(unsigned int (**)(uint64_t, void))(*(void *)a2 + 560))(a2, 0)) {
          CI::format_has_alpha(*v7);
        }
      }
    }
    if (v10) {
      CI::input_format_for_conversion(v10);
    }
    if (!*(unsigned char *)(a1 + 188)) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 568))(a2, 1, v9);
    }
    operator new();
  }
  unint64_t v11 = ci_logger_render();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
    CI::SurfaceImage::render_graph_core(v7, v11);
  }
  operator new();
}

CI::ColorMatrixNode *CI::ColorMatrixNode::append_to_tree(CI::ColorMatrixNode *this, CI::Node *a2, const double (*a3)[4])
{
  int v3 = (int)a3;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (CI::ColorMatrixNode::is_identity(a2, (const double (*)[4])a2))
  {
    if (!this) {
      return this;
    }
  }
  else if (!(*(unsigned int (**)(CI::ColorMatrixNode *))(*(void *)this + 288))(this) {
         || !CI::ColorMatrixNode::is_rrra(a2, v6))
  }
  {
    if (v3 && (*(unsigned int (**)(CI::ColorMatrixNode *))(*(void *)this + 232))(this))
    {
      int v8 = 0;
      uint64_t v9 = this;
      while (1)
      {
        int v10 = v9;
        if ((*(uint64_t (**)(CI::ColorMatrixNode *))(*(void *)v9 + 176))(v9)) {
          break;
        }
        uint64_t v9 = (CI::ColorMatrixNode *)(*(uint64_t (**)(CI::ColorMatrixNode *, void))(*(void *)v9 + 48))(v9, 0);
        int v8 = v10;
        if (((*(uint64_t (**)(CI::ColorMatrixNode *))(*(void *)v9 + 232))(v9) & 1) == 0) {
          goto LABEL_16;
        }
      }
      int v10 = v8;
    }
    else
    {
      int v10 = 0;
      uint64_t v9 = this;
    }
LABEL_16:
    if ((*(unsigned int (**)(CI::ColorMatrixNode *))(*(void *)v9 + 16))(v9) != 33) {
      operator new();
    }
    CMatrix::CMatrix((CMatrix *)v24, 4u, 4u, (const double *)v9 + 7);
    CMatrix::CMatrix((CMatrix *)v23, 4u, 1u, (const double *)v9 + 23);
    CMatrix::CMatrix((CMatrix *)v22, 4u, 4u, (const double *)a2);
    CMatrix::CMatrix((CMatrix *)v21, 4u, 1u, (const double *)a2 + 16);
    CMatrix::operator*(v22, v24, v20);
    CMatrix::operator*(v22, v23, (unsigned int *)v25);
    CMatrix::operator+((unsigned int *)v25, v21, v19);
    uint64_t v17 = CMatrix::operator[](v20, 0);
    uint64_t v18 = v11;
    double v12 = CMatrixRow::operator[]((uint64_t)&v17, 0);
    v25[4] = v12[4];
    v25[5] = v12[5];
    v25[6] = v12[6];
    v25[7] = v12[7];
    v25[0] = *v12;
    v25[1] = v12[1];
    v25[2] = v12[2];
    v25[3] = v12[3];
    uint64_t v17 = CMatrix::operator[](v19, 0);
    uint64_t v18 = v13;
    CGFloat v14 = CMatrixRow::operator[]((uint64_t)&v17, 0);
    v25[8] = *v14;
    v25[9] = v14[1];
    if (!CI::ColorMatrixNode::is_identity((CI::ColorMatrixNode *)v25, v15)) {
      operator new();
    }
    CGFloat v16 = (CI::Object *)*((void *)v9 + 5);
    if (v16) {
      CI::Object::ref(*((void *)v9 + 5));
    }
    if (!v10) {
      return v16;
    }
    (*(void (**)(CI::ColorMatrixNode *, CI::Object *, void))(*(void *)v10 + 200))(v10, v16, 0);
    if (v16) {
      CI::Object::unref(v16);
    }
    CI::Object::ref((uint64_t)this);
    return this;
  }

  return (CI::ColorMatrixNode *)CI::Object::ref((uint64_t)this);
}

void CMatrix::CMatrix(CMatrix *this, unsigned int a2, unsigned int a3, const double *a4)
{
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  if (a2 > 5 || a3 >= 6) {
    *(void *)this = 0;
  }
  bzero((char *)this + 8, 0xC8uLL);
  memcpy((char *)this + 8, a4, 8 * *(unsigned int *)this * (unint64_t)*((unsigned int *)this + 1));
}

BOOL CI::ColorMatrixNode::is_identity(CI::ColorMatrixNode *this, const double (*a2)[4])
{
  return fabs(*(double *)this + -1.0) < 0.0003
      && fabs(*((double *)this + 1)) < 0.0003
      && fabs(*((double *)this + 2)) < 0.0003
      && fabs(*((double *)this + 3)) < 0.0003
      && fabs(*((double *)this + 4)) < 0.0003
      && fabs(*((double *)this + 5) + -1.0) < 0.0003
      && fabs(*((double *)this + 6)) < 0.0003
      && fabs(*((double *)this + 7)) < 0.0003
      && fabs(*((double *)this + 8)) < 0.0003
      && fabs(*((double *)this + 9)) < 0.0003
      && fabs(*((double *)this + 10) + -1.0) < 0.0003
      && fabs(*((double *)this + 11)) < 0.0003
      && fabs(*((double *)this + 12)) < 0.0003
      && fabs(*((double *)this + 13)) < 0.0003
      && fabs(*((double *)this + 14)) < 0.0003
      && fabs(*((double *)this + 15) + -1.0) < 0.0003
      && fabs(*((double *)this + 16)) < 0.0003
      && fabs(*((double *)this + 17)) < 0.0003
      && fabs(*((double *)this + 18)) < 0.0003
      && fabs(*((double *)this + 19)) < 0.0003;
}

{
  return CI::ColorMatrixNode::is_identity((CI::ColorMatrixNode *)((char *)this + 56), a2);
}

void CMatrix::operator*(unsigned int *a1@<X0>, _DWORD *a2@<X1>, unsigned int *a3@<X8>)
{
  uint64_t v4 = a1[1];
  if (v4 == *a2)
  {
    uint64_t v7 = *a1;
    uint64_t v8 = a2[1];
    *a3 = v7;
    a3[1] = v8;
    if (v7 > 5 || v8 >= 6) {
      *(void *)a3 = 0;
    }
    bzero(a3 + 2, 0xC8uLL);
    if (v7)
    {
      int v10 = 0;
      unint64_t v11 = 0;
      unint64_t v12 = *a3;
      unint64_t v13 = a3[1];
      do
      {
        if (v8)
        {
          for (unint64_t i = 0; i != v8; ++i)
          {
            BOOL v15 = i >= v13 || v11 >= v12;
            CGFloat v16 = (double *)&a3[2 * (v13 * v11) + 2 + 2 * i];
            if (v15) {
              CGFloat v16 = (double *)&CMatrixRow::operator[]const::zero;
            }
            *CGFloat v16 = 0.0;
            if (v4)
            {
              unsigned int v17 = 0;
              double v18 = 0.0;
              uint64_t v19 = v4;
              CGRect v20 = (double *)&a1[2 * v10 + 2];
              do
              {
                double v21 = *v20++;
                double v18 = v18 + v21 * *(double *)&a2[2 * i + 2 + 2 * v17];
                *CGFloat v16 = v18;
                v17 += v8;
                --v19;
              }
              while (v19);
            }
          }
        }
        ++v11;
        v10 += v4;
      }
      while (v11 != v7);
    }
  }
  else
  {
    *(void *)a3 = 0;
    bzero(a3 + 2, 0xC8uLL);
  }
}

uint64_t CMatrix::operator[](unsigned int *a1, unsigned int a2)
{
  if (*a1 <= a2) {
    return 0;
  }
  else {
    return a1[1];
  }
}

void *CMatrixRow::operator[](uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return &CMatrixRow::operator[]const::zero;
  }
  uint64_t v3 = v2 + 8 * a2;
  if (*(_DWORD *)a1 > a2) {
    return (void *)v3;
  }
  else {
    return &CMatrixRow::operator[]const::zero;
  }
}

CI::Object *CI::SwizzleNode::append_to_tree(CI::Object *this, int a2, int a3)
{
  uint64_t v3 = this;
  if (a2)
  {
    if (a3 && (*(unsigned int (**)(CI::Object *))(*(void *)this + 232))(this))
    {
      uint64_t v5 = 0;
      uint64_t v6 = (uint64_t)v3;
      while (1)
      {
        uint64_t v7 = v6;
        if ((*(uint64_t (**)(uint64_t))(*(void *)v6 + 176))(v6)) {
          break;
        }
        uint64_t v6 = (*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 48))(v6, 0);
        uint64_t v5 = v7;
        if (((*(uint64_t (**)(uint64_t))(*(void *)v6 + 232))(v6) & 1) == 0) {
          goto LABEL_9;
        }
      }
      uint64_t v7 = v5;
    }
    else
    {
      uint64_t v7 = 0;
      uint64_t v6 = (uint64_t)v3;
    }
LABEL_9:
    if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 16))(v6) != 47) {
      operator new();
    }
    int v8 = *(_DWORD *)(v6 + 56);
    if (a2 == 1 && v8 == 1)
    {
      uint64_t v9 = *(CI::Object **)(v6 + 40);
      if (v9) {
        CI::Object::ref(*(void *)(v6 + 40));
      }
    }
    else
    {
      if (a2 != 10 || (v8 & 0xFFFFFFFE) != 0xA) {
        operator new();
      }
      CI::Object::ref(v6);
      uint64_t v9 = (CI::Object *)v6;
    }
    if (!v7) {
      return v9;
    }
    (*(void (**)(uint64_t, CI::Object *, void))(*(void *)v7 + 200))(v7, v9, 0);
    if (v9) {
      CI::Object::unref(v9);
    }
    if (v3) {
      CI::Object::ref((uint64_t)v3);
    }
    return v3;
  }
  if (!this) {
    return v3;
  }

  return (CI::Object *)CI::Object::ref((uint64_t)this);
}

uint64_t get_ycc_to_rgb_matrix(int a1, int a2, int a3, double *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  HIDWORD(v8) = a3;
  LODWORD(v8) = a3;
  unsigned int v7 = v8 >> 1;
  BOOL v9 = v7 > 8;
  int v10 = (1 << v7) & 0x171;
  if (v9 || v10 == 0) {
    return 0;
  }
  uint64_t result = 0;
  if (a1 > 708)
  {
    if (a1 == 2020)
    {
      float64x2_t v14 = (float64x2_t)xmmword_19395AC30;
      uint64_t v15 = 0x3FE5B22D0E560419;
    }
    else
    {
      if (a1 != 709) {
        return result;
      }
      float64x2_t v14 = (float64x2_t)xmmword_19395AC50;
      uint64_t v15 = 0x3FE6E2EB1C432CA5;
    }
  }
  else if (a1 == 240)
  {
    float64x2_t v14 = (float64x2_t)xmmword_19395AC40;
    uint64_t v15 = 0x3FE66E978D4FDF3BLL;
  }
  else
  {
    if (a1 != 601) {
      return result;
    }
    float64x2_t v14 = (float64x2_t)xmmword_19395AC20;
    uint64_t v15 = 0x3FE2C8B439581062;
  }
  *(_OWORD *)a5 = xmmword_19395A440;
  __asm { FMOV            V2.2D, #1.0 }
  float64x2_t v20 = vsubq_f64(_Q2, v14);
  *(double *)(a5 + 16) = v20.f64[1] + v20.f64[1];
  *(void *)a6 = 0x3FF0000000000000;
  __asm { FMOV            V3.2D, #-2.0 }
  *(float64x2_t *)(a6 + 8) = vdivq_f64(vmulq_f64(v14, vmulq_f64(v20, _Q3)), (float64x2_t)vdupq_lane_s64(v15, 0));
  *(void *)a7 = 0x3FF0000000000000;
  *(double *)(a7 + 8) = v20.f64[0] + v20.f64[0];
  *(void *)(a7 + 16) = 0;
  switch(a3)
  {
    case 16:
      double v22 = 32768.0;
      double v23 = 65535.0;
      double v24 = 65534.0;
      break;
    case 10:
      double v22 = 512.0;
      double v23 = 1023.0;
      double v24 = 1022.0;
      break;
    case 12:
      double v22 = 2048.0;
      double v23 = 4095.0;
      double v24 = 4094.0;
      break;
    default:
      double v22 = 1.0;
      if (a3 == 8) {
        double v23 = 255.0;
      }
      else {
        double v23 = 1.0;
      }
      if (a3 == 8) {
        double v24 = 254.0;
      }
      else {
        double v24 = 1.0;
      }
      if (a3 == 8) {
        double v22 = 128.0;
      }
      break;
  }
  double v25 = 1.0;
  double v26 = 4.0;
  if (a3 != 10) {
    double v26 = 1.0;
  }
  if (a3 == 12) {
    double v26 = 16.0;
  }
  if (a3 == 16) {
    double v26 = 256.0;
  }
  if (!a2)
  {
    if (a3)
    {
      double v25 = v23 / (v26 * 219.0);
      double v28 = v23 / (v26 * 224.0);
      double v27 = v26 * -16.0 / v23;
      goto LABEL_40;
    }
    double v27 = 0.0;
LABEL_42:
    double v29 = 0.0;
    double v28 = 1.0;
    goto LABEL_43;
  }
  double v27 = 0.0;
  if (!a3) {
    goto LABEL_42;
  }
  double v28 = v23 / v24;
LABEL_40:
  double v29 = -v22 / v23;
LABEL_43:
  a4[1] = v29;
  a4[2] = v29;
  *a4 = v27;
  *(double *)a5 = v25 * *(double *)a5;
  *(float64x2_t *)(a5 + 8) = vmulq_n_f64(*(float64x2_t *)(a5 + 8), v28);
  *(double *)a6 = v25 * *(double *)a6;
  *(float64x2_t *)(a6 + 8) = vmulq_n_f64(*(float64x2_t *)(a6 + 8), v28);
  *(double *)a7 = v25 * *(double *)a7;
  *(float64x2_t *)(a7 + 8) = vmulq_n_f64(*(float64x2_t *)(a7 + 8), v28);
  return 1;
}

void CMatrix::operator+(unsigned int *a1@<X0>, _DWORD *a2@<X1>, unsigned int *a3@<X8>)
{
  uint64_t v4 = *a1;
  if (v4 == *a2 && (uint64_t v7 = a1[1], v7 == a2[1]))
  {
    *a3 = v4;
    a3[1] = v7;
    if (v4 > 5 || v7 >= 6) {
      *(void *)a3 = 0;
    }
    bzero(a3 + 2, 0xC8uLL);
    if (v4)
    {
      int v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      unint64_t v12 = *a3;
      unint64_t v13 = a3[1];
      do
      {
        if (v7)
        {
          unint64_t v14 = 0;
          uint64_t v15 = (uint64_t)&a3[2 * v9 + 2];
          do
          {
            if (v14 >= v13 || v11 >= v12) {
              unsigned int v17 = (double *)&CMatrixRow::operator[]const::zero;
            }
            else {
              unsigned int v17 = (double *)v15;
            }
            double *v17 = *(double *)&a1[2 * v10 + 2 + 2 * v14] + *(double *)&a2[2 * v10 + 2 + 2 * v14];
            ++v14;
            v15 += 8;
          }
          while (v7 != v14);
        }
        ++v11;
        v10 += v7;
        v9 += v13;
      }
      while (v11 != v4);
    }
  }
  else
  {
    *(void *)a3 = 0;
    bzero(a3 + 2, 0xC8uLL);
  }
}

uint64_t CI::Context::swizzler_for_input(uint64_t a1, uint64_t a2)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = ___ZNK2CI7Context18swizzler_for_inputENS_11PixelFormatE_block_invoke;
  _OWORD v3[3] = &__block_descriptor_tmp_20;
  v3[4] = a1;
  return CI::format_swizzle_for_input(a2, (uint64_t)v3);
}

uint64_t CI::ColorMatrixNode::output_is_luma(CI::ColorMatrixNode *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 5) + 264))(*((void *)this + 5));
  if (result)
  {
    return CI::ColorMatrixNode::is_rrra((CI::ColorMatrixNode *)((char *)this + 56), v3);
  }
  return result;
}

uint64_t CI::SurfaceImage::matrix_bias(CI::SurfaceImage *this, double *a2, double *a3, double *a4, double *a5)
{
  if (!*((_DWORD *)this + 44)) {
    return 0;
  }
  uint64_t PixelFormat = IOSurfaceGetPixelFormat(*((IOSurfaceRef *)this + 14));
  int v11 = equivalent_uncompressed_format(PixelFormat);
  int v12 = 0;
  if (v11 > 1937126451)
  {
    if (v11 <= 2016686639)
    {
      if (v11 > 1953903153)
      {
        BOOL v13 = v11 == 1953903154;
        unsigned __int16 v16 = 13364;
      }
      else
      {
        BOOL v13 = v11 == 1937126452;
        unsigned __int16 v16 = 12848;
      }
      int v14 = v16 | 0x74760000;
    }
    else if (v11 <= 2016687155)
    {
      BOOL v13 = v11 == 2016686640;
      int v14 = 2016686642;
    }
    else
    {
      BOOL v13 = v11 == 2016687156 || v11 == 2033463352;
      int v14 = 2037741171;
    }
  }
  else if (v11 <= 1882468911)
  {
    if (v11 > 875704949)
    {
      BOOL v13 = v11 == 875704950;
      int v14 = 875836534;
    }
    else
    {
      BOOL v13 = v11 == 846624121;
      int v14 = 875704438;
    }
  }
  else if (v11 <= 1882469427)
  {
    BOOL v13 = v11 == 1882468912;
    int v14 = 1882468914;
  }
  else
  {
    BOOL v13 = v11 == 1882469428 || v11 == 1937125936;
    int v14 = 1937125938;
  }
  if (!v13 && v11 != v14) {
    int v12 = 1;
  }
  int v18 = 8;
  if (v11 > 1936077875)
  {
    if (v11 > 1953903667)
    {
      if (v11 > 2019963441)
      {
        if (v11 > 2033463351)
        {
          if (v11 == 2033463352 || v11 == 2037741158) {
            goto LABEL_97;
          }
          int v24 = 2037741171;
          goto LABEL_77;
        }
        if (v11 == 2019963442) {
          goto LABEL_96;
        }
        unsigned __int16 v20 = 13364;
LABEL_94:
        int v19 = v20 | 0x78660000;
        goto LABEL_95;
      }
      if (v11 > 2016686641)
      {
        if (v11 == 2016686642 || v11 == 2016687156) {
          goto LABEL_96;
        }
        unsigned __int16 v20 = 12848;
        goto LABEL_94;
      }
      if (v11 != 1953903668)
      {
        int v19 = 2016686640;
        goto LABEL_95;
      }
LABEL_89:
      int v18 = 12;
      goto LABEL_97;
    }
    if (v11 <= 1952854575)
    {
      if (v11 > 1937125937)
      {
        if (v11 == 1937125938) {
          goto LABEL_73;
        }
        unsigned __int16 v25 = 13364;
      }
      else
      {
        if (v11 == 1936077876) {
          goto LABEL_73;
        }
        unsigned __int16 v25 = 12848;
      }
      int v23 = v25 | 0x73760000;
LABEL_72:
      if (v11 != v23) {
        goto LABEL_100;
      }
      goto LABEL_73;
    }
    if (v11 <= 1952855091)
    {
      if (v11 == 1952854576) {
        goto LABEL_89;
      }
      int v22 = 1952854578;
    }
    else
    {
      if (v11 == 1952855092 || v11 == 1953903152) {
        goto LABEL_89;
      }
      int v22 = 1953903154;
    }
    if (v11 != v22) {
      goto LABEL_100;
    }
    goto LABEL_89;
  }
  if (v11 > 1751527985)
  {
    if (v11 <= 1885745711)
    {
      if (v11 > 1882468911)
      {
        if (v11 == 1882468912 || v11 == 1882468914) {
          goto LABEL_96;
        }
        int v19 = 1882469428;
LABEL_95:
        if (v11 == v19) {
          goto LABEL_96;
        }
LABEL_100:
        int v18 = -1;
        goto LABEL_97;
      }
      if (v11 == 1751527986) {
        goto LABEL_86;
      }
      unsigned __int16 v21 = 13364;
LABEL_85:
      if (v11 != (v21 | 0x68660000)) {
        goto LABEL_100;
      }
LABEL_86:
      int v18 = 0;
      goto LABEL_97;
    }
    if (v11 <= 1885746227)
    {
      if (v11 != 1885745712)
      {
        int v19 = 1885745714;
        goto LABEL_95;
      }
    }
    else if (v11 != 1885746228)
    {
      if (v11 != 1936077360)
      {
        int v23 = 1936077362;
        goto LABEL_72;
      }
LABEL_73:
      int v18 = 16;
      goto LABEL_97;
    }
LABEL_96:
    int v18 = 10;
    goto LABEL_97;
  }
  if (v11 <= 875704933)
  {
    if (v11 <= 875704421)
    {
      if (v11 == 846624102) {
        goto LABEL_97;
      }
      int v24 = 846624121;
      goto LABEL_77;
    }
    if (v11 == 875704422) {
      goto LABEL_97;
    }
    unsigned __int16 v26 = 12406;
LABEL_76:
    int v24 = v26 | 0x34320000;
LABEL_77:
    if (v11 != v24) {
      goto LABEL_100;
    }
    goto LABEL_97;
  }
  if (v11 <= 875836517)
  {
    if (v11 == 875704934) {
      goto LABEL_97;
    }
    unsigned __int16 v26 = 12918;
    goto LABEL_76;
  }
  if (v11 != 875836518 && v11 != 875836534)
  {
    unsigned __int16 v21 = 12848;
    goto LABEL_85;
  }
LABEL_97:
  int v27 = *((_DWORD *)this + 44);

  return get_ycc_to_rgb_matrix(v27, v12, v18, a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5);
}

uint64_t CI::SurfaceNode::output_is_luma(CI **this, __IOSurface *a2)
{
  int v3 = CI::format_from_IOSurface(this[7], a2);
  uint64_t result = CI::format_is_luminance(v3);
  if (result)
  {
    uint64_t v5 = (uint64_t (*)(CI **))*((void *)*this + 33);
    return v5(this);
  }
  return result;
}

uint64_t CI::format_is_luminance(int a1)
{
  uint64_t result = 1;
  if (a1 > 2050)
  {
    if ((a1 - 2051) >= 2 && (a1 - 2307) >= 2 && a1 != 3331) {
      return 0;
    }
  }
  else if ((a1 - 259) >= 2 && (a1 - 1795) >= 2 && a1 != 771)
  {
    return 0;
  }
  return result;
}

uint64_t CI::format_swizzle_for_input(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  unsigned int v3 = 0;
  if (!a1 || !a2) {
    return v2 | v3;
  }
  int v5 = a1;
  if ((a1 - 532) >= 2 && (a1 - 276) > 1)
  {
    if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1))
    {
      uint64_t v2 = 0;
      goto LABEL_10;
    }
  }
  else if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1))
  {
    uint64_t v2 = 0x400000000;
LABEL_10:
    unsigned int v3 = v5;
    return v2 | v3;
  }
  if (v5 <= 1792)
  {
    if (v5 > 770)
    {
      if (v5 > 1042)
      {
        if (v5 > 1298)
        {
          if (v5 <= 1553)
          {
            if (v5 == 1299)
            {
              unsigned int v3 = 2056;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
              {
                uint64_t v2 = 0;
                return v2 | v3;
              }
            }
            else if (v5 == 1302)
            {
              unsigned int v3 = 2056;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
              {
                uint64_t v2 = 0;
                return v2 | v3;
              }
            }
          }
          else
          {
            switch(v5)
            {
              case 1554:
                unsigned int v3 = 2056;
                if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
                {
                  uint64_t v2 = 0;
                  return v2 | v3;
                }
                break;
              case 1555:
                unsigned int v3 = 2056;
                if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
                {
                  uint64_t v2 = 0;
                  return v2 | v3;
                }
                break;
              case 1558:
                unsigned int v3 = 2056;
                if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
                {
                  uint64_t v2 = 0;
                  return v2 | v3;
                }
                break;
            }
          }
        }
        else if (v5 <= 1284)
        {
          if (v5 == 1043)
          {
            unsigned int v3 = 2056;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
            {
              uint64_t v2 = 0;
              return v2 | v3;
            }
          }
          else if (v5 == 1046)
          {
            unsigned int v3 = 2056;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
            {
              uint64_t v2 = 0;
              return v2 | v3;
            }
          }
        }
        else
        {
          switch(v5)
          {
            case 1285:
              unsigned int v3 = 2053;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2053))
              {
                uint64_t v2 = 0;
                return v2 | v3;
              }
              break;
            case 1286:
              unsigned int v3 = 2054;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2054))
              {
                uint64_t v2 = 0;
                return v2 | v3;
              }
              break;
            case 1298:
              unsigned int v3 = 2056;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
              {
                uint64_t v2 = 0;
                return v2 | v3;
              }
              break;
          }
        }
        goto LABEL_320;
      }
      switch(v5)
      {
        case 771:
          unsigned int v3 = 773;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 773)) {
            goto LABEL_308;
          }
          unsigned int v3 = 1797;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797) & 1) == 0) {
            goto LABEL_237;
          }
          uint64_t v2 = 0x4E00000000;
          return v2 | v3;
        case 772:
        case 776:
        case 777:
        case 778:
        case 779:
        case 780:
        case 781:
        case 782:
        case 783:
        case 788:
        case 789:
          goto LABEL_320;
        case 773:
          unsigned int v3 = 1797;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797) & 1) == 0) {
            goto LABEL_149;
          }
          goto LABEL_152;
        case 774:
          unsigned int v3 = 1798;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1798) & 1) == 0) {
            goto LABEL_250;
          }
LABEL_152:
          uint64_t v2 = 0x4D00000000;
          return v2 | v3;
        case 775:
          unsigned int v3 = 784;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 784))
          {
LABEL_280:
            uint64_t v2 = 0xA00000000;
          }
          else
          {
            unsigned int v3 = 785;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 785))
            {
LABEL_222:
              uint64_t v2 = 0xB00000000;
            }
            else
            {
              unsigned int v3 = 264;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0) {
                goto LABEL_320;
              }
              uint64_t v2 = 0x3F00000000;
            }
          }
          return v2 | v3;
        case 784:
          unsigned int v3 = 785;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 785)) {
            goto LABEL_211;
          }
          unsigned int v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0) {
            goto LABEL_320;
          }
          uint64_t v2 = 0x4000000000;
          return v2 | v3;
        case 785:
          unsigned int v3 = 784;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 784))
          {
LABEL_211:
            uint64_t v2 = 0x100000000;
          }
          else
          {
            unsigned int v3 = 264;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0) {
              goto LABEL_320;
            }
            uint64_t v2 = 0x4100000000;
          }
          break;
        case 786:
          unsigned int v3 = 2056;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
            goto LABEL_320;
          }
          uint64_t v2 = 0;
          return v2 | v3;
        case 787:
          unsigned int v3 = 2056;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
            goto LABEL_320;
          }
          uint64_t v2 = 0;
          return v2 | v3;
        case 790:
          unsigned int v3 = 2056;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
            goto LABEL_320;
          }
          uint64_t v2 = 0;
          return v2 | v3;
        default:
          if (v5 != 1042) {
            goto LABEL_320;
          }
          unsigned int v3 = 2056;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
            goto LABEL_320;
          }
          uint64_t v2 = 0;
          return v2 | v3;
      }
    }
    else
    {
      if (v5 > 531)
      {
        if (v5 == 532)
        {
LABEL_101:
          unsigned int v3 = 264;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264))
          {
            uint64_t v2 = 0;
            return v2 | v3;
          }
          goto LABEL_320;
        }
        if (v5 == 533)
        {
LABEL_103:
          unsigned int v3 = 264;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264))
          {
            uint64_t v2 = 0;
            return v2 | v3;
          }
          goto LABEL_320;
        }
        if (v5 != 535)
        {
LABEL_320:
          int v19 = ci_logger_render();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
            CI::format_swizzle_for_input(v5);
          }
LABEL_322:
          unsigned int v3 = 0;
          goto LABEL_323;
        }
        unsigned int v3 = 265;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 265) & 1) == 0)
        {
          uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 16);
LABEL_207:
          unsigned int v3 = 266;
          if (v7(a2, 266))
          {
            uint64_t v2 = 0x500000000;
            return v2 | v3;
          }
          unsigned int v3 = 264;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264))
          {
LABEL_282:
            uint64_t v2 = 0x600000000;
            return v2 | v3;
          }
          goto LABEL_320;
        }
LABEL_323:
        uint64_t v2 = 0;
        return v2 | v3;
      }
      switch(v5)
      {
        case 257:
          unsigned int v3 = 261;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 261) & 1) == 0)
          {
            unsigned int v3 = 259;
            char v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 259);
LABEL_51:
            if ((v6 & 1) == 0) {
              goto LABEL_320;
            }
          }
LABEL_52:
          uint64_t v2 = 0x1400000000;
          return v2 | v3;
        case 258:
          unsigned int v3 = 261;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 261) & 1) == 0)
          {
            unsigned int v3 = 259;
            char v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 259);
LABEL_265:
            if ((v9 & 1) == 0) {
              goto LABEL_320;
            }
          }
LABEL_266:
          uint64_t v2 = 0x800000000;
          return v2 | v3;
        case 259:
          unsigned int v3 = 261;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 261)) {
            goto LABEL_308;
          }
          unsigned int v3 = 257;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 257))
          {
LABEL_269:
            uint64_t v2 = 0x1A00000000;
            return v2 | v3;
          }
          unsigned int v3 = 258;
          char v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 258);
LABEL_307:
          if (v10) {
            goto LABEL_308;
          }
          goto LABEL_320;
        case 260:
          unsigned int v3 = 262;
          char v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262);
LABEL_195:
          if ((v11 & 1) == 0) {
            goto LABEL_320;
          }
LABEL_271:
          uint64_t v2 = 0x900000000;
          return v2 | v3;
        case 261:
          unsigned int v3 = 259;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 259)) {
            goto LABEL_311;
          }
          unsigned int v3 = 257;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 257))
          {
LABEL_274:
            uint64_t v2 = 0x1700000000;
            return v2 | v3;
          }
          unsigned int v3 = 258;
          char v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 258);
LABEL_310:
          if ((v12 & 1) == 0) {
            goto LABEL_320;
          }
LABEL_311:
          uint64_t v2 = 0x1600000000;
          return v2 | v3;
        case 262:
          unsigned int v3 = 260;
          char v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 260);
LABEL_201:
          if ((v13 & 1) == 0) {
            goto LABEL_320;
          }
LABEL_276:
          uint64_t v2 = 0x1800000000;
          return v2 | v3;
        case 263:
          unsigned int v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0) {
            goto LABEL_320;
          }
          uint64_t v2 = 0;
          return v2 | v3;
        case 264:
          unsigned int v3 = 266;
          char v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266);
          goto LABEL_210;
        case 265:
          uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 16);
          goto LABEL_207;
        case 266:
          unsigned int v3 = 264;
          char v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264);
LABEL_210:
          if (v14) {
            goto LABEL_211;
          }
          goto LABEL_320;
        case 267:
          unsigned int v3 = 266;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266))
          {
            uint64_t v2 = 0x300000000;
            return v2 | v3;
          }
          unsigned int v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0) {
            goto LABEL_320;
          }
          uint64_t v2 = 0x200000000;
          return v2 | v3;
        case 268:
          unsigned int v3 = 264;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264)) {
            goto LABEL_280;
          }
          unsigned int v3 = 266;
          char v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266);
          goto LABEL_221;
        case 269:
          unsigned int v3 = 265;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 265)) {
            goto LABEL_280;
          }
          unsigned int v3 = 266;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266))
          {
            uint64_t v2 = 0xD00000000;
            return v2 | v3;
          }
          unsigned int v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0) {
            goto LABEL_320;
          }
          uint64_t v2 = 0xE00000000;
          return v2 | v3;
        case 270:
          unsigned int v3 = 266;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266)) {
            goto LABEL_280;
          }
          unsigned int v3 = 264;
          char v15 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264);
LABEL_221:
          if (v15) {
            goto LABEL_222;
          }
          goto LABEL_320;
        case 271:
          unsigned int v3 = 267;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 267)) {
            goto LABEL_280;
          }
          unsigned int v3 = 266;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266))
          {
            uint64_t v2 = 0xC00000000;
            return v2 | v3;
          }
          unsigned int v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0) {
            goto LABEL_320;
          }
          uint64_t v2 = 0xF00000000;
          break;
        case 276:
          goto LABEL_101;
        case 277:
          goto LABEL_103;
        default:
          goto LABEL_320;
      }
    }
  }
  else
  {
    if (v5 > 2304)
    {
      if (v5 <= 3080)
      {
        if (v5 <= 2566)
        {
          switch(v5)
          {
            case 2305:
              unsigned int v3 = 2309;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2309)) {
                goto LABEL_52;
              }
              unsigned int v3 = 2307;
              char v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2307);
              goto LABEL_51;
            case 2306:
              unsigned int v3 = 2309;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2309)) {
                goto LABEL_266;
              }
              unsigned int v3 = 2307;
              char v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2307);
              goto LABEL_265;
            case 2307:
              unsigned int v3 = 2309;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2309)) {
                goto LABEL_308;
              }
              unsigned int v3 = 2305;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2305)) {
                goto LABEL_269;
              }
              unsigned int v3 = 2306;
              char v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2306);
              goto LABEL_307;
            case 2308:
              unsigned int v3 = 2310;
              char v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2310);
              goto LABEL_195;
            case 2309:
              unsigned int v3 = 2307;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2307)) {
                goto LABEL_311;
              }
              unsigned int v3 = 2305;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2305)) {
                goto LABEL_274;
              }
              unsigned int v3 = 2306;
              char v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2306);
              goto LABEL_310;
            case 2310:
              unsigned int v3 = 2308;
              char v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2308);
              goto LABEL_201;
            case 2311:
              unsigned int v3 = 2312;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2312))
              {
                uint64_t v2 = 0;
                return v2 | v3;
              }
              unsigned int v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
                goto LABEL_320;
              }
              uint64_t v2 = 0xA00000000;
              break;
            case 2312:
              unsigned int v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
                goto LABEL_320;
              }
              uint64_t v2 = 0;
              return v2 | v3;
            case 2313:
              unsigned int v3 = 2312;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2312)) {
                goto LABEL_282;
              }
              unsigned int v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
                goto LABEL_320;
              }
              uint64_t v2 = 0x600000000;
              return v2 | v3;
            case 2316:
              unsigned int v3 = 2312;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2312)) {
                goto LABEL_280;
              }
              unsigned int v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
                goto LABEL_320;
              }
              uint64_t v2 = 0xA00000000;
              return v2 | v3;
            default:
              goto LABEL_320;
          }
          return v2 | v3;
        }
        if (v5 > 2823)
        {
          if (v5 == 2824)
          {
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800))
            {
              unsigned int v17 = ci_logger_render();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
                CI::format_swizzle_for_input();
              }
              goto LABEL_322;
            }
          }
          else if (v5 == 3079)
          {
            unsigned int v3 = 785;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 785))
            {
              uint64_t v2 = 0x4900000000;
              return v2 | v3;
            }
            unsigned int v3 = 784;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 784))
            {
              uint64_t v2 = 0x4800000000;
              return v2 | v3;
            }
            unsigned int v3 = 264;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264))
            {
              uint64_t v2 = 0x4700000000;
              return v2 | v3;
            }
          }
        }
        else if (v5 == 2567)
        {
          unsigned int v3 = 785;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 785))
          {
            uint64_t v2 = 0x4400000000;
            return v2 | v3;
          }
          unsigned int v3 = 784;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 784))
          {
            uint64_t v2 = 0x4300000000;
            return v2 | v3;
          }
          unsigned int v3 = 264;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264))
          {
            uint64_t v2 = 0x4200000000;
            return v2 | v3;
          }
        }
        else if (v5 == 2569)
        {
          unsigned int v3 = 1800;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800))
          {
            uint64_t v2 = 0x4C00000000;
            return v2 | v3;
          }
          unsigned int v3 = 2056;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
          {
            uint64_t v2 = 0x4C00000000;
            return v2 | v3;
          }
        }
        goto LABEL_320;
      }
      if (v5 > 3349)
      {
        if (v5 <= 3605)
        {
          switch(v5)
          {
            case 3350:
              unsigned int v3 = 2056;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
              {
                uint64_t v2 = 0;
                return v2 | v3;
              }
              break;
            case 3602:
              unsigned int v3 = 2056;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
              {
                uint64_t v2 = 0;
                return v2 | v3;
              }
              break;
            case 3603:
              unsigned int v3 = 2056;
              if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
              {
                uint64_t v2 = 0;
                return v2 | v3;
              }
              break;
          }
        }
        else if (v5 > 3858)
        {
          if (v5 == 3859)
          {
            unsigned int v3 = 2056;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
            {
              uint64_t v2 = 0;
              return v2 | v3;
            }
          }
          else if (v5 == 3862)
          {
            unsigned int v3 = 2056;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
            {
              uint64_t v2 = 0;
              return v2 | v3;
            }
          }
        }
        else if (v5 == 3606)
        {
          unsigned int v3 = 2056;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
          {
            uint64_t v2 = 0;
            return v2 | v3;
          }
        }
        else if (v5 == 3858)
        {
          unsigned int v3 = 2056;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
          {
            uint64_t v2 = 0;
            return v2 | v3;
          }
        }
        goto LABEL_320;
      }
      if (v5 <= 3333)
      {
        switch(v5)
        {
          case 3081:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800))
            {
              unsigned __int16 v16 = ci_logger_render();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
                CI::format_swizzle_for_input();
              }
              goto LABEL_322;
            }
            break;
          case 3331:
            unsigned int v3 = 3333;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 3333) & 1) != 0
              || (unsigned int v3 = 1797, ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797) & 1) != 0))
            {
LABEL_308:
              uint64_t v2 = 0x1500000000;
              return v2 | v3;
            }
LABEL_237:
            unsigned int v3 = 262;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262))
            {
LABEL_238:
              uint64_t v2 = 0x1C00000000;
              return v2 | v3;
            }
            break;
          case 3333:
            unsigned int v3 = 1797;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797)) {
              goto LABEL_323;
            }
LABEL_149:
            unsigned int v3 = 262;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262))
            {
LABEL_150:
              uint64_t v2 = 0x1B00000000;
              return v2 | v3;
            }
            break;
        }
        goto LABEL_320;
      }
      if (v5 != 3334)
      {
        if (v5 == 3346)
        {
          unsigned int v3 = 2056;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
          {
            uint64_t v2 = 0;
            return v2 | v3;
          }
        }
        else if (v5 == 3347)
        {
          unsigned int v3 = 2056;
          if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056))
          {
            uint64_t v2 = 0;
            return v2 | v3;
          }
        }
        goto LABEL_320;
      }
      unsigned int v3 = 1798;
      if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1798) & 1) == 0)
      {
LABEL_250:
        unsigned int v3 = 264;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264))
        {
LABEL_251:
          uint64_t v2 = 0x2300000000;
          return v2 | v3;
        }
        goto LABEL_320;
      }
      goto LABEL_323;
    }
    switch(v5)
    {
      case 1793:
        unsigned int v3 = 1797;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797)) {
          goto LABEL_52;
        }
        unsigned int v3 = 1795;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1795)) {
          goto LABEL_52;
        }
        unsigned int v3 = 262;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262))
        {
          uint64_t v2 = 0x1D00000000;
          return v2 | v3;
        }
        unsigned int v3 = 260;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 260) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0x2100000000;
        return v2 | v3;
      case 1794:
        unsigned int v3 = 1797;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797)) {
          goto LABEL_266;
        }
        unsigned int v3 = 1795;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1795)) {
          goto LABEL_266;
        }
        unsigned int v3 = 262;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262))
        {
          uint64_t v2 = 0x1E00000000;
          return v2 | v3;
        }
        unsigned int v3 = 260;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 260) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0x2200000000;
        return v2 | v3;
      case 1795:
        unsigned int v3 = 1797;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797)) {
          goto LABEL_308;
        }
        unsigned int v3 = 1793;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1793)) {
          goto LABEL_269;
        }
        unsigned int v3 = 1794;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1794)) {
          goto LABEL_308;
        }
        unsigned int v3 = 262;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262)) {
          goto LABEL_238;
        }
        unsigned int v3 = 260;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 260) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0x2000000000;
        return v2 | v3;
      case 1796:
        unsigned int v3 = 1798;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1798)) {
          goto LABEL_271;
        }
        unsigned int v3 = 264;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264))
        {
          uint64_t v2 = 0x2400000000;
          return v2 | v3;
        }
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266)) {
          goto LABEL_320;
        }
        int v18 = ci_logger_render();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          CI::format_swizzle_for_input();
        }
        goto LABEL_322;
      case 1797:
        unsigned int v3 = 1795;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1795)) {
          goto LABEL_311;
        }
        unsigned int v3 = 1793;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1793)) {
          goto LABEL_274;
        }
        unsigned int v3 = 1794;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1794)) {
          goto LABEL_311;
        }
        unsigned int v3 = 262;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262)) {
          goto LABEL_150;
        }
        unsigned int v3 = 260;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 260) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0x1F00000000;
        return v2 | v3;
      case 1798:
        unsigned int v3 = 1796;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1796)) {
          goto LABEL_276;
        }
        unsigned int v3 = 264;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264)) {
          goto LABEL_251;
        }
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266)) {
          goto LABEL_320;
        }
        unint64_t v8 = ci_logger_render();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          CI::format_swizzle_for_input();
        }
        goto LABEL_322;
      case 1799:
        unsigned int v3 = 1800;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800))
        {
          uint64_t v2 = 0;
          return v2 | v3;
        }
        unsigned int v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0;
        break;
      case 1800:
        unsigned int v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0;
        return v2 | v3;
      case 1801:
        unsigned int v3 = 1800;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800)) {
          goto LABEL_282;
        }
        unsigned int v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0x600000000;
        return v2 | v3;
      case 1802:
      case 1803:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        goto LABEL_320;
      case 1804:
        unsigned int v3 = 1800;
        if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800)) {
          goto LABEL_280;
        }
        unsigned int v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0xA00000000;
        return v2 | v3;
      case 1810:
        unsigned int v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0;
        return v2 | v3;
      case 1811:
        unsigned int v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0;
        return v2 | v3;
      case 1814:
        unsigned int v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
          goto LABEL_320;
        }
        uint64_t v2 = 0;
        return v2 | v3;
      default:
        switch(v5)
        {
          case 2049:
            unsigned int v3 = 2053;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2053)) {
              goto LABEL_52;
            }
            unsigned int v3 = 2051;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2051)) {
              goto LABEL_52;
            }
            unsigned int v3 = 2050;
            char v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2050);
            goto LABEL_51;
          case 2050:
            unsigned int v3 = 2053;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2053)) {
              goto LABEL_266;
            }
            unsigned int v3 = 2051;
            char v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2051);
            goto LABEL_265;
          case 2051:
            unsigned int v3 = 2053;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2053)) {
              goto LABEL_308;
            }
            unsigned int v3 = 2049;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2049)) {
              goto LABEL_269;
            }
            unsigned int v3 = 2050;
            char v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2050);
            goto LABEL_307;
          case 2052:
            unsigned int v3 = 2054;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2054)) {
              goto LABEL_271;
            }
            unsigned int v3 = 2310;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2310) & 1) == 0) {
              goto LABEL_320;
            }
            uint64_t v2 = 0x900000000;
            return v2 | v3;
          case 2053:
            unsigned int v3 = 2051;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2051)) {
              goto LABEL_311;
            }
            unsigned int v3 = 2049;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2049)) {
              goto LABEL_274;
            }
            unsigned int v3 = 2050;
            char v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2050);
            goto LABEL_310;
          case 2054:
            unsigned int v3 = 2052;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2052)) {
              goto LABEL_276;
            }
            unsigned int v3 = 2310;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2310) & 1) == 0) {
              goto LABEL_320;
            }
            uint64_t v2 = 0;
            return v2 | v3;
          case 2055:
            unsigned int v3 = 2056;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0) {
              goto LABEL_320;
            }
            uint64_t v2 = 0;
            return v2 | v3;
          case 2060:
            unsigned int v3 = 2056;
            if ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056)) {
              goto LABEL_280;
            }
            goto LABEL_320;
          default:
            goto LABEL_320;
        }
    }
  }
  return v2 | v3;
}

uint64_t ___ZNK2CI7Context18swizzler_for_inputENS_11PixelFormatE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 424))();
}

void CI::SurfaceNode::SurfaceNode(CI::Node *a1)
{
}

{
  CI::SurfaceNode::SurfaceNode(a1);
}

void sub_19369FDA8(_Unwind_Exception *a1)
{
  *((void *)v1 + 5) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::Node::~Node(v1);
  _Unwind_Resume(a1);
}

CI::Object *CI::ConvertNode::append_to_tree(CI::Object *this, int a2)
{
  uint64_t v2 = this;
  if (a2)
  {
    if ((*(unsigned int (**)(CI::Object *))(*(void *)this + 16))(this) != 42
      || ((int v4 = (*(uint64_t (**)(CI::Object *))(*(void *)v2 + 424))(v2), a2 != 25) || v4 != 26)
      && (a2 != 27 || v4 != 28)
      && (a2 != 6 || v4 != 5)
      && (a2 != 5 || v4 != 6)
      && (a2 != 23 || v4 != 24)
      && (a2 != 24 || v4 != 23)
      && (a2 != 20 || v4 != 19)
      && (a2 != 22 || v4 != 21)
      && (a2 != 15 || v4 != 16)
      && (a2 != 16 || v4 != 15)
      && (a2 != 12 || v4 != 11)
      && (a2 != 14 || v4 != 13))
    {
      if ((*(int (**)(CI::Object *))(*(void *)v2 + 16))(v2) >= 41) {
        (*(void (**)(CI::Object *))(*(void *)v2 + 16))(v2);
      }
      operator new();
    }
    uint64_t v5 = (*(uint64_t (**)(CI::Object *, void))(*(void *)v2 + 48))(v2, 0);
    uint64_t v2 = (CI::Object *)v5;
    if (v5) {
      CI::Object::ref(v5);
    }
    return v2;
  }
  if (!this) {
    return v2;
  }

  return (CI::Object *)CI::Object::ref((uint64_t)this);
}

uint64_t CI::NodeWithChild::output_is_luma(CI::NodeWithChild *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 288))();
}

BOOL CI::SwizzleNode::output_is_luma(CI::SwizzleNode *this)
{
  int v1 = *((_DWORD *)this + 14);
  return v1 == 21 || v1 == 26;
}

uint64_t CI::MetalContext::supports_sample_mode(uint64_t a1, int a2, int a3)
{
  if (a2 == 1) {
    return CI::format_is_full_float(a3) ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t CI::format_is_full_float(int a1)
{
  return ((a1 - 2305) < 0xC) & (0x9FFu >> (a1 - 1));
}

void sub_1936A038C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C407DA4F8A2);
  _Unwind_Resume(a1);
}

CI::CropImage *CI::CropImage::CropImage(CI::CropImage *this, CI::Image *a2, CGRect a3)
{
  double height = a3.size.height;
  double width = a3.size.width;
  double y = a3.origin.y;
  double x = a3.origin.x;
  char v9 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v9 + 14) = &unk_1EE45B188;
  atomic_fetch_add(&dword_1EB466E78[4], 1u);
  *(void *)char v9 = &unk_1EE45EE18;
  *((void *)v9 + 14) = &unk_1EE45EF70;
  *((double *)v9 + 15) = x;
  *((double *)v9 + 16) = y;
  *((double *)v9 + 17) = width;
  *((double *)v9 + 18) = height;
  *((void *)this + 10) = CI::CropImage::makeDigest(*((void *)a2 + 10), x, y, width, height);
  *((void *)this + 11) = CI::CropImage::makeDigest(*((void *)a2 + 11), x, y, width, height);
  return this;
}

void sub_1936A04B4(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::CropImage::makeDigest(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(double *)unint64_t v8 = a2;
  *(double *)&v8[1] = a3;
  *(double *)&void v8[2] = a4;
  *(double *)&v8[3] = a5;
  XXH64_reset(v7, 0);
  LODWORD(__src) = 6;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  uint64_t __src = a1;
  XXH64_update((uint64_t)v7, (char *)&__src, 8uLL);
  XXH64_update((uint64_t)v7, (char *)v8, 0x20uLL);
  return XXH64_digest((uint64_t)v7);
}

uint64_t CI::image_render_to_bitmap(CI *this, CI::Context *a2, CI::Image *a3, CGRect a4, CGColorSpace *a5, CI::Bitmap *a6, const CI::RenderDestination *a7)
{
  CGFloat height = a4.size.height;
  CGFloat width = a4.size.width;
  double y = a4.origin.y;
  double x = a4.origin.x;
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  CFAbsoluteTimeGetCurrent();
  v51.a = 1.0;
  v51.b = 0.0;
  v51.c = 0.0;
  v51.d = 1.0;
  v51.tdouble x = -x;
  v51.tdouble y = -y;
  v56.origin.double x = x;
  v56.origin.double y = y;
  v56.size.CGFloat width = width;
  v56.size.CGFloat height = height;
  CGRect v57 = CGRectApplyAffineTransform(v56, &v51);
  double v37 = v57.origin.y;
  double v38 = v57.origin.x;
  double v39 = v57.size.width;
  double v41 = v57.size.height;
  v65.origin.double x = (*(double (**)(CI::Context *))(*(void *)a2 + 88))(a2);
  v65.origin.double y = v15;
  v65.size.CGFloat width = v16;
  v65.size.CGFloat height = v17;
  v58.origin.double x = x;
  v58.origin.double y = y;
  v58.size.CGFloat width = width;
  v58.size.CGFloat height = height;
  CGRect v59 = CGRectIntersection(v58, v65);
  v50.a = 1.0;
  v50.b = 0.0;
  v50.c = 0.0;
  v50.d = 1.0;
  v50.tdouble x = -x;
  v50.tdouble y = -y;
  CGRect v60 = CGRectApplyAffineTransform(v59, &v50);
  double v18 = v60.origin.x;
  double v19 = v60.origin.y;
  double v20 = v60.size.width;
  double v21 = v60.size.height;
  if (!CGRectIsEmpty(v60))
  {
    v61.origin.double x = v18;
    v61.origin.double y = v19;
    v61.size.CGFloat width = v20;
    v61.size.CGFloat height = v21;
    if (!CGRectIsNull(v61))
    {
      v62.origin.double x = v18;
      v62.origin.double y = v19;
      v62.size.CGFloat width = v20;
      v62.size.CGFloat height = v21;
      if (!CGRectIsInfinite(v62))
      {
        float v22 = v19 - v37;
        float v23 = v41 + v37 - (v19 + v21);
        float v24 = v18 - v38;
        float v25 = v39 + v38 - (v18 + v20);
        int v26 = vcvtps_s32_f32(v22);
        int v27 = vcvtps_s32_f32(v23);
        signed int v28 = vcvtps_s32_f32(v24);
        int v29 = vcvtps_s32_f32(v25);
        CI::clearBitmap(a5, (const CI::Bitmap *)v39, v26, (int)v38, (int)v37);
        CI::clearBitmap(a5, (const CI::Bitmap *)v28, (unint64_t)(v41 - (double)(v27 + v26)), (int)v38, v26);
        CI::clearBitmap(a5, (const CI::Bitmap *)v29, (unint64_t)(v41 - (double)(v27 + v26)), (int)(v39 - (double)v29), v26);
        CI::clearBitmap(a5, (const CI::Bitmap *)v39, v27, (int)v38, (int)(v41 - (double)v27));
      }
    }
  }
  unsigned int v30 = *((_DWORD *)a5 + 26);
  CI::Context::swizzler_for_output((uint64_t)this, v30, 0, &v47);
  __int32 v45 = v47.i32[0];
  __int16 v46 = 0;
  v44.a = 1.0 / (double)(unint64_t)v48;
  v44.b = 0.0;
  v44.c = 0.0;
  v44.tdouble x = 0.0;
  v44.tdouble y = 0.0;
  v44.d = 1.0;
  v63.origin.double x = x;
  v63.origin.double y = y;
  v63.size.CGFloat width = width;
  v63.size.CGFloat height = height;
  CGRect v64 = CGRectApplyAffineTransform(v63, &v44);
  CGFloat v31 = v64.origin.x;
  CGFloat v32 = v64.origin.y;
  v43[0] = v47;
  v43[1] = v48;
  v43[2] = v49;
  buf.origin.double x = 1.0;
  buf.origin.double y = 0.0;
  buf.size.CGFloat width = 0.0;
  buf.size.CGFloat height = 1.0;
  uint64_t v54 = 0;
  uint64_t v53 = 0;
  CGFloat v40 = v64.size.width;
  CGFloat v42 = v64.size.height;
  uint64_t v33 = CI::prepare_initial_graph((uint64_t *)this, "get_bitmap", (unsigned int *)a2, (uint64_t)a6, 0, v30, (uint64_t)v43, (char *)&buf, v64.origin.x, v64.origin.y, v64.size.width, v64.size.height, 1u, (uint64_t)&v45);
  if (v33)
  {
    v35.f64[0] = v40;
    v35.f64[1] = v42;
    buf.origin.double x = v31;
    buf.origin.double y = v32;
    buf.size_t size = (CGSize)vcvtq_f64_f32(vrndp_f32(vcvt_f32_f64(v35)));
    CI::tile_node_graph((uint64_t)this, (uint64_t)a6, (uint64_t)"get_bitmap", (uint64_t)v33, v34, &buf);
  }
  return 0;
}

void CI::clearBitmap(CI *this, const CI::Bitmap *a2, uint64_t a3, int a4, int a5)
{
  if (((a5 | a4) & 0x80000000) == 0
    && (unint64_t)a2 + a4 <= *((void *)this + 10)
    && a3 * (void)a2
    && (unint64_t)(a3 + a5) <= *((void *)this + 11)
    && (CI::format_is_ycc(*((_DWORD *)this + 26)) & 1) == 0)
  {
    uint64_t v11 = *((void *)this + 9);
    uint64_t v24 = *((void *)this + 12);
    int v12 = CI::format_bytes_per_pixel(*((_DWORD *)this + 26));
    uint64_t v13 = *((void *)this + 11);
    uint64_t v14 = *((void *)this + 12);
    uint64_t v15 = *((void *)this + 9);
    uint64_t v23 = *((void *)this + 10);
    int v16 = CI::format_bytes_per_pixel(*((_DWORD *)this + 26));
    if (a3)
    {
      uint64_t v17 = v11;
      uint64_t v18 = 0;
      uint64_t v19 = v17 + v24 * a5 + v12 * a4;
      unint64_t v20 = v15 + (v13 - 1) * v14 + v23 * v16 + 1;
      do
      {
        double v21 = (void *)(v19 + *((void *)this + 12) * v18);
        size_t v22 = (int)CI::format_bytes_per_pixel(*((_DWORD *)this + 26)) * (void)a2;
        if ((unint64_t)v21 + v22 >= v20) {
          break;
        }
        bzero(v21, v22);
        ++v18;
      }
      while (a3 != v18);
    }
  }
}

const CI::Context *CI::prepare_initial_graph(uint64_t *a1, const char *a2, unsigned int *a3, uint64_t a4, CGColorSpace *a5, int a6, uint64_t a7, char *a8, CGFloat a9, CGFloat a10, CGFloat a11, CGFloat a12, unsigned __int8 a13, uint64_t a14)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  v59.origin.double x = a9;
  v59.origin.double y = a10;
  v59.size.CGFloat width = a11;
  v59.size.CGFloat height = a12;
  v58[1] = 0;
  v58[0] = 0;
  CGRect v57 = (uint64_t *)v58;
  if (!CI_CACHE_PROGRAM_GRAPH()) {
    goto LABEL_11;
  }
  double v21 = ci_signpost_log_render();
  os_signpost_id_t v22 = (*(uint64_t (**)(uint64_t *))(*a1 + 272))(a1) << 32;
  if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v21))
  {
    *(_WORD *)CGRect buf = 0;
    _os_signpost_emit_with_name_impl(&dword_193671000, v21, OS_SIGNPOST_INTERVAL_BEGIN, v22, "traverse_gathering_digests", "", buf, 2u);
  }
  uint64_t v23 = (*(uint64_t (**)(uint64_t *))(*a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)buf, v23, 0, (uint64_t)"traverse_gathering_digests", 34);
  uint64_t v60 = MEMORY[0x1E4F143A8];
  uint64_t v61 = 0x40000000;
  CGRect v62 = ___ZN2CIL26traverse_gathering_digestsEPKNS_7ContextEPNS_5ImageERNSt3__13mapINS_10ImageIndexENS_30ImageDigestForRenderGraphCacheENS5_4lessIS7_EENS5_9allocatorINS5_4pairIKS7_S8_EEEEEE_block_invoke;
  CGRect v63 = &__block_descriptor_tmp_45;
  CGRect v64 = (uint8_t *)&v57;
  *(void *)uint64_t __src = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t __src[8] = 0x40000000;
  CGRect v66 = ___ZNK2CI5Image15traverse_uniqueEU13block_pointerFvPKS0_iE_block_invoke;
  CGRect v67 = &unk_1E5776528;
  CGRect v68 = (uint64_t **)&v60;
  CI::GraphObject::traverse_unique((uint64_t)a3, (uint64_t)__src);
  uint64_t v24 = ci_signpost_log_render();
  os_signpost_id_t v25 = *(void *)&buf[8];
  if ((unint64_t)(*(void *)&buf[8] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int v26 = v24;
    if (os_signpost_enabled(v24))
    {
      *(_WORD *)uint64_t __src = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v26, OS_SIGNPOST_INTERVAL_END, v25, "traverse_gathering_digests", "", __src, 2u);
    }
  }
  TimerBase::~TimerBase((TimerBase *)buf);
  *(void *)CGRect buf = a3 + 25;
  int v27 = std::__tree<std::__value_type<CI::NodeIndex,unsigned long>,std::__map_value_compare<CI::NodeIndex,std::__value_type<CI::NodeIndex,unsigned long>,std::less<CI::NodeIndex>,true>,std::allocator<std::__value_type<CI::NodeIndex,unsigned long>>>::__emplace_unique_key_args<CI::NodeIndex,std::piecewise_construct_t const&,std::tuple<CI::NodeIndex const&>,std::tuple<>>(&v57, a3 + 25, (uint64_t)&std::piecewise_construct, (_DWORD **)buf)[5];
  XXH64_reset((int64x2_t *)buf, 0);
  *(void *)uint64_t __src = v27;
  XXH64_update((uint64_t)buf, (char *)__src, 8uLL);
  XXH64_update((uint64_t)buf, (char *)&v59, 0x20uLL);
  CI::XXHashHelper::add((CI::XXHashHelper *)buf, a5);
  *(_DWORD *)uint64_t __src = a6;
  XXH64_update((uint64_t)buf, (char *)__src, 4uLL);
  *(_DWORD *)uint64_t __src = *(_DWORD *)(a7 + 8);
  XXH64_update((uint64_t)buf, (char *)__src, 4uLL);
  XXH64_update((uint64_t)buf, a8, 0x30uLL);
  *(_DWORD *)uint64_t __src = a13;
  XXH64_update((uint64_t)buf, (char *)__src, 4uLL);
  unint64_t v28 = XXH64_digest((uint64_t)buf);
  uint64_t v29 = CI::ObjectCache<CI::Node,unsigned long long,false>::find(a1[39], v28);
  if (!v29)
  {
LABEL_11:
    uint64_t v33 = ci_signpost_log_render();
    os_signpost_id_t v34 = (*(uint64_t (**)(uint64_t *))(*a1 + 272))(a1) << 32;
    if (v34 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v33))
    {
      *(_WORD *)CGRect buf = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v33, OS_SIGNPOST_INTERVAL_BEGIN, v34, "prepare_initial_graph", "", buf, 2u);
    }
    uint64_t v35 = (*(uint64_t (**)(uint64_t *))(*a1 + 272))(a1);
    TimerBase::TimerBase((uint64_t)v56, v35, 0, (uint64_t)"prepare_initial_graph", 1);
    if (CI_DEBUG_CONTEXT_COLOR())
    {
      long long v80 = 0u;
      long long v79 = 0u;
      uint64_t v77 = 0;
      long long v76 = 0u;
      long long v75 = 0u;
      long long v74 = 0u;
      long long v73 = 0u;
      long long v72 = 0u;
      long long v71 = 0u;
      *(_OWORD *)CGRect buf = 0u;
      uint64_t v78 = 0x3FF0000000000000;
      int v37 = CI_DEBUG_CONTEXT_COLOR();
      int v38 = (*(uint64_t (**)(uint64_t *))(*a1 + 16))(a1);
      double v39 = 0.0;
      if (v38 == 77) {
        double v39 = 1.0;
      }
      if (v37 == 2)
      {
        *(double *)&long long v79 = v39;
        uint64_t v40 = 4;
        uint64_t v41 = 4;
      }
      else
      {
        *(double *)CGRect buf = v39;
        uint64_t v41 = 2;
        uint64_t v40 = 1;
      }
      if ((*(unsigned int (**)(uint64_t *))(*a1 + 16))(a1) == 76) {
        double v42 = 1.0;
      }
      else {
        double v42 = 0.0;
      }
      *(double *)&buf[32 * v40 + 8] = v42;
      if ((*(unsigned int (**)(uint64_t *))(*a1 + 16))(a1) == 74) {
        double v43 = 1.0;
      }
      else {
        double v43 = 0.0;
      }
      *(double *)&buf[32 * v41 + 16] = v43;
      operator new();
    }
    if (!a4)
    {
      if (!CI_NO_CM() && (CI::format_only_alpha(a6) & 1) == 0)
      {
        CGAffineTransform v50 = (CGColorSpace *)(*(uint64_t (**)(unsigned int *))(*(void *)a3 + 248))(a3);
        unsigned int v52 = CI::ColorSpace_is_HDR(v50, v51);
        if (!a5
          || !v52
          || (CI::ColorSpace_is_HDR(a5, v53) & 1) != 0
          || CGColorSpaceUsesExtendedRange(a5))
        {
          operator new();
        }
        operator new();
      }
      if (a6 == 3079 || a6 == 2567) {
LABEL_33:
      }
        operator new();
      if ((CI::format_only_alpha(a6) & 1) == 0
        && ((*(uint64_t (**)(unsigned int *))(*(void *)a3 + 128))(a3) & 1) == 0)
      {
        int has_alpha = CI::format_has_alpha(a6);
        if (a6 && !has_alpha) {
          goto LABEL_33;
        }
        if (!*((unsigned char *)a1 + 40) || CI::format_has_unpremul_alpha(a6)) {
          operator new();
        }
        if ((CI::format_is_float(a6) & 1) == 0 && *((unsigned char *)a1 + 41)) {
          operator new();
        }
      }
    }
    int v47 = *(_DWORD *)(a7 + 8);
    if (v47)
    {
      if (*(void *)(a7 + 16) > 1uLL || *(void *)(a7 + 24) >= 2uLL)
      {
        CI::Kernel::builtin(v47);
        double v48 = (double)*(unint64_t *)(a7 + 24);
        *(double *)CGRect buf = (double)*(unint64_t *)(a7 + 16);
        *(void *)&long long v71 = 0;
        *(void *)&uint8_t buf[8] = 0;
        *((double *)&v71 + 1) = v48;
        long long v72 = 0uLL;
        operator new();
      }
      operator new();
    }
    if (a6 > 529)
    {
      if (a6 != 534 && a6 != 530) {
LABEL_65:
      }
        CI::Image::BuildMapToUnionRoi((CI::Image *)a3, v36, v59);
    }
    else if (a6 != 274 && a6 != 278)
    {
      goto LABEL_65;
    }
    operator new();
  }
  uint64_t v30 = v29;
  uint64_t v31 = (*(uint64_t (**)(uint64_t, void))(*(void *)v29 + 48))(v29, 0);
  if (v31) {
    CGFloat v32 = (const CI::Context *)CI::Object::ref(v31);
  }
  else {
    CGFloat v32 = 0;
  }
  if (a14)
  {
    int v44 = *(_DWORD *)(v30 + 104);
    *(_WORD *)(a14 + 4) = *(_WORD *)(v30 + 108);
    *(_DWORD *)a14 = v44;
  }
  *(void *)uint64_t __src = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t __src[8] = 0x40000000;
  CGRect v66 = ___ZN2CIL28traverse_restoring_resourcesERKNSt3__13mapINS_10ImageIndexENS_30ImageDigestForRenderGraphCacheENS0_4lessIS2_EENS0_9allocatorINS0_4pairIKS2_S3_EEEEEERKNS_14ImageToNodeMapEPNS_5ImageE_block_invoke;
  CGRect v67 = &__block_descriptor_tmp_55;
  CGRect v68 = &v57;
  uint64_t v69 = v30 + 56;
  uint64_t v60 = MEMORY[0x1E4F143A8];
  uint64_t v61 = 0x40000000;
  CGRect v62 = ___ZNK2CI5Image15traverse_uniqueEU13block_pointerFvPKS0_E_block_invoke;
  CGRect v63 = &unk_1E57765F0;
  CGRect v64 = __src;
  CI::GraphObject::traverse_unique((uint64_t)a3, (uint64_t)&v60);
  CI::traverse_node_graph_gathering_digests((CI *)a1, v32, v45);
  CI::Object::unref((CI::Object *)v30);
  (*(void (**)(unsigned int *))(*(void *)a3 + 88))(a3);
  if (CI::print_tree_enabled(2, (uint64_t)a1))
  {
    if (!strcmp(a2, "get_bitmap")) {
      __int16 v46 = "get_bitmap_cacheHit";
    }
    else {
      __int16 v46 = a2;
    }
    if (!strcmp(a2, "render_to_surface")) {
      __int16 v46 = "render_to_surface_cacheHit";
    }
    if (!strcmp(a2, "create_cgimage_check")) {
      __int16 v46 = "create_cgimage_check_cacheHit";
    }
    if (!strcmp(a2, "render_to_display")) {
      __int16 v46 = "render_to_display_cacheHit";
    }
    if (!strcmp(a2, "render_to_texture")) {
      __int16 v46 = "render_to_texture_cacheHit";
    }
    if (CI_PRINT_TREE_graphviz()) {
      CI::dump_optimized_graph((uint64_t)a1, a4, (uint64_t)v46, v32, &v59, a6);
    }
    else {
      CI::print_optimized_graph((uint64_t)a1, a4, (uint64_t)v46, (uint64_t)v32, (uint64_t)&v59, a6);
    }
  }
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v57, v58[0]);
  return v32;
}

CI::AffineNode *CI::AffineImage::render_graph_core(uint64_t a1, const CI::Affine *a2, CI::Object *this)
{
  if (this) {
    uint64_t v5 = (CI::AffineNode *)CI::Object::ref((uint64_t)this);
  }
  else {
    uint64_t v5 = 0;
  }
  if ((*(unsigned int (**)(CI::AffineNode *))(*(void *)v5 + 16))(v5) == 35) {
    return v5;
  }
  if (a2) {
    unsigned int v7 = (*(uint64_t (**)(const CI::Affine *))(*(void *)a2 + 216))(a2);
  }
  else {
    unsigned int v7 = 0;
  }
  int v8 = *(unsigned __int8 *)(a1 + 168);
  if (v8 == 110) {
    unsigned int v9 = 0;
  }
  else {
    unsigned int v9 = v7;
  }
  if (v8 == 121) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = v9;
  }
  uint64_t v11 = CI::AffineNode::append_to_tree_with_quality(v5, (float64x2_t *)(a1 + 120), a2, (CI::Context *)v10);
  CI::Object::unref(v5);
  return v11;
}

uint64_t CI::AffineNode::append_to_tree(CI::AffineNode *this, CI::Node *a2, const CI::Affine *a3)
{
  char v3 = (char)a3;
  if (!CI::Affine::isIdentity(a2) || (v3 & 1) != 0)
  {
    if (*(unsigned int (**)(CI::AffineNode *))(*(void *)this + 16))(this) != 35 || (v3)
    {
      if ((*(unsigned int (**)(CI::AffineNode *))(*(void *)this + 16))(this) != 28) {
        operator new();
      }
      CI::Affine::operator*((double *)this + 7, (double *)a2, (double *)&v8);
      if (!CI::Affine::isNearIdentity((CI::Affine *)&v8, 0.00001) || (v3 & 1) != 0) {
        operator new();
      }
      uint64_t v6 = *((void *)this + 5);
      if (v6) {
        CI::Object::ref(*((void *)this + 5));
      }
      return v6;
    }
  }
  else if (!this)
  {
    return 0;
  }

  return CI::Object::ref((uint64_t)this);
}

uint64_t CI::Context::downsampleQuality(CI::Context *this)
{
  return *((unsigned __int8 *)this + 60);
}

CI::AffineNode *CI::AffineNode::append_to_tree_with_quality(CI::AffineNode *this, float64x2_t *a2, const CI::Affine *a3, CI::Context *a4)
{
  int v4 = (int)a4;
  if (CI::Affine::isIdentity((CI::Affine *)a2))
  {
    if (!this) {
      return this;
    }
    return (CI::AffineNode *)CI::Object::ref((uint64_t)this);
  }
  double v8 = hypot(a2->f64[0], a2->f64[1]);
  if (hypot(a2[1].f64[0], a2[1].f64[1]) >= 1.0 && v8 >= 1.0 || v4 == 0)
  {
    return (CI::AffineNode *)CI::AffineNode::append_to_tree(this, (CI::Node *)a2, 0);
  }
  float64x2_t v11 = a2[1];
  float64x2_t v42 = *a2;
  float64x2_t v43 = v11;
  float64x2_t v44 = a2[2];
  double v12 = v42.f64[1];
  double v13 = v42.f64[0];
  double v14 = v11.f64[1];
  double v15 = v11.f64[0];
  double v16 = v44.f64[1];
  double v17 = v44.f64[0];
  while (1)
  {
    if ((*(unsigned int (**)(CI::AffineNode *))(*(void *)this + 16))(this) == 28)
    {
      double v18 = *((double *)this + 7);
      double v19 = *((double *)this + 8);
      double v20 = v19 * v15;
      double v21 = *((double *)this + 9);
      double v22 = *((double *)this + 10);
      double v23 = *((double *)this + 11);
      double v24 = *((double *)this + 12);
      double v25 = v15 * v24;
      double v15 = v15 * v22 + v21 * v13;
      double v26 = v25 + v23 * v13;
      double v13 = v20 + v18 * v13;
      double v27 = v19 * v14;
      double v28 = v14 * v22;
      double v29 = v14 * v24;
      double v14 = v28 + v21 * v12;
      double v30 = v29 + v23 * v12;
      double v12 = v27 + v18 * v12;
      double v17 = v17 + v26;
      double v16 = v30 + v16;
      v43.f64[0] = v15;
      v43.f64[1] = v14;
      v44.f64[0] = v17;
      v44.f64[1] = v16;
      goto LABEL_21;
    }
    if ((*(unsigned int (**)(CI::AffineNode *))(*(void *)this + 16))(this) != 39
      || (*(unsigned int (**)(CI::AffineNode *))(*(void *)this + 408))(this) != 4)
    {
      break;
    }
LABEL_21:
    this = (CI::AffineNode *)(*(uint64_t (**)(CI::AffineNode *, void))(*(void *)this + 48))(this, 0);
  }
  v42.f64[0] = v13;
  v42.f64[1] = v12;
  if (v13 == 1.0 && v12 == 0.0 && v15 == 0.0 && v14 == 1.0 && v17 == 0.0 && v16 == 0.0)
  {
    CI::Object::ref((uint64_t)this);
  }
  else
  {
    long double v31 = hypot(v13, v12);
    long double v32 = hypot(v15, v14);
    double v33 = fmax(floor(-0.2 - log2(v31)), 0.0);
    double v34 = fmax(floor(-0.2 - log2(v32)), 0.0);
    uint64_t v35 = (CI::AffineNode *)CI::Object::ref((uint64_t)this);
    if (v33 != 0.0 && v34 != 0.0)
    {
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      uint64_t v36 = 0x3FE0000000000000;
      uint64_t v39 = 0x3FE0000000000000;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      CI::AffineNode::append_to_tree(v35, (CI::Node *)&v36, 0);
      if (v35) {
        CI::Object::unref(v35);
      }
      v42.f64[0] = v13 + v13;
      v42.f64[1] = v12 + v12;
      v43.f64[0] = v15 + v15;
      v43.f64[1] = v14 + v14;
      CI::NoopNode::append_to_tree_and_unref();
    }
    if (v33 != 0.0)
    {
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      uint64_t v36 = 0x3FE0000000000000;
      uint64_t v39 = 0x3FF0000000000000;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      CI::AffineNode::append_to_tree(v35, (CI::Node *)&v36, 0);
      if (v35) {
        CI::Object::unref(v35);
      }
      float64x2_t v42 = vaddq_f64(v42, v42);
      CI::NoopNode::append_to_tree_and_unref();
    }
    if (v34 != 0.0)
    {
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      uint64_t v36 = 0x3FF0000000000000;
      uint64_t v39 = 0x3FE0000000000000;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      CI::AffineNode::append_to_tree(v35, (CI::Node *)&v36, 0);
      if (v35) {
        CI::Object::unref(v35);
      }
      float64x2_t v43 = vaddq_f64(v43, v43);
      CI::NoopNode::append_to_tree_and_unref();
    }
    this = (CI::AffineNode *)CI::AffineNode::append_to_tree(v35, (CI::Node *)&v42, 0);
    if (v35) {
      CI::Object::unref(v35);
    }
  }
  return this;
}

BOOL CI::print_tree_enabled(int a1, uint64_t a2)
{
  if ((CI_PRINT_TREE() & a1) == 0) {
    return 0;
  }
  int v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 272))(a2);
  BOOL result = CI_PRINT_TREE_context(v3, (char *)(a2 + 236));
  if (!result) {
    return result;
  }
  return !CI_PRINT_TREE_frame() || *(void *)(a2 + 152) == (int)CI_PRINT_TREE_frame();
}

uint64_t CI_PRINT_TREE()
{
  if (CI_PRINT_TREE::didCheck != -1) {
    dispatch_once(&CI_PRINT_TREE::didCheck, &__block_literal_global_29_0);
  }
  return CI_PRINT_TREE::v;
}

uint64_t CI::ObjectCache<CI::Node,unsigned long long,false>::find(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI11ObjectCacheINS_4NodeEyLb0EE4findEy_block_invoke;
  block[3] = &unk_1E5776880;
  void block[5] = a1;
  void block[6] = a2;
  void block[4] = &v5;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 56), block);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL CI::MetalContext::supports_sRGB_texture_for_format(id *this, int a2, int a3)
{
  int v3 = a2 - 261;
  if ((a2 - 261) > 5 || ((0x2Bu >> v3) & 1) == 0) {
    return 0;
  }
  unsigned int v5 = dword_193959510[v3];
  if (a3 != 1)
  {
    if (a3 == 2 || a3 == 3 && CI::MetalContext::formatIsReadable(this, dword_193959510[v3]))
    {
      return CI::MetalContext::formatIsWritable(this, v5);
    }
    return 0;
  }
  unsigned int v7 = dword_193959510[v3];

  return CI::MetalContext::formatIsReadable(this, v7);
}

uint64_t *std::map<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>,std::__tree_node<std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>,void *> *,long>>>(uint64_t *result, unsigned int *a2, unsigned int *a3)
{
  if (a2 != a3)
  {
    int v4 = a2;
    unsigned int v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      BOOL result = std::__tree<std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>,std::__map_value_compare<CI::ImageIndex,std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>,std::less<CI::ImageIndex>,true>,std::allocator<std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>>>::__emplace_hint_unique_key_args<CI::ImageIndex,std::pair<CI::ImageIndex const,CI::ImageDigestForRenderGraphCache> const&>(v5, v6, v4 + 8, (_OWORD *)v4 + 2);
      unsigned int v7 = (unsigned int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          unsigned int v7 = *(unsigned int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (unsigned int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          int v4 = v8;
        }
        while (!v9);
      }
      int v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>,std::__map_value_compare<CI::ImageIndex,std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>,std::less<CI::ImageIndex>,true>,std::allocator<std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>>>::__emplace_hint_unique_key_args<CI::ImageIndex,std::pair<CI::ImageIndex const,CI::ImageDigestForRenderGraphCache> const&>(uint64_t **a1, uint64_t *a2, unsigned int *a3, _OWORD *a4)
{
  uint64_t v6 = std::__tree<std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>,std::__map_value_compare<CI::ImageIndex,std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>,std::less<CI::ImageIndex>,true>,std::allocator<std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>>>::__find_equal<CI::ImageIndex>(a1, a2, &v11, &v10, a3);
  unsigned int v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    unsigned int v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>,std::__map_value_compare<CI::ImageIndex,std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>,std::less<CI::ImageIndex>,true>,std::allocator<std::__value_type<CI::ImageIndex,CI::ImageDigestForRenderGraphCache>>>::__find_equal<CI::ImageIndex>(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  unsigned int v5 = a1 + 1;
  if (a1 + 1 == a2 || (unsigned int v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      BOOL v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      double v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        double v13 = v10;
      }
      while (v14);
    }
    unsigned int v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          double v17 = (uint64_t *)v16;
          unsigned int v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          unsigned int v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        unsigned int v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      double v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    double v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      double v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    double v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      double v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          double v21 = (uint64_t *)v20;
          unsigned int v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          unsigned int v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        unsigned int v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      double v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t CI::traverse_node_graph_gathering_digests(CI *this, const CI::Context *a2, CI::Node *a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZN2CIL37traverse_node_graph_gathering_digestsEPKNS_7ContextEPNS_4NodeE_block_invoke;
  v4[3] = &__block_descriptor_tmp_56_0;
  v4[4] = this;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = ___ZN2CI4Node15traverse_uniqueEU13block_pointerFvPS0_E_block_invoke;
  v5[3] = &unk_1E57764E0;
  v5[4] = v4;
  return CI::GraphObject::traverse_unique((uint64_t)a2, (uint64_t)v5);
}

uint64_t CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::ObjectCache(uint64_t a1, unint64_t a2)
{
  *(void *)a1 = a2;
  uint64_t v4 = a1 + 16;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 1065353216;
  unsigned int v5 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *(void *)(a1 + 56) = dispatch_queue_create("CI::ObjectCacheQ", v5);
  *(void *)(a1 + 64) = dispatch_group_create();
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>(v4, vcvtps_u32_f32((float)a2 / *(float *)(a1 + 48)));
  return a1;
}

uint64_t CI::GraphObject::traverse_unique(uint64_t a1, uint64_t a2)
{
  v12[0] = 0;
  v12[1] = v12;
  void v12[2] = 0x5002000000;
  v12[3] = __Block_byref_object_copy__92;
  v12[4] = __Block_byref_object_dispose__93;
  memset(v13, 0, sizeof(v13));
  int v14 = 1065353216;
  v10[0] = 0;
  v10[1] = v10;
  void v10[2] = 0x2000000000;
  int v11 = 0;
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>((uint64_t)v13, 0x80uLL);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  void v9[2] = ___ZN2CI11GraphObject15traverse_uniqueEPKS0_U13block_pointerFvS2_iE_block_invoke;
  v9[3] = &unk_1E5775DD0;
  v9[4] = v12;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  void v8[2] = ___ZN2CI11GraphObject15traverse_uniqueEPKS0_U13block_pointerFvS2_iE_block_invoke_2;
  v8[3] = &unk_1E5775DF8;
  void v8[4] = a2;
  v8[5] = v10;
  CI::GraphObject::traverse_stoppable(a1, v4, v5, v6, (uint64_t)v9, (uint64_t)v8);
  _Block_object_dispose(v10, 8);
  _Block_object_dispose(v12, 8);
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v13);
}

{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void v8[6];
  void v9[5];
  void v10[3];
  int v11;
  void v12[5];
  unsigned char v13[32];
  int v14;

  v12[0] = 0;
  v12[1] = v12;
  void v12[2] = 0x5002000000;
  v12[3] = __Block_byref_object_copy__27;
  v12[4] = __Block_byref_object_dispose__27;
  memset(v13, 0, sizeof(v13));
  int v14 = 1065353216;
  v10[0] = 0;
  v10[1] = v10;
  void v10[2] = 0x2000000000;
  int v11 = 0;
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>((uint64_t)v13, 0x80uLL);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  void v9[2] = ___ZN2CI11GraphObject15traverse_uniqueEPS0_U13block_pointerFvS1_iE_block_invoke;
  v9[3] = &unk_1E5775D80;
  v9[4] = v12;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  void v8[2] = ___ZN2CI11GraphObject15traverse_uniqueEPS0_U13block_pointerFvS1_iE_block_invoke_2;
  v8[3] = &unk_1E5775DA8;
  void v8[4] = a2;
  v8[5] = v10;
  CI::GraphObject::traverse_stoppable(a1, v4, v5, v6, (uint64_t)v9, (uint64_t)v8);
  _Block_object_dispose(v10, 8);
  _Block_object_dispose(v12, 8);
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v13);
}

void std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      int v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *int v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            int v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          int v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    uint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

uint64_t std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      int v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int8x8_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t CI_INPUT_SRGB_TEXTURES()
{
  {
    CI_INPUT_SRGB_TEXTURES::v = get_int("CI_INPUT_SRGB_TEXTURES", 2);
  }
  return CI_INPUT_SRGB_TEXTURES::v;
}

void sub_1936A4408(_Unwind_Exception *a1)
{
}

void CI::Image::traverse_stoppable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK2CI5Image18traverse_stoppableEU13block_pointerFbPKS0_S2_EU13block_pointerFvS2_S2_E_block_invoke;
  v4[3] = &unk_1E5776658;
  v4[4] = a2;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = ___ZNK2CI5Image18traverse_stoppableEU13block_pointerFbPKS0_S2_EU13block_pointerFvS2_S2_E_block_invoke_2;
  _OWORD v3[3] = &unk_1E5776680;
  v3[4] = a3;
  CI::GraphObject::traverse_stoppable(a1, 0, 0, 0, (uint64_t)v4, (uint64_t)v3);
}

BOOL CI::MetalContext::formatIsReadable(id *this, unsigned int a2)
{
  uint64_t v4 = a2;
  if (a2 > 0x2FF || (int v5 = *((unsigned __int8 *)this + a2 + 460), !*((unsigned char *)this + a2 + 460)))
  {
    [this[49] device];
    MTLPixelFormatGetInfoForDevice();
    int v5 = 0;
    if (a2 <= 0x2FF) {
      *((unsigned char *)this + v4 + 460) = 0;
    }
  }
  return v5 == 114 || v5 == 119;
}

void CI::Image::BuildMapToUseCount(CI::Image *this, CI::Image *a2, CI::Context *a3)
{
  v3[0] = 0;
  v3[1] = v3;
  v3[2] = 0x2000000000;
  _OWORD v3[3] = 0;
  operator new();
}

void CI::Image::BuildMapToUnionRoi(CI::Image *this, CI::Image *a2, CGRect a3)
{
  v3[0] = 0;
  v3[1] = v3;
  v3[2] = 0x2000000000;
  _OWORD v3[3] = 0;
  operator new();
}

void CI::SerialObjectPtrArray::replace(CI::SerialObjectPtrArray *this, CI::Object *a2, int a3)
{
  if (a2) {
    CI::Object::ref((uint64_t)a2);
  }
  if (a3 > 9)
  {
    uint64_t v10 = *((void *)this + 2);
    uint64_t v11 = (a3 - 10);
    unint64_t v12 = *(CI::Object **)(v10 + 8 * v11);
    if (v12)
    {
      CI::Object::unref(v12);
      uint64_t v10 = *((void *)this + 2);
    }
    unint64_t v8 = (void *)(v10 + 8 * v11);
  }
  else
  {
    uint64_t v6 = (char *)this + 8 * a3;
    uint8x8_t v9 = (CI::Object *)*((void *)v6 + 3);
    unint64_t v8 = v6 + 24;
    uint64_t v7 = v9;
    if (v9) {
      CI::Object::unref(v7);
    }
  }
  void *v8 = a2;
}

void CI::ObjectCache<CI::Node,unsigned long long,false>::insert(uint64_t a1, uint64_t a2, CI::Object *this, int a4)
{
  if (this) {
    CI::Object::ref((uint64_t)this);
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  void v8[2] = ___ZN2CI11ObjectCacheINS_4NodeEyLb0EE6insertEyPS1_j_block_invoke;
  v8[3] = &__block_descriptor_tmp_278;
  void v8[4] = a1;
  v8[5] = a2;
  void v8[6] = this;
  int v9 = a4;
  Queue::execute_async((dispatch_queue_t *)(a1 + 56), v8);
}

uint64_t CI_OUTPUT_SRGB_TEXTURES()
{
  {
    CI_OUTPUT_SRGB_TEXTURES::v = get_BOOL("CI_OUTPUT_SRGB_TEXTURES", 1);
  }
  return CI_OUTPUT_SRGB_TEXTURES::v;
}

void sub_1936A4988(_Unwind_Exception *a1)
{
}

uint64_t CI_DEBUG_CONTEXT_COLOR()
{
  {
    CI_DEBUG_CONTEXT_COLOR::v = get_int("CI_DEBUG_CONTEXT_COLOR", 0);
  }
  return CI_DEBUG_CONTEXT_COLOR::v;
}

void sub_1936A4A08(_Unwind_Exception *a1)
{
}

BOOL CI::Affine::isNearIdentity(CI::Affine *this, double a2)
{
  return fabs(*(double *)this + -1.0) < a2
      && fabs(*((double *)this + 1)) < a2
      && fabs(*((double *)this + 2)) < a2
      && fabs(*((double *)this + 3) + -1.0) < a2
      && fabs(*((double *)this + 4)) < a2
      && fabs(*((double *)this + 5)) < a2;
}

uint64_t CI::print_time_enabled(CI *this, CI::Context *a2)
{
  uint64_t result = CI_PRINT_TIME();
  if (result)
  {
    int v4 = (*(uint64_t (**)(CI *))(*(void *)this + 272))(this);
    return CI_PRINT_TIME_context(v4, (char *)this + 236);
  }
  return result;
}

void ___ZN2CI14TextureManager10remove_allEv_block_invoke(uint64_t a1)
{
  for (unint64_t i = *(CI::TextureManager **)(a1 + 32);
        *((void *)i + 6);
}

void CI::TextureManager::remove_lru(CI::TextureManager *this, CI::Object *a2)
{
  int v3 = (char *)this + 32;
  int v4 = (char *)*((void *)this + 5);
  if (v4 != v3)
  {
    while (*((CI::Object **)v4 + 2) != a2)
    {
      int v4 = (char *)*((void *)v4 + 1);
      if (v4 == v3) {
        return;
      }
    }
    if (v4 != v3)
    {
      uint64_t v6 = (void *)*((void *)this + 15);
      if (!v6) {
        goto LABEL_17;
      }
      uint64_t v7 = (uint64_t *)((char *)this + 120);
      do
      {
        unint64_t v8 = v6[4];
        BOOL v9 = v8 >= (unint64_t)a2;
        if (v8 >= (unint64_t)a2) {
          uint64_t v10 = v6;
        }
        else {
          uint64_t v10 = v6 + 1;
        }
        if (v9) {
          uint64_t v7 = v6;
        }
        uint64_t v6 = (void *)*v10;
      }
      while (*v10);
      if (v7 != (uint64_t *)((char *)this + 120) && v7[4] <= (unint64_t)a2)
      {
        uint64_t v11 = (_DWORD *)v7[5];
        int v12 = v11[5];
        if (!v12)
        {
          unsigned int v15 = ci_logger_render();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
            CI::TextureManager::remove_lru(v15);
          }
          abort();
        }
        int v13 = v12 - 1;
        v11[5] = v13;
        if (!v13)
        {
          uint64_t v14 = *(void *)v4;
          *(void *)(v14 + 8) = *((void *)v4 + 1);
          **((void **)v4 + 1) = v14;
          --*((void *)this + 6);
          operator delete(v4);
          std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__remove_node_pointer((uint64_t **)this + 14, v7);
          operator delete(v7);
          long long v16 = *(_OWORD *)v11;
          (**(void (***)(CI::TextureManager *, long long *))this)(this, &v16);
          long long v16 = 0uLL;
          if (a2)
          {
            switch(v11[4])
            {
              case 0:
                CI::Object::unref(a2);
                break;
              case 1:
                CGImageRelease(a2);
                break;
              case 2:
                CFRelease(a2);
                break;
              case 4:
                ReturnSurfaceToCache((uint64_t)a2);
                break;
              default:
                break;
            }
          }
          free(v11);
        }
      }
      else
      {
LABEL_17:
        x_log("TextureManager::remove_lru() did not find an info struct!\n");
      }
    }
  }
}

uint64_t *std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      int v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    int v4 = a2;
    do
    {
      int v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      int v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  uint64_t v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  int v3 = a2;
  if (*a2)
  {
    int v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      int v3 = a2;
      goto LABEL_7;
    }
    do
    {
      int v3 = v4;
      int v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  uint64_t v6 = (uint64_t **)v3[2];
  uint64_t v7 = *v6;
  if (*v6 == v3)
  {
    *uint64_t v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      uint64_t v7 = 0;
      uint64_t result = (uint64_t *)v2;
    }
    else
    {
      uint64_t v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *int v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      int v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      void v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      *int v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        uint64_t result = v7;
      }
      uint64_t v7 = *(uint64_t **)(*v7 + 8);
    }
    unsigned int v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      long long v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        *uint64_t v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        _OWORD v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        void v7[2] = (uint64_t)v15;
        long long v16 = v7;
      }
      else
      {
        unsigned int v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      double v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *double v24 = v23;
      goto LABEL_72;
    }
    long long v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 24) = 0;
    double v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      double v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    uint64_t v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    void v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      uint64_t result = v7;
    }
    uint64_t v7 = *(uint64_t **)v12;
  }
  double v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  uint64_t v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    double v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    uint64_t v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    void v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    *uint64_t v20 = (uint64_t)v7;
    void v7[2] = (uint64_t)v20;
    double v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  double v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

void CI::MetalTextureManager::release_texture(CI::MetalTextureManager *this, Texture a2)
{
  var0 = (void *)a2.var0.var0;
  if (*(void *)a2.var0.var0) {
    CFRelease(*(CFTypeRef *)a2.var0.var0);
  }
  void *var0 = 0;
  var0[1] = 0;
}

uint64_t QueuePool<4>::QueuePool(uint64_t a1, char *a2)
{
  *(_DWORD *)a1 = 0;
  int v4 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *(void *)(a1 + 8) = dispatch_queue_create("QueuePoolLock", v4);
  std::string::basic_string[abi:nn180100]<0>((void *)(a1 + 16), a2);
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return a1;
}

void ___ZN9QueuePoolILi4EE3getEP21dispatch_queue_attr_s_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(int **)(a1 + 40);
  if (!*(void *)&v2[2 * *v2 + 10])
  {
    std::string::basic_string[abi:nn180100]<0>(&v29, "-Pool-");
    int v3 = *((char *)v2 + 39);
    if (v3 >= 0) {
      int v4 = (const std::string::value_type *)(v2 + 4);
    }
    else {
      int v4 = (const std::string::value_type *)*((void *)v2 + 2);
    }
    if (v3 >= 0) {
      std::string::size_type v5 = *((unsigned __int8 *)v2 + 39);
    }
    else {
      std::string::size_type v5 = *((void *)v2 + 3);
    }
    uint64_t v6 = std::string::insert(&v29, 0, v4, v5);
    std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, *v2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v30, (const std::string::value_type *)p_p, size);
    std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
    long long v31 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    uint64_t v32 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
    if (v32 >= 0) {
      uint64_t v12 = (const char *)&v31;
    }
    else {
      uint64_t v12 = (const char *)v31;
    }
    int v13 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    *(void *)&v2[2 * *v2 + 10] = dispatch_queue_create(v12, v13);
    if (SHIBYTE(v32) < 0) {
      operator delete((void *)v31);
    }
  }
  std::string::basic_string[abi:nn180100]<0>(&v29, "-");
  int v14 = *((char *)v2 + 39);
  if (v14 >= 0) {
    unsigned int v15 = (const std::string::value_type *)(v2 + 4);
  }
  else {
    unsigned int v15 = (const std::string::value_type *)*((void *)v2 + 2);
  }
  if (v14 >= 0) {
    std::string::size_type v16 = *((unsigned __int8 *)v2 + 39);
  }
  else {
    std::string::size_type v16 = *((void *)v2 + 3);
  }
  double v17 = std::string::insert(&v29, 0, v15, v16);
  std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *v2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    double v19 = &__p;
  }
  else {
    double v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v20 = __p.__r_.__value_.__l.__size_;
  }
  BOOL v21 = std::string::append(&v30, (const std::string::value_type *)v19, v20);
  std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
  long long v31 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  uint64_t v32 = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  if (v32 >= 0) {
    uint64_t v23 = (const char *)&v31;
  }
  else {
    uint64_t v23 = (const char *)v31;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = dispatch_queue_create_with_target_V2(v23, *(dispatch_queue_attr_t *)(a1 + 48), *(dispatch_queue_t *)&v2[2 * *v2 + 10]);
  int v24 = *v2 + 1;
  BOOL v25 = -v24 < 0;
  int v26 = -v24 & 3;
  int v27 = v24 & 3;
  if (!v25) {
    int v27 = -v26;
  }
  *uint64_t v2 = v27;
  if (SHIBYTE(v32) < 0) {
    operator delete((void *)v31);
  }
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

uint64_t floatSetter(void *a1, const char *a2)
{
  uint64_t v4 = objc_msgSend(NSNumber, "numberWithFloat:");
  size_t v5 = keyForSetter(a2);

  return [a1 setValue:v4 forKey:v5];
}

double pointGetter(void *a1, SEL aSelector)
{
  int v3 = NSStringFromSelector(aSelector);
  if ([(NSString *)v3 isEqualToString:@"parameterB"])
  {
    uint64_t v4 = @"inputB";
  }
  else if ([(NSString *)v3 isEqualToString:@"parameterC"])
  {
    uint64_t v4 = @"inputC";
  }
  else if ([(NSString *)v3 isEqualToString:@"underColorRemoval"])
  {
    uint64_t v4 = @"inputUCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"grayComponentReplacement"])
  {
    uint64_t v4 = @"inputGCR";
  }
  else if ([(NSString *)v3 isEqualToString:@"textureImage"])
  {
    uint64_t v4 = @"inputTexture";
  }
  else
  {
    uint64_t v4 = (__CFString *)objc_msgSend(@"input", "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  uint64_t v5 = [a1 valueForKey:v4];
  double v6 = 0.0;
  if (v5)
  {
    uint64_t v7 = (void *)v5;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [v7 CGPointValue];
      return v8;
    }
  }
  return v6;
}

uint64_t objSetter(void *a1, const char *a2, uint64_t a3)
{
  uint64_t v5 = keyForSetter(a2);

  return [a1 setValue:a3 forKey:v5];
}

__CFString *keyForSetter(const char *a1)
{
  uint64_t v1 = NSStringFromSelector(a1);
  if ([(NSString *)v1 isEqualToString:@"setBackgroundImage:"]) {
    return @"inputBackgroundImage";
  }
  if ([(NSString *)v1 isEqualToString:@"setMaskImage:"]) {
    return @"inputMaskImage";
  }
  if ([(NSString *)v1 isEqualToString:@"setSmallImage:"]) {
    return @"inputSmallImage";
  }
  if ([(NSString *)v1 isEqualToString:@"setTargetImage:"]) {
    return @"inputTargetImage";
  }
  if ([(NSString *)v1 isEqualToString:@"setBacksideImage:"]) {
    return @"inputBacksideImage";
  }
  if ([(NSString *)v1 isEqualToString:@"setShadingImage:"]) {
    return @"inputShadingImage";
  }
  if ([(NSString *)v1 isEqualToString:@"setGradientImage:"]) {
    return @"inputGradientImage";
  }
  if ([(NSString *)v1 isEqualToString:@"setPaletteImage:"]) {
    return @"inputPaletteImage";
  }
  if ([(NSString *)v1 isEqualToString:@"setTextureImage:"]) {
    return @"inputTexture";
  }
  if ([(NSString *)v1 isEqualToString:@"setParameterB:"]) {
    return @"inputB";
  }
  if ([(NSString *)v1 isEqualToString:@"setParameterC:"]) {
    return @"inputC";
  }
  if ([(NSString *)v1 isEqualToString:@"setUnderColorRemoval:"]) {
    return @"inputUCR";
  }
  if ([(NSString *)v1 isEqualToString:@"setGrayComponentReplacement:"]) {
    return @"inputGCR";
  }
  int v3 = [(NSString *)v1 stringByReplacingCharactersInRange:0, 3, @"input" withString];
  uint64_t v4 = [(NSString *)v3 length] - 1;

  return (__CFString *)-[NSString substringWithRange:](v3, "substringWithRange:", 0, v4);
}

uint64_t CI_ENABLE_KERNEL_CACHE()
{
  {
    CI_ENABLE_KERNEL_CACHE::v = get_BOOL("CI_ENABLE_KERNEL_CACHE", 1);
  }
  return CI_ENABLE_KERNEL_CACHE::v;
}

void sub_1936A59BC(_Unwind_Exception *a1)
{
}

CI::ColorMatchImage *CI::ColorMatchImage::ColorMatchImage(CI::ColorMatchImage *this, CI::Image *a2, CGColorSpace *a3)
{
  double v6 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v6 + 14) = &unk_1EE45AFD0;
  atomic_fetch_add(&dword_1EB466E78[2], 1u);
  *(void *)double v6 = &unk_1EE45A690;
  *((unsigned char *)v6 + 138) = 0;
  *((_DWORD *)v6 + 35) = 0;
  *((void *)v6 + 14) = &unk_1EE45A7E8;
  *((void *)v6 + 15) = 0;
  *((unsigned char *)v6 + 136) = 1;
  *((void *)this + 16) = CGColorSpaceRetain(a3);
  *((unsigned char *)this + 137) = 0;
  *((void *)this + 10) = CI::ColorMatchImage::makeDigest(*((void *)a2 + 10), 0, a3, 0.0);
  *((void *)this + 11) = CI::ColorMatchImage::makeDigest(*((void *)a2 + 11), 0, a3, 0.0);
  return this;
}

CI::ColorMatchImage *CI::ColorMatchImage::ColorMatchImage(CI::ColorMatchImage *this, CI::Image *a2, CGColorSpace *a3, int a4)
{
  double v8 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v8 + 14) = &unk_1EE45AFD0;
  atomic_fetch_add(&dword_1EB466E78[2], 1u);
  *(void *)double v8 = &unk_1EE45A690;
  *((void *)v8 + 14) = &unk_1EE45A7E8;
  *((unsigned char *)v8 + 138) = 0;
  *((_DWORD *)v8 + 35) = 0;
  CGColorSpaceRef v9 = CGColorSpaceRetain(a3);
  *((_WORD *)this + 68) = 256;
  *((void *)this + 15) = v9;
  *((void *)this + 16) = 0;
  if (a4)
  {
    BOOL IsHDR = CGColorSpaceIsHDR(a3);
    float v11 = 1.0;
  }
  else
  {
    BOOL IsHDR = 0;
    float v11 = 0.0;
  }
  *((unsigned char *)this + 138) = IsHDR;
  *((float *)this + 35) = v11;
  *((void *)this + 10) = CI::ColorMatchImage::makeDigest(*((void *)a2 + 10), a3, 0, v11);
  *((void *)this + 11) = CI::ColorMatchImage::makeDigest(*((void *)a2 + 11), a3, 0, *((float *)this + 35));
  return this;
}

unint64_t CI::ColorMatchImage::makeDigest(uint64_t a1, CGColorSpace *a2, CGColorSpace *a3, float a4)
{
  XXH64_reset(v9, 0);
  LODWORD(__src) = 4;
  XXH64_update((uint64_t)v9, (char *)&__src, 4uLL);
  uint64_t __src = a1;
  XXH64_update((uint64_t)v9, (char *)&__src, 8uLL);
  if (!a2)
  {
    LODWORD(__src) = 1;
    XXH64_update((uint64_t)v9, (char *)&__src, 4uLL);
    if (a3) {
      goto LABEL_3;
    }
LABEL_5:
    LODWORD(__src) = 1;
    XXH64_update((uint64_t)v9, (char *)&__src, 4uLL);
    goto LABEL_6;
  }
  CI::XXHashHelper::add((CI::XXHashHelper *)v9, a2);
  if (!a3) {
    goto LABEL_5;
  }
LABEL_3:
  CI::XXHashHelper::add((CI::XXHashHelper *)v9, a3);
LABEL_6:
  *(float *)&uint64_t __src = a4;
  XXH64_update((uint64_t)v9, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v9);
}

CI::Object *CI::SwizzleImage::render_graph_core(int *a1, uint64_t a2, uint64_t a3)
{
  int v5 = (*(uint64_t (**)(int *))(*(void *)a1 + 184))(a1);
  if (a3)
  {
    double v6 = (CI::Object *)CI::Object::ref(a3);
    uint64_t v7 = CI::SwizzleNode::append_to_tree(v6, a1[30], v5);
    if (v6) {
      CI::Object::unref(v6);
    }
    return v7;
  }
  else
  {
    int v9 = a1[30];
    return CI::SwizzleNode::append_to_tree(0, v9, v5);
  }
}

CI::PremultiplyNode *CI::ColorMatchImage::render_graph_core(uint64_t a1, CGColorSpace **a2, CI::PremultiplyNode *appended)
{
  v133[9] = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 184))(a1);
  if (*(unsigned char *)(a1 + 136)) {
    uint64_t v7 = a2 + 3;
  }
  else {
    uint64_t v7 = (CGColorSpace **)(a1 + 120);
  }
  double v8 = *v7;
  if (*(unsigned char *)(a1 + 137)) {
    int v9 = a2 + 3;
  }
  else {
    int v9 = (CGColorSpace **)(a1 + 128);
  }
  uint64_t v10 = *v9;
  if (appended) {
    appended = (CI::PremultiplyNode *)CI::Object::ref((uint64_t)appended);
  }
  if (v8) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11 || v8 == v10) {
    return appended;
  }
  int v13 = *(_DWORD *)(a1 + 100);
  int v14 = *(unsigned __int8 *)(a1 + 138);
  float v15 = *(float *)(a1 + 140);
  CMatrix::CMatrix((CMatrix *)v108);
  double v91 = 0.0;
  if (!CI::get_colorspace_gamma_and_matrix(v8, (CGColorSpace *)&v91, v108, v16))
  {
    if (CGColorSpaceGetModel(v8) == kCGColorSpaceModelMonochrome || CGColorSpaceGetModel(v8) == kCGColorSpaceModelRGB)
    {
      float v20 = (*((float (**)(CGColorSpace **))*a2 + 19))(a2);
      {
        CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::cache = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
      BOOL v21 = !CGColorSpaceIsHDR(v8);
      if (v20 == 2.0) {
        BOOL v21 = 1;
      }
      if (v14) {
        BOOL v22 = 0;
      }
      else {
        BOOL v22 = v21;
      }
      if (v22)
      {
        pthread_mutex_lock(&CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::mutex);
        Value = CFDictionaryGetValue((CFDictionaryRef)CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::cache, v8);
        pthread_mutex_unlock(&CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::mutex);
        if (Value)
        {
          CFRetain(Value);
LABEL_57:
          appended = CI::AppendConverterArray((int)a2, appended, v13, (CFArrayRef)Value, 0, (CI::Node *)v6);
          CFRelease(Value);
          goto LABEL_74;
        }
      }
      unsigned int v84 = v6;
      if (CI::CI_EXTENDED_PCS(void)::didCheck != -1) {
        dispatch_once(&CI::CI_EXTENDED_PCS(void)::didCheck, &__block_literal_global_85);
      }
      if (CI::CI_EXTENDED_PCS(void)::v) {
        BOOL v24 = v14 == 0;
      }
      else {
        BOOL v24 = 1;
      }
      BOOL v25 = (CFStringRef *)MEMORY[0x1E4F1DC88];
      if (v24) {
        BOOL v25 = (CFStringRef *)MEMORY[0x1E4F1DBE0];
      }
      int v26 = CGColorSpaceCreateWithName(*v25);
      Value = CI::createConverterArray(v8, v26, v27, v20, v15);
      if (Value) {
        BOOL v28 = v22;
      }
      else {
        BOOL v28 = 0;
      }
      if (v28)
      {
        pthread_mutex_lock(&CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::mutex);
        CFDictionaryAddValue((CFMutableDictionaryRef)CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::cache, v8, Value);
        pthread_mutex_unlock(&CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::mutex);
        CGColorSpaceRelease(v26);
        unint64_t v6 = v84;
        goto LABEL_57;
      }
      CGColorSpaceRelease(v26);
      unint64_t v6 = v84;
      if (Value) {
        goto LABEL_57;
      }
    }
    CI::snprintf_cs((CI *)&v109, (char *)0x100, v8, 0);
    double v33 = ci_logger_render();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
      CI::ColorMatchImage::render_graph_core((uint64_t)&v109, v33);
    }
    goto LABEL_74;
  }
  double v17 = v91;
  if (v91 == -1.0)
  {
    std::string::size_type v18 = CI::PremultiplyNode::append_to_tree(appended, (CI::Node *)0xFFFFFFFFLL, v6);
    if (appended) {
      CI::Object::unref(appended);
    }
    if ((CI_INPUT_SRGB_TEXTURES() & 0xFFFFFFFD) != 0)
    {
      uint64_t v125 = 0;
      *(void *)&long long v126 = &v125;
      *((void *)&v126 + 1) = 0x2000000000;
      uint64_t v127 = 0;
      uint64_t v127 = (*(uint64_t (**)(CI::PremultiplyNode *))(*(void *)v18 + 400))(v18);
      double v19 = *(unsigned int **)(v126 + 24);
      if (!v19)
      {
        uint64_t v86 = MEMORY[0x1E4F143A8];
        uint64_t v87 = 0x40000000;
        CGRect v88 = ___ZN2CIL19AppendColorSpaceSrcEPNS_7ContextEPNS_4NodeENS_10ImageIndexEP12CGColorSpacebfb_block_invoke;
        uint64_t v89 = &unk_1E5770720;
        CGRect v90 = &v125;
        uint64_t v109 = MEMORY[0x1E4F143A8];
        uint64_t v110 = 0x40000000;
        v111 = ___ZN2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPS0_E_block_invoke;
        v112 = &unk_1E5774720;
        v113 = &v86;
        CI::GraphObject::traverse_preorder_stoppable((uint64_t)v18, 0, 0, 0, (uint64_t)&v109);
        double v19 = *(unsigned int **)(v126 + 24);
        if (!v19) {
          goto LABEL_62;
        }
      }
      if ((v6 & (*((unsigned int (**)(CGColorSpace **, void, uint64_t))*a2 + 73))(a2, *v19, 3)) == 1)
      {
        *(unsigned char *)(*(void *)(v126 + 24) + 4) = 1;
      }
      else
      {
LABEL_62:
        double v34 = CI::SRGBNode::append_to_tree(v18, (CI::Node *)0xFFFFFFFFLL, v6);
        CI::Object::unref(v18);
        std::string::size_type v18 = v34;
      }
      _Block_object_dispose(&v125, 8);
      uint64_t v32 = v18;
    }
    else
    {
      uint64_t v32 = CI::SRGBNode::append_to_tree(v18, (CI::Node *)0xFFFFFFFFLL, v6);
      if (v18) {
        CI::Object::unref(v18);
      }
    }
    long long v31 = v32;
LABEL_65:
    appended = CI::PremultiplyNode::append_to_tree(v31, (CI::Node *)1, v6);
    if (v32) {
      CI::Object::unref(v32);
    }
    goto LABEL_67;
  }
  if (v91 != 0.0 && v91 != 1.0)
  {
    std::string v30 = CI::PremultiplyNode::append_to_tree(appended, (CI::Node *)0xFFFFFFFFLL, v6);
    if (appended) {
      CI::Object::unref(appended);
    }
    long long v31 = CI::CurveNode::append_to_tree_and_unref(v30, (CI::Node *)v6, v17);
    uint64_t v32 = v31;
    goto LABEL_65;
  }
LABEL_67:
  if (CMatrix::columnCount((CMatrix *)v108) == 1)
  {
    CMatrix::CMatrix((CMatrix *)&v109, (const CMatrix *)v108);
    uint64_t v127 = 0;
    uint64_t v130 = 0;
    memset(&v133[4], 0, 40);
    memset(v133, 0, 32);
    long long v132 = 0u;
    long long v129 = 0u;
    long long v126 = 0u;
    uint64_t v125 = 0x3FF0000000000000;
    uint64_t v128 = 0x3FF0000000000000;
    uint64_t v131 = 0x3FF0000000000000;
    v133[4] = 0x3FF0000000000000;
  }
  else
  {
    if (CMatrix::isNearIdentity((CMatrix *)v108, 0.0001)) {
      goto LABEL_74;
    }
    CMatrix::CMatrix((CMatrix *)&v109, (const CMatrix *)v108);
    uint64_t v106 = CMatrix::operator[]((unsigned int *)&v109, 0);
    uint64_t v107 = v35;
    uint64_t v125 = *(void *)CMatrixRow::operator[]((uint64_t)&v106, 0);
    uint64_t v104 = CMatrix::operator[]((unsigned int *)&v109, 1u);
    uint64_t v105 = v36;
    *(void *)&long long v126 = *(void *)CMatrixRow::operator[]((uint64_t)&v104, 0);
    uint64_t v102 = CMatrix::operator[]((unsigned int *)&v109, 2u);
    uint64_t v103 = v37;
    *((void *)&v126 + 1) = *(void *)CMatrixRow::operator[]((uint64_t)&v102, 0);
    uint64_t v127 = 0;
    uint64_t v100 = CMatrix::operator[]((unsigned int *)&v109, 0);
    uint64_t v101 = v38;
    uint64_t v128 = *(void *)CMatrixRow::operator[]((uint64_t)&v100, 1u);
    uint64_t v98 = CMatrix::operator[]((unsigned int *)&v109, 1u);
    uint64_t v99 = v39;
    *(void *)&long long v129 = *(void *)CMatrixRow::operator[]((uint64_t)&v98, 1u);
    uint64_t v96 = CMatrix::operator[]((unsigned int *)&v109, 2u);
    uint64_t v97 = v40;
    *((void *)&v129 + 1) = *(void *)CMatrixRow::operator[]((uint64_t)&v96, 1u);
    uint64_t v130 = 0;
    uint64_t v94 = CMatrix::operator[]((unsigned int *)&v109, 0);
    uint64_t v95 = v41;
    uint64_t v131 = *(void *)CMatrixRow::operator[]((uint64_t)&v94, 2u);
    uint64_t v92 = CMatrix::operator[]((unsigned int *)&v109, 1u);
    uint64_t v93 = v42;
    *(void *)&long long v132 = *(void *)CMatrixRow::operator[]((uint64_t)&v92, 2u);
    *(void *)&v85[0] = CMatrix::operator[]((unsigned int *)&v109, 2u);
    v85[1] = v43;
    *((void *)&v132 + 1) = *(void *)CMatrixRow::operator[]((uint64_t)v85, 2u);
    memset(v133, 0, 24);
    *(_OWORD *)&v133[3] = unk_193959C40;
    memset(&v133[5], 0, 32);
  }
  float64x2_t v44 = CI::ColorMatrixNode::append_to_tree(appended, (CI::Node *)&v125, (const double (*)[4])v6);
  if (appended) {
    CI::Object::unref(appended);
  }
  appended = v44;
LABEL_74:
  int v45 = *(_DWORD *)(a1 + 100);
  CMatrix::CMatrix((CMatrix *)v108);
  v85[0] = 0.0;
  if (!CI::get_colorspace_gamma_and_matrix(v10, (CGColorSpace *)v85, v108, v46))
  {
    if (CGColorSpaceGetModel(v10) == kCGColorSpaceModelMonochrome || CGColorSpaceGetModel(v10) == kCGColorSpaceModelRGB)
    {
      BOOL IsHDR = CGColorSpaceIsHDR(v10);
      float v58 = (*((float (**)(CGColorSpace **))*a2 + 19))(a2);
      {
        CI::createConverterArrayTo(CGColorSpace *,float)::cache = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      }
      BOOL v59 = !CGColorSpaceIsHDR(v10);
      int v60 = v58 == 2.0 || v59;
      if (v60 == 1)
      {
        pthread_mutex_lock(&CI::createConverterArrayTo(CGColorSpace *,float)::mutex);
        ConverterArradouble y = CFDictionaryGetValue((CFDictionaryRef)CI::createConverterArrayTo(CGColorSpace *,float)::cache, v10);
        pthread_mutex_unlock(&CI::createConverterArrayTo(CGColorSpace *,float)::mutex);
        if (ConverterArray)
        {
          CFRetain(ConverterArray);
LABEL_116:
          appended = CI::AppendConverterArray((int)a2, appended, v45, (CFArrayRef)ConverterArray, IsHDR, (CI::Node *)v6);
          CFRelease(ConverterArray);
          return appended;
        }
      }
      if (CI::CI_EXTENDED_PCS(void)::didCheck != -1) {
        dispatch_once(&CI::CI_EXTENDED_PCS(void)::didCheck, &__block_literal_global_85);
      }
      if (CI::CI_EXTENDED_PCS(void)::v) {
        long long v76 = (CFStringRef *)MEMORY[0x1E4F1DBE0];
      }
      else {
        long long v76 = (CFStringRef *)MEMORY[0x1E4F1DC88];
      }
      uint64_t v77 = CGColorSpaceCreateWithName(*v76);
      ConverterArradouble y = CI::createConverterArray(v77, v10, v78, v58, 0.0);
      if (ConverterArray) {
        char v79 = v60;
      }
      else {
        char v79 = 0;
      }
      if (v79)
      {
        pthread_mutex_lock(&CI::createConverterArrayTo(CGColorSpace *,float)::mutex);
        CFDictionaryAddValue((CFMutableDictionaryRef)CI::createConverterArrayTo(CGColorSpace *,float)::cache, v10, ConverterArray);
        pthread_mutex_unlock(&CI::createConverterArrayTo(CGColorSpace *,float)::mutex);
        CGColorSpaceRelease(v77);
        goto LABEL_116;
      }
      CGColorSpaceRelease(v77);
      if (ConverterArray) {
        goto LABEL_116;
      }
    }
    CI::snprintf_cs((CI *)&v109, (char *)0x100, v10, 0);
    double v82 = ci_logger_render();
    if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR)) {
      CI::ColorMatchImage::render_graph_core((uint64_t)&v109, v82);
    }
    return appended;
  }
  if (CMatrix::columnCount((CMatrix *)v108) == 1)
  {
    uint64_t v125 = CMatrix::operator[]((unsigned int *)v108, 0);
    *(void *)&long long v126 = v47;
    uint64_t v109 = *(void *)CMatrixRow::operator[]((uint64_t)&v125, 0);
    uint64_t v86 = CMatrix::operator[]((unsigned int *)v108, 1u);
    uint64_t v87 = v48;
    uint64_t v110 = *(void *)CMatrixRow::operator[]((uint64_t)&v86, 0);
    uint64_t v106 = CMatrix::operator[]((unsigned int *)v108, 2u);
    uint64_t v107 = v49;
    v111 = *(uint64_t (**)(uint64_t))CMatrixRow::operator[]((uint64_t)&v106, 0);
    v112 = 0;
    uint64_t v104 = CMatrix::operator[]((unsigned int *)v108, 0);
    uint64_t v105 = v50;
    v113 = *(uint64_t **)CMatrixRow::operator[]((uint64_t)&v104, 0);
    uint64_t v102 = CMatrix::operator[]((unsigned int *)v108, 1u);
    uint64_t v103 = v51;
    uint64_t v114 = *(void *)CMatrixRow::operator[]((uint64_t)&v102, 0);
    uint64_t v100 = CMatrix::operator[]((unsigned int *)v108, 2u);
    uint64_t v101 = v52;
    uint64_t v115 = *(void *)CMatrixRow::operator[]((uint64_t)&v100, 0);
    uint64_t v116 = 0;
    uint64_t v98 = CMatrix::operator[]((unsigned int *)v108, 0);
    uint64_t v99 = v53;
    uint64_t v117 = *(void *)CMatrixRow::operator[]((uint64_t)&v98, 0);
    uint64_t v96 = CMatrix::operator[]((unsigned int *)v108, 1u);
    uint64_t v97 = v54;
    uint64_t v118 = *(void *)CMatrixRow::operator[]((uint64_t)&v96, 0);
    uint64_t v94 = CMatrix::operator[]((unsigned int *)v108, 2u);
    uint64_t v95 = v55;
    uint64_t v119 = *(void *)CMatrixRow::operator[]((uint64_t)&v94, 0);
    uint64_t v120 = 0;
    long long v121 = xmmword_193959C30;
    long long v122 = unk_193959C40;
    long long v123 = 0u;
    long long v124 = 0u;
    CGRect v56 = (CI::Node *)&v109;
  }
  else
  {
    if (CMatrix::isNearIdentity((CMatrix *)v108, 0.0001)) {
      goto LABEL_91;
    }
    CMatrix::inverse((CMatrix *)v108, (unsigned int *)&v109);
    uint64_t v86 = CMatrix::operator[]((unsigned int *)&v109, 0);
    uint64_t v87 = v62;
    uint64_t v125 = *(void *)CMatrixRow::operator[]((uint64_t)&v86, 0);
    uint64_t v106 = CMatrix::operator[]((unsigned int *)&v109, 1u);
    uint64_t v107 = v63;
    *(void *)&long long v126 = *(void *)CMatrixRow::operator[]((uint64_t)&v106, 0);
    uint64_t v104 = CMatrix::operator[]((unsigned int *)&v109, 2u);
    uint64_t v105 = v64;
    *((void *)&v126 + 1) = *(void *)CMatrixRow::operator[]((uint64_t)&v104, 0);
    uint64_t v127 = 0;
    uint64_t v102 = CMatrix::operator[]((unsigned int *)&v109, 0);
    uint64_t v103 = v65;
    uint64_t v128 = *(void *)CMatrixRow::operator[]((uint64_t)&v102, 1u);
    uint64_t v100 = CMatrix::operator[]((unsigned int *)&v109, 1u);
    uint64_t v101 = v66;
    *(void *)&long long v129 = *(void *)CMatrixRow::operator[]((uint64_t)&v100, 1u);
    uint64_t v98 = CMatrix::operator[]((unsigned int *)&v109, 2u);
    uint64_t v99 = v67;
    *((void *)&v129 + 1) = *(void *)CMatrixRow::operator[]((uint64_t)&v98, 1u);
    uint64_t v130 = 0;
    uint64_t v96 = CMatrix::operator[]((unsigned int *)&v109, 0);
    uint64_t v97 = v68;
    uint64_t v131 = *(void *)CMatrixRow::operator[]((uint64_t)&v96, 2u);
    uint64_t v94 = CMatrix::operator[]((unsigned int *)&v109, 1u);
    uint64_t v95 = v69;
    *(void *)&long long v132 = *(void *)CMatrixRow::operator[]((uint64_t)&v94, 2u);
    uint64_t v92 = CMatrix::operator[]((unsigned int *)&v109, 2u);
    uint64_t v93 = v70;
    *((void *)&v132 + 1) = *(void *)CMatrixRow::operator[]((uint64_t)&v92, 2u);
    memset(v133, 0, 24);
    *(_OWORD *)&v133[3] = unk_193959C40;
    memset(&v133[5], 0, 32);
    CGRect v56 = (CI::Node *)&v125;
  }
  long long v71 = CI::ColorMatrixNode::append_to_tree(appended, v56, (const double (*)[4])v6);
  if (appended) {
    CI::Object::unref(appended);
  }
  appended = v71;
LABEL_91:
  double v72 = v85[0];
  if (v85[0] == -1.0)
  {
    long long v73 = CI::PremultiplyNode::append_to_tree(appended, (CI::Node *)0xFFFFFFFFLL, v6);
    if (appended) {
      CI::Object::unref(appended);
    }
    long long v74 = CI::SRGBNode::append_to_tree(v73, (CI::Node *)1, v6);
    if (v73) {
      CI::Object::unref(v73);
    }
    appended = CI::PremultiplyNode::append_to_tree(v74, (CI::Node *)1, v6);
    if (v74)
    {
      long long v75 = v74;
LABEL_114:
      CI::Object::unref(v75);
    }
  }
  else if (v85[0] != 0.0 && v85[0] != 1.0)
  {
    long long v80 = CI::PremultiplyNode::append_to_tree(appended, (CI::Node *)0xFFFFFFFFLL, v6);
    if (appended) {
      CI::Object::unref(appended);
    }
    uint64_t v81 = CI::CurveNode::append_to_tree_and_unref(v80, (CI::Node *)v6, 1.0 / v72);
    appended = CI::PremultiplyNode::append_to_tree(v81, (CI::Node *)1, v6);
    if (v81)
    {
      long long v75 = v81;
      goto LABEL_114;
    }
  }
  return appended;
}

void CI::ColorKernelImage::render_graph_core(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v3 = *(void **)(a1 + 112);
  if (!(*(uint64_t (**)(void *))(*v3 + 72))(v3)
    || v3[4]
    || (*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2) == 77)
  {
    operator new();
  }
  uint64_t v4 = ci_logger_render();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 112) + 24);
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 304))(a2);
    *(_DWORD *)CGRect buf = 136446466;
    uint64_t v9 = v5;
    __int16 v10 = 2082;
    uint64_t v11 = v6;
    _os_log_error_impl(&dword_193671000, v4, OS_LOG_TYPE_ERROR, "Cannot render image (with Metal kernel '%{public}s') using an %{public}s context.", buf, 0x16u);
  }
  operator new();
}

BOOL CI::Image::render_graph_allow_reorder(CI::Image *this)
{
  return CI_GRAPH_ALLOW_REORDER() != 0;
}

uint64_t CI_GRAPH_ALLOW_REORDER()
{
  {
    CI_GRAPH_ALLOW_REORDER::v = get_BOOL("CI_GRAPH_ALLOW_REORDER", 1);
  }
  return CI_GRAPH_ALLOW_REORDER::v;
}

void sub_1936A71BC(_Unwind_Exception *a1)
{
}

uint64_t CI::ImageToNodeMap::findAndRef(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 8);
  int v3 = v4;
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      double v8 = v3;
    }
    else {
      double v8 = v3 + 1;
    }
    if (v7) {
      uint64_t v5 = v3;
    }
    int v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 != v2 && v5[4] <= a2 && (uint64_t v9 = v5[5]) != 0) {
    return CI::Object::ref(v9);
  }
  else {
    return 0;
  }
}

void CI::Color::vector_in_workingspace(CI::Color *this, CGColorSpace **a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  float32x2_t v8 = *(float32x2_t *)((char *)this + 24);
  int v9 = *((_DWORD *)this + 8);
  if (!CI_NO_CM())
  {
    CGColorSpaceRef v4 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
    unint64_t v6 = v4;
    if (*((void *)this + 5)) {
      BOOL v7 = (CI *)*((void *)this + 5);
    }
    else {
      BOOL v7 = v4;
    }
    CI::match_color(&v8, v7, a2[3], v5);
    CGColorSpaceRelease(v6);
  }
  operator new();
}

uint64_t CI_NO_CM()
{
  {
    CI_NO_CM::v = get_BOOL("CI_NO_CM", 0);
  }
  return CI_NO_CM::v;
}

void sub_1936A7374(_Unwind_Exception *a1)
{
}

uint64_t CI::ColorKernelNode::append_to_tree(uint64_t a1, CI::SerialObjectPtrArray *a2, uint64_t a3, int a4)
{
  int v7 = CI::Kernel::num_image_arguments((CI::Kernel *)a1);
  BOOL v8 = (*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1) == 62 && v7 == 2;
  if (!v8 || !*(_DWORD *)(a1 + 172))
  {
LABEL_22:
    if (a4)
    {
      if (*(unsigned char *)(a1 + 165) && v7 == 1)
      {
        int image_argument = CI::Kernel::index_of_first_image_argument((CI::Kernel *)a1);
        int v14 = image_argument;
        if (image_argument > 9) {
          float v15 = (uint64_t *)(*((void *)a2 + 2) + 8 * (image_argument - 10));
        }
        else {
          float v15 = (uint64_t *)((char *)a2 + 8 * image_argument + 24);
        }
        uint64_t v25 = *v15;
        if ((*(unsigned int (**)(uint64_t))(*(void *)*v15 + 232))(*v15))
        {
          if (((*(uint64_t (**)(uint64_t))(*(void *)v25 + 176))(v25) & 1) == 0)
          {
            int v27 = (CI::Object *)v25;
            while (1)
            {
              int v26 = v27;
              int v27 = (CI::Object *)(*(uint64_t (**)(CI::Object *, void))(*(void *)v27 + 48))(v27, 0);
              if (((*(uint64_t (**)(CI::Object *))(*(void *)v27 + 232))(v27) & 1) == 0) {
                break;
              }
              if ((*(uint64_t (**)(CI::Object *))(*(void *)v27 + 176))(v27)) {
                goto LABEL_52;
              }
            }
LABEL_53:
            CI::Object::ref(v25);
            CI::SerialObjectPtrArray::replace(a2, v27, v14);
            operator new();
          }
          int v26 = 0;
          int v27 = (CI::Object *)v25;
LABEL_52:
          if (v26) {
            goto LABEL_53;
          }
        }
        operator new();
      }
      if (*(unsigned char *)(a1 + 165) && v7 >= 2)
      {
        int v16 = 0;
        int v17 = 0;
        long long v32 = 0x3FF0000000000000uLL;
        *(void *)&long long v33 = 0;
        *((void *)&v33 + 1) = 0x3FF0000000000000;
        int v18 = 1;
        int v19 = 1;
        long long v34 = 0uLL;
        do
        {
          int v20 = CI::Kernel::index_of_nth_image_argument((CI::Kernel *)a1, v16);
          if (v20 > 9) {
            BOOL v21 = (void *)(*((void *)a2 + 2) + 8 * (v20 - 10));
          }
          else {
            BOOL v21 = (void *)((char *)a2 + 8 * v20 + 24);
          }
          uint64_t v22 = *v21;
          if ((*(unsigned int (**)(void))(*(void *)*v21 + 16))(*v21) != 28) {
            int v18 = ((*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22) == 35) & v18;
          }
          if ((*(unsigned int (**)(uint64_t))(*(void *)v22 + 16))(v22) == 28)
          {
            long long v23 = *(_OWORD *)(v22 + 72);
            long long v29 = *(_OWORD *)(v22 + 56);
            long long v30 = v23;
            long long v31 = *(_OWORD *)(v22 + 88);
            BOOL isOrientationWithIntegralTranslation = CI::Affine::isOrientationWithIntegralTranslation((CI::Affine *)&v29);
            if ((v17 & 1) == 0)
            {
              long long v32 = v29;
              long long v33 = v30;
              long long v34 = v31;
            }
            v19 &= isOrientationWithIntegralTranslation;
            int v17 = 1;
          }
          ++v16;
        }
        while (v7 != v16);
        if (v18 & v17 & v19)
        {
          CI::Affine::inverse((CI::Affine *)&v32, (double *)&v29);
          operator new();
        }
      }
    }
    operator new();
  }
  uint64_t v10 = *((void *)a2 + 3);
  uint64_t v9 = *((void *)a2 + 4);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 16))(v10) == 35)
  {
    v35.origin.double x = (*(double (**)(uint64_t))(*(void *)v10 + 160))(v10);
    IsEmptdouble y = CGRectIsEmpty(v35);
  }
  else
  {
    IsEmptdouble y = 0;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 16))(v9) == 35)
  {
    v36.origin.double x = (*(double (**)(uint64_t))(*(void *)v9 + 160))(v9);
    BOOL v12 = CGRectIsEmpty(v36);
    if (!IsEmpty) {
      goto LABEL_16;
    }
  }
  else
  {
    BOOL v12 = 0;
    if (!IsEmpty) {
      goto LABEL_16;
    }
  }
  if (*(unsigned char *)(a1 + 162) || (*(unsigned char *)(a1 + 172) & 4) != 0)
  {
LABEL_42:
    CI::SerialObjectPtrArray::~SerialObjectPtrArray(a2);
    MEMORY[0x1997023B0]();
    operator new();
  }
LABEL_16:
  if (v12 && (*(unsigned char *)(a1 + 172) & 8) != 0) {
    goto LABEL_42;
  }
  if (IsEmpty && (*(unsigned char *)(a1 + 172) & 1) != 0)
  {
    CI::Object::ref(v9);
    CI::SerialObjectPtrArray::~SerialObjectPtrArray(a2);
    MEMORY[0x1997023B0]();
  }
  else
  {
    if (!v12 || (*(unsigned char *)(a1 + 172) & 2) == 0) {
      goto LABEL_22;
    }
    CI::Object::ref(v10);
    CI::SerialObjectPtrArray::~SerialObjectPtrArray(a2);
    MEMORY[0x1997023B0]();
    return v10;
  }
  return v9;
}

void CI::match_color(float32x2_t *this, CI *a2, CGColorSpace *a3, CGColorSpace *a4)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (a2 == a3 || !a2 || !a3) {
    return;
  }
  CMatrix::CMatrix((CMatrix *)v43);
  CMatrix::CMatrix((CMatrix *)v42);
  double v40 = 1.0;
  double v41 = 1.0;
  colorspace_gamma_and_matridouble x = CI::get_colorspace_gamma_and_matrix(a2, (CGColorSpace *)&v41, v43, v7);
  char v10 = CI::get_colorspace_gamma_and_matrix(a3, (CGColorSpace *)&v40, v42, v9);
  if (colorspace_gamma_and_matrix && (v10 & 1) != 0)
  {
    CMatrix::inverse((CMatrix *)v42, (unsigned int *)&v44);
    CMatrix::operator*((unsigned int *)v43, &v44, (unsigned int *)&v46);
    int v11 = CMatrix::isNearIdentity((CMatrix *)&v46, 0.001);
    char v12 = v11;
    long double v13 = v41;
    if (v11 && v41 == v40) {
      return;
    }
    float v15 = this->f32[0];
    float v14 = this->f32[1];
    double v16 = this->f32[0];
    double v17 = v14;
    float v18 = this[1].f32[0];
    long double v19 = v18;
    if (v41 == -1.0)
    {
      if (v16 >= 0.04045) {
        double v16 = pow(v16 * 0.947867299 + 0.0521327014, 2.4);
      }
      else {
        double v16 = v16 * 0.0773993808;
      }
      if (v17 >= 0.04045) {
        double v17 = pow(v17 * 0.947867299 + 0.0521327014, 2.4);
      }
      else {
        double v17 = v17 * 0.0773993808;
      }
      if (v19 < 0.04045)
      {
        long double v19 = v19 * 0.0773993808;
        goto LABEL_34;
      }
      double v24 = v19 * 0.947867299 + 0.0521327014;
      long double v25 = 2.4;
    }
    else
    {
      if (v41 == 0.0 || v41 == 1.0) {
        goto LABEL_34;
      }
      double v22 = pow(this->f32[0], v41);
      if (v15 >= 0.0) {
        double v16 = v22;
      }
      else {
        double v16 = 0.0;
      }
      double v23 = pow(v14, v13);
      if (v14 >= 0.0) {
        double v17 = v23;
      }
      else {
        double v17 = 0.0;
      }
      if (v18 < 0.0)
      {
        long double v19 = 0.0;
LABEL_34:
        if ((v12 & 1) == 0)
        {
          CMatrix::transpose((CMatrix *)&v46, (unsigned int *)&v38);
          CMatrix::CMatrix((CMatrix *)v37, 3u, 1u, v16, v26, v27, *(void *)&v17, *(void *)&v19);
          CMatrix::operator*((unsigned int *)&v38, v37, (unsigned int *)&v44);
          uint64_t v38 = CMatrix::operator[]((unsigned int *)&v44, 0);
          uint64_t v39 = v28;
          double v16 = *(double *)CMatrixRow::operator[]((uint64_t)&v38, 0);
          uint64_t v38 = CMatrix::operator[]((unsigned int *)&v44, 1u);
          uint64_t v39 = v29;
          double v17 = *(double *)CMatrixRow::operator[]((uint64_t)&v38, 0);
          uint64_t v38 = CMatrix::operator[]((unsigned int *)&v44, 2u);
          uint64_t v39 = v30;
          long double v19 = *(double *)CMatrixRow::operator[]((uint64_t)&v38, 0);
        }
        double v31 = v40;
        if (v40 == -1.0)
        {
          if (v16 >= 0.0031308) {
            double v32 = pow(v16, 0.4166667) * 1.055 + -0.055;
          }
          else {
            double v32 = v16 * 12.92;
          }
          if (v17 >= 0.0031308) {
            double v33 = pow(v17, 0.4166667) * 1.055 + -0.055;
          }
          else {
            double v33 = v17 * 12.92;
          }
          if (v19 >= 0.0031308) {
            long double v19 = pow(v19, 0.4166667) * 1.055 + -0.055;
          }
          else {
            long double v19 = v19 * 12.92;
          }
        }
        else if (v40 == 0.0 || v40 == 1.0)
        {
          double v32 = v16;
          double v33 = v17;
        }
        else
        {
          double v33 = 0.0;
          double v32 = 0.0;
          if (v16 >= 0.0) {
            double v32 = pow(v16, 1.0 / v40);
          }
          if (v17 >= 0.0) {
            double v33 = pow(v17, 1.0 / v31);
          }
          if (v19 >= 0.0) {
            long double v19 = pow(v19, 1.0 / v31);
          }
          else {
            long double v19 = 0.0;
          }
        }
        float32_t v34 = v32;
        float32_t v35 = v33;
        this->f32[0] = v34;
        this->f32[1] = v35;
        float32_t v36 = v19;
        this[1].f32[0] = v36;
        return;
      }
      double v24 = v18;
      long double v25 = v13;
    }
    long double v19 = pow(v24, v25);
    goto LABEL_34;
  }
  float64x2_t v46 = vcvtq_f64_f32(*this);
  double v47 = this[1].f32[0];
  uint64_t v48 = 0x3FF0000000000000;
  float64x2_t v44 = 0u;
  *(_OWORD *)int v45 = 0u;
  MEMORY[0x199700F90](a3, 0);
  if (CGColorTransformConvertColorComponents())
  {
    *this = vcvt_f32_f64(v44);
    float32_t v20 = v45[0];
    this[1].f32[0] = v20;
    CGColorTransformRelease();
  }
  else
  {
    CGColorTransformRelease();
    CI::snprintf_cs((CI *)&v46, (char *)0x100, a2, 0);
    CI::snprintf_cs((CI *)&v44, (char *)0x100, a3, 0);
    BOOL v21 = ci_logger_render();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
      CI::match_color((uint64_t)&v46, (uint64_t)&v44, v21);
    }
  }
}

void CMatrix::CMatrix(CMatrix *this)
{
  *(void *)this = 0;
  bzero((char *)this + 8, 0xC8uLL);
}

uint64_t CI::get_colorspace_gamma_and_matrix(CI *this, CGColorSpace *a2, double *a3, CMatrix *a4)
{
  int Type = CGColorSpaceGetType();
  {
    CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgblin_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88]);
  }
  {
    CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgbextlin_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE0]);
  }
  CMatrix::CMatrix((CMatrix *)v80, 3u, 1u, 1.0, v7, v8, 0x3FF0000000000000, 0x3FF0000000000000);
  CMatrix::CMatrix((CMatrix *)v79, 3u, 1u, 0.222488, v10, v11, 0x3FE6F09FA54C5543, 0x3FAF07FFA8C22B89);
  CMatrix::identityMatrix((CMatrix *)3, v78);
  CMatrix::CMatrix((CMatrix *)v77, 3u, 3u, 0.436066, v12, v13, 0x3FCC7A7C9DE05037, 0x3F8C7FFDE7210BE9, 0x3FD8A63F9A49C2C2, 0x3FE6F09FA54C5543, 0x3FB8D9FFBB36A253, 0x3FC24FFC9795B35BLL, 0x3FAF07FFA8C22B89, 0x3FE6D9DFDAC68A93);
  if ((CI *)CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgblin_cs == this
    || (CI *)CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgbextlin_cs == this)
  {
    CMatrix::operator=((unsigned int *)a3, v78);
    *(void *)a2 = 0x3FF0000000000000;
  }
  else
  {
    uint64_t v16 = 0;
    switch(Type)
    {
      case 0:
        goto LABEL_6;
      case 1:
        goto LABEL_17;
      case 3:
        uint64_t v96 = 0;
        memset(v95, 0, sizeof(v95));
        CGColorSpaceGetCalibratedGrayData();
        *(void *)a2 = v96;
        CMatrix::operator=((unsigned int *)a3, v79);
        return 1;
      case 4:
        uint64_t v16 = 1;
        CMatrix::CMatrix((CMatrix *)v76, 3u, 1u, 0.9642, v14, v15, 0x3FF0000000000000, 0x3FEA6594AF4F0D84);
        long long v75 = 0u;
        long long v74 = 0u;
        long long v73 = 0u;
        long long v72 = 0u;
        long long v71 = 0u;
        memset(&v70[26], 0, 64);
        CGColorSpaceGetCalibratedRGBData();
        *(void *)a2 = 0;
        CMatrix::CMatrix((CMatrix *)v70, 3u, 1u, v70[26], v18, v19, *(void *)&v70[27], 0);
        CMatrix::CMatrix((CMatrix *)v68, (const CMatrix *)v70);
        CMatrix::CMatrix((CMatrix *)v67, (const CMatrix *)v76);
        CMatrix::CMatrix((CMatrix *)v95, 3u, 3u, 0.8951, v20, v21, 0x3FD10CB295E9E1B1, 0xBFC4A8C154C985F0, 0xBFE801A36E2EB1C4, 0x3FFB6A7EF9DB22D1, 0x3FA2CA57A786C227, 0x3FA3EAB367A0F909, 0xBFB189374BC6A7F0, 0x3FF0793DD97F62B7);
        CMatrix::CMatrix((CMatrix *)v94, 3u, 3u, 0.986993, v22, v23, 0xBFC2D2AA5C5F7C67, 0x3FC479AAE6C8F755, 0x3FDBAAE297396D09, 0x3FE09667B5F1BEF5, 0x3FA93CAB81F969E4, 0xBF8177A7008A697BLL, 0x3FA480841EDE1199, 0x3FEEFDD872F33CA3);
        CMatrix::operator*((unsigned int *)v95, v68, v93);
        CMatrix::operator*((unsigned int *)v95, v67, v92);
        uint64_t v81 = CMatrix::operator[](v92, 0);
        uint64_t v82 = v24;
        double v25 = *(double *)CMatrixRow::operator[]((uint64_t)&v81, 0);
        v69[0] = CMatrix::operator[](v93, 0);
        v69[1] = v26;
        double v27 = v25 / *(double *)CMatrixRow::operator[]((uint64_t)v69, 0);
        uint64_t v89 = CMatrix::operator[](v92, 1u);
        uint64_t v90 = v28;
        double v29 = *(double *)CMatrixRow::operator[]((uint64_t)&v89, 0);
        uint64_t v87 = CMatrix::operator[](v93, 1u);
        uint64_t v88 = v30;
        *(double *)&uint64_t v31 = v29 / *(double *)CMatrixRow::operator[]((uint64_t)&v87, 0);
        uint64_t v85 = CMatrix::operator[](v92, 2u);
        uint64_t v86 = v32;
        double v33 = *(double *)CMatrixRow::operator[]((uint64_t)&v85, 0);
        uint64_t v83 = CMatrix::operator[](v93, 2u);
        uint64_t v84 = v34;
        float32_t v35 = (double *)CMatrixRow::operator[]((uint64_t)&v83, 0);
        CMatrix::diagonalMatrix((CMatrix *)3, v27, v91, v31, v33 / *v35);
        CMatrix::operator*(v94, v91, (unsigned int *)&v81);
        CMatrix::operator*((unsigned int *)&v81, v95, (unsigned int *)v69);
        CMatrix::CMatrix((CMatrix *)v94, 3u, 1u, *((double *)&v71 + 1), v36, v37, v72);
        CMatrix::operator*((unsigned int *)v69, v94, (unsigned int *)v95);
        CMatrix::CMatrix((CMatrix *)v93, 3u, 1u, *(double *)&v73, v38, v39, *((void *)&v73 + 1), (void)v74);
        CMatrix::operator*((unsigned int *)v69, v93, v94);
        CMatrix::CMatrix((CMatrix *)v92, 3u, 1u, *((double *)&v74 + 1), v40, v41, v75);
        CMatrix::operator*((unsigned int *)v69, v92, v93);
        CMatrix::inverse((CMatrix *)v77, v92);
        uint64_t v81 = CMatrix::operator[]((unsigned int *)v95, 0);
        uint64_t v82 = v42;
        double v43 = *(double *)CMatrixRow::operator[]((uint64_t)&v81, 0);
        uint64_t v89 = CMatrix::operator[]((unsigned int *)v95, 1u);
        uint64_t v90 = v44;
        uint64_t v45 = *(void *)CMatrixRow::operator[]((uint64_t)&v89, 0);
        uint64_t v87 = CMatrix::operator[]((unsigned int *)v95, 2u);
        uint64_t v88 = v46;
        uint64_t v47 = *(void *)CMatrixRow::operator[]((uint64_t)&v87, 0);
        uint64_t v85 = CMatrix::operator[](v94, 0);
        uint64_t v86 = v48;
        uint64_t v49 = *(void *)CMatrixRow::operator[]((uint64_t)&v85, 0);
        uint64_t v83 = CMatrix::operator[](v94, 1u);
        uint64_t v84 = v50;
        uint64_t v51 = *(void *)CMatrixRow::operator[]((uint64_t)&v83, 0);
        v66[0] = CMatrix::operator[](v94, 2u);
        v66[1] = v52;
        uint64_t v53 = *(void *)CMatrixRow::operator[]((uint64_t)v66, 0);
        v65[0] = CMatrix::operator[](v93, 0);
        v65[1] = v54;
        uint64_t v55 = *(void *)CMatrixRow::operator[]((uint64_t)v65, 0);
        v64[0] = CMatrix::operator[](v93, 1u);
        v64[1] = v56;
        uint64_t v57 = *(void *)CMatrixRow::operator[]((uint64_t)v64, 0);
        v63[0] = CMatrix::operator[](v93, 2u);
        v63[1] = v58;
        BOOL v59 = CMatrixRow::operator[]((uint64_t)v63, 0);
        CMatrix::CMatrix((CMatrix *)v91, 3u, 3u, v43, v60, v61, v45, v47, v49, v51, v53, v55, v57, *v59);
        CMatrix::operator*(v91, v92, (unsigned int *)&v81);
        CMatrix::operator=((unsigned int *)a3, (unsigned int *)&v81);
        return v16;
      case 6:
        {
          CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgb_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
        }
        {
          CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::esrgb_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE8]);
        }
        {
          CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::ggray_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
        }
        if ((CI *)CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgb_cs == this
          || (CI *)CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::esrgb_cs == this)
        {
LABEL_17:
          double v17 = v78;
        }
        else
        {
          if ((CI *)CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::ggray_cs != this) {
            return 0;
          }
LABEL_6:
          double v17 = v79;
        }
        CMatrix::operator=((unsigned int *)a3, v17);
        *(void *)a2 = 0xBFF0000000000000;
        break;
      default:
        return v16;
    }
  }
  return 1;
}

void CMatrix::CMatrix(CMatrix *this, unsigned int a2, unsigned int a3, double a4, uint64_t a5, uint64_t a6, ...)
{
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  if (a2 > 5 || a3 >= 6) {
    *(void *)this = 0;
  }
  bzero((char *)this + 8, 0xC8uLL);
  *((double *)this + 1) = a4;
  uint64_t v12 = &a5;
  uint64_t v8 = (*((_DWORD *)this + 1) * *(_DWORD *)this);
  if (v8 >= 2)
  {
    uint64_t v9 = (uint64_t *)((char *)this + 16);
    uint64_t v10 = v8 - 1;
    do
    {
      uint64_t v11 = v12++;
      *v9++ = *v11;
      --v10;
    }
    while (v10);
  }
}

unsigned int *CMatrix::operator=(unsigned int *a1, unsigned int *a2)
{
  if (a1 != a2)
  {
    unsigned int v3 = *a2;
    unsigned int v4 = a2[1];
    *a1 = *a2;
    a1[1] = v4;
    memcpy(a1 + 2, a2 + 2, 8 * v3 * (unint64_t)v4);
  }
  return a1;
}

void CMatrix::identityMatrix(CMatrix *this@<X0>, unsigned int *a2@<X8>)
{
  int v2 = (int)this;
  *a2 = this;
  a2[1] = this;
  if (this >= 6)
  {
    *(void *)a2 = 0;
    bzero(a2 + 2, 0xC8uLL);
  }
  else
  {
    bzero(a2 + 2, 0xC8uLL);
    if (!v2) {
      return;
    }
  }
  int v4 = 0;
  unint64_t v5 = 0;
  LODWORD(v7) = *a2;
  unsigned int v6 = a2[1];
  if (*a2 >= v6) {
    unint64_t v7 = v6;
  }
  else {
    unint64_t v7 = v7;
  }
  uint64_t v8 = a2 + 2;
  do
  {
    uint64_t v9 = &v8[2 * v4];
    if (v5 >= v7) {
      uint64_t v9 = &CMatrixRow::operator[]const::zero;
    }
    *uint64_t v9 = 0x3FF0000000000000;
    ++v5;
    v4 += v6;
    v8 += 2;
  }
  while (v2 != v5);
}

uint64_t CMatrix::isNearIdentity(CMatrix *this, double a2)
{
  unint64_t v2 = *(unsigned int *)this;
  if (v2 == *((_DWORD *)this + 1))
  {
    if (v2)
    {
      unsigned int v3 = 0;
      unint64_t v4 = 0;
      BOOL v5 = 0;
      while (2)
      {
        for (uint64_t i = 0; i != v2; ++i)
        {
          if (v4 == i) {
            double v7 = *((double *)this + (v2 * v4) + v4 + 1) + -1.0;
          }
          else {
            double v7 = *((double *)this + v3 + i + 1);
          }
          if (fabs(v7) >= a2)
          {
            char v8 = v5;
            return v8 & 1;
          }
        }
        ++v4;
        v3 += v2;
        char v8 = 1;
        BOOL v5 = v4 >= v2;
        if (v4 != v2) {
          continue;
        }
        break;
      }
    }
    else
    {
      char v8 = 1;
    }
  }
  else
  {
    char v8 = 0;
  }
  return v8 & 1;
}

CI::AffineImage *CI::AffineImage::AffineImage(CI::AffineImage *this, CI::Image *a2, const CI::Affine *a3, int a4)
{
  char v8 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v8 + 14) = &unk_1EE45ACB0;
  atomic_fetch_add(dword_1EB466E78, 1u);
  *(void *)char v8 = &unk_1EE457850;
  *((void *)v8 + 14) = &unk_1EE4579A8;
  long long v9 = *(_OWORD *)a3;
  long long v10 = *((_OWORD *)a3 + 1);
  *(_OWORD *)((char *)v8 + 152) = *((_OWORD *)a3 + 2);
  *(_OWORD *)((char *)v8 + 136) = v10;
  *(_OWORD *)((char *)v8 + 120) = v9;
  *((unsigned char *)v8 + 168) = a4;
  *((void *)this + 10) = CI::AffineImage::makeDigest(*((void *)a2 + 10), (char *)a3, a4);
  *((void *)this + 11) = CI::AffineImage::makeDigest(*((void *)a2 + 11), (char *)a3, a4);
  if (!CI::Affine::isOrientationWithIntegralTranslation(a3)) {
    *((unsigned char *)this + 97) = 0;
  }
  return this;
}

void sub_1936A8C10(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

CI::ImageWithChild *CI::ImageWithChild::ImageWithChild(CI::ImageWithChild *this, CI::Image *a2)
{
  *((_DWORD *)this + 2) = 1;
  *(void *)this = &unk_1EE45DAA8;
  long long v4 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
  *((_OWORD *)this + 1) = *MEMORY[0x1E4F1DB20];
  *((_OWORD *)this + 2) = v4;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((_WORD *)this + 48) = 0;
  *((_DWORD *)this + 25) = atomic_fetch_add(&CI::gImageCounter, 1u) + 1;
  *(void *)this = &unk_1EE459AB8;
  if (!a2) {
    operator new();
  }
  uint64_t v5 = CI::Object::ref((uint64_t)a2);
  int v6 = *((_DWORD *)a2 + 18) + 1;
  *((void *)this + 13) = v5;
  *((_DWORD *)this + 18) = v6;
  *((_WORD *)this + 48) = *((_WORD *)a2 + 48);
  return this;
}

unint64_t CI::AffineImage::makeDigest(uint64_t a1, char *a2, int a3)
{
  XXH64_reset(v7, 0);
  LODWORD(__src) = 2;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  uint64_t __src = a1;
  XXH64_update((uint64_t)v7, (char *)&__src, 8uLL);
  XXH64_update((uint64_t)v7, a2, 0x30uLL);
  LODWORD(__src) = a3;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v7);
}

BOOL CI::Affine::isOrientationWithIntegralTranslation(CI::Affine *this)
{
  if ((fabs(*(double *)this) == 1.0 || *(double *)this == 0.0)
    && ((double v1 = *((double *)this + 1), fabs(v1) == 1.0) || v1 == 0.0)
    && ((double v2 = *((double *)this + 2), fabs(v2) == 1.0) || v2 == 0.0)
    && ((double v3 = *((double *)this + 3), fabs(v3) == 1.0) || v3 == 0.0)
    && vabdd_f64(*((double *)this + 4), round(*((double *)this + 4))) < 1.0e-10)
  {
    return vabdd_f64(*((double *)this + 5), round(*((double *)this + 5))) < 1.0e-10;
  }
  else
  {
    return 0;
  }
}

uint64_t get_BOOL(const char *a1, uint64_t a2)
{
  long long v4 = getenv(a1);
  if (v4)
  {
    unsigned int v5 = atoi(v4);
    if (v5 <= 1) {
      return v5 != 0;
    }
    return a2;
  }
  if (userDefaults(void)::didCheck != -1) {
    dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_193);
  }
  int v6 = objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      return a2;
    }
  }

  return [v6 BOOLValue];
}

void CMatrix::inverse(CMatrix *this@<X0>, unsigned int *a2@<X8>)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  int v4 = *((_DWORD *)this + 1);
  if (*(_DWORD *)this != 3 || v4 != 3)
  {
    if (*(_DWORD *)this != v4)
    {
      CMatrix::transpose(this, (unsigned int *)v27);
      CMatrix::operator*((unsigned int *)v27, this, v26);
      CMatrix::inverse(v25, (CMatrix *)v26);
      CMatrix::operator*((unsigned int *)v25, v27, a2);
      return;
    }
    goto LABEL_8;
  }
  double v6 = *((double *)this + 1);
  double v7 = *((double *)this + 2);
  double v8 = *((double *)this + 3);
  double v9 = *((double *)this + 4);
  double v10 = *((double *)this + 5);
  double v11 = *((double *)this + 6);
  double v12 = *((double *)this + 7);
  double v13 = *((double *)this + 8);
  double v14 = *((double *)this + 9);
  v27[0] = v10 * v14 - v13 * v11;
  v27[1] = v13 * v8 - v7 * v14;
  v27[2] = v7 * v11 - v10 * v8;
  double v28 = v12 * v11 - v9 * v14;
  double v29 = v6 * v14 - v12 * v8;
  double v30 = v9 * v8 - v6 * v11;
  double v31 = v9 * v13 - v12 * v10;
  double v32 = v12 * v7 - v6 * v13;
  double v33 = v6 * v10 - v9 * v7;
  double v15 = v7 * v28 + v6 * v27[0] + v8 * v31;
  if (fabs(v15) < 1.0e-10)
  {
LABEL_8:
    *(void *)a2 = 0;
    bzero(a2 + 2, 0xC8uLL);
    return;
  }
  *(void *)a2 = 0x300000003;
  bzero(a2 + 2, 0xC8uLL);
  int v16 = 0;
  unint64_t v17 = 0;
  unint64_t v18 = *a2;
  unint64_t v19 = a2[1];
  uint64_t v20 = v27;
  do
  {
    unint64_t v21 = 0;
    uint64_t v22 = (uint64_t)&a2[2 * v16 + 2];
    do
    {
      if (v21 >= v19 || v17 >= v18) {
        uint64_t v24 = (double *)&CMatrixRow::operator[]const::zero;
      }
      else {
        uint64_t v24 = (double *)v22;
      }
      *uint64_t v24 = v20[v21++] / v15;
      v22 += 8;
    }
    while (v21 != 3);
    ++v17;
    v20 += 3;
    v16 += v19;
  }
  while (v17 != 3);
}

uint64_t CMatrix::columnCount(CMatrix *this)
{
  return *((unsigned int *)this + 1);
}

CI::PremultiplyNode *CI::PremultiplyNode::append_to_tree(CI::PremultiplyNode *this, CI::Node *a2, int a3)
{
  double v3 = this;
  if (a2)
  {
    int v5 = (int)a2;
    if (a3 && (*(unsigned int (**)(CI::PremultiplyNode *))(*(void *)this + 232))(this))
    {
      double v6 = 0;
      double v7 = v3;
      while (1)
      {
        double v8 = v7;
        if ((*(uint64_t (**)(CI::PremultiplyNode *))(*(void *)v7 + 176))(v7)) {
          break;
        }
        double v7 = (CI::PremultiplyNode *)(*(uint64_t (**)(CI::PremultiplyNode *, void))(*(void *)v7 + 48))(v7, 0);
        double v6 = v8;
        if (((*(uint64_t (**)(CI::PremultiplyNode *))(*(void *)v7 + 232))(v7) & 1) == 0) {
          goto LABEL_9;
        }
      }
      double v8 = v6;
    }
    else
    {
      double v8 = 0;
      double v7 = v3;
    }
LABEL_9:
    if ((*(unsigned int (**)(CI::PremultiplyNode *))(*(void *)v7 + 264))(v7)) {
      goto LABEL_10;
    }
    if ((*(unsigned int (**)(CI::PremultiplyNode *))(*(void *)v7 + 16))(v7) == 40)
    {
      if (!(*((_DWORD *)v7 + 14) + v5))
      {
        double v7 = (CI::PremultiplyNode *)*((void *)v7 + 5);
        if (!v7)
        {
LABEL_26:
          if (!v8) {
            return v7;
          }
          (*(void (**)(CI::PremultiplyNode *, CI::PremultiplyNode *, void))(*(void *)v8 + 200))(v8, v7, 0);
          if (v7) {
            CI::Object::unref(v7);
          }
          if (v3) {
            CI::Object::ref((uint64_t)v3);
          }
          return v3;
        }
LABEL_10:
        CI::Object::ref((uint64_t)v7);
        goto LABEL_26;
      }
    }
    else if (v5 == -1)
    {
      if (a3)
      {
        if ((*(unsigned int (**)(CI::PremultiplyNode *))(*(void *)v7 + 16))(v7) == 31)
        {
          uint64_t v10 = (*(uint64_t (**)(CI::PremultiplyNode *, void))(*(void *)v7 + 48))(v7, 0);
          if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 16))(v10) == 40)
          {
            double v11 = (_DWORD *)(*(uint64_t (**)(CI::PremultiplyNode *, void))(*(void *)v7 + 48))(v7, 0);
            if (v11[14] == 1)
            {
              (*(void (**)(_DWORD *, void))(*(void *)v11 + 48))(v11, 0);
              operator new();
            }
            operator new();
          }
        }
      }
    }
    operator new();
  }
  if (!this) {
    return v3;
  }

  return (CI::PremultiplyNode *)CI::Object::ref((uint64_t)this);
}

uint64_t CI::Node::isMultiUse(CI::Node *this)
{
  return *((unsigned __int8 *)this + 32);
}

void CI::NodeWithChild::set_child(CI::NodeWithChild *this, CI::Node *a2, int a3)
{
  if (!a3)
  {
    int v4 = (CI::Object *)*((void *)this + 5);
    uint64_t v5 = a2 ? CI::Object::ref((uint64_t)a2) : 0;
    *((void *)this + 5) = v5;
    if (v4)
    {
      CI::Object::unref(v4);
    }
  }
}

uint64_t CI_FORCE_INSERT_NOOPS()
{
  {
    CI_FORCE_INSERT_NOOPS::v = get_Y_or_N("CI_FORCE_INSERT_NOOPS");
  }
  return CI_FORCE_INSERT_NOOPS::v;
}

void sub_1936A9640(_Unwind_Exception *a1)
{
}

CI::Object *CI::SRGBNode::append_to_tree(CI::SRGBNode *this, CI::Node *a2, int a3)
{
  double v3 = this;
  if (a2)
  {
    int v4 = (int)a2;
    if (a3 && (*(unsigned int (**)(CI::SRGBNode *))(*(void *)this + 232))(this))
    {
      uint64_t v5 = 0;
      double v6 = v3;
      while (1)
      {
        double v7 = v6;
        if ((*(uint64_t (**)(CI::Object *))(*(void *)v6 + 176))(v6)) {
          break;
        }
        double v6 = (CI::Object *)(*(uint64_t (**)(CI::Object *, void))(*(void *)v6 + 48))(v6, 0);
        uint64_t v5 = v7;
        if (((*(uint64_t (**)(CI::Object *))(*(void *)v6 + 232))(v6) & 1) == 0) {
          goto LABEL_9;
        }
      }
      double v7 = v5;
    }
    else
    {
      double v7 = 0;
      double v6 = v3;
    }
LABEL_9:
    int v8 = (*(uint64_t (**)(CI::Object *))(*(void *)v6 + 16))(v6);
    uint64_t v9 = *(void *)v6;
    if (v8 == 35)
    {
      if (!(*(unsigned int (**)(CI::Object *))(v9 + 416))(v6)) {
        goto LABEL_25;
      }
    }
    else
    {
      if ((*(unsigned int (**)(CI::Object *))(v9 + 16))(v6) != 38 || *((_DWORD *)v6 + 14) + v4) {
LABEL_25:
      }
        operator new();
      double v6 = (CI::Object *)*((void *)v6 + 5);
      if (!v6) {
        goto LABEL_20;
      }
    }
    CI::Object::ref((uint64_t)v6);
LABEL_20:
    if (!v7) {
      return v6;
    }
    (*(void (**)(CI::Object *, CI::Object *, void))(*(void *)v7 + 200))(v7, v6, 0);
    if (v6) {
      CI::Object::unref(v6);
    }
    if (v3) {
      CI::Object::ref((uint64_t)v3);
    }
    return v3;
  }
  if (!this) {
    return v3;
  }

  return (CI::Object *)CI::Object::ref((uint64_t)this);
}

uint64_t get_Y_or_N(const char *a1)
{
  double v2 = getenv(a1);
  if (!v2)
  {
    if (userDefaults(void)::didCheck != -1) {
      dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_193);
    }
    double v6 = objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if ([v6 intValue] == 1) {
        return 89;
      }
      if (![v6 intValue]) {
        return 78;
      }
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if ([v6 isEqual:@"Y"] & 1) != 0 || (objc_msgSend(v6, "isEqual:", @"y")) {
        return 89;
      }
      if ([v6 isEqual:@"N"] & 1) != 0 || (objc_msgSend(v6, "isEqual:", @"n")) {
        return 78;
      }
    }
    return 0;
  }
  int v3 = *v2;
  uint64_t result = 89;
  char v5 = v3 - 48;
  if ((v3 - 48) > 0x3E) {
    goto LABEL_15;
  }
  if (((1 << v5) & 0x4000000040000001) != 0) {
    return 78;
  }
  if (((1 << v5) & 0x20000000002) == 0)
  {
LABEL_15:
    if (v3 != 121) {
      return 0;
    }
  }
  return result;
}

void sub_1936A9B24(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C400067BF2CLL);
  _Unwind_Resume(a1);
}

CI::ClampToAlphaImage *CI::ClampToAlphaImage::ClampToAlphaImage(CI::ClampToAlphaImage *this, CI::Image *a2)
{
  int v4 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v4 + 14) = &unk_1EE45B2A0;
  atomic_fetch_add(&dword_1EB466E78[6], 1u);
  *(void *)int v4 = &unk_1EE45C5B8;
  *((void *)v4 + 14) = &unk_1EE45C710;
  *((void *)this + 10) = CI::ClampToAlphaImage::makeDigest(*((void *)a2 + 10));
  *((void *)this + 11) = CI::ClampToAlphaImage::makeDigest(*((void *)a2 + 11));
  return this;
}

void sub_1936A9C04(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::ClampToAlphaImage::makeDigest(uint64_t a1)
{
  XXH64_reset(v3, 0);
  LODWORD(__src) = 8;
  XXH64_update((uint64_t)v3, (char *)&__src, 4uLL);
  uint64_t __src = a1;
  XXH64_update((uint64_t)v3, (char *)&__src, 8uLL);
  return XXH64_digest((uint64_t)v3);
}

void ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke_2(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  uint64_t v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

void ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  uint64_t v2 = *(NSObject **)(a1 + 32);

  dispatch_release(v2);
}

void ___ZN2CI11ProgramNode28create_program_and_argumentsEPNS_7ContextEPKc_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(int **)(a1 + 32);
  int v3 = *(CI **)(a1 + 40);
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48)) == 77) {
    int v3 = (CI *)"ciKernelMain";
  }
  x_stream_init(v24);
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48)) == 74
    || (*(unsigned int (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48)) == 77
    || (CI_PRINT_TIME() & 0x100) != 0)
  {
    int v3 = (CI *)(*(uint64_t (**)(int *, void *))(*(void *)v2 + 408))(v2, v24);
  }
  v4.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  if (CI_ENABLE_METAL_DAG()
    && (*(unsigned int (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48)) == 77)
  {
    *((void *)v2 + 15) = CI::create_metal_dag(v3, *(const CI::MetalContext **)(a1 + 48), *(const CI::MetalContext **)(a1 + 56), (const CI::Node *)v2, *((const CI::ProgramNode **)v2 + 16), v5);
    CI_ENABLE_METAL_DAG();
  }
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 48) + 16))(*(void *)(a1 + 48)) == 75)
  {
    uint64_t sw_dag = CI::create_sw_dag(v3, *(const CI::SWContext **)(a1 + 48), *(const CI::SWContext **)(a1 + 56), (const CI::Node *)v2, *((const CI::ProgramNode **)v2 + 16), v6);
    *((void *)v2 + 15) = sw_dag;
    if (!sw_dag) {
      goto LABEL_14;
    }
  }
  else if (!*((void *)v2 + 15))
  {
LABEL_14:
    if (CI_VERBOSE_SIGNPOSTS())
    {
      int v8 = ci_signpost_log_render();
      os_signpost_id_t v9 = v2[9] | (unint64_t)((*(uint64_t (**)(void))(**(void **)(a1 + 48) + 272))(*(void *)(a1 + 48)) << 32);
      if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
      {
        *(_WORD *)CGRect buf = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v8, OS_SIGNPOST_INTERVAL_BEGIN, v9, "create_main_program_fosl", "", buf, 2u);
      }
    }
    uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 272))(*(void *)(a1 + 48));
    TimerBase::TimerBase((uint64_t)v23, v10, v2[9], (uint64_t)"create_main_program_fosl", 0);
    operator new();
  }
  v11.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t v12 = *((void *)v2 + 15);
  *(double *)(v12 + 32) = (double)(v11.__d_.__rep_ - v4.__d_.__rep_) / 1000000000.0;
  *(void *)(v12 + 16) = *((void *)v2 + 20);
  if (CI_ENABLE_KERNEL_CACHE()) {
    CI::Context::cacheMainProgram(*(void *)(a1 + 48), *((void *)v2 + 20), *((CI::Object **)v2 + 15));
  }
  uint64_t CachedMainProgram = CI::Context::findCachedMainProgram(*(void *)(a1 + 48), *((void *)v2 + 20));
  double v14 = (CI::Object *)*((void *)v2 + 15);
  *((unsigned char *)v2 + 168) = CachedMainProgram == (void)v14;
  if (CachedMainProgram)
  {
    if (v14) {
      CI::Object::unref(v14);
    }
    *((void *)v2 + 15) = CachedMainProgram;
  }
  double v15 = *(char **)(a1 + 48);
  if (CI_PRINT_PROGRAM())
  {
    int v16 = (*(uint64_t (**)(char *))(*(void *)v15 + 272))(v15);
    if (CI_PRINT_PROGRAM_context(v16, v15 + 236))
    {
      unint64_t v17 = (FILE *)CI_LOG_FILE();
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 0x40000000;
      void v20[2] = ___ZN2CI11ProgramNode28create_program_and_argumentsEPNS_7ContextEPKc_block_invoke_78;
      v20[3] = &__block_descriptor_tmp_86;
      v20[4] = v2;
      v20[5] = v3;
      v20[6] = *(void *)(a1 + 48);
      int v21 = *(_DWORD *)(a1 + 72);
      stream_to_file(v17, (uint64_t)v20);
    }
  }
  if (CI::MainProgram::num_arguments(*((CI::MainProgram **)v2 + 15)) != **((_DWORD **)v2 + 16))
  {
    unint64_t v18 = (FILE *)CI_LOG_FILE();
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 0x40000000;
    v19[2] = ___ZN2CI11ProgramNode28create_program_and_argumentsEPNS_7ContextEPKc_block_invoke_2;
    v19[3] = &__block_descriptor_tmp_91;
    v19[4] = v2;
    v19[5] = v3;
    stream_to_file(v18, (uint64_t)v19);
  }
  if ((int)CI_ASYNC_KERNEL_COMPILE() >= 2) {
    (*(void (**)(void, void))(**((void **)v2 + 15) + 72))(*((void *)v2 + 15), *(unsigned int *)(a1 + 72));
  }
  x_stream_free((uint64_t)v24);
}

uint64_t CI_ENABLE_METAL_DAG()
{
  {
    CI_ENABLE_METAL_DAG::v = get_int("CI_ENABLE_METAL_DAG", 1);
  }
  return CI_ENABLE_METAL_DAG::v;
}

void sub_1936AA418(_Unwind_Exception *a1)
{
}

void *x_stream_init(void *result)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = 0;
  return result;
}

void x_stream_free(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    free(v2);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
}

char *CI::ProgramNode::make_function_name(uint64_t a1, char **a2)
{
  x_stream_write((uint64_t)a2, "ci", 2uLL);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = ___ZNK2CI11ProgramNode18make_function_nameER15x_stream_struct_block_invoke;
  v5[3] = &__block_descriptor_tmp_5_2;
  v5[4] = a2;
  CI::ProgramNode::traverse_graph_preorder_stoppable(a1, (uint64_t)v5);
  return x_stream_get(a2);
}

char *x_stream_get(char **a1)
{
  uint64_t v2 = a1[1];
  if (v2 + 1 < a1[2]) {
    goto LABEL_4;
  }
  if (x_stream_grow(a1, 1uLL))
  {
    uint64_t v2 = a1[1];
LABEL_4:
    *uint64_t v2 = 0;
    return *a1;
  }
  return 0;
}

void CI::Context::cacheMainProgram(uint64_t a1, uint64_t a2, CI::Object *a3)
{
}

void CI::MetalMainProgram::compileAsync(uint64_t a1, int a2)
{
  uint64_t v2 = *(NSObject **)(a1 + 128);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN2CI16MetalMainProgram12compileAsyncENS_9NodeIndexE_block_invoke;
  _OWORD v3[3] = &__block_descriptor_44_e5_v8__0l;
  void v3[4] = a1;
  int v4 = a2;
  dispatch_sync(v2, v3);
}

uint64_t CI::MetalDAGHelper::process_kernels(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CI::MetalDAGHelper::analyze_kernels(a1, a5);
  if (*(_DWORD *)(a1 + 32))
  {
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    void v8[2] = ___ZN2CI14MetalDAGHelper15build_constantsEPKNS_11ProgramNodeE_block_invoke;
    v8[3] = &__block_descriptor_40_e23_B36__0_v8r_v16i24i28i32l;
    void v8[4] = a1;
    CI::ProgramNode::traverse_graph_preorder_stoppable(a5, (uint64_t)v8);
    CI::MetalContext::use_imageblocks_for_format(*(void *)(a1 + 24), *(_DWORD *)(a5 + 140));
    operator new();
  }
  return 0;
}

void sub_1936AAA08(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x1010C40C0D7B093);
  _Unwind_Resume(a1);
}

void CI::StitchableFunctionDAGDescriptor::create_early_out_function_info(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v4 = objc_alloc(MEMORY[0x1E4F35260]);
    uint64_t v5 = *(void *)(a1 + 112);
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
    uint64_t v7 = MEMORY[0x1E4F1CBF0];
    id v22 = (id)[v4 initWithName:v5 arguments:v6 controlDependencies:MEMORY[0x1E4F1CBF0]];
    int v8 = (void *)[objc_alloc(MEMORY[0x1E4F35258]) initWithCondition:v22 controlDependencies:v7];
    *(void *)(a1 + 40) = v22;
    objc_msgSend(*(id *)(a1 + 72), "addObject:");
    unint64_t v9 = *(void *)(a1 + 64);
    int v10 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)(a1 + 80) = v10 + 1;
    std::chrono::steady_clock::time_point v11 = *(char **)(a1 + 56);
    if ((unint64_t)v11 >= v9)
    {
      double v13 = *(char **)(a1 + 48);
      uint64_t v14 = (v11 - v13) >> 2;
      unint64_t v15 = v14 + 1;
      if ((unint64_t)(v14 + 1) >> 62) {
        abort();
      }
      uint64_t v16 = v9 - (void)v13;
      if (v16 >> 1 > v15) {
        unint64_t v15 = v16 >> 1;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v15;
      }
      if (v17)
      {
        unint64_t v18 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>(a1 + 64, v17);
        double v13 = *(char **)(a1 + 48);
        std::chrono::steady_clock::time_point v11 = *(char **)(a1 + 56);
      }
      else
      {
        unint64_t v18 = 0;
      }
      unint64_t v19 = &v18[4 * v14];
      uint64_t v20 = &v18[4 * v17];
      *(_DWORD *)unint64_t v19 = v10;
      uint64_t v12 = v19 + 4;
      while (v11 != v13)
      {
        int v21 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v19 - 1) = v21;
        v19 -= 4;
      }
      *(void *)(a1 + 48) = v19;
      *(void *)(a1 + 56) = v12;
      *(void *)(a1 + 64) = v20;
      if (v13) {
        operator delete(v13);
      }
    }
    else
    {
      *(_DWORD *)std::chrono::steady_clock::time_point v11 = v10;
      uint64_t v12 = v11 + 4;
    }
    *(void *)(a1 + 56) = v12;
    [*(id *)(a1 + 72) addObject:v8];
    ++*(_DWORD *)(a1 + 80);
  }
}

uint64_t CI::create_metal_dag(CI *this, const CI::MetalContext *a2, const CI::MetalContext *a3, const CI::Node *a4, const CI::ProgramNode *a5, CI::SerialObjectPtrArray *a6)
{
  CI::MetalDAGHelper::MetalDAGHelper((CI::MetalDAGHelper *)v13, a2);
  uint64_t v10 = CI::MetalContext::device((id *)a2);
  uint64_t v11 = CI::MetalDAGHelper::process_kernels((uint64_t)v13, v10, (uint64_t)this, (uint64_t)a3, (uint64_t)a4);
  CI::MetalDAGHelper::~MetalDAGHelper(v13);
  return v11;
}

void sub_1936AAC74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
}

void CI::create_metal_args(CI *this, const CI::MetalContext *a2, const CI::Node *a3, const CI::ProgramNode *a4, CI::SerialObjectPtrArray *a5)
{
  CI::MetalDAGHelper::MetalDAGHelper((CI::MetalDAGHelper *)v9, this);
  CI::MetalContext::device((id *)this);
  CI::MetalDAGHelper::analyze_kernels((uint64_t)v9, (uint64_t)a3);
  CI::MetalDAGHelper::build_dag((CI::MetalDAGHelper *)v9, a2, a3, a4, 1);
  CI::MetalDAGHelper::~MetalDAGHelper(v9);
}

void sub_1936AAD0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
}

uint64_t CI::MetalContext::device(id *this)
{
  return [this[49] device];
}

void CI::MetalDAGHelper::~MetalDAGHelper(id *this)
{
  *this = &unk_1EE459C10;

  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 22), this[23]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy((uint64_t)(this + 19), this[20]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 16), this[17]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 13), this[14]);
  uint64_t v2 = (std::__shared_weak_count *)this[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

{
  uint64_t vars8;

  CI::MetalDAGHelper::~MetalDAGHelper(this);

  JUMPOUT(0x1997023B0);
}

void sub_1936AADAC(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v1 + 176, *(void **)(v1 + 184));
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy(v1 + 152, *(void **)(v1 + 160));
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v1 + 128, *(void **)(v1 + 136));
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v1 + 104, *(void **)(v1 + 112));
  int v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,CI::DAGHelper::TextureReadFunction>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

CI::MetalDAGHelper *CI::MetalDAGHelper::MetalDAGHelper(CI::MetalDAGHelper *this, const CI::MetalContext *a2)
{
  *(void *)this = &unk_1EE459C10;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = a2;
  *((_DWORD *)this + 8) = 0;
  *((unsigned char *)this + 56) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((_OWORD *)this + 5) = xmmword_19394C940;
  *((void *)this + 14) = 0;
  *((void *)this + 13) = (char *)this + 112;
  *((void *)this + 12) = 16;
  *((void *)this + 15) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 16) = (char *)this + 136;
  *((void *)this + 18) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 22) = (char *)this + 184;
  *((void *)this + 19) = (char *)this + 160;
  *((void *)this + 25) = objc_opt_new();
  return this;
}

void sub_1936AAF20(_Unwind_Exception *a1)
{
  uint64_t v6 = v4;
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v6, *(void **)(v1 + 184));
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy(v5, *(void **)(v1 + 160));
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v3, *(void **)(v1 + 136));
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v2, *(void **)(v1 + 112));
  int v8 = *(std::__shared_weak_count **)(v1 + 16);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  _Unwind_Resume(a1);
}

uint64_t CI::MetalDAGHelper::build_dag(CI::MetalDAGHelper *this, const CI::Node *a2, const CI::ProgramNode *a3, CI::SerialObjectPtrArray *a4, uint64_t a5)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v10 = ci_signpost_log_render();
    os_signpost_id_t v11 = *((int *)a3 + 9) | (unint64_t)((*(uint64_t (**)(void))(**((void **)this + 3) + 272))(*((void *)this + 3)) << 32);
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
    {
      *(_WORD *)CGRect buf = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v10, OS_SIGNPOST_INTERVAL_BEGIN, v11, "build_dag", "", buf, 2u);
    }
  }
  uint64_t v12 = (*(uint64_t (**)(void))(**((void **)this + 3) + 272))(*((void *)this + 3));
  TimerBase::TimerBase((uint64_t)v49, v12, *((_DWORD *)a3 + 9), (uint64_t)"build_dag", 5);
  uint64_t v45 = 0;
  uint64_t v46 = &v45;
  uint64_t v47 = 0x2020000000;
  uint64_t v48 = a5 + 1;
  v44[0] = MEMORY[0x1E4F143A8];
  v44[1] = 3221225472;
  v44[2] = ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke;
  v44[3] = &unk_1E5770C20;
  v44[6] = a5;
  v44[7] = a3;
  v44[8] = a4;
  v44[4] = &v45;
  v44[5] = this;
  CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v44, (uint64_t)&__block_literal_global_89);
  *(void *)CGRect buf = 0;
  uint64_t v37 = buf;
  uint64_t v38 = 0x4012000000;
  uint64_t v39 = __Block_byref_object_copy__25;
  uint64_t v40 = __Block_byref_object_dispose__25;
  uint64_t v41 = "";
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  if (*((unsigned char *)a3 + 136))
  {
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 3221225472;
    v35[2] = ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_44;
    v35[3] = &unk_1E5770C68;
    v35[6] = this;
    v35[7] = a5;
    v35[8] = a3;
    v35[9] = a4;
    v35[4] = &v45;
    int64x2_t v35[5] = buf;
    CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v35, 0);
  }
  else
  {
    v34[0] = MEMORY[0x1E4F143A8];
    v34[1] = 3221225472;
    v34[2] = ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_2_45;
    void v34[3] = &__block_descriptor_56_e33_v60__0_v8r_v16i24i28_v32Q40_48i56l;
    v34[4] = this;
    v34[5] = a3;
    v34[6] = a4;
    CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v34, (uint64_t)&__block_literal_global_48_1);
    v33[0] = MEMORY[0x1E4F143A8];
    v33[1] = 3221225472;
    v33[2] = ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_4;
    v33[3] = &__block_descriptor_48_e33_v60__0_v8r_v16i24i28_v32Q40_48i56l;
    v33[4] = this;
    v33[5] = a5;
    CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v33, (uint64_t)&__block_literal_global_54);
  }
  v32[0] = MEMORY[0x1E4F143A8];
  v32[1] = 3221225472;
  v32[2] = ___ZN2CI14MetalDAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_6;
  _OWORD v32[3] = &unk_1E5770C68;
  v32[6] = this;
  v32[7] = a5;
  v32[8] = a3;
  v32[9] = a4;
  v32[4] = &v45;
  v32[5] = buf;
  CI::ProgramNode::traverse_dag((uint64_t)a3, (unint64_t)a2, (uint64_t)v32, (uint64_t)&__block_literal_global_56_2);
  double v13 = v37;
  if (!*((_WORD *)v37 + 24) && !*((_WORD *)v37 + 28) && *((void *)this + 21))
  {
    uint64_t v14 = (char *)this + 152;
    uint64_t v15 = *((void *)this + 19);
    unint64_t v31 = *(void *)(v15 + 32);
    if (*(char *)(v15 + 63) < 0) {
      std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)(v15 + 40), *(void *)(v15 + 48));
    }
    else {
      std::string v28 = *(std::string *)(v15 + 40);
    }
    std::vector<unsigned long>::vector(__p, v15 + 64);
    char v30 = *(unsigned char *)(v15 + 88);
    if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v16 = &v28;
    }
    else {
      uint64_t v16 = (std::string *)v28.__r_.__value_.__r.__words[0];
    }
    CI::MetalDAGHelper::add_function_with_name(this, (const char *)v16, 0);
    std::string::size_type size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
    if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v28.__r_.__value_.__l.__size_;
    }
    if (size != 14) {
      goto LABEL_26;
    }
    unint64_t v18 = &v28;
    if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      unint64_t v18 = (std::string *)v28.__r_.__value_.__r.__words[0];
    }
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    uint64_t v20 = *(std::string::size_type *)((char *)v18->__r_.__value_.__r.__words + 6);
    if (v19 == 0x646165725F69635FLL && v20 == 0x6C657869705F6461) {
      CI::MetalDAGHelper::add_read_pixel_function_info((uint64_t)this, *(void *)__p[0], *((void *)__p[0] + 1), *((void *)__p[0] + 2), *((void *)__p[0] + 3));
    }
    else {
LABEL_26:
    }
      CI::MetalDAGHelper::add_read_pixel_420_function_info((uint64_t)this, *(void *)__p[0], *((void *)__p[0] + 1), *((void *)__p[0] + 2), *((void *)__p[0] + 3), *((void *)__p[0] + 4), *((void *)__p[0] + 5), *((void *)__p[0] + 6));
    uint64_t v22 = v46[3];
    v46[3] = v22 + 1;
    uint64_t v23 = (uint64_t **)((char *)this + 128);
    uint64_t v50 = &v31;
    *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)this + 16, &v31, (uint64_t)&std::piecewise_construct, (uint64_t **)&v50)+ 20) = v22;
    if (v30)
    {
      CI::MetalDAGHelper::add_function_with_name(this, "_ci_srgb_to_linear", 0);
      uint64_t v50 = &v31;
      std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)this + 16, &v31, (uint64_t)&std::piecewise_construct, (uint64_t **)&v50);
      CI::MetalDAGHelper::add_colour_inout_function_info((uint64_t)this);
      uint64_t v24 = v46[3];
      v46[3] = v24 + 1;
      uint64_t v50 = &v31;
      *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v23, &v31, (uint64_t)&std::piecewise_construct, (uint64_t **)&v50)+ 20) = v24;
    }
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__erase_unique<unsigned long long>((uint64_t)v14, &v31);
    uint64_t v50 = &v31;
    double v25 = std::__tree<std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v23, &v31, (uint64_t)&std::piecewise_construct, (uint64_t **)&v50);
    *((_OWORD *)v37 + 3) = *(_OWORD *)(v25 + 5);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v28.__r_.__value_.__l.__data_);
    }
    double v13 = v37;
  }
  uint64_t v26 = *((void *)v13 + 6);
  _Block_object_dispose(buf, 8);
  _Block_object_dispose(&v45, 8);
  CI::MetalDAGHelper::build_dag(CI::Node const*,CI::ProgramNode const*,CI::SerialObjectPtrArray *,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)v49);
  return v26;
}

void sub_1936AB568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54)
{
  _Block_object_dispose(&a54, 8);
  _Block_object_dispose((const void *)(v54 - 184), 8);
  CI::MetalDAGHelper::build_dag(CI::Node const*,CI::ProgramNode const*,CI::SerialObjectPtrArray *,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)(v54 - 152));
  _Unwind_Resume(a1);
}

void CI::ProgramNode::traverse_dag_preorder(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = malloc_type_calloc(0x400uLL, 1uLL, 0xC49614F4uLL);
  uint64_t v9 = *(void *)(a1 + 48);
  if (v9 == a2)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    do
    {
      v8[v10++] = 48;
      uint64_t v9 = (*(uint64_t (**)(uint64_t, void))(*(void *)v9 + 48))(v9, 0);
    }
    while (v9 != a2);
  }
  v12[0] = 0;
  v12[1] = 0;
  os_signpost_id_t v11 = v12;
  CI::_traverse_dag((CI::SerialStringArray **)a1, a2, 0, v10, 0, 0, 0, (uint64_t)v8, (uint64_t)&v11, a3, 0, a4);
  free(v8);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v11, v12[0]);
}

void CI::MetalDAGHelper::build_dag(CI::Node const*,CI::ProgramNode const*,CI::SerialObjectPtrArray *,unsigned long)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v2 = ci_signpost_log_render();
    os_signpost_id_t v3 = *((void *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "build_dag", "", v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1936AB764(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void CI::ProgramNode::traverse_dag(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = malloc_type_calloc(0x400uLL, 1uLL, 0xE68F0782uLL);
  uint64_t v9 = *(void *)(a1 + 48);
  if (v9 == a2)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    do
    {
      v8[v10++] = 48;
      uint64_t v9 = (*(uint64_t (**)(uint64_t, void))(*(void *)v9 + 48))(v9, 0);
    }
    while (v9 != a2);
  }
  v12[0] = 0;
  v12[1] = 0;
  os_signpost_id_t v11 = v12;
  CI::_traverse_dag((CI::SerialStringArray **)a1, a2, 0, v10, 0, 0, 0, (uint64_t)v8, (uint64_t)&v11, 0, a3, a4);
  free(v8);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v11, v12[0]);
}

void CI::MetalDAGHelper::analyze_kernels(uint64_t a1, uint64_t a2)
{
  if (*(void *)(*(void *)(a1 + 24) + 1928))
  {
    uint64_t v42 = 0;
    uint64_t v43 = &v42;
    uint64_t v44 = 0x2020000000;
    char v45 = 1;
    uint64_t v38 = 0;
    uint64_t v39 = &v38;
    uint64_t v40 = 0x2020000000;
    char v41 = 1;
    uint64_t v34 = 0;
    float32_t v35 = &v34;
    uint64_t v36 = 0x2020000000;
    char v37 = 0;
    uint64_t v30 = 0;
    unint64_t v31 = &v30;
    uint64_t v32 = 0x2020000000;
    char v33 = 0;
    uint64_t v26 = 0;
    double v27 = &v26;
    uint64_t v28 = 0x2020000000;
    char v29 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = &v22;
    uint64_t v24 = 0x2020000000;
    char v25 = 1;
    uint64_t v18 = 0;
    std::string::size_type v19 = &v18;
    uint64_t v20 = 0x2020000000;
    char v21 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x4012000000;
    uint64_t v14 = __Block_byref_object_copy__59;
    uint64_t v15 = __Block_byref_object_dispose__60;
    uint64_t v16 = "";
    long long v17 = xmmword_19394C970;
    uint64_t v7 = 0;
    int v8 = &v7;
    uint64_t v9 = 0x2020000000;
    char v10 = 0;
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    _OWORD v6[2] = ___ZN2CI14MetalDAGHelper15analyze_kernelsEPKNS_11ProgramNodeEPU19objcproto9MTLDevice11objc_object_block_invoke;
    v6[3] = &unk_1E5774E88;
    v6[13] = a1;
    v6[14] = a2;
    v6[4] = &v26;
    int64x2_t v6[5] = &v7;
    double v6[6] = &v38;
    v6[7] = &v42;
    v6[8] = &v34;
    v6[9] = &v30;
    v6[10] = &v22;
    v6[11] = &v18;
    v6[12] = &v11;
    CI::ProgramNode::traverse_graph_preorder_stoppable(a2, (uint64_t)v6);
    *(_OWORD *)(a1 + 40) = *((_OWORD *)v12 + 3);
    *(unsigned char *)(a1 + 56) = *((unsigned char *)v8 + 24);
    *(unsigned char *)(a1 + 36) = *((unsigned char *)v23 + 24);
    *(unsigned char *)(a1 + 37) = *((unsigned char *)v19 + 24);
    if ((*((unsigned char *)v39 + 24) || *((unsigned char *)v43 + 24))
      && !*((unsigned char *)v35 + 24)
      && (!*((unsigned char *)v27 + 24) || !*(unsigned char *)(a2 + 136) || *((unsigned char *)v31 + 24)))
    {
      int v4 = CI_ENABLE_FUNCTION_STITCHING();
      int v5 = 1;
      if (v4)
      {
        if (*((unsigned char *)v39 + 24)) {
          int v5 = 2;
        }
        else {
          int v5 = 1;
        }
      }
      *(_DWORD *)(a1 + 32) = v5;
      CI::MetalDAGHelper::build_dag_object((CI::MetalDAGHelper *)a1);
    }
    _Block_object_dispose(&v7, 8);
    _Block_object_dispose(&v11, 8);
    _Block_object_dispose(&v18, 8);
    _Block_object_dispose(&v22, 8);
    _Block_object_dispose(&v26, 8);
    _Block_object_dispose(&v30, 8);
    _Block_object_dispose(&v34, 8);
    _Block_object_dispose(&v38, 8);
    _Block_object_dispose(&v42, 8);
  }
}

void sub_1936ABB14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v37 - 224), 8);
  _Block_object_dispose((const void *)(v37 - 192), 8);
  _Block_object_dispose((const void *)(v37 - 160), 8);
  _Block_object_dispose((const void *)(v37 - 128), 8);
  _Block_object_dispose((const void *)(v37 - 96), 8);
  _Block_object_dispose((const void *)(v37 - 64), 8);
  _Unwind_Resume(a1);
}

void CI::ProgramNode::traverse_graph_preorder_stoppable(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  uint64_t v9 = malloc_type_calloc(0x400uLL, 1uLL, 0x7029249AuLL);
  uint64_t v4 = *(void *)(a1 + 48);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 0x40000000;
  v5[2] = ___ZNK2CI11ProgramNode33traverse_graph_preorder_stoppableEU13block_pointerFbPNS_4NodeEPKS1_iiiE_block_invoke;
  v5[3] = &unk_1E5770928;
  void v5[5] = &v6;
  v5[6] = a1;
  v5[4] = a2;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 0x40000000;
  void v10[2] = ___ZN2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPS0_PKS0_iiE_block_invoke;
  void v10[3] = &unk_1E57756F0;
  void v10[4] = v5;
  CI::GraphObject::traverse_preorder_stoppable(v4, 0, 0, 0, (uint64_t)v10);
  free((void *)v7[3]);
  _Block_object_dispose(&v6, 8);
}

void CI::MetalDAGHelper::build_dag_object(CI::MetalDAGHelper *this)
{
  int v2 = *((_DWORD *)this + 8);
  switch(v2)
  {
    case 1:
      std::allocate_shared[abi:nn180100]<CI::LegacyDAGDescriptor,std::allocator<CI::LegacyDAGDescriptor>,BOOL &,BOOL &,void>((char *)this + 36, (char *)this + 37, &v13);
      long long v3 = v13;
      long long v13 = 0uLL;
      uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
      *(_OWORD *)((char *)this + 8) = v3;
      if (!v4) {
        return;
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
      break;
    case 2:
      std::allocate_shared[abi:nn180100]<CI::StitchableFunctionDAGDescriptor,std::allocator<CI::StitchableFunctionDAGDescriptor>,BOOL &,BOOL &,void>((char *)this + 36, (char *)this + 37, &v13);
      uint64_t v5 = *((void *)&v13 + 1);
      uint64_t v6 = (void *)v13;
      if (*((void *)&v13 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v13 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 2);
      *((void *)this + 1) = v6;
      *((void *)this + 2) = v5;
      if (v7)
      {
        std::__shared_weak_count::__release_shared[abi:nn180100](v7);
        uint64_t v6 = (void *)v13;
      }
      uint64_t v8 = CI::MetalDAGHelper::new_function_with_name(this, "_ci_sampler_builder", 0);
      uint64_t v9 = CI::MetalDAGHelper::new_function_with_name(this, "_ci_dest_struct_builder", 0);
      uint64_t v10 = CI::MetalDAGHelper::new_function_with_name(this, "_ci_dest_struct_builder_h", 0);
      uint64_t v11 = CI::MetalDAGHelper::new_function_with_name(this, "_ci_group_destination_builder", 0);
      uint64_t v12 = CI::MetalDAGHelper::new_function_with_name(this, "_ci_group_destination_builder_h", 0);
      v6[18] = v8;
      v6[19] = v9;
      v6[20] = v10;
      v6[21] = v11;
      v6[22] = v12;
      break;
    case 0:
      abort();
    default:
      return;
  }
  if (*((void *)&v13 + 1)) {
    std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v13 + 1));
  }
}

void sub_1936ABDF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CI::PrecompiledKernels::new_specialzied_function(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  dispatch_sync(*(dispatch_queue_t *)(a1 + 56), &__block_literal_global_155_0);
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  uint64_t v6 = *(void **)(a1 + 8 * a3 + 24);
  uint64_t result = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (result)
  {
    uint64_t v8 = result;
    uint64_t v9 = *(void *)v12;
LABEL_3:
    uint64_t v10 = 0;
    while (1)
    {
      if (*(void *)v12 != v9) {
        objc_enumerationMutation(v6);
      }
      uint64_t result = objc_msgSend(*(id *)(*((void *)&v11 + 1) + 8 * v10), "newFunctionWithName:constantValues:error:", objc_msgSend(NSString, "stringWithUTF8String:", a2), *(void *)(a1 + 16), 0);
      if (result) {
        break;
      }
      if (v8 == ++v10)
      {
        uint64_t result = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
        uint64_t v8 = result;
        if (result) {
          goto LABEL_3;
        }
        return result;
      }
    }
  }
  return result;
}

uint64_t CI::MetalDAGHelper::new_function_with_name(CI::MetalDAGHelper *this, const char *a2, unsigned __int8 *a3)
{
  if (*(unsigned char *)(*((void *)this + 3) + 43))
  {
    uint64_t result = CI::MetalDAGHelper::get_precompiled_kernel((uint64_t)this, (uint64_t)a2, 1u);
    if (a3)
    {
      if (result) {
        *a3 |= 7u;
      }
    }
  }
  else
  {
    return CI::MetalDAGHelper::get_precompiled_kernel((uint64_t)this, (uint64_t)a2, 0);
  }
  return result;
}

uint64_t CI::MetalDAGHelper::get_precompiled_kernel(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v3 = *(_DWORD *)(a1 + 32);
  if (v3 == 1) {
    return CI::PrecompiledKernels::new_function(*(void *)(*(void *)(a1 + 24) + 1928), a2, a3);
  }
  if (v3 == 2) {
    return CI::PrecompiledKernels::new_specialzied_function(*(void *)(*(void *)(a1 + 24) + 1936), a2, a3);
  }
  return 0;
}

void std::__shared_weak_count::__release_shared[abi:nn180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void *std::allocate_shared[abi:nn180100]<CI::StitchableFunctionDAGDescriptor,std::allocator<CI::StitchableFunctionDAGDescriptor>,BOOL &,BOOL &,void>@<X0>(char *a1@<X1>, char *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0xD0uLL);
  uint64_t result = std::__shared_ptr_emplace<CI::StitchableFunctionDAGDescriptor>::__shared_ptr_emplace[abi:nn180100]<BOOL &,BOOL &,std::allocator<CI::StitchableFunctionDAGDescriptor>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1936AC0A8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_FUNCTION_STITCHING()
{
  {
    CI_ENABLE_FUNCTION_STITCHING::v = get_BOOL("CI_ENABLE_FUNCTION_STITCHING", 1);
  }
  return CI_ENABLE_FUNCTION_STITCHING::v;
}

void sub_1936AC124(_Unwind_Exception *a1)
{
}

void *std::__shared_ptr_emplace<CI::StitchableFunctionDAGDescriptor>::__shared_ptr_emplace[abi:nn180100]<BOOL &,BOOL &,std::allocator<CI::StitchableFunctionDAGDescriptor>,0>(void *a1, char *a2, char *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1EE45FAA0;
  CI::StitchableFunctionDAGDescriptor::StitchableFunctionDAGDescriptor((CI::StitchableFunctionDAGDescriptor *)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1936AC18C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

CI::StitchableFunctionDAGDescriptor *CI::StitchableFunctionDAGDescriptor::StitchableFunctionDAGDescriptor(CI::StitchableFunctionDAGDescriptor *this, char a2, char a3)
{
  *(void *)this = &unk_1EE45D6A8;
  *((unsigned char *)this + 8) = a2;
  *((unsigned char *)this + 9) = a3;
  *((_WORD *)this + 12) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = objc_opt_new();
  *(void *)this = &unk_1EE45D800;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  uint64_t v4 = objc_opt_new();
  *(_OWORD *)((char *)this + 88) = 0u;
  *((void *)this + 9) = v4;
  *((_DWORD *)this + 20) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((void *)this + 15) = objc_opt_new();
  *((void *)this + 16) = objc_opt_new();
  *((void *)this + 17) = @"ciKernelMain";
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((void *)this + 22) = 0;
  return this;
}

void sub_1936AC290(_Unwind_Exception *a1)
{
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 56) = v5;
    operator delete(v5);
  }
  *(void *)uint64_t v1 = v2;

  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<CI::StitchableFunctionDAGDescriptor>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 112))();
}

void CI::StitchableFunctionDAGDescriptor::~StitchableFunctionDAGDescriptor(id *this)
{
  *this = &unk_1EE45D800;

  uint64_t v2 = this[11];
  int v3 = this[12];
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 48))(*v2);
    }
    ++v2;
  }

  id v4 = this[11];
  if (v4)
  {
    this[12] = v4;
    operator delete(v4);
  }
  id v5 = this[6];
  if (v5)
  {
    this[7] = v5;
    operator delete(v5);
  }
  *this = &unk_1EE45D6A8;
}

{
  uint64_t vars8;

  CI::StitchableFunctionDAGDescriptor::~StitchableFunctionDAGDescriptor(this);

  JUMPOUT(0x1997023B0);
}

void sub_1936AC408(_Unwind_Exception *a1)
{
  int v3 = *(void **)(v1 + 88);
  if (v3)
  {
    *(void *)(v1 + 96) = v3;
    operator delete(v3);
  }
  CI::StitchableFunctionDAGDescriptor::~StitchableFunctionDAGDescriptor(v1);
  *(void *)uint64_t v1 = &unk_1EE45D6A8;

  _Unwind_Resume(a1);
}

uint64_t CI::MetalDAGHelper::add_init_destcoord_function_info(uint64_t this, uint64_t a2)
{
  if (*(void *)(this + 64))
  {
    uint64_t v2 = this;
    if (*(void *)(this + 72))
    {
      id v4 = (void (***)(void))(***(uint64_t (****)(void, uint64_t))(this + 8))(*(void *)(this + 8), 3);
      (**v4)();
      ((void (*)(void (***)(void), uint64_t, void, void))**v4)(v4, 4, 0, 0);
      ((void (*)(void (***)(void), uint64_t, void, uint64_t))**v4)(v4, 4, 0, a2);
      id v5 = *(uint64_t (**)(void))(**(void **)(v2 + 8) + 40);
      return v5();
    }
  }
  return this;
}

uint64_t CI::MetalDAGHelper::add_early_out_function_info(uint64_t this, uint64_t a2)
{
  if (*(void *)(this + 64))
  {
    uint64_t v2 = this;
    if (*(void *)(this + 72))
    {
      id v4 = (void (***)(void))(***(uint64_t (****)(void, uint64_t))(this + 8))(*(void *)(this + 8), 2);
      (**v4)();
      ((void (*)(void (***)(void), uint64_t, void, uint64_t))**v4)(v4, 4, 0, a2);
      id v5 = *(uint64_t (**)(void))(**(void **)(v2 + 8) + 48);
      return v5();
    }
  }
  return this;
}

void CI::MetalDAGHelper::createMetalDAG()
{
}

void sub_1936AC7C0(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  MEMORY[0x1997023B0](v1, 0x10F1C40832F53FDLL);
  _Unwind_Resume(a1);
}

void *CI::MetalDAG::MetalDAG(uint64_t a1, const char *a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LODWORD(v13) = 0;
  uint64_t result = (void *)CI::MetalMainProgram::MetalMainProgram(a1, a3, a2, 0, a5, 0, a6, a7, v13, a8);
  result[22] = &unk_1EE456A58;
  atomic_fetch_add(&dword_1EB466F58[10], 1u);
  *uint64_t result = &unk_1EE45E778;
  result[12] = &unk_1EE45E7E0;
  uint64_t v11 = *a4;
  uint64_t v12 = a4[1];
  result[22] = &unk_1EE45E808;
  result[23] = v11;
  result[24] = v12;
  if (v12)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    uint64_t v11 = result[23];
  }
  *(void *)(v11 + 32) = result[15];
  result[25] = *(void *)(a3 + 1944);
  return result;
}

uint64_t CI::MetalMainProgram::MetalMainProgram(uint64_t a1, uint64_t a2, const char *a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  long long v14 = CI::MainProgram::MainProgram((int64x2_t *)a1, a3, a4, a5, a6);
  v14[6].i64[0] = (uint64_t)&unk_1EE45B160;
  atomic_fetch_add(&dword_1EB466F58[9], 1u);
  v14->i64[0] = (uint64_t)&unk_1EE45BE28;
  v14[6].i64[0] = (uint64_t)&unk_1EE45BE90;
  v14[7].i64[0] = a7;
  v14[7].i64[1] = 0;
  uint64_t v15 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v16 = dispatch_queue_create("CI::KernelCompileQueue", v15);
  *(void *)(a1 + 148) = 0;
  *(void *)(a1 + 128) = v16;
  *(unsigned char *)(a1 + 144) = 0;
  *(void *)(a1 + 156) = 0;
  *(void *)(a1 + 161) = 0;
  *(void *)(a1 + 120) = *(void *)(a2 + 1952);
  *(void *)(a1 + 136) = *(void *)(a2 + 1920);
  *(unsigned char *)(a1 + 144) = CI::MetalContext::use_imageblocks_for_format(a2, *(_DWORD *)a10);
  *(_DWORD *)(a1 + 148) = CIMetalFormatForFormat(*(_DWORD *)a10, (*(unsigned __int8 *)(a10 + 4) >> 1) & 1);
  CFTypeRef v17 = (CFTypeRef)[*(id *)(a2 + 392) device];
  if (v17) {
    CFTypeRef v17 = CFRetain(v17);
  }
  *(void *)(a1 + 152) = v17;
  *(_DWORD *)(a1 + 40) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 272))(a2);
  if (!*(void *)(a1 + 112))
  {
    *(void *)(a1 + 104) = 16;
    CI::MainProgram::num_arguments((CI::MainProgram *)a1);
    operator new();
  }
  *(void *)(a1 + 104) = a8;
  return a1;
}

void sub_1936ACB30(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v3, 0x1010C40C0D7B093);
  *((void *)v1 + 12) = v2;
  atomic_fetch_add((atomic_uint *volatile)(v4 + 268), 0xFFFFFFFF);
  CI::MainProgram::~MainProgram(v1);
  _Unwind_Resume(a1);
}

int64x2_t *CI::MainProgram::MainProgram(int64x2_t *a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  a1->i32[2] = 1;
  a1->i64[0] = (uint64_t)&unk_1EE457C28;
  a1[3].i64[0] = 0;
  i64 = a1[3].i64;
  a1[2].i64[0] = 0;
  a1[1].i64[0] = 0;
  a1[1].i64[1] = 0;
  a1[2].i32[2] = 0;
  a1[3].i64[1] = 0;
  CI::KernelArguments::KernelArguments((int64x2_t *)a1[4].i64, a4, a5);
  a1[5] = vdupq_n_s64(1uLL);
  if (a2) {
    void *i64 = strdup(a2);
  }
  if (a3) {
    a1[3].i64[1] = (uint64_t)strdup(a3);
  }
  return a1;
}

void *CI::KernelArguments::KernelArguments(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = a2;
  result[1] = a3;
  return result;
}

uint64_t CI_PRINT_PROGRAM()
{
  if (CI_PRINT_PROGRAM::didCheck != -1) {
    dispatch_once(&CI_PRINT_PROGRAM::didCheck, &__block_literal_global_67);
  }
  return CI_PRINT_PROGRAM::v;
}

uint64_t CI::NodeWithChildren::child(CI::NodeWithChildren *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  if ((*(int (**)(CI::NodeWithChildren *))(*(void *)this + 40))(this) <= (int)a2) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 5);
  if (a2 > 9) {
    uint64_t v5 = *(void *)(v4 + 16) + 8 * (a2 - 10);
  }
  else {
    uint64_t v5 = v4 + 8 * a2 + 24;
  }
  return *(void *)v5;
}

void CI::NodeWithChildren::set_child(CI::NodeWithChildren *this, CI::Node *a2, int a3)
{
  if ((a3 & 0x80000000) == 0 && (*(int (**)(CI::NodeWithChildren *))(*(void *)this + 40))(this) > a3)
  {
    uint64_t v6 = (CI::SerialObjectPtrArray *)*((void *)this + 5);
    CI::SerialObjectPtrArray::replace(v6, a2, a3);
  }
}

uint64_t CI::NodeWithChildren::child_count(CI::NodeWithChildren *this)
{
  uint64_t v1 = (unsigned int *)*((void *)this + 5);
  if (v1) {
    return *v1;
  }
  else {
    return 0;
  }
}

void CI::Context::recursive_render(char *a1, void *a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v182 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(CI::Node **)a3;
  if (!*(void *)a3) {
    return;
  }
  uint64_t v6 = a3;
  rect.origin.double x = CI::Node::roi(*(CI::Node **)a3, *(_DWORD *)(a3 + 8));
  rect.origin.double y = v9;
  rect.size.CGFloat width = v10;
  rect.size.CGFloat height = v11;
  uint64_t v12 = (CI::TextureManager *)(*(uint64_t (**)(char *))(*(void *)a1 + 112))(a1);
  {
    CI::TextureManager::intermediate(v12);
  }
  long long v167 = *(_OWORD *)((char *)v5 + 140);
  if (!v167) {
    LODWORD(v167) = *((_DWORD *)a1 + 8);
  }
  unsigned int v13 = *(_DWORD *)(v6 + 8);
  if (a4)
  {
    if (CGRectIsEmpty(rect))
    {
      uint64_t v14 = CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::emptyIntermediate;
    }
    else
    {
      uint64_t v15 = (void *)CI::Node::rois(v5);
      uint64_t v16 = (uint64_t)(*(void *)(*v15 + 120 * (int)v13 + 40) - *(void *)(*v15 + 120 * (int)v13 + 32)) >> 4;
      uint64_t v17 = (*(uint64_t (**)(CI::Node *))(*(void *)v5 + 384))(v5);
      uint64_t v14 = (*(uint64_t (**)(CI::TextureManager *, long long *, uint64_t, CGRect *, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 40))(v12, &v167, v17, &rect, 1, 1 - 0x5555555555555555 * v16, 1);
      if (v14)
      {
        *(void *)std::string __p = v5;
        *(_DWORD *)&__p[8] = v13;
        CI::TextureManager::add_intermediate_for_node((uint64_t)v12, __p, v14);
      }
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  if ((*(unsigned int (**)(void))(**((void **)v5 + 6) + 16))(*((void *)v5 + 6)) == 41)
  {
    uint64_t v18 = (unsigned __int8 *)*((void *)v5 + 6);
    int v19 = v18[153];
    if (v18[153]) {
      int v19 = (*(int (**)(unsigned __int8 *))(*(void *)v18 + 40))(v18) > 0;
    }
    a5 |= v19;
  }
  uint64_t v20 = a2[3];
  v166[0] = MEMORY[0x1E4F143A8];
  v166[1] = 0x40000000;
  v166[2] = ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke;
  v166[3] = &__block_descriptor_tmp_9_1;
  uint64_t v125 = v20;
  v166[4] = v20;
  char v21 = (void *)CI::Node::rois(v5);
  uint64_t v165 = 0;
  v163 = 0;
  v164 = 0;
  if ((v13 & 0x80000000) != 0) {
    return;
  }
  uint64_t v22 = *v21 + 120 * v13;
  int v23 = *(_DWORD *)(v22 + 80);
  long long v24 = *(_OWORD *)(v22 + 16);
  *(_OWORD *)std::string __p = *(_OWORD *)v22;
  *(_OWORD *)&__p[16] = v24;
  CI::SerialRectArray::recurseSubdivide((double *)__p, v23, &v163);
  char v25 = v163;
  if (v164 == v163) {
    goto LABEL_173;
  }
  uint64_t v139 = 0;
  __s2 = a1 + 236;
  uint64_t v126 = v14;
  uint64_t v127 = a2;
  uint64_t v128 = (CI::Context *)a1;
  uint64_t v129 = v14;
  v135 = v5;
  v141 = v12;
  uint64_t v133 = v6;
  unsigned int v131 = v13;
  while (2)
  {
    unsigned int v138 = 0;
    unint64_t v26 = 0;
    do
    {
      unint64_t v137 = v26;
      if (a4 || ((v164 - (unsigned char *)v163) >> 5) - 1 != v139)
      {
        dispatch_group_t v27 = dispatch_group_create();
      }
      else
      {
        dispatch_retain((dispatch_object_t)a2[2]);
        dispatch_group_t v27 = (dispatch_group_t)a2[2];
      }
      v162[0] = MEMORY[0x1E4F143A8];
      v162[1] = 0x40000000;
      v162[2] = ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke_2;
      v162[3] = &__block_descriptor_tmp_10_1;
      object = v27;
      v162[4] = v27;
      v160 = 0;
      uint64_t v161 = 0;
      v159 = &v160;
      v158[0] = 0;
      v158[1] = 0;
      v157 = (uint64_t *)v158;
      int v28 = (*(uint64_t (**)(CI::Node *))(*(void *)v5 + 40))(v5);
      if (v28)
      {
        int v29 = v28;
        uint64_t v30 = 0;
        do
        {
          CI::ProgramNode::roiKeys_of_child(v5, *((CGRect *)v163 + v139), v30, __p);
          uint64_t v155 = (uint64_t)(*(void *)&__p[8] - *(void *)__p) >> 4;
          std::__tree<char const*>::__emplace_unique_key_args<char const*,char const* const&>(&v157, (unint64_t *)&v155, &v155);
          uint64_t v31 = v137;
          if ((uint64_t)(*(void *)&__p[8] - *(void *)__p) >> 4 > v137) {
            uint64_t v31 = (uint64_t)(*(void *)&__p[8] - *(void *)__p) >> 4;
          }
          unint64_t v137 = v31;
          if (*(void *)__p)
          {
            *(void *)&__p[8] = *(void *)__p;
            operator delete(*(void **)__p);
          }
          uint64_t v30 = (v30 + 1);
        }
        while (v29 != v30);
      }
      int v134 = (*(uint64_t (**)(CI::Node *))(*(void *)v5 + 40))(v5);
      if (v134)
      {
        uint64_t v32 = 0;
        do
        {
          int v33 = *(_DWORD *)(v6 + 8);
          *(void *)std::string __p = v5;
          *(_DWORD *)&__p[8] = v33;
          *(_DWORD *)&__p[12] = v139;
          *(_DWORD *)&__p[16] = v32;
          *(_DWORD *)&__p[20] = v138;
          *(void *)&__p[24] = 0;
          *(void *)&long long v170 = 0;
          DWORD2(v170) = 0;
          CI::ProgramNode::roiKeys_of_child(v5, *((CGRect *)v163 + v139), v32, &v155);
          uint64_t v34 = (_OWORD *)v155;
          v140 = v156;
          if ((_OWORD *)v155 != v156)
          {
            do
            {
              *(_OWORD *)v149 = *v34;
              float32_t v35 = v149[0];
              uint64_t v36 = (CI::SerialRectArray *)CI::Node::rois(v149[0]);
              CI::SerialRectArray::restore(v36, (int)v149[1], (const CI::parentROI *)__p);
              uint64_t v37 = (void *)CI::Node::rois(v35);
              uint64_t v38 = *v37 + 120 * SLODWORD(v149[1]);
              uint64_t v39 = *(void *)(v38 + 32);
              uint64_t v40 = *(void *)(v38 + 40);
              while (v39 != v40)
              {
                if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vceqq_s32(*(int32x4_t *)&__p[8], *(int32x4_t *)(v39 + 8))), 0xFuLL))) & 1) != 0&& *(void *)v39 == *(void *)__p)
                {
                  char v41 = operator new(0x38uLL);
                  uint64_t v42 = (uint64_t *)v41;
                  *((_OWORD *)v41 + 2) = *(_OWORD *)v149;
                  *((_DWORD *)v41 + 12) = v32;
                  uint64_t v43 = v160;
                  uint64_t v44 = &v160;
                  char v45 = &v160;
                  if (v160)
                  {
                    uint64_t v46 = (CI::Node *)*((void *)v41 + 4);
                    do
                    {
                      while (1)
                      {
                        uint64_t v44 = (uint64_t **)v43;
                        uint64_t v47 = (CI::SerialRectArray *)CI::Node::rois(v46);
                        unsigned int v48 = CI::SerialRectArray::maxParentDistance(v47);
                        uint64_t v49 = (CI::SerialRectArray *)CI::Node::rois((CI::Node *)v44[4]);
                        if (v48 >= CI::SerialRectArray::maxParentDistance(v49)) {
                          break;
                        }
                        uint64_t v43 = *v44;
                        char v45 = v44;
                        if (!*v44) {
                          goto LABEL_44;
                        }
                      }
                      uint64_t v43 = v44[1];
                    }
                    while (v43);
                    char v45 = v44 + 1;
                  }
LABEL_44:
                  *uint64_t v42 = 0;
                  v42[1] = 0;
                  uint64_t v42[2] = (uint64_t)v44;
                  *char v45 = v42;
                  if (*v159)
                  {
                    v159 = (uint64_t **)*v159;
                    uint64_t v42 = *v45;
                  }
                  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v160, v42);
                  ++v161;
                  uint64_t v12 = v141;
                  CI::TextureManager::add_to_pending((uint64_t)v141, (uint64_t)v149);
                }
                v39 += 48;
              }
              ++v34;
            }
            while (v34 != v140);
            uint64_t v34 = (_OWORD *)v155;
          }
          if (v34)
          {
            v156 = v34;
            operator delete(v34);
          }
          uint64_t v32 = (v32 + 1);
          uint64_t v6 = v133;
          uint64_t v5 = v135;
        }
        while (v32 != v134);
      }
      a2 = v127;
      uint64_t v50 = v128;
      unsigned int v51 = v131;
      if (v126 || (uint64_t v52 = v159, v159 == &v160))
      {
LABEL_65:
        if (CI_VERBOSE_SIGNPOSTS())
        {
          BOOL v59 = ci_signpost_log_render();
          os_signpost_id_t v60 = *((int *)v5 + 9) | (unint64_t)((*(uint64_t (**)(CI::Context *))(*(void *)v128 + 272))(v128) << 32);
          if (v60 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v59))
          {
            *(_DWORD *)std::string __p = 134218752;
            *(CGFloat *)&__p[4] = rect.origin.x;
            *(_WORD *)&__p[12] = 2048;
            *(CGFloat *)&__p[14] = rect.origin.y;
            *(_WORD *)&__p[22] = 2048;
            *(CGFloat *)&__p[24] = rect.size.width;
            LOWORD(v170) = 2048;
            *(CGFloat *)((char *)&v170 + 2) = rect.size.height;
            _os_signpost_emit_with_name_impl(&dword_193671000, v59, OS_SIGNPOST_INTERVAL_BEGIN, v60, "render_quad", "[%g %g %g %g]", __p, 0x2Au);
          }
        }
        uint64_t v61 = (*(uint64_t (**)(CI::Context *))(*(void *)v128 + 272))(v128);
        TimerBase::TimerBase((uint64_t)&v155, v61, *((_DWORD *)v5 + 9), (uint64_t)"render_quad", 6);
        v149[0] = v5;
        v149[1] = (CI::Node *)__PAIR64__(v139, v131);
        int v150 = -1;
        unsigned int v151 = v138;
        uint64_t v152 = 0;
        uint64_t v153 = 0;
        int v154 = 0;
        CI::Object::ref((uint64_t)v128);
        if (!a4)
        {
          uint64_t v70 = object;
          dispatch_retain(object);
          dispatch_group_enter(object);
          dispatch_retain(v125);
          dispatch_group_enter(v125);
          (*(void (**)(CI::Context *, void *, CI::Node **, void *, void *))(*(void *)v128 + 40))(v128, v127, v149, v166, v162);
LABEL_135:
          dispatch_retain(v70);
          if (CI::Context::render_completion_queue(void)::onceToken != -1) {
            dispatch_once(&CI::Context::render_completion_queue(void)::onceToken, &__block_literal_global_83);
          }
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 0x40000000;
          block[2] = ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke_11;
          block[3] = &__block_descriptor_tmp_12_0;
          void block[4] = v70;
          void block[5] = v50;
          dispatch_async((dispatch_queue_t)CI::Context::render_completion_queue(void)::sRenderCompletionQueue, block);
          if (CI_VERBOSE_SIGNPOSTS())
          {
            char v108 = ci_signpost_log_render();
            os_signpost_id_t v109 = *((int *)v5 + 9) | (unint64_t)((*(uint64_t (**)(CI::Context *))(*(void *)v50
                                                                                                  + 272))(v50) << 32);
            if (v109 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v108))
            {
              *(_WORD *)std::string __p = 0;
              _os_signpost_emit_with_name_impl(&dword_193671000, v108, OS_SIGNPOST_INTERVAL_BEGIN, v109, "remove_parentROI", "", __p, 2u);
            }
          }
          uint64_t v110 = (*(uint64_t (**)(CI::Context *))(*(void *)v50 + 272))(v50);
          TimerBase::TimerBase((uint64_t)__p, v110, *((_DWORD *)v5 + 9), (uint64_t)"remove_parentROI", 0);
          v111 = v159;
          if (v159 != &v160)
          {
            do
            {
              CI::TextureManager::remove_from_pending((uint64_t)v12, (uint64_t)(v111 + 4));
              v112 = (CI::SerialRectArray **)(*(uint64_t (**)(CI::Node *, void))(*(void *)v5 + 48))(v5, *((unsigned int *)v111 + 12));
              unsigned int v113 = *((_DWORD *)v111 + 12);
              *(void *)CGRect buf = v5;
              v143 = (uint8_t *)__PAIR64__(v139, v51);
              unint64_t v144 = __PAIR64__(v138, v113);
              v145 = 0;
              uint64_t v146 = 0;
              int v147 = 0;
              CI::Node::remove_parentROI(v112, (const CI::parentROI *)buf, (uint64_t)(v111 + 4), (uint64_t)v12, object);
              uint64_t v114 = v111[1];
              if (v114)
              {
                do
                {
                  uint64_t v115 = (uint64_t **)v114;
                  uint64_t v114 = (uint64_t *)*v114;
                }
                while (v114);
              }
              else
              {
                do
                {
                  uint64_t v115 = (uint64_t **)v111[2];
                  BOOL v58 = *v115 == (uint64_t *)v111;
                  v111 = v115;
                }
                while (!v58);
              }
              v111 = v115;
            }
            while (v115 != &v160);
          }
          if (CI_VERBOSE_SIGNPOSTS())
          {
            uint64_t v116 = ci_signpost_log_render();
            os_signpost_id_t v117 = *(void *)&__p[8];
            if ((unint64_t)(*(void *)&__p[8] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
            {
              uint64_t v118 = v116;
              if (os_signpost_enabled(v116))
              {
                *(_WORD *)CGRect buf = 0;
                _os_signpost_emit_with_name_impl(&dword_193671000, v118, OS_SIGNPOST_INTERVAL_END, v117, "remove_parentROI", "", buf, 2u);
              }
            }
          }
          TimerBase::~TimerBase((TimerBase *)__p);
          dispatch_release(object);
          if (CI_VERBOSE_SIGNPOSTS())
          {
            uint64_t v119 = ci_signpost_log_render();
            os_signpost_id_t v120 = (os_signpost_id_t)v156;
            if ((unint64_t)v156 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              long long v121 = v119;
              if (os_signpost_enabled(v119))
              {
                *(_WORD *)std::string __p = 0;
                _os_signpost_emit_with_name_impl(&dword_193671000, v121, OS_SIGNPOST_INTERVAL_END, v120, "render_quad", "", __p, 2u);
              }
            }
          }
          ++v138;
          TimerBase::~TimerBase((TimerBase *)&v155);
          int v94 = 1;
          goto LABEL_157;
        }
        if ((*(unsigned int (**)(CI::Node *))(*(void *)v5 + 16))(v5) == 52)
        {
          uint64_t v62 = (void *)CI::Node::rois(v135);
          if ((int)CI::Node::rois_count(v135) >= 1)
          {
            uint64_t v63 = 0;
            while (2)
            {
              uint64_t v64 = *v62 + 120 * v63;
              uint64_t v65 = *(void *)(v64 + 32);
              uint64_t v66 = *(void *)(v64 + 40);
              while (v65 != v66)
              {
                uint64_t v67 = *(void *)(*(void *)v65 + 48);
                if ((*(int (**)(uint64_t))(*(void *)v67 + 16))(v67) >= 41
                  && (*(int (**)(uint64_t))(*(void *)v67 + 16))(v67) < 43)
                {
                  BOOL v69 = 1;
                  uint64_t v5 = v135;
                  goto LABEL_84;
                }
                v65 += 48;
              }
              if (++v63 < (int)CI::Node::rois_count(v135)) {
                continue;
              }
              break;
            }
          }
        }
        uint64_t v5 = v135;
        uint64_t v68 = *((void *)v135 + 6);
        BOOL v69 = (*(int (**)(uint64_t))(*(void *)v68 + 16))(v68) >= 41
           && (*(int (**)(uint64_t))(*(void *)v68 + 16))(v68) < 43;
LABEL_84:
        unsigned int v51 = v131;
        uint64_t v70 = object;
        if (!v129)
        {
          unint64_t v71 = CI::Context::bytesLimit(v128);
          if (*((void *)v128 + 46))
          {
            int v72 = (*(uint64_t (**)(CI::Context *))(*(void *)v128 + 272))(v128);
            unint64_t SurfaceCacheNonVolatileSizeForContext = GetSurfaceCacheNonVolatileSizeForContext(v72);
          }
          else
          {
            unint64_t SurfaceCacheNonVolatileSizeForContext = GetSurfaceCacheNonVolatileSize();
          }
          if (SurfaceCacheNonVolatileSizeForContext > v71)
          {
            if (CI_VERBOSE_SIGNPOSTS())
            {
              long long v74 = ci_signpost_log_render();
              os_signpost_id_t v75 = *((int *)v135 + 9) | (unint64_t)((*(uint64_t (**)(CI::Context *))(*(void *)v128 + 272))(v128) << 32);
              if (v75 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v74))
              {
                *(_WORD *)std::string __p = 0;
                _os_signpost_emit_with_name_impl(&dword_193671000, v74, OS_SIGNPOST_INTERVAL_BEGIN, v75, "wait_for_cache", "", __p, 2u);
              }
            }
            uint64_t v76 = (*(uint64_t (**)(CI::Context *))(*(void *)v128 + 272))(v128);
            uint64_t v5 = v135;
            TimerBase::TimerBase((uint64_t)__p, v76, *((_DWORD *)v135 + 9), (uint64_t)"wait_for_cache", 19);
            (*(void (**)(CI::Context *))(*(void *)v128 + 56))(v128);
            int v77 = (*(uint64_t (**)(CI::Context *))(*(void *)v128 + 272))(v128);
            unint64_t v78 = GetSurfaceCacheNonVolatileSizeForContext(v77) - v71;
            do
            {
              if (!v78) {
                break;
              }
              uint64_t v79 = CI::TextureManager::releaseDeepIntermediate(v141);
              v78 -= v79;
            }
            while (v79);
            unsigned int v51 = v131;
            if (CI_VERBOSE_SIGNPOSTS())
            {
              long long v80 = ci_signpost_log_render();
              os_signpost_id_t v81 = *(void *)&__p[8];
              if ((unint64_t)(*(void *)&__p[8] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
              {
                uint64_t v82 = v80;
                if (os_signpost_enabled(v80))
                {
                  *(_WORD *)CGRect buf = 0;
                  _os_signpost_emit_with_name_impl(&dword_193671000, v82, OS_SIGNPOST_INTERVAL_END, v81, "wait_for_cache", "", buf, 2u);
                }
              }
            }
            TimerBase::~TimerBase((TimerBase *)__p);
          }
          if (CI_VERBOSE_SIGNPOSTS())
          {
            uint64_t v83 = ci_signpost_log_render();
            os_signpost_id_t v84 = *((int *)v5 + 9) | (unint64_t)((*(uint64_t (**)(CI::Context *))(*(void *)v128
                                                                                                 + 272))(v128) << 32);
            if (v84 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v83))
            {
              *(_WORD *)std::string __p = 0;
              _os_signpost_emit_with_name_impl(&dword_193671000, v83, OS_SIGNPOST_INTERVAL_BEGIN, v84, "create_intermediate", "", __p, 2u);
            }
          }
          uint64_t v85 = (*(uint64_t (**)(CI::Context *))(*(void *)v128 + 272))(v128);
          TimerBase::TimerBase((uint64_t)__p, v85, *((_DWORD *)v5 + 9), (uint64_t)"create_intermediate", 9);
          if (!CI::PixelFormatType_from_format(v167)) {
            CI::Context::recursive_render();
          }
          if (CGRectIsEmpty(rect) || CGRectIsInfinite(rect)) {
            CI::Context::recursive_render(&rect.size.width, &rect.size.height);
          }
          uint64_t v86 = (void *)CI::Node::rois(v5);
          uint64_t v87 = (uint64_t)(*(void *)(*v86 + 120 * v51 + 40) - *(void *)(*v86 + 120 * v51 + 32)) >> 4;
          uint64_t v88 = (*(uint64_t (**)(CI::Node *))(*(void *)v5 + 384))(v5);
          if (v69) {
            uint64_t v89 = 1;
          }
          else {
            uint64_t v89 = 64;
          }
          uint64_t v90 = (*(uint64_t (**)(CI::TextureManager *, long long *, uint64_t, CGRect *, uint64_t, uint64_t, void))(*(void *)v141 + 40))(v141, &v167, v88, &rect, v89, 1 - 0x5555555555555555 * v87, 0);
          *(void *)CGRect buf = v5;
          LODWORD(v143) = v51;
          CI::TextureManager::add_intermediate_for_node((uint64_t)v141, buf, v90);
          if (CI_VERBOSE_SIGNPOSTS())
          {
            double v91 = ci_signpost_log_render();
            os_signpost_id_t v92 = *(void *)&__p[8];
            if ((unint64_t)(*(void *)&__p[8] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
            {
              uint64_t v93 = v91;
              if (os_signpost_enabled(v91))
              {
                *(_WORD *)CGRect buf = 0;
                _os_signpost_emit_with_name_impl(&dword_193671000, v93, OS_SIGNPOST_INTERVAL_END, v92, "create_intermediate", "", buf, 2u);
              }
            }
          }
          TimerBase::~TimerBase((TimerBase *)__p);
          uint64_t v70 = object;
          uint64_t v129 = v90;
          if (!v90)
          {
            if (dyld_program_sdk_at_least())
            {
              CI::TileTask::setTaskError(v127, @"Render failed because of failure to allocate intermediate.");
              uint64_t v129 = 0;
LABEL_134:
              uint64_t v12 = v141;
              goto LABEL_135;
            }
            uint64_t v129 = 0;
          }
        }
        v184.origin.double x = CI::parentROI::roi((CI::parentROI *)v149);
        if (CGRectIsEmpty(v184))
        {
          uint64_t v95 = ci_logger_render();
          if (os_log_type_enabled(v95, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)std::string __p = 0;
            _os_log_impl(&dword_193671000, v95, OS_LOG_TYPE_INFO, "Skipping render due to error in computation of destination ROI", __p, 2u);
          }
        }
        else if ((*(unsigned int (**)(uint64_t))(*(void *)v129 + 8))(v129))
        {
          dispatch_retain(v70);
          dispatch_group_enter(v70);
          (*(void (**)(CI::Context *, void *, CI::Node **, uint64_t, void, void *))(*(void *)v128
                                                                                                  + 48))(v128, v127, v149, v129, a5, v162);
          uint64_t v12 = v141;
          if ((CI_PRINT_TREE_dump_intermediates() & 1) != 0
            || (CI_PRINT_TREE_dump_raw_intermediates() & 1) != 0
            || CI_PRINT_TREE_dump_bmtl_intermediates())
          {
            int v96 = (*(uint64_t (**)(CI::Context *))(*(void *)v128 + 272))(v128);
            if (CI_PRINT_TREE_context(v96, __s2)
              && (*((void *)v128 + 19) == (int)CI_PRINT_TREE_frame() || !CI_PRINT_TREE_frame()))
            {
              int v97 = *((_DWORD *)v5 + 9);
              uint64_t v98 = (double *)(*(uint64_t (**)(uint64_t))(*(void *)v129 + 32))(v129);
              double v99 = *v98;
              double v100 = v98[1];
              double v101 = v98[2];
              double v102 = v98[3];
              uint64_t v103 = (const void *)(**(uint64_t (***)(uint64_t))v129)(v129);
              RetainSurfaceFromCache(v103);
              RetainSurfaceFromCache(v103);
              if (CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::onceToken != -1) {
                dispatch_once(&CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::onceToken, &__block_literal_global_85);
              }
              BOOL is_deep = CI::format_is_deep(*((_DWORD *)v135 + 35));
              uint64_t v105 = CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::sRGBLinear;
              uint64_t v106 = CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::sRGB;
              if (CI::ProgramNode::mainProgram((dispatch_queue_t *)v135)) {
                Class isa = CI::ProgramNode::mainProgram((dispatch_queue_t *)v135)[6].isa;
              }
              else {
                Class isa = 0;
              }
              *(void *)CGRect buf = 0;
              v143 = buf;
              unint64_t v144 = 0x2000000000;
              if (isa) {
                long long v122 = (const char *)isa;
              }
              else {
                long long v122 = "intermediate";
              }
              v145 = strdup(v122);
              dispatch_retain(object);
              if (CI::Context::render_completion_queue(void)::onceToken != -1) {
                dispatch_once(&CI::Context::render_completion_queue(void)::onceToken, &__block_literal_global_83);
              }
              if (is_deep) {
                uint64_t v123 = v105;
              }
              else {
                uint64_t v123 = v106;
              }
              *(void *)std::string __p = MEMORY[0x1E4F143A8];
              *(void *)&__p[8] = 0x40000000;
              *(void *)&__p[16] = ___ZN2CIL26dump_intermediate_for_nodeEPKNS_11ProgramNodeEPKNS_14intermediate_tEP16dispatch_group_s_block_invoke_2;
              *(void *)&__p[24] = &unk_1E5773E30;
              int v177 = v97;
              int v178 = (int)v99;
              int v179 = (int)v100;
              int v180 = (int)v101;
              int v181 = (int)v102;
              v171 = v103;
              uint64_t v172 = v123;
              double v173 = v99;
              double v174 = v100;
              double v175 = v101;
              double v176 = v102;
              uint64_t v70 = object;
              *((void *)&v170 + 1) = object;
              *(void *)&long long v170 = buf;
              dispatch_async((dispatch_queue_t)CI::Context::render_completion_queue(void)::sRenderCompletionQueue, __p);
              _Block_object_dispose(buf, 8);
              uint64_t v50 = v128;
              uint64_t v5 = v135;
              uint64_t v12 = v141;
              unsigned int v51 = v131;
            }
          }
          goto LABEL_135;
        }
        goto LABEL_134;
      }
      while (1)
      {
        v183.origin.double x = CI::Node::roi((CI::Node *)v52[4], *((_DWORD *)v52 + 10));
        if (!CGRectIsEmpty(v183))
        {
          unsigned int v55 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v52[4] + 16))(v52[4], v53, v54);
          if ((CI::is_image_type(v55) & 1) == 0
            && !CI::TextureManager::get_intermediate_for_node((uint64_t)v12, (uint64_t)(v52 + 4)))
          {
            CI::Context::recursive_render(v128, v127, v52 + 4, v5, a5);
            if (v127[23]) {
              break;
            }
          }
        }
        uint64_t v56 = v52[1];
        if (v56)
        {
          do
          {
            uint64_t v57 = (uint64_t **)v56;
            uint64_t v56 = (uint64_t *)*v56;
          }
          while (v56);
        }
        else
        {
          do
          {
            uint64_t v57 = (uint64_t **)v52[2];
            BOOL v58 = *v57 == (uint64_t *)v52;
            uint64_t v52 = v57;
          }
          while (!v58);
        }
        uint64_t v52 = v57;
        if (v57 == &v160) {
          goto LABEL_65;
        }
      }
      int v94 = 0;
LABEL_157:
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v157, v158[0]);
      std::__tree<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey,CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::compareDepth,std::allocator<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey>>::destroy(v160);
      if (!v94)
      {
        char v25 = v163;
        goto LABEL_173;
      }
      unint64_t v26 = v137 - 1;
    }
    while (v137 > 1);
    char v25 = v163;
    if (++v139 < (unint64_t)((v164 - (unsigned char *)v163) >> 5)) {
      continue;
    }
    break;
  }
LABEL_173:
  if (v25)
  {
    v164 = v25;
    operator delete(v25);
  }
}

uint64_t CI_VERBOSE_SIGNPOSTS()
{
  {
    CI_VERBOSE_SIGNPOSTS::v = get_BOOL("CI_VERBOSE_SIGNPOSTS", 0);
  }
  return CI_VERBOSE_SIGNPOSTS::v;
}

void sub_1936AE4DC(_Unwind_Exception *a1)
{
}

double CI::parentROI::roi(CI::parentROI *this)
{
  uint64_t v2 = *(void **)(*(void *)this + 16);
  unsigned int v3 = *((_DWORD *)this + 2);
  std::string __p = 0;
  CGFloat v10 = 0;
  uint64_t v11 = 0;
  uint64_t v4 = *v2 + 120 * v3;
  int v5 = *(_DWORD *)(v4 + 80);
  long long v6 = *(_OWORD *)(v4 + 16);
  v12[0] = *(_OWORD *)v4;
  v12[1] = v6;
  CI::SerialRectArray::recurseSubdivide((double *)v12, v5, &__p);
  double v7 = *((double *)__p + 4 * *((int *)this + 3));
  CGFloat v10 = __p;
  operator delete(__p);
  return v7;
}

void std::__tree<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey,CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::compareDepth,std::allocator<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey,CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::compareDepth,std::allocator<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey>>::destroy(*a1);
    std::__tree<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey,CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::compareDepth,std::allocator<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey>>::destroy(a1[1]);
    operator delete(a1);
  }
}

uint64_t CI::subdivide_program_rois(int *a1, unint64_t a2, uint64_t a3, int a4, unint64_t *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  unint64_t v15 = a2;
  int NodeUseCount = CI::Node::GetNodeUseCount(a3, a2);
  if (a4)
  {
    uint64_t v18 = *(void **)(a3 + 8);
    if (v18)
    {
      uint64_t v19 = a3 + 8;
      do
      {
        unint64_t v20 = v18[4];
        BOOL v21 = v20 >= v15;
        if (v20 >= v15) {
          uint64_t v22 = v18;
        }
        else {
          uint64_t v22 = v18 + 1;
        }
        if (v21) {
          uint64_t v19 = (uint64_t)v18;
        }
        uint64_t v18 = (void *)*v22;
      }
      while (*v22);
      if (v19 != a3 + 8 && *(void *)(v19 + 32) <= v15) {
        --*(_DWORD *)(v19 + 40);
      }
    }
    --NodeUseCount;
  }
  if (NodeUseCount) {
    return 0;
  }
  int v24 = CI::Node::rois_count((CI::Node *)v15);
  uint64_t v25 = *(void *)v15;
  if (!v24)
  {
    int v30 = (*(uint64_t (**)(unint64_t))(v25 + 40))(v15);
    if (v30 >= 1)
    {
      int v31 = v30;
      uint64_t v32 = 0;
      do
      {
        uint64_t v33 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v15 + 48))(v15, v32);
        v311.origin.CGFloat x = a6;
        v311.origin.CGFloat y = a7;
        v311.size.double width = a8;
        v311.size.double height = a9;
        double v34 = CI::Node::region_of_child((CI::Node *)v15, v311);
        uint64_t v35 = CI::subdivide_program_rois(a1, v33, a3, 1, a5, v34);
        uint64_t v32 = (v32 + 1);
      }
      while (v31 != v32);
      return v35;
    }
    return 0;
  }
  if ((*(unsigned int (**)(unint64_t))(v25 + 16))(v15) != 52) {
    return 0;
  }
  unint64_t v294 = CI::Context::bytesLimit((CI::Context *)a1);
  unint64_t v26 = (*(uint64_t (**)(int *))(*(void *)a1 + 448))(a1);
  unint64_t v27 = (*(uint64_t (**)(int *))(*(void *)a1 + 456))(a1);
  uint64_t v28 = *(void *)a1;
  if (v26 >= v27) {
    uint64_t v29 = (*(uint64_t (**)(int *))(v28 + 456))(a1);
  }
  else {
    uint64_t v29 = (*(uint64_t (**)(int *))(v28 + 448))(a1);
  }
  v296 = (CGRect *)v29;
  uint64_t v36 = a5;
  uint64_t v37 = (CGRect **)CI::Node::rois((CI::Node *)v15);
  CI::SerialRectArray::unionRect(v37);
  CGFloat v39 = v38;
  CGFloat v41 = v40;
  CGFloat v43 = v42;
  CGFloat v45 = v44;
  int v46 = *(_DWORD *)(v15 + 140);
  if (!v46) {
    int v46 = a1[8];
  }
  int v47 = CI::format_bytes_per_pixel(v46);
  unsigned int v48 = *(void **)(a3 + 8);
  if (!v48) {
    goto LABEL_40;
  }
  uint64_t v49 = a3 + 8;
  do
  {
    unint64_t v50 = v48[4];
    BOOL v51 = v50 >= v15;
    if (v50 >= v15) {
      uint64_t v52 = v48;
    }
    else {
      uint64_t v52 = v48 + 1;
    }
    if (v51) {
      uint64_t v49 = (uint64_t)v48;
    }
    unsigned int v48 = (void *)*v52;
  }
  while (*v52);
  if (v49 == a3 + 8 || *(void *)(v49 + 32) > v15) {
LABEL_40:
  }
    uint64_t v49 = a3 + 8;
  unint64_t v280 = v47;
  v297 = (CI::Node *)v15;
  uint64_t v292 = a3;
  if (*(unsigned char *)(v49 + 44) && (int)CI::Node::rois_count((CI::Node *)v15) >= 2)
  {
    int v53 = CI::Node::rois_count((CI::Node *)v15);
    if (v53 < 1)
    {
      unint64_t v55 = 0;
    }
    else
    {
      uint64_t v54 = 0;
      unint64_t v55 = 0;
      uint64_t v56 = v53;
      do
      {
        uint64_t v57 = *(void *)CI::Node::rois((CI::Node *)v15) + 120 * v54;
        uint64_t v58 = *(void *)(v57 + 32);
        uint64_t v59 = *(void *)(v57 + 40);
        while (v58 != v59)
        {
          if (v55 <= *(void *)(v58 + 24)) {
            unint64_t v55 = *(void *)(v58 + 24);
          }
          v58 += 48;
        }
        ++v54;
      }
      while (v54 != v56);
    }
    uint64_t v62 = (CGRect **)CI::Node::rois((CI::Node *)v15);
    CI::SerialRectArray::unionRect(v62);
    v300[0] = v63;
    v300[1] = v64;
    size.double width = v65;
    size.double height = v66;
    uint64_t v67 = (CGRect **)CI::Node::rois((CI::Node *)v15);
    CI::SerialRectArray::unionRect(v67);
    v304.origin.CGFloat x = v68;
    v304.origin.CGFloat y = v69;
    v304.size.double width = v70;
    v304.size.double height = v71;
    int v72 = CI::format_bytes_per_pixel(a1[8]);
    uint64_t v61 = v296;
    unint64_t v60 = CI::programNodeMemoryLoad((CI *)v15, (CGFloat *)v300, &v304, v296, v72, 1) + v55;
    uint64_t v36 = a5;
  }
  else
  {
    unint64_t v60 = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v61 = v296;
  }
  v293 = a1;
  if (v60 < v294)
  {
    int v287 = (*(uint64_t (**)(unint64_t))(*(void *)v15 + 40))(v15);
    if (v287 >= 1)
    {
      unint64_t v298 = 0;
      uint64_t v73 = 0;
      do
      {
        long long v74 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v15 + 48))(v15, v73);
        int v75 = (*(unsigned int (**)(_DWORD *))(*(void *)v74 + 16))(v74) == 52 && v74[38] > 1;
        v312.origin.CGFloat x = v39;
        v312.origin.CGFloat y = v41;
        v312.size.double width = v43;
        v312.size.double height = v45;
        CI::ProgramNode::compute_regions_of_child((CI::Node **)v15, v312, v73, (unint64_t)v61, 0, v75, (uint64_t *)&v304);
        CGFloat y = v304.origin.y;
        if (*(void *)&v304.origin.y != *(void *)&v304.origin.x)
        {
          unint64_t v77 = 0;
          uint64_t v78 = v73;
          do
          {
            int v79 = CI::Node::rois_count((CI::Node *)v15);
            if (v79 >= 1)
            {
              long long v80 = 0;
              unint64_t v81 = v79;
              do
              {
                uint64_t v82 = (CI::SerialRectArray *)CI::Node::rois((CI::Node *)v15);
                *(void *)(*(void *)v82 + 120 * (void)v80 + 88) = v60;
                CI::SerialRectArray::updateParents(v82, (int)v80, v60);
                uint64_t v83 = *(void *)CI::Node::rois((CI::Node *)v15) + 120 * (void)v80;
                uint64_t v84 = *(void *)(v83 + 32);
                uint64_t v85 = *(void *)(v83 + 40);
                if (v84 == v85)
                {
                  unint64_t v87 = 0;
                  unint64_t v86 = 0;
                }
                else
                {
                  unint64_t v86 = 0;
                  unint64_t v87 = 0;
                  do
                  {
                    if (v87 <= *(void *)(v84 + 32)) {
                      unint64_t v87 = *(void *)(v84 + 32);
                    }
                    if (v86 <= *(void *)(v84 + 24)) {
                      unint64_t v86 = *(void *)(v84 + 24);
                    }
                    v84 += 48;
                  }
                  while (v84 != v85);
                }
                unint64_t v88 = CI::nodePathLoad(v297, v80, v280);
                if (v87 <= v60) {
                  unint64_t v87 = v60;
                }
                uint64_t v89 = (void *)CI::Node::rois(v297);
                uint64_t v90 = *v89 + 120 * (void)v80;
                uint64_t v91 = *(void *)(v90 + 32);
                uint64_t v92 = *(void *)(v90 + 40);
                if (v91 == v92)
                {
                  unsigned int v93 = 0;
                  uint64_t v73 = v78;
                }
                else
                {
                  unsigned int v93 = 0;
                  uint64_t v73 = v78;
                  do
                  {
                    if (v93 <= *(_DWORD *)(v91 + 40)) {
                      unsigned int v93 = *(_DWORD *)(v91 + 40);
                    }
                    v91 += 48;
                  }
                  while (v91 != v92);
                }
                uint64_t v94 = *v89 + 120 * (void)v80;
                uint64_t v95 = *(void *)(v94 + 56);
                uint64_t v96 = *(void *)(v94 + 64);
                while (v95 != v96)
                {
                  if (v93 <= *(_DWORD *)(v95 + 40)) {
                    unsigned int v93 = *(_DWORD *)(v95 + 40);
                  }
                  v95 += 48;
                }
                unint64_t v97 = v88 + v86;
                unint64_t v15 = (unint64_t)v297;
                v300[0] = v297;
                v300[1] = (CI *)v80;
                *(void *)&size.double width = __PAIR64__(v77, v73);
                *(void *)&size.double height = v97;
                unint64_t v302 = v87;
                unsigned int v303 = v93 + 1;
                uint64_t v36 = a5;
                unint64_t v98 = *a5;
                if (*a5 <= v97) {
                  unint64_t v98 = v97;
                }
                *a5 = v98;
                double v99 = CI::Node::roi(v297, (int)v80);
                CGFloat v101 = v100;
                CGFloat v103 = v102;
                CGFloat v105 = v104;
                int v106 = (*(uint64_t (**)(_DWORD *))(*(void *)v74 + 16))(v74);
                BOOL v107 = 0;
                if (v106 == 52) {
                  BOOL v107 = v74[38] > 1;
                }
                v313.origin.CGFloat x = v99;
                v313.origin.CGFloat y = v101;
                v313.size.double width = v103;
                v313.size.double height = v105;
                uint64_t v61 = v296;
                CI::ProgramNode::compute_regions_of_child((CI::Node **)v297, v313, v73, (unint64_t)v296, 1, v107, (uint64_t *)__p);
                if (__p[0])
                {
                  __p[1] = __p[0];
                  operator delete(__p[0]);
                }
                (*(void (**)(_DWORD *, unint64_t, CGRect *, CI **, double, double, double, double))(*(void *)v74 + 344))(v74, v294, v296, v300, *(double *)(*(void *)&v304.origin.x + 32 * v77), *(double *)(*(void *)&v304.origin.x + 32 * v77 + 8), *(double *)(*(void *)&v304.origin.x + 32 * v77 + 16), *(double *)(*(void *)&v304.origin.x + 32 * v77 + 24));
                long long v80 = (const CI::ProgramNode *)((char *)v80 + 1);
              }
              while (v80 != (const CI::ProgramNode *)v81);
            }
            uint64_t v108 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v15 + 48))(v15, v73);
            unint64_t v109 = CI::subdivide_program_rois(v293, v108, v292, 1, v36, *(double *)(*(void *)&v304.origin.x + 32 * v77));
            unint64_t v110 = v298;
            if (v109 > v298) {
              unint64_t v110 = v109;
            }
            unint64_t v298 = v110;
            ++v77;
            CGFloat y = v304.origin.x;
          }
          while (v77 < (uint64_t)(*(void *)&v304.origin.y - *(void *)&v304.origin.x) >> 5);
        }
        if (y != 0.0)
        {
          v304.origin.CGFloat y = y;
          operator delete(*(void **)&y);
        }
        uint64_t v73 = (v73 + 1);
      }
      while (v73 != v287);
      return v298;
    }
    return 0;
  }
  int v111 = CI::Node::rois_count((CI::Node *)v15);
  if (v111 < 1) {
    return 0;
  }
  v112 = 0;
  unint64_t v298 = 0;
  double v113 = (double)(unint64_t)v61;
  unint64_t v291 = v111;
  do
  {
    uint64_t v114 = *(void *)CI::Node::rois((CI::Node *)v15) + 120 * (void)v112;
    uint64_t v115 = *(void *)(v114 + 32);
    uint64_t v116 = *(void *)(v114 + 40);
    if (v115 == v116)
    {
      unint64_t v118 = 0;
      unint64_t v117 = 0;
      uint64_t v119 = v293;
    }
    else
    {
      unint64_t v117 = 0;
      unint64_t v118 = 0;
      uint64_t v119 = v293;
      do
      {
        if (v117 <= *(void *)(v115 + 24)) {
          unint64_t v117 = *(void *)(v115 + 24);
        }
        if (v118 <= *(void *)(v115 + 32)) {
          unint64_t v118 = *(void *)(v115 + 32);
        }
        v115 += 48;
      }
      while (v115 != v116);
    }
    unint64_t v279 = v118;
    int v288 = v119[8];
    v305 = 0;
    v306 = 0;
    unint64_t v307 = 0;
    int v120 = (*(uint64_t (**)(unint64_t))(*(void *)v15 + 40))(v15);
    if (v120 < 1)
    {
      v136 = 0;
      uint64_t v139 = 0;
LABEL_163:
      BOOL v161 = v139 != v136;
      if (!v136) {
        goto LABEL_165;
      }
LABEL_164:
      v306 = v136;
      operator delete(v136);
      goto LABEL_165;
    }
    int v121 = v120;
    uint64_t v122 = 0;
    do
    {
      uint64_t v123 = (int *)(*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v15 + 48))(v15, v122);
      if ((*(unsigned int (**)(int *))(*(void *)v123 + 16))(v123) == 52 && v123[38] > 1)
      {
        uint64_t v124 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v15 + 48))(v15, v122);
        uint64_t v125 = v124;
        uint64_t v126 = v306;
        if ((unint64_t)v306 >= v307)
        {
          uint64_t v128 = v306 - v305;
          if ((unint64_t)(v128 + 1) >> 61) {
            abort();
          }
          unint64_t v129 = (uint64_t)(v307 - (void)v305) >> 2;
          if (v129 <= v128 + 1) {
            unint64_t v129 = v128 + 1;
          }
          if (v307 - (unint64_t)v305 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v130 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v130 = v129;
          }
          if (v130) {
            unsigned int v131 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v307, v130);
          }
          else {
            unsigned int v131 = 0;
          }
          long long v132 = (uint64_t *)&v131[8 * v128];
          *long long v132 = v125;
          uint64_t v127 = v132 + 1;
          int v134 = v305;
          uint64_t v133 = v306;
          if (v306 != v305)
          {
            do
            {
              uint64_t v135 = *--v133;
              *--long long v132 = v135;
            }
            while (v133 != v134);
            uint64_t v133 = v305;
          }
          v305 = v132;
          v306 = v127;
          unint64_t v307 = (unint64_t)&v131[8 * v130];
          if (v133) {
            operator delete(v133);
          }
        }
        else
        {
          uint64_t *v306 = v124;
          uint64_t v127 = v126 + 1;
        }
        v306 = v127;
      }
      uint64_t v122 = (v122 + 1);
    }
    while (v122 != v121);
    v136 = v306;
    if (v306 == v305)
    {
      uint64_t v139 = v306;
LABEL_162:
      uint64_t v36 = a5;
      goto LABEL_163;
    }
    unint64_t v137 = 0;
    v136 = v305;
    while (1)
    {
      unsigned int v138 = (*(uint64_t (**)(uint64_t))(*(void *)v136[v137] + 16))(v136[v137]);
      if ((CI::is_image_type(v138) & 1) == 0) {
        break;
      }
LABEL_138:
      ++v137;
      v136 = v305;
      uint64_t v139 = v306;
      if (v137 >= v306 - v305) {
        goto LABEL_162;
      }
    }
    v140 = (CI *)v305[v137];
    int v141 = 1;
    do
    {
      int v142 = CI::format_bytes_per_pixel(v288);
      v308 = 0;
      v309 = 0;
      uint64_t v310 = 0;
      v300[0] = COERCE_CI_((*(double (**)(CI *))(*(void *)v140 + 168))(v140));
      v300[1] = v143;
      size.double width = v144;
      size.double height = v145;
      unsigned int v146 = v141;
      CI::SerialRectArray::recurseSubdivide((double *)v300, v141, (void **)&v308);
      int v147 = v308;
      if (v308 == v309)
      {
        unint64_t v148 = 0;
        if (v308) {
          goto LABEL_147;
        }
      }
      else
      {
        unint64_t v148 = 0;
        do
        {
          *(CGPoint *)v300 = v147->origin;
          CGSize size = v147->size;
          v304.origin.CGFloat x = (*(double (**)(CI *))(*(void *)v140 + 168))(v140);
          v304.origin.CGFloat y = v149;
          v304.size.double width = v150;
          v304.size.double height = v151;
          unint64_t v152 = CI::programNodeMemoryLoad(v140, (CGFloat *)v300, &v304, v61, v142, 0);
          if (v148 <= v152) {
            unint64_t v148 = v152;
          }
          ++v147;
        }
        while (v147 != v309);
        int v147 = v308;
        if (v308)
        {
LABEL_147:
          v309 = v147;
          operator delete(v147);
        }
      }
      BOOL v153 = v148 + v117 > v294;
      unint64_t v15 = (unint64_t)v297;
      if (!v153) {
        goto LABEL_138;
      }
      (*(void (**)(CI *))(*(void *)v140 + 168))(v140);
      double v155 = v154;
      (*(void (**)(CI *))(*(void *)v140 + 168))(v140);
      double v157 = v156;
      (*(void (**)(CI *))(*(void *)v140 + 168))(v140);
      if (v155 <= v157) {
        double v160 = v159;
      }
      else {
        double v160 = v158;
      }
      if (v160 > v113) {
        break;
      }
      int v141 = 2 * v146;
    }
    while (v146 < 0x40);
    BOOL v161 = 0;
    v136 = v305;
    uint64_t v36 = a5;
    if (v305) {
      goto LABEL_164;
    }
LABEL_165:
    CGRect v314 = CGRectInset(*((CGRect *)v119 + 5), 0.000001, 0.000001);
    CGRect v315 = CGRectIntegral(v314);
    double width = v315.size.width;
    double height = v315.size.height;
    CGRect v316 = CGRectInset(*(CGRect *)(v119 + 50), 0.000001, 0.000001);
    CGRect v317 = CGRectIntegral(v316);
    BOOL v164 = v317.size.width == width;
    if (v317.size.height != height) {
      BOOL v164 = 0;
    }
    int v281 = v161 && v164;
    if (!CI_ENABLE_SUBDIVIDE_ROI()
      || (*(unsigned int (**)(void))(**(void **)(v15 + 48) + 16))(*(void *)(v15 + 48)) == 41
      || (*(unsigned int (**)(void))(**(void **)(v15 + 48) + 16))(*(void *)(v15 + 48)) == 42
      || (*(unsigned int (**)(int *))(*(void *)v119 + 16))(v119) == 74)
    {
      v300[0] = COERCE_CI_(CI::Node::roi((CI::Node *)v15, (int)v112));
      v300[1] = v165;
      size.double width = v166;
      size.double height = v167;
      v304.origin.CGFloat x = CI::Node::roi((CI::Node *)v15, (int)v112);
      v304.origin.CGFloat y = v168;
      v304.size.double width = v169;
      v304.size.double height = v170;
      int v171 = CI::format_bytes_per_pixel(v119[8]);
      unint64_t v172 = CI::programNodeMemoryLoad((CI *)v15, (CGFloat *)v300, &v304, v61, v171, 0) + v117;
      goto LABEL_172;
    }
    while (1)
    {
      int v202 = CI::format_bytes_per_pixel(v119[8]);
      unint64_t v172 = CI::estimateProgramNodeMemoryLoad((CI *)v15, v112, v61, v202, v281) + v117;
      if (v172 <= v294) {
        break;
      }
      v204 = (uint64_t *)CI::Node::rois((CI::Node *)v15);
      uint64_t v205 = *v204;
      uint64_t v206 = v204[1];
      if (*v204 != v206)
      {
        unint64_t v207 = 0;
        do
        {
          v207 += *(int *)(v205 + 80);
          v205 += 120;
        }
        while (v205 != v206);
        if (v207 > 0x3F) {
          goto LABEL_216;
        }
      }
      CI::Node::roi((CI::Node *)v15, (int)v112);
      double v209 = v208;
      CI::Node::roi((CI::Node *)v15, (int)v112);
      double v211 = v210;
      CI::Node::roi((CI::Node *)v15, (int)v112);
      double v214 = v209 <= v211 ? v213 : v212;
      if (v214 > v113)
      {
LABEL_216:
        if (v281)
        {
          uint64_t v216 = *(void *)CI::Node::rois((CI::Node *)v15) + 120 * (void)v112;
          for (int i = 1; ; int i = 2 * *(_DWORD *)(v216 + 80))
          {
            *(_DWORD *)(v216 + 80) = i;
            int v218 = CI::format_bytes_per_pixel(v119[8]);
            LOBYTE(v281) = 0;
            unint64_t v172 = CI::estimateProgramNodeMemoryLoad((CI *)v15, v112, v61, v218, 0) + v117;
            if (v172 <= v294) {
              break;
            }
            v219 = (uint64_t *)CI::Node::rois((CI::Node *)v15);
            uint64_t v220 = *v219;
            uint64_t v221 = v219[1];
            if (*v219 != v221)
            {
              unint64_t v222 = 0;
              do
              {
                v222 += *(int *)(v220 + 80);
                v220 += 120;
              }
              while (v220 != v221);
              if (v222 > 0x3F) {
                goto LABEL_228;
              }
            }
            CI::Node::roi((CI::Node *)v15, (int)v112);
            double v224 = v223;
            CI::Node::roi((CI::Node *)v15, (int)v112);
            double v226 = v225;
            CI::Node::roi((CI::Node *)v15, (int)v112);
            double v229 = v224 <= v226 ? v228 : v227;
            if (v229 > v113) {
              goto LABEL_228;
            }
            uint64_t v216 = *(void *)CI::Node::rois((CI::Node *)v15) + 120 * (void)v112;
          }
        }
        else
        {
LABEL_228:
          LOBYTE(v281) = 0;
        }
        break;
      }
      v215 = (void *)CI::Node::rois((CI::Node *)v15);
      *(_DWORD *)(*v215 + 120 * (void)v112 + 80) *= 2;
    }
    BOOL isRootNode = CI::isRootNode((CI *)v15, v203);
    double v231 = 0.0;
    if (!isRootNode)
    {
      CI::Node::roi((CI::Node *)v15, (int)v112);
      double v231 = v233 * v232 * (double)v280;
    }
    if (v281)
    {
      int v281 = 1;
      goto LABEL_172;
    }
    unint64_t v282 = (unint64_t)v231;
    unint64_t v278 = v172;
    unint64_t v286 = v117;
    while (2)
    {
      v234 = (uint64_t *)CI::Node::rois((CI::Node *)v15);
      uint64_t v235 = *v234;
      uint64_t v236 = v234[1];
      if (*v234 == v236) {
        goto LABEL_241;
      }
      unint64_t v237 = 0;
      do
      {
        v237 += *(int *)(v235 + 80);
        v235 += 120;
      }
      while (v235 != v236);
      if (v237 <= 0x3F)
      {
LABEL_241:
        CI::Node::roi((CI::Node *)v15, (int)v112);
        double v239 = v238;
        CI::Node::roi((CI::Node *)v15, (int)v112);
        double v241 = v240;
        CI::Node::roi((CI::Node *)v15, (int)v112);
        double v244 = v239 <= v241 ? v243 : v242;
        if (v244 <= v113)
        {
          unint64_t v245 = CI::nodePathLoad((CI *)v15, v112, v280);
          int v246 = CI::format_bytes_per_pixel(v119[8]);
          v247 = (void *)CI::Node::rois((CI::Node *)v15);
          v309 = 0;
          uint64_t v310 = 0;
          v308 = 0;
          uint64_t v248 = *v247 + 120 * (void)v112;
          int v249 = *(_DWORD *)(v248 + 80);
          CGSize v250 = *(CGSize *)(v248 + 16);
          *(_OWORD *)v300 = *(_OWORD *)v248;
          CGSize size = v250;
          CI::SerialRectArray::recurseSubdivide((double *)v300, v249, (void **)&v308);
          v251 = v308;
          if (v308 == v309)
          {
            unint64_t v254 = 0;
            uint64_t v36 = a5;
            if (v308) {
              goto LABEL_278;
            }
          }
          else
          {
            unint64_t v252 = v294 - v117 - v245;
            unint64_t v253 = v246;
            unint64_t v254 = 0;
            uint64_t v36 = a5;
            v255 = v308;
            unint64_t v284 = v252;
            do
            {
              int v256 = (*(uint64_t (**)(unint64_t))(*(void *)v15 + 40))(v15);
              v306 = 0;
              unint64_t v307 = 0;
              v305 = (uint64_t *)&v306;
              if (v256)
              {
                int v257 = v256;
                unint64_t v290 = v254;
                v258 = v255;
                uint64_t v259 = 0;
                do
                {
                  v304.origin.CGFloat x = 0.0;
                  *(void *)&v304.origin.CGFloat x = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v15 + 48))(v15, v259);
                  v300[0] = (CI *)&v304;
                  v260 = std::__tree<std::__value_type<CI::Node *,CI::roiList>,std::__map_value_compare<CI::Node *,std::__value_type<CI::Node *,CI::roiList>,std::less<CI::Node *>,true>,std::allocator<std::__value_type<CI::Node *,CI::roiList>>>::__emplace_unique_key_args<CI::Node *,std::piecewise_construct_t const&,std::tuple<CI::Node * const&>,std::tuple<>>(&v305, (unint64_t *)&v304, (uint64_t)&std::piecewise_construct, (uint64_t **)v300);
                  CI::ProgramNode::compute_regions_of_child((CI::Node **)v15, *v258, v259, (unint64_t)v61, 0, 0, (uint64_t *)v300);
                  v262 = (CGRect *)v300[0];
                  v261 = v300[1];
                  if (v300[0] != v300[1])
                  {
                    v263 = (CI::roiList *)(v260 + 5);
                    do
                      CI::roiList::_insertROI(v263, v262++);
                    while (v262 != (CGRect *)v261);
                    v262 = (CGRect *)v300[0];
                  }
                  if (v262)
                  {
                    v300[1] = (CI *)v262;
                    operator delete(v262);
                  }
                  uint64_t v259 = (v259 + 1);
                }
                while (v259 != v257);
                v264 = v305;
                uint64_t v36 = a5;
                v255 = v258;
                unint64_t v117 = v286;
                unint64_t v254 = v290;
                if (v305 != (uint64_t *)&v306)
                {
                  do
                  {
                    v300[0] = (CI *)v264[4];
                    std::vector<CGRect>::vector(&v300[1], (uint64_t)(v264 + 5));
                    if ((*(unsigned int (**)(CI *))(*(void *)v300[0] + 16))(v300[0]) == 52)
                    {
                      int v265 = *((_DWORD *)v300[0] + 35);
                      unint64_t v266 = v253;
                      if (v265) {
                        unint64_t v266 = (int)CI::format_bytes_per_pixel(v265);
                      }
                      v267 = *(CI **)&size.width;
                      if (*(CI **)&size.width != v300[1])
                      {
                        uint64_t v268 = 0;
                        unint64_t v269 = 0;
                        double v270 = (double)v266;
                        v267 = v300[1];
                        do
                        {
                          double v271 = *(double *)((char *)v267 + v268 + 16);
                          double v272 = *(double *)((char *)v267 + v268 + 24);
                          v304.origin = *(CGPoint *)((char *)v267 + v268);
                          v304.size.double width = v271;
                          v304.size.double height = v272;
                          if (CI::programNodeMemoryLoad(v300[0], &v304.origin.x, &v304, v61, v253, 0) > v284)
                          {
                            double v273 = (double)v254;
                            if (v271 * v272 * v270 >= (double)v254) {
                              double v273 = v271 * v272 * v270;
                            }
                            unint64_t v254 = (unint64_t)v273;
                          }
                          ++v269;
                          v267 = v300[1];
                          v268 += 32;
                        }
                        while (v269 < (uint64_t)(*(void *)&size.width - (unint64_t)v300[1]) >> 5);
                      }
                    }
                    else
                    {
                      v267 = v300[1];
                    }
                    if (v267)
                    {
                      *(void *)&size.double width = v267;
                      operator delete(v267);
                    }
                    v274 = (uint64_t *)v264[1];
                    uint64_t v36 = a5;
                    unint64_t v15 = (unint64_t)v297;
                    if (v274)
                    {
                      do
                      {
                        v275 = (uint64_t **)v274;
                        v274 = (uint64_t *)*v274;
                      }
                      while (v274);
                    }
                    else
                    {
                      do
                      {
                        v275 = (uint64_t **)v264[2];
                        BOOL v276 = *v275 == v264;
                        v264 = (uint64_t *)v275;
                      }
                      while (!v276);
                    }
                    v264 = (uint64_t *)v275;
                  }
                  while (v275 != &v306);
                }
              }
              else
              {
                unint64_t v117 = v286;
              }
              std::__tree<std::__value_type<CI::Node *,CI::roiList>,std::__map_value_compare<CI::Node *,std::__value_type<CI::Node *,CI::roiList>,std::less<CI::Node *>,true>,std::allocator<std::__value_type<CI::Node *,CI::roiList>>>::destroy((uint64_t)&v305, v306);
              ++v255;
            }
            while (v255 != v309);
            v251 = v308;
            unint64_t v172 = v278;
            uint64_t v119 = v293;
            if (v308)
            {
LABEL_278:
              v309 = v251;
              operator delete(v251);
            }
          }
          if (v254 <= v282) {
            break;
          }
          v277 = (void *)CI::Node::rois((CI::Node *)v15);
          *(_DWORD *)(*v277 + 120 * (void)v112 + 80) *= 2;
          continue;
        }
      }
      break;
    }
    int v281 = 0;
LABEL_172:
    unint64_t v173 = v298;
    if (v172 > v298) {
      unint64_t v173 = v172;
    }
    unint64_t v298 = v173;
    double v174 = (CI::SerialRectArray *)CI::Node::rois((CI::Node *)v15);
    *(void *)(*(void *)v174 + 120 * (void)v112 + 88) = v172;
    CI::SerialRectArray::updateParents(v174, (int)v112, v172);
    unint64_t v175 = v279;
    if (v279 <= v172) {
      unint64_t v175 = v172;
    }
    unint64_t v289 = v175;
    double v176 = (void *)CI::Node::rois((CI::Node *)v15);
    memset(&v304, 0, 24);
    uint64_t v177 = *v176 + 120 * (void)v112;
    int v178 = *(_DWORD *)(v177 + 80);
    CGSize v179 = *(CGSize *)(v177 + 16);
    *(_OWORD *)v300 = *(_OWORD *)v177;
    CGSize size = v179;
    CI::SerialRectArray::recurseSubdivide((double *)v300, v178, (void **)&v304);
    unint64_t v180 = CI::nodePathLoad((CI *)v15, v112, v280);
    CGFloat x = v304.origin.y;
    if (*(void *)&v304.origin.y != *(void *)&v304.origin.x)
    {
      uint64_t v182 = 0;
      unint64_t v183 = v180 + v117;
      CGRect v184 = (char *)v112 + 1;
      v185 = v112;
      do
      {
        unint64_t v285 = v182 + 1;
        int v283 = (*(uint64_t (**)(unint64_t))(*(void *)v15 + 40))(v15);
        if (v283 >= 1)
        {
          uint64_t v186 = 0;
          do
          {
            uint64_t v187 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v15 + 48))(v15, v186);
            v188 = (_DWORD *)v187;
            unint64_t v189 = *v36;
            if (*v36 <= v183) {
              unint64_t v189 = v183;
            }
            *uint64_t v36 = v189;
            int v190 = v281
                && (*(unsigned int (**)(uint64_t))(*(void *)v187 + 16))(v187) == 52
                && v188[38] > 1;
            CI::ProgramNode::compute_regions_of_child((CI::Node **)v15, *(CGRect *)(*(void *)&v304.origin.x + 32 * v182), v186, (unint64_t)v296, 1, v190, (uint64_t *)&v308);
            v191 = v309;
            if (v309 != v308)
            {
              uint64_t v192 = 0;
              unint64_t v193 = 0;
              unint64_t v194 = v309 - v308;
              do
              {
                if (v184 == (char *)v291)
                {
                  BOOL v195 = v193 + 1 == v194;
                  BOOL v196 = v285 == (uint64_t)(*(void *)&v304.origin.y - *(void *)&v304.origin.x) >> 5 && v195;
                }
                else
                {
                  BOOL v196 = 0;
                }
                v197 = (CI::SerialRectArray *)CI::Node::rois(v297);
                int v198 = CI::SerialRectArray::maxParentDistance(v197);
                v300[0] = v297;
                v112 = v185;
                v300[1] = (CI *)__PAIR64__(v182, v185);
                *(void *)&size.double width = __PAIR64__(v193, v186);
                *(void *)&size.double height = v183;
                unint64_t v302 = v289;
                unsigned int v303 = v198 + 1;
                (*(void (**)(_DWORD *, unint64_t, CGRect *, CI **, CGFloat, CGFloat, CGFloat, CGFloat))(*(void *)v188 + 344))(v188, v294, v296, v300, v308[v192].origin.x, v308[v192].origin.y, v308[v192].size.width, v308[v192].size.height);
                BOOL v199 = v196;
                uint64_t v36 = a5;
                unint64_t v200 = CI::subdivide_program_rois(v293, v188, v292, v199, a5, v308[v192].origin.x);
                unint64_t v201 = v298;
                if (v200 > v298) {
                  unint64_t v201 = v200;
                }
                unint64_t v298 = v201;
                ++v193;
                v191 = v308;
                unint64_t v194 = v309 - v308;
                ++v192;
              }
              while (v194 > v193);
              unint64_t v15 = (unint64_t)v297;
            }
            if (v191)
            {
              v309 = v191;
              operator delete(v191);
            }
            uint64_t v186 = (v186 + 1);
          }
          while (v186 != v283);
        }
        CGFloat x = v304.origin.x;
        ++v182;
      }
      while (v285 < (uint64_t)(*(void *)&v304.origin.y - *(void *)&v304.origin.x) >> 5);
      uint64_t v61 = v296;
    }
    if (x != 0.0)
    {
      v304.origin.CGFloat y = x;
      operator delete(*(void **)&x);
    }
    v112 = (const CI::ProgramNode *)((char *)v112 + 1);
  }
  while (v112 != (const CI::ProgramNode *)v291);
  return v298;
}

double CI::Node::roi(CI::Node *this, int a2)
{
  return *(double *)(**((void **)this + 2) + 120 * a2);
}

uint64_t CI::format_bytes_per_pixel(int a1)
{
  return (CI::format_bits_per_pixel(a1) + 7) >> 3;
}

uint64_t CI::format_bits_per_pixel(int a1)
{
  uint64_t result = 0;
  if (a1 <= 1792)
  {
    if (a1 > 770)
    {
      if (a1 > 1042)
      {
        if (a1 > 1298)
        {
          if (a1 <= 1553)
          {
            if (a1 == 1299) {
              return 32;
            }
            if (a1 != 1302) {
              return result;
            }
          }
          else
          {
            if (a1 == 1554) {
              return 16;
            }
            if (a1 == 1555) {
              return 32;
            }
            if (a1 != 1558) {
              return result;
            }
          }
          return 22;
        }
        if (a1 <= 1284)
        {
          if (a1 != 1043)
          {
            if (a1 != 1046) {
              return result;
            }
            return 32;
          }
          return 48;
        }
        switch(a1)
        {
          case 1285:
            return 10;
          case 1286:
            return 20;
          case 1298:
            return 16;
        }
      }
      else
      {
        switch(a1)
        {
          case 771:
          case 773:
            return 16;
          case 772:
          case 776:
          case 777:
          case 778:
          case 779:
          case 780:
          case 781:
          case 782:
          case 783:
          case 788:
          case 789:
            return result;
          case 774:
          case 775:
          case 784:
          case 785:
          case 790:
            return 32;
          case 786:
            return 24;
          case 787:
            return 48;
          default:
            if (a1 == 1042) {
              return 24;
            }
            break;
        }
      }
    }
    else
    {
      switch(a1)
      {
        case 257:
        case 258:
        case 259:
        case 261:
          uint64_t result = 8;
          break;
        case 260:
        case 262:
        case 276:
        case 277:
        case 278:
          return 16;
        case 263:
        case 275:
          return 24;
        case 264:
        case 265:
        case 266:
        case 267:
        case 268:
        case 269:
        case 270:
        case 271:
          return 32;
        case 272:
        case 273:
          return result;
        case 274:
LABEL_28:
          uint64_t result = 12;
          break;
        default:
          switch(a1)
          {
            case 530:
              goto LABEL_28;
            case 531:
              return 24;
            case 532:
            case 533:
            case 534:
              return 16;
            case 535:
              return 32;
            default:
              return result;
          }
      }
    }
  }
  else
  {
    if (a1 > 2304)
    {
      if (a1 <= 3080)
      {
        if (a1 <= 2566)
        {
          switch(a1)
          {
            case 2305:
            case 2306:
            case 2307:
            case 2309:
              return 32;
            case 2308:
            case 2310:
              return 64;
            case 2311:
              uint64_t result = 96;
              break;
            case 2312:
            case 2313:
            case 2316:
              uint64_t result = 128;
              break;
            default:
              return result;
          }
          return result;
        }
        if (a1 > 2823)
        {
          if (a1 == 2824) {
            return 64;
          }
          if (a1 != 3079) {
            return result;
          }
        }
        else if (a1 != 2567)
        {
          if (a1 != 2569) {
            return result;
          }
          return 64;
        }
        return 32;
      }
      if (a1 > 3349)
      {
        if (a1 <= 3605)
        {
          if (a1 == 3350) {
            return 32;
          }
          if (a1 == 3602) {
            return 24;
          }
          if (a1 != 3603) {
            return result;
          }
        }
        else
        {
          if (a1 <= 3858)
          {
            if (a1 == 3606) {
              return 32;
            }
            if (a1 != 3858) {
              return result;
            }
            return 24;
          }
          if (a1 != 3859)
          {
            if (a1 != 3862) {
              return result;
            }
            return 32;
          }
        }
        return 48;
      }
      if (a1 > 3333)
      {
        if (a1 == 3334) {
          return 32;
        }
        if (a1 == 3346) {
          return 24;
        }
        if (a1 != 3347) {
          return result;
        }
        return 48;
      }
      if (a1 == 3081) {
        return 64;
      }
      if (a1 != 3331 && a1 != 3333) {
        return result;
      }
      return 16;
    }
    switch(a1)
    {
      case 1793:
      case 1794:
      case 1795:
      case 1797:
        return 16;
      case 1796:
      case 1798:
      case 1814:
        return 32;
      case 1799:
      case 1811:
        return 48;
      case 1800:
      case 1801:
      case 1804:
        return 64;
      case 1802:
      case 1803:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        return result;
      case 1810:
        return 24;
      default:
        switch(a1)
        {
          case 2049:
          case 2050:
          case 2051:
          case 2053:
            return 16;
          case 2052:
          case 2054:
          case 2070:
            return 32;
          case 2055:
          case 2067:
            return 48;
          case 2056:
          case 2060:
            return 64;
          case 2066:
            return 24;
          default:
            return result;
        }
    }
  }
  return result;
}

uint64_t CI::MetalContext::max_output_image_size(CI::MetalContext *this)
{
  return *((void *)this + 50);
}

uint64_t ___ZN2CIL32make_program_graph_if_renderableEPNS_7ContextEPKcNS_14GraphWithDepthERK6CGRectRKNS_19output_swizzle_infoEPcm_block_invoke(uint64_t a1, CI::ProgramNode *a2)
{
  uint64_t result = (*(uint64_t (**)(CI::ProgramNode *))(*(void *)a2 + 16))(a2);
  if (result == 52)
  {
    CI::ProgramNode::release_program_and_arguments(a2);
    uint64_t result = (*(uint64_t (**)(void *))(**((void **)a2 + 6) + 16))(*((void **)a2 + 6));
    if (result != 41)
    {
      uint64_t result = (*(uint64_t (**)(void *))(**((void **)a2 + 6) + 16))(*((void **)a2 + 6));
      if (result != 42)
      {
        int v5 = *(CI::Context **)(a1 + 32);
        CI::ProgramNode::create_program_and_arguments(a2, v5, "main");
      }
    }
  }
  return result;
}

uint64_t CI::ProgramNode::type(CI::ProgramNode *this)
{
  return 52;
}

uint64_t CI::Node::GetNodeUseCount(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    int v5 = *(void **)(a1 + 8);
    unsigned int v3 = (void *)(a1 + 8);
    uint64_t v4 = v5;
    if (!v5) {
      return 0;
    }
    long long v6 = v3;
    do
    {
      unint64_t v7 = v4[4];
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        CGFloat v9 = v4;
      }
      else {
        CGFloat v9 = v4 + 1;
      }
      if (v8) {
        long long v6 = v4;
      }
      uint64_t v4 = (void *)*v9;
    }
    while (*v9);
    if (v6 != v3 && v6[4] <= a2) {
      return *((unsigned int *)v6 + 10);
    }
    else {
      return 0;
    }
  }
  return v2;
}

uint64_t CI::SerialRectArray::maxParentDistance(CI::SerialRectArray *this)
{
  uint64_t v1 = *(void *)this;
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = v2 - *(void *)this;
  if (v2 == *(void *)this) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t result = 0;
  unint64_t v6 = v3 / 120;
  if (v6 <= 1) {
    unint64_t v6 = 1;
  }
  do
  {
    uint64_t v7 = v1 + 120 * v4;
    uint64_t v8 = *(void *)(v7 + 32);
    uint64_t v9 = *(void *)(v7 + 40);
    if (v8 == v9)
    {
      unsigned int v10 = 0;
    }
    else
    {
      unsigned int v10 = 0;
      uint64_t v11 = v8;
      do
      {
        if (v10 <= *(_DWORD *)(v11 + 40)) {
          unsigned int v10 = *(_DWORD *)(v11 + 40);
        }
        v11 += 48;
      }
      while (v11 != v9);
    }
    uint64_t v12 = v1 + 120 * v4;
    uint64_t v13 = *(void *)(v12 + 56);
    uint64_t v14 = *(void *)(v12 + 64);
    for (uint64_t i = v13; i != v14; i += 48)
    {
      if (v10 <= *(_DWORD *)(i + 40)) {
        unsigned int v10 = *(_DWORD *)(i + 40);
      }
    }
    if (result <= v10)
    {
      if (v8 == v9)
      {
        uint64_t result = 0;
      }
      else
      {
        LODWORD(result) = 0;
        do
        {
          unsigned int v16 = *(_DWORD *)(v8 + 40);
          if (result <= v16) {
            uint64_t result = v16;
          }
          else {
            uint64_t result = result;
          }
          v8 += 48;
        }
        while (v8 != v9);
      }
      while (v13 != v14)
      {
        unsigned int v17 = *(_DWORD *)(v13 + 40);
        if (result <= v17) {
          uint64_t result = v17;
        }
        else {
          uint64_t result = result;
        }
        v13 += 48;
      }
    }
    ++v4;
  }
  while (v4 != v6);
  return result;
}

unint64_t CI::nodePathLoad(CI *this, const CI::ProgramNode *a2, unint64_t a3)
{
  int v4 = (int)a2;
  if (*(int *)(*(void *)CI::Node::rois(this) + 120 * (int)a2 + 80) < 2 || CI::isRootNode(this, v6)) {
    return 0;
  }
  CI::Node::roi(this, v4);
  return (unint64_t)(v9 * v8 * (double)a3);
}

uint64_t CI::MetalContext::max_input_image_size(CI::MetalContext *this)
{
  return *((void *)this + 50);
}

void CI::SerialRectArray::restore(CI::SerialRectArray *this, int a2, const CI::parentROI *a3)
{
  uint64_t v3 = *(void *)this + 120 * a2;
  int v5 = *(_DWORD **)(v3 + 56);
  v3 += 56;
  int v4 = v5;
  double v8 = *(_DWORD **)(v3 + 8);
  uint64_t v7 = (void *)(v3 + 8);
  unint64_t v6 = v8;
  while (v4 != v6)
  {
    if (*(void *)v4 == *(void *)a3
      && *((_DWORD *)a3 + 4) == v4[4]
      && *((_DWORD *)a3 + 3) == v4[3]
      && *((_DWORD *)a3 + 2) == v4[2])
    {
      uint64_t v12 = *(void *)this + 120 * a2;
      unint64_t v15 = *(void *)(v12 + 48);
      uint64_t v14 = (void *)(v12 + 48);
      unint64_t v13 = v15;
      unsigned int v17 = (void **)(v14 - 1);
      unsigned int v16 = (_OWORD *)*(v14 - 1);
      if ((unint64_t)v16 >= v15)
      {
        BOOL v21 = (void **)(v14 - 2);
        uint64_t v22 = *(v14 - 2);
        unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v16 - v22) >> 4);
        unint64_t v24 = v23 + 1;
        if (v23 + 1 > 0x555555555555555) {
          abort();
        }
        unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - v22) >> 4);
        if (2 * v25 > v24) {
          unint64_t v24 = 2 * v25;
        }
        if (v25 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v26 = 0x555555555555555;
        }
        else {
          unint64_t v26 = v24;
        }
        if (v26) {
          unint64_t v27 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::parentROI>>((uint64_t)v14, v26);
        }
        else {
          unint64_t v27 = 0;
        }
        uint64_t v28 = &v27[48 * v23];
        long long v29 = *(_OWORD *)v4;
        long long v30 = *((_OWORD *)v4 + 2);
        *((_OWORD *)v28 + 1) = *((_OWORD *)v4 + 1);
        *((_OWORD *)v28 + 2) = v30;
        *(_OWORD *)uint64_t v28 = v29;
        int v31 = (char *)*v17;
        uint64_t v32 = (char *)*v21;
        uint64_t v33 = v28;
        if (*v17 != *v21)
        {
          do
          {
            long long v34 = *((_OWORD *)v31 - 3);
            long long v35 = *((_OWORD *)v31 - 1);
            *((_OWORD *)v33 - 2) = *((_OWORD *)v31 - 2);
            *((_OWORD *)v33 - 1) = v35;
            *((_OWORD *)v33 - 3) = v34;
            v33 -= 48;
            v31 -= 48;
          }
          while (v31 != v32);
          int v31 = (char *)*v21;
        }
        *BOOL v21 = v33;
        unint64_t v20 = v28 + 48;
        FILE *v17 = v28 + 48;
        *uint64_t v14 = &v27[48 * v26];
        if (v31) {
          operator delete(v31);
        }
      }
      else
      {
        long long v18 = *(_OWORD *)v4;
        long long v19 = *((_OWORD *)v4 + 2);
        v16[1] = *((_OWORD *)v4 + 1);
        void v16[2] = v19;
        *unsigned int v16 = v18;
        unint64_t v20 = v16 + 3;
      }
      FILE *v17 = v20;
      uint64_t v36 = *v7 - (void)(v4 + 12);
      if ((_DWORD *)*v7 != v4 + 12) {
        memmove(v4, v4 + 12, *v7 - (void)(v4 + 12));
      }
      unint64_t v6 = (_DWORD *)((char *)v4 + v36);
      *uint64_t v7 = (char *)v4 + v36;
    }
    else
    {
      v4 += 12;
    }
  }
}

void CI::TextureManager::add_to_pending(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(NSObject **)(a1 + 104);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = ___ZN2CI14TextureManager14add_to_pendingERKNS_6roiKeyE_block_invoke;
  _OWORD v3[3] = &__block_descriptor_tmp_17_1;
  void v3[4] = a1;
  void v3[5] = a2;
  dispatch_sync(v2, v3);
}

void CI::SurfaceNode::add_roi(CI::SurfaceNode *this, unint64_t a2, unint64_t a3, CGRect a4, const CI::parentROI *a5)
{
  CGFloat height = a4.size.height;
  CGFloat width = a4.size.width;
  CGFloat y = a4.origin.y;
  CGFloat x = a4.origin.x;
  if (CGRectIsEmpty(a4))
  {
    unint64_t v13 = this;
    unint64_t v14 = a2;
    unint64_t v15 = a3;
    double v16 = x;
    double v17 = y;
    double v18 = width;
    double v19 = height;
    goto LABEL_128;
  }
  v64.origin.CGFloat x = (*(double (**)(CI::SurfaceNode *))(*(void *)this + 168))(this);
  CGFloat v20 = v64.origin.x;
  CGFloat v21 = v64.origin.y;
  CGFloat v22 = v64.size.width;
  CGFloat v23 = v64.size.height;
  if (CGRectIsNull(v64))
  {
    unint64_t v24 = 0;
    unint64_t v25 = 0;
    int v26 = 0x7FFFFFFF;
    int v27 = 0x7FFFFFFF;
  }
  else
  {
    v65.origin.CGFloat x = v20;
    v65.origin.CGFloat y = v21;
    v65.size.CGFloat width = v22;
    v65.size.CGFloat height = v23;
    if (CGRectIsInfinite(v65))
    {
      int v26 = -2147483647;
      unint64_t v24 = 0xFFFFFFFFLL;
      unint64_t v25 = 0xFFFFFFFFLL;
      int v27 = -2147483647;
    }
    else
    {
      v66.origin.CGFloat x = v20;
      v66.origin.CGFloat y = v21;
      v66.size.CGFloat width = v22;
      v66.size.CGFloat height = v23;
      CGRect v67 = CGRectInset(v66, 0.000001, 0.000001);
      CGRect v68 = CGRectIntegral(v67);
      int v27 = (int)v68.origin.x;
      int v26 = (int)v68.origin.y;
      unint64_t v25 = (unint64_t)v68.size.width;
      unint64_t v24 = (unint64_t)v68.size.height;
    }
  }
  v69.origin.CGFloat x = x;
  v69.origin.CGFloat y = y;
  v69.size.CGFloat width = width;
  v69.size.CGFloat height = height;
  if (CGRectIsNull(v69))
  {
    unint64_t v28 = 0;
    unint64_t v29 = 0;
    int v30 = 0x7FFFFFFF;
    int v31 = 0x7FFFFFFF;
  }
  else
  {
    v70.origin.CGFloat x = x;
    v70.origin.CGFloat y = y;
    v70.size.CGFloat width = width;
    v70.size.CGFloat height = height;
    if (CGRectIsInfinite(v70))
    {
      int v30 = -2147483647;
      unint64_t v28 = 0xFFFFFFFFLL;
      unint64_t v29 = 0xFFFFFFFFLL;
      int v31 = -2147483647;
    }
    else
    {
      v71.origin.CGFloat x = x;
      v71.origin.CGFloat y = y;
      v71.size.CGFloat width = width;
      v71.size.CGFloat height = height;
      CGRect v72 = CGRectInset(v71, 0.000001, 0.000001);
      CGRect v73 = CGRectIntegral(v72);
      int v31 = (int)v73.origin.x;
      int v30 = (int)v73.origin.y;
      unint64_t v29 = (unint64_t)v73.size.width;
      unint64_t v28 = (unint64_t)v73.size.height;
    }
  }
  if (*((_DWORD *)this + 25) != 1 || v27 == -2147483647 && v26 == -2147483647 && v25 == 0xFFFFFFFF && v24 == 0xFFFFFFFF) {
    goto LABEL_18;
  }
  int v34 = 0x7FFFFFFF;
  if (v31 == 0x7FFFFFFF)
  {
    if (v30 == 0x7FFFFFFF && !v29 && !v28)
    {
      uint64_t v32 = 0;
      uint64_t v33 = 0;
      int v35 = 0x7FFFFFFF;
      goto LABEL_19;
    }
  }
  else if (v31 == -2147483647 && v30 == -2147483647 && v29 == 0xFFFFFFFF && v28 == 0xFFFFFFFF)
  {
    goto LABEL_109;
  }
  if (v24) {
    BOOL v51 = 0;
  }
  else {
    BOOL v51 = v25 == 0;
  }
  BOOL v53 = v51 && v26 == 0x7FFFFFFF && v27 == 0x7FFFFFFF;
  if (!v53 && v27 <= v31 && v27 + (int)v25 >= v31 + (int)v29 && v26 <= v30 && v26 + (int)v24 >= v30 + (int)v28)
  {
LABEL_18:
    uint64_t v32 = v28;
    uint64_t v33 = v29;
    int v34 = v30;
    int v35 = v31;
    goto LABEL_19;
  }
LABEL_109:
  if ((v27 != 0x7FFFFFFF || v26 != 0x7FFFFFFF || v25 || v24) && (v31 != 0x7FFFFFFF || v30 != 0x7FFFFFFF || v29 || v28))
  {
    if (v31 != -2147483647
      || v30 != -2147483647
      || v29 != 0xFFFFFFFF
      || (uint64_t v32 = v24, v33 = v25, v34 = v26, v35 = v27, v28 != 0xFFFFFFFF))
    {
      if (v27 <= v31) {
        int v35 = v31;
      }
      else {
        int v35 = v27;
      }
      int v56 = v27 + v25;
      if (v27 + (int)v25 >= v31 + (int)v29) {
        int v56 = v31 + v29;
      }
      LODWORD(v33) = v56 - v35;
      if (v56 < v35) {
        goto LABEL_117;
      }
      if (v26 <= v30) {
        int v34 = v30;
      }
      else {
        int v34 = v26;
      }
      int v57 = v26 + v24;
      if (v26 + (int)v24 >= v30 + (int)v28) {
        int v57 = v30 + v28;
      }
      BOOL v58 = __OFSUB__(v57, v34);
      LODWORD(v32) = v57 - v34;
      if ((int)v32 < 0 != v58) {
        goto LABEL_117;
      }
      uint64_t v33 = (int)v33;
      uint64_t v32 = (int)v32;
    }
    if (v33 && v32) {
      goto LABEL_19;
    }
  }
LABEL_117:
  int v54 = v31 + v29;
  if (v54 >= v27)
  {
    int v55 = v27 + v25;
    if (v31 <= v27 + (int)v25)
    {
      if (v31 <= v27) {
        int v35 = v27;
      }
      else {
        int v35 = v31;
      }
      if (v54 >= v55) {
        int v59 = v27 + v25;
      }
      else {
        int v59 = v54;
      }
      uint64_t v33 = v59 - v35;
    }
    else
    {
      int v35 = v55 - 1;
      uint64_t v33 = 1;
    }
  }
  else
  {
    uint64_t v33 = 1;
    int v35 = v27;
  }
  int v60 = v30 + v28;
  if (v60 >= v26)
  {
    int v61 = v26 + v24;
    if (v30 <= v26 + (int)v24)
    {
      if (v30 <= v26) {
        int v34 = v26;
      }
      else {
        int v34 = v30;
      }
      if (v60 >= v61) {
        int v62 = v26 + v24;
      }
      else {
        int v62 = v60;
      }
      uint64_t v32 = v62 - v34;
    }
    else
    {
      int v34 = v61 - 1;
      uint64_t v32 = 1;
    }
  }
  else
  {
    uint64_t v32 = 1;
    int v34 = v26;
  }
LABEL_19:
  int v36 = 0x7FFFFFFF;
  if ((v27 != 0x7FFFFFFF || v26 != 0x7FFFFFFF || v25 || v24) && (v35 != 0x7FFFFFFF || v34 != 0x7FFFFFFF || v33 || v32))
  {
    if (v27 == -2147483647 && v26 == -2147483647 && v25 == 0xFFFFFFFF && v24 == 0xFFFFFFFF)
    {
      int v36 = v35;
      int v39 = v34;
      unint64_t v37 = v33;
      unint64_t v38 = v32;
    }
    else if (v35 != -2147483647 {
           || v34 != -2147483647
    }
           || v33 != 0xFFFFFFFFLL
           || (int v36 = v27, v39 = v26, v37 = v25, v38 = v24, v32 != 0xFFFFFFFFLL))
    {
      if (v27 <= v35) {
        int v42 = v35;
      }
      else {
        int v42 = v27;
      }
      int v43 = v27 + v25;
      if (v27 + (int)v25 >= v35 + (int)v33) {
        int v43 = v35 + v33;
      }
      if (v26 <= v34) {
        int v39 = v34;
      }
      else {
        int v39 = v26;
      }
      int v44 = v26 + v24;
      int v45 = v34 + v32;
      if (v26 + (int)v24 >= v45) {
        int v44 = v45;
      }
      BOOL v46 = v44 < v39;
      unint64_t v47 = v44 - v39;
      if (v46) {
        int v48 = 0x7FFFFFFF;
      }
      else {
        int v48 = v42;
      }
      if (v46)
      {
        int v39 = 0x7FFFFFFF;
        unint64_t v49 = 0;
      }
      else
      {
        unint64_t v49 = v43 - v42;
      }
      if (v46) {
        unint64_t v47 = 0;
      }
      BOOL v50 = v43 < v42;
      if (v43 >= v42) {
        int v36 = v48;
      }
      else {
        int v36 = 0x7FFFFFFF;
      }
      if (v50)
      {
        int v39 = 0x7FFFFFFF;
        unint64_t v37 = 0;
      }
      else
      {
        unint64_t v37 = v49;
      }
      if (v50) {
        unint64_t v38 = 0;
      }
      else {
        unint64_t v38 = v47;
      }
    }
  }
  else
  {
    unint64_t v37 = 0;
    unint64_t v38 = 0;
    int v39 = 0x7FFFFFFF;
  }
  if (v25 <= v24) {
    unint64_t v40 = v24;
  }
  else {
    unint64_t v40 = v25;
  }
  if (v40 <= 0x1000 && 3 * v24 * v25 <= 4 * v37 * v38)
  {
    if (v27 == -2147483647)
    {
      if (v26 == -2147483647 && v25 == 0xFFFFFFFF && v24 == 0xFFFFFFFF)
      {
LABEL_124:
        CGFloat v41 = (double *)MEMORY[0x1E4F1DB10];
        goto LABEL_125;
      }
    }
    else if (v27 == 0x7FFFFFFF && v26 == 0x7FFFFFFF && !v25 && !v24)
    {
      goto LABEL_55;
    }
    double v16 = (double)v27;
    double v17 = (double)v26;
    double v18 = (double)v25;
    double v19 = (double)v24;
    goto LABEL_127;
  }
  if (v36 == -2147483647)
  {
    if (v39 != -2147483647 || v37 != 0xFFFFFFFF || v38 != 0xFFFFFFFF) {
      goto LABEL_59;
    }
    goto LABEL_124;
  }
  if (v36 == 0x7FFFFFFF && v39 == 0x7FFFFFFF && !v37 && !v38)
  {
LABEL_55:
    CGFloat v41 = (double *)MEMORY[0x1E4F1DB20];
LABEL_125:
    double v16 = *v41;
    double v17 = v41[1];
    double v18 = v41[2];
    double v19 = v41[3];
    goto LABEL_127;
  }
LABEL_59:
  double v16 = (double)v36;
  double v17 = (double)v39;
  double v18 = (double)v37;
  double v19 = (double)v38;
LABEL_127:
  unint64_t v13 = this;
  unint64_t v14 = a2;
  unint64_t v15 = a3;
LABEL_128:

  CI::Node::add_roi(v13, v14, v15, *(CGRect *)&v16, a5);
}

CI::SerialObjectPtrArray *CI::ProgramNode::release_program_and_arguments(CI::ProgramNode *this)
{
  uint64_t v2 = (CI::Object *)*((void *)this + 15);
  if (v2) {
    CI::Object::unref(v2);
  }
  *((void *)this + 15) = 0;
  uint64_t result = (CI::SerialObjectPtrArray *)*((void *)this + 16);
  if (result)
  {
    CI::SerialObjectPtrArray::~SerialObjectPtrArray(result);
    uint64_t result = (CI::SerialObjectPtrArray *)MEMORY[0x1997023B0]();
  }
  *((void *)this + 16) = 0;
  return result;
}

void CI::SerialRectArray::unionRect(CGRect **this)
{
  uint64_t v1 = *MEMORY[0x1E4F1DB20];
  uint64_t v2 = *(void *)(MEMORY[0x1E4F1DB20] + 8);
  uint64_t v3 = *(void *)(MEMORY[0x1E4F1DB20] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4F1DB20] + 24);
  for (uint64_t i = *this; i != this[1]; uint64_t i = (CGRect *)((char *)i + 120))
    *(CGRect *)&uint64_t v1 = CGRectUnion(*(CGRect *)&v1, *i);
}

unint64_t CI::estimateProgramNodeMemoryLoad(CI *this, const CI::ProgramNode *a2, const CGRect *a3, unint64_t a4, int a5)
{
  unsigned int v8 = a2;
  unsigned int v10 = (void *)CI::Node::rois(this);
  CGFloat v21 = 0;
  uint64_t v22 = 0;
  CGFloat v20 = 0;
  if ((v8 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v11 = *v10 + 120 * v8;
  int v12 = *(_DWORD *)(v11 + 80);
  long long v13 = *(_OWORD *)(v11 + 16);
  long long v23 = *(_OWORD *)v11;
  long long v24 = v13;
  CI::SerialRectArray::recurseSubdivide((double *)&v23, v12, (void **)&v20);
  unint64_t v15 = v20;
  unint64_t v14 = v21;
  if (v20 == v21)
  {
    unint64_t v16 = 0;
    if (!v21) {
      return v16;
    }
LABEL_11:
    CGFloat v21 = v14;
    operator delete(v14);
    return v16;
  }
  unint64_t v16 = 0;
  do
  {
    long long v23 = *v15;
    long long v24 = v15[1];
    double v17 = (void *)CI::Node::rois(this);
    unint64_t v18 = CI::programNodeMemoryLoad(this, (CGFloat *)&v23, (const CGRect *)(*v17 + 120 * v8), a3, a4, a5);
    if (v16 <= v18) {
      unint64_t v16 = v18;
    }
    v15 += 2;
  }
  while (v15 != v21);
  unint64_t v14 = v20;
  if (v20) {
    goto LABEL_11;
  }
  return v16;
}

BOOL CI::isRootNode(CI *this, const CI::ProgramNode *a2)
{
  return !**(void **)(*(void *)CI::Node::rois(this) + 32) && CI::Node::rois_count(this) == 1;
}

void CI::SerialRectArray::updateParents(CI::SerialRectArray *this, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)this + 120 * a2;
  uint64_t v4 = *(void *)(v3 + 32);
  for (uint64_t i = *(void *)(v3 + 40); v4 != i; v4 += 48)
  {
    uint64_t v7 = *(CI::Node **)v4;
    if (*(void *)v4)
    {
      int v8 = *(_DWORD *)(v4 + 8);
      double v9 = (CI::SerialRectArray *)CI::Node::rois(*(CI::Node **)v4);
      int v10 = (*(uint64_t (**)(CI::Node *))(*(void *)v7 + 40))(v7);
      CI::SerialRectArray::updateSubGraphLoad(v9, v8, a3, v10);
    }
  }
}

void CI::MetalContext::render_root_node(uint64_t a1, CI::TileTask *a2, CI::parentROI *this, uint64_t a4, uint64_t a5)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)this;
  v34.origin.CGFloat x = CI::parentROI::roi(this);
  v34.origin.CGFloat y = v11;
  v34.size.CGFloat width = v12;
  v34.size.CGFloat height = v13;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    unint64_t v14 = ci_signpost_log_render();
    os_signpost_id_t v15 = *(int *)(v10 + 36) | (unint64_t)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1) << 32);
    if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v14))
    {
      *(_DWORD *)CGRect buf = 68289026;
      int v36 = 256;
      __int16 v37 = 2082;
      unint64_t v38 = CI::Context::programName((dispatch_queue_t *)v10, v16);
      _os_signpost_emit_with_name_impl(&dword_193671000, v14, OS_SIGNPOST_INTERVAL_BEGIN, v15, "render_node", "%{public}.256s", buf, 0x12u);
    }
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)buf, v17, *(_DWORD *)(v10 + 36), (uint64_t)"render_node", 0);
  *(void *)(a1 + 1800) = *(void *)(a1 + 1792);
  uint64_t v18 = *(void *)(v10 + 48);
  BOOL v19 = (*(int (**)(uint64_t))(*(void *)v18 + 16))(v18) >= 41
     && (*(int (**)(uint64_t))(*(void *)v18 + 16))(v18) < 43;
  if (!CI_ENABLE_METAL_DEBUG()
    || *(void *)(a1 + 1808)
    || (uint64_t v28 = *(void *)(v10 + 48), (*(int (**)(uint64_t))(*(void *)v28 + 16))(v28) >= 41)
    && (*(int (**)(uint64_t))(*(void *)v28 + 16))(v28) < 43)
  {
    CGFloat v20 = 0;
  }
  else
  {
    CGFloat v20 = v33;
    v33[0] = MEMORY[0x1E4F143A8];
    v33[1] = 3221225472;
    v33[2] = ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke;
    v33[3] = &__block_descriptor_48_e11_v24__0Q8Q16l;
    v33[4] = a2;
    v33[5] = v10;
  }
  CGFloat v21 = *(void **)(a1 + 1808);
  if (!v21) {
    CGFloat v21 = CIMetalCommandBufferCreate(*(void *)(a1 + 1920), *(void **)(a1 + 392), !v19, v20);
  }
  *(void *)(a1 + 1792) = v21;
  uint64_t v22 = *(void *)(a1 + 1888);
  if (v22)
  {
    (*(void (**)(CGRect *__return_ptr))(v22 + 16))(&cf);
    CGFloat x = cf.origin.x;
    if (*(void *)&cf.origin.x) {
      CGFloat x = COERCE_DOUBLE(CFRetain(*(CFTypeRef *)&cf.origin.x));
    }
    *(CGFloat *)(a1 + 1864) = x;
  }
  cf.origin.CGFloat x = 0.0;
  cf.origin.CGFloat y = 0.0;
  cf.CGSize size = *(CGSize *)(a1 + 1832);
  *(unsigned char *)(a1 + 1896) = CI::MetalContext::render_node((CI::MetalContext *)a1, a2, this, &cf, (void **)(a1 + 1864), 0, 2);
  if (*(void *)(a1 + 1880)) {
    objc_msgSend(*(id *)(a1 + 1792), "presentDrawable:");
  }
  BOOL v24 = *(void *)(a1 + 1792) == *(void *)(a1 + 1808);
  unint64_t v25 = CI::ProgramNode::program_name((CI::ProgramNode *)v10);
  CI::TileTask::addROIForNode(a2, (CI::ProgramNode *)v10, &v34);
  if (a2) {
    CI::Object::ref((uint64_t)a2);
  }
  if (*(void *)(a1 + 1808))
  {
    (*(void (**)(uint64_t))(a4 + 16))(a4);
  }
  else
  {
    int v26 = *(void **)(a1 + 1792);
    v31[0] = MEMORY[0x1E4F143A8];
    v31[1] = 3221225472;
    v31[2] = ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_2;
    v31[3] = &unk_1E57726D8;
    v31[4] = a4;
    [v26 addScheduledHandler:v31];
  }
  int v27 = *(void **)(a1 + 1792);
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_3;
  v29[3] = &unk_1E5773C00;
  BOOL v30 = v24;
  v29[6] = v25;
  v29[7] = v10;
  v29[4] = a5;
  v29[5] = a2;
  CIMetalCommandBufferAddCompletionHandler(v27, (uint64_t)v29);
  if (!*(unsigned char *)(a1 + 1904) && !*(void *)(a1 + 1856)) {
    CIMetalCommandBufferSynchronizeTexture(*(void *)(a1 + 1792), *(void *)(a1 + 1864));
  }
  if (*(void *)(a1 + 1792) != *(void *)(a1 + 1808)) {
    CIMetalCommandBufferCommit();
  }
  CI::MetalContext::render_root_node(CI::TileTask *,CI::parentROI const&,void({block_pointer})(void),void({block_pointer})(void))::SignpostTimer::~SignpostTimer((TimerBase *)buf);
}

void sub_1936B130C(_Unwind_Exception *a1)
{
  CI::MetalContext::render_root_node(CI::TileTask *,CI::parentROI const&,void({block_pointer})(void),void({block_pointer})(void))::SignpostTimer::~SignpostTimer((TimerBase *)(v1 - 144));
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_SUBDIVIDE_ROI()
{
  {
    CI_ENABLE_SUBDIVIDE_ROI::v = get_BOOL("CI_ENABLE_SUBDIVIDE_ROI", 1);
  }
  return CI_ENABLE_SUBDIVIDE_ROI::v;
}

void sub_1936B13A4(_Unwind_Exception *a1)
{
}

uint64_t CI_ENABLE_METAL_DEBUG()
{
  {
    CI_ENABLE_METAL_DEBUG::v = get_BOOL("CI_ENABLE_METAL_DEBUG", 0);
  }
  return CI_ENABLE_METAL_DEBUG::v;
}

void sub_1936B1424(_Unwind_Exception *a1)
{
}

void CI::TextureManager::remove_from_pending(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(NSObject **)(a1 + 104);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = ___ZN2CI14TextureManager19remove_from_pendingERKNS_6roiKeyE_block_invoke;
  _OWORD v3[3] = &__block_descriptor_tmp_18_2;
  void v3[4] = a1;
  void v3[5] = a2;
  dispatch_sync(v2, v3);
}

void CI::MetalContext::render_root_node(CI::TileTask *,CI::parentROI const&,void({block_pointer})(void),void({block_pointer})(void))::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v2 = ci_signpost_log_render();
    os_signpost_id_t v3 = *((void *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)int v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "render_node", "", v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1936B1544(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

const char *CI::ProgramNode::program_name(CI::ProgramNode *this)
{
  uint64_t v1 = *((void *)this + 15);
  if (v1) {
    return *(const char **)(v1 + 48);
  }
  uint64_t v4 = *((void *)this + 6);
  if ((*(int (**)(uint64_t))(*(void *)v4 + 16))(v4) < 41
    || (*(int (**)(uint64_t))(*(void *)v4 + 16))(v4) > 42)
  {
    return 0;
  }
  CFStringRef v5 = (const __CFString *)(*(uint64_t (**)(void))(**((void **)this + 6) + 24))(*((void *)this + 6));

  return CFStringGetCStringPtr(v5, 0x8000100u);
}

void *CIMetalCommandBufferAddCompletionHandler(void *result, uint64_t a2)
{
  if (a2)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = __CIMetalCommandBufferAddCompletionHandler_block_invoke;
    v2[3] = &unk_1E57726D8;
    void v2[4] = a2;
    return (void *)[result addCompletedHandler:v2];
  }
  return result;
}

void CI::TextureManager::intermediate(CI::TextureManager *this)
{
}

void *CIMetalDeviceGetLimits(void *result, unint64_t *a2)
{
  if (a2)
  {
    os_signpost_id_t v3 = result;
    unint64_t v4 = [result maxTextureWidth2D];
    if (v4 >= [v3 maxTextureHeight2D]) {
      unint64_t v5 = [v3 maxTextureHeight2D];
    }
    else {
      unint64_t v5 = [v3 maxTextureWidth2D];
    }
    *a2 = v5;
    if (v5 >= (int)CI_MAX_TEXTURE_SIZE()) {
      unint64_t v6 = (int)CI_MAX_TEXTURE_SIZE();
    }
    else {
      unint64_t v6 = *a2;
    }
    *a2 = v6;
    unint64_t v7 = [v3 maxComputeTextures];
    if (v7 >= [v3 maxComputeSamplers]) {
      uint64_t v8 = [v3 maxComputeSamplers];
    }
    else {
      uint64_t v8 = [v3 maxComputeTextures];
    }
    a2[1] = v8;
    a2[2] = [v3 maxBufferLength];
    a2[3] = [v3 iosurfaceReadOnlyTextureAlignmentBytes];
    a2[4] = [v3 iosurfaceTextureAlignmentBytes];
    a2[5] = [v3 sharedMemorySize];
    uint64_t result = (void *)[v3 dedicatedMemorySize];
    a2[6] = (unint64_t)result;
  }
  return result;
}

unint64_t ___ZNK2CI14TextureManager25get_intermediate_for_nodeERKNS_6roiKeyE_block_invoke(unint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  unint64_t v4 = *(void **)(v1 + 152);
  uint64_t v2 = (void *)(v1 + 152);
  os_signpost_id_t v3 = v4;
  if (v4)
  {
    unint64_t v5 = (CI::Node *)result;
    uint64_t v6 = *(void *)(result + 48);
    uint64_t result = *(void *)v6;
    unint64_t v7 = v2;
    do
    {
      unint64_t v8 = v3[4];
      BOOL v9 = v8 >= result;
      if (v8 >= result) {
        uint64_t v10 = v3;
      }
      else {
        uint64_t v10 = v3 + 1;
      }
      if (v9) {
        unint64_t v7 = v3;
      }
      os_signpost_id_t v3 = (void *)*v10;
    }
    while (*v10);
    if (v7 != v2 && result >= v7[4])
    {
      uint64_t v13 = v7[6];
      CGFloat v11 = v7 + 6;
      uint64_t v12 = v13;
      if (v13)
      {
        int v14 = *(_DWORD *)(v6 + 8);
        os_signpost_id_t v15 = v11;
        do
        {
          int v16 = *(_DWORD *)(v12 + 32);
          BOOL v17 = v16 < v14;
          if (v16 >= v14) {
            uint64_t v18 = (uint64_t *)v12;
          }
          else {
            uint64_t v18 = (uint64_t *)(v12 + 8);
          }
          if (!v17) {
            os_signpost_id_t v15 = (void *)v12;
          }
          uint64_t v12 = *v18;
        }
        while (*v18);
        if (v15 != v11 && v14 >= *((_DWORD *)v15 + 8))
        {
          v19.origin.CGFloat x = CI::Node::roi((CI::Node *)result, v14);
          uint64_t result = CGRectIsInfinite(v19);
          *(void *)(*(void *)(*((void *)v5 + 4) + 8) + 24) = v15[5];
        }
      }
    }
  }
  return result;
}

CI::ImageWithChild *CI::SwizzleImage::SwizzleImage(CI::ImageWithChild *a1, uint64_t *a2, int a3)
{
  uint64_t v6 = CI::ImageWithChild::ImageWithChild(a1, (CI::Image *)a2);
  *((void *)v6 + 14) = &unk_1EE45ABE8;
  atomic_fetch_add(&dword_1EB466E78[21], 1u);
  *(void *)uint64_t v6 = &unk_1EE458C60;
  *((void *)v6 + 14) = &unk_1EE458DC0;
  *((_DWORD *)v6 + 30) = a3;
  *((void *)a1 + 10) = CI::SwizzleImage::makeDigest(a2[10], a3);
  *((void *)a1 + 11) = CI::SwizzleImage::makeDigest(a2[11], a3);
  return a1;
}

void sub_1936B1A18(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::SwizzleImage::makeDigest(uint64_t a1, int a2)
{
  XXH64_reset(v5, 0);
  LODWORD(__src) = 23;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  uint64_t __src = a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  LODWORD(__src) = a2;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v5);
}

void __CIMetalRenderToTextures_block_invoke_83(uint64_t a1, void *a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (CI_KDEBUG()) {
    kdebug_trace();
  }
  if (CI_VERBOSE_SIGNPOSTS())
  {
    unint64_t v4 = ci_signpost_log_render();
    os_signpost_id_t v5 = *(int *)(a1 + 72) | (*(void *)(a1 + 64) << 32);
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v6 = v4;
      if (os_signpost_enabled(v4))
      {
        double v7 = *(double *)(a1 + 56);
        unsigned int v8 = *(double *)(a1 + 48);
        *(_DWORD *)CGRect buf = 134218496;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v8;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v7;
        _os_signpost_emit_with_name_impl(&dword_193671000, v6, OS_SIGNPOST_INTERVAL_END, v5, "gpu_compute", "cb:%p [%u, %u]", buf, 0x18u);
      }
    }
  }
  uint64_t v37 = a1;
  id object = a2;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  BOOL v9 = *(void **)(a1 + 32);
  uint64_t v10 = [v9 countByEnumeratingWithState:&v40 objects:v63 count:16];
  if (v10)
  {
    unint64_t v11 = v10;
    uint64_t v12 = 0;
    uint64_t v13 = *(void *)v41;
    CFStringRef v14 = (const __CFString *)*MEMORY[0x1E4F2F128];
    uint64_t v15 = *MEMORY[0x1E4F28568];
    for (uint64_t i = *(void *)v41; ; uint64_t i = *(void *)v41)
    {
      if (i != v13) {
        objc_enumerationMutation(v9);
      }
      BOOL v17 = *(void **)(*((void *)&v40 + 1) + 8 * v12);
      if ([v17 iosurface])
      {
        if (SurfaceIsVolatile((__IOSurface *)[v17 iosurface])) {
          break;
        }
      }
LABEL_25:
      if (++v12 >= v11)
      {
        uint64_t v32 = [v9 countByEnumeratingWithState:&v40 objects:v63 count:16];
        if (!v32) {
          goto LABEL_31;
        }
        unint64_t v11 = v32;
        uint64_t v12 = 0;
      }
    }
    long long v61 = 0u;
    long long v62 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    memset(buf, 0, sizeof(buf));
    uint64_t v18 = (__IOSurface *)[v17 iosurface];
    CFStringRef v19 = (const __CFString *)IOSurfaceCopyValue(v18, v14);
    if (v19)
    {
      CFStringRef v20 = v19;
      CFStringGetCString(v19, (char *)buf, 256, 0x8000100u);
      CFAutorelease(v20);
    }
    OSType PixelFormat = IOSurfaceGetPixelFormat(v18);
    unsigned int v39 = bswap32(PixelFormat);
    uint64_t v22 = ci_logger_render();
    BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    if (PixelFormat < 0x29)
    {
      if (v23)
      {
        uint64_t v36 = v39;
        uint64_t v33 = [v17 width];
        uint64_t v34 = [v17 height];
        *(_DWORD *)BOOL v46 = 134218754;
        *(void *)unint64_t v47 = v36;
        *(_WORD *)&v47[8] = 2048;
        *(void *)&v47[10] = v33;
        *(_WORD *)&v47[18] = 2048;
        *(void *)&v47[20] = v34;
        *(_WORD *)&v47[28] = 2082;
        *(void *)&v47[30] = buf;
        int v26 = v22;
        int v27 = "Internal error: Input texture: (%ld: %lu x %lu) has volatile backing (%{public}s) surface";
        uint32_t v28 = 42;
        goto LABEL_30;
      }
    }
    else if (v23)
    {
      uint64_t v24 = [v17 width];
      uint64_t v25 = [v17 height];
      *(_DWORD *)BOOL v46 = 68158722;
      *(_DWORD *)unint64_t v47 = 4;
      *(_WORD *)&v47[4] = 2080;
      *(void *)&v47[6] = &v39;
      *(_WORD *)&v47[14] = 2048;
      *(void *)&v47[16] = v24;
      *(_WORD *)&v47[24] = 2048;
      *(void *)&v47[26] = v25;
      *(_WORD *)&v47[34] = 2082;
      *(void *)&v47[36] = buf;
      int v26 = v22;
      int v27 = "Internal error: Input texture: (%.4s: %lu x %lu) has volatile backing (%{public}s) surface";
      uint32_t v28 = 48;
LABEL_30:
      _os_log_error_impl(&dword_193671000, v26, OS_LOG_TYPE_ERROR, v27, v46, v28);
    }
    if (isImageConversionServiceProcess_onceToken != -1) {
      dispatch_once(&isImageConversionServiceProcess_onceToken, &__block_literal_global_48);
    }
    if (isImageConversionServiceProcess_isICS)
    {
      int v35 = ci_logger_render();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        __CIMetalRenderToTextures_block_invoke_83_cold_1();
      }
      abort();
    }
    unint64_t v29 = (void *)MEMORY[0x199702DB0]();
    uint64_t v44 = v15;
    int v45 = @"Input texture has volatile backing surface";
    uint64_t v30 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v45 forKeys:&v44 count:1];
    int v31 = (void *)[MEMORY[0x1E4F28C58] errorWithDomain:@"com.apple.coreimage" code:1 userInfo:v30];
    if (v31) {
      objc_setAssociatedObject(object, setInternalError, v31, (void *)0x301);
    }
    goto LABEL_25;
  }
LABEL_31:
}

BOOL SurfaceIsVolatile(__IOSurface *a1)
{
  uint32_t oldState = 0;
  if (IOSurfaceSetPurgeable(a1, 3u, &oldState)) {
    BOOL v1 = 1;
  }
  else {
    BOOL v1 = oldState == 0;
  }
  return !v1;
}

void CI::ColorKernelImage::~ColorKernelImage(CI::ColorKernelImage *this)
{
  CI::ColorKernelImage::~ColorKernelImage(this);

  JUMPOUT(0x1997023B0);
}

{
  CI::Object *v2;
  CI::SerialObjectPtrArray *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EE45BAC0;
  *((void *)this + 13) = &unk_1EE45BC18;
  uint64_t v2 = (CI::Object *)*((void *)this + 14);
  if (v2 && *((unsigned char *)v2 + 12)) {
    CI::Object::unref(v2);
  }
  os_signpost_id_t v3 = (CI::SerialObjectPtrArray *)*((void *)this + 15);
  if (v3)
  {
    CI::SerialObjectPtrArray::~SerialObjectPtrArray(v3);
    MEMORY[0x1997023B0]();
  }
  _Block_release(*((const void **)this + 20));
  *((void *)this + 20) = 0;
  *((void *)this + 13) = &unk_1EE45AA08;
  atomic_fetch_add(&dword_1EB466E78[9], 0xFFFFFFFF);

  CI::Image::~Image(this);
}

uint64_t GetPixelBufferYCCMatrix(__CVBuffer *a1)
{
  uint64_t result = (uint64_t)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F24C18], 0);
  if (result)
  {
    uint64_t v2 = (const void *)result;
    if (CFEqual((CFTypeRef)result, (CFTypeRef)*MEMORY[0x1E4F24C48]))
    {
      return 709;
    }
    else if (CFEqual(v2, (CFTypeRef)*MEMORY[0x1E4F24C40]))
    {
      return 601;
    }
    else if (CFEqual(v2, (CFTypeRef)*MEMORY[0x1E4F24C60]))
    {
      return 240;
    }
    else if (CFEqual(v2, (CFTypeRef)*MEMORY[0x1E4F24C30]))
    {
      return 2020;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CGColorSpaceRef CVImageBufferCopyColorSpace(__CVBuffer *a1)
{
  PixelFormatint Type = CVPixelBufferGetPixelFormatType(a1);
  int v3 = 1;
  if (PixelFormatType > 1279340853)
  {
    if (PixelFormatType > 1717856626)
    {
      if (PixelFormatType == 1717856627 || PixelFormatType == 1751410032) {
        goto LABEL_17;
      }
      int v4 = 1751411059;
    }
    else
    {
      if (PixelFormatType == 1279340854 || PixelFormatType == 1279342648) {
        goto LABEL_17;
      }
      int v4 = 1717855600;
    }
  }
  else
  {
    if ((PixelFormatType - 1278226488) <= 0x30
      && ((1 << (PixelFormatType - 56)) & 0x1400000000001) != 0
      || (PixelFormatType - 1279340600) <= 0x30
      && ((1 << (PixelFormatType - 56)) & 0x1400000000001) != 0)
    {
      goto LABEL_17;
    }
    int v4 = 1278226742;
  }
  if (PixelFormatType != v4) {
    int v3 = 0;
  }
LABEL_17:
  if (PixelFormatType > 1751410031)
  {
    if (PixelFormatType != 1751411059)
    {
      int v5 = 1751410032;
LABEL_22:
      if (PixelFormatType == v5) {
        goto LABEL_23;
      }
      if (dyld_program_sdk_at_least())
      {
        Attachment = (CGColorSpace *)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F24A00], 0);
        if (Attachment)
        {
          CGColorSpaceRef ICCBased = Attachment;
          CGColorSpaceRetain(Attachment);
          return ICCBased;
        }
        CFDataRef v10 = (const __CFData *)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F24B70], 0);
        if (v10)
        {
          CFDataRef v11 = v10;
          size_t Length = CFDataGetLength(v10);
          uint64_t v13 = CGDataProviderCreateWithData(0, v11, Length, 0);
          *(_DWORD *)IOSurfaceRef buffer = 0;
          v25.location = 16;
          v25.length = 4;
          CFDataGetBytes(v11, v25, buffer);
          v14.i32[0] = *(_DWORD *)buffer;
          size_t v15 = vmovn_s16((int16x8_t)vmovl_u8(v14)).u32[0] == 1497453127 ? 1 : 3;
          CGColorSpaceRef ICCBased = CGColorSpaceCreateICCBased(v15, 0, v13, 0);
          CFRelease(v13);
          if (ICCBased) {
            return ICCBased;
          }
        }
      }
      if (v3)
      {
        CFTypeRef v16 = CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F24BC8], 0);
        if (v16)
        {
          if (CFEqual(v16, (CFTypeRef)*MEMORY[0x1E4F24BE8]))
          {
            CGColorSpaceRef ICCBased = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC78]);
            if (ICCBased) {
              return ICCBased;
            }
          }
        }
        BOOL v17 = (CFStringRef *)MEMORY[0x1E4F1DC00];
      }
      else
      {
        CFDictionaryRef Attachments = CVBufferGetAttachments(a1, kCVAttachmentMode_ShouldPropagate);
        if (Attachments)
        {
          CGColorSpaceRef ICCBased = CVImageBufferCreateColorSpaceFromAttachments(Attachments);
          if (ICCBased) {
            return ICCBased;
          }
        }
        CFNumberRef v19 = (const __CFNumber *)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F24B28], 0);
        CFTypeRef v20 = CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F24C18], 0);
        CFTypeRef v21 = CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F24A90], 0);
        CFTypeRef v22 = CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E4F24BC8], 0);
        CGColorSpaceRef ICCBased = CreateColorSpaceFromInfo(v21, v22, v20, v19);
        if (ICCBased) {
          return ICCBased;
        }
        BOOL v17 = (CFStringRef *)MEMORY[0x1E4F1DC98];
      }
      return CGColorSpaceCreateWithName(*v17);
    }
  }
  else if (PixelFormatType != 1717855600)
  {
    int v5 = 1717856627;
    goto LABEL_22;
  }
LABEL_23:
  CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F1DBD0];

  return CGColorSpaceCreateWithName(v6);
}

void sub_1936B3DBC(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C4084945667);
  _Unwind_Resume(a1);
}

BOOL CI::format_has_unpremul_alpha(int a1)
{
  return a1 == 535 || (a1 & 0xFFFFFFFE) == 784;
}

uint64_t CI::format_has_alpha(int a1)
{
  uint64_t result = 1;
  if (a1 > 2048)
  {
    if (a1 <= 2568)
    {
      if ((a1 - 2305) > 8 || ((1 << (a1 - 1)) & 0x18B) == 0)
      {
        unsigned int v3 = a1 - 2049;
        if (v3 > 7 || ((1 << v3) & 0x8B) == 0) {
          return 0;
        }
      }
    }
    else if (a1 != 2569 && a1 != 2824 && a1 != 3081)
    {
      return 0;
    }
  }
  else if (a1 > 783)
  {
    if (((a1 - 1793) > 8 || ((1 << (a1 - 1)) & 0x18B) == 0) && (a1 - 784) >= 2) {
      return 0;
    }
  }
  else if (((a1 - 257) > 0xA || ((1 << (a1 - 1)) & 0x78B) == 0) && a1 != 535)
  {
    return 0;
  }
  return result;
}

uint64_t getContentDigestFromOptions(NSDictionary *a1)
{
  id v1 = [(NSDictionary *)a1 objectForKey:@"kCIImageContentDigest"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    if ((unint64_t)[v1 length] >= 0x10)
    {
      XXH64_reset(v23, 0);
      uint64_t v2 = [v1 bytes];
      uint64_t v3 = [v1 length];
      if (!v2) {
        return XXH64_digest((uint64_t)v23);
      }
      size_t v4 = v3;
      if (!v3) {
        return XXH64_digest((uint64_t)v23);
      }
      p_src = (char *)v2;
LABEL_15:
      XXH64_update((uint64_t)v23, p_src, v4);
      return XXH64_digest((uint64_t)v23);
    }
    double v7 = ci_logger_api();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      getContentDigestFromOptions(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    return 0;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if ((unint64_t)[v1 length] >= 0x10)
      {
        XXH64_reset(v23, 0);
        uint64_t __src = [v1 UTF8String];
        p_src = (char *)&__src;
        size_t v4 = 8;
        goto LABEL_15;
      }
      size_t v15 = ci_logger_api();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        getContentDigestFromOptions(v15, v16, v17, v18, v19, v20, v21, v22);
      }
    }
    return 0;
  }

  return [v1 unsignedLongLongValue];
}

uint64_t CI::PixelFormatType_is_source_supported(CI *this)
{
  int v1 = equivalent_uncompressed_format((uint64_t)this);
  uint64_t result = 1;
  if (v1 > 1667839023)
  {
    if (v1 > 1936077359)
    {
      if (v1 <= 1953903667)
      {
        if (v1 <= 1937126451)
        {
          if (v1 <= 1936077875)
          {
            if (v1 == 1936077360) {
              return result;
            }
            int v3 = 1936077362;
          }
          else
          {
            if (v1 == 1936077876 || v1 == 1937125936) {
              return result;
            }
            int v3 = 1937125938;
          }
        }
        else if (v1 > 1952855091)
        {
          if (v1 == 1952855092 || v1 == 1953903152) {
            return result;
          }
          int v3 = 1953903154;
        }
        else
        {
          if (v1 == 1937126452 || v1 == 1952854576) {
            return result;
          }
          int v3 = 1952854578;
        }
      }
      else if (v1 > 2019963439)
      {
        if (v1 > 2033463351)
        {
          if (v1 == 2033463352 || v1 == 2037741158) {
            return result;
          }
          int v3 = 2037741171;
        }
        else
        {
          if (v1 == 2019963440 || v1 == 2019963442) {
            return result;
          }
          int v3 = 2019963956;
        }
      }
      else if (v1 > 2016686639)
      {
        if (v1 == 2016686640 || v1 == 2016686642) {
          return result;
        }
        int v3 = 2016687156;
      }
      else
      {
        if (v1 == 1953903668 || v1 == 1999843442) {
          return result;
        }
        int v3 = 1999908961;
      }
    }
    else if (v1 > 1751527985)
    {
      if (v1 > 1882468913)
      {
        if (v1 > 1885745713)
        {
          if (v1 == 1885745714 || v1 == 1885746228) {
            return result;
          }
          int v3 = 1919379252;
        }
        else
        {
          if (v1 == 1882468914 || v1 == 1882469428) {
            return result;
          }
          int v3 = 1885745712;
        }
      }
      else if (v1 > 1815361649)
      {
        if (v1 == 1815361650 || v1 == 1815491698) {
          return result;
        }
        int v3 = 1882468912;
      }
      else
      {
        if (v1 == 1751527986 || v1 == 1751528500) {
          return result;
        }
        int v3 = 1815162994;
      }
    }
    else if (v1 > 1717856626)
    {
      if (v1 > 1751410031)
      {
        if (v1 == 1751410032 || v1 == 1751411059) {
          return result;
        }
        int v3 = 1751527984;
      }
      else
      {
        if (v1 == 1717856627 || v1 == 1734505012) {
          return result;
        }
        int v3 = 1735549492;
      }
    }
    else
    {
      if ((v1 - 1667844406) <= 0x32 && ((1 << (v1 - 54)) & 0x5000000000005) != 0
        || v1 == 1667839024)
      {
        return result;
      }
      int v3 = 1717855600;
    }
    goto LABEL_117;
  }
  if (v1 > 1093677111)
  {
    if (v1 > 1279340599)
    {
      if (v1 > 1380410944)
      {
        if (v1 > 1667838255)
        {
          if (v1 == 1667838256 || v1 == 1667838822) {
            return result;
          }
          int v3 = 1667838824;
        }
        else
        {
          if (v1 == 1380410945 || v1 == 1380411457) {
            return result;
          }
          int v3 = 1650943796;
        }
      }
      else
      {
        if (v1 <= 1279340853)
        {
          unsigned int v5 = v1 - 1279340600;
          if (v5 > 0x30 || ((1 << v5) & 0x1400000000001) == 0) {
            return 0;
          }
          return result;
        }
        if (v1 == 1279340854 || v1 == 1279342648) {
          return result;
        }
        int v3 = 1380401729;
      }
    }
    else if (v1 > 1111970368)
    {
      if ((v1 - 1278226488) <= 0x30 && ((1 << (v1 - 56)) & 0x1400000000001) != 0
        || (v1 - 1278226736) <= 6 && ((1 << (v1 - 48)) & 0x45) != 0)
      {
        return result;
      }
      int v3 = 1111970369;
    }
    else
    {
      if ((v1 - 1093677112) <= 0x30 && ((1 << (v1 - 56)) & 0x1400000000001) != 0
        || v1 == 1093677366)
      {
        return result;
      }
      int v3 = 1094862674;
    }
    goto LABEL_117;
  }
  if (v1 > 843264303)
  {
    if (v1 > 875704421)
    {
      if (v1 > 875704949)
      {
        if (v1 == 875704950 || v1 == 875836518) {
          return result;
        }
        int v3 = 875836534;
      }
      else
      {
        if (v1 == 875704422 || v1 == 875704438) {
          return result;
        }
        int v3 = 875704934;
      }
    }
    else
    {
      if (v1 <= 845361455)
      {
        unsigned int v4 = v1 - 843264304;
        if (v4 > 6 || ((1 << v4) & 0x45) == 0) {
          return 0;
        }
        return result;
      }
      if (v1 == 845361456 || v1 == 846624102) {
        return result;
      }
      int v3 = 846624121;
    }
LABEL_117:
    if (v1 == v3) {
      return result;
    }
    return 0;
  }
  if (v1 <= 826487087)
  {
    if (((v1 - 826486840) > 0x30 || ((1 << (v1 - 56)) & 0x1400000000001) == 0)
      && v1 != 24
      && v1 != 32)
    {
      return 0;
    }
  }
  else if (((v1 - 826487088) > 6 || ((1 << (v1 - 48)) & 0x45) == 0) {
         && ((v1 - 843264056) > 0x30 || ((1 << (v1 - 56)) & 0x1400000000001) == 0))
  }
  {
    int v3 = 828584240;
    goto LABEL_117;
  }
  return result;
}

void CI::ColorMatchImage::append_and_unref(CI::ColorMatchImage *this, CI::Image *a2, CGColorSpace *a3)
{
}

void sub_1936B47F4(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

uint64_t CI::SurfaceImage::SurfaceImage(uint64_t a1, void *a2, uint64_t a3, int a4, int a5, const void *a6, int a7, int a8, float a9, char a10, char a11)
{
  float valuePtr = a9;
  CI::Image::Image((__n128 *)a1);
  *(void *)(v19 + 104) = &unk_1EE45AB48;
  atomic_fetch_add(&dword_1EB466E78[17], 1u);
  *(void *)uint64_t v19 = &unk_1EE458AD0;
  *(void *)(v19 + 112) = a2;
  *(void *)(v19 + 120) = a3;
  *(_DWORD *)(v19 + 172) = 0;
  *(void *)(v19 + 152) = 0;
  *(void *)(v19 + 160) = 0;
  *(void *)(v19 + 144) = 0;
  *(void *)(v19 + 104) = &unk_1EE458C38;
  CFRetain(a2);
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 168) = a4;
  *(_DWORD *)(a1 + 180) = a7;
  if (a6) {
    CFTypeRef v20 = CFRetain(a6);
  }
  else {
    CFTypeRef v20 = 0;
  }
  *(void *)(a1 + 136) = v20;
  *(_DWORD *)(a1 + 184) = a8;
  *(unsigned char *)(a1 + 188) = a10;
  *(unsigned char *)(a1 + 189) = a11;
  *(_DWORD *)(a1 + 176) = 0;
  float v21 = valuePtr;
  if (valuePtr == 0.0)
  {
    CFNumberRef v22 = (const __CFNumber *)IOSurfaceCopyValue(*(IOSurfaceRef *)(a1 + 112), (CFStringRef)*MEMORY[0x1E4F2F078]);
    if (v22)
    {
      CFNumberRef v23 = v22;
      CFNumberGetValue(v22, kCFNumberFloatType, &valuePtr);
      CFRelease(v23);
      float v21 = valuePtr;
    }
    else if (!CI::format_is_extended(a4) && (CI::format_is_float(a4) & 1) == 0)
    {
      float valuePtr = 1.0;
      float v21 = 1.0;
    }
  }
  *(float *)(a1 + 172) = v21;
  if (CI::format_is_ycc_or_ycca(*(_DWORD *)(a1 + 168)))
  {
    if (a5)
    {
      *(_DWORD *)(a1 + 176) = a5;
      goto LABEL_21;
    }
    int v32 = 0;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    memset(v27, 0, sizeof(v27));
    size_t __src = 116;
    if (!IOSurfaceGetBulkAttachments()
      && __src == 116
      && (unsigned int v24 = BYTE10(v28) - 1, v24 < 9)
      && ((0x161u >> v24) & 1) != 0)
    {
      default_ycc_color_matriCGFloat x = dword_193959D8C[(char)v24];
    }
    else
    {
      if (*(_DWORD *)(a1 + 176)) {
        goto LABEL_21;
      }
      default_ycc_color_matriCGFloat x = CI::format_get_default_ycc_color_matrix(a4);
    }
    *(_DWORD *)(a1 + 176) = default_ycc_color_matrix;
  }
LABEL_21:
  XXH64_reset(v27, 0);
  LODWORD(__src) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
  if (*(void *)(a1 + 120))
  {
    size_t __src = *(void *)(a1 + 120);
    XXH64_update((uint64_t)v27, (char *)&__src, 8uLL);
    size_t __src = IOSurfaceGetWidth((IOSurfaceRef)a2);
    XXH64_update((uint64_t)v27, (char *)&__src, 8uLL);
    size_t __src = IOSurfaceGetHeight((IOSurfaceRef)a2);
    XXH64_update((uint64_t)v27, (char *)&__src, 8uLL);
    LODWORD(__src) = IOSurfaceGetPixelFormat((IOSurfaceRef)a2);
    XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
    LODWORD(__src) = *(_DWORD *)(a1 + 168);
    XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
    LODWORD(__src) = *(_DWORD *)(a1 + 176);
    XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
    LODWORD(__src) = *(_DWORD *)(a1 + 180);
    XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
    LODWORD(__src) = *(_DWORD *)(a1 + 184);
    XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
    LODWORD(__src) = *(unsigned __int8 *)(a1 + 188);
    XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
    LODWORD(__src) = *(_DWORD *)(a1 + 172);
  }
  else
  {
    LODWORD(__src) = *(_DWORD *)(a1 + 100);
  }
  XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
  *(void *)(a1 + 80) = XXH64_digest((uint64_t)v27);
  XXH64_reset(v27, 0);
  LODWORD(__src) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
  size_t __src = IOSurfaceGetWidth((IOSurfaceRef)a2);
  XXH64_update((uint64_t)v27, (char *)&__src, 8uLL);
  size_t __src = IOSurfaceGetHeight((IOSurfaceRef)a2);
  XXH64_update((uint64_t)v27, (char *)&__src, 8uLL);
  LODWORD(__src) = IOSurfaceGetPixelFormat((IOSurfaceRef)a2);
  XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 168);
  XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 176);
  XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 180);
  XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 184);
  XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
  LODWORD(__src) = *(unsigned __int8 *)(a1 + 188);
  XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 172);
  XXH64_update((uint64_t)v27, (char *)&__src, 4uLL);
  *(void *)(a1 + 88) = XXH64_digest((uint64_t)v27);
  *(_WORD *)(a1 + 96) = 257;
  return a1;
}

{
  return CI::SurfaceImage::SurfaceImage(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t CI::SurfaceImage::type(CI::SurfaceImage *this)
{
  return 19;
}

uint64_t CI::format_is_ycc_or_ycca(int a1)
{
  LODWORD(result) = CI::format_is_ycc(a1);
  if (a1 == 535) {
    return 1;
  }
  else {
    return result;
  }
}

uint64_t CI::format_is_ycc(int a1)
{
  HIDWORD(v3) = a1 - 274;
  LODWORD(v3) = a1 - 274;
  unsigned int v2 = v3 >> 8;
  if (v2 < 0xF && ((0x70FFu >> v2) & 1) != 0) {
    return 1;
  }
  char is_ycc_422 = CI::format_is_ycc_422(a1);
  HIDWORD(v5) = a1 - 275;
  LODWORD(v5) = a1 - 275;
  unsigned int v6 = (0x70FFu >> ((unsigned __int16)(a1 - 275) >> 8)) & 1;
  if ((v5 >> 8) >= 0xF) {
    unsigned int v6 = 0;
  }
  if (is_ycc_422) {
    return 1;
  }
  else {
    return v6;
  }
}

void CI::AffineImage::append_and_unref(CI::AffineImage *this, CI::Image *a2, CGAffineTransform *a3)
{
}

void sub_1936B4E38(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C402ADBAFB5);
  _Unwind_Resume(a1);
}

uint64_t CI::format_has_x(int a1)
{
  uint64_t result = 1;
  if (a1 > 1803)
  {
    if (a1 <= 2315)
    {
      if (a1 != 1804 && a1 != 2060) {
        return 0;
      }
    }
    else if (a1 != 2316 && a1 != 2567 && a1 != 3079)
    {
      return 0;
    }
  }
  else if ((a1 - 268) >= 4 && a1 != 775)
  {
    return 0;
  }
  return result;
}

double OptionHeadroom(NSDictionary *a1)
{
  if (![(NSDictionary *)a1 objectForKey:@"kCIImageContentHeadroom"]) {
    return 0.0;
  }
  objc_msgSend(-[NSDictionary objectForKey:](a1, "objectForKey:", @"kCIImageContentHeadroom"), "floatValue");
  if (*(float *)&result < 1.0 && *(float *)&result != 0.0)
  {
    unint64_t v3 = ci_logger_api();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      OptionHeadroom();
    }
    return 0.0;
  }
  return result;
}

double iosurface_limits@<D0>(uint64_t a1@<X8>)
{
  if (iosurface_limits_once != -1) {
    dispatch_once(&iosurface_limits_once, &__block_literal_global_79);
  }
  double result = *(double *)&iosurface_limits_limits;
  *(_OWORD *)a1 = iosurface_limits_limits;
  *(void *)(a1 + 16) = qword_1EB466D08;
  return result;
}

BOOL CI::format_is_extended(int a1)
{
  BOOL result = 1;
  if (((a1 - 2049) > 0x15 || ((1 << (a1 - 1)) & 0x2608FF) == 0)
    && ((a1 - 2305) > 0xB || ((1 << (a1 - 1)) & 0x9FF) == 0))
  {
    return ((a1 - 2567) & 0xFFFFFDFD) == 0;
  }
  return result;
}

void CI::SurfaceImage::set_owner(CI::SurfaceImage *this, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 16);
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v3 = (CFTypeRef)*((void *)this + 16);
    }
    if (v3) {
      CFRelease(v3);
    }
    *((void *)this + 16) = cf;
  }
}

void CI::ColorMatchImage::~ColorMatchImage(CI::ColorMatchImage *this)
{
  CI::ColorMatchImage::~ColorMatchImage(this);

  JUMPOUT(0x1997023B0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EE45A690;
  *((void *)this + 14) = &unk_1EE45A7E8;
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 15));
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 16));
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 14) = &unk_1EE45AFD0;
  atomic_fetch_add(&dword_1EB466E78[2], 0xFFFFFFFF);

  CI::ImageWithChild::~ImageWithChild(this);
}

void CI::AffineImage::~AffineImage(CI::AffineImage *this)
{
  *((void *)this + 14) = &unk_1EE45ACB0;
  atomic_fetch_add(dword_1EB466E78, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);

  JUMPOUT(0x1997023B0);
}

{
  *((void *)this + 14) = &unk_1EE45ACB0;
  atomic_fetch_add(dword_1EB466E78, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);
}

void CI::Image::~Image(CI::Image *this)
{
  unsigned int v2 = (void (**)(CI::Image *, void))&unk_1EE45DAA8;
  *(void *)this = &unk_1EE45DAA8;
  CFTypeRef v3 = (const void *)*((void *)this + 6);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 6) = 0;
    unsigned int v2 = *(void (***)(CI::Image *, void))this;
  }
  v2[37](this, 0);
  (*(void (**)(CI::Image *, void))(*(void *)this + 312))(this, 0);
}

void CI::Image::set_base_obj(CI::Image *this, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 8);
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v3 = (CFTypeRef)*((void *)this + 8);
    }
    if (v3) {
      CFRelease(v3);
    }
    *((void *)this + 8) = cf;
  }
}

void CI::Image::set_user_info(CI::Image *this, CFTypeRef cf)
{
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 7);
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v3 = (CFTypeRef)*((void *)this + 7);
    }
    if (v3) {
      CFRelease(v3);
    }
    *((void *)this + 7) = cf;
  }
}

void CI::ImageWithChild::~ImageWithChild(CI::ImageWithChild *this)
{
  *(void *)this = &unk_1EE459AB8;
  unsigned int v2 = (CI::Object *)*((void *)this + 13);
  if (v2) {
    CI::Object::unref(v2);
  }
  *((void *)this + 13) = 0;

  CI::Image::~Image(this);
}

{
  uint64_t vars8;

  CI::ImageWithChild::~ImageWithChild(this);

  JUMPOUT(0x1997023B0);
}

void sub_1936B5460(_Unwind_Exception *a1)
{
  CI::Image::~Image(v1);
  _Unwind_Resume(a1);
}

void CI::OptimizedGraph::OptimizedGraph(CI::OptimizedGraph *this)
{
}

void CI::NodeWithChildren::NodeWithChildren(CI::NodeWithChildren *this, CI::Node *a2)
{
}

CI::ColorMatrixImage *CI::ColorMatrixImage::ColorMatrixImage(CI::ColorMatrixImage *this, CI::Image *a2, double (*a3)[4])
{
  unsigned int v6 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v6 + 14) = &unk_1EE45B138;
  atomic_fetch_add(&dword_1EB466E78[3], 1u);
  *(void *)unsigned int v6 = &unk_1EE45BC40;
  *((void *)v6 + 14) = &unk_1EE45BD98;
  long long v7 = *(_OWORD *)&(*a3)[0];
  *(_OWORD *)((char *)v6 + 136) = *(_OWORD *)&(*a3)[2];
  *(_OWORD *)((char *)v6 + 12CI::NodeWithChildren::NodeWithChildren(this, 0) = v7;
  long long v8 = *(_OWORD *)&(*a3)[4];
  long long v9 = *(_OWORD *)&(*a3)[6];
  long long v10 = *(_OWORD *)&(*a3)[8];
  *(_OWORD *)((char *)v6 + 20CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_OWORD *)&(*a3)[10];
  *(_OWORD *)((char *)v6 + 184) = v10;
  *(_OWORD *)((char *)v6 + 168) = v9;
  *(_OWORD *)((char *)v6 + 152) = v8;
  long long v11 = *(_OWORD *)&(*a3)[12];
  long long v12 = *(_OWORD *)&(*a3)[14];
  long long v13 = *(_OWORD *)&(*a3)[16];
  *(_OWORD *)((char *)v6 + 264) = *(_OWORD *)&(*a3)[18];
  *(_OWORD *)((char *)v6 + 248) = v13;
  *(_OWORD *)((char *)v6 + 232) = v12;
  *(_OWORD *)((char *)v6 + 216) = v11;
  *((void *)this + 1CI::NodeWithChildren::NodeWithChildren(this, 0) = CI::ColorMatrixImage::makeDigest(*((void *)a2 + 10), (char *)a3);
  *((void *)this + 11) = CI::ColorMatrixImage::makeDigest(*((void *)a2 + 11), (char *)a3);
  *((unsigned char *)this + 97) = 0;
  return this;
}

unint64_t CI::ColorMatrixImage::makeDigest(uint64_t a1, char *a2)
{
  XXH64_reset(v5, 0);
  LODWORD(__src) = 5;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  uint64_t __src = a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  if (a2) {
    XXH64_update((uint64_t)v5, a2, 0xA0uLL);
  }
  return XXH64_digest((uint64_t)v5);
}

void ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke_11(uint64_t a1)
{
  dispatch_group_wait(*(dispatch_group_t *)(a1 + 32), 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  unsigned int v2 = *(CI::Object **)(a1 + 40);
  if (v2)
  {
    CI::Object::unref(v2);
  }
}

CI::ClampToAlphaNode *CI::ClampToAlphaNode::append_to_tree(CI::ClampToAlphaNode *this, CI::Node *a2)
{
  unsigned int v2 = this;
  if (a2 && (*(unsigned int (**)(CI::ClampToAlphaNode *))(*(void *)this + 232))(this))
  {
    CFTypeRef v3 = 0;
    unsigned int v4 = v2;
    while (1)
    {
      unint64_t v5 = v4;
      if ((*(uint64_t (**)(CI::Object *))(*(void *)v4 + 176))(v4)) {
        break;
      }
      unsigned int v4 = (CI::Object *)(*(uint64_t (**)(CI::Object *, void))(*(void *)v4 + 48))(v4, 0);
      CFTypeRef v3 = v5;
      if (((*(uint64_t (**)(CI::Object *))(*(void *)v4 + 232))(v4) & 1) == 0) {
        goto LABEL_8;
      }
    }
    unint64_t v5 = v3;
  }
  else
  {
    unint64_t v5 = 0;
    unsigned int v4 = v2;
  }
LABEL_8:
  if ((*(unsigned int (**)(CI::Object *))(*(void *)v4 + 256))(v4)) {
    operator new();
  }
  CI::Object::ref((uint64_t)v4);
  if (!v5) {
    return v4;
  }
  (*(void (**)(CI::Object *, CI::Object *, void))(*(void *)v5 + 200))(v5, v4, 0);
  CI::Object::unref(v4);
  if (v2) {
    CI::Object::ref((uint64_t)v2);
  }
  return v2;
}

uint64_t CI::PremultiplyNode::may_be_extended_range(CI::PremultiplyNode *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 256))();
}

uint64_t CI::ColorKernelNode::may_be_extended_range(CI::ColorKernelNode *this)
{
  return 1;
}

uint64_t CI::SwizzleNode::may_be_extended_range(CI::SwizzleNode *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 256))();
}

uint64_t CI::SRGBNode::may_be_extended_range(CI::SRGBNode *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 256))();
}

void sub_1936B719C(_Unwind_Exception *a1)
{
  CI::create_cgimage(CIContext *,CIImage *,CGRect,CGColorSpace *,int,BOOL,CI::Trilean,void({block_pointer})(CGRect,NSError *))::SignpostTimer::~SignpostTimer((TimerBase *)(v1 - 224));
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Unwind_Resume(a1);
}

uint64_t CI::format_modernize(uint64_t a1, CI *this, const char *a3)
{
  uint64_t v3 = a1;
  int v4 = a1 - 1;
  if (a1 - 1) <= 0x3E && ((0x7C77FFFFF807FFFFuLL >> v4))
  {
    uint64_t v3 = dword_193959694[v4];
    CI::log_old_format(this, off_1E57743D8[v4], a3);
  }
  return v3;
}

void sub_1936B753C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C402ADBAFB5);
  _Unwind_Resume(a1);
}

uint64_t CI::AffineImage::alpha_one(CI::AffineImage *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 13) + 128))(*((void *)this + 13));
  if (!result) {
    return result;
  }
  v9.origin.double x = (*(double (**)(CI::AffineImage *))(*(void *)this + 88))(this);
  double x = v9.origin.x;
  double y = v9.origin.y;
  double width = v9.size.width;
  double height = v9.size.height;
  if (CGRectIsInfinite(v9))
  {
    *(int64x2_t *)&v8.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v8.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    double height = 1.79769313e308;
    double width = 1.79769313e308;
    goto LABEL_11;
  }
  v10.origin.double x = x;
  v10.origin.double y = y;
  v10.size.double width = width;
  v10.size.double height = height;
  if (CGRectIsNull(v10))
  {
    *(int64x2_t *)&v8.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_OWORD *)&v8.var2 = 0uLL;
  }
  else
  {
    v8.var0 = x;
    v8.var1 = y;
    v8.var2 = width;
    v8.var3 = height;
    if (x == -8.98846567e307 && y == -8.98846567e307)
    {
LABEL_11:
      if (width == 1.79769313e308 && height == 1.79769313e308) {
        return 1;
      }
    }
  }
  return (fabs(*((double *)this + 16)) < 0.0001 && fabs(*((double *)this + 17)) < 0.0001
       || fabs(*((double *)this + 15)) < 0.0001 && fabs(*((double *)this + 18)) < 0.0001)
      && Rectangle::isNearIntegral(&v8, 0.00001);
}

uint64_t CI::ColorKernelImage::alpha_one(CI::ColorKernelImage *this)
{
  if (*((unsigned char *)this + 168)) {
    return 1;
  }
  if (!*(unsigned char *)(*((void *)this + 14) + 162)) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(CI::ColorKernelImage *, void))(*(void *)this + 48))(this, 0);
  if (result)
  {
    unsigned int v2 = *(uint64_t (**)(void))(*(void *)result + 128);
    return v2();
  }
  return result;
}

uint64_t CI::MetalContext::surface_rowbytes_alignment_for_output(uint64_t a1)
{
  return *(void *)(a1 + 432);
}

CFTypeRef CI::RenderDestination::setColorspace(CI::RenderDestination *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  CFTypeRef result = (CFTypeRef)*((void *)this + 3);
  if (result) {
    CFTypeRef result = CFAutorelease(result);
  }
  *((void *)this + 3) = cf;
  return result;
}

uint64_t CI_IOSURFACE_WRAPPING(unsigned int a1)
{
  {
    CI_IOSURFACE_WRAPPING::v = get_int("CI_IOSURFACE_WRAPPING", 3);
  }
  return CI_IOSURFACE_WRAPPING::v & a1;
}

void sub_1936B7848(_Unwind_Exception *a1)
{
}

uint64_t CI::format_CGBitmapInfo(int a1, int a2)
{
  if (a2) {
    uint64_t v2 = 1;
  }
  else {
    uint64_t v2 = 3;
  }
  if (a2) {
    uint64_t v3 = 2;
  }
  else {
    uint64_t v3 = 4;
  }
  if (a1 <= 1794)
  {
    if (a1 > 770)
    {
      switch(a1)
      {
        case 771:
          return 4096;
        case 775:
          return 204806;
        case 784:
          int v6 = 204800;
          return v3 | v6;
        default:
          return 0xFFFFFFFFLL;
      }
    }
    else
    {
      int v5 = a1 - 259;
      uint64_t result = 0;
      switch(v5)
      {
        case 0:
        case 4:
          return result;
        case 1:
        case 5:
          uint64_t result = v2;
          break;
        case 6:
          uint64_t result = v3;
          break;
        case 7:
          uint64_t result = v3 | 0x2000;
          break;
        case 8:
          uint64_t result = v2 | 0x2000;
          break;
        case 9:
          uint64_t result = 5;
          break;
        case 10:
          uint64_t result = 6;
          break;
        case 11:
          uint64_t result = 8198;
          break;
        case 12:
          uint64_t result = 8197;
          break;
        default:
          return 0xFFFFFFFFLL;
      }
    }
  }
  else if (a1 > 2306)
  {
    switch(a1)
    {
      case 2307:
      case 2311:
        uint64_t result = 8448;
        break;
      case 2308:
      case 2312:
        int v7 = 8448;
LABEL_24:
        uint64_t result = v2 | v7;
        break;
      case 2309:
      case 2310:
      case 2314:
      case 2315:
        return 0xFFFFFFFFLL;
      case 2313:
        int v6 = 8448;
        return v3 | v6;
      case 2316:
        uint64_t result = 8453;
        break;
      default:
        if (a1 == 3331) {
          return 4096;
        }
        return 0xFFFFFFFFLL;
    }
  }
  else
  {
    switch(a1)
    {
      case 1795:
      case 1799:
        return 4096;
      case 1796:
      case 1800:
        uint64_t result = v2 | 0x1000;
        break;
      case 1797:
      case 1798:
      case 1802:
      case 1803:
        return 0xFFFFFFFFLL;
      case 1801:
        uint64_t result = v3 | 0x1000;
        break;
      case 1804:
        uint64_t result = 4101;
        break;
      default:
        switch(a1)
        {
          case 2051:
          case 2055:
            uint64_t result = 4352;
            break;
          case 2052:
          case 2056:
            int v7 = 4352;
            goto LABEL_24;
          case 2060:
            uint64_t result = 4357;
            break;
          default:
            return 0xFFFFFFFFLL;
        }
        break;
    }
  }
  return result;
}

void CI::create_cgimage_immediate(CIContext *,CIImage *,CGRect,CGColorSpace *,int,CIRenderDestinationAlphaMode,NSError **)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  uint64_t v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = *((void *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    int v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)int v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "new_bitmap", "", v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1936B7AF0(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::MetalContext::supportsDeferredCGImage(CI::MetalContext *this)
{
  return 1;
}

void sub_1936B7EA8(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C4095EC1125);
  _Unwind_Resume(a1);
}

uint64_t CI::RenderToBitmap::render(CI::RenderToBitmap *this, CI::Image *a2, CI::Context *a3)
{
  v28.origin.double x = (*(double (**)(CI::Image *))(*(void *)a2 + 88))(a2);
  CGRect v29 = CGRectInset(v28, 0.00100000005, 0.00100000005);
  CGRect v30 = CGRectIntegral(v29);
  double x = v30.origin.x;
  double y = v30.origin.y;
  double width = v30.size.width;
  double height = v30.size.height;
  CGRect v10 = (CI::Image *)(*(uint64_t (**)(CI::Image *))(*(void *)a2 + 240))(a2);
  unint64_t v11 = (unint64_t)x;
  unint64_t v12 = (unint64_t)y;
  uint64_t v13 = *((void *)this + 6);
  uint64_t v14 = *(unsigned int *)(v13 + 104);
  uint64_t v15 = *(void *)(v13 + 96);
  int v16 = CI::format_bytes_per_pixel(*(_DWORD *)(v13 + 104));
  uint64_t v17 = (void *)*((void *)this + 6);
  uint64_t v18 = v17[9];
  if (v17[10] - (unint64_t)x >= (unint64_t)width) {
    unint64_t v19 = (unint64_t)width;
  }
  else {
    unint64_t v19 = v17[10] - v11;
  }
  unint64_t v20 = v17[11] - v12;
  if (v20 >= (unint64_t)height) {
    unint64_t v21 = (unint64_t)height;
  }
  else {
    unint64_t v21 = v20;
  }
  CI::Bitmap::Bitmap(v25, v18 + v15 * v12 + v16 * v11, v19, v21, v15, v14, v10);
  v31.size.double width = (double)v26;
  v31.size.double height = (double)v27;
  v31.origin.double x = x;
  v31.origin.double y = y;
  uint64_t v23 = CI::image_render_to_bitmap(a3, a2, v10, v31, (CGColorSpace *)v25, this, v22);
  CI::Bitmap::~Bitmap((CI::Bitmap *)v25);
  return v23;
}

uint64_t CI::ClampToAlphaImage::colorspace(CI::ClampToAlphaImage *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 240))();
}

CGColorSpace *CI::ColorMatchImage::colorspace(CGColorSpace **this, CGColorSpace *a2)
{
  if (*((unsigned char *)this + 138))
  {
    SDRCopdouble y = CI::ColorSpaceCreateSDRCopy(this[15], a2);
    os_signpost_id_t v3 = SDRCopy;
    if (SDRCopy) {
      CFAutorelease(SDRCopy);
    }
  }
  else if (*((unsigned char *)this + 137))
  {
    if (*((unsigned char *)this + 136)) {
      return 0;
    }
    else {
      return this[15];
    }
  }
  else
  {
    return this[16];
  }
  return v3;
}

void CI::Bitmap::~Bitmap(CI::Bitmap *this)
{
  CI::Bitmap::~Bitmap(this);

  JUMPOUT(0x1997023B0);
}

{
  CGColorSpace *v2;
  const void *v3;
  const void *v4;

  *(void *)this = &unk_1EE45DBF8;
  *((void *)this + 2) = &unk_1EE45DC30;
  uint64_t v2 = (CGColorSpace *)*((void *)this + 4);
  if (v2)
  {
    CGColorSpaceRelease(v2);
    *((void *)this + 4) = 0;
  }
  *((void *)this + 9) = 0;
  os_signpost_id_t v3 = (const void *)*((void *)this + 5);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 5) = 0;
  }
  if (*((void *)this + 6))
  {
    CGDataProviderReleaseBytePtr();
    CGDataProviderRelease(*((CGDataProviderRef *)this + 6));
    *((void *)this + 6) = 0;
  }
  int v4 = (const void *)*((void *)this + 8);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 8) = 0;
  }
  *((_OWORD *)this + 5) = xmmword_1939594A0;
  *((void *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 14) = 0;
  *((_WORD *)this + 68) = 0;
  *((void *)this + 2) = &unk_1EE45B098;
  atomic_fetch_add(&dword_1EB466E78[53], 0xFFFFFFFF);
}

uint64_t CI::Bitmap::Bitmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5, CGColorSpace *a6, uint64_t a7)
{
  *(void *)a1 = &unk_1EE45DF30;
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)(a1 + 16) = &unk_1EE45B098;
  atomic_fetch_add(&dword_1EB466E78[53], 1u);
  *(void *)a1 = &unk_1EE45DBF8;
  *(void *)(a1 + 16) = &unk_1EE45DC30;
  *(void *)(a1 + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 8CI::NodeWithChildren::NodeWithChildren(this, 0) = a2;
  *(void *)(a1 + 88) = a3;
  *(_DWORD *)(a1 + 104) = a4;
  *(unsigned char *)(a1 + 24) = a5;
  *(void *)(a1 + 96) = a7;
  *(void *)(a1 + 112) = (int)CI::format_component_count(a4);
  *(void *)(a1 + 12CI::NodeWithChildren::NodeWithChildren(this, 0) = (int)CI::format_bytes_per_pixel(*(_DWORD *)(a1 + 104));
  *(void *)(a1 + 128) = (int)CI::format_bits_per_component(*(_DWORD *)(a1 + 104));
  *(unsigned char *)(a1 + 137) = CI::format_is_half_float(*(_DWORD *)(a1 + 104));
  *(unsigned char *)(a1 + 136) = CI::format_is_float(*(_DWORD *)(a1 + 104));
  *(void *)(a1 + 32) = CGColorSpaceRetain(a6);
  CFDataRef CFData = CI::createCFData(*(void *)(a1 + 88) * *(void *)(a1 + 96));
  *(void *)(a1 + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = CFData;
  *(unsigned char *)(a1 + 56) = 1;
  *(void *)(a1 + 72) = CFDataGetBytePtr(CFData);
  *(void *)(a1 + 48) = 0;
  return a1;
}

uint64_t CI::Bitmap::Bitmap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, CGColorSpace *a7)
{
  *(void *)a1 = &unk_1EE45DF30;
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)(a1 + 16) = &unk_1EE45B098;
  atomic_fetch_add(&dword_1EB466E78[53], 1u);
  *(void *)a1 = &unk_1EE45DBF8;
  *(void *)(a1 + 16) = &unk_1EE45DC30;
  *(void *)(a1 + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 8CI::NodeWithChildren::NodeWithChildren(this, 0) = a3;
  *(void *)(a1 + 88) = a4;
  *(void *)(a1 + 96) = a5;
  *(_DWORD *)(a1 + 104) = a6;
  *(void *)(a1 + 112) = (int)CI::format_component_count(a6);
  *(void *)(a1 + 12CI::NodeWithChildren::NodeWithChildren(this, 0) = (int)CI::format_bytes_per_pixel(*(_DWORD *)(a1 + 104));
  *(void *)(a1 + 128) = (int)CI::format_bits_per_component(*(_DWORD *)(a1 + 104));
  *(unsigned char *)(a1 + 137) = CI::format_is_half_float(*(_DWORD *)(a1 + 104));
  *(unsigned char *)(a1 + 136) = CI::format_is_float(*(_DWORD *)(a1 + 104));
  *(unsigned char *)(a1 + 24) = 1;
  CGColorSpaceRef v10 = CGColorSpaceRetain(a7);
  *(unsigned char *)(a1 + 56) = 0;
  *(void *)(a1 + 72) = a2;
  *(void *)(a1 + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = v10;
  return a1;
}

uint64_t CI::format_is_float(int a1)
{
  uint64_t result = 1;
  if ((a1 - 2049) > 0x15 || ((1 << (a1 - 1)) & 0x2608FF) == 0)
  {
    unsigned int v3 = a1 - 2305;
    if (v3 > 0xB || ((1 << v3) & 0x9FF) == 0) {
      return 0;
    }
  }
  return result;
}

uint64_t CI::format_is_half_float(int a1)
{
  return ((a1 - 2049) < 0x16) & (0x2608FFu >> (a1 - 1));
}

uint64_t CI::format_component_count(int a1)
{
  uint64_t result = 0;
  if (a1 <= 1792)
  {
    if (a1 > 770)
    {
      if (a1 <= 1041)
      {
        switch(a1)
        {
          case 771:
          case 773:
            return 1;
          case 774:
            return 2;
          case 775:
          case 784:
          case 785:
          case 786:
          case 787:
          case 790:
            return 3;
          default:
            return result;
        }
      }
      else
      {
        if (a1 <= 1297)
        {
          if ((a1 - 1042) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0) {
            return 3;
          }
          if (a1 != 1285)
          {
            if (a1 != 1286) {
              return result;
            }
            return 2;
          }
          return 1;
        }
        if ((a1 - 1554) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0
          || (a1 - 1298) < 2
          || a1 == 1302)
        {
          return 3;
        }
      }
    }
    else
    {
      switch(a1)
      {
        case 257:
        case 258:
        case 259:
        case 261:
          return 1;
        case 260:
        case 262:
          return 2;
        case 263:
        case 268:
        case 269:
        case 270:
        case 271:
        case 274:
        case 275:
        case 276:
        case 277:
        case 278:
          return 3;
        case 264:
        case 265:
        case 266:
        case 267:
          return 4;
        case 272:
        case 273:
          return result;
        default:
          if ((a1 - 530) < 5) {
            return 3;
          }
          if (a1 == 535) {
            uint64_t result = 4;
          }
          else {
            uint64_t result = 0;
          }
          break;
      }
    }
  }
  else if (a1 <= 2304)
  {
    switch(a1)
    {
      case 1793:
      case 1794:
      case 1795:
      case 1797:
        return 1;
      case 1796:
      case 1798:
        return 2;
      case 1799:
      case 1804:
      case 1810:
      case 1811:
      case 1814:
        return 3;
      case 1800:
      case 1801:
        return 4;
      case 1802:
      case 1803:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        return result;
      default:
        switch(a1)
        {
          case 2049:
          case 2050:
          case 2051:
          case 2053:
            return 1;
          case 2052:
          case 2054:
            return 2;
          case 2055:
          case 2060:
          case 2066:
          case 2067:
          case 2070:
            return 3;
          case 2056:
            return 4;
          default:
            return result;
        }
    }
  }
  else if (a1 <= 3078)
  {
    if (a1 > 2566)
    {
      if (a1 == 2567) {
        return 3;
      }
      if (a1 == 2569 || a1 == 2824) {
        return 4;
      }
    }
    else
    {
      switch(a1)
      {
        case 2305:
        case 2306:
        case 2307:
        case 2309:
          return 1;
        case 2308:
        case 2310:
          return 2;
        case 2311:
        case 2316:
          return 3;
        case 2312:
        case 2313:
          return 4;
        default:
          return result;
      }
    }
  }
  else
  {
    if (a1 <= 3601)
    {
      char v3 = a1 - 3;
      if ((a1 - 3331) > 0x13) {
        goto LABEL_9;
      }
      if (((1 << v3) & 0x98000) != 0) {
        return 3;
      }
      if (((1 << v3) & 5) == 0)
      {
        if (a1 != 3334)
        {
LABEL_9:
          if (a1 != 3079)
          {
            if (a1 != 3081) {
              return result;
            }
            return 4;
          }
          return 3;
        }
        return 2;
      }
      return 1;
    }
    if ((a1 - 3602) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0) {
      return 3;
    }
    unsigned int v4 = a1 - 3858;
    if (v4 <= 4 && ((1 << v4) & 0x13) != 0) {
      return 3;
    }
  }
  return result;
}

BOOL CI::format_is_deep(int a1)
{
  return CI::format_bits_per_component(a1) > 8;
}

uint64_t CI::format_bits_per_component(int a1)
{
  uint64_t result = 0;
  if (a1 <= 1792)
  {
    if (a1 > 770)
    {
      if (a1 <= 1041)
      {
        unsigned int v11 = a1 - 771;
        if (v11 > 0x13) {
          return result;
        }
        int v6 = 1 << v11;
        if ((v6 & 0x9E010) != 0) {
          return 10;
        }
        int v7 = 13;
        goto LABEL_41;
      }
      if ((a1 - 1285) <= 0x11 && ((1 << (a1 - 5)) & 0x26003) != 0) {
        return 10;
      }
      if ((a1 - 1042) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0) {
        return 10;
      }
      unsigned int v8 = a1 - 1554;
      if (v8 <= 4 && ((1 << v8) & 0x13) != 0) {
        return 10;
      }
    }
    else if ((a1 - 257) <= 0x15 && ((1 << (a1 - 1)) & 0x3E7FFF) != 0 || (a1 - 530) < 6)
    {
      return 8;
    }
  }
  else
  {
    if (a1 <= 2304)
    {
      if ((a1 - 1793) <= 0x15)
      {
        int v4 = 1 << (a1 - 1);
        if ((v4 & 0x9FF) != 0 || (v4 & 0x260000) != 0) {
          return 16;
        }
      }
      unsigned int v5 = a1 - 2049;
      if (v5 > 0x15) {
        return result;
      }
      int v6 = 1 << v5;
      if ((_BYTE)v6) {
        return 16;
      }
      int v7 = 2492416;
      goto LABEL_41;
    }
    if (a1 > 3078)
    {
      if (a1 <= 3601)
      {
        if ((a1 - 3331) > 0x13)
        {
LABEL_8:
          if (a1 != 3079 && a1 != 3081) {
            return result;
          }
          return 10;
        }
        int v3 = 1 << (a1 - 3);
        if ((v3 & 0xD) == 0)
        {
          if ((v3 & 0x98000) == 0) {
            goto LABEL_8;
          }
          return 12;
        }
        return 16;
      }
      if ((a1 - 3602) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0) {
        return 12;
      }
      unsigned int v12 = a1 - 3858;
      if (v12 > 4) {
        return result;
      }
      int v6 = 1 << v12;
      int v7 = 19;
LABEL_41:
      if ((v6 & v7) == 0) {
        return result;
      }
      return 16;
    }
    if (a1 > 2566)
    {
      if (a1 == 2567 || a1 == 2569) {
        return 10;
      }
      if (a1 != 2824) {
        return result;
      }
      return 16;
    }
    unsigned int v9 = a1 - 2305;
    if (((1 << v9) & 0x9FF) != 0) {
      unsigned int v10 = 32;
    }
    else {
      unsigned int v10 = 0;
    }
    if (v9 <= 0xB) {
      return v10;
    }
    else {
      return 0;
    }
  }
  return result;
}

CFDataRef CI::createCFData(uint64_t this)
{
  if (!CI_IOSURFACE_WRAPPING(2u))
  {
    {
      CI::createCFData(unsigned long)::page_CGSize size = getpagesize();
    }
    unint64_t v2 = CI::createCFData(unsigned long)::page_size - 1 + this;
    if ((CI::createCFData(unsigned long)::page_size & (CI::createCFData(unsigned long)::page_size - 1)) != 0) {
      this = v2 / CI::createCFData(unsigned long)::page_size * CI::createCFData(unsigned long)::page_size;
    }
    else {
      this = v2 & -CI::createCFData(unsigned long)::page_size;
    }
  }
  int v3 = (const UInt8 *)mmap(0, this, 3, 4098, 1140850688, 0);
  if (v3 == (const UInt8 *)-1) {
    int v4 = 0;
  }
  else {
    int v4 = v3;
  }
  v8.version = xmmword_1EE4622F8;
  *(_OWORD *)&v8.retain = unk_1EE462308;
  *(_OWORD *)&v8.copyDescription = xmmword_1EE462318;
  *(_OWORD *)&v8.reallocate = unk_1EE462328;
  v8.preferredSize = (CFAllocatorPreferredSizeCallBack)qword_1EE462338;
  v8.info = (void *)this;
  CFAllocatorRef v5 = CFAllocatorCreate(0, &v8);
  CFDataRef v6 = CFDataCreateWithBytesNoCopy(0, v4, this, v5);
  CFRelease(v5);
  return v6;
}

uint64_t CI::format_destination_rowbytes_requirement(int a1)
{
  if ((a1 - 2049) <= 0x15 && ((1 << (a1 - 1)) & 0x2608FF) != 0) {
    return 8;
  }
  uint64_t v2 = 16;
  if ((a1 & 0xFFFFFFFD) == 0x904) {
    uint64_t v2 = 8;
  }
  if (((1 << (a1 - 4)) & 0x13D) != 0) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = 4;
  }
  if ((a1 - 2308) <= 8) {
    return v3;
  }
  else {
    return 4;
  }
}

uint64_t CI::format_is_supported_render_to_bitmap(int a1)
{
  if (CI::format_is_ycc_biplanar(a1)) {
    return 0;
  }
  uint64_t result = 1;
  if (a1 > 2048)
  {
    if (a1 <= 2566)
    {
      if ((a1 - 2305) <= 0xB && ((1 << (a1 - 1)) & 0x9FD) != 0) {
        return result;
      }
      if ((a1 - 2049) <= 0xB)
      {
        int v3 = 1 << (a1 - 1);
        int v4 = 2301;
LABEL_23:
        if ((v3 & v4) != 0) {
          return result;
        }
      }
    }
    else
    {
      if (a1 > 3080)
      {
        if (((a1 - 3331) > 3 || a1 == 3332) && a1 != 3081) {
          return 0;
        }
        return result;
      }
      if (a1 == 2567 || a1 == 2569 || a1 == 3079) {
        return result;
      }
    }
    return 0;
  }
  if (a1 > 770)
  {
    if ((a1 - 1793) <= 0xB && ((1 << (a1 - 1)) & 0x9FD) != 0) {
      return result;
    }
    if ((a1 - 771) <= 0xE)
    {
      int v3 = 1 << (a1 - 3);
      int v4 = 24605;
      goto LABEL_23;
    }
    return 0;
  }
  if (((a1 - 257) > 0xE || a1 == 258) && a1 != 535) {
    return 0;
  }
  return result;
}

uint64_t CI::RenderToBitmap::RenderToBitmap(uint64_t a1, CI::Object *this)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)a1 = &unk_1EE45CC00;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = &unk_1EE45B228;
  atomic_fetch_add(&dword_1EB466F58[23], 1u);
  *(void *)a1 = &unk_1EE459F78;
  *(void *)(a1 + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = &unk_1EE459FD0;
  *(void *)(a1 + 48) = this;
  if (this)
  {
    CI::Object::ref((uint64_t)this);
    uint64_t v3 = *(void *)(a1 + 48);
    if (v3) {
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(v3 + 104);
    }
  }
  return a1;
}

CGColorSpaceRef default_colorspace_for_format(int a1, int a2)
{
  if (CI::format_is_rgb(a1))
  {
    if (CI::format_is_float(a1) | a2) {
      int v4 = (const __CFString **)MEMORY[0x1E4F1DBE0];
    }
    else {
      int v4 = (const __CFString **)MEMORY[0x1E4F1DC98];
    }
  }
  else
  {
    if (!CI::format_is_luminance(a1)) {
      return 0;
    }
    int is_float = CI::format_is_float(a1);
    int v4 = (const __CFString **)MEMORY[0x1E4F1DC00];
    if (is_float) {
      int v4 = (const __CFString **)MEMORY[0x1E4F1DBD0];
    }
  }
  CFStringRef v6 = *v4;

  return CGColorSpaceCreateWithName(v6);
}

uint64_t CI::format_is_rgb(int a1)
{
  uint64_t result = 1;
  if (a1 > 2054)
  {
    if (a1 > 2566)
    {
      if (a1 <= 2823)
      {
        if (a1 != 2567 && a1 != 2569) {
          return 0;
        }
      }
      else if (a1 != 2824 && a1 != 3079 && a1 != 3081)
      {
        return 0;
      }
      return result;
    }
    if ((a1 - 2311) <= 5 && ((1 << (a1 - 7)) & 0x27) != 0) {
      return result;
    }
    unsigned int v3 = a1 - 2055;
    if (v3 <= 5)
    {
      int v4 = 1 << v3;
      int v5 = 35;
      goto LABEL_13;
    }
    return 0;
  }
  if ((a1 - 263) < 9 || (a1 - 1799) <= 5 && ((1 << (a1 - 7)) & 0x27) != 0) {
    return result;
  }
  unsigned int v6 = a1 - 775;
  if (v6 > 0xA) {
    return 0;
  }
  int v4 = 1 << v6;
  int v5 = 1537;
LABEL_13:
  if ((v4 & v5) == 0) {
    return 0;
  }
  return result;
}

uint64_t CI::format_only_alpha(int a1)
{
  HIDWORD(v1) = a1 - 257;
  LODWORD(v1) = a1 - 257;
  return ((v1 >> 8) < 9) & (0x1C1u >> ((unsigned __int16)(a1 - 257) >> 8));
}

CFStringRef _block_invoke_2(uint64_t a1, void *a2)
{
  CFStringRef v2 = (const __CFString *)[a2 description];

  return CI::Context::AbortIfUnhandledError(v2, v3);
}

CGImageRef CI::Bitmap::create_CGImage(CI::Bitmap *this)
{
  CGBitmapInfo v2 = CI::format_CGBitmapInfo(*((_DWORD *)this + 26), *((unsigned __int8 *)this + 24));
  if (v2 == -1) {
    return 0;
  }
  CGBitmapInfo v3 = v2;
  CFDataRef v4 = (const __CFData *)*((void *)this + 5);
  CGDataProviderRef v5 = v4 ? CGDataProviderCreateWithCFData(v4) : (CGDataProviderRef)CGDataProviderCreateWithCopyOfData();
  unsigned int v6 = v5;
  if (!v5) {
    return 0;
  }
  int v7 = (CGColorSpace *)*((void *)this + 4);
  DeviceRGB = v7;
  if (!v7) {
    DeviceRGB = CGColorSpaceCreateDeviceRGB();
  }
  size_t v9 = *((void *)this + 10);
  size_t v10 = *((void *)this + 11);
  size_t v11 = (int)CI::format_bits_per_component(*((_DWORD *)this + 26));
  int v12 = CI::format_bits_per_pixel(*((_DWORD *)this + 26));
  CGImageRef v13 = CGImageCreate(v9, v10, v11, v12, *((void *)this + 12), DeviceRGB, v3, v6, 0, 1, kCGRenderingIntentDefault);
  CGDataProviderRelease(v6);
  if (!v7) {
    CGColorSpaceRelease(DeviceRGB);
  }
  return v13;
}

double CI::ColorKernelImage::headroom(CI::ColorKernelImage *this)
{
  LODWORD(result) = *((_DWORD *)this + 44);
  if (*(float *)&result < 1.0)
  {
    if (*(unsigned char *)(*((void *)this + 14) + 164))
    {
      CGBitmapInfo v2 = *(void (**)(void))(*(void *)(*(uint64_t (**)(CI::ColorKernelImage *, void))(*(void *)this + 48))(this, 0)+ 232);
      v2();
    }
    else
    {
      return 0.0;
    }
  }
  return result;
}

uint64_t CI::AffineImage::headroom(CI::AffineImage *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 13) + 232))();
}

const __CFString *CI::Context::AbortIfUnhandledError(const __CFString *this, const __CFString *a2)
{
  if (this)
  {
    CFRange v2 = CFStringFind(this, @"Render failed because of failure to allocate intermediate.", 1uLL);
    this = (const __CFString *)v2.location;
    if (v2.length) {
      abort();
    }
  }
  return this;
}

uint64_t ___ZN2CI14TextureManager19purge_intermediatesEm_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(*(void *)(result + 32) + 136);
  for (uint64_t i = *(void *)(v1 + 8); i != v1; uint64_t i = *(void *)(i + 8))
    double result = (*(uint64_t (**)(void))(**(void **)(i + 16) + 16))(*(void *)(i + 16));
  return result;
}

void *CI::RenderTask::addTileTask(void *this, CI::TileTask *a2)
{
  if (!this[16])
  {
    CFRange v2 = this;
    if (a2) {
      uint64_t v3 = CI::Object::ref((uint64_t)a2);
    }
    else {
      uint64_t v3 = 0;
    }
    this = v2 + 19;
    unint64_t v4 = v2[19];
    CGDataProviderRef v5 = (uint64_t *)v2[18];
    if ((unint64_t)v5 >= v4)
    {
      uint64_t v7 = v2[17];
      uint64_t v8 = ((uint64_t)v5 - v7) >> 3;
      if ((unint64_t)(v8 + 1) >> 61) {
        abort();
      }
      uint64_t v9 = v4 - v7;
      uint64_t v10 = v9 >> 2;
      if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
        uint64_t v10 = v8 + 1;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v11 = v10;
      }
      uint64_t v23 = v2 + 19;
      if (v11) {
        int v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)this, v11);
      }
      else {
        int v12 = 0;
      }
      CGImageRef v13 = (uint64_t *)&v12[8 * v8];
      uint64_t v14 = &v12[8 * v11];
      CFNumberRef v22 = v14;
      *CGImageRef v13 = v3;
      unsigned int v6 = v13 + 1;
      v21.i64[1] = (uint64_t)(v13 + 1);
      int v16 = (void *)v2[17];
      uint64_t v15 = (void *)v2[18];
      if (v15 == v16)
      {
        int64x2_t v18 = vdupq_n_s64((unint64_t)v15);
      }
      else
      {
        do
        {
          uint64_t v17 = *--v15;
          *uint64_t v15 = 0;
          *--CGImageRef v13 = v17;
        }
        while (v15 != v16);
        int64x2_t v18 = *(int64x2_t *)(v2 + 17);
        unsigned int v6 = (void *)v21.i64[1];
        uint64_t v14 = v22;
      }
      v2[17] = v13;
      v2[18] = v6;
      int64x2_t v21 = v18;
      unint64_t v19 = (char *)v2[19];
      v2[19] = v14;
      CFNumberRef v22 = v19;
      uint64_t v20 = v18.i64[0];
      this = (void *)std::__split_buffer<std::unique_ptr<CI::TileTask,CI::ObjectDeleter<CI::TileTask>>>::~__split_buffer((uint64_t)&v20);
    }
    else
    {
      *CGDataProviderRef v5 = v3;
      unsigned int v6 = v5 + 1;
    }
    v2[18] = v6;
  }
  return this;
}

uint64_t std::__split_buffer<std::unique_ptr<CI::TileTask,CI::ObjectDeleter<CI::TileTask>>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::unique_ptr<CI::TileTask,CI::ObjectDeleter<CI::TileTask>>>::__destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    CGDataProviderRef v5 = *(CI::Object **)(i - 8);
    *(void *)(i - 8) = 0;
    if (v5) {
      CI::Object::unref(v5);
    }
  }
}

os_log_t __ci_signpost_log_render_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "signpost_render");
  ci_signpost_log_render_log = (uint64_t)result;
  return result;
}

os_log_t __ci_signpost_log_filter_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coreimage", "signpost_filter");
  ci_signpost_log_filter_log = (uint64_t)result;
  return result;
}

double ___ZNK2CI8TileTask15compileWaitTimeEv_block_invoke(uint64_t a1)
{
  for (uint64_t i = *(double **)(*(void *)(a1 + 40) + 104); i; uint64_t i = *(double **)i)
  {
    uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
    double result = i[5] + *(double *)(v2 + 24);
    *(double *)(v2 + 24) = result;
  }
  return result;
}

double ___ZNK2CI8TileTask13executionTimeEv_block_invoke(uint64_t a1)
{
  for (uint64_t i = *(double **)(*(void *)(a1 + 40) + 104); i; uint64_t i = *(double **)i)
  {
    uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
    double result = i[3] + *(double *)(v2 + 24);
    *(double *)(v2 + 24) = result;
  }
  return result;
}

double ___ZNK2CI8TileTask11compileTimeEv_block_invoke(uint64_t a1)
{
  for (uint64_t i = *(double **)(*(void *)(a1 + 40) + 104); i; uint64_t i = *(double **)i)
  {
    uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
    double result = i[4] + *(double *)(v2 + 24);
    *(double *)(v2 + 24) = result;
  }
  return result;
}

void *__useOneDispatchPerCommandBuffer_block_invoke()
{
  double result = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CB18], "standardUserDefaults"), "objectForKey:", @"com.apple.coreimage.perDispatchCommandBuffer");
  if (result)
  {
    uint64_t v1 = [result BOOLValue];
    useOneDispatchPerCommandBuffer_double result = v1;
    useOneDispatchPerCommandBuffer_setOverride = 1;
    uint64_t v9 = "NO";
    if (v1) {
      uint64_t v9 = "YES";
    }
    return (void *)x_log(v1, v2, v3, v4, v5, v6, v7, v8, (char)v9);
  }
  return result;
}

void sub_1936B9BCC(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

BOOL CI::ColorSpace_is_RGB_or_Gray_and_supports_output(BOOL this, CGColorSpace *a2)
{
  if (this)
  {
    uint64_t v2 = (CGColorSpace *)this;
    CFTypeID v3 = CFGetTypeID((CFTypeRef)this);
    if (v3 == CGColorSpaceGetTypeID())
    {
      this = CGColorSpaceSupportsOutput(v2);
      if (this) {
        return CGColorSpaceGetModel(v2) < kCGColorSpaceModelCMYK;
      }
    }
    else
    {
      return 0;
    }
  }
  return this;
}

uint64_t ___ZNK2CI8TileTask15executionCyclesEv_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void **)(*(void *)(result + 40) + 104);
  if (v1)
  {
    uint64_t v2 = 0;
    while (1)
    {
      uint64_t v3 = v1[8];
      if (!v3) {
        break;
      }
      v2 += v3;
      uint64_t v1 = (void *)*v1;
      if (!v1) {
        goto LABEL_7;
      }
    }
  }
  else
  {
    uint64_t v2 = 0;
LABEL_7:
    *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v2;
  }
  return result;
}

void CI::TextureManager::complete_intermediate(uint64_t a1, int a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = *(NSObject **)(a1 + 104);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN2CI14TextureManager21complete_intermediateENS_4TypeEPNS_14intermediate_tE_block_invoke;
    block[3] = &__block_descriptor_tmp_13_1;
    void block[4] = a1;
    void block[5] = a3;
    int v5 = a2;
    dispatch_sync(v3, block);
  }
}

void sub_1936B9E58(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C407DA4F8A2);
  _Unwind_Resume(a1);
}

CI::ClampImage *CI::ClampImage::ClampImage(CI::ClampImage *this, CI::Image *a2, CGRect a3)
{
  double height = a3.size.height;
  double width = a3.size.width;
  double y = a3.origin.y;
  double x = a3.origin.x;
  uint64_t v9 = CI::ImageWithChild::ImageWithChild(this, a2);
  *((void *)v9 + 14) = &unk_1EE45B200;
  atomic_fetch_add(&dword_1EB466E78[5], 1u);
  *(void *)uint64_t v9 = &unk_1EE4574A8;
  *((void *)v9 + 14) = &unk_1EE457600;
  *((double *)v9 + 15) = x;
  *((double *)v9 + 16) = y;
  *((double *)v9 + 17) = width;
  *((double *)v9 + 18) = height;
  *((void *)this + 1CI::NodeWithChildren::NodeWithChildren(this, 0) = CI::ClampImage::makeDigest(*((void *)a2 + 10), x, y, width, height);
  *((void *)this + 11) = CI::ClampImage::makeDigest(*((void *)a2 + 11), x, y, width, height);
  return this;
}

void sub_1936B9F80(_Unwind_Exception *a1)
{
  *((void *)v1 + 14) = v2;
  atomic_fetch_add(v3, 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::ClampImage::makeDigest(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(double *)uint64_t v8 = a2;
  *(double *)&v8[1] = a3;
  *(double *)&void v8[2] = a4;
  *(double *)&v8[3] = a5;
  XXH64_reset(v7, 0);
  LODWORD(__src) = 7;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  uint64_t __src = a1;
  XXH64_update((uint64_t)v7, (char *)&__src, 8uLL);
  XXH64_update((uint64_t)v7, (char *)v8, 0x20uLL);
  return XXH64_digest((uint64_t)v7);
}

CGColorSpaceRef ___ZL20GetDefaultColorSpacev_block_invoke()
{
  if (dyld_program_sdk_at_least()) {
    CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
  }
  else {
    CGColorSpaceRef result = CGColorSpaceCreateDeviceRGB();
  }
  GetDefaultColorSpace(void)::cs = (uint64_t)result;
  return result;
}

uint64_t can_use_metal()
{
  if (can_use_metal_once != -1) {
    dispatch_once(&can_use_metal_once, &__block_literal_global_22);
  }
  return can_use_metal_canUse;
}

id CIMetalCopyDefaultDevice()
{
  if (!CI_ENABLE_METAL_GPU()) {
    return 0;
  }

  return MTLCreateSystemDefaultDevice();
}

void __can_use_metal_block_invoke()
{
  if (CI_ENABLE_METAL_GPU())
  {
    if (CI_ENABLE_METAL_GPU())
    {
      id v0 = MTLCreateSystemDefaultDevice();
      if (v0) {
        can_use_metal_canUse = 1;
      }
    }
    else
    {
      id v0 = 0;
    }

    if ((can_use_metal_canUse & 1) == 0)
    {
      uint64_t v2 = ci_logger_api();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        __can_use_metal_block_invoke_cold_2();
      }
    }
  }
  else
  {
    uint64_t v1 = ci_logger_api();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
      __can_use_metal_block_invoke_cold_1();
    }
  }
}

uint64_t CI_ENABLE_METAL_GPU()
{
  if (CI_ENABLE_METAL_GPU::didCheck != -1) {
    dispatch_once(&CI_ENABLE_METAL_GPU::didCheck, &__block_literal_global_97);
  }
  return CI_ENABLE_METAL_GPU::v;
}

void CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::insert(uint64_t a1, uint64_t a2, CI::Object *this, int a4)
{
  if (this) {
    CI::Object::ref((uint64_t)this);
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  void v8[2] = ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE6insertES2_PS1_j_block_invoke;
  v8[3] = &__block_descriptor_tmp_105;
  void v8[4] = a1;
  void v8[5] = a2;
  void v8[6] = this;
  int v9 = a4;
  Queue::execute_async((dispatch_queue_t *)(a1 + 56), v8);
}

unint64_t CI::MetalContext::set_bitmap_destination(uint64_t a1, CI::Bitmap *a2, double *a3, int *a4, unint64_t a5)
{
  unint64_t result = *a4;
  if (result)
  {
    *(unsigned char *)(a1 + 1904) = 0;
    unsigned int v11 = CIMetalFormatForFormat(result, *((unsigned __int8 *)a4 + 4));
    double v12 = a3[1];
    double v13 = *a3 * (double)a5;
    int v14 = 2;
    if (CI::MetalContext::use_imageblocks_for_format(a1, *a4))
    {
      if (CI_ENABLE_METAL_IMAGEBLOCKS() == 2) {
        int v14 = 4;
      }
      else {
        int v14 = 2;
      }
    }
    *(_OWORD *)(a1 + 1832) = *(_OWORD *)a3;
    char v15 = 2 * *((unsigned char *)a4 + 4);
    *(_DWORD *)(a1 + 1848) = *a4;
    *(unsigned char *)(a1 + 1852) = v15;
    {
      CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_CGSize size = getpagesize();
    }
    unint64_t v16 = *((void *)a2 + 9);
    unint64_t v17 = CI::Bitmap::length(a2);
    uint64_t v18 = *((void *)a2 + 12);
    uint64_t v19 = CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size
        - 1;
    if ((CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size & (CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size - 1)) != 0)
    {
      if (v16
         % CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size
        || v17
         % CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size)
      {
        goto LABEL_16;
      }
    }
    else if ((v19 & v16) != 0 || (v19 & v17) != 0)
    {
      goto LABEL_16;
    }
    if ((v18 & 0x3F) == 0 && v17 >= v18 * (unint64_t)v12)
    {
      uint64_t v20 = CIMetalBufferCreateAndWrapData(*(void *)(a1 + 1920), (void *)[*(id *)(a1 + 392) device], v16, v17);
      *(void *)(a1 + 1856) = v20;
      unint64_t result = (unint64_t)CIMetalTextureCreateFromBuffer(*(void *)(a1 + 1920), v20, v11, (unint64_t)v13, (unint64_t)v12, v18, v14);
LABEL_17:
      *(void *)(a1 + 1864) = result;
      return result;
    }
LABEL_16:
    unint64_t result = (unint64_t)CIMetalTextureCreate(*(void *)(a1 + 1920), (void *)[*(id *)(a1 + 392) device], v11, (unint64_t)v13, (unint64_t)v12, v14);
    goto LABEL_17;
  }
  return result;
}

void CI::RenderToSurface::render(CI **this, CI::Image *a2, CI::Context *a3)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = CI::format_from_IOSurface(this[6], a2);
  unint64_t v7 = (*(uint64_t (**)(CI::Context *, uint64_t))(*(void *)a3 + 544))(a3, v6);
  BOOL IsRowBytesAligned = SurfaceIsRowBytesAligned(this[6], v7);
  BOOL v9 = (IOSurfaceGetWidth(this[6]) & 1) == 0 && (IOSurfaceGetHeight(this[6]) & 1) == 0;
  v89.origin.CGFloat x = (*(double (**)(CI::Image *))(*(void *)a2 + 88))(a2);
  CGRect v90 = CGRectInset(v89, 0.00100000005, 0.00100000005);
  CGRect v91 = CGRectIntegral(v90);
  CGFloat x = v91.origin.x;
  CGFloat y = v91.origin.y;
  CGFloat width = v91.size.width;
  CGFloat height = v91.size.height;
  if (!CI::format_is_ycc_biplanar(v6))
  {
    if (!IsRowBytesAligned) {
      operator new();
    }
LABEL_46:
    unint64_t v38 = this[6];
    CGFloat v39 = x;
    CGFloat v40 = y;
    CGFloat v41 = width;
    CGFloat v42 = height;
    CI::image_render_to_surface(a3, a2, v38, *(CGRect *)&v39, (__IOSurface *)this, v14);
  }
  int is_ycc_full_range = CI::format_is_ycc_full_range(v6);
  BOOL is_deep = CI::format_is_deep(v6);
  CI::format_is_ycc_420(v6);
  CI::format_is_ycc_422(v6);
  CI::format_is_ycc_444(v6);
  int v70 = CI::format_bits_per_component(v6);
  int is_packed = CI::format_is_packed(v6);
  int is_half_float = CI::format_is_half_float(v6);
  int CompressionTypeOfPlane = IOSurfaceGetCompressionTypeOfPlane();
  int v18 = 1;
  if ((*(uint64_t (**)(CI::Context *, uint64_t, uint64_t))(*(void *)a3 + 432))(a3, v6, 1))
  {
LABEL_36:
    int v31 = (*(unsigned int (**)(CI::Context *))(*(void *)a3 + 16))(a3) != 76 || v9;
    int v32 = v18 & v31;
    size_t v33 = IOSurfaceGetHeight(this[6]);
    size_t v34 = IOSurfaceGetWidth(this[6]);
    int v35 = this[6];
    if (v33 <= v34) {
      size_t v36 = IOSurfaceGetWidth(v35);
    }
    else {
      size_t v36 = IOSurfaceGetHeight(v35);
    }
    if (v36 <= (*(uint64_t (**)(CI::Context *))(*(void *)a3 + 440))(a3)) {
      int v37 = v32;
    }
    else {
      int v37 = 0;
    }
    if ((v37 & IsRowBytesAligned) == 1) {
      goto LABEL_46;
    }
    if (CompressionTypeOfPlane) {
      operator new();
    }
    size_t v43 = IOSurfaceGetWidth(this[6]);
    size_t v44 = IOSurfaceGetHeight(this[6]);
    v97.origin.CGFloat x = x;
    v97.origin.CGFloat y = y;
    v97.size.CGFloat width = width;
    v97.size.CGFloat height = height;
    size_t v63 = v44;
    if (CGRectIsNull(v97))
    {
      unint64_t v64 = 0;
      uint64_t v66 = 0;
      goto LABEL_66;
    }
    v98.origin.CGFloat x = x;
    v98.origin.CGFloat y = y;
    v98.size.CGFloat width = width;
    v98.size.CGFloat height = height;
    if (CGRectIsInfinite(v98))
    {
      unint64_t v45 = 0xFFFFFFFFLL;
      int v46 = -2147483647;
      int v47 = -2147483647;
      unint64_t v48 = 0xFFFFFFFFLL;
    }
    else
    {
      v99.origin.CGFloat x = x;
      v99.origin.CGFloat y = y;
      v99.size.CGFloat width = width;
      v99.size.CGFloat height = height;
      CGRect v100 = CGRectInset(v99, 0.000001, 0.000001);
      CGRect v101 = CGRectIntegral(v100);
      int v46 = (int)v101.origin.x;
      int v47 = (int)v101.origin.y;
      unint64_t v45 = (unint64_t)v101.size.width;
      unint64_t v48 = (unint64_t)v101.size.height;
    }
    if (v46 == -2147483647 && v47 == -2147483647 && v45 == 0xFFFFFFFF)
    {
      int v47 = -2147483647;
      LODWORD(v45) = -1;
      if (!v48 || v48 == 0xFFFFFFFF)
      {
        unint64_t v64 = v48;
        uint64_t v66 = 0xFFFFFFFFLL;
        goto LABEL_66;
      }
    }
    else if (!v45 || !v48)
    {
      unint64_t v64 = v48;
      uint64_t v66 = v45;
LABEL_66:
      int v49 = (*(uint64_t (**)(CI::Context *, uint64_t, uint64_t))(*(void *)a3 + 432))(a3, 784, 1);
      int v50 = (*(uint64_t (**)(CI::Context *, uint64_t, uint64_t))(*(void *)a3 + 432))(a3, 785, 1);
      if (is_half_float)
      {
        uint64_t v51 = 2056;
      }
      else if (v70 != 10 || v50 != 1)
      {
        int v52 = v49 ^ 1;
        if (v70 != 10) {
          int v52 = 1;
        }
        if (is_deep) {
          unsigned int v53 = 1800;
        }
        else {
          unsigned int v53 = 264;
        }
        if (v52) {
          uint64_t v51 = v53;
        }
        else {
          uint64_t v51 = 784;
        }
      }
      else
      {
        uint64_t v51 = 785;
      }
      uint64_t v54 = CI::PixelFormatType_from_format(v51);
      long long v55 = ci_logger_performance();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)CGRect buf = 136447234;
        *(void *)&uint8_t buf[4] = "render";
        __int16 v80 = 2082;
        unint64_t v81 = CI::name_for_format(v51);
        __int16 v82 = 2048;
        size_t v83 = v43;
        v84[0] = 2048;
        *(void *)&v84[1] = v63;
        v84[5] = 2082;
        uint64_t v85 = CI::name_for_format(v6);
        _os_log_impl(&dword_193671000, v55, OS_LOG_TYPE_INFO, "%{public}s CI_CONVERSIONS: Rendered via an intermediate YCC444 (%{public}s) buffer instead of directly to a (%zux%zu) %{public}s surface.", buf, 0x34u);
      }
      long long v56 = (void *)(*(uint64_t (**)(CI::Context *, uint64_t))(*(void *)a3 + 544))(a3, v51);
      Surface = CreateSurface((__CVBuffer *)v66, (__CVBuffer *)v64, v56, v54, 0);
      if (Surface)
      {
        if ((int)v51 > 1799)
        {
          if (v51 == 2056)
          {
            *(void *)CGRect buf = 0x3C00000000000000;
            v77[0] = MEMORY[0x1E4F143A8];
            v77[1] = 0x40000000;
            v77[2] = ___ZNK2CI15RenderToSurface6renderEPNS_5ImageEPNS_7ContextE_block_invoke_2;
            v77[3] = &__block_descriptor_tmp_4_5;
            v77[4] = buf;
            long long v59 = v77;
          }
          else
          {
            *(void *)unint64_t v86 = 0xFFFF800080000040;
            long long v60 = v86;
            if (is_ycc_full_range) {
              long long v60 = buf;
            }
            v78[0] = MEMORY[0x1E4F143A8];
            v78[1] = 0x40000000;
            v78[2] = ___ZNK2CI15RenderToSurface6renderEPNS_5ImageEPNS_7ContextE_block_invoke;
            v78[3] = &__block_descriptor_tmp_30;
            v78[4] = v60;
            *(void *)CGRect buf = 0xFFFF800080000000;
            long long v59 = v78;
          }
        }
        else if (v51 == 784)
        {
          if (is_ycc_full_range) {
            int v62 = 524800;
          }
          else {
            int v62 = 67633664;
          }
          v75[0] = MEMORY[0x1E4F143A8];
          v75[1] = 0x40000000;
          v75[2] = ___ZNK2CI15RenderToSurface6renderEPNS_5ImageEPNS_7ContextE_block_invoke_3;
          v75[3] = &__block_descriptor_tmp_5_4;
          int v76 = v62;
          long long v59 = v75;
        }
        else if (v51 == 785)
        {
          if (is_ycc_full_range) {
            int v58 = 537395200;
          }
          else {
            int v58 = 537395264;
          }
          v73[0] = MEMORY[0x1E4F143A8];
          v73[1] = 0x40000000;
          v73[2] = ___ZNK2CI15RenderToSurface6renderEPNS_5ImageEPNS_7ContextE_block_invoke_4;
          v73[3] = &__block_descriptor_tmp_6_4;
          int v74 = v58;
          long long v59 = v73;
        }
        else
        {
          *(_DWORD *)CGRect buf = -8355840;
          *(_DWORD *)unint64_t v86 = -8355824;
          long long v61 = v86;
          if (is_ycc_full_range) {
            long long v61 = buf;
          }
          v72[0] = MEMORY[0x1E4F143A8];
          v72[1] = 0x40000000;
          v72[2] = ___ZNK2CI15RenderToSurface6renderEPNS_5ImageEPNS_7ContextE_block_invoke_5;
          v72[3] = &__block_descriptor_tmp_9_4;
          v72[4] = v61;
          long long v59 = v72;
        }
        SurfaceApplyPlaneBlock(Surface, (uint64_t)v59);
        operator new();
      }
      operator new();
    }
    uint64_t v66 = (int)(v45 + v46 + 1 - (v46 & 0xFFFFFFFE | (v45 + v46 + 1) & 1));
    unint64_t v64 = (int)(v48 + v47 + 1 - (v47 & 0xFFFFFFFE | (v48 + v47 + 1) & 1));
    goto LABEL_66;
  }
  int v19 = ((CompressionTypeOfPlane != 0) | ~is_packed) & CI::Context::format_is_supported_for_output((uint64_t)a3, v6, 1);
  if ((*(unsigned int (**)(CI::Context *))(*(void *)a3 + 16))(a3) == 74) {
    v19 &= ~is_half_float;
  }
  v92.origin.CGFloat x = x;
  v92.origin.CGFloat y = y;
  v92.size.CGFloat width = width;
  v92.size.CGFloat height = height;
  int v67 = CompressionTypeOfPlane;
  BOOL v68 = is_deep;
  int v65 = v19;
  if (CGRectIsNull(v92))
  {
    unint64_t v20 = 0;
    unint64_t v21 = 0;
    int v22 = 0x7FFFFFFF;
    int v23 = 0x7FFFFFFF;
  }
  else
  {
    v93.origin.CGFloat x = x;
    v93.origin.CGFloat y = y;
    v93.size.CGFloat width = width;
    v93.size.CGFloat height = height;
    if (CGRectIsInfinite(v93))
    {
      int v22 = -2147483647;
      unint64_t v20 = 0xFFFFFFFFLL;
      unint64_t v21 = 0xFFFFFFFFLL;
      int v23 = -2147483647;
    }
    else
    {
      v94.origin.CGFloat x = x;
      v94.origin.CGFloat y = y;
      v94.size.CGFloat width = width;
      v94.size.CGFloat height = height;
      CGRect v95 = CGRectInset(v94, 0.000001, 0.000001);
      CGRect v96 = CGRectIntegral(v95);
      int v23 = (int)v96.origin.x;
      int v22 = (int)v96.origin.y;
      unint64_t v21 = (unint64_t)v96.size.width;
      unint64_t v20 = (unint64_t)v96.size.height;
    }
  }
  if ((*(unsigned int (**)(CI::Context *))(*(void *)a3 + 16))(a3) != 77
    || ((*(uint64_t (**)(CI::Context *))(*(void *)a3 + 576))(a3) & 0x10) != 0)
  {
    if ((v23 | v22)) {
      int v18 = 0;
    }
    else {
      int v18 = v65;
    }
    int CompressionTypeOfPlane = v67;
    BOOL is_deep = v68;
    goto LABEL_36;
  }
  if (v23 == -2147483647 && v22 == -2147483647 && v21 == 0xFFFFFFFF)
  {
    unsigned int v24 = -2147483647;
    uint64_t v25 = 0xFFFFFFFFLL;
    unint64_t v26 = v20;
    if (!v20)
    {
      unint64_t v27 = 0;
      unsigned int v28 = -2147483647;
      int CompressionTypeOfPlane = v67;
      goto LABEL_31;
    }
    unint64_t v27 = v20;
    unsigned int v28 = -2147483647;
    int CompressionTypeOfPlane = v67;
    if (v26 == 0xFFFFFFFF)
    {
LABEL_31:
      BOOL v29 = 0;
      if (v23 == v28)
      {
        int v30 = v65;
        if (v22 == v24 && v21 == v25) {
          BOOL v29 = v26 == v27;
        }
      }
      else
      {
        int v30 = v65;
      }
      int v18 = (v9 && v29) & v30;
      BOOL is_deep = v68;
      goto LABEL_36;
    }
  }
  else
  {
    unint64_t v26 = v20;
    unint64_t v27 = v20;
    uint64_t v25 = v21;
    unsigned int v24 = v22;
    unsigned int v28 = v23;
    int CompressionTypeOfPlane = v67;
    if (!v21) {
      goto LABEL_31;
    }
    unint64_t v27 = v26;
    uint64_t v25 = v21;
    unsigned int v24 = v22;
    unsigned int v28 = v23;
    if (!v26) {
      goto LABEL_31;
    }
  }
  unsigned int v28 = v23 & 0xFFFFFFFE;
  unsigned int v24 = v22 & 0xFFFFFFFE;
  uint64_t v25 = (int)(v21 + v23 + 1 - (v23 & 0xFFFFFFFE | (v21 + v23 + 1) & 1));
  unint64_t v27 = (int)(v26 + v22 + 1 - (v22 & 0xFFFFFFFE | (v26 + v22 + 1) & 1));
  goto LABEL_31;
}

uint64_t CI::format_is_packed(int a1)
{
  uint64_t result = 1;
  if ((a1 - 1285) > 0x11 || ((1 << (a1 - 5)) & 0x26003) == 0)
  {
    unsigned int v3 = a1 - 1554;
    if (v3 > 4 || ((1 << v3) & 0x13) == 0) {
      return 0;
    }
  }
  return result;
}

BOOL CI::Context::format_is_supported_for_output(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 576))(a1);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  void v8[2] = ___ZNK2CI7Context30format_is_supported_for_outputENS_11PixelFormatENS_15DestinationTypeE_block_invoke;
  v8[3] = &__block_descriptor_tmp_19_2;
  void v8[4] = a1;
  int v9 = a3;
  CI::format_swizzle_for_output(a2, v6, (uint64_t)v8, v10);
  return v10[0].i32[0] != 0;
}

void CI::Context::swizzler_for_output(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, int64x2_t *a4@<X8>)
{
  int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 576))(a1);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  void v9[2] = ___ZNK2CI7Context19swizzler_for_outputENS_11PixelFormatENS_15DestinationTypeE_block_invoke;
  v9[3] = &__block_descriptor_tmp_21_0;
  v9[4] = a1;
  int v10 = a3;
  CI::format_swizzle_for_output(a2, v8, (uint64_t)v9, a4);
}

uint64_t CI::MetalContext::supported_compute_features(CI::MetalContext *this)
{
  if (*((unsigned char *)this + 458)) {
    int v1 = 15;
  }
  else {
    int v1 = 7;
  }
  return v1 | (16 * *((unsigned __int8 *)this + 459));
}

void CI::format_swizzle_for_output(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, int64x2_t *a4@<X8>)
{
  if (!a1 || !a3) {
    goto LABEL_423;
  }
  int v7 = a1;
  if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, a1))
  {
    a4->i32[1] = 0;
    a4->i32[2] = 0;
    a4->i32[0] = v7;
LABEL_425:
    unint64_t v34 = 1;
    goto LABEL_426;
  }
  if (v7 > 1792)
  {
    if (v7 <= 2304)
    {
      switch(v7)
      {
        case 1793:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797))
          {
            uint64_t v8 = 1797;
            goto LABEL_395;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1795))
          {
            uint64_t v43 = 1795;
            goto LABEL_353;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1794))
          {
            uint64_t v8 = 1794;
            goto LABEL_395;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
          {
            a4->i64[0] = 262;
            int v12 = 39;
            goto LABEL_396;
          }
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264)) {
            goto LABEL_421;
          }
          a4->i64[0] = 264;
          int v47 = 87;
          goto LABEL_408;
        case 1794:
          goto LABEL_423;
        case 1795:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)) {
            goto LABEL_308;
          }
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1794)) {
            goto LABEL_309;
          }
          uint64_t v9 = 1794;
          goto LABEL_356;
        case 1796:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
          {
            uint64_t v9 = 1798;
            goto LABEL_356;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
          {
            a4->i64[0] = 264;
            int v12 = 43;
            goto LABEL_396;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
          {
            a4->i64[0] = 266;
            int v12 = 42;
            goto LABEL_396;
          }
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800)) {
            goto LABEL_421;
          }
          uint64_t v45 = 1800;
          goto LABEL_407;
        case 1797:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1795))
          {
            uint64_t v26 = 1795;
            goto LABEL_242;
          }
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1794)) {
            goto LABEL_299;
          }
          uint64_t v44 = 1794;
          break;
        case 1798:
          goto LABEL_229;
        case 1799:
          if ((a2 & 1) == 0 || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)) {
            goto LABEL_421;
          }
          uint64_t v27 = 1797;
          goto LABEL_248;
        case 1800:
        case 1802:
        case 1803:
        case 1805:
        case 1806:
        case 1807:
        case 1808:
        case 1809:
        case 1812:
        case 1813:
          goto LABEL_421;
        case 1801:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800)) {
            goto LABEL_421;
          }
          uint64_t v28 = 1800;
          goto LABEL_274;
        case 1804:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800)) {
            goto LABEL_421;
          }
          uint64_t v29 = 1800;
          goto LABEL_251;
        case 1810:
          goto LABEL_66;
        case 1811:
          goto LABEL_100;
        case 1814:
          goto LABEL_95;
        default:
          switch(v7)
          {
            case 2049:
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053))
              {
                uint64_t v8 = 2053;
                goto LABEL_395;
              }
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2051))
              {
                uint64_t v43 = 2051;
                goto LABEL_353;
              }
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2050))
              {
                uint64_t v8 = 2050;
                goto LABEL_395;
              }
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056)) {
                goto LABEL_421;
              }
              uint64_t v51 = 2056;
              goto LABEL_415;
            case 2050:
              goto LABEL_423;
            case 2051:
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053))
              {
                uint64_t v9 = 2053;
                goto LABEL_356;
              }
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2050))
              {
                uint64_t v9 = 2050;
                goto LABEL_356;
              }
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056)) {
                goto LABEL_421;
              }
              uint64_t v48 = 2056;
              goto LABEL_399;
            case 2052:
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                uint64_t v9 = 2054;
                goto LABEL_356;
              }
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056)) {
                goto LABEL_421;
              }
              uint64_t v45 = 2056;
              goto LABEL_407;
            case 2053:
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2051))
              {
                uint64_t v26 = 2051;
                goto LABEL_242;
              }
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2050))
              {
                uint64_t v44 = 2050;
                goto LABEL_361;
              }
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056)) {
                goto LABEL_421;
              }
              uint64_t v49 = 2056;
              goto LABEL_402;
            case 2054:
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056)) {
                goto LABEL_421;
              }
              uint64_t v30 = 2056;
              goto LABEL_348;
            case 2055:
              if ((a2 & 1) == 0 || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)) {
                goto LABEL_421;
              }
              uint64_t v27 = 2053;
              goto LABEL_248;
            case 2060:
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056)) {
                goto LABEL_421;
              }
              uint64_t v29 = 2056;
              goto LABEL_251;
            case 2066:
              int v39 = CI_ENABLE_WRITE_420();
              if ((~a2 & 0xD) == 0
                && v39
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                uint64_t v11 = 0x80600000805;
                goto LABEL_257;
              }
              CI_ENABLE_WRITE_420();
              if ((~a2 & 5) != 0
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                goto LABEL_285;
              }
              uint64_t v14 = 0x80600000805;
              goto LABEL_279;
            case 2067:
              if ((~a2 & 5) != 0
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                goto LABEL_285;
              }
              uint64_t v19 = 0x80600000805;
              goto LABEL_262;
            case 2070:
              int v40 = CI_ENABLE_WRITE_420();
              if ((~a2 & 0xD) == 0
                && v40
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                uint64_t v16 = 0x80600000805;
                goto LABEL_268;
              }
              CI_ENABLE_WRITE_420();
              if ((~a2 & 5) == 0
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                uint64_t v20 = 0x80600000805;
                goto LABEL_284;
              }
LABEL_285:
              int v42 = CI_ENABLE_WRITE_420();
              if ((~a2 & 0x24) != 0
                || !v42
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                goto LABEL_421;
              }
              uint64_t v22 = 0x80600000805;
              break;
            default:
              goto LABEL_421;
          }
          goto LABEL_290;
      }
LABEL_361:
      a4->i64[0] = v44;
      int v12 = 8;
      goto LABEL_396;
    }
    if (v7 <= 3080)
    {
      if (v7 <= 2566)
      {
        switch(v7)
        {
          case 2305:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2309))
            {
              uint64_t v8 = 2309;
              goto LABEL_395;
            }
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2307))
            {
              uint64_t v43 = 2307;
              goto LABEL_353;
            }
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2306))
            {
              uint64_t v8 = 2306;
              goto LABEL_395;
            }
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312)) {
              goto LABEL_421;
            }
            uint64_t v51 = 2312;
            goto LABEL_415;
          case 2306:
            goto LABEL_423;
          case 2307:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2309))
            {
              uint64_t v9 = 2309;
              goto LABEL_356;
            }
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2306))
            {
              uint64_t v9 = 2306;
              goto LABEL_356;
            }
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312)) {
              goto LABEL_421;
            }
            uint64_t v48 = 2312;
            goto LABEL_399;
          case 2308:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2310))
            {
              uint64_t v9 = 2310;
              goto LABEL_356;
            }
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312)) {
              goto LABEL_421;
            }
            uint64_t v45 = 2312;
            goto LABEL_407;
          case 2309:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2307))
            {
              uint64_t v26 = 2307;
              goto LABEL_242;
            }
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2306))
            {
              uint64_t v44 = 2306;
              goto LABEL_361;
            }
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312)) {
              goto LABEL_421;
            }
            uint64_t v49 = 2312;
            break;
          case 2310:
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312)) {
              goto LABEL_421;
            }
            uint64_t v30 = 2312;
            goto LABEL_348;
          case 2311:
            if ((a2 & 1) == 0 || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2309)) {
              goto LABEL_421;
            }
            uint64_t v27 = 2309;
            goto LABEL_248;
          case 2313:
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312)) {
              goto LABEL_421;
            }
            uint64_t v28 = 2312;
            goto LABEL_274;
          case 2316:
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312)) {
              goto LABEL_421;
            }
            uint64_t v29 = 2312;
            goto LABEL_251;
          default:
            goto LABEL_421;
        }
LABEL_402:
        a4->i64[0] = v49;
        int v50 = 82;
        goto LABEL_416;
      }
      if (v7 > 2823)
      {
        if (v7 == 2824)
        {
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800))
          {
            size_t v36 = ci_logger_render();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
              CI::format_swizzle_for_output();
            }
            goto LABEL_423;
          }
        }
        else if (v7 == 3079)
        {
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 784))
          {
            a4->i64[0] = 784;
            int v12 = 74;
            goto LABEL_396;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 785))
          {
            a4->i64[0] = 785;
            int v12 = 75;
            goto LABEL_396;
          }
          if ((a2 & 2) != 0 && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
          {
            a4->i64[0] = 264;
            int v12 = 51;
            goto LABEL_396;
          }
        }
      }
      else if (v7 == 2567)
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 784))
        {
          a4->i64[0] = 784;
          int v12 = 69;
          goto LABEL_396;
        }
        if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 785))
        {
          a4->i64[0] = 785;
          int v12 = 70;
          goto LABEL_396;
        }
        if ((a2 & 2) != 0 && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
        {
          a4->i64[0] = 264;
          int v12 = 50;
          goto LABEL_396;
        }
      }
      else if (v7 == 2569 && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800))
      {
        a4->i64[0] = 1800;
        int v12 = 52;
LABEL_396:
        a4->i32[2] = v12;
        goto LABEL_425;
      }
      goto LABEL_421;
    }
    if (v7 > 3349)
    {
      if (v7 > 3605)
      {
        if (v7 <= 3858)
        {
          if (v7 != 3606)
          {
            if (v7 != 3858) {
              goto LABEL_421;
            }
LABEL_66:
            int v13 = CI_ENABLE_WRITE_420();
            if ((~a2 & 0xD) == 0
              && v13
              && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
              && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
            {
              uint64_t v11 = 0x70600000705;
LABEL_257:
              a4->i64[0] = v11;
              int v12 = 56;
              goto LABEL_396;
            }
            CI_ENABLE_WRITE_420();
            if ((~a2 & 5) == 0
              && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
              && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
            {
              uint64_t v14 = 0x70600000705;
              goto LABEL_279;
            }
            goto LABEL_108;
          }
LABEL_95:
          int v18 = CI_ENABLE_WRITE_420();
          if ((~a2 & 0xD) == 0
            && v18
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
          {
            uint64_t v16 = 0x70600000705;
            goto LABEL_268;
          }
          CI_ENABLE_WRITE_420();
          if ((~a2 & 5) == 0
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
          {
            uint64_t v20 = 0x70600000705;
            goto LABEL_284;
          }
LABEL_108:
          int v21 = CI_ENABLE_WRITE_420();
          if ((~a2 & 0x24) != 0
            || !v21
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
          {
            goto LABEL_421;
          }
          uint64_t v22 = 0x70600000705;
LABEL_290:
          a4->i64[0] = v22;
          int v12 = 60;
          goto LABEL_396;
        }
        if (v7 != 3859)
        {
          if (v7 != 3862) {
            goto LABEL_421;
          }
          goto LABEL_95;
        }
        goto LABEL_100;
      }
      if (v7 == 3350) {
        goto LABEL_95;
      }
      if (v7 == 3602) {
        goto LABEL_66;
      }
      if (v7 != 3603)
      {
LABEL_421:
        int v52 = ci_logger_render();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
          CI::format_swizzle_for_output(v7);
        }
LABEL_423:
        a4->i64[0] = 0;
        goto LABEL_424;
      }
LABEL_100:
      if ((~a2 & 5) != 0
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
      {
        goto LABEL_108;
      }
      uint64_t v19 = 0x70600000705;
LABEL_262:
      a4->i64[0] = v19;
      int v12 = 55;
      goto LABEL_396;
    }
    if (v7 > 3333)
    {
      if (v7 != 3334)
      {
        if (v7 == 3346) {
          goto LABEL_66;
        }
        if (v7 != 3347) {
          goto LABEL_421;
        }
        goto LABEL_100;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
      {
        uint64_t v33 = 1798;
        goto LABEL_271;
      }
LABEL_229:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        a4->i64[0] = 264;
        int v12 = 41;
        goto LABEL_396;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
      {
        a4->i64[0] = 266;
        int v12 = 40;
        goto LABEL_396;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800)) {
        goto LABEL_421;
      }
      uint64_t v30 = 1800;
LABEL_348:
      a4->i64[0] = v30;
      int v47 = 81;
    }
    else
    {
      if (v7 == 3081)
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800))
        {
          int v35 = ci_logger_render();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
            CI::format_swizzle_for_output();
          }
          goto LABEL_423;
        }
        goto LABEL_421;
      }
      if (v7 == 3331)
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 3333))
        {
          uint64_t v9 = 3333;
        }
        else
        {
LABEL_307:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797))
          {
LABEL_309:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
            {
              a4->i64[0] = 262;
              int v12 = 38;
              goto LABEL_396;
            }
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264)) {
              goto LABEL_421;
            }
            a4->i64[0] = 264;
            int v47 = 86;
            goto LABEL_408;
          }
LABEL_308:
          uint64_t v9 = 1797;
        }
LABEL_356:
        a4->i64[0] = v9;
        int v12 = 62;
        goto LABEL_396;
      }
      if (v7 != 3333) {
        goto LABEL_421;
      }
LABEL_193:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797))
      {
        uint64_t v33 = 1797;
LABEL_271:
        a4->i64[0] = v33;
LABEL_424:
        a4->i32[2] = 0;
        goto LABEL_425;
      }
LABEL_299:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        a4->i64[0] = 262;
        int v12 = 37;
        goto LABEL_396;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264)) {
        goto LABEL_421;
      }
      a4->i64[0] = 264;
      int v47 = 85;
    }
LABEL_408:
    a4->i32[2] = v47;
    int64x2_t v37 = (int64x2_t)xmmword_193959660;
    goto LABEL_417;
  }
  if (v7 > 770)
  {
    if (v7 <= 1041)
    {
      switch(v7)
      {
        case 771:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 773))
          {
            uint64_t v9 = 773;
            goto LABEL_356;
          }
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)) {
            goto LABEL_307;
          }
          a4->i64[0] = 1797;
          int v12 = 80;
          goto LABEL_396;
        case 773:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)) {
            goto LABEL_193;
          }
          uint64_t v32 = 1797;
          goto LABEL_197;
        case 774:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798)) {
            goto LABEL_229;
          }
          uint64_t v32 = 1798;
LABEL_197:
          a4->i64[0] = v32;
          int v12 = 79;
          goto LABEL_396;
        case 775:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 784))
          {
            uint64_t v29 = 784;
LABEL_251:
            a4->i64[0] = v29;
            int v12 = 10;
            goto LABEL_396;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 785))
          {
            uint64_t v46 = 785;
LABEL_331:
            a4->i64[0] = v46;
            int v12 = 11;
            goto LABEL_396;
          }
          if ((a2 & 2) != 0 && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
          {
            a4->i64[0] = 264;
            int v12 = 47;
            goto LABEL_396;
          }
          goto LABEL_421;
        case 784:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 785))
          {
            uint64_t v31 = 785;
            goto LABEL_204;
          }
          if ((a2 & 2) == 0 || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264)) {
            goto LABEL_421;
          }
          a4->i64[0] = 264;
          int v12 = 49;
          goto LABEL_396;
        case 785:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 784))
          {
            uint64_t v31 = 784;
LABEL_204:
            a4->i64[0] = v31;
            unint64_t v34 = 1;
            a4->i32[2] = 1;
            goto LABEL_426;
          }
          if ((a2 & 2) != 0 && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
          {
            a4->i64[0] = 264;
            int v12 = 48;
            goto LABEL_396;
          }
          break;
        case 786:
          goto LABEL_66;
        case 787:
          goto LABEL_100;
        case 790:
          goto LABEL_95;
        default:
          goto LABEL_421;
      }
      goto LABEL_421;
    }
    if (v7 <= 1298)
    {
      if (v7 <= 1045)
      {
        if (v7 == 1042) {
          goto LABEL_66;
        }
        if (v7 != 1043) {
          goto LABEL_421;
        }
        goto LABEL_100;
      }
      if (v7 == 1046) {
        goto LABEL_95;
      }
      if (v7 != 1298) {
        goto LABEL_421;
      }
    }
    else
    {
      if (v7 <= 1553)
      {
        if (v7 != 1299)
        {
          if (v7 != 1302) {
            goto LABEL_421;
          }
          goto LABEL_77;
        }
LABEL_122:
        if ((~a2 & 5) != 0
          || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
          || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
        {
          int v25 = CI_ENABLE_WRITE_420();
          if ((~a2 & 0x24) != 0
            || !v25
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
          {
            goto LABEL_421;
          }
          uint64_t v22 = 0x50600000505;
          goto LABEL_290;
        }
        uint64_t v19 = 0x50600000505;
        goto LABEL_262;
      }
      if (v7 != 1554)
      {
        if (v7 != 1555)
        {
          if (v7 != 1558) {
            goto LABEL_421;
          }
LABEL_77:
          int v15 = CI_ENABLE_WRITE_420();
          if ((~a2 & 0xD) == 0
            && v15
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
          {
            uint64_t v16 = 0x50600000505;
LABEL_268:
            a4->i64[0] = v16;
            int v12 = 57;
            goto LABEL_396;
          }
          CI_ENABLE_WRITE_420();
          if ((~a2 & 5) != 0
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
          {
            goto LABEL_421;
          }
          uint64_t v20 = 0x50600000505;
LABEL_284:
          a4->i64[0] = v20;
          a4->i32[2] = 54;
          int64x2_t v41 = (int64x2_t)xmmword_193959660;
LABEL_427:
          a4[1] = v41;
          a4[2] = v41;
          return;
        }
        goto LABEL_122;
      }
    }
    int v17 = CI_ENABLE_WRITE_420();
    if ((~a2 & 0xD) == 0
      && v17
      && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
      && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
    {
      uint64_t v11 = 0x50600000505;
      goto LABEL_257;
    }
    CI_ENABLE_WRITE_420();
    if ((~a2 & 5) != 0
      || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
      || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
    {
      goto LABEL_421;
    }
    uint64_t v14 = 0x50600000505;
LABEL_279:
    a4->i64[0] = v14;
    a4->i32[2] = 53;
    unint64_t v34 = 2;
LABEL_426:
    int64x2_t v41 = vdupq_n_s64(v34);
    goto LABEL_427;
  }
  switch(v7)
  {
    case 257:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261))
      {
        uint64_t v8 = 261;
LABEL_395:
        a4->i64[0] = v8;
        int v12 = 7;
        goto LABEL_396;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 259))
      {
        uint64_t v43 = 259;
LABEL_353:
        a4->i64[0] = v43;
        int v12 = 26;
        goto LABEL_396;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 258))
      {
        uint64_t v8 = 258;
        goto LABEL_395;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264)) {
        goto LABEL_421;
      }
      uint64_t v51 = 264;
LABEL_415:
      a4->i64[0] = v51;
      int v50 = 84;
LABEL_416:
      a4->i32[2] = v50;
      int64x2_t v37 = (int64x2_t)xmmword_193959680;
LABEL_417:
      int64x2_t v38 = vdupq_n_s64(1uLL);
LABEL_418:
      a4[1] = v37;
      a4[2] = v38;
      return;
    case 258:
      goto LABEL_423;
    case 259:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261))
      {
        uint64_t v9 = 261;
        goto LABEL_356;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 258))
      {
        uint64_t v9 = 258;
        goto LABEL_356;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264)) {
        goto LABEL_421;
      }
      uint64_t v48 = 264;
LABEL_399:
      a4->i64[0] = v48;
      int v50 = 83;
      goto LABEL_416;
    case 260:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        uint64_t v9 = 262;
        goto LABEL_356;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264)) {
        goto LABEL_421;
      }
      uint64_t v45 = 264;
LABEL_407:
      a4->i64[0] = v45;
      int v47 = 88;
      goto LABEL_408;
    case 261:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 259))
      {
        uint64_t v26 = 259;
LABEL_242:
        a4->i64[0] = v26;
        int v12 = 21;
        goto LABEL_396;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 258))
      {
        uint64_t v44 = 258;
        goto LABEL_361;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        uint64_t v49 = 264;
        goto LABEL_402;
      }
      goto LABEL_421;
    case 262:
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264)) {
        goto LABEL_421;
      }
      uint64_t v30 = 264;
      goto LABEL_348;
    case 263:
      if ((a2 & 1) == 0 || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)) {
        goto LABEL_421;
      }
      uint64_t v27 = 261;
LABEL_248:
      a4->i64[0] = v27;
      a4->i32[2] = 46;
      int64x2_t v37 = vdupq_n_s64(1uLL);
      int64x2_t v38 = (int64x2_t)xmmword_193959670;
      goto LABEL_418;
    case 264:
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266)) {
        goto LABEL_421;
      }
      uint64_t v31 = 266;
      goto LABEL_204;
    case 265:
LABEL_272:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        uint64_t v28 = 264;
LABEL_274:
        a4->i64[0] = v28;
        int v12 = 3;
      }
      else
      {
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266)) {
          goto LABEL_421;
        }
        a4->i64[0] = 266;
        int v12 = 5;
      }
      goto LABEL_396;
    case 266:
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264)) {
        goto LABEL_421;
      }
      uint64_t v31 = 264;
      goto LABEL_204;
    case 267:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        a4->i64[0] = 264;
        int v12 = 2;
        goto LABEL_396;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266)) {
        goto LABEL_421;
      }
      a4->i64[0] = 266;
      int v12 = 6;
      goto LABEL_396;
    case 268:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        uint64_t v29 = 264;
        goto LABEL_251;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266)) {
        goto LABEL_421;
      }
      uint64_t v46 = 266;
      goto LABEL_331;
    case 269:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 265))
      {
        uint64_t v29 = 265;
        goto LABEL_251;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        a4->i64[0] = 264;
        int v12 = 17;
        goto LABEL_396;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266)) {
        goto LABEL_421;
      }
      a4->i64[0] = 266;
      int v12 = 19;
      goto LABEL_396;
    case 270:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
      {
        uint64_t v29 = 266;
        goto LABEL_251;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264)) {
        goto LABEL_421;
      }
      uint64_t v46 = 264;
      goto LABEL_331;
    case 271:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 267))
      {
        uint64_t v29 = 267;
        goto LABEL_251;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        a4->i64[0] = 264;
        int v12 = 16;
        goto LABEL_396;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266)) {
        goto LABEL_421;
      }
      a4->i64[0] = 266;
      int v12 = 18;
      goto LABEL_396;
    case 272:
    case 273:
    case 276:
    case 277:
      goto LABEL_421;
    case 274:
LABEL_44:
      int v10 = CI_ENABLE_WRITE_420();
      if ((~a2 & 0xD) == 0
        && v10
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        uint64_t v11 = 0x10600000105;
        goto LABEL_257;
      }
      CI_ENABLE_WRITE_420();
      if ((~a2 & 5) != 0
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        goto LABEL_134;
      }
      uint64_t v14 = 0x10600000105;
      goto LABEL_279;
    case 275:
LABEL_113:
      if ((~a2 & 5) != 0
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        goto LABEL_134;
      }
      uint64_t v19 = 0x10600000105;
      goto LABEL_262;
    case 278:
LABEL_117:
      int v23 = CI_ENABLE_WRITE_420();
      if ((~a2 & 0xD) == 0
        && v23
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        uint64_t v16 = 0x10600000105;
        goto LABEL_268;
      }
      CI_ENABLE_WRITE_420();
      if ((~a2 & 5) == 0
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        uint64_t v20 = 0x10600000105;
        goto LABEL_284;
      }
LABEL_134:
      int v24 = CI_ENABLE_WRITE_420();
      if ((~a2 & 0x24) != 0
        || !v24
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        goto LABEL_421;
      }
      uint64_t v22 = 0x10600000105;
      goto LABEL_290;
    default:
      switch(v7)
      {
        case 530:
          goto LABEL_44;
        case 531:
          goto LABEL_113;
        case 534:
          goto LABEL_117;
        case 535:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 265)) {
            goto LABEL_272;
          }
          uint64_t v33 = 265;
          break;
        default:
          goto LABEL_421;
      }
      goto LABEL_271;
  }
}

uint64_t CI::MetalContext::format_is_directly_supported_for_output(id *a1, int a2)
{
  uint64_t result = 1;
  if (a2 <= 1297)
  {
    if (a2 <= 772)
    {
      if ((a2 - 261) > 0x11) {
        goto LABEL_7;
      }
      int v4 = 1 << (a2 - 5);
      if ((v4 & 0x2B) != 0) {
        return result;
      }
      if ((v4 & 0x22000) == 0)
      {
LABEL_7:
        if (a2 != 530 && a2 != 534) {
          return 0;
        }
      }
      goto LABEL_28;
    }
    if (a2 > 785)
    {
      if ((a2 - 1285) >= 2)
      {
        if (a2 != 786 && a2 != 1042) {
          return 0;
        }
LABEL_28:
        return CI::MetalContext::use_imageblocks_for_format((uint64_t)a1, a2);
      }
    }
    else if ((a2 - 773) >= 2 && (a2 - 784) >= 2)
    {
      return 0;
    }
    goto LABEL_38;
  }
  if (a2 > 2308)
  {
    if (a2 > 2566)
    {
      if (a2 > 3078)
      {
        if (a2 != 3081 && a2 != 3079) {
          return 0;
        }
      }
      else if (a2 != 2567 && a2 != 2569)
      {
        return 0;
      }
LABEL_38:
      unsigned int v6 = CIMetalFormatForFormat(a2, 0);
      return CI::MetalContext::formatIsWritable(a1, v6);
    }
    unsigned int v5 = a2 - 2309;
  }
  else
  {
    if (a2 <= 2052)
    {
      if ((a2 - 1797) <= 3 && a2 != 1799) {
        return result;
      }
      if (a2 != 1298 && a2 != 1554) {
        return 0;
      }
      goto LABEL_28;
    }
    unsigned int v5 = a2 - 2053;
  }
  if (v5 > 3 || v5 == 2) {
    return 0;
  }
  return result;
}

uint64_t ___ZNK2CI7Context19swizzler_for_outputENS_11PixelFormatENS_15DestinationTypeE_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 32) + 432))(*(void *)(a1 + 32), a2, *(unsigned int *)(a1 + 40));
}

uint64_t ___ZNK2CI7Context30format_is_supported_for_outputENS_11PixelFormatENS_15DestinationTypeE_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 32) + 432))(*(void *)(a1 + 32), a2, *(unsigned int *)(a1 + 40));
}

void CI::ProgramNode::create_program_and_arguments(CI::ProgramNode *this, CI::Context *a2, const char *a3)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    unsigned int v5 = ci_signpost_log_render();
    os_signpost_id_t v6 = *((int *)this + 9) | (unint64_t)((*(uint64_t (**)(CI::Context *))(*(void *)a2 + 272))(a2) << 32);
    if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
    {
      *(_WORD *)CGRect buf = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v6, "create_program_and_arguments", "", buf, 2u);
    }
  }
  uint64_t v7 = (*(uint64_t (**)(CI::Context *))(*(void *)a2 + 272))(a2);
  TimerBase::TimerBase((uint64_t)v9, v7, *((_DWORD *)this + 9), (uint64_t)"create_program_and_arguments", 37);
  operator new();
}

uint64_t CI::Context::findCachedMainProgram(uint64_t a1, uint64_t a2)
{
  return CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::find(*(void *)(a1 + 304), a2);
}

uint64_t CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::find(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  os_signpost_id_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE4findES2__block_invoke;
  block[3] = &unk_1E5773F38;
  void block[5] = a1;
  void block[6] = a2;
  void block[4] = &v5;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 56), block);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

unint64_t CI::ProgramNode::compute_kernel_digest(CI::ProgramNode *this, const CI::Context *a2)
{
  uint64_t v16 = 0;
  int v17 = &v16;
  uint64_t v18 = 0x8002000000;
  uint64_t v19 = __Block_byref_object_copy__26;
  uint64_t v20 = __Block_byref_object_dispose__26;
  XXH64_reset(v21, 0);
  v15[0] = 0;
  v15[1] = v15;
  _OWORD v15[2] = 0x2000000000;
  v15[3] = 0;
  v12[0] = 0;
  v12[1] = v12;
  _OWORD v12[2] = 0x4002000000;
  v12[3] = __Block_byref_object_copy__69;
  v14[0] = 0;
  v14[1] = 0;
  v12[4] = __Block_byref_object_dispose__70;
  int v13 = v14;
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 0x40000000;
  v11[2] = ___ZNK2CI11ProgramNode21compute_kernel_digestEPKNS_7ContextE_block_invoke;
  void v11[3] = &unk_1E5775540;
  v11[4] = v12;
  v11[5] = v15;
  v11[6] = &v16;
  v11[7] = this;
  CI::ProgramNode::traverse_graph_preorder_stoppable((uint64_t)this, (uint64_t)v11);
  uint64_t v4 = (uint64_t)(v17 + 5);
  uint64_t __src = CI::Node::unique_child_count(this);
  XXH64_update(v4, (char *)&__src, 8uLL);
  LODWORD(__src) = *((unsigned char *)this + 144) & 1;
  XXH64_update((uint64_t)(v17 + 5), (char *)&__src, 4uLL);
  if (CI_ENABLE_METAL_IMAGEBLOCKS() == 2
    && (*(unsigned int (**)(const CI::Context *))(*(void *)a2 + 16))(a2) == 77)
  {
    int v6 = *((_DWORD *)this + 35);
    uint64_t v5 = (char *)this + 140;
    if (CI::MetalContext::use_imageblocks_for_format((uint64_t)a2, v6))
    {
      p_src = v5;
      size_t v8 = 8;
    }
    else
    {
      LODWORD(__src) = 0;
      p_src = (char *)&__src;
      size_t v8 = 4;
    }
    XXH64_update((uint64_t)(v17 + 5), p_src, v8);
  }
  unint64_t v9 = XXH64_digest((uint64_t)(v17 + 5));
  _Block_object_dispose(v12, 8);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v13, v14[0]);
  _Block_object_dispose(v15, 8);
  _Block_object_dispose(&v16, 8);
  return v9;
}

uint64_t CI::MetalContext::use_imageblocks_for_format(uint64_t a1, int a2)
{
  uint64_t result = CI_ENABLE_METAL_IMAGEBLOCKS();
  if (result)
  {
    if (!*(unsigned char *)(a1 + 457)) {
      return 0;
    }
    uint64_t result = 0;
    if (a2 > 529)
    {
      if (a2 != 530 && a2 != 2066 && a2 != 534) {
        return result;
      }
      return CI_ENABLE_METAL_IMAGEBLOCKS() == 2;
    }
    if (a2 == 274 || a2 == 278) {
      return CI_ENABLE_METAL_IMAGEBLOCKS() == 2;
    }
  }
  return result;
}

uint64_t CI_ENABLE_METAL_IMAGEBLOCKS()
{
  {
    CI_ENABLE_METAL_IMAGEBLOCKS::v = get_int("CI_ENABLE_METAL_IMAGEBLOCKS", 0);
  }
  return CI_ENABLE_METAL_IMAGEBLOCKS::v;
}

void sub_1936BDDA0(_Unwind_Exception *a1)
{
}

uint64_t CI_ENABLE_WRITE_420()
{
  {
    CI_ENABLE_WRITE_420::v = get_BOOL("CI_ENABLE_WRITE_420", 1);
  }
  return CI_ENABLE_WRITE_420::v;
}

void sub_1936BDE20(_Unwind_Exception *a1)
{
}

void CI::ProgramNode::dispatch_main_program_args(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  if (CI_ASYNC_KERNEL_COMPILE() && *(_DWORD *)(a2 + 344) != 1)
  {
    if (a4) {
      (*(void (**)(uint64_t))(a4 + 16))(a4);
    }
    uint64_t v11 = (dispatch_queue_t *)(a1 + 104);
    Queue::execute_async(v11, a3);
    if (a5)
    {
      Queue::execute_async(v11, a5);
    }
  }
  else
  {
    int v10 = (void (*)(void *))a3[2];
    v10(a3);
  }
}

void Queue::execute_async(dispatch_queue_t *a1, void *a2)
{
  qos_class_t v4 = qos_class_self();
  dispatch_block_t v5 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v4, 0, a2);
  dispatch_async(*a1, v5);

  _Block_release(v5);
}

uint64_t CI_ASYNC_KERNEL_COMPILE()
{
  {
    CI_ASYNC_KERNEL_COMPILE::v = get_int("CI_ASYNC_KERNEL_COMPILE", 2);
  }
  return CI_ASYNC_KERNEL_COMPILE::v;
}

void sub_1936BDFD8(_Unwind_Exception *a1)
{
}

uint64_t CI::format_is_ycc_full_range(int a1)
{
  uint64_t result = 1;
  if (a1 <= 1809)
  {
    if ((a1 - 274) < 5 || (a1 - 786) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0) {
      return result;
    }
    unsigned int v3 = a1 - 1298;
    goto LABEL_8;
  }
  if (((a1 - 1810) > 4 || ((1 << (a1 - 18)) & 0x13) == 0)
    && ((a1 - 2066) > 4 || ((1 << (a1 - 18)) & 0x13) == 0))
  {
    unsigned int v3 = a1 - 3346;
LABEL_8:
    if (v3 > 4 || ((1 << v3) & 0x13) == 0) {
      return 0;
    }
  }
  return result;
}

uint64_t CI::format_is_ycc_444(int a1)
{
  HIDWORD(v1) = a1 - 275;
  LODWORD(v1) = a1 - 275;
  return ((v1 >> 8) < 0xF) & (0x70FFu >> ((unsigned __int16)(a1 - 275) >> 8));
}

uint64_t CI::format_is_ycc_422(int a1)
{
  uint64_t result = 1;
  if (a1 <= 1045)
  {
    if ((a1 - 276) >= 3 && (a1 - 532) >= 3 && a1 != 790) {
      return 0;
    }
  }
  else if (a1 > 2069)
  {
    if (a1 > 3605)
    {
      if (a1 != 3606 && a1 != 3862) {
        return 0;
      }
    }
    else if (a1 != 2070 && a1 != 3350)
    {
      return 0;
    }
  }
  else
  {
    if (a1 <= 1557)
    {
      if (a1 == 1046 || a1 == 1302) {
        return result;
      }
      return 0;
    }
    if (a1 != 1558 && a1 != 1814) {
      return 0;
    }
  }
  return result;
}

uint64_t CI::format_is_ycc_420(int a1)
{
  HIDWORD(v1) = a1 - 274;
  LODWORD(v1) = a1 - 274;
  return ((v1 >> 8) < 0xF) & (0x70FFu >> ((unsigned __int16)(a1 - 274) >> 8));
}

uint64_t ___ZN2CI11ProgramNode28create_program_and_argumentsEPNS_7ContextEPKc_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    CI::Object::ref(v2);
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    return CI::Object::ref(result);
  }
  return result;
}

CFIndex CI::Bitmap::length(CI::Bitmap *this)
{
  if (*((void *)this + 5))
  {
    CFDataRef v1 = (const __CFData *)*((void *)this + 5);
    return CFDataGetLength(v1);
  }
  else
  {
    uint64_t v3 = *((void *)this + 10);
    uint64_t v4 = (*((void *)this + 11) - 1) * *((void *)this + 12);
    return v4 + v3 * (int)CI::format_bytes_per_pixel(*((_DWORD *)this + 26));
  }
}

void *CIMetalTextureCreate(uint64_t a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6)
{
  if (!a3) {
    return 0;
  }
  TextureDescriptor = CreateTextureDescriptor(a3, a4, a5, a6);
  int v10 = TextureDescriptor;
  if (a6 == 3) {
    [TextureDescriptor setStorageMode:2];
  }
  uint64_t v11 = (void *)[a2 newTextureWithDescriptor:v10];
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v11, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  return v11;
}

id ___ZL11defaultCubev_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v1[4] = xmmword_193950910;
  void v1[5] = unk_193950920;
  v1[6] = xmmword_193950930;
  v1[7] = unk_193950940;
  v1[0] = xmmword_1939508D0;
  v1[1] = unk_1939508E0;
  v1[2] = xmmword_1939508F0;
  v1[3] = unk_193950900;
  id result = (id)[MEMORY[0x1E4F1C9B8] dataWithBytes:v1 length:128];
  defaultCube(void)::data = (uint64_t)result;
  return result;
}

uint64_t ___ZN2CI16MetalMainProgram12compileAsyncENS_9NodeIndexE_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (!*(void *)(result + 160) && *(double *)(result + 24) == 0.0) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 80))(result, *(unsigned int *)(a1 + 40));
  }
  return result;
}

void CI::ProgramNode::~ProgramNode(CI::ProgramNode *this)
{
  CI::ProgramNode::~ProgramNode(this);

  JUMPOUT(0x1997023B0);
}

{
  NSObject **v2;
  CI::Object *v3;
  CI::SerialStringArray *v4;
  CI::SerialObjectPtrArray *v5;
  CI::SerialStringArray *v6;
  uint64_t vars8;

  *(void *)this = &unk_1EE457CE8;
  *((void *)this + 5) = &unk_1EE457E98;
  uint64_t v2 = (NSObject **)((char *)this + 104);
  dispatch_sync(*((dispatch_queue_t *)this + 13), &__block_literal_global_171);
  CI::ProgramNode::release_program_and_arguments(this);
  uint64_t v3 = (CI::Object *)*((void *)this + 6);
  if (v3) {
    CI::Object::unref(v3);
  }
  uint64_t v4 = (CI::SerialStringArray *)*((void *)this + 7);
  *((void *)this + 6) = 0;
  if (v4)
  {
    CI::SerialStringArray::~SerialStringArray(v4);
    MEMORY[0x1997023B0]();
  }
  dispatch_block_t v5 = (CI::SerialObjectPtrArray *)*((void *)this + 8);
  if (v5)
  {
    CI::SerialObjectPtrArray::~SerialObjectPtrArray(v5);
    MEMORY[0x1997023B0]();
  }
  int v6 = (CI::SerialStringArray *)*((void *)this + 9);
  if (v6)
  {
    CI::SerialStringArray::~SerialStringArray(v6);
    MEMORY[0x1997023B0]();
  }
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  Queue::~Queue(v2);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)this + 80, *((void **)this + 11));
  *((void *)this + 5) = &unk_1EE45B048;
  atomic_fetch_add(&dword_1EB466E78[50], 0xFFFFFFFF);

  CI::Node::~Node(this);
}

void CI::SerialStringArray::~SerialStringArray(CI::SerialStringArray *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 4);
  if (v3) {
    free(v3);
  }
}

void Queue::~Queue(NSObject **this)
{
  uint64_t v2 = *this;
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = this[1];
  if (v3) {
    dispatch_release(v3);
  }
}

void ___ZN2CI14TextureManager29release_intermediate_for_nodeERKNS_6roiKeyEb_block_invoke(void *a1)
{
  uint64_t v1 = a1[6];
  uint64_t v4 = *(void **)(v1 + 152);
  uint64_t v2 = v1 + 152;
  uint64_t v3 = v4;
  if (v4)
  {
    int v6 = (uint64_t **)(v2 - 8);
    unint64_t v7 = a1[7];
    uint64_t v8 = v2;
    do
    {
      unint64_t v9 = v3[4];
      BOOL v10 = v9 >= v7;
      if (v9 >= v7) {
        uint64_t v11 = v3;
      }
      else {
        uint64_t v11 = v3 + 1;
      }
      if (v10) {
        uint64_t v8 = (uint64_t)v3;
      }
      uint64_t v3 = (void *)*v11;
    }
    while (*v11);
    if (v8 != v2 && v7 >= *(void *)(v8 + 32))
    {
      uint64_t v12 = *(void *)(v8 + 48);
      if (v12)
      {
        int v13 = *(_DWORD *)(a1[8] + 8);
        uint64_t v14 = v8 + 48;
        do
        {
          int v15 = *(_DWORD *)(v12 + 32);
          BOOL v16 = v15 < v13;
          if (v15 >= v13) {
            int v17 = (uint64_t *)v12;
          }
          else {
            int v17 = (uint64_t *)(v12 + 8);
          }
          if (!v16) {
            uint64_t v14 = v12;
          }
          uint64_t v12 = *v17;
        }
        while (*v17);
        if (v14 != v8 + 48 && v13 >= *(_DWORD *)(v14 + 32))
        {
          *(void *)(*(void *)(a1[4] + 8) + 24) = *(void *)(v14 + 40);
          uint64_t v18 = *(uint64_t (****)(void))(*(void *)(a1[4] + 8) + 24);
          *(void *)(*(void *)(a1[5] + 8) + 24) = (**v18)(v18);
          uint64_t v19 = *(void *)(*(void *)(a1[5] + 8) + 24);
          if (v19) {
            ReturnSurfaceToCache(v19);
          }
          uint64_t v20 = *(void *)(*(void *)(a1[4] + 8) + 24);
          --*(void *)(v20 + 64);
          uint64_t v21 = *(void *)(*(void *)(a1[4] + 8) + 24);
          if ((*(uint64_t (**)(uint64_t))(*(void *)v21 + 16))(v21) == 1)
          {
            std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__remove_node_pointer((uint64_t **)(v8 + 40), (uint64_t *)v14);
            operator delete((void *)v14);
          }
        }
      }
      if (!*(void *)(v8 + 56))
      {
        std::__tree<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>>>::erase(v6, v8);
      }
    }
  }
}

uint64_t ___ZL13CoreAnalyticsP8NSStringP9CIContext_block_invoke_2(uint64_t a1)
{
  v16[8] = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = (const __CFString *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "mainBundle"), "bundleIdentifier");
  uint64_t v3 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "mainBundle"), "bundlePath"), "pathExtension");
  CFStringRef v4 = CoreAnayticsAppIndentifier(v2);
  dispatch_block_t v5 = (void *)[MEMORY[0x1E4F22448] extensionPointRecordForCurrentProcess];
  if (v5) {
    uint64_t v6 = [v5 identifier];
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t result = [*(id *)(a1 + 32) _internalContext];
  if (result)
  {
    uint64_t v8 = result;
    v15[0] = @"identifier";
    v15[1] = @"extension";
    unint64_t v9 = &stru_1EE465CC0;
    if (v2) {
      BOOL v10 = (__CFString *)v2;
    }
    else {
      BOOL v10 = &stru_1EE465CC0;
    }
    if (v3) {
      uint64_t v11 = (__CFString *)v3;
    }
    else {
      uint64_t v11 = &stru_1EE465CC0;
    }
    if (v6) {
      uint64_t v11 = (__CFString *)v6;
    }
    v16[0] = v10;
    v16[1] = v11;
    if (v4) {
      unint64_t v9 = (__CFString *)v4;
    }
    _OWORD v15[2] = @"client";
    v15[3] = @"contextMethod";
    uint64_t v12 = *(void *)(a1 + 40);
    void v16[2] = v9;
    v16[3] = v12;
    void v15[4] = @"cacheIntermediates";
    if ((*(unsigned int (**)(uint64_t))(*(void *)result + 232))(result) == -1) {
      int v13 = &unk_1EE4AA5E0;
    }
    else {
      int v13 = &unk_1EE4AA5F8;
    }
    v16[4] = v13;
    void v15[5] = @"workingFormat";
    void v16[5] = [NSString stringWithUTF8String:CI::name_for_format(*(_DWORD *)(v8 + 32))];
    v15[6] = @"backing";
    v16[6] = [NSString stringWithUTF8String:(*(uint64_t (**)(uint64_t))(*(void *)v8 + 304))(v8)];
    v15[7] = @"coreui";
    if (!strcmp((const char *)(v8 + 236), "CoreUI")) {
      uint64_t v14 = &unk_1EE4AA5F8;
    }
    else {
      uint64_t v14 = &unk_1EE4AA5E0;
    }
    v16[7] = v14;
    return [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v16 forKeys:v15 count:8];
  }
  return result;
}

void ___ZL31defaultIntermediateMemoryTargetv_block_invoke()
{
  id v0 = CIMetalCopyDefaultDevice();
  if (CIMetalDeviceIsA9OrHigher(v0, v1))
  {
    if (objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "mainBundle"), "bundleIdentifier"))
    {
      CFStringRef v2 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "mainBundle"), "infoDictionary");
      if (v2)
      {
        uint64_t v3 = v2;
        if (![v2 objectForKeyedSubscript:@"NSExtension"])
        {
          CFStringRef v4 = (void *)[v3 objectForKeyedSubscript:@"CFBundlePackageType"];
          if (v4)
          {
            if ([v4 containsString:@"APPL"]) {
              defaultIntermediateMemoryTarget(void)::targetMB = 1;
            }
          }
        }
      }
    }
  }
  if (v0)
  {
    CFRelease(v0);
  }
}

void ___ZN2CI11ProgramNode28create_program_and_argumentsEPNS_7ContextEPKc_block_invoke_4(uint64_t a1)
{
  CFStringRef v2 = *(CI::Object **)(a1 + 32);
  if (v2) {
    CI::Object::unref(v2);
  }
  uint64_t v3 = *(CI::Object **)(a1 + 40);
  if (v3)
  {
    CI::Object::unref(v3);
  }
}

void ___ZN2CI19MetalTextureManager19purge_intermediatesEm_block_invoke(uint64_t a1)
{
  CFStringRef v2 = *(CI::TextureManager **)(a1 + 32);
  if (CI_RECYCLE_METAL_TEXTURES() && CI_IOSURFACE_INTERMEDIATES())
  {
    uint64_t v3 = *((void *)v2 + 13);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN2CI19MetalTextureManager19purge_intermediatesEm_block_invoke_2;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    uint64_t v4 = *(void *)(a1 + 40);
    v5[4] = v2;
    int64x2_t v5[5] = v4;
    dispatch_sync(v3, v5);
  }
  CI::TextureManager::purge_intermediates(v2);
}

void CI::TextureManager::purge_intermediates(CI::TextureManager *this)
{
  uint64_t v1 = *((void *)this + 13);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI14TextureManager19purge_intermediatesEm_block_invoke;
  block[3] = &__block_descriptor_tmp_10_4;
  void block[4] = this;
  dispatch_sync(v1, block);
}

uint64_t ___ZN2CI7Context23render_completion_queueEv_block_invoke()
{
  id v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  CI::Context::render_completion_queue(void)::sRenderCompletionQueue = (uint64_t)dispatch_queue_create("CI::RenderCompletionQueue", v0);
  if ((CI_PRINT_TREE_dump_intermediates() & 1) != 0 || (uint64_t result = CI_PRINT_TREE_dump_outputs(), result))
  {
    return atexit_b(&__block_literal_global_5_3);
  }
  return result;
}

void ___ZN2CI23image_render_to_surfaceEPNS_7ContextEPNS_5ImageE6CGRectP11__IOSurfacePKNS_17RenderDestinationE_block_invoke(uint64_t a1, CI::ProgramNode *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v6.origin.CGFloat x = a3;
  v6.origin.CGFloat y = a4;
  v6.size.CGFloat width = a5;
  v6.size.CGFloat height = a6;
  CI::Context::render(*(CI::Context **)(a1 + 32), a2, &v6);
}

uint64_t CI_PRINT_TREE_dump_outputs()
{
  {
    CI_PRINT_TREE_dump_outputs::v = CI_PRINT_TREE_has_string("dump-outputs") != 0;
  }
  return CI_PRINT_TREE_dump_outputs::v;
}

void sub_1936BEED4(_Unwind_Exception *a1)
{
}

void CI::MetalContext::after_render(CI::MetalContext *this)
{
  CFStringRef v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = (*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this) << 32;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_signpost_emit_with_name_impl(&dword_193671000, v2, OS_SIGNPOST_INTERVAL_BEGIN, v3, "after_render", "", v7, 2u);
  }
  uint64_t v4 = (*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this);
  TimerBase::TimerBase((uint64_t)v7, v4, 0, (uint64_t)"after_render", 8);
  *((_OWORD *)this + 112) = 0u;
  CI::TextureManager::remove_all(*((CI::TextureManager **)this + 227));
  uint64_t v5 = *((void *)this + 227);
  if (CI_RECYCLE_METAL_TEXTURES()) {
    uint64_t v6 = CI_INTERMEDIATE_CACHE_SIZE();
  }
  else {
    uint64_t v6 = 0;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 64))(v5, v6);
  CI::MetalContext::after_render(void)::SignpostTimer::~SignpostTimer((TimerBase *)v7);
}

void sub_1936BF04C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t CI_RECYCLE_METAL_TEXTURES()
{
  {
    CI_RECYCLE_METAL_TEXTURES::v = get_BOOL("CI_RECYCLE_METAL_TEXTURES", 0);
  }
  return CI_RECYCLE_METAL_TEXTURES::v;
}

void sub_1936BF0C8(_Unwind_Exception *a1)
{
}

void CI::MetalContext::after_render(void)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  CFStringRef v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = *((void *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "after_render", "", v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1936BF16C(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void CI::MetalTextureManager::purge_intermediates(CI::MetalTextureManager *this, uint64_t a2)
{
  CFStringRef v2 = *((void *)this + 12);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN2CI19MetalTextureManager19purge_intermediatesEm_block_invoke;
  _OWORD v3[3] = &__block_descriptor_48_e5_v8__0l;
  void v3[4] = this;
  void v3[5] = a2;
  dispatch_async(v2, v3);
}

void CI::TextureManager::remove_all(CI::TextureManager *this)
{
  uint64_t v1 = *((void *)this + 13);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI14TextureManager10remove_allEv_block_invoke;
  block[3] = &__block_descriptor_tmp_6_6;
  void block[4] = this;
  dispatch_sync(v1, block);
}

void ___ZN2CI22image_render_to_bitmapEPNS_7ContextEPNS_5ImageE6CGRectP12CGColorSpacePNS_6BitmapEPKNS_17RenderDestinationE_block_invoke(uint64_t a1, CI::ProgramNode *this, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  v44[0] = 0x3FF0000000000000;
  v44[1] = 0;
  v44[2] = 0;
  v44[3] = 0x3FF0000000000000;
  *(double *)&v44[4] = -a3;
  *(double *)&v44[5] = -a4;
  CI::ProgramNode::addDestinationTransform(this, *(const CI::Context **)(a1 + 32), (const CI::Affine *)v44);
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(v12 + 96);
  uint64_t v14 = *(void *)(v12 + 72);
  uint64_t v15 = (int)CI::format_bits_per_pixel(*(_DWORD *)(v12 + 104));
  CI::Affine::inverse((CI::Affine *)(a1 + 48), &v45.a);
  CGAffineTransform v43 = v45;
  v70.origin.double x = a3;
  v70.origin.double y = a4;
  v70.size.CGFloat width = a5;
  v70.size.double height = a6;
  CGRect v71 = CGRectApplyAffineTransform(v70, &v43);
  double x = v71.origin.x;
  double y = v71.origin.y;
  double height = v71.size.height;
  CGFloat rect = v71.size.width;
  *(float *)&v71.size.CGFloat width = v71.size.width;
  v71.size.CGFloat width = ceilf(*(float *)&v71.size.width);
  CGFloat v17 = *(double *)(a1 + 104);
  float v18 = v71.size.height;
  v71.size.double height = ceilf(v18);
  CGFloat v20 = *(double *)(a1 + 112);
  CGFloat v19 = *(double *)(a1 + 120);
  CGFloat v21 = *(double *)(a1 + 128);
  CGFloat v22 = *(double *)(a1 + 136);
  v42.CGFloat a = *(CGFloat *)(a1 + 96);
  CGFloat a = v42.a;
  v42.b = v17;
  v42.c = v20;
  v42.d = v19;
  v42.tdouble x = v21;
  v42.tdouble y = v22;
  CGRect v72 = CGRectApplyAffineTransform(v71, &v42);
  double v23 = v72.origin.x;
  double v24 = v72.origin.y;
  *(float *)&v72.origin.double x = v72.size.width;
  uint64_t v25 = vcvtps_u32_f32(*(float *)&v72.origin.x);
  *(float *)&v72.origin.double x = v72.size.height;
  uint64_t v26 = vcvtps_u32_f32(*(float *)&v72.origin.x);
  CGRect v73 = *(CGRect *)(a1 + 144);
  v41.CGFloat a = a;
  v41.b = v17;
  v41.c = v20;
  v41.d = v19;
  v41.tdouble x = v21;
  v41.tdouble y = v22;
  CGRect v74 = CGRectApplyAffineTransform(v73, &v41);
  CI::Bitmap::Bitmap((uint64_t)&v45, v14 + v13 * (unint64_t)(v24 - v74.origin.y) + (((unint64_t)(v23 - v74.origin.x) * v15 + 7) >> 3), v25, v26, v13, *(_DWORD *)(*(void *)(a1 + 40) + 104), *(CGColorSpace **)(a1 + 176));
  *(void *)&v45.CGFloat a = &unk_1EE4569D0;
  *(void *)&v45.c = &unk_1EE456A08;
  int32x4_t v27 = vdupq_n_s32(0x3B808081u);
  uint64_t v49 = v27.i64[0];
  int32x4_t v50 = v27;
  int32x4_t v51 = v27;
  int32x4_t v55 = v27;
  int32x4_t v56 = v27;
  int32x4_t v53 = v27;
  int32x4_t v54 = v27;
  int32x4_t v52 = v27;
  int32x4_t v28 = vdupq_n_s32(0x37800080u);
  uint64_t v57 = v28.i64[0];
  int32x4_t v58 = v28;
  int32x4_t v59 = v28;
  int32x4_t v64 = v28;
  int32x4_t v63 = v28;
  int32x4_t v62 = v28;
  int32x4_t v60 = v28;
  int32x4_t v61 = v28;
  int32x4_t v29 = vdupq_n_s32(0x3A802008u);
  uint64_t v65 = v29.i64[0];
  int32x4_t v68 = v29;
  int32x4_t v66 = v29;
  int32x4_t v67 = v29;
  *(double *)v29.i64 = (double)(v46 / *(void *)(a1 + 200));
  double v30 = (double)(v47 / *(void *)(a1 + 208));
  __int16 v48 = 0;
  double v39 = *(double *)v29.i64;
  double v40 = v30;
  (*(void (**)(void))(**(void **)(a1 + 32) + 352))();
  v75.origin.double x = x;
  v75.origin.double y = y;
  v75.size.double height = height;
  v38.CGFloat a = 1.0;
  v38.b = 0.0;
  v38.c = 0.0;
  v38.d = -1.0;
  v38.tdouble x = -x;
  v38.tdouble y = height + y;
  v75.size.CGFloat width = rect;
  CGRect v76 = CGRectApplyAffineTransform(v75, &v38);
  CGFloat v31 = v76.origin.y;
  *(_OWORD *)&v76.origin.double y = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v36.CGFloat a = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v36.c = *(_OWORD *)&v76.origin.y;
  *(_OWORD *)&v36.tdouble x = *(_OWORD *)(a1 + 80);
  v76.origin.double y = v31;
  CGRect v37 = CGRectApplyAffineTransform(v76, &v36);
  CI::Context::render(*(CI::Context **)(a1 + 32), this, &v37);
}

void CI::Context::render(CI::Context *this, CI::ProgramNode *a2, const CGRect *a3)
{
}

CI::TileTask *CI::TileTask::TileTask(CI::TileTask *this, CI::Context *a2, CI::ProgramNode *a3, const CGRect *a4)
{
  *((_DWORD *)this + 2) = 1;
  *(void *)this = &unk_1EE45EBD8;
  *((void *)this + 2) = dispatch_group_create();
  dispatch_group_t v8 = dispatch_group_create();
  uint64_t v9 = *((void *)a2 + 24);
  *((void *)this + 3) = v8;
  *((void *)this + 4) = v9;
  *((void *)this + 5) = 0;
  if (a3) {
    uint64_t v10 = CI::Object::ref((uint64_t)a3);
  }
  else {
    uint64_t v10 = 0;
  }
  *((void *)this + 6) = v10;
  CGPoint origin = a4->origin;
  *(CGSize *)((char *)this + 72) = a4->size;
  *(CGPoint *)((char *)this + 56) = origin;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 3CI::NodeWithChildren::NodeWithChildren(this, 0) = 1065353216;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_DWORD *)this + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = 1065353216;
  uint64_t v12 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v13 = dispatch_queue_create("CI::TileTaskQueue", v12);
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 21) = v13;
  return this;
}

uint64_t CI::Context::pre_render(CI::Context *this)
{
  return 1;
}

void CI::MetalContext::readback_bitmap(uint64_t a1, uint64_t *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = ci_signpost_log_render();
  os_signpost_id_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1) << 32;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    uint64_t v6 = a2[10];
    uint64_t v7 = a2[11];
    int v10 = 134218240;
    uint64_t v11 = v6;
    __int16 v12 = 2048;
    uint64_t v13 = v7;
    _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "readback_bitmap", "[%zu %zu]", (uint8_t *)&v10, 0x16u);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)&v10, v8, 0, (uint64_t)"readback_bitmap", 7);
  uint64_t v9 = *(void **)(a1 + 1792);
  if (v9 != *(void **)(a1 + 1808))
  {
    CIMetalCommandBufferWaitUntilCompleted(v9);
    if (a2)
    {
      if (!*(void *)(a1 + 1856) && *(unsigned char *)(a1 + 1896)) {
        CIMetalTextureGetBytes(*(void **)(a1 + 1864), a2[9], a2[12]);
      }
    }
  }
  CI::MetalContext::readback_bitmap(CI::Bitmap *,CI::output_swizzle_info)::SignpostTimer::~SignpostTimer((TimerBase *)&v10);
}

void sub_1936BFBC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t CIMetalTextureGetBytes(void *a1, uint64_t a2, uint64_t a3)
{
  memset(v7, 0, 24);
  v7[3] = [a1 width];
  v7[4] = [a1 height];
  int64x2_t v7[5] = 1;
  return [a1 getBytes:a2 bytesPerRow:a3 fromRegion:v7 mipmapLevel:0];
}

void CIMetalCommandBufferWaitUntilCompleted(void *a1)
{
  if ((unint64_t)[a1 status] < 2)
  {
    NSLog(&cfstr_MetalCommandBu.isa);
  }
  else
  {
    [a1 waitUntilCompleted];
  }
}

uint64_t CI_PRINT_TREE_dump_intermediates()
{
  {
    CI_PRINT_TREE_dump_intermediates::v = CI_PRINT_TREE_has_string("dump-intermediates") != 0;
  }
  return CI_PRINT_TREE_dump_intermediates::v;
}

void sub_1936BFD14(_Unwind_Exception *a1)
{
}

char *CI_PRINT_TREE_has_string(char *a1)
{
  string = get_string("CI_PRINT_TREE");
  uint64_t result = 0;
  if (a1)
  {
    if (string)
    {
      uint64_t result = strstr(string, a1);
      if (result)
      {
        uint64_t v4 = result;
        uint64_t result = a1;
        if (v4 != a1)
        {
          if (*(v4 - 1) == 32) {
            return (char *)v4;
          }
          else {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

char *get_string(const char *a1)
{
  uint64_t result = getenv(a1);
  if (!result)
  {
    if (userDefaults(void)::didCheck != -1) {
      dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_193);
    }
    uint64_t result = (char *)objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
    if (result)
    {
      os_signpost_id_t v3 = result;
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        return (char *)[v3 UTF8String];
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void CI::MetalContext::readback_bitmap(CI::Bitmap *,CI::output_swizzle_info)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  CFStringRef v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = *((void *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)os_signpost_id_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "readback_bitmap", "", v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1936BFF98(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

double CI::ProgramNode::restoreDestinationTransform(CI::AffineNode **this, const CI::Affine *a2)
{
  return CI::AffineNode::append_transform(this[6], a2);
}

uint64_t __CIMetalCommandBufferAddCompletionHandler_block_invoke(uint64_t a1, void *a2)
{
  CIAbortIfICSAndUnsuccessfulCommandBufferExecution(a2);
  os_signpost_id_t v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v3();
}

void CIAbortIfICSAndUnsuccessfulCommandBufferExecution(void *a1)
{
  if ([a1 status] == 5)
  {
    if ([a1 label]) {
      objc_msgSend((id)objc_msgSend(a1, "label"), "UTF8String");
    }
    if ([a1 error])
    {
      CFStringRef v2 = ci_logger_render();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        CIAbortIfICSAndUnsuccessfulCommandBufferExecution_cold_2(a1);
      }
    }
    if (isImageConversionServiceProcess_onceToken != -1) {
      dispatch_once(&isImageConversionServiceProcess_onceToken, &__block_literal_global_48);
    }
    if (isImageConversionServiceProcess_isICS)
    {
      os_signpost_id_t v3 = ci_logger_render();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        CIAbortIfICSAndUnsuccessfulCommandBufferExecution_cold_1();
      }
      exit(1);
    }
  }
}

unint64_t CIMetalCommandBufferGetGPUTime(void *a1)
{
  unint64_t result = [a1 status];
  if (result >= 4)
  {
    objc_msgSend(a1, "GPUEndTime", -1.0);
    return [a1 GPUStartTime];
  }
  return result;
}

uint64_t ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_3(uint64_t a1, void *a2)
{
  if ([a2 status] == 5)
  {
    uint64_t v4 = *(CI::TileTask **)(a1 + 40);
    id v5 = (id)[a2 error];
  }
  else
  {
    if (!internalError(a2)) {
      goto LABEL_6;
    }
    uint64_t v4 = *(CI::TileTask **)(a1 + 40);
    id v5 = internalError(a2);
  }
  CI::TileTask::setCommandBufferError(v4, v5);
LABEL_6:
  if ((CI_PRINT_TIME() & 0x100) != 0)
  {
    if (*(unsigned char *)(a1 + 64))
    {
      CIMetalCommandBufferGetGPUTime(a2);
      x_log("CI_PRINT_TIME [GPU] command buffer (%p) = %.1f ms\n");
    }
    else
    {
      CIMetalCommandBufferGetGPUTime(a2);
      x_log("CI_PRINT_TIME [GPU] root program (%s) = %.1f ms\n");
    }
  }
  CIMetalCommandBufferGetGPUTime(a2);
  CI::TileTask::incrementTimeForNode(*(CI::TileTask **)(a1 + 40), *(const CI::ProgramNode **)(a1 + 56), v6);
  uint64_t v7 = *(void *)(a1 + 40);
  *(CFAbsoluteTime *)(v7 + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = CFAbsoluteTimeGetCurrent();
  uint64_t v8 = *(CI::Object **)(a1 + 40);
  if (v8) {
    CI::Object::unref(v8);
  }
  uint64_t v9 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v9();
}

id internalError(void *a1)
{
  return objc_getAssociatedObject(a1, setInternalError);
}

void CI::TileTask::incrementTimeForNode(CI::TileTask *this, const CI::ProgramNode *a2, double a3)
{
  if (a3 != 0.0)
  {
    void block[7] = v3;
    block[8] = v4;
    id v5 = *((void *)this + 21);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN2CI8TileTask20incrementTimeForNodeEPKNS_11ProgramNodeEd_block_invoke;
    block[3] = &__block_descriptor_tmp_6_5;
    void block[4] = this;
    void block[5] = a2;
    *(double *)&void block[6] = a3;
    dispatch_async(v5, block);
  }
}

void CI::image_render_to_surface(CI *this, CI::Context *a2, IOSurfaceRef buffer, CGRect a4, __IOSurface *a5, const CI::RenderDestination *a6)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  CGRect v58 = a4;
  if (this)
  {
    double height = a4.size.height;
    double width = a4.size.width;
    CGFloat y = a4.origin.y;
    CGFloat x = a4.origin.x;
    OSType PixelFormat = (CI *)IOSurfaceGetPixelFormat(buffer);
    unsigned int v15 = PixelFormat;
    if (CI::iosurface_destination_format_supported_p(PixelFormat))
    {
      uint64_t v17 = CI::format_from_IOSurface(buffer, v16);
      int v18 = v17;
      CI::Context::swizzler_for_output((uint64_t)this, v17, 1, &v55);
      if ((width | height))
      {
        __int32 v19 = v55.i32[2];
        if (v55.i32[2] == 56 || v55.i32[2] == 53)
        {
          CGFloat v20 = ci_logger_performance();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)CGRect buf = 136446722;
            *(void *)&uint8_t buf[4] = "image_render_to_surface";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = width;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = height;
            _os_log_impl(&dword_193671000, v20, OS_LOG_TYPE_INFO, "%{public}s Rendering a region that has odd width (%d) or height (%d) may impact performance", buf, 0x18u);
          }
          __int32 v19 = 58;
          v55.i32[2] = 58;
          int64x2_t v56 = vdupq_n_s64(1uLL);
          *(void *)&long long v57 = 1;
        }
        if ((width & 1) != 0 && (v19 == 57 || v19 == 54))
        {
          CGFloat v21 = ci_logger_performance();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)CGRect buf = 136446466;
            *(void *)&uint8_t buf[4] = "image_render_to_surface";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = width;
            _os_log_impl(&dword_193671000, v21, OS_LOG_TYPE_INFO, "%{public}s Rendering a region that has odd width (%d) may impact performance", buf, 0x12u);
          }
          v55.i32[2] = 59;
          int64x2_t v56 = vdupq_n_s64(1uLL);
          *(void *)&long long v57 = 1;
        }
      }
      if ((*(unsigned int (**)(CI *))(*(void *)this + 16))(this) != 76) {
        goto LABEL_24;
      }
      if ((int)CI::format_bytes_per_pixel(v18) <= 5) {
        CI::format_is_half_float(v18);
      }
      if (CI::format_is_full_float(v18)) {
        CI::format_bytes_per_pixel(v18);
      }
      if (CI::format_is_packed(v18)) {
        int v22 = CI::format_is_ycc(v18) ^ 1;
      }
      else {
LABEL_24:
      }
        int v22 = 0;
      if ((*(unsigned int (**)(CI *))(*(void *)this + 16))(this) == 76
        || (*(unsigned int (**)(CI *))(*(void *)this + 16))(this) == 74)
      {
        HIDWORD(v24) = v18 - 263;
        LODWORD(v24) = v18 - 263;
        unsigned int v23 = v24 >> 8;
        if (v23 <= 8) {
          v22 |= 0x1C1u >> v23;
        }
      }
      size_t v25 = IOSurfaceGetWidth(buffer);
      unint64_t v26 = v56.i64[0];
      size_t v27 = IOSurfaceGetHeight(buffer);
      unint64_t v28 = v56.u64[1];
      size_t v29 = IOSurfaceGetWidth(buffer);
      double v30 = (double)(v29 / v56.i64[0]);
      size_t v31 = IOSurfaceGetHeight(buffer);
      double v32 = (double)(v31 / v56.i64[1]) * (double)*((unint64_t *)&v57 + 1);
      v54[0] = v30 * (double)(unint64_t)v57;
      v54[1] = v32;
      if (v54[0] > v32) {
        double v32 = v30 * (double)(unint64_t)v57;
      }
      if ((v22 & 1) != 0
        || (v25 % v26) | (v27 % v28)
        || (*(uint64_t (**)(CI *))(*(void *)this + 440))(this) < (unint64_t)v32)
      {
        if (IOSurfaceGetPlaneCount(buffer) < 2)
        {
          IOSurfaceLock(buffer, 0, 0);
          v73.origin.CGFloat x = (*(double (**)(CI::Context *))(*(void *)a2 + 88))(a2);
          v73.origin.CGFloat y = v33;
          v73.size.double width = v34;
          v73.size.double height = v35;
          v64.origin.CGFloat x = x;
          v64.origin.CGFloat y = y;
          v64.size.double width = width;
          v64.size.double height = height;
          CGRect v65 = CGRectIntersection(v64, v73);
          v51.CGFloat a = 1.0;
          v51.b = 0.0;
          v51.c = 0.0;
          v51.d = 1.0;
          v51.tCGFloat x = 0.0;
          v51.tCGFloat y = 0.0;
          CGRect v66 = CGRectApplyAffineTransform(v65, &v51);
          CGFloat v36 = v66.origin.x;
          CGFloat v37 = v66.origin.y;
          CGFloat v38 = v66.size.width;
          CGFloat v39 = v66.size.height;
          if (CGRectIsNull(v66))
          {
            unint64_t v40 = 0;
            unint64_t v41 = 0;
            unint64_t v53 = 0;
            long long v52 = IRectNull;
          }
          else
          {
            v67.origin.CGFloat x = v36;
            v67.origin.CGFloat y = v37;
            v67.size.double width = v38;
            v67.size.double height = v39;
            if (CGRectIsInfinite(v67))
            {
              long long v52 = IRectInfinite;
              unint64_t v40 = 0xFFFFFFFFLL;
              unint64_t v53 = 0xFFFFFFFFLL;
              unint64_t v41 = 0xFFFFFFFFLL;
            }
            else
            {
              v68.origin.CGFloat x = v36;
              v68.origin.CGFloat y = v37;
              v68.size.double width = v38;
              v68.size.double height = v39;
              CGRect v69 = CGRectInset(v68, 0.000001, 0.000001);
              CGRect v70 = CGRectIntegral(v69);
              unint64_t v41 = (unint64_t)v70.size.width;
              unint64_t v40 = (unint64_t)v70.size.height;
              LODWORD(v52) = (int)v70.origin.x;
              DWORD1(v52) = (int)v70.origin.y;
              *((void *)&v52 + 1) = (unint64_t)v70.size.width;
              unint64_t v53 = (unint64_t)v70.size.height;
            }
          }
          CGAffineTransform v42 = ci_signpost_log_render();
          os_signpost_id_t v43 = (*(uint64_t (**)(CI *))(*(void *)this + 272))(this) << 32;
          if (v43 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v42))
          {
            *(_DWORD *)CGRect buf = 134218240;
            *(void *)&uint8_t buf[4] = v41;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v40;
            _os_signpost_emit_with_name_impl(&dword_193671000, v42, OS_SIGNPOST_INTERVAL_BEGIN, v43, "new_bitmap", "[%zu %zu]", buf, 0x16u);
          }
          uint64_t v44 = (*(uint64_t (**)(CI *))(*(void *)this + 272))(this);
          TimerBase::TimerBase((uint64_t)buf, v44, 0, (uint64_t)"new_bitmap", 0);
          operator new();
        }
        operator new();
      }
      CFAbsoluteTimeGetCurrent();
      v50.CGFloat a = 1.0 / (double)v56.u64[0];
      v50.b = 0.0;
      v50.c = 0.0;
      v50.d = 1.0 / (double)v56.u64[1];
      v50.tCGFloat x = 0.0;
      v50.tCGFloat y = 0.0;
      v71.origin.CGFloat x = x;
      v71.origin.CGFloat y = y;
      v71.size.double width = width;
      v71.size.double height = height;
      CGRect v72 = CGRectApplyAffineTransform(v71, &v50);
      CGRect v58 = v72;
      LODWORD(v52) = v55.i32[0];
      WORD2(v52) = 0;
      v49[0] = v55;
      v49[1] = v56;
      v49[2] = v57;
      *(void *)CGRect buf = 0x3FF0000000000000;
      *(void *)&uint8_t buf[8] = 0;
      *(void *)&uint8_t buf[16] = 0;
      uint64_t v60 = 0x3FF0000000000000;
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      CGAffineTransform v45 = CI::prepare_initial_graph((uint64_t *)this, "render_to_surface", (unsigned int *)a2, (uint64_t)a5, 0, v18, (uint64_t)v49, buf, v72.origin.x, v72.origin.y, v72.size.width, v72.size.height, 0, (uint64_t)&v52);
      if (v45)
      {
        uint64_t v47 = (uint64_t)v45;
        uint64_t v48 = v46;
        (*(void (**)(CI *, IOSurfaceRef, double *, long long *))(*(void *)this + 360))(this, buffer, v54, &v52);
        CI::tile_node_graph((uint64_t)this, (uint64_t)a5, (uint64_t)"render_to_surface", v47, v48, &v58);
      }
      operator new();
    }
    if (v15 >= 0x29)
    {
      *(_DWORD *)CGRect buf = bswap32(v15);
      operator new();
    }
    operator new();
  }
  operator new();
}

uint64_t CI::iosurface_destination_format_supported_p(CI *this)
{
  int v1 = equivalent_uncompressed_format((uint64_t)this);
  uint64_t result = 1;
  if (v1 <= 1717855599)
  {
    if (v1 <= 875836517)
    {
      if (v1 <= 843264303)
      {
        if (v1 <= 826487087)
        {
          if (((v1 - 826486840) > 0x30 || ((1 << (v1 - 56)) & 0x1400000000001) == 0)
            && v1 != 24
            && v1 != 32)
          {
            return 0;
          }
        }
        else if ((v1 - 826487088) > 6 || ((1 << (v1 - 48)) & 0x45) == 0)
        {
          unsigned int v4 = v1 - 843264056;
          if (v4 > 0x30 || ((1 << v4) & 0x1400000000001) == 0) {
            return 0;
          }
        }
        return result;
      }
      if (v1 <= 846624120)
      {
        if ((v1 - 843264304) <= 6 && ((1 << (v1 - 48)) & 0x45) != 0) {
          return result;
        }
        int v3 = 846624102;
      }
      else
      {
        if (v1 <= 875704437)
        {
          if (v1 == 846624121) {
            return result;
          }
          unsigned __int16 v6 = 12390;
        }
        else
        {
          if (v1 == 875704438 || v1 == 875704934) {
            return result;
          }
          unsigned __int16 v6 = 12918;
        }
        int v3 = v6 | 0x34320000;
      }
    }
    else if (v1 <= 1279340599)
    {
      if (v1 <= 1111970368)
      {
        if (v1 == 875836518 || v1 == 875836534) {
          return result;
        }
        int v3 = 1094862674;
      }
      else
      {
        if ((v1 - 1278226488) <= 0x30 && ((1 << (v1 - 56)) & 0x1400000000001) != 0
          || (v1 - 1278226736) <= 6 && ((1 << (v1 - 48)) & 0x45) != 0)
        {
          return result;
        }
        int v3 = 1111970369;
      }
    }
    else if (v1 <= 1380401728)
    {
      if ((v1 - 1279340600) <= 0x30 && ((1 << (v1 - 56)) & 0x1400000000001) != 0
        || v1 == 1279340854)
      {
        return result;
      }
      int v3 = 1279342648;
    }
    else if (v1 > 1650943795)
    {
      if (v1 == 1650943796 || v1 == 1667838256) {
        return result;
      }
      int v3 = 1667839024;
    }
    else
    {
      if (v1 == 1380401729 || v1 == 1380410945) {
        return result;
      }
      int v3 = 1380411457;
    }
    goto LABEL_108;
  }
  if (v1 > 1936077875)
  {
    if (v1 > 1999843441)
    {
      if (v1 <= 2019963439)
      {
        if (v1 <= 2016686639)
        {
          if (v1 == 1999843442) {
            return result;
          }
          int v3 = 1999908961;
        }
        else
        {
          if (v1 == 2016686640 || v1 == 2016686642) {
            return result;
          }
          int v3 = 2016687156;
        }
      }
      else if (v1 > 2033463351)
      {
        if (v1 == 2033463352 || v1 == 2037741158) {
          return result;
        }
        int v3 = 2037741171;
      }
      else
      {
        if (v1 == 2019963440 || v1 == 2019963442) {
          return result;
        }
        int v3 = 2019963956;
      }
      goto LABEL_108;
    }
    if (v1 <= 1952854577)
    {
      if (v1 <= 1937125937)
      {
        if (v1 == 1936077876) {
          return result;
        }
        int v3 = 1937125936;
        goto LABEL_108;
      }
      if (v1 == 1937125938 || v1 == 1937126452) {
        return result;
      }
      unsigned __int16 v5 = 12848;
LABEL_107:
      int v3 = v5 | 0x74660000;
      goto LABEL_108;
    }
    if (v1 <= 1953903151)
    {
      if (v1 == 1952854578) {
        return result;
      }
      unsigned __int16 v5 = 13364;
      goto LABEL_107;
    }
    if (v1 == 1953903152 || v1 == 1953903154) {
      return result;
    }
    int v3 = 1953903668;
LABEL_108:
    if (v1 == v3) {
      return result;
    }
    return 0;
  }
  if (v1 <= 1815361649)
  {
    if (v1 > 1751411058)
    {
      if (v1 <= 1751527985)
      {
        if (v1 == 1751411059) {
          return result;
        }
        int v3 = 1751527984;
      }
      else
      {
        if (v1 == 1751527986 || v1 == 1751528500) {
          return result;
        }
        int v3 = 1815162994;
      }
    }
    else if (v1 <= 1734505011)
    {
      if (v1 == 1717855600) {
        return result;
      }
      int v3 = 1717856627;
    }
    else
    {
      if (v1 == 1734505012 || v1 == 1735549492) {
        return result;
      }
      int v3 = 1751410032;
    }
    goto LABEL_108;
  }
  if (v1 <= 1885745711)
  {
    if (v1 <= 1882468911)
    {
      if (v1 == 1815361650) {
        return result;
      }
      int v3 = 1815491698;
    }
    else
    {
      if (v1 == 1882468912 || v1 == 1882468914) {
        return result;
      }
      int v3 = 1882469428;
    }
    goto LABEL_108;
  }
  if (v1 > 1919379251)
  {
    if (v1 == 1919379252 || v1 == 1936077360) {
      return result;
    }
    int v3 = 1936077362;
    goto LABEL_108;
  }
  if (v1 != 1885745712 && v1 != 1885745714)
  {
    int v3 = 1885746228;
    goto LABEL_108;
  }
  return result;
}

uint64_t CI::traverse_releasing_resources(CI *this, CI::Node *a2)
{
  uint64_t result = CI_CACHE_PROGRAM_GRAPH();
  if (result)
  {
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 0x40000000;
    v4[2] = ___ZN2CI4Node15traverse_uniqueEU13block_pointerFvPS0_E_block_invoke;
    v4[3] = &unk_1E57764E0;
    v4[4] = &__block_literal_global_93;
    return CI::GraphObject::traverse_unique((uint64_t)this, (uint64_t)v4);
  }
  return result;
}

double CI::MetalContext::unset_destination(CI::MetalContext *this)
{
  CFStringRef v2 = (const void *)*((void *)this + 226);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 226) = 0;
  }
  uint64_t v3 = 0;
  char v4 = 1;
  do
  {
    char v5 = v4;
    unsigned __int16 v6 = (char *)this + 8 * v3;
    uint64_t v7 = (const void *)*((void *)v6 + 233);
    if (v7)
    {
      uint64_t v8 = v6 + 1864;
      CFRelease(v7);
      void *v8 = 0;
    }
    char v4 = 0;
    uint64_t v3 = 1;
  }
  while ((v5 & 1) != 0);
  uint64_t v9 = (const void *)*((void *)this + 232);
  if (v9)
  {
    CFRelease(v9);
    *((void *)this + 232) = 0;
  }
  int v10 = (const void *)*((void *)this + 235);
  if (v10)
  {
    CFRelease(v10);
    *((void *)this + 235) = 0;
  }
  uint64_t v11 = (const void *)*((void *)this + 236);
  if (v11) {
    _Block_release(v11);
  }
  *((void *)this + 237) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 1864) = 0u;
  *(_OWORD *)((char *)this + 188CI::NodeWithChildren::NodeWithChildren(this, 0) = 0u;
  *(_OWORD *)((char *)this + 1832) = 0u;
  *(_OWORD *)((char *)this + 1848) = 0u;
  return result;
}

void CI::Node::remove_parentROI(CI::SerialRectArray **a1, const CI::parentROI *a2, uint64_t a3, uint64_t a4, dispatch_object_t object)
{
  dispatch_retain(object);
  int v10 = *(NSObject **)(a4 + 96);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI4Node16remove_parentROIERKNS_9parentROIERKNS_6roiKeyEPNS_14TextureManagerEPv_block_invoke;
  block[3] = &__block_descriptor_tmp_27;
  void block[4] = object;
  dispatch_async(v10, block);
  size_t v31 = (uint64_t *)a3;
  int v11 = *(_DWORD *)(a3 + 8);
  CI::SerialRectArray::removeTile(a1[2], v11, a2);
  unsigned int v12 = (*((uint64_t (**)(CI::SerialRectArray **))*a1 + 2))(a1);
  BOOL v13 = (CI::is_image_type(v12) & 1) != 0
     || *(void *)(*(void *)a1[2] + 120 * v11 + 40) == *(void *)(*(void *)a1[2] + 120 * v11 + 32);
  BOOL v30 = v13;
  uint64_t intermediate_for_node = (uint64_t (***)(void))CI::TextureManager::get_intermediate_for_node(a4, (uint64_t)v31);
  if (intermediate_for_node
    && (unsigned int v15 = intermediate_for_node, (**intermediate_for_node)(intermediate_for_node))
    && (unsigned int v16 = (*((uint64_t (**)(CI::SerialRectArray **))*a1 + 2))(a1), CI::is_image_type(v16))
    && (uint64_t v17 = (__IOSurface *)(**v15)(v15), IOSurfaceGetPlaneCount(v17) >= 2))
  {
    int v18 = (__IOSurface *)(**v15)(v15);
    size_t PlaneCount = IOSurfaceGetPlaneCount(v18);
    if (!PlaneCount) {
      return;
    }
  }
  else
  {
    size_t PlaneCount = 1;
  }
  uint64_t v19 = 0;
  uint64_t v33 = a4;
  do
  {
    uint64_t v32 = v19;
    uint64_t v20 = CI::TextureManager::release_intermediate_for_node(a4, v31);
    if (v30)
    {
      uint64_t v21 = v20;
      int v22 = *a1;
      if (v20)
      {
        int v23 = (*((uint64_t (**)(CI::SerialRectArray **))v22 + 2))(a1);
        size_t v25 = *(NSObject **)(v33 + 88);
        unint64_t v24 = *(NSObject **)(v33 + 96);
        v34[0] = MEMORY[0x1E4F143A8];
        v34[1] = 0x40000000;
        v34[2] = ___ZN2CI4Node16remove_parentROIERKNS_9parentROIERKNS_6roiKeyEPNS_14TextureManagerEPv_block_invoke_3;
        void v34[3] = &__block_descriptor_tmp_3_5;
        int v35 = v23;
        v34[4] = v33;
        v34[5] = v21;
        dispatch_group_async(v25, v24, v34);
      }
      else if ((*((int (**)(CI::SerialRectArray **))v22 + 5))(a1) >= 1)
      {
        uint64_t v26 = 0;
        do
        {
          if (*(int *)(*(void *)a1[2] + 120 * v11 + 80) >= 1)
          {
            signed int v27 = 0;
            do
            {
              *(void *)&long long v45 = a1;
              *((void *)&v45 + 1) = __PAIR64__(v27, v11);
              long long v46 = v26 | 0xFFFFFFFF00000000;
              *(void *)&long long v47 = 0;
              DWORD2(v47) = 0;
              unint64_t v28 = *(uint64_t ***)((*((uint64_t (**)(CI::SerialRectArray **, uint64_t))*a1 + 6))(a1, v26) + 16);
              v36[0] = MEMORY[0x1E4F143A8];
              v36[1] = 0x40000000;
              v36[2] = ___ZN2CI4Node16remove_parentROIERKNS_9parentROIERKNS_6roiKeyEPNS_14TextureManagerEPv_block_invoke_2;
              v36[3] = &__block_descriptor_tmp_2_1;
              long long v38 = v46;
              long long v39 = v47;
              long long v37 = v45;
              int v42 = v26;
              v36[4] = a1;
              uint64_t v40 = v33;
              dispatch_object_t v41 = object;
              CI::SerialRectArray::findParentROI(v28, (uint64_t)&v45, (uint64_t)v36, (uint64_t)v43);
              std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)v43, v44);
              ++v27;
            }
            while (v27 < *(_DWORD *)(*(void *)a1[2] + 120 * v11 + 80));
          }
          uint64_t v26 = (v26 + 1);
        }
        while ((int)v26 < (*((int (**)(CI::SerialRectArray **))*a1 + 5))(a1));
      }
    }
    uint64_t v19 = v32 + 1;
    a4 = v33;
  }
  while (v32 + 1 != PlaneCount);
}

uint64_t CI::TextureManager::get_intermediate_for_node(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v9 = 0;
  CFStringRef v2 = *(NSObject **)(a1 + 104);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZNK2CI14TextureManager25get_intermediate_for_nodeERKNS_6roiKeyE_block_invoke;
  block[3] = &unk_1E5776F40;
  void block[5] = a1;
  void block[6] = a2;
  void block[4] = &v6;
  dispatch_sync(v2, block);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void CI::SerialRectArray::removeTile(CI::SerialRectArray *this, int a2, const CI::parentROI *a3)
{
  uint64_t v3 = *(void *)this + 120 * a2;
  uint64_t v5 = *(void *)(v3 + 32);
  v3 += 32;
  uint64_t v4 = v5;
  uint64_t v7 = *(void *)(v3 + 8);
  uint64_t v6 = (void *)(v3 + 8);
  if (v4 != v7)
  {
    uint64_t v11 = -v4;
    while (!CI::parentROI::operator==(v4, (uint64_t)a3))
    {
      v4 += 48;
      v11 -= 48;
      if (v4 == *v6) {
        return;
      }
    }
    uint64_t v12 = *(void *)this + 120 * a2;
    unint64_t v15 = *(void *)(v12 + 72);
    uint64_t v14 = (char **)(v12 + 72);
    unint64_t v13 = v15;
    uint64_t v17 = (void **)(v14 - 1);
    unsigned int v16 = *(v14 - 1);
    if ((unint64_t)v16 >= v15)
    {
      uint64_t v21 = (void **)(v14 - 2);
      uint64_t v22 = (uint64_t)*(v14 - 2);
      unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v16 - v22) >> 4);
      unint64_t v24 = v23 + 1;
      if (v23 + 1 > 0x555555555555555) {
        abort();
      }
      unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - v22) >> 4);
      if (2 * v25 > v24) {
        unint64_t v24 = 2 * v25;
      }
      if (v25 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v26 = 0x555555555555555;
      }
      else {
        unint64_t v26 = v24;
      }
      if (v26) {
        signed int v27 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::parentROI>>((uint64_t)v14, v26);
      }
      else {
        signed int v27 = 0;
      }
      unint64_t v28 = &v27[48 * v23];
      size_t v29 = &v27[48 * v26];
      long long v30 = *(_OWORD *)v4;
      long long v31 = *(_OWORD *)(v4 + 32);
      *((_OWORD *)v28 + 1) = *(_OWORD *)(v4 + 16);
      *((_OWORD *)v28 + 2) = v31;
      *(_OWORD *)unint64_t v28 = v30;
      uint64_t v20 = v28 + 48;
      uint64_t v32 = (char *)*v17;
      uint64_t v33 = (char *)*v21;
      if (*v17 != *v21)
      {
        do
        {
          long long v34 = *((_OWORD *)v32 - 3);
          long long v35 = *((_OWORD *)v32 - 1);
          *((_OWORD *)v28 - 2) = *((_OWORD *)v32 - 2);
          *((_OWORD *)v28 - 1) = v35;
          *((_OWORD *)v28 - 3) = v34;
          v28 -= 48;
          v32 -= 48;
        }
        while (v32 != v33);
        uint64_t v32 = (char *)*v21;
      }
      *uint64_t v21 = v28;
      __IOSurface *v17 = v20;
      *uint64_t v14 = v29;
      if (v32) {
        operator delete(v32);
      }
    }
    else
    {
      long long v18 = *(_OWORD *)v4;
      long long v19 = *(_OWORD *)(v4 + 32);
      v16[1] = *(_OWORD *)(v4 + 16);
      void v16[2] = v19;
      *unsigned int v16 = v18;
      uint64_t v20 = v16 + 3;
    }
    __IOSurface *v17 = v20;
    uint64_t v36 = *v6 - (48 - v11);
    if (*v6 != 48 - v11) {
      memmove((void *)-v11, (const void *)(48 - v11), *v6 - (48 - v11));
    }
    *uint64_t v6 = v36 - v11;
  }
}

uint64_t CI::TextureManager::release_intermediate_for_node(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  v7[0] = 0;
  v7[1] = v7;
  void v7[2] = 0x2000000000;
  v7[3] = 0;
  uint64_t v3 = *(NSObject **)(a1 + 104);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI14TextureManager29release_intermediate_for_nodeERKNS_6roiKeyEb_block_invoke;
  block[3] = &unk_1E5776FB0;
  void block[6] = a1;
  void block[7] = v2;
  block[8] = a2;
  void block[4] = &v8;
  void block[5] = v7;
  dispatch_sync(v3, block);
  uint64_t v4 = v9[3];
  _Block_object_dispose(v7, 8);
  _Block_object_dispose(&v8, 8);
  return v4;
}

void CI::TileTask::~TileTask(dispatch_queue_t *this)
{
  CI::TileTask::~TileTask(this);

  JUMPOUT(0x1997023B0);
}

{
  CI::Object *v2;
  dispatch_queue_t v3;
  dispatch_queue_t v4;

  *this = (dispatch_queue_t)&unk_1EE45EBD8;
  dispatch_sync(this[21], &__block_literal_global_94);
  uint64_t v2 = (CI::Object *)this[6];
  if (v2) {
    CI::Object::unref(v2);
  }
  dispatch_release(this[2]);
  dispatch_release(this[3]);
  dispatch_release(this[21]);
  uint64_t v3 = this[22];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = this[23];
  if (v4) {
    CFRelease(v4);
  }
  std::__hash_table<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::__unordered_map_hasher<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::hash<CI::ProgramNode *>,std::equal_to<CI::ProgramNode *>,true>,std::__unordered_map_equal<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::equal_to<CI::ProgramNode *>,std::hash<CI::ProgramNode *>,true>,std::allocator<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>>>::~__hash_table((uint64_t)(this + 16));
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)(this + 11));
}

uint64_t std::__hash_table<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::__unordered_map_hasher<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::hash<CI::ProgramNode *>,std::equal_to<CI::ProgramNode *>,true>,std::__unordered_map_equal<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::equal_to<CI::ProgramNode *>,std::hash<CI::ProgramNode *>,true>,std::allocator<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::__unordered_map_hasher<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::hash<CI::ProgramNode *>,std::equal_to<CI::ProgramNode *>,true>,std::__unordered_map_equal<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::equal_to<CI::ProgramNode *>,std::hash<CI::ProgramNode *>,true>,std::allocator<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::__unordered_map_hasher<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::hash<CI::ProgramNode *>,std::equal_to<CI::ProgramNode *>,true>,std::__unordered_map_equal<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::equal_to<CI::ProgramNode *>,std::hash<CI::ProgramNode *>,true>,std::allocator<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[3];
      if (v4)
      {
        void v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void CI::RenderTask::~RenderTask(CI::RenderTask *this)
{
  CI::RenderTask::~RenderTask(this);

  JUMPOUT(0x1997023B0);
}

{
  CI::Object *v2;
  const void *v3;
  const void *v4;
  CI::Object *v5;
  void **v6;

  *(void *)this = &unk_1EE4577A8;
  uint64_t v2 = (CI::Object *)*((void *)this + 5);
  if (v2) {
    CI::Object::unref(v2);
  }
  *((void *)this + 5) = 0;
  uint64_t v3 = (const void *)*((void *)this + 16);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)this + 16) = 0;
  uint64_t v4 = (const void *)*((void *)this + 12);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 12) = 0;
  uint64_t v5 = (CI::Object *)*((void *)this + 3);
  if (v5) {
    CI::Object::unref(v5);
  }
  *((void *)this + 3) = 0;
  uint64_t v6 = (void **)((char *)this + 136);
  std::vector<std::unique_ptr<CI::TileTask,CI::ObjectDeleter<CI::TileTask>>>::__destroy_vector::operator()[abi:nn180100](&v6);
}

void std::vector<std::unique_ptr<CI::TileTask,CI::ObjectDeleter<CI::TileTask>>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<CI::TileTask,CI::ObjectDeleter<CI::TileTask>>>::__clear[abi:nn180100](v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::unique_ptr<CI::TileTask,CI::ObjectDeleter<CI::TileTask>>>::__clear[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)*a1;
  uint64_t v3 = (void *)a1[1];
  while (v3 != v2)
  {
    uint64_t v5 = (CI::Object *)*--v3;
    uint64_t v4 = v5;
    *uint64_t v3 = 0;
    if (v5) {
      CI::Object::unref(v4);
    }
  }
  a1[1] = v2;
}

void CI::TextureSampler::~TextureSampler(CI::TextureSampler *this)
{
  CI::TextureSampler::~TextureSampler(this);

  JUMPOUT(0x1997023B0);
}

{
  CI::Object *v2;

  *(void *)this = &unk_1EE45A290;
  *((void *)this + 2) = &unk_1EE45A2C8;
  uint64_t v2 = (CI::Object *)*((void *)this + 3);
  if (v2) {
    CI::Object::unref(v2);
  }
  *((void *)this + 2) = &unk_1EE456A30;
  *((void *)this + 3) = 0;
  atomic_fetch_add(&dword_1EB466F58[2], 0xFFFFFFFF);
}

void __ReturnSurfaceToCache_block_invoke(uint64_t a1, CI::SurfaceCacheEntry *a2)
{
  uint64_t v3 = *(__IOSurface **)(a1 + 32);
  uint64_t v4 = CI::gCacheList;
  if (v3) {
    BOOL v5 = CI::gCacheList == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = CI::gCacheList;
    while (1)
    {
      uint64_t v6 = *(void *)(v6 + 8);
      if (v6 == CI::gCacheList) {
        break;
      }
      uint64_t v7 = *(void *)(v6 + 16);
      if (*(__IOSurface **)(v7 + 24) == v3)
      {
        uint64_t v8 = *(void *)(v7 + 88);
        if (v8 <= 0) {
          __ReturnSurfaceToCache_block_invoke_cold_1();
        }
        uint64_t v9 = v8 - 1;
        *(void *)(v7 + 88) = v9;
        if (!v9)
        {
          if (*(void *)(v7 + 152))
          {
            CI::RemoveCacheEntry((CI *)v7, a2);
            uint64_t v3 = (__IOSurface *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 8))(v7);
            goto LABEL_12;
          }
          signed int v12 = *(_DWORD *)(v7 + 96);
          if (v12 != 8)
          {
            if (v12 == -1) {
              goto LABEL_23;
            }
            if (v12 > 6 || (uint64_t v13 = *(void *)(v4 + 8), v13 == v4))
            {
LABEL_34:
              uint64_t v3 = (__IOSurface *)SurfaceSetVolatile(v3, v12);
            }
            else
            {
              while (1)
              {
                uint64_t v14 = *(void *)(v13 + 16);
                if (*(int *)(v14 + 96) >= 7
                  && !*(void *)(v14 + 88)
                  && *(_DWORD *)(v14 + 56)
                  && *(void *)(v14 + 64)
                  && SurfaceIsVolatileNonEmpty(*(__IOSurface **)(v14 + 24)))
                {
                  break;
                }
                uint64_t v13 = *(void *)(v13 + 8);
                if (v13 == v4)
                {
                  uint64_t v3 = *(__IOSurface **)(v7 + 24);
                  signed int v12 = *(_DWORD *)(v7 + 96);
                  goto LABEL_34;
                }
              }
LABEL_23:
              CI::SurfaceCacheEntry::empty((IOSurfaceRef *)v7);
            }
          }
LABEL_12:
          uint64_t v3 = (__IOSurface *)CI::RemoveFromStartUntilAtOrBelowCapacity(v3);
        }
        CI::UpdateVolatilityStats(v3);
        int v10 = CI_LOG_SURFACE_CACHE();
        if (v10) {
          CI::LogCacheState((CI *)(v10 > 1), (uint64_t)"ReturnSurfaceToCache", v11);
        }
        break;
      }
    }
    uint64_t v3 = *(__IOSurface **)(a1 + 32);
  }
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t CI_LOG_SURFACE_CACHE()
{
  {
    CI_LOG_SURFACE_CACHE::v = get_int("CI_LOG_SURFACE_CACHE", 0);
  }
  return CI_LOG_SURFACE_CACHE::v;
}

void sub_1936C2710(_Unwind_Exception *a1)
{
}

void CI::UpdateVolatilityStats(CI *this)
{
  unint64_t v1 = CI::gCacheNonVolatileSizePeak;
  atomic_store(CI::GetCurrentCacheVolatileSize(this), &CI::gVolatileSize);
  unint64_t v2 = atomic_load(&CI::gCacheSize);
  unint64_t v3 = atomic_load(&CI::gVolatileSize);
  uint64_t v4 = v2 - v3;
  if (v2 - v3 > v1)
  {
    if (CI_TRACE_PEAK_SURFACE_CACHE())
    {
      if (CI::gPeakNonVolatileList) {
        CFArrayRemoveAllValues((CFMutableArrayRef)CI::gPeakNonVolatileList);
      }
      else {
        CI::gPeakNonVolatileList = (uint64_t)CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      }
      uint64_t v5 = CI::gCacheList;
      if (CI::gCacheList)
      {
        uint64_t v6 = *(void *)(CI::gCacheList + 8);
        if (v6 != CI::gCacheList)
        {
          do
          {
            uint64_t v7 = *(void *)(v6 + 16);
            if (*(void *)(v7 + 88) || *(_DWORD *)(v7 + 96) == 8)
            {
              Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              __CFDictionary::setValue(Mutable, @"id", *(const void **)(v7 + 64), v9);
              __CFDictionary::setValue(Mutable, (__CFDictionary *)@"x", (const __CFString *)*(int *)(v7 + 32));
              __CFDictionary::setValue(Mutable, (__CFDictionary *)@"y", (const __CFString *)*(int *)(v7 + 36));
              __CFDictionary::setValue(Mutable, (__CFDictionary *)@"w", *(const __CFString **)(v7 + 40));
              __CFDictionary::setValue(Mutable, (__CFDictionary *)@"h", *(const __CFString **)(v7 + 48));
              __CFDictionary::setValue(Mutable, (__CFDictionary *)@"size", *(const __CFString **)(v7 + 104));
              int v10 = (__CFString *)*(unsigned int *)(v7 + 56);
              if (v10) {
                __CFDictionary::setValue(Mutable, (__CFDictionary *)@"ctxIndex", v10);
              }
              uint64_t v11 = (__CFString *)*(unsigned int *)(v7 + 60);
              if (v11) {
                __CFDictionary::setValue(Mutable, (__CFDictionary *)@"imgIndex", v11);
              }
              if (CI::gPeakNonVolatileList) {
                CFArrayAppendValue((CFMutableArrayRef)CI::gPeakNonVolatileList, Mutable);
              }
            }
            uint64_t v6 = *(void *)(v6 + 8);
          }
          while (v6 != v5);
        }
      }
    }
    CI::gCacheNonVolatileSizePeauint64_t k = v4;
  }
}

uint64_t CI::GetCurrentCacheVolatileSize(CI *this)
{
  if (!CI::gCacheList) {
    return 0;
  }
  uint64_t v1 = *(void *)(CI::gCacheList + 8);
  if (v1 == CI::gCacheList) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    uint64_t v3 = *(void *)(v1 + 16);
    if (!*(void *)(v3 + 88) && *(_DWORD *)(v3 + 96) != 8) {
      result += *(void *)(v3 + 104);
    }
    uint64_t v1 = *(void *)(v1 + 8);
  }
  while (v1 != CI::gCacheList);
  return result;
}

void CI::TileTask::addROIForNode(CI::TileTask *this, CI::ProgramNode *a2, const CGRect *a3)
{
  uint64_t v21 = a2;
  uint64_t v22 = &v21;
  uint64_t v4 = std::__hash_table<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::__unordered_map_hasher<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::hash<CI::ProgramNode *>,std::equal_to<CI::ProgramNode *>,true>,std::__unordered_map_equal<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::equal_to<CI::ProgramNode *>,std::hash<CI::ProgramNode *>,true>,std::allocator<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>>>::__emplace_unique_key_args<CI::ProgramNode *,std::piecewise_construct_t const&,std::tuple<CI::ProgramNode * const&>,std::tuple<>>((uint64_t)this + 128, &v21, (uint64_t)&std::piecewise_construct, &v22);
  unint64_t v5 = v4[4];
  unint64_t v6 = v4[5];
  if (v5 >= v6)
  {
    uint64_t v9 = v4[3];
    uint64_t v10 = (uint64_t)(v5 - v9) >> 5;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 59) {
      abort();
    }
    uint64_t v12 = v6 - v9;
    if (v12 >> 4 > v11) {
      unint64_t v11 = v12 >> 4;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v13 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>((uint64_t)(v4 + 5), v13);
    }
    else {
      uint64_t v14 = 0;
    }
    unint64_t v15 = (CGSize *)&v14[32 * v10];
    unsigned int v16 = &v14[32 * v13];
    CGSize size = a3->size;
    *unint64_t v15 = (CGSize)a3->origin;
    v15[1] = size;
    uint64_t v8 = (char *)&v15[2];
    long long v19 = (char *)v4[3];
    long long v18 = (char *)v4[4];
    if (v18 != v19)
    {
      do
      {
        CGSize v20 = (CGSize)*((_OWORD *)v18 - 1);
        v15[-2] = *((CGSize *)v18 - 2);
        v15[-1] = v20;
        v15 -= 2;
        v18 -= 32;
      }
      while (v18 != v19);
      long long v18 = (char *)v4[3];
    }
    v4[3] = v15;
    v4[4] = v8;
    void v4[5] = v16;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    CGSize v7 = a3->size;
    *(CGPoint *)unint64_t v5 = a3->origin;
    *(CGSize *)(v5 + 16) = v7;
    uint64_t v8 = (char *)(v5 + 32);
  }
  v4[4] = v8;
}

void *std::__hash_table<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::__unordered_map_hasher<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::hash<CI::ProgramNode *>,std::equal_to<CI::ProgramNode *>,true>,std::__unordered_map_equal<CI::ProgramNode *,std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>,std::equal_to<CI::ProgramNode *>,std::hash<CI::ProgramNode *>,true>,std::allocator<std::__hash_value_type<CI::ProgramNode *,std::vector<CGRect>>>>::__emplace_unique_key_args<CI::ProgramNode *,std::piecewise_construct_t const&,std::tuple<CI::ProgramNode * const&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x30uLL);
  *uint64_t i = 0;
  i[1] = v9;
  i[2] = **a4;
  i[3] = 0;
  i[4] = 0;
  i[5] = 0;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v10 || (float)(v16 * (float)v10) < v15)
  {
    BOOL v17 = 1;
    if (v10 >= 3) {
      BOOL v17 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v10);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__rehash<true>(a1, v20);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v21 = *(void *)a1;
  uint64_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *uint64_t i = *v22;
LABEL_38:
    *uint64_t v22 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v23 = *(void *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v23 >= v10) {
        v23 %= v10;
      }
    }
    else
    {
      v23 &= v10 - 1;
    }
    uint64_t v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void CI::RenderToBitmap::~RenderToBitmap(CI::RenderToBitmap *this)
{
  CI::RenderToBitmap::~RenderToBitmap(this);

  JUMPOUT(0x1997023B0);
}

{
  CI::Object *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EE459F78;
  *((void *)this + 5) = &unk_1EE459FD0;
  unint64_t v2 = (CI::Object *)*((void *)this + 6);
  if (v2) {
    CI::Object::unref(v2);
  }
  *((void *)this + 5) = &unk_1EE45B228;
  atomic_fetch_add(&dword_1EB466F58[23], 0xFFFFFFFF);

  CI::RenderDestination::~RenderDestination(this);
}

void CI::RenderDestination::~RenderDestination(CI::RenderDestination *this)
{
  *(void *)this = &unk_1EE45CC00;
  unint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFAutorelease(v2);
  }
  *((void *)this + 3) = 0;
  uint64_t v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFAutorelease(v3);
  }
  *((void *)this + 2) = 0;
}

uint64_t ___ZN2CI14TextureManager21complete_intermediateENS_4TypeEPNS_14intermediate_tE_block_invoke(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  --*(void *)(v2 + 64);
  uint64_t v4 = (**(uint64_t (***)(uint64_t))v2)(v2);
  ReturnSurfaceToCache(v4);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40));
  if (!result)
  {
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 40) + 64))(*(void *)(a1 + 40)))
    {
      uint64_t v6 = (***(uint64_t (****)(void))(a1 + 40))(*(void *)(a1 + 40));
      ReturnSurfaceToCache(v6);
    }
    uint64_t v7 = *(void *)(a1 + 40);
    if (*(_DWORD *)(a1 + 48) == 52)
    {
      unint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 16);
      return v8(v3, v7);
    }
    else
    {
      return CI::TextureManager::_release_intermediate(v3, v7);
    }
  }
  return result;
}

void ReturnSurfaceToCache(uint64_t a1)
{
  if (GetQueue(void)::onceToken != -1) {
    dispatch_once(&GetQueue(void)::onceToken, &__block_literal_global_71);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __ReturnSurfaceToCache_block_invoke;
  block[3] = &__block_descriptor_tmp_35_1;
  void block[4] = a1;
  dispatch_async((dispatch_queue_t)gSurfaceCacheQueue, block);
}

void CI::TextureManager::intermediate(CI::TextureManager *this, __IOSurface *a2, const CGRect *a3)
{
}

uint64_t CI::TextureManager::tmIntermediate_t::surface(CI::TextureManager::tmIntermediate_t *this)
{
  return *((void *)this + 3);
}

void RetainSurfaceFromCache(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  if (GetQueue(void)::onceToken != -1) {
    dispatch_once(&GetQueue(void)::onceToken, &__block_literal_global_71);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __RetainSurfaceFromCache_block_invoke;
  block[3] = &__block_descriptor_tmp_33_0;
  void block[4] = cf;
  dispatch_async((dispatch_queue_t)gSurfaceCacheQueue, block);
}

void __CIMetalRenderToTextures_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (CI_KDEBUG()) {
    kdebug_trace();
  }
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v4 = ci_signpost_log_render();
    os_signpost_id_t v5 = *(int *)(a1 + 56) | (*(void *)(a1 + 48) << 32);
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v6 = v4;
      if (os_signpost_enabled(v4))
      {
        double v7 = *(double *)(a1 + 40);
        unsigned int v8 = *(double *)(a1 + 32);
        int v9 = 134218496;
        uint64_t v10 = a2;
        __int16 v11 = 1024;
        unsigned int v12 = v8;
        __int16 v13 = 1024;
        unsigned int v14 = v7;
        _os_signpost_emit_with_name_impl(&dword_193671000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v5, "gpu_compute", "cb:%p [%u, %u]", (uint8_t *)&v9, 0x18u);
      }
    }
  }
}

void ___ZL8GetQueuev_block_invoke()
{
  id v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  gSurfaceCacheQueue = (uint64_t)dispatch_queue_create("CI::SurfaceCacheQueue", v0);
  global_queue = dispatch_get_global_queue(2, 0);
  gMemoryPressure = (uint64_t)dispatch_source_create(MEMORY[0x1E4F14468], 0, 6uLL, global_queue);
  dispatch_source_set_event_handler((dispatch_source_t)gMemoryPressure, &__block_literal_global_75);
  uint64_t v2 = gMemoryPressure;

  dispatch_resume(v2);
}

CFTypeRef CI::RenderTask::waitUntilCompleted(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 144) == *(void *)(a1 + 136)) {
    return 0;
  }
  uint64_t v4 = ci_signpost_log_render();
  if ((unint64_t)((a2 << 32) - 1) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    os_signpost_id_t v5 = v4;
    if (os_signpost_enabled(v4))
    {
      *(_WORD *)unint64_t v19 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v5, OS_SIGNPOST_INTERVAL_BEGIN, a2 << 32, "wait", "", v19, 2u);
    }
  }
  TimerBase::TimerBase((uint64_t)v19, a2, 0, (uint64_t)"wait", 19);
  dispatch_group_wait(*(dispatch_group_t *)(*(void *)(*(void *)(a1 + 144) - 8) + 16), 0xFFFFFFFFFFFFFFFFLL);
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 20CI::NodeWithChildren::NodeWithChildren(this, 0) = 0u;
  *(void *)(a1 + 216) = 0;
  uint64_t v6 = *(CI::TileTask ***)(a1 + 136);
  double v7 = *(CI::TileTask ***)(a1 + 144);
  while (1)
  {
    if (v6 == v7)
    {
      CFTypeRef v13 = 0;
      goto LABEL_17;
    }
    uint64_t v8 = CI::TileTask::commandBufferError(*v6);
    int v9 = *v6;
    if (v8) {
      break;
    }
    *(double *)(a1 + 168) = CI::TileTask::executionTime(v9) + *(double *)(a1 + 168);
    *(double *)(a1 + 176) = CI::TileTask::compileTime(*v6);
    *(double *)(a1 + 184) = CI::TileTask::compileWaitTime(*v6) + *(double *)(a1 + 184);
    *(void *)(a1 + 192) += CI::TileTask::executionCycles(*v6);
    uint64_t v10 = *v6;
    __int16 v11 = (void *)*((void *)*v6 + 18);
    if (v11)
    {
      uint64_t v12 = 0;
      do
      {
        v12 += (uint64_t)(v11[4] - v11[3]) >> 5;
        __int16 v11 = (void *)*v11;
      }
      while (v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    *(void *)(a1 + 200) += v12;
    *(void *)(a1 + 208) += CI::TileTask::pixelsProcessed(v10);
    *(void *)(a1 + 216) += CI::TileTask::pixelsOverdrawn(v10);
    ++v6;
  }
  unsigned int v14 = (const void *)CI::TileTask::commandBufferError(v9);
  CFTypeRef v13 = CFRetain(v14);
LABEL_17:
  uint64_t v15 = ci_signpost_log_render();
  os_signpost_id_t v16 = v20;
  if (v20 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    BOOL v17 = v15;
    if (os_signpost_enabled(v15))
    {
      *(_WORD *)CGRect buf = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v17, OS_SIGNPOST_INTERVAL_END, v16, "wait", "", buf, 2u);
    }
  }
  TimerBase::~TimerBase((TimerBase *)v19);
  return v13;
}

uint64_t CI::TileTask::commandBufferError(CI::TileTask *this)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  uint64_t v1 = *((void *)this + 21);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK2CI8TileTask18commandBufferErrorEv_block_invoke;
  v4[3] = &unk_1E5776C50;
  v4[4] = &v5;
  void v4[5] = this;
  dispatch_sync(v1, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t CI::TileTask::pixelsOverdrawn(CI::TileTask *this)
{
  uint64_t v1 = *((void *)this + 18);
  if (v1)
  {
    uint64_t v2 = 0;
    do
    {
      uint64_t v64 = v2;
      std::string __p = 0;
      CGRect v72 = 0;
      uint64_t v73 = 0;
      CGRect v69 = 0;
      unint64_t v70 = 0;
      CGRect v68 = (uint64_t *)&v69;
      uint64_t v4 = *(double **)(v1 + 24);
      uint64_t v3 = *(double **)(v1 + 32);
      if (v4 == v3)
      {
        unint64_t v5 = 0;
      }
      else
      {
        do
        {
          std::__tree<double>::__emplace_unique_key_args<double,double const&>(&v68, v4, (uint64_t *)v4);
          double v66 = *v4 + v4[2];
          std::__tree<double>::__emplace_unique_key_args<double,double const&>(&v68, &v66, (uint64_t *)&v66);
          v4 += 4;
        }
        while (v4 != v3);
        unint64_t v5 = v70;
      }
      std::vector<double>::reserve(&__p, v5);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>,std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>,std::back_insert_iterator<std::vector<double>>>((uint64_t)&v66, v68, &v69, (uint64_t)&__p);
      std::__sort<std::__less<double,double> &,double *>();
      std::vector<std::vector<CGRect>>::vector(&v66, ((char *)v72 - (unsigned char *)__p) >> 3);
      CGRect v65 = (uint64_t *)v1;
      uint64_t v6 = *(double **)(v1 + 24);
      uint64_t v7 = *(double **)(v1 + 32);
      if (v6 != v7)
      {
        int v9 = (double *)__p;
        uint64_t v8 = v72;
        uint64_t v10 = v72;
        do
        {
          if (v10 == v9)
          {
            uint64_t v10 = v9;
          }
          else
          {
            double v11 = *v6;
            double v12 = *v6 + v6[2];
            double v13 = *v9;
            if (*v9 < v12)
            {
              uint64_t v14 = 0;
              double v15 = v6[1];
              double v16 = v15 + v6[3];
              while (1)
              {
                if (v13 >= v11)
                {
                  uint64_t v17 = *(void *)&v66 + 24 * v14;
                  unint64_t v19 = (double **)(v17 + 8);
                  unint64_t v18 = *(double **)(v17 + 8);
                  uint64_t v21 = (void *)(v17 + 16);
                  unint64_t v20 = *(void *)(v17 + 16);
                  if ((unint64_t)v18 >= v20)
                  {
                    unint64_t v23 = *(double **)v17;
                    uint64_t v24 = ((uint64_t)v18 - *(void *)v17) >> 4;
                    unint64_t v25 = v24 + 1;
                    if ((unint64_t)(v24 + 1) >> 60) {
                      goto LABEL_75;
                    }
                    uint64_t v26 = v20 - (void)v23;
                    if (v26 >> 3 > v25) {
                      unint64_t v25 = v26 >> 3;
                    }
                    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v27 = v25;
                    }
                    if (v27)
                    {
                      unint64_t v28 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)v21, v27);
                      unint64_t v18 = *v19;
                      unint64_t v23 = *(double **)v17;
                    }
                    else
                    {
                      unint64_t v28 = 0;
                    }
                    size_t v29 = &v28[16 * v24];
                    *(double *)size_t v29 = v15;
                    *((_DWORD *)v29 + 2) = 1;
                    long long v30 = v29;
                    if (v18 != v23)
                    {
                      do
                      {
                        *((_OWORD *)v30 - 1) = *((_OWORD *)v18 - 1);
                        v30 -= 16;
                        v18 -= 2;
                      }
                      while (v18 != v23);
                      unint64_t v23 = *(double **)v17;
                    }
                    *(void *)uint64_t v17 = v30;
                    uint64_t v22 = (double *)(v29 + 16);
                    *unint64_t v19 = (double *)(v29 + 16);
                    *uint64_t v21 = &v28[16 * v27];
                    if (v23) {
                      operator delete(v23);
                    }
                  }
                  else
                  {
                    *unint64_t v18 = v15;
                    *((_DWORD *)v18 + 2) = 1;
                    uint64_t v22 = v18 + 2;
                  }
                  *unint64_t v19 = v22;
                  uint64_t v31 = *(void *)&v66 + 24 * v14;
                  uint64_t v33 = (double **)(v31 + 8);
                  uint64_t v32 = *(double **)(v31 + 8);
                  long long v35 = (void *)(v31 + 16);
                  unint64_t v34 = *(void *)(v31 + 16);
                  if ((unint64_t)v32 >= v34)
                  {
                    long long v37 = *(double **)v31;
                    uint64_t v38 = ((uint64_t)v32 - *(void *)v31) >> 4;
                    unint64_t v39 = v38 + 1;
                    if ((unint64_t)(v38 + 1) >> 60) {
LABEL_75:
                    }
                      abort();
                    uint64_t v40 = v34 - (void)v37;
                    if (v40 >> 3 > v39) {
                      unint64_t v39 = v40 >> 3;
                    }
                    if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v41 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v41 = v39;
                    }
                    if (v41)
                    {
                      int v42 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)v35, v41);
                      uint64_t v32 = *v33;
                      long long v37 = *(double **)v31;
                    }
                    else
                    {
                      int v42 = 0;
                    }
                    os_signpost_id_t v43 = &v42[16 * v38];
                    *(double *)os_signpost_id_t v43 = v16;
                    *((_DWORD *)v43 + 2) = -1;
                    uint64_t v44 = v43;
                    if (v32 != v37)
                    {
                      do
                      {
                        *((_OWORD *)v44 - 1) = *((_OWORD *)v32 - 1);
                        v44 -= 16;
                        v32 -= 2;
                      }
                      while (v32 != v37);
                      long long v37 = *(double **)v31;
                    }
                    *(void *)uint64_t v31 = v44;
                    uint64_t v36 = (double *)(v43 + 16);
                    *uint64_t v33 = (double *)(v43 + 16);
                    *long long v35 = &v42[16 * v41];
                    if (v37) {
                      operator delete(v37);
                    }
                  }
                  else
                  {
                    *uint64_t v32 = v16;
                    *((_DWORD *)v32 + 2) = -1;
                    uint64_t v36 = v32 + 2;
                  }
                  *uint64_t v33 = v36;
                  int v9 = (double *)__p;
                  uint64_t v8 = v72;
                }
                if (++v14 >= (unint64_t)(v8 - v9)) {
                  break;
                }
                double v13 = v9[v14];
                uint64_t v10 = v8;
                if (v13 >= v12) {
                  goto LABEL_51;
                }
              }
              uint64_t v10 = v8;
            }
          }
LABEL_51:
          v6 += 4;
        }
        while (v6 != v7);
      }
      long long v45 = *(uint64_t **)&v66;
      long long v46 = v67;
      while (v45 != v46)
      {
        uint64_t v47 = *v45;
        unint64_t v48 = v45[1];
        v45 += 3;
        unint64_t v49 = 126 - 2 * __clz((uint64_t)(v48 - v47) >> 4);
        if (v48 == v47) {
          uint64_t v50 = 0;
        }
        else {
          uint64_t v50 = v49;
        }
        std::__introsort<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*,false>(v47, v48, v50, 1);
      }
      unint64_t v51 = 0;
      if (((char *)v72 - (unsigned char *)__p) >> 3 == 1)
      {
        uint64_t v54 = v64;
      }
      else
      {
        uint64_t v52 = 0;
        double v53 = *(double *)__p;
        uint64_t v54 = v64;
        do
        {
          double v55 = v53;
          int64x2_t v56 = (uint64_t *)(*(void *)&v66 + 24 * v52++);
          double v53 = *((double *)__p + v52);
          uint64_t v57 = *v56;
          uint64_t v58 = v56[1];
          if (v57 != v58)
          {
            int v59 = 0;
            double v60 = v53 - v55;
            double v61 = 0.0;
            do
            {
              if (v59)
              {
                v59 += *(_DWORD *)(v57 + 8);
                if (!v59) {
                  unint64_t v51 = (unint64_t)((double)v51 + v60 * (*(double *)v57 - v61));
                }
              }
              else
              {
                double v61 = *(double *)v57;
                int v59 = *(_DWORD *)(v57 + 8);
              }
              v57 += 16;
            }
            while (v57 != v58);
          }
        }
        while (v52 != (((char *)v72 - (unsigned char *)__p) >> 3) - 1);
      }
      CGRect v74 = (void **)&v66;
      std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100](&v74);
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v68, v69);
      if (__p)
      {
        CGRect v72 = (double *)__p;
        operator delete(__p);
      }
      uint64_t v2 = v51 + v54;
      uint64_t v1 = *v65;
    }
    while (*v65);
  }
  else
  {
    uint64_t v2 = 0;
  }
  return CI::TileTask::pixelsProcessed(this) - v2;
}

uint64_t *std::__tree<double>::__emplace_unique_key_args<double,double const&>(uint64_t **a1, double *a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    double v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        double v9 = *((double *)v5 + 4);
        if (v7 >= v9) {
          break;
        }
        unint64_t v5 = (uint64_t *)*v5;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      unint64_t v5 = (uint64_t *)v5[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x28uLL);
    void v10[4] = *a3;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = (uint64_t)(a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                double v40 = *(double *)(a2 - 16);
                double v41 = *(double *)v10;
                if (v40 < *(double *)v10)
                {
                  *(double *)unint64_t v10 = v40;
                  *(double *)(a2 - 16) = v41;
                  int v42 = *(_DWORD *)(v10 + 8);
                  *(_DWORD *)(v10 + 8) = *(_DWORD *)(a2 - 8);
                  *(_DWORD *)(a2 - 8) = v42;
                }
                break;
              case 3uLL:
                uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*>(v10, v10 + 16, a2 - 16);
                break;
              case 4uLL:
                uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*>(v10, v10 + 16, v10 + 32, a2 - 16);
                break;
              case 5uLL:
                uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*>(v10, v10 + 16, v10 + 32, v10 + 48);
                double v43 = *(double *)(a2 - 16);
                double v44 = *(double *)(v10 + 48);
                if (v43 < v44)
                {
                  *(double *)(v10 + 48) = v43;
                  *(double *)(a2 - 16) = v44;
                  int v45 = *(_DWORD *)(v10 + 56);
                  *(_DWORD *)(v10 + 56) = *(_DWORD *)(a2 - 8);
                  *(_DWORD *)(a2 - 8) = v45;
                  double v46 = *(double *)(v10 + 48);
                  double v47 = *(double *)(v10 + 32);
                  if (v46 < v47)
                  {
                    *(double *)(v10 + 32) = v46;
                    *(double *)(v10 + 48) = v47;
                    int v48 = *(_DWORD *)(v10 + 40);
                    int v49 = *(_DWORD *)(v10 + 56);
                    *(_DWORD *)(v10 + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = v49;
                    *(_DWORD *)(v10 + 56) = v48;
                    double v50 = *(double *)(v10 + 16);
                    if (v46 < v50)
                    {
                      *(double *)(v10 + 16) = v46;
                      *(double *)(v10 + 32) = v50;
                      int v51 = *(_DWORD *)(v10 + 24);
                      *(_DWORD *)(v10 + 24) = v49;
                      *(_DWORD *)(v10 + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = v51;
                      double v52 = *(double *)v10;
                      if (v46 < *(double *)v10)
                      {
                        *(double *)unint64_t v10 = v46;
                        *(double *)(v10 + 16) = v52;
                        int v53 = *(_DWORD *)(v10 + 8);
                        *(_DWORD *)(v10 + 8) = v49;
                        *(_DWORD *)(v10 + 24) = v53;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 383)
          {
            unint64_t v54 = v10 + 16;
            BOOL v56 = v10 == a2 || v54 == a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  unint64_t v59 = v54;
                  double v60 = *(double *)(v58 + 16);
                  double v61 = *(double *)v58;
                  if (v60 < *(double *)v58)
                  {
                    uint64_t v62 = *(void *)(v58 + 24);
                    uint64_t v63 = v57;
                    while (1)
                    {
                      uint64_t v64 = v10 + v63;
                      *(double *)(v64 + 16) = v61;
                      *(_DWORD *)(v64 + 24) = *(_DWORD *)(v10 + v63 + 8);
                      if (!v63) {
                        break;
                      }
                      double v61 = *(double *)(v64 - 16);
                      v63 -= 16;
                      if (v60 >= v61)
                      {
                        uint64_t v65 = v10 + v63 + 16;
                        goto LABEL_85;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_85:
                    *(double *)uint64_t v65 = v60;
                    *(_DWORD *)(v65 + 8) = v62;
                  }
                  unint64_t v54 = v59 + 16;
                  v57 += 16;
                  unint64_t v58 = v59;
                }
                while (v59 + 16 != a2);
              }
            }
            else if (!v56)
            {
              CGRect v94 = (double *)(v10 + 24);
              do
              {
                unint64_t v95 = v54;
                double v96 = *(double *)(v9 + 16);
                double v97 = *(double *)v9;
                if (v96 < *(double *)v9)
                {
                  uint64_t v98 = *(void *)(v9 + 24);
                  CGRect v99 = v94;
                  do
                  {
                    CGRect v100 = v99;
                    *(v99 - 1) = v97;
                    int v101 = *((_DWORD *)v99 - 4);
                    v99 -= 2;
                    *(_DWORD *)CGRect v100 = v101;
                    double v97 = *(v100 - 5);
                  }
                  while (v96 < v97);
                  *(v99 - 1) = v96;
                  *(_DWORD *)CGRect v99 = v98;
                }
                unint64_t v54 = v95 + 16;
                v94 += 2;
                unint64_t v9 = v95;
              }
              while (v95 + 16 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 16 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12 && *(double *)v70 < *(double *)(v70 + 16))
                  {
                    v70 += 16;
                    uint64_t v69 = 2 * v68 + 2;
                  }
                  unint64_t v71 = v10 + 16 * v68;
                  double v72 = *(double *)v70;
                  double v73 = *(double *)v71;
                  if (*(double *)v70 >= *(double *)v71)
                  {
                    uint64_t v74 = *(void *)(v71 + 8);
                    do
                    {
                      unint64_t v75 = v71;
                      unint64_t v71 = v70;
                      *(double *)unint64_t v75 = v72;
                      *(_DWORD *)(v75 + 8) = *(_DWORD *)(v70 + 8);
                      if (v66 < v69) {
                        break;
                      }
                      uint64_t v76 = 2 * v69;
                      uint64_t v69 = (2 * v69) | 1;
                      unint64_t v70 = v10 + 16 * v69;
                      uint64_t v77 = v76 + 2;
                      if (v77 < (uint64_t)v12 && *(double *)v70 < *(double *)(v70 + 16))
                      {
                        v70 += 16;
                        uint64_t v69 = v77;
                      }
                      double v72 = *(double *)v70;
                    }
                    while (*(double *)v70 >= v73);
                    *(double *)unint64_t v71 = v73;
                    *(_DWORD *)(v71 + 8) = v74;
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              uint64_t v78 = (unint64_t)v11 >> 4;
              do
              {
                uint64_t v79 = 0;
                double v80 = *(double *)v10;
                int v81 = *(_DWORD *)(v10 + 8);
                unint64_t v82 = v10;
                do
                {
                  unint64_t v83 = v82;
                  v82 += 16 * v79 + 16;
                  uint64_t v84 = 2 * v79;
                  uint64_t v79 = (2 * v79) | 1;
                  uint64_t v85 = v84 + 2;
                  if (v85 < v78 && *(double *)v82 < *(double *)(v82 + 16))
                  {
                    v82 += 16;
                    uint64_t v79 = v85;
                  }
                  *(void *)unint64_t v83 = *(void *)v82;
                  *(_DWORD *)(v83 + 8) = *(_DWORD *)(v82 + 8);
                }
                while (v79 <= (uint64_t)((unint64_t)(v78 - 2) >> 1));
                if (v82 == a2 - 16)
                {
                  *(double *)unint64_t v82 = v80;
                  *(_DWORD *)(v82 + 8) = v81;
                }
                else
                {
                  *(void *)unint64_t v82 = *(void *)(a2 - 16);
                  *(_DWORD *)(v82 + 8) = *(_DWORD *)(a2 - 8);
                  *(double *)(a2 - 16) = v80;
                  *(_DWORD *)(a2 - 8) = v81;
                  uint64_t v86 = v82 - v10 + 16;
                  if (v86 >= 17)
                  {
                    unint64_t v87 = (((unint64_t)v86 >> 4) - 2) >> 1;
                    unint64_t v88 = v10 + 16 * v87;
                    double v89 = *(double *)v88;
                    double v90 = *(double *)v82;
                    if (*(double *)v88 < *(double *)v82)
                    {
                      uint64_t v91 = *(void *)(v82 + 8);
                      do
                      {
                        unint64_t v92 = v82;
                        unint64_t v82 = v88;
                        *(double *)unint64_t v92 = v89;
                        *(_DWORD *)(v92 + 8) = *(_DWORD *)(v88 + 8);
                        if (!v87) {
                          break;
                        }
                        unint64_t v87 = (v87 - 1) >> 1;
                        unint64_t v88 = v10 + 16 * v87;
                        double v89 = *(double *)v88;
                      }
                      while (*(double *)v88 < v90);
                      *(double *)unint64_t v82 = v90;
                      *(_DWORD *)(v82 + 8) = v91;
                    }
                  }
                }
                a2 -= 16;
              }
              while (v78-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = v10 + 16 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*>(v9, v9 + 16 * (v12 >> 1), a2 - 16);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*>(v9 + 16, v14 - 16, a2 - 32);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*>(v9 + 32, v9 + 16 + 16 * v13, a2 - 48);
            uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*>(v14 - 16, v14, v9 + 16 + 16 * v13);
            double v15 = *(double *)v9;
            *(void *)unint64_t v9 = *(void *)v14;
            *(double *)uint64_t v14 = v15;
            int v16 = *(_DWORD *)(v9 + 8);
            *(_DWORD *)(v9 + 8) = *(_DWORD *)(v14 + 8);
            *(_DWORD *)(v14 + 8) = v16;
          }
          else
          {
            uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*>(v9 + 16 * (v12 >> 1), v9, a2 - 16);
          }
          --a3;
          double v17 = *(double *)v9;
          if (a4) {
            break;
          }
          uint64_t v18 = *(void *)(v9 + 8);
          if (*(double *)(v9 - 16) < v17) {
            goto LABEL_13;
          }
          if (v17 >= *(double *)(a2 - 16))
          {
            unint64_t v32 = v9 + 16;
            do
            {
              unint64_t v10 = v32;
              if (v32 >= a2) {
                break;
              }
              v32 += 16;
            }
            while (v17 >= *(double *)v10);
          }
          else
          {
            unint64_t v10 = v9;
            do
            {
              double v31 = *(double *)(v10 + 16);
              v10 += 16;
            }
            while (v17 >= v31);
          }
          unint64_t v33 = a2;
          if (v10 < a2)
          {
            unint64_t v33 = a2;
            do
            {
              double v34 = *(double *)(v33 - 16);
              v33 -= 16;
            }
            while (v17 < v34);
          }
          if (v10 < v33)
          {
            double v35 = *(double *)v10;
            double v36 = *(double *)v33;
            do
            {
              *(double *)unint64_t v10 = v36;
              *(double *)unint64_t v33 = v35;
              int v37 = *(_DWORD *)(v10 + 8);
              *(_DWORD *)(v10 + 8) = *(_DWORD *)(v33 + 8);
              *(_DWORD *)(v33 + 8) = v37;
              do
              {
                double v38 = *(double *)(v10 + 16);
                v10 += 16;
                double v35 = v38;
              }
              while (v17 >= v38);
              do
              {
                double v39 = *(double *)(v33 - 16);
                v33 -= 16;
                double v36 = v39;
              }
              while (v17 < v39);
            }
            while (v10 < v33);
          }
          BOOL v4 = v10 - 16 >= v9;
          BOOL v5 = v10 - 16 == v9;
          if (v10 - 16 != v9)
          {
            *(void *)unint64_t v9 = *(void *)(v10 - 16);
            *(_DWORD *)(v9 + 8) = *(_DWORD *)(v10 - 8);
          }
          a4 = 0;
          *(double *)(v10 - 16) = v17;
          *(_DWORD *)(v10 - 8) = v18;
        }
        uint64_t v18 = *(void *)(v9 + 8);
LABEL_13:
        uint64_t v19 = 0;
        do
        {
          double v20 = *(double *)(v9 + v19 + 16);
          v19 += 16;
        }
        while (v20 < v17);
        unint64_t v21 = v9 + v19;
        uint64_t v22 = (double *)a2;
        if (v19 == 16)
        {
          uint64_t v22 = (double *)a2;
          do
          {
            if (v21 >= (unint64_t)v22) {
              break;
            }
            double v24 = *(v22 - 2);
            v22 -= 2;
          }
          while (v24 >= v17);
        }
        else
        {
          do
          {
            double v23 = *(v22 - 2);
            v22 -= 2;
          }
          while (v23 >= v17);
        }
        if (v21 >= (unint64_t)v22)
        {
          unint64_t v10 = v9 + v19;
        }
        else
        {
          double v25 = *v22;
          unint64_t v10 = v9 + v19;
          uint64_t v26 = v22;
          do
          {
            *(double *)unint64_t v10 = v25;
            double *v26 = v20;
            int v27 = *(_DWORD *)(v10 + 8);
            *(_DWORD *)(v10 + 8) = *((_DWORD *)v26 + 2);
            *((_DWORD *)v26 + 2) = v27;
            do
            {
              double v28 = *(double *)(v10 + 16);
              v10 += 16;
              double v20 = v28;
            }
            while (v28 < v17);
            do
            {
              double v29 = *(v26 - 2);
              v26 -= 2;
              double v25 = v29;
            }
            while (v29 >= v17);
          }
          while (v10 < (unint64_t)v26);
        }
        if (v10 - 16 != v9)
        {
          *(void *)unint64_t v9 = *(void *)(v10 - 16);
          *(_DWORD *)(v9 + 8) = *(_DWORD *)(v10 - 8);
        }
        *(double *)(v10 - 16) = v17;
        *(_DWORD *)(v10 - 8) = v18;
        if (v21 >= (unint64_t)v22) {
          break;
        }
LABEL_34:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*,false>(v9, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v30 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*>(v9, v10 - 16);
      uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,CI::TileTask::pixelsOverdrawn(void)::$_0::operator() const(std::vector<CGRect> const&)::{lambda(std::pair<double,int>,std::pair<double,int>)#1} &,std::pair<double,int>*>(v10, a2);
      if (result) {
        break;
      }
      if (!v30) {
        goto LABEL_34;
      }
    }
    a2 = v10 - 16;
    if (!v30) {
      continue;
    }
    return result;
  }
}

unint64_t CI::TileTask::pixelsProcessed(CI::TileTask *this)
{
  uint64_t v1 = (void *)*((void *)this + 18);
  if (!v1) {
    return 0;
  }
  unint64_t result = 0;
  do
  {
    for (uint64_t i = v1[3]; i != v1[4]; i += 32)
      unint64_t result = (unint64_t)((double)result + ceil(*(double *)(i + 16)) * ceil(*(double *)(i + 24)));
    uint64_t v1 = (void *)*v1;
  }
  while (v1);
  return result;
}

void std::vector<double>::reserve(void **a1, unint64_t a2)
{
  BOOL v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v3, a2);
    double v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v9 = &v6[8 * v8];
    unint64_t v10 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    unint64_t v12 = v7;
    if (v11 != *a1)
    {
      unint64_t v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void *std::vector<std::vector<CGRect>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](a1, a2);
    BOOL v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<IRect>>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::vector<IRect>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      size_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

char *std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    abort();
  }
  unint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(24 * a2);
}

void *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>,std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>,std::back_insert_iterator<std::vector<double>>>(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v4 = a2;
  uint64_t v10 = a4;
  if (a2 == a3) {
    return a2;
  }
  size_t v5 = a3;
  do
  {
    std::back_insert_iterator<std::vector<double>>::operator=[abi:nn180100](&v10, v4 + 4);
    uint64_t v6 = (void *)v4[1];
    if (v6)
    {
      do
      {
        double v7 = v6;
        uint64_t v6 = (void *)*v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        double v7 = (void *)v4[2];
        BOOL v8 = *v7 == (void)v4;
        uint64_t v4 = v7;
      }
      while (!v8);
    }
    uint64_t v4 = v7;
  }
  while (v7 != v5);
  return v5;
}

uint64_t *std::back_insert_iterator<std::vector<double>>::operator=[abi:nn180100](uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  size_t v5 = *(void **)(*a1 + 8);
  uint64_t v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    BOOL v8 = *(void **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      abort();
    }
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)v6, v12);
      BOOL v8 = *(void **)v4;
      size_t v5 = *(void **)(v4 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    double v15 = &v13[8 * v12];
    *(void *)uint64_t v14 = *a2;
    double v7 = v14 + 8;
    while (v5 != v8)
    {
      uint64_t v16 = *--v5;
      *((void *)v14 - 1) = v16;
      v14 -= 8;
    }
    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *size_t v5 = *a2;
    double v7 = v5 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

uint64_t CI::TileTask::executionCycles(CI::TileTask *this)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  uint64_t v1 = *((void *)this + 21);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK2CI8TileTask15executionCyclesEv_block_invoke;
  v4[3] = &unk_1E5776DD0;
  v4[4] = &v5;
  void v4[5] = this;
  dispatch_sync(v1, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

double CI::TileTask::compileWaitTime(CI::TileTask *this)
{
  uint64_t v5 = 0;
  uint64_t v6 = (double *)&v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  uint64_t v1 = *((void *)this + 21);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK2CI8TileTask15compileWaitTimeEv_block_invoke;
  v4[3] = &unk_1E5776D80;
  v4[4] = &v5;
  void v4[5] = this;
  dispatch_sync(v1, v4);
  double v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

double CI::TileTask::executionTime(CI::TileTask *this)
{
  uint64_t v5 = 0;
  uint64_t v6 = (double *)&v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  uint64_t v1 = *((void *)this + 21);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK2CI8TileTask13executionTimeEv_block_invoke;
  v4[3] = &unk_1E5776D58;
  v4[4] = &v5;
  void v4[5] = this;
  dispatch_sync(v1, v4);
  double v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

double CI::TileTask::compileTime(CI::TileTask *this)
{
  uint64_t v5 = 0;
  uint64_t v6 = (double *)&v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  uint64_t v1 = *((void *)this + 21);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK2CI8TileTask11compileTimeEv_block_invoke;
  v4[3] = &unk_1E5776DA8;
  v4[4] = &v5;
  void v4[5] = this;
  dispatch_sync(v1, v4);
  double v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t *___ZN2CI14TextureManager25add_intermediate_for_nodeERKNS_6roiKeyEPNS_14intermediate_tE_block_invoke(void *a1)
{
  double v2 = (uint64_t **)(a1[6] + 144);
  *(void *)&long long v6 = a1[7];
  uint64_t v3 = std::__tree<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>>>::__emplace_unique_key_args<CI::Node const*,std::piecewise_construct_t const&,std::tuple<CI::Node const* const&>,std::tuple<>>(v2, (unint64_t *)v6, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6);
  uint64_t v4 = *(void *)(a1[4] + 8);
  LODWORD(v6) = *(_DWORD *)(a1[7] + 8);
  *((void *)&v6 + 1) = *(void *)(v4 + 24);
  std::__tree<std::__value_type<int const,CI::TextureManager::tmIntermediate_t *>,std::__map_value_compare<int const,std::__value_type<int const,CI::TextureManager::tmIntermediate_t *>,std::less<int const>,true>,std::allocator<std::__value_type<int const,CI::TextureManager::tmIntermediate_t *>>>::__emplace_multi<std::pair<int const,CI::TextureManager::tmIntermediate_t *>>((uint64_t **)v3 + 5, &v6);
  *(void *)&long long v6 = a1[7];
  unint64_t result = std::__tree<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>>>::__emplace_unique_key_args<CI::Node const*,std::piecewise_construct_t const&,std::tuple<CI::Node const* const&>,std::tuple<>>(v2, (unint64_t *)v6, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6);
  *(void *)(*(void *)(a1[5] + 8) + 24) = result[7];
  return result;
}

uint64_t *std::__tree<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>>>::__emplace_unique_key_args<CI::Node const*,std::piecewise_construct_t const&,std::tuple<CI::Node const* const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v7 = a1 + 1;
  long long v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        long long v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      long long v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x40uLL);
    uint64_t v12 = **a4;
    v11[7] = 0;
    v11[6] = 0;
    v11[4] = v12;
    v11[5] = (uint64_t)(v11 + 6);
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void __PurgeCacheEntriesForImage_block_invoke(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 32);
  uint64_t v2 = CI::gCacheList;
  if (v1) {
    BOOL v3 = CI::gCacheList == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    goto LABEL_18;
  }
  uint64_t v4 = *(void *)(CI::gCacheList + 8);
  if (v4 == CI::gCacheList) {
    goto LABEL_18;
  }
  char v5 = 0;
  do
  {
    uint64_t v6 = *(void *)(v4 + 16);
    if (*(_DWORD *)(v6 + 60) == v1)
    {
      if (*(void *)(v6 + 88)) {
        *(_DWORD *)(v6 + 96) = -1;
      }
      else {
        CI::SurfaceCacheEntry::empty((IOSurfaceRef *)v6);
      }
      char v5 = 1;
    }
    uint64_t v4 = *(void *)(v4 + 8);
  }
  while (v4 != v2);
  if ((v5 & 1) == 0)
  {
LABEL_18:
    CI_LOG_SURFACE_CACHE();
  }
  else
  {
    CI::UpdateVolatilityStats((CI *)v6);
    int v7 = CI_LOG_SURFACE_CACHE();
    if (v7)
    {
      BOOL v9 = v7 > 1;
      CI::LogCacheState((CI *)v9, (uint64_t)"PurgeCacheEntriesForImage", v8);
    }
  }
}

void ___ZL8GetQueuev_block_invoke_3(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = CI::gCacheList;
  if (!CI::gCacheList || (uint64_t v18 = 0, v19 = 0, v17 = 0, v3 = *(void *)(CI::gCacheList + 8), v3 == CI::gCacheList))
  {
    CI_LOG_SURFACE_CACHE();
  }
  else
  {
    uint64_t v4 = 0;
    char v5 = 0;
    do
    {
      uint64_t v6 = *(CI **)(v3 + 16);
      if (!*((void *)v6 + 11))
      {
        if (v4 >= v19)
        {
          uint64_t v7 = ((char *)v4 - v17) >> 3;
          if ((unint64_t)(v7 + 1) >> 61) {
            abort();
          }
          unint64_t v8 = ((char *)v19 - v17) >> 2;
          if (v8 <= v7 + 1) {
            unint64_t v8 = v7 + 1;
          }
          if ((unint64_t)((char *)v19 - v17) >= 0x7FFFFFFFFFFFFFF8) {
            a2 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            a2 = v8;
          }
          if (a2) {
            BOOL v9 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v19, a2);
          }
          else {
            BOOL v9 = 0;
          }
          unint64_t v10 = &v9[8 * v7];
          *(void *)unint64_t v10 = v6;
          uint64_t v4 = (CI **)(v10 + 8);
          uint64_t v11 = v18;
          if (v18 != (CI **)v17)
          {
            do
            {
              uint64_t v12 = (uint64_t)*--v11;
              *((void *)v10 - 1) = v12;
              v10 -= 8;
            }
            while (v11 != (CI **)v17);
            uint64_t v11 = (CI **)v17;
          }
          double v17 = v10;
          uint64_t v19 = (CI **)&v9[8 * a2];
          if (v11) {
            operator delete(v11);
          }
        }
        else
        {
          *v4++ = v6;
        }
        uint64_t v18 = v4;
        char v5 = 1;
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v2);
    uint64_t v13 = (CI **)v17;
    if (v17 != (char *)v4)
    {
      do
      {
        uint64_t v14 = *v13;
        CI::RemoveCacheEntry(*v13, (CI::SurfaceCacheEntry *)a2);
        if (v14) {
          (*(void (**)(CI *))(*(void *)v14 + 8))(v14);
        }
        ++v13;
      }
      while (v13 != v4);
      uint64_t v4 = (CI **)v17;
    }
    if (v4) {
      operator delete(v4);
    }
    int v15 = CI_LOG_SURFACE_CACHE();
    if ((v5 & (v15 != 0)) == 1) {
      CI::LogCacheState((CI *)(v15 > 1), (uint64_t)"MemoryPreasure", v16);
    }
  }
}

void ___ZN2CI13KernelArchive4findEyPKc_block_invoke(void *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  int v1 = (void *)a1[6];
  if (v1[1] != v1[2])
  {
    uint64_t v3 = objc_msgSend(NSString, "stringWithFormat:", @"ci_%016llX", a1[7]);
    uint64_t v4 = v1[7];
    if (v1[8] == v4)
    {
      LODWORD(v5) = 0;
    }
    else
    {
      unint64_t v5 = 0;
      while (![*(id *)(v4 + 8 * v5) containsObject:v3])
      {
        ++v5;
        uint64_t v4 = v1[7];
        if (v5 >= (v1[8] - v4) >> 3) {
          goto LABEL_9;
        }
      }
      *(void *)(*(void *)(a1[4] + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = [*(id *)(v1[1] + 8 * v5) newFunctionWithName:v3];
      *(void *)(*(void *)(a1[5] + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = *(void *)(v1[4] + 8 * v5);
    }
LABEL_9:
    if (CI_LOG_AIR_ARCHIVE_MISS() && !*(void *)(*(void *)(a1[4] + 8) + 40))
    {
      uint64_t v6 = ci_logger_render();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)CGRect buf = 138543362;
        uint64_t v17 = v3;
        _os_log_impl(&dword_193671000, v6, OS_LOG_TYPE_INFO, "Failed to find function %{public}@ in any air archive", buf, 0xCu);
      }
    }
    if (CI_LOG_AIR_ARCHIVE_ACTIVITY())
    {
      uint64_t v7 = *(void *)(*(void *)(a1[4] + 8) + 40);
      unint64_t v8 = ci_logger_render();
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_INFO);
      if (v7)
      {
        if (!v9) {
          return;
        }
        uint64_t v10 = a1[8];
        uint64_t v11 = (uint64_t)(v1[2] - v1[1]) >> 3;
        *(_DWORD *)CGRect buf = 138544130;
        uint64_t v17 = v3;
        __int16 v18 = 2082;
        uint64_t v19 = v10;
        __int16 v20 = 1024;
        int v21 = v5;
        __int16 v22 = 2048;
        uint64_t v23 = v11;
        uint64_t v12 = "Found function %{public}@ for %{public}s in the archive %d/%zu";
        uint64_t v13 = v8;
        uint32_t v14 = 38;
      }
      else
      {
        if (!v9) {
          return;
        }
        uint64_t v15 = a1[8];
        *(_DWORD *)CGRect buf = 138543618;
        uint64_t v17 = v3;
        __int16 v18 = 2082;
        uint64_t v19 = v15;
        uint64_t v12 = "Failed to find function %{public}@ for %{public}s in any air archive";
        uint64_t v13 = v8;
        uint32_t v14 = 22;
      }
      _os_log_impl(&dword_193671000, v13, OS_LOG_TYPE_INFO, v12, buf, v14);
    }
  }
}

void sub_1936C6688(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10F1C4010D716A0);
  _Unwind_Resume(a1);
}

void OptionIsTrueOrFalse(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = 0;
  if (a1 && a2) {
    unint64_t v5 = (void *)[a1 objectForKey:a2];
  }
  if (v5 == (void *)MEMORY[0x1E4F1CC38] || v5 == &unk_1EE4AA5F8)
  {
    uint64_t v7 = *(void (**)(uint64_t, uint64_t))(a3 + 16);
    uint64_t v8 = a3;
    uint64_t v9 = 1;
  }
  else
  {
    if (v5 != (void *)MEMORY[0x1E4F1CC28] && v5 != &unk_1EE4AA5E0)
    {
      if (v5)
      {
        uint64_t v11 = ci_logger_api();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          OptionIsTrueOrFalse((uint64_t)v5, a2, v11);
        }
      }
      return;
    }
    uint64_t v7 = *(void (**)(uint64_t, uint64_t))(a3 + 16);
    uint64_t v8 = a3;
    uint64_t v9 = 0;
  }

  v7(v8, v9);
}

uint64_t pointSetter(void *a1, const char *a2)
{
  uint64_t v4 = +[CIVector vectorWithCGPoint:](CIVector, "vectorWithCGPoint:");
  unint64_t v5 = keyForSetter(a2);

  return [a1 setValue:v4 forKey:v5];
}

uint64_t isWidget()
{
  if (isWidget_once != -1) {
    dispatch_once(&isWidget_once, &__block_literal_global_66);
  }
  return isWidget_bWidget;
}

uint64_t get_rgb_to_ycc_matrix(int a1, int a2, int a3, double *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  HIDWORD(v8) = a3;
  LODWORD(v8) = a3;
  unsigned int v7 = v8 >> 1;
  BOOL v9 = v7 > 8;
  int v10 = (1 << v7) & 0x171;
  if (v9 || v10 == 0) {
    return 0;
  }
  uint64_t result = 0;
  if (a1 > 708)
  {
    if (a1 == 2020)
    {
      float64x2_t v14 = (float64x2_t)xmmword_19395AC70;
      double v15 = 0.2627;
    }
    else
    {
      if (a1 != 709) {
        return result;
      }
      float64x2_t v14 = (float64x2_t)xmmword_19395AC90;
      double v15 = 0.2126;
    }
  }
  else if (a1 == 240)
  {
    float64x2_t v14 = (float64x2_t)xmmword_19395AC80;
    double v15 = 0.212;
  }
  else
  {
    if (a1 != 601) {
      return result;
    }
    float64x2_t v14 = (float64x2_t)xmmword_19395AC60;
    double v15 = 0.299;
  }
  *(double *)a5 = v15;
  *(float64x2_t *)(a5 + 8) = v14;
  double v16 = v14.f64[1];
  __asm { FMOV            V2.2D, #-0.5 }
  float64x2_t v21 = vmulq_f64(v14, _Q2);
  double v22 = 1.0;
  double v23 = 1.0 - v16;
  *(double *)a6 = v15 * -0.5 / v23;
  *(double *)(a6 + 8) = v21.f64[0] / v23;
  *(void *)(a6 + 16) = 0x3FE0000000000000;
  *(void *)a7 = 0x3FE0000000000000;
  *(float64x2_t *)(a7 + 8) = vdivq_f64(v21, (float64x2_t)vdupq_lane_s64(COERCE__INT64(1.0 - v15), 0));
  if (a3 == 16)
  {
    double v24 = 32768.0;
    double v25 = 65535.0;
    double v26 = 65534.0;
  }
  else if (a3 == 10)
  {
    double v24 = 512.0;
    double v25 = 1023.0;
    double v26 = 1022.0;
  }
  else if (a3 == 12)
  {
    double v24 = 2048.0;
    double v25 = 4095.0;
    double v26 = 4094.0;
  }
  else
  {
    if (a3 == 8) {
      double v25 = 255.0;
    }
    else {
      double v25 = 1.0;
    }
    if (a3 == 8) {
      double v26 = 254.0;
    }
    else {
      double v26 = 1.0;
    }
    double v24 = 128.0;
    if (a3 != 8) {
      double v24 = 1.0;
    }
  }
  if (a3 == 10) {
    double v22 = 4.0;
  }
  if (a3 == 12) {
    double v22 = 16.0;
  }
  double v27 = 256.0;
  if (a3 != 16) {
    double v27 = v22;
  }
  if (a2)
  {
    double v28 = v26 / v25;
    double v29 = 1.0;
    if (!a3) {
      double v28 = 1.0;
    }
    double v30 = 0.0;
  }
  else if (a3)
  {
    double v29 = v27 * 219.0 / v25;
    double v28 = v27 * 224.0 / v25;
    double v30 = v27 * 16.0 / v25;
  }
  else
  {
    double v29 = 1.0;
    double v30 = 0.0;
    double v28 = 1.0;
  }
  double v31 = v24 / v25;
  if (!a3) {
    double v31 = 0.0;
  }
  a4[1] = v31;
  a4[2] = v31;
  *a4 = v30;
  *(float64x2_t *)a5 = vmulq_n_f64(*(float64x2_t *)a5, v29);
  *(double *)(a5 + 16) = v29 * *(double *)(a5 + 16);
  *(float64x2_t *)a6 = vmulq_n_f64(*(float64x2_t *)a6, v28);
  *(double *)(a6 + 16) = v28 * *(double *)(a6 + 16);
  *(float64x2_t *)a7 = vmulq_n_f64(*(float64x2_t *)a7, v28);
  *(double *)(a7 + 16) = v28 * *(double *)(a7 + 16);
  return 1;
}

uint64_t __isWidget_block_invoke()
{
  uint64_t result = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "mainBundle"), "bundlePath"), "pathExtension"), "containsString:", @"appex");
  if (result)
  {
    uint64_t result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F22448], "extensionPointRecordForCurrentProcess"), "identifier"), "isEqualToString:", @"com.apple.widgetkit-extension");
    isWidget_bWidget = result;
  }
  return result;
}

uint64_t __iosurface_limits_block_invoke()
{
  *(void *)&iosurface_limits_limits = MEMORY[0x199701F80](*MEMORY[0x1E4F2F2C0]);
  *((void *)&iosurface_limits_limits + 1) = MEMORY[0x199701F80](*MEMORY[0x1E4F2F0E8]);
  uint64_t result = MEMORY[0x199701F80](*MEMORY[0x1E4F2EFE0]);
  qword_1EB466D08 = result;
  return result;
}

CGColorSpaceRef ___ZN2CI7Context19defaultWorkingSpaceEv_block_invoke()
{
  int v0 = dyld_program_sdk_at_least();
  uint64_t v1 = (CFStringRef *)MEMORY[0x1E4F1DBE0];
  if (!v0) {
    uint64_t v1 = (CFStringRef *)MEMORY[0x1E4F1DC88];
  }
  CGColorSpaceRef result = CGColorSpaceCreateWithName(*v1);
  CI::Context::defaultWorkingSpace(void)::space = (uint64_t)result;
  return result;
}

void ___ZN2CI4Node16remove_parentROIERKNS_9parentROIERKNS_6roiKeyEPNS_14TextureManagerEPv_block_invoke_3(uint64_t a1)
{
}

uint64_t ___ZN2CI12MetalContext18binaryArchiveCacheEv_block_invoke()
{
  uint64_t result = objc_opt_new();
  CI::MetalContext::binaryArchiveCache(void)::cache = result;
  return result;
}

void ___ZN2CI11ObjectCacheINS_4NodeEyLb0EE6insertEyPS1_j_block_invoke(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  ++v2[1];
  uint64_t v3 = a1 + 5;
  uint64_t v4 = std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::find<CI::ProgramDigest>(v2 + 2, a1 + 5);
  if (v4)
  {
    v4[4] = v2[1];
    unint64_t v5 = (CI::Object *)a1[6];
    if (v5)
    {
      CI::Object::unref(v5);
    }
  }
  else
  {
    if (v2[5] == *v2) {
      CI::ObjectCache<CI::Node,unsigned long long,false>::evict((uint64_t)v2);
    }
    *(void *)&long long v7 = a1 + 6;
    *((void *)&v7 + 1) = v2 + 1;
    unint64_t v8 = a1 + 7;
    BOOL v9 = v3;
    std::__hash_table<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>>>::__emplace_unique_impl<std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<CI::Node* const&,unsigned long long &,unsigned int const&>>(v2 + 2, (uint64_t)&std::piecewise_construct, &v9, &v7);
    uint64_t v6 = (CI::Object *)a1[6];
    if (v6) {
      CI::Object::unref(v6);
    }
  }
}

uint64_t ___ZL13CoreAnalyticsP8NSStringP9CIContext_block_invoke()
{
  return AnalyticsSendEventLazy();
}

uint64_t ___ZL12userDefaultsv_block_invoke()
{
  uint64_t result = [objc_alloc(MEMORY[0x1E4F1CB18]) initWithSuiteName:@"com.apple.coreimage"];
  userDefaults(void)::defaults = result;
  return result;
}

void __GetSurfaceFromCacheAndFill_block_invoke_20(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v2 = ci_signpost_log_cache();
    if (os_signpost_enabled(v2))
    {
      int v3 = *(_DWORD *)(a1 + 56);
      int v4 = *(_DWORD *)(a1 + 60);
      int v5 = *(_DWORD *)(a1 + 32);
      int v6 = *(_DWORD *)(a1 + 36);
      uint64_t v7 = *(void *)(a1 + 40);
      uint64_t v8 = *(void *)(a1 + 48);
      v9[0] = 67110400;
      v9[1] = v3;
      __int16 v10 = 1024;
      int v11 = v4;
      __int16 v12 = 1024;
      int v13 = v5;
      __int16 v14 = 1024;
      int v15 = v6;
      __int16 v16 = 2048;
      uint64_t v17 = v7;
      __int16 v18 = 2048;
      uint64_t v19 = v8;
      _os_signpost_emit_with_name_impl(&dword_193671000, v2, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "GetSurfaceFromCacheAndFill", "cid:%u iid:%u [%d %d %zu %zu]", (uint8_t *)v9, 0x2Eu);
    }
  }
}

uint64_t __GetSurfaceFromCacheAndFill_block_invoke(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v2 = ci_signpost_log_cache();
    if (os_signpost_enabled(v2))
    {
      int v3 = *(_DWORD *)(a1 + 96);
      int v4 = *(_DWORD *)(a1 + 100);
      int v5 = *(_DWORD *)(a1 + 56);
      int v6 = *(_DWORD *)(a1 + 60);
      uint64_t v7 = *(void *)(a1 + 64);
      uint64_t v8 = *(void *)(a1 + 72);
      *(_DWORD *)CGRect buf = 67110400;
      int v45 = v3;
      __int16 v46 = 1024;
      int v47 = v4;
      __int16 v48 = 1024;
      int v49 = v5;
      __int16 v50 = 1024;
      int v51 = v6;
      __int16 v52 = 2048;
      uint64_t v53 = v7;
      __int16 v54 = 2048;
      uint64_t v55 = v8;
      _os_signpost_emit_with_name_impl(&dword_193671000, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "GetSurfaceFromCacheAndFill", "cid:%u iid:%u [%d %d %zu %zu]", buf, 0x2Eu);
    }
  }
  v37[0] = MEMORY[0x1E4F143A8];
  v37[1] = 0x40000000;
  double v38 = __GetSurfaceFromCacheAndFill_block_invoke_20;
  double v39 = &__block_descriptor_tmp_21_3;
  int v9 = *(_DWORD *)(a1 + 100);
  int v42 = *(_DWORD *)(a1 + 96);
  int v43 = v9;
  long long v40 = *(_OWORD *)(a1 + 56);
  ++CI::gCacheGetCount;
  CFStringRef v10 = *(const __CFString **)(a1 + 80);
  uint64_t v41 = *(void *)(a1 + 72);
  long long v35 = v40;
  uint64_t v36 = v41;
  int v11 = *(_DWORD *)(a1 + 104);
  memset(v34, 0, sizeof(v34));
  uint64_t CacheEntryWithInfo = CI::FindCacheEntryWithInfo((uint64_t)&v35, v11, (uint64_t)v34, v42, v9, v10);
  if (CacheEntryWithInfo)
  {
    uint64_t v13 = CacheEntryWithInfo;
    __int16 v14 = *(const void **)(CacheEntryWithInfo + 24);
    if (v14) {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CFRetain(v14);
    }
    *(_DWORD *)(v13 + 96) = 1;
    CI::SurfaceCacheEntry::setIdentifier((CI::SurfaceCacheEntry *)v13, *(CFTypeRef *)(a1 + 80));
    ++*(void *)(v13 + 88);
    if (!SurfaceSetNonVolatile(*(__IOSurface **)(*(void *)(*(void *)(a1 + 40) + 8) + 24)))
    {
      CI::SurfaceCacheEntry::setFillBlock(v13, *(void **)(a1 + 32));
      CI::SurfaceCacheEntry::setFillQueue((CI::SurfaceCacheEntry *)v13, *(dispatch_object_t *)(a1 + 88));
      CI::SurfaceCacheEntry::fillAsync((CI::SurfaceCacheEntry *)v13);
      ++CI::gCacheGetCountPurged;
    }
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v13;
    uint64_t v16 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    if (v16) {
      CI::Object::ref(v16);
    }
    uint64_t v17 = (CI *)CI::MoveCacheEntryToEnd((CI *)v13, v15);
  }
  else
  {
    ++CI::gCacheGetCountMissed;
    unint64_t v18 = atomic_load(&CI::gCacheSize);
    unint64_t SurfaceMemorySize = CreateSurfaceMemorySize(*(unsigned int *)(a1 + 64), *(unsigned int *)(a1 + 72), 0x20uLL, *(unsigned int *)(a1 + 104));
    buf[0] = 0;
    unint64_t v20 = SurfaceMemorySize + v18;
    unint64_t v21 = CI_SURFACE_CACHE_CAPACITY();
    char v22 = 0;
    if (v20 < v21)
    {
      if (CI::gCacheList) {
        char v22 = *(void *)(CI::gCacheList + 16) < 0x100uLL;
      }
      else {
        char v22 = 1;
      }
    }
    unint64_t v23 = *(void *)(a1 + 64);
    unint64_t v24 = *(void *)(a1 + 72);
    int v26 = *(_DWORD *)(a1 + 100);
    int v25 = *(_DWORD *)(a1 + 104);
    memset(v33, 0, sizeof(v33));
    Unuseduint64_t CacheEntryWithInfo = CI::FindUnusedCacheEntryWithInfo(v23, v24, v23, v24, v25, (uint64_t)v33, *(_DWORD *)(a1 + 96), v26, v22, buf, 0);
    double v28 = (CI::SurfaceCacheEntry *)UnusedCacheEntryWithInfo;
    if (buf[0]) {
      ++CI::gCacheGetCountInUseMissed;
    }
    if (!UnusedCacheEntryWithInfo)
    {
      ++CI::gCacheCountAllocated;
      operator new();
    }
    ++CI::gCacheGetCountRecycled;
    uint64_t v29 = *(void *)(a1 + 72);
    *(_OWORD *)(UnusedCacheEntryWithInfo + 32) = *(_OWORD *)(a1 + 56);
    *(void *)(UnusedCacheEntryWithInfo + 48) = v29;
    *(_DWORD *)(UnusedCacheEntryWithInfo + 56) = *(_DWORD *)(a1 + 96);
    *(_DWORD *)(UnusedCacheEntryWithInfo + 6CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(UnusedCacheEntryWithInfo + 96) = 1;
    CI::SurfaceCacheEntry::setIdentifier((CI::SurfaceCacheEntry *)UnusedCacheEntryWithInfo, *(CFTypeRef *)(a1 + 80));
    CI::SurfaceCacheEntry::setFillBlock((uint64_t)v28, *(void **)(a1 + 32));
    CI::SurfaceCacheEntry::setFillQueue(v28, *(dispatch_object_t *)(a1 + 88));
    ++*((void *)v28 + 11);
    CI::MoveCacheEntryToEnd(v28, v30);
    double v31 = (const void *)*((void *)v28 + 3);
    if (v31) {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CFRetain(v31);
    }
    if (*((void *)v28 + 11) == 1) {
      SurfaceSetVolatileEmpty(*(IOSurfaceRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    }
    SurfaceSetNonVolatile(*(__IOSurface **)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    CI::SurfaceCacheEntry::fillAsync(v28);
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v28;
    uint64_t v17 = *(CI **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    if (v17) {
      uint64_t v17 = (CI *)CI::Object::ref((uint64_t)v17);
    }
  }
  CI::UpdateVolatilityStats(v17);
  return ((uint64_t (*)(void *))v38)(v37);
}

char *std::vector<std::pair<void const*,void const*>>::__init_with_size[abi:nn180100]<std::pair<void const*,void const*>*,std::pair<void const*,void const*>*>(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    uint64_t result = std::vector<CI::Perspective::Line>::__vallocate[abi:nn180100](result, a4);
    uint64_t v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

_OWORD *std::__tree<std::__value_type<int const,CI::TextureManager::tmIntermediate_t *>,std::__map_value_compare<int const,std::__value_type<int const,CI::TextureManager::tmIntermediate_t *>,std::less<int const>,true>,std::allocator<std::__value_type<int const,CI::TextureManager::tmIntermediate_t *>>>::__emplace_multi<std::pair<int const,CI::TextureManager::tmIntermediate_t *>>(uint64_t **a1, _OWORD *a2)
{
  int v4 = operator new(0x30uLL);
  int v5 = v4;
  v4[2] = *a2;
  int v6 = a1 + 1;
  uint64_t v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        int v6 = (uint64_t **)v7;
        if (*((_DWORD *)v4 + 8) >= *((_DWORD *)v7 + 8)) {
          break;
        }
        uint64_t v7 = (uint64_t *)*v7;
        long long v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      uint64_t v7 = (uint64_t *)v7[1];
    }
    while (v7);
    long long v8 = v6 + 1;
  }
  else
  {
    long long v8 = a1 + 1;
  }
LABEL_8:
  std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v6, v8, (uint64_t *)v4);
  return v5;
}

uint64_t std::deque<CI::SurfaceCacheEntry *>::~deque[abi:nn180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  int v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      int v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 512;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return std::__split_buffer<CI::SurfaceCacheEntry **>::~__split_buffer((uint64_t)a1);
}

uint64_t std::list<CI::attached_surface_t *>::splice(uint64_t result, uint64_t *a2, uint64_t a3, void *a4, void *a5)
{
  if (a4 != a5)
  {
    unint64_t v5 = (void *)*a5;
    if (result != a3)
    {
      uint64_t v6 = 1;
      if (v5 != a4)
      {
        uint64_t v7 = a4;
        do
        {
          uint64_t v7 = (void *)v7[1];
          ++v6;
        }
        while (v7 != v5);
      }
      *(void *)(a3 + 16) -= v6;
      *(void *)(result + 16) += v6;
    }
    uint64_t v8 = *a4;
    *(void *)(v8 + 8) = v5[1];
    *(void *)v5[1] = v8;
    uint64_t v9 = *a2;
    *(void *)(v9 + 8) = a4;
    *a4 = v9;
    *a2 = (uint64_t)v5;
    v5[1] = a2;
  }
  return result;
}

uint64_t std::__split_buffer<CI::SurfaceCacheEntry **>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>>>::__emplace_unique_impl<std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<CI::Node* const&,unsigned long long &,unsigned int const&>>(void *a1, uint64_t a2, void **a3, long long *a4)
{
  uint64_t v7 = a1 + 2;
  uint64_t v8 = operator new(0x30uLL);
  v13[0] = v8;
  v13[1] = v7;
  void *v8 = 0;
  v8[1] = 0;
  uint64_t v9 = *a3;
  long long v15 = *a4;
  uint64_t v16 = *((void *)a4 + 2);
  std::pair<CI::ProgramDigest const,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>::pair[abi:nn180100]<CI::ProgramDigest const&,CI::MainProgram* const&,unsigned long long &,unsigned int const&>((uint64_t)(v8 + 2), v9, (uint64_t)&v15);
  char v14 = 1;
  v8[1] = v8[2];
  inserted = std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique(a1, v8);
  if (v11) {
    v13[0] = 0;
  }
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,void *>>>>::reset[abi:nn180100]((uint64_t)v13, 0);
  return inserted;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,void *>>>>::reset[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      CI::ObjectCache<CI::Node,unsigned long long,false>::Entry::~Entry((uint64_t)v2 + 24);
    }
    operator delete(v2);
  }
}

uint64_t CI::Context::cacheVolatility(CI::Context *this)
{
  return *((unsigned int *)this + 58);
}

uint64_t CI::CGNode::type(CI::CGNode *this)
{
  return 29;
}

uint64_t CI::TextureManager::tmIntermediate_t::useCount(CI::TextureManager::tmIntermediate_t *this)
{
  return *((void *)this + 8);
}

__n128 CI::TextureManager::tmIntermediate_t::texture@<Q0>(CI::TextureManager::tmIntermediate_t *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *(__n128 *)((char *)this + 8);
  *a2 = result;
  return result;
}

uint64_t CI::TextureManager::tmIntermediate_t::preventInFlight(CI::TextureManager::tmIntermediate_t *this)
{
  return *((unsigned __int8 *)this + 73);
}

uint64_t CI::ProviderNode::type(CI::ProviderNode *this)
{
  return 44;
}

uint64_t CI::ProviderNode::surfaceForROI(uint64_t a1, void *a2, CGFloat *a3, uint64_t a4)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v8 = ci_signpost_log_render();
    os_signpost_id_t v9 = *(int *)(a1 + 36) | (unint64_t)((*(uint64_t (**)(void *))(*a2 + 272))(a2) << 32);
    if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
    {
      CGFloat v10 = *a3;
      uint64_t v11 = *((void *)a3 + 1);
      uint64_t v12 = *((void *)a3 + 2);
      uint64_t v13 = *((void *)a3 + 3);
      *(_DWORD *)CGRect buf = 134218752;
      *(CGFloat *)uint64_t v76 = v10;
      *(_WORD *)&v76[8] = 2048;
      *(void *)&v76[10] = v11;
      __int16 v77 = 2048;
      uint64_t v78 = v12;
      __int16 v79 = 2048;
      uint64_t v80 = v13;
      _os_signpost_emit_with_name_impl(&dword_193671000, v8, OS_SIGNPOST_INTERVAL_BEGIN, v9, "surface_for_roi_from_prov", "[%g %g %g %g]", buf, 0x2Au);
    }
  }
  uint64_t v14 = (*(uint64_t (**)(void *))(*a2 + 272))(a2);
  TimerBase::TimerBase((uint64_t)buf, v14, *(_DWORD *)(a1 + 36), (uint64_t)"surface_for_roi_from_prov", 23);
  uint64_t v15 = *(void *)(a1 + 128);
  uint64_t v16 = *(void *)(a1 + 136);
  CGFloat v17 = *a3;
  CGFloat v18 = a3[1];
  CGFloat v19 = a3[2];
  CGFloat v20 = a3[3];
  v82.origin.int x = *a3;
  v82.origin.int y = v18;
  v82.size.unint64_t width = v19;
  v82.size.unint64_t height = v20;
  if (CGRectIsNull(v82))
  {
    unint64_t width = 0;
    unint64_t height = 0;
    BOOL v23 = 0;
    int v24 = 0x7FFFFFFF;
    int v25 = 0x7FFFFFFF;
  }
  else
  {
    v83.origin.int x = v17;
    v83.origin.int y = v18;
    v83.size.unint64_t width = v19;
    v83.size.unint64_t height = v20;
    if (CGRectIsInfinite(v83))
    {
      BOOL v23 = 0;
      int v24 = -2147483647;
      unint64_t width = 0xFFFFFFFFLL;
      int v25 = -2147483647;
      unint64_t height = 0xFFFFFFFFLL;
    }
    else
    {
      v84.origin.int x = v17;
      v84.origin.int y = v18;
      v84.size.unint64_t width = v19;
      v84.size.unint64_t height = v20;
      CGRect v85 = CGRectInset(v84, 0.000001, 0.000001);
      CGRect v86 = CGRectIntegral(v85);
      int x = (int)v86.origin.x;
      int y = (int)v86.origin.y;
      unint64_t width = (unint64_t)v86.size.width;
      unint64_t height = (unint64_t)v86.size.height;
      BOOL v29 = v15 == (unint64_t)v86.size.width && v16 == height;
      if (y) {
        int v30 = (int)v86.origin.y;
      }
      else {
        int v30 = 0;
      }
      if (y) {
        BOOL v29 = 0;
      }
      if (x) {
        int v24 = (int)v86.origin.x;
      }
      else {
        int v24 = 0;
      }
      if (x) {
        int v25 = (int)v86.origin.y;
      }
      else {
        int v25 = v30;
      }
      if (x) {
        BOOL v23 = 0;
      }
      else {
        BOOL v23 = v29;
      }
    }
  }
  uint64_t v31 = CI::PixelFormatType_from_format(*(_DWORD *)(a1 + 48));
  int v32 = *(_DWORD *)(a1 + 188);
  uint64_t v33 = *(void *)(a1 + 96);
  double v34 = *(uint64_t **)(a1 + 64);
  long long v35 = *(uint64_t **)(a1 + 72);
  if (v34 == v35
    || 0xAAAAAAAAAAAAAAABLL * (v35 - v34) <= 1
    && ((v37 = *v34, uint64_t v36 = v34[1], v37 == v36) || 0xAAAAAAAAAAAAAAABLL * ((v36 - v37) >> 3) < 2))
  {
    if (v23)
    {
      double v38 = v64;
      v64[0] = MEMORY[0x1E4F143A8];
      v64[1] = 0x40000000;
      void v64[2] = ___ZNK2CI12ProviderNode13surfaceForROIEPKNS_7ContextERK6CGRectRNS_8Tileable5StatsE_block_invoke_3;
      v64[3] = &__block_descriptor_tmp_10_2;
      v64[4] = a1;
      int v65 = v24;
      int v66 = v25;
      unint64_t v67 = width;
      unint64_t v68 = height;
    }
    else
    {
      double v38 = v63;
      v63[0] = MEMORY[0x1E4F143A8];
      v63[1] = 0x40000000;
      void v63[2] = ___ZNK2CI12ProviderNode13surfaceForROIEPKNS_7ContextERK6CGRectRNS_8Tileable5StatsE_block_invoke_5;
      v63[3] = &__block_descriptor_tmp_12_1;
      v63[4] = a1;
      v63[5] = v25;
      v63[6] = v24;
    }
  }
  else
  {
    double v38 = v69;
    v69[0] = MEMORY[0x1E4F143A8];
    v69[1] = 0x40000000;
    v69[2] = ___ZNK2CI12ProviderNode13surfaceForROIEPKNS_7ContextERK6CGRectRNS_8Tileable5StatsE_block_invoke;
    v69[3] = &__block_descriptor_tmp_8_3;
    v69[4] = a1;
    int v70 = v24;
    int v71 = v25;
    unint64_t v72 = width;
    unint64_t v73 = height;
  }
  if (v33) {
    int v39 = 0;
  }
  else {
    int v39 = v32;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  *(void *)&long long v61 = __PAIR64__(v25, v24);
  *((void *)&v61 + 1) = width;
  unint64_t v62 = height;
  uint64_t v41 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 440))(a1, a2[19]);
  uint64_t SurfaceFromCacheAndFill = GetSurfaceFromCacheAndFill(&v61, v31, 0, v39, v41, *(void *)(a1 + 120), (uint64_t)v38);
  *(double *)a4 = *(double *)a4 + CFAbsoluteTimeGetCurrent() - Current;
  *(void *)(a4 + 8) += height * width;
  unint64_t v43 = *(void *)(a1 + 168);
  double v44 = *(uint64_t **)(a1 + 160);
  if ((unint64_t)v44 >= v43)
  {
    uint64_t v46 = *(void *)(a1 + 152);
    uint64_t v47 = ((uint64_t)v44 - v46) >> 3;
    if ((unint64_t)(v47 + 1) >> 61) {
      abort();
    }
    uint64_t v48 = v43 - v46;
    uint64_t v49 = v48 >> 2;
    if (v48 >> 2 <= (unint64_t)(v47 + 1)) {
      uint64_t v49 = v47 + 1;
    }
    if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v50 = v49;
    }
    if (v50) {
      int v51 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(a1 + 168, v50);
    }
    else {
      int v51 = 0;
    }
    __int16 v52 = (uint64_t *)&v51[8 * v47];
    uint64_t v53 = &v51[8 * v50];
    *__int16 v52 = SurfaceFromCacheAndFill;
    int v45 = v52 + 1;
    uint64_t v55 = *(char **)(a1 + 152);
    __int16 v54 = *(char **)(a1 + 160);
    if (v54 != v55)
    {
      do
      {
        uint64_t v56 = *((void *)v54 - 1);
        v54 -= 8;
        *--__int16 v52 = v56;
      }
      while (v54 != v55);
      __int16 v54 = *(char **)(a1 + 152);
    }
    *(void *)(a1 + 152) = v52;
    *(void *)(a1 + 16CI::NodeWithChildren::NodeWithChildren(this, 0) = v45;
    *(void *)(a1 + 168) = v53;
    if (v54) {
      operator delete(v54);
    }
  }
  else
  {
    *double v44 = SurfaceFromCacheAndFill;
    int v45 = v44 + 1;
  }
  *(void *)(a1 + 16CI::NodeWithChildren::NodeWithChildren(this, 0) = v45;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v57 = ci_signpost_log_render();
    os_signpost_id_t v58 = *(void *)&v76[4];
    if ((unint64_t)(*(void *)&v76[4] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      unint64_t v59 = v57;
      if (os_signpost_enabled(v57))
      {
        *(_WORD *)uint64_t v74 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v59, OS_SIGNPOST_INTERVAL_END, v58, "surface_for_roi_from_prov", "", v74, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)buf);
  return SurfaceFromCacheAndFill;
}

CFStringRef CI::ProviderNode::cacheIdentity(CI::ProviderNode *this, dispatch_queue_s *a2)
{
  if (*((unsigned char *)this + 187) && *((void *)this + 11)) {
    return (CFStringRef)*((void *)this + 11);
  }
  else {
    return CI::makeCacheID(*((CI **)this + 12), *((void *)this + 15), a2);
  }
}

const char *CI::MetalContext::name(CI::MetalContext *this)
{
  return "metal";
}

unint64_t CI::RemoveFromStartUntilAtOrBelowCapacity(CI *this)
{
  unint64_t result = CI_SURFACE_CACHE_CAPACITY();
  if (CI::gCacheList)
  {
    unint64_t v3 = result;
    unint64_t v4 = atomic_load(&CI::gCacheSize);
    uint64_t v5 = CI::gCacheList;
    unint64_t v6 = *(void *)(CI::gCacheList + 16);
    long long v23 = 0u;
    unsigned long long v24 = 0u;
    long long v22 = 0u;
    for (uint64_t i = *(void *)(CI::gCacheList + 8); i != v5; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v8 = *(CI **)(i + 16);
      unint64_t v21 = v8;
      if (v4 <= v3 && v6 < 0x101) {
        break;
      }
      if (!CI::isPriorEntry(v8, v2))
      {
        v4 -= *((void *)v21 + 13);
        std::deque<CI::SurfaceCacheEntry *>::push_back(&v22, &v21);
        --v6;
      }
    }
    uint64_t v9 = CI::gCacheList;
    for (uint64_t j = *(void *)(CI::gCacheList + 8); j != v9; uint64_t j = *(void *)(j + 8))
    {
      uint64_t v11 = *(CI **)(j + 16);
      unint64_t v21 = v11;
      if (v4 <= v3 && v6 < 0x101) {
        break;
      }
      if (CI::isPriorEntry(v11, v2) && !*((void *)v21 + 11))
      {
        v4 -= *((void *)v21 + 13);
        std::deque<CI::SurfaceCacheEntry *>::push_back(&v22, &v21);
        --v6;
      }
    }
    uint64_t v12 = *((void *)&v24 + 1);
    if (*((void *)&v24 + 1) && *(void *)(CI::gCacheList + 16) >= 0x401uLL)
    {
      unint64_t v13 = v24;
      do
      {
        uint64_t v14 = *(CI **)(*(void *)(*((void *)&v22 + 1) + ((v13 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v13 & 0x1FF));
        CI::RemoveCacheEntry(v14, v2);
        if (v14) {
          (*(void (**)(CI *))(*(void *)v14 + 8))(v14);
        }
        uint64_t v12 = *((void *)&v24 + 1) - 1;
        unint64_t v13 = v24 + 1;
        unsigned long long v24 = __PAIR128__(*((unint64_t *)&v24 + 1), (uint64_t)v24 + 1) + __PAIR128__(-1, 0);
        if (v13 >= 0x400)
        {
          operator delete(**((void ***)&v22 + 1));
          unint64_t v13 = v24 - 512;
          *((void *)&v22 + 1) += 8;
          *(void *)&unsigned long long v24 = v24 - 512;
          uint64_t v12 = *((void *)&v24 + 1);
        }
      }
      while (v12 && *(void *)(CI::gCacheList + 16) >= 0x401uLL);
    }
    if ((void)v23 != *((void *)&v22 + 1))
    {
      uint64_t v15 = (void *)(*((void *)&v22 + 1) + 8 * ((unint64_t)v24 >> 9));
      uint64_t v16 = *v15 + 8 * (v24 & 0x1FF);
      uint64_t v17 = *(void *)(*((void *)&v22 + 1) + (((unint64_t)(v24 + v12) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((v24 + v12) & 0x1FF);
      if (v16 != v17)
      {
        int v18 = 0;
        while (1)
        {
          uint64_t v19 = *(void *)v16;
          if (!*(_DWORD *)(*(void *)v16 + 60)) {
            goto LABEL_34;
          }
          if (!v18) {
            break;
          }
LABEL_35:
          v16 += 8;
          if (v16 - *v15 == 4096)
          {
            uint64_t v20 = v15[1];
            ++v15;
            uint64_t v16 = v20;
          }
          if (v16 == v17) {
            return std::deque<CI::SurfaceCacheEntry *>::~deque[abi:nn180100](&v22);
          }
        }
        if (!*(void *)(v19 + 64))
        {
          int v18 = *(_DWORD *)(*(void *)v16 + 60);
          goto LABEL_35;
        }
        if (!SurfaceIsVolatileEmpty(*(__IOSurface **)(v19 + 24)))
        {
          int v18 = *(_DWORD *)(v19 + 60);
          goto LABEL_35;
        }
        int v18 = 0;
LABEL_34:
        CI::RemoveCacheEntry((CI *)v19, v2);
        (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
        goto LABEL_35;
      }
    }
    return std::deque<CI::SurfaceCacheEntry *>::~deque[abi:nn180100](&v22);
  }
  return result;
}

uint64_t CI::FindCacheEntryWithInfo(uint64_t a1, int a2, uint64_t a3, int a4, int a5, CFStringRef theString1)
{
  uint64_t v6 = CI::gCacheList;
  if (!CI::gCacheList) {
    return 0;
  }
  uint64_t v7 = *(void *)(CI::gCacheList + 8);
  if (v7 == CI::gCacheList) {
    return 0;
  }
  while (1)
  {
    uint64_t v14 = *(void *)(v7 + 16);
    if (*(_DWORD *)(v14 + 56) == a4 && *(_DWORD *)(v14 + 60) == a5 && *(void *)(v14 + 24))
    {
      BOOL v15 = *(_DWORD *)(v14 + 32) == *(_DWORD *)a1 && *(_DWORD *)(v14 + 36) == *(_DWORD *)(a1 + 4);
      BOOL v16 = v15 && *(void *)(v14 + 40) == *(void *)(a1 + 8);
      if (v16
        && *(void *)(v14 + 48) == *(void *)(a1 + 16)
        && *(_DWORD *)(v14 + 128) == a2
        && *(void *)(v14 + 144) == *(void *)(a3 + 8)
        && *(_DWORD *)(v14 + 136) == *(_DWORD *)a3
        && *(void *)(v14 + 152) == *(void *)(a3 + 16))
      {
        CFStringRef v18 = *(const __CFString **)(v14 + 64);
        if (v18)
        {
          if (CFEqual(theString1, v18)) {
            break;
          }
        }
      }
    }
    uint64_t v7 = *(void *)(v7 + 8);
    if (v7 == v6) {
      return 0;
    }
  }
  return v14;
}

void *CI::MoveCacheEntryToEnd(CI *this, CI::SurfaceCacheEntry *a2)
{
  uint64_t v5 = this;
  std::list<CI::attached_surface_t *>::remove((void *)CI::gCacheList, &v5);
  uint64_t v2 = (uint64_t *)CI::gCacheList;
  unint64_t result = operator new(0x18uLL);
  result[2] = v5;
  uint64_t v4 = *v2;
  *unint64_t result = *v2;
  result[1] = v2;
  *(void *)(v4 + 8) = result;
  *uint64_t v2 = (uint64_t)result;
  ++v2[2];
  return result;
}

void CI::SWContext::SWContext(CI::SWContext *this, const CI::Context *a2)
{
}

void CI::Context::Context(CI::Context *this, const CI::Context *a2)
{
  *((_DWORD *)this + 2) = 1;
  *(void *)this = &unk_1EE45E140;
  *((_DWORD *)this + 9) = 0;
  *((unsigned char *)this + 41) = 1;
  *((_DWORD *)this + 36) = atomic_fetch_add(&CI::gContextCounter, 1u) + 1;
  *((void *)this + 19) = 0;
  long long v2 = *MEMORY[0x1E4F1DB20];
  long long v3 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
  *((_OWORD *)this + 1CI::NodeWithChildren::NodeWithChildren(this, 0) = *MEMORY[0x1E4F1DB20];
  *((_OWORD *)this + 11) = v3;
  *((void *)this + 24) = 0;
  *(_OWORD *)((char *)this + 216) = v3;
  *(_OWORD *)((char *)this + 20CI::NodeWithChildren::NodeWithChildren(this, 0) = v2;
  *((_DWORD *)this + 58) = 1;
  *(_OWORD *)((char *)this + 252) = 0u;
  *(_OWORD *)((char *)this + 236) = 0u;
  *(_OWORD *)((char *)this + 268) = 0u;
  *(_OWORD *)((char *)this + 284) = 0u;
  *((unsigned char *)this + 30CI::NodeWithChildren::NodeWithChildren(this, 0) = 1;
  *((_DWORD *)this + 86) = 0;
  uint64_t v4 = *((void *)a2 + 45);
  *((void *)this + 44) = 0;
  *((void *)this + 45) = v4;
  *((_OWORD *)this + 23) = *((_OWORD *)a2 + 23);
  operator new();
}

void CI::Context::Context(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)a1 = &unk_1EE45E140;
  *(_DWORD *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 36) = 0;
  *(unsigned char *)(a1 + 41) = 1;
  unsigned int add = atomic_fetch_add(&CI::gContextCounter, 1u);
  long long v10 = *MEMORY[0x1E4F1DB20];
  long long v9 = *(_OWORD *)(MEMORY[0x1E4F1DB20] + 16);
  *(_OWORD *)(a1 + 236) = 0u;
  *(_DWORD *)(a1 + 144) = add + 1;
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 16CI::NodeWithChildren::NodeWithChildren(this, 0) = v10;
  *(_OWORD *)(a1 + 176) = v9;
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 20CI::NodeWithChildren::NodeWithChildren(this, 0) = v10;
  *(_OWORD *)(a1 + 216) = v9;
  *(_DWORD *)(a1 + 232) = 1;
  *(_OWORD *)(a1 + 252) = 0u;
  *(_OWORD *)(a1 + 268) = 0u;
  *(_OWORD *)(a1 + 284) = 0u;
  *(unsigned char *)(a1 + 30CI::NodeWithChildren::NodeWithChildren(this, 0) = 1;
  *(_DWORD *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 36CI::NodeWithChildren::NodeWithChildren(this, 0) = a7;
  *(void *)(a1 + 368) = a6;
  *(void *)(a1 + 376) = a8;
  operator new();
}

uint64_t CI::format_get_default_ycc_color_matrix(int a1)
{
  uint64_t result = CI::format_is_ycc(a1);
  if (a1 != 535 && !result) {
    return result;
  }
  uint64_t result = 601;
  if (a1 > 1297)
  {
    if (a1 > 2065)
    {
      if (((a1 - 3346) > 4 || ((1 << (a1 - 18)) & 0x13) == 0) && a1 != 2066) {
        return 709;
      }
      return result;
    }
    if ((a1 - 1298) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0) {
      return result;
    }
    unsigned int v3 = a1 - 1810;
  }
  else
  {
    if ((a1 - 274) < 5 || (a1 - 532) <= 3 && a1 != 534) {
      return result;
    }
    unsigned int v3 = a1 - 786;
  }
  if (v3 > 4 || ((1 << v3) & 0x13) == 0) {
    return 709;
  }
  return result;
}

uint64_t CI::format_is_supported_source_bitmap(int a1)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a1 != 2824) {
      return CI::format_is_ycc_biplanar(a1) ^ 1;
    }
  }
  return result;
}

uint64_t CI::alpha_mode_from_CGImageProvider(uint64_t result)
{
  if (result)
  {
    unsigned int AlphaInfo = CGImageProviderGetAlphaInfo();
    if (AlphaInfo > 5) {
      return 0xFFFFFFFFLL;
    }
    else {
      return dword_193959960[AlphaInfo];
    }
  }
  return result;
}

uint64_t CI::format_from_CGImageProvider(uint64_t result)
{
  if (result)
  {
    unsigned int v1 = CGImageProviderGetComponentType() - 1;
    if (v1 > 5) {
      return 0;
    }
    uint64_t PixelSize = CGImageProviderGetPixelSize();
    uint64_t v3 = 8 * PixelSize;
    if (8 * PixelSize != 128
      && (PixelSize & 0x1FFFFFFFFFFFFFFBLL) != 8
      && (PixelSize & 0x1FFFFFFFFFFFFFFDLL) != 4
      && (PixelSize & 0x1FFFFFFFFFFFFFFDLL) != 1
      && v3 != 16)
    {
      return 0;
    }
    ColorSpace = (CGColorSpace *)CGImageProviderGetColorSpace();
    CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
    int AlphaInfo = CGImageProviderGetAlphaInfo();
    if (Model == kCGColorSpaceModelRGB)
    {
      int v8 = 0;
      int v7 = 1;
    }
    else
    {
      uint64_t result = 0;
      if (Model) {
        return result;
      }
      int v7 = 0;
      int v8 = 1;
    }
    uint64_t result = 0;
    switch(v1)
    {
      case 0u:
        if (v3 == 8) {
          int v9 = v8;
        }
        else {
          int v9 = 0;
        }
        if (v9 == 1 && !AlphaInfo) {
          return 259;
        }
        char v16 = v8 ^ 1;
        if (v3 != 16) {
          char v16 = 1;
        }
        if ((v16 & 1) == 0)
        {
          BOOL v17 = ((AlphaInfo - 1) & 0xFFFFFFFD) == 0;
          unsigned int v18 = 260;
          goto LABEL_69;
        }
        if (v3 == 24) {
          int v22 = v7;
        }
        else {
          int v22 = 0;
        }
        if (v22 == 1 && !AlphaInfo) {
          return 263;
        }
        char v26 = v7 ^ 1;
        if (v3 != 32) {
          char v26 = 1;
        }
        if (v26) {
          return 0;
        }
        int BitmapInfo = CGImageProviderGetBitmapInfo();
        int v28 = BitmapInfo - 1;
        if (!(!v17 & v29))
        {
          uint64_t result = 264;
          switch(v28)
          {
            case 0:
            case 2:
              return result;
            case 1:
            case 3:
              return 265;
            case 4:
              goto LABEL_137;
            case 5:
              return 269;
            default:
              JUMPOUT(0);
          }
        }
        switch(BitmapInfo)
        {
          case 8193:
          case 8195:
            uint64_t result = 267;
            break;
          case 8194:
          case 8196:
            uint64_t result = 266;
            break;
          case 8197:
            uint64_t result = 271;
            break;
          case 8198:
            uint64_t result = 270;
            break;
          default:
            if ((AlphaInfo | 2) == 3)
            {
              uint64_t result = 264;
            }
            else
            {
              if (AlphaInfo != 5) {
                return 0;
              }
LABEL_137:
              uint64_t result = 268;
            }
            break;
        }
        return result;
      case 1u:
        if (v3 == 16) {
          int v10 = v8;
        }
        else {
          int v10 = 0;
        }
        if (v10 == 1 && !AlphaInfo) {
          return 1795;
        }
        char v19 = v8 ^ 1;
        if (v3 != 32) {
          char v19 = 1;
        }
        if ((v19 & 1) == 0)
        {
          BOOL v17 = ((AlphaInfo - 1) & 0xFFFFFFFD) == 0;
          unsigned int v18 = 1796;
          goto LABEL_69;
        }
        if (v3 == 48) {
          int v23 = v7;
        }
        else {
          int v23 = 0;
        }
        if (v23 == 1 && !AlphaInfo) {
          return 1799;
        }
        char v30 = v7 ^ 1;
        if (v3 != 64) {
          char v30 = 1;
        }
        if (v30) {
          return 0;
        }
        if ((AlphaInfo | 2) == 3) {
          return 1800;
        }
        if (AlphaInfo != 5) {
          return 0;
        }
        return 1804;
      case 3u:
        if (v3 == 32) {
          int v11 = v8;
        }
        else {
          int v11 = 0;
        }
        if (v11 == 1 && !AlphaInfo) {
          return 2307;
        }
        char v20 = v8 ^ 1;
        if (v3 != 64) {
          char v20 = 1;
        }
        if ((v20 & 1) == 0)
        {
          BOOL v17 = ((AlphaInfo - 1) & 0xFFFFFFFD) == 0;
          unsigned int v18 = 2308;
          goto LABEL_69;
        }
        if (v3 == 96) {
          int v24 = v7;
        }
        else {
          int v24 = 0;
        }
        if (v24 == 1 && !AlphaInfo) {
          return 2311;
        }
        char v31 = v7 ^ 1;
        if (v3 != 128) {
          char v31 = 1;
        }
        if (v31) {
          return 0;
        }
        if ((AlphaInfo | 2) == 3) {
          return 2312;
        }
        if (AlphaInfo != 5) {
          return 0;
        }
        return 2316;
      case 4u:
        if (v3 == 16) {
          int v12 = v8;
        }
        else {
          int v12 = 0;
        }
        if (v12 == 1 && !AlphaInfo) {
          return 2051;
        }
        char v21 = v8 ^ 1;
        if (v3 != 32) {
          char v21 = 1;
        }
        if (v21)
        {
          if (v3 == 48) {
            int v25 = v7;
          }
          else {
            int v25 = 0;
          }
          if (v25 != 1 || AlphaInfo)
          {
            char v32 = v7 ^ 1;
            if (v3 != 64) {
              char v32 = 1;
            }
            if (v32) {
              return 0;
            }
            if ((AlphaInfo | 2) == 3)
            {
              return 2056;
            }
            else
            {
              if (AlphaInfo != 5) {
                return 0;
              }
              return 2060;
            }
          }
          else
          {
            return 2055;
          }
        }
        else
        {
          BOOL v17 = ((AlphaInfo - 1) & 0xFFFFFFFD) == 0;
          unsigned int v18 = 2052;
LABEL_69:
          if (v17) {
            return v18;
          }
          else {
            return 0;
          }
        }
      case 5u:
        if (v3 != 32) {
          return 0;
        }
        if (AlphaInfo == 3) {
          char v13 = v7;
        }
        else {
          char v13 = 0;
        }
        if (v13) {
          return 784;
        }
        if (AlphaInfo == 5) {
          char v14 = v7;
        }
        else {
          char v14 = 0;
        }
        if ((v14 & 1) == 0)
        {
          if (AlphaInfo == 4) {
            char v15 = v7;
          }
          else {
            char v15 = 0;
          }
          if (v15) {
            return 784;
          }
          if (AlphaInfo != 6) {
            LOBYTE(v7) = 0;
          }
          if ((v7 & 1) == 0) {
            return 0;
          }
        }
        uint64_t result = 775;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t CI::PixelFormatType_from_format(int a1)
{
  uint64_t result = 0;
  if (a1 <= 1792)
  {
    if (a1 > 770)
    {
      if (a1 > 1045)
      {
        if (a1 == 1558) {
          int v14 = 1882468914;
        }
        else {
          int v14 = 0;
        }
        if (a1 == 1555) {
          unsigned int v15 = 1882469428;
        }
        else {
          unsigned int v15 = v14;
        }
        if (a1 == 1554) {
          unsigned int v15 = 1882468912;
        }
        if (a1 == 1302) {
          int v16 = 1885745714;
        }
        else {
          int v16 = 0;
        }
        if (a1 == 1299) {
          int v17 = 1885746228;
        }
        else {
          int v17 = v16;
        }
        if (a1 <= 1553) {
          unsigned int v15 = v17;
        }
        unsigned int v18 = 1885745712;
        if (a1 != 1298) {
          unsigned int v18 = 0;
        }
        if (a1 == 1286) {
          unsigned int v18 = 845361456;
        }
        if (a1 == 1285) {
          int v19 = 828584240;
        }
        else {
          int v19 = 0;
        }
        if (a1 == 1046) {
          int v20 = 2016686642;
        }
        else {
          int v20 = v19;
        }
        if (a1 <= 1285) {
          unsigned int v18 = v20;
        }
        if (a1 <= 1298) {
          return v18;
        }
        else {
          return v15;
        }
      }
      else
      {
        switch(a1)
        {
          case 771:
            int v5 = 1278226488;
            goto LABEL_148;
          case 772:
          case 775:
          case 776:
          case 777:
          case 778:
          case 779:
          case 780:
          case 781:
          case 782:
          case 783:
          case 788:
          case 789:
            return result;
          case 773:
            int v5 = 826486840;
            goto LABEL_148;
          case 774:
            int v5 = 843264056;
LABEL_148:
            uint64_t result = (v5 + 248);
            break;
          case 784:
            uint64_t result = 1815162994;
            break;
          case 785:
            unsigned __int16 v30 = 12592;
LABEL_151:
            uint64_t result = v30 | 0x63690000u;
            break;
          case 786:
            uint64_t result = 2019963440;
            break;
          case 787:
            uint64_t result = 2019963956;
            break;
          case 790:
            uint64_t result = 2019963442;
            break;
          default:
            if (a1 == 1043) {
              unsigned int v27 = 2016687156;
            }
            else {
              unsigned int v27 = 0;
            }
            if (a1 == 1042) {
              uint64_t result = 2016686640;
            }
            else {
              uint64_t result = v27;
            }
            break;
        }
      }
    }
    else
    {
      switch(a1)
      {
        case 257:
          uint64_t result = 1093677112;
          break;
        case 258:
          int v29 = 1667844406;
LABEL_158:
          uint64_t result = (v29 + 2);
          break;
        case 259:
          uint64_t result = 1278226488;
          break;
        case 260:
          uint64_t result = 1279340600;
          break;
        case 261:
          uint64_t result = 826486840;
          break;
        case 262:
          uint64_t result = 843264056;
          break;
        case 263:
          uint64_t result = 24;
          break;
        case 264:
          unsigned __int16 v28 = 16961;
LABEL_125:
          uint64_t result = v28 | 0x52470000u;
          break;
        case 265:
          uint64_t result = 32;
          break;
        case 266:
          uint64_t result = 1111970369;
          break;
        case 267:
          uint64_t result = 1094862674;
          break;
        case 268:
        case 269:
        case 270:
        case 271:
        case 272:
        case 273:
          return result;
        case 274:
          uint64_t result = 875704422;
          break;
        case 275:
          uint64_t result = 875836518;
          break;
        case 276:
          uint64_t result = 846624102;
          break;
        case 277:
          uint64_t result = 2037741158;
          break;
        case 278:
          uint64_t result = 875704934;
          break;
        default:
          switch(a1)
          {
            case 530:
              int v21 = 875704422;
              goto LABEL_170;
            case 531:
              int v21 = 875836518;
LABEL_170:
              uint64_t result = v21 | 0x10u;
              break;
            case 532:
              uint64_t result = 846624121;
              break;
            case 533:
              uint64_t result = 2037741171;
              break;
            case 534:
              uint64_t result = 875704950;
              break;
            case 535:
              uint64_t result = 2033463352;
              break;
            default:
              return result;
          }
          break;
      }
    }
  }
  else
  {
    if (a1 > 2304)
    {
      if (a1 > 3330)
      {
        if (a1 > 3601)
        {
          if (a1 == 3862) {
            int v22 = 1937125938;
          }
          else {
            int v22 = 0;
          }
          if (a1 == 3859) {
            int v23 = 1937126452;
          }
          else {
            int v23 = v22;
          }
          if (a1 == 3858) {
            unsigned int v8 = 1937125936;
          }
          else {
            unsigned int v8 = v23;
          }
          if (a1 == 3606) {
            int v24 = 1953903154;
          }
          else {
            int v24 = 0;
          }
          if (a1 == 3603) {
            int v25 = 1953903668;
          }
          else {
            int v25 = v24;
          }
          if (a1 == 3602) {
            unsigned int v11 = 1953903152;
          }
          else {
            unsigned int v11 = v25;
          }
          BOOL v12 = a1 <= 3857;
        }
        else
        {
          if (a1 == 3350) {
            int v6 = 1952854578;
          }
          else {
            int v6 = 0;
          }
          if (a1 == 3347) {
            int v7 = 1952855092;
          }
          else {
            int v7 = v6;
          }
          if (a1 == 3346) {
            unsigned int v8 = 1952854576;
          }
          else {
            unsigned int v8 = v7;
          }
          if (a1 == 3334) {
            int v9 = 843264306;
          }
          else {
            int v9 = 0;
          }
          if (a1 == 3333) {
            int v10 = 826487090;
          }
          else {
            int v10 = v9;
          }
          if (a1 == 3331) {
            unsigned int v11 = 1278226738;
          }
          else {
            unsigned int v11 = v10;
          }
          BOOL v12 = a1 <= 3345;
        }
      }
      else
      {
        if (a1 <= 2566)
        {
          switch(a1)
          {
            case 2305:
              int v3 = 1093677112;
              goto LABEL_115;
            case 2306:
              int v13 = 1667844406;
              goto LABEL_161;
            case 2307:
              int v3 = 1278226488;
              goto LABEL_115;
            case 2308:
              return 1279340646;
            case 2309:
              int v3 = 826486840;
              goto LABEL_115;
            case 2310:
              int v3 = 843264056;
LABEL_115:
              uint64_t result = (v3 + 46);
              break;
            case 2311:
              uint64_t result = 1667838822;
              break;
            case 2312:
              unsigned __int16 v28 = 26177;
              goto LABEL_125;
            default:
              return result;
          }
          return result;
        }
        if (a1 == 3081) {
          unsigned int v8 = 1667839024;
        }
        else {
          unsigned int v8 = 0;
        }
        if (a1 == 3079) {
          unsigned int v8 = 1667838768;
        }
        if (a1 == 2569) {
          int v26 = 1999908961;
        }
        else {
          int v26 = 0;
        }
        if (a1 == 2567) {
          unsigned int v11 = 1999843442;
        }
        else {
          unsigned int v11 = v26;
        }
        BOOL v12 = a1 <= 3078;
      }
      if (v12) {
        return v11;
      }
      else {
        return v8;
      }
    }
    switch(a1)
    {
      case 1793:
        int v4 = 1093677112;
        goto LABEL_139;
      case 1794:
        unsigned __int16 v30 = 18742;
        goto LABEL_151;
      case 1795:
        int v4 = 1278226488;
        goto LABEL_139;
      case 1796:
        return 1279340854;
      case 1797:
        int v4 = 826486840;
        goto LABEL_139;
      case 1798:
        int v4 = 843264056;
LABEL_139:
        uint64_t result = (v4 + 254);
        break;
      case 1799:
        uint64_t result = 1815361650;
        break;
      case 1800:
        uint64_t result = 1815491698;
        break;
      case 1801:
        uint64_t result = 1664496754;
        break;
      case 1802:
      case 1803:
      case 1804:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        return result;
      case 1810:
        uint64_t result = 1936077360;
        break;
      case 1811:
        int v31 = 1936077360;
LABEL_166:
        uint64_t result = (v31 + 516);
        break;
      case 1814:
        int v32 = 1936077360;
LABEL_168:
        uint64_t result = v32 | 2u;
        break;
      default:
        switch(a1)
        {
          case 2049:
            int v13 = 1093677112;
            goto LABEL_161;
          case 2050:
            return 1667844456;
          case 2051:
            int v13 = 1278226488;
            goto LABEL_161;
          case 2052:
            int v29 = 1279340646;
            goto LABEL_158;
          case 2053:
            int v13 = 826486840;
            goto LABEL_161;
          case 2054:
            int v13 = 843264056;
LABEL_161:
            uint64_t result = (v13 + 48);
            break;
          case 2055:
            uint64_t result = 1667838824;
            break;
          case 2056:
            uint64_t result = 1380411457;
            break;
          case 2066:
            uint64_t result = 1751527984;
            break;
          case 2067:
            int v31 = 1751527984;
            goto LABEL_166;
          case 2070:
            int v32 = 1751527984;
            goto LABEL_168;
          default:
            return result;
        }
        break;
    }
  }
  return result;
}

uint64_t CI::format_from_CVPixelBuffer(CI *this, __CVBuffer *a2)
{
  PixelFormatint Type = (CI *)CVPixelBufferGetPixelFormatType(this);
  uint64_t v4 = CI::format_from_PixelFormatType(PixelFormatType);
  unsigned int v5 = CI::format_with_x_for_format(v4);
  if (v5 != v4)
  {
    unsigned int v6 = v5;
    if (CVBufferGetAttachment(this, (CFStringRef)*MEMORY[0x1E4F249D0], 0) == (CFTypeRef)*MEMORY[0x1E4F1CFD0]) {
      return v6;
    }
    else {
      return v4;
    }
  }
  return v4;
}

void CI::new_precompiled_kernels(CI *this, const CI::MetalContext *a2)
{
}

void sub_1936C9A7C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10C1C40108F59C3);
  _Unwind_Resume(a1);
}

uint64_t CI::alpha_mode_from_CGImage(uint64_t this, CGImage *a2)
{
  if (this)
  {
    long long v2 = (CGImage *)this;
    uint64_t ImageProvider = CGImageGetImageProvider();
    if (ImageProvider && (uint64_t v4 = ImageProvider, CI::format_from_CGImageProvider(ImageProvider)))
    {
      return CI::alpha_mode_from_CGImageProvider(v4);
    }
    else
    {
      CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(v2);
      if (AlphaInfo > kCGImageAlphaOnly) {
        return 0xFFFFFFFFLL;
      }
      else {
        return dword_193959940[AlphaInfo];
      }
    }
  }
  return this;
}

void CI::new_stitchable_kernels(CI *this, const CI::MetalContext *a2)
{
}

void sub_1936C9B64(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10C1C40108F59C3);
  _Unwind_Resume(a1);
}

uint64_t CI::format_from_CGImage(uint64_t this, CGImage *a2)
{
  if (this)
  {
    long long v2 = (CGImage *)this;
    uint64_t ImageProvider = CGImageGetImageProvider();
    if (!ImageProvider || (this = CI::format_from_CGImageProvider(ImageProvider), !this))
    {
      size_t BitsPerComponent = CGImageGetBitsPerComponent(v2);
      this = 0;
      if (BitsPerComponent <= 0x20 && ((1 << BitsPerComponent) & 0x100010500) != 0)
      {
        size_t BitsPerPixel = CGImageGetBitsPerPixel(v2);
        this = 0;
        *((void *)&v7 + 1) = BitsPerPixel;
        *(void *)&long long v7 = BitsPerPixel - 8;
        unint64_t v6 = v7 >> 3;
        if (v6 <= 0xF && ((1 << v6) & 0x88AF) != 0)
        {
          ColorSpace = CGImageGetColorSpace(v2);
          CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
          CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(v2);
          CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(v2);
          CGImagePixelFormatInfo PixelFormatInfo = CGImageGetPixelFormatInfo(v2);
          int v13 = BitmapInfo & 0x7000;
          BOOL v14 = (PixelFormatInfo & 0x30000) != 0 && BitsPerComponent == 10;
          int v15 = BitmapInfo & 0x7100;
          char v17 = v14 && v15 == 0x2000;
          BOOL v18 = (BitmapInfo & 0x100) == 0 && BitsPerComponent == 8;
          BOOL v19 = (BitmapInfo & 0x100) == 0 || BitsPerComponent != 32;
          char v20 = v13 != 0x2000 || v19;
          if (v13 == 4096) {
            int v21 = (BitsPerComponent == 16) & ((unsigned __int16)(BitmapInfo & 0x100) >> 8);
          }
          else {
            int v21 = 0;
          }
          BOOL v22 = v15 == 4096 && BitsPerComponent == 16;
          if (Model == kCGColorSpaceModelRGB)
          {
            int v24 = 0;
            int v23 = 1;
          }
          else
          {
            this = 0;
            if (Model) {
              return this;
            }
            int v23 = 0;
            int v24 = 1;
          }
          char v25 = v17 ^ 1;
          if (BitsPerPixel != 32) {
            char v25 = 1;
          }
          if ((v25 & 1) == 0)
          {
            if (AlphaInfo == kCGImageAlphaFirst) {
              char v26 = v23;
            }
            else {
              char v26 = 0;
            }
            if (v26) {
              return 784;
            }
            char v27 = AlphaInfo == kCGImageAlphaNoneSkipFirst ? v23 : 0;
            if (v27) {
              return 775;
            }
          }
          unsigned int v28 = AlphaInfo & 0xFFFFFFFD;
          if (v22)
          {
            if (BitsPerPixel == 16) {
              int v29 = v24;
            }
            else {
              int v29 = 0;
            }
            if (v29 == 1 && AlphaInfo == kCGImageAlphaNone) {
              return 1795;
            }
            if (BitsPerPixel != 32) {
              int v24 = 0;
            }
            if (v24 == 1 && v28 == 1) {
              return 1796;
            }
            if (BitsPerPixel == 48) {
              int v32 = v23;
            }
            else {
              int v32 = 0;
            }
            if (v32 == 1 && AlphaInfo == kCGImageAlphaNone) {
              return 1799;
            }
            if (BitsPerPixel != 64) {
              return 0;
            }
            if (v23 && v28 == 1) {
              return 1800;
            }
            if (!v23) {
              return 0;
            }
            this = 1801;
            if (AlphaInfo != kCGImageAlphaPremultipliedFirst && AlphaInfo != kCGImageAlphaFirst)
            {
              if (AlphaInfo == kCGImageAlphaNoneSkipLast) {
                return 1804;
              }
              return 0;
            }
          }
          else
          {
            if (v21)
            {
              if (BitsPerPixel == 16) {
                int v30 = v24;
              }
              else {
                int v30 = 0;
              }
              if (v30 == 1 && AlphaInfo == kCGImageAlphaNone) {
                return 2051;
              }
              if (BitsPerPixel != 32) {
                int v24 = 0;
              }
              if (v24 == 1 && v28 == 1) {
                return 2052;
              }
              if (BitsPerPixel == 48) {
                int v34 = v23;
              }
              else {
                int v34 = 0;
              }
              if (v34 == 1 && AlphaInfo == kCGImageAlphaNone) {
                return 2055;
              }
              if (BitsPerPixel == 64)
              {
                if (v23 && v28 == 1) {
                  return 2056;
                }
                if (AlphaInfo != kCGImageAlphaNoneSkipLast) {
                  LOBYTE(v23) = 0;
                }
                if (v23) {
                  return 2060;
                }
              }
              return 0;
            }
            if (v20)
            {
              if (!v18) {
                return 0;
              }
              if (BitsPerPixel == 8) {
                int v31 = v24;
              }
              else {
                int v31 = 0;
              }
              if (v31 == 1 && AlphaInfo == kCGImageAlphaNone) {
                return 259;
              }
              if (BitsPerPixel != 16) {
                int v24 = 0;
              }
              if (v24 == 1 && v28 == 1) {
                return 260;
              }
              if (BitsPerPixel != 24) {
                int v23 = 0;
              }
              if (v23 == 1 && AlphaInfo == kCGImageAlphaNone) {
                return 263;
              }
              if (BitsPerPixel != 32 || Model != kCGColorSpaceModelRGB) {
                return 0;
              }
              this = 264;
              switch(BitmapInfo)
              {
                case 1u:
                case 3u:
                  return this;
                case 2u:
                case 4u:
                  this = 265;
                  break;
                case 5u:
                  this = 268;
                  break;
                case 6u:
                  this = 269;
                  break;
                default:
                  JUMPOUT(0);
              }
            }
            else
            {
              if (BitsPerPixel == 32) {
                int v33 = v24;
              }
              else {
                int v33 = 0;
              }
              if (v33 == 1 && AlphaInfo == kCGImageAlphaNone) {
                return 2307;
              }
              if (BitsPerPixel != 64) {
                int v24 = 0;
              }
              if (v24 == 1 && v28 == 1) {
                return 2308;
              }
              if (BitsPerPixel == 96) {
                int v35 = v23;
              }
              else {
                int v35 = 0;
              }
              if (v35 == 1 && AlphaInfo == kCGImageAlphaNone) {
                return 2311;
              }
              if (BitsPerPixel != 128) {
                return 0;
              }
              if (v23 && v28 == 1) {
                return 2312;
              }
              if (!v23) {
                return 0;
              }
              this = 2313;
              if (AlphaInfo != kCGImageAlphaPremultipliedFirst && AlphaInfo != kCGImageAlphaFirst)
              {
                if (AlphaInfo == kCGImageAlphaNoneSkipLast) {
                  return 2316;
                }
                return 0;
              }
            }
          }
        }
      }
    }
  }
  return this;
}

void CI::MetalTextureManager::MetalTextureManager(CI::MetalTextureManager *this, CI::MetalContext *a2)
{
  int v3 = (*(uint64_t (**)(CI::MetalContext *))(*(void *)a2 + 272))(a2);
  CI::TextureManager::TextureManager(this, v3);
}

void sub_1936CA120(_Unwind_Exception *a1)
{
  CI::TextureManager::~TextureManager(v1);
  _Unwind_Resume(a1);
}

void *CI::MetalTextureManager::texture_for_CGImage(void **a1, CGImage *a2, uint64_t a3)
{
  uint64_t v6 = ((uint64_t (*)(void **))(*a1)[1])(a1);
  if (v6) {
    return *(void **)v6;
  }
  size_t Width = CGImageGetWidth(a2);
  size_t Height = CGImageGetHeight(a2);
  size_t BytesPerRow = CGImageGetBytesPerRow(a2);
  if (Width > (*(uint64_t (**)(void))(*a1[21] + 440))()
    || Height > (*(uint64_t (**)(void *))(*a1[21] + 440))(a1[21]))
  {
    x_log("Cannot handle a (%lu x %lu) sized texture with the given context!\n", Width, Height);
    return 0;
  }
  DataProvider = CGImageGetDataProvider(a2);
  uint64_t v13 = CGDataProviderRetainBytePtr();
  if (v13)
  {
    texture = CI::MetalTextureManager::create_texture((uint64_t)a1, (uint64_t)a2, 1, v13, Width, Height, BytesPerRow, a3);
    CGDataProviderReleaseBytePtr();
    return texture;
  }
  CFDataRef v14 = CGDataProviderCopyData(DataProvider);
  if (!v14) {
    return 0;
  }
  CFDataRef v15 = v14;
  if (CFDataGetLength(v14) >= 1 && (BytePtr = CFDataGetBytePtr(v15)) != 0) {
    texture = CI::MetalTextureManager::create_texture((uint64_t)a1, (uint64_t)a2, 1, (uint64_t)BytePtr, Width, Height, BytesPerRow, a3);
  }
  else {
    texture = 0;
  }
  CFRelease(v15);
  return texture;
}

void CI::new_kernel_archive()
{
}

void sub_1936CA394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  MEMORY[0x1997023B0](v11, 0x80C40512DBC69);
  _Unwind_Resume(a1);
}

CI::PrecompiledKernels *CI::PrecompiledKernels::PrecompiledKernels(CI::PrecompiledKernels *this)
{
  *(void *)this = &unk_1EE45CED0;
  *((unsigned char *)this + 8) = 1;
  *((void *)this + 2) = 0;
  long long v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *((void *)this + 7) = dispatch_queue_create("CI::LoadLibrariesQueue", v2);
  *((void *)this + 8) = dispatch_group_create();
  *((void *)this + 2) = objc_opt_new();
  return this;
}

void sub_1936CA458(_Unwind_Exception *a1)
{
  Queue::~Queue(v1);
  _Unwind_Resume(a1);
}

void CI::SurfaceCacheEntry::setIdentifier(CI::SurfaceCacheEntry *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v4 = (const void *)*((void *)this + 8);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 8) = cf;
}

dispatch_queue_t *CI::StitchableKernels::StitchableKernels(dispatch_queue_t *this, const CI::MetalContext *a2)
{
  *(void *)CI::PrecompiledKernels::PrecompiledKernels((CI::PrecompiledKernels *)this) = &unk_1EE45CCD8;
  uint64_t v4 = [NSString stringWithUTF8String:*((void *)a2 + 240)];
  this[3] = (dispatch_queue_t)(id)[MEMORY[0x1E4F1CA48] array];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  _OWORD v6[2] = ___ZN2CI17StitchableKernelsC2EPKNS_12MetalContextE_block_invoke;
  v6[3] = &unk_1E5774EF0;
  int64x2_t v6[5] = this;
  double v6[6] = a2;
  v6[4] = v4;
  Queue::execute_async(this + 7, v6);
  return this;
}

void sub_1936CA584(_Unwind_Exception *a1)
{
  CI::PrecompiledKernels::~PrecompiledKernels(v1);
  _Unwind_Resume(a1);
}

const char *CI::name_for_format(int a1)
{
  if (a1 <= 1792)
  {
    if (a1 <= 770)
    {
      switch(a1)
      {
        case 257:
          uint64_t result = "A8";
          break;
        case 258:
          uint64_t result = "I8";
          break;
        case 259:
          uint64_t result = "L8";
          break;
        case 260:
          uint64_t result = "LA8";
          break;
        case 261:
          uint64_t result = "R8";
          break;
        case 262:
          uint64_t result = "RG8";
          break;
        case 263:
          uint64_t result = "RGB8";
          break;
        case 264:
          uint64_t result = "RGBA8";
          break;
        case 265:
          uint64_t result = "ARGB8";
          break;
        case 266:
          uint64_t result = "BGRA8";
          break;
        case 267:
          uint64_t result = "ABGR8";
          break;
        case 268:
          uint64_t result = "RGBX8";
          break;
        case 269:
          uint64_t result = "XRGB8";
          break;
        case 270:
          uint64_t result = "BGRX8";
          break;
        case 271:
          uint64_t result = "XBGR8";
          break;
        case 272:
        case 273:
          return "unknown-format";
        case 274:
          uint64_t result = "YCC420f";
          break;
        case 275:
          uint64_t result = "YCC444f";
          break;
        case 276:
          uint64_t result = "CbYCrY8f";
          break;
        case 277:
          uint64_t result = "YCbYCr8f";
          break;
        case 278:
          uint64_t result = "YCC422f";
          break;
        default:
          switch(a1)
          {
            case 530:
              uint64_t result = "YCC420v";
              break;
            case 531:
              uint64_t result = "YCC444v";
              break;
            case 532:
              uint64_t result = "CbYCrY8";
              break;
            case 533:
              uint64_t result = "YCbYCr8";
              break;
            case 534:
              uint64_t result = "YCC422v";
              break;
            case 535:
              uint64_t result = "AYCbCr8";
              break;
            default:
              if (a1) {
                return "unknown-format";
              }
              uint64_t result = "Nil";
              break;
          }
          break;
      }
    }
    else
    {
      if (a1 > 1042)
      {
        if (a1 > 1298)
        {
          if (a1 <= 1553)
          {
            if (a1 == 1299) {
              return "YCC444f10Packed";
            }
            if (a1 == 1302) {
              return "YCC422f10Packed";
            }
          }
          else
          {
            switch(a1)
            {
              case 1554:
                return "YCC420v10Packed";
              case 1555:
                return "YCC444v10Packed";
              case 1558:
                return "YCC422v10Packed";
            }
          }
        }
        else if (a1 <= 1284)
        {
          if (a1 == 1043) {
            return "YCC444v10";
          }
          if (a1 == 1046) {
            return "YCC422v10";
          }
        }
        else
        {
          switch(a1)
          {
            case 1285:
              return "R10p";
            case 1286:
              return "RG10p";
            case 1298:
              return "YCC420f10Packed";
          }
        }
        return "unknown-format";
      }
      switch(a1)
      {
        case 771:
          uint64_t result = "L10";
          break;
        case 772:
        case 776:
        case 777:
        case 778:
        case 779:
        case 780:
        case 781:
        case 782:
        case 783:
        case 788:
        case 789:
          return "unknown-format";
        case 773:
          uint64_t result = "R10";
          break;
        case 774:
          uint64_t result = "RG10";
          break;
        case 775:
          uint64_t result = "RGB10";
          break;
        case 784:
          uint64_t result = "A2RGB10";
          break;
        case 785:
          uint64_t result = "A2BGR10";
          break;
        case 786:
          uint64_t result = "YCC420f10";
          break;
        case 787:
          uint64_t result = "YCC444f10";
          break;
        case 790:
          uint64_t result = "YCC422f10";
          break;
        default:
          if (a1 != 1042) {
            return "unknown-format";
          }
          uint64_t result = "YCC420v10";
          break;
      }
    }
  }
  else
  {
    if (a1 > 2304)
    {
      if (a1 > 3080)
      {
        if (a1 <= 3349)
        {
          if (a1 > 3333)
          {
            switch(a1)
            {
              case 3334:
                return "RG12";
              case 3346:
                return "YCC420f12";
              case 3347:
                return "YCC444f12";
            }
          }
          else
          {
            switch(a1)
            {
              case 3081:
                return "ARGB10-WideLinear";
              case 3331:
                return "L12";
              case 3333:
                return "R12";
            }
          }
        }
        else if (a1 <= 3605)
        {
          switch(a1)
          {
            case 3350:
              return "YCC422f12";
            case 3602:
              return "YCC420v12";
            case 3603:
              return "YCC444v12";
          }
        }
        else if (a1 > 3858)
        {
          if (a1 == 3859) {
            return "YCC444v16";
          }
          if (a1 == 3862) {
            return "YCC422v16";
          }
        }
        else
        {
          if (a1 == 3606) {
            return "YCC422v12";
          }
          if (a1 == 3858) {
            return "YCC420v16";
          }
        }
      }
      else
      {
        if (a1 <= 2566)
        {
          switch(a1)
          {
            case 2305:
              uint64_t result = "Af";
              break;
            case 2306:
              uint64_t result = "If";
              break;
            case 2307:
              uint64_t result = "Lf";
              break;
            case 2308:
              uint64_t result = "LAf";
              break;
            case 2309:
              uint64_t result = "Rf";
              break;
            case 2310:
              uint64_t result = "RGf";
              break;
            case 2311:
              uint64_t result = "RGBf";
              break;
            case 2312:
              uint64_t result = "RGBAf";
              break;
            case 2313:
              uint64_t result = "ARGBf";
              break;
            case 2316:
              uint64_t result = "RGBXf";
              break;
            default:
              return "unknown-format";
          }
          return result;
        }
        if (a1 > 2823)
        {
          if (a1 == 2824) {
            return "RGBA14";
          }
          if (a1 == 3079) {
            return "RGB10-WideLinear";
          }
        }
        else
        {
          if (a1 == 2567) {
            return "RGB10-WideGamut";
          }
          if (a1 == 2569) {
            return "ARGB10-WideGamut";
          }
        }
      }
      return "unknown-format";
    }
    switch(a1)
    {
      case 1793:
        uint64_t result = "A16";
        break;
      case 1794:
        uint64_t result = "I16";
        break;
      case 1795:
        uint64_t result = "L16";
        break;
      case 1796:
        uint64_t result = "LA16";
        break;
      case 1797:
        uint64_t result = "R16";
        break;
      case 1798:
        uint64_t result = "RG16";
        break;
      case 1799:
        uint64_t result = "RGB16";
        break;
      case 1800:
        uint64_t result = "RGBA16";
        break;
      case 1801:
        uint64_t result = "ARGB16";
        break;
      case 1802:
      case 1803:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        return "unknown-format";
      case 1804:
        uint64_t result = "RGBX16";
        break;
      case 1810:
        uint64_t result = "YCC420f16";
        break;
      case 1811:
        uint64_t result = "YCC444f16";
        break;
      case 1814:
        uint64_t result = "YCC422f16";
        break;
      default:
        switch(a1)
        {
          case 2049:
            uint64_t result = "Ah";
            break;
          case 2050:
            uint64_t result = "Ih";
            break;
          case 2051:
            uint64_t result = "Lh";
            break;
          case 2052:
            uint64_t result = "LAh";
            break;
          case 2053:
            uint64_t result = "Rh";
            break;
          case 2054:
            uint64_t result = "RGh";
            break;
          case 2055:
            uint64_t result = "RGBh";
            break;
          case 2056:
            uint64_t result = "RGBAh";
            break;
          case 2060:
            uint64_t result = "RGBXh";
            break;
          case 2066:
            uint64_t result = "YCC420fh";
            break;
          case 2067:
            uint64_t result = "YCC444fh";
            break;
          case 2070:
            uint64_t result = "YCC422fh";
            break;
          default:
            return "unknown-format";
        }
        break;
    }
  }
  return result;
}

CI::RenderToSurface *CI::RenderToSurface::RenderToSurface(CI::RenderToSurface *this, CFTypeRef cf)
{
  *((_DWORD *)this + 2) = 1;
  *(void *)this = &unk_1EE45CC00;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = &unk_1EE456D58;
  atomic_fetch_add(&dword_1EB466F58[25], 1u);
  *(void *)this = &unk_1EE45B4C0;
  *((void *)this + 5) = &unk_1EE45B518;
  *((void *)this + 6) = cf;
  if (cf) {
    CFRetain(cf);
  }
  return this;
}

void CI::TextureManager::TextureManager(CI::TextureManager *this, int a2)
{
  *(void *)this = &unk_1EE45A228;
  *((_DWORD *)this + 2) = a2;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = (char *)this + 32;
  *((void *)this + 5) = (char *)this + 32;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 64;
  *((void *)this + 9) = (char *)this + 64;
  *((void *)this + 1CI::NodeWithChildren::NodeWithChildren(this, 0) = 0;
  *((void *)this + 11) = dispatch_group_create();
  *((void *)this + 12) = dispatch_queue_create("CI::complete_intermediate", 0);
  int v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v4 = dispatch_queue_create("CI::TextureManager", v3);
  *((void *)this + 16) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 13) = v4;
  *((void *)this + 14) = (char *)this + 120;
  operator new();
}

uint64_t CI::TextureManager::add_intermediate_for_node(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v8 = 0;
  int v9 = &v8;
  v7[0] = 0;
  v7[1] = v7;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  void v7[2] = 0x2000000000;
  v7[3] = a3;
  if (a3 && *a2)
  {
    dispatch_queue_t v4 = *(NSObject **)(a1 + 104);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 0x40000000;
    _OWORD v6[2] = ___ZN2CI14TextureManager25add_intermediate_for_nodeERKNS_6roiKeyEPNS_14intermediate_tE_block_invoke;
    v6[3] = &unk_1E5776F18;
    double v6[6] = a1;
    void v6[7] = a2;
    v6[4] = v7;
    int64x2_t v6[5] = &v8;
    dispatch_sync(v4, v6);
    uint64_t v3 = v9[3];
  }
  _Block_object_dispose(v7, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t CI::TextureManager::_release_intermediate(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  (*(void (**)(void *__return_ptr, uint64_t))(*(void *)a2 + 24))(v4, a2);
  (**(void (***)(uint64_t, void *))a1)(a1, v4);
  v4[0] = 0;
  v4[1] = 0;
  std::list<CI::attached_surface_t *>::remove(*(void **)(a1 + 136), &v5);
  uint64_t result = v5;
  if (v5) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5);
  }
  return result;
}

void CI::TextureManager::tmIntermediate_t::~tmIntermediate_t(CI::TextureManager::tmIntermediate_t *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1EE45A1D0;
  JUMPOUT(0x1997023B0);
}

{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1EE45A1D0;
}

uint64_t CI::KernelArchive::KernelArchive(uint64_t a1, long long **a2)
{
  dispatch_queue_t v4 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E4F14430], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *(void *)a1 = dispatch_queue_create("CI::KernelArchiveLockQueue", v4);
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 8CI::NodeWithChildren::NodeWithChildren(this, 0) = objc_opt_new();
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (*a2 != v6)
  {
    uint64_t v7 = MEMORY[0x1E4F143A8];
    do
    {
      long long v8 = *v5++;
      int v9 = *(NSObject **)a1;
      block[0] = v7;
      block[1] = 3221225472;
      block[2] = ___ZN2CI13KernelArchive10addArchiveENSt3__14pairIPKvS4_EE_block_invoke;
      block[3] = &__block_descriptor_56_e5_v8__0l;
      void block[4] = a1;
      long long v12 = v8;
      dispatch_barrier_sync(v9, block);
    }
    while (v5 != v6);
  }
  return a1;
}

void sub_1936CB144(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void **)(v1 + 56);
  if (v5)
  {
    *(void *)(v1 + 64) = v5;
    operator delete(v5);
  }
  CI::KernelArchive::KernelArchive(v3, v2, v1);
  _Unwind_Resume(a1);
}

void CI::new_ci_dylib(CI *this, const CI::MetalContext *a2)
{
}

void sub_1936CB1E8(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10C0C4009D5372FLL);
  _Unwind_Resume(a1);
}

void CI::SurfaceImage::~SurfaceImage(CI::SurfaceImage *this)
{
  *(void *)this = &unk_1EE458AD0;
  *((void *)this + 13) = &unk_1EE458C38;
  long long v2 = (const void *)*((void *)this + 14);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 14) = 0;
    uint64_t v3 = (const void *)*((void *)this + 17);
    if (v3) {
      CFRelease(v3);
    }
    *((void *)this + 17) = 0;
    dispatch_queue_t v4 = (const void *)*((void *)this + 16);
    if (v4)
    {
      CFRelease(v4);
      *((void *)this + 16) = 0;
    }
  }
  uint64_t v5 = (const void *)*((void *)this + 18);
  if (v5) {
    CFRelease(v5);
  }
  *((void *)this + 18) = 0;
  uint64_t v6 = (const void *)*((void *)this + 19);
  if (v6) {
    CFRelease(v6);
  }
  *((void *)this + 19) = 0;
  uint64_t v7 = (const void *)*((void *)this + 20);
  if (v7) {
    CFRelease(v7);
  }
  *((void *)this + 2CI::NodeWithChildren::NodeWithChildren(this, 0) = 0;
  *((void *)this + 13) = &unk_1EE45AB48;
  atomic_fetch_add(&dword_1EB466E78[17], 0xFFFFFFFF);

  CI::Image::~Image(this);
}

{
  uint64_t vars8;

  CI::SurfaceImage::~SurfaceImage(this);

  JUMPOUT(0x1997023B0);
}

void CI::MetalContext::MetalContext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (dyld_program_sdk_at_least()) {
    int v16 = 2056;
  }
  else {
    int v16 = 264;
  }
  if (a6) {
    int v17 = a6;
  }
  else {
    int v17 = v16;
  }
  CI::Context::Context(a1, a4, a5, v17, a7, a8, a9, a10);
}

{
  CI::MetalContext::MetalContext(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

void sub_1936CB4A8(_Unwind_Exception *a1)
{
  uint64_t v5 = *(CI::Object **)(v1 + 1824);
  *(void *)(v1 + 1824) = 0;
  if (v5) {
    CI::Object::unref(v5);
  }
  *(void *)(v1 + 384) = v2;
  atomic_fetch_add((atomic_uint *volatile)(v3 + 308), 0xFFFFFFFF);
  CI::Context::~Context((CGColorSpaceRef *)v1);
  _Unwind_Resume(a1);
}

uint64_t CI::MetalContext::load_archives(CI::MetalContext *this)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t result = CI_USE_ARCHIVED_KERNELS();
  if (result)
  {
    if (CI::MetalContext::binaryArchiveCache(void)::onceToken != -1) {
      dispatch_once(&CI::MetalContext::binaryArchiveCache(void)::onceToken, &__block_literal_global_12_0);
    }
    uint64_t v3 = (void *)CI::MetalContext::binaryArchiveCache(void)::cache;
    int v30 = 0;
    int v31 = 0;
    unint64_t v32 = 0;
    objc_sync_enter((id)CI::MetalContext::binaryArchiveCache(void)::cache);
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    uint64_t v4 = [v3 countByEnumeratingWithState:&v26 objects:v37 count:16];
    if (v4)
    {
      uint64_t v5 = *(void *)v27;
      do
      {
        for (uint64_t i = 0; i != v4; ++i)
        {
          if (*(void *)v27 != v5) {
            objc_enumerationMutation(v3);
          }
          uint64_t v7 = *(void *)(*((void *)&v26 + 1) + 8 * i);
          long long v8 = (void *)[v3 objectForKey:v7];
          if (v8)
          {
            int v9 = ci_logger_render();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
            {
              int v10 = (*(uint64_t (**)(CI::MetalContext *))(*(void *)this + 272))(this);
              *(_DWORD *)CGRect buf = 67109378;
              int v34 = v10;
              __int16 v35 = 2114;
              uint64_t v36 = v7;
              _os_log_impl(&dword_193671000, v9, OS_LOG_TYPE_INFO, "Context[%d] uses %{public}@ archive", buf, 0x12u);
            }
            uint64_t v11 = [v8 objectForKeyedSubscript:@"air"];
            uint64_t v12 = [v8 objectForKeyedSubscript:@"bin"];
            uint64_t v13 = v12;
            CFDataRef v14 = v31;
            if ((unint64_t)v31 >= v32)
            {
              int64_t v16 = (v31 - (unsigned char *)v30) >> 4;
              unint64_t v17 = v16 + 1;
              if ((unint64_t)(v16 + 1) >> 60) {
                abort();
              }
              uint64_t v18 = v32 - (void)v30;
              if ((uint64_t)(v32 - (void)v30) >> 3 > v17) {
                unint64_t v17 = v18 >> 3;
              }
              if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v19 = v17;
              }
              if (v19) {
                char v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)&v32, v19);
              }
              else {
                char v20 = 0;
              }
              int v21 = (long long *)&v20[16 * v16];
              *(void *)int v21 = v11;
              *((void *)v21 + 1) = v13;
              int v23 = (long long *)v30;
              BOOL v22 = (long long *)v31;
              int v24 = v21;
              if (v31 != v30)
              {
                do
                  *--int v24 = *--v22;
                while (v22 != v23);
                BOOL v22 = (long long *)v30;
              }
              CFDataRef v15 = v21 + 1;
              int v30 = v24;
              int v31 = (char *)(v21 + 1);
              unint64_t v32 = (unint64_t)&v20[16 * v19];
              if (v22) {
                operator delete(v22);
              }
            }
            else
            {
              *(void *)int v31 = v11;
              *((void *)v14 + 1) = v12;
              CFDataRef v15 = (long long *)(v14 + 16);
            }
            int v31 = (char *)v15;
          }
        }
        uint64_t v4 = [v3 countByEnumeratingWithState:&v26 objects:v37 count:16];
      }
      while (v4);
    }
    objc_sync_exit(v3);
    memset(__p, 0, sizeof(__p));
    std::vector<std::pair<void const*,void const*>>::__init_with_size[abi:nn180100]<std::pair<void const*,void const*>*,std::pair<void const*,void const*>*>((char *)__p, (long long *)v30, (long long *)v31, (v31 - (unsigned char *)v30) >> 4);
    CI::new_kernel_archive();
  }
  return result;
}

void sub_1936CB820(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  if (a26) {
    operator delete(a26);
  }
  _Unwind_Resume(exception_object);
}

void CI::ClampImage::~ClampImage(CI::ClampImage *this)
{
  *((void *)this + 14) = &unk_1EE45B200;
  atomic_fetch_add(&dword_1EB466E78[5], 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);

  JUMPOUT(0x1997023B0);
}

{
  *((void *)this + 14) = &unk_1EE45B200;
  atomic_fetch_add(&dword_1EB466E78[5], 0xFFFFFFFF);
  CI::ImageWithChild::~ImageWithChild(this);
}

CGColorSpaceRef GetWorkingColorSpaceFromOptions(NSDictionary *a1, BOOL *a2)
{
  if (a2) {
    *a2 = 1;
  }
  uint64_t v3 = [(NSDictionary *)a1 valueForKey:@"working_color_space"];
  CGColorSpaceRef DeviceRGB = v3;
  if (v3 && v3 != (CGColorSpace *)*MEMORY[0x1E4F1D260])
  {
    if (!CGColorSpaceGetType())
    {
      CGColorSpaceRef DeviceRGB = CGColorSpaceCreateDeviceRGB();
      CFAutorelease(DeviceRGB);
    }
    if (!CI::ColorSpace_is_RGB_and_supports_output((BOOL)DeviceRGB, v5))
    {
      uint64_t v6 = ci_logger_api();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        GetWorkingColorSpaceFromOptions(v6);
      }
      CGColorSpaceRef DeviceRGB = 0;
      if (a2) {
        *a2 = 0;
      }
    }
  }
  return DeviceRGB;
}

id GetOutputColorSpaceFromOptions(NSDictionary *a1, BOOL *a2)
{
  if (a2) {
    *a2 = 1;
  }
  id v4 = [(NSDictionary *)a1 valueForKey:@"output_color_space"];
  id result = 0;
  if (v4)
  {
    if (v4 != (id)*MEMORY[0x1E4F1D260])
    {
      BOOL is_RGB_or_Gray_and_supports_output = CI::ColorSpace_is_RGB_or_Gray_and_supports_output((BOOL)v4, v3);
      id result = v4;
      if (!is_RGB_or_Gray_and_supports_output)
      {
        uint64_t v7 = ci_logger_api();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
          GetOutputColorSpaceFromOptions(v7);
        }
        id result = 0;
        if (a2) {
          *a2 = 0;
        }
      }
    }
  }
  return result;
}

void CoreAnalytics(NSString *a1, CIContext *a2)
{
  if (a1)
  {
    unint64_t v2 = 0x1EB466000uLL;
    {
      uint64_t v6 = a2;
      uint64_t v7 = a1;
      unint64_t v2 = 0x1EB466000;
      int v5 = v4;
      a2 = v6;
      a1 = v7;
      if (v5)
      {
        CoreAnalytics(NSString *,CIContext *)::queue = (uint64_t)dispatch_queue_create("CoreImageAnalytics", 0);
        unint64_t v2 = 0x1EB466000;
        a2 = v6;
        a1 = v7;
      }
    }
    uint64_t v3 = *(NSObject **)(v2 + 3384);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZL13CoreAnalyticsP8NSStringP9CIContext_block_invoke;
    block[3] = &unk_1E57710E0;
    void block[4] = a2;
    void block[5] = a1;
    dispatch_async(v3, block);
  }
}

BOOL checkFormat(int a1)
{
  if (a1 == 274 || a1 == 530 || a1 == 1298 || a1 == 1554 || a1 == 786 || a1 == 1042) {
    return 1;
  }
  HIDWORD(v7) = a1 - 1810;
  LODWORD(v7) = a1 - 1810;
  unsigned int v6 = v7 >> 8;
  if (v6 >= 9)
  {
    if (a1 == 2066) {
      return 1;
    }
  }
  else
  {
    unsigned int v8 = 0x1C1u >> v6;
    uint64_t v9 = 1;
    if ((v8 & 1) != 0 || a1 == 2066) {
      return v9;
    }
  }
  HIDWORD(v11) = a1 - 278;
  LODWORD(v11) = a1 - 278;
  unsigned int v10 = v11 >> 8;
  if (v10 < 0xF && ((0x70FFu >> v10) & 1) != 0) {
    return 1;
  }
  uint64_t v9 = 1;
  if (a1 > 1554)
  {
    if (a1 > 3346)
    {
      if (a1 == 3347 || a1 == 3603 || a1 == 3859) {
        return v9;
      }
    }
    else if (a1 == 1555 || a1 == 1811 || a1 == 2067)
    {
      return v9;
    }
  }
  else if (a1 > 786)
  {
    if (a1 == 787 || a1 == 1043 || a1 == 1299) {
      return v9;
    }
  }
  else if (a1 == 275 || a1 == 531 || a1 == 535)
  {
    return v9;
  }
  return a1 == 264
      || a1 == 265
      || a1 == 266
      || a1 == 267
      || a1 == 268
      || a1 == 269
      || a1 == 270
      || a1 == 271
      || a1 == 2056
      || a1 == 2060
      || a1 == 2567
      || a1 == 2569
      || a1 == 3079
      || a1 == 3081
      || a1 == 775
      || a1 == 784
      || a1 == 785
      || a1 == 1800
      || a1 == 1801
      || a1 == 1804
      || a1 == 2312
      || a1 == 2316
      || a1 == 2313
      || a1 == 263
      || a1 == 1799
      || a1 == 2310
      || a1 == 2309
      || a1 == 2308
      || a1 == 2307
      || a1 == 262
      || a1 == 774
      || a1 == 3334
      || a1 == 1798
      || a1 == 2054
      || a1 == 260
      || a1 == 1796
      || a1 == 261
      || a1 == 773
      || a1 == 3333
      || a1 == 1797
      || a1 == 2053
      || a1 == 259
      || a1 == 771
      || a1 == 3331
      || a1 == 1795
      || a1 == 2051;
}

__n64 _fillColor(CIImage *a1)
{
  result.n64_u64[0] = 0;
  if (a1)
  {
    unint64_t v2 = [(CIImage *)a1 _internalRepresentation];
    if ((*(unsigned int (**)(void *))(*v2 + 16))(v2) == 9)
    {
      uint64_t v3 = (float *)v2[14];
      result.n64_u64[0] = 0;
      if (v3)
      {
        float v4 = v3[9];
        result.n64_f32[0] = v3[6] * v4;
        result.n64_f32[1] = v4 * v3[7];
      }
    }
    else
    {
      return (__n64)vdupq_n_s32(0x7FC00000u).u64[0];
    }
  }
  return result;
}

uint64_t SurfaceSetVolatile(IOSurfaceRef buffer, unsigned int a2)
{
  if (CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck != -1) {
    dispatch_once(&CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck, &__block_literal_global_28);
  }
  if (CI_TRASH_SURFACES_ON_SETVOLATILE_v) {
    SurfaceApplyPlaneBlock(buffer, (uint64_t)&__block_literal_global_32_1);
  }
  if (a2 >= 7) {
    int v4 = 7;
  }
  else {
    int v4 = a2;
  }
  uint32_t oldState = 0;
  return IOSurfaceSetPurgeable(buffer, (v4 << 8) | 1, &oldState);
}

BOOL SurfaceSetNonVolatile(__IOSurface *a1)
{
  uint32_t oldState = 0;
  if (IOSurfaceSetPurgeable(a1, 0, &oldState)) {
    return 1;
  }
  if (CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck != -1) {
    dispatch_once(&CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck, &__block_literal_global_28);
  }
  return !CI_TRASH_SURFACES_ON_SETVOLATILE_v && oldState != 2;
}

uint64_t GetSurfaceFromCacheAndFill(long long *a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v36 = 0;
  uint64_t v37 = &v36;
  uint64_t v38 = 0x2000000000;
  uint64_t v39 = 0;
  if (*((void *)a1 + 1))
  {
    uint64_t v8 = 0;
    if (a5)
    {
      uint64_t v9 = a2;
      if (a2)
      {
        if (*((void *)a1 + 2))
        {
          uint64_t v8 = 0;
          if (a6)
          {
            if (a7)
            {
              if ((a2 & 0xFD000000) == 0x2D000000 || (int)a2 >> 24 == 124 || (int)a2 >> 24 == 38)
              {
                unsigned int v35 = bswap32(a2);
                CFDataRef v15 = ci_logger_cache();
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)CGRect buf = 136446722;
                  *(void *)&uint8_t buf[4] = "GetSurfaceFromCacheAndFill";
                  *(_WORD *)&unsigned char buf[12] = 1042;
                  *(_DWORD *)&buf[14] = 4;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = &v35;
                  _os_log_impl(&dword_193671000, v15, OS_LOG_TYPE_DEFAULT, "%{public}s  was passed compressed format '%{public}.4s'.  Ignoring compression.\n", buf, 0x1Cu);
                }
                LODWORD(v9) = equivalent_uncompressed_format(v9);
              }
              if (a3 && a4)
              {
                int64_t v16 = ci_logger_cache();
                BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
                int v18 = 0;
                if (v17)
                {
                  *(_DWORD *)CGRect buf = 136446722;
                  *(void *)&uint8_t buf[4] = "GetSurfaceFromCacheAndFill";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = a3;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = a4;
                  _os_log_impl(&dword_193671000, v16, OS_LOG_TYPE_DEFAULT, "%{public}s  was passed contextIndex=%d and imageIndex=%d.  Ignoring imageIndex.\n", buf, 0x18u);
                  int v18 = 0;
                }
              }
              else
              {
                int v18 = a4;
              }
              *(void *)CGRect buf = 0;
              *(void *)&uint8_t buf[8] = buf;
              *(void *)&uint8_t buf[16] = 0x2000000000;
              *(void *)&unsigned char buf[24] = 0;
              if (GetQueue(void)::onceToken != -1)
              {
                int v24 = v18;
                dispatch_once(&GetQueue(void)::onceToken, &__block_literal_global_71);
                int v18 = v24;
              }
              block[0] = MEMORY[0x1E4F143A8];
              block[1] = 0x40000000;
              block[2] = __GetSurfaceFromCacheAndFill_block_invoke;
              block[3] = &unk_1E5776908;
              int v32 = a3;
              int v33 = v18;
              long long v28 = *a1;
              uint64_t v19 = *((void *)a1 + 2);
              int v34 = v9;
              uint64_t v29 = v19;
              uint64_t v30 = a5;
              void block[4] = a7;
              void block[5] = &v36;
              uint64_t v31 = a6;
              void block[6] = buf;
              dispatch_sync((dispatch_queue_t)gSurfaceCacheQueue, block);
              char v20 = *(dispatch_queue_t **)(*(void *)&buf[8] + 24);
              if (v20)
              {
                if (v20[9])
                {
                  dispatch_sync(v20[9], &__block_literal_global_6);
                  char v20 = *(dispatch_queue_t **)(*(void *)&buf[8] + 24);
                }
                CI::Object::unref((CI::Object *)v20);
              }
              int v21 = CI_LOG_SURFACE_CACHE();
              if (v21)
              {
                int v22 = v21;
                if (GetQueue(void)::onceToken != -1) {
                  dispatch_once(&GetQueue(void)::onceToken, &__block_literal_global_71);
                }
                v25[0] = MEMORY[0x1E4F143A8];
                v25[1] = 0x40000000;
                v25[2] = __GetSurfaceFromCacheAndFill_block_invoke_23;
                v25[3] = &__block_descriptor_tmp_24_3;
                int v26 = v22;
                dispatch_sync((dispatch_queue_t)gSurfaceCacheQueue, v25);
              }
              uint64_t v8 = v37[3];
              _Block_object_dispose(buf, 8);
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  _Block_object_dispose(&v36, 8);
  return v8;
}

CFStringRef CoreAnayticsAppIndentifier(const __CFString *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    CFIndex Length = CFStringGetLength(result);
    v3.location = 0;
    v3.length = Length;
    if (CFStringFindWithOptions(v1, @"com.microsoft", v3, 1uLL, 0))
    {
      return @"Microsoft";
    }
    else
    {
      v4.location = 0;
      v4.length = Length;
      if (CFStringFindWithOptions(v1, @"com.adobe", v4, 1uLL, 0))
      {
        return @"Adobe";
      }
      else
      {
        v5.location = 0;
        v5.length = Length;
        if (CFStringFindWithOptions(v1, @"com.google", v5, 1uLL, 0))
        {
          return @"Google";
        }
        else
        {
          v6.location = 0;
          v6.length = Length;
          if (CFStringFindWithOptions(v1, @"com.facebook", v6, 1uLL, 0))
          {
            return @"Facebook";
          }
          else
          {
            v7.location = 0;
            v7.length = Length;
            if (CFStringFindWithOptions(v1, @"com.burbn.instagram", v7, 1uLL, 0))
            {
              return @"Instagram";
            }
            else
            {
              v8.location = 0;
              v8.length = Length;
              if (CFStringFindWithOptions(v1, @"com.gentlemencoders", v8, 1uLL, 0))
              {
                return @"GentlemenCoders";
              }
              else
              {
                v9.location = 0;
                v9.length = Length;
                if (CFStringFindWithOptions(v1, @"com.fxfactory", v9, 1uLL, 0))
                {
                  return @"FxFactory";
                }
                else
                {
                  v10.location = 0;
                  v10.length = Length;
                  if (CFStringFindWithOptions(v1, @"com.ubercab", v10, 1uLL, 0))
                  {
                    return @"Uber";
                  }
                  else
                  {
                    v11.location = 0;
                    v11.length = Length;
                    if (CFStringFindWithOptions(v1, @"com.postmates", v11, 1uLL, 0))
                    {
                      return @"Postmates";
                    }
                    else
                    {
                      v12.location = 0;
                      v12.length = Length;
                      if (CFStringFindWithOptions(v1, @"com.dynamicappdesign.rawplus", v12, 1uLL, 0))
                      {
                        return @"RawPlus";
                      }
                      else
                      {
                        v13.location = 0;
                        v13.length = Length;
                        if (CFStringFindWithOptions(v1, @"com.pixelmatorteam", v13, 1uLL, 0))
                        {
                          return @"Pixelmator";
                        }
                        else
                        {
                          v14.location = 0;
                          v14.length = Length;
                          if (CFStringFindWithOptions(v1, @"com.vidvox", v14, 1uLL, 0))
                          {
                            return @"Vidvox";
                          }
                          else
                          {
                            v15.location = 0;
                            v15.length = Length;
                            if (CFStringFindWithOptions(v1, @"com.boinx", v15, 1uLL, 0))
                            {
                              return @"Boinx";
                            }
                            else
                            {
                              v16.location = 0;
                              v16.length = Length;
                              if (CFStringFindWithOptions(v1, @"com.ecamm", v16, 1uLL, 0))
                              {
                                return @"Ecamm";
                              }
                              else
                              {
                                v17.location = 0;
                                v17.length = Length;
                                if (CFStringFindWithOptions(v1, @"com.crossforward", v17, 1uLL, 0))
                                {
                                  return @"CrossForward";
                                }
                                else
                                {
                                  v18.location = 0;
                                  v18.length = Length;
                                  if (CFStringFindWithOptions(v1, @"com.apple", v18, 1uLL, 0)) {
                                    return v1;
                                  }
                                  else {
                                    return @"Other";
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t CI_WORKING_FORMAT()
{
  if (CI_WORKING_FORMAT::didCheck != -1) {
    dispatch_once(&CI_WORKING_FORMAT::didCheck, &__block_literal_global_90_0);
  }
  return CI_WORKING_FORMAT::v;
}

uint64_t CI_USE_ARCHIVED_KERNELS()
{
  {
    CI_USE_ARCHIVED_KERNELS::v = get_int("CI_USE_ARCHIVED_KERNELS", 2);
  }
  return CI_USE_ARCHIVED_KERNELS::v;
}

void sub_1936CC878(_Unwind_Exception *a1)
{
}

uint64_t CI_SURFACE_CACHE_CAPACITY()
{
  {
    CI_SURFACE_CACHE_CAPACITY::v = get_ulong("CI_SURFACE_CACHE_CAPACITY", 0x20000000);
  }
  return CI_SURFACE_CACHE_CAPACITY::v;
}

void sub_1936CC8F8(_Unwind_Exception *a1)
{
}

uint64_t CI_MAX_TEXTURE_SIZE()
{
  {
    CI_MAX_TEXTURE_SIZE::v = get_int("CI_MAX_TEXTURE_SIZE", 0x7FFFFFFFLL);
  }
  return CI_MAX_TEXTURE_SIZE::v;
}

void sub_1936CC978(_Unwind_Exception *a1)
{
}

uint64_t CIMetalDeviceIsSupported(void *a1, const char *a2)
{
  return [a1 supportsFamily:1002];
}

void *CIMetalDeviceIsA9OrHigher(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 supportsFamily:1003];
  }
  return a1;
}

void *CIMetalCommandQueueCreate(uint64_t a1, void *a2)
{
  _DWORD v9[2] = *MEMORY[0x1E4F143B8];
  CFRange v3 = (void *)[a2 newCommandQueue];
  if (!dyld_program_sdk_at_least()) {
    goto LABEL_5;
  }
  if (isWidget_once != -1) {
    dispatch_once(&isWidget_once, &__block_literal_global_66);
  }
  if (!isWidget_bWidget) {
LABEL_5:
  }
    [v3 setBackgroundGPUPriority:2];
  if (CI_ENABLE_METAL_DEBUG())
  {
    if (objc_msgSend((id)objc_msgSend((id)objc_msgSend(v3, "device"), "name"), "containsString:", @"AMD"))
    {
      CFRange v4 = @"AMDStat_GPU_Engine_Ticks";
    }
    else if (objc_msgSend((id)objc_msgSend((id)objc_msgSend(v3, "device"), "name"), "containsString:", @"Intel"))
    {
      CFRange v4 = @"GPU_CoreClocks";
    }
    else if (objc_msgSend((id)objc_msgSend((id)objc_msgSend(v3, "device"), "name"), "containsString:", @"NVIDIA"))
    {
      CFRange v4 = @"MTLStatHostElapsedCycles";
    }
    else
    {
      CFRange v4 = (__CFString *)[@"MTLStatTotalGPUCycles" copy];
    }
    v9[0] = @"MTLStat_nSec";
    v9[1] = v4;
    CFRange v5 = (void *)[MEMORY[0x1E4F1C978] arrayWithObjects:v9 count:2];
    uint64_t v6 = [v5 count];
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    void v8[2] = __configureQueue_block_invoke;
    v8[3] = &__block_descriptor_40_e42_v32__0___MTLCommandBuffer__8__NSData_16Q24l;
    void v8[4] = v6;
    [v3 addPerfSampleHandler:v8];
    [v3 setStatEnabled:1];
    [v3 setStatLocations:63];
    [v3 setStatOptions:1];
    if ([v3 requestCounters:v5 withIndex:0]) {
      NSLog(&cfstr_ErrorRequestin.isa);
    }
  }
  if (CI_ENABLE_METAL_LABEL()) {
    objc_msgSend(v3, "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  return v3;
}

void sub_1936CD0B8(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40E019140BLL);
  _Unwind_Resume(a1);
}

void sub_1936CD57C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1936CD994(_Unwind_Exception *a1)
{
}

int8x8_t cikernel::_distanceMaskPrep(CI *a1, float32x2_t a2, int8x16_t a3)
{
  DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v4 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  int8x8_t v5 = (int8x8_t)vdiv_f32(vsub_f32(*DC, *(float32x2_t *)a3.i8), v4);
  v4.i32[0] = 0.5;
  return vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vmvn_s8((int8x8_t)vcge_f32(v4, a2)), 0), v5, (int8x8_t)vdup_n_s32(0x7F800000u));
}

void CI::f4_s_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  CFRange v11 = (double (*)(void *, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  CFRange v16 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    CFRange v16 = (__n128 *)((char *)a2 + 64 * v15);
  }
  CFRange v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    CFRange v17 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v18 = v11(a1, *v17, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

void CI::ColorKernel::~ColorKernel(CI::ColorKernel *this)
{
  CI::Kernel::~Kernel(this);

  JUMPOUT(0x1997023B0);
}

uint64_t CI::Kernel::metalConstantTypes(CI::Kernel *this)
{
  return 0;
}

uint64_t CI::ColorKernel::set_extentType(uint64_t result, int a2)
{
  if (*(unsigned char *)(result + 12)) {
    *(_DWORD *)(result + 168) = a2;
  }
  return result;
}

uint64_t CI::ColorKernel::set_blendBehavior(uint64_t result, int a2, int a3)
{
  if (*(unsigned char *)(result + 12))
  {
    if (a3) {
      int v3 = *(_DWORD *)(result + 172) | a2;
    }
    else {
      int v3 = *(_DWORD *)(result + 172) & ~a2;
    }
    *(_DWORD *)(result + 172) = v3;
  }
  return result;
}

void CI::Kernel::~Kernel(CI::Kernel *this)
{
  *(void *)this = &unk_1EE45DED0;
  if (*((unsigned char *)this + 12))
  {
    unint64_t v2 = (void *)*((void *)this + 3);
    if (v2) {
      free(v2);
    }
    int v3 = (void *)*((void *)this + 4);
    if (v3 && !*((unsigned char *)this + 104)) {
      free(v3);
    }
    float32x2_t v4 = (void *)*((void *)this + 5);
    if (v4) {
      free(v4);
    }
    *((void *)this + 4) = 0;
    *((void *)this + 5) = 0;
    int8x8_t v5 = (const void *)*((void *)this + 14);
    if (v5)
    {
      CFRelease(v5);
      *((void *)this + 14) = 0;
    }
  }
  CI::KernelArguments::~KernelArguments((CI::Kernel *)((char *)this + 144));
}

{
  uint64_t vars8;

  CI::Kernel::~Kernel(this);

  JUMPOUT(0x1997023B0);
}

void sub_1936CEF84(_Unwind_Exception *a1)
{
  CI::KernelArguments::~KernelArguments((CI::KernelArguments *)(v1 + 144));
  _Unwind_Resume(a1);
}

uint64_t CI::Kernel::type(CI::Kernel *this)
{
  return 61;
}

void CI::KernelArguments::~KernelArguments(CI::KernelArguments *this)
{
  uint64_t v2 = *(void *)this;
  if (*(void *)this)
  {
    int v3 = *(void **)(v2 + 16);
    if (v3) {
      free(v3);
    }
    MEMORY[0x1997023B0](v2, 0x1010C40C0D7B093);
  }
  *(void *)this = 0;
  float32x2_t v4 = (CI::SerialStringArray *)*((void *)this + 1);
  if (v4)
  {
    CI::SerialStringArray::~SerialStringArray(v4);
    MEMORY[0x1997023B0]();
  }
  *((void *)this + 1) = 0;
}

__n128 cikernel::_distanceMask(uint64_t a1, int8x16_t a2, float a3)
{
  float32x2_t v8 = *(float32x2_t *)CI::getDC((CI *)a1);
  int8x16_t v9 = a2;
  float32x2_t v21 = (float32x2_t)vextq_s8(v9, v9, 8uLL).u64[0];
  float32x2_t v10 = vadd_f32(*(float32x2_t *)a2.i8, vmul_f32(v21, vdiv_f32(vsub_f32(v8, *(float32x2_t *)a2.i8), v21)));
  long long v11 = xmmword_19394C7D0;
  long long v20 = xmmword_19394C7D0;
  int v12 = -1;
  float v13 = *(float *)"(knN";
  do
  {
    *(float *)&long long v11 = (float)v12;
    long long v24 = v11;
    for (int i = -1; i != 2; ++i)
    {
      float64x2_t v15 = (float64x2_t)v24;
      *((float *)v15.f64 + 1) = (float)i;
      float32x2_t v16 = vadd_f32(v8, vmul_n_f32(*(float32x2_t *)&v15.f64[0], a3));
      *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v16, 1), *(float *)(a1 + 16), v16.f32[0]);
      LODWORD(v4) = *(_DWORD *)(a1 + 28);
      v6.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v16, 1), *(float *)&v4, v16.f32[0]);
      v16.f32[0] = *(float *)(a1 + 24) + *(float *)v9.i32;
      *(float *)v15.f64 = *(float *)v6.i32 + *(float *)v5.i32;
      v16.f32[1] = *(float *)v6.i32 + *(float *)v5.i32;
      *(double *)&long long v11 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v16, v15, *(double *)v9.i64, v4, v5, v6, v7);
      if (*(float *)&v11 != INFINITY)
      {
        v9.i32[1] = a2.i32[1];
        float32x2_t v17 = vsub_f32(v10, vadd_f32(*(float32x2_t *)a2.i8, vmul_f32(v21, *(float32x2_t *)&v11)));
        float v18 = sqrtf(vaddv_f32(vmul_f32(v17, v17)));
        if (v18 < v13)
        {
          long long v20 = v11;
          float v13 = v18;
        }
      }
    }
    ++v12;
  }
  while (v12 != 2);
  return (__n128)v20;
}

void CI::f4_sr_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  int v12 = *(double (**)(uint64_t, __n128, float))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  int v14 = *(_DWORD *)(v11 + 40);
  uint64_t v15 = *(void *)(v11 + 32);
  uint64_t v16 = *(void *)(v11 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 80)), a2);
  }
  float32x2_t v17 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    float32x2_t v17 = (__n128 *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v18 = v12(a4 + 80 * v13, *v17, *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

void CI::GeneralKernel::~GeneralKernel(CI::GeneralKernel *this)
{
  CI::Kernel::~Kernel(this);

  JUMPOUT(0x1997023B0);
}

uint64_t CI::GeneralKernel::type(CI::GeneralKernel *this)
{
  return 64;
}

double CI::BitmapSampler::read(uint64x2_t *a1, double a2, float64x2_t a3, double a4, double a5, int8x16_t a6, int8x16_t a7, int8x16_t a8)
{
  if (a1[8].i8[11])
  {
    a3 = vcvtq_f64_u64(a1[5]);
    *(float32x2_t *)&a3.f64[0] = vcvt_f32_f64(a3);
    a2 = COERCE_DOUBLE(vmul_f32(*(float32x2_t *)&a2, *(float32x2_t *)&a3.f64[0]));
  }
  if (a1[8].i8[10])
  {
    uint64_t v9 = a1[5].i64[0];
    double v10 = 0.0;
    if (v9)
    {
      uint64_t v11 = a1[5].i64[1];
      if (v11)
      {
        uint64_t v12 = a1[4].i64[1];
        if (v12)
        {
          if (a1[7].i64[0] && a1[7].i64[1])
          {
            int v13 = (int)*(float *)&a2;
            LODWORD(a2) = HIDWORD(a2);
            int v14 = v13 & ~(v13 >> 31);
            int v15 = v9 - 1;
            if (v14 >= v15) {
              int v16 = v15;
            }
            else {
              int v16 = v14;
            }
            int v17 = v11 - 1;
            if (((int)*((float *)&a2 + 1) & ~((int)*((float *)&a2 + 1) >> 31)) < (int)v11 - 1) {
              int v17 = (int)*((float *)&a2 + 1) & ~((int)*((float *)&a2 + 1) >> 31);
            }
            return CI::BitmapSampler::read((CI::BitmapSampler *)a1, (unsigned __int8 *)(v12 + a1[6].i64[0] * v17), v16, a2, (int8x16_t)a3);
          }
        }
      }
    }
    return v10;
  }
  HIDWORD(a3.f64[0]) = -1090519040;
  *(float32x2_t *)v18.f32 = vadd_f32(*(float32x2_t *)&a2, (float32x2_t)0xBF000000BF000000);
  int v19 = vcvtms_s32_f32(v18.f32[0]);
  int v20 = vcvtms_s32_f32(v18.f32[1]);
  *(float *)a3.f64 = v18.f32[1] - (float)(int)floorf(v18.f32[1]);
  uint64_t v21 = a1[5].i64[0];
  uint64_t v22 = a1[5].i64[1];
  int v23 = v21 - 1;
  if ((v19 & ~(v19 >> 31)) >= (int)v21 - 1) {
    int v24 = v21 - 1;
  }
  else {
    int v24 = v19 & ~(v19 >> 31);
  }
  int v25 = v22 - 1;
  if ((v20 & ~(v20 >> 31)) >= (int)v22 - 1) {
    int v26 = v22 - 1;
  }
  else {
    int v26 = v20 & ~(v20 >> 31);
  }
  if (v19 < 0) {
    int v27 = -1;
  }
  else {
    int v27 = v19;
  }
  if (v20 < 0) {
    int v20 = -1;
  }
  if (v27 + 1 < v23) {
    int v28 = v27 + 1;
  }
  else {
    int v28 = v21 - 1;
  }
  if (v20 + 1 < v25) {
    int v29 = v20 + 1;
  }
  else {
    int v29 = v22 - 1;
  }
  if (v24 + 1 != v28)
  {
    float32x4_t v33 = 0uLL;
    if (v21 && v22)
    {
      uint64_t v34 = a1[4].i64[1];
      float32x4_t v35 = 0uLL;
      if (!v34 || !a1[7].i64[0] || !a1[7].i64[1]) {
        goto LABEL_50;
      }
      int v36 = v26 & ~(v26 >> 31);
      if ((v24 & ~(v24 >> 31)) >= v23) {
        int v37 = v21 - 1;
      }
      else {
        int v37 = v24 & ~(v24 >> 31);
      }
      if (v36 >= v25) {
        int v38 = v22 - 1;
      }
      else {
        int v38 = v36;
      }
      float64x2_t v46 = a3;
      *(double *)v18.i64 = CI::BitmapSampler::read((CI::BitmapSampler *)a1, (unsigned __int8 *)(v34 + a1[6].i64[0] * v38), v37, *(double *)v18.i64, (int8x16_t)a3);
      float32x4_t v33 = 0uLL;
      a3 = v46;
      float32x4_t v35 = v18;
      uint64_t v21 = a1[5].i64[0];
    }
    else
    {
      float32x4_t v35 = 0uLL;
    }
    if (!v21)
    {
LABEL_60:
      *(void *)&double v10 = vmlaq_n_f32(vmulq_n_f32(v35, 1.0 - *(float *)a3.f64), v33, *(float *)a3.f64).u64[0];
      return v10;
    }
LABEL_50:
    uint64_t v39 = a1[5].i64[1];
    if (v39)
    {
      uint64_t v40 = a1[4].i64[1];
      if (v40)
      {
        if (a1[7].i64[0] && a1[7].i64[1])
        {
          int v41 = v21 - 1;
          if ((v24 & ~(v24 >> 31)) >= v41) {
            int v42 = v41;
          }
          else {
            int v42 = v24 & ~(v24 >> 31);
          }
          int v43 = v39 - 1;
          if ((v29 & ~(v29 >> 31)) < (int)v39 - 1) {
            int v43 = v29 & ~(v29 >> 31);
          }
          float32x4_t v45 = v35;
          unsigned __int32 v47 = LODWORD(a3.f64[0]);
          *(double *)v44.i64 = CI::BitmapSampler::read((CI::BitmapSampler *)a1, (unsigned __int8 *)(v40 + a1[6].i64[0] * v43), v42, *(double *)v18.i64, (int8x16_t)a3);
          float32x4_t v35 = v45;
          LODWORD(a3.f64[0]) = v47;
          float32x4_t v33 = v44;
        }
      }
    }
    goto LABEL_60;
  }
  v18.f32[0] = v18.f32[0] - (float)v19;
  uint64_t v30 = a1[4].i64[1];
  uint64_t v31 = a1[6].i64[0];

  *(float *)&a4 = (float)v19;
  return CI::BitmapSampler::bilinear_read((float32x4_t *)a1, (int32x2_t *)(v30 + v31 * v26), (unsigned __int8 *)(v30 + v31 * v29), v24, v24, *(double *)v18.i64, a3.f64[0], a4, a5, a6, a7, a8);
}

double CI::BitmapSampler::bilinear_read(float32x4_t *this, int32x2_t *a2, unsigned __int8 *a3, int a4, int a5, double a6, double a7, double a8, double a9, int8x16_t a10, int8x16_t a11, int8x16_t a12)
{
  int v13 = a3;
  int v14 = this[6].i32[2];
  if ((v14 - 1285) >= 2)
  {
    uint64_t v15 = this[7].i64[1];
    a2 = (int32x2_t *)((char *)a2 + v15 * a4);
    int v13 = &a3[v15 * a5];
  }
  int16x4_t v16 = 0;
  if (v14 <= 2048)
  {
    if (v14 > 1284)
    {
      switch(v14)
      {
        case 1793:
        case 1794:
        case 1795:
        case 1797:
          goto LABEL_6;
        case 1796:
        case 1798:
          goto LABEL_44;
        case 1799:
          float32x4_t v86 = this[21];
          float32x4_t v87 = this[22];
          float32x4_t v88 = this[24];
          v148[2] = this[23];
          v148[3] = v88;
          v148[0] = v86;
          v148[1] = v87;
          double v89 = CI::bilinear_three_components(a2, (int32x2_t *)v13, v148, *(float *)&a6, *(float *)&a7);
          goto LABEL_56;
        case 1800:
        case 1801:
        case 1804:
          goto LABEL_34;
        case 1802:
        case 1803:
          return *(double *)&v16;
        default:
          if (v14 == 1285)
          {
            v122.f32[0] = 1.0 - *(float *)&a6;
            v122.i32[1] = LODWORD(a6);
            v122.f32[2] = 1.0 - *(float *)&a6;
            v122.i32[3] = LODWORD(a6);
            v18.f32[0] = 1.0 - *(float *)&a7;
            v18.i32[1] = LODWORD(a7);
            v123.f32[0] = (float)(((unsigned __int32)a2->i32[a4 / 3] >> (10 * (a4 % 3))) & 0x3FF);
            v123.f32[1] = (float)(((unsigned __int32)a2->i32[(a4 + 1) / 3] >> (10 * ((a4 + 1) % 3))) & 0x3FF);
            v123.f32[2] = (float)((*(_DWORD *)&v13[4 * (a5 / 3)] >> (10 * (a5 % 3))) & 0x3FF);
            v123.f32[3] = (float)((*(_DWORD *)&v13[4 * ((a5 + 1) / 3)] >> (10 * ((a5 + 1) % 3))) & 0x3FF);
            int8x16_t v28 = (int8x16_t)vmulq_f32(v122, vmulq_f32(this[26], v123));
            goto LABEL_25;
          }
          if (v14 != 1286) {
            return *(double *)&v16;
          }
          *(float *)&a9 = 1.0 - *(float *)&a6;
          int32x2_t v30 = vdup_lane_s32(*(int32x2_t *)&a6, 0);
          *(int32x2_t *)v31.f32 = vdup_lane_s32(*(int32x2_t *)&a9, 0);
          *(int32x2_t *)&v31.u32[2] = v30;
          v32.f32[0] = (float)(((unsigned __int32)a2->i32[2 * a4 / 3] >> (10 * (2 * a4 % 3))) & 0x3FF);
          v33.f32[0] = (float)((*(_DWORD *)&v13[4 * (2 * a5 / 3)] >> (10 * (2 * a5 % 3))) & 0x3FF);
          v33.f32[1] = (float)((*(_DWORD *)&v13[4 * (((2 * a5) | 1) / 3)] >> (10 * (((2 * a5) | 1) % 3))) & 0x3FF);
          v33.f32[2] = (float)((*(_DWORD *)&v13[4 * ((2 * a5 + 2) / 3)] >> (10 * ((2 * a5 + 2) % 3))) & 0x3FF);
          v33.f32[3] = (float)((*(_DWORD *)&v13[4 * ((2 * a5 + 3) / 3)] >> (10 * ((2 * a5 + 3) % 3))) & 0x3FF);
          v32.f32[1] = (float)(((unsigned __int32)a2->i32[((2 * a4) | 1) / 3] >> (10 * (((2 * a4) | 1) % 3))) & 0x3FF);
          v32.f32[2] = (float)(((unsigned __int32)a2->i32[(2 * a4 + 2) / 3] >> (10 * ((2 * a4 + 2) % 3))) & 0x3FF);
          v32.f32[3] = (float)(((unsigned __int32)a2->i32[(2 * a4 + 3) / 3] >> (10 * ((2 * a4 + 3) % 3))) & 0x3FF);
          float v34 = 1.0 - *(float *)&a7;
          int8x16_t v35 = (int8x16_t)vmulq_f32(v31, vmulq_f32(this[28], v33));
          int8x16_t v36 = (int8x16_t)vmulq_f32(v31, vmulq_f32(this[27], v32));
          break;
      }
LABEL_47:
      float32x2_t v98 = vadd_f32(*(float32x2_t *)v35.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL));
      float32x2_t v84 = vmul_n_f32(vadd_f32(*(float32x2_t *)v36.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL)), v34);
LABEL_61:
      float32x2_t v85 = vmul_n_f32(v98, *(float *)&a7);
      goto LABEL_62;
    }
    switch(v14)
    {
      case 257:
        CI::bilinear_single_component(a2, (__int8 *)v13, *(float32_t *)&a6, a7, this[10], *(int16x4_t *)&a9);
        int16x4_t v16 = 0;
        return *(double *)&v16;
      case 258:
      case 259:
      case 261:
        *(float *)&a9 = 1.0 - *(float *)&a6;
        v20.f32[0] = 1.0 - *(float *)&a6;
        v20.i32[1] = LODWORD(a6);
        v20.f32[2] = 1.0 - *(float *)&a6;
        v20.i32[3] = LODWORD(a6);
        v21.f32[0] = 1.0 - *(float *)&a7;
        v21.i32[1] = LODWORD(a7);
        LOBYTE(a7) = a2->i8[0];
        BYTE4(a7) = a2->i8[1];
        LOBYTE(a9) = *v13;
        BYTE4(a9) = v13[1];
        int8x16_t v22 = (int8x16_t)vmovl_u16((uint16x4_t)vuzp1_s16(*(int16x4_t *)&a7, *(int16x4_t *)&a9));
        v23.i64[0] = 0xFF000000FFLL;
        v23.i64[1] = 0xFF000000FFLL;
        int8x16_t v24 = (int8x16_t)vmulq_f32(v20, vmulq_f32(this[10], vaddq_f32((float32x4_t)vorrq_s8(vandq_s8(v22, v23), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000))));
        v22.i64[0] = vextq_s8(v24, v24, 4uLL).u64[0];
        v24.i32[1] = vextq_s8(v24, v24, 8uLL).i32[1];
        float32x2_t v25 = vmul_f32(v21, vadd_f32(*(float32x2_t *)v22.i8, *(float32x2_t *)v24.i8));
        goto LABEL_26;
      case 260:
      case 262:
        *(float *)&a9 = 1.0 - *(float *)&a6;
        *(int32x2_t *)v90.f32 = vdup_lane_s32(*(int32x2_t *)&a9, 0);
        *(int32x2_t *)&v90.u32[2] = vdup_lane_s32(*(int32x2_t *)&a6, 0);
        v91.i32[0] = a2->i32[0];
        v91.i32[1] = *(_DWORD *)v13;
        uint16x8_t v92 = vmovl_u8(v91);
        int8x16_t v93 = (int8x16_t)vmovl_high_u16(v92);
        int8x16_t v94 = (int8x16_t)vdupq_n_s32(0x4B400000u);
        float32x4_t v95 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v92.i8), v94);
        float32x4_t v96 = (float32x4_t)vorrq_s8(v93, v94);
        float32x4_t v97 = (float32x4_t)vdupq_n_s32(0xCB400000);
        float v34 = 1.0 - *(float *)&a7;
        int8x16_t v35 = (int8x16_t)vmulq_f32(v90, vmulq_f32(this[12], vaddq_f32(v96, v97)));
        int8x16_t v36 = (int8x16_t)vmulq_f32(v90, vmulq_f32(this[11], vaddq_f32(v95, v97)));
        goto LABEL_47;
      case 263:
        float32x4_t v124 = this[13];
        float32x4_t v125 = this[14];
        float32x4_t v126 = this[16];
        v149[2] = this[15];
        v149[3] = v126;
        v149[0] = v124;
        v149[1] = v125;
        double v89 = CI::bilinear_three_components((uint64_t)a2, (uint64_t)v13, v149, *(float *)&a6, *(float *)&a7);
        goto LABEL_56;
      case 264:
      case 268:
        float32x4_t v51 = this[15];
        float32x4_t v50 = this[16];
        float32x4_t v53 = this[13];
        float32x4_t v52 = this[14];
        float v54 = 1.0;
        float v55 = 1.0 - *(float *)&a6;
        uint16x8_t v110 = vmovl_u8(*(uint8x8_t *)v13);
        int8x16_t v57 = (int8x16_t)vmovl_high_u16(v110);
        int8x16_t v58 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v110.i8);
        uint16x8_t v56 = vmovl_u8((uint8x8_t)*a2);
        goto LABEL_35;
      case 265:
      case 269:
        goto LABEL_65;
      case 266:
      case 270:
        uint16x8_t v111 = vmovl_u8(*(uint8x8_t *)v13);
        int8x16_t v112 = (int8x16_t)vmovl_high_u16(v111);
        uint16x8_t v113 = vmovl_u8((uint8x8_t)*a2);
        int8x16_t v114 = (int8x16_t)vmovl_high_u16(v113);
        int8x16_t v115 = (int8x16_t)vdupq_n_s32(0x4B400000u);
        float32x4_t v116 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v113.i8), v115);
        float32x4_t v117 = (float32x4_t)vorrq_s8(v114, v115);
        float32x4_t v118 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v111.i8), v115);
        float32x4_t v119 = (float32x4_t)vorrq_s8(v112, v115);
        float32x4_t v120 = (float32x4_t)vdupq_n_s32(0xCB400000);
        int8x16_t v121 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(this[13], vaddq_f32(v116, v120)), 1.0 - *(float *)&a6), vmulq_n_f32(vmulq_f32(this[14], vaddq_f32(v117, v120)), *(float *)&a6)), 1.0 - *(float *)&a7), vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(this[15], vaddq_f32(v118, v120)), 1.0 - *(float *)&a6), vmulq_n_f32(vmulq_f32(this[16], vaddq_f32(v119, v120)), *(float *)&a6)), *(float *)&a7)));
        int16x4_t v16 = (int16x4_t)vextq_s8(v121, v121, 0xCuLL).u64[0];
        return *(double *)&v16;
      case 267:
      case 271:
        uint16x8_t v99 = vmovl_u8(*(uint8x8_t *)v13);
        int8x16_t v100 = (int8x16_t)vmovl_high_u16(v99);
        uint16x8_t v101 = vmovl_u8((uint8x8_t)*a2);
        int8x16_t v102 = (int8x16_t)vmovl_high_u16(v101);
        int8x16_t v103 = (int8x16_t)vdupq_n_s32(0x4B400000u);
        float32x4_t v104 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v101.i8), v103);
        float32x4_t v105 = (float32x4_t)vorrq_s8(v102, v103);
        float32x4_t v106 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v99.i8), v103);
        float32x4_t v107 = (float32x4_t)vorrq_s8(v100, v103);
        float32x4_t v108 = (float32x4_t)vdupq_n_s32(0xCB400000);
        int8x16_t v109 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(this[13], vaddq_f32(v104, v108)), 1.0 - *(float *)&a6), vmulq_n_f32(vmulq_f32(this[14], vaddq_f32(v105, v108)), *(float *)&a6)), 1.0 - *(float *)&a7), vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(this[15], vaddq_f32(v106, v108)), 1.0 - *(float *)&a6), vmulq_n_f32(vmulq_f32(this[16], vaddq_f32(v107, v108)), *(float *)&a6)), *(float *)&a7)));
        int16x4_t v16 = (int16x4_t)vextq_s8(v109, v109, 8uLL).u64[0];
        return *(double *)&v16;
      default:
        char v27 = v14 - 3;
        if ((v14 - 771) > 0xE) {
          goto LABEL_64;
        }
        if (((1 << v27) & 0x6010) != 0) {
          goto LABEL_33;
        }
        if (((1 << v27) & 5) != 0)
        {
          v16.i32[0] = 1.0;
          v17.f32[0] = 1.0 - *(float *)&a6;
          v17.i32[1] = LODWORD(a6);
          v17.f32[2] = 1.0 - *(float *)&a6;
          v17.i32[3] = LODWORD(a6);
          v18.f32[0] = 1.0 - *(float *)&a7;
          v18.i32[1] = LODWORD(a7);
          LOWORD(a7) = a2->i16[0];
          WORD2(a7) = a2->i16[1];
          v16.i16[0] = *(_WORD *)v13;
          v16.i16[2] = *((_WORD *)v13 + 1);
          float32x4_t v19 = vmulq_f32(this[26], vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(vshr_n_u16((uint16x4_t)vuzp1_s16(*(int16x4_t *)&a7, v16), 6uLL)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)));
          goto LABEL_24;
        }
        if (v14 == 774)
        {
          *(float *)&a9 = 1.0 - *(float *)&a6;
          *(int32x2_t *)v69.f32 = vdup_lane_s32(*(int32x2_t *)&a9, 0);
          *(int32x2_t *)&v69.u32[2] = vdup_lane_s32(*(int32x2_t *)&a6, 0);
          float v70 = 1.0 - *(float *)&a7;
          *(int32x2_t *)v127.i8 = *a2;
          v127.i64[1] = *(void *)v13;
          uint16x8_t v128 = vshrq_n_u16(v127, 6uLL);
          int8x16_t v129 = (int8x16_t)vmovl_high_u16(v128);
          int8x16_t v130 = (int8x16_t)vdupq_n_s32(0x4B400000u);
          float32x4_t v131 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v128.i8), v130);
          float32x4_t v132 = (float32x4_t)vorrq_s8(v129, v130);
          float32x4_t v133 = (float32x4_t)vdupq_n_s32(0xCB400000);
          float32x4_t v71 = vmulq_f32(this[27], vaddq_f32(v131, v133));
          float32x4_t v72 = vmulq_f32(this[28], vaddq_f32(v132, v133));
          goto LABEL_60;
        }
LABEL_64:
        if (v14 == 535)
        {
LABEL_65:
          uint16x8_t v137 = vmovl_u8(*(uint8x8_t *)v13);
          int8x16_t v138 = (int8x16_t)vmovl_high_u16(v137);
          uint16x8_t v139 = vmovl_u8((uint8x8_t)*a2);
          int8x16_t v140 = (int8x16_t)vmovl_high_u16(v139);
          int8x16_t v141 = (int8x16_t)vdupq_n_s32(0x4B400000u);
          float32x4_t v142 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v139.i8), v141);
          float32x4_t v143 = (float32x4_t)vorrq_s8(v140, v141);
          float32x4_t v144 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v137.i8), v141);
          float32x4_t v145 = (float32x4_t)vorrq_s8(v138, v141);
          float32x4_t v146 = (float32x4_t)vdupq_n_s32(0xCB400000);
          int8x16_t v147 = (int8x16_t)vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(this[13], vaddq_f32(v142, v146)), 1.0 - *(float *)&a6), vmulq_n_f32(vmulq_f32(this[14], vaddq_f32(v143, v146)), *(float *)&a6)), 1.0 - *(float *)&a7), vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(this[15], vaddq_f32(v144, v146)), 1.0 - *(float *)&a6), vmulq_n_f32(vmulq_f32(this[16], vaddq_f32(v145, v146)), *(float *)&a6)), *(float *)&a7));
          int16x4_t v16 = (int16x4_t)vextq_s8(v147, v147, 4uLL).u64[0];
        }
        break;
    }
    return *(double *)&v16;
  }
  if (v14 <= 2304)
  {
    switch(v14)
    {
      case 2049:
      case 2050:
      case 2051:
      case 2053:
        v17.f32[0] = 1.0 - *(float *)&a6;
        v17.i32[1] = LODWORD(a6);
        v17.f32[2] = 1.0 - *(float *)&a6;
        v17.i32[3] = LODWORD(a6);
        v18.f32[0] = 1.0 - *(float *)&a7;
        v18.i32[1] = LODWORD(a7);
        v26.i32[0] = a2->i32[0];
        v26.i32[1] = *(_DWORD *)v13;
        float32x4_t v19 = vcvtq_f32_f16(v26);
        goto LABEL_24;
      case 2052:
      case 2054:
        *(float *)&a9 = 1.0 - *(float *)&a6;
        *(int32x2_t *)v69.f32 = vdup_lane_s32(*(int32x2_t *)&a9, 0);
        *(int32x2_t *)&v69.u32[2] = vdup_lane_s32(*(int32x2_t *)&a6, 0);
        float v70 = 1.0 - *(float *)&a7;
        float32x4_t v71 = vcvtq_f32_f16((float16x4_t)*a2);
        float32x4_t v72 = vcvtq_f32_f16(*(float16x4_t *)v13);
LABEL_60:
        int8x16_t v134 = (int8x16_t)vmulq_f32(v69, v72);
        int8x16_t v135 = (int8x16_t)vmulq_f32(v69, v71);
        float32x2_t v98 = vadd_f32(*(float32x2_t *)v134.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v134, v134, 8uLL));
        float32x2_t v84 = vmul_n_f32(vadd_f32(*(float32x2_t *)v135.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v135, v135, 8uLL)), v70);
        goto LABEL_61;
      case 2055:
        double v89 = CI::bilinear_three_components((float16x4_t *)a2, (float16x4_t *)v13, *(float *)&a6, *(float *)&a7);
LABEL_56:
        int16x4_t v16 = *(int16x4_t *)&v89;
        break;
      case 2056:
      case 2060:
        float v37 = 1.0 - *(float *)&a7;
        float32x4_t v75 = vmulq_n_f32(vcvt_hight_f32_f16(*(float16x8_t *)v13), *(float *)&a6);
        float32x4_t v76 = vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v13), 1.0 - *(float *)&a6);
        float32x4_t v48 = vaddq_f32(vmulq_n_f32(vcvtq_f32_f16((float16x4_t)*a2), 1.0 - *(float *)&a6), vmulq_n_f32(vcvt_hight_f32_f16(*(float16x8_t *)a2->i8), *(float *)&a6));
        float32x4_t v49 = vaddq_f32(v76, v75);
        goto LABEL_40;
      default:
        return *(double *)&v16;
    }
    return *(double *)&v16;
  }
  if (v14 <= 2566)
  {
    switch(v14)
    {
      case 2305:
      case 2306:
      case 2307:
      case 2309:
        v17.f32[0] = 1.0 - *(float *)&a6;
        v17.i32[1] = LODWORD(a6);
        v17.f32[2] = 1.0 - *(float *)&a6;
        v17.i32[3] = LODWORD(a6);
        v18.f32[0] = 1.0 - *(float *)&a7;
        v18.i32[1] = LODWORD(a7);
        *(int32x2_t *)v19.f32 = *a2;
        v19.i64[1] = *(void *)v13;
        goto LABEL_24;
      case 2308:
      case 2310:
        *(float *)&a9 = 1.0 - *(float *)&a6;
        *(int32x2_t *)v69.f32 = vdup_lane_s32(*(int32x2_t *)&a9, 0);
        *(int32x2_t *)&v69.u32[2] = vdup_lane_s32(*(int32x2_t *)&a6, 0);
        float v70 = 1.0 - *(float *)&a7;
        float32x4_t v71 = *(float32x4_t *)a2->i8;
        float32x4_t v72 = *(float32x4_t *)v13;
        goto LABEL_60;
      case 2311:
        double v89 = CI::bilinear_three_components((float32x4_t *)a2, (float32x4_t *)v13, *(float *)&a6, *(float *)&a7);
        goto LABEL_56;
      case 2312:
      case 2316:
        float v37 = 1.0 - *(float *)&a7;
        float32x4_t v73 = vmulq_n_f32(*((float32x4_t *)v13 + 1), *(float *)&a6);
        float32x4_t v74 = vmulq_n_f32(*(float32x4_t *)v13, 1.0 - *(float *)&a6);
        float32x4_t v48 = vaddq_f32(vmulq_n_f32(*(float32x4_t *)a2->i8, 1.0 - *(float *)&a6), vmulq_n_f32(*(float32x4_t *)a2[2].i8, *(float *)&a6));
        float32x4_t v49 = vaddq_f32(v74, v73);
        goto LABEL_40;
      default:
        return *(double *)&v16;
    }
    return *(double *)&v16;
  }
  if (v14 <= 3080)
  {
    if (v14 != 2567)
    {
      if (v14 == 2569)
      {
LABEL_34:
        float32x4_t v51 = this[23];
        float32x4_t v50 = this[24];
        float32x4_t v53 = this[21];
        float32x4_t v52 = this[22];
        float v54 = 1.0;
        float v55 = 1.0 - *(float *)&a6;
        uint16x8_t v56 = *(uint16x8_t *)a2->i8;
        int8x16_t v57 = (int8x16_t)vmovl_high_u16(*(uint16x8_t *)v13);
        int8x16_t v58 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v13);
LABEL_35:
        int8x16_t v59 = (int8x16_t)vmovl_high_u16(v56);
        int8x16_t v60 = (int8x16_t)vdupq_n_s32(0x4B400000u);
        float32x4_t v61 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v56.i8), v60);
        float32x4_t v62 = (float32x4_t)vorrq_s8(v59, v60);
        float32x4_t v63 = (float32x4_t)vorrq_s8(v58, v60);
        float32x4_t v64 = (float32x4_t)vorrq_s8(v57, v60);
        float32x4_t v65 = (float32x4_t)vdupq_n_s32(0xCB400000);
        float v66 = v54 - *(float *)&a7;
        float32x4_t v67 = vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(v51, vaddq_f32(v63, v65)), v55), vmulq_n_f32(vmulq_f32(v50, vaddq_f32(v64, v65)), *(float *)&a6)), *(float *)&a7);
        float32x4_t v68 = vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(v53, vaddq_f32(v61, v65)), v55), vmulq_n_f32(vmulq_f32(v52, vaddq_f32(v62, v65)), *(float *)&a6)), v66);
LABEL_41:
        int16x4_t v16 = (int16x4_t)vaddq_f32(v68, v67).u64[0];
        return *(double *)&v16;
      }
      if (v14 != 3079) {
        return *(double *)&v16;
      }
    }
LABEL_33:
    float v37 = 1.0 - *(float *)&a7;
    unsigned int v38 = a2->u32[1];
    a11.i32[0] = (unsigned __int32)a2->i32[0] >> 20;
    a12.i32[0] = vand_s8(*(int8x8_t *)a11.i8, (int8x8_t)0x300000003).u32[0];
    a11.i32[1] = a2->i32[0];
    v39.i32[0] = a2->i32[0];
    v39.i32[1] = (unsigned __int32)a2->i32[0] >> 10;
    *(int8x8_t *)v40.i8 = vand_s8(v39, (int8x8_t)0x300000003);
    *(uint32x2_t *)a11.i8 = vshr_n_u32(*(uint32x2_t *)a11.i8, 0x1EuLL);
    a12.i32[1] = a11.i32[1];
    v40.i64[1] = a12.i64[0];
    a11.i32[0] = v38 & 0x3FF;
    *(int8x8_t *)a12.i8 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v38), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
    uint32x4_t v41 = (uint32x4_t)vextq_s8(vextq_s8(a11, a11, 4uLL), a12, 0xCuLL);
    v41.i32[3] = v38 >> 30;
    unsigned int v43 = *(_DWORD *)v13;
    unsigned int v42 = *((_DWORD *)v13 + 1);
    a12.i32[0] = v43 & 0x3FF;
    *(int8x8_t *)v12.i8 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v43), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
    uint32x4_t v44 = (uint32x4_t)vextq_s8(vextq_s8(a12, a12, 4uLL), v12, 0xCuLL);
    v44.i32[3] = v43 >> 30;
    v12.i32[0] = v42 & 0x3FF;
    *(int8x8_t *)a10.i8 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v42), (uint32x2_t)0xFFFFFFECFFFFFFF6), (int8x8_t)0x300000003);
    uint32x4_t v45 = (uint32x4_t)vextq_s8(vextq_s8(v12, v12, 4uLL), a10, 0xCuLL);
    v45.i32[3] = v42 >> 30;
    float32x4_t v46 = vmulq_n_f32(vmulq_f32(vcvtq_f32_u32(v45), (float32x4_t)xmmword_19394C7F0), *(float *)&a6);
    float32x4_t v47 = vmulq_n_f32(vmulq_f32(vcvtq_f32_u32(v44), (float32x4_t)xmmword_19394C7F0), 1.0 - *(float *)&a6);
    float32x4_t v48 = vaddq_f32(vmulq_n_f32(vmulq_f32(vcvtq_f32_u32(v40), (float32x4_t)xmmword_19394C7F0), 1.0 - *(float *)&a6), vmulq_n_f32(vmulq_f32(vcvtq_f32_u32(v41), (float32x4_t)xmmword_19394C7F0), *(float *)&a6));
    float32x4_t v49 = vaddq_f32(v47, v46);
LABEL_40:
    float32x4_t v67 = vmulq_n_f32(v49, *(float *)&a7);
    float32x4_t v68 = vmulq_n_f32(v48, v37);
    goto LABEL_41;
  }
  if (v14 <= 3332)
  {
    if (v14 != 3081)
    {
      if (v14 != 3331) {
        return *(double *)&v16;
      }
      goto LABEL_6;
    }
    goto LABEL_34;
  }
  if (v14 == 3333)
  {
LABEL_6:
    v16.i32[0] = 1.0;
    v17.f32[0] = 1.0 - *(float *)&a6;
    v17.i32[1] = LODWORD(a6);
    v17.f32[2] = 1.0 - *(float *)&a6;
    v17.i32[3] = LODWORD(a6);
    v18.f32[0] = 1.0 - *(float *)&a7;
    v18.i32[1] = LODWORD(a7);
    LOWORD(a7) = a2->i16[0];
    WORD2(a7) = a2->i16[1];
    v16.i16[0] = *(_WORD *)v13;
    v16.i16[2] = *((_WORD *)v13 + 1);
    float32x4_t v19 = vmulq_f32(this[18], vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)vuzp1_s16(*(int16x4_t *)&a7, v16)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)));
LABEL_24:
    int8x16_t v28 = (int8x16_t)vmulq_f32(v17, v19);
LABEL_25:
    float32x2_t v29 = (float32x2_t)vextq_s8(v28, v28, 4uLL).u64[0];
    v28.i32[1] = vextq_s8(v28, v28, 8uLL).i32[1];
    float32x2_t v25 = vmul_f32(v18, vadd_f32(v29, *(float32x2_t *)v28.i8));
LABEL_26:
    int16x4_t v16 = (int16x4_t)vadd_f32(v25, (float32x2_t)vdup_lane_s32((int32x2_t)v25, 1)).u32[0];
    return *(double *)&v16;
  }
  if (v14 == 3334)
  {
LABEL_44:
    *(float *)a11.i32 = 1.0 - *(float *)&a6;
    *(int32x2_t *)v77.f32 = vdup_lane_s32(*(int32x2_t *)a11.i8, 0);
    *(int32x2_t *)&v77.u32[2] = vdup_lane_s32(*(int32x2_t *)&a6, 0);
    int8x16_t v78 = (int8x16_t)vdupq_n_s32(0x4B400000u);
    float32x4_t v79 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*a2), v78);
    float32x4_t v80 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v13), v78);
    float32x4_t v81 = (float32x4_t)vdupq_n_s32(0xCB400000);
    int8x16_t v82 = (int8x16_t)vmulq_f32(v77, vmulq_f32(this[20], vaddq_f32(v80, v81)));
    int8x16_t v83 = (int8x16_t)vmulq_f32(v77, vmulq_f32(this[19], vaddq_f32(v79, v81)));
    float32x2_t v84 = vmul_n_f32(vadd_f32(*(float32x2_t *)v83.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v83, v83, 8uLL)), 1.0 - *(float *)&a7);
    float32x2_t v85 = vmul_n_f32(vadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v82, v82, 8uLL)), *(float *)&a7);
LABEL_62:
    int16x4_t v16 = (int16x4_t)vadd_f32(v84, v85);
  }
  return *(double *)&v16;
}

double CI::BitmapSampler::read(CI::BitmapSampler *this, unsigned __int8 *a2, int a3, double a4, int8x16_t a5)
{
  int v5 = *((_DWORD *)this + 26);
  if ((v5 - 1285) >= 2) {
    a2 += *((void *)this + 15) * a3;
  }
  _Q0.i64[0] = 0;
  if (v5 > 2048)
  {
    if (v5 <= 2304)
    {
      switch(v5)
      {
        case 2049:
        case 2050:
        case 2051:
        case 2053:
          _H0 = *(_WORD *)a2;
          __asm { FCVT            S0, H0 }
          goto LABEL_25;
        case 2052:
        case 2054:
          _Q0.i32[0] = *(_DWORD *)a2;
          _Q0.i64[0] = vcvtq_f32_f16(*(float16x4_t *)_Q0.f32).u64[0];
          break;
        case 2055:
          _Q0.i32[0] = *(_DWORD *)a2;
          float32x2_t v22 = (float32x2_t)vcvtq_f32_f16(*(float16x4_t *)_Q0.f32).u64[0];
          _H0 = *((_WORD *)a2 + 2);
          __asm { FCVT            S2, H0 }
LABEL_54:
          __asm { FMOV            V0.4S, #1.0 }
          *(float32x2_t *)_Q0.f32 = v22;
          break;
        case 2056:
        case 2060:
          _Q0.i64[0] = vcvtq_f32_f16(*(float16x4_t *)a2).u64[0];
          break;
        default:
          return *(double *)_Q0.i64;
      }
      return *(double *)_Q0.i64;
    }
    if (v5 <= 2566)
    {
      switch(v5)
      {
        case 2305:
        case 2306:
        case 2307:
        case 2309:
          _Q0.i32[0] = *(_DWORD *)a2;
          goto LABEL_25;
        case 2308:
        case 2310:
          _Q0.i64[0] = *(void *)a2;
          break;
        case 2311:
          __asm { FMOV            V0.4S, #1.0 }
          _Q0.i64[0] = *(void *)a2;
          break;
        case 2312:
        case 2316:
          _Q0 = *(float32x4_t *)a2;
          break;
        default:
          return *(double *)_Q0.i64;
      }
      return *(double *)_Q0.i64;
    }
    if (v5 > 3080)
    {
      if (v5 > 3332)
      {
        if (v5 != 3333)
        {
          if (v5 == 3334)
          {
LABEL_43:
            v18.i32[0] = *(unsigned __int16 *)a2;
            v18.i32[1] = *((unsigned __int16 *)a2 + 1);
            float32x2_t v19 = vadd_f32((float32x2_t)vorr_s8(v18, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000));
            float32x2_t v20 = *(float32x2_t *)((char *)this + 272);
LABEL_57:
            *(float32x2_t *)_Q0.f32 = vmul_f32(v20, v19);
          }
          return *(double *)_Q0.i64;
        }
        goto LABEL_6;
      }
      if (v5 != 3081)
      {
        if (v5 != 3331) {
          return *(double *)_Q0.i64;
        }
LABEL_6:
        _Q0.i16[0] = *(_WORD *)a2;
        _Q0.f32[0] = (float)_Q0.u32[0];
        float v7 = 65535.0;
LABEL_24:
        _Q0.f32[0] = _Q0.f32[0] / v7;
LABEL_25:
        _Q0.i32[1] = 0;
        return *(double *)_Q0.i64;
      }
LABEL_35:
      _Q0 = vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)a2), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000));
      float32x4_t v17 = *((float32x4_t *)this + 18);
LABEL_36:
      _Q0.i64[0] = vmulq_f32(v17, _Q0).u64[0];
      return *(double *)_Q0.i64;
    }
    if (v5 != 2567)
    {
      if (v5 == 2569) {
        goto LABEL_35;
      }
      if (v5 != 3079) {
        return *(double *)_Q0.i64;
      }
    }
LABEL_33:
    a5.i32[0] = *(_DWORD *)a2;
    a5.i32[1] = *(_DWORD *)a2 >> 10;
    a5.i32[2] = *(_DWORD *)a2 >> 20;
    v15.i64[0] = 0x300000003;
    v15.i64[1] = 0x300000003;
    uint32x4_t v16 = (uint32x4_t)vandq_s8(a5, v15);
    v16.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(*(_DWORD *)a2), 0x1EuLL).i32[3];
    _Q0 = vcvtq_f32_u32(v16);
    float32x4_t v14 = (float32x4_t)xmmword_19394C810;
LABEL_34:
    _Q0.i64[0] = vdivq_f32(_Q0, v14).u64[0];
    return *(double *)_Q0.i64;
  }
  if (v5 > 1284)
  {
    switch(v5)
    {
      case 1793:
      case 1794:
      case 1795:
      case 1797:
        goto LABEL_6;
      case 1796:
      case 1798:
        goto LABEL_43;
      case 1799:
        v21.i32[0] = *(unsigned __int16 *)a2;
        v21.i32[1] = *((unsigned __int16 *)a2 + 1);
        float32x2_t v22 = vmul_f32(*(float32x2_t *)((char *)this + 272), vadd_f32((float32x2_t)vorr_s8(v21, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)));
        goto LABEL_54;
      case 1800:
      case 1801:
      case 1804:
        goto LABEL_35;
      case 1802:
      case 1803:
        return *(double *)_Q0.i64;
      default:
        if (v5 == 1285)
        {
          _Q0.f32[0] = (float)((*(_DWORD *)&a2[4 * (a3 / 3)] >> (10 * (a3 % 3))) & 0x3FF) / 1023.0;
          _Q0.i32[1] = 0;
          return *(double *)_Q0.i64;
        }
        if (v5 != 1286) {
          return *(double *)_Q0.i64;
        }
        _Q0.f32[0] = (float)((*(_DWORD *)&a2[4 * (2 * a3 / 3)] >> (10 * (2 * a3 % 3))) & 0x3FF);
        _Q0.f32[1] = (float)((*(_DWORD *)&a2[4 * (((2 * a3) | 1) / 3)] >> (10 * (((2 * a3) | 1) % 3))) & 0x3FF);
        _Q0.i32[2] = 0;
        _Q0.i32[3] = 1.0;
        float32x4_t v14 = (float32x4_t)xmmword_19394C800;
        break;
    }
    goto LABEL_34;
  }
  switch(v5)
  {
    case 257:
      _Q0.i64[0] = 0;
      return *(double *)_Q0.i64;
    case 258:
    case 259:
    case 261:
      _Q0.i8[0] = *a2;
      _Q0.f32[0] = (float)_Q0.u32[0];
      float v7 = 255.0;
      goto LABEL_24;
    case 260:
    case 262:
      v23.i32[0] = *a2;
      v23.i32[1] = a2[1];
      float32x2_t v19 = vadd_f32((float32x2_t)vorr_s8(v23, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000));
      float32x2_t v20 = *(float32x2_t *)((char *)this + 144);
      goto LABEL_57;
    case 263:
      v26.i32[0] = *a2;
      v26.i32[1] = a2[1];
      float32x2_t v22 = vmul_f32(*(float32x2_t *)((char *)this + 144), vadd_f32((float32x2_t)vorr_s8(v26, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)));
      goto LABEL_54;
    case 264:
    case 268:
      _Q0.i32[0] = *(_DWORD *)a2;
      _Q0 = vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)_Q0.f32)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000));
      float32x4_t v17 = *((float32x4_t *)this + 10);
      goto LABEL_36;
    case 265:
    case 269:
      goto LABEL_60;
    case 266:
    case 270:
      _Q0.i32[0] = *(_DWORD *)a2;
      _Q0 = (float32x4_t)vrev64q_s32((int32x4_t)vmulq_f32(*((float32x4_t *)this + 10), vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)_Q0.f32)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000))));
      _Q0.i64[0] = vextq_s8((int8x16_t)_Q0, (int8x16_t)_Q0, 0xCuLL).u64[0];
      return *(double *)_Q0.i64;
    case 267:
    case 271:
      _Q0.i32[0] = *(_DWORD *)a2;
      _Q0 = (float32x4_t)vrev64q_s32((int32x4_t)vmulq_f32(*((float32x4_t *)this + 10), vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)_Q0.f32)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000))));
      _Q0.i64[0] = vextq_s8((int8x16_t)_Q0, (int8x16_t)_Q0, 8uLL).u64[0];
      return *(double *)_Q0.i64;
    default:
      char v13 = v5 - 3;
      if ((v5 - 771) > 0xE) {
        goto LABEL_59;
      }
      if (((1 << v13) & 0x6010) != 0) {
        goto LABEL_33;
      }
      if (((1 << v13) & 5) != 0)
      {
        _Q0.f32[0] = (float)(*(unsigned __int16 *)a2 >> 6);
        float v7 = *(float *)"";
        goto LABEL_24;
      }
      if (v5 == 774)
      {
        v27.i32[0] = *(unsigned __int16 *)a2;
        v27.i32[1] = *((unsigned __int16 *)a2 + 1);
        float32x2_t v19 = vadd_f32((float32x2_t)vsra_n_u32((uint32x2_t)vdup_n_s32(0x4B400000u), v27, 6uLL), (float32x2_t)vdup_n_s32(0xCB400000));
        float32x2_t v20 = *(float32x2_t *)((char *)this + 400);
        goto LABEL_57;
      }
LABEL_59:
      if (v5 == 535)
      {
LABEL_60:
        _Q0.i32[0] = *(_DWORD *)a2;
        _Q0 = vmulq_f32(*((float32x4_t *)this + 10), vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)_Q0.f32)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)));
        _Q0.i64[0] = vextq_s8((int8x16_t)_Q0, (int8x16_t)_Q0, 4uLL).u64[0];
      }
      break;
  }
  return *(double *)_Q0.i64;
}

float CI::bilinear_single_component(unsigned char *a1, __int8 *a2, float32_t a3, double a4, float32x4_t a5, int16x4_t a6)
{
  a6.i32[0] = 1.0;
  v6.f32[0] = 1.0 - a3;
  v6.f32[1] = a3;
  v6.f32[2] = 1.0 - a3;
  v6.f32[3] = a3;
  v7.f32[0] = 1.0 - *(float *)&a4;
  v7.i32[1] = LODWORD(a4);
  LOBYTE(a4) = *a1;
  BYTE4(a4) = a1[1];
  a6.i8[0] = *a2;
  a6.i8[4] = a2[1];
  int8x16_t v8 = (int8x16_t)vmovl_u16((uint16x4_t)vuzp1_s16(*(int16x4_t *)&a4, a6));
  v9.i64[0] = 0xFF000000FFLL;
  v9.i64[1] = 0xFF000000FFLL;
  int8x16_t v10 = (int8x16_t)vmulq_f32(v6, vmulq_f32(vaddq_f32((float32x4_t)vorrq_s8(vandq_s8(v8, v9), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)), a5));
  float32x2_t v11 = (float32x2_t)vextq_s8(v10, v10, 4uLL).u64[0];
  v10.i32[1] = vextq_s8(v10, v10, 8uLL).i32[1];
  return vaddv_f32(vmul_f32(v7, vadd_f32(v11, *(float32x2_t *)v10.i8)));
}

double CI::bilinear_three_components(uint64_t a1, uint64_t a2, float32x4_t *a3, float a4, float a5)
{
  v5.i32[0] = *(_DWORD *)a1;
  uint16x8_t v7 = vmovl_u8(v5);
  v6.i8[4] = *(unsigned char *)(a1 + 5);
  v8.i8[7] = 0;
  v8.i8[0] = v7.i8[0];
  v8.i8[1] = v7.i8[2];
  v8.i8[2] = v7.i8[4];
  v8.i8[3] = v7.i8[6];
  v8.i8[4] = *(unsigned char *)(a1 + 4);
  *(__int16 *)((char *)&v8.i16[2] + 1) = v6.u8[4];
  v7.i8[7] = 0;
  v6.i32[0] = *(_DWORD *)a2;
  uint16x8_t v9 = vmovl_u8(v6);
  v7.i8[0] = v9.i8[0];
  v7.i8[1] = v9.i8[2];
  v7.i8[2] = v9.i8[4];
  v7.i8[3] = v9.i8[6];
  v7.i8[4] = *(unsigned char *)(a2 + 4);
  *(__int16 *)((char *)&v7.i16[2] + 1) = *(unsigned __int8 *)(a2 + 5);
  uint16x8_t v10 = vmovl_u8(*(uint8x8_t *)v7.i8);
  int8x16_t v11 = (int8x16_t)vmovl_high_u16(v10);
  uint16x8_t v12 = vmovl_u8(v8);
  int8x16_t v13 = (int8x16_t)vmovl_high_u16(v12);
  int8x16_t v14 = (int8x16_t)vdupq_n_s32(0x4B400000u);
  float32x4_t v15 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v12.i8), v14);
  float32x4_t v16 = (float32x4_t)vorrq_s8(v13, v14);
  float32x4_t v17 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v10.i8), v14);
  float32x4_t v18 = (float32x4_t)vorrq_s8(v11, v14);
  float32x4_t v19 = (float32x4_t)vdupq_n_s32(0xCB400000);
  *(void *)&double result = vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(*a3, vaddq_f32(v15, v19)), 1.0 - a4), vmulq_n_f32(vmulq_f32(a3[1], vaddq_f32(v16, v19)), a4)), 1.0 - a5), vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(a3[2], vaddq_f32(v17, v19)), 1.0 - a4), vmulq_n_f32(vmulq_f32(a3[3], vaddq_f32(v18, v19)), a4)), a5)).u64[0];
  return result;
}

double CI::bilinear_three_components(int32x2_t *a1, int32x2_t *a2, float32x4_t *a3, float a4, float a5)
{
  int8x16_t v5 = (int8x16_t)vdupq_n_s32(0x4B400000u);
  float32x4_t v6 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s32(*a1, 0)), v5);
  float32x4_t v7 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*a1), v5);
  float32x4_t v8 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s32(*a2, 0)), v5);
  float32x4_t v9 = (float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*a2), v5);
  float32x4_t v10 = (float32x4_t)vdupq_n_s32(0xCB400000);
  *(void *)&double result = vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(*a3, vaddq_f32(v7, v10)), 1.0 - a4), vmulq_n_f32(vmulq_f32(a3[1], vaddq_f32(v6, v10)), a4)), 1.0 - a5), vmulq_n_f32(vaddq_f32(vmulq_n_f32(vmulq_f32(a3[2], vaddq_f32(v9, v10)), 1.0 - a4), vmulq_n_f32(vmulq_f32(a3[3], vaddq_f32(v8, v10)), a4)), a5)).u64[0];
  return result;
}

double CI::bilinear_three_components(float16x4_t *a1, float16x4_t *a2, float a3, float a4)
{
  *(void *)&double result = vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vcvtq_f32_f16(*a1), 1.0 - a3), vmulq_n_f32(vcvtq_f32_f16((float16x4_t)vzip2_s32((int32x2_t)*a1, 0)), a3)), 1.0 - a4), vmulq_n_f32(vaddq_f32(vmulq_n_f32(vcvtq_f32_f16(*a2), 1.0 - a3), vmulq_n_f32(vcvtq_f32_f16((float16x4_t)vzip2_s32((int32x2_t)*a2, 0)), a3)), a4)).u64[0];
  return result;
}

double CI::bilinear_three_components(float32x4_t *a1, float32x4_t *a2, float a3, float a4)
{
  *(void *)&double result = vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(*a1, 1.0 - a3), vmulq_n_f32((float32x4_t)(unint64_t)(*(long long *)a1 >> 32), a3)), 1.0 - a4), vmulq_n_f32(vaddq_f32(vmulq_n_f32(*a2, 1.0 - a3), vmulq_n_f32((float32x4_t)(unint64_t)(*(long long *)a2 >> 32), a3)), a4)).u64[0];
  return result;
}

CI *cikernel::_distanceMaskPost(CI *result, double a2)
{
  if (*(float *)&a2 != INFINITY && *((float *)&a2 + 1) != INFINITY) {
    return (CI *)CI::getDC(result);
  }
  return result;
}

void CI::f4_s_s_f4_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  float32x4_t v10 = (double (*)(void *, __n128, __n128, __n128, float))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  uint64_t v17 = *(void *)(v9 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
  }
  float32x4_t v18 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x4_t v18 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float32x4_t v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float32x4_t v19 = (__n128 *)((char *)a2 + 64 * v14);
  }
  float32x2_t v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float32x2_t v20 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v21 = v10(a1, *v20, *v19, *v18, *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

void cikernel::_holeFillRefine(cikernel *this, SamplerObj *a2, float a3)
{
  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v6.i8 = *DC;
  LODWORD(v7) = *((_DWORD *)this + 7);
  *(float *)&double v8 = *((float *)this + 6)
                + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v9) = *((_DWORD *)this + 9);
  float32x2_t v37 = *DC;
  *(float *)v10.f64 = *(float *)&v9
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v7, COERCE_FLOAT(*DC));
  HIDWORD(v8) = LODWORD(v10.f64[0]);
  double v13 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v8, v10, v7, v9, v6, v11, v12);
  if (*(float *)&v13 > 0.001 && *(float *)&v13 <= 0.95)
  {
    float v36 = *(float *)&v13 * a3;
    float v14 = 1.0 / ((float)(*(float *)&v13 * a3) + 0.22);
    float v15 = 0.75;
    if (v14 <= 0.75) {
      float v15 = v14;
    }
    if (v14 >= 0.1) {
      float v16 = v15;
    }
    else {
      float v16 = 0.1;
    }
    float v17 = 0.0;
    do
    {
      __float2 v19 = __sincosf_stret(v17);
      *(void *)&v18.f64[0] = __PAIR64__(LODWORD(v19.__sinval), LODWORD(v19.__cosval));
      float32x2_t v20 = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v19.__sinval), LODWORD(v19.__cosval)), v36);
      float32x2_t v21 = vadd_f32(v37, v20);
      *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v21, 1), *((float *)this + 4), v21.f32[0]);
      LODWORD(v23) = *((_DWORD *)this + 7);
      v24.i32[0] = *((_DWORD *)this + 9);
      *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v21, 1), *(float *)&v23, v21.f32[0]);
      v21.f32[0] = *((float *)this + 6) + *(float *)&v22;
      *(float *)v18.f64 = *(float *)v24.i32 + *(float *)v25.i32;
      v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
      double v27 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v21, v18, v22, v23, v25, v24, v26);
      if (*((float *)&v27 + 1) > 0.5) {
        break;
      }
      float32x2_t v34 = vsub_f32(v37, v20);
      *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v34, 1), *((float *)this + 4), v34.f32[0]);
      LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = *((_DWORD *)this + 7);
      v32.i32[0] = *((_DWORD *)this + 9);
      *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v34, 1), *(float *)&v30, v34.f32[0]);
      v34.f32[0] = *((float *)this + 6) + *(float *)&v29;
      *(float *)v28.f64 = *(float *)v32.i32 + *(float *)v31.i32;
      v34.f32[1] = *(float *)v32.i32 + *(float *)v31.i32;
      double v35 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v34, v28, v29, v30, v31, v32, v33);
      if (*((float *)&v35 + 1) > 0.5) {
        break;
      }
      float v17 = v16 + v17;
    }
    while (v17 < 3.1415926);
  }
}

void CI::f4_sr_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int8x16_t v11 = *(void **)(a1 + 48);
  int8x16_t v12 = *(double (**)(uint64_t, float))(a1 + 24);
  uint64_t v13 = v11[1];
  uint64_t v14 = v11[4];
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * v11[7]), a2);
  }
  *(double *)&long long v15 = v12(a4 + 80 * v13, *((float *)a2 + 16 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

__n64 cikernel::_holeFillPost(__n64 result)
{
  result.n64_u32[0] = 0;
  if (result.n64_f32[1] <= 0.5) {
    result.n64_f32[0] = 1.0;
  }
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_s(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int8x16_t v11 = (double (*)(void *, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 32)), a2);
  }
  uint64_t v14 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v14 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v15 = v11(a1, *v14);
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

void OUTLINED_FUNCTION_0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t CI::SoftwareDAGDescriptor::print(CI::SoftwareDAGDescriptor *this, __sFILE *__stream)
{
  void (**v35)(void **__return_ptr);
  const char *v36;
  CI::SoftwareDAGDescriptor *v38;
  unsigned int v39;
  unsigned int v40;
  void *__p[2];
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  long long v46;
  char *v47;
  void (***v48)(void **__return_ptr);
  unint64_t v49;
  char v50;

  fwrite("// Software DAG Functions\n", 0x1AuLL, 1uLL, __stream);
  uint64_t v4 = *((void *)this + 2);
  uint32x4_t v44 = 0;
  uint32x4_t v45 = 0;
  unsigned int v43 = 0;
  std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)&v43, *(void *)v4, *(void *)(v4 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v4 + 8) - *(void *)v4) >> 3));
  int8x16_t v5 = *(char **)(v4 + 40);
  float32x4_t v46 = *(_OWORD *)(v4 + 24);
  float32x4_t v47 = v5;
  float32x4_t v48 = (void (***)(void **__return_ptr))v43;
  float32x4_t v49 = *(void *)(v4 + 56);
  float32x4_t v50 = *(unsigned char *)(v4 + 64);
  fprintf(__stream, "#%zu = ", 0);
  fprintf(__stream, "%s(", v47);
  (**v48)(__p);
  if (v42 >= 0) {
    int8x16_t v6 = __p;
  }
  else {
    int8x16_t v6 = (void **)__p[0];
  }
  fputs((const char *)v6, __stream);
  if (v42 < 0) {
    operator delete(__p[0]);
  }
  fwrite(")\n", 2uLL, 1uLL, __stream);
  __p[0] = &v43;
  std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
  unsigned int v38 = this;
  if (*((void *)this + 6) == *((void *)this + 5))
  {
    unint64_t v18 = 0;
  }
  else
  {
    unint64_t v7 = 0;
    do
    {
      unint64_t v8 = v7 + 1;
      fprintf(__stream, "#%zu = ", v7 + 1);
      uint64_t v9 = *((void *)this + 5) + 72 * v7;
      uint32x4_t v44 = 0;
      uint32x4_t v45 = 0;
      unsigned int v43 = 0;
      std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)&v43, *(void *)v9, *(void *)(v9 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v9 + 8) - *(void *)v9) >> 3));
      long long v10 = *(_OWORD *)(v9 + 24);
      float32x4_t v47 = *(char **)(v9 + 40);
      float32x4_t v46 = v10;
      float32x4_t v48 = (void (***)(void **__return_ptr))v43;
      float32x4_t v49 = *(void *)(v9 + 56);
      float32x4_t v50 = *(unsigned char *)(v9 + 64);
      fputs(v47, __stream);
      if (v49)
      {
        uint64_t v11 = 0;
        for (unint64_t i = 0; i < v49; ++i)
        {
          if (i) {
            uint64_t v13 = 44;
          }
          else {
            uint64_t v13 = 40;
          }
          fprintf(__stream, "%c ", v13);
          int v14 = (int)v48[v11 + 2];
          if ((v14 - 3) < 2 || v14 == 0)
          {
            (*v48[v11])(__p);
            if (v42 >= 0) {
              float v16 = __p;
            }
            else {
              float v16 = (void **)__p[0];
            }
            fputs((const char *)v16, __stream);
            if (v42 < 0) {
              operator delete(__p[0]);
            }
          }
          else if (v14 == 5)
          {
            fprintf(__stream, "#%zu", (size_t)v48[v11 + 1]);
          }
          else
          {
            uint32x4_t v40 = v48[v11 + 2];
            float v17 = "<Unknown>";
            if (v40 <= 5) {
              float v17 = off_1E5770CF0[v40];
            }
            fputs(v17, __stream);
          }
          v11 += 3;
        }
      }
      fwrite(")\n", 2uLL, 1uLL, __stream);
      __p[0] = &v43;
      std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
      this = v38;
      unint64_t v18 = 0x8E38E38E38E38E39 * ((uint64_t)(*((void *)v38 + 6) - *((void *)v38 + 5)) >> 3);
      unint64_t v7 = v8;
    }
    while (v8 < v18);
  }
  if (0x8E38E38E38E38E39 * ((uint64_t)(*((void *)this + 3) - *((void *)this + 2)) >> 3) >= 2)
  {
    uint64_t v19 = 1;
    while (1)
    {
      fprintf(__stream, "#%zu = ", v19 + v18);
      uint64_t v20 = *((void *)this + 2) + 72 * v19;
      uint32x4_t v44 = 0;
      uint32x4_t v45 = 0;
      unsigned int v43 = 0;
      std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)&v43, *(void *)v20, *(void *)(v20 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v20 + 8) - *(void *)v20) >> 3));
      long long v21 = *(_OWORD *)(v20 + 24);
      float32x4_t v47 = *(char **)(v20 + 40);
      float32x4_t v46 = v21;
      float32x4_t v48 = (void (***)(void **__return_ptr))v43;
      unint64_t v22 = *(void *)(v20 + 56);
      float32x4_t v49 = v22;
      float32x4_t v50 = *(unsigned char *)(v20 + 64);
      if (v22)
      {
        double v23 = (int *)(v43 + 16);
        char v24 = 1;
        do
        {
          int v25 = *v23;
          v23 += 6;
          v24 &= v25 == 5;
          --v22;
        }
        while (v22);
      }
      else
      {
        char v24 = 1;
      }
      fputs(v47, __stream);
      if (v49) {
        break;
      }
      fwrite("()\n", 3uLL, 1uLL, __stream);
LABEL_71:
      __p[0] = &v43;
      std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
      if (++v19 >= 0x8E38E38E38E38E39 * ((uint64_t)(*((void *)this + 3) - *((void *)this + 2)) >> 3)) {
        return fputc(10, __stream);
      }
    }
    if (v24)
    {
      unint64_t v26 = 0;
      uint64_t v27 = 1;
      do
      {
        if (v26) {
          uint64_t v28 = 44;
        }
        else {
          uint64_t v28 = 40;
        }
        fprintf(__stream, "%c #%zu", v28, (size_t)v48[v27] + v18);
        ++v26;
        v27 += 3;
      }
      while (v26 < v49);
LABEL_70:
      fwrite(")\n", 2uLL, 1uLL, __stream);
      this = v38;
      goto LABEL_71;
    }
    uint64_t v29 = 0;
    unint64_t v30 = 0;
    while (1)
    {
      uint64_t v31 = v30 ? 44 : 40;
      fprintf(__stream, "%c ", v31);
      unsigned int v32 = v48[v29 + 2];
      if (v32 > 7) {
        break;
      }
      if (((1 << v32) & 0x99) != 0)
      {
        (*v48[v29])(__p);
        if (v42 >= 0) {
          int8x16_t v33 = __p;
        }
        else {
          int8x16_t v33 = (void **)__p[0];
        }
        fputs((const char *)v33, __stream);
        if (v42 < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        if (v32 == 5)
        {
          double v35 = v48[v29 + 1];
          if (v35) {
            uint64_t v34 = (uint64_t)v35 + v18;
          }
          else {
            uint64_t v34 = 0;
          }
        }
        else
        {
          if (v32 != 6) {
            break;
          }
          uint64_t v34 = (uint64_t)v48[v29 + 1] + 1;
        }
        fprintf(__stream, "#%zu", v34);
      }
LABEL_69:
      ++v30;
      v29 += 3;
      if (v30 >= v49) {
        goto LABEL_70;
      }
    }
    int8x8_t v39 = v48[v29 + 2];
    float v36 = "<Unknown>";
    if (v39 <= 5) {
      float v36 = off_1E5770CF0[v39];
    }
    fputs(v36, __stream);
    goto LABEL_69;
  }
  return fputc(10, __stream);
}

void sub_1936D1804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  _Unwind_Resume(a1);
}

void CI::SoftwareDAG::~SoftwareDAG(CI::SoftwareDAG *this)
{
  *(void *)this = &unk_1EE456CA0;
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
  }

  CI::MainProgram::~MainProgram(this);
}

{
  uint64_t vars8;

  CI::SoftwareDAG::~SoftwareDAG(this);

  JUMPOUT(0x1997023B0);
}

uint64_t CI::SoftwareDAG::print_program(CI::SoftwareDAGDescriptor **this, __sFILE *a2)
{
  return CI::SoftwareDAGDescriptor::print(this[12], a2);
}

const char *CI::SoftwareDAG::get_type_name(CI::SoftwareDAG *this)
{
  return "SWDAG";
}

void CI::SoftwareDAG::execute(CI::SoftwareDAG *this, const CI::SerialObjectPtrArray *a2, dispatch_queue_t *a3, CGRect a4, const CI::BitmapSampler *a5, int a6)
{
  CGFloat height = a4.size.height;
  CGFloat width = a4.size.width;
  CGFloat y = a4.origin.y;
  CGFloat x = a4.origin.x;
  if (a5) {
    CI::Object::ref((uint64_t)a5);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZNK2CI11SoftwareDAG7executeERKNS_20SerialObjectPtrArrayEP5Queue6CGRectPKNS_13BitmapSamplerEb_block_invoke;
  block[3] = &__block_descriptor_88_e5_v8__0l;
  void block[4] = this;
  void block[5] = a2;
  *(CGFloat *)&void block[6] = x;
  *(CGFloat *)&void block[7] = y;
  *(CGFloat *)&block[8] = width;
  *(CGFloat *)&void block[9] = height;
  block[10] = a5;
  if (a6) {
    dispatch_sync(*a3, block);
  }
  else {
    Queue::execute_async(a3, block);
  }
}

void ___ZNK2CI11SoftwareDAG7executeERKNS_20SerialObjectPtrArrayEP5Queue6CGRectPKNS_13BitmapSamplerEb_block_invoke(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(CI::MainProgram **)(a1 + 32);
  uint64_t v3 = CI::MainProgram::num_arguments(v2);
  uint64_t v4 = v3;
  if (MEMORY[0x1F4188790](v3, v5, v6, v7, v8, v9))
  {
    uint64_t v13 = &v27[-64 * v4];
    do
    {
      *(_OWORD *)uint64_t v13 = 0uLL;
      *((_OWORD *)v13 + 1) = 0uLL;
      *((void *)v13 + 4) = 0x100000000;
      *((void *)v13 + 6) = 0;
      *((void *)v13 + 7) = 0;
      v13 += 64;
    }
    while (v13 != v27);
    if ((int)v4 >= 1)
    {
      unint64_t v14 = 0;
      uint64_t v15 = 24;
      float v16 = &v27[-64 * v4];
      do
      {
        int v17 = (*(uint64_t (**)(CI::MainProgram *, unint64_t))(*(void *)v2 + 40))(v2, v14);
        uint64_t v18 = *(void *)(a1 + 40);
        if (v14 > 9) {
          uint64_t v19 = (uint64_t *)(*(void *)(v18 + 16) + 8 * (v14 - 10));
        }
        else {
          uint64_t v19 = (uint64_t *)(v18 + v15);
        }
        uint64_t v20 = *v19;
        switch(v17)
        {
          case 1:
          case 2:
          case 3:
          case 4:
            *(void *)float v16 = v20;
            break;
          case 5:
          case 12:
          case 19:
          case 23:
            if ((*(unsigned int (**)(uint64_t))(*(void *)v20 + 16))(v20) != 58) {
              return;
            }
            *(_DWORD *)float v16 = *(_DWORD *)(v20 + 28);
            break;
          case 6:
          case 13:
          case 20:
          case 24:
            if ((*(unsigned int (**)(uint64_t))(*(void *)v20 + 16))(v20) != 58) {
              return;
            }
            *(void *)float v16 = *(void *)(v20 + 96);
            break;
          case 7:
          case 14:
          case 21:
          case 25:
            if ((*(unsigned int (**)(uint64_t))(*(void *)v20 + 16))(v20) != 58) {
              return;
            }
            long long v22 = *(_OWORD *)(v20 + 96);
            *((_DWORD *)v16 + 2) = DWORD2(v22);
            *(void *)float v16 = v22;
            break;
          case 8:
          case 15:
          case 22:
          case 26:
          case 27:
            if ((*(unsigned int (**)(uint64_t))(*(void *)v20 + 16))(v20) != 58) {
              return;
            }
            long long v21 = *(_OWORD *)(v20 + 96);
LABEL_20:
            *(_OWORD *)float v16 = v21;
            break;
          case 40:
          case 44:
          case 45:
            long long v21 = *(_OWORD *)(v20 + 96);
            long long v23 = *(_OWORD *)(v20 + 112);
            *((void *)v16 + 4) = *(void *)(v20 + 128);
            *((_OWORD *)v16 + 1) = v23;
            goto LABEL_20;
          case 41:
            long long v24 = *(_OWORD *)(v20 + 64);
            *(void *)&long long v28 = *(void *)(v20 + 128);
            long long v25 = *(_OWORD *)(v20 + 112);
            *(_OWORD *)float v16 = *(_OWORD *)(v20 + 96);
            *((_OWORD *)v16 + 1) = v25;
            *((_OWORD *)v16 + 2) = v28;
            *((_OWORD *)v16 + 3) = v24;
            break;
          default:
            break;
        }
        ++v14;
        v16 += 64;
        v15 += 8;
      }
      while (v4 != v14);
    }
  }
  CI::SoftwareDAGDescriptor::execute(*((void **)v2 + 12), (uint64_t)&v27[-64 * v4], *(void *)(a1 + 80), v10, v11, v12, *(CGFloat *)(a1 + 48), *(CGFloat *)(a1 + 56), *(CGFloat *)(a1 + 64), *(CGFloat *)(a1 + 72));
  unint64_t v26 = *(CI::Object **)(a1 + 80);
  if (v26) {
    CI::Object::unref(v26);
  }
}

void CI::SoftwareDAGDescriptor::execute(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, CGFloat a7, CGFloat a8, CGFloat a9, CGFloat a10)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = MEMORY[0x1F4188790](a1, 16 * ((a1[3] - a1[2]) / 72), a3, a4, a5, a6);
  long long v24 = &v43 - 2 * v23;
  if (v25 != v26) {
    bzero(&v43 - 2 * v23, v18);
  }
  uint64_t v27 = a1[6] - a1[5];
  if (v27)
  {
    unint64_t v28 = 0x8E38E38E38E38E39 * (v27 >> 3);
    MEMORY[0x1F4188790](v17, v18, v19, v20, v21, v22);
    unint64_t v30 = (uint64_t *)((char *)&v43 - v29);
  }
  else
  {
    MEMORY[0x1F4188790](v17, v18, v19, v20, v21, v22);
    unint64_t v30 = &v43 - 10;
    unint64_t v28 = 1;
  }
  uint64_t v31 = 0;
  do
  {
    unsigned int v32 = &v30[v31];
    *unsigned int v32 = (uint64_t)&unk_1EE4569B0;
    v32[8] = 0;
    v32[9] = 0;
    *(_OWORD *)(v32 + 1) = 0uLL;
    *(_OWORD *)(v32 + 3) = 0uLL;
    *(_OWORD *)(v32 + 5) = 0uLL;
    v31 += 10;
  }
  while (v32 + 10 != &v30[10 * v28]);
  uint64_t v33 = a1[1];
  unint64_t v44 = v28;
  CI::SWRendererPipeline::initSamplers(v33, a2, (uint64_t)v30);
  v47.origin.unint64_t x = a7;
  v47.origin.unint64_t y = a8;
  v47.size.unint64_t width = a9;
  v47.size.unint64_t height = a10;
  if (CGRectIsNull(v47))
  {
    unint64_t width = 0;
    unint64_t height = 0;
    unint64_t x = 0x7FFFFFFFLL;
    unint64_t y = 0x7FFFFFFFLL;
  }
  else
  {
    v48.origin.unint64_t x = a7;
    v48.origin.unint64_t y = a8;
    v48.size.unint64_t width = a9;
    v48.size.unint64_t height = a10;
    if (CGRectIsInfinite(v48))
    {
      unint64_t x = -2147483647;
      unint64_t width = 0xFFFFFFFFLL;
      unint64_t y = -2147483647;
      unint64_t height = 0xFFFFFFFFLL;
    }
    else
    {
      v49.origin.unint64_t x = a7;
      v49.origin.unint64_t y = a8;
      v49.size.unint64_t width = a9;
      v49.size.unint64_t height = a10;
      CGRect v50 = CGRectInset(v49, 0.000001, 0.000001);
      CGRect v51 = CGRectIntegral(v50);
      unint64_t width = (unint64_t)v51.size.width;
      unint64_t height = (unint64_t)v51.size.height;
      unint64_t y = (int)v51.origin.y;
      unint64_t x = (int)v51.origin.x;
    }
  }
  unint64_t v38 = height + y;
  if (height + y > y)
  {
    unint64_t v39 = width + x;
    do
    {
      if (v39 > x)
      {
        unint64_t v40 = x;
        do
        {
          v45[0] = v40;
          v45[1] = y;
          CI::SWRendererPipeline::execute((void *)a1[1], a2, v24, (uint64_t)v30, a3, v45);
          ++v40;
        }
        while (v39 > v40);
      }
      ++y;
    }
    while (v38 > y);
  }
  uint64_t v41 = 10 * v44;
  do
  {
    v30[v41 - 10] = (uint64_t)&unk_1EE4569B0;
    unsigned int v42 = (CI::Object *)v30[v41 - 9];
    if (v42) {
      CI::Object::unref(v42);
    }
    v41 -= 10;
  }
  while (v41 * 8);
}

void sub_1936D2060(_Unwind_Exception *exception_object)
{
  uint64_t v4 = 80 * *(void *)(v2 - 136);
  while (1)
  {
    *(void *)(v1 + v4 - 8CI::NodeWithChildren::NodeWithChildren(this, 0) = &unk_1EE4569B0;
    uint64_t v5 = *(CI::Object **)(v1 + v4 - 72);
    if (v5) {
      CI::Object::unref(v5);
    }
    v4 -= 80;
    if (!v4) {
      _Unwind_Resume(exception_object);
    }
  }
}

uint64_t CI::DAGHelper::add_function_with_name(uint64_t this, char *a2)
{
  if (*(void *)(this + 40))
  {
    uint64_t v2 = this;
    uint64_t v3 = this + 160;
    std::string::basic_string[abi:nn180100]<0>(__p, a2);
    uint64_t v4 = std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::find<std::string>(v3, __p);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v5 = *(uint64_t (****)(void, long long *))(v2 + 8);
    long long v6 = *(_OWORD *)(v4 + 7);
    uint64_t v7 = v4[9];
    return (**v5)(v5, &v6);
  }
  return this;
}

void sub_1936D2154(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CI::DAGHelper::add_arguments_for_image_node(uint64_t a1)
{
}

void sub_1936D2428(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x1081C40C4ADF1D2);
  _Unwind_Resume(a1);
}

uint64_t *CI::DAGHelper::add_init_destcoord_function_info(uint64_t *this)
{
  if (this[5])
  {
    uint64_t v1 = (uint64_t)this;
    uint64_t argument_info = CI::SoftwareDAGDescriptor::create_argument_info((CI::SoftwareDAGDescriptor *)this[1], 1);
    unsigned int v3 = argument_info;
    uint64_t v4 = *(void *)(*(void *)(v1 + 8) + 64);
    uint64_t v6 = 0;
    int v5 = 4;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v4 + 32 * argument_info + 8), &v5, &v6);
    return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(v1 + 8), v3);
  }
  return this;
}

uint64_t CI::SoftwareDAGDescriptor::create_argument_info(CI::SoftwareDAGDescriptor *this, uint64_t a2)
{
  unint64_t v6 = *((void *)this + 10);
  uint64_t v4 = (char *)this + 80;
  unint64_t v5 = v6;
  uint64_t v7 = (void *)*((void *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    char v9 = (uint64_t *)(v4 - 16);
    uint64_t v10 = *((void *)v4 - 2);
    uint64_t v11 = ((uint64_t)v7 - v10) >> 5;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 59) {
      abort();
    }
    uint64_t v13 = v5 - v10;
    if (v13 >> 4 > v12) {
      unint64_t v12 = v13 >> 4;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v14 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    v18[4] = v4;
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>((uint64_t)v4, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    float v16 = &v15[32 * v11];
    v18[0] = v15;
    v18[1] = v16;
    v18[3] = &v15[32 * v14];
    *(void *)float v16 = a2;
    *((void *)v16 + 1) = 0;
    *((void *)v16 + 2) = 0;
    *((void *)v16 + 3) = 0;
    v18[2] = v16 + 32;
    std::vector<CI::SoftwareDAGDescriptor::ArgumentInfo>::__swap_out_circular_buffer(v9, v18);
    uint64_t v8 = (void *)*((void *)this + 9);
    std::__split_buffer<CI::SoftwareDAGDescriptor::ArgumentInfo>::~__split_buffer(v18);
  }
  else
  {
    *uint64_t v7 = a2;
    v7[1] = 0;
    void v7[2] = 0;
    v7[3] = 0;
    uint64_t v8 = v7 + 4;
    *((void *)this + 9) = v7 + 4;
  }
  *((void *)this + 9) = v8;
  return (((uint64_t)v8 - *((void *)this + 8)) >> 5) - 1;
}

void sub_1936D25D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CI::SoftwareDAGDescriptor::ArgumentInfo>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t *CI::SoftwareDAGDescriptor::create_function_info(uint64_t *this, unsigned int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v2 = this;
    unsigned int v3 = (uint64_t *)(this[8] + 32 * a2 + 8);
    unint64_t v6 = v3;
    uint64_t v4 = (long long *)(this + 11);
    unint64_t v5 = (uint64_t *)this[3];
    if ((unint64_t)v5 >= this[4])
    {
      this = (uint64_t *)std::vector<CI::SWRendererFunctionNode>::__emplace_back_slow_path<CI::SWFunction &,std::vector<CI::SWRendererFunctionInputNode> *&>(this + 2, v4, &v6);
    }
    else
    {
      long long v7 = *v4;
      uint64_t v8 = this[13];
      CI::SWRendererFunctionNode::SWRendererFunctionNode(v5, (uint64_t)&v7, v3);
      this = v5 + 9;
      v2[3] = (uint64_t)(v5 + 9);
    }
    v2[3] = (uint64_t)this;
  }
  return this;
}

void sub_1936D2670(_Unwind_Exception *a1)
{
  *(void *)(v1 + 24) = v2;
  _Unwind_Resume(a1);
}

uint64_t *CI::DAGHelper::add_read_pixel_function_info(uint64_t *this, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  if (this[5])
  {
    uint64_t v8 = (uint64_t)this;
    uint64_t argument_info = CI::SoftwareDAGDescriptor::create_argument_info((CI::SoftwareDAGDescriptor *)this[1], 3);
    uint64_t v10 = *(void *)(*(void *)(v8 + 8) + 64);
    uint64_t v14 = a2;
    int v13 = 0;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v10 + 32 * argument_info + 8), &v13, &v14);
    uint64_t v11 = *(void *)(*(void *)(v8 + 8) + 64);
    uint64_t v14 = a5;
    int v13 = 4;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v11 + 32 * argument_info + 8), &v13, &v14);
    uint64_t v12 = *(void *)(*(void *)(v8 + 8) + 64);
    uint64_t v14 = a4;
    int v13 = 5;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v12 + 32 * argument_info + 8), &v13, &v14);
    return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(v8 + 8), argument_info);
  }
  return this;
}

uint64_t *CI::DAGHelper::add_read_pixel_420_function_info(uint64_t *this, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8)
{
  if (this[5])
  {
    uint64_t v13 = (uint64_t)this;
    uint64_t argument_info = CI::SoftwareDAGDescriptor::create_argument_info((CI::SoftwareDAGDescriptor *)this[1], 5);
    uint64_t v15 = *(void *)(*(void *)(v13 + 8) + 64);
    uint64_t v21 = a2;
    int v20 = 0;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v15 + 32 * argument_info + 8), &v20, &v21);
    uint64_t v16 = *(void *)(*(void *)(v13 + 8) + 64);
    uint64_t v21 = a5;
    int v20 = 4;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v16 + 32 * argument_info + 8), &v20, &v21);
    uint64_t v17 = *(void *)(*(void *)(v13 + 8) + 64);
    uint64_t v21 = a6;
    int v20 = 0;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v17 + 32 * argument_info + 8), &v20, &v21);
    uint64_t v18 = *(void *)(*(void *)(v13 + 8) + 64);
    uint64_t v21 = a8;
    int v20 = 4;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v18 + 32 * argument_info + 8), &v20, &v21);
    uint64_t v19 = *(void *)(*(void *)(v13 + 8) + 64);
    uint64_t v21 = a4;
    int v20 = 5;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v19 + 32 * argument_info + 8), &v20, &v21);
    return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(v13 + 8), argument_info);
  }
  return this;
}

uint64_t *CI::DAGHelper::add_colour_inout_function_info(uint64_t *this, uint64_t a2)
{
  if (this[5])
  {
    uint64_t v3 = (uint64_t)this;
    uint64_t argument_info = CI::SoftwareDAGDescriptor::create_argument_info((CI::SoftwareDAGDescriptor *)this[1], 1);
    unsigned int v5 = argument_info;
    uint64_t v6 = *(void *)(*(void *)(v3 + 8) + 64);
    uint64_t v8 = a2;
    int v7 = 5;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v6 + 32 * argument_info + 8), &v7, &v8);
    return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(v3 + 8), v5);
  }
  return this;
}

uint64_t *CI::DAGHelper::add_write_pixel_function_info(uint64_t *this, uint64_t a2)
{
  if (this[5])
  {
    uint64_t v3 = (uint64_t)this;
    uint64_t argument_info = CI::SoftwareDAGDescriptor::create_argument_info((CI::SoftwareDAGDescriptor *)this[1], 3);
    uint64_t v5 = *(void *)(*(void *)(v3 + 8) + 64);
    uint64_t v9 = 0;
    int v8 = 0;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v5 + 32 * argument_info + 8), &v8, &v9);
    uint64_t v6 = *(void *)(*(void *)(v3 + 8) + 64);
    uint64_t v9 = a2;
    int v8 = 5;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v6 + 32 * argument_info + 8), &v8, &v9);
    int v7 = (char **)(*(void *)(*(void *)(v3 + 8) + 64) + 32 * argument_info + 8);
    LODWORD(v9) = 7;
    std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType>(v7, (int *)&v9);
    return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(v3 + 8), argument_info);
  }
  return this;
}

uint64_t *CI::DAGHelper::add_function_info(uint64_t a1, uint64_t a2, CI::ColorKernelNode *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *((void *)a3 + 6);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 16))(v8) != 62) {
    (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  }
  if (*(unsigned char *)(v8 + 12)) {
    int v9 = CI::KernelArguments::count((CI::KernelArguments *)(v8 + 144));
  }
  else {
    int v9 = *(_DWORD *)(v8 + 20);
  }
  if (*(void *)(a1 + 40)) {
    int argument_info = CI::SoftwareDAGDescriptor::create_argument_info(*(CI::SoftwareDAGDescriptor **)(a1 + 8), v9);
  }
  else {
    int argument_info = -1;
  }
  signed int v11 = 0;
  uint64_t v12 = argument_info;
  while (1)
  {
    signed int v13 = *(unsigned char *)(v8 + 12) ? CI::KernelArguments::count((CI::KernelArguments *)(v8 + 144)) : *(_DWORD *)(v8 + 20);
    if (v11 >= v13) {
      return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(a1 + 8), v12);
    }
    int v14 = CI::ColorKernelNode::kernel_argument_type(a3, v11);
    int v15 = v14;
    switch(v14)
    {
      case 30:
        if (*(void *)(a1 + 40))
        {
          uint64_t v16 = *(void *)(*(void *)(a1 + 8) + 64);
          uint64_t v32 = a5;
          uint64_t v17 = (char **)(v16 + 32 * v12 + 8);
          int v31 = 5;
          goto LABEL_37;
        }
        goto LABEL_38;
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
        goto LABEL_19;
      case 36:
        if (!*(void *)(a1 + 40)) {
          goto LABEL_38;
        }
        uint64_t v21 = *(void *)(*(void *)(a1 + 8) + 64);
        uint64_t v32 = 0;
        goto LABEL_24;
      case 37:
        uint64_t v22 = *(void ***)(a1 + 40);
        if (v22)
        {
          uint64_t v23 = *(int *)v22;
          CI::SerialValArray<int>::append(v22, 37);
          if (*(void *)(a1 + 40))
          {
            uint64_t v24 = *(void *)(*(void *)(a1 + 8) + 64);
            uint64_t v32 = v23;
            int v31 = 4;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v24 + 32 * v12 + 8), &v31, &v32);
          }
        }
        if (a4) {
          CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
        }
        goto LABEL_38;
      case 38:
        uint64_t v25 = *(void *)(*(void *)(a1 + 8) + 64);
        uint64_t v32 = 0;
        uint64_t v26 = v25 + 32 * v12;
        goto LABEL_36;
      case 39:
        if (*(unsigned char *)(v8 + 166))
        {
          uint64_t v27 = *(void *)(a1 + 48);
          *(void *)(a1 + 48) = v27 + 1;
        }
        else
        {
          uint64_t v27 = 0;
        }
        if (!*(void *)(a1 + 40)) {
          goto LABEL_38;
        }
        uint64_t v28 = *(void *)(*(void *)(a1 + 8) + 64);
        uint64_t v32 = v27;
        uint64_t v26 = v28 + 32 * v12;
LABEL_36:
        uint64_t v17 = (char **)(v26 + 8);
        int v31 = 0;
        goto LABEL_37;
      default:
        if ((v14 - 1) < 2 || v14 == 4) {
          goto LABEL_38;
        }
LABEL_19:
        CI::KernelArguments::is_uniform(v14);
        argument = (CI::Object *)CI::ColorKernelNode::get_argument(a3, v11);
        CI::SerialObjectPtrArray::append(a4, argument);
        uint64_t v19 = *(void ***)(a1 + 40);
        if (!v19) {
          goto LABEL_38;
        }
        uint64_t v20 = *(int *)v19;
        CI::SerialValArray<int>::append(v19, v15);
        if (!*(void *)(a1 + 40)) {
          goto LABEL_38;
        }
        uint64_t v21 = *(void *)(*(void *)(a1 + 8) + 64);
        uint64_t v32 = v20;
LABEL_24:
        uint64_t v17 = (char **)(v21 + 32 * v12 + 8);
        int v31 = 4;
LABEL_37:
        std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>(v17, &v31, &v32);
LABEL_38:
        ++v11;
        break;
    }
  }
}

uint64_t *CI::DAGHelper::add_function_info(uint64_t a1, CI::SerialStringArray **a2, CI::ColorKernelNode *a3, uint64_t a4, std::string::size_type a5, uint64_t a6, uint64_t a7, char *a8, unsigned __int8 a9, void *a10)
{
  signed int v13 = a3;
  uint64_t v16 = *((void *)a3 + 6);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v16 + 16))(v16) != 62) {
    (*(void (**)(uint64_t))(*(void *)v16 + 16))(v16);
  }
  if (*(unsigned char *)(v16 + 12)) {
    int v17 = CI::KernelArguments::count((CI::KernelArguments *)(v16 + 144));
  }
  else {
    int v17 = *(_DWORD *)(v16 + 20);
  }
  if (*(void *)(a1 + 40)) {
    int argument_info = CI::SoftwareDAGDescriptor::create_argument_info(*(CI::SoftwareDAGDescriptor **)(a1 + 8), v17);
  }
  else {
    int argument_info = -1;
  }
  signed int v19 = 0;
  char v78 = 0;
  float32x4_t v79 = (CI::KernelArguments *)(v16 + 144);
  uint64_t v73 = a6 + 1;
  float32x4_t v74 = (void *)(a1 + 96);
  uint64_t v72 = a1 + 112;
  uint64_t v68 = v16;
  float32x4_t v76 = (uint64_t **)(a1 + 88);
  *(void *)float32x4_t v77 = argument_info;
  uint64_t v69 = a6 + 2;
  uint64_t v66 = (uint64_t)&a8[a6 + 3];
  uint64_t v70 = a4;
  float32x4_t v75 = v13;
  while (1)
  {
    signed int v20 = *(unsigned char *)(v16 + 12) ? CI::KernelArguments::count(v79) : *(_DWORD *)(v16 + 20);
    if (v19 >= v20) {
      break;
    }
    int v21 = CI::ColorKernelNode::kernel_argument_type(v13, v19);
    int v22 = v21;
    if (v21 > 29)
    {
      switch(v21)
      {
        case 30:
          if (!*(void *)(a1 + 40)) {
            goto LABEL_80;
          }
          uint64_t v23 = *(void *)(*(void *)(a1 + 8) + 64);
          v81.__r_.__value_.__r.__words[0] = a5;
          uint64_t v24 = (char **)(v23 + 32 * *(void *)v77 + 8);
          int v25 = 5;
          goto LABEL_54;
        case 36:
          if (!*(void *)(a1 + 40)) {
            goto LABEL_80;
          }
          uint64_t v31 = *(void *)(*(void *)(a1 + 8) + 64);
          v81.__r_.__value_.__r.__words[0] = 0;
          goto LABEL_53;
        case 37:
          uint64_t v32 = *(void ***)(a1 + 40);
          if (v32)
          {
            std::string::size_type v33 = *(int *)v32;
            CI::SerialValArray<int>::append(v32, 37);
            if (*(void *)(a1 + 40))
            {
              uint64_t v34 = *(void *)(*(void *)(a1 + 8) + 64);
              v81.__r_.__value_.__r.__words[0] = v33;
              LODWORD(v84[0]) = 4;
              std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v34 + 32 * *(void *)v77 + 8), (int *)v84, (uint64_t *)&v81);
            }
          }
          if (a4) {
            CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
          }
          goto LABEL_80;
        case 38:
          if (!*(void *)(a1 + 40)) {
            goto LABEL_80;
          }
          uint64_t v35 = *(void *)(*(void *)(a1 + 8) + 64);
          v81.__r_.__value_.__r.__words[0] = 0;
          uint64_t v24 = (char **)(v35 + 32 * *(void *)v77 + 8);
          LODWORD(v84[0]) = 0;
          goto LABEL_55;
        case 39:
          goto LABEL_80;
        default:
          goto LABEL_50;
      }
    }
    switch(v21)
    {
      case 1:
        goto LABEL_21;
      case 2:
        break;
      case 4:
LABEL_21:
        argument = (const char *)CI::ColorKernelNode::get_argument(v13, v19);
        uint64_t v28 = (CI::Node *)argument;
        if (v22 == 4)
        {
          (*(void (**)(const char *))(*(void *)argument + 232))(argument);
          CI::Node::rois_count(v28);
          v84[0] = 0;
          v84[0] = (uint64_t *)CI::hash_image_node_id((uint64_t)v28, 0);
          v81.__r_.__value_.__r.__words[0] = (std::string::size_type)v84;
          uint64_t v29 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)(a1 + 136), (unint64_t *)v84, (uint64_t)&std::piecewise_construct, &v81);
          if (*(void *)(a1 + 40))
          {
            uint64_t v30 = *(void *)(*(void *)(a1 + 8) + 64);
            v81.__r_.__value_.__r.__words[0] = (std::string::size_type)v29[5];
            LODWORD(v8CI::NodeWithChildren::NodeWithChildren(this, 0) = 0;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v30 + 32 * *(void *)v77 + 8), (int *)&v80, (uint64_t *)&v81);
          }
          signed int v13 = v75;
        }
        else
        {
          a8[v73] = v78 + 48;
          a8[v69] = 0;
          float v36 = CI::replaceWithLeaf(a2, (const CI::ProgramNode *)(a8 + 1), argument, v27);
          float32x2_t v37 = (uint64_t *)CI::hash_dag_node_id((unint64_t)v36, a7, a8);
          if ((*(unsigned int (**)(const char *))(*(void *)v36 + 232))(v36))
          {
            uint64_t v38 = v66;
            do
            {
              unint64_t v39 = (const char *)(*(uint64_t (**)(const char *, void))(*(void *)v36 + 48))(v36, 0);
              *(_WORD *)(v38 - 1) = 48;
              float v36 = CI::replaceWithLeaf(a2, (const CI::ProgramNode *)(a8 + 1), v39, v40);
              float32x2_t v37 = (uint64_t *)CI::hash_dag_node_id((unint64_t)v36, (uint64_t)v37, a8);
              ++v38;
            }
            while (((*(uint64_t (**)(const char *))(*(void *)v36 + 232))(v36) & 1) != 0);
          }
          signed int v13 = v75;
          uint64_t v41 = (void *)*v74;
          a4 = v70;
          uint64_t v16 = v68;
          if (!*v74) {
            goto LABEL_48;
          }
          unsigned int v42 = (void *)(a1 + 96);
          do
          {
            unint64_t v43 = v41[4];
            BOOL v44 = v43 >= (unint64_t)v37;
            if (v43 >= (unint64_t)v37) {
              uint32x4_t v45 = v41;
            }
            else {
              uint32x4_t v45 = v41 + 1;
            }
            if (v44) {
              unsigned int v42 = v41;
            }
            uint64_t v41 = (void *)*v45;
          }
          while (*v45);
          if (v42 == v74 || (unint64_t)v37 < v42[4])
          {
LABEL_48:
            float32x4_t v80 = v37;
            v84[0] = (uint64_t *)&v80;
            uint64_t v46 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v72, (unint64_t *)&v80, (uint64_t)&std::piecewise_construct, v84);
            CGRect v47 = v46;
            if (*((char *)v46 + 63) < 0) {
              std::string::__init_copy_ctor_external(&v81, (const std::string::value_type *)v46[5], v46[6]);
            }
            else {
              std::string v81 = *(std::string *)(v46 + 5);
            }
            std::vector<unsigned long>::vector(__p, (uint64_t)(v47 + 8));
            char v83 = *((unsigned char *)v47 + 88);
            if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              CGRect v51 = &v81;
            }
            else {
              CGRect v51 = (std::string *)v81.__r_.__value_.__r.__words[0];
            }
            CI::DAGHelper::add_function_with_name(a1, (char *)v51);
            signed int v13 = v75;
            std::string::size_type size = HIBYTE(v81.__r_.__value_.__r.__words[2]);
            if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type size = v81.__r_.__value_.__l.__size_;
            }
            if (size != 14) {
              goto LABEL_69;
            }
            float v55 = &v81;
            if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              float v55 = (std::string *)v81.__r_.__value_.__r.__words[0];
            }
            std::string::size_type v56 = v55->__r_.__value_.__r.__words[0];
            uint64_t v57 = *(std::string::size_type *)((char *)v55->__r_.__value_.__r.__words + 6);
            if (v56 == 0x646165725F69635FLL && v57 == 0x6C657869705F6461) {
              CI::DAGHelper::add_read_pixel_function_info((uint64_t *)a1, *(void *)__p[0], v52, *((void *)__p[0] + 2), *((void *)__p[0] + 3));
            }
            else {
LABEL_69:
            }
              CI::DAGHelper::add_read_pixel_420_function_info((uint64_t *)a1, *(void *)__p[0], v52, *((void *)__p[0] + 2), *((void *)__p[0] + 3), *((void *)__p[0] + 4), v53, *((void *)__p[0] + 6));
            uint64_t v59 = (*a10)++;
            float32x4_t v80 = v37;
            v84[0] = (uint64_t *)&v80;
            *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v76, (unint64_t *)&v80, (uint64_t)&std::piecewise_construct, v84)+ 2CI::NodeWithChildren::NodeWithChildren(this, 0) = v59;
            if (v83)
            {
              CI::DAGHelper::add_function_with_name(a1, "_ci_srgb_to_linear");
              float32x4_t v80 = v37;
              v84[0] = (uint64_t *)&v80;
              int8x16_t v60 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v76, (unint64_t *)&v80, (uint64_t)&std::piecewise_construct, v84);
              CI::DAGHelper::add_colour_inout_function_info((uint64_t *)a1, *((unsigned __int16 *)v60 + 20));
              uint64_t v61 = (*a10)++;
              float32x4_t v80 = v37;
              v84[0] = (uint64_t *)&v80;
              *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v76, (unint64_t *)&v80, (uint64_t)&std::piecewise_construct, v84)+ 2CI::NodeWithChildren::NodeWithChildren(this, 0) = v61;
            }
            v84[0] = v37;
            std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__erase_unique<unsigned long long>(v72, (unint64_t *)v84);
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
            if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v81.__r_.__value_.__l.__data_);
            }
          }
          v84[0] = v37;
          v81.__r_.__value_.__r.__words[0] = (std::string::size_type)v84;
          float32x4_t v62 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v76, (unint64_t *)v84, (uint64_t)&std::piecewise_construct, (uint64_t **)&v81);
          if (*(void *)(a1 + 40))
          {
            uint64_t v63 = *(void *)(*(void *)(a1 + 8) + 64);
            v81.__r_.__value_.__r.__words[0] = *((unsigned __int16 *)v62 + a9 + 20);
            LODWORD(v84[0]) = 5;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v63 + 32 * *(void *)v77 + 8), (int *)v84, (uint64_t *)&v81);
          }
          a8[v73] = 0;
        }
        ++v78;
        break;
      default:
LABEL_50:
        CI::KernelArguments::is_uniform(v21);
        CGRect v48 = (CI::Object *)CI::ColorKernelNode::get_argument(v13, v19);
        CI::SerialObjectPtrArray::append(a4, v48);
        CGRect v49 = *(void ***)(a1 + 40);
        if (v49)
        {
          std::string::size_type v50 = *(int *)v49;
          CI::SerialValArray<int>::append(v49, v22);
          if (*(void *)(a1 + 40))
          {
            uint64_t v31 = *(void *)(*(void *)(a1 + 8) + 64);
            v81.__r_.__value_.__r.__words[0] = v50;
LABEL_53:
            uint64_t v24 = (char **)(v31 + 32 * *(void *)v77 + 8);
            int v25 = 4;
LABEL_54:
            LODWORD(v84[0]) = v25;
LABEL_55:
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>(v24, (int *)v84, (uint64_t *)&v81);
          }
        }
        break;
    }
LABEL_80:
    ++v19;
  }
  if (*(void *)(a1 + 40))
  {
    float32x4_t v64 = *(void (****)(void, std::string *))(a1 + 8);
    std::string v81 = *(std::string *)(v16 + 48);
    (**v64)(v64, &v81);
  }
  return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(a1 + 8), v77[0]);
}

void sub_1936D34B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
}

void CI::DAGHelper::TextureReadFunction::~TextureReadFunction(CI::DAGHelper::TextureReadFunction *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
}

uint64_t *CI::DAGHelper::add_function_info(CI::SoftwareDAGDescriptor **this, const CI::ProgramNode *a2, const CI::GeneralKernelNode *a3, CI::Object **a4, uint64_t a5, unint64_t a6)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *((void *)a3 + 6);
  (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  if (*(unsigned char *)(v8 + 12)) {
    int v9 = CI::KernelArguments::count((CI::KernelArguments *)(v8 + 144));
  }
  else {
    int v9 = *(_DWORD *)(v8 + 20);
  }
  if (this[5]) {
    int argument_info = CI::SoftwareDAGDescriptor::create_argument_info(this[1], v9);
  }
  else {
    int argument_info = -1;
  }
  unint64_t v11 = 0;
  *(void *)unint64_t v53 = argument_info;
  while (1)
  {
    int v12 = *(unsigned char *)(v8 + 12) ? CI::KernelArguments::count((CI::KernelArguments *)(v8 + 144)) : *(_DWORD *)(v8 + 20);
    if ((uint64_t)v11 >= v12) {
      return CI::SoftwareDAGDescriptor::create_function_info((uint64_t *)this[1], v53[0]);
    }
    uint64_t v13 = *((void *)a3 + 6);
    if (*(unsigned char *)(v13 + 12))
    {
      int type = CI::KernelArguments::get_type((CI::KernelArguments *)(v13 + 144), v11);
    }
    else
    {
      if ((uint64_t)v11 >= *(int *)(v13 + 20))
      {
        int type = 0;
LABEL_25:
        CI::KernelArguments::is_uniform(type);
        uint64_t v16 = *((void *)a3 + 7);
        if (v11 > 9) {
          int v17 = (CI::Object **)(*(void *)(v16 + 16) + 8 * (v11 - 10));
        }
        else {
          int v17 = (CI::Object **)(v16 + 8 * v11 + 24);
        }
        CI::SerialObjectPtrArray::append((uint64_t)a4, *v17);
        uint64_t v18 = (void **)this[5];
        if (v18)
        {
          *(void *)&double v19 = *(int *)v18;
          CI::SerialValArray<int>::append(v18, type);
          if (this[5])
          {
            uint64_t v20 = *((void *)this[1] + 8);
            double v55 = v19;
            v61[0] = 4;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v20 + 32 * *(void *)v53 + 8), v61, (uint64_t *)&v55);
          }
        }
        goto LABEL_59;
      }
      int type = *(_DWORD *)(*(void *)(v13 + 72) + 4 * v11);
    }
    if (type <= 29)
    {
      if (type != 1)
      {
        if (type == 2)
        {
          uint64_t v26 = *((void *)a3 + 7);
          if (v11 > 9) {
            uint64_t v27 = (double **)(*(void *)(v26 + 16) + 8 * (v11 - 10));
          }
          else {
            uint64_t v27 = (double **)(v26 + 8 * v11 + 24);
          }
          uint64_t v28 = *v27;
          double v56 = 0.0;
          double v57 = 0.0;
          double v55 = 1.0;
          double v58 = 1.0;
          double v59 = 0.0;
          double v60 = 0.0;
          size_t v29 = CI::ProgramNode::child_depth(a2, 0);
          if (v29 - 1 > a6)
          {
            unint64_t v30 = ~a6 + v29;
            do
            {
              if ((*(unsigned int (**)(double *))(*(void *)v28 + 16))(v28) == 28)
              {
                double v31 = v28[7];
                double v32 = v28[8];
                double v33 = v32 * v57 + v31 * v55;
                double v34 = v32 * v58 + v31 * v56;
                double v35 = v28[9];
                double v36 = v28[10];
                double v37 = v57 * v36 + v35 * v55;
                double v38 = v58 * v36 + v35 * v56;
                double v39 = v28[11];
                double v40 = v28[12];
                double v41 = v59 + v57 * v40 + v39 * v55;
                double v42 = v58 * v40 + v39 * v56 + v60;
                double v55 = v33;
                double v56 = v34;
                double v57 = v37;
                double v58 = v38;
                double v59 = v41;
                double v60 = v42;
              }
              else
              {
                int v43 = (*(uint64_t (**)(double *))(*(void *)v28 + 16))(v28);
                uint64_t v44 = *(void *)v28;
                if (v43 == 45)
                {
                  (*(void (**)(double *))(v44 + 408))(v28);
                }
                else if ((*(unsigned int (**)(double *))(v44 + 16))(v28) != 30)
                {
                  (*(void (**)(double *))(*(void *)v28 + 16))(v28);
                }
              }
              uint64_t v28 = (double *)(*(uint64_t (**)(double *, void))(*(void *)v28 + 48))(v28, 0);
              --v30;
            }
            while (v30);
          }
          uint64_t v45 = (*(uint64_t (**)(const CI::ProgramNode *, void))(*(void *)a2 + 48))(a2, 0);
          if ((*(unsigned int (**)(uint64_t))(*(void *)v45 + 16))(v45) == 52)
          {
            uint64_t v46 = *(unsigned int *)(v45 + 140);
            char v47 = *(unsigned char *)(v45 + 144);
            *(void *)uint64_t v61 = *(void *)(v45 + 145);
            *(int *)((char *)&v61[1] + 3) = *(_DWORD *)(v45 + 152);
            if (v47)
            {
              if (CI_INTERMEDIATE_SRGB_TEXTURES()
                && (*(unsigned int (**)(CI::SoftwareDAGDescriptor *, uint64_t, uint64_t))(*(void *)this[2]
                                                                                                 + 584))(this[2], v46, 1))
              {
                *(_DWORD *)(v45 + 14CI::NodeWithChildren::NodeWithChildren(this, 0) = v46;
                *(unsigned char *)(v45 + 144) = v47 | 4;
                *(void *)(v45 + 145) = *(void *)v61;
                *(_DWORD *)(v45 + 152) = *(int *)((char *)&v61[1] + 3);
              }
              else
              {
                CGRect v48 = CI::name_for_format(v46);
                x_log("Cannot use sRGB texture binding with format %s for sampler %d in kernel '%s'.\n", v48, v11, *(const char **)(v8 + 24));
              }
            }
          }
          operator new();
        }
        if (type != 4) {
          goto LABEL_25;
        }
      }
    }
    else
    {
      switch(type)
      {
        case 30:
          if (this[5])
          {
            uint64_t v15 = *((void *)this[1] + 8);
            double v55 = *(double *)&a5;
            v61[0] = 5;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v15 + 32 * *(void *)v53 + 8), v61, (uint64_t *)&v55);
          }
          break;
        case 36:
          if (this[5])
          {
            uint64_t v21 = *((void *)this[1] + 8);
            double v55 = 0.0;
            v61[0] = 4;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v21 + 32 * *(void *)v53 + 8), v61, (uint64_t *)&v55);
          }
          break;
        case 37:
          int v22 = (void **)this[5];
          if (v22)
          {
            *(void *)&double v23 = *(int *)v22;
            CI::SerialValArray<int>::append(v22, 37);
            if (this[5])
            {
              uint64_t v24 = *((void *)this[1] + 8);
              double v55 = v23;
              v61[0] = 4;
              std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v24 + 32 * *(void *)v53 + 8), v61, (uint64_t *)&v55);
            }
          }
          if (a4) {
            CI::SerialObjectPtrArray::append((uint64_t)a4, a4[3]);
          }
          break;
        case 38:
          if (this[5])
          {
            uint64_t v25 = *((void *)this[1] + 8);
            double v55 = 0.0;
            v61[0] = 0;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v25 + 32 * *(void *)v53 + 8), v61, (uint64_t *)&v55);
          }
          break;
        case 39:
          break;
        default:
          goto LABEL_25;
      }
    }
LABEL_59:
    ++v11;
  }
}

void sub_1936D3D54(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10A1C40000A9EE4);
  _Unwind_Resume(a1);
}

uint64_t x_log(const char *a1, ...)
{
  va_start(va, a1);
  return vfprintf((FILE *)*MEMORY[0x1E4F143C8], a1, va);
}

unint64_t CI::SoftwareDAGDescriptor::create_sampler_builder_function_info(CI::SoftwareDAGDescriptor *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v3 = (uint64_t *)(*((void *)this + 8) + 32 * a2 + 8);
  uint64_t v8 = v3;
  uint64_t v4 = (long long *)((char *)this + 112);
  uint64_t v5 = (uint64_t *)*((void *)this + 6);
  if ((unint64_t)v5 >= *((void *)this + 7))
  {
    uint64_t v6 = std::vector<CI::SWRendererFunctionNode>::__emplace_back_slow_path<CI::SWFunction const&,std::vector<CI::SWRendererFunctionInputNode> *&>((uint64_t *)this + 5, v4, &v8);
  }
  else
  {
    long long v9 = *v4;
    uint64_t v10 = *((void *)this + 16);
    CI::SWRendererFunctionNode::SWRendererFunctionNode(v5, (uint64_t)&v9, v3);
    uint64_t v6 = (uint64_t)(v5 + 9);
    *((void *)this + 6) = v5 + 9;
  }
  *((void *)this + 6) = v6;
  return 0x8E38E38E38E38E39 * ((v6 - *((void *)this + 5)) >> 3) - 1;
}

void sub_1936D3E9C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = v2;
  _Unwind_Resume(a1);
}

uint64_t *CI::DAGHelper::add_function_info(uint64_t a1, CI::ProgramNode *a2, uint64_t a3, uint64_t a4, std::string::size_type a5, unint64_t a6, uint64_t a7, char *a8, unsigned __int8 a9, void *a10)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *(void *)(a3 + 48);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v14 + 16))(v14) != 64) {
    (*(void (**)(uint64_t))(*(void *)v14 + 16))(v14);
  }
  if (*(unsigned char *)(v14 + 12)) {
    int v16 = CI::KernelArguments::count((CI::KernelArguments *)(v14 + 144));
  }
  else {
    int v16 = *(_DWORD *)(v14 + 20);
  }
  uint64_t v99 = v14;
  if (*(void *)(a1 + 40)) {
    int argument_info = CI::SoftwareDAGDescriptor::create_argument_info(*(CI::SoftwareDAGDescriptor **)(a1 + 8), v16);
  }
  else {
    int argument_info = -1;
  }
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  *(void *)float32x4_t v97 = argument_info;
  float32x2_t v98 = (CI::KernelArguments *)(v14 + 144);
  int8x16_t v100 = (CI::ProgramNode *)(a8 + 1);
  float32x4_t v96 = (uint64_t **)(a1 + 88);
  unint64_t v93 = a6 + 1;
  int8x16_t v94 = (void *)(a1 + 96);
  uint64_t v92 = a1 + 112;
  while (1)
  {
    int v20 = *(unsigned char *)(v99 + 12) ? CI::KernelArguments::count(v98) : *(_DWORD *)(v99 + 20);
    if ((uint64_t)v18 >= v20) {
      break;
    }
    uint64_t v21 = *(void *)(a3 + 48);
    if (*(unsigned char *)(v21 + 12))
    {
      int type = CI::KernelArguments::get_type((CI::KernelArguments *)(v21 + 144), v18);
    }
    else
    {
      if ((uint64_t)v18 >= *(int *)(v21 + 20))
      {
        int type = 0;
LABEL_28:
        CI::KernelArguments::is_uniform(type);
        uint64_t v26 = *(void *)(a3 + 56);
        if (v18 > 9) {
          uint64_t v27 = (CI::Object **)(*(void *)(v26 + 16) + 8 * (v18 - 10));
        }
        else {
          uint64_t v27 = (CI::Object **)(v26 + 8 * v18 + 24);
        }
        CI::SerialObjectPtrArray::append(a4, *v27);
        uint64_t v28 = *(void ***)(a1 + 40);
        if (v28)
        {
          std::string::size_type v29 = *(int *)v28;
          CI::SerialValArray<int>::append(v28, type);
          if (*(void *)(a1 + 40))
          {
            uint64_t v30 = *(void *)(*(void *)(a1 + 8) + 64);
            v103.__r_.__value_.__r.__words[0] = v29;
            *(_DWORD *)float32x4_t v108 = 4;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v30 + 32 * *(void *)v97 + 8), (int *)v108, (uint64_t *)&v103);
          }
        }
        goto LABEL_106;
      }
      int type = *(_DWORD *)(*(void *)(v21 + 72) + 4 * v18);
    }
    if (type <= 29)
    {
      if (type != 1)
      {
        if (type == 2)
        {
          uint64_t v36 = *(void *)(a3 + 56);
          if (v18 > 9) {
            double v37 = (double **)(*(void *)(v36 + 16) + 8 * (v18 - 10));
          }
          else {
            double v37 = (double **)(v36 + 8 * v18 + 24);
          }
          unint64_t v53 = *v37;
          v103.__r_.__value_.__r.__words[2] = 0;
          *(_OWORD *)&v103.__r_.__value_.__l.__data_ = 0x3FF0000000000000uLL;
          *(double *)&float32x4_t v104 = 1.0;
          double v105 = 0.0;
          double v106 = 0.0;
          size_t v54 = CI::ProgramNode::child_depth(a2, v19);
          uint64_t v95 = v19;
          if (v54 - 1 > a6)
          {
            unint64_t v55 = ~a6 + v54;
            do
            {
              if ((*(unsigned int (**)(double *))(*(void *)v53 + 16))(v53) == 28)
              {
                double v56 = v53[7];
                double v57 = v53[8];
                double v58 = v57 * *(double *)&v103.__r_.__value_.__r.__words[2]
                    + v56 * *(double *)&v103.__r_.__value_.__l.__data_;
                *(double *)&std::string::size_type v59 = v57 * *(double *)&v104 + v56 * *(double *)&v103.__r_.__value_.__l.__size_;
                double v60 = v53[9];
                double v61 = v53[10];
                double v62 = *(double *)&v103.__r_.__value_.__r.__words[2] * v61
                    + v60 * *(double *)&v103.__r_.__value_.__l.__data_;
                double v63 = *(double *)&v104 * v61 + v60 * *(double *)&v103.__r_.__value_.__l.__size_;
                double v64 = v53[11];
                double v65 = v53[12];
                double v66 = v105
                    + *(double *)&v103.__r_.__value_.__r.__words[2] * v65
                    + v64 * *(double *)&v103.__r_.__value_.__l.__data_;
                double v67 = *(double *)&v104 * v65 + v64 * *(double *)&v103.__r_.__value_.__l.__size_ + v106;
                *(double *)&v103.__r_.__value_.__l.__data_ = v58;
                v103.__r_.__value_.__l.__size_ = v59;
                *(double *)&v103.__r_.__value_.__r.__words[2] = v62;
                *(double *)&float32x4_t v104 = v63;
                double v105 = v66;
                double v106 = v67;
              }
              else
              {
                int v68 = (*(uint64_t (**)(double *))(*(void *)v53 + 16))(v53);
                uint64_t v69 = *(void *)v53;
                if (v68 == 45)
                {
                  (*(void (**)(double *))(v69 + 408))(v53);
                }
                else if ((*(unsigned int (**)(double *))(v69 + 16))(v53) != 30)
                {
                  (*(void (**)(double *))(*(void *)v53 + 16))(v53);
                }
              }
              unint64_t v53 = (double *)(*(uint64_t (**)(double *, void))(*(void *)v53 + 48))(v53, 0);
              --v55;
            }
            while (v55);
          }
          uint64_t v70 = (*(uint64_t (**)(CI::ProgramNode *, uint64_t))(*(void *)a2 + 48))(a2, v95);
          if ((*(unsigned int (**)(uint64_t))(*(void *)v70 + 16))(v70) == 52)
          {
            uint64_t v71 = *(unsigned int *)(v70 + 140);
            char v72 = *(unsigned char *)(v70 + 144);
            *(void *)float32x4_t v108 = *(void *)(v70 + 145);
            *(_DWORD *)&v108[7] = *(_DWORD *)(v70 + 152);
            if (v72)
            {
              if (CI_INTERMEDIATE_SRGB_TEXTURES()
                && (*(unsigned int (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 16) + 584))(*(void *)(a1 + 16), v71, 1))
              {
                *(_DWORD *)(v70 + 14CI::NodeWithChildren::NodeWithChildren(this, 0) = v71;
                *(unsigned char *)(v70 + 144) = v72 | 4;
                *(void *)(v70 + 145) = *(void *)v108;
                *(_DWORD *)(v70 + 152) = *(_DWORD *)&v108[7];
              }
              else
              {
                float32x4_t v86 = CI::name_for_format(v71);
                x_log("Cannot use sRGB texture binding with format %s for sampler %d in kernel '%s'.\n", v86, v18, *(const char **)(v99 + 24));
              }
            }
          }
          operator new();
        }
        if (type != 4) {
          goto LABEL_28;
        }
      }
      uint64_t v24 = *(void *)(a3 + 56);
      if (v18 > 9) {
        uint64_t v25 = (CI::Node **)(*(void *)(v24 + 16) + 8 * (v18 - 10));
      }
      else {
        uint64_t v25 = (CI::Node **)(v24 + 8 * v18 + 24);
      }
      double v38 = *v25;
      if (type == 4)
      {
        (*(void (**)(CI::Node *))(*(void *)v38 + 232))(v38);
        CI::Node::rois_count(v38);
        *(void *)float32x4_t v108 = 0;
        *(void *)float32x4_t v108 = CI::hash_image_node_id((uint64_t)v38, 0);
        v103.__r_.__value_.__r.__words[0] = (std::string::size_type)v108;
        double v39 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)(a1 + 136), (unint64_t *)v108, (uint64_t)&std::piecewise_construct, &v103);
        if (*(void *)(a1 + 40))
        {
          uint64_t v40 = *(void *)(*(void *)(a1 + 8) + 64);
          v103.__r_.__value_.__r.__words[0] = (std::string::size_type)v39[5];
          LODWORD(v102) = 0;
          std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v40 + 32 * *(void *)v97 + 8), (int *)&v102, (uint64_t *)&v103);
        }
      }
      else
      {
        a8[v93] = v19 + 48;
        a8[a6 + 2] = 0;
        double v41 = CI::replaceWithLeaf((CI::SerialStringArray **)a2, v100, (const char *)v38, v15);
        unint64_t v42 = CI::hash_dag_node_id((unint64_t)v41, a7, a8);
        if ((*(unsigned int (**)(const char *))(*(void *)v41 + 232))(v41))
        {
          uint64_t v43 = (uint64_t)&a8[a6 + 3];
          do
          {
            uint64_t v44 = (const char *)(*(uint64_t (**)(const char *, void))(*(void *)v41 + 48))(v41, 0);
            *(_WORD *)(v43 - 1) = 48;
            double v41 = CI::replaceWithLeaf((CI::SerialStringArray **)a2, v100, v44, v45);
            unint64_t v42 = CI::hash_dag_node_id((unint64_t)v41, v42, a8);
            ++v43;
          }
          while (((*(uint64_t (**)(const char *))(*(void *)v41 + 232))(v41) & 1) != 0);
        }
        uint64_t v46 = (void *)*v94;
        if (!*v94) {
          goto LABEL_63;
        }
        char v47 = (void *)(a1 + 96);
        do
        {
          unint64_t v48 = v46[4];
          BOOL v49 = v48 >= v42;
          if (v48 >= v42) {
            std::string::size_type v50 = v46;
          }
          else {
            std::string::size_type v50 = v46 + 1;
          }
          if (v49) {
            char v47 = v46;
          }
          uint64_t v46 = (void *)*v50;
        }
        while (*v50);
        if (v47 == v94 || v42 < v47[4])
        {
LABEL_63:
          unint64_t v102 = v42;
          *(void *)float32x4_t v108 = &v102;
          CGRect v51 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v92, &v102, (uint64_t)&std::piecewise_construct, (void **)v108);
          unint64_t v52 = v51;
          if (*((char *)v51 + 63) < 0) {
            std::string::__init_copy_ctor_external(&v103, (const std::string::value_type *)v51[5], v51[6]);
          }
          else {
            std::string v103 = *(std::string *)(v51 + 5);
          }
          std::vector<unsigned long>::vector(&v104, (uint64_t)(v52 + 8));
          char v107 = *((unsigned char *)v52 + 88);
          if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v73 = &v103;
          }
          else {
            uint64_t v73 = (std::string *)v103.__r_.__value_.__r.__words[0];
          }
          CI::DAGHelper::add_function_with_name(a1, (char *)v73);
          std::string::size_type size = HIBYTE(v103.__r_.__value_.__r.__words[2]);
          if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type size = v103.__r_.__value_.__l.__size_;
          }
          if (size != 14) {
            goto LABEL_93;
          }
          float32x4_t v77 = &v103;
          if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            float32x4_t v77 = (std::string *)v103.__r_.__value_.__r.__words[0];
          }
          std::string::size_type v78 = v77->__r_.__value_.__r.__words[0];
          uint64_t v79 = *(std::string::size_type *)((char *)v77->__r_.__value_.__r.__words + 6);
          if (v78 == 0x646165725F69635FLL && v79 == 0x6C657869705F6461) {
            CI::DAGHelper::add_read_pixel_function_info((uint64_t *)a1, *(void *)v104, v74, *((void *)v104 + 2), *((void *)v104 + 3));
          }
          else {
LABEL_93:
          }
            CI::DAGHelper::add_read_pixel_420_function_info((uint64_t *)a1, *(void *)v104, v74, *((void *)v104 + 2), *((void *)v104 + 3), *((void *)v104 + 4), v75, *((void *)v104 + 6));
          uint64_t v81 = (*a10)++;
          unint64_t v102 = v42;
          *(void *)float32x4_t v108 = &v102;
          *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, &v102, (uint64_t)&std::piecewise_construct, (uint64_t **)v108)+ 2CI::NodeWithChildren::NodeWithChildren(this, 0) = v81;
          if (v107)
          {
            CI::DAGHelper::add_function_with_name(a1, "_ci_srgb_to_linear");
            unint64_t v102 = v42;
            *(void *)float32x4_t v108 = &v102;
            int8x16_t v82 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, &v102, (uint64_t)&std::piecewise_construct, (uint64_t **)v108);
            CI::DAGHelper::add_colour_inout_function_info((uint64_t *)a1, *((unsigned __int16 *)v82 + 20));
            uint64_t v83 = (*a10)++;
            unint64_t v102 = v42;
            *(void *)float32x4_t v108 = &v102;
            *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, &v102, (uint64_t)&std::piecewise_construct, (uint64_t **)v108)+ 2CI::NodeWithChildren::NodeWithChildren(this, 0) = v83;
          }
          *(void *)float32x4_t v108 = v42;
          std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__erase_unique<unsigned long long>(v92, (unint64_t *)v108);
          if (*(double *)&v104 != 0.0)
          {
            double v105 = *(double *)&v104;
            operator delete(v104);
          }
          if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v103.__r_.__value_.__l.__data_);
          }
        }
        *(void *)float32x4_t v108 = v42;
        v103.__r_.__value_.__r.__words[0] = (std::string::size_type)v108;
        float32x2_t v84 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v96, (unint64_t *)v108, (uint64_t)&std::piecewise_construct, (uint64_t **)&v103);
        if (*(void *)(a1 + 40))
        {
          uint64_t v85 = *(void *)(*(void *)(a1 + 8) + 64);
          v103.__r_.__value_.__r.__words[0] = *((unsigned __int16 *)v84 + a9 + 20);
          *(_DWORD *)float32x4_t v108 = 5;
          std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v85 + 32 * *(void *)v97 + 8), (int *)v108, (uint64_t *)&v103);
        }
        a8[v93] = 0;
      }
      uint64_t v19 = (v19 + 1);
    }
    else
    {
      switch(type)
      {
        case 30:
          if (*(void *)(a1 + 40))
          {
            uint64_t v23 = *(void *)(*(void *)(a1 + 8) + 64);
            v103.__r_.__value_.__r.__words[0] = a5;
            *(_DWORD *)float32x4_t v108 = 5;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v23 + 32 * *(void *)v97 + 8), (int *)v108, (uint64_t *)&v103);
          }
          break;
        case 36:
          if (*(void *)(a1 + 40))
          {
            uint64_t v31 = *(void *)(*(void *)(a1 + 8) + 64);
            v103.__r_.__value_.__r.__words[0] = 0;
            *(_DWORD *)float32x4_t v108 = 4;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v31 + 32 * *(void *)v97 + 8), (int *)v108, (uint64_t *)&v103);
          }
          break;
        case 37:
          double v32 = *(void ***)(a1 + 40);
          if (v32)
          {
            std::string::size_type v33 = *(int *)v32;
            CI::SerialValArray<int>::append(v32, 37);
            if (*(void *)(a1 + 40))
            {
              uint64_t v34 = *(void *)(*(void *)(a1 + 8) + 64);
              v103.__r_.__value_.__r.__words[0] = v33;
              *(_DWORD *)float32x4_t v108 = 4;
              std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v34 + 32 * *(void *)v97 + 8), (int *)v108, (uint64_t *)&v103);
            }
          }
          if (a4) {
            CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
          }
          break;
        case 38:
          if (*(void *)(a1 + 40))
          {
            uint64_t v35 = *(void *)(*(void *)(a1 + 8) + 64);
            v103.__r_.__value_.__r.__words[0] = 0;
            *(_DWORD *)float32x4_t v108 = 0;
            std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>((char **)(v35 + 32 * *(void *)v97 + 8), (int *)v108, (uint64_t *)&v103);
          }
          break;
        case 39:
          break;
        default:
          goto LABEL_28;
      }
    }
LABEL_106:
    ++v18;
  }
  if (*(void *)(a1 + 40))
  {
    float32x4_t v87 = *(void (****)(void, std::string *))(a1 + 8);
    std::string v103 = *(std::string *)(v99 + 48);
    (**v87)(v87, &v103);
  }
  return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(a1 + 8), v97[0]);
}

void sub_1936D4C34(_Unwind_Exception *a1)
{
  CI::DAGHelper::TextureReadFunction::~TextureReadFunction((CI::DAGHelper::TextureReadFunction *)(v1 - 208));
  _Unwind_Resume(a1);
}

uint64_t CI::DAGHelper::color_output_for_kernel(CI::DAGHelper *this, const CI::Kernel *a2, unint64_t *a3)
{
  uint64_t v12 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    uint64_t v4 = *((void *)a2 + 16);
    uint64_t v5 = *((void *)a2 + 17);
    uint64_t v6 = (*a3)++;
    if (v4 == 2 && v5 == 2)
    {
      for (uint64_t i = 0; i != 4; ++i)
      {
        CI::DAGHelper::add_function_with_name((uint64_t)this, CI::DAGHelper::color_output_for_kernel(CI::Kernel const*,unsigned long &)::sGroupOutputFunctions[i]);
        CI::DAGHelper::add_colour_inout_function_info((uint64_t *)this, v6);
        unint64_t v10 = (*a3)++;
        *((_WORD *)&v12 + i) = v10;
      }
    }
    else
    {
      LOWORD(v12) = v6;
    }
  }
  return v12;
}

uint64_t CI::DAGHelper::build_dag(CI::DAGHelper *this, const CI::Node *a2, const CI::ProgramNode *a3, CI::SerialObjectPtrArray *a4, uint64_t a5)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    unint64_t v10 = ci_signpost_log_render();
    os_signpost_id_t v11 = *((int *)a3 + 9) | (unint64_t)((*(uint64_t (**)(void))(**((void **)this + 2) + 272))(*((void *)this + 2)) << 32);
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
    {
      *(_WORD *)CGRect buf = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v10, OS_SIGNPOST_INTERVAL_BEGIN, v11, "build_dag", "", buf, 2u);
    }
  }
  uint64_t v12 = (*(uint64_t (**)(void))(**((void **)this + 2) + 272))(*((void *)this + 2));
  TimerBase::TimerBase((uint64_t)buf, v12, *((_DWORD *)a3 + 9), (uint64_t)"build_dag", 5);
  uint64_t v47 = 0;
  unint64_t v48 = &v47;
  uint64_t v49 = 0x2020000000;
  uint64_t v50 = a5 + 1;
  v46[0] = MEMORY[0x1E4F143A8];
  v46[1] = 3221225472;
  v46[2] = ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke;
  v46[3] = &unk_1E5770C20;
  v46[6] = a5;
  v46[7] = a3;
  v46[8] = a4;
  uint8_t v46[4] = &v47;
  v46[5] = this;
  CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v46, (uint64_t)&__block_literal_global);
  uint64_t v39 = 0;
  uint64_t v40 = &v39;
  uint64_t v41 = 0x3812000000;
  unint64_t v42 = __Block_byref_object_copy_;
  uint64_t v43 = __Block_byref_object_dispose_;
  uint64_t v44 = "";
  uint64_t v45 = 0;
  if (*((unsigned char *)a3 + 136))
  {
    v38[0] = MEMORY[0x1E4F143A8];
    v38[1] = 3221225472;
    v38[2] = ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_21;
    v38[3] = &unk_1E5770C68;
    v38[6] = this;
    v38[7] = a5;
    v38[8] = a3;
    v38[9] = a4;
    v38[4] = &v47;
    v38[5] = &v39;
    CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v38, 0);
  }
  else
  {
    v37[0] = MEMORY[0x1E4F143A8];
    v37[1] = 3221225472;
    void v37[2] = ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_2_22;
    v37[3] = &__block_descriptor_56_e33_v60__0_v8r_v16i24i28_v32Q40_48i56l;
    v37[4] = this;
    v37[5] = a3;
    v37[6] = a4;
    CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v37, (uint64_t)&__block_literal_global_25);
    v36[0] = MEMORY[0x1E4F143A8];
    v36[1] = 3221225472;
    v36[2] = ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_4;
    v36[3] = &__block_descriptor_48_e33_v60__0_v8r_v16i24i28_v32Q40_48i56l;
    v36[4] = this;
    void v36[5] = a5;
    CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v36, (uint64_t)&__block_literal_global_29);
  }
  v35[0] = MEMORY[0x1E4F143A8];
  v35[1] = 3221225472;
  v35[2] = ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_6;
  v35[3] = &unk_1E5770C68;
  v35[6] = this;
  v35[7] = a5;
  v35[8] = a3;
  v35[9] = a4;
  v35[4] = &v47;
  int64x2_t v35[5] = &v39;
  CI::ProgramNode::traverse_dag((uint64_t)a3, (unint64_t)a2, (uint64_t)v35, (uint64_t)&__block_literal_global_31);
  uint64_t v13 = v40;
  if (!*((_WORD *)v40 + 24) && *((void *)this + 16))
  {
    uint64_t v14 = (char *)this + 112;
    uint64_t v15 = *((void *)this + 14);
    unint64_t v34 = *(void *)(v15 + 32);
    if (*(char *)(v15 + 63) < 0) {
      std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v15 + 40), *(void *)(v15 + 48));
    }
    else {
      std::string v31 = *(std::string *)(v15 + 40);
    }
    std::vector<unsigned long>::vector(__p, v15 + 64);
    char v33 = *(unsigned char *)(v15 + 88);
    if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v16 = &v31;
    }
    else {
      int v16 = (std::string *)v31.__r_.__value_.__r.__words[0];
    }
    CI::DAGHelper::add_function_with_name((uint64_t)this, (char *)v16);
    std::string::size_type size = HIBYTE(v31.__r_.__value_.__r.__words[2]);
    if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v31.__r_.__value_.__l.__size_;
    }
    if (size != 14) {
      goto LABEL_25;
    }
    int v20 = &v31;
    if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v20 = (std::string *)v31.__r_.__value_.__r.__words[0];
    }
    std::string::size_type v21 = v20->__r_.__value_.__r.__words[0];
    uint64_t v22 = *(std::string::size_type *)((char *)v20->__r_.__value_.__r.__words + 6);
    if (v21 == 0x646165725F69635FLL && v22 == 0x6C657869705F6461) {
      CI::DAGHelper::add_read_pixel_function_info((uint64_t *)this, *(void *)__p[0], v17, *((void *)__p[0] + 2), *((void *)__p[0] + 3));
    }
    else {
LABEL_25:
    }
      CI::DAGHelper::add_read_pixel_420_function_info((uint64_t *)this, *(void *)__p[0], v17, *((void *)__p[0] + 2), *((void *)__p[0] + 3), *((void *)__p[0] + 4), v18, *((void *)__p[0] + 6));
    uint64_t v24 = v48[3];
    v48[3] = v24 + 1;
    uint64_t v25 = (uint64_t **)((char *)this + 88);
    unint64_t v52 = &v34;
    *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)this + 11, &v34, (uint64_t)&std::piecewise_construct, (uint64_t **)&v52)+ 2CI::NodeWithChildren::NodeWithChildren(this, 0) = v24;
    if (v33)
    {
      CI::DAGHelper::add_function_with_name((uint64_t)this, "_ci_srgb_to_linear");
      unint64_t v52 = &v34;
      uint64_t v26 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)this + 11, &v34, (uint64_t)&std::piecewise_construct, (uint64_t **)&v52);
      CI::DAGHelper::add_colour_inout_function_info((uint64_t *)this, *((unsigned __int16 *)v26 + 20));
      uint64_t v27 = v48[3];
      v48[3] = v27 + 1;
      unint64_t v52 = &v34;
      *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v25, &v34, (uint64_t)&std::piecewise_construct, (uint64_t **)&v52)+ 2CI::NodeWithChildren::NodeWithChildren(this, 0) = v27;
    }
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__erase_unique<unsigned long long>((uint64_t)v14, &v34);
    unint64_t v52 = &v34;
    uint64_t v28 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v25, &v34, (uint64_t)&std::piecewise_construct, (uint64_t **)&v52);
    v40[6] = v28[5];
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    uint64_t v13 = v40;
  }
  uint64_t v29 = v13[6];
  _Block_object_dispose(&v39, 8);
  _Block_object_dispose(&v47, 8);
  CI::DAGHelper::build_dag(CI::Node const*,CI::ProgramNode const*,CI::SerialObjectPtrArray *,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)buf);
  return v29;
}

void sub_1936D5378(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54)
{
  _Block_object_dispose(&a54, 8);
  _Block_object_dispose((const void *)(v54 - 192), 8);
  CI::DAGHelper::build_dag(CI::Node const*,CI::ProgramNode const*,CI::SerialObjectPtrArray *,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)(v54 - 160));
  _Unwind_Resume(a1);
}

void ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke(void *a1, CI::Object *this, int a3, int a4, int a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  if (a9 == -1)
  {
    uint64_t v14 = a1[5];
    uint64_t v27 = this;
    uint64_t v28 = 0;
    if (this) {
      CI::Object::ref((uint64_t)this);
    }
    uint64_t v15 = (*(uint64_t (**)(CI::Object *, void))(*(void *)this + 320))(this, *(void *)(v14 + 16));
    uint64_t v28 = v15;
    if (v15) {
      int v16 = (CI::ColorKernelNode *)v15;
    }
    else {
      int v16 = v27;
    }
    if ((*(unsigned int (**)(CI::ColorKernelNode *))(*(void *)v16 + 16))(v16) == 50)
    {
      uint64_t v18 = *((void *)v16 + 6);
      if (a6)
      {
        unint64_t v26 = CI::hash_dag_node_id(a6, a7, 0);
        *(void *)&long long v29 = &v26;
        uint64_t v19 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v14 + 64), &v26, (uint64_t)&std::piecewise_construct, (uint64_t **)&v29)+ 5;
      }
      else
      {
        uint64_t v19 = a1 + 6;
      }
      uint64_t v20 = *v19;
      if (*(void *)(v14 + 40))
      {
        std::string::size_type v21 = *(void (****)(void, long long *))(v14 + 8);
        long long v29 = *(_OWORD *)(v18 + 48);
        uint64_t v30 = *(void *)(v18 + 64);
        (**v21)(v21, &v29);
      }
      CI::DAGHelper::add_function_info(v14, v17, v16, a1[8], v20);
      unint64_t v22 = CI::hash_dag_node_id((unint64_t)this, a7, a8);
      unint64_t v23 = CI::hash_dag_node_id((unint64_t)this, v22, 0);
      uint64_t v24 = *(void *)(a1[4] + 8);
      uint64_t v25 = *(void *)(v24 + 24);
      *(void *)(v24 + 24) = v25 + 1;
      unint64_t v26 = v23;
      *(void *)&long long v29 = &v26;
      std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v14 + 64), &v26, (uint64_t)&std::piecewise_construct, (uint64_t **)&v29)[5] = v25;
    }
    CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)&v27);
  }
}

void sub_1936D55D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a2 + 232))(a2) ^ 1;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = *(void *)(a2 + 48);
  return result;
}

uint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_21(uint64_t result, const CI::GeneralKernelNode *a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  if (a9 == -1)
  {
    uint64_t v14 = result;
    uint64_t v15 = *(void *)(result + 48);
    double result = (*(uint64_t (**)(const CI::GeneralKernelNode *))(*(void *)a2 + 16))(a2);
    if (result == 51)
    {
      double result = (*(uint64_t (**)(const CI::GeneralKernelNode *))(*(void *)a2 + 296))(a2);
      if ((result & 1) == 0)
      {
        unint64_t v16 = CI::hash_dag_node_id((unint64_t)a2, a7, a8);
        uint64_t v17 = *((void *)a2 + 6);
        if (a6)
        {
          unint64_t v23 = CI::hash_dag_node_id(a6, a7, 0);
          *(void *)&long long v24 = &v23;
          uint64_t v18 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 64), &v23, (uint64_t)&std::piecewise_construct, (uint64_t **)&v24)+ 5;
        }
        else
        {
          uint64_t v18 = (uint64_t *)(v14 + 56);
        }
        uint64_t v19 = *v18;
        if (*(void *)(v15 + 40))
        {
          uint64_t v20 = *(void (****)(void, long long *))(v15 + 8);
          long long v24 = *(_OWORD *)(v17 + 48);
          uint64_t v25 = *(void *)(v17 + 64);
          (**v20)(v20, &v24);
        }
        CI::DAGHelper::add_function_info((CI::SoftwareDAGDescriptor **)v15, *(const CI::ProgramNode **)(v14 + 64), a2, *(CI::Object ***)(v14 + 72), v19, a4);
        uint64_t v21 = CI::DAGHelper::color_output_for_kernel((CI::DAGHelper *)v15, (const CI::Kernel *)v17, (unint64_t *)(*(void *)(*(void *)(v14 + 32) + 8) + 24));
        unint64_t v22 = (uint64_t **)(v15 + 88);
        unint64_t v23 = v16;
        *(void *)&long long v24 = &v23;
        std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v22, &v23, (uint64_t)&std::piecewise_construct, (uint64_t **)&v24)[5] = v21;
        unint64_t v23 = v16;
        *(void *)&long long v24 = &v23;
        double result = (uint64_t)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v22, &v23, (uint64_t)&std::piecewise_construct, (uint64_t **)&v24);
        *(void *)(*(void *)(*(void *)(v14 + 40) + 8) + 48) = *(void *)(result + 40);
      }
    }
  }
  return result;
}

unint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_2_22(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  if (a9 != -1)
  {
    uint64_t v12 = *(void *)(result + 32);
    (*(void (**)(void, void))(**(void **)(result + 40) + 48))(*(void *)(result + 40), a9);
    if (a3 && !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a3 + 192))(a3, a5)) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = (const CI::Node *)(int)a9;
    }
    double result = CI::hash_image_node_id(a2, v13);
    uint64_t v14 = *(void **)(v12 + 144);
    if (!v14) {
      goto LABEL_17;
    }
    uint64_t v15 = v12 + 144;
    do
    {
      unint64_t v16 = v14[4];
      BOOL v17 = v16 >= result;
      if (v16 >= result) {
        uint64_t v18 = v14;
      }
      else {
        uint64_t v18 = v14 + 1;
      }
      if (v17) {
        uint64_t v15 = (uint64_t)v14;
      }
      uint64_t v14 = (void *)*v18;
    }
    while (*v18);
    if (v15 == v12 + 144 || result < *(void *)(v15 + 32)) {
LABEL_17:
    }
      CI::DAGHelper::add_arguments_for_image_node(v12);
  }
  return result;
}

uint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_3(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a2 + 232))(a2) ^ 1;
}

unint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_4(unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  if (a9 != -1)
  {
    unint64_t v13 = result;
    uint64_t v14 = *(void *)(result + 32);
    if (!a3 || (double result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 192))(a3, a5), result))
    {
      double result = CI::hash_dag_node_id(a2, a7, a8);
      uint64_t v15 = (void *)result;
      unint64_t v16 = *(void **)(v14 + 96);
      if (!v16) {
        goto LABEL_15;
      }
      BOOL v17 = (void *)(v14 + 96);
      do
      {
        unint64_t v18 = v16[4];
        BOOL v19 = v18 >= result;
        if (v18 >= result) {
          uint64_t v20 = v16;
        }
        else {
          uint64_t v20 = v16 + 1;
        }
        if (v19) {
          BOOL v17 = v16;
        }
        unint64_t v16 = (void *)*v20;
      }
      while (*v20);
      if (v17 == (void *)(v14 + 96) || result < v17[4])
      {
LABEL_15:
        int v21 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 16))(a2);
        uint64_t v22 = *(void *)a2;
        if (v21 != 46)
        {
          if ((*(unsigned int (**)(unint64_t))(*(void *)a2 + 16))(a2) != 44)
          {
            unint64_t v38 = 0;
            goto LABEL_20;
          }
          uint64_t v22 = *(void *)a2;
        }
        unint64_t v38 = (*(int (**)(unint64_t))(v22 + 208))(a2);
LABEL_20:
        unint64_t v48 = CI::hash_image_node_id(a2, (const CI::Node *)a9);
        v42.__r_.__value_.__r.__words[0] = (std::string::size_type)&v48;
        unint64_t v23 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)(v14 + 136), &v48, (uint64_t)&std::piecewise_construct, &v42);
        uint64_t v25 = v23[5];
        long long v24 = v23[6];
        uint64_t v27 = v23[7];
        unint64_t v26 = v23[8];
        uint64_t v28 = v23[9];
        uint64_t v36 = v23[10];
        char v37 = *((unsigned char *)v23 + 88);
        if (a6)
        {
          long long v29 = (void *)CI::hash_dag_node_id(a6, a7, 0);
          uint64_t v30 = v14;
          uint64_t v45 = v29;
          v42.__r_.__value_.__r.__words[0] = (std::string::size_type)&v45;
          std::string v31 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v14 + 64), (unint64_t *)&v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v42)+ 5;
        }
        else
        {
          uint64_t v30 = v14;
          std::string v31 = (uint64_t *)(v13 + 40);
        }
        uint64_t v32 = *v31;
        if (v38 < 2)
        {
          uint64_t v35 = operator new(0x20uLL);
          uint64_t v46 = v35 + 4;
          uint64_t v47 = v35 + 4;
          *uint64_t v35 = v25;
          v35[1] = v24;
          v35[2] = v32;
          v35[3] = v27;
          uint64_t v45 = v35;
          std::string::basic_string[abi:nn180100]<0>(v40, "_ci_read_pixel");
        }
        else
        {
          char v33 = operator new(0x38uLL);
          uint64_t v46 = v33 + 7;
          uint64_t v47 = v33 + 7;
          *char v33 = v25;
          v33[1] = v24;
          v33[2] = v32;
          void v33[3] = v27;
          v33[4] = v26;
          v33[5] = v28;
          void v33[6] = v36;
          uint64_t v45 = v33;
          std::string::basic_string[abi:nn180100]<0>(v40, "_ci_read_pixel_420");
        }
        CI::DAGHelper::TextureReadFunction::TextureReadFunction(&v42, (long long *)v40, (uint64_t)&v45);
        uint64_t v39 = v15;
        uint64_t v49 = (unint64_t *)&v39;
        unint64_t v34 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v30 + 112, (unint64_t *)&v39, (uint64_t)&std::piecewise_construct, &v49);
        CI::DAGHelper::TextureReadFunction::operator=((std::string *)(v34 + 5), &v42);
        if (__p)
        {
          uint64_t v44 = __p;
          operator delete(__p);
        }
        if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v42.__r_.__value_.__l.__data_);
        }
        if (v41 < 0) {
          operator delete(v40[0]);
        }
        if (v45)
        {
          uint64_t v46 = v45;
          operator delete(v45);
        }
        uint64_t v45 = v15;
        v42.__r_.__value_.__r.__words[0] = (std::string::size_type)&v45;
        double result = (unint64_t)std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v30 + 112, (unint64_t *)&v45, (uint64_t)&std::piecewise_construct, &v42);
        *(unsigned char *)(result + 88) = v37 & 1;
      }
    }
  }
  return result;
}

void sub_1936D5DD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a27) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_5(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a2 + 232))(a2) ^ 1;
}

void ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_6(uint64_t a1, CI::Object *this, int a3, int a4, int a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  if (a9 == -1)
  {
    uint64_t v15 = *(void *)(a1 + 48);
    uint64_t v46 = this;
    uint64_t v47 = 0;
    if (this) {
      CI::Object::ref((uint64_t)this);
    }
    uint64_t v16 = (*(uint64_t (**)(CI::Object *, void))(*(void *)this + 320))(this, *(void *)(v15 + 16));
    uint64_t v47 = v16;
    if (!v16) {
      uint64_t v16 = (uint64_t)v46;
    }
    uint64_t v44 = (CI::ColorKernelNode *)v16;
    if ((*(unsigned int (**)(void))(*(void *)v16 + 16))() == 49)
    {
      BOOL v17 = (const CI::Kernel *)*((void *)v44 + 6);
      if (a6)
      {
        unint64_t v45 = CI::hash_dag_node_id(a6, a7, 0);
        unint64_t v48 = &v45;
        unint64_t v18 = (std::string::size_type *)(std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 64), &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48)+ 5);
      }
      else
      {
        unint64_t v18 = (std::string::size_type *)(a1 + 56);
      }
      std::string::size_type v21 = *v18;
      unint64_t v22 = CI::hash_dag_node_id((unint64_t)this, a7, a8);
      CI::DAGHelper::add_function_info(v15, *(CI::SerialStringArray ***)(a1 + 64), v44, *(void *)(a1 + 72), v21, a4, a7, a8, 0, (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      unint64_t v23 = a8;
      uint64_t v24 = a7;
      uint64_t v25 = CI::DAGHelper::color_output_for_kernel((CI::DAGHelper *)v15, v17, (unint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      unint64_t v26 = v23;
      uint64_t v27 = v15;
      uint64_t v28 = (uint64_t **)(v15 + 88);
      unint64_t v45 = v22;
      unint64_t v48 = &v45;
      long long v29 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 88), &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48);
      uint64_t v30 = 0;
      v29[5] = v25;
      do
      {
        uint64_t v31 = v30 + 1;
        if (*(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 2 * v30 + 50))
        {
          CI::DAGHelper::add_function_info(v27, *(CI::SerialStringArray ***)(a1 + 64), v44, *(void *)(a1 + 72), v21, a4, v24, v26, v31, (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
          unint64_t v45 = v22;
          unint64_t v48 = &v45;
          uint64_t v32 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v28, &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48);
          uint64_t v33 = *(void *)(*(void *)(a1 + 32) + 8);
          uint64_t v34 = *(void *)(v33 + 24);
          *(void *)(v33 + 24) = v34 + 1;
          *((_WORD *)v32 + v30 + 21) = v34;
        }
        ++v30;
      }
      while (v31 != 3);
    }
    else
    {
      if ((*(unsigned int (**)(CI::ColorKernelNode *))(*(void *)v44 + 16))(v44) != 51
        || !(*(unsigned int (**)(CI::ColorKernelNode *))(*(void *)v44 + 296))(v44))
      {
        goto LABEL_19;
      }
      BOOL v19 = (const CI::Kernel *)*((void *)v44 + 6);
      if (a6)
      {
        unint64_t v45 = CI::hash_dag_node_id(a6, a7, 0);
        unint64_t v48 = &v45;
        uint64_t v20 = (std::string::size_type *)(std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 64), &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48)+ 5);
      }
      else
      {
        uint64_t v20 = (std::string::size_type *)(a1 + 56);
      }
      std::string::size_type v35 = *v20;
      unint64_t v22 = CI::hash_dag_node_id((unint64_t)this, a7, a8);
      CI::DAGHelper::add_function_info(v15, *(CI::ProgramNode **)(a1 + 64), (uint64_t)v44, *(void *)(a1 + 72), v35, a4, a7, a8, 0, (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      uint64_t v43 = a8;
      uint64_t v36 = CI::DAGHelper::color_output_for_kernel((CI::DAGHelper *)v15, v19, (unint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      uint64_t v37 = v15;
      uint64_t v28 = (uint64_t **)(v15 + 88);
      unint64_t v45 = v22;
      unint64_t v48 = &v45;
      uint64_t v38 = 0;
      std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 88), &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48)[5] = v36;
      do
      {
        uint64_t v39 = v38 + 1;
        if (*(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 2 * v38 + 50))
        {
          CI::DAGHelper::add_function_info(v37, *(CI::ProgramNode **)(a1 + 64), (uint64_t)v44, *(void *)(a1 + 72), v35, a4, a7, v43, v39, (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
          unint64_t v45 = v22;
          unint64_t v48 = &v45;
          uint64_t v40 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v28, &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48);
          uint64_t v41 = *(void *)(*(void *)(a1 + 32) + 8);
          uint64_t v42 = *(void *)(v41 + 24);
          *(void *)(v41 + 24) = v42 + 1;
          *((_WORD *)v40 + v38 + 21) = v42;
        }
        ++v38;
      }
      while (v39 != 3);
    }
    unint64_t v45 = v22;
    unint64_t v48 = &v45;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v28, &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48)[5];
LABEL_19:
    CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)&v46);
  }
}

void sub_1936D6364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_7(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a2 + 232))(a2) ^ 1;
}

void CI::DAGHelper::build_dag(CI::Node const*,CI::ProgramNode const*,CI::SerialObjectPtrArray *,unsigned long)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  if (CI_VERBOSE_SIGNPOSTS())
  {
    uint64_t v2 = ci_signpost_log_render();
    os_signpost_id_t v3 = *((void *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "build_dag", "", v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1936D648C(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::DAGHelper::analyze_kernels(CI::DAGHelper *this, const CI::ProgramNode *a2)
{
  v18[0] = 0;
  v18[1] = v18;
  v18[2] = 0x2020000000;
  char v19 = 0;
  v16[0] = 0;
  v16[1] = v16;
  void v16[2] = 0x2020000000;
  char v17 = 0;
  uint64_t v12 = 0;
  unint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 1;
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x4012000000;
  uint64_t v8 = __Block_byref_object_copy__32;
  long long v9 = __Block_byref_object_dispose__33;
  unint64_t v10 = "";
  long long v11 = xmmword_19394C970;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN2CI9DAGHelper15analyze_kernelsEPKNS_11ProgramNodeE_block_invoke;
  v4[3] = &unk_1E5770CD0;
  v4[8] = this;
  v4[9] = a2;
  v4[4] = v16;
  void v4[5] = v18;
  void v4[6] = &v12;
  v4[7] = &v5;
  CI::ProgramNode::traverse_graph_preorder_stoppable((uint64_t)a2, (uint64_t)v4);
  *(_OWORD *)((char *)this + 24) = *((_OWORD *)v6 + 3);
  if (*((unsigned char *)v13 + 24)) {
    operator new();
  }
  _Block_object_dispose(&v5, 8);
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(v16, 8);
  _Block_object_dispose(v18, 8);
  return 0xFFFFFFFFLL;
}

void sub_1936D668C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 128), 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Block_object_dispose((const void *)(v11 - 64), 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__32(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

BOOL ___ZN2CI9DAGHelper15analyze_kernelsEPKNS_11ProgramNodeE_block_invoke(uint64_t a1, CI::Object *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a6 == -1)
  {
    uint64_t v9 = *(void *)(a1 + 64);
    unint64_t v18 = this;
    uint64_t v19 = 0;
    if (this) {
      CI::Object::ref((uint64_t)this);
    }
    uint64_t v10 = (*(uint64_t (**)(CI::Object *, void))(*(void *)this + 320))(this, *(void *)(v9 + 16));
    uint64_t v19 = v10;
    if (v10) {
      uint64_t v11 = (void *)v10;
    }
    else {
      uint64_t v11 = v18;
    }
    if ((*(unsigned int (**)(void *))(*v11 + 16))(v11) == 49
      || (*(unsigned int (**)(void *))(*v11 + 16))(v11) == 50
      || (*(unsigned int (**)(void *))(*v11 + 16))(v11) == 51)
    {
      uint64_t v12 = v11[6];
      if (v12)
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 16))(v12) == 62 && *(unsigned char *)(v12 + 176)) {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
        }
        if ((*(uint64_t (**)(uint64_t))(*(void *)v12 + 72))(v12)) {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
        }
        uint64_t v13 = *(void *)(*(void *)(a1 + 56) + 8);
        unint64_t v14 = *(void *)(v13 + 48);
        if (v14 <= *(void *)(v12 + 128)) {
          unint64_t v14 = *(void *)(v12 + 128);
        }
        *(void *)(v13 + 48) = v14;
        uint64_t v15 = *(void *)(*(void *)(a1 + 56) + 8);
        unint64_t v16 = *(void *)(v15 + 56);
        if (v16 <= *(void *)(v12 + 136)) {
          unint64_t v16 = *(void *)(v12 + 136);
        }
        *(void *)(v15 + 56) = v16;
      }
    }
    CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)&v18);
  }
  else
  {
    uint64_t v7 = (unsigned char *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 72) + 48))(*(void *)(a1 + 72), a6);
    if (*(unsigned int (**)(unsigned char *))(*(void *)v7 + 16))(v7) == 52 && (v7[144]) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    }
  }
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) == 0;
}

void sub_1936D6950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void CI::DAGHelper::process_kernels(CI::DAGHelper *this, const char *a2, const CI::Node *a3, const CI::ProgramNode *a4, CI::SerialObjectPtrArray *a5)
{
}

void sub_1936D6B10(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10F1C40A348548ELL);
  _Unwind_Resume(a1);
}

void CI::SoftwareDAGDescriptor::analyze_set_destcoord(CI::SoftwareDAGDescriptor *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (0x8E38E38E38E38E39 * ((*((void *)this + 3) - v1) >> 3) - 3 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = 0;
    int v4 = -1;
    unint64_t v5 = 1;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)&v9, *(void *)(v1 + v3 + 72), *(void *)(v1 + v3 + 80), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v1 + v3 + 80) - *(void *)(v1 + v3 + 72)) >> 3));
      v7[0] = (void **)&unk_1EE456E38;
      uint64_t v6 = *(void ***)(v10 - 16);
      int v8 = *(_DWORD *)(v10 - 8);
      v7[1] = v6;
      if (v6 != (void **)v4)
      {
        *(unsigned char *)(*((void *)this + 2) + v3 + 136) = 1;
        int v4 = (int)v6;
      }
      v7[0] = (void **)&v9;
      std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](v7);
      ++v5;
      uint64_t v1 = *((void *)this + 2);
      v3 += 72;
    }
    while (-1 - 0x71C71C71C71C71C7 * ((*((void *)this + 3) - v1) >> 3) > v5);
  }
}

uint64_t CI::SoftwareDAGDescriptor::create_pipeline(uint64_t this)
{
  if (!*(void *)(this + 8)) {
    operator new();
  }
  return this;
}

uint64_t CI::create_sw_dag(CI *this, const CI::SWContext *a2, const CI::SWContext *a3, const CI::Node *a4, const CI::ProgramNode *a5, CI::SerialObjectPtrArray *a6)
{
  CI::DAGHelper::DAGHelper((CI::DAGHelper *)v11, a2);
  if (!CI::DAGHelper::analyze_kernels((CI::DAGHelper *)v11, a4)) {
    CI::DAGHelper::process_kernels((CI::DAGHelper *)v11, (const char *)this, a3, a4, a5);
  }
  CI::DAGHelper::~DAGHelper(v11);
  return 0;
}

void sub_1936D6D88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CI::DAGHelper::~DAGHelper((char **)va);
  _Unwind_Resume(a1);
}

void CI::create_sw_args(CI *this, const CI::SWContext *a2, const CI::Node *a3, const CI::ProgramNode *a4, CI::SerialObjectPtrArray *a5)
{
  CI::DAGHelper::DAGHelper((CI::DAGHelper *)&v8, this);
  if (!CI::DAGHelper::analyze_kernels((CI::DAGHelper *)&v8, a3))
  {
    CI::DAGHelper::build_dag((CI::DAGHelper *)&v8, a2, a3, a4, 1);
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
    }
  }
  CI::DAGHelper::~DAGHelper(&v8);
}

void sub_1936D6E44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CI::DAGHelper::~DAGHelper((char **)va);
  _Unwind_Resume(a1);
}

uint64_t CI::SoftwareDAG::type(CI::SoftwareDAG *this)
{
  return 69;
}

char *std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    if (a2 != a3)
    {
      uint64_t v8 = *((void *)v6 + 1);
      do
      {
        *(void *)uint64_t v7 = &unk_1EE456E38;
        uint64_t v9 = *(void *)(a2 + 8);
        *(_DWORD *)(v7 + 16) = *(_DWORD *)(a2 + 16);
        *(void *)(v7 + 8) = v9;
        a2 += 24;
        v7 += 24;
        v8 += 24;
      }
      while (a2 != a3);
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

void std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    int v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 24;
      uint64_t v7 = v4 - 24;
      uint64_t v8 = v4 - 24;
      do
      {
        uint64_t v9 = *(void *)v8;
        v8 -= 24;
        (*(void (**)(char *))(v9 + 8))(v7);
        v6 -= 24;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void CI::SWRendererFunctionInputNode::description(CI::SWRendererFunctionInputNode *this@<X0>, void *a2@<X8>)
{
  switch(*((_DWORD *)this + 4))
  {
    case 0:
      std::to_string(&v13, *((void *)this + 1));
      int v4 = std::string::insert(&v13, 0, "Texture[", 8uLL);
      long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
      v14.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v5;
      v4->__r_.__value_.__l.__size_ = 0;
      v4->__r_.__value_.__r.__words[2] = 0;
      v4->__r_.__value_.__r.__words[0] = 0;
      uint64_t v6 = std::string::append(&v14, "]", 1uLL);
      goto LABEL_6;
    case 3:
      std::to_string(&v14, *((void *)this + 1));
      uint64_t v11 = std::string::insert(&v14, 0, "Sampler#", 8uLL);
      long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      a2[2] = *((void *)&v11->__r_.__value_.__l + 2);
      *(_OWORD *)a2 = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      if ((SHIBYTE(v14.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
      BOOL v10 = (void *)v14.__r_.__value_.__r.__words[0];
      goto LABEL_16;
    case 4:
      std::to_string(&v13, *((void *)this + 1));
      uint64_t v7 = std::string::insert(&v13, 0, "Buffer[", 7uLL);
      long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v14.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      uint64_t v6 = std::string::append(&v14, "]", 1uLL);
LABEL_6:
      long long v9 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      a2[2] = *((void *)&v6->__r_.__value_.__l + 2);
      *(_OWORD *)a2 = v9;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v14.__r_.__value_.__l.__data_);
      }
      if ((SHIBYTE(v13.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
      BOOL v10 = (void *)v13.__r_.__value_.__r.__words[0];
LABEL_16:
      operator delete(v10);
      break;
    case 5:
    case 6:
      uint64_t v3 = "";
      goto LABEL_11;
    case 7:
      uint64_t v3 = "ThreadPosition";
      goto LABEL_11;
    default:
      uint64_t v3 = "Unknown";
LABEL_11:
      std::string::basic_string[abi:nn180100]<0>(a2, v3);
      break;
  }
}

void sub_1936D7190(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CI::SWRendererFunctionInputNode::~SWRendererFunctionInputNode(CI::SWRendererFunctionInputNode *this)
{
}

void SamplerObj::~SamplerObj(SamplerObj *this)
{
  *(void *)this = &unk_1EE4569B0;
  uint64_t v1 = (CI::Object *)*((void *)this + 1);
  if (v1) {
    CI::Object::unref(v1);
  }
}

{
  CI::Object *v1;
  uint64_t vars8;

  *(void *)this = &unk_1EE4569B0;
  uint64_t v1 = (CI::Object *)*((void *)this + 1);
  if (v1) {
    CI::Object::unref(v1);
  }

  JUMPOUT(0x1997023B0);
}

uint64_t std::vector<CI::SoftwareDAGDescriptor::ArgumentInfo>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = *(void *)(a3 + v11 - 32);
      *(void *)(a7 + v11 - 24) = 0;
      uint64_t v13 = a7 + v11 - 24;
      *(void *)(v13 - 8) = v12;
      *(void *)(v13 + 8) = 0;
      *(void *)(v13 + 16) = 0;
      std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)v13, *(void *)(a3 + v11 - 24), *(void *)(a3 + v11 - 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + v11 - 16) - *(void *)(a3 + v11 - 24)) >> 3));
      v11 -= 32;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void **std::__split_buffer<CI::SoftwareDAGDescriptor::ArgumentInfo>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<CI::SoftwareDAGDescriptor::ArgumentInfo>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    int v4 = (void **)(i - 24);
    std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](&v4);
  }
}

char *std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType,unsigned long &>(char **a1, int *a2, uint64_t *a3)
{
  unint64_t v8 = (unint64_t)a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  unint64_t v7 = v8;
  unint64_t v9 = *(void *)(v6 - 8);
  if (v9 >= v8)
  {
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (void)*a1) >> 3);
    unint64_t v14 = v13 + 1;
    if (v13 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (void)*a1) >> 3);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x555555555555555) {
      unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v16 = v14;
    }
    uint64_t v33 = v6;
    char v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(v6, v16);
    uint64_t v19 = &v17[24 * v13];
    int v20 = *a2;
    uint64_t v21 = *a3;
    *(void *)uint64_t v19 = &unk_1EE456E38;
    *((void *)v19 + 1) = v21;
    *((_DWORD *)v19 + 4) = v20;
    unint64_t v22 = *a1;
    unint64_t v23 = (unint64_t)a1[1];
    if ((char *)v23 == *a1)
    {
      int64x2_t v27 = vdupq_n_s64(v23);
      uint64_t v25 = &v17[24 * v13];
    }
    else
    {
      uint64_t v24 = (uint64_t)&v17[24 * v13 - 24];
      uint64_t v25 = &v17[24 * v13];
      do
      {
        *((void *)v25 - 3) = &unk_1EE456E38;
        v25 -= 24;
        uint64_t v26 = *(void *)(v23 - 16);
        *((_DWORD *)v25 + 4) = *(_DWORD *)(v23 - 8);
        *((void *)v25 + 1) = v26;
        v24 -= 24;
        v23 -= 24;
      }
      while ((char *)v23 != v22);
      int64x2_t v27 = *(int64x2_t *)a1;
    }
    uint64_t v12 = v19 + 24;
    *a1 = v25;
    a1[1] = v19 + 24;
    int64x2_t v31 = v27;
    uint64_t v28 = a1[2];
    a1[2] = &v17[24 * v18];
    uint64_t v32 = v28;
    uint64_t v30 = v27.i64[0];
    std::__split_buffer<CI::SWRendererFunctionInputNode>::~__split_buffer((uint64_t)&v30);
  }
  else
  {
    int v10 = *a2;
    uint64_t v11 = *a3;
    *(void *)unint64_t v9 = &unk_1EE456E38;
    *(void *)(v9 + 8) = v11;
    *(_DWORD *)(v9 + 16) = v10;
    uint64_t v12 = (char *)(v9 + 24);
  }
  a1[1] = v12;
  return v12 - 24;
}

char *std::vector<CI::SWRendererFunctionInputNode>::emplace_back<CI::SWArgumentInfoType>(char **a1, int *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (void)*a1) >> 3);
    unint64_t v11 = v10 + 1;
    if (v10 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)*a1) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v11;
    }
    uint64_t v29 = v4;
    unint64_t v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(v4, v13);
    unint64_t v16 = &v14[24 * v10];
    int v17 = *a2;
    *(void *)unint64_t v16 = &unk_1EE456E38;
    *((void *)v16 + 1) = 0;
    *((_DWORD *)v16 + 4) = v17;
    uint64_t v18 = *a1;
    unint64_t v19 = (unint64_t)a1[1];
    if ((char *)v19 == *a1)
    {
      int64x2_t v23 = vdupq_n_s64(v19);
      uint64_t v21 = &v14[24 * v10];
    }
    else
    {
      uint64_t v20 = (uint64_t)&v14[24 * v10 - 24];
      uint64_t v21 = &v14[24 * v10];
      do
      {
        *((void *)v21 - 3) = &unk_1EE456E38;
        v21 -= 24;
        uint64_t v22 = *(void *)(v19 - 16);
        *((_DWORD *)v21 + 4) = *(_DWORD *)(v19 - 8);
        *((void *)v21 + 1) = v22;
        v20 -= 24;
        v19 -= 24;
      }
      while ((char *)v19 != v18);
      int64x2_t v23 = *(int64x2_t *)a1;
    }
    unint64_t v9 = v16 + 24;
    *a1 = v21;
    a1[1] = v16 + 24;
    int64x2_t v27 = v23;
    uint64_t v24 = a1[2];
    a1[2] = &v14[24 * v15];
    uint64_t v28 = v24;
    uint64_t v26 = v23.i64[0];
    std::__split_buffer<CI::SWRendererFunctionInputNode>::~__split_buffer((uint64_t)&v26);
  }
  else
  {
    int v8 = *a2;
    *(void *)unint64_t v7 = &unk_1EE456E38;
    *(void *)(v7 + 8) = 0;
    *(_DWORD *)(v7 + 16) = v8;
    unint64_t v9 = (char *)(v7 + 24);
  }
  a1[1] = v9;
  return v9 - 24;
}

uint64_t std::__split_buffer<CI::SWRendererFunctionInputNode>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void *)(i - 24);
    *(void *)(a1 + 16) = i - 24;
    (*(void (**)(void))(v4 + 8))();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::vector<CI::SWRendererFunctionNode>::__emplace_back_slow_path<CI::SWFunction &,std::vector<CI::SWRendererFunctionInputNode> *&>(uint64_t *a1, long long *a2, uint64_t **a3)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL) {
    abort();
  }
  uint64_t v10 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v11 = 0x8E38E38E38E38E39 * ((v10 - v3) >> 3);
  if (2 * v11 > v5) {
    unint64_t v5 = 2 * v11;
  }
  if (v11 >= 0x1C71C71C71C71C7) {
    unint64_t v12 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v12 = v5;
  }
  uint64_t v20 = v9;
  if (v12) {
    unint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionNode>>(v9, v12);
  }
  else {
    unint64_t v13 = 0;
  }
  unint64_t v16 = v13;
  int v17 = (uint64_t *)&v13[72 * v4];
  uint64_t v18 = v17;
  unint64_t v19 = &v13[72 * v12];
  long long v21 = *a2;
  uint64_t v22 = *((void *)a2 + 2);
  CI::SWRendererFunctionNode::SWRendererFunctionNode(v17, (uint64_t)&v21, *a3);
  uint64_t v18 = v17 + 9;
  std::vector<CI::SWRendererFunctionNode>::__swap_out_circular_buffer(a1, &v16);
  uint64_t v14 = a1[1];
  std::__split_buffer<CI::SWRendererFunctionNode>::~__split_buffer(&v16);
  return v14;
}

void sub_1936D7934(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CI::SWRendererFunctionNode>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t *CI::SWRendererFunctionNode::SWRendererFunctionNode(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)a1, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
  uint64_t v6 = *(void *)(a2 + 16);
  *(_OWORD *)(a1 + 3) = *(_OWORD *)a2;
  uint64_t v7 = *a1;
  a1[5] = v6;
  a1[6] = v7;
  a1[7] = 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3);
  *((unsigned char *)a1 + 64) = 0;
  return a1;
}

uint64_t std::vector<CI::SWRendererFunctionNode>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<CI::SWRendererFunctionNode>,std::reverse_iterator<CI::SWRendererFunctionNode*>,std::reverse_iterator<CI::SWRendererFunctionNode*>,std::reverse_iterator<CI::SWRendererFunctionNode*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionNode>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(72 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<CI::SWRendererFunctionNode>,std::reverse_iterator<CI::SWRendererFunctionNode*>,std::reverse_iterator<CI::SWRendererFunctionNode*>,std::reverse_iterator<CI::SWRendererFunctionNode*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = a7 + v11;
      *(void *)(v12 - 72) = 0;
      *(void *)(v12 - 64) = 0;
      *(void *)(a7 + v11 - 56) = 0;
      std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)(a7 + v11 - 72), *(void *)(a3 + v11 - 72), *(void *)(a3 + v11 - 64), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + v11 - 64) - *(void *)(a3 + v11 - 72)) >> 3));
      uint64_t v13 = *(void *)(a3 + v11 - 32);
      *(_OWORD *)(a7 + v11 - 48) = *(_OWORD *)(a3 + v11 - 48);
      uint64_t v14 = *(void *)(a7 + v11 - 72);
      *(void *)(a7 + v11 - 32) = v13;
      *(void *)(a7 + v11 - 24) = v14;
      *(void *)(a7 + v11 - 16) = *(void *)(a3 + v11 - 16);
      *(unsigned char *)(a7 + v11 - 8) = *(unsigned char *)(a3 + v11 - 8);
      v11 -= 72;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void **std::__split_buffer<CI::SWRendererFunctionNode>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<CI::SWRendererFunctionNode>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    unint64_t v4 = (void **)(i - 72);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](&v5);
  }
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  uint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    uint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

uint64_t std::vector<CI::SWRendererFunctionNode>::__emplace_back_slow_path<CI::SWFunction const&,std::vector<CI::SWRendererFunctionInputNode> *&>(uint64_t *a1, long long *a2, uint64_t **a3)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL) {
    abort();
  }
  uint64_t v10 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v11 = 0x8E38E38E38E38E39 * ((v10 - v3) >> 3);
  if (2 * v11 > v5) {
    unint64_t v5 = 2 * v11;
  }
  if (v11 >= 0x1C71C71C71C71C7) {
    unint64_t v12 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v12 = v5;
  }
  uint64_t v20 = v9;
  if (v12) {
    uint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionNode>>(v9, v12);
  }
  else {
    uint64_t v13 = 0;
  }
  unint64_t v16 = v13;
  int v17 = (uint64_t *)&v13[72 * v4];
  uint64_t v18 = v17;
  unint64_t v19 = &v13[72 * v12];
  long long v21 = *a2;
  uint64_t v22 = *((void *)a2 + 2);
  CI::SWRendererFunctionNode::SWRendererFunctionNode(v17, (uint64_t)&v21, *a3);
  uint64_t v18 = v17 + 9;
  std::vector<CI::SWRendererFunctionNode>::__swap_out_circular_buffer(a1, &v16);
  uint64_t v14 = a1[1];
  std::__split_buffer<CI::SWRendererFunctionNode>::~__split_buffer(&v16);
  return v14;
}

void sub_1936D7D90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CI::SWRendererFunctionNode>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

char *TimerBase::get_and_increment_queue_level(TimerBase *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = (char *)dispatch_queue_get_specific(*((dispatch_queue_t *)this + 4), "com.apple.coreimage.TimerBase.dispatchQueueKey")+ 1;
  dispatch_queue_set_specific(v1, "com.apple.coreimage.TimerBase.dispatchQueueKey", v2, 0);
  return v2;
}

std::string *CI::DAGHelper::TextureReadFunction::TextureReadFunction(std::string *this, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  std::vector<unsigned long>::vector(this[1].__r_.__value_.__r.__words, a3);
  this[2].__r_.__value_.__s.__data_[0] = 0;
  return this;
}

void sub_1936D7E6C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void TimerBase::add_time_at_level(TimerBase *this, int a2, double a3)
{
  uint64_t v3 = *((void *)this + 4);
  if (v3)
  {
    unint64_t v4 = (const void *)(a2 + 0x6369746C0);
    long long v5 = (void *)(((double)(unint64_t)dispatch_queue_get_specific(*((dispatch_queue_t *)this + 4), v4)
                 / 10000000.0
                 + a3)
                * 10000000.0
                + 0.5);
    dispatch_queue_set_specific(v3, v4, v5, 0);
  }
}

__n128 _ci_sampler_builder(uint64_t a1, CI::Object *this, long long *a3, __n128 *a4)
{
  *(void *)a1 = &unk_1EE4569B0;
  if (this) {
    uint64_t v7 = CI::Object::ref((uint64_t)this);
  }
  else {
    uint64_t v7 = 0;
  }
  *(void *)(a1 + 8) = v7;
  long long v8 = *a3;
  long long v9 = a3[1];
  *(void *)(a1 + 48) = *((void *)a3 + 4);
  *(_OWORD *)(a1 + 16) = v8;
  *(_OWORD *)(a1 + 32) = v9;
  __n128 result = *a4;
  *(__n128 *)(a1 + 64) = *a4;
  return result;
}

__n128 CI::SoftwareDAGDescriptor::add_function(uint64_t a1, __n128 *a2)
{
  __n128 result = *a2;
  *(void *)(a1 + 104) = a2[1].n128_u64[0];
  *(__n128 *)(a1 + 88) = result;
  return result;
}

void CI::SoftwareDAGDescriptor::~SoftwareDAGDescriptor(CI::SoftwareDAGDescriptor *this)
{
  CI::SoftwareDAGDescriptor::~SoftwareDAGDescriptor(this);

  JUMPOUT(0x1997023B0);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this = &unk_1EE456E10;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    MEMORY[0x1997023B0](v2, 0x1060C4030F2A1FBLL);
  }
  uint64_t v3 = (void **)((char *)this + 64);
  std::vector<CI::SoftwareDAGDescriptor::ArgumentInfo>::__destroy_vector::operator()[abi:nn180100](&v3);
  uint64_t v3 = (void **)((char *)this + 40);
  std::vector<CI::SWRendererFunctionNode>::__destroy_vector::operator()[abi:nn180100](&v3);
  uint64_t v3 = (void **)((char *)this + 16);
  std::vector<CI::SWRendererFunctionNode>::__destroy_vector::operator()[abi:nn180100](&v3);
}

void std::vector<CI::SoftwareDAGDescriptor::ArgumentInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        std::string::size_type v6 = v4 - 32;
        uint64_t v7 = (void **)(v4 - 24);
        std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](&v7);
        unint64_t v4 = v6;
      }
      while (v6 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<CI::SWRendererFunctionNode>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 9;
        std::string::size_type v6 = v4;
        std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

CI::DAGHelper *CI::DAGHelper::DAGHelper(CI::DAGHelper *this, const CI::SWContext *a2)
{
  v10[6] = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1EE456E60;
  *((void *)this + 2) = a2;
  *((void *)this + 5) = 0;
  *((_OWORD *)this + 3) = xmmword_19394C940;
  *((void *)this + 9) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 1CI::NodeWithChildren::NodeWithChildren(this, 0) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 11) = (char *)this + 96;
  *((void *)this + 15) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = (char *)this + 120;
  *((void *)this + 16) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 17) = (char *)this + 144;
  *((void *)this + 19) = 0;
  std::string::basic_string[abi:nn180100]<0>(v5, "_ci_read_pixel");
  v5[3] = _ci_read_pixel;
  v5[4] = CI::f4_sr2d_f3x3_f2;
  int64x2_t v5[5] = "_ci_read_pixel";
  std::string::basic_string[abi:nn180100]<0>(v6, "_ci_read_pixel_420");
  v6[3] = _ci_read_pixel_420;
  v6[4] = CI::f4_sr2d_f3x3_sr2d_f2_f2;
  int64x2_t v6[5] = "_ci_read_pixel_420";
  std::string::basic_string[abi:nn180100]<0>(v7, "_ci_srgb_to_linear");
  v7[3] = _ci_srgb_to_linear;
  void v7[4] = CI::f4;
  int64x2_t v7[5] = "_ci_srgb_to_linear";
  std::string::basic_string[abi:nn180100]<0>(v8, "_ci_init_destcoord");
  v8[3] = _ci_init_destcoord;
  void v8[4] = 0;
  void v8[5] = "_ci_init_destcoord";
  std::string::basic_string[abi:nn180100]<0>(v9, "_ci_write_pixel");
  void v9[3] = _ci_write_pixel;
  v9[4] = CI::f4_sr2d_f4_gid;
  void v9[5] = "_ci_write_pixel";
  std::string::basic_string[abi:nn180100]<0>(v10, "_ci_linear_to_srgb");
  int64x2_t v10[3] = _ci_linear_to_srgb;
  void v10[4] = CI::f4;
  void v10[5] = "_ci_linear_to_srgb";
  std::map<std::string,CI::SWFunction>::map[abi:nn180100]((uint64_t)this + 160, v5, 6);
  uint64_t v3 = 36;
  do
  {
    if (*((char *)&v5[v3 - 3] - 1) < 0) {
      operator delete(v5[v3 - 6]);
    }
    v3 -= 6;
  }
  while (v3 * 8);
  return this;
}

void sub_1936D83FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v18 = 288;
  while (1)
  {
    if (*(char *)(v12 + v18 - 25) < 0) {
      operator delete(*(void **)(v12 + v18 - 48));
    }
    v18 -= 48;
    if (!v18)
    {
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v13, *v11);
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy(a9, *v16);
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(a10, *v15);
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(a11, *v14);
      _Unwind_Resume(a1);
    }
  }
}

void sub_1936D8490()
{
}

double _ci_read_pixel(uint64x2_t *a1, float32x2_t *a2, double a3, float64x2_t a4, double a5, double a6, int8x16_t a7, int8x16_t a8, int8x16_t a9)
{
  __int32 v9 = a2[4].i32[1];
  if (v9 != 2)
  {
    if (v9 == 1)
    {
      a4.f64[0] = *(float64_t *)a2;
      float32x2_t v10 = a2[1];
      HIDWORD(a4.f64[0]) = a2[2].i32[0];
      v10.i32[1] = a2[2].i32[1];
      a5 = COERCE_DOUBLE(vmla_f32(v10, *(float32x2_t *)&a4.f64[0], *(float32x2_t *)&a3));
      a3 = a5;
    }
    else
    {
      *(float *)&a5 = vmlas_n_f32(vmuls_lane_f32(a2->f32[1], *(float32x2_t *)&a3, 1), a2->f32[0], *(float *)&a3);
      LODWORD(a6) = a2[1].i32[1];
      a8.i32[0] = a2[2].i32[1];
      *(float *)a7.i32 = vmlas_n_f32(vmuls_lane_f32(a2[2].f32[0], *(float32x2_t *)&a3, 1), *(float *)&a6, *(float *)&a3);
      *(float *)&a3 = a2[1].f32[0] + *(float *)&a5;
      *(float *)a4.f64 = *(float *)a8.i32 + *(float *)a7.i32;
      *((float *)&a3 + 1) = *(float *)a8.i32 + *(float *)a7.i32;
    }
  }
  return CI::BitmapSampler::read(a1, a3, a4, a5, a6, a7, a8, a9);
}

void CI::f4_sr2d_f3x3_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  float32x2_t v10 = *(void **)(a1 + 48);
  unint64_t v11 = *(double (**)(uint64_t, char *, double))(a1 + 24);
  uint64_t v12 = *((void *)a2 + 8 * v10[1]);
  uint64_t v13 = v10[4];
  uint64_t v14 = (CI *)(a3 + 16 * v10[7]);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC(v14, a2);
  }
  *(double *)&long long v15 = v11(v12, (char *)a2 + 64 * v13, *(double *)v14);
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

double _ci_read_pixel_420(uint64x2_t *a1, float32x2_t *a2, uint64x2_t *a3, float32x2_t a4, float64x2_t a5, double a6, double a7, int8x16_t a8, int8x16_t a9, int8x16_t a10)
{
  a9.i64[0] = *(void *)&a5.f64[0];
  __int32 v12 = a2[4].i32[1];
  if (v12 != 2)
  {
    if (v12 == 1)
    {
      float32x2_t v13 = *a2;
      float32x2_t v14 = a2[1];
      v13.i32[1] = a2[2].i32[0];
      v14.i32[1] = a2[2].i32[1];
      *(float32x2_t *)&a5.f64[0] = vmla_f32(v14, v13, *(float32x2_t *)a9.i8);
      a9.i64[0] = *(void *)&a5.f64[0];
    }
    else
    {
      LODWORD(a6) = a2[1].i32[1];
      a8.i32[0] = a2[2].i32[1];
      *(float *)&a7 = vmlas_n_f32(vmuls_lane_f32(a2[2].f32[0], *(float32x2_t *)&a5.f64[0], 1), *(float *)&a6, *(float *)a5.f64);
      *(float *)&unint64_t v15 = a2[1].f32[0]
                     + vmlas_n_f32(vmuls_lane_f32(a2->f32[1], *(float32x2_t *)&a5.f64[0], 1), a2->f32[0], *(float *)a5.f64);
      *(float *)a5.f64 = *(float *)a8.i32 + *(float *)&a7;
      *((float *)&v15 + 1) = *(float *)a8.i32 + *(float *)&a7;
      a9.i64[0] = v15;
    }
  }
  float32x2_t v25 = *(float32x2_t *)a9.i8;
  double v16 = CI::BitmapSampler::read(a1, *(double *)a9.i64, a5, a6, a7, a8, a9, a10);
  unsigned int v26 = LODWORD(v16);
  double v23 = CI::BitmapSampler::read(a3, COERCE_DOUBLE(vmul_f32(a4, v25)), v17, v18, v19, v20, v21, v22);
  return COERCE_DOUBLE(__PAIR64__(LODWORD(v23), v26));
}

void CI::f4_sr2d_f3x3_sr2d_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  float32x2_t v10 = *(void **)(a1 + 48);
  unint64_t v11 = *(double (**)(uint64_t, char *, uint64_t, double, double))(a1 + 24);
  uint64_t v12 = *((void *)a2 + 8 * v10[1]);
  uint64_t v13 = v10[4];
  uint64_t v14 = *((void *)a2 + 8 * v10[7]);
  uint64_t v15 = v10[10];
  double v16 = (CI *)(a3 + 16 * v10[13]);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC(v16, a2);
  }
  *(double *)&long long v17 = v11(v12, (char *)a2 + 64 * v13, v14, *((double *)a2 + 8 * v15), *(double *)v16);
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

float32x4_t _ci_srgb_to_linear(float32x4_t a1)
{
  float32x4_t v1 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i64[0] = 0x8000000080000000;
  v2.i64[1] = 0x8000000080000000;
  __asm { FMOV            V0.4S, #1.0 }
  float32x4_t v12 = (float32x4_t)_Q0;
  float32x4_t v13 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v1), (int8x16_t)vcgtzq_f32(v1)), vorrq_s8(vandq_s8((int8x16_t)v1, v2), _Q0), (int8x16_t)0);
  float32x4_t v11 = vabsq_f32(v1);
  simd_float4 v8 = (simd_float4)vaddq_f32(vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3F72A76Eu)), (float32x4_t)vdupq_n_s32(0x3D558919u));
  v8.i32[3] = 0;
  float32x4_t result = (float32x4_t)_simd_pow_f4(v8, (simd_float4)xmmword_19394C950);
  float32x4_t v9 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_n_s32(0x3D25AEE6u), v11), (int8x16_t)0, (int8x16_t)v12);
  result.i64[0] = vmulq_laneq_f32(vmulq_f32(v13, vmlaq_f32(vmulq_f32(vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3D9E8391u)), vsubq_f32(v12, v9)), v9, result)), a1, 3).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

void CI::f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  float32x4_t v9 = (double (*)(void *))a1[3];
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(a1[6] + 8)), a2);
  }
  *(double *)&long long v10 = v9(a1);
  *(_OWORD *)(a3 + 16 * a7) = v10;
}

__n64 _ci_init_destcoord(const mat3 *a1, IPoint a2)
{
  float v2 = (float)a2.var0 + 0.5;
  float v3 = (float)a2.var1 + 0.5;
  result.n64_f32[0] = *((float *)a1 + 2) + (float)((float)(v3 * *((float *)a1 + 1)) + (float)(v2 * *(float *)a1));
  result.n64_f32[1] = *((float *)a1 + 5) + (float)((float)(v3 * *((float *)a1 + 4)) + (float)(v2 * *((float *)a1 + 3)));
  return result;
}

double _ci_write_pixel(CI::BitmapSampler *a1, IPoint a2, __n128 a3)
{
  __n128 v4 = a3;
  CI::BitmapSampler::write(a1, a2, (const vec4 *)&v4);
  return v4.n128_f64[0];
}

void CI::f4_sr2d_f4_gid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  int v10 = *(_DWORD *)(v9 + 40);
  uint64_t v11 = *(void *)(v9 + 32);
  float32x4_t v12 = (__n128 *)(a3 + 16 * v11);
  float32x4_t v13 = (__n128 *)(a2 + (v11 << 6));
  if (v10 == 5) {
    float32x4_t v13 = v12;
  }
  *(double *)&long long v14 = (*(double (**)(uint64_t, void, __n128))(a1 + 24))(a5, *a6, *v13);
  *(_OWORD *)(a3 + 16 * a7) = v14;
}

float32x4_t _ci_linear_to_srgb(float32x4_t a1)
{
  float32x4_t v1 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i64[0] = 0x8000000080000000;
  v2.i64[1] = 0x8000000080000000;
  __asm { FMOV            V0.4S, #1.0 }
  float32x4_t v12 = (float32x4_t)_Q0;
  float32x4_t v13 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v1), (int8x16_t)vcgtzq_f32(v1)), vorrq_s8(vandq_s8((int8x16_t)v1, v2), _Q0), (int8x16_t)0);
  float32x4_t v11 = vabsq_f32(v1);
  simd_float4 v8 = (simd_float4)v11;
  v8.i32[3] = 0;
  float32x4_t result = (float32x4_t)_simd_pow_f4(v8, (simd_float4)xmmword_19394C960);
  float32x4_t v9 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_n_s32(0x3B4D2E1Cu), v11), (int8x16_t)0, (int8x16_t)v12);
  result.i64[0] = vmulq_laneq_f32(vmulq_f32(v13, vmlaq_f32(vmulq_f32(vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x414EB852u)), vsubq_f32(v12, v9)), v9, vaddq_f32(vmulq_f32(result, (float32x4_t)vdupq_n_s32(0x3F870A3Du)), (float32x4_t)vdupq_n_s32(0xBD6147AE)))), a1, 3).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

void CI::DAGHelper::~DAGHelper(char **this)
{
  CI::DAGHelper::~DAGHelper(this);

  JUMPOUT(0x1997023B0);
}

{
  *this = (char *)&unk_1EE456E60;
  std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::destroy((uint64_t)(this + 20), this[21]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 17), this[18]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy((uint64_t)(this + 14), this[15]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 11), this[12]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 8), this[9]);
}

unint64_t CI::BitmapSampler::write(CI::BitmapSampler *this, IPoint a2, const vec4 *a3)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  long long v5 = (uint64_t *)((char *)this + 80);
  unint64_t v4 = *((void *)this + 10);
  if (!v4 || (unint64_t v6 = *((void *)this + 11)) == 0)
  {
    double v64 = ci_logger_render();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR)) {
      CI::BitmapSampler::write(v5, (uint64_t)this, v64);
    }
    goto LABEL_68;
  }
  int var0 = a2.var0;
  int var1 = a2.var1;
  uint64_t v9 = a2.var0;
  _CF = a2.var1 >= v6 || a2.var0 >= v4;
  if (_CF || (*(void *)&a2 & 0x8000000000000000) != 0 || a2.var0 < 0)
  {
    double v65 = ci_logger_render();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
LABEL_72:
      uint64_t v66 = *((void *)this + 10);
      uint64_t v67 = *((void *)this + 11);
      v68[0] = 67109888;
      v68[1] = var0;
      __int16 v69 = 1024;
      int v70 = var1;
      __int16 v71 = 2048;
      uint64_t v72 = v66;
      __int16 v73 = 2048;
      uint64_t v74 = v67;
      _os_log_error_impl(&dword_193671000, v65, OS_LOG_TYPE_ERROR, "Bitmap write error: Writing to point (%d,%d) out of bounds (%zux%zu)", (uint8_t *)v68, 0x22u);
      abort();
    }
LABEL_68:
    abort();
  }
  uint64_t v12 = *((void *)this + 15);
  uint64_t v13 = *((void *)this + 16);
  uint64_t v14 = *((void *)this + 12);
  unint64_t v15 = v14 * v6;
  uint64_t v16 = v14 * a2.var1;
  unint64_t result = CI::format_bytes_per_row(*((_DWORD *)this + 26), a2.var0);
  if (result + v16 > v15)
  {
    double v65 = ci_logger_render();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
      goto LABEL_72;
    }
    goto LABEL_68;
  }
  uint64_t v18 = *((void *)this + 9) + v16 + v12 * v9;
  int v19 = *((_DWORD *)this + 26);
  if ((v19 | 4) == 0x10E)
  {
    float32x4_t v20 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v21.i64[0] = 0x3F0000003F000000;
    v21.i64[1] = 0x3F0000003F000000;
    int16x8_t v22 = (int16x8_t)vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v21, v20, *(float32x4_t *)a3), (float32x4_t)0), v20));
    *(int16x4_t *)v22.i8 = vrev32_s16(vmovn_s32((int32x4_t)v22));
    *(int8x8_t *)v22.i8 = vext_s8(*(int8x8_t *)v22.i8, *(int8x8_t *)v22.i8, 6uLL);
LABEL_12:
    unsigned __int32 v23 = vmovn_s16(v22).u32[0];
LABEL_13:
    *(_DWORD *)uint64_t v18 = v23;
    return result;
  }
  if (!*((unsigned char *)this + 136) && v13 == 8)
  {
    switch(v12)
    {
      case 1:
        float v24 = 255.0;
        float v25 = (float)(*(float *)a3 * 255.0) + 0.5;
        if (v25 <= 255.0) {
          float v24 = (float)(*(float *)a3 * 255.0) + 0.5;
        }
        _NF = v25 < 0.0;
        float v27 = 0.0;
        if (!_NF) {
          float v27 = v24;
        }
        int v28 = (int)v27;
        goto LABEL_40;
      case 2:
        float32x2_t v37 = (float32x2_t)vdup_n_s32(0x437F0000u);
        int32x2_t v38 = vcvt_s32_f32(vminnm_f32(vmaxnm_f32(vmla_f32((float32x2_t)0x3F0000003F000000, v37, *(float32x2_t *)a3), 0), v37));
        *(unsigned char *)(v18 + 1) = v38.i8[4];
        LOBYTE(v28) = v38.i8[0];
LABEL_40:
        *(unsigned char *)uint64_t v18 = v28;
        break;
      case 3:
        float32x4_t v39 = (float32x4_t)vdupq_n_s32(0x437F0000u);
        v40.i64[0] = 0x3F0000003F000000;
        v40.i64[1] = 0x3F0000003F000000;
        int16x4_t v41 = vmovn_s32(vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v40, v39, *(float32x4_t *)a3), (float32x4_t)0), v39)));
        *(unsigned char *)uint64_t v18 = v41.i8[0];
        *(unsigned char *)(v18 + 1) = v41.i8[2];
        *(unsigned char *)(v18 + 2) = v41.i8[4];
        break;
      case 4:
        float32x4_t v42 = (float32x4_t)vdupq_n_s32(0x437F0000u);
        v43.i64[0] = 0x3F0000003F000000;
        v43.i64[1] = 0x3F0000003F000000;
        int16x8_t v22 = (int16x8_t)vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v43, v42, *(float32x4_t *)a3), (float32x4_t)0), v42));
        *(int16x4_t *)v22.i8 = vmovn_s32((int32x4_t)v22);
        goto LABEL_12;
      default:
        return result;
    }
    return result;
  }
  if (!*((unsigned char *)this + 136) && v13 == 16)
  {
    switch(v12)
    {
      case 2:
        float v29 = 65535.0;
        float v30 = (float)(*(float *)a3 * 65535.0) + 0.5;
        if (v30 <= 65535.0) {
          float v29 = (float)(*(float *)a3 * 65535.0) + 0.5;
        }
        _NF = v30 < 0.0;
        float v31 = 0.0;
        if (!_NF) {
          float v31 = v29;
        }
        int v32 = (int)v31;
        goto LABEL_49;
      case 4:
        float32x2_t v51 = (float32x2_t)vdup_n_s32(0x477FFF00u);
        int32x2_t v52 = vcvt_s32_f32(vminnm_f32(vmaxnm_f32(vmla_f32((float32x2_t)0x3F0000003F000000, v51, *(float32x2_t *)a3), 0), v51));
        *(_WORD *)(v18 + 2) = v52.i16[2];
        LOWORD(v32) = v52.i16[0];
LABEL_49:
        *(_WORD *)uint64_t v18 = v32;
        break;
      case 6:
        float32x4_t v53 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
        v54.i64[0] = 0x3F0000003F000000;
        v54.i64[1] = 0x3F0000003F000000;
        float16x4_t v55 = (float16x4_t)vmovn_s32(vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v54, v53, *(float32x4_t *)a3), (float32x4_t)0), v53)));
        goto LABEL_57;
      case 8:
        goto LABEL_64;
      default:
        return result;
    }
    return result;
  }
  if (*((unsigned char *)this + 136) && v13 == 16)
  {
    switch(v12)
    {
      case 2:
        _S0 = *(_DWORD *)a3;
        __asm { FCVT            H0, S0 }
        *(_WORD *)uint64_t v18 = _S0;
        break;
      case 4:
        unsigned __int32 v23 = vcvt_f16_f32(*(float32x4_t *)a3).u32[0];
        goto LABEL_13;
      case 6:
        float16x4_t v55 = vcvt_f16_f32(*(float32x4_t *)a3);
LABEL_57:
        *(_DWORD *)uint64_t v18 = v55.i32[0];
        *(_WORD *)(v18 + 4) = v55.i16[2];
        break;
      case 8:
        float16x4_t v61 = vcvt_f16_f32(*(float32x4_t *)a3);
        goto LABEL_65;
      default:
        return result;
    }
    return result;
  }
  if (*((unsigned char *)this + 136) && v13 == 32)
  {
    *((void *)&v36 + 1) = v12;
    *(void *)&long long v36 = v12 - 4;
    switch((unint64_t)(v36 >> 2))
    {
      case 0uLL:
        *(_DWORD *)uint64_t v18 = *(_DWORD *)a3;
        break;
      case 1uLL:
        *(void *)uint64_t v18 = *(void *)a3;
        break;
      case 2uLL:
        *(_DWORD *)uint64_t v18 = *(_DWORD *)a3;
        *(_DWORD *)(v18 + 4) = *((_DWORD *)a3 + 1);
        *(_DWORD *)(v18 + 8) = *((_DWORD *)a3 + 2);
        break;
      case 3uLL:
        *(_OWORD *)uint64_t v18 = *(_OWORD *)a3;
        break;
      default:
        return result;
    }
    return result;
  }
  if (v19 <= 784)
  {
    if (v19 != 775 && v19 != 784) {
      goto LABEL_62;
    }
LABEL_53:
    float32x4_t v56 = (float32x4_t)vdupq_n_s32(0x447FC000u);
    v57.i64[0] = 0x3F0000003F000000;
    v57.i64[1] = 0x3F0000003F000000;
    int8x16_t v58 = (int8x16_t)vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v57, v56, *(float32x4_t *)a3), (float32x4_t)0), v56));
    v56.i64[0] = 0xFFFF0000FFFFLL;
    v56.i64[1] = 0xFFFF0000FFFFLL;
    int8x16_t v59 = vandq_s8(v58, (int8x16_t)v56);
    __int32 v60 = v58.i32[0];
    v59.i32[0] = vextq_s8(v59, v59, 8uLL).i32[1];
    uint32x2_t v49 = vshl_u32(*(uint32x2_t *)v59.i8, (uint32x2_t)0xA0000001ELL);
    int v50 = v59.i32[2] | (v60 << 20);
    goto LABEL_54;
  }
  if (v19 == 3079 || v19 == 2567) {
    goto LABEL_53;
  }
  if (v19 == 785)
  {
    float32x4_t v44 = (float32x4_t)vdupq_n_s32(0x447FC000u);
    v45.i64[0] = 0x3F0000003F000000;
    v45.i64[1] = 0x3F0000003F000000;
    int8x16_t v46 = (int8x16_t)vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v45, v44, *(float32x4_t *)a3), (float32x4_t)0), v44));
    v44.i64[0] = 0xFFFF0000FFFFLL;
    v44.i64[1] = 0xFFFF0000FFFFLL;
    int8x16_t v47 = vandq_s8(v46, (int8x16_t)v44);
    __int32 v48 = v47.i32[0];
    v47.i32[0] = vextq_s8(v47, v47, 8uLL).i32[1];
    uint32x2_t v49 = vshl_u32(*(uint32x2_t *)v47.i8, (uint32x2_t)0xA0000001ELL);
    int v50 = v48 | (v46.i32[2] << 20);
LABEL_54:
    *(_DWORD *)uint64_t v18 = v50 | v49.i32[0] | v49.i32[1];
    return result;
  }
LABEL_62:
  if (v12 == 8 && v13 == 10)
  {
LABEL_64:
    float32x4_t v62 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    v63.i64[0] = 0x3F0000003F000000;
    v63.i64[1] = 0x3F0000003F000000;
    float16x4_t v61 = (float16x4_t)vmovn_s32(vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v63, v62, *(float32x4_t *)a3), (float32x4_t)0), v62)));
LABEL_65:
    *(float16x4_t *)uint64_t v18 = v61;
  }
  return result;
}

uint64_t std::map<std::string,CI::SWFunction>::map[abi:nn180100](uint64_t a1, void **a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 48 * a3;
    do
    {
      std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,CI::SWFunction> const&>((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 6;
      v6 -= 48;
    }
    while (v6);
  }
  return a1;
}

void sub_1936D9118(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,CI::SWFunction> const&>(uint64_t **a1, uint64_t a2, void **a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__find_equal<std::string>(a1, a2, &v10, &v9, a3);
  unint64_t result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__construct_node<std::pair<std::string const,CI::SWFunction> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

void **std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__find_equal<std::string>(void *a1, uint64_t a2, void ***a3, uint64_t *a4, void **a5)
{
  uint64_t v9 = (void **)(a1 + 1);
  if (a1 + 1 == (void *)a2
    || (std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a5, (void **)(a2 + 32)) & 0x80) != 0)
  {
    if (*a1 == a2)
    {
      uint64_t v12 = (void *)a2;
    }
    else
    {
      float32x4_t v11 = *(void **)a2;
      if (*(void *)a2)
      {
        do
        {
          uint64_t v12 = v11;
          float32x4_t v11 = (void *)v11[1];
        }
        while (v11);
      }
      else
      {
        uint64_t v16 = (void *)a2;
        do
        {
          uint64_t v12 = (void *)v16[2];
          BOOL v17 = *v12 == (void)v16;
          uint64_t v16 = v12;
        }
        while (v17);
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v12 + 4, a5) & 0x80) == 0) {
        goto LABEL_17;
      }
    }
    if (*(void *)a2)
    {
      *a3 = (void **)v12;
      return (void **)(v12 + 1);
    }
    else
    {
      *a3 = (void **)a2;
      return (void **)a2;
    }
  }
  if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>((void *)(a2 + 32), a5) & 0x80) == 0)
  {
    *a3 = (void **)a2;
    *a4 = a2;
    return (void **)a4;
  }
  a4 = (uint64_t *)(a2 + 8);
  uint64_t v13 = *(void *)(a2 + 8);
  if (v13)
  {
    uint64_t v14 = *(void ***)(a2 + 8);
    do
    {
      unint64_t v15 = v14;
      uint64_t v14 = (void **)*v14;
    }
    while (v14);
  }
  else
  {
    int v19 = (void **)a2;
    do
    {
      unint64_t v15 = (void **)v19[2];
      BOOL v17 = *v15 == v19;
      int v19 = v15;
    }
    while (!v17);
  }
  if (v15 == v9)
  {
LABEL_29:
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = (void **)a2;
    }
    return (void **)a4;
  }
  if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a5, v15 + 4) & 0x80) != 0)
  {
    uint64_t v13 = *a4;
    goto LABEL_29;
  }
LABEL_17:

  return (void **)std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
}

__n128 std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__construct_node<std::pair<std::string const,CI::SWFunction> const&>@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x50uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((void *)v6 + 6) = *(void *)(a2 + 16);
  }
  __n128 result = *(__n128 *)(a2 + 24);
  *(__n128 *)(v6 + 56) = result;
  *((void *)v6 + 9) = *(void *)(a2 + 40);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1936D93E0(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,CI::SWFunction>,void *>>>::operator()[abi:nn180100](v3, v2);
  _Unwind_Resume(a1);
}

void *std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__find_equal<std::string>(uint64_t a1, void *a2, void **a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = v4;
        simd_float4 v8 = v4 + 4;
        if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, (void **)v4 + 4) & 0x80) == 0) {
          break;
        }
        uint64_t v4 = (void *)*v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a3) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, void **a2)
{
  size_t v2 = *((unsigned __int8 *)a1 + 23);
  size_t v3 = a1[1];
  if ((v2 & 0x80u) != 0)
  {
    a1 = (void *)*a1;
    size_t v2 = v3;
  }
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = *a2;
  }
  if (v4 >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  return std::operator<=>[abi:nn180100]<char,std::char_traits<char>>(a1, v2, v5, v6);
}

uint64_t std::operator<=>[abi:nn180100]<char,std::char_traits<char>>(const void *a1, size_t a2, void *__s2, size_t a4)
{
  if (a4 >= a2) {
    size_t v7 = a2;
  }
  else {
    size_t v7 = a4;
  }
  int v8 = memcmp(a1, __s2, v7);
  if (v8)
  {
    if ((v8 & 0x80000000) == 0) {
      return 1;
    }
  }
  else
  {
    if (a2 == a4) {
      return 0;
    }
    if (a2 >= a4) {
      return 1;
    }
  }
  return 255;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,CI::SWFunction>,void *>>>::operator()[abi:nn180100](uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0) {
      operator delete(__p[4]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::destroy(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

void **std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::find<std::string>(uint64_t a1, void **a2)
{
  size_t v2 = (void **)(a1 + 8);
  size_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = (void **)(a1 + 8);
  do
  {
    char v6 = std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v3 + 4, a2);
    if (v6 >= 0) {
      size_t v7 = v3;
    }
    else {
      size_t v7 = v3 + 1;
    }
    if (v6 >= 0) {
      uint64_t v5 = (void **)v3;
    }
    size_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2
    || (std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) != 0)
  {
    return v2;
  }
  return v5;
}

uint64_t *std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  char v6 = (uint64_t **)(a1 + 8);
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = (uint64_t *)*v8;
        char v6 = (uint64_t **)v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = (uint64_t *)v8[1];
      if (!v5)
      {
        char v6 = (uint64_t **)(v8 + 1);
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v8 = (uint64_t *)(a1 + 8);
LABEL_10:
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a1, a4, (uint64_t)v11);
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v8, v6, v11[0]);
    int v8 = v11[0];
    v11[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>>>>::reset[abi:nn180100]((uint64_t)v11, 0);
  }
  return v8;
}

void *std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, void **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  char v6 = operator new(0x60uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  v6[4] = **a2;
  __n128 result = std::string::basic_string[abi:nn180100]<0>(v6 + 5, "");
  void v6[8] = 0;
  v6[9] = 0;
  *((unsigned char *)v6 + 88) = 0;
  v6[10] = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1936D9824(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>>>>::reset[abi:nn180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t CI::getDC(CI *this)
{
  return CI::_thread_dc();
}

void *CI::setDC(CI *this, const vec2 *a2)
{
  __n128 result = (void *)CI::_thread_dc();
  *__n128 result = *v3;
  return result;
}

double CI::SWRendererPipeline::initSamplers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 24))
  {
    uint64_t v3 = a3;
    unint64_t v6 = 0;
    uint64_t v7 = 48;
    uint64_t v8 = a3;
    do
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 8) + v7);
      uint64_t v10 = *(void *)(a2 + (*(void *)(v9 + 8) << 6));
      float32x4_t v11 = (long long *)(a2 + (*(void *)(v9 + 32) << 6));
      long long v13 = *v11;
      long long v14 = v11[1];
      long long v15 = v11[2];
      long long v16 = v11[3];
      *(void *)uint64_t v3 = &unk_1EE4569B0;
      if (v10) {
        uint64_t v10 = CI::Object::ref(v10);
      }
      *(void *)(v3 + 8) = v10;
      *(_OWORD *)(v3 + 16) = v13;
      *(_OWORD *)(v3 + 32) = v14;
      *(void *)(v3 + 48) = v15;
      double result = *(double *)&v16;
      *(_OWORD *)(v3 + 64) = v16;
      ++v6;
      v3 += 80;
      v7 += 72;
      v8 += 80;
    }
    while (*(void *)(a1 + 24) > v6);
  }
  return result;
}

uint64_t CI::SWRendererPipeline::execute(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, int *a6)
{
  unint64_t v6 = (float *)(a2 + (*(void *)(*(void *)(*a1 + 48) + 8) << 6));
  float v7 = (float)*a6 + 0.5;
  float v8 = (float)a6[1] + 0.5;
  *(float *)&uint64_t v9 = v6[2] + (float)((float)(v6[1] * v8) + (float)(v7 * *v6));
  *((float *)&v9 + 1) = v6[5] + (float)((float)(v8 * v6[4]) + (float)(v7 * v6[3]));
  *a3 = v9;
  if (a1[2] >= 2uLL)
  {
    unint64_t v16 = 1;
    uint64_t v17 = 104;
    do
    {
      (*(void (**)(uint64_t, uint64_t, void *, uint64_t, uint64_t, int *, unint64_t))(*a1 + v17))(*a1 + v17 - 32, a2, a3, a4, a5, a6, v16++);
      v17 += 72;
    }
    while (a1[2] > v16);
  }
  return 1;
}

const char *acLog(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  double result = getenv("CI_DEBUG_AUTOCROP");
  if (result)
  {
    double result = (const char *)atoi(result);
    if (result) {
      return (const char *)vfprintf((FILE *)*MEMORY[0x1E4F143C8], a1, &a9);
    }
  }
  return result;
}

char *BGHashMapCreate(unsigned int a1)
{
  size_t v2 = (char *)malloc_type_malloc(16 * a1 + 24, 0x344C54A3uLL);
  uint64_t v3 = v2 + 24;
  *(void *)size_t v2 = v2 + 24;
  *((_DWORD *)v2 + 2) = a1;
  *((void *)v2 + 2) = 0;
  if (a1)
  {
    uint64_t v4 = a1;
    do
    {
      *uint64_t v3 = 0;
      v3 += 16;
      --v4;
    }
    while (v4);
  }
  uint64_t v5 = malloc_type_malloc(0x1D4D8uLL, 0x61CF12B5uLL);
  *uint64_t v5 = v5 + 3;
  v5[1] = 5000;
  v5[2] = 0;
  *((void *)v2 + 2) = v5;
  return v2;
}

void BGHashMapRelease(void *a1)
{
  if (a1)
  {
    size_t v2 = (void *)a1[2];
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)v2[2];
        free(v2);
        size_t v2 = v3;
      }
      while (v3);
    }
    free(a1);
  }
}

void BGHashClear(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void **)(v2 + 16);
  if (v3)
  {
    do
    {
      uint64_t v4 = (void *)v3[2];
      free(v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
  *(_DWORD *)(v2 + 12) = 0;
  *(void *)(v2 + 16) = 0;
  uint64_t v5 = *(void **)a1;
  size_t v6 = 16 * *(unsigned int *)(a1 + 8);

  bzero(v5, v6);
}

uint64_t BGHashFindKey(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v3 = BYTE2(a2) | (BYTE2(a2) << 8);
  if (!*(unsigned char *)(*(void *)a1
                 + 16
                 * ((257 * (16974593 * a2 + BYTE3(a2) + 66049 * BYTE1(a2) + v3) + BYTE4(a2) + 842144005)
                  % *(_DWORD *)(a1 + 8))))
    return 0;
  uint64_t v4 = *(void *)(*(void *)a1
                 + 16
                 * ((257 * (16974593 * a2 + BYTE3(a2) + 66049 * BYTE1(a2) + v3) + BYTE4(a2) + 842144005)
                  % *(_DWORD *)(a1 + 8))
                 + 8);
  if (!v4) {
    return 0;
  }
  while (*(void *)v4 != a2)
  {
    uint64_t v4 = *(void *)(v4 + 16);
    if (!v4) {
      return 0;
    }
  }
  *a3 = *(_DWORD *)(v4 + 8);
  return 1;
}

char *BGHashSetValue(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = (257 * (16974593 * a2 + BYTE3(a2) + 66049 * BYTE1(a2) + (BYTE2(a2) | (BYTE2(a2) << 8)))
      + BYTE4(a2)
      + 842144005)
     % *(_DWORD *)(a1 + 8);
  uint64_t v6 = *(void *)a1;
  float v7 = (unsigned char *)(*(void *)a1 + 16 * v5);
  int v8 = *v7;
  double result = bgNewLinkedListEntry(a1);
  if (v8)
  {
    *((void *)result + 2) = *(void *)(v6 + 16 * v5 + 8);
  }
  else
  {
    *((void *)result + 2) = 0;
    *float v7 = 1;
  }
  *(void *)double result = a2;
  *((_DWORD *)result + 2) = a3;
  *(void *)(v6 + 16 * v5 + 8) = result;
  return result;
}

char *bgNewLinkedListEntry(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 16);
  unsigned int v3 = v2[3];
  if (v3 == v2[2])
  {
    uint64_t v2 = malloc_type_malloc(24 * v3 + 24, 0x61CF12B5uLL);
    uint64_t v4 = (char *)(v2 + 6);
    *(void *)uint64_t v2 = v2 + 6;
    v2[2] = v3;
    v2[3] = 0;
    *((void *)v2 + 2) = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v2;
    unsigned int v3 = 0;
  }
  else
  {
    uint64_t v4 = *(char **)v2;
  }
  v2[3] = v3 + 1;
  return &v4[24 * v3];
}

unint64_t hash3(unsigned __int8 *a1)
{
  return ((unint64_t)a1[2] << 16) | ((unint64_t)a1[1] << 8) | *a1;
}

unint64_t hash5(unsigned __int8 *a1)
{
  return *a1 | ((unint64_t)*(unsigned int *)(a1 + 1) << 8);
}

uint64_t hash_shift(uint64_t a1, int a2, int a3)
{
  v5[1] = 0;
  v5[2] = 0;
  v5[0] = a1;
  unsigned int v3 = *((unsigned __int8 *)v5 + a2) + a3;
  if (v3 > 0xFF) {
    return -1;
  }
  *((unsigned char *)v5 + a2) = v3;
  return v5[0];
}

unint64_t hash_pad(int a1)
{
  return ((unint64_t)(a1 & 0x80) << 49) | ((((unint64_t)(a1 & 0x40) >> 6) & 1) << 48) | ((((unint64_t)(a1 & 0x20) >> 5) & 1) << 40) | ((((unint64_t)(a1 & 0x10) >> 4) & 1) << 32) | (a1 << 21) & 0x1000000 | (unint64_t)((a1 << 14) & 0x10000) | (a1 << 7) & 0x100 | (unint64_t)(a1 & 1);
}

void sub_1936DD3A4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1936DD4C0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1936DD924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *zmalloc(size_t a1)
{
  return malloc_type_malloc(a1, 0x4A7C05C1uLL);
}

void *zcalloc(size_t a1, size_t a2)
{
  return malloc_type_calloc(a1, a2, 0x293D63F1uLL);
}

void *initBitmap(uint64_t a1, int a2, int a3, int a4, int a5, float a6)
{
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(float *)(a1 + 36) = a6;
  int v7 = a4 * a2 * a5;
  *(_DWORD *)(a1 + 16) = a4 * a2;
  *(_DWORD *)(a1 + 2CI::NodeWithChildren::NodeWithChildren(this, 0) = v7;
  *(_DWORD *)(a1 + 24) = v7 * a3;
  double result = malloc_type_malloc(v7 * a3, 0x4A7C05C1uLL);
  *(void *)a1 = result;
  return result;
}

void termBitmap(void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    free(v2);
  }
  *a1 = 0;
}

uint64_t constructBitmap(uint64_t result, uint64_t a2, int a3, int a4, int a5, int a6, int a7, float a8)
{
  *(void *)double result = a2;
  *(_DWORD *)(result + 8) = a3;
  *(_DWORD *)(result + 12) = a4;
  *(_DWORD *)(result + 28) = a5;
  *(_DWORD *)(result + 32) = a6;
  *(float *)(result + 36) = a8;
  *(_DWORD *)(result + 16) = a7 / a6;
  *(_DWORD *)(result + 2CI::NodeWithChildren::NodeWithChildren(this, 0) = a7;
  *(_DWORD *)(result + 24) = a7 * a4;
  return result;
}

float constructSliceBitmap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5 = *(_DWORD *)(a1 + 16);
  int v4 = *(_DWORD *)(a1 + 20);
  int v6 = *(_DWORD *)(a1 + 28);
  int v7 = *(_DWORD *)(a1 + 32);
  *(void *)a2 = *(void *)a1 + v4 * (int)a3 + v6 * (int)a4 * v7;
  *(_DWORD *)(a2 + 8) = HIDWORD(a4) - a4;
  *(_DWORD *)(a2 + 12) = HIDWORD(a3) - a3;
  *(_DWORD *)(a2 + 16) = v5;
  *(_DWORD *)(a2 + 2CI::NodeWithChildren::NodeWithChildren(this, 0) = v4;
  *(_DWORD *)(a2 + 24) = v4 * (HIDWORD(a3) - a3);
  *(_DWORD *)(a2 + 28) = v6;
  *(_DWORD *)(a2 + 32) = v7;
  float result = *(float *)(a1 + 36);
  *(float *)(a2 + 36) = result;
  return result;
}

BOOL bilinearLookupTest(uint64_t a1, float a2, float a3)
{
  BOOL result = 0;
  if (a2 >= 0.0 && a3 >= 0.0) {
    return (float)(*(_DWORD *)(a1 + 8) - 1) >= a2 && (float)(*(_DWORD *)(a1 + 12) - 1) >= a3;
  }
  return result;
}

uint64_t bilinearLookup(uint64_t a1, float a2, float a3)
{
  float v3 = 0.0;
  float v4 = 0.0;
  if (a2 >= 0.0)
  {
    float v4 = a2;
    if ((float)(*(_DWORD *)(a1 + 8) - 1) < a2) {
      float v4 = (float)(*(_DWORD *)(a1 + 8) - 1);
    }
  }
  int v5 = *(_DWORD *)(a1 + 12);
  if (a3 >= 0.0)
  {
    float v3 = a3;
    if ((float)(v5 - 1) < a3) {
      float v3 = (float)(v5 - 1);
    }
  }
  int v6 = vcvtms_s32_f32(v4);
  signed int v7 = vcvtms_s32_f32(v3);
  if (*(_DWORD *)(a1 + 8) - 2 < v6) {
    int v6 = *(_DWORD *)(a1 + 8) - 2;
  }
  int v8 = v5 - 2;
  if (v8 >= v7) {
    int v8 = v7;
  }
  float v9 = v4 - (float)v6;
  float v10 = v3 - (float)v8;
  uint64_t v11 = *(int *)(a1 + 16);
  uint64_t v12 = *(int *)(a1 + 28);
  long long v13 = (unsigned __int8 *)(*(void *)a1 + v8 * (int)v11 + (int)v12 * v6);
  float v14 = (float)*v13 + (float)((float)(v13[v12] - *v13) * v9);
  return (int)rintf(v14+ (float)((float)((float)((float)v13[v11]+ (float)((float)(v13[(int)v12 + (int)v11] - v13[v11]) * v9))- v14)* v10));
}

uint64_t bilinearLookupAccurate(uint64_t a1, float a2, float a3)
{
  float v3 = 0.0;
  float v4 = 0.0;
  if (a2 >= 0.0)
  {
    float v4 = a2;
    if ((float)(*(_DWORD *)(a1 + 8) - 1) < a2) {
      float v4 = (float)(*(_DWORD *)(a1 + 8) - 1);
    }
  }
  int v5 = *(_DWORD *)(a1 + 12);
  if (a3 >= 0.0)
  {
    float v3 = a3;
    if ((float)(v5 - 1) < a3) {
      float v3 = (float)(v5 - 1);
    }
  }
  int v6 = vcvtms_s32_f32(v4);
  signed int v7 = vcvtms_s32_f32(v3);
  if (*(_DWORD *)(a1 + 8) - 2 < v6) {
    int v6 = *(_DWORD *)(a1 + 8) - 2;
  }
  int v8 = v5 - 2;
  if (v8 >= v7) {
    int v8 = v7;
  }
  int v9 = (int)rintf((float)(v4 - (float)v6) * 64.0);
  float v10 = rintf((float)(v3 - (float)v8) * 64.0);
  uint64_t v11 = *(int *)(a1 + 16);
  uint64_t v12 = *(int *)(a1 + 28);
  long long v13 = (unsigned __int8 *)(*(void *)a1 + v8 * (int)v11 + (int)v12 * v6);
  int v14 = v13[v11];
  LODWORD(v11) = v13[(int)v12 + (int)v11];
  LODWORD(v13) = *v13 + (((v13[v12] - *v13) * v9 + 32) >> 6);
  return ((v14 - v13 + ((((int)v11 - v14) * v9 + 32) >> 6)) * (int)v10 + (v13 << 6));
}

double bilinearCbCrLookup(uint64_t a1, float a2, float a3)
{
  float v3 = 0.0;
  float v4 = 0.0;
  if (a2 >= 0.0)
  {
    float v4 = a2;
    if ((float)(*(_DWORD *)(a1 + 8) - 1) < a2) {
      float v4 = (float)(*(_DWORD *)(a1 + 8) - 1);
    }
  }
  int v5 = *(_DWORD *)(a1 + 12);
  if (a3 >= 0.0)
  {
    float v3 = a3;
    if ((float)(v5 - 1) < a3) {
      float v3 = (float)(v5 - 1);
    }
  }
  int v6 = vcvtms_s32_f32(v4);
  signed int v7 = vcvtms_s32_f32(v3);
  if (*(_DWORD *)(a1 + 8) - 2 < v6) {
    int v6 = *(_DWORD *)(a1 + 8) - 2;
  }
  int v8 = v5 - 2;
  if (v8 >= v7) {
    int v8 = v7;
  }
  float v9 = v4 - (float)v6;
  float v10 = v3 - (float)v8;
  uint64_t v11 = *(int *)(a1 + 16);
  uint64_t v12 = *(int *)(a1 + 28);
  long long v13 = (unsigned __int8 *)(*(void *)a1 + v8 * (int)v11 + (int)v12 * v6);
  float v14 = (float)*v13 + (float)((float)(v13[v12] - *v13) * v9);
  return (double)(uint64_t)rintf(v14+ (float)((float)((float)((float)v13[v11]+ (float)((float)(v13[(int)v12 + (int)v11] - v13[v11]) * v9))- v14)* v10));
}

float bilinearARGB8LookupComponents(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, float a6, float a7)
{
  float v7 = 0.0;
  float v8 = 0.0;
  if (a6 >= 0.0)
  {
    float v8 = a6;
    if ((float)(*(_DWORD *)(a1 + 8) - 1) < a6) {
      float v8 = (float)(*(_DWORD *)(a1 + 8) - 1);
    }
  }
  int v9 = *(_DWORD *)(a1 + 12);
  if (a7 >= 0.0)
  {
    float v7 = a7;
    if ((float)(v9 - 1) < a7) {
      float v7 = (float)(v9 - 1);
    }
  }
  int v10 = vcvtms_s32_f32(v8);
  signed int v11 = vcvtms_s32_f32(v7);
  if (*(_DWORD *)(a1 + 8) - 2 < v10) {
    int v10 = *(_DWORD *)(a1 + 8) - 2;
  }
  int v12 = v9 - 2;
  if (v12 >= v11) {
    int v12 = v11;
  }
  float v13 = v8 - (float)v10;
  float v14 = v7 - (float)v12;
  uint64_t v15 = *(int *)(a1 + 16);
  uint64_t v16 = *(int *)(a1 + 28);
  uint64_t v17 = (unsigned __int8 *)(*(void *)a1 + v12 * (int)v15 + (int)v16 * v10);
  unsigned int v18 = *v17;
  unsigned int v19 = v17[1];
  unsigned int v20 = v17[2];
  unsigned int v21 = v17[3];
  int v22 = v17[v16];
  int v23 = v17[v16 + 1];
  int v24 = v17[v16 + 2];
  int v25 = v17[v16 + 3];
  unsigned int v26 = v17[v15];
  unsigned int v27 = v17[v15 + 1];
  unsigned int v28 = v17[v15 + 2];
  unsigned int v29 = v17[v15 + 3];
  float v30 = &v17[(int)v16 + (int)v15];
  LODWORD(v15) = *v30;
  LODWORD(v16) = v30[1];
  int v31 = v30[2];
  LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = v30[3];
  float v32 = (float)v18 + (float)((float)(int)(v22 - v18) * v13);
  *a2 = (int)rintf(v32 + (float)((float)((float)((float)v26 + (float)((float)(int)(v15 - v26) * v13)) - v32) * v14));
  float v33 = (float)v19 + (float)((float)(int)(v23 - v19) * v13);
  *a3 = (int)rintf(v33 + (float)((float)((float)((float)v27 + (float)((float)(int)(v16 - v27) * v13)) - v33) * v14));
  float v34 = (float)v20 + (float)((float)(int)(v24 - v20) * v13);
  *a4 = (int)rintf(v34 + (float)((float)((float)((float)v28 + (float)((float)(int)(v31 - v28) * v13)) - v34) * v14));
  float v35 = (float)v21 + (float)((float)(int)(v25 - v21) * v13);
  float result = rintf(v35 + (float)((float)((float)((float)v29 + (float)((float)(int)(v30 - v29) * v13)) - v35) * v14));
  *a5 = (int)result;
  return result;
}

int *copySliceOfBitmapToBitmap(int *result, char **a2, uint64_t a3, uint64_t a4)
{
  if (result[8] == *((_DWORD *)a2 + 8) && (float v4 = result, result[7] == *((_DWORD *)a2 + 7)))
  {
    int v5 = HIDWORD(a3) - a3;
    if (SHIDWORD(a3) > (int)a3)
    {
      int v6 = a4;
      int v7 = HIDWORD(a4) - a4;
      float v8 = *a2;
      uint64_t v9 = result[5];
      uint64_t v10 = *(void *)result + (int)v9 * (uint64_t)(int)a3;
      uint64_t v11 = *((int *)a2 + 5);
      do
      {
        int v12 = v4[8] * v4[7];
        float result = (int *)memmove(v8, (const void *)(v10 + v12 * v6), v12 * v7);
        v10 += v9;
        v8 += v11;
        --v5;
      }
      while (v5);
    }
  }
  else
  {
    return (int *)puts("copySliceOfBitmapToBitmap: bytes per sample or samples per pixel differs!");
  }
  return result;
}

int *copyBitmapToSliceOfBitmap(int *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result[8] == *(_DWORD *)(a2 + 32) && (int v5 = result, result[7] == *(_DWORD *)(a2 + 28)))
  {
    int v6 = HIDWORD(a3) - a3;
    if (SHIDWORD(a3) > (int)a3)
    {
      int v7 = a4;
      int v8 = HIDWORD(a4) - a4;
      uint64_t v9 = *(int *)(a2 + 20);
      uint64_t v10 = *(void *)a2 + (int)v9 * (uint64_t)(int)a3;
      uint64_t v11 = *(char **)result;
      uint64_t v12 = result[5];
      do
      {
        float result = (int *)memmove((void *)(v10 + *(int *)(a2 + 28) * (uint64_t)v7 * *(int *)(a2 + 32)), v11, v5[7] * (uint64_t)v8 * v5[8]);
        v11 += v12;
        v10 += v9;
        --v6;
      }
      while (v6);
    }
  }
  else
  {
    return (int *)puts("copyBitmapToSliceOfBitmap: bytes per sample or samples per pixel differs!");
  }
  return result;
}

unint64_t bitmapToBitmapDifferenceBitmapRect(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, int8x8_t a7)
{
  int v7 = *(_DWORD *)(a1 + 12);
  if (v7 < 1) {
    return 0;
  }
  char v8 = 0;
  unsigned int v9 = 0;
  uint64_t v10 = (*(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28));
  uint64_t v11 = *(unsigned __int8 **)a2;
  uint64_t v12 = *(unsigned __int8 **)a1;
  uint64_t v13 = *(int *)(a1 + 20);
  int v14 = *(_DWORD *)(a1 + 8);
  if (v14 <= 1) {
    int v15 = 1;
  }
  else {
    int v15 = *(_DWORD *)(a1 + 8);
  }
  int32x2_t v16 = 0;
  int32x2_t v17 = 0;
  do
  {
    if (v14 >= 1)
    {
      if (v10 > 8 || ((1 << v10) & 0x116) == 0)
      {
        puts("bitmapToBitmapDifferenceBitmapRect: source pixel configuration illegal");
        return 0;
      }
      unsigned int v18 = 0;
      unsigned int v19 = v11;
      unsigned int v20 = v12;
      int32x2_t v21 = v16;
      do
      {
        switch(v10)
        {
          case 4:
            if (*v20 != *v19
              || (v20[1] == v19[1] ? (BOOL v22 = v20[2] == v19[2]) : (BOOL v22 = 0),
                  v22 ? (BOOL v23 = v20[3] == v19[3]) : (BOOL v23 = 0),
                  !v23))
            {
LABEL_35:
              int32x2_t v16 = (int32x2_t)__PAIR64__(v18, v9);
              if (v8)
              {
                a7 = (int8x8_t)vcgt_s32(v17, (int32x2_t)__PAIR64__(v18, v9));
                int32x2_t v17 = vmin_s32((int32x2_t)__PAIR64__(v18, v9), v17);
                int32x2_t v16 = (int32x2_t)vbsl_s8(a7, (int8x8_t)v21, (int8x8_t)vmax_s32((int32x2_t)__PAIR64__(v18, v9), v21));
                char v8 = 1;
              }
              else
              {
                char v8 = 1;
                int32x2_t v17 = (int32x2_t)__PAIR64__(v18, v9);
              }
              goto LABEL_38;
            }
            break;
          case 2:
            if (*v20 != *v19 || v20[1] != v19[1]) {
              goto LABEL_35;
            }
            break;
          case 1:
            if (*v20 != *v19) {
              goto LABEL_35;
            }
            break;
          default:
            if (*v20 != *v19) {
              goto LABEL_35;
            }
            v16.i32[0] = *(_DWORD *)(v19 + 1);
            a7.i32[0] = *(_DWORD *)(v20 + 1);
            a7 = (int8x8_t)vmovl_u8((uint8x8_t)a7).u64[0];
            if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16((int16x4_t)vmvn_s8((int8x8_t)vceq_s16((int16x4_t)a7, (int16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v16))), 0xFuLL))) & 1) != 0|| v20[5] != v19[5]|| v20[6] != v19[6]|| v20[7] != v19[7])
            {
              goto LABEL_35;
            }
            break;
        }
        int32x2_t v16 = v21;
LABEL_38:
        ++v18;
        v20 += v10;
        v19 += *(int *)(a2 + 32) * (uint64_t)*(int *)(a2 + 28);
        int32x2_t v21 = v16;
      }
      while (v15 != v18);
    }
    ++v9;
    v12 += v13;
    v11 += *(int *)(a2 + 20);
  }
  while (v9 != v7);
  if (v8)
  {
    v25.i64[0] = v17.u32[0];
    v25.i64[1] = v17.u32[1];
    return vorrq_s8((int8x16_t)vshll_n_s32(vadd_s32(v16, (int32x2_t)0x100000001), 0x20uLL), v25).u64[0];
  }
  return 0;
}

unint64_t makeBitmapRect(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  return a2 | (unint64_t)(a4 << 32);
}

unint64_t insetBitmapRect(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return (a1 + a4) | ((unint64_t)(HIDWORD(a1) - a4) << 32);
}

unint64_t offsetBitmapRect(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return (a1 + a4) | ((unint64_t)(HIDWORD(a1) + a4) << 32);
}

uint64_t intersectBitmapRects(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((int)a1 <= (int)a3) {
    uint64_t v3 = a3;
  }
  else {
    uint64_t v3 = a1;
  }
  if (SHIDWORD(a1) >= SHIDWORD(a3)) {
    uint64_t v4 = HIDWORD(a3);
  }
  else {
    uint64_t v4 = HIDWORD(a1);
  }
  return v3 | (v4 << 32);
}

uint64_t unionBitmapRects(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((int)a1 >= (int)a3) {
    uint64_t v3 = a3;
  }
  else {
    uint64_t v3 = a1;
  }
  if (SHIDWORD(a1) <= SHIDWORD(a3)) {
    uint64_t v4 = HIDWORD(a3);
  }
  else {
    uint64_t v4 = HIDWORD(a1);
  }
  return v3 | (v4 << 32);
}

unint64_t halfBitmapRect(uint64_t a1)
{
  if ((int)a1 >= 0) {
    int v1 = a1;
  }
  else {
    int v1 = a1 + 1;
  }
  return (v1 >> 1) | ((unint64_t)(SHIDWORD(a1) / 2) << 32);
}

unint64_t twiceBitmapRect(uint64_t a1)
{
  return (2 * a1) & 0xFFFFFFFEFFFFFFFELL;
}

unint64_t evenBitmapRect(uint64_t a1)
{
  return (a1 + 0x100000000) & 0xFFFFFFFE00000000 | a1 & 0xFFFFFFFE;
}

double alignedBitmapRectAroundPoint(unsigned int a1, unsigned int a2, unsigned int a3)
{
  int32x2_t v3 = vdup_n_s32(a3);
  int32x2_t v4 = vadd_s32(v3, (int32x2_t)__PAIR64__(a1, a2));
  int8x8_t v5 = (int8x8_t)vadd_s32(v4, (int32x2_t)0x100000001);
  unint64_t v6 = *(void *)&vsub_s32((int32x2_t)__PAIR64__(a1, a2), v3) & 0xFFFFFFFEFFFFFFFELL;
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  *(void *)&double result = vorrq_s8((int8x16_t)vshll_n_s32((int32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)vand_s8(v5, (int8x8_t)0x100000001)), v5, (int8x8_t)vadd_s32((int32x2_t)(*(void *)&v4 & 0xFFFFFFFEFFFFFFFELL), (int32x2_t)0x200000002)), 0x20uLL), v7).u64[0];
  return result;
}

unint64_t clipBitmapRectToBitmapBounds(unint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = HIDWORD(a1);
  if ((int)(*(_DWORD *)(a3 + 12) & 0xFFFFFFFE) < SHIDWORD(a1)) {
    LODWORD(v3) = *(_DWORD *)(a3 + 12) & 0xFFFFFFFE;
  }
  return a1 & ~((int)a1 >> 31) | ((unint64_t)(v3
                                                                 - (((_BYTE)v3
                                                                   - (a1 & ~((int)a1 >> 31))) & 1)) << 32);
}

uint64_t clipBitmapRectToWidthAndHeight(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = a1;
  if ((int)(a4 & 0xFFFFFFFE) >= SHIDWORD(a1)) {
    uint64_t v5 = HIDWORD(a1);
  }
  else {
    uint64_t v5 = a4 & 0xFFFFFFFE;
  }
  if ((int)a1 < 0) {
    uint64_t v4 = 0;
  }
  return v4 | (v5 << 32);
}

uint64_t applyMaxFilter8(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 8) < a2) {
    return 1;
  }
  int v3 = *(_DWORD *)(a1 + 12);
  if (v3 < a2) {
    return 1;
  }
  uint64_t v4 = *(int *)(a1 + 16);
  uint64_t v5 = *(int *)(a1 + 28);
  if (a2 >= 0) {
    int v6 = a2;
  }
  else {
    int v6 = a2 + 1;
  }
  if (v3 <= (int)v4) {
    int v3 = *(_DWORD *)(a1 + 16);
  }
  uint64_t result = (uint64_t)malloc_type_calloc(v3, 1uLL, 0x293D63F1uLL);
  if (result)
  {
    int v9 = -(v6 >> 1);
    int v10 = a2 - (v6 >> 1);
    int v11 = *(_DWORD *)(a1 + 12);
    int v12 = a2;
    if (v11 >= 1)
    {
      int v13 = 0;
      int v14 = 0;
      int v15 = *(char **)a1;
      int v16 = v6 >> 1;
      if ((v6 >> 1) + 1 <= 1) {
        int v17 = 1;
      }
      else {
        int v17 = (v6 >> 1) + 1;
      }
      uint64_t v64 = result;
      int v65 = v12;
      uint64_t v63 = (int)v5 * (uint64_t)v12;
      do
      {
        int v67 = v14;
        uint64_t v66 = v15;
        memmove((void *)result, v15, *(int *)(a1 + 8));
        if ((int)v5 < 1)
        {
          uint64_t result = v64;
          int v12 = v65;
          int v19 = v67;
          unsigned int v20 = v66;
        }
        else
        {
          uint64_t v18 = 0;
          uint64_t result = v64;
          int v12 = v65;
          int v19 = v67;
          unsigned int v20 = v66;
          uint64_t v62 = v5 * (v9 - 1);
          do
          {
            uint64_t v21 = v64 + v18;
            BOOL v22 = &v66[v18];
            if (v65 < -1)
            {
              int v28 = 0;
            }
            else
            {
              int v23 = 0;
              int v24 = -(v6 >> 1);
              do
              {
                if (v23 <= v16) {
                  int v25 = v6 >> 1;
                }
                else {
                  int v25 = v23;
                }
                if (v23 < v16) {
                  int v26 = -v23;
                }
                else {
                  int v26 = -(v6 >> 1);
                }
                if (v26 >= v10)
                {
                  int v13 = 0;
                }
                else
                {
                  int v13 = 0;
                  uint64_t v27 = (int)v5 * (v25 + v24);
                  do
                  {
                    if (v13 <= *(unsigned __int8 *)(v21 + v27)) {
                      int v13 = *(unsigned __int8 *)(v21 + v27);
                    }
                    ++v26;
                    v27 += v5;
                  }
                  while (v26 < v10);
                }
                ++v23;
                *BOOL v22 = v13;
                v21 += v5;
                v22 += v5;
                --v24;
              }
              while (v23 != v17);
              int v28 = v17;
            }
            int v29 = *(_DWORD *)(a1 + 8);
            int v30 = v29 - v10;
            if (v28 < v29 - v10)
            {
              int v31 = (unsigned __int8 *)(v21 + v62);
              float v32 = (unsigned __int8 *)(v21 + v62 + v63);
              do
              {
                if (v13 <= *v31 || v13 <= *v32)
                {
                  float v33 = &v31[v5];
                  if (&v31[v5] <= v32)
                  {
                    int v13 = 0;
                    do
                    {
                      if (v13 <= *v33) {
                        int v13 = *v33;
                      }
                      v33 += v5;
                    }
                    while (v33 <= v32);
                  }
                  else
                  {
                    int v13 = 0;
                  }
                }
                ++v28;
                v21 += v5;
                *BOOL v22 = v13;
                v31 += v5;
                v32 += v5;
                v22 += v5;
              }
              while (v28 < v30);
              goto LABEL_47;
            }
            int v30 = v28;
            while (v30 < v29)
            {
              if (v30 + v10 <= v29) {
                int v34 = v10;
              }
              else {
                int v34 = v29 - v30;
              }
              if (v9 >= v34)
              {
                LOBYTE(v35) = 0;
              }
              else
              {
                int v35 = 0;
                uint64_t v36 = (int)v5 * v9;
                int v37 = -(v6 >> 1);
                do
                {
                  if (v35 <= *(unsigned __int8 *)(v21 + v36)) {
                    int v35 = *(unsigned __int8 *)(v21 + v36);
                  }
                  ++v37;
                  v36 += v5;
                }
                while (v37 < v34);
              }
              *BOOL v22 = v35;
              ++v30;
              v21 += v5;
              v22 += v5;
LABEL_47:
              int v29 = *(_DWORD *)(a1 + 8);
            }
            ++v18;
          }
          while (v18 != v5);
        }
        int v14 = v19 + 1;
        int v15 = &v20[v4];
        int v11 = *(_DWORD *)(a1 + 12);
      }
      while (v14 < v11);
    }
    if (*(_DWORD *)(a1 + 8) * (int)v5 >= 1)
    {
      int v38 = 0;
      float32x4_t v39 = *(char **)a1;
      int v40 = (v6 >> 1) + 1;
      int v41 = v6 >> 1;
      if (v40 <= 1) {
        int v40 = 1;
      }
      do
      {
        if (v11 >= 1)
        {
          uint64_t v42 = 0;
          float32x4_t v43 = v39;
          do
          {
            *(unsigned char *)(result + v42) = *v43;
            v43 += v4;
            int v11 = *(_DWORD *)(a1 + 12);
            ++v42;
          }
          while ((int)v42 < v11);
        }
        if (v12 < -1)
        {
          int v52 = 0;
          int v50 = 0;
          uint64_t v47 = result;
          int8x16_t v46 = v39;
        }
        else
        {
          int v44 = 0;
          int v45 = -(v6 >> 1);
          int8x16_t v46 = v39;
          uint64_t v47 = result;
          do
          {
            if (v44 <= v41) {
              int v48 = v6 >> 1;
            }
            else {
              int v48 = v44;
            }
            if (v44 < v41) {
              int v49 = -v44;
            }
            else {
              int v49 = -(v6 >> 1);
            }
            if (v49 >= v10)
            {
              int v50 = 0;
            }
            else
            {
              int v50 = 0;
              uint64_t v51 = v48 + v45;
              do
              {
                if (v50 <= *(unsigned __int8 *)(v47 + v51)) {
                  int v50 = *(unsigned __int8 *)(v47 + v51);
                }
                ++v51;
              }
              while ((int)v51 < v10);
            }
            ++v44;
            *int8x16_t v46 = v50;
            ++v47;
            v46 += v4;
            --v45;
          }
          while (v44 != v40);
          int v11 = *(_DWORD *)(a1 + 12);
          int v52 = v40;
        }
        int v53 = v11 - v10;
        if (v52 < v11 - v10)
        {
          float32x4_t v54 = (unsigned __int8 *)(v47 + v9 - 1);
          float16x4_t v55 = &v54[v12];
          do
          {
            if (v50 <= *v54 || v50 <= *v55)
            {
              float32x4_t v56 = v54 + 1;
              if (v54 + 1 <= v55)
              {
                int v50 = 0;
                do
                {
                  int v58 = *v56++;
                  int v57 = v58;
                  if (v50 <= v58) {
                    int v50 = v57;
                  }
                }
                while (v56 <= v55);
              }
              else
              {
                int v50 = 0;
              }
            }
            ++v52;
            ++v47;
            *int8x16_t v46 = v50;
            ++v54;
            ++v55;
            v46 += v4;
          }
          while (v52 < v53);
          goto LABEL_101;
        }
        int v53 = v52;
        while (v53 < v11)
        {
          if (v53 + v10 <= v11) {
            int v59 = v10;
          }
          else {
            int v59 = v11 - v53;
          }
          if (v9 >= v59)
          {
            LOBYTE(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = 0;
          }
          else
          {
            int v60 = 0;
            uint64_t v61 = v9;
            do
            {
              if (v60 <= *(unsigned __int8 *)(v47 + v61)) {
                int v60 = *(unsigned __int8 *)(v47 + v61);
              }
              ++v61;
            }
            while ((int)v61 < v59);
          }
          *int8x16_t v46 = v60;
          ++v53;
          ++v47;
          v46 += v4;
LABEL_101:
          int v11 = *(_DWORD *)(a1 + 12);
        }
        ++v38;
        ++v39;
      }
      while (v38 < *(_DWORD *)(a1 + 8) * (int)v5);
    }
    free((void *)result);
    return 1;
  }
  return result;
}

void *initBitmask(int a1, int a2)
{
  uint64_t v4 = zmalloc(0x18uLL);
  if (!v4)
  {
    char v8 = "initBitmask: bitmap record can not be allocated";
    goto LABEL_7;
  }
  uint64_t v5 = v4;
  int v6 = a1 + 7;
  if (a1 < -7) {
    int v6 = a1 + 14;
  }
  void v4[2] = a1;
  v4[3] = a2;
  v4[4] = v6 >> 3;
  int8x16_t v7 = zcalloc(a2, (uint64_t)v6 >> 3);
  *uint64_t v5 = v7;
  if (!v7)
  {
    zfree(v5);
    char v8 = "initBitmask: bitmap body can not be allocated";
LABEL_7:
    puts(v8);
    return 0;
  }
  return v5;
}

void termBitmask(void **a1)
{
  if (a1)
  {
    int v3 = *a1;
    if (v3) {
      zfree(v3);
    }
    zfree(a1);
  }
  else
  {
    puts("termBitmask: bitmap was null");
  }
}

uint64_t bitValueFromBitmask(uint64_t a1, unsigned int a2, int a3)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t result = 0;
  if ((a3 & 0x80000000) == 0 && *(_DWORD *)(a1 + 8) > (signed int)a2)
  {
    if (*(_DWORD *)(a1 + 12) > a3) {
      return (*(unsigned __int8 *)(*(void *)a1 + *(int *)(a1 + 16) * (uint64_t)a3 + ((unint64_t)a2 >> 3)) >> (a2 & 7)) & 1;
    }
    return 0;
  }
  return result;
}

uint64_t setBitInBitmask(uint64_t result, unsigned int a2, int a3, int a4)
{
  if ((a2 & 0x80000000) == 0
    && (a3 & 0x80000000) == 0
    && *(_DWORD *)(result + 8) > (signed int)a2
    && *(_DWORD *)(result + 12) > a3)
  {
    uint64_t v4 = *(void *)result + *(int *)(result + 16) * (uint64_t)a3;
    unint64_t v5 = (unint64_t)a2 >> 3;
    int v6 = 1 << (a2 & 7);
    char v7 = *(unsigned char *)(v4 + v5);
    char v8 = v7 | v6;
    char v9 = v7 & ~(_BYTE)v6;
    if (a4) {
      char v9 = v8;
    }
    *(unsigned char *)(v4 + v5) = v9;
  }
  return result;
}

uint64_t bitmaskMinus(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 8) != *(_DWORD *)(a2 + 8)) {
    return puts("bitmaskMinus: bitmasks have different shapes");
  }
  int v2 = *(_DWORD *)(result + 12);
  if (v2 != *(_DWORD *)(a2 + 12)) {
    return puts("bitmaskMinus: bitmasks have different shapes");
  }
  int v3 = *(_DWORD *)(result + 16);
  if (v3 != *(_DWORD *)(a2 + 16)) {
    return puts("bitmaskMinus: bitmasks have different shapes");
  }
  int v4 = v3 * v2;
  if (v4 >= 1)
  {
    unint64_t v5 = *(char **)a2;
    int v6 = *(unsigned char **)result;
    do
    {
      char v7 = *v5++;
      *v6++ &= ~v7;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t spreadBitmask(uint64_t result, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(result + 12);
  if (v3 >= 1)
  {
    uint64_t v6 = result;
    int v7 = 0;
    int v8 = *(_DWORD *)(result + 8);
    do
    {
      if (v8 <= 0)
      {
        LODWORD(v1CI::NodeWithChildren::NodeWithChildren(this, 0) = v7 + 1;
      }
      else
      {
        unsigned int v9 = 0;
        uint64_t v10 = v7 + 1;
        do
        {
          uint64_t v11 = *(void *)v6;
          int v12 = *(_DWORD *)(v6 + 12);
          uint64_t v13 = *(int *)(v6 + 16);
          uint64_t v14 = *(void *)v6 + (int)v13 * (uint64_t)v7;
          int v15 = a3;
          if (v9)
          {
            int v15 = a3;
            if (v12 > v7) {
              int v15 = (*(unsigned __int8 *)(v14 + ((unint64_t)(v9 - 1) >> 3)) >> ((v9 - 1) & 7)) & 1;
            }
          }
          int v16 = v9 + 1;
          int v17 = a3;
          if (v8 > (int)(v9 + 1))
          {
            int v17 = a3;
            if (v12 > v7) {
              int v17 = (*(unsigned __int8 *)(v14 + ((unint64_t)(v9 + 1) >> 3)) >> ((v9 + 1) & 7)) & 1;
            }
          }
          unint64_t v18 = (unint64_t)v9 >> 3;
          char v19 = v9 & 7;
          int v20 = a3;
          if (v7)
          {
            int v20 = a3;
            if (v12 >= v7) {
              int v20 = (*(unsigned __int8 *)(v11 + v13 * (v7 - 1) + v18) >> v19) & 1;
            }
          }
          int v21 = a3;
          if (v12 > (int)v10) {
            int v21 = (*(unsigned __int8 *)(v11 + v13 * v10 + v18) >> v19) & 1;
          }
          uint64_t result = setBitInBitmask(a2, v16 - 1, v7, v15 | (*(unsigned __int8 *)(v14 + v18) >> v19) & 1 | v17 | v20 | v21);
          int v8 = *(_DWORD *)(v6 + 8);
          unsigned int v9 = v16;
        }
        while (v16 < v8);
        int v3 = *(_DWORD *)(v6 + 12);
      }
      int v7 = v10;
    }
    while ((int)v10 < v3);
  }
  return result;
}

void spreadBitmask3(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v6 = bitmaskBoundingBitmapRect(a1);
  uint64_t v8 = v7;
  bzero(*(void **)a2, *(int *)(a2 + 12) * (uint64_t)*(int *)(a2 + 16));
  int v9 = *(_DWORD *)(a1 + 12);
  if ((int)v6 < 1
    || ((unint64_t v10 = HIDWORD(v6), v9 > SHIDWORD(v6)) ? (v11 = (int)v8 < 1) : (v11 = 1),
        v11 || *(_DWORD *)(a1 + 8) <= SHIDWORD(v8)))
  {
    if (v9 < 1) {
      return;
    }
    int v26 = 0;
    int v27 = *(_DWORD *)(a1 + 8);
    while (v27 <= 0)
    {
      LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = v26 + 1;
LABEL_63:
      int v26 = v30;
      if ((int)v30 >= v9) {
        return;
      }
    }
    unsigned int v28 = 0;
    uint64_t v29 = v26 - 1;
    uint64_t v30 = v26 + 1;
    while (1)
    {
      int v31 = 2 * a3;
      int v32 = a3;
      if (!v28) {
        goto LABEL_37;
      }
      int v33 = *(_DWORD *)(a1 + 12);
      int v34 = a3;
      if (v26)
      {
        int v34 = a3;
        if (v33 >= v26) {
          int v34 = (*(unsigned __int8 *)(*(void *)a1 + *(int *)(a1 + 16) * v29 + ((unint64_t)(v28 - 1) >> 3)) >> ((v28 - 1) & 7)) & 1;
        }
      }
      int v35 = a3;
      if (v33 > v26) {
        int v35 = (*(unsigned __int8 *)(*(void *)a1 + *(int *)(a1 + 16) * (uint64_t)v26 + ((unint64_t)(v28 - 1) >> 3)) >> ((v28 - 1) & 7)) & 1;
      }
      int v31 = v35 + v34;
      if (v33 > (int)v30) {
        break;
      }
      int v32 = a3;
      if (v26)
      {
LABEL_38:
        uint64_t v36 = *(void *)a1;
        int v37 = *(_DWORD *)(a1 + 12);
        int v38 = *(_DWORD *)(a1 + 16);
        if (v37 >= v26) {
          int v39 = (*(unsigned __int8 *)(v36 + v38 * (uint64_t)(int)v29 + ((unint64_t)v28 >> 3)) >> (v28 & 7)) & 1;
        }
        else {
          int v39 = a3;
        }
        goto LABEL_43;
      }
LABEL_41:
      uint64_t v36 = *(void *)a1;
      int v39 = a3;
      int v37 = *(_DWORD *)(a1 + 12);
      int v38 = *(_DWORD *)(a1 + 16);
LABEL_43:
      int v40 = v38;
      unint64_t v41 = (unint64_t)v28 >> 3;
      char v42 = v28 & 7;
      int v43 = a3;
      if (v37 > (int)v30) {
        int v43 = (*(unsigned __int8 *)(v36 + v38 * (uint64_t)(int)v30 + v41) >> v42) & 1;
      }
      signed int v44 = v28 + 1;
      int v45 = a3;
      if (v27 > (int)(v28 + 1))
      {
        int v45 = a3;
        if (v37 >= v26)
        {
          int v45 = a3;
          if (v26) {
            int v45 = (*(unsigned __int8 *)(v36 + v38 * (uint64_t)(int)v29 + ((unint64_t)(v28 + 1) >> 3)) >> ((v28 + 1) & 7)) & 1;
          }
        }
      }
      uint64_t v46 = v36 + v38 * (uint64_t)v26;
      unsigned int v47 = *(unsigned __int8 *)(v46 + v41);
      int v48 = a3;
      int v49 = a3;
      if (v27 > v44)
      {
        int v48 = a3;
        if (v37 > v26) {
          int v48 = (*(unsigned __int8 *)(v46 + ((unint64_t)(v28 + 1) >> 3)) >> ((v28 + 1) & 7)) & 1;
        }
        if (v37 <= (int)v30) {
          int v49 = a3;
        }
        else {
          int v49 = (*(unsigned __int8 *)(v36 + v40 * (uint64_t)(int)v30 + ((unint64_t)(v28 + 1) >> 3)) >> ((v28 + 1) & 7)) & 1;
        }
      }
      int v50 = v32 + v31 + v39;
      int v51 = (v47 >> v42) & 1;
      if (v50 + v51 + v43 + v45 + v48 + v49 > 1 || v51 != 0)
      {
        setBitInBitmask(a2, v28, v26, 1);
        int v27 = *(_DWORD *)(a1 + 8);
      }
      unsigned int v28 = v44;
      if (v44 >= v27)
      {
        int v9 = *(_DWORD *)(a1 + 12);
        goto LABEL_63;
      }
    }
    int v32 = (*(unsigned __int8 *)(*(void *)a1 + *(int *)(a1 + 16) * v30 + ((unint64_t)(v28 - 1) >> 3)) >> ((v28 - 1) & 7)) & 1;
LABEL_37:
    if (v26) {
      goto LABEL_38;
    }
    goto LABEL_41;
  }
  if ((int)v6 < SHIDWORD(v6))
  {
    int v12 = v6;
    do
    {
      if ((int)v8 >= SHIDWORD(v8))
      {
        LODWORD(v13) = v12 + 1;
      }
      else
      {
        uint64_t v13 = v12 + 1;
        signed int v14 = v8;
        do
        {
          uint64_t v15 = *(void *)a1;
          uint64_t v16 = *(int *)(a1 + 16);
          uint64_t v17 = *(void *)a1 + v16 * (v12 - 1);
          int v18 = v14 + 6;
          if (v14 - 1 >= 0) {
            int v18 = v14 - 1;
          }
          uint64_t v19 = v15 + (int)v16 * (uint64_t)v12;
          uint64_t v20 = v15 + v16 * v13;
          int v21 = ((*(unsigned __int8 *)(v19 + (v18 >> 3)) >> ((v14 - 1) & 7)) & 1)
              + ((*(unsigned __int8 *)(v17 + (v18 >> 3)) >> ((v14 - 1) & 7)) & 1)
              + ((*(unsigned __int8 *)(v20 + (v18 >> 3)) >> ((v14 - 1) & 7)) & 1)
              + ((*(unsigned __int8 *)(v17 + v14 / 8) >> (v14 & 7)) & 1);
          int v22 = (*(unsigned __int8 *)(v19 + v14 / 8) >> (v14 & 7)) & 1;
          signed int v23 = v14 + 1;
          int v24 = v14 + 8;
          if (v14 + 1 >= 0) {
            int v24 = v14 + 1;
          }
          if (v21
             + v22
             + ((*(unsigned __int8 *)(v20 + v14 / 8) >> (v14 & 7)) & 1)
             + ((*(unsigned __int8 *)(v17 + (v24 >> 3)) >> (v23 & 7)) & 1)
             + ((*(unsigned __int8 *)(v19 + (v24 >> 3)) >> (v23 & 7)) & 1)
             + ((*(unsigned __int8 *)(v20 + (v24 >> 3)) >> (v23 & 7)) & 1u) > 1
            || v22 != 0)
          {
            setBitInBitmask(a2, v14, v12, 1);
          }
          signed int v14 = v23;
        }
        while (HIDWORD(v8) != v23);
      }
      int v12 = v13;
    }
    while (v13 != v10);
  }
}

unint64_t bitmaskBoundingBitmapRect(uint64_t a1)
{
  int v4 = *(_DWORD *)(a1 + 8);
  signed int v3 = *(_DWORD *)(a1 + 12);
  if (v3 < 1)
  {
    unsigned int v15 = -1;
    uint64_t v14 = *(unsigned int *)(a1 + 8);
    unsigned int v10 = -1;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = *(unsigned int *)(a1 + 12);
    uint64_t v7 = *(__int8 **)a1;
    int v8 = *(_DWORD *)(a1 + 16);
    uint32x4_t v9 = (uint32x4_t)vdupq_n_s32(v4 - 1);
    unsigned int v10 = -1;
    v11.i64[0] = 0x700000007;
    v11.i64[1] = 0x700000007;
    v12.i64[0] = 0x100000001;
    v12.i64[1] = 0x100000001;
    v13.i64[0] = 0x800000008;
    v13.i64[1] = 0x800000008;
    uint64_t v14 = *(unsigned int *)(a1 + 8);
    unsigned int v15 = -1;
    do
    {
      if (v8 >= 1)
      {
        uint64_t v16 = 0;
        while (!v7[v16])
        {
          if (v8 == ++v16) {
            goto LABEL_28;
          }
        }
        if (v4 >= 1)
        {
          int8x16_t v17 = (int8x16_t)vdupq_n_s32(v10);
          int8x16_t v18 = (int8x16_t)vdupq_n_s32(v14);
          int32x4_t v19 = vdupq_n_s32(v15);
          int32x4_t v20 = vdupq_n_s32(v3);
          unsigned int v21 = (v4 + 7) & 0xFFFFFFF8;
          int v22 = v7;
          int32x4_t v23 = (int32x4_t)v17;
          int32x4_t v24 = (int32x4_t)v18;
          int32x4_t v25 = vdupq_n_s32(v5);
          int32x4_t v26 = v19;
          int32x4_t v27 = v20;
          int32x4_t v28 = (int32x4_t)xmmword_19394C9F0;
          int32x4_t v29 = (int32x4_t)xmmword_19394C9E0;
          do
          {
            int8x16_t v30 = (int8x16_t)v27;
            int8x16_t v31 = (int8x16_t)v20;
            int8x16_t v32 = (int8x16_t)v26;
            int8x16_t v33 = (int8x16_t)v19;
            int8x16_t v34 = (int8x16_t)v24;
            int32x4_t v35 = (int32x4_t)v18;
            int8x16_t v36 = (int8x16_t)v23;
            int32x4_t v37 = (int32x4_t)v17;
            int32x4_t v38 = (int32x4_t)vcgeq_u32(v9, (uint32x4_t)v28);
            *(int16x4_t *)v2.i8 = vmovn_s32(v38);
            uint8x8_t v39 = (uint8x8_t)vmovn_s16(v2);
            if (v39.i8[0]) {
              v39.i8[0] = *v22;
            }
            if (vmovn_s16(v2).i8[1]) {
              v39.i8[1] = *v22;
            }
            int16x4_t v40 = (int16x4_t)vmovn_s16(v2);
            if (v40.i8[2]) {
              v39.i8[2] = *v22;
            }
            if (vmovn_s16(v2).i8[3]) {
              v39.i8[3] = *v22;
            }
            int16x8_t v2 = (int16x8_t)vcgeq_u32(v9, (uint32x4_t)v29);
            int16x4_t v41 = (int16x4_t)vmovn_s16(vmovn_hight_s32(v40, (int32x4_t)v2));
            if (v41.i8[4]) {
              v39.i8[4] = *v22;
            }
            int16x4_t v42 = (int16x4_t)vmovn_s16(vmovn_hight_s32(v41, (int32x4_t)v2));
            if (v42.i8[5]) {
              v39.i8[5] = *v22;
            }
            int16x4_t v43 = (int16x4_t)vmovn_s16(vmovn_hight_s32(v42, (int32x4_t)v2));
            if (v43.i8[6]) {
              v39.i8[6] = *v22;
            }
            if (vmovn_s16(vmovn_hight_s32(v43, *(int32x4_t *)&v2)).i8[7]) {
              v39.i8[7] = *v22;
            }
            uint16x8_t v44 = vmovl_u8(v39);
            int8x16_t v45 = (int8x16_t)vmovl_high_u16(v44);
            int8x16_t v46 = vbicq_s8((int8x16_t)v38, (int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v12, (uint32x4_t)vandq_s8((int8x16_t)v28, v11)), (int8x16_t)vmovl_u16(*(uint16x4_t *)v44.i8))));
            int8x16_t v47 = vbicq_s8((int8x16_t)v2, (int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v12, (uint32x4_t)vandq_s8((int8x16_t)v29, v11)), v45)));
            int32x4_t v27 = (int32x4_t)vbslq_s8(v47, (int8x16_t)vminq_s32(v25, v27), (int8x16_t)v27);
            int32x4_t v20 = (int32x4_t)vbslq_s8(v46, (int8x16_t)vminq_s32(v25, v20), (int8x16_t)v20);
            int32x4_t v26 = (int32x4_t)vbslq_s8(v47, (int8x16_t)vmaxq_s32(v25, v26), (int8x16_t)v26);
            int32x4_t v19 = (int32x4_t)vbslq_s8(v46, (int8x16_t)vmaxq_s32(v25, v19), (int8x16_t)v19);
            int32x4_t v24 = (int32x4_t)vbslq_s8(v47, (int8x16_t)vminq_s32(v29, v24), (int8x16_t)v24);
            int8x16_t v18 = vbslq_s8(v46, (int8x16_t)vminq_s32(v28, v35), (int8x16_t)v35);
            int32x4_t v23 = (int32x4_t)vbslq_s8(v47, (int8x16_t)vmaxq_s32(v29, v23), (int8x16_t)v23);
            int8x16_t v17 = vbslq_s8(v46, (int8x16_t)vmaxq_s32(v28, v37), (int8x16_t)v37);
            int32x4_t v28 = vaddq_s32(v28, v13);
            int32x4_t v29 = vaddq_s32(v29, v13);
            ++v22;
            v21 -= 8;
          }
          while (v21);
          signed int v3 = vminvq_s32(vminq_s32((int32x4_t)vbslq_s8((int8x16_t)v38, (int8x16_t)v20, v31), (int32x4_t)vbslq_s8((int8x16_t)v2, (int8x16_t)v27, v30)));
          unsigned int v15 = vmaxvq_s32(vmaxq_s32((int32x4_t)vbslq_s8((int8x16_t)v38, (int8x16_t)v19, v33), (int32x4_t)vbslq_s8((int8x16_t)v2, (int8x16_t)v26, v32)));
          uint64_t v14 = vminvq_s32(vminq_s32((int32x4_t)vbslq_s8((int8x16_t)v38, v18, (int8x16_t)v35), (int32x4_t)vbslq_s8((int8x16_t)v2, (int8x16_t)v24, v34)));
          unsigned int v10 = vmaxvq_s32(vmaxq_s32((int32x4_t)vbslq_s8((int8x16_t)v38, v17, (int8x16_t)v37), (int32x4_t)vbslq_s8((int8x16_t)v2, (int8x16_t)v23, v36)));
        }
      }
LABEL_28:
      ++v5;
      v7 += v8;
    }
    while (v5 != v6);
  }
  return makeBitmapRect(v14, v3, v10 + 1, v15 + 1);
}

uint64_t chokeBitmask(uint64_t result, uint64_t a2, char a3)
{
  int v3 = *(_DWORD *)(result + 12);
  if (v3 >= 1)
  {
    uint64_t v6 = result;
    int v7 = 0;
    int v8 = *(_DWORD *)(result + 8);
    do
    {
      if (v8 <= 0)
      {
        LODWORD(v1CI::NodeWithChildren::NodeWithChildren(this, 0) = v7 + 1;
      }
      else
      {
        unsigned int v9 = 0;
        uint64_t v10 = v7 + 1;
        do
        {
          uint64_t v11 = *(void *)v6;
          int v12 = *(_DWORD *)(v6 + 12);
          uint64_t v13 = *(int *)(v6 + 16);
          uint64_t v14 = *(void *)v6 + (int)v13 * (uint64_t)v7;
          LOBYTE(v15) = a3;
          if (v9)
          {
            LOBYTE(v15) = a3;
            if (v12 > v7) {
              int v15 = (*(unsigned __int8 *)(v14 + ((unint64_t)(v9 - 1) >> 3)) >> ((v9 - 1) & 7)) & 1;
            }
          }
          int v16 = v9 + 1;
          LOBYTE(v17) = a3;
          if (v8 > (int)(v9 + 1))
          {
            LOBYTE(v17) = a3;
            if (v12 > v7) {
              int v17 = (*(unsigned __int8 *)(v14 + ((unint64_t)(v9 + 1) >> 3)) >> ((v9 + 1) & 7)) & 1;
            }
          }
          unint64_t v18 = (unint64_t)v9 >> 3;
          char v19 = v9 & 7;
          LOBYTE(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = a3;
          if (v7)
          {
            LOBYTE(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = a3;
            if (v12 >= v7) {
              int v20 = (*(unsigned __int8 *)(v11 + v13 * (v7 - 1) + v18) >> v19) & 1;
            }
          }
          LOBYTE(v21) = a3;
          if (v12 > (int)v10) {
            int v21 = (*(unsigned __int8 *)(v11 + v13 * v10 + v18) >> v19) & 1;
          }
          uint64_t result = setBitInBitmask(a2, v16 - 1, v7, (*(unsigned __int8 *)(v14 + v18) >> v19) & 1 & v15 & v17 & v20 & v21);
          int v8 = *(_DWORD *)(v6 + 8);
          unsigned int v9 = v16;
        }
        while (v16 < v8);
        int v3 = *(_DWORD *)(v6 + 12);
      }
      int v7 = v10;
    }
    while ((int)v10 < v3);
  }
  return result;
}

unsigned __int8 *computeThresholdedBitmask(unsigned __int8 *result, uint64_t *a2, int a3)
{
  int v3 = *((_DWORD *)result + 3);
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = *((_DWORD *)result + 2);
    uint64_t v6 = *a2;
    int v7 = *(unsigned __int8 **)result;
    uint64_t v8 = *((int *)a2 + 4);
    uint64_t v9 = *((int *)result + 7);
    uint64_t v10 = *((int *)result + 4);
    do
    {
      if (v5 >= 1)
      {
        unsigned int v11 = 0;
        uint64_t result = v7;
        do
        {
          if (*result > a3) {
            *(unsigned char *)(v6 + ((unint64_t)v11 >> 3)) |= 1 << (v11 & 7);
          }
          ++v11;
          result += v9;
        }
        while (v5 != v11);
      }
      ++v4;
      v7 += v10;
      v6 += v8;
    }
    while (v4 != v3);
  }
  return result;
}

unint64_t bitmaskBoundingBitmapRectWithSeedPoint(uint64_t *a1, int a2, int a3)
{
  if (a2 < 0
    || a3 < 0
    || (uint64_t v5 = *((unsigned int *)a1 + 2), (int)v5 <= a2)
    || (uint64_t v6 = *((unsigned int *)a1 + 3), (int)v6 <= a3)
    || (uint64_t v7 = *a1,
        uint64_t v8 = *((int *)a1 + 4),
        uint64_t v9 = *a1 + (int)v8 * (uint64_t)a3,
        unint64_t v10 = (unint64_t)a2 >> 3,
        int v11 = 1 << (a2 & 7),
        (v11 & *(unsigned char *)(v9 + v10)) == 0))
  {
    uint64_t v14 = 0;
    LODWORD(v15) = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
  }
  else
  {
    LODWORD(v12) = a2;
    while (1)
    {
      BOOL v13 = __OFSUB__(v12, 1);
      unint64_t v12 = (v12 - 1);
      if (((v12 & 0x80000000) != 0) != v13) {
        break;
      }
      if (((*(unsigned __int8 *)(v9 + (v12 >> 3)) >> (v12 & 7)) & 1) == 0)
      {
        uint64_t v14 = (v12 + 1);
        goto LABEL_15;
      }
    }
    uint64_t v14 = 0;
LABEL_15:
    int v19 = v5 - 1;
    if (a2 > (int)v5 - 1) {
      int v19 = a2;
    }
    while (v19 != a2)
    {
      uint64_t v16 = (a2 + 1);
      if ((int)v16 >= 0) {
        int v20 = a2 + 1;
      }
      else {
        int v20 = a2 + 8;
      }
      int v21 = *(unsigned __int8 *)(v9 + (v20 >> 3)) >> (v16 & 7);
      a2 = v16;
      if ((v21 & 1) == 0) {
        goto LABEL_24;
      }
    }
    uint64_t v16 = (v19 + 1);
LABEL_24:
    uint64_t v22 = a3;
    LODWORD(v15) = a3 + 1;
    int32x4_t v23 = (unsigned __int8 *)(v7 + v10 + (a3 - 1) * v8);
    uint64_t v24 = a3;
    while (1)
    {
      BOOL v25 = v24-- < 1;
      if (v25) {
        break;
      }
      int v26 = *v23;
      LODWORD(v15) = v15 - 1;
      v23 -= v8;
      if ((v11 & v26) == 0) {
        goto LABEL_29;
      }
    }
    LODWORD(v15) = a3 & (a3 >> 31);
LABEL_29:
    int v27 = v6 - 1;
    if (a3 > (int)v6 - 1) {
      int v27 = a3;
    }
    int v28 = a3 - 1;
    uint64_t v29 = v27 - v22;
    int8x16_t v30 = (unsigned __int8 *)(v7 + v10 + v8 + (int)v8 * (uint64_t)(int)v22);
    while (v29)
    {
      int v31 = *v30;
      ++v28;
      --v29;
      v30 += v8;
      if ((v11 & v31) == 0) {
        goto LABEL_36;
      }
    }
    int v28 = v27;
LABEL_36:
    uint64_t v17 = (v28 + 1);
    while (1)
    {
LABEL_37:
      if ((int)v14 >= 1)
      {
        int v32 = 0;
        uint64_t v33 = v14;
        while ((int)v17 > (int)v15)
        {
          int v34 = v33 + 6;
          if ((int)v33 >= 1) {
            int v34 = v33 - 1;
          }
          int32x4_t v35 = (unsigned __int8 *)(v7 + (int)v8 * (uint64_t)(int)v15 + (v34 >> 3));
          int v36 = v17 - v15;
          while (((1 << ((v33 - 1) & 7)) & *v35) == 0)
          {
            v35 += v8;
            if (!--v36)
            {
              uint64_t v14 = v33;
              goto LABEL_50;
            }
          }
          int v32 = 1;
          BOOL v25 = (int)v33 < 2;
          uint64_t v33 = (v33 - 1);
          if (v25)
          {
            uint64_t v14 = 0;
            goto LABEL_50;
          }
        }
      }
      int v32 = 0;
LABEL_50:
      if ((int)v16 < (int)v5)
      {
        int v37 = v32;
        uint64_t v38 = v16;
        while ((int)v17 > (int)v15)
        {
          uint8x8_t v39 = (unsigned __int8 *)(v7 + (int)v8 * (uint64_t)(int)v15 + (int)v38 / 8);
          int v40 = v17 - v15;
          while (((1 << (v38 & 7)) & *v39) == 0)
          {
            v39 += v8;
            if (!--v40)
            {
              uint64_t v16 = v38;
              int v32 = v37;
              goto LABEL_59;
            }
          }
          uint64_t v38 = (v38 + 1);
          int v37 = 1;
          if (v38 == v5)
          {
            uint64_t v16 = v5;
            int v32 = 1;
            break;
          }
        }
      }
LABEL_59:
      if ((int)v15 >= 1)
      {
        uint64_t v15 = v15;
        int v41 = v32;
        while ((int)v14 < (int)v16)
        {
          int v42 = v14;
          while (((*(unsigned __int8 *)(v7 + (v15 - 1) * v8 + v42 / 8) >> (v42 & 7)) & 1) == 0)
          {
            if (v16 == ++v42) {
              goto LABEL_70;
            }
          }
          int v41 = 1;
          BOOL v25 = v15-- < 2;
          if (v25)
          {
            LODWORD(v15) = 0;
            goto LABEL_70;
          }
        }
      }
      int v41 = v32;
LABEL_70:
      if ((int)v17 < (int)v6)
      {
        uint64_t v17 = (int)v17;
        int v43 = v41;
LABEL_72:
        if ((int)v14 < (int)v16) {
          break;
        }
      }
      if (!v41) {
        goto LABEL_11;
      }
    }
    int v44 = v14;
    do
    {
      if ((*(unsigned __int8 *)(v7 + v17 * v8 + v44 / 8) >> (v44 & 7)))
      {
        ++v17;
        int v43 = 1;
        if (v17 != (int)v6) {
          goto LABEL_72;
        }
        uint64_t v17 = v6;
        goto LABEL_37;
      }
      ++v44;
    }
    while (v16 != v44);
    if (v43) {
      goto LABEL_37;
    }
  }
LABEL_11:
  return makeBitmapRect(v14, v15, v16, v17);
}

uint64_t bitmaskCentroidUsingBoundingRect(uint64_t result, uint64_t a2, uint64_t a3)
{
  if ((int)a2 < SHIDWORD(a2))
  {
    int v3 = 0;
    int v4 = 0;
    int v5 = 0;
    int v6 = a2;
    do
    {
      if ((int)a3 < SHIDWORD(a3))
      {
        int v7 = a3;
        do
        {
          int v8 = *(unsigned __int8 *)(*(void *)result + *(int *)(result + 16) * (uint64_t)v6 + v7 / 8);
          int v9 = 1 << (v7 & 7);
          BOOL v10 = (v9 & v8) == 0;
          if ((v9 & v8) != 0) {
            int v11 = v7;
          }
          else {
            int v11 = 0;
          }
          v5 += v11;
          if (v10) {
            int v12 = 0;
          }
          else {
            int v12 = v6;
          }
          v4 += v12;
          if (!v10) {
            ++v3;
          }
          ++v7;
        }
        while (HIDWORD(a3) != v7);
      }
      ++v6;
    }
    while (v6 != HIDWORD(a2));
  }
  return result;
}

uint64_t bitmaskCentroid(uint64_t a1)
{
  unint64_t v3 = bitmaskBoundingBitmapRect(a1);

  return bitmaskCentroidUsingBoundingRect(a1, v3, v2);
}

float bitmaskOvalnessUsingBoundingRect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3 = 1.0 / (float)(HIDWORD(a3) - a3);
  int v4 = HIDWORD(a2) - a2;
  float v5 = 1.0 / (float)(HIDWORD(a2) - a2);
  if (SHIDWORD(a2) <= (int)a2)
  {
    int v7 = 0;
  }
  else
  {
    int v6 = 0;
    int v7 = 0;
    uint64_t v8 = (uint64_t)rintf(v5 * 16777000.0);
    float v9 = rintf(v3 * 16777000.0);
    do
    {
      if (SHIDWORD(a3) > (int)a3)
      {
        int v10 = ((int)(uint64_t)v9 >> 1) + 2048;
        int v11 = a3;
        do
        {
          v7 += (*(unsigned __int8 *)(*(void *)a1 + *(int *)(a1 + 16) * (uint64_t)(int)a2 + v11 / 8) >> (v11 & 7)) & 1 ^ (((((((int)v8 >> 1) + 2048 + v6 * (int)v8) >> 12) - 2048) * (((((int)v8 >> 1) + 2048 + v6 * (int)v8) >> 12) - 2048) + ((v10 >> 12) - 2048) * ((v10 >> 12) - 2048)) < 0x400000);
          ++v11;
          v10 += (uint64_t)v9;
        }
        while (HIDWORD(a3) != v11);
      }
      LODWORD(a2) = a2 + 1;
      ++v6;
    }
    while (v6 != v4);
  }
  return (float)v7 * -2.0 * v5 * v3 + 1.0;
}

uint64_t bitmaskAreaUsingBoundingRect(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = HIDWORD(a2);
  if ((int)a2 >= SHIDWORD(a2)) {
    return 0;
  }
  uint64_t v4 = 0;
  do
  {
    if ((int)a3 < SHIDWORD(a3))
    {
      int v5 = a3;
      do
      {
        uint64_t v4 = ((*(unsigned __int8 *)(*(void *)a1 + *(int *)(a1 + 16) * (uint64_t)(int)a2 + v5 / 8) >> (v5 & 7)) & 1)
           + v4;
        ++v5;
      }
      while (HIDWORD(a3) != v5);
    }
    LODWORD(a2) = a2 + 1;
  }
  while (a2 != v3);
  return v4;
}

uint64_t bitmaskArea(uint64_t a1)
{
  unint64_t v3 = bitmaskBoundingBitmapRect(a1);

  return bitmaskAreaUsingBoundingRect(a1, v3, v2);
}

uint64_t closestSetBitInBitmaskUsingBoundingRect(uint64_t result, unint64_t a2, uint64_t a3, int *a4, int *a5, double a6, double a7)
{
  unint64_t v7 = HIDWORD(a2);
  if ((int)a2 >= SHIDWORD(a2))
  {
    int v10 = -1;
    int v9 = -1;
  }
  else
  {
    float v8 = (float)(*(_DWORD *)(result + 8) * *(_DWORD *)(result + 8) + *(_DWORD *)(result + 12) * *(_DWORD *)(result + 12));
    int v9 = -1;
    int v10 = -1;
    do
    {
      if ((int)a3 < SHIDWORD(a3))
      {
        float v11 = (float)(int)a2 - a7;
        float v12 = v11 * v11;
        int v13 = a3;
        do
        {
          if ((*(unsigned __int8 *)(*(void *)result + *(int *)(result + 16) * (uint64_t)(int)a2 + v13 / 8) >> (v13 & 7)))
          {
            float v14 = (float)v13 - a6;
            float v15 = v12 + (float)(v14 * v14);
            if (v15 < v8)
            {
              int v10 = v13;
              int v9 = a2;
              float v8 = v15;
            }
          }
          ++v13;
        }
        while (HIDWORD(a3) != v13);
      }
      LODWORD(a2) = a2 + 1;
    }
    while (a2 != v7);
  }
  *a4 = v10;
  *a5 = v9;
  return result;
}

double bitmaskContrastUsingBoundingRect(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t a4, float *a5, int *a6)
{
  unint64_t v6 = HIDWORD(a4);
  int v8 = *((_DWORD *)a2 + 2);
  int v7 = *((_DWORD *)a2 + 3);
  if ((int)a4 <= 1) {
    LODWORD(a4) = 1;
  }
  if (v8 <= (int)v6) {
    LODWORD(v6) = v8 - 1;
  }
  if ((int)a3 <= 1) {
    int v9 = 1;
  }
  else {
    int v9 = a3;
  }
  if (v7 <= SHIDWORD(a3)) {
    int v10 = v7 - 1;
  }
  else {
    int v10 = HIDWORD(a3);
  }
  if (v9 >= v10)
  {
    *a5 = 0.0;
    *a6 = 0;
  }
  else
  {
    int v11 = 0;
    int v12 = 0;
    int v13 = 0;
    uint64_t v14 = *a2;
    uint64_t v15 = *((int *)a2 + 4);
    uint64_t v16 = (int)v15 * v9;
    uint64_t v17 = *((int *)a2 + 7);
    uint64_t v18 = *a2 + v16 + -(int)v15 - v17;
    uint64_t v19 = *a2 + v16 + (int)v17 - (int)v15;
    uint64_t v20 = *a2 + v16 - v17;
    uint64_t v21 = *a2 + v17 + v16;
    uint64_t v22 = *a2 + v16 - v15;
    uint64_t v23 = v14 + v15 + v16 - v17;
    uint64_t v24 = v14 + v15 + v16;
    uint64_t v25 = v14 + v16 + (int)v17 + (int)v15;
    uint64_t v26 = (int)v17 * (int)a4;
    int v46 = v10;
    int v47 = a4;
    do
    {
      if ((int)a4 >= (int)v6)
      {
        ++v9;
      }
      else
      {
        uint64_t v27 = v19;
        uint64_t v28 = *(int *)(a1 + 16);
        uint64_t v29 = *(void *)a1 + (int)v28 * (uint64_t)v9;
        uint64_t v30 = *(void *)a1 + v28 * (v9 + 1);
        uint64_t v31 = *(void *)a1 + v28 * (v9 - 1);
        uint64_t v32 = v25;
        uint64_t v33 = v24;
        uint64_t v49 = v23;
        uint64_t v50 = v21;
        uint64_t v51 = v20;
        uint64_t v52 = v19;
        uint64_t v53 = v22;
        uint64_t v34 = v18;
        unsigned int v35 = a4;
        do
        {
          unint64_t v36 = (unint64_t)v35 >> 3;
          unsigned int v37 = v35 + 1;
          if (((*(unsigned __int8 *)(v29 + v36) >> (v35 & 7)) & 1) != 0
            && ((*(unsigned __int8 *)(v29 + ((unint64_t)(v35 + 1) >> 3)) >> ((v35 + 1) & 7)) & 1)
             + ((*(unsigned __int8 *)(v30 + v36) >> (v35 & 7)) & 1)
             + ((*(unsigned __int8 *)(v29 + ((unint64_t)(v35 - 1) >> 3)) >> ((v35 - 1) & 7)) & 1)
             + ((*(unsigned __int8 *)(v31 + v36) >> (v35 & 7)) & 1u) <= 3)
          {
            int v38 = *(unsigned __int8 *)(v34 + v26) - *(unsigned __int8 *)(v32 + v26);
            if (v38 < 0) {
              int v38 = *(unsigned __int8 *)(v32 + v26) - *(unsigned __int8 *)(v34 + v26);
            }
            int v39 = *(unsigned __int8 *)(v22 + v26) - *(unsigned __int8 *)(v33 + v26);
            if (v39 < 0) {
              int v39 = *(unsigned __int8 *)(v33 + v26) - *(unsigned __int8 *)(v22 + v26);
            }
            int v40 = *(unsigned __int8 *)(v27 + v26) - *(unsigned __int8 *)(v23 + v26);
            if (v40 < 0) {
              int v40 = *(unsigned __int8 *)(v23 + v26) - *(unsigned __int8 *)(v27 + v26);
            }
            int v41 = *(unsigned __int8 *)(v20 + v26) - *(unsigned __int8 *)(v21 + v26);
            if (v41 < 0) {
              int v41 = *(unsigned __int8 *)(v21 + v26) - *(unsigned __int8 *)(v20 + v26);
            }
            int v42 = v40 + v41 + v39 + v38;
            if (v42 >= v11) {
              int v43 = v11;
            }
            else {
              int v43 = v42;
            }
            if (v12) {
              int v11 = v43;
            }
            else {
              int v11 = v42;
            }
            v13 += v42;
            ++v12;
          }
          v34 += v17;
          v22 += v17;
          v27 += v17;
          v20 += v17;
          v21 += v17;
          v23 += v17;
          v33 += v17;
          v32 += v17;
          unsigned int v35 = v37;
        }
        while (v6 != v37);
        int v10 = v46;
        LODWORD(a4) = v47;
        ++v9;
        uint64_t v19 = v52;
        uint64_t v22 = v53;
        uint64_t v21 = v50;
        uint64_t v20 = v51;
        uint64_t v23 = v49;
      }
      v18 += v15;
      v22 += v15;
      v19 += v15;
      v20 += v15;
      v21 += v15;
      v23 += v15;
      v24 += v15;
      v25 += v15;
    }
    while (v9 != v10);
    *a5 = (float)v11;
    *a6 = v12;
    if (v12)
    {
      *(float *)&double result = (float)v13 / (float)v12;
      return result;
    }
  }
  return 0.0;
}

void getBitmaskInfo(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v6 = bitmaskBoundingBitmapRect(a1);
  unint64_t v8 = v7;
  *(void *)(a3 + 36) = v6;
  *(void *)(a3 + 44) = v7;
  bitmaskCentroidUsingBoundingRect(a1, v6, v7);
  *(void *)a3 = v9;
  *(void *)(a3 + 8) = v10;
  *(_DWORD *)(a3 + 16) = bitmaskAreaUsingBoundingRect(a1, v6, v8);
  *(float *)(a3 + 2CI::NodeWithChildren::NodeWithChildren(this, 0) = bitmaskOvalnessUsingBoundingRect(a1, v6, v8);
  double v11 = bitmaskContrastUsingBoundingRect(a1, a2, v6, v8, (float *)(a3 + 28), (int *)(a3 + 32));
  *(_DWORD *)(a3 + 24) = LODWORD(v11);
  BOOL v12 = *(int *)(a3 + 36) < 1
     || *(_DWORD *)(a3 + 40) >= *(_DWORD *)(a1 + 12)
     || *(int *)(a3 + 44) < 1
     || *(_DWORD *)(a3 + 48) >= *(_DWORD *)(a1 + 8);
  *(unsigned char *)(a3 + 56) = v12;
}

void getBitmaskInfoWithSeedPoint(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  unint64_t v8 = bitmaskBoundingBitmapRectWithSeedPoint((uint64_t *)a1, a4, a5);
  unint64_t v10 = v9;
  *(void *)(a3 + 36) = v8;
  *(void *)(a3 + 44) = v9;
  bitmaskCentroidUsingBoundingRect(a1, v8, v9);
  *(void *)a3 = v11;
  *(void *)(a3 + 8) = v12;
  *(_DWORD *)(a3 + 16) = bitmaskAreaUsingBoundingRect(a1, v8, v10);
  *(float *)(a3 + 2CI::NodeWithChildren::NodeWithChildren(this, 0) = bitmaskOvalnessUsingBoundingRect(a1, v8, v10);
  double v13 = bitmaskContrastUsingBoundingRect(a1, a2, v8, v10, (float *)(a3 + 28), (int *)(a3 + 32));
  *(_DWORD *)(a3 + 24) = LODWORD(v13);
  BOOL v14 = *(int *)(a3 + 36) < 1
     || *(_DWORD *)(a3 + 40) >= *(_DWORD *)(a1 + 12)
     || *(int *)(a3 + 44) < 1
     || *(_DWORD *)(a3 + 48) >= *(_DWORD *)(a1 + 8);
  *(unsigned char *)(a3 + 56) = v14;
}

__n64 cikernel::_accordianWarpS(CI *a1, double a2, double a3)
{
  float v11 = *(float *)&a3;
  float v3 = *((float *)&a3 + 1);
  result.n64_u64[0] = *(unint64_t *)CI::getDC(a1);
  float v5 = (float)(result.n64_f32[1] - v11) / v3;
  if (v5 <= 1.0) {
    float v6 = (float)(result.n64_f32[1] - v11) / v3;
  }
  else {
    float v6 = 1.0;
  }
  BOOL v7 = v5 < 0.0;
  float v8 = 0.0;
  if (!v7) {
    float v8 = v6;
  }
  float v9 = 1.0
     - fabs((float)((float)(v8 * *(float *)&a2) + (float)(floorf((float)(v8 * *(float *)&a2) * 0.5) * -2.0)) + -1.0);
  result.n64_f32[0] = (float)(vmuls_lane_f32(v9, *(float32x2_t *)&a2, 1) + 1.0) * result.n64_f32[0];
  result.n64_u32[1] = fminf(result.n64_f32[1], fmaxf(result.n64_f32[1] - v3, v11));
  return result;
}

void CI::f2_f3_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, __n128))a1[3];
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  uint64_t v15 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    uint64_t v15 = (__n128 *)((char *)a2 + 64 * v14);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *((__n128 *)a2 + 4 * v12), *v15);
}

void CI::WarpKernel::~WarpKernel(CI::WarpKernel *this)
{
  CI::Kernel::~Kernel(this);

  JUMPOUT(0x1997023B0);
}

__n64 cikernel::_accordianWarpT(CI *a1, double a2, __n128 a3)
{
  float v3 = a3.n128_f32[1];
  result.n64_u64[0] = *(unint64_t *)CI::getDC(a1);
  _V16.S[2] = a3.n128_u32[2];
  _S2 = result.n64_f32[1] - a3.n128_f32[0];
  float v7 = (float)(result.n64_f32[1] - a3.n128_f32[0]) / v3;
  if (v7 <= 1.0) {
    float v8 = (float)(result.n64_f32[1] - a3.n128_f32[0]) / v3;
  }
  else {
    float v8 = 1.0;
  }
  _NF = v7 < 0.0;
  float v10 = 0.0;
  if (!_NF) {
    float v10 = v8;
  }
  float v11 = 1.0
      - fabs((float)((float)(v10 * *(float *)&a2) + (float)(floorf((float)(v10 * *(float *)&a2) * 0.5) * -2.0)) + -1.0);
  __asm { FMLA            S4, S2, V16.S[2] }
  result.n64_f32[0] = (float)(vmuls_lane_f32(v11, *(float32x2_t *)&a2, 1) + 1.0) * result.n64_f32[0];
  result.n64_u32[1] = fmaxf(result.n64_f32[1], fminf(_S4, a3.n128_f32[3] + result.n64_f32[1]));
  return result;
}

double cikernel::_accordionMix(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float a5, double a6)
{
  float v13 = *(float *)&a6;
  float v6 = *((float *)&a6 + 1);
  uint64_t DC = CI::getDC(a1);
  float v8 = (float)(*(float *)(DC + 4) - v13) / v6;
  if (v8 <= 1.0) {
    float v9 = (float)(*(float *)(DC + 4) - v13) / v6;
  }
  else {
    float v9 = 1.0;
  }
  BOOL v10 = v8 < 0.0;
  float v11 = 0.0;
  if (!v10) {
    float v11 = v9;
  }
  *(void *)&double result = vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a5), a3, a5), 1.0 - vmuls_lane_f32((float)(v11 * a4.f32[0]) - floorf(v11 * a4.f32[0]), a4, 2)).u64[0];
  return result;
}

void CI::f4_s_s_f3_f_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  BOOL v10 = *(double (**)(__n128, __n128, __n128, float, __n128))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = *(void *)(v9 + 56);
  uint64_t v16 = *(void *)(v9 + 80);
  int v17 = *(_DWORD *)(v9 + 112);
  uint64_t v18 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v23 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v13 = v23;
  }
  uint64_t v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    uint64_t v19 = (__n128 *)((char *)a2 + 64 * v18);
  }
  uint64_t v20 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    uint64_t v20 = (__n128 *)((char *)a2 + 64 * v14);
  }
  uint64_t v21 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    uint64_t v21 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v22 = v10(*v21, *v20, *((__n128 *)a2 + 4 * v15), *((float *)a2 + 16 * v16), *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_accordionFoldTransition(uint64_t a1, uint64_t a2, float32x4_t a3, float a4, float64x2_t a5)
{
  float v7 = *((float *)a5.f64 + 1);
  uint64_t v8 = *(void *)CI::getDC((CI *)a1);
  float v10 = *((float *)&v8 + 1);
  int8x16_t v11 = (int8x16_t)a5;
  _S11 = *((float *)&v8 + 1) - *(float *)a5.f64;
  *(float *)v13.f64 = (float)(*((float *)&v8 + 1) - *(float *)a5.f64) / v7;
  if (*(float *)v13.f64 <= 1.0) {
    float v14 = (float)(*((float *)&v8 + 1) - *(float *)a5.f64) / v7;
  }
  else {
    float v14 = 1.0;
  }
  _NF = *(float *)v13.f64 < 0.0;
  v13.f64[0] = 0.0;
  if (!_NF) {
    *(float *)v13.f64 = v14;
  }
  int8x16_t v16 = (int8x16_t)a3;
  *(float *)v13.f64 = *(float *)v13.f64 * a3.f32[0];
  double v17 = 1.0;
  double v18 = 1.0 - fabs((float)(*(float *)v13.f64 + (float)(floorf(*(float *)v13.f64 * 0.5) * -2.0)) + -1.0);
  *(float *)&double v18 = v18;
  *(float *)&double v17 = fminf(*((float *)&v8 + 1), fmaxf(*((float *)&v8 + 1) - v7, *(float *)a5.f64));
  float v19 = (float)(vmuls_lane_f32(*(float *)&v18, *(float32x2_t *)a3.f32, 1) + 1.0) * *(float *)&v8;
  v11.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)&double v20 = *(float *)(a1 + 24)
                 + (float)((float)(*(float *)(a1 + 20) * *(float *)&v17) + (float)(v19 * *(float *)(a1 + 16)));
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v18 = *(float *)&v17 * *(float *)(a1 + 32);
  float v35 = 1.0 - vmuls_lane_f32(*(float *)v13.f64 - floorf(*(float *)v13.f64), a3, 2);
  *(float *)v13.f64 = *(float *)v16.i32 + (float)(*(float *)&v18 + (float)(v19 * *(float *)v11.i32));
  *((float *)&v20 + 1) = *(float *)v13.f64;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v20, v13, v18, v17, v11, v16, v9);
  float32x4_t v33 = _Q0;
  _Q1 = a5;
  __asm { FMLA            S0, S11, V1.S[2] }
  *(float *)_Q1.f64 = fmaxf(v10, fminf(_Q0.f32[0], *((float *)&a5.f64[1] + 1) + v10));
  LODWORD(v26) = *(_DWORD *)(a2 + 28);
  _Q0.f32[0] = *(float *)(a2 + 24)
             + (float)((float)(*(float *)_Q1.f64 * *(float *)(a2 + 20)) + (float)(v19 * *(float *)(a2 + 16)));
  LODWORD(v27) = *(_DWORD *)(a2 + 32);
  v28.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)_Q1.f64 = *(float *)v28.i32
                    + (float)((float)(*(float *)_Q1.f64 * *(float *)&v27) + (float)(v19 * *(float *)&v26));
  _Q0.i32[1] = LODWORD(_Q1.f64[0]);
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)_Q0.i64, _Q1, v27, v26, v28, v29, v30);
  *(void *)&double result = vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(v33, 1.0 - a4), v31, a4), v35).u64[0];
  return result;
}

void CI::f4_sr_sr_f3_f_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  int8x16_t v11 = *(double (**)(uint64_t, uint64_t, __n128, float, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  uint64_t v14 = *(void *)(v10 + 56);
  uint64_t v15 = *(void *)(v10 + 80);
  int v16 = *(_DWORD *)(v10 + 112);
  uint64_t v17 = *(void *)(v10 + 104);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 128)), a2);
  }
  double v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    double v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  *(double *)&long long v19 = v11(a4 + 80 * v12, a4 + 80 * v13, *((__n128 *)a2 + 4 * v14), *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

float32x2_t cikernel::_tile(CI *a1, float32x2_t a2, int8x16_t a3)
{
  float32x2_t v4 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), vsub_f32(*(float32x2_t *)CI::getDC(a1), a2));
  return vadd_f32(a2, vmul_f32(*(float32x2_t *)a3.i8, vminnm_f32(vsub_f32(v4, vrndm_f32(v4)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu))));
}

void CI::f2_f2_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int8x16_t v11 = (double (*)(void *, double, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  int v16 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    int v16 = (__n128 *)((char *)a2 + 64 * v15);
  }
  uint64_t v17 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v17 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v17, *v16);
}

float32x2_t cikernel::_lowq_affine(CI *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4)
{
  uint64_t DC = (float32x2_t *)CI::getDC(a1);
  int32x2_t v8 = (int32x2_t)vmul_f32(a3, *DC);
  int32x2_t v9 = (int32x2_t)vmul_f32(a4, *DC);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v8, v9), (float32x2_t)vzip2_s32(v8, v9)));
}

void CI::f2_f2_f2_f2(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int8x16_t v11 = (double (*)(void *, double, double, double))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  int v16 = *(_DWORD *)(v10 + 64);
  uint64_t v17 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  double v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    double v18 = (double *)((char *)a2 + 64 * v17);
  }
  long long v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    long long v19 = (double *)((char *)a2 + 64 * v15);
  }
  double v20 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    double v20 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v20, *v19, *v18);
}

uint64_t CGAffineTransformFromObject(objc_object *a1, CGAffineTransform *a2)
{
  if (!a1)
  {
    long long v5 = *MEMORY[0x1E4F1DAB8];
    long long v6 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
    *(_OWORD *)&a2->c = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *(_OWORD *)&a2->tunint64_t x = v6;
    *(_OWORD *)&a2->CGFloat a = v5;
    return 1;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [(objc_object *)a1 transformStruct];
      *(_OWORD *)&a2->CGFloat a = 0u;
      *(_OWORD *)&a2->c = 0u;
      *(_OWORD *)&a2->tunint64_t x = 0u;
      return 1;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0 && [(objc_object *)a1 count] == 6)
    {
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 0), "doubleValue");
      a2->CGFloat a = v8;
      uint64_t v7 = 1;
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 1), "doubleValue");
      a2->b = v9;
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 2), "doubleValue");
      a2->c = v10;
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 3), "doubleValue");
      a2->d = v11;
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 4), "doubleValue");
      a2->tunint64_t x = v12;
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 5), "doubleValue");
      a2->tunint64_t y = v13;
      return v7;
    }
    return 0;
  }
  float32x2_t v4 = (const char *)[(objc_object *)a1 objCType];
  if (strcmp(v4, "{CGAffineTransform=dddddd}") && strcmp(v4, "{?=dddddd}")) {
    return 0;
  }
  [(objc_object *)a1 getValue:a2 size:48];
  return 1;
}

double cikernel::_ASGh50(uint64x2_t **this, SamplerObj *a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)this);
  double v4 = 2.0;
  double v5 = 0.5;
  v6.f64[0] = floor(floorf(COERCE_FLOAT(*DC)) * 2.0 + 0.499) + 0.5;
  *(float *)v6.f64 = v6.f64[0];
  LODWORD(v5) = *((_DWORD *)this + 4);
  LODWORD(v4) = *((_DWORD *)this + 5);
  v7.i32[1] = 0;
  float v8 = *((float *)this + 6);
  float v9 = *((float *)this + 7);
  *(float *)v10.i32 = v8 + (float)(*(float *)&v5 + (float)(*(float *)&v4 * 0.0));
  float v11 = *((float *)this + 8);
  float v12 = *((float *)this + 9);
  *(float *)&v10.i32[1] = v12 + (float)(v9 + (float)(v11 * 0.0));
  *(float *)v13.i32 = v8 + (float)((float)(*(float *)&v4 * 0.0) + (float)(*(float *)&v5 * 0.0));
  *(float *)v7.i32 = v12 + (float)((float)(v11 * 0.0) + (float)(v9 * 0.0));
  v13.i32[1] = v7.i32[0];
  float32x2_t v14 = vsub_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)v13.i8);
  *(float *)&double v4 = vmuls_lane_f32(*(float *)&v4, *DC, 1);
  *(float *)&double v15 = v8 + (float)(*(float *)&v4 + (float)(*(float *)v6.f64 * *(float *)&v5));
  *(float *)&double v5 = vmuls_lane_f32(v11, *DC, 1);
  *(float *)v6.f64 = v12 + (float)(*(float *)&v5 + (float)(*(float *)v6.f64 * v9));
  HIDWORD(v15) = LODWORD(v6.f64[0]);
  float32x2_t v72 = *(float32x2_t *)&v15;
  *(double *)v16.i64 = CI::BitmapSampler::read(this[1], v15, v6, v5, v4, v7, v13, v10);
  float32x4_t v17 = (float32x4_t)vdupq_n_s32(0x3F0006F2u);
  float32x4_t v69 = vmulq_f32(v16, v17);
  *(double *)v23.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v14, v72)), (float64x2_t)v17, v18, v19, v20, v21, v22);
  float32x4_t v66 = v23;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v72, v14)), v24, v25, v26, v27, v28, v29);
  float64x2_t v31 = (float64x2_t)v69;
  float32x4_t v70 = vaddq_f32(v69, vmulq_f32(vaddq_f32(v66, _Q0), (float32x4_t)vdupq_n_s32(0x3E96D656u)));
  __asm { FMOV            V0.2S, #3.0 }
  float32x2_t v36 = vmul_f32(v14, *(float32x2_t *)_Q0.f32);
  *(double *)v42.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v36, v72)), v31, v37, v38, v39, v40, v41);
  float32x4_t v67 = v42;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v72, v36)), v43, v44, v45, v46, v47, v48);
  float64x2_t v50 = (float64x2_t)v70;
  float32x4_t v71 = vaddq_f32(v70, vmulq_f32(vaddq_f32(v67, _Q0), (float32x4_t)vdupq_n_s32(0xBD4FC321)));
  __asm { FMOV            V0.2S, #5.0 }
  float32x2_t v51 = vmul_f32(v14, *(float32x2_t *)_Q0.f32);
  *(double *)v57.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v51, v72)), v50, v52, v53, v54, v55, v56);
  float32x4_t v68 = v57;
  *(double *)v64.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v72, v51)), v58, v59, v60, v61, v62, v63);
  *(void *)&double result = vaddq_f32(v71, vmulq_f32(vaddq_f32(v68, v64), (float32x4_t)vdupq_n_s32(0x3BC6C851u))).u64[0];
  return result;
}

void CI::f4_sr(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  float v11 = *(double (**)(uint64_t))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 32)), a2);
  }
  *(double *)&long long v13 = v11(a4 + 80 * v12);
  *(_OWORD *)(a3 + 16 * a7) = v13;
}

double cikernel::_ASGv50(uint64x2_t **this, SamplerObj *a2)
{
  uint64_t DC = (void *)CI::getDC((CI *)this);
  double v4 = 2.0;
  double v5 = 0.5;
  v6.f64[0] = floor(floorf(COERCE_FLOAT(HIDWORD(*DC))) * 2.0 + 0.499) + 0.5;
  *(float *)v6.f64 = v6.f64[0];
  LODWORD(v5) = *((_DWORD *)this + 4);
  LODWORD(v4) = *((_DWORD *)this + 5);
  v7.i32[1] = 0;
  v8.i32[0] = *((_DWORD *)this + 6);
  float v9 = *((float *)this + 7);
  *(float *)v10.i32 = *(float *)v8.i32 + (float)(*(float *)&v4 + (float)(*(float *)&v5 * 0.0));
  float v11 = *((float *)this + 8);
  float v12 = *((float *)this + 9);
  *(float *)&v10.i32[1] = v12 + (float)(v11 + (float)(v9 * 0.0));
  v13.f32[0] = *(float *)v8.i32 + (float)((float)(*(float *)&v4 * 0.0) + (float)(*(float *)&v5 * 0.0));
  *(float *)v7.i32 = v12 + (float)((float)(v11 * 0.0) + (float)(v9 * 0.0));
  v13.f32[1] = *(float *)v7.i32;
  float32x2_t v14 = vsub_f32(*(float32x2_t *)v10.i8, v13);
  *(float *)&double v4 = vmlas_n_f32(*(float *)&v4 * *(float *)v6.f64, *(float *)&v5, COERCE_FLOAT(*DC));
  *(float *)&double v5 = *(float *)v8.i32 + *(float *)&v4;
  *(float *)v6.f64 = v12 + vmlas_n_f32(v11 * *(float *)v6.f64, v9, COERCE_FLOAT(*DC));
  *(float *)&double v15 = *(float *)v8.i32 + *(float *)&v4;
  HIDWORD(v15) = LODWORD(v6.f64[0]);
  float32x2_t v72 = *(float32x2_t *)&v15;
  *(double *)v16.i64 = CI::BitmapSampler::read(this[1], v15, v6, v5, v4, v7, v10, v8);
  float32x4_t v17 = (float32x4_t)vdupq_n_s32(0x3F0006F2u);
  float32x4_t v69 = vmulq_f32(v16, v17);
  *(double *)v23.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v14, v72)), (float64x2_t)v17, v18, v19, v20, v21, v22);
  float32x4_t v66 = v23;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v72, v14)), v24, v25, v26, v27, v28, v29);
  float64x2_t v31 = (float64x2_t)v69;
  float32x4_t v70 = vaddq_f32(v69, vmulq_f32(vaddq_f32(v66, _Q0), (float32x4_t)vdupq_n_s32(0x3E96D656u)));
  __asm { FMOV            V0.2S, #3.0 }
  float32x2_t v36 = vmul_f32(v14, *(float32x2_t *)_Q0.f32);
  *(double *)v42.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v36, v72)), v31, v37, v38, v39, v40, v41);
  float32x4_t v67 = v42;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v72, v36)), v43, v44, v45, v46, v47, v48);
  float64x2_t v50 = (float64x2_t)v70;
  float32x4_t v71 = vaddq_f32(v70, vmulq_f32(vaddq_f32(v67, _Q0), (float32x4_t)vdupq_n_s32(0xBD4FC321)));
  __asm { FMOV            V0.2S, #5.0 }
  float32x2_t v51 = vmul_f32(v14, *(float32x2_t *)_Q0.f32);
  *(double *)v57.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v51, v72)), v50, v52, v53, v54, v55, v56);
  float32x4_t v68 = v57;
  *(double *)v64.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v72, v51)), v58, v59, v60, v61, v62, v63);
  *(void *)&double result = vaddq_f32(v71, vmulq_f32(vaddq_f32(v68, v64), (float32x4_t)vdupq_n_s32(0x3BC6C851u))).u64[0];
  return result;
}

double cikernel::_ASGh66(uint64x2_t **this, SamplerObj *a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)this);
  float v4 = 0.5 * COERCE_FLOAT(*DC);
  float v5 = floorf(v4);
  float v6 = floor((float)(v4 - v5) + (float)(v4 - v5));
  float v88 = v6;
  double v7 = 1.5;
  v8.f64[0] = floor(floorf(COERCE_FLOAT(*DC)) * 1.5 + 0.499) + 0.5;
  *(float *)v8.f64 = v8.f64[0];
  float v9 = *((float *)this + 4);
  LODWORD(v7) = *((_DWORD *)this + 5);
  v10.i32[1] = 0;
  float v11 = *((float *)this + 6);
  float v12 = *((float *)this + 7);
  *(float *)v13.i32 = v11 + (float)(v9 + (float)(*(float *)&v7 * 0.0));
  float v14 = *((float *)this + 8);
  float v15 = *((float *)this + 9);
  *(float *)&v13.i32[1] = v15 + (float)(v12 + (float)(v14 * 0.0));
  *(float *)v16.i32 = v11 + (float)((float)(*(float *)&v7 * 0.0) + (float)(v9 * 0.0));
  *(float *)v10.i32 = v15 + (float)((float)(v14 * 0.0) + (float)(v12 * 0.0));
  v16.i32[1] = v10.i32[0];
  float32x2_t v17 = vsub_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v16.i8);
  float32x2_t v18 = vadd_f32(v17, v17);
  float32x2_t v19 = vadd_f32(v17, v18);
  float32x2_t v20 = vadd_f32(v18, v18);
  *(float *)&double v7 = vmuls_lane_f32(*(float *)&v7, *DC, 1);
  *(float *)&double v21 = v11 + (float)(*(float *)&v7 + (float)(*(float *)v8.f64 * v9));
  *((float *)&v21 + 1) = v15 + (float)(vmuls_lane_f32(v14, *DC, 1) + (float)(*(float *)v8.f64 * v12));
  double v89 = v21;
  *(double *)v22.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v21, v20)), v8, v21, v7, v10, v16, v13);
  float32x4_t v86 = v22;
  *(double *)v29.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v89, v19)), v23, v24, v25, v26, v27, v28);
  float32x4_t v87 = v29;
  *(double *)v36.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v89, v18)), v30, v31, v32, v33, v34, v35);
  float32x4_t v85 = v36;
  *(double *)v43.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v89, v17)), v37, v38, v39, v40, v41, v42);
  float32x4_t v84 = v43;
  *(double *)v50.i64 = CI::BitmapSampler::read(this[1], v89, v44, v45, v46, v47, v48, v49);
  float32x4_t v83 = v50;
  *(double *)v57.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v89)), v51, v52, v53, v54, v55, v56);
  float32x4_t v81 = v57;
  *(double *)v64.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v18, *(float32x2_t *)&v89)), v58, v59, v60, v61, v62, v63);
  float32x4_t v80 = v64;
  *(double *)v71.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v89, v19)), v65, v66, v67, v68, v69, v70);
  float32x4_t v82 = v71;
  *(double *)v78.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v89, v20)), v72, v73, v74, v75, v76, v77);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v83, (float32x4_t)vdupq_n_s32(0x3F2AA3BCu)), vmulq_f32(vaddq_f32(v84, v81), (float32x4_t)vdupq_n_s32(0x3E75B08Du))), vmulq_f32(vaddq_f32(v85, v80), (float32x4_t)vdupq_n_s32(0xBD9EC1EA))), vmulq_f32(vaddq_f32(v86, v78), (float32x4_t)vdupq_n_s32(0x3B8D1E61u))), 1.0 - v88), vaddq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v83, v81), (float32x4_t)vdupq_n_s32(0x3F086A95u)), vmulq_f32(vaddq_f32(v85, v82), (float32x4_t)vdupq_n_s32(0xBD32FB50))), vmulq_f32(vaddq_f32(v87, v78), (float32x4_t)vdupq_n_s32(0x3C31480Cu))), v88).u64[0];
  return result;
}

double cikernel::_ASGv66(uint64x2_t **this, SamplerObj *a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)this);
  float v4 = vmuls_lane_f32(0.5, *DC, 1);
  float v5 = floorf(v4);
  float v6 = floor((float)(v4 - v5) + (float)(v4 - v5));
  float v88 = v6;
  double v7 = 1.5;
  v8.f64[0] = floor(floorf(COERCE_FLOAT(HIDWORD(*(unint64_t *)DC))) * 1.5 + 0.499) + 0.5;
  *(float *)v8.f64 = v8.f64[0];
  float v9 = *((float *)this + 4);
  LODWORD(v7) = *((_DWORD *)this + 5);
  v10.i32[1] = 0;
  v11.i32[0] = *((_DWORD *)this + 6);
  float v12 = *((float *)this + 7);
  *(float *)v13.i32 = *(float *)v11.i32 + (float)(*(float *)&v7 + (float)(v9 * 0.0));
  float v14 = *((float *)this + 8);
  float v15 = *((float *)this + 9);
  *(float *)&v13.i32[1] = v15 + (float)(v14 + (float)(v12 * 0.0));
  v16.f32[0] = *(float *)v11.i32 + (float)((float)(*(float *)&v7 * 0.0) + (float)(v9 * 0.0));
  *(float *)v10.i32 = v15 + (float)((float)(v14 * 0.0) + (float)(v12 * 0.0));
  v16.f32[1] = *(float *)v10.i32;
  float32x2_t v17 = vsub_f32(*(float32x2_t *)v13.i8, v16);
  float32x2_t v18 = vadd_f32(v17, v17);
  float32x2_t v19 = vadd_f32(v17, v18);
  float32x2_t v20 = vadd_f32(v18, v18);
  *(float *)&double v7 = vmlas_n_f32(*(float *)&v7 * *(float *)v8.f64, v9, COERCE_FLOAT(*DC));
  *(float *)&double v21 = *(float *)v11.i32 + *(float *)&v7;
  *(float *)v8.f64 = vmlas_n_f32(v14 * *(float *)v8.f64, v12, COERCE_FLOAT(*DC));
  *((float *)&v21 + 1) = v15 + *(float *)v8.f64;
  double v89 = v21;
  *(double *)v22.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v21, v20)), v8, v21, v7, v10, v13, v11);
  float32x4_t v86 = v22;
  *(double *)v29.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v89, v19)), v23, v24, v25, v26, v27, v28);
  float32x4_t v87 = v29;
  *(double *)v36.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v89, v18)), v30, v31, v32, v33, v34, v35);
  float32x4_t v85 = v36;
  *(double *)v43.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v89, v17)), v37, v38, v39, v40, v41, v42);
  float32x4_t v84 = v43;
  *(double *)v50.i64 = CI::BitmapSampler::read(this[1], v89, v44, v45, v46, v47, v48, v49);
  float32x4_t v83 = v50;
  *(double *)v57.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v89)), v51, v52, v53, v54, v55, v56);
  float32x4_t v81 = v57;
  *(double *)v64.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v18, *(float32x2_t *)&v89)), v58, v59, v60, v61, v62, v63);
  float32x4_t v80 = v64;
  *(double *)v71.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v19, *(float32x2_t *)&v89)), v65, v66, v67, v68, v69, v70);
  float32x4_t v82 = v71;
  *(double *)v78.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v20, *(float32x2_t *)&v89)), v72, v73, v74, v75, v76, v77);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v83, (float32x4_t)vdupq_n_s32(0x3F2AA3BCu)), vmulq_f32(vaddq_f32(v84, v81), (float32x4_t)vdupq_n_s32(0x3E75B08Du))), vmulq_f32(vaddq_f32(v85, v80), (float32x4_t)vdupq_n_s32(0xBD9EC1EA))), vmulq_f32(vaddq_f32(v86, v78), (float32x4_t)vdupq_n_s32(0x3B8D1E61u))), 1.0 - v88), vaddq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v83, v81), (float32x4_t)vdupq_n_s32(0x3F086A95u)), vmulq_f32(vaddq_f32(v85, v82), (float32x4_t)vdupq_n_s32(0xBD32FB50))), vmulq_f32(vaddq_f32(v87, v78), (float32x4_t)vdupq_n_s32(0x3C31480Cu))), v88).u64[0];
  return result;
}

double cikernel::_ASGv75(uint64x2_t **this, SamplerObj *a2)
{
  uint64_t DC = (void *)CI::getDC((CI *)this);
  LODWORD(v4) = HIDWORD(*DC);
  float v5 = floor((float)((float)(v4 / 3.0) - floorf(v4 / 3.0)) * 3.0);
  double v6 = 0.5;
  v7.f64[0] = floor(floorf(v4) * 1.33333333 + 0.5) + 0.5;
  *(float *)v7.f64 = v7.f64[0];
  float v8 = *((float *)this + 4);
  LODWORD(v6) = *((_DWORD *)this + 5);
  v9.i32[0] = *((_DWORD *)this + 6);
  v10.i32[0] = *((_DWORD *)this + 7);
  *(float *)v11.i32 = *(float *)v9.i32 + (float)(*(float *)&v6 + (float)(v8 * 0.0));
  float v12 = *((float *)this + 8);
  float v13 = *((float *)this + 9);
  *(float *)&v11.i32[1] = v13 + (float)(v12 + (float)(*(float *)v10.i32 * 0.0));
  v14.f32[0] = *(float *)v9.i32 + (float)((float)(*(float *)&v6 * 0.0) + (float)(v8 * 0.0));
  v14.f32[1] = v13 + (float)((float)(v12 * 0.0) + (float)(*(float *)v10.i32 * 0.0));
  float32x2_t v15 = vsub_f32(*(float32x2_t *)v11.i8, v14);
  float32x2_t v16 = vadd_f32(v15, v15);
  float32x2_t v17 = vadd_f32(v15, v16);
  float32x2_t v18 = vadd_f32(v16, v16);
  *(float *)&double v6 = vmlas_n_f32(*(float *)&v6 * *(float *)v7.f64, v8, COERCE_FLOAT(*DC));
  *(float *)&double v19 = *(float *)v9.i32 + *(float *)&v6;
  *(float *)v7.f64 = vmlas_n_f32(v12 * *(float *)v7.f64, *(float *)v10.i32, COERCE_FLOAT(*DC));
  *((float *)&v19 + 1) = v13 + *(float *)v7.f64;
  double v96 = v19;
  *(double *)v20.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v19, v18)), v7, v19, v6, v11, v9, v10);
  float32x4_t v95 = v20;
  *(double *)v27.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v17)), v21, v22, v23, v24, v25, v26);
  float32x4_t v94 = v27;
  *(double *)v34.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v16)), v28, v29, v30, v31, v32, v33);
  float32x4_t v93 = v34;
  *(double *)v41.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v15)), v35, v36, v37, v38, v39, v40);
  float32x4_t v92 = v41;
  *(double *)v48.i64 = CI::BitmapSampler::read(this[1], v96, v42, v43, v44, v45, v46, v47);
  float32x4_t v91 = v48;
  *(double *)v55.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v15, *(float32x2_t *)&v96)), v49, v50, v51, v52, v53, v54);
  float32x4_t v90 = v55;
  *(double *)v62.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v16, *(float32x2_t *)&v96)), v56, v57, v58, v59, v60, v61);
  float32x4_t v89 = v62;
  *(double *)v69.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v96)), v63, v64, v65, v66, v67, v68);
  float32x4_t v88 = v69;
  *(double *)v76.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v18, *(float32x2_t *)&v96)), v70, v71, v72, v73, v74, v75);
  float32x4_t v77 = (float32x4_t)vdupq_n_s32(0x39C168EBu);
  float32x4_t v78 = (float32x4_t)vdupq_n_s32(0x3C151754u);
  float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x3D0D1CCEu);
  float32x4_t v80 = vmulq_f32(v91, (float32x4_t)vdupq_n_s32(0x3F2998B2u));
  float32x4_t v81 = (float32x4_t)vdupq_n_s32(0x3EE24338u);
  float32x4_t v82 = (float32x4_t)vdupq_n_s32(0x3DA75B23u);
  float32x4_t v83 = (float32x4_t)vdupq_n_s32(0x3B46B2D7u);
  float32x4_t v84 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vmulq_f32(v94, v78), vmulq_f32(v95, v77)), vmulq_f32(v93, v79)), v80), vmulq_f32(v90, v81)), vmulq_f32(v89, v82)), vmulq_f32(v76, v83));
  float32x4_t v85 = vsubq_f32(vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v95, v83), vmulq_f32(v93, v82)), vmulq_f32(v92, v81)), v80), vmulq_f32(v89, v79)), vmulq_f32(v88, v78)), vmulq_f32(v76, v77));
  v78.f32[0] = fminf(v5, 1.0);
  float32x4_t v86 = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v91, (float32x4_t)vdupq_n_s32(0x3F4010EAu)), vmulq_f32(vaddq_f32(v92, v90), (float32x4_t)vdupq_n_s32(0x3E41574Eu))), vmulq_f32(vaddq_f32(v93, v89), (float32x4_t)vdupq_n_s32(0xBD9BD797))), vmulq_f32(vaddq_f32(v94, v88), (float32x4_t)vdupq_n_s32(0x3C472ACCu))), 1.0 - v78.f32[0]), v84, v78.f32[0]);
  v84.f32[0] = fmaxf(v5 + -1.0, 0.0);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v86, 1.0 - v84.f32[0]), v85, v84.f32[0]).u64[0];
  return result;
}

double cikernel::_ASGh80(uint64x2_t **this, SamplerObj *a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)this);
  float v4 = floor((float)((float)(0.25 * COERCE_FLOAT(*DC)) - floorf(0.25 * COERCE_FLOAT(*DC))) * 4.0);
  double v5 = 1.25;
  v6.f64[0] = floor(floorf(COERCE_FLOAT(*DC)) * 1.25 + 0.499) + 0.5;
  *(float *)v6.f64 = v6.f64[0];
  float v7 = *((float *)this + 4);
  LODWORD(v5) = *((_DWORD *)this + 5);
  v8.i32[0] = *((_DWORD *)this + 6);
  float v9 = *((float *)this + 7);
  *(float *)v10.i32 = *(float *)v8.i32 + (float)(v7 + (float)(*(float *)&v5 * 0.0));
  float v11 = *((float *)this + 8);
  float v12 = *((float *)this + 9);
  *(float *)&v10.i32[1] = v12 + (float)(v9 + (float)(v11 * 0.0));
  *(float *)v13.i32 = *(float *)v8.i32 + (float)((float)(*(float *)&v5 * 0.0) + (float)(v7 * 0.0));
  *(float *)&v13.i32[1] = v12 + (float)((float)(v11 * 0.0) + (float)(v9 * 0.0));
  float32x2_t v14 = vsub_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)v13.i8);
  float32x2_t v15 = vadd_f32(v14, v14);
  float32x2_t v16 = vadd_f32(v14, v15);
  float32x2_t v17 = vadd_f32(v15, v15);
  *(float *)&double v5 = vmuls_lane_f32(*(float *)&v5, *DC, 1);
  *(float *)&double v18 = *(float *)v8.i32 + (float)(*(float *)&v5 + (float)(*(float *)v6.f64 * v7));
  *((float *)&v18 + 1) = v12 + (float)(vmuls_lane_f32(v11, *DC, 1) + (float)(*(float *)v6.f64 * v9));
  double v96 = v18;
  *(double *)v19.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v18, v17)), v6, v18, v5, v13, v10, v8);
  float32x4_t v95 = v19;
  *(double *)v26.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v16)), v20, v21, v22, v23, v24, v25);
  float32x4_t v94 = v26;
  *(double *)v33.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v15)), v27, v28, v29, v30, v31, v32);
  float32x4_t v93 = v33;
  *(double *)v40.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v14)), v34, v35, v36, v37, v38, v39);
  float32x4_t v92 = v40;
  *(double *)v47.i64 = CI::BitmapSampler::read(this[1], v96, v41, v42, v43, v44, v45, v46);
  float32x4_t v91 = v47;
  *(double *)v54.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v14, *(float32x2_t *)&v96)), v48, v49, v50, v51, v52, v53);
  float32x4_t v90 = v54;
  *(double *)v61.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v15, *(float32x2_t *)&v96)), v55, v56, v57, v58, v59, v60);
  float32x4_t v89 = v61;
  *(double *)v68.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v96, v16)), v62, v63, v64, v65, v66, v67);
  float32x4_t v88 = v68;
  *(double *)v75.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v96, v17)), v69, v70, v71, v72, v73, v74);
  float32x4_t v76 = (float32x4_t)vdupq_n_s32(0x395DE0F1u);
  float32x4_t v77 = (float32x4_t)vdupq_n_s32(0x3BE3920Bu);
  float32x4_t v78 = (float32x4_t)vdupq_n_s32(0x3CE3D41Bu);
  float32x4_t v79 = vmulq_f32(v91, (float32x4_t)vdupq_n_s32(0x3F3D4D47u));
  float32x4_t v80 = (float32x4_t)vdupq_n_s32(0x3EB8D105u);
  float32x4_t v81 = (float32x4_t)vdupq_n_s32(0x3DBB4F61u);
  float32x4_t v82 = (float32x4_t)vdupq_n_s32(0x3C465F60u);
  float32x4_t v83 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vmulq_f32(v94, v77), vmulq_f32(v95, v76)), vmulq_f32(v93, v78)), v79), vmulq_f32(v90, v80)), vmulq_f32(v89, v81)), vmulq_f32(v88, v82));
  float32x4_t v84 = vsubq_f32(vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v94, v82), vmulq_f32(v93, v81)), vmulq_f32(v92, v80)), v79), vmulq_f32(v89, v78)), vmulq_f32(v88, v77)), vmulq_f32(v75, v76));
  v77.f32[0] = fminf(v4, 1.0);
  float32x4_t v85 = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v91, (float32x4_t)vdupq_n_s32(0x3F4CDCC0u)), vmulq_f32(vaddq_f32(v92, v90), (float32x4_t)vdupq_n_s32(0x3E1CCAF7u))), vmulq_f32(vaddq_f32(v93, v89), (float32x4_t)vdupq_n_s32(0xBD84D643))), vmulq_f32(vaddq_f32(v94, v88), (float32x4_t)vdupq_n_s32(0x3C456854u))), vmulq_f32(vaddq_f32(v95, v75), (float32x4_t)vdupq_n_s32(0xB9DFA948))), 1.0 - v77.f32[0]), v83, v77.f32[0]);
  v83.f32[0] = fmaxf(v4 + -1.0, 0.0);
  float32x4_t v86 = vmlaq_n_f32(vmulq_n_f32(v85, 1.0 - v83.f32[0]), vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v91, v90), (float32x4_t)vdupq_n_s32(0x3F138E4Au)), vmulq_f32(vaddq_f32(v92, v89), (float32x4_t)vdupq_n_s32(0xBDA10EBE))), vmulq_f32(vaddq_f32(v94, v75), (float32x4_t)vdupq_n_s32(0x3B14DF20u))), vmulq_f32(v95, (float32x4_t)vdupq_n_s32(0xB82907CC))), v83.f32[0]);
  v83.f32[0] = fmaxf(v4 + -2.0, 0.0);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v86, 1.0 - v83.f32[0]), v84, v83.f32[0]).u64[0];
  return result;
}

double cikernel::_ASGv80(uint64x2_t **this, SamplerObj *a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)this);
  float v4 = vmuls_lane_f32(0.25, *DC, 1);
  float v5 = floor((float)(v4 - floorf(v4)) * 4.0);
  double v6 = 1.25;
  v7.f64[0] = floor(floorf(COERCE_FLOAT(HIDWORD(*(unint64_t *)DC))) * 1.25 + 0.499) + 0.5;
  *(float *)v7.f64 = v7.f64[0];
  float v8 = *((float *)this + 4);
  LODWORD(v6) = *((_DWORD *)this + 5);
  v9.i32[0] = *((_DWORD *)this + 6);
  v10.i32[0] = *((_DWORD *)this + 7);
  *(float *)v11.i32 = *(float *)v9.i32 + (float)(*(float *)&v6 + (float)(v8 * 0.0));
  float v12 = *((float *)this + 8);
  float v13 = *((float *)this + 9);
  *(float *)&v11.i32[1] = v13 + (float)(v12 + (float)(*(float *)v10.i32 * 0.0));
  v14.f32[0] = *(float *)v9.i32 + (float)((float)(*(float *)&v6 * 0.0) + (float)(v8 * 0.0));
  v14.f32[1] = v13 + (float)((float)(v12 * 0.0) + (float)(*(float *)v10.i32 * 0.0));
  float32x2_t v15 = vsub_f32(*(float32x2_t *)v11.i8, v14);
  float32x2_t v16 = vadd_f32(v15, v15);
  float32x2_t v17 = vadd_f32(v15, v16);
  float32x2_t v18 = vadd_f32(v16, v16);
  *(float *)&double v6 = vmlas_n_f32(*(float *)&v6 * *(float *)v7.f64, v8, COERCE_FLOAT(*DC));
  *(float *)&double v19 = *(float *)v9.i32 + *(float *)&v6;
  *(float *)v7.f64 = vmlas_n_f32(v12 * *(float *)v7.f64, *(float *)v10.i32, COERCE_FLOAT(*DC));
  *((float *)&v19 + 1) = v13 + *(float *)v7.f64;
  double v97 = v19;
  *(double *)v20.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v19, v18)), v7, v19, v6, v11, v9, v10);
  float32x4_t v96 = v20;
  *(double *)v27.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v97, v17)), v21, v22, v23, v24, v25, v26);
  float32x4_t v95 = v27;
  *(double *)v34.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v97, v16)), v28, v29, v30, v31, v32, v33);
  float32x4_t v94 = v34;
  *(double *)v41.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v97, v15)), v35, v36, v37, v38, v39, v40);
  float32x4_t v93 = v41;
  *(double *)v48.i64 = CI::BitmapSampler::read(this[1], v97, v42, v43, v44, v45, v46, v47);
  float32x4_t v92 = v48;
  *(double *)v55.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v15, *(float32x2_t *)&v97)), v49, v50, v51, v52, v53, v54);
  float32x4_t v91 = v55;
  *(double *)v62.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v16, *(float32x2_t *)&v97)), v56, v57, v58, v59, v60, v61);
  float32x4_t v90 = v62;
  *(double *)v69.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v97)), v63, v64, v65, v66, v67, v68);
  float32x4_t v89 = v69;
  *(double *)v76.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v18, *(float32x2_t *)&v97)), v70, v71, v72, v73, v74, v75);
  float32x4_t v77 = (float32x4_t)vdupq_n_s32(0x395DE0F1u);
  float32x4_t v78 = (float32x4_t)vdupq_n_s32(0x3BE3920Bu);
  float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x3CE3D41Bu);
  float32x4_t v80 = vmulq_f32(v92, (float32x4_t)vdupq_n_s32(0x3F3D4D47u));
  float32x4_t v81 = (float32x4_t)vdupq_n_s32(0x3EB8D105u);
  float32x4_t v82 = (float32x4_t)vdupq_n_s32(0x3DBB4F61u);
  float32x4_t v83 = (float32x4_t)vdupq_n_s32(0x3C465F60u);
  float32x4_t v84 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vmulq_f32(v95, v78), vmulq_f32(v96, v77)), vmulq_f32(v94, v79)), v80), vmulq_f32(v91, v81)), vmulq_f32(v90, v82)), vmulq_f32(v89, v83));
  float32x4_t v85 = vsubq_f32(vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v95, v83), vmulq_f32(v94, v82)), vmulq_f32(v93, v81)), v80), vmulq_f32(v90, v79)), vmulq_f32(v89, v78)), vmulq_f32(v76, v77));
  v78.f32[0] = fminf(v5, 1.0);
  float32x4_t v86 = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v92, (float32x4_t)vdupq_n_s32(0x3F4CDCC0u)), vmulq_f32(vaddq_f32(v93, v91), (float32x4_t)vdupq_n_s32(0x3E1CCAF7u))), vmulq_f32(vaddq_f32(v94, v90), (float32x4_t)vdupq_n_s32(0xBD84D643))), vmulq_f32(vaddq_f32(v95, v89), (float32x4_t)vdupq_n_s32(0x3C456854u))), vmulq_f32(vaddq_f32(v96, v76), (float32x4_t)vdupq_n_s32(0xB9DFA948))), 1.0 - v78.f32[0]), v84, v78.f32[0]);
  v84.f32[0] = fmaxf(v5 + -1.0, 0.0);
  float32x4_t v87 = vmlaq_n_f32(vmulq_n_f32(v86, 1.0 - v84.f32[0]), vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v92, v91), (float32x4_t)vdupq_n_s32(0x3F138E4Au)), vmulq_f32(vaddq_f32(v93, v90), (float32x4_t)vdupq_n_s32(0xBDA10EBE))), vmulq_f32(vaddq_f32(v95, v76), (float32x4_t)vdupq_n_s32(0x3B14DF20u))), vmulq_f32(v96, (float32x4_t)vdupq_n_s32(0xB82907CC))), v84.f32[0]);
  v84.f32[0] = fmaxf(v5 + -2.0, 0.0);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v87, 1.0 - v84.f32[0]), v85, v84.f32[0]).u64[0];
  return result;
}

double cikernel::_ASGh60(uint64x2_t **this, SamplerObj *a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)this);
  float v4 = floor((float)((float)(COERCE_FLOAT(*DC) / 3.0) - floorf(COERCE_FLOAT(*DC) / 3.0)) * 3.0);
  v5.f64[0] = floor(floorf(COERCE_FLOAT(*DC)) / 0.6 + 0.499) + 0.5;
  *(float *)v5.f64 = v5.f64[0];
  float v6 = *((float *)this + 4);
  float v7 = *((float *)this + 5);
  v8.i32[0] = *((_DWORD *)this + 6);
  float v9 = *((float *)this + 7);
  *(float *)v10.i32 = *(float *)v8.i32 + (float)(v6 + (float)(v7 * 0.0));
  float v11 = *((float *)this + 8);
  float v12 = *((float *)this + 9);
  *(float *)&v10.i32[1] = v12 + (float)(v9 + (float)(v11 * 0.0));
  *(float *)v13.i32 = *(float *)v8.i32 + (float)((float)(v7 * 0.0) + (float)(v6 * 0.0));
  *(float *)&v13.i32[1] = v12 + (float)((float)(v11 * 0.0) + (float)(v9 * 0.0));
  float32x2_t v14 = vsub_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)v13.i8);
  float32x2_t v15 = vadd_f32(v14, v14);
  float32x2_t v16 = vadd_f32(v14, v15);
  float32x2_t v17 = vadd_f32(v15, v15);
  *(float *)&double v18 = vmuls_lane_f32(v7, *DC, 1);
  *(float *)&double v19 = *(float *)v8.i32 + (float)(*(float *)&v18 + (float)(*(float *)v5.f64 * v6));
  *((float *)&v19 + 1) = v12 + (float)(vmuls_lane_f32(v11, *DC, 1) + (float)(*(float *)v5.f64 * v9));
  double v96 = v19;
  *(double *)v20.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v19, v17)), v5, v19, v18, v13, v10, v8);
  float32x4_t v95 = v20;
  *(double *)v27.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v16)), v21, v22, v23, v24, v25, v26);
  float32x4_t v94 = v27;
  *(double *)v34.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v15)), v28, v29, v30, v31, v32, v33);
  float32x4_t v93 = v34;
  *(double *)v41.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v14)), v35, v36, v37, v38, v39, v40);
  float32x4_t v92 = v41;
  *(double *)v48.i64 = CI::BitmapSampler::read(this[1], v96, v42, v43, v44, v45, v46, v47);
  float32x4_t v91 = v48;
  *(double *)v55.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v14, *(float32x2_t *)&v96)), v49, v50, v51, v52, v53, v54);
  float32x4_t v90 = v55;
  *(double *)v62.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v15, *(float32x2_t *)&v96)), v56, v57, v58, v59, v60, v61);
  float32x4_t v89 = v62;
  *(double *)v69.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v16, *(float32x2_t *)&v96)), v63, v64, v65, v66, v67, v68);
  float32x4_t v88 = v69;
  *(double *)v76.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v96)), v70, v71, v72, v73, v74, v75);
  float32x4_t v77 = (float32x4_t)vdupq_n_s32(0x3C14C7A3u);
  float32x4_t v78 = (float32x4_t)vdupq_n_s32(0x3D474371u);
  float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x3EDD553Fu);
  float32x4_t v80 = vmulq_f32(v91, (float32x4_t)vdupq_n_s32(0x3F0DF9F0u));
  float32x4_t v81 = (float32x4_t)vdupq_n_s32(0x3DEB32CFu);
  float32x4_t v82 = (float32x4_t)vdupq_n_s32(0x3D8C7B7Cu);
  float32x4_t v83 = (float32x4_t)vdupq_n_s32(0x3BAAAD28u);
  float32x4_t v84 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v95, v77), vmulq_f32(v94, v78)), vmulq_f32(v92, v79)), v80), vmulq_f32(v90, v81)), vmulq_f32(v89, v82)), vmulq_f32(v76, v83));
  float32x4_t v85 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v95, v83), vmulq_f32(v93, v82)), vmulq_f32(v92, v81)), v80), vmulq_f32(v90, v79)), vmulq_f32(v88, v78)), vmulq_f32(v76, v77));
  v78.f32[0] = fminf(v4, 1.0);
  float32x4_t v86 = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v91, (float32x4_t)vdupq_n_s32(0x3F19A4F0u)), vmulq_f32(vaddq_f32(v92, v90), (float32x4_t)vdupq_n_s32(0x3E8A9AC3u))), vmulq_f32(vaddq_f32(v93, v89), (float32x4_t)vdupq_n_s32(0xBD71927F))), vmulq_f32(vaddq_f32(v94, v88), (float32x4_t)vdupq_n_s32(0xBCAADC82))), vmulq_f32(vaddq_f32(v95, v76), (float32x4_t)vdupq_n_s32(0x3C140D7Eu))), 1.0 - v78.f32[0]), v84, v78.f32[0]);
  v84.f32[0] = fmaxf(v4 + -1.0, 0.0);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v86, 1.0 - v84.f32[0]), v85, v84.f32[0]).u64[0];
  return result;
}

double cikernel::_ASGv60(uint64x2_t **this, SamplerObj *a2)
{
  uint64_t DC = (void *)CI::getDC((CI *)this);
  LODWORD(v4) = HIDWORD(*DC);
  double v5 = 3.0;
  float v6 = floor((float)((float)(v4 / 3.0) - floorf(v4 / 3.0)) * 3.0);
  v7.f64[0] = floor(floorf(v4) / 0.6 + 0.499) + 0.5;
  *(float *)v7.f64 = v7.f64[0];
  float v8 = *((float *)this + 4);
  LODWORD(v5) = *((_DWORD *)this + 5);
  v9.i32[0] = *((_DWORD *)this + 6);
  v10.i32[0] = *((_DWORD *)this + 7);
  *(float *)v11.i32 = *(float *)v9.i32 + (float)(*(float *)&v5 + (float)(v8 * 0.0));
  float v12 = *((float *)this + 8);
  float v13 = *((float *)this + 9);
  *(float *)&v11.i32[1] = v13 + (float)(v12 + (float)(*(float *)v10.i32 * 0.0));
  v14.f32[0] = *(float *)v9.i32 + (float)((float)(*(float *)&v5 * 0.0) + (float)(v8 * 0.0));
  v14.f32[1] = v13 + (float)((float)(v12 * 0.0) + (float)(*(float *)v10.i32 * 0.0));
  float32x2_t v15 = vsub_f32(*(float32x2_t *)v11.i8, v14);
  float32x2_t v16 = vadd_f32(v15, v15);
  float32x2_t v17 = vadd_f32(v15, v16);
  float32x2_t v18 = vadd_f32(v16, v16);
  *(float *)&double v5 = vmlas_n_f32(*(float *)&v5 * *(float *)v7.f64, v8, COERCE_FLOAT(*DC));
  *(float *)&double v19 = *(float *)v9.i32 + *(float *)&v5;
  *(float *)v7.f64 = vmlas_n_f32(v12 * *(float *)v7.f64, *(float *)v10.i32, COERCE_FLOAT(*DC));
  *((float *)&v19 + 1) = v13 + *(float *)v7.f64;
  double v96 = v19;
  *(double *)v20.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v19, v18)), v7, v19, v5, v11, v9, v10);
  float32x4_t v95 = v20;
  *(double *)v27.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v17)), v21, v22, v23, v24, v25, v26);
  float32x4_t v94 = v27;
  *(double *)v34.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v16)), v28, v29, v30, v31, v32, v33);
  float32x4_t v93 = v34;
  *(double *)v41.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v96, v15)), v35, v36, v37, v38, v39, v40);
  float32x4_t v92 = v41;
  *(double *)v48.i64 = CI::BitmapSampler::read(this[1], v96, v42, v43, v44, v45, v46, v47);
  float32x4_t v91 = v48;
  *(double *)v55.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v15, *(float32x2_t *)&v96)), v49, v50, v51, v52, v53, v54);
  float32x4_t v90 = v55;
  *(double *)v62.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v16, *(float32x2_t *)&v96)), v56, v57, v58, v59, v60, v61);
  float32x4_t v89 = v62;
  *(double *)v69.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v96)), v63, v64, v65, v66, v67, v68);
  float32x4_t v88 = v69;
  *(double *)v76.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v18, *(float32x2_t *)&v96)), v70, v71, v72, v73, v74, v75);
  float32x4_t v77 = (float32x4_t)vdupq_n_s32(0x3C14C7A3u);
  float32x4_t v78 = (float32x4_t)vdupq_n_s32(0x3D474371u);
  float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x3EDD553Fu);
  float32x4_t v80 = vmulq_f32(v91, (float32x4_t)vdupq_n_s32(0x3F0DF9F0u));
  float32x4_t v81 = (float32x4_t)vdupq_n_s32(0x3DEB32CFu);
  float32x4_t v82 = (float32x4_t)vdupq_n_s32(0x3D8C7B7Cu);
  float32x4_t v83 = (float32x4_t)vdupq_n_s32(0x3BAAAD28u);
  float32x4_t v84 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v95, v77), vmulq_f32(v94, v78)), vmulq_f32(v92, v79)), v80), vmulq_f32(v90, v81)), vmulq_f32(v89, v82)), vmulq_f32(v76, v83));
  float32x4_t v85 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v95, v83), vmulq_f32(v93, v82)), vmulq_f32(v92, v81)), v80), vmulq_f32(v90, v79)), vmulq_f32(v88, v78)), vmulq_f32(v76, v77));
  v78.f32[0] = fminf(v6, 1.0);
  float32x4_t v86 = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v91, (float32x4_t)vdupq_n_s32(0x3F19A4F0u)), vmulq_f32(vaddq_f32(v92, v90), (float32x4_t)vdupq_n_s32(0x3E8A9AC3u))), vmulq_f32(vaddq_f32(v93, v89), (float32x4_t)vdupq_n_s32(0xBD71927F))), vmulq_f32(vaddq_f32(v94, v88), (float32x4_t)vdupq_n_s32(0xBCAADC82))), vmulq_f32(vaddq_f32(v95, v76), (float32x4_t)vdupq_n_s32(0x3C140D7Eu))), 1.0 - v78.f32[0]), v84, v78.f32[0]);
  v84.f32[0] = fmaxf(v6 + -1.0, 0.0);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v86, 1.0 - v84.f32[0]), v85, v84.f32[0]).u64[0];
  return result;
}

float64x2_t Rectangle::integralize@<Q0>(Rectangle *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  if (fabs(this->var0) == INFINITY || (double var1 = this->var1, fabs(var1) == INFINITY))
  {
    float64x2_t result = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
    *(float64x2_t *)a3 = result;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
  }
  else
  {
    BOOL v6 = this->var0 == -8.98846567e307 && var1 == -8.98846567e307;
    if (v6 && this->var2 == 1.79769313e308 && this->var3 == 1.79769313e308)
    {
      float64x2_t result = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
      *(float64x2_t *)a3 = result;
      *(int64x2_t *)(a3 + 16) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    }
    else
    {
      Rectangle::inset(this, a2, a2, (uint64_t)v8);
      float64x2_t v7 = vrndmq_f64(v8[0]);
      float64x2_t result = vsubq_f64(vrndpq_f64(vaddq_f64(v8[0], v8[1])), v7);
      *(float64x2_t *)a3 = v7;
      *(float64x2_t *)(a3 + 16) = result;
    }
  }
  return result;
}

void ___ZL5downHP7CIImagedd_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5 = *(double *)(a1 + 32);
  float v6 = *(double *)(a1 + 40);
  roiDownK(*(CGRect *)&a2, v5, v6, 1);
}

void roiDownK(CGRect a1, float a2, float a3, int a4)
{
  CGFloat height = a1.size.height;
  CGFloat width = a1.size.width;
  CGFloat y = a1.origin.y;
  CGFloat x = a1.origin.x;
  double v8 = 1.0;
  if (a4) {
    double v9 = 1.0 / a3;
  }
  else {
    double v9 = 1.0;
  }
  if (a4)
  {
    double v10 = (float)-a2;
  }
  else
  {
    double v8 = 1.0 / a3;
    double v10 = 0.0;
  }
  if (a4) {
    double v11 = 0.0;
  }
  else {
    double v11 = (float)-a2;
  }
  CGAffineTransformMakeScale(&v12, v9, v8);
  v13.origin.CGFloat x = x;
  v13.origin.CGFloat y = y;
  v13.size.CGFloat width = width;
  v13.size.CGFloat height = height;
  CGRect v14 = CGRectApplyAffineTransform(v13, &v12);
  CGRectInset(v14, v10, v11);
}

int64x2_t Rectangle::inset@<Q0>(Rectangle *this@<X0>, double a2@<D0>, double a3@<D1>, uint64_t a4@<X8>)
{
  double var0 = this->var0;
  if (fabs(this->var0) == INFINITY) {
    goto LABEL_14;
  }
  double var1 = this->var1;
  if (fabs(var1) == INFINITY) {
    goto LABEL_14;
  }
  BOOL v6 = var0 == -8.98846567e307 && var1 == -8.98846567e307;
  if (v6 && this->var2 == 1.79769313e308 && this->var3 == 1.79769313e308)
  {
    int64x2_t result = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)a4 = result;
    *(int64x2_t *)(a4 + 16) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    return result;
  }
  double var2 = this->var2;
  double v9 = fabs(var2) + a2 * -2.0;
  if (v9 < 0.0 || (var3 = this->var3, double v11 = fabs(var3) + a3 * -2.0, v11 < 0.0))
  {
LABEL_14:
    int64x2_t result = vdupq_n_s64(0x7FF0000000000000uLL);
    *(int64x2_t *)a4 = result;
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
  }
  else
  {
    *(double *)result.i64 = fmin(var0, var0 + var2) + a2;
    *(void *)a4 = result.i64[0];
    *(double *)(a4 + 8) = fmin(var1, var3 + var1) + a3;
    *(double *)(a4 + 16) = v9;
    *(double *)(a4 + 24) = v11;
  }
  return result;
}

double cikernel::_asgDownH(uint64_t a1, int8x16_t a2, float a3)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  _Q2 = a2;
  *(float32x2_t *)_Q3.i8 = vmul_f32(*(float32x2_t *)a2.i8, *DC);
  int8x16_t v213 = _Q3;
  v8.i64[0] = 0.5;
  *(float *)v8.i32 = floor(*(float *)_Q3.i32 + -0.5) + 0.5;
  int8x16_t v199 = v8;
  int8x16_t v9 = _Q3;
  v9.i32[0] = v8.i32[0];
  float64x2_t v10 = (float64x2_t)vextq_s8(_Q2, _Q2, 8uLL);
  __asm { FMOV            V2.2S, #5.0 }
  *(float32x2_t *)_Q2.i8 = vmul_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v15.i8 = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)_Q2.i8);
  __asm { FMOV            V3.2S, #4.0 }
  *(float32x2_t *)_Q3.i8 = vmul_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)_Q3.i8);
  *(float32x2_t *)_Q4.i8 = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)_Q3.i8);
  int8x16_t v191 = _Q4;
  __asm { FMOV            V4.2S, #3.0 }
  *(float32x2_t *)_Q4.i8 = vmul_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)_Q4.i8);
  *(float32x2_t *)v17.i8 = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)_Q4.i8);
  int8x16_t v193 = v17;
  *(float32x2_t *)v17.i8 = vadd_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)&v10.f64[0]);
  *(float32x2_t *)v18.i8 = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)v17.i8);
  int8x16_t v195 = v18;
  *(float32x2_t *)v18.i8 = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)&v10.f64[0]);
  int8x16_t v197 = v18;
  *(float32x2_t *)v18.i8 = vadd_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)v9.i8);
  *(float32x2_t *)v17.i8 = vadd_f32(*(float32x2_t *)v17.i8, *(float32x2_t *)v9.i8);
  int8x16_t v200 = v18;
  int8x16_t v202 = v17;
  *(float32x2_t *)_Q4.i8 = vadd_f32(*(float32x2_t *)_Q4.i8, *(float32x2_t *)v9.i8);
  *(float32x2_t *)_Q3.i8 = vadd_f32(*(float32x2_t *)_Q3.i8, *(float32x2_t *)v9.i8);
  int8x16_t v204 = _Q4;
  int8x16_t v205 = _Q3;
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q2.i8, *(float32x2_t *)v9.i8);
  int8x16_t v209 = _Q2;
  __asm { FMOV            V2.2S, #6.0 }
  *(float32x2_t *)&v10.f64[0] = vmul_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v9.i8 = vadd_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)v9.i8);
  int8x16_t v212 = v9;
  float32x2_t v189 = *(float32x2_t *)v15.i8;
  _Q2.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v9.i32 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v15.i8, 1), *(float *)(a1 + 16), *(float *)v15.i32);
  _Q3.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.f64 = *(float *)_Q3.i32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v15.i8, 1), *(float *)_Q2.i32, *(float *)v15.i32);
  v9.i32[1] = LODWORD(v10.f64[0]);
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v9.i64, v10, *(double *)_Q2.i64, *(double *)_Q3.i64, _Q4, v17, v15);
  float32x4_t v187 = v19;
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v19.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v191.i8, 1), *(float *)(a1 + 16), *(float *)v191.i32);
  LODWORD(v21) = *(_DWORD *)(a1 + 36);
  *(float *)v22.f64 = *(float *)&v21
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v191.i8, 1), *(float *)&v20, *(float *)v191.i32);
  v19.i32[1] = LODWORD(v22.f64[0]);
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v22, v20, v21, v191, v23, v24);
  float32x4_t v186 = v25;
  LODWORD(v26) = *(_DWORD *)(a1 + 28);
  v25.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v193.i8, 1), *(float *)(a1 + 16), *(float *)v193.i32);
  LODWORD(v27) = *(_DWORD *)(a1 + 36);
  *(float *)v28.f64 = *(float *)&v27
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v193.i8, 1), *(float *)&v26, *(float *)v193.i32);
  v25.i32[1] = LODWORD(v28.f64[0]);
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v28, v26, v27, v193, v29, v30);
  float32x4_t v185 = v31;
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v31.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v195.i8, 1), *(float *)(a1 + 16), *(float *)v195.i32);
  LODWORD(v33) = *(_DWORD *)(a1 + 36);
  *(float *)v34.f64 = *(float *)&v33
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v195.i8, 1), *(float *)&v32, *(float *)v195.i32);
  v31.i32[1] = LODWORD(v34.f64[0]);
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v34, v32, v33, v195, v35, v36);
  float32x4_t v184 = v37;
  LODWORD(v38) = *(_DWORD *)(a1 + 28);
  v37.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v197.i8, 1), *(float *)(a1 + 16), *(float *)v197.i32);
  LODWORD(v39) = *(_DWORD *)(a1 + 36);
  *(float *)v40.f64 = *(float *)&v39
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v197.i8, 1), *(float *)&v38, *(float *)v197.i32);
  v37.i32[1] = LODWORD(v40.f64[0]);
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v40, v38, v39, v197, v41, v42);
  float32x4_t v183 = v43;
  LODWORD(v44) = *(_DWORD *)(a1 + 28);
  v43.f32[0] = *(float *)(a1 + 24)
             + (float)(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v213.i8, 1)
                     + (float)(*(float *)v199.i32 * *(float *)(a1 + 16)));
  LODWORD(v45) = *(_DWORD *)(a1 + 36);
  *(float *)v46.f64 = *(float *)&v45
                    + (float)(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v213.i8, 1)
                            + (float)(*(float *)v199.i32 * *(float *)&v44));
  v43.i32[1] = LODWORD(v46.f64[0]);
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v46, v44, v45, v213, v199, v47);
  float32x4_t v182 = v48;
  LODWORD(v49) = *(_DWORD *)(a1 + 28);
  v48.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v200.i8, 1), *(float *)(a1 + 16), *(float *)v200.i32);
  LODWORD(v5CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 36);
  *(float *)v51.f64 = *(float *)&v50
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v200.i8, 1), *(float *)&v49, *(float *)v200.i32);
  v48.i32[1] = LODWORD(v51.f64[0]);
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v51, v49, v50, v200, v52, v53);
  float32x4_t v181 = v54;
  LODWORD(v55) = *(_DWORD *)(a1 + 28);
  v54.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v202.i8, 1), *(float *)(a1 + 16), *(float *)v202.i32);
  LODWORD(v56) = *(_DWORD *)(a1 + 36);
  *(float *)v57.f64 = *(float *)&v56
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v202.i8, 1), *(float *)&v55, *(float *)v202.i32);
  v54.i32[1] = LODWORD(v57.f64[0]);
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v54.i64, v57, v55, v56, v202, v58, v59);
  float32x4_t v180 = v60;
  LODWORD(v61) = *(_DWORD *)(a1 + 28);
  v60.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v204.i8, 1), *(float *)(a1 + 16), *(float *)v204.i32);
  LODWORD(v62) = *(_DWORD *)(a1 + 36);
  *(float *)v63.f64 = *(float *)&v62
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v204.i8, 1), *(float *)&v61, *(float *)v204.i32);
  v60.i32[1] = LODWORD(v63.f64[0]);
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v60.i64, v63, v61, v62, v204, v64, v65);
  float32x4_t v179 = v66;
  LODWORD(v67) = *(_DWORD *)(a1 + 28);
  v66.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v205.i8, 1), *(float *)(a1 + 16), *(float *)v205.i32);
  LODWORD(v68) = *(_DWORD *)(a1 + 36);
  *(float *)v69.f64 = *(float *)&v68
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v205.i8, 1), *(float *)&v67, *(float *)v205.i32);
  v66.i32[1] = LODWORD(v69.f64[0]);
  *(double *)v72.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v66.i64, v69, v67, v68, v205, v70, v71);
  float32x4_t v178 = v72;
  LODWORD(v73) = *(_DWORD *)(a1 + 28);
  v72.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v209.i8, 1), *(float *)(a1 + 16), *(float *)v209.i32);
  LODWORD(v74) = *(_DWORD *)(a1 + 36);
  *(float *)v75.f64 = *(float *)&v74
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v209.i8, 1), *(float *)&v73, *(float *)v209.i32);
  v72.i32[1] = LODWORD(v75.f64[0]);
  *(double *)v78.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v72.i64, v75, v73, v74, v209, v76, v77);
  float32x4_t v177 = v78;
  LODWORD(v79) = *(_DWORD *)(a1 + 28);
  v78.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v212.i8, 1), *(float *)(a1 + 16), *(float *)v212.i32);
  LODWORD(v8CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 36);
  *(float *)v81.f64 = *(float *)&v80
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v212.i8, 1), *(float *)&v79, *(float *)v212.i32);
  v78.i32[1] = LODWORD(v81.f64[0]);
  *(double *)v84.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v78.i64, v81, v79, v80, v212, v82, v83);
  float32x2_t v86 = *(float32x2_t *)v213.i8;
  float v85 = *(float *)a2.i32;
  float32x4_t v176 = v84;
  float v87 = fabsf((float)(vsub_f32(v189, *(float32x2_t *)v213.i8).f32[0] / *(float *)a2.i32) + a3);
  float v190 = 0.0;
  float v188 = 0.0;
  if (v87 < 3.0)
  {
    double v88 = v87;
    float v188 = 1.0;
    if (v88 >= 0.000001)
    {
      float v89 = v88 * 3.14159265;
      float v90 = sinf(v89);
      long double v91 = v89 * 0.125;
      float v92 = v90 / v89;
      long double v93 = cos(v91);
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v93 = v93;
      float v188 = (float)((float)((float)(v92 * *(float *)&v93) * *(float *)&v93) * *(float *)&v93) * *(float *)&v93;
    }
  }
  float v94 = fabsf((float)(vsub_f32(*(float32x2_t *)v191.i8, v86).f32[0] / v85) + a3);
  if (v94 < 3.0)
  {
    double v95 = v94;
    float v190 = 1.0;
    if (v95 >= 0.000001)
    {
      float v96 = v95 * 3.14159265;
      float v97 = sinf(v96);
      long double v98 = v96 * 0.125;
      float v99 = v97 / v96;
      long double v100 = cos(v98);
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v100 = v100;
      float v190 = (float)((float)((float)(v99 * *(float *)&v100) * *(float *)&v100) * *(float *)&v100) * *(float *)&v100;
    }
  }
  float v101 = fabsf((float)(vsub_f32(*(float32x2_t *)v193.i8, v86).f32[0] / v85) + a3);
  float v194 = 0.0;
  float v192 = 0.0;
  if (v101 < 3.0)
  {
    double v102 = v101;
    float v192 = 1.0;
    if (v102 >= 0.000001)
    {
      float v103 = v102 * 3.14159265;
      float v104 = sinf(v103);
      long double v105 = v103 * 0.125;
      float v106 = v104 / v103;
      long double v107 = cos(v105);
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v107 = v107;
      float v192 = (float)((float)((float)(v106 * *(float *)&v107) * *(float *)&v107) * *(float *)&v107) * *(float *)&v107;
    }
  }
  float v108 = fabsf((float)(vsub_f32(*(float32x2_t *)v195.i8, v86).f32[0] / v85) + a3);
  if (v108 < 3.0)
  {
    double v109 = v108;
    float v194 = 1.0;
    if (v109 >= 0.000001)
    {
      float v110 = v109 * 3.14159265;
      float v111 = sinf(v110);
      long double v112 = v110 * 0.125;
      float v113 = v111 / v110;
      long double v114 = cos(v112);
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v114 = v114;
      float v194 = (float)((float)((float)(v113 * *(float *)&v114) * *(float *)&v114) * *(float *)&v114) * *(float *)&v114;
    }
  }
  float v115 = fabsf((float)(vsub_f32(*(float32x2_t *)v197.i8, v86).f32[0] / v85) + a3);
  float v198 = 0.0;
  float v196 = 0.0;
  if (v115 < 3.0)
  {
    double v116 = v115;
    float v196 = 1.0;
    if (v116 >= 0.000001)
    {
      float v117 = v116 * 3.14159265;
      float v118 = sinf(v117);
      long double v119 = v117 * 0.125;
      float v120 = v118 / v117;
      long double v121 = cos(v119);
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v121 = v121;
      float v196 = (float)((float)((float)(v120 * *(float *)&v121) * *(float *)&v121) * *(float *)&v121) * *(float *)&v121;
    }
  }
  float v122 = fabsf((float)((float)(*(float *)v199.i32 - v86.f32[0]) / v85) + a3);
  if (v122 < 3.0)
  {
    double v123 = v122;
    float v198 = 1.0;
    if (v123 >= 0.000001)
    {
      float v124 = v123 * 3.14159265;
      float v125 = sinf(v124);
      long double v126 = v124 * 0.125;
      float v127 = v125 / v124;
      long double v128 = cos(v126);
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v128 = v128;
      float v198 = (float)((float)((float)(v127 * *(float *)&v128) * *(float *)&v128) * *(float *)&v128) * *(float *)&v128;
    }
  }
  float v129 = fabsf((float)(vsub_f32(*(float32x2_t *)v200.i8, v86).f32[0] / v85) + a3);
  float v130 = 0.0;
  float v131 = 0.0;
  if (v129 < 3.0)
  {
    double v132 = v129;
    float v131 = 1.0;
    if (v132 >= 0.000001)
    {
      float v133 = v132 * 3.14159265;
      float v134 = sinf(v133);
      long double v135 = v133 * 0.125;
      float v136 = v134 / v133;
      long double v137 = cos(v135);
      float v130 = 0.0;
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v137 = v137;
      float v131 = (float)((float)((float)(v136 * *(float *)&v137) * *(float *)&v137) * *(float *)&v137) * *(float *)&v137;
    }
  }
  float v138 = fabsf((float)(vsub_f32(*(float32x2_t *)v202.i8, v86).f32[0] / v85) + a3);
  float v203 = v131;
  if (v138 < 3.0)
  {
    double v139 = v138;
    float v130 = 1.0;
    if (v139 >= 0.000001)
    {
      float v140 = v139 * 3.14159265;
      float v141 = sinf(v140);
      long double v142 = v140 * 0.125;
      float v143 = v141 / v140;
      long double v144 = cos(v142);
      float v131 = v203;
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v144 = v144;
      float v130 = (float)((float)((float)(v143 * *(float *)&v144) * *(float *)&v144) * *(float *)&v144) * *(float *)&v144;
    }
  }
  float v145 = fabsf((float)(vsub_f32(*(float32x2_t *)v204.i8, v86).f32[0] / v85) + a3);
  float v146 = 0.0;
  float v147 = 0.0;
  float v201 = v130;
  if (v145 < 3.0)
  {
    double v148 = v145;
    float v147 = 1.0;
    if (v148 >= 0.000001)
    {
      float v149 = v148 * 3.14159265;
      float v150 = sinf(v149);
      long double v151 = v149 * 0.125;
      float v152 = v150 / v149;
      long double v153 = cos(v151);
      float v146 = 0.0;
      float v130 = v201;
      float v131 = v203;
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v153 = v153;
      float v147 = (float)((float)((float)(v152 * *(float *)&v153) * *(float *)&v153) * *(float *)&v153) * *(float *)&v153;
    }
  }
  float v154 = fabsf((float)(vsub_f32(*(float32x2_t *)v205.i8, v86).f32[0] / v85) + a3);
  if (v154 < 3.0)
  {
    double v155 = v154;
    float v146 = 1.0;
    if (v155 >= 0.000001)
    {
      float v156 = v155 * 3.14159265;
      float v206 = v147;
      float v157 = sinf(v156);
      long double v158 = v156 * 0.125;
      float v159 = v157 / v156;
      long double v160 = cos(v158);
      float v147 = v206;
      float v130 = v201;
      float v131 = v203;
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v160 = v160;
      float v146 = (float)((float)((float)(v159 * *(float *)&v160) * *(float *)&v160) * *(float *)&v160) * *(float *)&v160;
    }
  }
  float v161 = fabsf((float)(vsub_f32(*(float32x2_t *)v209.i8, v86).f32[0] / v85) + a3);
  float v162 = 0.0;
  float v163 = 0.0;
  if (v161 < 3.0)
  {
    double v164 = v161;
    float v163 = 1.0;
    if (v164 >= 0.000001)
    {
      float v165 = v164 * 3.14159265;
      float v207 = v147;
      float v210 = v146;
      float v166 = sinf(v165);
      long double v167 = v165 * 0.125;
      float v168 = v166 / v165;
      long double v169 = cos(v167);
      float v162 = 0.0;
      float v147 = v207;
      float v146 = v210;
      float v130 = v201;
      float v131 = v203;
      float32x2_t v86 = *(float32x2_t *)v213.i8;
      float v85 = *(float *)a2.i32;
      *(float *)&long double v169 = v169;
      float v163 = (float)((float)((float)(v168 * *(float *)&v169) * *(float *)&v169) * *(float *)&v169) * *(float *)&v169;
    }
  }
  long double v170 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v212.i8, v86));
  *(float *)&long double v170 = fabsf((float)(*(float *)&v170 / v85) + a3);
  if (*(float *)&v170 < 3.0)
  {
    long double v170 = *(float *)&v170;
    float v162 = 1.0;
    if (v170 >= 0.000001)
    {
      float v171 = v170 * 3.14159265;
      float v208 = v147;
      float v211 = v146;
      float v215 = v163;
      float v172 = sinf(v171);
      long double v173 = v171 * 0.125;
      float v174 = v172 / v171;
      long double v170 = cos(v173);
      float v163 = v215;
      float v147 = v208;
      float v146 = v211;
      float v130 = v201;
      float v131 = v203;
      *(float *)&long double v170 = v170;
      float v162 = (float)((float)((float)(v174 * *(float *)&v170) * *(float *)&v170) * *(float *)&v170) * *(float *)&v170;
    }
  }
  *(float *)&long double v170 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v188 + v190) + v192)
                                                                                  + v194)
                                                                          + v196)
                                                                  + v198)
                                                          + v131)
                                                  + v130)
                                          + v147)
                                  + v146)
                          + v163)
                  + v162;
  *(void *)&double result = vdivq_f32(vaddq_f32(vmulq_n_f32(v181, v131), vaddq_f32(vmulq_n_f32(v180, v130), vaddq_f32(vmulq_n_f32(v179, v147), vaddq_f32(vmulq_n_f32(v178, v146), vaddq_f32(vmulq_n_f32(v177, v163), vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(v187, v188), vmulq_n_f32(v186, v190)), vmulq_n_f32(v185, v192)), vmulq_n_f32(v184, v194)), vmulq_n_f32(v183, v196)),
                                       vmulq_n_f32(v182, v198)),
                                     vmulq_n_f32(v176, v162))))))),
                         (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v170, 0)).u64[0];
  return result;
}

float ___ZL5downVP7CIImagedd_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5 = *(double *)(a1 + 32);
  float v6 = *(double *)(a1 + 40);
  roiDownK(*(CGRect *)&a2, v5, v6, 0);
  return result;
}

double cikernel::_asgDownV(uint64_t a1, int8x16_t a2, float a3)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  _Q2 = a2;
  *(float32x2_t *)v7.i8 = vmul_f32(*(float32x2_t *)a2.i8, *DC);
  int8x16_t v188 = v7;
  float v8 = *(float *)&v7.i32[1];
  v9.i64[0] = 0.5;
  *(float *)v9.i32 = floor(*(float *)&v7.i32[1] + -0.5) + 0.5;
  int8x16_t v204 = v9;
  int8x16_t v10 = v7;
  v10.i32[1] = v9.i32[0];
  float64x2_t v11 = (float64x2_t)vextq_s8(_Q2, _Q2, 8uLL);
  __asm { FMOV            V2.2S, #5.0 }
  *(float32x2_t *)_Q2.i8 = vmul_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v7.i8 = vsub_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)_Q2.i8);
  __asm { FMOV            V4.2S, #4.0 }
  float32x2_t v17 = vmul_f32(*(float32x2_t *)&v11.f64[0], _D4);
  *(float32x2_t *)_Q5.i8 = vsub_f32(*(float32x2_t *)v10.i8, v17);
  int8x16_t v193 = _Q5;
  __asm { FMOV            V5.2S, #3.0 }
  *(float32x2_t *)_Q5.i8 = vmul_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)_Q5.i8);
  *(float32x2_t *)v19.i8 = vsub_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)_Q5.i8);
  int8x16_t v197 = v19;
  *(float32x2_t *)v19.i8 = vadd_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)&v11.f64[0]);
  *(float32x2_t *)v20.i8 = vsub_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)v19.i8);
  int8x16_t v199 = v20;
  *(float32x2_t *)v20.i8 = vsub_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)&v11.f64[0]);
  int8x16_t v201 = v20;
  *(float32x2_t *)v20.i8 = vadd_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)v10.i8);
  int8x16_t v203 = v20;
  *(float32x2_t *)v19.i8 = vadd_f32(*(float32x2_t *)v19.i8, *(float32x2_t *)v10.i8);
  *(float32x2_t *)_Q5.i8 = vadd_f32(*(float32x2_t *)_Q5.i8, *(float32x2_t *)v10.i8);
  int8x16_t v206 = v19;
  int8x16_t v207 = _Q5;
  *(float32x2_t *)v21.i8 = vadd_f32(v17, *(float32x2_t *)v10.i8);
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q2.i8, *(float32x2_t *)v10.i8);
  int8x16_t v209 = v21;
  int8x16_t v211 = _Q2;
  __asm { FMOV            V2.2S, #6.0 }
  *(float32x2_t *)&v11.f64[0] = vmul_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v10.i8 = vadd_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)v10.i8);
  int8x16_t v215 = v10;
  _Q2.i32[0] = *(_DWORD *)(a1 + 28);
  _Q5.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v7.i8, 1), *(float *)_Q2.i32, *(float *)v7.i32);
  float v22 = *(float *)&v7.i32[1];
  *(float *)v10.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v7.i8, 1), *(float *)(a1 + 16), *(float *)v7.i32);
  *(float *)v11.f64 = *(float *)_Q5.i32 + *(float *)v21.i32;
  *(float *)&v10.i32[1] = *(float *)_Q5.i32 + *(float *)v21.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v10.i64, v11, *(double *)_Q2.i64, *(double *)v7.i64, v21, _Q5, v19);
  float32x4_t v195 = v23;
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v193.i8, 1), *(float *)&v24, *(float *)v193.i32);
  float v27 = *(float *)&v193.i32[1];
  v23.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v193.i8, 1), *(float *)(a1 + 16), *(float *)v193.i32);
  *(float *)v28.f64 = *(float *)v25.i32 + *(float *)&v26;
  v23.f32[1] = *(float *)v25.i32 + *(float *)&v26;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v28, v24, v26, v25, v193, v29);
  float32x4_t v194 = v30;
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v30.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v197.i8, 1), *(float *)(a1 + 16), *(float *)v197.i32);
  LODWORD(v32) = *(_DWORD *)(a1 + 36);
  *(float *)v33.f64 = *(float *)&v32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v197.i8, 1), *(float *)&v31, *(float *)v197.i32);
  v30.i32[1] = LODWORD(v33.f64[0]);
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v33, v31, v32, v197, v34, v35);
  float32x4_t v192 = v36;
  LODWORD(v37) = *(_DWORD *)(a1 + 28);
  v36.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v199.i8, 1), *(float *)(a1 + 16), *(float *)v199.i32);
  LODWORD(v38) = *(_DWORD *)(a1 + 36);
  *(float *)v39.f64 = *(float *)&v38
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v199.i8, 1), *(float *)&v37, *(float *)v199.i32);
  v36.i32[1] = LODWORD(v39.f64[0]);
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v39, v37, v38, v199, v40, v41);
  float32x4_t v191 = v42;
  LODWORD(v43) = *(_DWORD *)(a1 + 28);
  v42.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v201.i8, 1), *(float *)(a1 + 16), *(float *)v201.i32);
  LODWORD(v44) = *(_DWORD *)(a1 + 36);
  *(float *)v45.f64 = *(float *)&v44
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v201.i8, 1), *(float *)&v43, *(float *)v201.i32);
  v42.i32[1] = LODWORD(v45.f64[0]);
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v45, v43, v44, v201, v46, v47);
  float32x4_t v190 = v48;
  LODWORD(v49) = *(_DWORD *)(a1 + 28);
  v50.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v51 = vmlas_n_f32(*(float *)(a1 + 32) * *(float *)v204.i32, *(float *)&v49, *(float *)v188.i32);
  v48.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(*(float *)(a1 + 20) * *(float *)v204.i32, *(float *)(a1 + 16), *(float *)v188.i32);
  *(float *)v52.f64 = *(float *)v50.i32 + *(float *)&v51;
  v48.f32[1] = *(float *)v50.i32 + *(float *)&v51;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v52, v49, v51, v50, v204, v188);
  float32x4_t v189 = v53;
  LODWORD(v54) = *(_DWORD *)(a1 + 28);
  v53.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v203.i8, 1), *(float *)(a1 + 16), *(float *)v203.i32);
  LODWORD(v55) = *(_DWORD *)(a1 + 36);
  *(float *)v56.f64 = *(float *)&v55
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v203.i8, 1), *(float *)&v54, *(float *)v203.i32);
  v53.i32[1] = LODWORD(v56.f64[0]);
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v56, v54, v55, v203, v57, v58);
  float32x4_t v187 = v59;
  LODWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v59.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v206.i8, 1), *(float *)(a1 + 16), *(float *)v206.i32);
  LODWORD(v61) = *(_DWORD *)(a1 + 36);
  *(float *)v62.f64 = *(float *)&v61
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v206.i8, 1), *(float *)&v60, *(float *)v206.i32);
  v59.i32[1] = LODWORD(v62.f64[0]);
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v59.i64, v62, v60, v61, v206, v63, v64);
  float32x4_t v186 = v65;
  LODWORD(v66) = *(_DWORD *)(a1 + 28);
  v65.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v207.i8, 1), *(float *)(a1 + 16), *(float *)v207.i32);
  LODWORD(v67) = *(_DWORD *)(a1 + 36);
  *(float *)v68.f64 = *(float *)&v67
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v207.i8, 1), *(float *)&v66, *(float *)v207.i32);
  v65.i32[1] = LODWORD(v68.f64[0]);
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v68, v66, v67, v207, v69, v70);
  float32x4_t v185 = v71;
  LODWORD(v72) = *(_DWORD *)(a1 + 28);
  v71.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v209.i8, 1), *(float *)(a1 + 16), *(float *)v209.i32);
  LODWORD(v73) = *(_DWORD *)(a1 + 36);
  *(float *)v74.f64 = *(float *)&v73
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v209.i8, 1), *(float *)&v72, *(float *)v209.i32);
  v71.i32[1] = LODWORD(v74.f64[0]);
  *(double *)v77.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v71.i64, v74, v72, v73, v209, v75, v76);
  float32x4_t v184 = v77;
  LODWORD(v78) = *(_DWORD *)(a1 + 28);
  v77.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v211.i8, 1), *(float *)(a1 + 16), *(float *)v211.i32);
  LODWORD(v79) = *(_DWORD *)(a1 + 36);
  *(float *)v80.f64 = *(float *)&v79
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v211.i8, 1), *(float *)&v78, *(float *)v211.i32);
  v77.i32[1] = LODWORD(v80.f64[0]);
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v77.i64, v80, v78, v79, v211, v81, v82);
  float32x4_t v183 = v83;
  LODWORD(v84) = *(_DWORD *)(a1 + 28);
  v83.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v215.i8, 1), *(float *)(a1 + 16), *(float *)v215.i32);
  LODWORD(v85) = *(_DWORD *)(a1 + 36);
  *(float *)v86.f64 = *(float *)&v85
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v215.i8, 1), *(float *)&v84, *(float *)v215.i32);
  v83.i32[1] = LODWORD(v86.f64[0]);
  *(double *)v89.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v86, v84, v85, v215, v87, v88);
  float32x4_t v182 = v89;
  float v90 = fabsf((float)((float)(v22 - v8) / *(float *)&a2.i32[1]) + a3);
  a2.i32[0] = 0;
  float v91 = 0.0;
  if (v90 < 3.0)
  {
    double v92 = v90;
    float v91 = 1.0;
    if (v92 >= 0.000001)
    {
      float v93 = v92 * 3.14159265;
      float v94 = sinf(v93);
      long double v95 = v93 * 0.125;
      float v96 = v94 / v93;
      float v97 = cos(v95);
      float v91 = (float)((float)((float)(v96 * v97) * v97) * v97) * v97;
    }
  }
  float v181 = v91;
  float v98 = fabsf((float)((float)(v27 - v8) / *(float *)&a2.i32[1]) + a3);
  if (v98 < 3.0)
  {
    double v99 = v98;
    a2.i32[0] = 1.0;
    if (v99 >= 0.000001)
    {
      float v100 = v99 * 3.14159265;
      float v101 = sinf(v100);
      long double v102 = v100 * 0.125;
      float v103 = v101 / v100;
      float v104 = cos(v102);
      *(float *)a2.i32 = (float)((float)((float)(v103 * v104) * v104) * v104) * v104;
    }
  }
  float v105 = fabsf((float)((float)(*(float *)&v197.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  float v200 = 0.0;
  float v106 = 0.0;
  if (v105 < 3.0)
  {
    double v107 = v105;
    float v106 = 1.0;
    if (v107 >= 0.000001)
    {
      float v108 = v107 * 3.14159265;
      float v109 = sinf(v108);
      long double v110 = v108 * 0.125;
      float v111 = v109 / v108;
      float v112 = cos(v110);
      float v106 = (float)((float)((float)(v111 * v112) * v112) * v112) * v112;
    }
  }
  float v198 = v106;
  float v113 = fabsf((float)((float)(*(float *)&v199.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  if (v113 < 3.0)
  {
    double v114 = v113;
    float v200 = 1.0;
    if (v114 >= 0.000001)
    {
      float v115 = v114 * 3.14159265;
      float v116 = sinf(v115);
      long double v117 = v115 * 0.125;
      float v118 = v116 / v115;
      float v119 = cos(v117);
      float v200 = (float)((float)((float)(v118 * v119) * v119) * v119) * v119;
    }
  }
  float v120 = fabsf((float)((float)(*(float *)&v201.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  float v121 = 0.0;
  float v122 = 0.0;
  if (v120 < 3.0)
  {
    double v123 = v120;
    float v122 = 1.0;
    if (v123 >= 0.000001)
    {
      float v124 = v123 * 3.14159265;
      float v125 = sinf(v124);
      long double v126 = v124 * 0.125;
      float v127 = v125 / v124;
      long double v128 = cos(v126);
      float v121 = 0.0;
      *(float *)&long double v128 = v128;
      float v122 = (float)((float)((float)(v127 * *(float *)&v128) * *(float *)&v128) * *(float *)&v128) * *(float *)&v128;
    }
  }
  float v202 = v122;
  float v129 = fabsf((float)((float)(*(float *)v204.i32 - v8) / *(float *)&a2.i32[1]) + a3);
  if (v129 < 3.0)
  {
    double v130 = v129;
    float v121 = 1.0;
    if (v130 >= 0.000001)
    {
      float v131 = v130 * 3.14159265;
      float v132 = sinf(v131);
      long double v133 = v131 * 0.125;
      float v134 = v132 / v131;
      float v135 = cos(v133);
      float v121 = (float)((float)((float)(v134 * v135) * v135) * v135) * v135;
    }
  }
  float v205 = v121;
  float v136 = fabsf((float)((float)(*(float *)&v203.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  float v137 = 0.0;
  float v138 = 0.0;
  if (v136 < 3.0)
  {
    double v139 = v136;
    float v138 = 1.0;
    if (v139 >= 0.000001)
    {
      float v140 = v139 * 3.14159265;
      float v141 = sinf(v140);
      long double v142 = v140 * 0.125;
      float v143 = v141 / v140;
      long double v144 = cos(v142);
      float v137 = 0.0;
      *(float *)&long double v144 = v144;
      float v138 = (float)((float)((float)(v143 * *(float *)&v144) * *(float *)&v144) * *(float *)&v144) * *(float *)&v144;
    }
  }
  *(float *)v206.i32 = v138;
  float v145 = fabsf((float)((float)(*(float *)&v206.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  if (v145 < 3.0)
  {
    double v146 = v145;
    float v137 = 1.0;
    if (v146 >= 0.000001)
    {
      float v147 = v146 * 3.14159265;
      float v148 = sinf(v147);
      long double v149 = v147 * 0.125;
      float v150 = v148 / v147;
      float v151 = cos(v149);
      float v137 = (float)((float)((float)(v150 * v151) * v151) * v151) * v151;
    }
  }
  float v152 = fabsf((float)((float)(*(float *)&v207.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  float v153 = 0.0;
  float v154 = 0.0;
  float v208 = v137;
  if (v152 < 3.0)
  {
    double v155 = v152;
    float v154 = 1.0;
    if (v155 >= 0.000001)
    {
      float v156 = v155 * 3.14159265;
      float v157 = sinf(v156);
      long double v158 = v156 * 0.125;
      float v159 = v157 / v156;
      long double v160 = cos(v158);
      float v153 = 0.0;
      float v137 = v208;
      *(float *)&long double v160 = v160;
      float v154 = (float)((float)((float)(v159 * *(float *)&v160) * *(float *)&v160) * *(float *)&v160) * *(float *)&v160;
    }
  }
  float v161 = fabsf((float)((float)(*(float *)&v209.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  if (v161 < 3.0)
  {
    double v162 = v161;
    float v153 = 1.0;
    if (v162 >= 0.000001)
    {
      float v163 = v162 * 3.14159265;
      float v212 = v154;
      float v164 = sinf(v163);
      long double v165 = v163 * 0.125;
      float v166 = v164 / v163;
      long double v167 = cos(v165);
      float v154 = v212;
      float v137 = v208;
      *(float *)&long double v167 = v167;
      float v153 = (float)((float)((float)(v166 * *(float *)&v167) * *(float *)&v167) * *(float *)&v167) * *(float *)&v167;
    }
  }
  HIDWORD(v168) = v215.i32[1];
  *(float *)&long double v168 = fabsf((float)((float)(*(float *)&v211.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  float v169 = 0.0;
  float v170 = 0.0;
  if (*(float *)&v168 < 3.0)
  {
    long double v168 = *(float *)&v168;
    float v170 = 1.0;
    if (v168 >= 0.000001)
    {
      float v171 = v168 * 3.14159265;
      float v213 = v154;
      float v216 = v153;
      float v172 = sinf(v171);
      long double v173 = v171 * 0.125;
      float v174 = v172 / v171;
      long double v168 = cos(v173);
      float v169 = 0.0;
      float v154 = v213;
      float v153 = v216;
      float v137 = v208;
      *(float *)&long double v168 = v168;
      float v170 = (float)((float)((float)(v174 * *(float *)&v168) * *(float *)&v168) * *(float *)&v168) * *(float *)&v168;
    }
  }
  float v175 = fabsf((float)((float)(*(float *)&v215.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  if (v175 < 3.0)
  {
    long double v168 = v175;
    float v169 = 1.0;
    if (v168 >= 0.000001)
    {
      float v176 = v168 * 3.14159265;
      float v214 = v154;
      float v217 = v153;
      float v210 = v170;
      float v177 = sinf(v176);
      long double v178 = v176 * 0.125;
      float v179 = v177 / v176;
      long double v168 = cos(v178);
      float v170 = v210;
      float v154 = v214;
      float v153 = v217;
      float v137 = v208;
      *(float *)&long double v168 = v168;
      float v169 = (float)((float)((float)(v179 * *(float *)&v168) * *(float *)&v168) * *(float *)&v168) * *(float *)&v168;
    }
  }
  *(float *)&long double v168 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v181
                                                                                                  + *(float *)a2.i32)
                                                                                          + v198)
                                                                                  + v200)
                                                                          + v202)
                                                                  + v205)
                                                          + *(float *)v206.i32)
                                                  + v137)
                                          + v154)
                                  + v153)
                          + v170)
                  + v169;
  *(void *)&double result = vdivq_f32(vaddq_f32(vmulq_n_f32(v187, *(float *)v206.i32), vaddq_f32(vmulq_n_f32(v186, v137), vaddq_f32(vmulq_n_f32(v185, v154), vaddq_f32(vmulq_n_f32(v184, v153), vaddq_f32(vmulq_n_f32(v183, v170), vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(v195, v181), vmulq_n_f32(v194, *(float *)a2.i32)), vmulq_n_f32(v192, v198)), vmulq_n_f32(v191, v200)), vmulq_n_f32(v190, v202)),
                                       vmulq_n_f32(v189, v205)),
                                     vmulq_n_f32(v182, v169))))))),
                         (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v168, 0)).u64[0];
  return result;
}

void *CI::AreaHistogram::loadKernel(void *a1, uint64_t a2)
{
  if (CI::AreaHistogram::getKernelCache(void)::onceToken != -1) {
    dispatch_once(&CI::AreaHistogram::getKernelCache(void)::onceToken, &__block_literal_global_328);
  }
  float v4 = (void *)CI::AreaHistogram::getKernelCache(void)::kernelCache;
  uint64_t v5 = [NSString stringWithFormat:@"%@_%@", objc_msgSend(NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(a1, "registryID")), a2];
  float v6 = (void *)[v4 objectForKey:v5];
  if (!v6)
  {
    int8x16_t v7 = objc_msgSend(a1, "newDefaultLibraryWithBundle:error:", objc_msgSend(MEMORY[0x1E4F28B50], "bundleWithIdentifier:", @"com.apple.CoreImage"), 0);
    float v8 = (void *)[v7 newFunctionWithName:a2];
    float v6 = (void *)[a1 newComputePipelineStateWithFunction:v8 error:0];
    [v4 setObject:v6 forKey:v5];
  }
  return v6;
}

double cikernel::_CIAreaHistogramScaleAndClamp(float32x4_t a1, double a2, double a3)
{
  *(void *)&double result = vminnmq_f32(vmaxnmq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0), (float32x4_t)0), vdivq_f32(vrndmq_f32(vmulq_n_f32(vmulq_n_f32(a1, *(float *)&a2), *(float *)&a3)), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0))).u64[0];
  return result;
}

void CI::f4_s_f_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float64x2_t v11 = (double (*)(void *, __n128, float, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  float32x2_t v16 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float32x2_t v16 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v17 = v11(a1, *v16, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

void ___ZL16mpsAreaHistogramPU32objcproto21CIImageProcessorInput11objc_objectPU33objcproto22CIImageProcessorOutput11objc_object5IRectjjf_block_invoke(uint64_t a1)
{
}

double cikernel::_CIAreaHistogramScale(float32x4_t a1, float a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, a2);
  float32x4_t v3 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  *(void *)&double result = vdivq_f32(vrndmq_f32(vmulq_f32(v2, v3)), v3).u64[0];
  return result;
}

void CI::f4_s_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float64x2_t v11 = (double (*)(void *, __n128, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  uint64_t v15 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v15 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v16 = v11(a1, *v15, *((float *)a2 + 16 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

double cikernel::_prepHistogram(float32x4_t a1, float a2)
{
  a1.i32[3] = 0;
  float32x4_t v3 = vmaxnmq_f32(a1, (float32x4_t)0);
  v3.i32[3] = 0;
  *(void *)&double result = vmulq_n_f32(vminnmq_f32(v3, (float32x4_t)xmmword_19394CBC0), a2).u64[0];
  return result;
}

float32x4_t cikernel::_logHistogram(simd_float4 a1, double a2, float a3)
{
  unsigned __int32 v8 = a1.u32[3];
  a1.i32[3] = 0;
  float32x4_t v4 = (float32x4_t)_simd_log2_f4(a1);
  float32x4_t v5 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0);
  float32x4_t result = vsubq_f32(v4, v5);
  v5.f32[0] = a3 - *(float *)&a2;
  result.i64[0] = vdivq_f32(result, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 0)).u64[0];
  result.i32[3] = v8;
  return result;
}

float cikernel::_perc_norm_red(float32x4_t a1, float32x4_t a2)
{
  return fmaxf(vsubq_f32(a1, a2).f32[0]/ fmaxf(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 1), a2).f32[0], 0.00001), 0.0);
}

void CI::f4_s_s(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float64x2_t v11 = (double (*)(void *, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  long long v16 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    long long v16 = (__n128 *)((char *)a2 + 64 * v15);
  }
  long long v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    long long v17 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v18 = v11(a1, *v17, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_perc_accum_red(cikernel *this, SamplerObj *a2, double a3, float64x2_t a4, double a5, double a6, int8x16_t a7, int8x16_t a8, int8x16_t a9)
{
  float v9 = *(float *)a4.f64;
  float v10 = *(float *)&a3;
  int v11 = (int)*(float *)a4.f64;
  float v12 = 0.0;
  if ((int)*(float *)a4.f64 < 1)
  {
    int v14 = 0;
    float v15 = 0.0;
    float v16 = 0.0;
  }
  else
  {
    int v14 = 0;
    float v15 = 0.0;
    float v16 = 0.0;
    while (1)
    {
      float v17 = (float)v14 + 0.5;
      LODWORD(a5) = *((_DWORD *)this + 6);
      a8.i32[0] = *((_DWORD *)this + 9);
      *(float *)a7.i32 = *((float *)this + 8) * 0.5;
      *(float *)&a6 = *(float *)a7.i32 + (float)(v17 * *((float *)this + 7));
      *(float *)&double v18 = *(float *)&a5
                     + (float)((float)(*((float *)this + 5) * 0.5) + (float)(v17 * *((float *)this + 4)));
      *(float *)a4.f64 = *(float *)a8.i32 + *(float *)&a6;
      *((float *)&v18 + 1) = *(float *)a8.i32 + *(float *)&a6;
      a3 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v18, a4, a5, a6, a7, a8, a9);
      float v16 = v16 + *(float *)&a3;
      if (v16 >= v10) {
        break;
      }
      float v15 = v15 + *(float *)&a3;
      if (v11 == ++v14)
      {
        int v14 = v11;
        break;
      }
    }
  }
  if (v10 > 0.0 && (float)(v16 - v15) > 0.0) {
    float v12 = (float)(v10 - v15) / (float)(v16 - v15);
  }
  *(float *)&a3 = (float)(v12 + (float)v14) / v9;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)&a3, 0).u64[0];
  return result;
}

void CI::f4_sr_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v11 = *(void **)(a1 + 48);
  float v12 = *(double (**)(uint64_t, float, float))(a1 + 24);
  uint64_t v13 = v11[1];
  uint64_t v14 = v11[4];
  uint64_t v15 = v11[7];
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * v11[10]), a2);
  }
  *(double *)&long long v16 = v12(a4 + 80 * v13, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

float cikernel::_perc_denorm_red(float a1, float32x4_t a2)
{
  return vmlas_n_f32(a2.f32[0], vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 1), a2).f32[0], a1);
}

float cikernel::_perc_clip_hard(float32x4_t a1, float32x4_t a2)
{
  BOOL v2 = (vmovn_s32(vcgtq_f32(a2, a1)).u8[0] & 1) == 0;
  float v3 = 1.0;
  if (!v2) {
    return 0.0;
  }
  return v3;
}

float cikernel::_perc_clip_soft(float32x4_t a1, float32x4_t a2)
{
  BOOL v2 = (vmovn_s32(vcgtq_f32(a2, a1)).u8[0] & 1) == 0;
  float v3 = 0.0;
  if (v2) {
    return a1.f32[0];
  }
  return v3;
}

void cikernel::_prepHoughTransform(CI *a1, float32x4_t a2, double a3, float a4)
{
  uint64_t DC = (void *)CI::getDC(a1);
  if (sqrtf(vaddv_f32((float32x2_t)*(_OWORD *)&vmulq_f32(a2, a2))) >= a4)
  {
    int v15 = HIDWORD(*DC);
    float v6 = atanf(a2.f32[0] / (float)-a2.f32[1]);
    _KR00_8 = __sincosf_stret(v6);
    _V2.S[1] = v15;
    __asm
    {
      FMLA            S0, S1, V2.S[1]
      FMOV            V0.4S, #1.0
    }
  }
}

void CI::f4_s_f_f_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int v11 = (double (*)(void *, __n128, float, float, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  uint64_t v16 = *(void *)(v10 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  float v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float v17 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v18 = v11(a1, *v17, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

id ___ZN2CI13AreaHistogramL14getKernelCacheEv_block_invoke()
{
  id result = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  CI::AreaHistogram::getKernelCache(void)::kernelCache = (uint64_t)result;
  return result;
}

void OUTLINED_FUNCTION_1_0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

void OUTLINED_FUNCTION_2(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x16u);
}

void sub_1936EDE3C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(v1 - 208))(v1 - 224);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
}

double maximum_time(double a1, double a2, float a3, float a4)
{
  int v4 = vcvtps_s32_f32(vmlas_n_f32(vmuls_lane_f32(*(float *)&a2, *(float32x2_t *)&a1, 1), *((float *)&a2 + 1), *(float *)&a1) / a3);
  if (*(float *)&a2 < 0.00001)
  {
    float v5 = sqrtf(*((float *)&a1 + 1) / a4) + (float)(v4 - 1);
LABEL_7:
    double v7 = v5;
    return v7 + 0.00001;
  }
  if (*((float *)&a2 + 1) < 0.00001)
  {
    float v5 = sqrtf(*(float *)&a1 / a4) + (float)(v4 - 1);
    goto LABEL_7;
  }
  if (v4 == 1)
  {
    float32x2_t v6 = vsqrt_f32(vdiv_f32(*(float32x2_t *)&a1, vmul_n_f32(*(float32x2_t *)&a2, a4)));
    float v5 = fminf(v6.f32[0], v6.f32[1]);
    goto LABEL_7;
  }
  double v7 = 0.0;
  if (v4 >= 2)
  {
    float32x2_t v9 = vmul_n_f32(*(float32x2_t *)&a2, a4);
    float32x2_t v10 = vsqrt_f32(vdiv_f32(*(float32x2_t *)&a1, v9));
    float v11 = fminf(v10.f32[0], v10.f32[1]);
    double v7 = 0.0;
    BOOL v12 = 1;
    for (int i = 1; i != v4; ++i)
    {
      float v14 = (float)i;
      float v15 = (float)i * a3;
      double v16 = (float)((float)-(float)(v15 * *((float *)&a2 + 1)) / *(float *)&a2);
      double v17 = (float)((float)((float)(*(float *)&a2 * v15) / *((float *)&a2 + 1))
                  - (float)(*((float *)&a1 + 1) / *((float *)&a2 + 1)));
      if ((float)-*((float *)&a2 + 1) * v16 < (float)-*((float *)&a2 + 1) * v17) {
        double v17 = v16;
      }
      float v18 = (float)((float)(*((float *)&a2 + 1) * a3) * v14) + v17 * *(float *)&a2;
      if (v12)
      {
        double v19 = fmax(v7, (float)(v11 + (float)(i - 1)));
        BOOL v12 = v18 <= 0.00001;
        if (v18 > 0.00001) {
          double v7 = v19;
        }
      }
      float32_t v20 = (float)((float)(*(float *)&a2 * a3) * v14) - v17 * *((float *)&a2 + 1);
      v21.f32[0] = *(float *)&a1 - v18;
      v21.f32[1] = v20;
      float32x2_t v22 = vsqrt_f32(vdiv_f32(v21, v9));
      double v7 = fmax(v7, (float)(fminf(v22.f32[0], v22.f32[1]) + v14));
    }
  }
  return v7 + 0.00001;
}

float32x2_t cikernel::_barsSwipe(CI *a1, __n128 a2, float32x2_t a3, float a4)
{
  uint64_t DC = (float32x2_t *)CI::getDC(a1);
  float v7 = fmaxf(a4 - fabsf(floorf(a2.n128_f32[2] + vaddv_f32(vmul_f32((float32x2_t)a2.n128_u64[0], *DC)))), 0.0);
  return vadd_f32(*(float32x2_t *)CI::getDC((CI *)DC), vmul_n_f32(a3, v7 * v7));
}

void CI::f2_f3_f2_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, double, float))a1[3];
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  double v16 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    double v16 = (double *)((char *)a2 + 64 * v14);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *((__n128 *)a2 + 4 * v12), *v16, *((float *)a2 + 16 * v15));
}

void cikernel::_CBHorzGuided(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4, float a5, float a6)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v12.i8 = *DC;
  int8x16_t v51 = v12;
  LODWORD(v13) = *((_DWORD *)this + 7);
  *(float *)&double v14 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v15) = *((_DWORD *)this + 9);
  *(float *)v16.f64 = *(float *)&v15
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v13, COERCE_FLOAT(*DC));
  HIDWORD(v14) = LODWORD(v16.f64[0]);
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v14, v16, v13, v15, v12, v17, v18);
  float32x4_t v50 = v19;
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *((_DWORD *)a2 + 7);
  v19.f32[0] = *((float *)a2 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v51.i8, 1), *((float *)a2 + 4), *(float *)v51.i32);
  LODWORD(v21) = *((_DWORD *)a2 + 9);
  *(float *)v22.f64 = *(float *)&v21
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v51.i8, 1), *(float *)&v20, *(float *)v51.i32);
  v19.i32[1] = LODWORD(v22.f64[0]);
  CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v19.i64, v22, v20, v21, v51, v23, v24);
  int v26 = (int)a4;
  if (((int)a4 & 0x80000000) == 0)
  {
    int v27 = -v26;
    int v28 = (2 * v26) | 1;
    float32x4_t v29 = 0uLL;
    *(void *)&long long v25 = 0;
    do
    {
      long long v56 = v25;
      float32x4_t v57 = v29;
      float v30 = expf(-(float)((float)(v27 * v27) * a6));
      HIDWORD(v31.f64[0]) = 0;
      *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v51.i8, (float32x2_t)COERCE_UNSIGNED_INT((float)v27));
      int8x16_t v52 = v32;
      LODWORD(v33) = *((_DWORD *)this + 7);
      *(float *)&double v34 = *((float *)this + 6)
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v32.i8, 1), *((float *)this + 4), *(float *)v32.i32);
      LODWORD(v35) = *((_DWORD *)this + 9);
      *(float *)v31.f64 = *(float *)&v35
                        + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v32.i8, 1), *(float *)&v33, *(float *)v32.i32);
      HIDWORD(v34) = LODWORD(v31.f64[0]);
      *(double *)v38.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v34, v31, v33, v35, v32, v36, v37);
      float32x4_t v58 = v38;
      HIDWORD(v39) = v52.i32[1];
      LODWORD(v39) = *((_DWORD *)a2 + 7);
      v40.i32[0] = *((_DWORD *)a2 + 9);
      *(float *)&double v41 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v52.i8, 1), *(float *)&v39, *(float *)v52.i32);
      v38.f32[0] = *((float *)a2 + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v52.i8, 1), *((float *)a2 + 4), *(float *)v52.i32);
      *(float *)v42.f64 = *(float *)v40.i32 + *(float *)&v41;
      v38.f32[1] = *(float *)v40.i32 + *(float *)&v41;
      *(double *)v44.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v38.i64, v42, v39, v41, v40, v52, v43);
      float32x4_t v53 = v44;
      float32x4_t v45 = vsubq_f32(v58, v50);
      float32x4_t v46 = v45;
      v46.i32[3] = v54;
      v45.i32[3] = v55;
      float32x4_t v47 = vmulq_f32(v46, v45);
      float v48 = expf(-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0]* a5));
      long long v25 = v56;
      float v49 = vmuls_lane_f32(v30 * v48, v58, 3);
      *(float *)&long long v25 = *(float *)&v56 + v49;
      ++v27;
      float32x4_t v29 = vaddq_f32(v57, vmulq_n_f32(v53, v49));
      --v28;
    }
    while (v28);
  }
}

void CI::f4_sr_sr_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  float v11 = *(void **)(a1 + 48);
  int8x16_t v12 = *(double (**)(uint64_t, uint64_t, float, float, float))(a1 + 24);
  uint64_t v13 = v11[1];
  uint64_t v14 = v11[4];
  uint64_t v15 = v11[7];
  uint64_t v16 = v11[10];
  uint64_t v17 = v11[13];
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * v11[16]), a2);
  }
  *(double *)&long long v18 = v12(a4 + 80 * v13, a4 + 80 * v14, *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

void cikernel::_CBVertGuided(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4, float a5, float a6)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v12.i8 = *DC;
  int8x16_t v51 = v12;
  LODWORD(v13) = *((_DWORD *)this + 7);
  *(float *)&double v14 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v15) = *((_DWORD *)this + 9);
  *(float *)v16.f64 = *(float *)&v15
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v13, COERCE_FLOAT(*DC));
  HIDWORD(v14) = LODWORD(v16.f64[0]);
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v14, v16, v13, v15, v12, v17, v18);
  float32x4_t v50 = v19;
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *((_DWORD *)a2 + 7);
  v19.f32[0] = *((float *)a2 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v51.i8, 1), *((float *)a2 + 4), *(float *)v51.i32);
  LODWORD(v21) = *((_DWORD *)a2 + 9);
  *(float *)v22.f64 = *(float *)&v21
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v51.i8, 1), *(float *)&v20, *(float *)v51.i32);
  v19.i32[1] = LODWORD(v22.f64[0]);
  CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v19.i64, v22, v20, v21, v51, v23, v24);
  int v26 = (int)a4;
  if (((int)a4 & 0x80000000) == 0)
  {
    int v27 = -v26;
    int v28 = (2 * v26) | 1;
    float32x4_t v29 = 0uLL;
    *(void *)&long long v25 = 0;
    do
    {
      long long v56 = v25;
      float32x4_t v57 = v29;
      float v30 = expf(-(float)((float)(v27 * v27) * a6));
      LODWORD(v31.f64[0]) = 0;
      *((float *)v31.f64 + 1) = (float)v27;
      *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v51.i8, *(float32x2_t *)&v31.f64[0]);
      int8x16_t v52 = v32;
      LODWORD(v33) = *((_DWORD *)this + 7);
      *(float *)&double v34 = *((float *)this + 6)
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v32.i8, 1), *((float *)this + 4), *(float *)v32.i32);
      LODWORD(v35) = *((_DWORD *)this + 9);
      *(float *)v31.f64 = *(float *)&v35
                        + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v32.i8, 1), *(float *)&v33, *(float *)v32.i32);
      HIDWORD(v34) = LODWORD(v31.f64[0]);
      *(double *)v38.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v34, v31, v33, v35, v32, v36, v37);
      float32x4_t v58 = v38;
      HIDWORD(v39) = v52.i32[1];
      LODWORD(v39) = *((_DWORD *)a2 + 7);
      v40.i32[0] = *((_DWORD *)a2 + 9);
      *(float *)&double v41 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v52.i8, 1), *(float *)&v39, *(float *)v52.i32);
      v38.f32[0] = *((float *)a2 + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v52.i8, 1), *((float *)a2 + 4), *(float *)v52.i32);
      *(float *)v42.f64 = *(float *)v40.i32 + *(float *)&v41;
      v38.f32[1] = *(float *)v40.i32 + *(float *)&v41;
      *(double *)v44.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v38.i64, v42, v39, v41, v40, v52, v43);
      float32x4_t v53 = v44;
      float32x4_t v45 = vsubq_f32(v58, v50);
      float32x4_t v46 = v45;
      v46.i32[3] = v54;
      v45.i32[3] = v55;
      float32x4_t v47 = vmulq_f32(v46, v45);
      float v48 = expf(-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0]* a5));
      long long v25 = v56;
      float v49 = vmuls_lane_f32(v30 * v48, v58, 3);
      *(float *)&long long v25 = *(float *)&v56 + v49;
      ++v27;
      float32x4_t v29 = vaddq_f32(v57, vmulq_n_f32(v53, v49));
      --v28;
    }
    while (v28);
  }
}

void cikernel::_CBHorz(cikernel *this, SamplerObj *a2, float a3, float a4, float a5)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v10.i8 = *DC;
  LODWORD(v11) = *((_DWORD *)this + 7);
  *(float *)&double v12 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v13) = *((_DWORD *)this + 9);
  float32x2_t v37 = *DC;
  *(float *)v14.f64 = *(float *)&v13
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  HIDWORD(v12) = LODWORD(v14.f64[0]);
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v14, v11, v13, v10, v15, v16);
  float32x4_t v38 = v17;
  int v19 = (int)a3;
  if (((int)a3 & 0x80000000) == 0)
  {
    int v20 = -v19;
    int v21 = (2 * v19) | 1;
    float32x4_t v22 = 0uLL;
    *(void *)&long long v18 = 0;
    do
    {
      long long v42 = v18;
      float32x4_t v43 = v22;
      float v23 = expf(-(float)((float)(v20 * v20) * a5));
      HIDWORD(v24.f64[0]) = 0;
      float32x2_t v25 = vadd_f32(v37, (float32x2_t)COERCE_UNSIGNED_INT((float)v20));
      *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
      LODWORD(v27) = *((_DWORD *)this + 7);
      v28.i32[0] = *((_DWORD *)this + 9);
      *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)&v27, v25.f32[0]);
      v25.f32[0] = *((float *)this + 6) + *(float *)&v26;
      *(float *)v24.f64 = *(float *)v28.i32 + *(float *)v29.i32;
      v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
      *(double *)v31.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v25, v24, v26, v27, v29, v28, v30);
      float32x4_t v39 = v31;
      float32x4_t v32 = vsubq_f32(v31, v38);
      float32x4_t v33 = v32;
      v33.i32[3] = v40;
      v32.i32[3] = v41;
      float32x4_t v34 = vmulq_f32(v33, v32);
      float v35 = expf(-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0]* a4));
      long long v18 = v42;
      float v36 = vmuls_lane_f32(v23 * v35, v39, 3);
      *(float *)&long long v18 = *(float *)&v42 + v36;
      ++v20;
      float32x4_t v22 = vaddq_f32(v43, vmulq_n_f32(v39, v36));
      --v21;
    }
    while (v21);
  }
}

void CI::f4_sr_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  double v11 = *(void **)(a1 + 48);
  double v12 = *(double (**)(uint64_t, float, float, float))(a1 + 24);
  uint64_t v13 = v11[1];
  uint64_t v14 = v11[4];
  uint64_t v15 = v11[7];
  uint64_t v16 = v11[10];
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * v11[13]), a2);
  }
  *(double *)&long long v17 = v12(a4 + 80 * v13, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

void cikernel::_CBVert(cikernel *this, SamplerObj *a2, float a3, float a4, float a5)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v10.i8 = *DC;
  LODWORD(v11) = *((_DWORD *)this + 7);
  *(float *)&double v12 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v13) = *((_DWORD *)this + 9);
  float32x2_t v37 = *DC;
  *(float *)v14.f64 = *(float *)&v13
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  HIDWORD(v12) = LODWORD(v14.f64[0]);
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v14, v11, v13, v10, v15, v16);
  float32x4_t v38 = v17;
  int v19 = (int)a3;
  if (((int)a3 & 0x80000000) == 0)
  {
    int v20 = -v19;
    int v21 = (2 * v19) | 1;
    float32x4_t v22 = 0uLL;
    *(void *)&long long v18 = 0;
    do
    {
      long long v42 = v18;
      float32x4_t v43 = v22;
      float v23 = expf(-(float)((float)(v20 * v20) * a5));
      LODWORD(v24.f64[0]) = 0;
      *((float *)v24.f64 + 1) = (float)v20;
      float32x2_t v25 = vadd_f32(v37, *(float32x2_t *)&v24.f64[0]);
      *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
      LODWORD(v27) = *((_DWORD *)this + 7);
      v28.i32[0] = *((_DWORD *)this + 9);
      *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)&v27, v25.f32[0]);
      v25.f32[0] = *((float *)this + 6) + *(float *)&v26;
      *(float *)v24.f64 = *(float *)v28.i32 + *(float *)v29.i32;
      v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
      *(double *)v31.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v25, v24, v26, v27, v29, v28, v30);
      float32x4_t v39 = v31;
      float32x4_t v32 = vsubq_f32(v31, v38);
      float32x4_t v33 = v32;
      v33.i32[3] = v40;
      v32.i32[3] = v41;
      float32x4_t v34 = vmulq_f32(v33, v32);
      float v35 = expf(-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).f32[0]* a4));
      long long v18 = v42;
      float v36 = vmuls_lane_f32(v23 * v35, v39, 3);
      *(float *)&long long v18 = *(float *)&v42 + v36;
      ++v20;
      float32x4_t v22 = vaddq_f32(v43, vmulq_n_f32(v39, v36));
      --v21;
    }
    while (v21);
  }
}

double cikernel::_add(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vaddq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_multiply(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_min(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vminnmq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_max(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmaxnmq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_clear()
{
  return 0.0;
}

double cikernel::_dst(double a1, double a2)
{
  return a2;
}

double cikernel::_srcOver(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vaddq_f32(a1, vmulq_n_f32(a2, 1.0 - a1.f32[3])).u64[0];
  return result;
}

double cikernel::_dstOver(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vaddq_f32(a2, vmulq_n_f32(a1, 1.0 - a2.f32[3])).u64[0];
  return result;
}

double cikernel::_srcIn(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_laneq_f32(a1, a2, 3).u64[0];
  return result;
}

double cikernel::_dstIn(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_laneq_f32(a2, a1, 3).u64[0];
  return result;
}

double cikernel::_srcOut(float32x4_t a1, __n128 a2)
{
  *(void *)&double result = vmulq_n_f32(a1, 1.0 - a2.n128_f32[3]).u64[0];
  return result;
}

double cikernel::_dstOut(__n128 a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_n_f32(a2, 1.0 - a1.n128_f32[3]).u64[0];
  return result;
}

double cikernel::_srcAtop(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vaddq_f32(vmulq_laneq_f32(a1, a2, 3), vmulq_n_f32(a2, 1.0 - a1.f32[3])).u64[0];
  return result;
}

double cikernel::_dstAtop(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vaddq_f32(vmulq_laneq_f32(a2, a1, 3), vmulq_n_f32(a1, 1.0 - a2.f32[3])).u64[0];
  return result;
}

double cikernel::_exclusiveOr(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])).u64[0];
  return result;
}

double cikernel::_multiplyBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_f32(vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001)), vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)));
  v2.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_screenBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  float32x4_t v4 = vsubq_f32(vaddq_f32(v2, v3), vmulq_f32(v2, v3));
  v4.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v4, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_overlayBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vsubq_f32(vaddq_f32(v2, v3), vmulq_f32(v2, v3));
  __asm { FMOV            V17.4S, #-1.0 }
  float32x4_t v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(v4, v3)), (int8x16_t)vaddq_f32(vaddq_f32(v5, v5), _Q17), (int8x16_t)vmulq_f32(v2, vaddq_f32(v3, v3)));
  v11.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v11, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_darkenBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  float32x4_t v4 = vminnmq_f32(v3, v2);
  v4.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v4, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_lightenBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  float32x4_t v4 = vmaxnmq_f32(v3, v2);
  v4.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v4, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_colorDodgeBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  __asm { FMOV            V7.4S, #1.0 }
  float32x4_t v8 = vdivq_f32(vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)), vmaxnmq_f32(vsubq_f32(_Q7, v2), (float32x4_t)vdupq_n_s32(0x33D6BF95u)));
  v8.i32[3] = 1.0;
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v8, (float32x4_t)0), _Q7), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_colorBurnBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  __asm { FMOV            V7.4S, #1.0 }
  float32x4_t v8 = vsubq_f32(_Q7, vdivq_f32(vsubq_f32(_Q7, vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001))), vmaxnmq_f32(v2, (float32x4_t)vdupq_n_s32(0x33D6BF95u))));
  v8.i32[3] = 1.0;
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v8, (float32x4_t)0), _Q7), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_hardLightBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vsubq_f32(vaddq_f32(v2, v3), vmulq_f32(v2, v3));
  __asm { FMOV            V17.4S, #-1.0 }
  float32x4_t v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(v4, v2)), (int8x16_t)vaddq_f32(vaddq_f32(v5, v5), _Q17), (int8x16_t)vmulq_f32(v3, vaddq_f32(v2, v2)));
  v11.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v11, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_softLightBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  __asm
  {
    FMOV            V7.4S, #0.25
    FMOV            V17.4S, #16.0
    FMOV            V18.4S, #-12.0
  }
  float32x4_t v11 = vmulq_f32(v3, vaddq_f32(vmulq_f32(v3, _Q17), _Q18));
  __asm { FMOV            V18.4S, #4.0 }
  float32x4_t v13 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(_Q7, v3)), (int8x16_t)vsqrtq_f32(v3), (int8x16_t)vmulq_f32(v3, vaddq_f32(v11, _Q18)));
  __asm { FMOV            V17.4S, #-1.0 }
  float32x4_t v15 = vaddq_f32(vaddq_f32(v2, v2), _Q17);
  _Q17.i64[0] = 0x3F0000003F000000;
  _Q17.i64[1] = 0x3F0000003F000000;
  float32x4_t v16 = vsubq_f32(_Q17, v2);
  __asm { FMOV            V17.4S, #1.0 }
  float32x4_t v18 = vaddq_f32(v3, vmulq_f32(v15, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(v16), (int8x16_t)vsubq_f32(v13, v3), (int8x16_t)vmulq_f32(v3, vsubq_f32(_Q17, v3)))));
  v18.i32[3] = 1.0;
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v18, (float32x4_t)0), _Q17), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_differenceBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vabdq_f32(vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)), vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001)));
  v2.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_exclusionBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  v4.i64[0] = 0xC0000000C0000000;
  v4.i64[1] = 0xC0000000C0000000;
  float32x4_t v5 = vaddq_f32(vaddq_f32(v2, v3), vmulq_f32(v2, vmulq_f32(v3, v4)));
  v5.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v5, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_hueBlendMode(float32x4_t a1, float32x4_t a2, double a3, double a4, double a5, float32x4_t a6)
{
  float32x4_t v6 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  float32x4_t v7 = v6;
  v7.i32[3] = a1.i32[3];
  float32x4_t v8 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  a6.i32[0] = v8.i32[1];
  v9.i64[0] = vrev64q_s32((int32x4_t)v7).u64[0];
  v9.i64[1] = v7.i64[1];
  float32x4_t v10 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v7, v9);
  float32x4_t v11 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v10, (float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2))), 1)), (int8x16_t)v10, (int8x16_t)vuzp1q_s32((int32x4_t)v10, vrev64q_s32((int32x4_t)v10)));
  int8x16_t v12 = (int8x16_t)v11;
  v12.i32[0] = v11.i32[1];
  int32x4_t v13 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v11, v12);
  float32x4_t v14 = 0uLL;
  if (*(float *)v13.i32 > *(float *)&v13.i32[2])
  {
    int32x4_t v15 = (int32x4_t)v8;
    v15.i32[3] = a2.i32[3];
    v16.i64[0] = vrev64q_s32(v15).u64[0];
    v16.i64[1] = v15.i64[1];
    float32x4_t v17 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v8, a6), 0), (int8x16_t)v15, v16);
    float32x4_t v18 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v17, (float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2))), 1)), (int8x16_t)v17, (int8x16_t)vuzp1q_s32((int32x4_t)v17, vrev64q_s32((int32x4_t)v17)));
    int8x16_t v19 = (int8x16_t)v18;
    v19.i32[0] = v18.i32[1];
    float32x4_t v20 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))), 0)), (int8x16_t)v18, v19);
    float32x4_t v21 = vmulq_n_f32(vsubq_f32(v7, (float32x4_t)vdupq_laneq_s32(v13, 2)), vsubq_f32(v20, (float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2)).f32[0]);
    *(float *)v13.i32 = *(float *)v13.i32 - *(float *)&v13.i32[2];
    float32x4_t v14 = vdivq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.i8, 0));
  }
  v26.i32[1] = 1069295861;
  double v22 = v8.f32[1] * 0.59 + v8.f32[0] * 0.3 + v8.f32[2] * 0.11;
  *(float *)&double v22 = v22;
  float v23 = v14.f32[1] * 0.59 + v14.f32[0] * 0.3 + v14.f32[2] * 0.11;
  *(float *)&double v22 = *(float *)&v22 - v23;
  float32x4_t v24 = vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v22, 0));
  double v25 = v24.f32[1] * 0.59 + v24.f32[0] * 0.3 + v24.f32[2] * 0.11;
  *(float *)&double v25 = v25;
  *(float *)v26.i32 = fminf(fminf(v24.f32[0], v24.f32[1]), v24.f32[2]);
  float v27 = fmaxf(fmaxf(v24.f32[0], v24.f32[1]), v24.f32[2]);
  if (*(float *)v26.i32 < 0.0)
  {
    float32x4_t v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v25, 0);
    *(float *)v26.i32 = *(float *)&v25 - *(float *)v26.i32;
    float32x4_t v24 = vaddq_f32(v28, vdivq_f32(vmulq_n_f32(vsubq_f32(v24, v28), *(float *)&v25), (float32x4_t)vdupq_lane_s32(v26, 0)));
  }
  if (v27 > 1.0)
  {
    float32x4_t v29 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v25, 0);
    float32x4_t v30 = vmulq_n_f32(vsubq_f32(v24, v29), 1.0 - *(float *)&v25);
    *(float *)&double v25 = v27 - *(float *)&v25;
    float32x4_t v24 = vaddq_f32(v29, vdivq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v25, 0)));
  }
  v24.i32[3] = 1.0;
  __asm { FMOV            V5.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v24, (float32x4_t)0), _Q5), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_saturationBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  float32x4_t v3 = v2;
  v3.i32[3] = a2.i32[3];
  v4.i64[0] = vrev64q_s32((int32x4_t)v3).u64[0];
  v4.i64[1] = v3.i64[1];
  float32x4_t v5 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1)), 0), (int8x16_t)v3, v4);
  float32x4_t v6 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v5, (float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2))), 1)), (int8x16_t)v5, (int8x16_t)vuzp1q_s32((int32x4_t)v5, vrev64q_s32((int32x4_t)v5)));
  int8x16_t v7 = (int8x16_t)v6;
  v7.i32[0] = v6.i32[1];
  int8x16_t v8 = vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v6, v7);
  float32x4_t v9 = 0uLL;
  if (*(float *)v8.i32 > *(float *)&v8.i32[2])
  {
    float32x4_t v10 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
    int16x4_t v11 = vmovn_s32(vcgtq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1)));
    v10.i32[3] = a1.i32[3];
    v12.i64[0] = vrev64q_s32((int32x4_t)v10).u64[0];
    v12.i64[1] = v10.i64[1];
    float32x4_t v13 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(v11, 0)), 0x1FuLL)), (int8x16_t)v10, v12);
    float32x4_t v14 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v13, (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2))), 1)), (int8x16_t)v13, (int8x16_t)vuzp1q_s32((int32x4_t)v13, vrev64q_s32((int32x4_t)v13)));
    int8x16_t v15 = (int8x16_t)v14;
    v15.i32[0] = v14.i32[1];
    float32x4_t v16 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))), 0)), (int8x16_t)v14, v15);
    float32x4_t v17 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2);
    *(float *)v8.i32 = *(float *)v8.i32 - *(float *)&v8.i32[2];
    float32x4_t v9 = vdivq_f32(vmulq_n_f32(vsubq_f32(v3, v17), vsubq_f32(v16, v17).f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.i8, 0));
  }
  v22.i32[1] = 1069295861;
  double v18 = v2.f32[1] * 0.59 + v2.f32[0] * 0.3 + v2.f32[2] * 0.11;
  *(float *)&double v18 = v18;
  float v19 = v9.f32[1] * 0.59 + v9.f32[0] * 0.3 + v9.f32[2] * 0.11;
  *(float *)&double v18 = *(float *)&v18 - v19;
  float32x4_t v20 = vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 0));
  double v21 = v20.f32[1] * 0.59 + v20.f32[0] * 0.3 + v20.f32[2] * 0.11;
  *(float *)&double v21 = v21;
  *(float *)v22.i32 = fminf(fminf(v20.f32[0], v20.f32[1]), v20.f32[2]);
  float v23 = fmaxf(fmaxf(v20.f32[0], v20.f32[1]), v20.f32[2]);
  if (*(float *)v22.i32 < 0.0)
  {
    float32x4_t v24 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v21, 0);
    *(float *)v22.i32 = *(float *)&v21 - *(float *)v22.i32;
    float32x4_t v20 = vaddq_f32(v24, vdivq_f32(vmulq_n_f32(vsubq_f32(v20, v24), *(float *)&v21), (float32x4_t)vdupq_lane_s32(v22, 0)));
  }
  if (v23 > 1.0)
  {
    float32x4_t v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v21, 0);
    float32x4_t v26 = vmulq_n_f32(vsubq_f32(v20, v25), 1.0 - *(float *)&v21);
    *(float *)&double v21 = v23 - *(float *)&v21;
    float32x4_t v20 = vaddq_f32(v25, vdivq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v21, 0)));
  }
  v20.i32[3] = 1.0;
  __asm { FMOV            V5.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v20, (float32x4_t)0), _Q5), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_colorBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  int32x4_t v3 = (int32x4_t)vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  float32x2_t v4 = (float32x2_t)vzip1_s32(*(int32x2_t *)v3.i8, *(int32x2_t *)v2.f32);
  float32x2_t v5 = (float32x2_t)vzip2_s32(*(int32x2_t *)v3.i8, *(int32x2_t *)v2.f32);
  v3.i64[0] = vzip2q_s32(v3, (int32x4_t)v2).u64[0];
  v2.i32[3] = a1.i32[3];
  *(float32x2_t *)v3.i8 = vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v5), (float64x2_t)vdupq_n_s64(0x3FE2E147AE147AE1uLL)), (float64x2_t)vdupq_n_s64(0x3FD3333333333333uLL), vcvtq_f64_f32(v4)), (float64x2_t)vdupq_n_s64(0x3FBC28F5C28F5C29uLL), vcvtq_f64_f32(*(float32x2_t *)v3.i8)));
  float32x4_t v6 = vaddq_f32(v2, (float32x4_t)vdupq_lane_s32((int32x2_t)vsub_f32(*(float32x2_t *)v3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v3.i8, 1)), 0));
  double v8 = v6.f32[2];
  double v7 = v6.f32[1] * 0.59 + v6.f32[0] * 0.3 + v6.f32[2] * 0.11;
  *(float *)&double v7 = v7;
  *(float *)&double v8 = fminf(fminf(v6.f32[0], v6.f32[1]), v6.f32[2]);
  float v9 = fmaxf(fmaxf(v6.f32[0], v6.f32[1]), v6.f32[2]);
  if (*(float *)&v8 < 0.0)
  {
    float32x4_t v10 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0);
    *(float *)&double v8 = *(float *)&v7 - *(float *)&v8;
    float32x4_t v6 = vaddq_f32(v10, vdivq_f32(vmulq_n_f32(vsubq_f32(v6, v10), *(float *)&v7), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v8, 0)));
  }
  if (v9 > 1.0)
  {
    float32x4_t v11 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0);
    float32x4_t v12 = vmulq_n_f32(vsubq_f32(v6, v11), 1.0 - *(float *)&v7);
    *(float *)&double v7 = v9 - *(float *)&v7;
    float32x4_t v6 = vaddq_f32(v11, vdivq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0)));
  }
  v6.i32[3] = 1.0;
  __asm { FMOV            V6.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v6, (float32x4_t)0), _Q6), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_luminosityBlendMode(float32x4_t a1, float32x4_t a2)
{
  int32x4_t v2 = (int32x4_t)vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  float32x2_t v4 = (float32x2_t)vzip1_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.f32);
  float32x2_t v5 = (float32x2_t)vzip2_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.f32);
  v2.i64[0] = vzip2q_s32(v2, (int32x4_t)v3).u64[0];
  v3.i32[3] = a2.i32[3];
  *(float32x2_t *)v2.i8 = vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v5), (float64x2_t)vdupq_n_s64(0x3FE2E147AE147AE1uLL)), (float64x2_t)vdupq_n_s64(0x3FD3333333333333uLL), vcvtq_f64_f32(v4)), (float64x2_t)vdupq_n_s64(0x3FBC28F5C28F5C29uLL), vcvtq_f64_f32(*(float32x2_t *)v2.i8)));
  float32x4_t v6 = vaddq_f32(v3, (float32x4_t)vdupq_lane_s32((int32x2_t)vsub_f32(*(float32x2_t *)v2.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v2.i8, 1)), 0));
  double v8 = v6.f32[2];
  double v7 = v6.f32[1] * 0.59 + v6.f32[0] * 0.3 + v6.f32[2] * 0.11;
  *(float *)&double v7 = v7;
  *(float *)&double v8 = fminf(fminf(v6.f32[0], v6.f32[1]), v6.f32[2]);
  float v9 = fmaxf(fmaxf(v6.f32[0], v6.f32[1]), v6.f32[2]);
  if (*(float *)&v8 < 0.0)
  {
    float32x4_t v10 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0);
    *(float *)&double v8 = *(float *)&v7 - *(float *)&v8;
    float32x4_t v6 = vaddq_f32(v10, vdivq_f32(vmulq_n_f32(vsubq_f32(v6, v10), *(float *)&v7), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v8, 0)));
  }
  if (v9 > 1.0)
  {
    float32x4_t v11 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0);
    float32x4_t v12 = vmulq_n_f32(vsubq_f32(v6, v11), 1.0 - *(float *)&v7);
    *(float *)&double v7 = v9 - *(float *)&v7;
    float32x4_t v6 = vaddq_f32(v11, vdivq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0)));
  }
  if (a1.f32[3] >= 0.000001)
  {
    v6.i32[3] = 1.0;
    __asm { FMOV            V6.4S, #1.0 }
    a2.i64[0] = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v6, (float32x4_t)0), _Q6), a1, 3), a2, 3)).u64[0];
  }
  return *(double *)a2.i64;
}

double cikernel::_subtractBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vsubq_f32(vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)), vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001)));
  v2.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_divideBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vdivq_f32(vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)), vmaxnmq_f32(v2, (float32x4_t)vdupq_n_s32(0x33D6BF95u)));
  v3.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v3, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_linearBurnBlendMode(float32x4_t a1, float32x4_t a2)
{
  __asm { FMOV            V4.4S, #-1.0 }
  float32x4_t v7 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001)), vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001))), _Q4);
  v7.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v7, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_linearDodgeBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vaddq_f32(vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001)), vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)));
  v2.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_vividLightBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  __asm { FMOV            V7.4S, #1.0 }
  float32x4_t v9 = (float32x4_t)vdupq_n_s32(0x33D6BF95u);
  int8x16_t v10 = (int8x16_t)vsubq_f32(_Q7, vdivq_f32(vsubq_f32(_Q7, v3), vmaxnmq_f32(vaddq_f32(v2, v2), v9)));
  float32x4_t v11 = vsubq_f32(_Q7, v2);
  int8x16_t v12 = (int8x16_t)vdivq_f32(v3, vmaxnmq_f32(vaddq_f32(v11, v11), v9));
  v11.i64[0] = 0x3F0000003F000000;
  v11.i64[1] = 0x3F0000003F000000;
  float32x4_t v13 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(v11, v2)), v12, v10);
  v13.i32[3] = 1.0;
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v13, (float32x4_t)0), _Q7), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_linearLightBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  float32x4_t v3 = vaddq_f32(vaddq_f32(v2, v2), vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)));
  __asm { FMOV            V4.4S, #-1.0 }
  float32x4_t v9 = vaddq_f32(v3, _Q4);
  v9.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v9, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_pinLightBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  float32x4_t v4 = vaddq_f32(v2, v2);
  __asm { FMOV            V7.4S, #-1.0 }
  float32x4_t v10 = vaddq_f32(v4, _Q7);
  float32x4_t v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(v3, v10)), (int8x16_t)v10, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(v3, v4)), (int8x16_t)v3, (int8x16_t)v4));
  v11.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v11, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_hardMixBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  __asm { FMOV            V7.4S, #1.0 }
  float32x4_t v9 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(vsubq_f32(_Q7, v3), v2)), (int8x16_t)_Q7, (int8x16_t)0);
  v9.i32[3] = 1.0;
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v9, (float32x4_t)0), _Q7), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_darkerColorBlendMode(float32x4_t a1, float32x4_t a2)
{
  int32x4_t v2 = (int32x4_t)vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  int32x4_t v3 = (int32x4_t)vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  float32x2_t v4 = vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.i8)), (float64x2_t)vdupq_n_s64(0x3FE2E147AE147AE1uLL)), (float64x2_t)vdupq_n_s64(0x3FD3333333333333uLL), vcvtq_f64_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.i8))), (float64x2_t)vdupq_n_s64(0x3FBC28F5C28F5C29uLL), vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v2, v3))));
  float32x4_t v5 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16((int16x4_t)vcgt_f32(v4, (float32x2_t)vdup_lane_s32((int32x2_t)v4, 1)), 0)), 0x1FuLL)), (int8x16_t)v3, (int8x16_t)v2);
  v5.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v5, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_lighterColorBlendMode(float32x4_t a1, float32x4_t a2)
{
  int32x4_t v2 = (int32x4_t)vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  int32x4_t v3 = (int32x4_t)vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  float32x2_t v4 = vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.i8)), (float64x2_t)vdupq_n_s64(0x3FE2E147AE147AE1uLL)), (float64x2_t)vdupq_n_s64(0x3FD3333333333333uLL), vcvtq_f64_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.i8))), (float64x2_t)vdupq_n_s64(0x3FBC28F5C28F5C29uLL), vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v2, v3))));
  float32x4_t v5 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16((int16x4_t)vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v4, 1), v4), 0)), 0x1FuLL)), (int8x16_t)v3, (int8x16_t)v2);
  v5.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v5, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_plusDarker(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vaddq_f32(a1, a2);
  float32x4_t v3 = vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 3), v2);
  v3.i32[3] = v2.i32[3];
  float32x4_t v4 = vmaxnmq_f32(v3, (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  float32x4_t v10 = vminnmq_f32(v4, _Q1);
  *(void *)&double result = vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 3), v10).u64[0];
  return result;
}

double cikernel::_plusLighter(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vaddq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_hueBlendMode_v0(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v3 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  int32x4_t v2 = vcgtq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1));
  v3.i32[3] = a1.i32[3];
  float32x4_t v4 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  int32x4_t v5 = (int32x4_t)v4;
  v5.i32[3] = a2.i32[3];
  int16x4_t v6 = vmovn_s32(v2);
  v2.i64[0] = vrev64q_s32((int32x4_t)v3).u64[0];
  v2.i64[1] = v3.i64[1];
  float32x4_t v7 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(v6, 0)), 0x1FuLL)), (int8x16_t)v3, (int8x16_t)v2);
  float32x4_t v8 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v7, (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2))), 1)), (int8x16_t)v7, (int8x16_t)vuzp1q_s32((int32x4_t)v7, vrev64q_s32((int32x4_t)v7)));
  int8x16_t v9 = (int8x16_t)v8;
  v9.i32[0] = v8.i32[1];
  int32x4_t v10 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v8, v9);
  v9.i64[0] = vrev64q_s32(v5).u64[0];
  v9.i64[1] = v5.i64[1];
  float32x4_t v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v5, v9);
  float32x4_t v12 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v11, (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2))), 1)), (int8x16_t)v11, (int8x16_t)vuzp1q_s32((int32x4_t)v11, vrev64q_s32((int32x4_t)v11)));
  int8x16_t v13 = (int8x16_t)v12;
  v13.i32[0] = v12.i32[1];
  float32x4_t v14 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))), 0)), (int8x16_t)v12, v13);
  if (*(float *)&v10.i32[2] + 0.00001 <= *(float *)v10.i32)
  {
    float32x4_t v15 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2);
    float32x4_t v16 = vmulq_n_f32(vsubq_f32(v3, (float32x4_t)vdupq_laneq_s32(v10, 2)), vsubq_f32(v14, v15).f32[0]);
    *(float *)v10.i32 = *(float *)v10.i32 - *(float *)&v10.i32[2];
    float32x4_t v14 = vaddq_f32(v15, vdivq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.i8, 0)));
  }
  else
  {
    v14.i32[1] = v14.i32[2];
  }
  v14.i32[3] = a2.i32[3];
  float32x4_t v17 = vmulq_laneq_f32(v4, a2, 3);
  v17.i32[3] = a2.i32[3];
  float32x4_t v18 = vmlaq_laneq_f32(vmulq_n_f32(v3, 1.0 - a2.f32[3]), v14, a2, 3);
  v18.i32[3] = 1.0;
  *(void *)&double result = vmlaq_laneq_f32(vmulq_n_f32(v17, 1.0 - a1.f32[3]), v18, a1, 3).u64[0];
  return result;
}

double cikernel::_saturationBlendMode_v0(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v3 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  int32x4_t v2 = vcgtq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1));
  v3.i32[3] = a1.i32[3];
  float32x4_t v4 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  float32x4_t v5 = v4;
  v5.i32[3] = a2.i32[3];
  v6.i64[0] = vrev64q_s32((int32x4_t)v3).u64[0];
  v6.i64[1] = v3.i64[1];
  float32x4_t v7 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(v2), 0)), 0x1FuLL)), (int8x16_t)v3, v6);
  float32x4_t v8 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v7, (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2))), 1)), (int8x16_t)v7, (int8x16_t)vuzp1q_s32((int32x4_t)v7, vrev64q_s32((int32x4_t)v7)));
  int8x16_t v9 = (int8x16_t)v8;
  v9.i32[0] = v8.i32[1];
  int8x16_t v10 = vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v8, v9);
  float v11 = *(float *)v10.i32 + *(float *)&v10.i32[2];
  v6.i64[0] = vrev64q_s32((int32x4_t)v5).u64[0];
  v6.i64[1] = v5.i64[1];
  float32x4_t v12 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v5, v6);
  float32x4_t v13 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v12, (float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2))), 1)), (int8x16_t)v12, (int8x16_t)vuzp1q_s32((int32x4_t)v12, vrev64q_s32((int32x4_t)v12)));
  float v14 = (float)(*(float *)v10.i32 + *(float *)&v10.i32[2]) * 0.5;
  int8x16_t v15 = (int8x16_t)v13;
  v15.i32[0] = v13.i32[1];
  int32x4_t v16 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v13, v15);
  float v17 = (float)(*(float *)v16.i32 + *(float *)&v16.i32[2]) * 0.5;
  float v18 = *(float *)v10.i32 - *(float *)&v10.i32[2];
  float v19 = 2.0 - v11;
  if (v14 < 0.5) {
    float v19 = v11;
  }
  float v20 = v18 / fmaxf(v19, 0.000001);
  float v21 = v17 + (float)(v17 * v20);
  float v22 = (float)(v17 + v20) - (float)(v17 * v20);
  if (v17 > 0.5) {
    float v21 = v22;
  }
  double v23 = -(v21 - v17 * 2.0);
  *(float *)&double v23 = v23;
  if (*(float *)&v16.i32[2] + 0.00001 <= *(float *)v16.i32)
  {
    float32x4_t v29 = vmulq_n_f32(vsubq_f32(v5, (float32x4_t)vdupq_laneq_s32(v16, 2)), v21 - *(float *)&v23);
    *(float *)v16.i32 = *(float *)v16.i32 - *(float *)&v16.i32[2];
    _Q6 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v23, 0), vdivq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.i8, 0)));
  }
  else
  {
    __asm { FMOV            V6.4S, #1.0 }
    _Q6.i64[0] = __PAIR64__(LODWORD(v23), LODWORD(v21));
    _Q6.i32[2] = LODWORD(v23);
  }
  _Q6.i32[3] = a2.i32[3];
  float32x4_t v30 = vmulq_laneq_f32(v4, a2, 3);
  v30.i32[3] = a2.i32[3];
  float32x4_t v31 = vmlaq_laneq_f32(vmulq_n_f32(v3, 1.0 - a2.f32[3]), _Q6, a2, 3);
  v31.i32[3] = 1.0;
  *(void *)&double result = vmlaq_laneq_f32(vmulq_n_f32(v30, 1.0 - a1.f32[3]), v31, a1, 3).u64[0];
  return result;
}

double cikernel::_colorBlendMode_v0(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v3 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  int32x4_t v2 = vcgtq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1));
  v3.i32[3] = a1.i32[3];
  float32x4_t v4 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  int32x4_t v5 = (int32x4_t)v4;
  v5.i32[3] = a2.i32[3];
  v6.i64[0] = vrev64q_s32((int32x4_t)v3).u64[0];
  v6.i64[1] = v3.i64[1];
  float32x4_t v7 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(v2), 0)), 0x1FuLL)), (int8x16_t)v3, v6);
  float32x4_t v8 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v7, (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2))), 1)), (int8x16_t)v7, (int8x16_t)vuzp1q_s32((int32x4_t)v7, vrev64q_s32((int32x4_t)v7)));
  float64x2_t v9 = (float64x2_t)v8;
  LODWORD(v9.f64[0]) = v8.i32[1];
  int32x4_t v10 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v8, (int8x16_t)v9);
  v6.i64[0] = vrev64q_s32(v5).u64[0];
  v6.i64[1] = v5.i64[1];
  float32x4_t v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v5, v6);
  float32x4_t v12 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v11, (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2))), 1)), (int8x16_t)v11, (int8x16_t)vuzp1q_s32((int32x4_t)v11, vrev64q_s32((int32x4_t)v11)));
  int8x16_t v16 = (int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))), 0));
  float64x2_t v14 = (float64x2_t)v12;
  LODWORD(v14.f64[0]) = v12.i32[1];
  float32x4_t v13 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)v14);
  *(float *)v14.f64 = *(float *)v10.i32 + *(float *)&v10.i32[2];
  float v15 = 0.5 * vaddq_f32(v13, (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2)).f32[0];
  *(float *)v16.i32 = *(float *)v10.i32 - *(float *)&v10.i32[2];
  if ((float)((float)(*(float *)v10.i32 + *(float *)&v10.i32[2]) * 0.5) >= 0.5) {
    *(float *)v14.f64 = 2.0 - (float)(*(float *)v10.i32 + *(float *)&v10.i32[2]);
  }
  float v17 = *(float *)v16.i32 / fmaxf(*(float *)v14.f64, 0.000001);
  double v18 = v15;
  float v19 = v15 + (float)(v15 * v17);
  float v20 = (float)(v15 + v17) - (float)(v15 * v17);
  if (v15 <= 0.5) {
    float v21 = v19;
  }
  else {
    float v21 = v20;
  }
  v14.f64[0] = v21;
  v9.f64[0] = -(v21 - v18 * 2.0);
  *(float *)v9.f64 = v9.f64[0];
  float32x4_t v22 = vmulq_n_f32(vsubq_f32(v3, (float32x4_t)vdupq_laneq_s32(v10, 2)), v21 - *(float *)v9.f64);
  float32x4_t v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.i8, 0);
  float32x4_t v24 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v9.f64[0], 0);
  v9.f64[0] = *(float *)v9.f64 + 0.00001;
  int8x16_t v25 = (int8x16_t)vdivq_f32(v22, v23);
  v23.i64[0] = 0x8000000080000000;
  v23.i64[1] = 0x8000000080000000;
  float32x4_t v26 = vaddq_f32(v24, (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_f64(v9, v14).i64[0], 0), (int8x16_t)v23, v25));
  v26.i32[3] = a2.i32[3];
  float32x4_t v27 = vmulq_laneq_f32(v4, a2, 3);
  v27.i32[3] = a2.i32[3];
  float32x4_t v28 = vmlaq_laneq_f32(vmulq_n_f32(v3, 1.0 - a2.f32[3]), v26, a2, 3);
  v28.i32[3] = 1.0;
  *(void *)&double result = vmlaq_laneq_f32(vmulq_n_f32(v27, 1.0 - a1.f32[3]), v28, a1, 3).u64[0];
  return result;
}

double cikernel::_luminosityBlendMode_v0(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  int32x4_t v3 = (int32x4_t)v2;
  v3.i32[3] = a1.i32[3];
  float32x4_t v5 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  int32x4_t v4 = vcgtq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1));
  v5.i32[3] = a2.i32[3];
  v6.i64[0] = vrev64q_s32((int32x4_t)v5).u64[0];
  v6.i64[1] = v5.i64[1];
  float32x4_t v7 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(v4), 0)), 0x1FuLL)), (int8x16_t)v5, v6);
  float32x4_t v8 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v7, (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2))), 1)), (int8x16_t)v7, (int8x16_t)vuzp1q_s32((int32x4_t)v7, vrev64q_s32((int32x4_t)v7)));
  float64x2_t v9 = (float64x2_t)v8;
  LODWORD(v9.f64[0]) = v8.i32[1];
  int32x4_t v10 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v8, (int8x16_t)v9);
  v6.i64[0] = vrev64q_s32(v3).u64[0];
  v6.i64[1] = v3.i64[1];
  float32x4_t v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v3, v6);
  float32x4_t v12 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v11, (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2))), 1)), (int8x16_t)v11, (int8x16_t)vuzp1q_s32((int32x4_t)v11, vrev64q_s32((int32x4_t)v11)));
  int8x16_t v16 = (int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))), 0));
  float64x2_t v14 = (float64x2_t)v12;
  LODWORD(v14.f64[0]) = v12.i32[1];
  float32x4_t v13 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)v14);
  *(float *)v14.f64 = *(float *)v10.i32 + *(float *)&v10.i32[2];
  float v15 = 0.5 * vaddq_f32(v13, (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2)).f32[0];
  *(float *)v16.i32 = *(float *)v10.i32 - *(float *)&v10.i32[2];
  if ((float)((float)(*(float *)v10.i32 + *(float *)&v10.i32[2]) * 0.5) >= 0.5) {
    *(float *)v14.f64 = 2.0 - (float)(*(float *)v10.i32 + *(float *)&v10.i32[2]);
  }
  float v17 = *(float *)v16.i32 / fmaxf(*(float *)v14.f64, 0.000001);
  double v18 = v15;
  float v19 = v15 + (float)(v15 * v17);
  float v20 = (float)(v15 + v17) - (float)(v15 * v17);
  if (v15 <= 0.5) {
    float v21 = v19;
  }
  else {
    float v21 = v20;
  }
  v14.f64[0] = v21;
  v9.f64[0] = -(v21 - v18 * 2.0);
  *(float *)v9.f64 = v9.f64[0];
  float32x4_t v22 = vmulq_n_f32(vsubq_f32(v5, (float32x4_t)vdupq_laneq_s32(v10, 2)), v21 - *(float *)v9.f64);
  float32x4_t v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v9.f64[0], 0);
  v9.f64[0] = *(float *)v9.f64 + 0.00001;
  int8x16_t v24 = (int8x16_t)vdivq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.i8, 0));
  v25.i64[0] = 0x8000000080000000;
  v25.i64[1] = 0x8000000080000000;
  float32x4_t v26 = vaddq_f32(v23, (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_f64(v9, v14).i64[0], 0), v25, v24));
  v26.i32[3] = a1.i32[3];
  float32x4_t v27 = vmulq_laneq_f32(v2, a1, 3);
  v27.i32[3] = a1.i32[3];
  float32x4_t v28 = vmlaq_laneq_f32(vmulq_n_f32(v5, 1.0 - a1.f32[3]), v26, a1, 3);
  v28.i32[3] = 1.0;
  *(void *)&double result = vmlaq_laneq_f32(vmulq_n_f32(v27, 1.0 - a2.f32[3]), v28, a2, 3).u64[0];
  return result;
}

double cikernel::_linearBurnBlendMode_v0(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  float32x4_t v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  float32x4_t v4 = vmulq_laneq_f32(v3, a2, 3);
  v3.i32[3] = a2.i32[3];
  __asm { FMOV            V17.4S, #1.0 }
  v4.i32[3] = a2.i32[3];
  float32x4_t v10 = vmlaq_laneq_f32(vmulq_n_f32(v2, 1.0 - a2.f32[3]), vminnmq_f32(vmaxnmq_f32(vsubq_f32(v3, vsubq_f32(_Q17, vmulq_laneq_f32(v2, a1, 3))), (float32x4_t)0), _Q17), a2, 3);
  v10.i32[3] = 1.0;
  *(void *)&double result = vmlaq_laneq_f32(vmulq_n_f32(v4, 1.0 - a1.f32[3]), v10, a1, 3).u64[0];
  return result;
}

double cikernel::_mix(float32x4_t a1, float32x4_t a2, float a3)
{
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a3), a1, a3).u64[0];
  return result;
}

void CI::f4_s_s_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x4_t v11 = (double (*)(void *, __n128, __n128, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  uint64_t v16 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  float v17 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    float v17 = (__n128 *)((char *)a2 + 64 * v15);
  }
  double v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    double v18 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v19 = v11(a1, *v18, *v17, *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_blendWithMask(float32x4_t a1, float32x4_t a2, float32x2_t a3)
{
  *(void *)&double result = vmlaq_lane_f32(vmulq_n_f32(a2, 1.0 - a3.f32[1]), a1, a3, 1).u64[0];
  return result;
}

void CI::f4_s_s_s(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x4_t v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  int v16 = *(_DWORD *)(v10 + 64);
  uint64_t v17 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  double v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    double v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  long long v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    long long v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  float v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float v20 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double cikernel::_blendWithMaskB0(float32x4_t a1, float32x2_t a2)
{
  *(void *)&double result = vmulq_lane_f32(a1, a2, 1).u64[0];
  return result;
}

double cikernel::_blendWithRedMask(float32x4_t a1, float32x4_t a2, float a3)
{
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a3), a1, a3).u64[0];
  return result;
}

double cikernel::_blendWithRedMaskB0(float32x4_t a1, float a2)
{
  *(void *)&double result = vmulq_n_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_blendWithBlueMask(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  *(void *)&double result = vmlaq_laneq_f32(vmulq_n_f32(a2, 1.0 - a3.f32[2]), a1, a3, 2).u64[0];
  return result;
}

double cikernel::_blendWithBlueMaskB0(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_laneq_f32(a1, a2, 2).u64[0];
  return result;
}

double cikernel::_blendWithAlphaMask(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  *(void *)&double result = vmlaq_laneq_f32(vmulq_n_f32(a2, 1.0 - a3.f32[3]), a1, a3, 3).u64[0];
  return result;
}

double cikernel::_blendWithAlphaMaskB0(float32x4_t a1, float32x4_t a2)
{
  *(void *)&double result = vmulq_laneq_f32(a1, a2, 3).u64[0];
  return result;
}

double cikernel::_bloom(float32x4_t a1, float32x4_t a2, float a3)
{
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a3), vmaxnmq_f32(a1, a2), a3).u64[0];
  return result;
}

double cikernel::_gloom(float32x4_t a1, float32x4_t a2, float a3)
{
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a3), vminnmq_f32(a1, a2), a3).u64[0];
  return result;
}

double addPoints(void *a1, void *a2, double x, double y, double width, double height)
{
  for (uint64_t i = 0; i != 4; ++i)
  {
    [a1 valueAtIndex:i];
    double v14 = v13;
    [a2 valueAtIndex:i];
    double v16 = v15;
    if (fabs(v14 + 1.0) > 0.001 && fabs(v15 + 1.0) > 0.001)
    {
      v18.origin.CGFloat x = x;
      v18.origin.CGFloat y = y;
      v18.size.CGFloat width = width;
      v18.size.CGFloat height = height;
      if (CGRectIsNull(v18))
      {
        CGFloat x = v14 + -0.5;
        CGFloat y = v16 + -0.5;
        CGFloat width = 1.0;
        CGFloat height = 1.0;
      }
      else
      {
        v21.size.CGFloat width = 1.0;
        v21.size.CGFloat height = 1.0;
        v19.origin.CGFloat x = x;
        v19.origin.CGFloat y = y;
        v19.size.CGFloat width = width;
        v19.size.CGFloat height = height;
        v21.origin.CGFloat x = v14 + -0.5;
        v21.origin.CGFloat y = v16 + -0.5;
        CGRect v20 = CGRectUnion(v19, v21);
        CGFloat x = v20.origin.x;
        CGFloat y = v20.origin.y;
        CGFloat width = v20.size.width;
        CGFloat height = v20.size.height;
      }
    }
  }
  return x;
}

CIImage *boxBlurImage(CIImage *a1, unsigned int a2, int a3, int a4)
{
  v79[2] = *MEMORY[0x1E4F143B8];
  if ((int)a2 > 1)
  {
    switch(a2)
    {
      case 3u:
        uint64_t v10 = +[CIKernel kernelWithInternalRepresentation:&CI::_boxBlur3];
        [(CIImage *)a1 extent];
        CGRect v82 = CGRectInset(v81, (double)-a3, (double)-a4);
        CGFloat x = v82.origin.x;
        CGFloat y = v82.origin.y;
        CGFloat width = v82.size.width;
        CGFloat height = v82.size.height;
        v67[0] = MEMORY[0x1E4F143A8];
        v67[1] = 3221225472;
        void v67[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke;
        v67[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
        int v68 = a3;
        int v69 = a4;
        v79[0] = a1;
        v79[1] = +[CIVector vectorWithX:(double)a3 Y:(double)a4];
        uint64_t v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v79 count:2];
        double v16 = v67;
        goto LABEL_15;
      case 5u:
        uint64_t v10 = +[CIKernel kernelWithInternalRepresentation:&CI::_boxBlur5];
        [(CIImage *)a1 extent];
        CGRect v86 = CGRectInset(v85, (double)(-2 * a3), (double)(-2 * a4));
        CGFloat x = v86.origin.x;
        CGFloat y = v86.origin.y;
        CGFloat width = v86.size.width;
        CGFloat height = v86.size.height;
        v64[0] = MEMORY[0x1E4F143A8];
        v64[1] = 3221225472;
        void v64[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_2;
        v64[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
        int v65 = a3;
        int v66 = a4;
        v78[0] = a1;
        v78[1] = +[CIVector vectorWithX:(double)a3 Y:(double)a4];
        uint64_t v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v78 count:2];
        double v16 = v64;
        goto LABEL_15;
      case 7u:
        uint64_t v10 = +[CIKernel kernelWithInternalRepresentation:&CI::_boxBlur7];
        [(CIImage *)a1 extent];
        CGRect v88 = CGRectInset(v87, (double)(-3 * a3), (double)(-3 * a4));
        CGFloat x = v88.origin.x;
        CGFloat y = v88.origin.y;
        CGFloat width = v88.size.width;
        CGFloat height = v88.size.height;
        v61[0] = MEMORY[0x1E4F143A8];
        v61[1] = 3221225472;
        v61[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_3;
        v61[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
        int v62 = a3;
        int v63 = a4;
        v77[0] = a1;
        v77[1] = +[CIVector vectorWithX:(double)a3 Y:(double)a4];
        uint64_t v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v77 count:2];
        double v16 = v61;
        goto LABEL_15;
      case 9u:
        uint64_t v10 = +[CIKernel kernelWithInternalRepresentation:&CI::_boxBlur9];
        [(CIImage *)a1 extent];
        CGRect v90 = CGRectInset(v89, (double)(-4 * a3), (double)(-4 * a4));
        CGFloat x = v90.origin.x;
        CGFloat y = v90.origin.y;
        CGFloat width = v90.size.width;
        CGFloat height = v90.size.height;
        v58[0] = MEMORY[0x1E4F143A8];
        v58[1] = 3221225472;
        v58[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_4;
        v58[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
        int v59 = a3;
        int v60 = a4;
        v76[0] = a1;
        v76[1] = +[CIVector vectorWithX:(double)a3 Y:(double)a4];
        uint64_t v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v76 count:2];
        double v16 = v58;
        goto LABEL_15;
      case 0xBu:
        uint64_t v10 = +[CIKernel kernelWithInternalRepresentation:&CI::_boxBlur11];
        [(CIImage *)a1 extent];
        CGRect v92 = CGRectInset(v91, (double)(-5 * a3), (double)(-5 * a4));
        CGFloat x = v92.origin.x;
        CGFloat y = v92.origin.y;
        CGFloat width = v92.size.width;
        CGFloat height = v92.size.height;
        v55[0] = MEMORY[0x1E4F143A8];
        v55[1] = 3221225472;
        v55[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_5;
        v55[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
        int v56 = a3;
        int v57 = a4;
        v75[0] = a1;
        v75[1] = +[CIVector vectorWithX:(double)a3 Y:(double)a4];
        uint64_t v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v75 count:2];
        double v16 = v55;
        goto LABEL_15;
      case 0xDu:
        uint64_t v10 = +[CIKernel kernelWithInternalRepresentation:&CI::_boxBlur13];
        [(CIImage *)a1 extent];
        CGRect v94 = CGRectInset(v93, (double)(-6 * a3), (double)(-6 * a4));
        CGFloat x = v94.origin.x;
        CGFloat y = v94.origin.y;
        CGFloat width = v94.size.width;
        CGFloat height = v94.size.height;
        v52[0] = MEMORY[0x1E4F143A8];
        v52[1] = 3221225472;
        v52[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_6;
        v52[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
        int v53 = a3;
        int v54 = a4;
        v74[0] = a1;
        v74[1] = +[CIVector vectorWithX:(double)a3 Y:(double)a4];
        uint64_t v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v74 count:2];
        double v16 = v52;
LABEL_15:
        float32x4_t v27 = v10;
        double v28 = x;
        double v29 = y;
        double v30 = width;
        double v31 = height;
        break;
      default:
        if (a2 < 0x31 || (unsigned int v17 = a2 / 7, a2 % 7))
        {
          if (a2 < 0x19 || (unsigned int v32 = a2 / 5, a2 % 5))
          {
            unsigned int v37 = a2 / 3;
            if (a2 == 3 * (a2 / 3))
            {
              float32x4_t v44 = (void *)boxBlurImage(a1, a2 / 3, a3, a4);
              double v45 = (double)(int)(v37 * a3);
              double v46 = (double)(int)(v37 * a4);
              float32x4_t v47 = +[CIVector vectorWithX:v45 Y:v46];
              float32x4_t v22 = +[CIKernel kernelWithInternalRepresentation:&CI::_boxCombine3];
              [v44 extent];
              CGRect v100 = CGRectInset(v99, -v45, -v46);
              CGFloat v23 = v100.origin.x;
              CGFloat v24 = v100.origin.y;
              CGFloat v25 = v100.size.width;
              CGFloat v26 = v100.size.height;
              v49[0] = MEMORY[0x1E4F143A8];
              v49[1] = 3221225472;
              v49[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_9;
              _OWORD v49[3] = &__block_descriptor_48_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              *(double *)&v49[4] = v45;
              *(double *)&v49[5] = v46;
              v71[0] = v44;
              v71[1] = v47;
              uint64_t v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v71 count:2];
              double v16 = v49;
            }
            else
            {
              int v38 = (a2 >> 1) | 1;
              float32x4_t v39 = (void *)boxBlurImage(a1, v38, a3, a4);
              float v40 = floor((double)(int)a2 * 0.25 + 0.5);
              double v41 = (float)((float)a3 * v40);
              double v42 = (float)((float)a4 * v40);
              float32x4_t v43 = +[CIVector vectorWithX:v41 Y:v42 Z:(double)v38 / (double)(int)a2 W:(double)v38 / (double)(int)a2 * -2.0 + 1.0];
              float32x4_t v22 = +[CIKernel kernelWithInternalRepresentation:&CI::_boxCombine2];
              [v39 extent];
              CGRect v98 = CGRectInset(v97, -v41, -v42);
              CGFloat v23 = v98.origin.x;
              CGFloat v24 = v98.origin.y;
              CGFloat v25 = v98.size.width;
              CGFloat v26 = v98.size.height;
              v70[0] = a1;
              v70[1] = v39;
              v70[2] = v43;
              uint64_t v15 = objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v70, 3, MEMORY[0x1E4F143A8], 3221225472, ___ZL12boxBlurImageP7CIImageiii_block_invoke_10, &__block_descriptor_48_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l, *(void *)&v41, *(void *)&v42);
              double v16 = &v48;
            }
          }
          else
          {
            float32x4_t v33 = (void *)boxBlurImage(a1, a2 / 5, a3, a4);
            double v34 = (double)(int)(v32 * a3);
            double v35 = (double)(int)(v32 * a4);
            float v36 = +[CIVector vectorWithX:v34 Y:v35];
            float32x4_t v22 = +[CIKernel kernelWithInternalRepresentation:&CI::_boxCombine5];
            [v33 extent];
            CGRect v96 = CGRectInset(v95, v34 * -2.0, v35 * -2.0);
            CGFloat v23 = v96.origin.x;
            CGFloat v24 = v96.origin.y;
            CGFloat v25 = v96.size.width;
            CGFloat v26 = v96.size.height;
            v50[0] = MEMORY[0x1E4F143A8];
            v50[1] = 3221225472;
            void v50[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_8;
            v50[3] = &__block_descriptor_48_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
            *(double *)&v50[4] = v34;
            *(double *)&v50[5] = v35;
            v72[0] = v33;
            v72[1] = v36;
            uint64_t v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v72 count:2];
            double v16 = v50;
          }
        }
        else
        {
          CGRect v18 = (void *)boxBlurImage(a1, v17, a3, a4);
          double v19 = (double)(int)(v17 * a3);
          double v20 = (double)(int)(v17 * a4);
          CGRect v21 = +[CIVector vectorWithX:v19 Y:v20];
          float32x4_t v22 = +[CIKernel kernelWithInternalRepresentation:&CI::_boxCombine7];
          [v18 extent];
          CGRect v84 = CGRectInset(v83, v19 * -3.0, v20 * -3.0);
          CGFloat v23 = v84.origin.x;
          CGFloat v24 = v84.origin.y;
          CGFloat v25 = v84.size.width;
          CGFloat v26 = v84.size.height;
          v51[0] = MEMORY[0x1E4F143A8];
          v51[1] = 3221225472;
          v51[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_7;
          v51[3] = &__block_descriptor_48_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
          *(double *)&v51[4] = v19;
          *(double *)&v51[5] = v20;
          v73[0] = v18;
          v73[1] = v21;
          uint64_t v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v73 count:2];
          double v16 = v51;
        }
        float32x4_t v27 = v22;
        double v28 = v23;
        double v29 = v24;
        double v30 = v25;
        double v31 = v26;
        break;
    }
    return -[CIKernel applyWithExtent:roiCallback:arguments:](v27, "applyWithExtent:roiCallback:arguments:", v16, v15, v28, v29, v30, v31);
  }
  else
  {
    float32x4_t v5 = a1;
    return v5;
  }
}

double cikernel::_boxBlur3x3(cikernel *this, SamplerObj *a2)
{
  float32x2_t v3 = *(float32x2_t *)CI::getDC(this);
  __asm { FMOV            V0.2S, #1.0 }
  float32x2_t v9 = vadd_f32(v3, _D0);
  *(float *)&double v10 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v9, 1), *((float *)this + 4), v9.f32[0]);
  LODWORD(v11) = *((_DWORD *)this + 7);
  v12.i32[0] = *((_DWORD *)this + 9);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v9, 1), *(float *)&v11, v9.f32[0]);
  v9.f32[0] = *((float *)this + 6) + *(float *)&v10;
  *(float *)v14.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  v9.f32[1] = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v9, v14, v10, v11, v13, v12, v15);
  float32x4_t v44 = v16;
  *(float32x2_t *)v16.f32 = vadd_f32(v3, (float32x2_t)0xBF0000003F800000);
  *(float *)&double v17 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v16.f32, 1), *((float *)this + 4), v16.f32[0]);
  LODWORD(v18) = *((_DWORD *)this + 7);
  v19.i32[0] = *((_DWORD *)this + 9);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v16.f32, 1), *(float *)&v18, v16.f32[0]);
  v16.f32[0] = *((float *)this + 6) + *(float *)&v17;
  *(float *)v21.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v16.i64, v21, v17, v18, v20, v19, v22);
  float32x2_t v24 = vadd_f32(v3, (float32x2_t)0x3F800000BF000000);
  *(float *)&double v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v24, 1), *((float *)this + 4), v24.f32[0]);
  LODWORD(v26) = *((_DWORD *)this + 6);
  v27.i32[0] = *((_DWORD *)this + 7);
  v28.i32[0] = *((_DWORD *)this + 9);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v24, 1), *(float *)v27.i32, v24.f32[0]);
  float64x2_t v30 = (float64x2_t)v44;
  float32x4_t v45 = vaddq_f32(v44, vaddq_f32(v23, v23));
  v23.f32[0] = *(float *)&v26 + *(float *)&v25;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v23.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v23.i64, v30, v26, v25, v27, v29, v28);
  float32x2_t v32 = vadd_f32(v3, (float32x2_t)0xBF000000BF000000);
  *(float *)&double v33 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v32, 1), *((float *)this + 4), v32.f32[0]);
  LODWORD(v34) = *((_DWORD *)this + 6);
  v35.i32[0] = *((_DWORD *)this + 7);
  v36.i32[0] = *((_DWORD *)this + 9);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v32, 1), *(float *)v35.i32, v32.f32[0]);
  float64x2_t v38 = (float64x2_t)v45;
  float32x4_t v46 = vaddq_f32(v45, vaddq_f32(v31, v31));
  v31.f32[0] = *(float *)&v34 + *(float *)&v33;
  *(float *)v38.f64 = *(float *)v36.i32 + *(float *)v37.i32;
  v31.f32[1] = *(float *)v36.i32 + *(float *)v37.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v31.i64, v38, v34, v33, v35, v37, v36);
  __asm { FMOV            V1.4S, #4.0 }
  float32x4_t v41 = vaddq_f32(v46, vmulq_f32(v39, _Q1));
  __asm { FMOV            V1.4S, #9.0 }
  *(void *)&double result = vdivq_f32(v41, _Q1).u64[0];
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)-*(_DWORD *)(a1 + 32), (double)-*(_DWORD *)(a1 + 36));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_2(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)(-2 * *(_DWORD *)(a1 + 32)), (double)(-2 * *(_DWORD *)(a1 + 36)));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_3(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)(-3 * *(_DWORD *)(a1 + 32)), (double)(-3 * *(_DWORD *)(a1 + 36)));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_4(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)(-4 * *(_DWORD *)(a1 + 32)), (double)(-4 * *(_DWORD *)(a1 + 36)));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_5(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)(-5 * *(_DWORD *)(a1 + 32)), (double)(-5 * *(_DWORD *)(a1 + 36)));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_6(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)(-6 * *(_DWORD *)(a1 + 32)), (double)(-6 * *(_DWORD *)(a1 + 36)));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_7(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, *(double *)(a1 + 32) * -3.0, *(double *)(a1 + 40) * -3.0);
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_8(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, *(double *)(a1 + 32) * -2.0, *(double *)(a1 + 40) * -2.0);
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_9(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, -*(double *)(a1 + 32), -*(double *)(a1 + 40));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_10(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2) {
    *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&result, -*(double *)(a1 + 32), -*(double *)(a1 + 40));
  }
  return result;
}

double cikernel::_boxBlur3(uint64_t a1, float32x2_t a2)
{
  float32x2_t v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v5 = vsub_f32(v4, a2);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v10, v6, v7, v9, v8, v11);
  float32x4_t v26 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(vmul_f32(a2, (float32x2_t)0x3F0000003F000000), v4);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  __asm { FMOV            V1.4S, #3.0 }
  *(void *)&double result = vdivq_f32(vaddq_f32(v26, vaddq_f32(v19, v19)), _Q1).u64[0];
  return result;
}

void CI::f4_sr_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  float32x4_t v12 = *(double (**)(uint64_t, double))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  int v14 = *(_DWORD *)(v11 + 40);
  uint64_t v15 = *(void *)(v11 + 32);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 56)), a2);
  }
  int8x16_t v16 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    int8x16_t v16 = (double *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v17 = v12(a4 + 80 * v13, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

double cikernel::_boxBlur5(uint64_t a1, float32x2_t a2)
{
  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  int8x16_t v35 = (int8x16_t)v4;
  __asm { FMOV            V0.2S, #1.5 }
  float32x2_t v10 = vmul_f32(a2, _D0);
  float32x2_t v11 = vsub_f32(*(float32x2_t *)&v4.f64[0], v10);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v4, v12, v13, v15, v14, v16);
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x3ECCCCCDu);
  LODWORD(v19) = *(_DWORD *)(a1 + 28);
  *(float *)v20.f64 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v35.i8, 1), *(float *)(a1 + 16), *(float *)v35.i32);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v35.i8, 1), *(float *)&v19, *(float *)v35.i32);
  float32x4_t v33 = vmulq_f32(v17, v18);
  float32x4_t v34 = v18;
  *((float *)v20.f64 + 1) = *(float *)v21.i32 + *(float *)&v22;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v20.f64[0], v20, v22, v19, v21, v35, (int8x16_t)v18);
  float32x2_t v24 = vadd_f32(v10, *(float32x2_t *)v35.i8);
  *(float *)&double v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v24, 1), *(float *)(a1 + 16), v24.f32[0]);
  LODWORD(v26) = *(_DWORD *)(a1 + 24);
  v27.i32[0] = *(_DWORD *)(a1 + 28);
  v28.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v24, 1), *(float *)v27.i32, v24.f32[0]);
  float64x2_t v30 = (float64x2_t)v33;
  float32x4_t v36 = vaddq_f32(v33, vmulq_f32(v23, (float32x4_t)vdupq_n_s32(0x3E4CCCCDu)));
  v23.f32[0] = *(float *)&v26 + *(float *)&v25;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v23.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v30, v26, v25, v27, v29, v28);
  *(void *)&double result = vaddq_f32(v36, vmulq_f32(v31, v34)).u64[0];
  return result;
}

double cikernel::_boxBlur7(uint64_t a1, float32x2_t a2)
{
  float32x2_t v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  __asm { FMOV            V0.2S, #2.5 }
  float32x2_t v10 = vmul_f32(a2, _D0);
  float32x2_t v11 = vsub_f32(v4, v10);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v16, v12, v13, v15, v14, v17);
  float32x4_t v46 = v18;
  *(float32x2_t *)v18.f32 = vsub_f32(v4, a2);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v18.f32, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v18.f32, 1), *(float *)&v20, v18.f32[0]);
  v18.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v18.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v23, v19, v20, v22, v21, v24);
  float32x2_t v26 = vadd_f32(vmul_f32(a2, (float32x2_t)0x3F0000003F000000), v4);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v26, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 24);
  v29.i32[0] = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v26, 1), *(float *)v29.i32, v26.f32[0]);
  v32.i64[0] = 0x3F0000003F000000;
  v32.i64[1] = 0x3F0000003F000000;
  float32x4_t v33 = vmulq_f32(v25, v32);
  float64x2_t v34 = (float64x2_t)v46;
  float32x4_t v47 = vaddq_f32(v46, v33);
  v33.f32[0] = *(float *)&v28 + *(float *)&v27;
  *(float *)v34.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v33.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v34, v28, v27, v29, v31, v30);
  float32x2_t v36 = vadd_f32(v10, v4);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v36, 1), *(float *)(a1 + 16), v36.f32[0]);
  LODWORD(v38) = *(_DWORD *)(a1 + 24);
  v39.i32[0] = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v36, 1), *(float *)v39.i32, v36.f32[0]);
  float64x2_t v42 = (float64x2_t)v47;
  float32x4_t v48 = vaddq_f32(v47, v35);
  v35.f32[0] = *(float *)&v38 + *(float *)&v37;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v35.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v42, v38, v37, v39, v41, v40);
  __asm { FMOV            V1.4S, #3.5 }
  *(void *)&double result = vdivq_f32(vaddq_f32(v48, v43), _Q1).u64[0];
  return result;
}

double cikernel::_boxBlur9(uint64_t a1, float32x2_t a2)
{
  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  int8x16_t v55 = (int8x16_t)v4;
  __asm { FMOV            V0.2S, #3.5 }
  float32x2_t v10 = vmul_f32(a2, _D0);
  float32x2_t v11 = vsub_f32(*(float32x2_t *)&v4.f64[0], v10);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v4, v12, v13, v15, v14, v16);
  float32x4_t v52 = _Q0;
  __asm { FMOV            V0.2S, #1.5 }
  float32x2_t v18 = vmul_f32(a2, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)_Q0.f32 = vsub_f32(*(float32x2_t *)v55.i8, v18);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v20, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  _Q0.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v23, v19, v20, v22, v21, v24);
  float64x2_t v26 = (float64x2_t)v52;
  float32x4_t v53 = vaddq_f32(v52, v25);
  LODWORD(v27) = *(_DWORD *)(a1 + 28);
  v25.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v55.i8, 1), *(float *)(a1 + 16), *(float *)v55.i32);
  LODWORD(v28) = *(_DWORD *)(a1 + 36);
  *(float *)v26.f64 = *(float *)&v28
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v55.i8, 1), *(float *)&v27, *(float *)v55.i32);
  v25.i32[1] = LODWORD(v26.f64[0]);
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v26, v27, v28, v55, v29, v30);
  float32x2_t v32 = vadd_f32(v18, *(float32x2_t *)v55.i8);
  *(float *)&double v33 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v32, 1), *(float *)(a1 + 16), v32.f32[0]);
  LODWORD(v34) = *(_DWORD *)(a1 + 24);
  v35.i32[0] = *(_DWORD *)(a1 + 28);
  v36.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v32, 1), *(float *)v35.i32, v32.f32[0]);
  v38.i64[0] = 0x3F0000003F000000;
  v38.i64[1] = 0x3F0000003F000000;
  float32x4_t v39 = vmulq_f32(v31, v38);
  float64x2_t v40 = (float64x2_t)v53;
  float32x4_t v54 = vaddq_f32(v53, v39);
  v39.f32[0] = *(float *)&v34 + *(float *)&v33;
  *(float *)v40.f64 = *(float *)v36.i32 + *(float *)v37.i32;
  v39.f32[1] = *(float *)v36.i32 + *(float *)v37.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v39.i64, v40, v34, v33, v35, v37, v36);
  float32x2_t v42 = vadd_f32(v10, *(float32x2_t *)v55.i8);
  *(float *)&double v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v42, 1), *(float *)(a1 + 16), v42.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a1 + 24);
  v45.i32[0] = *(_DWORD *)(a1 + 28);
  v46.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v42, 1), *(float *)v45.i32, v42.f32[0]);
  float64x2_t v48 = (float64x2_t)v54;
  float32x4_t v56 = vaddq_f32(v54, v41);
  v41.f32[0] = *(float *)&v44 + *(float *)&v43;
  *(float *)v48.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  v41.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, v48, v44, v43, v45, v47, v46);
  __asm { FMOV            V1.4S, #4.5 }
  *(void *)&double result = vdivq_f32(vaddq_f32(v56, v49), _Q1).u64[0];
  return result;
}

double cikernel::_boxBlur11(uint64_t a1, float32x2_t a2)
{
  float32x2_t v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  __asm { FMOV            V0.2S, #4.5 }
  float32x2_t v10 = vmul_f32(a2, _D0);
  float32x2_t v11 = vsub_f32(v4, v10);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v16, v12, v13, v15, v14, v17);
  float32x4_t v63 = _Q0;
  __asm { FMOV            V0.2S, #2.5 }
  float32x2_t v19 = vmul_f32(a2, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)_Q0.f32 = vsub_f32(v4, v19);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v21, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  _Q0.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v24, v20, v21, v23, v22, v25);
  float32x2_t v27 = vsub_f32(v4, a2);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v27, 1), *(float *)(a1 + 16), v27.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 24);
  v30.i32[0] = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v27, 1), *(float *)v30.i32, v27.f32[0]);
  float64x2_t v33 = (float64x2_t)v63;
  float32x4_t v64 = vaddq_f32(v63, v26);
  v26.f32[0] = *(float *)&v29 + *(float *)&v28;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v26.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v33, v29, v28, v30, v32, v31);
  float32x2_t v35 = vadd_f32(vmul_f32(a2, (float32x2_t)0x3F0000003F000000), v4);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v35, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 24);
  v38.i32[0] = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v35, 1), *(float *)v38.i32, v35.f32[0]);
  v41.i64[0] = 0x3F0000003F000000;
  v41.i64[1] = 0x3F0000003F000000;
  float32x4_t v42 = vmulq_f32(v34, v41);
  float64x2_t v43 = (float64x2_t)v64;
  float32x4_t v65 = vaddq_f32(v64, v42);
  v42.f32[0] = *(float *)&v37 + *(float *)&v36;
  *(float *)v43.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v42.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v43, v37, v36, v38, v40, v39);
  float32x2_t v45 = vadd_f32(v19, v4);
  *(float *)&double v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v45, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v47) = *(_DWORD *)(a1 + 24);
  v48.i32[0] = *(_DWORD *)(a1 + 28);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v45, 1), *(float *)v48.i32, v45.f32[0]);
  float64x2_t v51 = (float64x2_t)v65;
  float32x4_t v66 = vaddq_f32(v65, v44);
  v44.f32[0] = *(float *)&v47 + *(float *)&v46;
  *(float *)v51.f64 = *(float *)v49.i32 + *(float *)v50.i32;
  v44.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v44.i64, v51, v47, v46, v48, v50, v49);
  float32x2_t v53 = vadd_f32(v10, v4);
  *(float *)&double v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v53, 1), *(float *)(a1 + 16), v53.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a1 + 24);
  v56.i32[0] = *(_DWORD *)(a1 + 28);
  v57.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v58.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v53, 1), *(float *)v56.i32, v53.f32[0]);
  float64x2_t v59 = (float64x2_t)v66;
  float32x4_t v67 = vaddq_f32(v66, v52);
  v52.f32[0] = *(float *)&v55 + *(float *)&v54;
  *(float *)v59.f64 = *(float *)v57.i32 + *(float *)v58.i32;
  v52.f32[1] = *(float *)v57.i32 + *(float *)v58.i32;
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v59, v55, v54, v56, v58, v57);
  __asm { FMOV            V1.4S, #5.5 }
  *(void *)&double result = vdivq_f32(vaddq_f32(v67, v60), _Q1).u64[0];
  return result;
}

double cikernel::_boxBlur13(uint64_t a1, float32x2_t a2)
{
  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  int8x16_t v75 = (int8x16_t)v4;
  __asm { FMOV            V0.2S, #5.5 }
  float32x2_t v10 = vmul_f32(a2, _D0);
  float32x2_t v11 = vsub_f32(*(float32x2_t *)&v4.f64[0], v10);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v4, v12, v13, v15, v14, v16);
  float32x4_t v70 = _Q0;
  __asm { FMOV            V0.2S, #3.5 }
  float32x2_t v18 = vmul_f32(a2, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)_Q0.f32 = vsub_f32(*(float32x2_t *)v75.i8, v18);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v20, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  _Q0.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v23, v19, v20, v22, v21, v24);
  __asm { FMOV            V1.2S, #1.5 }
  float32x2_t v27 = vmul_f32(a2, _D1);
  float32x2_t v28 = vsub_f32(*(float32x2_t *)v75.i8, v27);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v31.i32, v28.f32[0]);
  float64x2_t v34 = (float64x2_t)v70;
  float32x4_t v71 = vaddq_f32(v70, v25);
  v25.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v25.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v34, v30, v29, v31, v33, v32);
  float64x2_t v36 = (float64x2_t)v71;
  float32x4_t v72 = vaddq_f32(v71, v35);
  LODWORD(v37) = *(_DWORD *)(a1 + 28);
  v35.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v75.i8, 1), *(float *)(a1 + 16), *(float *)v75.i32);
  LODWORD(v38) = *(_DWORD *)(a1 + 36);
  *(float *)v36.f64 = *(float *)&v38
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v75.i8, 1), *(float *)&v37, *(float *)v75.i32);
  v35.i32[1] = LODWORD(v36.f64[0]);
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v36, v37, v38, v75, v39, v40);
  float32x2_t v42 = vadd_f32(v27, *(float32x2_t *)v75.i8);
  *(float *)&double v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v42, 1), *(float *)(a1 + 16), v42.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a1 + 24);
  v45.i32[0] = *(_DWORD *)(a1 + 28);
  v46.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v42, 1), *(float *)v45.i32, v42.f32[0]);
  v48.i64[0] = 0x3F0000003F000000;
  v48.i64[1] = 0x3F0000003F000000;
  float32x4_t v49 = vmulq_f32(v41, v48);
  float64x2_t v50 = (float64x2_t)v72;
  float32x4_t v73 = vaddq_f32(v72, v49);
  v49.f32[0] = *(float *)&v44 + *(float *)&v43;
  *(float *)v50.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  v49.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v49.i64, v50, v44, v43, v45, v47, v46);
  float32x2_t v52 = vadd_f32(v18, *(float32x2_t *)v75.i8);
  *(float *)&double v53 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v52, 1), *(float *)(a1 + 16), v52.f32[0]);
  LODWORD(v54) = *(_DWORD *)(a1 + 24);
  v55.i32[0] = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v52, 1), *(float *)v55.i32, v52.f32[0]);
  float64x2_t v58 = (float64x2_t)v73;
  float32x4_t v74 = vaddq_f32(v73, v51);
  v51.f32[0] = *(float *)&v54 + *(float *)&v53;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v51.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v51.i64, v58, v54, v53, v55, v57, v56);
  float32x2_t v60 = vadd_f32(v10, *(float32x2_t *)v75.i8);
  *(float *)&double v61 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v60, 1), *(float *)(a1 + 16), v60.f32[0]);
  LODWORD(v62) = *(_DWORD *)(a1 + 24);
  v63.i32[0] = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v60, 1), *(float *)v63.i32, v60.f32[0]);
  float64x2_t v66 = (float64x2_t)v74;
  float32x4_t v76 = vaddq_f32(v74, v59);
  v59.f32[0] = *(float *)&v62 + *(float *)&v61;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v59.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v59.i64, v66, v62, v61, v63, v65, v64);
  __asm { FMOV            V1.4S, #6.5 }
  *(void *)&double result = vdivq_f32(vaddq_f32(v76, v67), _Q1).u64[0];
  return result;
}

double cikernel::_boxCombine7(uint64_t a1, float32x2_t a2)
{
  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  int8x16_t v71 = (int8x16_t)v4;
  __asm { FMOV            V0.2S, #3.0 }
  float32x2_t v10 = vmul_f32(a2, _D0);
  float32x2_t v11 = vsub_f32(*(float32x2_t *)&v4.f64[0], v10);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v4, v12, v13, v15, v14, v16);
  float32x4_t v66 = v17;
  float32x2_t v18 = vadd_f32(a2, a2);
  *(float32x2_t *)v17.f32 = vsub_f32(*(float32x2_t *)v71.i8, v18);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v17.f32, 1), *(float *)(a1 + 16), v17.f32[0]);
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v17.f32, 1), *(float *)&v20, v17.f32[0]);
  v17.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v17.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, v23, v19, v20, v22, v21, v24);
  float32x2_t v26 = vsub_f32(*(float32x2_t *)v71.i8, a2);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v26, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 24);
  v29.i32[0] = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v26, 1), *(float *)v29.i32, v26.f32[0]);
  float64x2_t v32 = (float64x2_t)v66;
  float32x4_t v67 = vaddq_f32(v66, v25);
  v25.f32[0] = *(float *)&v28 + *(float *)&v27;
  *(float *)v32.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v25.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v32, v28, v27, v29, v31, v30);
  float64x2_t v34 = (float64x2_t)v67;
  float32x4_t v68 = vaddq_f32(v67, v33);
  LODWORD(v35) = *(_DWORD *)(a1 + 28);
  v33.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v71.i8, 1), *(float *)(a1 + 16), *(float *)v71.i32);
  LODWORD(v36) = *(_DWORD *)(a1 + 36);
  *(float *)v34.f64 = *(float *)&v36
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v71.i8, 1), *(float *)&v35, *(float *)v71.i32);
  v33.i32[1] = LODWORD(v34.f64[0]);
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v34, v35, v36, v71, v37, v38);
  float32x2_t v40 = vadd_f32(a2, *(float32x2_t *)v71.i8);
  *(float *)&double v41 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v40, 1), *(float *)(a1 + 16), v40.f32[0]);
  LODWORD(v42) = *(_DWORD *)(a1 + 24);
  v43.i32[0] = *(_DWORD *)(a1 + 28);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v40, 1), *(float *)v43.i32, v40.f32[0]);
  float64x2_t v46 = (float64x2_t)v68;
  float32x4_t v69 = vaddq_f32(v68, v39);
  v39.f32[0] = *(float *)&v42 + *(float *)&v41;
  *(float *)v46.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  v39.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v39.i64, v46, v42, v41, v43, v45, v44);
  float32x2_t v48 = vadd_f32(v18, *(float32x2_t *)v71.i8);
  *(float *)&double v49 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v48, 1), *(float *)(a1 + 16), v48.f32[0]);
  LODWORD(v5CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v51.i32[0] = *(_DWORD *)(a1 + 28);
  v52.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v48, 1), *(float *)v51.i32, v48.f32[0]);
  float64x2_t v54 = (float64x2_t)v69;
  float32x4_t v70 = vaddq_f32(v69, v47);
  v47.f32[0] = *(float *)&v50 + *(float *)&v49;
  *(float *)v54.f64 = *(float *)v52.i32 + *(float *)v53.i32;
  v47.f32[1] = *(float *)v52.i32 + *(float *)v53.i32;
  *(double *)v55.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v47.i64, v54, v50, v49, v51, v53, v52);
  float32x2_t v56 = vadd_f32(v10, *(float32x2_t *)v71.i8);
  *(float *)&double v57 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v56, 1), *(float *)(a1 + 16), v56.f32[0]);
  LODWORD(v58) = *(_DWORD *)(a1 + 24);
  v59.i32[0] = *(_DWORD *)(a1 + 28);
  v60.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v61.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v56, 1), *(float *)v59.i32, v56.f32[0]);
  float64x2_t v62 = (float64x2_t)v70;
  float32x4_t v72 = vaddq_f32(v70, v55);
  v55.f32[0] = *(float *)&v58 + *(float *)&v57;
  *(float *)v62.f64 = *(float *)v60.i32 + *(float *)v61.i32;
  v55.f32[1] = *(float *)v60.i32 + *(float *)v61.i32;
  *(double *)v63.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v55.i64, v62, v58, v57, v59, v61, v60);
  __asm { FMOV            V1.4S, #7.0 }
  *(void *)&double result = vdivq_f32(vaddq_f32(v72, v63), _Q1).u64[0];
  return result;
}

double cikernel::_boxCombine5(uint64_t a1, float32x2_t a2)
{
  v4.i64[0] = *(void *)CI::getDC((CI *)a1);
  int8x16_t v46 = v4;
  float32x2_t v5 = vadd_f32(a2, a2);
  *(float32x2_t *)v4.i8 = vsub_f32(*(float32x2_t *)v4.i8, v5);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v4.i8, 1), *(float *)(a1 + 16), *(float *)v4.i32);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v4.i8, 1), *(float *)&v7, *(float *)v4.i32);
  *(float *)v4.i32 = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *(float *)&v4.i32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v4.i64, v10, v6, v7, v9, v8, v11);
  float32x4_t v43 = v12;
  *(float32x2_t *)v12.f32 = vsub_f32(*(float32x2_t *)v46.i8, a2);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float64x2_t v20 = (float64x2_t)v43;
  float32x4_t v44 = vaddq_f32(v43, v19);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v19.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v46.i8, 1), *(float *)(a1 + 16), *(float *)v46.i32);
  LODWORD(v22) = *(_DWORD *)(a1 + 36);
  *(float *)v20.f64 = *(float *)&v22
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v46.i8, 1), *(float *)&v21, *(float *)v46.i32);
  v19.i32[1] = LODWORD(v20.f64[0]);
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v20, v21, v22, v46, v23, v24);
  float32x2_t v26 = vadd_f32(a2, *(float32x2_t *)v46.i8);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v26, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 24);
  v29.i32[0] = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v26, 1), *(float *)v29.i32, v26.f32[0]);
  float64x2_t v32 = (float64x2_t)v44;
  float32x4_t v45 = vaddq_f32(v44, v25);
  v25.f32[0] = *(float *)&v28 + *(float *)&v27;
  *(float *)v32.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v25.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v32, v28, v27, v29, v31, v30);
  float32x2_t v34 = vadd_f32(v5, *(float32x2_t *)v46.i8);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v34, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 24);
  v37.i32[0] = *(_DWORD *)(a1 + 28);
  v38.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v34, 1), *(float *)v37.i32, v34.f32[0]);
  float64x2_t v40 = (float64x2_t)v45;
  float32x4_t v47 = vaddq_f32(v45, v33);
  v33.f32[0] = *(float *)&v36 + *(float *)&v35;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v33.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v40, v36, v35, v37, v39, v38);
  *(void *)&double result = vmulq_f32(vaddq_f32(v47, v41), (float32x4_t)vdupq_n_s32(0x3E4CCCCDu)).u64[0];
  return result;
}

double cikernel::_boxCombine3(uint64_t a1, float32x2_t a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v5.i8 = *DC;
  float32x2_t v35 = *DC;
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  *(float *)&double v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v8) = *(_DWORD *)(a1 + 36);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v6, COERCE_FLOAT(*DC));
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v9, v6, v8, v5, v10, v11);
  float32x4_t v34 = v12;
  *(float32x2_t *)v12.f32 = vsub_f32(v35, a2);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x2_t v20 = vadd_f32(a2, v35);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 24);
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v34;
  float32x4_t v36 = vaddq_f32(v34, v19);
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  __asm { FMOV            V1.4S, #3.0 }
  *(void *)&double result = vdivq_f32(vaddq_f32(v36, v27), _Q1).u64[0];
  return result;
}

double cikernel::_boxCombine2(uint64_t a1, uint64_t a2, float32x4_t a3)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v6.i8 = *DC;
  int8x16_t v31 = v6;
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  *(float *)&double v8 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v9) = *(_DWORD *)(a1 + 36);
  *(float *)v10.f64 = *(float *)&v9
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v7, COERCE_FLOAT(*DC));
  HIDWORD(v8) = LODWORD(v10.f64[0]);
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v8, v10, v7, v9, v6, v11, v12);
  *(void *)&v14.f64[1] = v31.i64[1];
  *(float32x2_t *)&v14.f64[0] = vsub_f32(*(float32x2_t *)v31.i8, *(float32x2_t *)a3.f32);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)&v14.f64[0], 1), *(float *)(a2 + 16), *(float *)v14.f64);
  LODWORD(v16) = *(_DWORD *)(a2 + 24);
  v17.i32[0] = *(_DWORD *)(a2 + 28);
  v18.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)&v14.f64[0], 1), *(float *)v17.i32, *(float *)v14.f64);
  float32x4_t v30 = vmulq_laneq_f32(v13, a3, 3);
  v13.f32[0] = *(float *)&v16 + *(float *)&v15;
  *(float *)v14.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v13.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v13.i64, v14, v16, v15, v17, v19, v18);
  float32x2_t v21 = vadd_f32(*(float32x2_t *)a3.f32, *(float32x2_t *)v31.i8);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v21, 1), *(float *)(a2 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a2 + 24);
  v24.i32[0] = *(_DWORD *)(a2 + 28);
  v25.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v21, 1), *(float *)v24.i32, v21.f32[0]);
  float64x2_t v27 = (float64x2_t)v30;
  float32x4_t v32 = vaddq_f32(v30, vmulq_laneq_f32(v20, a3, 2));
  v20.f32[0] = *(float *)&v23 + *(float *)&v22;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v20.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v20.i64, v27, v23, v22, v24, v26, v25);
  *(void *)&double result = vaddq_f32(v32, vmulq_laneq_f32(v28, a3, 2)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  int8x16_t v12 = *(double (**)(uint64_t, uint64_t, __n128))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  uint64_t v14 = *(void *)(v11 + 32);
  int v15 = *(_DWORD *)(v11 + 64);
  uint64_t v16 = *(void *)(v11 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 80)), a2);
  }
  int8x16_t v17 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    int8x16_t v17 = (__n128 *)((char *)a2 + 64 * v16);
  }
  *(double *)&long long v18 = v12(a4 + 80 * v13, a4 + 80 * v14, *v17);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

float32x2_t cikernel::_bumpDistortion(CI *a1, int8x16_t a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC(a1);
  float32x2_t v11 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  float32x2_t v3 = vsub_f32(v11, *DC);
  float v4 = 1.0;
  float v5 = 1.0 - (float)(sqrtf(vaddv_f32(vmul_f32(v3, v3))) * *(float *)a2.i32);
  if (v5 <= 1.0) {
    float v4 = v5;
  }
  BOOL v6 = v5 < 0.0;
  float v7 = 0.0;
  if (!v6) {
    float v7 = v4;
  }
  float v8 = (v7 * -2.0 + 3.0) * v7 * v7 * *(float *)&a2.i32[1] + 1.0;
  return vadd_f32(v11, vmul_n_f32(vsub_f32(*(float32x2_t *)CI::getDC((CI *)DC), v11), v8));
}

void CI::f2_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x2_t v11 = (double (*)(void *, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 32)), a2);
  }
  uint64_t v14 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v14 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v14);
}

float32x2_t cikernel::_bumpDistortionLinear(CI *a1, float32x4_t a2, __n128 a3)
{
  uint64_t DC = (CI *)CI::getDC(a1);
  v4.i64[0] = *(void *)DC;
  v4.i64[1] = 1065353216;
  int8x16_t v5 = (int8x16_t)vmulq_f32(a2, v4);
  float v6 = vaddv_f32(vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL)));
  float v7 = 1.0;
  float v8 = 1.0 - fabsf(v6);
  if (v8 <= 1.0) {
    float v7 = v8;
  }
  BOOL v9 = v8 < 0.0;
  float v10 = 0.0;
  if (!v9) {
    float v10 = v7;
  }
  float v11 = (v10 * -2.0 + 3.0) * v10 * v10 * a3.n128_f32[2] + 1.0;
  int v12 = (float32x2_t *)CI::getDC(DC);
  float v13 = (v11 + -1.0) * v6;
  return vadd_f32(*v12, vmul_n_f32((float32x2_t)a3.n128_u64[0], v13));
}

void CI::f2_f4_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float v11 = (double (*)(void *, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  uint64_t v16 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    uint64_t v16 = (__n128 *)((char *)a2 + 64 * v15);
  }
  int8x16_t v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    int8x16_t v17 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v17, *v16);
}

void sub_1936FAF20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1936FD5B4(_Unwind_Exception *a1)
{
}

uint64_t getFCRFaceExpressionLeftEyeClosed()
{
  uint64_t v3 = 0;
  float32x4_t v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getFCRFaceExpressionLeftEyeClosedSymbolLoc_ptr;
  uint64_t v6 = getFCRFaceExpressionLeftEyeClosedSymbolLoc_ptr;
  if (!getFCRFaceExpressionLeftEyeClosedSymbolLoc_ptr)
  {
    uint64_t v1 = (void *)FaceCoreLibrary();
    v4[3] = (uint64_t)dlsym(v1, "FCRFaceExpressionLeftEyeClosed");
    getFCRFaceExpressionLeftEyeClosedSymbolLoc_ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    getFCRFaceExpressionLeftEyeClosed_cold_1();
  }
  return *(void *)v0;
}

void sub_1936FD6EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getFCRFaceExpressionRightEyeClosed()
{
  uint64_t v3 = 0;
  float32x4_t v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getFCRFaceExpressionRightEyeClosedSymbolLoc_ptr;
  uint64_t v6 = getFCRFaceExpressionRightEyeClosedSymbolLoc_ptr;
  if (!getFCRFaceExpressionRightEyeClosedSymbolLoc_ptr)
  {
    uint64_t v1 = (void *)FaceCoreLibrary();
    v4[3] = (uint64_t)dlsym(v1, "FCRFaceExpressionRightEyeClosed");
    getFCRFaceExpressionRightEyeClosedSymbolLoc_ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    getFCRFaceExpressionRightEyeClosed_cold_1();
  }
  return *(void *)v0;
}

void sub_1936FD7E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getFCRFaceExpressionSmile()
{
  uint64_t v3 = 0;
  float32x4_t v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getFCRFaceExpressionSmileSymbolLoc_ptr;
  uint64_t v6 = getFCRFaceExpressionSmileSymbolLoc_ptr;
  if (!getFCRFaceExpressionSmileSymbolLoc_ptr)
  {
    uint64_t v1 = (void *)FaceCoreLibrary();
    v4[3] = (uint64_t)dlsym(v1, "FCRFaceExpressionSmile");
    getFCRFaceExpressionSmileSymbolLoc_ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    getFCRFaceExpressionSmile_cold_1();
  }
  return *(void *)v0;
}

void sub_1936FD8DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t FaceCoreLibraryCore()
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 0;
  uint64_t v3 = &v2;
  uint64_t v4 = 0x2020000000;
  uint64_t v0 = FaceCoreLibraryCore_frameworkLibrary;
  uint64_t v5 = FaceCoreLibraryCore_frameworkLibrary;
  if (!FaceCoreLibraryCore_frameworkLibrary)
  {
    long long v6 = xmmword_1E5771078;
    _OWORD v3[3] = _sl_dlopen();
    FaceCoreLibraryCore_frameworkLibrarCGFloat y = v3[3];
    uint64_t v0 = v3[3];
  }
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_193700864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __FaceCoreLibraryCore_block_invoke(uint64_t a1)
{
  uint64_t result = _sl_dlopen();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  FaceCoreLibraryCore_frameworkLibrarCGFloat y = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRFastFaceDetectionParametersSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  uint64_t result = dlsym(v2, "FCRFastFaceDetectionParameters");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRFastFaceDetectionParametersSymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t FaceCoreLibrary()
{
  uint64_t v1 = 0;
  uint64_t result = FaceCoreLibraryCore();
  if (!result) {
    FaceCoreLibrary_cold_1(&v1);
  }
  return result;
}

void *__getFCRSetupParamNumberOfAnglesSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  uint64_t result = dlsym(v2, "FCRSetupParamNumberOfAngles");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRSetupParamNumberOfAnglesSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

Class __getFaceCoreDetectorClass_block_invoke(uint64_t a1)
{
  FaceCoreLibrary();
  Class result = objc_getClass("FaceCoreDetector");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getFaceCoreDetectorClass_block_invoke_cold_1();
  }
  getFaceCoreDetectorClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getFaceCoreImageClass_block_invoke(uint64_t a1)
{
  FaceCoreLibrary();
  Class result = objc_getClass("FaceCoreImage");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getFaceCoreImageClass_block_invoke_cold_1();
  }
  getFaceCoreImageClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getFaceCoreFaceClass_block_invoke(uint64_t a1)
{
  FaceCoreLibrary();
  Class result = objc_getClass("FaceCoreFace");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getFaceCoreFaceClass_block_invoke_cold_1();
  }
  getFaceCoreFaceClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

void *__getFCRFaceExpressionLeftEyeClosedSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRFaceExpressionLeftEyeClosed");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRFaceExpressionLeftEyeClosedSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRFaceExpressionRightEyeClosedSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRFaceExpressionRightEyeClosed");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRFaceExpressionRightEyeClosedSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRFaceExpressionSmileSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRFaceExpressionSmile");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRFaceExpressionSmileSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRDetectionParamDetectionRegionSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRDetectionParamDetectionRegion");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRDetectionParamDetectionRegionSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRDetectionParamInitialAngleSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRDetectionParamInitialAngle");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRDetectionParamInitialAngleSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRExtractionParamExtractBlinkSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRExtractionParamExtractBlink");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRExtractionParamExtractBlinkSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRExtractionParamExtractSmileSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRExtractionParamExtractSmile");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRExtractionParamExtractSmileSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRExtractionParamExtractFaceprintSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRExtractionParamExtractFaceprint");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRExtractionParamExtractFaceprintSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRExtractionParamExtractLandmarkPointsSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRExtractionParamExtractLandmarkPoints");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRExtractionParamExtractLandmarkPointsSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRExtractionParamEnhancedEyesAndMouthLocalizationSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRExtractionParamEnhancedEyesAndMouthLocalization");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRExtractionParamEnhancedEyesAndMouthLocalizationSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                 + 24);
  return result;
}

void *__getFCRExtractionParamInitialAngleSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRExtractionParamInitialAngle");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRExtractionParamInitialAngleSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRFaceExpressionLeftEyeClosedScoreSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRFaceExpressionLeftEyeClosedScore");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRFaceExpressionLeftEyeClosedScoreSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRFaceExpressionRightEyeClosedScoreSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRFaceExpressionRightEyeClosedScore");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRFaceExpressionRightEyeClosedScoreSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getFCRFaceExpressionSmileScoreSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)FaceCoreLibrary();
  Class result = dlsym(v2, "FCRFaceExpressionSmileScore");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getFCRFaceExpressionSmileScoreSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

double vec2::get_xxy(vec2 *this, int32x4_t a2)
{
  a2.i64[0] = *(void *)this;
  a2.i64[0] = vzip1q_s32(a2, a2).u64[0];
  return *(double *)a2.i64;
}

double vec2::get_xyxy(vec2 *this)
{
  return *(double *)this;
}

void findBestThreeWayDivision(uint64_t a1@<X0>, uint64_t a2@<X1>, int *a3@<X2>, int *a4@<X3>, int a5@<W4>, int a6@<W5>, int a7@<W6>, uint64_t a8@<X8>)
{
  *(void *)(a8 + _Block_object_dispose(&STACK[0x3A0], 8) = 0;
  *(void *)(a8 + 16) = 0;
  uint64_t v10 = *a3;
  uint64_t v11 = *a4;
  if (a7 <= 0) {
    int v12 = v11 - v10 + 1;
  }
  else {
    int v12 = a7;
  }
  if (a6 <= 1) {
    unsigned int v13 = 1;
  }
  else {
    unsigned int v13 = a6;
  }
  *(int32x2_t *)a8 = vdup_n_s32(0x7F7FFFFFu);
  BurstLoggingMessage("\n***Finding three way division:\nfirstValidImage = %d, lastValidImage = %d\n", v10, v11);
  int v14 = v13 + v10 - 1;
  int v15 = v11 - 2 * v13;
  if (v14 <= v15)
  {
    int v16 = 0;
    int v17 = 0;
    int v19 = (int)(float)v12;
    uint64_t v20 = a2 / 0x32 + 1;
    int v21 = v10 + 1;
    uint64_t v22 = (int)(v10 + 2 * v13 - 1);
    uint64_t v23 = v19;
    uint64_t v24 = (int)(v11 - v13);
    uint64_t v25 = v14;
    uint64_t v95 = v15;
    uint64_t v94 = v24 - v13;
    uint64_t v26 = (int)v10 * (uint64_t)(int)a2;
    uint64_t v27 = (int)v20 * (uint64_t)(int)a2;
    uint64_t v28 = (a2 * (unsigned __int128)0x51EB851EB851EB9uLL) >> 64;
    uint64_t v29 = 4 * v28 + 4;
    uint64_t v30 = (int)a2 + (int)a2 * (uint64_t)v14;
    uint64_t v31 = (int)a2 + (int)a2 * v22;
    uint64_t v106 = a1 + 4 * (v14 + v26) + 4;
    uint64_t v32 = 4 * v27;
    double v107 = (int *)(a1 + 4 * v30 + 4 * v10);
    uint64_t v33 = 4 * v30 + 4 * v22 + a1 + 4;
    uint64_t v92 = 4 * (v28 + v27) + 4;
    uint64_t v93 = v26;
    float32x4_t v34 = (int *)(a1 + 4 * v31 + 4 * v10);
    float v35 = 3.4028e38;
    float v36 = 3.4028e38;
    uint64_t v18 = a2;
    int v98 = v19;
    uint64_t v99 = a2;
    uint64_t v96 = v24;
    uint64_t v97 = v19;
    do
    {
      float v104 = v34;
      uint64_t v105 = v33;
      if (v25 <= v94)
      {
        uint64_t v37 = v25 + 1;
        int8x16_t v38 = v34;
        uint64_t v39 = v31;
        uint64_t v40 = v22;
        uint64_t v102 = v30;
        uint64_t v103 = v22;
        uint64_t v101 = v31;
        do
        {
          if (v25 < v23 && v40 - v25 <= v23 && ~v40 + (int)v18 <= v19)
          {
            uint64_t v109 = v39;
            if (v25 <= v10)
            {
              int v41 = 0;
              float v46 = 0.0;
              float v42 = 0.0;
            }
            else
            {
              int v41 = 0;
              float v42 = 0.0;
              uint64_t v43 = v26;
              uint64_t v44 = v10;
              int v45 = v21;
              float v46 = 0.0;
              do
              {
                uint64_t v47 = v45;
                float32x2_t v48 = (int *)(a1 + 4 * (v43 + v45));
                uint64_t v49 = v47;
                do
                {
                  float v50 = (float)*v48;
                  if (v46 < v50) {
                    float v46 = (float)*v48;
                  }
                  float v42 = v42 + v50;
                  ++v41;
                  v49 += v20;
                  float32x2_t v48 = (int *)((char *)v48 + v29);
                }
                while (v49 <= v25);
                v44 += v20;
                int v45 = v47 + v20;
                v43 += v27;
              }
              while (v44 < v25);
            }
            if (v37 < v40)
            {
              uint64_t v51 = v30;
              uint64_t v52 = v37;
              int v53 = v25 + 2;
              do
              {
                uint64_t v54 = v53;
                float32x4_t v55 = (int *)(a1 + 4 * (v51 + v53));
                uint64_t v56 = v54;
                do
                {
                  float v57 = (float)*v55;
                  if (v46 < v57) {
                    float v46 = (float)*v55;
                  }
                  float v42 = v42 + v57;
                  ++v41;
                  v56 += v20;
                  float32x4_t v55 = (int *)((char *)v55 + v29);
                }
                while (v56 <= v40);
                v52 += v20;
                int v53 = v54 + v20;
                v51 += v27;
              }
              while (v52 < v40);
            }
            float v108 = v38;
            uint64_t v58 = v40 + 1;
            if (v40 + 1 < v11)
            {
              int v59 = v40 + 2;
              uint64_t v60 = v109;
              uint64_t v61 = v40 + 1;
              do
              {
                uint64_t v62 = v59;
                float32x4_t v63 = (int *)(a1 + 4 * (v60 + v59));
                uint64_t v64 = v62;
                do
                {
                  float v65 = (float)*v63;
                  if (v46 < v65) {
                    float v46 = (float)*v63;
                  }
                  float v42 = v42 + v65;
                  ++v41;
                  v64 += v20;
                  float32x4_t v63 = (int *)((char *)v63 + v29);
                }
                while (v64 <= v11);
                v61 += v20;
                int v59 = v62 + v20;
                v60 += v27;
              }
              while (v61 < v11);
            }
            if (v25 >= v10)
            {
              int v66 = 0;
              float v67 = 0.0;
              float32x4_t v68 = (int *)v106;
              uint64_t v69 = v10;
              do
              {
                float32x4_t v70 = v68;
                uint64_t v71 = v37;
                if (v25 < v11)
                {
                  do
                  {
                    float v67 = v67 + (float)*v70;
                    ++v66;
                    v71 += v20;
                    float32x4_t v70 = (int *)((char *)v70 + v29);
                  }
                  while (v71 <= v11);
                }
                v69 += v20;
                float32x4_t v68 = (int *)((char *)v68 + v32);
              }
              while (v69 <= v25);
            }
            else
            {
              int v66 = 0;
              float v67 = 0.0;
            }
            float32x4_t v72 = (int *)v33;
            float32x4_t v73 = v107;
            uint64_t v74 = v37;
            if (v40 > v25)
            {
              do
              {
                int8x16_t v75 = v73;
                for (uint64_t i = v10; i <= v25; v75 = (int *)((char *)v75 + v29))
                {
                  float v67 = v67 + (float)*v75;
                  ++v66;
                  i += v20;
                }
                float32x4_t v77 = v72;
                uint64_t v78 = v40 + 1;
                if (v40 < v11)
                {
                  do
                  {
                    float v67 = v67 + (float)*v77;
                    ++v66;
                    v78 += v20;
                    float32x4_t v77 = (int *)((char *)v77 + v29);
                  }
                  while (v78 <= v11);
                }
                v74 += v20;
                float32x4_t v73 = (int *)((char *)v73 + v32);
                float32x4_t v72 = (int *)((char *)v72 + v32);
              }
              while (v74 <= v40);
            }
            int8x16_t v38 = v108;
            double v79 = v108;
            uint64_t v37 = v25 + 1;
            if (v40 < v11)
            {
              do
              {
                if (v40 >= v10)
                {
                  float64x2_t v80 = v79;
                  uint64_t v81 = v10;
                  do
                  {
                    float v67 = v67 + (float)*v80;
                    ++v66;
                    v81 += v20;
                    float64x2_t v80 = (int *)((char *)v80 + v29);
                  }
                  while (v81 <= v40);
                }
                v58 += v20;
                double v79 = (int *)((char *)v79 + v32);
              }
              while (v58 <= v11);
            }
            float v82 = (float)(v42 / (float)v41) / (float)(v67 / (float)v66);
            BOOL v83 = v82 >= v35 || v36 * 1.25 <= v46;
            uint64_t v39 = v109;
            if (!v83)
            {
              BurstLoggingMessage("NEW BEST: largestInnerDistance = %f, bestRatio = %f\n", v46, v82);
              BurstLoggingMessage("Divider1 = %d, Divider2 = %d\n", v25, v40);
              int8x16_t v38 = v108;
              uint64_t v39 = v109;
              uint64_t v37 = v25 + 1;
              uint64_t v31 = v101;
              uint64_t v30 = v102;
              uint64_t v26 = v93;
              uint64_t v24 = v96;
              uint64_t v23 = v97;
              uint64_t v22 = v103;
              int v21 = v10 + 1;
              int v19 = v98;
              uint64_t v18 = v99;
              *(float *)a8 = v46;
              *(float *)(a8 + 4) = v82;
              *(_DWORD *)(a8 + _Block_object_dispose(&STACK[0x3A0], 8) = v10;
              *(_DWORD *)(a8 + 12) = v11;
              int v16 = v40;
              int v17 = v25;
              float v35 = v82;
              float v36 = v46;
              *(_DWORD *)(a8 + 16) = v25;
              *(_DWORD *)(a8 + 2CI::NodeWithChildren::NodeWithChildren(this, 0) = v40;
            }
          }
          v40 += v20;
          v39 += v27;
          v33 += v29;
          int8x16_t v38 = (int *)((char *)v38 + v32);
        }
        while (v40 <= v24);
      }
      v25 += v20;
      v22 += v20;
      v30 += v27;
      v31 += v27;
      v106 += v29;
      double v107 = (int *)((char *)v107 + v32);
      uint64_t v33 = v105 + v92;
      float32x4_t v34 = &v104[(unint64_t)v32 / 4];
    }
    while (v25 <= v95);
  }
  else
  {
    int v16 = 0;
    int v17 = 0;
    uint64_t v18 = a2;
  }
  if (a5 <= 2 && (int)v11 - (int)v10 >= 6)
  {
    if (v17 == v10)
    {
      ++*a3;
      int v84 = v11 - 1;
    }
    else
    {
      int v84 = v11 - 1;
      if (v16 != v11 - 1) {
        return;
      }
    }
    uint64_t v85 = v18;
    int v86 = *a4;
    if (v16 == v84) {
      *a4 = --v86;
    }
    BurstLoggingMessage("RECURSING: (%d->%d) becomes (%d->%d)\n", v10, v11, *a3, v86);
    findBestThreeWayDivision(&v110, a1, v85, a3, a4, (a5 + 1), a6, a7);
    *(_OWORD *)a8 = v110;
    *(void *)(a8 + 16) = v111;
  }
}

uint64_t updateBlurStatsOne16x16(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4)
{
  int v6 = computeEdge1Squared16x16_NEON(a1, (uint64_t)a2, a3, a4);
  int v7 = computeEdgeVal(a1, 2);
  uint64_t result = computeEdgeVal(a1, 1);
  BOOL v11 = v6 > 1225 || v7 > 1225 || (int)result > 1225;
  if (a2)
  {
    if (v11 && v6 < v7 && v7 != result)
    {
      ++*a2;
      if (v6 < 1225 || v7 < 1225 || (int)result <= 1224) {
        ++a2[1];
      }
    }
  }
  return result;
}

float computeRegistrationErrorStats(float *a1, float *a2, int a3, float result)
{
  if (a1)
  {
    float v4 = 0.0;
    if (a3 >= 1)
    {
      int v5 = a3;
      int v6 = a2;
      do
      {
        float v7 = *v6++;
        float v4 = v4 + v7;
        --v5;
      }
      while (v5);
    }
    float v8 = (float)a3;
    float v9 = (float)(v4 / (float)a3) * 0.5;
    for (uint64_t i = 16; i != -1; --i)
      a2[i] = v9;
    uint64_t v11 = a3 - 17;
    do
      a2[v11++] = v9;
    while (v11 < a3);
    if (a3 < 1)
    {
      float v15 = 0.0;
      float v14 = 0.0;
      float v13 = 0.0;
      float v12 = 0.0;
    }
    else
    {
      float v12 = 0.0;
      float v13 = 0.0;
      float v14 = 0.0;
      float v15 = 0.0;
      do
      {
        float v16 = *a2++;
        float v17 = v16;
        if (v16 > v13) {
          float v13 = v17;
        }
        float v12 = v12 + v17;
        float v15 = v15 + (float)(v17 * v17);
        float v14 = v14 + (float)(v17 * (float)(v17 * v17));
        --a3;
      }
      while (a3);
    }
    float v18 = v12 / v8;
    float v19 = (float)(v15 / v8) - (float)(v18 * v18);
    float v20 = sqrtf(v19);
    float v21 = (float)((float)(v14 / v8) - (float)((float)((float)(v18 * v18) + (float)(v19 * 3.0)) * v18))
        / (float)(v19 * v20);
    *a1 = v21;
    a1[1] = v18;
    a1[2] = v20;
    a1[3] = v13;
    BurstLoggingMessage("Registration error stats: mean=%f, stdDev=%f, skewness=%f, maxValue=%f\n", v18, v20, v21, v13);
  }
  return result;
}

void computeForegroundInterval(uint64_t a1, uint64_t a2, int a3, int *a4, int *a5)
{
  if (!a1 || !a4 || !a5) {
    return;
  }
  int v10 = a3 - 1;
  uint64_t v11 = (float *)malloc_type_malloc(8 * a3, 0x100004000313F17uLL);
  if (v11)
  {
    float v13 = v11;
    if (a3 < 37)
    {
      int v14 = 0;
    }
    else
    {
      int v14 = 0;
      uint64_t v15 = a2 + 8;
      float v16 = 0.0;
      uint64_t v17 = 18;
      v18.i64[0] = 0x100000001;
      v18.i64[1] = 0x100000001;
      float v19 = 0.0;
      do
      {
        uint64_t v20 = 0;
        v12.i32[0] = *(_DWORD *)(a2 + 4 * v17);
        float32x4_t v21 = (float32x4_t)vdupq_lane_s32(v12, 0);
        v22.i64[0] = 0x100000001;
        v22.i64[1] = 0x100000001;
        do
        {
          int32x4_t v22 = (int32x4_t)vbicq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(*(float32x4_t *)(v15 + v20), v21));
          v20 += 16;
        }
        while (v20 != 128);
        if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v22, v18)))) & 1) == 0)
        {
          uint64_t v23 = &v11[2 * v14];
          float *v23 = *(float *)v12.i32;
          *((_DWORD *)v23 + 1) = v17;
          ++v14;
          float v24 = *(float *)(a2 + 4 * v17);
          float v19 = v19 + v24;
          float v16 = v16 + (float)(v24 * v24);
        }
        ++v17;
        v15 += 4;
      }
      while (v17 != a3 - 18);
      if (v14)
      {
        float v25 = v19 / (float)v14;
        float v26 = sqrtf((float)(v16 / (float)v14) - (float)(v25 * v25));
LABEL_17:
        qsort(v11, v14, 8uLL, (int (__cdecl *)(const void *, const void *))comparePeaks);
        if (*v13 >= 5000.0)
        {
          if ((float)(v25 + (float)(v26 * 0.22)) >= 3000.0) {
            float v29 = v25 + (float)(v26 * 0.22);
          }
          else {
            float v29 = 3000.0;
          }
          BurstLoggingMessage("Peak rejection threshold = %f (mean = %f, std = %f)\n", v29, v25, v26);
          if (v14 < 2)
          {
            LODWORD(v31) = 1;
          }
          else
          {
            uint64_t v30 = v13 + 2;
            uint64_t v31 = 1;
            while (*v30 >= v29)
            {
              ++v31;
              v30 += 2;
              if (v14 == v31)
              {
                LODWORD(v31) = v14;
                break;
              }
            }
          }
          int v27 = 0;
          if (v31 <= 1) {
            uint64_t v31 = 1;
          }
          else {
            uint64_t v31 = v31;
          }
          uint64_t v32 = (int *)(v13 + 1);
          int v28 = a3;
          do
          {
            int v34 = *v32;
            v32 += 2;
            int v33 = v34;
            if (v34 < v28) {
              int v28 = v33;
            }
            if (v33 > v27) {
              int v27 = v33;
            }
            --v31;
          }
          while (v31);
          BurstLoggingMessage("Starting ROI construction at %d->%d\n", v28, v27);
        }
        else
        {
          int v27 = a3 - 17;
          BurstLoggingMessage("Insufficient peak error for ROI computation %f (threshold %f)\n", *v13, 5000.0);
          int v28 = 17;
        }
        free(v13);
        goto LABEL_39;
      }
    }
    float v26 = 0.0;
    float v25 = 3.4028e38;
    goto LABEL_17;
  }
  int v27 = 0;
  int v28 = a3;
LABEL_39:
  int v35 = 0;
  float v36 = *(float *)(a1 + 4) + (float)(*(float *)(a1 + 8) * 0.5);
  if (v36 < 3000.0) {
    float v36 = 3000.0;
  }
  uint64_t v37 = (float *)(a2 + 4 * (v28 - 1));
  while (v28 >= 18)
  {
    float v38 = *v37--;
    if (v38 < v36) {
      ++v35;
    }
    else {
      int v35 = 0;
    }
    --v28;
    if (v35 >= 4)
    {
      int v39 = v28 - 10;
      goto LABEL_49;
    }
  }
  int v39 = 0;
LABEL_49:
  int v40 = 0;
  *a4 = v39;
  uint64_t v41 = v27 + 1;
  while (v41 < a3 - 17)
  {
    if (*(float *)(a2 + 4 * v41) < v36) {
      ++v40;
    }
    else {
      int v40 = 0;
    }
    ++v27;
    ++v41;
    if (v40 >= 4) {
      goto LABEL_57;
    }
  }
  int v27 = v10;
LABEL_57:
  int v42 = v27 + 10;
  if (v27 + 10 >= a3) {
    int v42 = v10;
  }
  *a5 = v42;
}

uint64_t compareFloats(float *a1, float *a2)
{
  if (*a1 > *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 < *a2;
  }
}

uint64_t compareGridElements(uint64_t a1, uint64_t a2)
{
  float v2 = *(float *)(a1 + 4);
  float v3 = *(float *)(a2 + 4);
  if (v2 > v3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v2 < v3;
  }
}

uint64_t computeEdgeVal(uint64_t a1, int a2)
{
  int v4 = computeEdgeValOne8x8(a1, a2);
  int v5 = computeEdgeValOne8x8(a1 + 16, a2);
  if (v5 > v4) {
    int v4 = v5;
  }
  int v6 = computeEdgeValOne8x8(a1 + 512, a2);
  if (v6 > v4) {
    int v4 = v6;
  }
  LODWORD(result) = computeEdgeValOne8x8(a1 + 528, a2);
  if ((int)result <= v4) {
    return v4;
  }
  else {
    return result;
  }
}

uint64_t computeEdgeValOne8x8(uint64_t a1, int a2)
{
  if (a2 < 1) {
    return 0;
  }
  int v2 = 0;
  float v4 = 0.0;
  int v5 = (__int16 *)(a1 + 2 * a2);
  do
  {
    int v6 = a2;
    uint64_t v7 = a1;
    float v8 = v5;
    do
    {
      uint64_t v3 = (32 * a2);
      int v9 = *(__int16 *)(v7 + 2 * v3) * *(__int16 *)(v7 + 2 * v3) + v8[v3] * v8[v3] + *v8 * *v8;
      if (v4 < (float)v9) {
        float v4 = (float)v9;
      }
      ++v8;
      v7 += 2;
      --v6;
    }
    while (v6);
    ++v2;
    v5 += 32;
    a1 += 64;
  }
  while (v2 != a2);
  return (int)v4;
}

uint64_t comparePeaks(float *a1, float *a2)
{
  if (*a1 > *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 < *a2;
  }
}

void *BurstLoggingSetCallback(void *result, uint64_t a2)
{
  gBurstLoggingCallbacuint64_t k = result;
  gBurstLoggingUserDatCGFloat a = a2;
  return result;
}

uint64_t BurstLoggingSetFileHandle(uint64_t result)
{
  gBurstLoggingFileHandle = result;
  return result;
}

void BurstLoggingMessage(char *__format, ...)
{
  va_start(va, __format);
  if (__format)
  {
    va_copy(v6, va);
    int v2 = vsnprintf(&__str, 1uLL, __format, va);
    if (v2 > 0)
    {
      size_t v3 = (v2 + 1);
      float v4 = (char *)malloc_type_malloc(v3, 0xB8EEE3FBuLL);
      vsnprintf(v4, v3, __format, va);
      if (v4)
      {
        if (gBurstLoggingCallback) {
          gBurstLoggingCallback(gBurstLoggingUserData, v4);
        }
        if (gBurstLoggingFileHandle) {
          fputs(v4, (FILE *)gBurstLoggingFileHandle);
        }
        free(v4);
      }
    }
  }
}

double cikernel::_white(int32x4_t a1)
{
  *(void *)&double result = vdupq_laneq_s32(a1, 3).u64[0];
  return result;
}

double cikernel::_cmyk_convert(int32x4_t a1, double a2)
{
  float32x4_t v2 = (float32x4_t)vdupq_laneq_s32(a1, 3);
  a1.i32[3] = 0;
  float32x4_t v3 = vmaxnmq_f32((float32x4_t)a1, (float32x4_t)0);
  v3.i32[3] = 0;
  v2.i32[3] = 0;
  float32x4_t v4 = vminnmq_f32(v3, v2);
  __asm { FMOV            V2.4S, #1.0 }
  float32x4_t v10 = vsubq_f32(_Q2, v4);
  _Q2.f32[0] = vmuls_lane_f32(fminf(fminf(v10.f32[0], v10.f32[1]), v10.f32[2]), *(float32x2_t *)&a2, 1);
  *(float *)&a2 = (float)(_Q2.f32[0] * _Q2.f32[0]) * *(float *)&a2;
  *(void *)&double result = vsubq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0)).u64[0];
  return result;
}

void CI::f4_s_f2(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  uint64_t v11 = (double (*)(void *, __n128, double))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  float v16 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    float v16 = (double *)((char *)a2 + 64 * v15);
  }
  uint64_t v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v17 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v18 = v11(a1, *v17, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_cmyk_cyan(CI *a1, float32x4_t a2, double a3, float32x2_t a4, int8x16_t a5, float a6)
{
  float32x2_t v7 = a4;
  float32x2_t v8 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  int32x2_t v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v8);
  int32x2_t v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v8);
  float32x2_t v11 = vadd_f32(v7, vadd_f32((float32x2_t)vzip1_s32(v9, v10), (float32x2_t)vzip2_s32(v9, v10)));
  float32x2_t v12 = vmul_f32(vminnm_f32(vsub_f32(v11, vrndm_f32(v11)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)), (float32x2_t)vdup_n_s32(0x40C90FDBu));
  a5.i32[1] = v12.i32[1];
  v7.i32[0] = sinf(v12.f32[0]);
  float v13 = (float)(v7.f32[0] + sinf(*(float *)&a5.i32[1])) * 0.25 * (-1.0 / a6 + 0.995) + 0.5;
  v14.i32[1] = HIDWORD(a3);
  float v15 = (float)((float)(*(float *)&a3 - v13) * a6) + 0.5;
  if (v15 <= 1.0) {
    float v16 = v15;
  }
  else {
    float v16 = 1.0;
  }
  _NF = v15 < 0.0;
  float v18 = 0.0;
  if (!_NF) {
    float v18 = v16;
  }
  *(float *)v14.i32 = 1.0 - v18;
  float32x4_t v19 = vmaxnmq_f32(vmulq_f32(a2, vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v14, 0), (float32x4_t)xmmword_1939504D0, v18)), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(void *)&double result = vminnmq_f32(v19, _Q1).u64[0];
  return result;
}

void CI::f4_s_s_f2_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  int32x2_t v10 = *(double (**)(__n128, __n128, double, __n128, float))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  uint64_t v19 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v25 = *(_DWORD *)(v9 + 88);
    int v26 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v17 = v25;
    int v15 = v26;
  }
  uint64_t v20 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    uint64_t v20 = (__n128 *)((char *)a2 + 64 * v18);
  }
  float32x4_t v21 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x4_t v21 = (double *)((char *)a2 + 64 * v16);
  }
  int32x4_t v22 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    int32x4_t v22 = (__n128 *)((char *)a2 + 64 * v14);
  }
  uint64_t v23 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    uint64_t v23 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v24 = v10(*v23, *v22, *v21, *v20, *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v24;
}

double cikernel::_cmyk_magenta(CI *a1, float32x4_t a2, double a3, float32x2_t a4, int8x16_t a5, float a6)
{
  float v26 = *((float *)&a3 + 1);
  float32x2_t v7 = a4;
  float32x2_t v8 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  int32x2_t v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v8);
  int32x2_t v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v8);
  float32x2_t v11 = vadd_f32(v7, vadd_f32((float32x2_t)vzip1_s32(v9, v10), (float32x2_t)vzip2_s32(v9, v10)));
  float32x2_t v12 = vmul_f32(vminnm_f32(vsub_f32(v11, vrndm_f32(v11)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)), (float32x2_t)vdup_n_s32(0x40C90FDBu));
  a5.i32[1] = v12.i32[1];
  v7.i32[0] = sinf(v12.f32[0]);
  float v13 = (float)(v7.f32[0] + sinf(*(float *)&a5.i32[1])) * 0.25 * (-1.0 / a6 + 0.995) + 0.5;
  *(float *)&v14.i32[1] = v26;
  float v15 = (float)((float)(v26 - v13) * a6) + 0.5;
  if (v15 <= 1.0) {
    float v16 = v15;
  }
  else {
    float v16 = 1.0;
  }
  _NF = v15 < 0.0;
  float v18 = 0.0;
  if (!_NF) {
    float v18 = v16;
  }
  *(float *)v14.i32 = 1.0 - v18;
  float32x4_t v19 = vmaxnmq_f32(vmulq_f32(a2, vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v14, 0), (float32x4_t)xmmword_1939504E0, v18)), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(void *)&double result = vminnmq_f32(v19, _Q1).u64[0];
  return result;
}

double cikernel::_cmyk_yellow(CI *a1, float32x4_t a2, __n128 a3, float32x2_t a4, int8x16_t a5, float a6)
{
  float32x2_t v7 = a4;
  float32x2_t v8 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  int32x2_t v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v8);
  int32x2_t v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v8);
  float32x2_t v11 = vadd_f32(v7, vadd_f32((float32x2_t)vzip1_s32(v9, v10), (float32x2_t)vzip2_s32(v9, v10)));
  float32x2_t v12 = vmul_f32(vminnm_f32(vsub_f32(v11, vrndm_f32(v11)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)), (float32x2_t)vdup_n_s32(0x40C90FDBu));
  a5.i32[1] = v12.i32[1];
  v7.i32[0] = sinf(v12.f32[0]);
  float v13 = (float)(v7.f32[0] + sinf(*(float *)&a5.i32[1])) * 0.25 * (-1.0 / a6 + 0.995) + 0.5;
  v14.i32[1] = a3.n128_i32[1];
  float v15 = (float)((float)(a3.n128_f32[2] - v13) * a6) + 0.5;
  if (v15 <= 1.0) {
    float v16 = v15;
  }
  else {
    float v16 = 1.0;
  }
  _NF = v15 < 0.0;
  float v18 = 0.0;
  if (!_NF) {
    float v18 = v16;
  }
  *(float *)v14.i32 = 1.0 - v18;
  float32x4_t v19 = vmaxnmq_f32(vmulq_f32(a2, vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v14, 0), (float32x4_t)xmmword_1939504F0, v18)), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(void *)&double result = vminnmq_f32(v19, _Q1).u64[0];
  return result;
}

double cikernel::_cmyk_black(CI *a1, float32x4_t a2, __n128 a3, float32x2_t a4, int8x16_t a5, float a6)
{
  float32x2_t v7 = a4;
  float32x2_t v8 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  int32x2_t v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v8);
  int32x2_t v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v8);
  float32x2_t v11 = vadd_f32(v7, vadd_f32((float32x2_t)vzip1_s32(v9, v10), (float32x2_t)vzip2_s32(v9, v10)));
  float32x2_t v12 = vmul_f32(vminnm_f32(vsub_f32(v11, vrndm_f32(v11)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)), (float32x2_t)vdup_n_s32(0x40C90FDBu));
  a5.i32[1] = v12.i32[1];
  v7.i32[0] = sinf(v12.f32[0]);
  float v13 = (float)(v7.f32[0] + sinf(*(float *)&a5.i32[1])) * 0.25 * (-1.0 / a6 + 0.995) + 0.5;
  v14.i32[1] = a3.n128_i32[1];
  float v15 = (float)((float)(a3.n128_f32[3] - v13) * a6) + 0.5;
  if (v15 <= 1.0) {
    float v16 = v15;
  }
  else {
    float v16 = 1.0;
  }
  _NF = v15 < 0.0;
  float v18 = 0.0;
  if (!_NF) {
    float v18 = v16;
  }
  *(float *)v14.i32 = 1.0 - v18;
  float32x4_t v19 = vmaxnmq_f32(vmulq_f32(a2, vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v14, 0), (float32x4_t)xmmword_19394C7E0, v18)), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(void *)&double result = vminnmq_f32(v19, _Q1).u64[0];
  return result;
}

double cikernel::_radialLensDistortion(uint64_t a1, uint64_t a2, float64x2_t a3)
{
  float v5 = *(float *)&a3.f64[1];
  float v6 = *((float *)&a3.f64[1] + 1) + -1.0;
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  float64x2_t v8 = a3;
  float32x2_t v9 = vsub_f32(*(float32x2_t *)&a3.f64[0], *DC);
  *(float *)&double v10 = (float)((float)(v6 * sqrtf(vaddv_f32(vmul_f32(v9, v9)))) / v5) + 0.5;
  v11.i32[0] = *(_DWORD *)(a2 + 28);
  v9.f32[0] = *(float *)(a2 + 24)
            + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)&v10 * *(float *)(a2 + 16)));
  LODWORD(v12) = *(_DWORD *)(a2 + 32);
  v13.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v8.f64 = *(float *)v13.i32
                   + (float)((float)(*(float *)&v12 * 0.5) + (float)(*(float *)&v10 * *(float *)v11.i32));
  v9.f32[1] = *(float *)v8.f64;
  *(double *)&long long v15 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v9, v8, v10, v12, v11, v13, v14);
  long long v28 = v15;
  int v17 = (float32x2_t *)CI::getDC(v16);
  v20.f64[1] = *((float64_t *)&v28 + 1);
  HIDWORD(v21) = HIDWORD(a3.f64[0]);
  float32x2_t v19 = vsub_f32(*v17, *(float32x2_t *)&a3.f64[0]);
  *(float32x2_t *)&v20.f64[0] = vmul_n_f32(v19, *(float *)&v28);
  float32x2_t v25 = vadd_f32(*(float32x2_t *)&a3.f64[0], vadd_f32(v19, *(float32x2_t *)&v20.f64[0]));
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v25, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v25, 1), *(float *)&v22, v25.f32[0]);
  v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  float v26 = *(uint64x2_t **)(a1 + 8);

  v25.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(float *)v20.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  return CI::BitmapSampler::read(v26, *(double *)&v25, v20, v21, v22, v24, v23, v18);
}

double cikernel::_cheapBlur(uint64_t a1, float32x2_t a2)
{
  float32x2_t v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v5 = vmul_f32(a2, (float32x2_t)0x40800000BF800000);
  float32x2_t v6 = vadd_f32(v5, v4);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  float32x2_t v11 = vmul_f32(a2, (float32x2_t)0x3F80000040800000);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v12.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v12, v7, v8, v10, v9, v13);
  float32x4_t v50 = v14;
  *(float32x2_t *)v14.f32 = vadd_f32(v11, v4);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v14.f32, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v14.f32, 1), *(float *)&v16, v14.f32[0]);
  v14.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v19.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v14.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v14.i64, v19, v15, v16, v18, v17, v20);
  float32x4_t v49 = v21;
  *(float32x2_t *)v21.f32 = vsub_f32(v4, v11);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v21.f32, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v21.f32, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v26, v22, v23, v25, v24, v27);
  float32x4_t v48 = v28;
  *(float32x2_t *)v28.f32 = vsub_f32(v4, v5);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v28.f32, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.f32, 1), *(float *)&v30, v28.f32[0]);
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v29;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v28.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v33, v29, v30, v32, v31, v34);
  float32x4_t v47 = v35;
  uint64_t DC = (float32x2_t *)CI::getDC(v36);
  *(float *)&double v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v39) = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v39, COERCE_FLOAT(*DC));
  *(float *)&double v42 = *(float *)(a1 + 24) + *(float *)&v38;
  *(float *)v43.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  *((float *)&v42 + 1) = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v42, v43, v38, v39, v41, v40, v44);
  *(void *)&double result = vaddq_f32(vmulq_f32(vaddq_f32(v48, vaddq_f32(vaddq_f32(v50, v49), v47)), (float32x4_t)vdupq_n_s32(0x3E51745Du)), vmulq_f32(v45, (float32x4_t)vdupq_n_s32(0x3E3A2E8Cu))).u64[0];
  return result;
}

double cikernel::_lerp(float32x4_t a1, float32x4_t a2, float a3)
{
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a3), a1, a3).u64[0];
  return result;
}

double cikernel::_box4(cikernel *this, SamplerObj *a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  __asm { FMOV            V1.2S, #4.0 }
  float32x2_t v9 = vmul_f32(*DC, *(float32x2_t *)&_Q1.f64[0]);
  __asm { FMOV            V0.2S, #-1.0 }
  float32x2_t v11 = vadd_f32(v9, _D0);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v11, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)_Q1.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v11, _Q1, v12, v13, v15, v14, v16);
  float32x4_t v43 = v17;
  *(float32x2_t *)v17.f32 = vadd_f32(v9, (float32x2_t)0x3F800000BF800000);
  *(float *)&double v18 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v17.f32, 1), *((float *)this + 4), v17.f32[0]);
  LODWORD(v19) = *((_DWORD *)this + 7);
  v20.i32[0] = *((_DWORD *)this + 9);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v17.f32, 1), *(float *)&v19, v17.f32[0]);
  v17.f32[0] = *((float *)this + 6) + *(float *)&v18;
  *(float *)v22.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  v17.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v17.i64, v22, v18, v19, v21, v20, v23);
  float32x4_t v42 = v24;
  *(float32x2_t *)v24.f32 = vadd_f32(v9, (float32x2_t)0xBF8000003F800000);
  *(float *)&double v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v24.f32, 1), *((float *)this + 4), v24.f32[0]);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v24.f32, 1), *(float *)&v26, v24.f32[0]);
  v24.f32[0] = *((float *)this + 6) + *(float *)&v25;
  *(float *)v29.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v24.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v24.i64, v29, v25, v26, v28, v27, v30);
  float32x4_t v41 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  *(float32x2_t *)_Q0.f32 = vadd_f32(v9, *(float32x2_t *)_Q0.f32);
  *(float *)&double v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 7);
  v34.i32[0] = *((_DWORD *)this + 9);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v33, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v32;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  _Q0.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v36, v32, v33, v35, v34, v37);
  __asm { FMOV            V1.4S, #0.25 }
  *(void *)&double result = vmulq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v43, v42), v41), v38), _Q1).u64[0];
  return result;
}

double cikernel::_box6(cikernel *this, SamplerObj *a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  __asm { FMOV            V1.2S, #6.0 }
  float32x2_t v9 = vmul_f32(*DC, *(float32x2_t *)&_Q1.f64[0]);
  float32x2_t v10 = vadd_f32(v9, (float32x2_t)0xC0000000C0000000);
  *(float *)&double v11 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v10, 1), *((float *)this + 4), v10.f32[0]);
  LODWORD(v12) = *((_DWORD *)this + 7);
  v13.i32[0] = *((_DWORD *)this + 9);
  *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v10, 1), *(float *)&v12, v10.f32[0]);
  v10.f32[0] = *((float *)this + 6) + *(float *)&v11;
  *(float *)_Q1.f64 = *(float *)v13.i32 + *(float *)v14.i32;
  v10.f32[1] = *(float *)v13.i32 + *(float *)v14.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v10, _Q1, v11, v12, v14, v13, v15);
  float32x4_t v81 = v16;
  *(float32x2_t *)v16.f32 = vadd_f32(v9, (float32x2_t)0xC000000000000000);
  *(float *)&double v17 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v16.f32, 1), *((float *)this + 4), v16.f32[0]);
  LODWORD(v1_Block_object_dispose(&STACK[0x3A0], 8) = *((_DWORD *)this + 7);
  v19.i32[0] = *((_DWORD *)this + 9);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v16.f32, 1), *(float *)&v18, v16.f32[0]);
  v16.f32[0] = *((float *)this + 6) + *(float *)&v17;
  *(float *)v21.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v16.i64, v21, v17, v18, v20, v19, v22);
  float32x4_t v80 = v23;
  *(float32x2_t *)v23.f32 = vadd_f32(v9, (float32x2_t)0xC000000040000000);
  *(float *)&double v24 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v23.f32, 1), *((float *)this + 4), v23.f32[0]);
  LODWORD(v25) = *((_DWORD *)this + 7);
  v26.i32[0] = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v23.f32, 1), *(float *)&v25, v23.f32[0]);
  v23.f32[0] = *((float *)this + 6) + *(float *)&v24;
  *(float *)v28.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v23.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v23.i64, v28, v24, v25, v27, v26, v29);
  float32x4_t v79 = v30;
  *(float32x2_t *)v30.f32 = vadd_f32(v9, (float32x2_t)3221225472);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v30.f32, 1), *((float *)this + 4), v30.f32[0]);
  LODWORD(v32) = *((_DWORD *)this + 7);
  v33.i32[0] = *((_DWORD *)this + 9);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v30.f32, 1), *(float *)&v32, v30.f32[0]);
  v30.f32[0] = *((float *)this + 6) + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v30.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v35, v31, v32, v34, v33, v36);
  float32x4_t v78 = v37;
  *(float32x2_t *)v37.f32 = vadd_f32(v9, 0);
  *(float *)&double v38 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v37.f32, 1), *((float *)this + 4), v37.f32[0]);
  LODWORD(v39) = *((_DWORD *)this + 7);
  v40.i32[0] = *((_DWORD *)this + 9);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v37.f32, 1), *(float *)&v39, v37.f32[0]);
  v37.f32[0] = *((float *)this + 6) + *(float *)&v38;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v37.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v37.i64, v42, v38, v39, v41, v40, v43);
  float32x4_t v77 = v44;
  *(float32x2_t *)v44.f32 = vadd_f32(v9, (float32x2_t)0x40000000);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v44.f32, 1), *((float *)this + 4), v44.f32[0]);
  LODWORD(v46) = *((_DWORD *)this + 7);
  v47.i32[0] = *((_DWORD *)this + 9);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v44.f32, 1), *(float *)&v46, v44.f32[0]);
  v44.f32[0] = *((float *)this + 6) + *(float *)&v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v44.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v44.i64, v49, v45, v46, v48, v47, v50);
  float32x4_t v76 = v51;
  *(float32x2_t *)v51.f32 = vadd_f32(v9, (float32x2_t)0x40000000C0000000);
  *(float *)&double v52 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v51.f32, 1), *((float *)this + 4), v51.f32[0]);
  LODWORD(v53) = *((_DWORD *)this + 7);
  v54.i32[0] = *((_DWORD *)this + 9);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v51.f32, 1), *(float *)&v53, v51.f32[0]);
  v51.f32[0] = *((float *)this + 6) + *(float *)&v52;
  *(float *)v56.f64 = *(float *)v54.i32 + *(float *)v55.i32;
  v51.f32[1] = *(float *)v54.i32 + *(float *)v55.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v51.i64, v56, v52, v53, v55, v54, v57);
  float32x4_t v75 = v58;
  *(float32x2_t *)v58.f32 = vadd_f32(v9, (float32x2_t)0x4000000000000000);
  *(float *)&double v59 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v58.f32, 1), *((float *)this + 4), v58.f32[0]);
  LODWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = *((_DWORD *)this + 7);
  v61.i32[0] = *((_DWORD *)this + 9);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v58.f32, 1), *(float *)&v60, v58.f32[0]);
  v58.f32[0] = *((float *)this + 6) + *(float *)&v59;
  *(float *)v63.f64 = *(float *)v61.i32 + *(float *)v62.i32;
  v58.f32[1] = *(float *)v61.i32 + *(float *)v62.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v58.i64, v63, v59, v60, v62, v61, v64);
  float32x4_t v74 = v65;
  *(float32x2_t *)v65.f32 = vadd_f32(v9, (float32x2_t)0x4000000040000000);
  *(float *)&double v66 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v65.f32, 1), *((float *)this + 4), v65.f32[0]);
  LODWORD(v67) = *((_DWORD *)this + 7);
  v68.i32[0] = *((_DWORD *)this + 9);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v65.f32, 1), *(float *)&v67, v65.f32[0]);
  v65.f32[0] = *((float *)this + 6) + *(float *)&v66;
  *(float *)v70.f64 = *(float *)v68.i32 + *(float *)v69.i32;
  v65.f32[1] = *(float *)v68.i32 + *(float *)v69.i32;
  *(double *)v72.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v65.i64, v70, v66, v67, v69, v68, v71);
  *(void *)&double result = vmulq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v81, v80), v79), v78), v77), v76), v75), v74), v72), (float32x4_t)vdupq_n_s32(0x3DE38E39u)).u64[0];
  return result;
}

double cikernel::_cross4(cikernel *this, SamplerObj *a2, float a3)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v5.i8 = *DC;
  float64x2_t v47 = (float64x2_t)v5;
  LODWORD(v6) = *((_DWORD *)this + 7);
  *(float *)&double v7 = *((float *)this + 6)
                + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v_Block_object_dispose(&STACK[0x3A0], 8) = *((_DWORD *)this + 9);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v6, COERCE_FLOAT(*DC));
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v7, v9, v6, v8, v5, v10, v11);
  float32x4_t v45 = v12;
  float64x2_t v13 = v47;
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)&v47.f64[0], (float32x2_t)0xBFC00000BF000000);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v15, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v13.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v12.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v13, v14, v15, v17, v16, v18);
  float32x4_t v44 = v19;
  float64x2_t v20 = v47;
  *(float32x2_t *)v19.f32 = vadd_f32(*(float32x2_t *)&v47.f64[0], (float32x2_t)0x3FC000003F000000);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v19.f32, 1), *((float *)this + 4), v19.f32[0]);
  LODWORD(v22) = *((_DWORD *)this + 7);
  v23.i32[0] = *((_DWORD *)this + 9);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v19.f32, 1), *(float *)&v22, v19.f32[0]);
  v19.f32[0] = *((float *)this + 6) + *(float *)&v21;
  *(float *)v20.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v19.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, v20, v21, v22, v24, v23, v25);
  float32x4_t v43 = v26;
  float64x2_t v27 = v47;
  *(float32x2_t *)v26.f32 = vadd_f32(*(float32x2_t *)&v47.f64[0], (float32x2_t)0x3F000000BFC00000);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v26.f32, 1), *((float *)this + 4), v26.f32[0]);
  LODWORD(v29) = *((_DWORD *)this + 7);
  v30.i32[0] = *((_DWORD *)this + 9);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v26.f32, 1), *(float *)&v29, v26.f32[0]);
  v26.f32[0] = *((float *)this + 6) + *(float *)&v28;
  *(float *)v27.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v26.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v26.i64, v27, v28, v29, v31, v30, v32);
  float32x4_t v42 = v33;
  float64x2_t v34 = v47;
  *(float32x2_t *)v33.f32 = vadd_f32(*(float32x2_t *)&v47.f64[0], (float32x2_t)0xBF0000003FC00000);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v33.f32, 1), *((float *)this + 4), v33.f32[0]);
  LODWORD(v36) = *((_DWORD *)this + 7);
  v37.i32[0] = *((_DWORD *)this + 9);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v33.f32, 1), *(float *)&v36, v33.f32[0]);
  v33.f32[0] = *((float *)this + 6) + *(float *)&v35;
  *(float *)v34.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v33.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v33.i64, v34, v35, v36, v38, v37, v39);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v45, 1.0 - a3), vaddq_f32(vmulq_f32(v45, (float32x4_t)vdupq_n_s32(0x3DA3D70Au)), vmulq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v44, v43), v42), v40), (float32x4_t)vdupq_n_s32(0x3E6B851Fu))), a3).u64[0];
  return result;
}

double cikernel::_checker(CI *a1, float32x2_t a2, float32x4_t a3, float32x4_t a4, int32x4_t a5)
{
  float32x2_t v5 = vmul_n_f32(vsub_f32(*(float32x2_t *)CI::getDC(a1), a2), *(float *)a5.i32);
  float32x2_t v6 = vminnm_f32(vsub_f32(v5, vrndm_f32(v5)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  float32x2_t v12 = vminnm_f32(vmaxnm_f32(vadd_f32((float32x2_t)vdup_laneq_s32(a5, 2), vmul_lane_f32(vminnm_f32(vsub_f32(_D1, v6), v6), *(float32x2_t *)a5.i8, 1)), 0), _D1);
  __asm { FMOV            V2.2S, #3.0 }
  float32x2_t v14 = vmul_f32(v12, vmul_f32(v12, vsub_f32(_D2, vadd_f32(v12, v12))));
  _D1.f32[0] = fminf(v14.f32[0], v14.f32[1]) * 2.0 + 1.0 - vaddv_f32(v14);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a4, 1.0 - _D1.f32[0]), a3, _D1.f32[0]).u64[0];
  return result;
}

void CI::f4_f2_clr_clr_f3(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int8x16_t v11 = (double (*)(void *, double, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  uint64_t v16 = *(void *)(v10 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  int8x16_t v17 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    int8x16_t v17 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v18 = v11(a1, *v17, *((__n128 *)a2 + 4 * v14), *((__n128 *)a2 + 4 * v15), *((__n128 *)a2 + 4 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_circle(CI *a1, float32x4_t a2, float32x4_t a3)
{
  float v3 = a2.f32[2];
  float32x2_t v4 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a2.f32);
  float v5 = vmuls_lane_f32(v3 - sqrtf(vaddv_f32(vmul_f32(v4, v4))), a2, 3) + 0.5;
  float v6 = 1.0;
  if (v5 <= 1.0) {
    float v6 = v5;
  }
  BOOL v7 = v5 < 0.0;
  float v8 = 0.0;
  if (!v7) {
    float v8 = v6;
  }
  *(void *)&double result = vmulq_n_f32(a3, v8).u64[0];
  return result;
}

void CI::f4_f4_clr(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int8x16_t v11 = (double (*)(void *, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  uint64_t v15 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v15 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v16 = v11(a1, *v15, *((__n128 *)a2 + 4 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

float32x2_t cikernel::_circleSplash(CI *a1, float32x2_t a2, float a3)
{
  float32x2_t v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  float32x2_t v6 = vmul_f32(v5, v5);
  float32x2_t v7 = vadd_f32(v6, (float32x2_t)vdup_lane_s32((int32x2_t)v6, 1));
  float32x2_t v8 = vrsqrte_f32((float32x2_t)v7.u32[0]);
  float32x2_t v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v8, v8)));
  return vadd_f32(a2, vmul_n_f32(vmul_n_f32(v5, v9.f32[0]), fminf(vmul_f32(v7, v9).f32[0], a3)));
}

void CI::f2_f2_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int8x16_t v11 = (double (*)(void *, double, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 56)), a2);
  }
  uint64_t v15 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    uint64_t v15 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v15, *((float *)a2 + 16 * v14));
}

__n64 cikernel::_circularWrap(CI *a1, float32x2_t a2, float a3, float a4, float a5, float a6)
{
  float32x2_t v10 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  float32x2_t v11 = vmul_f32(v10, v10);
  float32x2_t v12 = vadd_f32(v11, (float32x2_t)vdup_lane_s32((int32x2_t)v11, 1));
  float32x2_t v13 = vrsqrte_f32((float32x2_t)v12.u32[0]);
  float32x2_t v14 = vmul_f32(v13, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v13, v13)));
  float32x2_t v15 = vmul_n_f32(v10, v14.f32[0]);
  float32x2_t v16 = vabs_f32(v15);
  float32x2_t v17 = vadd_f32(vmul_f32(vadd_f32(vmul_f32(vadd_f32(vmul_f32(v16, (float32x2_t)vdup_n_s32(0x3F667469u)), (float32x2_t)vdup_n_s32(0xBF32DEF3)), v16), (float32x2_t)vdup_n_s32(0x3F932752u)), v16), (float32x2_t)vdup_n_s32(0x3A9C2CD7u));
  int8x8_t v18 = vbsl_s8((int8x8_t)vcltz_f32(v15), (int8x8_t)vneg_f32(v17), (int8x8_t)v17);
  float v19 = *(float *)&v18.i32[1];
  if (v15.f32[0] < 0.0)
  {
    float v20 = 3.1415927 - *(float *)&v18.i32[1];
    float v19 = v20;
  }
  double v21 = *(float *)v18.i32;
  double v22 = v21 + -1.5707963;
  double v23 = 1.5707963 - v21;
  if (v15.f32[1] >= 0.0) {
    double v24 = v23;
  }
  else {
    double v24 = v22;
  }
  float v25 = v24;
  if ((vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16).u8[0] & 1) == 0) {
    float v25 = v19;
  }
  float v26 = (float)(v25 - a6) * 0.15915494;
  float v27 = (float)(v26 - floorf(v26)) * 6.2831853;
  result.n64_f32[0] = a5 + (float)(v27 * a4);
  result.n64_f32[1] = vmul_f32(v12, v14).f32[0] + a3;
  return result;
}

void CI::f2_f2_f_f_f_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  float32x2_t v11 = (double (*)(void *, double, float, float, float, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  uint64_t v16 = *(void *)(v10 + 80);
  uint64_t v17 = *(void *)(v10 + 104);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 128)), a2);
  }
  int8x8_t v18 = (double *)(a3 + 16 * v13);
  if (v12 != 5) {
    int8x8_t v18 = (double *)((char *)a2 + 64 * v13);
  }
  *(double *)(a3 + 16 * a7) = v11(a1, *v18, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
}

double cikernel::_colorAbsDiff(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2 = vabdq_f32(a1, a2);
  v2.i32[3] = a1.i32[3];
  *(void *)&double result = vmulq_laneq_f32(v2, a2, 3).u64[0];
  return result;
}

__n128 cikernel::_colorbalance(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  unsigned __int32 v10 = a1.u32[3];
  float32x4_t v3 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1939507A0, a1, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193950790, *(float32x2_t *)a1.f32, 1), vmulq_n_f32((float32x4_t)xmmword_193950780, a1.f32[0])));
  int8x16_t v11 = (int8x16_t)v3;
  v3.f32[0] = fmaxf(a2.f32[3], 0.00001);
  float32x4_t v4 = vdivq_f32(a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 0));
  v4.i32[3] = 0;
  simd_float4 v5 = (simd_float4)vmaxnmq_f32(v4, (float32x4_t)0);
  v5.i32[3] = 0;
  float32x4_t v6 = (float32x4_t)_simd_pow_f4(v5, (simd_float4)xmmword_1939507B0);
  int8x16_t v7 = (int8x16_t)vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1939507E0, v6, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1939507D0, *(float32x2_t *)v6.f32, 1), vmulq_n_f32((float32x4_t)xmmword_1939507C0, v6.f32[0])));
  result.n128_u64[0] = (unint64_t)vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 4uLL), vmul_n_f32(vmul_laneq_f32(vsub_f32(*(float32x2_t *)a3.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 4uLL)), a3, 2), powf(*(float *)v11.i32, a3.f32[3])));
  result.n128_u64[0] = vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_193950800, (float32x2_t)result.n128_u64[0], 1), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 0), vmulq_n_f32((float32x4_t)xmmword_1939507F0, result.n128_f32[0]))).u64[0];
  result.n128_u32[3] = v10;
  return result;
}

void CI::f4_s_clr_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int8x16_t v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  uint64_t v17 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    uint64_t v17 = (__n128 *)((char *)a2 + 64 * v16);
  }
  int8x8_t v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    int8x8_t v18 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v19 = v11(a1, *v18, *((__n128 *)a2 + 4 * v14), *v17);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_colorClamp(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  *(void *)&double result = vminnmq_f32(vmaxnmq_f32(a1, a2), a3).u64[0];
  return result;
}

void CI::f4_s_f4_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int8x16_t v11 = (double (*)(void *, __n128, __n128, __n128))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  int v16 = *(_DWORD *)(v10 + 64);
  uint64_t v17 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  int8x8_t v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x8_t v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  long long v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    long long v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  float v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float v20 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double cikernel::_colorClampAP(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  *(void *)&double result = vminnmq_f32(vmaxnmq_f32(a1, a2), a3).u64[0];
  return result;
}

CIImage *_imageByApplyingColorMatrix(void *a1, float a2, float a3, float a4, float a5, float a6, float a7, double a8, double a9, float a10, float a11, float a12, float a13, float a14, float a15)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  [a1 extent];
  if (CGRectIsEmpty(v38))
  {
    return +[CIImage emptyImage];
  }
  else
  {
    v29[0] = a2;
    v29[1] = a3;
    v29[2] = a4;
    v29[3] = 0.0;
    v29[4] = a5;
    v29[5] = a6;
    v29[6] = a7;
    v29[7] = 0.0;
    void v29[8] = a10;
    v29[9] = a11;
    v29[10] = a12;
    v29[11] = 0.0;
    long long v30 = xmmword_193950890;
    long long v31 = unk_1939508A0;
    double v32 = a13;
    double v33 = a14;
    double v34 = a15;
    uint64_t v35 = 0;
    if (!CI::ColorMatrixImage::is_identity((CI::ColorMatrixImage *)v29, v26))
    {
      [a1 _internalRepresentation];
      operator new();
    }
    return (CIImage *)a1;
  }
}

void sub_19371399C(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40112EC1AALL);
  _Unwind_Resume(a1);
}

double cikernel::_colorcube(uint64x2_t *a1, float32x4_t a2, int8x16_t a3, double a4, double a5, int8x16_t a6, int8x16_t a7, int8x16_t a8)
{
  a2.i32[3] = 0;
  float32x4_t v10 = vmaxnmq_f32(a2, (float32x4_t)xmmword_1939508B0);
  v10.i32[3] = 0;
  float32x4_t v11 = vmulq_n_f32(vminnmq_f32(v10, (float32x4_t)xmmword_19394CBC0), *(float *)a3.i32);
  float v12 = v11.f32[2];
  float v13 = floorf(v11.f32[2]);
  *(float32x2_t *)v11.f32 = vadd_f32(*(float32x2_t *)v11.f32, (float32x2_t)0x3F0000003F000000);
  *(double *)a6.i64 = *(float *)a3.i32 + 1.0;
  *(float *)&__int32 v14 = *(double *)a6.i64 * v13;
  a7.i32[0] = 0;
  a8.i32[0] = 0;
  a8.i32[1] = v14;
  float32x2_t v15 = vadd_f32(*(float32x2_t *)v11.f32, *(float32x2_t *)a8.i8);
  *(double *)a2.i64 = *(double *)a6.i64 * fminf(v13 + 1.0, *(float *)a3.i32);
  a2.f32[0] = *(double *)a2.i64;
  a7.i32[1] = a2.i32[0];
  float32x2_t v16 = vadd_f32(*(float32x2_t *)v11.f32, *(float32x2_t *)a7.i8);
  float32x2_t v26 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(double *)v17.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v26, v15)), (float64x2_t)a3, *(double *)&v15, *(double *)a2.i64, a6, a7, a8);
  float32x4_t v27 = v17;
  *(double *)v24.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v26, v16)), v18, v19, v20, v21, v22, v23);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v27, 1.0 - (float)(v12 - v13)), v24, v12 - v13).u64[0];
  return result;
}

void CI::f4_s_sr2d_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  float32x4_t v11 = *(double (**)(uint64_t, __n128, __n128))(a1 + 24);
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *((void *)a2 + 8 * *(void *)(v10 + 32));
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  float32x4_t v17 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x4_t v17 = (__n128 *)((char *)a2 + 64 * v16);
  }
  float64x2_t v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    float64x2_t v18 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v19 = v11(v14, *v18, *v17);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_colorcubeopaque(uint64x2_t *a1, float32x4_t a2, int8x16_t a3, double a4, double a5, int8x16_t a6, int8x16_t a7, int8x16_t a8)
{
  a2.i32[3] = 0;
  float32x4_t v10 = vmaxnmq_f32(a2, (float32x4_t)xmmword_1939508B0);
  v10.i32[3] = 0;
  float32x4_t v11 = vmulq_n_f32(vminnmq_f32(v10, (float32x4_t)xmmword_19394CBC0), *(float *)a3.i32);
  float v12 = v11.f32[2];
  float v13 = floorf(v11.f32[2]);
  *(float32x2_t *)v11.f32 = vadd_f32(*(float32x2_t *)v11.f32, (float32x2_t)0x3F0000003F000000);
  *(double *)a6.i64 = *(float *)a3.i32 + 1.0;
  *(float *)&__int32 v14 = *(double *)a6.i64 * v13;
  a7.i32[0] = 0;
  a8.i32[0] = 0;
  a8.i32[1] = v14;
  float32x2_t v15 = vadd_f32(*(float32x2_t *)v11.f32, *(float32x2_t *)a8.i8);
  *(double *)a2.i64 = *(double *)a6.i64 * fminf(v13 + 1.0, *(float *)a3.i32);
  a2.f32[0] = *(double *)a2.i64;
  a7.i32[1] = a2.i32[0];
  float32x2_t v16 = vadd_f32(*(float32x2_t *)v11.f32, *(float32x2_t *)a7.i8);
  float32x2_t v26 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(double *)v17.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v26, v15)), (float64x2_t)a3, *(double *)&v15, *(double *)a2.i64, a6, a7, a8);
  float32x4_t v27 = v17;
  *(double *)v24.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v26, v16)), v18, v19, v20, v21, v22, v23);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v27, 1.0 - (float)(v12 - v13)), v24, v12 - v13).u64[0];
  return result;
}

double cikernel::_colorcubeopaque_extend(uint64x2_t *a1, float32x4_t a2, int8x16_t a3, double a4, double a5, double a6, double a7, int8x16_t a8)
{
  float32x4_t v11 = (float32x4_t)vdupq_n_s32(0xBE99999A);
  float32x4_t v12 = vaddq_f32(a2, v11);
  float32x4_t v13 = vmulq_f32(v12, v12);
  a2.i32[3] = 0;
  float32x4_t v14 = vmaxnmq_f32(a2, (float32x4_t)0);
  v14.i32[3] = 0;
  v15.i64[1] = 1065353216;
  float32x4_t v16 = vaddq_f32(vminnmq_f32(v14, (float32x4_t)xmmword_1939508C0), v11);
  float32x4_t v17 = vmulq_f32(v16, v16);
  float v58 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0]);
  float32x4_t v18 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1)));
  v18.f32[0] = sqrtf(v18.f32[0]);
  float32x4_t v57 = v18;
  float32x4_t v19 = vmaxnmq_f32(a2, (float32x4_t)xmmword_1939508B0);
  v19.i32[3] = 0;
  v13.i64[1] = 1065353048;
  float32x4_t v20 = vmulq_n_f32(vminnmq_f32(v19, (float32x4_t)xmmword_19394CBC0), *(float *)a3.i32);
  float v21 = v20.f32[2];
  float v22 = floorf(v20.f32[2]);
  *(float32x2_t *)v20.f32 = vadd_f32(*(float32x2_t *)v20.f32, (float32x2_t)0x3F0000003F000000);
  v15.i64[0] = 1.0;
  double v23 = *(float *)a3.i32 + 1.0;
  v13.f32[0] = v23 * v22;
  a2.i32[0] = 0;
  a2.i32[1] = v13.i32[0];
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)a2.f32);
  *(double *)v14.i64 = v23 * fminf(v22 + 1.0, *(float *)a3.i32);
  v14.f32[0] = *(double *)v14.i64;
  a2.i32[0] = 0;
  a2.i32[1] = v14.i32[0];
  float32x2_t v24 = vadd_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)a2.f32);
  float v53 = *(float *)a3.i32;
  float32x2_t v59 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(double *)v25.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v59, *(float32x2_t *)v13.f32)), (float64x2_t)v13, *(double *)v14.i64, *(double *)a2.i64, v15, a3, a8);
  float32x4_t v55 = v25;
  *(double *)v32.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v59, v24)), v26, v27, v28, v29, v30, v31);
  float32x4_t v36 = vmlaq_n_f32(vmulq_n_f32(v55, 1.0 - (float)(v21 - v22)), v32, v21 - v22);
  *(void *)&v37.f64[1] = v57.i64[1];
  if (v58 > v57.f32[0])
  {
    float32x4_t v38 = vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3E99999Au), v53);
    float v39 = v38.f32[2];
    float v40 = floorf(v38.f32[2]);
    float32x4_t v56 = v36;
    *(float32x2_t *)v38.f32 = vadd_f32(*(float32x2_t *)v38.f32, (float32x2_t)0x3F0000003F000000);
    *(float *)v37.f64 = v23 * v40;
    LODWORD(v41) = 0;
    HIDWORD(v41) = LODWORD(v37.f64[0]);
    *(float32x2_t *)&v37.f64[0] = vadd_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)&v41);
    double v42 = v23 * fminf(v40 + 1.0, v53);
    *(float *)&double v42 = v42;
    LODWORD(v41) = 0;
    HIDWORD(v41) = LODWORD(v42);
    float32x2_t v43 = vadd_f32(*(float32x2_t *)v38.f32, *(float32x2_t *)&v41);
    *(double *)v44.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v59, *(float32x2_t *)&v37.f64[0])), v37, v42, v41, v33, v34, v35);
    float32x4_t v54 = v44;
    *(double *)v51.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v59, v43)), v45, v46, v47, v48, v49, v50);
    float32x4_t v36 = vmlaq_n_f32(vmulq_n_f32(v54, 1.0 - (float)(v39 - v40)), v51, v39 - v40);
    v36.i64[0] = vaddq_f32(v36, vdivq_f32(vmulq_n_f32(vsubq_f32(v56, v36), v58), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 0))).u64[0];
  }
  return *(double *)v36.i64;
}

double cikernel::_headroomToneMap(float32x4_t a1, float a2, float a3, float a4, float32x4_t a5)
{
  float v5 = fmaxf(fmaxf(a1.f32[0], a1.f32[1]), a1.f32[2]);
  if (v5 > 1.0)
  {
    float v6 = (float)(a5.f32[2] + sqrtf(fmaxf(vmlas_n_f32(a5.f32[1], v5, a5.f32[0]), 0.0))) / a5.f32[0];
    float v7 = a4 + vmuls_lane_f32(v6, a5, 3) * (v6 + -2.0);
    if (v5 >= a2) {
      float v8 = a3;
    }
    else {
      float v8 = v7;
    }
    a4 = fminf(v8 / v5, 1.0);
  }
  *(void *)&double result = vmulq_n_f32(a1, a4).u64[0];
  return result;
}

void calcUniforms(float a1@<S0>, float a2@<S1>, uint64_t a3@<X8>)
{
  BOOL v3 = (LODWORD(a2) & 0x7FFFFFFF) == 0x7F800000 || (LODWORD(a2) & 0x7FFFFFFF) == 0;
  float v4 = fabsf(a1);
  if (v3 || v4 == INFINITY)
  {
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    return;
  }
  if (a1 == 0.0)
  {
    *(_DWORD *)a3 = 1;
    *(float *)(a3 + 4) = a2;
    *(float *)(a3 + _Block_object_dispose(&STACK[0x3A0], 8) = a2;
LABEL_20:
    *(void *)(a3 + 2CI::NodeWithChildren::NodeWithChildren(this, 0) = 0;
    *(void *)(a3 + 12) = 0;
    *(_DWORD *)(a3 + 2_Block_object_dispose(&STACK[0x3A0], 8) = 0;
    return;
  }
  if (a1 <= a2)
  {
    *(_DWORD *)a3 = 1;
    *(float *)(a3 + 4) = a1;
    *(float *)(a3 + _Block_object_dispose(&STACK[0x3A0], 8) = a1;
    goto LABEL_20;
  }
  float v6 = fminf((float)((float)(fminf((float)(a1 + -1.0) / 3.9261, 1.0) * -0.5) + 1.0) + (float)((float)(a2 + -1.0) * 0.29999), 1.0);
  float v7 = a2 / v6;
  float v8 = (float)(a2 * 0.001) / 3.0;
  float v9 = (float)(a1 + 1.0) + (float)((float)(a2 / v6) * -2.0);
  float v10 = fabsf(v9);
  float v11 = (float)(v8 - v9) + a1;
  BOOL v12 = v10 > v8;
  if (v10 <= v8) {
    float v13 = (float)(v8 - v9) + a1;
  }
  else {
    float v13 = a1;
  }
  if (!v12) {
    float v9 = (float)(v11 + 1.0) + (float)((float)(a2 / v6) * -2.0);
  }
  *(_DWORD *)a3 = 2;
  *(float *)(a3 + 4) = a1;
  *(float *)(a3 + _Block_object_dispose(&STACK[0x3A0], 8) = a2;
  *(float *)(a3 + 12) = v6;
  *(float *)(a3 + 16) = v9;
  *(float *)(a3 + 2CI::NodeWithChildren::NodeWithChildren(this, 0) = -(float)(v13 - (float)(v7 * v7));
  *(float *)(a3 + 24) = 1.0 - v7;
  *(float *)(a3 + 2_Block_object_dispose(&STACK[0x3A0], 8) = v6 - a2;
}

id ___ZL12defaultTablev_block_invoke()
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  int v7 = 0;
  uint64_t v6 = 0;
  long long v8 = xmmword_1939509C0;
  __asm { FMOV            V0.2S, #1.0 }
  uint64_t v9 = _D0;
  id result = (id)[MEMORY[0x1E4F1C9B8] dataWithBytes:&v6 length:36];
  defaultTable(void)::datCGFloat a = (uint64_t)result;
  return result;
}

double cikernel::_colorcurves(uint64x2_t *a1, float32x4_t a2, int32x2_t a3, double a4, double a5, int8x16_t a6, int8x16_t a7, int8x16_t a8)
{
  *(int32x2_t *)a6.i8 = vdup_lane_s32(a3, 1);
  float32x4_t v9 = vsubq_f32(a2, (float32x4_t)vdupq_lane_s32(a3, 0));
  float32x4_t v10 = (float32x4_t)vdupq_lane_s32((int32x2_t)vsub_f32(*(float32x2_t *)a6.i8, (float32x2_t)a3), 0);
  float32x4_t v26 = vdivq_f32(v9, v10);
  v10.i32[0] = HIDWORD(a4);
  float32x4_t v28 = v10;
  v10.f32[0] = vmlas_n_f32(*((float *)&a4 + 1), v26.f32[0], *(float *)&a4);
  double v11 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(v10.u32[0] | 0x3F00000000000000), (float64x2_t)v10, a4, *(double *)v9.i64, a6, a7, a8);
  unsigned int v25 = LODWORD(v11);
  float64x2_t v12 = (float64x2_t)v28;
  *(float *)v12.f64 = vmlas_n_f32(v28.f32[0], v26.f32[1], *(float *)&a4);
  double v17 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(LODWORD(v12.f64[0]) | 0x3F00000000000000), v12, a4, v13, v14, v15, v16);
  unsigned int v24 = HIDWORD(v17);
  float64x2_t v18 = (float64x2_t)v28;
  *(float *)v18.f64 = vmlas_n_f32(v28.f32[0], v26.f32[2], *(float *)&a4);
  CI::BitmapSampler::read(a1, COERCE_DOUBLE(LODWORD(v18.f64[0]) | 0x3F00000000000000), v18, a4, v19, v20, v21, v22);
  return COERCE_DOUBLE(__PAIR64__(v24, v25));
}

void CI::f4_s_sr2d_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float32x4_t v10 = *(double (**)(uint64_t, __n128, double, double))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *((void *)a2 + 8 * *(void *)(v9 + 32));
  uint64_t v13 = *(void *)(v9 + 8);
  int v14 = *(_DWORD *)(v9 + 64);
  uint64_t v15 = *(void *)(v9 + 56);
  int v16 = *(_DWORD *)(v9 + 88);
  uint64_t v17 = *(void *)(v9 + 80);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 104)), a2);
  }
  float64x2_t v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    float64x2_t v18 = (double *)((char *)a2 + 64 * v17);
  }
  double v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    double v19 = (double *)((char *)a2 + 64 * v15);
  }
  int8x16_t v20 = (__n128 *)(a3 + 16 * v13);
  if (v11 != 5) {
    int8x16_t v20 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v21 = v10(v12, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

void CI::f4_s_f_f_f_f4(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = a1[6];
  float32x4_t v10 = (double (*)(void *, __n128, float, float, float, __n128))a1[3];
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  uint64_t v13 = *(void *)(v9 + 32);
  uint64_t v14 = *(void *)(v9 + 56);
  uint64_t v15 = *(void *)(v9 + 80);
  int v16 = *(_DWORD *)(v9 + 112);
  uint64_t v17 = *(void *)(v9 + 104);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
  }
  float64x2_t v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    float64x2_t v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  double v19 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    double v19 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v20 = v10(a1, *v19, *((float *)a2 + 16 * v13), *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_headroomClamp(float32x4_t a1, float a2, double a3)
{
  *(float *)&a3 = fmaxf(fmaxf(a1.f32[0], a1.f32[1]), a1.f32[2]);
  if (*(float *)&a3 > a2) {
    a1.i64[0] = vdivq_f32(vmulq_n_f32(a1, a2), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0)).u64[0];
  }
  return *(double *)a1.i64;
}

float32x4_t cikernel::_linearToAppleLog(float32x4_t a1)
{
  float32x4_t result = (float32x4_t)_simd_log2_f4((simd_float4)vaddq_f32(a1, (float32x4_t)vdupq_n_s32(0x3C1DF346u)));
  float32x4_t v1 = vaddq_f32(a1, (float32x4_t)vdupq_n_s32(0x3D670F18u));
  result.i64[0] = vbslq_s8((int8x16_t)vcltzq_f32(vaddq_f32(a1, (float32x4_t)vdupq_n_s32(0xBC23D70A))), vbslq_s8((int8x16_t)vcltzq_f32(v1), (int8x16_t)0, (int8x16_t)vmulq_f32(v1, vmulq_f32(v1, (float32x4_t)vdupq_n_s32(0x423D2601u)))), (int8x16_t)vaddq_f32(vmulq_f32(result, (float32x4_t)vdupq_n_s32(0x3DAF1D23u)), (float32x4_t)vdupq_n_s32(0x3F3180A9u))).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_appleLogToLinear(float32x4_t a1)
{
  unsigned __int32 v4 = a1.u32[3];
  simd_float4 v1 = (simd_float4)vdivq_f32(vaddq_f32(a1, (float32x4_t)vdupq_n_s32(0xBF3180A9)), (float32x4_t)vdupq_n_s32(0x3DAF1D23u));
  v2.i64[0] = 0x4000000040000000;
  v2.i64[1] = 0x4000000040000000;
  float32x4_t result = (float32x4_t)_simd_pow_f4(v2, v1);
  result.i64[0] = vaddq_f32(result, (float32x4_t)vdupq_n_s32(0xBC1DF346)).u64[0];
  result.i32[3] = v4;
  return result;
}

double cikernel::_colorMonochrome(float32x4_t a1, float32x4_t a2, float a3)
{
  float32x4_t v3 = vmulq_f32(a1, (float32x4_t)xmmword_193950A90);
  v3.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0];
  float32x4_t v4 = vmulq_n_f32(a2, v3.f32[0] + v3.f32[0]);
  __asm { FMOV            V7.4S, #1.0 }
  float32x4_t v9 = vmulq_n_f32(vsubq_f32(_Q7, a2), 1.0 - v3.f32[0]);
  float32x4_t v10 = vaddq_f32(v9, v9);
  v3.f32[0] = v3.f32[0] + -0.5;
  _NF = v3.f32[0] < 0.0;
  unint64_t v12 = 16843008;
  if (v3.f32[0] >= 0.0) {
    unint64_t v12 = 0;
  }
  int64x2_t v13 = vdupq_n_s64(v12);
  int v14 = _NF;
  int8x8_t v15 = (int8x8_t)vmovn_s64(vtstq_s64(v13, (int64x2_t)xmmword_193950AA0));
  __int8 v16 = v15.i8[0];
  v15.i32[0] = v14;
  *(float32x2_t *)v17.f32 = vcvt_f32_u32((uint32x2_t)vand_s8(v15, (int8x8_t)0x100000001));
  v17.f32[2] = (float)(v16 & 1);
  v17.i32[3] = v17.i32[0];
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a3), vmlaq_f32(vmulq_f32(vsubq_f32(_Q7, v10), vsubq_f32(_Q7, v17)), v17, v4), a3).u64[0];
  return result;
}

void CI::f4_s_clr_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  int v11 = (double (*)(void *, __n128, __n128, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  uint64_t v14 = *(void *)(v10 + 32);
  uint64_t v15 = *(void *)(v10 + 56);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 80)), a2);
  }
  __int8 v16 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    __int8 v16 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v17 = v11(a1, *v16, *((__n128 *)a2 + 4 * v14), *((float *)a2 + 16 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

void cikernel::_palettize(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v9, COERCE_FLOAT(*DC));
  *(float *)&double v12 = *((float *)this + 6) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v13, v8, v9, v11, v10, v14);
  float32x4_t v34 = v15;
  LODWORD(v16) = *((_DWORD *)a2 + 7);
  v15.f32[0] = *((float *)a2 + 6) + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)(*((float *)a2 + 4) * 0.5));
  LODWORD(v17) = *((_DWORD *)a2 + 9);
  *(float *)v18.f64 = *(float *)&v17 + (float)((float)(*((float *)a2 + 8) * 0.5) + (float)(*(float *)&v16 * 0.5));
  v15.f32[1] = *(float *)v18.f64;
  *(double *)v22.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v15.i64, v18, v16, v17, v19, v20, v21);
  if (a4 > 1.0)
  {
    HIDWORD(v26) = v34.i32[1];
    float32x4_t v27 = vsubq_f32(v34, v22);
    int8x16_t v28 = (int8x16_t)vmulq_f32(v27, v27);
    float32x4_t v29 = (float32x4_t)vextq_s8(v28, v28, 8uLL);
    *(float32x2_t *)v29.f32 = vadd_f32(*(float32x2_t *)v28.i8, *(float32x2_t *)v29.f32);
    *(float *)v24.i32 = vaddv_f32(*(float32x2_t *)v29.f32);
    float v30 = 1.0;
    do
    {
      float32x4_t v35 = (float32x4_t)v24;
      int8x16_t v36 = (int8x16_t)v22;
      v28.i32[0] = *((_DWORD *)a2 + 6);
      v24.i32[0] = *((_DWORD *)a2 + 9);
      *(float *)v23.i32 = *((float *)a2 + 8) * 0.5;
      *(float *)&double v26 = *(float *)v23.i32 + (float)((float)(v30 + 0.5) * *((float *)a2 + 7));
      *(float *)&double v31 = *(float *)v28.i32
                     + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)((float)(v30 + 0.5) * *((float *)a2 + 4)));
      v29.f32[0] = *(float *)v24.i32 + *(float *)&v26;
      *((float *)&v31 + 1) = *(float *)v24.i32 + *(float *)&v26;
      *(double *)v32.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v31, (float64x2_t)v29, *(double *)v28.i64, v26, v23, v24, v25);
      HIDWORD(v26) = v34.i32[1];
      int8x16_t v24 = (int8x16_t)v35;
      float32x4_t v33 = vsubq_f32(v34, v32);
      float32x4_t v29 = vmulq_f32(v33, v33);
      *(float32x2_t *)v29.f32 = vadd_f32(*(float32x2_t *)v29.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v29, (int8x16_t)v29, 8uLL));
      v29.f32[0] = vaddv_f32(*(float32x2_t *)v29.f32);
      int8x16_t v28 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v35, v29), 0);
      int8x16_t v23 = vbslq_s8(v28, (int8x16_t)v32, v36);
      float32x4_t v22 = (float32x4_t)v23;
      if (v29.f32[0] < v35.f32[0]) {
        *(float *)v24.i32 = v29.f32[0];
      }
      float v30 = v30 + 1.0;
    }
    while (v30 < a4);
  }
}

void CI::f4_sr_sr_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int8x16_t v11 = *(void **)(a1 + 48);
  double v12 = *(double (**)(uint64_t, uint64_t, float))(a1 + 24);
  uint64_t v13 = v11[1];
  uint64_t v14 = v11[4];
  uint64_t v15 = v11[7];
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * v11[10]), a2);
  }
  *(double *)&long long v16 = v12(a4 + 80 * v13, a4 + 80 * v14, *((float *)a2 + 16 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

double cikernel::_ddither(float32x4_t a1, int32x4_t a2, float a3)
{
  double v3 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vaddq_f32((float32x4_t)a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 1)))).f32[0]* 0.25+ -0.5;
  *(float *)&double v3 = v3;
  *(float *)&double v3 = *(float *)&v3 * a3;
  *(void *)&double result = vaddq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v3, 0)).u64[0];
  return result;
}

double cikernel::_shadowdesat(float32x4_t a1, float a2, double a3, float a4)
{
  float32x4_t v4 = vmulq_f32(a1, (float32x4_t)xmmword_193950AB0);
  float v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0];
  float v6 = (float)(v5 - (float)(a2 * a4)) / (float)(a2 - (float)(a2 * a4));
  if (v6 <= 1.0) {
    float v7 = v6;
  }
  else {
    float v7 = 1.0;
  }
  BOOL v8 = v6 < 0.0;
  float v9 = 0.0;
  if (!v8) {
    float v9 = v7;
  }
  *(float *)&a3 = (float)(1.0 - (float)((float)(v9 * v9) * (float)((float)(v9 * -2.0) + 3.0))) * *(float *)&a3;
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - *(float *)&a3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), v5).u64[0];
  return result;
}

double cikernel::_colorMap(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v9, COERCE_FLOAT(*DC));
  *(float *)&double v12 = *((float *)this + 6) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v13, v8, v9, v11, v10, v14);
  float32x4_t v29 = v15;
  LODWORD(v19.f64[0]) = 1.0;
  float32x4_t v20 = vmulq_n_f32(v15, 1.0 / fmaxf(v15.f32[3], 0.00001));
  float32x4_t v21 = vmulq_f32(v20, (float32x4_t)xmmword_193950A90);
  float32x4_t v22 = vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1));
  float v23 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), v22).f32[0];
  if (v23 <= 1.0) {
    *(float *)v19.f64 = v23;
  }
  BOOL v24 = v23 < 0.0;
  float v25 = 0.0;
  if (!v24) {
    float v25 = *(float *)v19.f64;
  }
  v22.f32[0] = (float)(v25 * a4) + 0.5;
  v16.i32[0] = *((_DWORD *)a2 + 7);
  *(float *)&double v26 = *((float *)a2 + 6)
                 + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)(v22.f32[0] * *((float *)a2 + 4)));
  v20.i32[0] = *((_DWORD *)a2 + 8);
  v17.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)v19.f64 = *(float *)v17.i32 + (float)((float)(v20.f32[0] * 0.5) + (float)(v22.f32[0] * *(float *)v16.i32));
  *((float *)&v26 + 1) = *(float *)v19.f64;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v26, v19, *(double *)v22.i64, *(double *)v20.i64, v16, v17, v18);
  *(void *)&double result = vmulq_laneq_f32(v27, v29, 3).u64[0];
  return result;
}

double cikernel::_ciSingleChannelColorMap(cikernel *this, SamplerObj *a2, SamplerObj *a3)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v7, COERCE_FLOAT(*DC));
  *(float *)&double v10 = *((float *)this + 6) + *(float *)&v6;
  *(float *)v11.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *((float *)&v10 + 1) = *(float *)v8.i32 + *(float *)v9.i32;
  double v13 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v10, v11, v6, v7, v9, v8, v12);
  LODWORD(v19.f64[0]) = 1132396544;
  if (*(float *)&v13 <= 1.0) {
    *(float *)v19.f64 = 255.0 * *(float *)&v13;
  }
  if (*(float *)&v13 < 0.0) {
    *(float *)v19.f64 = 0.0;
  }
  LODWORD(v15) = 0.5;
  v16.i32[0] = *((_DWORD *)a2 + 7);
  *(float *)&double v20 = *((float *)a2 + 6)
                 + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)(*(float *)v19.f64 * *((float *)a2 + 4)));
  v17.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)&double v14 = *((float *)a2 + 8) * 0.5;
  *(float *)v19.f64 = *(float *)v17.i32 + (float)(*(float *)&v14 + (float)(*(float *)v19.f64 * *(float *)v16.i32));
  HIDWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = LODWORD(v19.f64[0]);
  float32x4_t v21 = (uint64x2_t *)*((void *)a2 + 1);

  return CI::BitmapSampler::read(v21, v20, v19, v14, v15, v16, v17, v18);
}

void CI::f4_sr_sr(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  double v10 = *(void **)(a1 + 48);
  float64x2_t v11 = *(double (**)(uint64_t, uint64_t))(a1 + 24);
  uint64_t v12 = v10[1];
  uint64_t v13 = v10[4];
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * v10[7]), a2);
  }
  *(double *)&long long v14 = v11(a4 + 80 * v12, a4 + 80 * v13);
  *(_OWORD *)(a3 + 16 * a7) = v14;
}

double cikernel::_ciExtractChannel(__n128 a1, float a2)
{
  int v2 = (int)a2;
  if ((int)a2 >= 3) {
    LOBYTE(v2) = 3;
  }
  __n128 v4 = a1;
  *(void *)&double result = *(unsigned int *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF3 | (4 * (v2 & 3)));
  return result;
}

double cikernel::_colorPolynomial(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  *(void *)&double result = vaddq_f32(a2, vmulq_f32(a1, vaddq_f32(a3, vmulq_f32(a1, vaddq_f32(a4, vmulq_f32(a1, a5)))))).u64[0];
  return result;
}

void CI::f4_s_f4_f4_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  double v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  int v19 = *(_DWORD *)(v9 + 112);
  uint64_t v20 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v28 = *(_DWORD *)(v9 + 88);
    int v29 = *(_DWORD *)(v9 + 40);
    int v27 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v15 = v27;
    int v17 = v28;
    int v13 = v29;
  }
  float32x4_t v21 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    float32x4_t v21 = (__n128 *)((char *)a2 + 64 * v20);
  }
  float32x4_t v22 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    float32x4_t v22 = (__n128 *)((char *)a2 + 64 * v18);
  }
  float v23 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    float v23 = (__n128 *)((char *)a2 + 64 * v16);
  }
  BOOL v24 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    BOOL v24 = (__n128 *)((char *)a2 + 64 * v14);
  }
  float v25 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float v25 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v26 = v10(*v25, *v24, *v23, *v22, *v21);
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

double cikernel::_colorPolynomialRGB(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  *(void *)&double result = vaddq_f32(a2, vmulq_f32(a1, vaddq_f32(a3, vmulq_f32(a1, vaddq_f32(a4, vmulq_f32(a1, a5)))))).u64[0];
  return result;
}

__n64 cikernel::_colorPolynomialInverse(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float32x4_t v5 = vmulq_f32(a4, a4);
  float32x4_t v6 = vmulq_f32(a4, v5);
  float32x4_t v7 = v5;
  float32x4_t v28 = v5;
  __asm { FMOV            V5.4S, #27.0 }
  float32x4_t v35 = vsubq_f32(a1, a2);
  __asm { FMOV            V0.4S, #9.0 }
  float32x4_t v14 = vsubq_f32(vaddq_f32(vmulq_f32(a5, vmulq_f32(a4, vmulq_f32(a3, _Q0))), vmulq_f32(v35, vmulq_f32(a5, vmulq_f32(a5, _Q5)))), vaddq_f32(v6, v6));
  __asm { FMOV            V1.4S, #3.0 }
  float32x4_t v29 = _Q1;
  float32x4_t v16 = vsubq_f32(vmulq_f32(vmulq_f32(a3, _Q1), a5), v7);
  __asm { FMOV            V3.4S, #4.0 }
  float32x4_t v32 = _Q3;
  float32x4_t v18 = vaddq_f32(v14, vsqrtq_f32(vaddq_f32(vmulq_f32(v16, vmulq_f32(v16, vmulq_f32(v16, _Q3))), vmulq_f32(v14, v14))));
  v16.i64[0] = 0x3F0000003F000000;
  v16.i64[1] = 0x3F0000003F000000;
  float32x4_t v19 = (float32x4_t)_simd_pow_f4((simd_float4)vmulq_f32(v18, v16), (simd_float4)vdupq_n_s64(0x3EAAAAAB3EAAAAABuLL));
  float32x4_t v21 = vmulq_f32(a5, v29);
  int8x16_t v22 = (int8x16_t)vsubq_f32(vsubq_f32(vdivq_f32(v19, v21), vdivq_f32(vsubq_f32(a3, vdivq_f32(v28, v21)), v19)), vdivq_f32(a4, v21));
  int8x16_t v23 = (int8x16_t)vdivq_f32(vsubq_f32(vsqrtq_f32(vsubq_f32(vmulq_f32(a3, a3), vmulq_f32(vsubq_f32(a2, a1), vmulq_f32(a4, v32)))), a3), vaddq_f32(a4, a4));
  int8x16_t v24 = (int8x16_t)vdivq_f32(v35, a3);
  float32x4_t v25 = (float32x4_t)v22;
  if (a5.f32[1] == 0.0)
  {
    v25.i64[0] = 0;
    float32x4_t v25 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 1), v25), 0), v24, v23);
  }
  if (a5.f32[3] == 0.0) {
    float32x4_t v20 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a4, 3);
  }
  v20.i64[0] = 0;
  result.n64_u32[0] = vbslq_s8((int8x16_t)vceqq_f32(a5, v20), vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(a4, v20), 0), v24, v23), v22).u32[0];
  result.n64_u32[1] = v25.u32[1];
  return result;
}

__n64 cikernel::_colorPolynomialInverseRGB(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float32x4_t v5 = vmulq_f32(a4, a4);
  float32x4_t v6 = vmulq_f32(a4, v5);
  float32x4_t v7 = v5;
  float32x4_t v29 = v5;
  __asm { FMOV            V5.4S, #27.0 }
  float32x4_t v36 = vsubq_f32(a1, a2);
  float32x4_t v13 = vmulq_f32(v36, vmulq_f32(a5, vmulq_f32(a5, _Q5)));
  __asm { FMOV            V5.4S, #9.0 }
  float32x4_t v15 = vsubq_f32(vaddq_f32(vmulq_f32(a5, vmulq_f32(a4, vmulq_f32(a3, _Q5))), v13), vaddq_f32(v6, v6));
  __asm { FMOV            V1.4S, #3.0 }
  float32x4_t v30 = _Q1;
  float32x4_t v17 = vsubq_f32(vmulq_f32(vmulq_f32(a3, _Q1), a5), v7);
  __asm { FMOV            V3.4S, #4.0 }
  float32x4_t v32 = _Q3;
  float32x4_t v19 = vaddq_f32(v15, vsqrtq_f32(vaddq_f32(vmulq_f32(v17, vmulq_f32(v17, vmulq_f32(v17, _Q3))), vmulq_f32(v15, v15))));
  v17.i64[0] = 0x3F0000003F000000;
  v17.i64[1] = 0x3F0000003F000000;
  float32x4_t v20 = (float32x4_t)_simd_pow_f4((simd_float4)vmulq_f32(v19, v17), (simd_float4)vdupq_n_s64(0x3EAAAAAB3EAAAAABuLL));
  float32x4_t v22 = vmulq_f32(a5, v30);
  int8x16_t v23 = (int8x16_t)vsubq_f32(vsubq_f32(vdivq_f32(v20, v22), vdivq_f32(vsubq_f32(a3, vdivq_f32(v29, v22)), v20)), vdivq_f32(a4, v22));
  int8x16_t v24 = (int8x16_t)vdivq_f32(vsubq_f32(vsqrtq_f32(vsubq_f32(vmulq_f32(a3, a3), vmulq_f32(vsubq_f32(a2, a1), vmulq_f32(a4, v32)))), a3), vaddq_f32(a4, a4));
  int8x16_t v25 = (int8x16_t)vdivq_f32(v36, a3);
  float32x4_t v26 = (float32x4_t)v23;
  if (a5.f32[1] == 0.0)
  {
    v26.i64[0] = 0;
    float32x4_t v26 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 1), v26), 0), v25, v24);
  }
  if (a5.f32[2] == 0.0) {
    float32x4_t v21 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a4, 2);
  }
  v21.i64[0] = 0;
  result.n64_u32[0] = vbslq_s8((int8x16_t)vceqq_f32(a5, v21), vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(a4, v21), 0), v25, v24), v23).u32[0];
  result.n64_u32[1] = v26.u32[1];
  return result;
}

double cikernel::_colorCrossPolynomial(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17, float32x4_t a18, float32x4_t a19)
{
  *(void *)&double result = vaddq_f32(a19, vaddq_f32(vmulq_n_f32(a18, vmuls_lane_f32(a1.f32[0], a1, 2)), vaddq_f32(vmulq_n_f32(a17, vmuls_lane_f32(a1.f32[1], a1, 2)), vaddq_f32(vmulq_n_f32(a8, vmuls_lane_f32(a1.f32[0], *(float32x2_t *)a1.f32, 1)), vaddq_f32(vmulq_n_f32(a7, vmuls_lane_f32(a1.f32[2], a1, 2)), vaddq_f32(vmulq_n_f32(a6, vmuls_lane_f32(a1.f32[1], *(float32x2_t *)a1.f32, 1)), vaddq_f32(vmulq_n_f32(a5, vmulq_f32(a1, a1).f32[0]), vaddq_f32(vmulq_laneq_f32(a4, a1, 2), vaddq_f32(vmulq_n_f32(a2, a1.f32[0]), vmulq_lane_f32(a3, *(float32x2_t *)a1.f32, 1)))))))))).u64[0];
  return result;
}

void CI::f4_s_f3_f3_f3_f3_f3_f3_f3_f3_f3_f3(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  double v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  uint64_t v13 = *(void *)(v9 + 32);
  uint64_t v14 = *(void *)(v9 + 56);
  uint64_t v15 = *(void *)(v9 + 80);
  uint64_t v16 = *(void *)(v9 + 104);
  uint64_t v17 = *(void *)(v9 + 128);
  uint64_t v18 = *(void *)(v9 + 152);
  uint64_t v19 = *(void *)(v9 + 176);
  uint64_t v20 = *(void *)(v9 + 200);
  uint64_t v21 = *(void *)(v9 + 224);
  uint64_t v22 = *(void *)(v9 + 248);
  if (*(unsigned char *)(a1 + 64))
  {
    int8x16_t v23 = (CI *)(a3 + 16 * *(void *)(v9 + 272));
    uint64_t v30 = *(void *)(v9 + 80);
    uint64_t v31 = a3;
    uint64_t v24 = *(void *)(v9 + 32);
    uint64_t v28 = *(void *)(v9 + 128);
    uint64_t v29 = *(void *)(v9 + 200);
    uint64_t v27 = *(void *)(v9 + 248);
    CI::setDC(v23, a2);
    uint64_t v22 = v27;
    uint64_t v17 = v28;
    uint64_t v20 = v29;
    uint64_t v15 = v30;
    uint64_t v13 = v24;
    a3 = v31;
  }
  int8x16_t v25 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    int8x16_t v25 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v26 = v10(*v25, *((__n128 *)a2 + 4 * v13), *((__n128 *)a2 + 4 * v14), *((__n128 *)a2 + 4 * v15), *((__n128 *)a2 + 4 * v16), *((__n128 *)a2 + 4 * v17), *((__n128 *)a2 + 4 * v18), *((__n128 *)a2 + 4 * v19), *((double *)a2 + 8 * v20), *((double *)a2 + 8 * v20 + 1), *((double *)a2 + 8 * v21), *((double *)a2 + 8 * v21 + 1), *((double *)a2 + 8 * v22), *((double *)a2 + 8 * v22 + 1));
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

double cikernel::_colorPosterize(float32x4_t a1, double a2)
{
  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  float32x4_t v3 = vaddq_f32(vmulq_n_f32(a1, *(float *)&a2), v2);
  v3.i32[3] = 0;
  *(void *)&double result = vmulq_lane_f32(vrndmq_f32(v3), *(float32x2_t *)&a2, 1).u64[0];
  return result;
}

double cikernel::_colorThreshold(float32x4_t a1, int32x2_t a2)
{
  __asm { FMOV            V2.4S, #1.0 }
  *(void *)&double result = vbicq_s8(_Q2, (int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(a2, 0)))).u64[0];
  return result;
}

double cikernel::_otsu(cikernel *this, SamplerObj *a2, float32x4_t a3, int8x16_t a4, double a5, int8x16_t a6, int8x16_t a7, int8x16_t a8, int8x16_t a9)
{
  float v9 = a3.f32[0];
  int v10 = (int)a3.f32[0];
  if ((int)a3.f32[0] < 1)
  {
    float32x4_t v20 = 0uLL;
  }
  else
  {
    int v12 = 0;
    float32x4_t v13 = 0uLL;
    double v14 = 0.0;
    float32x4_t v15 = 0uLL;
    do
    {
      float32x4_t v44 = v15;
      float32x4_t v46 = v13;
      float v16 = v14 + 0.5;
      LODWORD(a5) = *((_DWORD *)this + 6);
      a8.i32[0] = *((_DWORD *)this + 9);
      *(float *)a7.i32 = *((float *)this + 8) * 0.5;
      *(float *)a6.i32 = *(float *)a7.i32 + (float)(v16 * *((float *)this + 7));
      *(float *)&double v17 = *(float *)&a5
                     + (float)((float)(*((float *)this + 5) * 0.5) + (float)(v16 * *((float *)this + 4)));
      *(float *)a4.i32 = *(float *)a8.i32 + *(float *)a6.i32;
      *((float *)&v17 + 1) = *(float *)a8.i32 + *(float *)a6.i32;
      *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v17, (float64x2_t)a4, a5, *(double *)a6.i64, a7, a8, a9);
      float32x4_t v13 = vaddq_f32(v46, v18);
      float32x4_t v15 = vaddq_f32(v44, vmulq_n_f32(v18, (float)v12));
      double v14 = v14 + 1.0;
      ++v12;
    }
    while (v10 != v12);
    int v19 = 0;
    float32x4_t v20 = 0uLL;
    double v21 = 0.0;
    float32x4_t v22 = 0uLL;
    float32x4_t v23 = 0uLL;
    float32x4_t v24 = 0uLL;
    float32x4_t v45 = v15;
    float32x4_t v47 = v13;
    do
    {
      int8x16_t v40 = (int8x16_t)v20;
      float32x4_t v41 = v24;
      float32x4_t v42 = v23;
      float32x4_t v43 = v22;
      float v25 = v21 + 0.5;
      v20.i32[0] = *((_DWORD *)this + 6);
      a8.i32[0] = *((_DWORD *)this + 9);
      *(float *)a7.i32 = *((float *)this + 8) * 0.5;
      *(float *)a6.i32 = *(float *)a7.i32 + (float)(v25 * *((float *)this + 7));
      *(float *)&double v26 = v20.f32[0] + (float)((float)(*((float *)this + 5) * 0.5) + (float)(v25 * *((float *)this + 4)));
      *(float *)a4.i32 = *(float *)a8.i32 + *(float *)a6.i32;
      *((float *)&v26 + 1) = *(float *)a8.i32 + *(float *)a6.i32;
      *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v26, (float64x2_t)a4, *(double *)v20.i64, *(double *)a6.i64, a7, a8, a9);
      float32x4_t v28 = vmulq_f32(v42, vsubq_f32(v47, v42));
      float32x4_t v29 = vmulq_f32(v45, v42);
      float32x4_t v30 = vsubq_f32(vmulq_f32(v47, v43), v29);
      int8x16_t v31 = (int8x16_t)vdivq_f32(vmulq_f32(v30, v30), v28);
      v29.i64[0] = 0;
      int8x16_t v32 = v31;
      v32.i32[0] = -1.0;
      int8x16_t v33 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v29, v28)), 0), v31, v32);
      int8x16_t v34 = v33;
      v34.i32[1] = -1.0;
      v28.i32[0] = vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL).u32[0];
      *(int8x8_t *)v28.f32 = vmvn_s8((int8x8_t)vclez_f32(*(float32x2_t *)v28.f32));
      int8x16_t v35 = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(*(int16x4_t *)v28.f32, 2)), v33, v34);
      a6 = v35;
      a6.i32[2] = -1.0;
      a4 = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(*(int16x4_t *)v28.f32, 0)), v35, a6);
      *(int16x4_t *)v35.i8 = vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32((float32x4_t)a4, v41)));
      int8x16_t v36 = v40;
      *(float *)v36.i32 = (float)v19;
      int8x16_t v37 = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(*(int16x4_t *)v35.i8, 0)), v40, v36);
      int8x16_t v38 = v37;
      *(float *)&v38.i32[1] = (float)v19;
      a9 = (int8x16_t)vmovl_s16(vdup_lane_s16(*(int16x4_t *)v35.i8, 1));
      a7 = vbslq_s8(a9, v37, v38);
      a8 = a7;
      *(float *)&a8.i32[2] = (float)v19;
      float32x4_t v20 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(*(int16x4_t *)v35.i8, 2)), a7, a8);
      float32x4_t v24 = vmaxnmq_f32(v41, (float32x4_t)a4);
      float32x4_t v23 = vaddq_f32(v42, v27);
      a3 = vmulq_n_f32(v27, (float)v19);
      float32x4_t v22 = vaddq_f32(v43, a3);
      double v21 = v21 + 1.0;
      ++v19;
    }
    while (v10 != v19);
  }
  a3.f32[0] = v9 + -1.0;
  a3.i64[0] = vdivq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a3.f32, 0)).u64[0];
  return *(double *)a3.i64;
}

double cikernel::_otsuThresh(float32x4_t a1, float32x4_t a2)
{
  __asm { FMOV            V2.4S, #1.0 }
  *(void *)&double result = vbicq_s8(_Q2, (int8x16_t)vcltzq_f32(vsubq_f32(a1, a2))).u64[0];
  return result;
}

double cikernel::_sobelEdges(uint64x2_t **this, SamplerObj *a2, float a3)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)this);
  float v5 = *((float *)this + 4);
  float v6 = *((float *)this + 5);
  v7.i32[0] = *((_DWORD *)this + 6);
  v8.i32[0] = *((_DWORD *)this + 7);
  v9.f32[0] = *(float *)v7.i32 + vmlas_n_f32(vmuls_lane_f32(v6, *DC, 1), v5, COERCE_FLOAT(*DC));
  LODWORD(v1CI::NodeWithChildren::NodeWithChildren(this, 0) = *((_DWORD *)this + 8);
  v11.i32[0] = *((_DWORD *)this + 9);
  v9.f32[1] = *(float *)v11.i32
            + vmlas_n_f32(vmuls_lane_f32(*(float *)&v10, *DC, 1), *(float *)v8.i32, COERCE_FLOAT(*DC));
  float32x2_t v12 = vadd_f32(*DC, (float32x2_t)1065353216);
  v13.f32[0] = *(float *)v7.i32 + vmlas_n_f32(vmuls_lane_f32(v6, v12, 1), v5, v12.f32[0]);
  v13.f32[1] = *(float *)v11.i32 + vmlas_n_f32(vmuls_lane_f32(*(float *)&v10, v12, 1), *(float *)v8.i32, v12.f32[0]);
  float32x2_t v14 = vsub_f32(v13, v9);
  float32x2_t v15 = vadd_f32(*DC, (float32x2_t)0x3F80000000000000);
  *(float *)v16.f64 = *(float *)v7.i32 + vmlas_n_f32(vmuls_lane_f32(v6, v15, 1), v5, v15.f32[0]);
  *(float *)&double v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)&v10, v15, 1), *(float *)v8.i32, v15.f32[0]);
  *((float *)v16.f64 + 1) = *(float *)v11.i32 + *(float *)&v17;
  float32x2_t v90 = v9;
  float32x2_t v18 = vsub_f32(*(float32x2_t *)&v16.f64[0], v9);
  float32x2_t v19 = vadd_f32(v18, v14);
  *(double *)v20.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v9, v19)), v16, v17, v10, v7, v8, v11);
  float32x4_t v88 = v20;
  *(double *)v27.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v90, v19)), v21, v22, v23, v24, v25, v26);
  float32x4_t v87 = v27;
  float32x2_t v28 = vsub_f32(v14, v18);
  *(double *)v35.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v90, v28)), v29, v30, v31, v32, v33, v34);
  float32x4_t v86 = v35;
  *(double *)v42.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v90, v28)), v36, v37, v38, v39, v40, v41);
  float32x4_t v85 = v42;
  *(double *)v49.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v90, v18)), v43, v44, v45, v46, v47, v48);
  float32x4_t v84 = v49;
  *(double *)v56.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v90, v18)), v50, v51, v52, v53, v54, v55);
  float32x4_t v83 = v56;
  *(double *)v63.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v90, v14)), v57, v58, v59, v60, v61, v62);
  float32x4_t v82 = v63;
  *(double *)v70.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v90, v14)), v64, v65, v66, v67, v68, v69);
  float32x4_t v81 = v70;
  *(double *)v77.i64 = CI::BitmapSampler::read(this[1], *(double *)&v90, v71, v72, v73, v74, v75, v76);
  float32x4_t v78 = vsubq_f32(vaddq_f32(v86, vaddq_f32(v88, vaddq_f32(v82, v82))), vaddq_f32(v87, vaddq_f32(v85, vaddq_f32(v81, v81))));
  float32x4_t v79 = vsubq_f32(vaddq_f32(v88, vaddq_f32(v85, vaddq_f32(v84, v84))), vaddq_f32(v86, vaddq_f32(v87, vaddq_f32(v83, v83))));
  *(void *)&double result = vmulq_laneq_f32(vmulq_n_f32(vsqrtq_f32(vaddq_f32(vmulq_f32(v79, v79), vmulq_f32(v78, v78))), a3), v77, 3).u64[0];
  return result;
}

double cikernel::_noiseComicReduction(uint64_t a1, int8x16_t a2, float32x4_t a3, __n128 a4)
{
  v5.i64[0] = *(void *)CI::getDC((CI *)a1);
  float64x2_t v92 = (float64x2_t)v5;
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  *(float *)&double v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v5.i8, 1), *(float *)(a1 + 16), *(float *)v5.i32);
  LODWORD(v_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 36);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v5.i8, 1), *(float *)&v6, *(float *)v5.i32);
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v9, v6, v8, v5, v10, v11);
  float32x4_t v87 = v12;
  v12.i32[0] = 0;
  v12.f32[1] = -*(float *)a2.i32;
  float64x2_t v13 = v92;
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v15, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v13.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v12.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v13, v14, v15, v17, v16, v18);
  float32x4_t v86 = v19;
  float64x2_t v20 = v92;
  *(float32x2_t *)v19.f32 = vadd_f32((float32x2_t)vzip1_s32(0, *(int32x2_t *)a2.i8), *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v19.f32, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v19.f32, 1), *(float *)&v22, v19.f32[0]);
  v19.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v20.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v19.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v20, v21, v22, v24, v23, v25);
  float32x4_t v85 = v26;
  *(void *)&v27.f64[0] = COERCE_UNSIGNED_INT(-*(float *)a2.i32);
  *(float32x2_t *)v26.f32 = vadd_f32(*(float32x2_t *)&v27.f64[0], *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v26.f32, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v26.f32, 1), *(float *)&v29, v26.f32[0]);
  v26.f32[0] = *(float *)(a1 + 24) + *(float *)&v28;
  *(float *)v27.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v26.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v27, v28, v29, v31, v30, v32);
  float32x4_t v84 = v33;
  float64x2_t v34 = v92;
  *(float32x2_t *)v33.f32 = vadd_f32((float32x2_t)a2.u32[0], *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v33.f32, 1), *(float *)(a1 + 16), v33.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 28);
  v37.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v33.f32, 1), *(float *)&v36, v33.f32[0]);
  v33.f32[0] = *(float *)(a1 + 24) + *(float *)&v35;
  *(float *)v34.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v33.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v34, v35, v36, v38, v37, v39);
  float32x4_t v83 = v40;
  *(int32x2_t *)&v41.f64[0] = vdup_lane_s32(*(int32x2_t *)a2.i8, 1);
  float64x2_t v80 = v41;
  *(float32x2_t *)v40.f32 = vadd_f32(*(float32x2_t *)&v41.f64[0], *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v40.f32, 1), *(float *)(a1 + 16), v40.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 28);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v40.f32, 1), *(float *)&v43, v40.f32[0]);
  v40.f32[0] = *(float *)(a1 + 24) + *(float *)&v42;
  *(float *)v41.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  v40.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v41, v42, v43, v45, v44, a2);
  float32x4_t v82 = v46;
  v46.f32[0] = -*(float *)&a2.i32[1];
  int32x2_t v90 = *(int32x2_t *)v46.f32;
  float64x2_t v47 = v80;
  *((float *)v47.f64 + 1) = -*(float *)&a2.i32[1];
  *(float32x2_t *)v46.f32 = vadd_f32(*(float32x2_t *)&v47.f64[0], *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v46.f32, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a1 + 28);
  v50.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v46.f32, 1), *(float *)&v49, v46.f32[0]);
  v46.f32[0] = *(float *)(a1 + 24) + *(float *)&v48;
  *(float *)v47.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v46.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v46.i64, v47, v48, v49, v51, v50, v52);
  float32x4_t v81 = v53;
  float64x2_t v54 = v92;
  *(float32x2_t *)v53.f32 = vadd_f32((float32x2_t)vdup_lane_s32(v90, 0), *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v53.f32, 1), *(float *)(a1 + 16), v53.f32[0]);
  LODWORD(v56) = *(_DWORD *)(a1 + 28);
  v57.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v58.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v53.f32, 1), *(float *)&v56, v53.f32[0]);
  v53.f32[0] = *(float *)(a1 + 24) + *(float *)&v55;
  *(float *)v54.f64 = *(float *)v57.i32 + *(float *)v58.i32;
  v53.f32[1] = *(float *)v57.i32 + *(float *)v58.i32;
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v54, v55, v56, v58, v57, v59);
  float32x4_t v79 = v60;
  float64x2_t v61 = v92;
  *(float32x2_t *)v60.f32 = vadd_f32((float32x2_t)__PAIR64__(a2.u32[1], v90.u32[0]), *(float32x2_t *)&v92.f64[0]);
  *(float *)&double v62 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v60.f32, 1), *(float *)(a1 + 16), v60.f32[0]);
  LODWORD(v63) = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v60.f32, 1), *(float *)&v63, v60.f32[0]);
  v60.f32[0] = *(float *)(a1 + 24) + *(float *)&v62;
  *(float *)v61.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v60.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v60.i64, v61, v62, v63, v65, v64, v66);
  float32x4_t v68 = vaddq_f32(vmulq_laneq_f32(v87, a3, 2), vaddq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(v86, v85), v84), v83), a3.f32[0]), vmulq_lane_f32(vaddq_f32(vaddq_f32(vaddq_f32(v82, v81), v79), v67), *(float32x2_t *)a3.f32, 1)));
  _Q0 = vabdq_f32(v68, v87);
  _Q0.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)_Q0, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q0.f32, 1), _Q0)).u32[0];
  _V3.S[1] = a4.n128_u32[1];
  __asm { FMLA            S2, S0, V3.S[1] }
  if (_S2 <= 1.0) {
    float v76 = _S2;
  }
  else {
    float v76 = 1.0;
  }
  if (_S2 >= a4.n128_f32[2]) {
    float v77 = v76;
  }
  else {
    float v77 = a4.n128_f32[2];
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v87, 1.0 - v77), v68, v77).u64[0];
  return result;
}

void CI::f4_sr_f2_f3_f3(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  float32x4_t v12 = *(double (**)(uint64_t, double, __n128, __n128))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  int v14 = *(_DWORD *)(v11 + 40);
  uint64_t v15 = *(void *)(v11 + 32);
  uint64_t v16 = *(void *)(v11 + 56);
  uint64_t v17 = *(void *)(v11 + 80);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 104)), a2);
  }
  int8x16_t v18 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    int8x16_t v18 = (double *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v19 = v12(a4 + 80 * v13, *v18, *((__n128 *)a2 + 4 * v16), *((__n128 *)a2 + 4 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_colorControls()
{
  return 0.0;
}

double cikernel::_spotColor(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17)
{
  v18.i32[1] = a17.i32[1];
  *(float *)v17.i32 = fmaxf(a1.f32[3], 0.00001);
  float32x4_t v19 = vdivq_f32(a1, (float32x4_t)vdupq_lane_s32(v17, 0));
  float32x4_t v20 = vsubq_f32(v19, a2);
  float32x4_t v21 = vmulq_f32(v20, v20);
  float v22 = (float)((float)(*(float *)a8.i32
                      - sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0]))* *(float *)a17.i32)+ 0.5;
  if (v22 <= 1.0) {
    float v23 = v22;
  }
  else {
    float v23 = 1.0;
  }
  BOOL v24 = v22 < 0.0;
  float v25 = 0.0;
  if (v24) {
    float v23 = 0.0;
  }
  float32x4_t v26 = vmulq_n_f32(a3, v23);
  float32x4_t v27 = vsubq_f32(v19, a4);
  int8x16_t v28 = (int8x16_t)vmulq_f32(v27, v27);
  float32x4_t v29 = vsubq_f32(v19, a6);
  int8x16_t v30 = (int8x16_t)vmulq_f32(v29, v29);
  a8.i32[0] = vextq_s8(a8, a8, 8uLL).u32[0];
  v18.i32[0] = vextq_s8(a17, a17, 8uLL).u32[0];
  float32x2_t v31 = vadd_f32(vmul_f32(v18, vsub_f32(*(float32x2_t *)a8.i8, vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)), vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v30.i8, *(int32x2_t *)v28.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v30.i8, *(int32x2_t *)v28.i8)))))), (float32x2_t)0x3F0000003F000000);
  float v32 = v31.f32[1];
  int32x2_t v33 = vcltz_f32(v31);
  if (v31.f32[1] > 1.0) {
    float v32 = 1.0;
  }
  if (v33.i8[4]) {
    float v32 = 0.0;
  }
  float32x4_t v34 = vmulq_n_f32(a5, v32);
  if (v31.f32[0] > 1.0) {
    v31.f32[0] = 1.0;
  }
  if ((v33.i8[0] & 1) == 0) {
    float v25 = v31.f32[0];
  }
  float32x4_t v35 = vmulq_n_f32(a7, v25);
  v31.f32[0] = 1.0 - v26.f32[3];
  *(void *)&double result = vaddq_f32(v35, vmulq_n_f32(vaddq_f32(v34, vmulq_n_f32(vaddq_f32(v26, (float32x4_t)vdupq_lane_s32((int32x2_t)v31, 0)), 1.0 - v34.f32[3])), 1.0 - v35.f32[3])).u64[0];
  return result;
}

void CI::f4_s_clr_clr_clr_clr_clr_clr_f4_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  int8x16_t v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  uint64_t v13 = *(void *)(v9 + 32);
  uint64_t v14 = *(void *)(v9 + 56);
  uint64_t v15 = *(void *)(v9 + 80);
  uint64_t v16 = *(const vec2 **)(v9 + 104);
  uint64_t v17 = *(void *)(v9 + 128);
  uint64_t v18 = *(void *)(v9 + 152);
  int v19 = *(_DWORD *)(v9 + 184);
  uint64_t v20 = *(void *)(v9 + 176);
  int v21 = *(_DWORD *)(v9 + 208);
  uint64_t v22 = *(void *)(v9 + 200);
  if (*(unsigned char *)(a1 + 64))
  {
    float32x4_t v27 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double))(a1 + 24);
    int8x16_t v30 = *(const vec2 **)(v9 + 104);
    uint64_t v31 = *(void *)(v9 + 80);
    uint64_t v29 = *(void *)(v9 + 56);
    int v28 = *(_DWORD *)(v9 + 184);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 224)), v16);
    int v19 = v28;
    uint64_t v14 = v29;
    uint64_t v16 = v30;
    uint64_t v15 = v31;
    int8x16_t v10 = v27;
  }
  float v23 = (double *)(a3 + 16 * v22);
  if (v21 != 5) {
    float v23 = (double *)(a2 + (v22 << 6));
  }
  BOOL v24 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    BOOL v24 = (__n128 *)(a2 + (v20 << 6));
  }
  float v25 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    float v25 = (__n128 *)(a2 + (v12 << 6));
  }
  *(double *)&long long v26 = v10(*v25, *(__n128 *)(a2 + (v13 << 6)), *(__n128 *)(a2 + (v14 << 6)), *(__n128 *)(a2 + (v15 << 6)), *(__n128 *)(a2 + ((void)v16 << 6)), *(__n128 *)(a2 + (v17 << 6)), *(__n128 *)(a2 + (v18 << 6)), *v24, *v23, v23[1]);
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

void sub_19371E3F8(_Unwind_Exception *exception_object)
{
}

void sub_19371E74C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19371EC1C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19371EC8C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19371ECEC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19371EDE8(_Unwind_Exception *a1)
{
}

void sub_193721688(_Unwind_Exception *a1)
{
}

void sub_19372170C(_Unwind_Exception *a1)
{
}

void sub_1937229E4(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10F1C4003C5734DLL);
  _Unwind_Resume(a1);
}

void sub_193723100(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10E1C40CDAF8E61);
  _Unwind_Resume(a1);
}

void sub_193723344(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x10F1C4003C5734DLL);
  _Unwind_Resume(a1);
}

void *___ZL13isSWAllowListv_block_invoke()
{
  double result = (void *)[MEMORY[0x1E4F28F80] processInfo];
  if (result)
  {
    uint64_t v1 = result;
    if (objc_msgSend((id)objc_msgSend(result, "processName"), "containsString:", @"ControlStrip")) {
      isSWAllowList(void)::allowed = 1;
    }
    double result = objc_msgSend((id)objc_msgSend(v1, "processName"), "containsString:", @"UserNotificationCenter");
    if (result) {
      isSWAllowList(void)::allowed = 1;
    }
  }
  return result;
}

uint64_t ___ZL19set_context_optionsPN2CI9GLContextEP12NSDictionary_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 208))();
}

uint64_t ___ZL19set_context_optionsPN2CI9GLContextEP12NSDictionary_block_invoke_2(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(result + 32) + 41) = a2;
  return result;
}

uint64_t ___ZL19set_context_optionsPN2CI9GLContextEP12NSDictionary_block_invoke_412(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 160))();
}

void OUTLINED_FUNCTION_1_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_2_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

void OUTLINED_FUNCTION_4(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x20u);
}

void ___ZN2CIL14create_cgimageEP9CIContextP7CIImage6CGRectP12CGColorSpaceibNS_7TrileanEU13block_pointerFvS4_P7NSErrorE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 40) + 264))(*(void *)(a1 + 40)) & 1) == 0) {
    CI::format_has_alpha(*(_DWORD *)(a1 + 68));
  }
  double v8 = ci_signpost_log_render();
  os_signpost_id_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 272))(*(void *)(a1 + 48)) << 32;
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    int v11 = 134218240;
    uint64_t v12 = a4;
    __int16 v13 = 2048;
    uint64_t v14 = a5;
    _os_signpost_emit_with_name_impl(&dword_193671000, v8, OS_SIGNPOST_INTERVAL_BEGIN, v9, "new_bitmap", "[%zu %zu]", (uint8_t *)&v11, 0x16u);
  }
  uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 272))(*(void *)(a1 + 48));
  TimerBase::TimerBase((uint64_t)&v11, v10, 0, (uint64_t)"new_bitmap", 0);
  operator new();
}

void sub_193723C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  MEMORY[0x1997023B0](v9, 0x10E1C40ABAAFD7FLL);
  _ZZZN2CIL14create_cgimageEP9CIContextP7CIImage6CGRectP12CGColorSpaceibNS_7TrileanEU13block_pointerFvS4_P7NSErrorEEUb_EN13SignpostTimerD1Ev((TimerBase *)&a9);
  _Unwind_Resume(a1);
}

void _ZZZN2CIL14create_cgimageEP9CIContextP7CIImage6CGRectP12CGColorSpaceibNS_7TrileanEU13block_pointerFvS4_P7NSErrorEEUb_EN13SignpostTimerD1Ev(TimerBase *a1)
{
  float32x4_t v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = *((void *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)int8x16_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "new_bitmap", "", v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_193723D50(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void CI::create_cgimage(CIContext *,CIImage *,CGRect,CGColorSpace *,int,BOOL,CI::Trilean,void({block_pointer})(CGRect,NSError *))::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  float32x4_t v2 = ci_signpost_log_render();
  os_signpost_id_t v3 = *((void *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)int8x16_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_193671000, v4, OS_SIGNPOST_INTERVAL_END, v3, "create_cgimage_check", "", v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_193723DF0(_Unwind_Exception *a1)
{
  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void __CFDictionary::setValue(__CFDictionary *this, __CFDictionary *a2, const __CFString *a3, const void *a4)
{
  uint64_t v4 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a3) {
    uint64_t v4 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  int8x16_t v5 = *v4;
  __CFDictionary::setValue(this, a2, *v4, a4);
  if (v5)
  {
    CFRelease(v5);
  }
}

uint64_t CI::copyImageBlockSetOptsCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  CGImageProviderGetSize();
  CGFloat v15 = v14;
  CGFloat v17 = v16;
  v69.origin.CGFloat x = a4;
  v69.origin.CGFloat y = a5;
  v69.size.double width = a6;
  v69.size.double height = a7;
  CGRect v75 = CGRectIntegral(v69);
  v70.origin.CGFloat x = 0.0;
  v70.origin.CGFloat y = 0.0;
  v70.size.double width = v15;
  v70.size.double height = v17;
  CGRect v71 = CGRectIntersection(v70, v75);
  CGFloat x = v71.origin.x;
  CGFloat y = v71.origin.y;
  double width = v71.size.width;
  double height = v71.size.height;
  int v22 = getpagesize();
  int v23 = CI::format_bytes_per_pixel(*(_DWORD *)(a1 + 16));
  uint64_t v24 = [*(id *)a1 _internalContext];
  if (a3)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E4F1DD50]);
    int valuePtr = 0;
    if (Value) {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    }
    if (CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E4F1DD38])) {
      return 0;
    }
    BOOL v26 = CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E4F1DD40]) == (const void *)*MEMORY[0x1E4F1CFD0];
    CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E4F1DD18]);
    int v65 = 0;
    if (v27)
    {
      CFNumberGetValue(v27, kCFNumberIntType, &v65);
      if (v65)
      {
        if (v22 % v65) {
          return 0;
        }
      }
    }
    CFNumberRef v28 = (const __CFNumber *)CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E4F1DD20]);
  }
  else
  {
    CFNumberRef v28 = 0;
    int valuePtr = 0;
    BOOL v26 = *MEMORY[0x1E4F1CFD0] == 0;
    int v65 = 0;
  }
  unsigned int v64 = (*(uint64_t (**)(uint64_t, void))(*(void *)v24 + 544))(v24, *(unsigned int *)(a1 + 16));
  if (v28) {
    CFNumberGetValue(v28, kCFNumberIntType, &v64);
  }
  if (a3 && CFDictionaryContainsKey(a3, (const void *)*MEMORY[0x1E4F1DD28])) {
    return 0;
  }
  unint64_t v29 = (unint64_t)(width * (double)(unint64_t)v23);
  if ((int)v64 >= 1 && v29 % v64) {
    unint64_t v29 = (v64 + v29 - 1) / v64 * v64;
  }
  unint64_t v30 = (v29 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v31 = (v29 + 7) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v32 = *(_DWORD *)(a1 + 16) == 259 ? v30 : v31;
  size_t v33 = ((unint64_t)((height + 1.0) * (double)v32) + v22 - 1) / v22 * v22;
  float32x4_t v34 = mmap(0, v33, 3, 4098, 1140850688, 0);
  if (v34 == (void *)-1) {
    return 0;
  }
  long long v63 = xmmword_1EE461CD8;
  long long v35 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
  *(_OWORD *)&v62.CGFloat a = *MEMORY[0x1E4F1DAB8];
  *(_OWORD *)&v62.c = v35;
  *(_OWORD *)&v62.tCGFloat x = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
  CGFloat v36 = x;
  *(CGFloat *)&long long v35 = y;
  double v37 = width;
  double v38 = height;
  CGRect v72 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v35 - 8), &v62);
  CGFloat v39 = v72.origin.x;
  CGFloat v40 = v72.origin.y;
  CGFloat v41 = v72.size.width;
  CGFloat v42 = v72.size.height;
  CGAffineTransformMakeTranslation(&v61, *(CGFloat *)(a1 + 32), *(CGFloat *)(a1 + 40));
  v73.origin.CGFloat x = v39;
  v73.origin.CGFloat y = v40;
  v73.size.double width = v41;
  v73.size.double height = v42;
  CGRect v74 = CGRectApplyAffineTransform(v73, &v61);
  uint64_t v57 = 0;
  int8x16_t v58 = &v57;
  uint64_t v59 = 0x2020000000;
  char v60 = 0;
  double v43 = *(NSObject **)(a1 + 64);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN2CIL29copyImageBlockSetOptsCallbackEPvP15CGImageProvider6CGRect6CGSizePK14__CFDictionary_block_invoke;
  block[3] = &unk_1E57713C0;
  *(CGFloat *)&void block[6] = x;
  *(CGFloat *)&void block[7] = y;
  *(double *)&block[8] = width;
  *(double *)&void block[9] = height;
  block[10] = v32;
  void block[11] = a1;
  block[12] = a2;
  block[13] = v24;
  CGRect v56 = v74;
  void block[4] = &v57;
  void block[5] = v34;
  dispatch_sync(v43, block);
  if (*((unsigned char *)v58 + 24))
  {
    int8x16_t v44 = malloc_type_calloc(1uLL, 0x10uLL, 0x1080040FC6463CFuLL);
    *int8x16_t v44 = v34;
    v44[1] = v33;
    uint64_t v67 = CGImageBlockCreate();
    if (v26 && mprotect(v34, v33, 1) == -1)
    {
      int8x16_t v45 = ci_logger_render();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
        CI::copyImageBlockSetOptsCallback(v45, v46, v47, v48, v49, v50, v51, v52);
      }
    }
    uint64_t v53 = CGImageBlockSetCreate();
  }
  else
  {
    munmap(v34, v33);
    uint64_t v53 = 0;
  }
  _Block_object_dispose(&v57, 8);
  return v53;
}

void sub_193724370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

__IOSurface *CI::copyIOSurfaceCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  CGImageProviderGetSize();
  double v6 = v5;
  double v8 = v7;
  uint64_t v9 = [*(id *)a1 _internalContext];
  if (v6 <= v8) {
    double v10 = v8;
  }
  else {
    double v10 = v6;
  }
  if (v10 > (double)(unint64_t)(*(uint64_t (**)(void))(*(void *)v9 + 440))()) {
    return 0;
  }
  uint64_t v43 = 16;
  if (!a3) {
    goto LABEL_15;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a3, @"kCGImageSurfaceFormatRequest");
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&v43 + 4);
    CFNumberRef Value = (const __CFNumber *)HIDWORD(v43);
  }
  if (!CI::format_from_PixelFormatType(Value)) {
    HIDWORD(v43) = 0;
  }
  CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(a3, @"kCGImageSurfaceBytesPerRowAlignmentRequest");
  if (v14) {
    CFNumberGetValue(v14, kCFNumberSInt32Type, &v43);
  }
  uint64_t v15 = HIDWORD(v43);
  if (!HIDWORD(v43))
  {
LABEL_15:
    uint64_t v15 = CI::PixelFormatType_from_format(*(_DWORD *)(a1 + 16));
    if (!v15) {
      uint64_t v15 = CI::PixelFormatType_approx_from_format(*(_DWORD *)(a1 + 16));
    }
  }
  Surface = 0;
  if (v15 && (v15 & 0xFF000000) != 0x63000000)
  {
    int v16 = CI::format_from_PixelFormatType((CI *)v15);
    if (!v16) {
      return 0;
    }
    int v17 = v16;
    Surface = CreateSurface((__CVBuffer *)v6, (__CVBuffer *)v8, (void *)(int)v43, v15, 1);
    if (Surface)
    {
      default_ycc_color_matriCGFloat x = CI::format_get_default_ycc_color_matrix(v17);
      if (default_ycc_color_matrix) {
        SurfaceSetYCCMatrix(Surface, default_ycc_color_matrix);
      }
      long long v19 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
      *(_OWORD *)&v42.CGFloat a = *MEMORY[0x1E4F1DAB8];
      *(_OWORD *)&v42.c = v19;
      *(_OWORD *)&v42.tCGFloat x = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
      uint64_t v20 = 0;
      *(void *)&long long v19 = 0;
      double v21 = v6;
      double v22 = v8;
      CGRect v44 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v19 - 8), &v42);
      CGFloat x = v44.origin.x;
      CGFloat y = v44.origin.y;
      CGFloat width = v44.size.width;
      CGFloat height = v44.size.height;
      CGAffineTransformMakeTranslation(&v41, *(CGFloat *)(a1 + 32), *(CGFloat *)(a1 + 40));
      v45.origin.CGFloat x = x;
      v45.origin.CGFloat y = y;
      v45.size.CGFloat width = width;
      v45.size.CGFloat height = height;
      CGRect v46 = CGRectApplyAffineTransform(v45, &v41);
      CGFloat v27 = v46.origin.x;
      CGFloat v28 = v46.origin.y;
      CGFloat v29 = v46.size.width;
      CGFloat v30 = v46.size.height;
      ColorSpace = (CGColorSpace *)CGImageProviderGetColorSpace();
      unint64_t v32 = ColorSpace;
      if (ColorSpace)
      {
        CFPropertyListRef v33 = CGColorSpaceCopyPropertyList(ColorSpace);
        if (v33)
        {
          float32x4_t v34 = v33;
          IOSurfaceSetValue(Surface, (CFStringRef)*MEMORY[0x1E4F2F068], v33);
          CFRelease(v34);
        }
      }
      if ([*(id *)(a1 + 8) isOpaque] && (CI::format_has_alpha(v17) & 1) != 0
        || CI::format_has_x(*(_DWORD *)(a1 + 16)))
      {
        IOSurfaceSetValue(Surface, @"IOSurfaceAlphaIsOpaque", (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
      }
      uint64_t v37 = 0;
      double v38 = &v37;
      uint64_t v39 = 0x2020000000;
      char v40 = 0;
      long long v35 = *(NSObject **)(a1 + 64);
      v36[0] = MEMORY[0x1E4F143A8];
      v36[1] = 3221225472;
      v36[2] = ___ZN2CIL21copyIOSurfaceCallbackEPvP15CGImageProviderPK14__CFDictionary_block_invoke;
      v36[3] = &unk_1E57713E8;
      void v36[6] = v32;
      v36[7] = a1;
      *(CGFloat *)&v36[8] = v27;
      *(CGFloat *)&v36[9] = v28;
      *(CGFloat *)&v36[10] = v29;
      *(CGFloat *)&v36[11] = v30;
      v36[4] = &v37;
      void v36[5] = Surface;
      dispatch_sync(v35, v36);
      if (!*((unsigned char *)v38 + 24))
      {
        CFRelease(Surface);
        Surface = 0;
      }
      _Block_object_dispose(&v37, 8);
    }
  }
  return Surface;
}

void sub_1937246D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CI::_providerInfoReleaseCallback(CI *this, void *a2)
{
  dispatch_release(*((dispatch_object_t *)this + 8));
  os_signpost_id_t v3 = (const void *)*((void *)this + 9);
  if (v3) {
    _Block_release(v3);
  }

  free(this);
}

void __CFDictionary::setValue(CFMutableDictionaryRef this, const void *key, const void *value, const void *a4)
{
  if (this) {
    BOOL v4 = key == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = !v4;
  if (value)
  {
    if (v5) {
      CFDictionarySetValue(this, key, value);
    }
  }
  else if (v5)
  {
    CFDictionaryRemoveValue(this, key);
  }
}

void CI::_imageBlockReleaseCallback(uint64_t a1)
{
  munmap(*(void **)a1, *(void *)(a1 + 8));

  free((void *)a1);
}

void ___ZN2CIL29copyImageBlockSetOptsCallbackEPvP15CGImageProvider6CGRect6CGSizePK14__CFDictionary_block_invoke(uint64_t a1)
{
  uint64_t v26 = 0;
  uint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = (unint64_t)*(double *)(a1 + 64);
  unint64_t v4 = (unint64_t)*(double *)(a1 + 72);
  uint64_t v5 = *(void *)(a1 + 80);
  uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 88) + 16);
  uint64_t ColorSpace = CGImageProviderGetColorSpace();
  CI::Bitmap::Bitmap(v20, v2, v3, v4, v5, v6, ColorSpace);
  uint64_t v8 = CI::PixelFormatType_approx_from_format(*(_DWORD *)(*(void *)(a1 + 88) + 16));
  if (!CI_IOSURFACE_WRAPPING(2u)) {
    goto LABEL_11;
  }
  if (!v8) {
    goto LABEL_11;
  }
  if ((*(unsigned char *)(a1 + 80) & 3) != 0) {
    goto LABEL_11;
  }
  double v9 = iosurface_limits((uint64_t)v19);
  if (v19[2] < *(void *)(a1 + 80)) {
    goto LABEL_11;
  }
  double v10 = *(double *)(a1 + 64);
  double v11 = *(double *)(a1 + 72);
  unint64_t v12 = (*(uint64_t (**)(void, double))(**(void **)(a1 + 104) + 440))(*(void *)(a1 + 104), v9);
  double v13 = v10 <= v11 ? v11 : v10;
  if (v13 > (double)v12
    || (WrappedSurface = CreateWrappedSurface(v22, v23, v8, v24, v25, v21)) == 0
    || (uint64_t v15 = [[CIRenderDestination alloc] initWithIOSurface:WrappedSurface], CFRelease(WrappedSurface), !v15))
  {
LABEL_11:
    int v16 = [CIRenderDestination alloc];
    uint64_t v15 = [(CIRenderDestination *)v16 initWithBitmapData:v21 width:v22 height:v23 bytesPerRow:v24 format:*(unsigned int *)(*(void *)(a1 + 88) + 16)];
  }
  [(CIRenderDestination *)v15 setFlipped:0];
  [(CIRenderDestination *)v15 setColorSpace:CGImageProviderGetColorSpace()];
  [(CIRenderDestination *)v15 setAlphaMode:*(void *)(*(void *)(a1 + 88) + 24)];
  uint64_t v17 = *(void *)(a1 + 88);
  if (*(void *)(v17 + 24) == 2)
  {
    [(CIRenderDestination *)v15 setClamped:0];
    uint64_t v17 = *(void *)(a1 + 88);
  }
  uint64_t v18 = objc_msgSend(*(id *)v17, "startTaskToRender:fromRect:toDestination:atPoint:error:", *(void *)(v17 + 8), v15, &v26, *(double *)(a1 + 112), *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *MEMORY[0x1E4F1DAD8], *(double *)(MEMORY[0x1E4F1DAD8] + 8));
  [v18 waitUntilCompletedAndReturnError:&v26];

  (*(void (**)(double, double, double, double))(*(void *)(*(void *)(a1 + 88) + 72) + 16))(*(double *)(a1 + 112), *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136));
  if (v18 && !v26) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  CI::Bitmap::~Bitmap((CI::Bitmap *)v20);
}

void sub_1937249F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  CI::Bitmap::~Bitmap((CI::Bitmap *)va);
  _Unwind_Resume(a1);
}

void ___ZN2CIL21copyIOSurfaceCallbackEPvP15CGImageProviderPK14__CFDictionary_block_invoke(uint64_t a1)
{
  uint64_t v2 = [[CIRenderDestination alloc] initWithIOSurface:*(void *)(a1 + 40)];
  [(CIRenderDestination *)v2 setFlipped:0];
  [(CIRenderDestination *)v2 setColorSpace:*(void *)(a1 + 48)];
  [(CIRenderDestination *)v2 setAlphaMode:*(void *)(*(void *)(a1 + 56) + 24)];
  uint64_t v3 = *(void *)(a1 + 56);
  if (*(void *)(v3 + 24) == 2)
  {
    [(CIRenderDestination *)v2 setClamped:0];
    uint64_t v3 = *(void *)(a1 + 56);
  }
  uint64_t v5 = 0;
  unint64_t v4 = objc_msgSend(*(id *)v3, "startTaskToRender:fromRect:toDestination:atPoint:error:", *(void *)(v3 + 8), v2, &v5, *(double *)(a1 + 64), *(double *)(a1 + 72), *(double *)(a1 + 80), *(double *)(a1 + 88), *MEMORY[0x1E4F1DAD8], *(double *)(MEMORY[0x1E4F1DAD8] + 8));
  [v4 waitUntilCompletedAndReturnError:&v5];
  (*(void (**)(double, double, double, double))(*(void *)(*(void *)(a1 + 56) + 72) + 16))(*(double *)(a1 + 64), *(double *)(a1 + 72), *(double *)(a1 + 80), *(double *)(a1 + 88));

  if (v4)
  {
    if (!v5) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    }
  }
}

void OUTLINED_FUNCTION_0_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

CIImage *downScale(CIImage *a1, float a2, float a3)
{
  float v4 = fmin(a2, 1.0);
  float v5 = fmin(a3, 1.0);
  if (v4 != 1.0 || v5 != 1.0)
  {
    memset(&v19, 0, sizeof(v19));
    CGAffineTransformMakeScale(&v19, v4, v5);
    CGAffineTransform v18 = v19;
    [[(CIImage *)a1 imageByApplyingTransform:&v18] extent];
    double v8 = v7;
    double v10 = v9;
    double v12 = v11;
    double v14 = v13;
    uint64_t v15 = [(CIImage *)a1 imageByClampingToExtent];
    CGAffineTransform v17 = v19;
    return -[CIImage imageByCroppingToRect:]([(CIImage *)v15 imageByApplyingTransform:&v17 highQualityDownsample:1], "imageByCroppingToRect:", v8, v10, v12, v14);
  }
  return a1;
}

void sub_193726974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
}

__n128 __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 4_Block_object_dispose(&STACK[0x3A0], 8) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void __Block_byref_object_copy__53(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__54(uint64_t a1)
{
}

uint64_t imageRepError(uint64_t a1, const NSString *a2)
{
  v6[1] = *MEMORY[0x1E4F143B8];
  float v5 = @"CINonLocalizedDescriptionKey";
  v6[0] = a2;
  uint64_t v3 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v6 forKeys:&v5 count:1];
  return [MEMORY[0x1E4F28C58] errorWithDomain:@"CINonLocalizedDescriptionKey" code:a1 userInfo:v3];
}

uint64_t imageRepError(uint64_t a1, const NSString *a2, const NSError *a3)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    v10[0] = *MEMORY[0x1E4F28A50];
    v10[1] = @"CINonLocalizedDescriptionKey";
    v11[0] = a3;
    v11[1] = a2;
    float v4 = (void *)MEMORY[0x1E4F1C9E8];
    float v5 = v11;
    uint64_t v6 = (__CFString **)v10;
    uint64_t v7 = 2;
  }
  else
  {
    double v12 = @"CINonLocalizedDescriptionKey";
    v13[0] = a2;
    float v4 = (void *)MEMORY[0x1E4F1C9E8];
    float v5 = v13;
    uint64_t v6 = &v12;
    uint64_t v7 = 1;
  }
  uint64_t v8 = [v4 dictionaryWithObjects:v5 forKeys:v6 count:v7];
  return [MEMORY[0x1E4F28C58] errorWithDomain:@"CINonLocalizedDescriptionKey" code:a1 userInfo:v8];
}

BOOL canCreateDataRepresentation(CIImage *a1, CGColorSpace *a2, int a3, NSError **a4)
{
  v33[1] = *MEMORY[0x1E4F143B8];
  [(CIImage *)a1 extent];
  CGRect v35 = CGRectInset(v34, 0.00100000005, 0.00100000005);
  CGRect v36 = CGRectIntegral(v35);
  CGFloat x = v36.origin.x;
  CGFloat y = v36.origin.y;
  CGFloat width = v36.size.width;
  CGFloat height = v36.size.height;
  if (CGRectIsEmpty(v36)
    || (v37.origin.x = x, v37.origin.y = y, v37.size.width = width, v37.size.CGFloat height = height, CGRectIsInfinite(v37)))
  {
    if (a4)
    {
      unint64_t v32 = @"CINonLocalizedDescriptionKey";
      v33[0] = @"image extent must be finite and non-empty.";
      uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v33 forKeys:&v32 count:1];
      *a4 = (NSError *)[MEMORY[0x1E4F28C58] errorWithDomain:@"CINonLocalizedDescriptionKey" code:1 userInfo:v11];
    }
    double v12 = ci_logger_api();
    BOOL result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (result)
    {
      canCreateDataRepresentation(v12, v14, v15, v16, v17, v18, v19, v20);
      return 0;
    }
    return result;
  }
  if (a2)
  {
    CFTypeID TypeID = CGColorSpaceGetTypeID();
    if (TypeID == CFGetTypeID(a2) && CGColorSpaceSupportsOutput(a2))
    {
      if (CI::format_is_luminance(a3))
      {
        int v22 = 0;
      }
      else
      {
        if (!CI::format_is_rgb(a3)) {
          goto LABEL_16;
        }
        int v22 = 1;
      }
      if (CGColorSpaceGetModel(a2) == v22) {
        return 1;
      }
    }
  }
LABEL_16:
  if (a4)
  {
    unint64_t v32 = @"CINonLocalizedDescriptionKey";
    v33[0] = @"unsupported colorspace.";
    uint64_t v23 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v33 forKeys:&v32 count:1];
    *a4 = (NSError *)[MEMORY[0x1E4F28C58] errorWithDomain:@"CINonLocalizedDescriptionKey" code:2 userInfo:v23];
  }
  uint64_t v24 = ci_logger_api();
  BOOL result = os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
  if (result)
  {
    canCreateDataRepresentation(v24, v25, v26, v27, v28, v29, v30, v31);
    return 0;
  }
  return result;
}

uint64_t canCreateDataRepresentation(CIImage *a1, CGColorSpace *a2, NSError **a3)
{
  v30[1] = *MEMORY[0x1E4F143B8];
  [(CIImage *)a1 extent];
  CGRect v32 = CGRectInset(v31, 0.00100000005, 0.00100000005);
  CGRect v33 = CGRectIntegral(v32);
  CGFloat x = v33.origin.x;
  CGFloat y = v33.origin.y;
  CGFloat width = v33.size.width;
  CGFloat height = v33.size.height;
  if (CGRectIsEmpty(v33)
    || (v34.origin.x = x, v34.origin.y = y, v34.size.width = width, v34.size.CGFloat height = height, CGRectIsInfinite(v34)))
  {
    if (a3)
    {
      uint64_t v29 = @"CINonLocalizedDescriptionKey";
      v30[0] = @"image extent must be finite and non-empty.";
      uint64_t v9 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v30 forKeys:&v29 count:1];
      *a3 = (NSError *)[MEMORY[0x1E4F28C58] errorWithDomain:@"CINonLocalizedDescriptionKey" code:1 userInfo:v9];
    }
    double v10 = ci_logger_api();
    uint64_t result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (result)
    {
      canCreateDataRepresentation(v10, v12, v13, v14, v15, v16, v17, v18);
      return 0;
    }
  }
  else
  {
    if (a2)
    {
      CFTypeID TypeID = CGColorSpaceGetTypeID();
      if (TypeID == CFGetTypeID(a2) && CGColorSpaceSupportsOutput(a2))
      {
        if (CGColorSpaceGetModel(a2) == kCGColorSpaceModelMonochrome) {
          return 1;
        }
        uint64_t result = CGColorSpaceGetModel(a2);
        if (result == 1) {
          return result;
        }
      }
    }
    if (a3)
    {
      uint64_t v29 = @"CINonLocalizedDescriptionKey";
      v30[0] = @"unsupported colorspace.";
      uint64_t v20 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v30 forKeys:&v29 count:1];
      *a3 = (NSError *)[MEMORY[0x1E4F28C58] errorWithDomain:@"CINonLocalizedDescriptionKey" code:2 userInfo:v20];
    }
    uint64_t v21 = ci_logger_api();
    uint64_t result = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    if (result)
    {
      canCreateDataRepresentation(v21, v22, v23, v24, v25, v26, v27, v28);
      return 0;
    }
  }
  return result;
}

BOOL canCreateDataRepresentation(CIImage *a1, NSError **a2)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  [(CIImage *)a1 extent];
  CGRect v20 = CGRectInset(v19, 0.00100000005, 0.00100000005);
  CGRect v21 = CGRectIntegral(v20);
  CGFloat x = v21.origin.x;
  CGFloat y = v21.origin.y;
  CGFloat width = v21.size.width;
  CGFloat height = v21.size.height;
  if (!CGRectIsEmpty(v21))
  {
    v22.origin.CGFloat x = x;
    v22.origin.CGFloat y = y;
    v22.size.CGFloat width = width;
    v22.size.CGFloat height = height;
    if (!CGRectIsInfinite(v22)) {
      return 1;
    }
  }
  if (a2)
  {
    uint64_t v17 = @"CINonLocalizedDescriptionKey";
    v18[0] = @"image extent must be finite and non-empty.";
    uint64_t v7 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v18 forKeys:&v17 count:1];
    *a2 = (NSError *)[MEMORY[0x1E4F28C58] errorWithDomain:@"CINonLocalizedDescriptionKey" code:1 userInfo:v7];
  }
  uint64_t v8 = ci_logger_api();
  BOOL result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  if (result)
  {
    canCreateDataRepresentation(v8, v10, v11, v12, v13, v14, v15, v16);
    return 0;
  }
  return result;
}

void sub_193727F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

uint64_t getkCMPhotoCompressionContainerOption_Format(void)
{
  uint64_t v3 = 0;
  float v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getkCMPhotoCompressionContainerOption_FormatSymbolLoc(void)::ptr;
  uint64_t v6 = getkCMPhotoCompressionContainerOption_FormatSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionContainerOption_FormatSymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)CMPhotoLibrary();
    v4[3] = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerOption_Format");
    getkCMPhotoCompressionContainerOption_FormatSymbolLoc(void)::ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    getkCMPhotoCompressionContainerOption_Format();
  }
  return *(void *)v0;
}

void sub_193728070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionContainerOption_ImageCountHint(void)
{
  uint64_t v3 = 0;
  float v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getkCMPhotoCompressionContainerOption_ImageCountHintSymbolLoc(void)::ptr;
  uint64_t v6 = getkCMPhotoCompressionContainerOption_ImageCountHintSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionContainerOption_ImageCountHintSymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)CMPhotoLibrary();
    v4[3] = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerOption_ImageCountHint");
    getkCMPhotoCompressionContainerOption_ImageCountHintSymbolLoc(void)::ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    getkCMPhotoCompressionContainerOption_ImageCountHint();
  }
  return *(void *)v0;
}

void sub_193728168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionContainerOption_BackingType(void)
{
  uint64_t v3 = 0;
  float v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getkCMPhotoCompressionContainerOption_BackingTypeSymbolLoc(void)::ptr;
  uint64_t v6 = getkCMPhotoCompressionContainerOption_BackingTypeSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionContainerOption_BackingTypeSymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)CMPhotoLibrary();
    v4[3] = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerOption_BackingType");
    getkCMPhotoCompressionContainerOption_BackingTypeSymbolLoc(void)::ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    getkCMPhotoCompressionContainerOption_BackingType();
  }
  return *(void *)v0;
}

void sub_193728260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_CMPhotoCompressionSessionOpenEmptyContainer(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  float v4 = (uint64_t (*)(uint64_t, uint64_t))getCMPhotoCompressionSessionOpenEmptyContainerSymbolLoc(void)::ptr;
  uint64_t v10 = getCMPhotoCompressionSessionOpenEmptyContainerSymbolLoc(void)::ptr;
  if (!getCMPhotoCompressionSessionOpenEmptyContainerSymbolLoc(void)::ptr)
  {
    uint64_t v5 = (void *)CMPhotoLibrary();
    v8[3] = (uint64_t)dlsym(v5, "CMPhotoCompressionSessionOpenEmptyContainer");
    getCMPhotoCompressionSessionOpenEmptyContainerSymbolLoc(void)::ptr = (_UNKNOWN *)v8[3];
    float v4 = (uint64_t (*)(uint64_t, uint64_t))v8[3];
  }
  _Block_object_dispose(&v7, 8);
  if (!v4) {
    soft_CMPhotoCompressionSessionOpenEmptyContainer();
  }
  return v4(a1, a2);
}

void sub_193728370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionOption_ImageOrientation(void)
{
  uint64_t v3 = 0;
  float v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getkCMPhotoCompressionOption_ImageOrientationSymbolLoc(void)::ptr;
  uint64_t v6 = getkCMPhotoCompressionOption_ImageOrientationSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionOption_ImageOrientationSymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)CMPhotoLibrary();
    v4[3] = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_ImageOrientation");
    getkCMPhotoCompressionOption_ImageOrientationSymbolLoc(void)::ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    getkCMPhotoCompressionOption_ImageOrientation();
  }
  return *(void *)v0;
}

void sub_193728468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionOption_QualityControllerType(void)
{
  uint64_t v3 = 0;
  float v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getkCMPhotoCompressionOption_QualityControllerTypeSymbolLoc(void)::ptr;
  uint64_t v6 = getkCMPhotoCompressionOption_QualityControllerTypeSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionOption_QualityControllerTypeSymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)CMPhotoLibrary();
    v4[3] = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_QualityControllerType");
    getkCMPhotoCompressionOption_QualityControllerTypeSymbolLoc(void)::ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    getkCMPhotoCompressionOption_QualityControllerType();
  }
  return *(void *)v0;
}

void sub_193728560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoQualityControllerParameter_QualityValue(void)
{
  uint64_t v3 = 0;
  float v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getkCMPhotoQualityControllerParameter_QualityValueSymbolLoc(void)::ptr;
  uint64_t v6 = getkCMPhotoQualityControllerParameter_QualityValueSymbolLoc(void)::ptr;
  if (!getkCMPhotoQualityControllerParameter_QualityValueSymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)CMPhotoLibrary();
    v4[3] = (uint64_t)dlsym(v1, "kCMPhotoQualityControllerParameter_QualityValue");
    getkCMPhotoQualityControllerParameter_QualityValueSymbolLoc(void)::ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    getkCMPhotoQualityControllerParameter_QualityValue();
  }
  return *(void *)v0;
}

void sub_193728658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionOption_QualityControllerParameters(void)
{
  uint64_t v3 = 0;
  float v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = getkCMPhotoCompressionOption_QualityControllerParametersSymbolLoc(void)::ptr;
  uint64_t v6 = getkCMPhotoCompressionOption_QualityControllerParametersSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionOption_QualityControllerParametersSymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)CMPhotoLibrary();
    v4[3] = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_QualityControllerParameters");
    getkCMPhotoCompressionOption_QualityControllerParametersSymbolLoc(void)::ptr = v4[3];
    uint64_t v0 = v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    getkCMPhotoCompressionOption_QualityControllerParameters();
  }
  return *(void *)v0;
}

void sub_193728750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_CMPhotoCompressionSessionAddImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000;
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))getCMPhotoCompressionSessionAddImageSymbolLoc(void)::ptr;
  uint64_t v14 = getCMPhotoCompressionSessionAddImageSymbolLoc(void)::ptr;
  if (!getCMPhotoCompressionSessionAddImageSymbolLoc(void)::ptr)
  {
    uint64_t v9 = (void *)CMPhotoLibrary();
    v12[3] = (uint64_t)dlsym(v9, "CMPhotoCompressionSessionAddImage");
    getCMPhotoCompressionSessionAddImageSymbolLoc(void)::ptr = (_UNKNOWN *)v12[3];
    uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v12[3];
  }
  _Block_object_dispose(&v11, 8);
  if (!v8) {
    soft_CMPhotoCompressionSessionAddImage();
  }
  return v8(a1, a2, a3, a4);
}

void sub_193728878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_CMPhotoCompressionSessionAddAuxiliaryImage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000;
  uint64_t v6 = getCMPhotoCompressionSessionAddAuxiliaryImageSymbolLoc(void)::ptr;
  uint64_t v12 = getCMPhotoCompressionSessionAddAuxiliaryImageSymbolLoc(void)::ptr;
  if (!getCMPhotoCompressionSessionAddAuxiliaryImageSymbolLoc(void)::ptr)
  {
    uint64_t v7 = (void *)CMPhotoLibrary();
    int64x2_t v10[3] = (uint64_t)dlsym(v7, "CMPhotoCompressionSessionAddAuxiliaryImage");
    getCMPhotoCompressionSessionAddAuxiliaryImageSymbolLoc(void)::ptr = (_UNKNOWN *)v10[3];
    uint64_t v6 = (void *)v10[3];
  }
  _Block_object_dispose(&v9, 8);
  if (!v6) {
    soft_CMPhotoCompressionSessionAddAuxiliaryImage();
  }
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, void, void, uint64_t, void))v6)(a1, a2, 3, 0, 0, a3, 0);
}

void sub_193728A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_CMPhotoCompressionSessionAddMetadataFromImageProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000;
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))getCMPhotoCompressionSessionAddMetadataFromImagePropertiesSymbolLoc(void)::ptr;
  uint64_t v12 = getCMPhotoCompressionSessionAddMetadataFromImagePropertiesSymbolLoc(void)::ptr;
  if (!getCMPhotoCompressionSessionAddMetadataFromImagePropertiesSymbolLoc(void)::ptr)
  {
    uint64_t v7 = (void *)CMPhotoLibrary();
    int64x2_t v10[3] = (uint64_t)dlsym(v7, "CMPhotoCompressionSessionAddMetadataFromImageProperties");
    getCMPhotoCompressionSessionAddMetadataFromImagePropertiesSymbolLoc(void)::ptr = (_UNKNOWN *)v10[3];
    uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, void, uint64_t))v10[3];
  }
  _Block_object_dispose(&v9, 8);
  if (!v6) {
    soft_CMPhotoCompressionSessionAddMetadataFromImageProperties();
  }
  return v6(a1, a2, 0, a3);
}

void sub_193728B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_CMPhotoCompressionSessionCloseContainerAndCopyBacking(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  float v4 = getCMPhotoCompressionSessionCloseContainerAndCopyBackingSymbolLoc(void)::ptr;
  uint64_t v10 = getCMPhotoCompressionSessionCloseContainerAndCopyBackingSymbolLoc(void)::ptr;
  if (!getCMPhotoCompressionSessionCloseContainerAndCopyBackingSymbolLoc(void)::ptr)
  {
    uint64_t v5 = (void *)CMPhotoLibrary();
    v8[3] = (uint64_t)dlsym(v5, "CMPhotoCompressionSessionCloseContainerAndCopyBacking");
    getCMPhotoCompressionSessionCloseContainerAndCopyBackingSymbolLoc(void)::ptr = (_UNKNOWN *)v8[3];
    float v4 = (void *)v8[3];
  }
  _Block_object_dispose(&v7, 8);
  if (!v4) {
    soft_CMPhotoCompressionSessionCloseContainerAndCopyBacking();
  }
  return ((uint64_t (*)(uint64_t, void, void, uint64_t))v4)(a1, 0, 0, a2);
}

void sub_193728C5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n64 cikernel::_flexMapLinGain(__n128 a1, __n128 a2, float a3, float a4)
{
  result.n64_f32[0] = (float)(fmaxf(a1.n128_f32[0], fmaxf(a1.n128_f32[1], fmaxf(a1.n128_f32[2], 0.0))) + a4)
                    / (float)(fmaxf(a2.n128_f32[0], fmaxf(a2.n128_f32[1], fmaxf(a2.n128_f32[2], 0.0))) + a3);
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_s_s_f_f(void *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = a1[6];
  uint64_t v11 = (double (*)(void *, __n128, __n128, float, float))a1[3];
  int v12 = *(_DWORD *)(v10 + 16);
  uint64_t v13 = *(void *)(v10 + 8);
  int v14 = *(_DWORD *)(v10 + 40);
  uint64_t v15 = *(void *)(v10 + 32);
  uint64_t v16 = *(void *)(v10 + 56);
  uint64_t v17 = *(void *)(v10 + 80);
  if (*((unsigned char *)a1 + 64)) {
    a1 = CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  uint64_t v18 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    uint64_t v18 = (__n128 *)((char *)a2 + 64 * v15);
  }
  CGRect v19 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    CGRect v19 = (__n128 *)((char *)a2 + 64 * v13);
  }
  *(double *)&long long v20 = v11(a1, *v19, *v18, *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_flexMapLinGainRGB(float32x4_t a1, float32x4_t a2, int32x2_t a3, int32x2_t a4)
{
  a1.i32[3] = 0;
  a2.i32[3] = 0;
  a1.i64[0] = vdivq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(a4, 0), vmaxnmq_f32(a1, (float32x4_t)0)), vaddq_f32((float32x4_t)vdupq_lane_s32(a3, 0), vmaxnmq_f32(a2, (float32x4_t)0))).u64[0];
  return *(double *)a1.i64;
}

double cikernel::_flexMapImageRGB(simd_float4 a1, double a2, float a3)
{
  a1.i32[3] = 0;
  float32x4_t v4 = (float32x4_t)_simd_log2_f4(a1);
  float32x4_t v5 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0);
  float32x4_t v6 = vsubq_f32(v4, v5);
  v5.f32[0] = a3 - *(float *)&a2;
  float32x4_t v7 = vdivq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 0));
  v7.i32[3] = 0;
  float32x4_t v8 = vmaxnmq_f32(v7, (float32x4_t)0);
  v8.i32[3] = 0;
  *(void *)&double result = vminnmq_f32(v8, (float32x4_t)xmmword_1939508C0).u64[0];
  return result;
}

double cikernel::_flexMapImage(float a1, float a2, float a3)
{
  float v3 = (float)(log2f(a1) - a2) / (float)(a3 - a2);
  if (v3 <= 1.0) {
    float v4 = v3;
  }
  else {
    float v4 = 1.0;
  }
  BOOL v5 = v3 < 0.0;
  int32x2_t v6 = 0;
  if (!v5) {
    *(float *)v6.i32 = v4;
  }
  *(void *)&double result = vdupq_lane_s32(v6, 0).u64[0];
  return result;
}

void *___ZL43getCMPhotoCompressionSessionCreateSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  double result = dlsym(v2, "CMPhotoCompressionSessionCreate");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCMPhotoCompressionSessionCreateSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CMPhotoLibrary(void)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v2[0] = 0;
  if (!CMPhotoLibraryCore(char **)::frameworkLibrary)
  {
    v2[1] = (void *)MEMORY[0x1E4F143A8];
    v2[2] = (void *)3221225472;
    v2[3] = ___ZL18CMPhotoLibraryCorePPc_block_invoke;
    void v2[4] = &__block_descriptor_40_e5_v8__0l;
    void v2[5] = v2;
    long long v3 = xmmword_1E5771500;
    uint64_t v4 = 0;
    CMPhotoLibraryCore(char **)::frameworkLibrarCGFloat y = _sl_dlopen();
  }
  uint64_t v0 = CMPhotoLibraryCore(char **)::frameworkLibrary;
  if (!CMPhotoLibraryCore(char **)::frameworkLibrary) {
    CMPhotoLibrary(v2);
  }
  if (v2[0]) {
    free(v2[0]);
  }
  return v0;
}

uint64_t ___ZL18CMPhotoLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CMPhotoLibraryCore(char **)::frameworkLibrarCGFloat y = result;
  return result;
}

void *___ZL53getkCMPhotoCompressionContainerOption_FormatSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "kCMPhotoCompressionContainerOption_Format");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCMPhotoCompressionContainerOption_FormatSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                               + 24);
  return result;
}

void *___ZL61getkCMPhotoCompressionContainerOption_ImageCountHintSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "kCMPhotoCompressionContainerOption_ImageCountHint");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCMPhotoCompressionContainerOption_ImageCountHintSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                       + 24);
  return result;
}

void *___ZL58getkCMPhotoCompressionContainerOption_BackingTypeSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "kCMPhotoCompressionContainerOption_BackingType");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCMPhotoCompressionContainerOption_BackingTypeSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32)
                                                                                                + 8)
                                                                                    + 24);
  return result;
}

void *___ZL55getCMPhotoCompressionSessionOpenEmptyContainerSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "CMPhotoCompressionSessionOpenEmptyContainer");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCMPhotoCompressionSessionOpenEmptyContainerSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32)
                                                                                                + 8)
                                                                                    + 24);
  return result;
}

void *___ZL54getkCMPhotoCompressionOption_ImageOrientationSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "kCMPhotoCompressionOption_ImageOrientation");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCMPhotoCompressionOption_ImageOrientationSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                + 24);
  return result;
}

void *___ZL59getkCMPhotoCompressionOption_QualityControllerTypeSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "kCMPhotoCompressionOption_QualityControllerType");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCMPhotoCompressionOption_QualityControllerTypeSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32)
                                                                                                 + 8)
                                                                                     + 24);
  return result;
}

void *___ZL59getkCMPhotoQualityControllerParameter_QualityValueSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "kCMPhotoQualityControllerParameter_QualityValue");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCMPhotoQualityControllerParameter_QualityValueSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32)
                                                                                                 + 8)
                                                                                     + 24);
  return result;
}

void *___ZL65getkCMPhotoCompressionOption_QualityControllerParametersSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "kCMPhotoCompressionOption_QualityControllerParameters");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCMPhotoCompressionOption_QualityControllerParametersSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                           + 24);
  return result;
}

void *___ZL45getCMPhotoCompressionSessionAddImageSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "CMPhotoCompressionSessionAddImage");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCMPhotoCompressionSessionAddImageSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                          + 24);
  return result;
}

void *___ZL54getCMPhotoCompressionSessionAddAuxiliaryImageSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "CMPhotoCompressionSessionAddAuxiliaryImage");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCMPhotoCompressionSessionAddAuxiliaryImageSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32)
                                                                                               + 8)
                                                                                   + 24);
  return result;
}

void *___ZL67getCMPhotoCompressionSessionAddMetadataFromImagePropertiesSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "CMPhotoCompressionSessionAddMetadataFromImageProperties");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCMPhotoCompressionSessionAddMetadataFromImagePropertiesSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                                + 24);
  return result;
}

void *___ZL65getCMPhotoCompressionSessionCloseContainerAndCopyBackingSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CMPhotoLibrary();
  uint64_t result = dlsym(v2, "CMPhotoCompressionSessionCloseContainerAndCopyBacking");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCMPhotoCompressionSessionCloseContainerAndCopyBackingSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                              + 24);
  return result;
}

uint64_t convert_weights(const double *a1, float *a2, unsigned int a3, unsigned int a4)
{
  if (a4)
  {
    int v4 = 0;
    int v5 = 0;
    int v6 = a3 * (a4 - 1);
    do
    {
      uint64_t v7 = a3;
      int v8 = v6;
      int v9 = v4;
      if (a3)
      {
        do
        {
          float v10 = a1[v8];
          a2[v9++] = v10;
          ++v8;
          --v7;
        }
        while (v7);
      }
      ++v5;
      v4 += a3;
      v6 -= a3;
    }
    while (v5 != a4);
    if (a3 >= 4 && a4 == 1)
    {
      uint64_t v11 = &a2[a3 - 1];
      while (fabsf(*a2) < 1.0e-10 && fabsf(*v11) < 1.0e-10)
      {
        ++a2;
        a3 -= 2;
        --v11;
        if (a3 <= 3) {
          goto LABEL_12;
        }
      }
      a4 = 1;
    }
    else
    {
LABEL_12:
      if (a4 >= 4 && a3 == 1)
      {
        int v12 = &a2[a4 - 1];
        do
        {
          if (fabsf(*a2) >= 1.0e-10) {
            break;
          }
          if (fabsf(*v12) >= 1.0e-10) {
            break;
          }
          ++a2;
          a4 -= 2;
          --v12;
        }
        while (a4 > 3);
        a3 = 1;
      }
    }
  }
  return a4 * a3;
}

CIImage *apply1DConvolution(CIImage *a1, CIVector *a2, double a3, unsigned int a4, int a5)
{
  v51[4] = *MEMORY[0x1E4F143B8];
  int v9 = [(CIVector *)a2 _values];
  if (a4) {
    unsigned int v10 = 9;
  }
  else {
    unsigned int v10 = 1;
  }
  if (a4) {
    unsigned int v11 = 1;
  }
  else {
    unsigned int v11 = 9;
  }
  int v12 = convert_weights(v9, v42, v10, v11);
  int v13 = v12;
  if (v12 >= 0) {
    int v14 = v12;
  }
  else {
    int v14 = v12 + 1;
  }
  int v15 = v14 >> 1;
  if (a4) {
    int v16 = v15;
  }
  else {
    int v16 = 0;
  }
  if (a4) {
    int v17 = 0;
  }
  else {
    int v17 = v15;
  }
  if (fabs(a3) >= 1.0e-10)
  {
    double x = *MEMORY[0x1E4F1DB10];
    double y = *(double *)(MEMORY[0x1E4F1DB10] + 8);
    double width = *(double *)(MEMORY[0x1E4F1DB10] + 16);
    double height = *(double *)(MEMORY[0x1E4F1DB10] + 24);
  }
  else
  {
    [(CIImage *)a1 extent];
    CGRect v53 = CGRectInset(v52, (double)-v16, (double)-v17);
    double x = v53.origin.x;
    double y = v53.origin.y;
    double width = v53.size.width;
    double height = v53.size.height;
  }
  unsigned int v22 = a4 ^ 1;
  if (v13 == 5)
  {
    uint64_t v25 = +[CIKernel kernelWithInternalRepresentation:&CI::_convolution5];
    if (a5)
    {
      uint64_t v26 = &CI::_convolutionrgb5;
LABEL_32:
      uint64_t v25 = +[CIKernel kernelWithInternalRepresentation:v26];
    }
LABEL_33:
    uint64_t v27 = v25;
    CGRect v33 = +[CIVector vectorWithX:v43 Y:v44 Z:v45 W:v46];
    CGRect v34 = +[CIVector vectorWithX:v47 Y:a3 Z:(double)a4 W:(double)v22];
    v36[0] = MEMORY[0x1E4F143A8];
    v36[1] = 3221225472;
    v36[2] = ___ZL18apply1DConvolutionP7CIImageP8CIVectordbb_block_invoke_2;
    v36[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
    int v37 = v16;
    int v38 = v17;
    v50[0] = a1;
    v50[1] = v33;
    void v50[2] = v34;
    uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithObjects:v50 count:3];
    CGRect v32 = v36;
    return -[CIKernel applyWithExtent:roiCallback:arguments:](v27, "applyWithExtent:roiCallback:arguments:", v32, v31, x, y, width, height);
  }
  if (v13 != 7)
  {
    if (v13 == 9)
    {
      uint64_t v23 = +[CIKernel kernelWithInternalRepresentation:&CI::_convolution9];
      if (a5)
      {
        uint64_t v24 = &CI::_convolutionrgb9;
LABEL_28:
        uint64_t v23 = +[CIKernel kernelWithInternalRepresentation:v24];
        goto LABEL_29;
      }
      goto LABEL_29;
    }
    uint64_t v25 = +[CIKernel kernelWithInternalRepresentation:&CI::_convolution3];
    if (a5)
    {
      uint64_t v26 = &CI::_convolutionrgb3;
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  uint64_t v23 = +[CIKernel kernelWithInternalRepresentation:&CI::_convolution7];
  if (a5)
  {
    uint64_t v24 = &CI::_convolutionrgb7;
    goto LABEL_28;
  }
LABEL_29:
  uint64_t v27 = v23;
  uint64_t v28 = +[CIVector vectorWithX:v42[0] Y:v42[1] Z:v43 W:v44];
  uint64_t v29 = +[CIVector vectorWithX:v45 Y:v46 Z:v47 W:v48];
  uint64_t v30 = +[CIVector vectorWithX:v49 Y:a3 Z:(double)a4 W:(double)v22];
  v39[0] = MEMORY[0x1E4F143A8];
  v39[1] = 3221225472;
  void v39[2] = ___ZL18apply1DConvolutionP7CIImageP8CIVectordbb_block_invoke;
  unint64_t v39[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
  int v40 = v16;
  int v41 = v17;
  v51[0] = a1;
  v51[1] = v28;
  v51[2] = v29;
  v51[3] = v30;
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithObjects:v51 count:4];
  CGRect v32 = v39;
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v27, "applyWithExtent:roiCallback:arguments:", v32, v31, x, y, width, height);
}

float32x4_t cikernel::_convrgb3x3sym(uint64_t a1, int8x16_t a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  v4.f64[0] = *(float64_t *)DC;
  float64x2_t v47 = v4;
  *(float *)&double v5 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v6) = *(_DWORD *)(a1 + 36);
  *(float *)v7.f64 = -*(float *)&a2.i32[1];
  HIDWORD(v7.f64[0]) = a2.i32[0];
  float64x2_t v46 = v7;
  *(float *)v8.f64 = *(float *)&v6
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v5) = LODWORD(v8.f64[0]);
  CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v5, v8, v7.f64[0], v6, a2, v9, v10);
  unsigned __int32 v45 = v11;
  float64x2_t v12 = v46;
  float32x2_t v13 = vadd_f32(*(float32x2_t *)&v46.f64[0], *(float32x2_t *)&v47.f64[0]);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v12.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v13, v12, v14, v15, v17, v16, v18);
  float32x4_t v43 = v19;
  float64x2_t v20 = v47;
  *(float32x2_t *)v19.f32 = vadd_f32(*(float32x2_t *)a2.i8, *(float32x2_t *)&v47.f64[0]);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v19.f32, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v19.f32, 1), *(float *)&v22, v19.f32[0]);
  v19.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v20.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v19.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v20, v21, v22, v24, v23, v25);
  HIDWORD(v27) = HIDWORD(v47.f64[0]);
  float32x2_t v28 = vsub_f32(*(float32x2_t *)&v47.f64[0], *(float32x2_t *)a2.i8);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 24);
  v30.i32[0] = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v30.i32, v28.f32[0]);
  float64x2_t v33 = (float64x2_t)v43;
  float32x4_t v44 = vaddq_f32(v43, v26);
  v26.f32[0] = *(float *)&v27 + *(float *)&v29;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v26.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v33, v27, v29, v30, v32, v31);
  HIDWORD(v35) = HIDWORD(v46.f64[0]);
  float32x2_t v36 = vsub_f32(*(float32x2_t *)&v47.f64[0], *(float32x2_t *)&v46.f64[0]);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v36, 1), *(float *)(a1 + 16), v36.f32[0]);
  LODWORD(v35) = *(_DWORD *)(a1 + 24);
  v38.i32[0] = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v36, 1), *(float *)v38.i32, v36.f32[0]);
  float64x2_t v41 = (float64x2_t)v44;
  float32x4_t v48 = vaddq_f32(v44, v34);
  v34.f32[0] = *(float *)&v35 + *(float *)&v37;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v34.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v41, v35, v37, v38, v40, v39);
  result.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)a2, 3), vmulq_laneq_f32(vaddq_f32(v48, result), (float32x4_t)a2, 2)).u64[0];
  result.i32[3] = v45;
  return result;
}

void CI::f4_sr_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  float64x2_t v12 = *(double (**)(uint64_t, __n128))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  int v14 = *(_DWORD *)(v11 + 40);
  uint64_t v15 = *(void *)(v11 + 32);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 56)), a2);
  }
  int8x16_t v16 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    int8x16_t v16 = (__n128 *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v17 = v12(a4 + 80 * v13, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

double cikernel::_conv3x3sym(uint64_t a1, int32x4_t a2)
{
  float32x2_t v3 = *(float32x2_t *)CI::getDC((CI *)a1);
  float64x2_t v4 = (float64x2_t)a2;
  v5.f32[0] = -*(float *)&a2.i32[1];
  v5.i32[1] = a2.i32[0];
  float32x2_t v39 = v5;
  float32x2_t v6 = vadd_f32(v5, v3);
  *(float *)&double v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v4, v7, v8, v10, v9, v11);
  float32x4_t v37 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)a2.i8, v3);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x2_t v20 = vsub_f32(v3, *(float32x2_t *)a2.i8);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 24);
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v37;
  float32x4_t v38 = vaddq_f32(v37, v19);
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  float32x2_t v28 = vsub_f32(v3, v39);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v31.i32, v28.f32[0]);
  float64x2_t v34 = (float64x2_t)v38;
  float32x4_t v40 = vaddq_f32(v38, v27);
  v27.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v34, v30, v29, v31, v33, v32);
  *(void *)&double result = vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 3), vmulq_laneq_f32(vaddq_f32(v40, v35), (float32x4_t)a2, 2)).u64[0];
  return result;
}

float32x4_t cikernel::_convrgb3x3(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v6.i8 = *DC;
  float64x2_t v89 = (float64x2_t)v6;
  *(float *)&double v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 36);
  float32x4_t v82 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v9, *(double *)v82.i64, v8, v6, v10, v11);
  float32x4_t v81 = v12;
  v12.f32[0] = -*(float *)&a4.i32[2];
  v12.f32[1] = -*(float *)&a4.i32[3];
  float64x2_t v13 = v89;
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)&v89.f64[0]);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v15, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v13.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v12.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v13, v14, v15, v17, v16, v18);
  v20.i32[0] = 0;
  v20.f32[1] = -*(float *)&a4.i32[3];
  HIDWORD(v21) = HIDWORD(v89.f64[0]);
  float32x2_t v22 = vadd_f32(v20, *(float32x2_t *)&v89.f64[0]);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 24);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v24.i32, v22.f32[0]);
  float64x2_t v27 = (float64x2_t)v82;
  float32x4_t v78 = vaddq_f32(v82, vmulq_n_f32(v19, a2.f32[0]));
  v19.f32[0] = *(float *)&v21 + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v19.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v27, v21, v23, v24, v26, v25);
  float32x2_t v29 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  *(float32x2_t *)v82.f32 = v29;
  v29.f32[1] = -*(float *)&a4.i32[3];
  HIDWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = HIDWORD(v89.f64[0]);
  float32x2_t v31 = vadd_f32(v29, *(float32x2_t *)&v89.f64[0]);
  *(float *)&double v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  v34.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)v33.i32, v31.f32[0]);
  float64x2_t v36 = (float64x2_t)v78;
  float32x4_t v79 = vaddq_f32(v78, vmulq_lane_f32(v28, *(float32x2_t *)a2.f32, 1));
  v28.f32[0] = *(float *)&v30 + *(float *)&v32;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v28.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v36, v30, v32, v33, v35, v34);
  HIDWORD(v3_Block_object_dispose(&STACK[0x3A0], 8) = HIDWORD(v89.f64[0]);
  float32x2_t v39 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a4.i32[2]), *(float32x2_t *)&v89.f64[0]);
  *(float *)&double v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v39, 1), *(float *)(a1 + 16), v39.f32[0]);
  LODWORD(v3_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v41.i32[0] = *(_DWORD *)(a1 + 28);
  v42.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v39, 1), *(float *)v41.i32, v39.f32[0]);
  float64x2_t v44 = (float64x2_t)v79;
  float32x4_t v80 = vaddq_f32(v79, vmulq_laneq_f32(v37, a2, 2));
  v37.f32[0] = *(float *)&v38 + *(float *)&v40;
  *(float *)v44.f64 = *(float *)v42.i32 + *(float *)v43.i32;
  v37.f32[1] = *(float *)v42.i32 + *(float *)v43.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v44, v38, v40, v41, v43, v42);
  HIDWORD(v46) = HIDWORD(v89.f64[0]);
  float32x2_t v47 = vadd_f32((float32x2_t)v82.u32[0], *(float32x2_t *)&v89.f64[0]);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v47, 1), *(float *)(a1 + 16), v47.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a1 + 24);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v47, 1), *(float *)(a1 + 28), v47.f32[0]);
  float32x4_t v51 = vmulq_n_f32(v81, a3.f32[0]);
  float32x4_t v84 = vaddq_f32(v51, vaddq_f32(v80, vmulq_laneq_f32(v45, a2, 3)));
  v45.f32[0] = *(float *)&v46 + *(float *)&v48;
  v51.f32[0] = *(float *)v49.i32 + *(float *)v50.i32;
  v45.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, (float64x2_t)v51, v46, v48, (int8x16_t)v81, v50, v49);
  double v53 = COERCE_DOUBLE(__PAIR64__(a4.u32[3], -*(float *)&a4.i32[2]));
  float32x2_t v54 = vadd_f32((float32x2_t)__PAIR64__(a4.u32[3], -*(float *)&a4.i32[2]), *(float32x2_t *)&v89.f64[0]);
  *(float *)&double v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v54, 1), *(float *)(a1 + 16), v54.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a1 + 24);
  v56.i32[0] = *(_DWORD *)(a1 + 28);
  v57.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v58.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v54, 1), *(float *)v56.i32, v54.f32[0]);
  float64x2_t v59 = (float64x2_t)v84;
  float32x4_t v85 = vaddq_f32(v84, vmulq_lane_f32(v52, *(float32x2_t *)a3.f32, 1));
  v52.f32[0] = *(float *)&v53 + *(float *)&v55;
  *(float *)v59.f64 = *(float *)v57.i32 + *(float *)v58.i32;
  v52.f32[1] = *(float *)v57.i32 + *(float *)v58.i32;
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v59, v53, v55, v56, v58, v57);
  v61.i32[1] = v82.i32[1];
  v61.i32[0] = 0;
  HIDWORD(v62) = HIDWORD(v89.f64[0]);
  float32x2_t v63 = vadd_f32(v61, *(float32x2_t *)&v89.f64[0]);
  *(float *)&double v64 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v63, 1), *(float *)(a1 + 16), v63.f32[0]);
  LODWORD(v62) = *(_DWORD *)(a1 + 24);
  v65.i32[0] = *(_DWORD *)(a1 + 28);
  v66.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v67.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v63, 1), *(float *)v65.i32, v63.f32[0]);
  float64x2_t v68 = (float64x2_t)v85;
  float32x4_t v86 = vaddq_f32(v85, vmulq_laneq_f32(v60, a3, 2));
  v60.f32[0] = *(float *)&v62 + *(float *)&v64;
  *(float *)v68.f64 = *(float *)v66.i32 + *(float *)v67.i32;
  v60.f32[1] = *(float *)v66.i32 + *(float *)v67.i32;
  *(double *)v69.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v60.i64, v68, v62, v64, v65, v67, v66);
  double v70 = COERCE_DOUBLE(__PAIR64__(a4.u32[3], v82.u32[0]));
  float32x2_t v71 = vadd_f32((float32x2_t)__PAIR64__(a4.u32[3], v82.u32[0]), *(float32x2_t *)&v89.f64[0]);
  *(float *)&double v72 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v71, 1), *(float *)(a1 + 16), v71.f32[0]);
  LODWORD(v7CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v73.i32[0] = *(_DWORD *)(a1 + 28);
  v74.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v75.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v71, 1), *(float *)v73.i32, v71.f32[0]);
  float64x2_t v76 = (float64x2_t)v86;
  float32x4_t v90 = vaddq_f32(v86, vmulq_laneq_f32(v69, a3, 3));
  v69.f32[0] = *(float *)&v70 + *(float *)&v72;
  *(float *)v76.f64 = *(float *)v74.i32 + *(float *)v75.i32;
  v69.f32[1] = *(float *)v74.i32 + *(float *)v75.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v69.i64, v76, v70, v72, v73, v75, v74);
  result.i64[0] = vaddq_f32(v90, vmulq_n_f32(result, *(float *)a4.i32)).u64[0];
  result.i32[3] = v81.i32[3];
  return result;
}

void CI::f4_sr_f4_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  int8x16_t v11 = *(double (**)(uint64_t, __n128, __n128, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  int v17 = *(_DWORD *)(v10 + 88);
  uint64_t v18 = *(void *)(v10 + 80);
  if (*(unsigned char *)(a1 + 64))
  {
    int v23 = *(_DWORD *)(v10 + 64);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
    int v15 = v23;
  }
  float32x4_t v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    float32x4_t v19 = (__n128 *)((char *)a2 + 64 * v18);
  }
  float32x2_t v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x2_t v20 = (__n128 *)((char *)a2 + 64 * v16);
  }
  double v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    double v21 = (__n128 *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v22 = v11(a4 + 80 * v12, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_conv3x3(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  float64x2_t v6 = (float64x2_t)a4;
  *(float32x2_t *)v7.i8 = *DC;
  int8x16_t v92 = v7;
  v8.f32[0] = -*(float *)&a4.i32[2];
  v8.f32[1] = -*(float *)&a4.i32[3];
  float32x2_t v9 = vadd_f32(v8, *DC);
  *(float *)&double v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v9, 1), *(float *)(a1 + 16), v9.f32[0]);
  v7.i32[0] = *(_DWORD *)(a1 + 28);
  v11.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v9, 1), *(float *)v7.i32, v9.f32[0]);
  v9.f32[0] = *(float *)(a1 + 24) + *(float *)&v10;
  *(float *)v6.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v9.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v9, v6, v10, *(double *)v7.i64, v12, v11, v13);
  v15.i32[0] = 0;
  v15.f32[1] = -*(float *)&a4.i32[3];
  HIDWORD(v16) = v92.i32[1];
  float32x2_t v17 = vadd_f32(v15, *(float32x2_t *)v92.i8);
  *(float *)&double v18 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v17, 1), *(float *)(a1 + 16), v17.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 24);
  v19.i32[0] = *(_DWORD *)(a1 + 28);
  v20.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v17, 1), *(float *)v19.i32, v17.f32[0]);
  float32x4_t v22 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  float32x4_t v81 = vaddq_f32(v22, vmulq_n_f32(v14, a2.f32[0]));
  v14.f32[0] = *(float *)&v16 + *(float *)&v18;
  v22.f32[0] = *(float *)v20.i32 + *(float *)v21.i32;
  v14.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v14.i64, (float64x2_t)v22, v16, v18, v19, v21, v20);
  float32x2_t v24 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  float32x2_t v84 = v24;
  v24.f32[1] = -*(float *)&a4.i32[3];
  HIDWORD(v25) = v92.i32[1];
  float32x2_t v26 = vadd_f32(v24, *(float32x2_t *)v92.i8);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v26, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v25) = *(_DWORD *)(a1 + 24);
  v28.i32[0] = *(_DWORD *)(a1 + 28);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v26, 1), *(float *)v28.i32, v26.f32[0]);
  float64x2_t v31 = (float64x2_t)v81;
  float32x4_t v82 = vaddq_f32(v81, vmulq_lane_f32(v23, *(float32x2_t *)a2.f32, 1));
  v23.f32[0] = *(float *)&v25 + *(float *)&v27;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v23.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v31, v25, v27, v28, v30, v29);
  HIDWORD(v33) = v92.i32[1];
  float32x2_t v34 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a4.i32[2]), *(float32x2_t *)v92.i8);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v34, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a1 + 24);
  v36.i32[0] = *(_DWORD *)(a1 + 28);
  v37.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v34, 1), *(float *)v36.i32, v34.f32[0]);
  float64x2_t v39 = (float64x2_t)v82;
  float32x4_t v83 = vaddq_f32(v82, vmulq_laneq_f32(v32, a2, 2));
  v32.f32[0] = *(float *)&v33 + *(float *)&v35;
  *(float *)v39.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v32.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v32.i64, v39, v33, v35, v36, v38, v37);
  float64x2_t v41 = (float64x2_t)v83;
  float32x4_t v86 = vaddq_f32(v83, vmulq_laneq_f32(v40, a2, 3));
  LODWORD(v42) = *(_DWORD *)(a1 + 28);
  v40.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v92.i8, 1), *(float *)(a1 + 16), *(float *)v92.i32);
  LODWORD(v43) = *(_DWORD *)(a1 + 36);
  *(float *)v41.f64 = *(float *)&v43
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v92.i8, 1), *(float *)&v42, *(float *)v92.i32);
  v40.i32[1] = LODWORD(v41.f64[0]);
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v41, v42, v43, v92, v44, v45);
  HIDWORD(v47) = v92.i32[1];
  float32x2_t v48 = vadd_f32((float32x2_t)v84.u32[0], *(float32x2_t *)v92.i8);
  *(float *)&double v49 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v48, 1), *(float *)(a1 + 16), v48.f32[0]);
  LODWORD(v47) = *(_DWORD *)(a1 + 24);
  v50.i32[0] = *(_DWORD *)(a1 + 28);
  v51.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v52.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v48, 1), *(float *)v50.i32, v48.f32[0]);
  float64x2_t v53 = (float64x2_t)v86;
  float32x4_t v87 = vaddq_f32(v86, vmulq_n_f32(v46, a3.f32[0]));
  v46.f32[0] = *(float *)&v47 + *(float *)&v49;
  *(float *)v53.f64 = *(float *)v51.i32 + *(float *)v52.i32;
  v46.f32[1] = *(float *)v51.i32 + *(float *)v52.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v46.i64, v53, v47, v49, v50, v52, v51);
  double v55 = COERCE_DOUBLE(__PAIR64__(a4.u32[3], -*(float *)&a4.i32[2]));
  float32x2_t v56 = vadd_f32((float32x2_t)__PAIR64__(a4.u32[3], -*(float *)&a4.i32[2]), *(float32x2_t *)v92.i8);
  *(float *)&double v57 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v56, 1), *(float *)(a1 + 16), v56.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a1 + 24);
  v58.i32[0] = *(_DWORD *)(a1 + 28);
  v59.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v56, 1), *(float *)v58.i32, v56.f32[0]);
  float64x2_t v61 = (float64x2_t)v87;
  float32x4_t v88 = vaddq_f32(v87, vmulq_lane_f32(v54, *(float32x2_t *)a3.f32, 1));
  v54.f32[0] = *(float *)&v55 + *(float *)&v57;
  *(float *)v61.f64 = *(float *)v59.i32 + *(float *)v60.i32;
  v54.f32[1] = *(float *)v59.i32 + *(float *)v60.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v54.i64, v61, v55, v57, v58, v60, v59);
  v63.i32[1] = v84.i32[1];
  v63.i32[0] = 0;
  HIDWORD(v64) = v92.i32[1];
  float32x2_t v65 = vadd_f32(v63, *(float32x2_t *)v92.i8);
  *(float *)&double v66 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v65, 1), *(float *)(a1 + 16), v65.f32[0]);
  LODWORD(v64) = *(_DWORD *)(a1 + 24);
  v67.i32[0] = *(_DWORD *)(a1 + 28);
  v68.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v65, 1), *(float *)v67.i32, v65.f32[0]);
  float64x2_t v70 = (float64x2_t)v88;
  float32x4_t v89 = vaddq_f32(v88, vmulq_laneq_f32(v62, a3, 2));
  v62.f32[0] = *(float *)&v64 + *(float *)&v66;
  *(float *)v70.f64 = *(float *)v68.i32 + *(float *)v69.i32;
  v62.f32[1] = *(float *)v68.i32 + *(float *)v69.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v62.i64, v70, v64, v66, v67, v69, v68);
  double v72 = COERCE_DOUBLE(__PAIR64__(a4.u32[3], v84.u32[0]));
  float32x2_t v73 = vadd_f32((float32x2_t)__PAIR64__(a4.u32[3], v84.u32[0]), *(float32x2_t *)v92.i8);
  *(float *)&double v74 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v73, 1), *(float *)(a1 + 16), v73.f32[0]);
  LODWORD(v72) = *(_DWORD *)(a1 + 24);
  v75.i32[0] = *(_DWORD *)(a1 + 28);
  v76.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v77.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v73, 1), *(float *)v75.i32, v73.f32[0]);
  float64x2_t v78 = (float64x2_t)v89;
  float32x4_t v93 = vaddq_f32(v89, vmulq_laneq_f32(v71, a3, 3));
  v71.f32[0] = *(float *)&v72 + *(float *)&v74;
  *(float *)v78.f64 = *(float *)v76.i32 + *(float *)v77.i32;
  v71.f32[1] = *(float *)v76.i32 + *(float *)v77.i32;
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v71.i64, v78, v72, v74, v75, v77, v76);
  *(void *)&double result = vaddq_f32(v93, vmulq_n_f32(v79, *(float *)a4.i32)).u64[0];
  return result;
}

double ___ZL18apply1DConvolutionP7CIImageP8CIVectordbb_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)-*(_DWORD *)(a1 + 32), (double)-*(_DWORD *)(a1 + 36));
  return result;
}

double ___ZL18apply1DConvolutionP7CIImageP8CIVectordbb_block_invoke_2(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)-*(_DWORD *)(a1 + 32), (double)-*(_DWORD *)(a1 + 36));
  return result;
}

double cikernel::_convolution9(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  v5.i64[0] = *(void *)CI::getDC((CI *)a1);
  int8x16_t v96 = v5;
  float64x2_t v6 = (float64x2_t)vextq_s8(a4, a4, 8uLL);
  float32x2_t v91 = *(float32x2_t *)&v6.f64[0];
  __asm { FMOV            V0.2S, #4.0 }
  float32x2_t v12 = vmul_f32(*(float32x2_t *)&v6.f64[0], _D0);
  float32x2_t v13 = vsub_f32(*(float32x2_t *)v5.i8, v12);
  *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)&v14, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)v5.i32;
  *(float *)v6.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v13.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v13, v6, *(double *)v5.i64, v14, v16, v15, v17);
  __asm { FMOV            V1.2S, #3.0 }
  HIDWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = v91.i32[1];
  float32x2_t v21 = vmul_f32(v91, _D1);
  float32x2_t v22 = vsub_f32(*(float32x2_t *)v96.i8, v21);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v24.i32, v22.f32[0]);
  float32x4_t v27 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  float32x4_t v85 = vaddq_f32(v27, vmulq_n_f32(v18, a2.f32[0]));
  v18.f32[0] = *(float *)&v20 + *(float *)&v23;
  v27.f32[0] = *(float *)v25.i32 + *(float *)v26.i32;
  v18.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, (float64x2_t)v27, v20, v23, v24, v26, v25);
  float32x2_t v29 = vadd_f32(v91, v91);
  float32x2_t v30 = vsub_f32(*(float32x2_t *)v96.i8, v29);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  v34.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)v33.i32, v30.f32[0]);
  float64x2_t v36 = (float64x2_t)v85;
  float32x4_t v86 = vaddq_f32(v85, vmulq_lane_f32(v28, *(float32x2_t *)a2.f32, 1));
  v28.f32[0] = *(float *)&v32 + *(float *)&v31;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v28.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v36, v32, v31, v33, v35, v34);
  HIDWORD(v3_Block_object_dispose(&STACK[0x3A0], 8) = v96.i32[1];
  float32x2_t v39 = vsub_f32(*(float32x2_t *)v96.i8, v91);
  *(float *)&double v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v39, 1), *(float *)(a1 + 16), v39.f32[0]);
  LODWORD(v3_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v41.i32[0] = *(_DWORD *)(a1 + 28);
  v42.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v39, 1), *(float *)v41.i32, v39.f32[0]);
  float64x2_t v44 = (float64x2_t)v86;
  float32x4_t v87 = vaddq_f32(v86, vmulq_laneq_f32(v37, a2, 2));
  v37.f32[0] = *(float *)&v38 + *(float *)&v40;
  *(float *)v44.f64 = *(float *)v42.i32 + *(float *)v43.i32;
  v37.f32[1] = *(float *)v42.i32 + *(float *)v43.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v44, v38, v40, v41, v43, v42);
  float64x2_t v46 = (float64x2_t)v87;
  float32x4_t v90 = vaddq_f32(v87, vmulq_laneq_f32(v45, a2, 3));
  LODWORD(v47) = *(_DWORD *)(a1 + 28);
  v45.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v96.i8, 1), *(float *)(a1 + 16), *(float *)v96.i32);
  LODWORD(v4_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 36);
  *(float *)v46.f64 = *(float *)&v48
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v96.i8, 1), *(float *)&v47, *(float *)v96.i32);
  v45.i32[1] = LODWORD(v46.f64[0]);
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v46, v47, v48, v96, v49, v50);
  HIDWORD(v52) = v96.i32[1];
  float32x2_t v53 = vadd_f32(v91, *(float32x2_t *)v96.i8);
  *(float *)&double v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v53, 1), *(float *)(a1 + 16), v53.f32[0]);
  LODWORD(v52) = *(_DWORD *)(a1 + 24);
  v55.i32[0] = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v53, 1), *(float *)v55.i32, v53.f32[0]);
  float64x2_t v58 = (float64x2_t)v90;
  float32x4_t v92 = vaddq_f32(v90, vmulq_n_f32(v51, a3.f32[0]));
  v51.f32[0] = *(float *)&v52 + *(float *)&v54;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v51.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v51.i64, v58, v52, v54, v55, v57, v56);
  float32x2_t v60 = vadd_f32(v29, *(float32x2_t *)v96.i8);
  *(float *)&double v61 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v60, 1), *(float *)(a1 + 16), v60.f32[0]);
  LODWORD(v62) = *(_DWORD *)(a1 + 24);
  v63.i32[0] = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v60, 1), *(float *)v63.i32, v60.f32[0]);
  float64x2_t v66 = (float64x2_t)v92;
  float32x4_t v93 = vaddq_f32(v92, vmulq_lane_f32(v59, *(float32x2_t *)a3.f32, 1));
  v59.f32[0] = *(float *)&v62 + *(float *)&v61;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v59.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v59.i64, v66, v62, v61, v63, v65, v64);
  float32x2_t v68 = vadd_f32(v21, *(float32x2_t *)v96.i8);
  *(float *)&double v69 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v68, 1), *(float *)(a1 + 16), v68.f32[0]);
  LODWORD(v7CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v71.i32[0] = *(_DWORD *)(a1 + 28);
  v72.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v68, 1), *(float *)v71.i32, v68.f32[0]);
  float64x2_t v74 = (float64x2_t)v93;
  float32x4_t v94 = vaddq_f32(v93, vmulq_laneq_f32(v67, a3, 2));
  v67.f32[0] = *(float *)&v70 + *(float *)&v69;
  *(float *)v74.f64 = *(float *)v72.i32 + *(float *)v73.i32;
  v67.f32[1] = *(float *)v72.i32 + *(float *)v73.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v67.i64, v74, v70, v69, v71, v73, v72);
  float32x2_t v76 = vadd_f32(v12, *(float32x2_t *)v96.i8);
  *(float *)&double v77 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v76, 1), *(float *)(a1 + 16), v76.f32[0]);
  LODWORD(v7_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v79.i32[0] = *(_DWORD *)(a1 + 28);
  v80.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v81.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v76, 1), *(float *)v79.i32, v76.f32[0]);
  float64x2_t v82 = (float64x2_t)v94;
  float32x4_t v97 = vaddq_f32(v94, vmulq_laneq_f32(v75, a3, 3));
  v75.f32[0] = *(float *)&v78 + *(float *)&v77;
  *(float *)v82.f64 = *(float *)v80.i32 + *(float *)v81.i32;
  v75.f32[1] = *(float *)v80.i32 + *(float *)v81.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v75.i64, v82, v78, v77, v79, v81, v80);
  *(void *)&double result = vaddq_f32(v97, vmulq_n_f32(v83, *(float *)a4.i32)).u64[0];
  return result;
}

double cikernel::_convolution7(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  v5.i64[0] = *(void *)CI::getDC((CI *)a1);
  int8x16_t v76 = v5;
  float32x4_t v67 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  float64x2_t v6 = (float64x2_t)vextq_s8(a4, a4, 8uLL);
  a4.i64[0] = *(void *)&v6.f64[0];
  __asm { FMOV            V0.2S, #3.0 }
  float32x2_t v12 = vmul_f32(*(float32x2_t *)&v6.f64[0], _D0);
  float32x2_t v13 = vsub_f32(*(float32x2_t *)v5.i8, v12);
  *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)&v14, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)v5.i32;
  *(float *)v6.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v13.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v13, v6, *(double *)v5.i64, v14, v16, v15, v17);
  float32x2_t v19 = vadd_f32(*(float32x2_t *)a4.i8, *(float32x2_t *)a4.i8);
  float32x2_t v20 = vsub_f32(*(float32x2_t *)v76.i8, v19);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 24);
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v67;
  float32x4_t v68 = vaddq_f32(v67, vmulq_lane_f32(v18, *(float32x2_t *)a2.f32, 1));
  v18.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v18.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v26, v22, v21, v23, v25, v24);
  HIDWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = v76.i32[1];
  float32x2_t v29 = vsub_f32(*(float32x2_t *)v76.i8, *(float32x2_t *)a4.i8);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v29, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v29, 1), *(float *)v31.i32, v29.f32[0]);
  float64x2_t v34 = (float64x2_t)v68;
  float32x4_t v69 = vaddq_f32(v68, vmulq_laneq_f32(v27, a2, 2));
  v27.f32[0] = *(float *)&v28 + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v34, v28, v30, v31, v33, v32);
  float64x2_t v36 = (float64x2_t)v69;
  float32x4_t v71 = vaddq_f32(v69, vmulq_laneq_f32(v35, a2, 3));
  LODWORD(v37) = *(_DWORD *)(a1 + 28);
  v35.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v76.i8, 1), *(float *)(a1 + 16), *(float *)v76.i32);
  LODWORD(v3_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 36);
  *(float *)v36.f64 = *(float *)&v38
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v76.i8, 1), *(float *)&v37, *(float *)v76.i32);
  v35.i32[1] = LODWORD(v36.f64[0]);
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v36, v37, v38, v76, v39, v40);
  HIDWORD(v42) = v76.i32[1];
  float32x2_t v43 = vadd_f32(*(float32x2_t *)a4.i8, *(float32x2_t *)v76.i8);
  *(float *)&double v44 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v43, 1), *(float *)(a1 + 16), v43.f32[0]);
  LODWORD(v42) = *(_DWORD *)(a1 + 24);
  v45.i32[0] = *(_DWORD *)(a1 + 28);
  v46.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v43, 1), *(float *)v45.i32, v43.f32[0]);
  float64x2_t v48 = (float64x2_t)v71;
  float32x4_t v73 = vaddq_f32(v71, vmulq_n_f32(v41, a3.f32[0]));
  v41.f32[0] = *(float *)&v42 + *(float *)&v44;
  *(float *)v48.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  v41.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, v48, v42, v44, v45, v47, v46);
  float32x2_t v50 = vadd_f32(v19, *(float32x2_t *)v76.i8);
  *(float *)&double v51 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v50, 1), *(float *)(a1 + 16), v50.f32[0]);
  LODWORD(v52) = *(_DWORD *)(a1 + 24);
  v53.i32[0] = *(_DWORD *)(a1 + 28);
  v54.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v50, 1), *(float *)v53.i32, v50.f32[0]);
  float64x2_t v56 = (float64x2_t)v73;
  float32x4_t v74 = vaddq_f32(v73, vmulq_lane_f32(v49, *(float32x2_t *)a3.f32, 1));
  v49.f32[0] = *(float *)&v52 + *(float *)&v51;
  *(float *)v56.f64 = *(float *)v54.i32 + *(float *)v55.i32;
  v49.f32[1] = *(float *)v54.i32 + *(float *)v55.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v49.i64, v56, v52, v51, v53, v55, v54);
  float32x2_t v58 = vadd_f32(v12, *(float32x2_t *)v76.i8);
  *(float *)&double v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v58, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v61.i32[0] = *(_DWORD *)(a1 + 28);
  v62.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v58, 1), *(float *)v61.i32, v58.f32[0]);
  float64x2_t v64 = (float64x2_t)v74;
  float32x4_t v77 = vaddq_f32(v74, vmulq_laneq_f32(v57, a3, 2));
  v57.f32[0] = *(float *)&v60 + *(float *)&v59;
  *(float *)v64.f64 = *(float *)v62.i32 + *(float *)v63.i32;
  v57.f32[1] = *(float *)v62.i32 + *(float *)v63.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v57.i64, v64, v60, v59, v61, v63, v62);
  *(void *)&double result = vaddq_f32(v77, vmulq_laneq_f32(v65, a3, 3)).u64[0];
  return result;
}

float32x4_t cikernel::_convolutionrgb9(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v6.i8 = *DC;
  float32x2_t v93 = *DC;
  *(float *)&double v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 36);
  int8x16_t v89 = vextq_s8(a4, a4, 8uLL);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v9, *(double *)v89.i64, v8, a4, v6, v10);
  float32x4_t v85 = _Q0;
  __asm { FMOV            V0.2S, #4.0 }
  float64x2_t v16 = (float64x2_t)v89;
  float32x2_t v17 = vmul_f32(*(float32x2_t *)v89.i8, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)_Q0.f32 = vsub_f32(v93, v17);
  *(float *)&double v18 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a1 + 28);
  v20.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v19, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v18;
  *(float *)v16.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  _Q0.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v16, v18, v19, v21, v20, v22);
  __asm { FMOV            V1.2S, #3.0 }
  HIDWORD(v25) = v89.i32[1];
  float32x2_t v26 = vmul_f32(*(float32x2_t *)v89.i8, _D1);
  float32x2_t v27 = vsub_f32(v93, v26);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v27, 1), *(float *)(a1 + 16), v27.f32[0]);
  LODWORD(v25) = *(_DWORD *)(a1 + 24);
  v29.i32[0] = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v27, 1), *(float *)v29.i32, v27.f32[0]);
  float32x4_t v32 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  float32x4_t v82 = vaddq_f32(v32, vmulq_n_f32(v23, a2.f32[0]));
  v23.f32[0] = *(float *)&v25 + *(float *)&v28;
  v32.f32[0] = *(float *)v30.i32 + *(float *)v31.i32;
  v23.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, (float64x2_t)v32, v25, v28, v29, v31, v30);
  float32x2_t v34 = vadd_f32(*(float32x2_t *)v89.i8, *(float32x2_t *)v89.i8);
  float32x2_t v35 = vsub_f32(v93, v34);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v35, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 24);
  v38.i32[0] = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v35, 1), *(float *)v38.i32, v35.f32[0]);
  float64x2_t v41 = (float64x2_t)v82;
  float32x4_t v83 = vaddq_f32(v82, vmulq_lane_f32(v33, *(float32x2_t *)a2.f32, 1));
  v33.f32[0] = *(float *)&v37 + *(float *)&v36;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v33.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v41, v37, v36, v38, v40, v39);
  HIDWORD(v43) = v89.i32[1];
  float32x2_t v44 = vsub_f32(v93, *(float32x2_t *)v89.i8);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v44, 1), *(float *)(a1 + 16), v44.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 24);
  v46.i32[0] = *(_DWORD *)(a1 + 28);
  v47.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v44, 1), *(float *)v46.i32, v44.f32[0]);
  float64x2_t v49 = (float64x2_t)v83;
  float32x4_t v84 = vaddq_f32(v83, vmulq_laneq_f32(v42, a2, 2));
  v42.f32[0] = *(float *)&v43 + *(float *)&v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v42.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v49, v43, v45, v46, v48, v47);
  HIDWORD(v51) = v89.i32[1];
  float32x2_t v52 = vadd_f32(*(float32x2_t *)v89.i8, v93);
  *(float *)&double v53 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v52, 1), *(float *)(a1 + 16), v52.f32[0]);
  LODWORD(v51) = *(_DWORD *)(a1 + 24);
  v54.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v52, 1), *(float *)(a1 + 28), v52.f32[0]);
  float32x4_t v56 = vmulq_n_f32(v85, a3.f32[0]);
  float32x4_t v90 = vaddq_f32(v56, vaddq_f32(v84, vmulq_laneq_f32(v50, a2, 3)));
  v50.f32[0] = *(float *)&v51 + *(float *)&v53;
  v56.f32[0] = *(float *)v54.i32 + *(float *)v55.i32;
  v50.f32[1] = *(float *)v54.i32 + *(float *)v55.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v50.i64, (float64x2_t)v56, v51, v53, (int8x16_t)v85, v55, v54);
  float32x2_t v58 = vadd_f32(v34, v93);
  *(float *)&double v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v58, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v61.i32[0] = *(_DWORD *)(a1 + 28);
  v62.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v58, 1), *(float *)v61.i32, v58.f32[0]);
  float64x2_t v64 = (float64x2_t)v90;
  float32x4_t v91 = vaddq_f32(v90, vmulq_lane_f32(v57, *(float32x2_t *)a3.f32, 1));
  v57.f32[0] = *(float *)&v60 + *(float *)&v59;
  *(float *)v64.f64 = *(float *)v62.i32 + *(float *)v63.i32;
  v57.f32[1] = *(float *)v62.i32 + *(float *)v63.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v57.i64, v64, v60, v59, v61, v63, v62);
  float32x2_t v66 = vadd_f32(v26, v93);
  *(float *)&double v67 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v66, 1), *(float *)(a1 + 16), v66.f32[0]);
  LODWORD(v6_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v69.i32[0] = *(_DWORD *)(a1 + 28);
  v70.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v66, 1), *(float *)v69.i32, v66.f32[0]);
  float64x2_t v72 = (float64x2_t)v91;
  float32x4_t v92 = vaddq_f32(v91, vmulq_laneq_f32(v65, a3, 2));
  v65.f32[0] = *(float *)&v68 + *(float *)&v67;
  *(float *)v72.f64 = *(float *)v70.i32 + *(float *)v71.i32;
  v65.f32[1] = *(float *)v70.i32 + *(float *)v71.i32;
  *(double *)v73.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v72, v68, v67, v69, v71, v70);
  float32x2_t v74 = vadd_f32(v17, v93);
  *(float *)&double v75 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v74, 1), *(float *)(a1 + 16), v74.f32[0]);
  LODWORD(v76) = *(_DWORD *)(a1 + 24);
  v77.i32[0] = *(_DWORD *)(a1 + 28);
  v78.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v79.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v74, 1), *(float *)v77.i32, v74.f32[0]);
  float64x2_t v80 = (float64x2_t)v92;
  float32x4_t v94 = vaddq_f32(v92, vmulq_laneq_f32(v73, a3, 3));
  v73.f32[0] = *(float *)&v76 + *(float *)&v75;
  *(float *)v80.f64 = *(float *)v78.i32 + *(float *)v79.i32;
  v73.f32[1] = *(float *)v78.i32 + *(float *)v79.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v73.i64, v80, v76, v75, v77, v79, v78);
  result.i64[0] = vaddq_f32(v94, vmulq_n_f32(result, *(float *)a4.i32)).u64[0];
  result.i32[3] = v85.i32[3];
  return result;
}

double cikernel::_convolutionrgb7(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v6.i8 = *DC;
  float32x2_t v76 = *DC;
  int8x16_t v7 = a4;
  float32x4_t v66 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  *(float *)&double v8 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v9) = *(_DWORD *)(a1 + 36);
  int8x16_t v72 = vextq_s8(v7, v7, 8uLL);
  *(float *)v10.f64 = *(float *)&v9
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v_Block_object_dispose(&STACK[0x3A0], 8) = LODWORD(v10.f64[0]);
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v8, v10, *(double *)v72.i64, v9, v6, v7, v11);
  float32x4_t v69 = _Q0;
  __asm { FMOV            V0.2S, #3.0 }
  float64x2_t v17 = (float64x2_t)v72;
  float32x2_t v18 = vmul_f32(*(float32x2_t *)v72.i8, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)_Q0.f32 = vsub_f32(v76, v18);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v20, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v17.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  _Q0.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v17, v19, v20, v22, v21, v23);
  float32x2_t v25 = vadd_f32(*(float32x2_t *)v72.i8, *(float32x2_t *)v72.i8);
  float32x2_t v26 = vsub_f32(v76, v25);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v26, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v29.i32[0] = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v26, 1), *(float *)v29.i32, v26.f32[0]);
  float64x2_t v32 = (float64x2_t)v66;
  float32x4_t v67 = vaddq_f32(v66, vmulq_lane_f32(v24, *(float32x2_t *)a2.f32, 1));
  v24.f32[0] = *(float *)&v28 + *(float *)&v27;
  *(float *)v32.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v24.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v24.i64, v32, v28, v27, v29, v31, v30);
  HIDWORD(v34) = v72.i32[1];
  float32x2_t v35 = vsub_f32(v76, *(float32x2_t *)v72.i8);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v35, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v34) = *(_DWORD *)(a1 + 24);
  v37.i32[0] = *(_DWORD *)(a1 + 28);
  v38.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v35, 1), *(float *)v37.i32, v35.f32[0]);
  float64x2_t v40 = (float64x2_t)v67;
  float32x4_t v68 = vaddq_f32(v67, vmulq_laneq_f32(v33, a2, 2));
  v33.f32[0] = *(float *)&v34 + *(float *)&v36;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v33.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v40, v34, v36, v37, v39, v38);
  HIDWORD(v42) = v72.i32[1];
  float32x2_t v43 = vadd_f32(*(float32x2_t *)v72.i8, v76);
  *(float *)&double v44 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v43, 1), *(float *)(a1 + 16), v43.f32[0]);
  LODWORD(v42) = *(_DWORD *)(a1 + 24);
  v45.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v43, 1), *(float *)(a1 + 28), v43.f32[0]);
  float32x4_t v47 = vmulq_n_f32(v69, a3.f32[0]);
  float32x4_t v73 = vaddq_f32(v47, vaddq_f32(v68, vmulq_laneq_f32(v41, a2, 3)));
  v41.f32[0] = *(float *)&v42 + *(float *)&v44;
  v47.f32[0] = *(float *)v45.i32 + *(float *)v46.i32;
  v41.f32[1] = *(float *)v45.i32 + *(float *)v46.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, (float64x2_t)v47, v42, v44, (int8x16_t)v69, v46, v45);
  float32x2_t v49 = vadd_f32(v25, v76);
  *(float *)&double v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v49, 1), *(float *)(a1 + 16), v49.f32[0]);
  LODWORD(v51) = *(_DWORD *)(a1 + 24);
  v52.i32[0] = *(_DWORD *)(a1 + 28);
  v53.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v49, 1), *(float *)v52.i32, v49.f32[0]);
  float64x2_t v55 = (float64x2_t)v73;
  float32x4_t v74 = vaddq_f32(v73, vmulq_lane_f32(v48, *(float32x2_t *)a3.f32, 1));
  v48.f32[0] = *(float *)&v51 + *(float *)&v50;
  *(float *)v55.f64 = *(float *)v53.i32 + *(float *)v54.i32;
  v48.f32[1] = *(float *)v53.i32 + *(float *)v54.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v55, v51, v50, v52, v54, v53);
  float32x2_t v57 = vadd_f32(v18, v76);
  *(float *)&double v58 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v57, 1), *(float *)(a1 + 16), v57.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 24);
  v60.i32[0] = *(_DWORD *)(a1 + 28);
  v61.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v57, 1), *(float *)v60.i32, v57.f32[0]);
  float64x2_t v63 = (float64x2_t)v74;
  float32x4_t v77 = vaddq_f32(v74, vmulq_laneq_f32(v56, a3, 2));
  v56.f32[0] = *(float *)&v59 + *(float *)&v58;
  *(float *)v63.f64 = *(float *)v61.i32 + *(float *)v62.i32;
  v56.f32[1] = *(float *)v61.i32 + *(float *)v62.i32;
  *(double *)v64.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v56.i64, v63, v59, v58, v60, v62, v61);
  *(void *)&double result = vaddq_f32(v77, vmulq_laneq_f32(v64, a3, 3)).u64[0];
  return result;
}

double cikernel::_convolution5(uint64_t a1, float32x4_t a2, int8x16_t a3)
{
  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  int8x16_t v50 = (int8x16_t)v4;
  int32x4_t v5 = vdupq_lane_s32(*(int32x2_t *)a3.i8, 1);
  float32x4_t v44 = (float32x4_t)v5;
  float32x2_t v47 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  float32x2_t v6 = vadd_f32(v47, v47);
  float32x2_t v7 = vsub_f32(*(float32x2_t *)&v4.f64[0], v6);
  *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v7, 1), *(float *)(a1 + 16), v7.f32[0]);
  LODWORD(v_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v7, 1), *(float *)&v8, v7.f32[0]);
  v7.f32[0] = *(float *)(a1 + 24) + *(float *)v5.i32;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v7.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v7, v4, *(double *)v5.i64, v8, v10, v9, v11);
  HIDWORD(v13) = v50.i32[1];
  float32x2_t v14 = vsub_f32(*(float32x2_t *)v50.i8, v47);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 24);
  v16.i32[0] = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)v16.i32, v14.f32[0]);
  float64x2_t v19 = (float64x2_t)v44;
  float32x4_t v45 = vaddq_f32(v44, vmulq_n_f32(v12, a2.f32[0]));
  v12.f32[0] = *(float *)&v13 + *(float *)&v15;
  *(float *)v19.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v12.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v19, v13, v15, v16, v18, v17);
  float64x2_t v21 = (float64x2_t)v45;
  float32x4_t v46 = vaddq_f32(v45, vmulq_lane_f32(v20, *(float32x2_t *)a2.f32, 1));
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v20.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v50.i8, 1), *(float *)(a1 + 16), *(float *)v50.i32);
  LODWORD(v23) = *(_DWORD *)(a1 + 36);
  *(float *)v21.f64 = *(float *)&v23
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v50.i8, 1), *(float *)&v22, *(float *)v50.i32);
  v20.i32[1] = LODWORD(v21.f64[0]);
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v21, v22, v23, v50, v24, v25);
  HIDWORD(v27) = v50.i32[1];
  float32x2_t v28 = vadd_f32(v47, *(float32x2_t *)v50.i8);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 24);
  v30.i32[0] = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v30.i32, v28.f32[0]);
  float64x2_t v33 = (float64x2_t)v46;
  float32x4_t v48 = vaddq_f32(v46, vmulq_laneq_f32(v26, a2, 2));
  v26.f32[0] = *(float *)&v27 + *(float *)&v29;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v26.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v33, v27, v29, v30, v32, v31);
  float32x2_t v35 = vadd_f32(v6, *(float32x2_t *)v50.i8);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v35, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 24);
  v38.i32[0] = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v35, 1), *(float *)v38.i32, v35.f32[0]);
  float64x2_t v41 = (float64x2_t)v48;
  float32x4_t v52 = vaddq_f32(v48, vmulq_laneq_f32(v34, a2, 3));
  v34.f32[0] = *(float *)&v37 + *(float *)&v36;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v34.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v41, v37, v36, v38, v40, v39);
  *(void *)&double result = vaddq_f32(v52, vmulq_n_f32(v42, *(float *)a3.i32)).u64[0];
  return result;
}

void CI::f4_sr_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  float32x4_t v12 = *(double (**)(uint64_t, __n128, __n128))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  int v14 = *(_DWORD *)(v11 + 40);
  uint64_t v15 = *(void *)(v11 + 32);
  int v16 = *(_DWORD *)(v11 + 64);
  uint64_t v17 = *(void *)(v11 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 80)), a2);
  }
  int8x16_t v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x16_t v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  float64x2_t v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    float64x2_t v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v20 = v12(a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_convolution3(uint64_t a1, float32x4_t a2, int8x16_t a3)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  int8x16_t v5 = a3;
  int32x4_t v6 = vdupq_lane_s32(*(int32x2_t *)a3.i8, 1);
  v7.f64[0] = *(float64_t *)DC;
  int8x16_t v31 = (int8x16_t)v7;
  float32x4_t v28 = (float32x4_t)v6;
  a3.i64[0] = vextq_s8(v5, v5, 8uLL).u64[0];
  float32x2_t v8 = vsub_f32(*DC, *(float32x2_t *)a3.i8);
  *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v8, 1), *(float *)(a1 + 16), v8.f32[0]);
  v6.i32[0] = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v8, 1), *(float *)v6.i32, v8.f32[0]);
  v8.f32[0] = *(float *)(a1 + 24) + *(float *)v5.i32;
  *(float *)v7.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v8.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v8, v7, *(double *)v5.i64, *(double *)v6.i64, v10, v9, v11);
  float64x2_t v13 = (float64x2_t)v28;
  float32x4_t v29 = vaddq_f32(v28, vmulq_lane_f32(v12, *(float32x2_t *)a2.f32, 1));
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v12.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v31.i8, 1), *(float *)(a1 + 16), *(float *)v31.i32);
  LODWORD(v15) = *(_DWORD *)(a1 + 36);
  *(float *)v13.f64 = *(float *)&v15
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v31.i8, 1), *(float *)&v14, *(float *)v31.i32);
  v12.i32[1] = LODWORD(v13.f64[0]);
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v13, v14, v15, v31, v16, v17);
  HIDWORD(v19) = v31.i32[1];
  float32x2_t v20 = vadd_f32(*(float32x2_t *)a3.i8, *(float32x2_t *)v31.i8);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a1 + 24);
  v22.i32[0] = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)v22.i32, v20.f32[0]);
  float64x2_t v25 = (float64x2_t)v29;
  float32x4_t v32 = vaddq_f32(v29, vmulq_laneq_f32(v18, a2, 2));
  v18.f32[0] = *(float *)&v19 + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v18.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v25, v19, v21, v22, v24, v23);
  *(void *)&double result = vaddq_f32(v32, vmulq_laneq_f32(v26, a2, 3)).u64[0];
  return result;
}

float32x4_t cikernel::_convolutionrgb5(uint64_t a1, float32x4_t a2, int8x16_t a3)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v5.i8 = *DC;
  float32x2_t v48 = *DC;
  *(float *)&double v6 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v7) = *(_DWORD *)(a1 + 36);
  float32x2_t v45 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(float *)v8.f64 = *(float *)&v7
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v6) = LODWORD(v8.f64[0]);
  *(double *)v10.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v6, v8, *(double *)&v45, v7, a3, v5, v9);
  float32x4_t v43 = v10;
  float32x2_t v11 = vadd_f32(v45, v45);
  *(float32x2_t *)v10.f32 = vsub_f32(v48, v11);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v10.f32, 1), *(float *)(a1 + 16), v10.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v10.f32, 1), *(float *)&v13, v10.f32[0]);
  v10.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v10.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v10.i64, v16, v12, v13, v15, v14, v17);
  HIDWORD(v19) = v45.i32[1];
  float32x2_t v20 = vsub_f32(v48, v45);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a1 + 24);
  v22.i32[0] = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)v22.i32, v20.f32[0]);
  float32x4_t v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a3.i8, 1);
  float32x4_t v42 = vaddq_f32(v25, vmulq_n_f32(v18, a2.f32[0]));
  v18.f32[0] = *(float *)&v19 + *(float *)&v21;
  v25.f32[0] = *(float *)v23.i32 + *(float *)v24.i32;
  v18.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, (float64x2_t)v25, v19, v21, v22, v24, v23);
  HIDWORD(v27) = v45.i32[1];
  float32x2_t v28 = vadd_f32(v45, v48);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 24);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)(a1 + 28), v28.f32[0]);
  float32x4_t v32 = vmulq_laneq_f32(v43, a2, 2);
  float32x4_t v46 = vaddq_f32(v32, vaddq_f32(v42, vmulq_lane_f32(v26, *(float32x2_t *)a2.f32, 1)));
  v26.f32[0] = *(float *)&v27 + *(float *)&v29;
  v32.f32[0] = *(float *)v30.i32 + *(float *)v31.i32;
  v26.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, (float64x2_t)v32, v27, v29, (int8x16_t)a2, v31, v30);
  float32x2_t v34 = vadd_f32(v11, v48);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v34, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 24);
  v37.i32[0] = *(_DWORD *)(a1 + 28);
  v38.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v34, 1), *(float *)v37.i32, v34.f32[0]);
  float64x2_t v40 = (float64x2_t)v46;
  float32x4_t v49 = vaddq_f32(v46, vmulq_laneq_f32(v33, a2, 3));
  v33.f32[0] = *(float *)&v36 + *(float *)&v35;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v33.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v40, v36, v35, v37, v39, v38);
  result.i64[0] = vaddq_f32(v49, vmulq_n_f32(result, *(float *)a3.i32)).u64[0];
  result.i32[3] = v43.i32[3];
  return result;
}

float32x4_t cikernel::_convolutionrgb3(uint64_t a1, float32x4_t a2, int8x16_t a3)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v5.i8 = *DC;
  float32x4_t v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a3.i8, 1);
  *(float *)&double v6 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v7) = *(_DWORD *)(a1 + 36);
  int8x16_t v26 = vextq_s8(a3, a3, 8uLL);
  float32x2_t v27 = *DC;
  *(float *)v8.f64 = *(float *)&v7
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v6) = LODWORD(v8.f64[0]);
  *(double *)v10.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v6, v8, *(double *)v26.i64, v7, v5, a3, v9);
  float32x4_t v30 = v10;
  float64x2_t v11 = (float64x2_t)v26;
  *(float32x2_t *)v10.f32 = vsub_f32(v27, *(float32x2_t *)v26.i8);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v10.f32, 1), *(float *)(a1 + 16), v10.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v10.f32, 1), *(float *)&v13, v10.f32[0]);
  v10.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v11.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v10.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v10.i64, v11, v12, v13, v15, v14, v16);
  HIDWORD(v1_Block_object_dispose(&STACK[0x3A0], 8) = v26.i32[1];
  float32x2_t v19 = vadd_f32(*(float32x2_t *)v26.i8, v27);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v19, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v1_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v19, 1), *(float *)(a1 + 28), v19.f32[0]);
  float32x4_t v23 = vmulq_laneq_f32(v30, a2, 2);
  float32x4_t v28 = vaddq_f32(v23, vaddq_f32(v25, vmulq_lane_f32(v17, *(float32x2_t *)a2.f32, 1)));
  v17.f32[0] = *(float *)&v18 + *(float *)&v20;
  v23.f32[0] = *(float *)v21.i32 + *(float *)v22.i32;
  v17.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, (float64x2_t)v23, v18, v20, (int8x16_t)a2, v22, v21);
  result.i64[0] = vaddq_f32(v28, vmulq_laneq_f32(result, a2, 3)).u64[0];
  result.i32[3] = v30.i32[3];
  return result;
}

float32x4_t cikernel::_convolutionrgb5x5(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, int8x16_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  float64x2_t v10 = (float64x2_t)vdupq_lane_s32(*(int32x2_t *)a8.i8, 1);
  float32x4_t v210 = (float32x4_t)v10;
  *(float32x2_t *)v11.i8 = *DC;
  int8x16_t v239 = vextq_s8(a8, a8, 8uLL);
  *(float *)&double v12 = *(float *)(a1 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v13) = *(_DWORD *)(a1 + 36);
  *(float32x2_t *)&double v242 = vadd_f32(*(float32x2_t *)v239.i8, *(float32x2_t *)v239.i8);
  float64x2_t v243 = (float64x2_t)v11;
  *(float *)v10.f64 = *(float *)&v13
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v12) = LODWORD(v10.f64[0]);
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v12, v10, v242, v13, v11, v239, v14);
  float32x4_t v214 = v15;
  v15.f32[0] = -*(float *)&v242;
  v15.f32[1] = -*((float *)&v242 + 1);
  float64x2_t v16 = v243;
  *(float32x2_t *)v15.f32 = vadd_f32(*(float32x2_t *)v15.f32, *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v15.f32, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v1_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 28);
  v19.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v15.f32, 1), *(float *)&v18, v15.f32[0]);
  v15.f32[0] = *(float *)(a1 + 24) + *(float *)&v17;
  *(float *)v16.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v15.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v15.i64, v16, v17, v18, v20, v19, v21);
  v23.f32[0] = -*(float *)&a8.i32[2];
  v23.f32[1] = -*((float *)&v242 + 1);
  HIDWORD(v24) = HIDWORD(v243.f64[0]);
  float32x2_t v25 = vadd_f32(v23, *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v25, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 24);
  v27.i32[0] = *(_DWORD *)(a1 + 28);
  v28.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v25, 1), *(float *)v27.i32, v25.f32[0]);
  float64x2_t v30 = (float64x2_t)v210;
  float32x4_t v211 = vaddq_f32(v210, vmulq_n_f32(v22, a2.f32[0]));
  v22.f32[0] = *(float *)&v24 + *(float *)&v26;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v22.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v30, v24, v26, v27, v29, v28);
  v32.i32[0] = 0;
  v32.f32[1] = -*((float *)&v242 + 1);
  HIDWORD(v33) = HIDWORD(v243.f64[0]);
  float32x2_t v34 = vadd_f32(v32, *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v34, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a1 + 24);
  v36.i32[0] = *(_DWORD *)(a1 + 28);
  v37.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v34, 1), *(float *)v36.i32, v34.f32[0]);
  float64x2_t v39 = (float64x2_t)v211;
  float32x4_t v212 = vaddq_f32(v211, vmulq_lane_f32(v31, *(float32x2_t *)a2.f32, 1));
  v31.f32[0] = *(float *)&v33 + *(float *)&v35;
  *(float *)v39.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v31.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v39, v33, v35, v36, v38, v37);
  HIDWORD(v41) = HIDWORD(v243.f64[0]);
  float32x2_t v42 = vadd_f32((float32x2_t)__PAIR64__(-*((float *)&v242 + 1), v239.u32[0]), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v42, 1), *(float *)(a1 + 16), v42.f32[0]);
  LODWORD(v41) = *(_DWORD *)(a1 + 24);
  v44.i32[0] = *(_DWORD *)(a1 + 28);
  v45.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v42, 1), *(float *)v44.i32, v42.f32[0]);
  float64x2_t v47 = (float64x2_t)v212;
  float32x4_t v213 = vaddq_f32(v212, vmulq_laneq_f32(v40, a2, 2));
  v40.f32[0] = *(float *)&v41 + *(float *)&v43;
  *(float *)v47.f64 = *(float *)v45.i32 + *(float *)v46.i32;
  v40.f32[1] = *(float *)v45.i32 + *(float *)v46.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v47, v41, v43, v44, v46, v45);
  HIDWORD(v49) = HIDWORD(v243.f64[0]);
  float32x2_t v50 = vadd_f32((float32x2_t)__PAIR64__(-*((float *)&v242 + 1), LODWORD(v242)), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v51 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v50, 1), *(float *)(a1 + 16), v50.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a1 + 24);
  v52.i32[0] = *(_DWORD *)(a1 + 28);
  v53.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v50, 1), *(float *)v52.i32, v50.f32[0]);
  float64x2_t v55 = (float64x2_t)v213;
  float32x4_t v215 = vaddq_f32(v213, vmulq_laneq_f32(v48, a2, 3));
  v48.f32[0] = *(float *)&v49 + *(float *)&v51;
  *(float *)v55.f64 = *(float *)v53.i32 + *(float *)v54.i32;
  v48.f32[1] = *(float *)v53.i32 + *(float *)v54.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v55, v49, v51, v52, v54, v53);
  HIDWORD(v57) = HIDWORD(v243.f64[0]);
  float32x2_t v58 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], -*(float *)&v242), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v58, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v57) = *(_DWORD *)(a1 + 24);
  v60.i32[0] = *(_DWORD *)(a1 + 28);
  v61.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v58, 1), *(float *)v60.i32, v58.f32[0]);
  float64x2_t v63 = (float64x2_t)v215;
  float32x4_t v216 = vaddq_f32(v215, vmulq_n_f32(v56, a3.f32[0]));
  v56.f32[0] = *(float *)&v57 + *(float *)&v59;
  *(float *)v63.f64 = *(float *)v61.i32 + *(float *)v62.i32;
  v56.f32[1] = *(float *)v61.i32 + *(float *)v62.i32;
  *(double *)v64.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v56.i64, v63, v57, v59, v60, v62, v61);
  HIDWORD(v65) = HIDWORD(v243.f64[0]);
  float32x2_t v66 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], -*(float *)&a8.i32[2]), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v67 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v66, 1), *(float *)(a1 + 16), v66.f32[0]);
  LODWORD(v65) = *(_DWORD *)(a1 + 24);
  v68.i32[0] = *(_DWORD *)(a1 + 28);
  v69.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v70.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v66, 1), *(float *)v68.i32, v66.f32[0]);
  float64x2_t v71 = (float64x2_t)v216;
  float32x4_t v217 = vaddq_f32(v216, vmulq_lane_f32(v64, *(float32x2_t *)a3.f32, 1));
  v64.f32[0] = *(float *)&v65 + *(float *)&v67;
  *(float *)v71.f64 = *(float *)v69.i32 + *(float *)v70.i32;
  v64.f32[1] = *(float *)v69.i32 + *(float *)v70.i32;
  *(double *)v72.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v64.i64, v71, v65, v67, v68, v70, v69);
  LODWORD(v73) = 0;
  *((float *)&v73 + 1) = -*(float *)&a8.i32[3];
  float32x2_t v74 = vadd_f32(*(float32x2_t *)&v73, *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v75 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v74, 1), *(float *)(a1 + 16), v74.f32[0]);
  LODWORD(v73) = *(_DWORD *)(a1 + 24);
  v76.i32[0] = *(_DWORD *)(a1 + 28);
  v77.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v78.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v74, 1), *(float *)v76.i32, v74.f32[0]);
  float64x2_t v79 = (float64x2_t)v217;
  float32x4_t v218 = vaddq_f32(v217, vmulq_laneq_f32(v72, a3, 2));
  v72.f32[0] = *(float *)&v73 + *(float *)&v75;
  *(float *)v79.f64 = *(float *)v77.i32 + *(float *)v78.i32;
  v72.f32[1] = *(float *)v77.i32 + *(float *)v78.i32;
  *(double *)v80.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v72.i64, v79, v73, v75, v76, v78, v77);
  HIDWORD(v81) = HIDWORD(v243.f64[0]);
  float32x2_t v82 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], v239.u32[0]), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v83 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v82, 1), *(float *)(a1 + 16), v82.f32[0]);
  LODWORD(v81) = *(_DWORD *)(a1 + 24);
  v84.i32[0] = *(_DWORD *)(a1 + 28);
  v85.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v86.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v82, 1), *(float *)v84.i32, v82.f32[0]);
  float64x2_t v87 = (float64x2_t)v218;
  float32x4_t v221 = vaddq_f32(v218, vmulq_laneq_f32(v80, a3, 3));
  v80.f32[0] = *(float *)&v81 + *(float *)&v83;
  *(float *)v87.f64 = *(float *)v85.i32 + *(float *)v86.i32;
  v80.f32[1] = *(float *)v85.i32 + *(float *)v86.i32;
  *(double *)v88.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v80.i64, v87, v81, v83, v84, v86, v85);
  HIDWORD(v89) = HIDWORD(v243.f64[0]);
  float32x2_t v90 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], LODWORD(v242)), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v91 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v90, 1), *(float *)(a1 + 16), v90.f32[0]);
  LODWORD(v89) = *(_DWORD *)(a1 + 24);
  v92.i32[0] = *(_DWORD *)(a1 + 28);
  v93.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v94.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v90, 1), *(float *)v92.i32, v90.f32[0]);
  float64x2_t v95 = (float64x2_t)v221;
  float32x4_t v222 = vaddq_f32(v221, vmulq_n_f32(v88, a4.f32[0]));
  v88.f32[0] = *(float *)&v89 + *(float *)&v91;
  *(float *)v95.f64 = *(float *)v93.i32 + *(float *)v94.i32;
  v88.f32[1] = *(float *)v93.i32 + *(float *)v94.i32;
  *(double *)v96.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v88.i64, v95, v89, v91, v92, v94, v93);
  HIDWORD(v97) = HIDWORD(v243.f64[0]);
  float32x2_t v98 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&v242), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v99 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v98, 1), *(float *)(a1 + 16), v98.f32[0]);
  LODWORD(v97) = *(_DWORD *)(a1 + 24);
  v100.i32[0] = *(_DWORD *)(a1 + 28);
  v101.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v102.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v98, 1), *(float *)v100.i32, v98.f32[0]);
  float64x2_t v103 = (float64x2_t)v222;
  float32x4_t v223 = vaddq_f32(v222, vmulq_lane_f32(v96, *(float32x2_t *)a4.f32, 1));
  v96.f32[0] = *(float *)&v97 + *(float *)&v99;
  *(float *)v103.f64 = *(float *)v101.i32 + *(float *)v102.i32;
  v96.f32[1] = *(float *)v101.i32 + *(float *)v102.i32;
  *(double *)v104.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v96.i64, v103, v97, v99, v100, v102, v101);
  HIDWORD(v105) = HIDWORD(v243.f64[0]);
  float32x2_t v106 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a8.i32[2]), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v107 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v106, 1), *(float *)(a1 + 16), v106.f32[0]);
  LODWORD(v105) = *(_DWORD *)(a1 + 24);
  v108.i32[0] = *(_DWORD *)(a1 + 28);
  v109.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v110.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v106, 1), *(float *)v108.i32, v106.f32[0]);
  float64x2_t v111 = (float64x2_t)v223;
  float32x4_t v224 = vaddq_f32(v223, vmulq_laneq_f32(v104, a4, 2));
  v104.f32[0] = *(float *)&v105 + *(float *)&v107;
  *(float *)v111.f64 = *(float *)v109.i32 + *(float *)v110.i32;
  v104.f32[1] = *(float *)v109.i32 + *(float *)v110.i32;
  *(double *)v112.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v104.i64, v111, v105, v107, v108, v110, v109);
  HIDWORD(v113) = HIDWORD(v243.f64[0]);
  float32x2_t v114 = vadd_f32((float32x2_t)v239.u32[0], *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v115 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v114, 1), *(float *)(a1 + 16), v114.f32[0]);
  LODWORD(v113) = *(_DWORD *)(a1 + 24);
  v116.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v117.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v114, 1), *(float *)(a1 + 28), v114.f32[0]);
  float32x4_t v118 = vmulq_n_f32(v214, *(float *)a5.i32);
  float32x4_t v226 = vaddq_f32(v118, vaddq_f32(v224, vmulq_laneq_f32(v112, a4, 3)));
  v112.f32[0] = *(float *)&v113 + *(float *)&v115;
  v118.f32[0] = *(float *)v116.i32 + *(float *)v117.i32;
  v112.f32[1] = *(float *)v116.i32 + *(float *)v117.i32;
  *(double *)v119.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v112.i64, (float64x2_t)v118, v113, v115, a5, v117, v116);
  HIDWORD(v12CI::NodeWithChildren::NodeWithChildren(this, 0) = HIDWORD(v243.f64[0]);
  float32x2_t v121 = vadd_f32((float32x2_t)LODWORD(v242), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v122 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v121, 1), *(float *)(a1 + 16), v121.f32[0]);
  LODWORD(v12CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v123.i32[0] = *(_DWORD *)(a1 + 28);
  v124.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v125.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v121, 1), *(float *)v123.i32, v121.f32[0]);
  float64x2_t v126 = (float64x2_t)v226;
  float32x4_t v227 = vaddq_f32(v226, vmulq_lane_f32(v119, *(float32x2_t *)a5.i8, 1));
  v119.f32[0] = *(float *)&v120 + *(float *)&v122;
  *(float *)v126.f64 = *(float *)v124.i32 + *(float *)v125.i32;
  v119.f32[1] = *(float *)v124.i32 + *(float *)v125.i32;
  *(double *)v127.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v119.i64, v126, v120, v122, v123, v125, v124);
  HIDWORD(v12_Block_object_dispose(&STACK[0x3A0], 8) = HIDWORD(v243.f64[0]);
  float32x2_t v129 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], -*(float *)&v242), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v130 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v129, 1), *(float *)(a1 + 16), v129.f32[0]);
  LODWORD(v12_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v131.i32[0] = *(_DWORD *)(a1 + 28);
  v132.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v133.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v129, 1), *(float *)v131.i32, v129.f32[0]);
  float64x2_t v134 = (float64x2_t)v227;
  float32x4_t v228 = vaddq_f32(v227, vmulq_laneq_f32(v127, (float32x4_t)a5, 2));
  v127.f32[0] = *(float *)&v128 + *(float *)&v130;
  *(float *)v134.f64 = *(float *)v132.i32 + *(float *)v133.i32;
  v127.f32[1] = *(float *)v132.i32 + *(float *)v133.i32;
  *(double *)v135.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v127.i64, v134, v128, v130, v131, v133, v132);
  HIDWORD(v136) = HIDWORD(v243.f64[0]);
  float32x2_t v137 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], -*(float *)&a8.i32[2]), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v138 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v137, 1), *(float *)(a1 + 16), v137.f32[0]);
  LODWORD(v136) = *(_DWORD *)(a1 + 24);
  v139.i32[0] = *(_DWORD *)(a1 + 28);
  v140.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v141.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v137, 1), *(float *)v139.i32, v137.f32[0]);
  float64x2_t v142 = (float64x2_t)v228;
  float32x4_t v230 = vaddq_f32(v228, vmulq_laneq_f32(v135, (float32x4_t)a5, 3));
  v135.f32[0] = *(float *)&v136 + *(float *)&v138;
  *(float *)v142.f64 = *(float *)v140.i32 + *(float *)v141.i32;
  v135.f32[1] = *(float *)v140.i32 + *(float *)v141.i32;
  *(double *)v143.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v135.i64, v142, v136, v138, v139, v141, v140);
  v144.i32[1] = v239.i32[1];
  v144.i32[0] = 0;
  HIDWORD(v145) = HIDWORD(v243.f64[0]);
  float32x2_t v146 = vadd_f32(v144, *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v147 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v146, 1), *(float *)(a1 + 16), v146.f32[0]);
  LODWORD(v145) = *(_DWORD *)(a1 + 24);
  v148.i32[0] = *(_DWORD *)(a1 + 28);
  v149.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v150.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v146, 1), *(float *)v148.i32, v146.f32[0]);
  float64x2_t v151 = (float64x2_t)v230;
  float32x4_t v231 = vaddq_f32(v230, vmulq_n_f32(v143, a6.f32[0]));
  v143.f32[0] = *(float *)&v145 + *(float *)&v147;
  *(float *)v151.f64 = *(float *)v149.i32 + *(float *)v150.i32;
  v143.f32[1] = *(float *)v149.i32 + *(float *)v150.i32;
  *(double *)v152.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v143.i64, v151, v145, v147, v148, v150, v149);
  HIDWORD(v153) = HIDWORD(v243.f64[0]);
  float32x2_t v154 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], v239.u32[0]), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v155 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v154, 1), *(float *)(a1 + 16), v154.f32[0]);
  LODWORD(v153) = *(_DWORD *)(a1 + 24);
  v156.i32[0] = *(_DWORD *)(a1 + 28);
  v157.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v158.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v154, 1), *(float *)v156.i32, v154.f32[0]);
  float64x2_t v159 = (float64x2_t)v231;
  float32x4_t v232 = vaddq_f32(v231, vmulq_lane_f32(v152, *(float32x2_t *)a6.f32, 1));
  v152.f32[0] = *(float *)&v153 + *(float *)&v155;
  *(float *)v159.f64 = *(float *)v157.i32 + *(float *)v158.i32;
  v152.f32[1] = *(float *)v157.i32 + *(float *)v158.i32;
  *(double *)v160.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v152.i64, v159, v153, v155, v156, v158, v157);
  HIDWORD(v161) = HIDWORD(v243.f64[0]);
  float32x2_t v162 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], LODWORD(v242)), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v163 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v162, 1), *(float *)(a1 + 16), v162.f32[0]);
  LODWORD(v161) = *(_DWORD *)(a1 + 24);
  v164.i32[0] = *(_DWORD *)(a1 + 28);
  v165.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v166.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v162, 1), *(float *)v164.i32, v162.f32[0]);
  float64x2_t v167 = (float64x2_t)v232;
  float32x4_t v233 = vaddq_f32(v232, vmulq_laneq_f32(v160, a6, 2));
  v160.f32[0] = *(float *)&v161 + *(float *)&v163;
  *(float *)v167.f64 = *(float *)v165.i32 + *(float *)v166.i32;
  v160.f32[1] = *(float *)v165.i32 + *(float *)v166.i32;
  *(double *)v168.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v160.i64, v167, v161, v163, v164, v166, v165);
  HIDWORD(v169) = HIDWORD(v243.f64[0]);
  float32x2_t v170 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v242), -*(float *)&v242), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v171 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v170, 1), *(float *)(a1 + 16), v170.f32[0]);
  LODWORD(v169) = *(_DWORD *)(a1 + 24);
  v172.i32[0] = *(_DWORD *)(a1 + 28);
  v173.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v174.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v170, 1), *(float *)v172.i32, v170.f32[0]);
  float64x2_t v175 = (float64x2_t)v233;
  float32x4_t v235 = vaddq_f32(v233, vmulq_laneq_f32(v168, a6, 3));
  v168.f32[0] = *(float *)&v169 + *(float *)&v171;
  *(float *)v175.f64 = *(float *)v173.i32 + *(float *)v174.i32;
  v168.f32[1] = *(float *)v173.i32 + *(float *)v174.i32;
  *(double *)v176.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v168.i64, v175, v169, v171, v172, v174, v173);
  HIDWORD(v177) = HIDWORD(v243.f64[0]);
  float32x2_t v178 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v242), -*(float *)&a8.i32[2]), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v179 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v178, 1), *(float *)(a1 + 16), v178.f32[0]);
  LODWORD(v177) = *(_DWORD *)(a1 + 24);
  v180.i32[0] = *(_DWORD *)(a1 + 28);
  v181.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v182.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v178, 1), *(float *)v180.i32, v178.f32[0]);
  float64x2_t v183 = (float64x2_t)v235;
  float32x4_t v236 = vaddq_f32(v235, vmulq_n_f32(v176, a7.f32[0]));
  v176.f32[0] = *(float *)&v177 + *(float *)&v179;
  *(float *)v183.f64 = *(float *)v181.i32 + *(float *)v182.i32;
  v176.f32[1] = *(float *)v181.i32 + *(float *)v182.i32;
  *(double *)v184.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v176.i64, v183, v177, v179, v180, v182, v181);
  v185.i32[1] = HIDWORD(v242);
  HIDWORD(v186) = HIDWORD(v243.f64[0]);
  v185.i32[0] = 0;
  float32x2_t v187 = vadd_f32(v185, *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v188 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v187, 1), *(float *)(a1 + 16), v187.f32[0]);
  LODWORD(v186) = *(_DWORD *)(a1 + 24);
  v189.i32[0] = *(_DWORD *)(a1 + 28);
  v190.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v191.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v187, 1), *(float *)v189.i32, v187.f32[0]);
  float64x2_t v192 = (float64x2_t)v236;
  float32x4_t v237 = vaddq_f32(v236, vmulq_lane_f32(v184, *(float32x2_t *)a7.f32, 1));
  v184.f32[0] = *(float *)&v186 + *(float *)&v188;
  *(float *)v192.f64 = *(float *)v190.i32 + *(float *)v191.i32;
  v184.f32[1] = *(float *)v190.i32 + *(float *)v191.i32;
  *(double *)v193.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v184.i64, v192, v186, v188, v189, v191, v190);
  double v194 = COERCE_DOUBLE(__PAIR64__(HIDWORD(v242), v239.u32[0]));
  float32x2_t v195 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v242), v239.u32[0]), *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v196 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v195, 1), *(float *)(a1 + 16), v195.f32[0]);
  LODWORD(v194) = *(_DWORD *)(a1 + 24);
  v197.i32[0] = *(_DWORD *)(a1 + 28);
  v198.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v199.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v195, 1), *(float *)v197.i32, v195.f32[0]);
  float64x2_t v200 = (float64x2_t)v237;
  float32x4_t v240 = vaddq_f32(v237, vmulq_laneq_f32(v193, a7, 2));
  v193.f32[0] = *(float *)&v194 + *(float *)&v196;
  *(float *)v200.f64 = *(float *)v198.i32 + *(float *)v199.i32;
  v193.f32[1] = *(float *)v198.i32 + *(float *)v199.i32;
  *(double *)v201.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v193.i64, v200, v194, v196, v197, v199, v198);
  HIDWORD(v202) = HIDWORD(v242);
  float32x2_t v203 = vadd_f32(*(float32x2_t *)&v242, *(float32x2_t *)&v243.f64[0]);
  *(float *)&double v204 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v203, 1), *(float *)(a1 + 16), v203.f32[0]);
  LODWORD(v202) = *(_DWORD *)(a1 + 24);
  v205.i32[0] = *(_DWORD *)(a1 + 28);
  v206.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v207.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v203, 1), *(float *)v205.i32, v203.f32[0]);
  float64x2_t v208 = (float64x2_t)v240;
  float32x4_t v244 = vaddq_f32(v240, vmulq_laneq_f32(v201, a7, 3));
  v201.f32[0] = *(float *)&v202 + *(float *)&v204;
  *(float *)v208.f64 = *(float *)v206.i32 + *(float *)v207.i32;
  v201.f32[1] = *(float *)v206.i32 + *(float *)v207.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v201.i64, v208, v202, v204, v205, v207, v206);
  result.i64[0] = vaddq_f32(v244, vmulq_n_f32(result, *(float *)a8.i32)).u64[0];
  result.i32[3] = v214.i32[3];
  return result;
}

void CI::f4_sr_f4_f4_f4_f4_f4_f4_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  int8x16_t v11 = *(const vec2 **)(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  int v13 = *(_DWORD *)(v10 + 40);
  uint64_t v14 = *(void *)(v10 + 32);
  int v15 = *(_DWORD *)(v10 + 64);
  uint64_t v16 = *(void *)(v10 + 56);
  int v17 = *(_DWORD *)(v10 + 88);
  uint64_t v18 = *(void *)(v10 + 80);
  int v19 = *(_DWORD *)(v10 + 112);
  uint64_t v20 = *(void *)(v10 + 104);
  int v21 = *(_DWORD *)(v10 + 136);
  uint64_t v22 = *(void *)(v10 + 128);
  int v23 = *(_DWORD *)(v10 + 160);
  uint64_t v24 = *(void *)(v10 + 152);
  int v25 = *(_DWORD *)(v10 + 184);
  uint64_t v26 = *(void *)(v10 + 176);
  if (*(unsigned char *)(a1 + 64))
  {
    int8x16_t v44 = *(const vec2 **)(a1 + 24);
    uint64_t v45 = *(void *)(v10 + 32);
    uint64_t v42 = *(void *)(v10 + 8);
    uint64_t v43 = *(void *)(v10 + 56);
    uint64_t v40 = *(void *)(v10 + 104);
    uint64_t v41 = *(void *)(v10 + 80);
    int v38 = *(_DWORD *)(v10 + 160);
    int v39 = *(_DWORD *)(v10 + 136);
    int v37 = *(_DWORD *)(v10 + 184);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 200)), v11);
    int v25 = v37;
    int v23 = v38;
    int v21 = v39;
    uint64_t v20 = v40;
    uint64_t v18 = v41;
    uint64_t v12 = v42;
    uint64_t v16 = v43;
    int8x16_t v11 = v44;
    uint64_t v14 = v45;
  }
  int8x16_t v27 = (__n128 *)(a3 + 16 * v26);
  if (v25 != 5) {
    int8x16_t v27 = (__n128 *)(a2 + (v26 << 6));
  }
  int8x16_t v28 = (__n128 *)(a3 + 16 * v24);
  if (v23 != 5) {
    int8x16_t v28 = (__n128 *)(a2 + (v24 << 6));
  }
  int8x16_t v29 = (__n128 *)(a3 + 16 * v22);
  if (v21 != 5) {
    int8x16_t v29 = (__n128 *)(a2 + (v22 << 6));
  }
  float64x2_t v30 = (__n128 *)(a3 + 16 * v20);
  float32x4_t v31 = (__n128 *)(a2 + (v20 << 6));
  if (v19 != 5) {
    float64x2_t v30 = v31;
  }
  float32x2_t v32 = (__n128 *)(a3 + 16 * v18);
  double v33 = (__n128 *)(a2 + (v18 << 6));
  if (v17 != 5) {
    float32x2_t v32 = v33;
  }
  float32x2_t v34 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x2_t v34 = (__n128 *)(a2 + (v16 << 6));
  }
  double v35 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    double v35 = (__n128 *)(a2 + (v14 << 6));
  }
  *(double *)&long long v36 = ((double (*)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128))v11)(a4 + 80 * v12, *v35, *v34, *v32, *v30, *v29, *v28, *v27);
  *(_OWORD *)(a3 + 16 * a7) = v36;
}

double cikernel::_convolution5x5(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8)
{
  v9.i64[0] = *(void *)CI::getDC((CI *)a1);
  int8x16_t v248 = v9;
  float64x2_t v10 = (float64x2_t)vdupq_lane_s32(*(int32x2_t *)a8.i8, 1);
  float32x4_t v213 = (float32x4_t)v10;
  float32x2_t v244 = (float32x2_t)vextq_s8(a8, a8, 8uLL).u64[0];
  float32x2_t v11 = vadd_f32(v244, v244);
  float32x2_t v247 = v11;
  v11.f32[0] = -v11.f32[0];
  unsigned int v238 = v11.u32[0];
  v11.f32[1] = -v11.f32[1];
  float32_t v217 = v11.f32[1];
  float32x2_t v12 = vadd_f32(v11, *(float32x2_t *)v9.i8);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v12, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v12, 1), *(float *)&v13, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)v9.i32;
  *(float *)v10.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v12.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v12, v10, *(double *)v9.i64, v13, v15, v14, v16);
  v18.f32[0] = -*(float *)&a8.i32[2];
  v18.f32[1] = v217;
  HIDWORD(v19) = v248.i32[1];
  float32x2_t v20 = vadd_f32(v18, *(float32x2_t *)v248.i8);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a1 + 24);
  v22.i32[0] = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)v22.i32, v20.f32[0]);
  float64x2_t v25 = (float64x2_t)v213;
  float32x4_t v214 = vaddq_f32(v213, vmulq_n_f32(v17, a2.f32[0]));
  v17.f32[0] = *(float *)&v19 + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v17.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, v25, v19, v21, v22, v24, v23);
  v27.i32[0] = 0;
  v27.f32[1] = v217;
  HIDWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = v248.i32[1];
  float32x2_t v29 = vadd_f32(v27, *(float32x2_t *)v248.i8);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v29, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v29, 1), *(float *)v31.i32, v29.f32[0]);
  float64x2_t v34 = (float64x2_t)v214;
  float32x4_t v215 = vaddq_f32(v214, vmulq_lane_f32(v26, *(float32x2_t *)a2.f32, 1));
  v26.f32[0] = *(float *)&v28 + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v26.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v34, v28, v30, v31, v33, v32);
  HIDWORD(v36) = v248.i32[1];
  float32x2_t v37 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v217), v244.u32[0]), *(float32x2_t *)v248.i8);
  *(float *)&double v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v37, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 24);
  v39.i32[0] = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v37, 1), *(float *)v39.i32, v37.f32[0]);
  float64x2_t v42 = (float64x2_t)v215;
  float32x4_t v216 = vaddq_f32(v215, vmulq_laneq_f32(v35, a2, 2));
  v35.f32[0] = *(float *)&v36 + *(float *)&v38;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v35.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v42, v36, v38, v39, v41, v40);
  HIDWORD(v44) = v248.i32[1];
  float32x2_t v45 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v217), v247.u32[0]), *(float32x2_t *)v248.i8);
  *(float *)&double v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v45, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a1 + 24);
  v47.i32[0] = *(_DWORD *)(a1 + 28);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v45, 1), *(float *)v47.i32, v45.f32[0]);
  float64x2_t v50 = (float64x2_t)v216;
  float32x4_t v218 = vaddq_f32(v216, vmulq_laneq_f32(v43, a2, 3));
  v43.f32[0] = *(float *)&v44 + *(float *)&v46;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v43.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v50, v44, v46, v47, v49, v48);
  HIDWORD(v52) = v248.i32[1];
  float32x2_t v53 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], v238), *(float32x2_t *)v248.i8);
  *(float *)&double v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v53, 1), *(float *)(a1 + 16), v53.f32[0]);
  LODWORD(v52) = *(_DWORD *)(a1 + 24);
  v55.i32[0] = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v53, 1), *(float *)v55.i32, v53.f32[0]);
  float64x2_t v58 = (float64x2_t)v218;
  float32x4_t v219 = vaddq_f32(v218, vmulq_n_f32(v51, a3.f32[0]));
  v51.f32[0] = *(float *)&v52 + *(float *)&v54;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v51.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v51.i64, v58, v52, v54, v55, v57, v56);
  HIDWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = v248.i32[1];
  float32x2_t v61 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], -*(float *)&a8.i32[2]), *(float32x2_t *)v248.i8);
  *(float *)&double v62 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v61, 1), *(float *)(a1 + 16), v61.f32[0]);
  LODWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v63.i32[0] = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v61, 1), *(float *)v63.i32, v61.f32[0]);
  float64x2_t v66 = (float64x2_t)v219;
  float32x4_t v220 = vaddq_f32(v219, vmulq_lane_f32(v59, *(float32x2_t *)a3.f32, 1));
  v59.f32[0] = *(float *)&v60 + *(float *)&v62;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v59.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v59.i64, v66, v60, v62, v63, v65, v64);
  LODWORD(v6_Block_object_dispose(&STACK[0x3A0], 8) = 0;
  *((float *)&v68 + 1) = -*(float *)&a8.i32[3];
  float32x2_t v69 = vadd_f32(*(float32x2_t *)&v68, *(float32x2_t *)v248.i8);
  *(float *)&double v70 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v69, 1), *(float *)(a1 + 16), v69.f32[0]);
  LODWORD(v6_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v71.i32[0] = *(_DWORD *)(a1 + 28);
  v72.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v69, 1), *(float *)v71.i32, v69.f32[0]);
  float64x2_t v74 = (float64x2_t)v220;
  float32x4_t v221 = vaddq_f32(v220, vmulq_laneq_f32(v67, a3, 2));
  v67.f32[0] = *(float *)&v68 + *(float *)&v70;
  *(float *)v74.f64 = *(float *)v72.i32 + *(float *)v73.i32;
  v67.f32[1] = *(float *)v72.i32 + *(float *)v73.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v67.i64, v74, v68, v70, v71, v73, v72);
  HIDWORD(v76) = v248.i32[1];
  float32x2_t v77 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], v244.u32[0]), *(float32x2_t *)v248.i8);
  *(float *)&double v78 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v77, 1), *(float *)(a1 + 16), v77.f32[0]);
  LODWORD(v76) = *(_DWORD *)(a1 + 24);
  v79.i32[0] = *(_DWORD *)(a1 + 28);
  v80.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v81.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v77, 1), *(float *)v79.i32, v77.f32[0]);
  float64x2_t v82 = (float64x2_t)v221;
  float32x4_t v224 = vaddq_f32(v221, vmulq_laneq_f32(v75, a3, 3));
  v75.f32[0] = *(float *)&v76 + *(float *)&v78;
  *(float *)v82.f64 = *(float *)v80.i32 + *(float *)v81.i32;
  v75.f32[1] = *(float *)v80.i32 + *(float *)v81.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v75.i64, v82, v76, v78, v79, v81, v80);
  HIDWORD(v84) = v248.i32[1];
  float32x2_t v85 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], v247.u32[0]), *(float32x2_t *)v248.i8);
  *(float *)&double v86 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v85, 1), *(float *)(a1 + 16), v85.f32[0]);
  LODWORD(v84) = *(_DWORD *)(a1 + 24);
  v87.i32[0] = *(_DWORD *)(a1 + 28);
  v88.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v85, 1), *(float *)v87.i32, v85.f32[0]);
  float64x2_t v90 = (float64x2_t)v224;
  float32x4_t v225 = vaddq_f32(v224, vmulq_n_f32(v83, a4.f32[0]));
  v83.f32[0] = *(float *)&v84 + *(float *)&v86;
  *(float *)v90.f64 = *(float *)v88.i32 + *(float *)v89.i32;
  v83.f32[1] = *(float *)v88.i32 + *(float *)v89.i32;
  *(double *)v91.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v90, v84, v86, v87, v89, v88);
  HIDWORD(v92) = v248.i32[1];
  float32x2_t v93 = vadd_f32((float32x2_t)v238, *(float32x2_t *)v248.i8);
  *(float *)&double v94 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v93, 1), *(float *)(a1 + 16), v93.f32[0]);
  LODWORD(v92) = *(_DWORD *)(a1 + 24);
  v95.i32[0] = *(_DWORD *)(a1 + 28);
  v96.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v97.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v93, 1), *(float *)v95.i32, v93.f32[0]);
  float64x2_t v98 = (float64x2_t)v225;
  float32x4_t v226 = vaddq_f32(v225, vmulq_lane_f32(v91, *(float32x2_t *)a4.f32, 1));
  v91.f32[0] = *(float *)&v92 + *(float *)&v94;
  *(float *)v98.f64 = *(float *)v96.i32 + *(float *)v97.i32;
  v91.f32[1] = *(float *)v96.i32 + *(float *)v97.i32;
  *(double *)v99.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v91.i64, v98, v92, v94, v95, v97, v96);
  HIDWORD(v10CI::NodeWithChildren::NodeWithChildren(this, 0) = v248.i32[1];
  float32x2_t v101 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a8.i32[2]), *(float32x2_t *)v248.i8);
  *(float *)&double v102 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v101, 1), *(float *)(a1 + 16), v101.f32[0]);
  LODWORD(v10CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v103.i32[0] = *(_DWORD *)(a1 + 28);
  v104.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v105.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v101, 1), *(float *)v103.i32, v101.f32[0]);
  float64x2_t v106 = (float64x2_t)v226;
  float32x4_t v227 = vaddq_f32(v226, vmulq_laneq_f32(v99, a4, 2));
  v99.f32[0] = *(float *)&v100 + *(float *)&v102;
  *(float *)v106.f64 = *(float *)v104.i32 + *(float *)v105.i32;
  v99.f32[1] = *(float *)v104.i32 + *(float *)v105.i32;
  *(double *)v107.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v99.i64, v106, v100, v102, v103, v105, v104);
  float64x2_t v108 = (float64x2_t)v227;
  float32x4_t v229 = vaddq_f32(v227, vmulq_laneq_f32(v107, a4, 3));
  LODWORD(v109) = *(_DWORD *)(a1 + 28);
  v107.f32[0] = *(float *)(a1 + 24)
              + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v248.i8, 1), *(float *)(a1 + 16), *(float *)v248.i32);
  LODWORD(v11CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 36);
  *(float *)v108.f64 = *(float *)&v110
                     + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v248.i8, 1), *(float *)&v109, *(float *)v248.i32);
  v107.i32[1] = LODWORD(v108.f64[0]);
  *(double *)v113.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v107.i64, v108, v109, v110, v248, v111, v112);
  HIDWORD(v114) = v248.i32[1];
  float32x2_t v115 = vadd_f32((float32x2_t)v244.u32[0], *(float32x2_t *)v248.i8);
  *(float *)&double v116 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v115, 1), *(float *)(a1 + 16), v115.f32[0]);
  LODWORD(v114) = *(_DWORD *)(a1 + 24);
  v117.i32[0] = *(_DWORD *)(a1 + 28);
  v118.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v119.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v115, 1), *(float *)v117.i32, v115.f32[0]);
  float64x2_t v120 = (float64x2_t)v229;
  float32x4_t v230 = vaddq_f32(v229, vmulq_n_f32(v113, a5.f32[0]));
  v113.f32[0] = *(float *)&v114 + *(float *)&v116;
  *(float *)v120.f64 = *(float *)v118.i32 + *(float *)v119.i32;
  v113.f32[1] = *(float *)v118.i32 + *(float *)v119.i32;
  *(double *)v121.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v113.i64, v120, v114, v116, v117, v119, v118);
  HIDWORD(v122) = v248.i32[1];
  float32x2_t v123 = vadd_f32((float32x2_t)v247.u32[0], *(float32x2_t *)v248.i8);
  *(float *)&double v124 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v123, 1), *(float *)(a1 + 16), v123.f32[0]);
  LODWORD(v122) = *(_DWORD *)(a1 + 24);
  v125.i32[0] = *(_DWORD *)(a1 + 28);
  v126.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v127.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v123, 1), *(float *)v125.i32, v123.f32[0]);
  float64x2_t v128 = (float64x2_t)v230;
  float32x4_t v231 = vaddq_f32(v230, vmulq_lane_f32(v121, *(float32x2_t *)a5.f32, 1));
  v121.f32[0] = *(float *)&v122 + *(float *)&v124;
  *(float *)v128.f64 = *(float *)v126.i32 + *(float *)v127.i32;
  v121.f32[1] = *(float *)v126.i32 + *(float *)v127.i32;
  *(double *)v129.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v121.i64, v128, v122, v124, v125, v127, v126);
  HIDWORD(v13CI::NodeWithChildren::NodeWithChildren(this, 0) = v248.i32[1];
  float32x2_t v131 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], v238), *(float32x2_t *)v248.i8);
  *(float *)&double v132 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v131, 1), *(float *)(a1 + 16), v131.f32[0]);
  LODWORD(v13CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v133.i32[0] = *(_DWORD *)(a1 + 28);
  v134.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v135.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v131, 1), *(float *)v133.i32, v131.f32[0]);
  float64x2_t v136 = (float64x2_t)v231;
  float32x4_t v232 = vaddq_f32(v231, vmulq_laneq_f32(v129, a5, 2));
  v129.f32[0] = *(float *)&v130 + *(float *)&v132;
  *(float *)v136.f64 = *(float *)v134.i32 + *(float *)v135.i32;
  v129.f32[1] = *(float *)v134.i32 + *(float *)v135.i32;
  *(double *)v137.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v129.i64, v136, v130, v132, v133, v135, v134);
  HIDWORD(v13_Block_object_dispose(&STACK[0x3A0], 8) = v248.i32[1];
  float32x2_t v139 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], -*(float *)&a8.i32[2]), *(float32x2_t *)v248.i8);
  *(float *)&double v140 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v139, 1), *(float *)(a1 + 16), v139.f32[0]);
  LODWORD(v13_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v141.i32[0] = *(_DWORD *)(a1 + 28);
  v142.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v143.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v139, 1), *(float *)v141.i32, v139.f32[0]);
  float64x2_t v144 = (float64x2_t)v232;
  float32x4_t v234 = vaddq_f32(v232, vmulq_laneq_f32(v137, a5, 3));
  v137.f32[0] = *(float *)&v138 + *(float *)&v140;
  *(float *)v144.f64 = *(float *)v142.i32 + *(float *)v143.i32;
  v137.f32[1] = *(float *)v142.i32 + *(float *)v143.i32;
  *(double *)v145.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v137.i64, v144, v138, v140, v141, v143, v142);
  v146.i32[1] = v244.i32[1];
  v146.i32[0] = 0;
  HIDWORD(v147) = v248.i32[1];
  float32x2_t v148 = vadd_f32(v146, *(float32x2_t *)v248.i8);
  *(float *)&double v149 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v148, 1), *(float *)(a1 + 16), v148.f32[0]);
  LODWORD(v147) = *(_DWORD *)(a1 + 24);
  v150.i32[0] = *(_DWORD *)(a1 + 28);
  v151.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v152.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v148, 1), *(float *)v150.i32, v148.f32[0]);
  float64x2_t v153 = (float64x2_t)v234;
  float32x4_t v235 = vaddq_f32(v234, vmulq_n_f32(v145, a6.f32[0]));
  v145.f32[0] = *(float *)&v147 + *(float *)&v149;
  *(float *)v153.f64 = *(float *)v151.i32 + *(float *)v152.i32;
  v145.f32[1] = *(float *)v151.i32 + *(float *)v152.i32;
  *(double *)v154.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v145.i64, v153, v147, v149, v150, v152, v151);
  HIDWORD(v155) = v248.i32[1];
  float32x2_t v156 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], v244.u32[0]), *(float32x2_t *)v248.i8);
  *(float *)&double v157 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v156, 1), *(float *)(a1 + 16), v156.f32[0]);
  LODWORD(v155) = *(_DWORD *)(a1 + 24);
  v158.i32[0] = *(_DWORD *)(a1 + 28);
  v159.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v160.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v156, 1), *(float *)v158.i32, v156.f32[0]);
  float64x2_t v161 = (float64x2_t)v235;
  float32x4_t v236 = vaddq_f32(v235, vmulq_lane_f32(v154, *(float32x2_t *)a6.f32, 1));
  v154.f32[0] = *(float *)&v155 + *(float *)&v157;
  *(float *)v161.f64 = *(float *)v159.i32 + *(float *)v160.i32;
  v154.f32[1] = *(float *)v159.i32 + *(float *)v160.i32;
  *(double *)v162.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v154.i64, v161, v155, v157, v158, v160, v159);
  HIDWORD(v163) = v248.i32[1];
  float32x2_t v164 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], v247.u32[0]), *(float32x2_t *)v248.i8);
  *(float *)&double v165 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v164, 1), *(float *)(a1 + 16), v164.f32[0]);
  LODWORD(v163) = *(_DWORD *)(a1 + 24);
  v166.i32[0] = *(_DWORD *)(a1 + 28);
  v167.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v168.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v164, 1), *(float *)v166.i32, v164.f32[0]);
  float64x2_t v169 = (float64x2_t)v236;
  float32x4_t v237 = vaddq_f32(v236, vmulq_laneq_f32(v162, a6, 2));
  v162.f32[0] = *(float *)&v163 + *(float *)&v165;
  *(float *)v169.f64 = *(float *)v167.i32 + *(float *)v168.i32;
  v162.f32[1] = *(float *)v167.i32 + *(float *)v168.i32;
  *(double *)v170.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v162.i64, v169, v163, v165, v166, v168, v167);
  HIDWORD(v171) = v248.i32[1];
  float32x2_t v172 = vadd_f32((float32x2_t)__PAIR64__(v247.u32[1], v238), *(float32x2_t *)v248.i8);
  *(float *)&double v173 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v172, 1), *(float *)(a1 + 16), v172.f32[0]);
  LODWORD(v171) = *(_DWORD *)(a1 + 24);
  v174.i32[0] = *(_DWORD *)(a1 + 28);
  v175.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v176.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v172, 1), *(float *)v174.i32, v172.f32[0]);
  float64x2_t v177 = (float64x2_t)v237;
  float32x4_t v240 = vaddq_f32(v237, vmulq_laneq_f32(v170, a6, 3));
  v170.f32[0] = *(float *)&v171 + *(float *)&v173;
  *(float *)v177.f64 = *(float *)v175.i32 + *(float *)v176.i32;
  v170.f32[1] = *(float *)v175.i32 + *(float *)v176.i32;
  *(double *)v178.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v170.i64, v177, v171, v173, v174, v176, v175);
  HIDWORD(v179) = v248.i32[1];
  float32x2_t v180 = vadd_f32((float32x2_t)__PAIR64__(v247.u32[1], -*(float *)&a8.i32[2]), *(float32x2_t *)v248.i8);
  *(float *)&double v181 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v180, 1), *(float *)(a1 + 16), v180.f32[0]);
  LODWORD(v179) = *(_DWORD *)(a1 + 24);
  v182.i32[0] = *(_DWORD *)(a1 + 28);
  v183.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v184.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v180, 1), *(float *)v182.i32, v180.f32[0]);
  float64x2_t v185 = (float64x2_t)v240;
  float32x4_t v241 = vaddq_f32(v240, vmulq_n_f32(v178, a7.f32[0]));
  v178.f32[0] = *(float *)&v179 + *(float *)&v181;
  *(float *)v185.f64 = *(float *)v183.i32 + *(float *)v184.i32;
  v178.f32[1] = *(float *)v183.i32 + *(float *)v184.i32;
  *(double *)v186.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v178.i64, v185, v179, v181, v182, v184, v183);
  v187.i32[1] = v247.i32[1];
  HIDWORD(v18_Block_object_dispose(&STACK[0x3A0], 8) = v248.i32[1];
  v187.i32[0] = 0;
  float32x2_t v189 = vadd_f32(v187, *(float32x2_t *)v248.i8);
  *(float *)&double v190 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v189, 1), *(float *)(a1 + 16), v189.f32[0]);
  LODWORD(v18_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v191.i32[0] = *(_DWORD *)(a1 + 28);
  v192.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v193.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v189, 1), *(float *)v191.i32, v189.f32[0]);
  float64x2_t v194 = (float64x2_t)v241;
  float32x4_t v242 = vaddq_f32(v241, vmulq_lane_f32(v186, *(float32x2_t *)a7.f32, 1));
  v186.f32[0] = *(float *)&v188 + *(float *)&v190;
  *(float *)v194.f64 = *(float *)v192.i32 + *(float *)v193.i32;
  v186.f32[1] = *(float *)v192.i32 + *(float *)v193.i32;
  *(double *)v195.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v186.i64, v194, v188, v190, v191, v193, v192);
  double v196 = COERCE_DOUBLE(__PAIR64__(v247.u32[1], v244.u32[0]));
  float32x2_t v197 = vadd_f32((float32x2_t)__PAIR64__(v247.u32[1], v244.u32[0]), *(float32x2_t *)v248.i8);
  *(float *)&double v198 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v197, 1), *(float *)(a1 + 16), v197.f32[0]);
  LODWORD(v196) = *(_DWORD *)(a1 + 24);
  v199.i32[0] = *(_DWORD *)(a1 + 28);
  v200.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v201.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v197, 1), *(float *)v199.i32, v197.f32[0]);
  float64x2_t v202 = (float64x2_t)v242;
  float32x4_t v245 = vaddq_f32(v242, vmulq_laneq_f32(v195, a7, 2));
  v195.f32[0] = *(float *)&v196 + *(float *)&v198;
  *(float *)v202.f64 = *(float *)v200.i32 + *(float *)v201.i32;
  v195.f32[1] = *(float *)v200.i32 + *(float *)v201.i32;
  *(double *)v203.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v195.i64, v202, v196, v198, v199, v201, v200);
  HIDWORD(v204) = v248.i32[1];
  float32x2_t v205 = vadd_f32(v247, *(float32x2_t *)v248.i8);
  *(float *)&double v206 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v205, 1), *(float *)(a1 + 16), v205.f32[0]);
  LODWORD(v204) = *(_DWORD *)(a1 + 24);
  v207.i32[0] = *(_DWORD *)(a1 + 28);
  v208.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v209.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v205, 1), *(float *)v207.i32, v205.f32[0]);
  float64x2_t v210 = (float64x2_t)v245;
  float32x4_t v249 = vaddq_f32(v245, vmulq_laneq_f32(v203, a7, 3));
  v203.f32[0] = *(float *)&v204 + *(float *)&v206;
  *(float *)v210.f64 = *(float *)v208.i32 + *(float *)v209.i32;
  v203.f32[1] = *(float *)v208.i32 + *(float *)v209.i32;
  *(double *)v211.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v203.i64, v210, v204, v206, v207, v209, v208);
  *(void *)&double result = vaddq_f32(v249, vmulq_n_f32(v211, *(float *)a8.i32)).u64[0];
  return result;
}

float32x4_t cikernel::_convolutionrgb7x7(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8, float32x4_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17, float32x4_t a18, float32x4_t a19, float32x4_t a20,int8x16_t a21)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v23.i8 = *DC;
  float64x2_t v24 = (float64x2_t)vdupq_lane_s32(*(int32x2_t *)a21.i8, 1);
  float32x4_t v473 = (float32x4_t)v24;
  int8x16_t v25 = vextq_s8(a21, a21, 8uLL);
  *(float32x2_t *)&v24.f64[0] = vadd_f32(*(float32x2_t *)v25.i8, *(float32x2_t *)v25.i8);
  float32x2_t v477 = *(float32x2_t *)&v24.f64[0];
  float64x2_t v486 = (float64x2_t)v23;
  int8x16_t v26 = v25;
  float32x2_t v475 = *(float32x2_t *)v25.i8;
  *(float *)v25.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v27) = *(_DWORD *)(a1 + 36);
  __asm { FMOV            V2.2S, #3.0 }
  *(float32x2_t *)&double v476 = vmul_f32(*(float32x2_t *)v26.i8, _D2);
  *(float *)v24.f64 = *(float *)&v27
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  v25.i32[1] = LODWORD(v24.f64[0]);
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v24, v476, v27, v23, v26, v33);
  float32x4_t v429 = v34;
  v34.f32[0] = -*(float *)&v476;
  v34.f32[1] = -*((float *)&v476 + 1);
  float64x2_t v35 = v486;
  *(float32x2_t *)v34.f32 = vadd_f32(*(float32x2_t *)v34.f32, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v34.f32, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 28);
  v38.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v34.f32, 1), *(float *)&v37, v34.f32[0]);
  v34.f32[0] = *(float *)(a1 + 24) + *(float *)&v36;
  *(float *)v35.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v34.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v35, v36, v37, v39, v38, v40);
  v42.f32[0] = -v477.f32[0];
  *(float *)&unsigned int v474 = -v477.f32[0];
  v42.f32[1] = -*((float *)&v476 + 1);
  HIDWORD(v43) = HIDWORD(v486.f64[0]);
  float32x2_t v44 = vadd_f32(v42, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v44, 1), *(float *)(a1 + 16), v44.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 24);
  v46.i32[0] = *(_DWORD *)(a1 + 28);
  v47.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v44, 1), *(float *)v46.i32, v44.f32[0]);
  float64x2_t v49 = (float64x2_t)v473;
  float32x4_t v426 = vaddq_f32(v473, vmulq_n_f32(v41, a2.f32[0]));
  v41.f32[0] = *(float *)&v43 + *(float *)&v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v41.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, v49, v43, v45, v46, v48, v47);
  v51.f32[0] = -*(float *)&a21.i32[2];
  v51.f32[1] = -*((float *)&v476 + 1);
  HIDWORD(v52) = HIDWORD(v486.f64[0]);
  float32x2_t v53 = vadd_f32(v51, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v53, 1), *(float *)(a1 + 16), v53.f32[0]);
  LODWORD(v52) = *(_DWORD *)(a1 + 24);
  v55.i32[0] = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v53, 1), *(float *)v55.i32, v53.f32[0]);
  float64x2_t v58 = (float64x2_t)v426;
  float32x4_t v427 = vaddq_f32(v426, vmulq_lane_f32(v50, *(float32x2_t *)a2.f32, 1));
  v50.f32[0] = *(float *)&v52 + *(float *)&v54;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v50.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v50.i64, v58, v52, v54, v55, v57, v56);
  v60.i32[0] = 0;
  v60.f32[1] = -*((float *)&v476 + 1);
  HIDWORD(v61) = HIDWORD(v486.f64[0]);
  float32x2_t v62 = vadd_f32(v60, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v63 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v62, 1), *(float *)(a1 + 16), v62.f32[0]);
  LODWORD(v61) = *(_DWORD *)(a1 + 24);
  v64.i32[0] = *(_DWORD *)(a1 + 28);
  v65.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v66.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v62, 1), *(float *)v64.i32, v62.f32[0]);
  float64x2_t v67 = (float64x2_t)v427;
  float32x4_t v428 = vaddq_f32(v427, vmulq_laneq_f32(v59, a2, 2));
  v59.f32[0] = *(float *)&v61 + *(float *)&v63;
  *(float *)v67.f64 = *(float *)v65.i32 + *(float *)v66.i32;
  v59.f32[1] = *(float *)v65.i32 + *(float *)v66.i32;
  *(double *)v68.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v59.i64, v67, v61, v63, v64, v66, v65);
  HIDWORD(v69) = HIDWORD(v486.f64[0]);
  float32x2_t v70 = vadd_f32((float32x2_t)__PAIR64__(-*((float *)&v476 + 1), v475.u32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v70, 1), *(float *)(a1 + 16), v70.f32[0]);
  LODWORD(v69) = *(_DWORD *)(a1 + 24);
  v72.i32[0] = *(_DWORD *)(a1 + 28);
  v73.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v70, 1), *(float *)v72.i32, v70.f32[0]);
  float64x2_t v75 = (float64x2_t)v428;
  float32x4_t v431 = vaddq_f32(v428, vmulq_laneq_f32(v68, a2, 3));
  v68.f32[0] = *(float *)&v69 + *(float *)&v71;
  *(float *)v75.f64 = *(float *)v73.i32 + *(float *)v74.i32;
  v68.f32[1] = *(float *)v73.i32 + *(float *)v74.i32;
  *(double *)v76.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v68.i64, v75, v69, v71, v72, v74, v73);
  HIDWORD(v77) = HIDWORD(v486.f64[0]);
  float32x2_t v78 = vadd_f32((float32x2_t)__PAIR64__(-*((float *)&v476 + 1), v477.u32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v79 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v78, 1), *(float *)(a1 + 16), v78.f32[0]);
  LODWORD(v77) = *(_DWORD *)(a1 + 24);
  v80.i32[0] = *(_DWORD *)(a1 + 28);
  v81.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v82.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v78, 1), *(float *)v80.i32, v78.f32[0]);
  float64x2_t v83 = (float64x2_t)v431;
  float32x4_t v432 = vaddq_f32(v431, vmulq_n_f32(v76, a3.f32[0]));
  v76.f32[0] = *(float *)&v77 + *(float *)&v79;
  *(float *)v83.f64 = *(float *)v81.i32 + *(float *)v82.i32;
  v76.f32[1] = *(float *)v81.i32 + *(float *)v82.i32;
  *(double *)v84.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v76.i64, v83, v77, v79, v80, v82, v81);
  HIDWORD(v85) = HIDWORD(v486.f64[0]);
  float32x2_t v86 = vadd_f32((float32x2_t)__PAIR64__(-*((float *)&v476 + 1), LODWORD(v476)), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v87 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v86, 1), *(float *)(a1 + 16), v86.f32[0]);
  LODWORD(v85) = *(_DWORD *)(a1 + 24);
  v88.i32[0] = *(_DWORD *)(a1 + 28);
  v89.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v90.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v86, 1), *(float *)v88.i32, v86.f32[0]);
  float64x2_t v91 = (float64x2_t)v432;
  float32x4_t v433 = vaddq_f32(v432, vmulq_lane_f32(v84, *(float32x2_t *)a3.f32, 1));
  v84.f32[0] = *(float *)&v85 + *(float *)&v87;
  *(float *)v91.f64 = *(float *)v89.i32 + *(float *)v90.i32;
  v84.f32[1] = *(float *)v89.i32 + *(float *)v90.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v84.i64, v91, v85, v87, v88, v90, v89);
  v93.f32[0] = -*(float *)&v476;
  v93.f32[1] = -v477.f32[1];
  HIDWORD(v94) = HIDWORD(v486.f64[0]);
  float32x2_t v95 = vadd_f32(v93, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v96 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v95, 1), *(float *)(a1 + 16), v95.f32[0]);
  LODWORD(v94) = *(_DWORD *)(a1 + 24);
  v97.i32[0] = *(_DWORD *)(a1 + 28);
  v98.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v99.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v95, 1), *(float *)v97.i32, v95.f32[0]);
  float64x2_t v100 = (float64x2_t)v433;
  float32x4_t v434 = vaddq_f32(v433, vmulq_laneq_f32(v92, a3, 2));
  v92.f32[0] = *(float *)&v94 + *(float *)&v96;
  *(float *)v100.f64 = *(float *)v98.i32 + *(float *)v99.i32;
  v92.f32[1] = *(float *)v98.i32 + *(float *)v99.i32;
  *(double *)v101.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v92.i64, v100, v94, v96, v97, v99, v98);
  HIDWORD(v102) = HIDWORD(v486.f64[0]);
  float32x2_t v103 = vadd_f32((float32x2_t)__PAIR64__(-v477.f32[1], -v477.f32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v104 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v103, 1), *(float *)(a1 + 16), v103.f32[0]);
  LODWORD(v102) = *(_DWORD *)(a1 + 24);
  v105.i32[0] = *(_DWORD *)(a1 + 28);
  v106.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v107.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v103, 1), *(float *)v105.i32, v103.f32[0]);
  float64x2_t v108 = (float64x2_t)v434;
  float32x4_t v436 = vaddq_f32(v434, vmulq_laneq_f32(v101, a3, 3));
  v101.f32[0] = *(float *)&v102 + *(float *)&v104;
  *(float *)v108.f64 = *(float *)v106.i32 + *(float *)v107.i32;
  v101.f32[1] = *(float *)v106.i32 + *(float *)v107.i32;
  *(double *)v109.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v101.i64, v108, v102, v104, v105, v107, v106);
  HIDWORD(v11CI::NodeWithChildren::NodeWithChildren(this, 0) = HIDWORD(v486.f64[0]);
  float32x2_t v111 = vadd_f32((float32x2_t)__PAIR64__(-v477.f32[1], -*(float *)&a21.i32[2]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v112 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v111, 1), *(float *)(a1 + 16), v111.f32[0]);
  LODWORD(v11CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v113.i32[0] = *(_DWORD *)(a1 + 28);
  v114.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v115.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v111, 1), *(float *)v113.i32, v111.f32[0]);
  float64x2_t v116 = (float64x2_t)v436;
  float32x4_t v437 = vaddq_f32(v436, vmulq_n_f32(v109, a4.f32[0]));
  v109.f32[0] = *(float *)&v110 + *(float *)&v112;
  *(float *)v116.f64 = *(float *)v114.i32 + *(float *)v115.i32;
  v109.f32[1] = *(float *)v114.i32 + *(float *)v115.i32;
  *(double *)v117.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v109.i64, v116, v110, v112, v113, v115, v114);
  v118.i32[0] = 0;
  v118.f32[1] = -v477.f32[1];
  HIDWORD(v119) = HIDWORD(v486.f64[0]);
  float32x2_t v120 = vadd_f32(v118, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v121 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v120, 1), *(float *)(a1 + 16), v120.f32[0]);
  LODWORD(v119) = *(_DWORD *)(a1 + 24);
  v122.i32[0] = *(_DWORD *)(a1 + 28);
  v123.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v124.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v120, 1), *(float *)v122.i32, v120.f32[0]);
  float64x2_t v125 = (float64x2_t)v437;
  float32x4_t v438 = vaddq_f32(v437, vmulq_lane_f32(v117, *(float32x2_t *)a4.f32, 1));
  v117.f32[0] = *(float *)&v119 + *(float *)&v121;
  *(float *)v125.f64 = *(float *)v123.i32 + *(float *)v124.i32;
  v117.f32[1] = *(float *)v123.i32 + *(float *)v124.i32;
  *(double *)v126.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v117.i64, v125, v119, v121, v122, v124, v123);
  HIDWORD(v127) = HIDWORD(v486.f64[0]);
  float32x2_t v128 = vadd_f32((float32x2_t)__PAIR64__(-v477.f32[1], v475.u32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v129 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v128, 1), *(float *)(a1 + 16), v128.f32[0]);
  LODWORD(v127) = *(_DWORD *)(a1 + 24);
  v130.i32[0] = *(_DWORD *)(a1 + 28);
  v131.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v132.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v128, 1), *(float *)v130.i32, v128.f32[0]);
  float64x2_t v133 = (float64x2_t)v438;
  float32x4_t v439 = vaddq_f32(v438, vmulq_laneq_f32(v126, a4, 2));
  v126.f32[0] = *(float *)&v127 + *(float *)&v129;
  *(float *)v133.f64 = *(float *)v131.i32 + *(float *)v132.i32;
  v126.f32[1] = *(float *)v131.i32 + *(float *)v132.i32;
  *(double *)v134.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v126.i64, v133, v127, v129, v130, v132, v131);
  HIDWORD(v135) = HIDWORD(v486.f64[0]);
  float32x2_t v136 = vadd_f32((float32x2_t)__PAIR64__(-v477.f32[1], v477.u32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v137 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v136, 1), *(float *)(a1 + 16), v136.f32[0]);
  LODWORD(v135) = *(_DWORD *)(a1 + 24);
  v138.i32[0] = *(_DWORD *)(a1 + 28);
  v139.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v140.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v136, 1), *(float *)v138.i32, v136.f32[0]);
  float64x2_t v141 = (float64x2_t)v439;
  float32x4_t v441 = vaddq_f32(v439, vmulq_laneq_f32(v134, a4, 3));
  v134.f32[0] = *(float *)&v135 + *(float *)&v137;
  *(float *)v141.f64 = *(float *)v139.i32 + *(float *)v140.i32;
  v134.f32[1] = *(float *)v139.i32 + *(float *)v140.i32;
  *(double *)v142.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v134.i64, v141, v135, v137, v138, v140, v139);
  HIDWORD(v143) = HIDWORD(v486.f64[0]);
  float32x2_t v144 = vadd_f32((float32x2_t)__PAIR64__(-v477.f32[1], LODWORD(v476)), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v145 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v144, 1), *(float *)(a1 + 16), v144.f32[0]);
  LODWORD(v143) = *(_DWORD *)(a1 + 24);
  v146.i32[0] = *(_DWORD *)(a1 + 28);
  v147.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v148.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v144, 1), *(float *)v146.i32, v144.f32[0]);
  float64x2_t v149 = (float64x2_t)v441;
  float32x4_t v442 = vaddq_f32(v441, vmulq_n_f32(v142, a5.f32[0]));
  v142.f32[0] = *(float *)&v143 + *(float *)&v145;
  *(float *)v149.f64 = *(float *)v147.i32 + *(float *)v148.i32;
  v142.f32[1] = *(float *)v147.i32 + *(float *)v148.i32;
  *(double *)v150.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v142.i64, v149, v143, v145, v146, v148, v147);
  v151.f32[0] = -*(float *)&v476;
  v151.f32[1] = -*(float *)&a21.i32[3];
  HIDWORD(v152) = HIDWORD(v486.f64[0]);
  float32x2_t v153 = vadd_f32(v151, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v154 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v153, 1), *(float *)(a1 + 16), v153.f32[0]);
  LODWORD(v152) = *(_DWORD *)(a1 + 24);
  v155.i32[0] = *(_DWORD *)(a1 + 28);
  v156.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v157.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v153, 1), *(float *)v155.i32, v153.f32[0]);
  float64x2_t v158 = (float64x2_t)v442;
  float32x4_t v443 = vaddq_f32(v442, vmulq_lane_f32(v150, *(float32x2_t *)a5.f32, 1));
  v150.f32[0] = *(float *)&v152 + *(float *)&v154;
  *(float *)v158.f64 = *(float *)v156.i32 + *(float *)v157.i32;
  v150.f32[1] = *(float *)v156.i32 + *(float *)v157.i32;
  *(double *)v159.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v150.i64, v158, v152, v154, v155, v157, v156);
  HIDWORD(v16CI::NodeWithChildren::NodeWithChildren(this, 0) = HIDWORD(v486.f64[0]);
  float32x2_t v161 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], -v477.f32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v162 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v161, 1), *(float *)(a1 + 16), v161.f32[0]);
  LODWORD(v16CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v163.i32[0] = *(_DWORD *)(a1 + 28);
  v164.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v165.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v161, 1), *(float *)v163.i32, v161.f32[0]);
  float64x2_t v166 = (float64x2_t)v443;
  float32x4_t v444 = vaddq_f32(v443, vmulq_laneq_f32(v159, a5, 2));
  v159.f32[0] = *(float *)&v160 + *(float *)&v162;
  *(float *)v166.f64 = *(float *)v164.i32 + *(float *)v165.i32;
  v159.f32[1] = *(float *)v164.i32 + *(float *)v165.i32;
  *(double *)v167.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v159.i64, v166, v160, v162, v163, v165, v164);
  HIDWORD(v16_Block_object_dispose(&STACK[0x3A0], 8) = HIDWORD(v486.f64[0]);
  float32x2_t v169 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], -*(float *)&a21.i32[2]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v170 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v169, 1), *(float *)(a1 + 16), v169.f32[0]);
  LODWORD(v16_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v171.i32[0] = *(_DWORD *)(a1 + 28);
  v172.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v173.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v169, 1), *(float *)v171.i32, v169.f32[0]);
  float64x2_t v174 = (float64x2_t)v444;
  float32x4_t v446 = vaddq_f32(v444, vmulq_laneq_f32(v167, a5, 3));
  v167.f32[0] = *(float *)&v168 + *(float *)&v170;
  *(float *)v174.f64 = *(float *)v172.i32 + *(float *)v173.i32;
  v167.f32[1] = *(float *)v172.i32 + *(float *)v173.i32;
  *(double *)v175.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v167.i64, v174, v168, v170, v171, v173, v172);
  LODWORD(v176) = 0;
  *((float *)&v176 + 1) = -*(float *)&a21.i32[3];
  float32x2_t v177 = vadd_f32(*(float32x2_t *)&v176, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v178 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v177, 1), *(float *)(a1 + 16), v177.f32[0]);
  LODWORD(v176) = *(_DWORD *)(a1 + 24);
  v179.i32[0] = *(_DWORD *)(a1 + 28);
  v180.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v181.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v177, 1), *(float *)v179.i32, v177.f32[0]);
  float64x2_t v182 = (float64x2_t)v446;
  float32x4_t v447 = vaddq_f32(v446, vmulq_n_f32(v175, a6.f32[0]));
  v175.f32[0] = *(float *)&v176 + *(float *)&v178;
  *(float *)v182.f64 = *(float *)v180.i32 + *(float *)v181.i32;
  v175.f32[1] = *(float *)v180.i32 + *(float *)v181.i32;
  *(double *)v183.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v175.i64, v182, v176, v178, v179, v181, v180);
  HIDWORD(v184) = HIDWORD(v486.f64[0]);
  float32x2_t v185 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], v475.u32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v186 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v185, 1), *(float *)(a1 + 16), v185.f32[0]);
  LODWORD(v184) = *(_DWORD *)(a1 + 24);
  v187.i32[0] = *(_DWORD *)(a1 + 28);
  v188.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v189.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v185, 1), *(float *)v187.i32, v185.f32[0]);
  float64x2_t v190 = (float64x2_t)v447;
  float32x4_t v448 = vaddq_f32(v447, vmulq_lane_f32(v183, *(float32x2_t *)a6.f32, 1));
  v183.f32[0] = *(float *)&v184 + *(float *)&v186;
  *(float *)v190.f64 = *(float *)v188.i32 + *(float *)v189.i32;
  v183.f32[1] = *(float *)v188.i32 + *(float *)v189.i32;
  *(double *)v191.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v183.i64, v190, v184, v186, v187, v189, v188);
  HIDWORD(v192) = HIDWORD(v486.f64[0]);
  float32x2_t v193 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], v477.u32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v194 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v193, 1), *(float *)(a1 + 16), v193.f32[0]);
  LODWORD(v192) = *(_DWORD *)(a1 + 24);
  v195.i32[0] = *(_DWORD *)(a1 + 28);
  v196.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v197.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v193, 1), *(float *)v195.i32, v193.f32[0]);
  float64x2_t v198 = (float64x2_t)v448;
  float32x4_t v449 = vaddq_f32(v448, vmulq_laneq_f32(v191, a6, 2));
  v191.f32[0] = *(float *)&v192 + *(float *)&v194;
  *(float *)v198.f64 = *(float *)v196.i32 + *(float *)v197.i32;
  v191.f32[1] = *(float *)v196.i32 + *(float *)v197.i32;
  *(double *)v199.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v191.i64, v198, v192, v194, v195, v197, v196);
  HIDWORD(v20CI::NodeWithChildren::NodeWithChildren(this, 0) = HIDWORD(v486.f64[0]);
  float32x2_t v201 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], LODWORD(v476)), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v202 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v201, 1), *(float *)(a1 + 16), v201.f32[0]);
  LODWORD(v20CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v203.i32[0] = *(_DWORD *)(a1 + 28);
  v204.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v205.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v201, 1), *(float *)v203.i32, v201.f32[0]);
  float64x2_t v206 = (float64x2_t)v449;
  float32x4_t v454 = vaddq_f32(v449, vmulq_laneq_f32(v199, a6, 3));
  v199.f32[0] = *(float *)&v200 + *(float *)&v202;
  *(float *)v206.f64 = *(float *)v204.i32 + *(float *)v205.i32;
  v199.f32[1] = *(float *)v204.i32 + *(float *)v205.i32;
  *(double *)v207.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v199.i64, v206, v200, v202, v203, v205, v204);
  HIDWORD(v20_Block_object_dispose(&STACK[0x3A0], 8) = HIDWORD(v486.f64[0]);
  float32x2_t v209 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&v476), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v210 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v209, 1), *(float *)(a1 + 16), v209.f32[0]);
  LODWORD(v20_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v211.i32[0] = *(_DWORD *)(a1 + 28);
  v212.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v213.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v209, 1), *(float *)v211.i32, v209.f32[0]);
  float64x2_t v214 = (float64x2_t)v454;
  float32x4_t v455 = vaddq_f32(v454, vmulq_n_f32(v207, a7.f32[0]));
  v207.f32[0] = *(float *)&v208 + *(float *)&v210;
  *(float *)v214.f64 = *(float *)v212.i32 + *(float *)v213.i32;
  v207.f32[1] = *(float *)v212.i32 + *(float *)v213.i32;
  *(double *)v215.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v207.i64, v214, v208, v210, v211, v213, v212);
  HIDWORD(v216) = HIDWORD(v486.f64[0]);
  float32x2_t v217 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-v477.f32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v218 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v217, 1), *(float *)(a1 + 16), v217.f32[0]);
  LODWORD(v216) = *(_DWORD *)(a1 + 24);
  v219.i32[0] = *(_DWORD *)(a1 + 28);
  v220.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v221.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v217, 1), *(float *)v219.i32, v217.f32[0]);
  float64x2_t v222 = (float64x2_t)v455;
  float32x4_t v456 = vaddq_f32(v455, vmulq_lane_f32(v215, *(float32x2_t *)a7.f32, 1));
  v215.f32[0] = *(float *)&v216 + *(float *)&v218;
  *(float *)v222.f64 = *(float *)v220.i32 + *(float *)v221.i32;
  v215.f32[1] = *(float *)v220.i32 + *(float *)v221.i32;
  *(double *)v223.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v215.i64, v222, v216, v218, v219, v221, v220);
  HIDWORD(v224) = HIDWORD(v486.f64[0]);
  float32x2_t v225 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a21.i32[2]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v226 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v225, 1), *(float *)(a1 + 16), v225.f32[0]);
  LODWORD(v224) = *(_DWORD *)(a1 + 24);
  v227.i32[0] = *(_DWORD *)(a1 + 28);
  v228.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v229.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v225, 1), *(float *)v227.i32, v225.f32[0]);
  float64x2_t v230 = (float64x2_t)v456;
  float32x4_t v457 = vaddq_f32(v456, vmulq_laneq_f32(v223, a7, 2));
  v223.f32[0] = *(float *)&v224 + *(float *)&v226;
  *(float *)v230.f64 = *(float *)v228.i32 + *(float *)v229.i32;
  v223.f32[1] = *(float *)v228.i32 + *(float *)v229.i32;
  *(double *)v231.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v223.i64, v230, v224, v226, v227, v229, v228);
  HIDWORD(v232) = HIDWORD(v486.f64[0]);
  float32x2_t v233 = vadd_f32((float32x2_t)v475.u32[0], *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v234 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v233, 1), *(float *)(a1 + 16), v233.f32[0]);
  LODWORD(v232) = *(_DWORD *)(a1 + 24);
  v235.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v236.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v233, 1), *(float *)(a1 + 28), v233.f32[0]);
  float32x4_t v237 = vmulq_n_f32(v429, *(float *)a8.i32);
  float32x4_t v458 = vaddq_f32(v237, vaddq_f32(v457, vmulq_laneq_f32(v231, a7, 3)));
  v231.f32[0] = *(float *)&v232 + *(float *)&v234;
  v237.f32[0] = *(float *)v235.i32 + *(float *)v236.i32;
  v231.f32[1] = *(float *)v235.i32 + *(float *)v236.i32;
  *(double *)v238.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v231.i64, (float64x2_t)v237, v232, v234, a8, v236, v235);
  HIDWORD(v239) = HIDWORD(v486.f64[0]);
  float32x2_t v240 = vadd_f32((float32x2_t)v477.u32[0], *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v241 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v240, 1), *(float *)(a1 + 16), v240.f32[0]);
  LODWORD(v239) = *(_DWORD *)(a1 + 24);
  v242.i32[0] = *(_DWORD *)(a1 + 28);
  v243.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v244.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v240, 1), *(float *)v242.i32, v240.f32[0]);
  float64x2_t v245 = (float64x2_t)v458;
  float32x4_t v459 = vaddq_f32(v458, vmulq_lane_f32(v238, *(float32x2_t *)a8.i8, 1));
  v238.f32[0] = *(float *)&v239 + *(float *)&v241;
  *(float *)v245.f64 = *(float *)v243.i32 + *(float *)v244.i32;
  v238.f32[1] = *(float *)v243.i32 + *(float *)v244.i32;
  *(double *)v246.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v238.i64, v245, v239, v241, v242, v244, v243);
  HIDWORD(v247) = HIDWORD(v486.f64[0]);
  float32x2_t v248 = vadd_f32((float32x2_t)LODWORD(v476), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v249 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v248, 1), *(float *)(a1 + 16), v248.f32[0]);
  LODWORD(v247) = *(_DWORD *)(a1 + 24);
  v250.i32[0] = *(_DWORD *)(a1 + 28);
  v251.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v252.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v248, 1), *(float *)v250.i32, v248.f32[0]);
  float64x2_t v253 = (float64x2_t)v459;
  float32x4_t v460 = vaddq_f32(v459, vmulq_laneq_f32(v246, (float32x4_t)a8, 2));
  v246.f32[0] = *(float *)&v247 + *(float *)&v249;
  *(float *)v253.f64 = *(float *)v251.i32 + *(float *)v252.i32;
  v246.f32[1] = *(float *)v251.i32 + *(float *)v252.i32;
  *(double *)v254.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v246.i64, v253, v247, v249, v250, v252, v251);
  HIDWORD(v255) = HIDWORD(v486.f64[0]);
  float32x2_t v256 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], -*(float *)&v476), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v257 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v256, 1), *(float *)(a1 + 16), v256.f32[0]);
  LODWORD(v255) = *(_DWORD *)(a1 + 24);
  v258.i32[0] = *(_DWORD *)(a1 + 28);
  v259.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v260.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v256, 1), *(float *)v258.i32, v256.f32[0]);
  float64x2_t v261 = (float64x2_t)v460;
  float32x4_t v461 = vaddq_f32(v460, vmulq_laneq_f32(v254, (float32x4_t)a8, 3));
  v254.f32[0] = *(float *)&v255 + *(float *)&v257;
  *(float *)v261.f64 = *(float *)v259.i32 + *(float *)v260.i32;
  v254.f32[1] = *(float *)v259.i32 + *(float *)v260.i32;
  *(double *)v262.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v254.i64, v261, v255, v257, v258, v260, v259);
  HIDWORD(v263) = HIDWORD(v486.f64[0]);
  float32x2_t v264 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], -v477.f32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v265 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v264, 1), *(float *)(a1 + 16), v264.f32[0]);
  LODWORD(v263) = *(_DWORD *)(a1 + 24);
  v266.i32[0] = *(_DWORD *)(a1 + 28);
  v267.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v268.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v264, 1), *(float *)v266.i32, v264.f32[0]);
  float64x2_t v269 = (float64x2_t)v461;
  float32x4_t v462 = vaddq_f32(v461, vmulq_n_f32(v262, a9.f32[0]));
  v262.f32[0] = *(float *)&v263 + *(float *)&v265;
  *(float *)v269.f64 = *(float *)v267.i32 + *(float *)v268.i32;
  v262.f32[1] = *(float *)v267.i32 + *(float *)v268.i32;
  *(double *)v270.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v262.i64, v269, v263, v265, v266, v268, v267);
  HIDWORD(v271) = HIDWORD(v486.f64[0]);
  float32x2_t v272 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], -*(float *)&a21.i32[2]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v273 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v272, 1), *(float *)(a1 + 16), v272.f32[0]);
  LODWORD(v271) = *(_DWORD *)(a1 + 24);
  v274.i32[0] = *(_DWORD *)(a1 + 28);
  v275.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v276.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v272, 1), *(float *)v274.i32, v272.f32[0]);
  float64x2_t v277 = (float64x2_t)v462;
  float32x4_t v463 = vaddq_f32(v462, vmulq_lane_f32(v270, *(float32x2_t *)a9.f32, 1));
  v270.f32[0] = *(float *)&v271 + *(float *)&v273;
  *(float *)v277.f64 = *(float *)v275.i32 + *(float *)v276.i32;
  v270.f32[1] = *(float *)v275.i32 + *(float *)v276.i32;
  *(double *)v278.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v270.i64, v277, v271, v273, v274, v276, v275);
  v279.i32[1] = v475.i32[1];
  v279.i32[0] = 0;
  HIDWORD(v28CI::NodeWithChildren::NodeWithChildren(this, 0) = HIDWORD(v486.f64[0]);
  float32x2_t v281 = vadd_f32(v279, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v282 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v281, 1), *(float *)(a1 + 16), v281.f32[0]);
  LODWORD(v28CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v283.i32[0] = *(_DWORD *)(a1 + 28);
  v284.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v285.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v281, 1), *(float *)v283.i32, v281.f32[0]);
  float64x2_t v286 = (float64x2_t)v463;
  float32x4_t v464 = vaddq_f32(v463, vmulq_laneq_f32(v278, a9, 2));
  v278.f32[0] = *(float *)&v280 + *(float *)&v282;
  *(float *)v286.f64 = *(float *)v284.i32 + *(float *)v285.i32;
  v278.f32[1] = *(float *)v284.i32 + *(float *)v285.i32;
  *(double *)v287.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v278.i64, v286, v280, v282, v283, v285, v284);
  HIDWORD(v28_Block_object_dispose(&STACK[0x3A0], 8) = HIDWORD(v486.f64[0]);
  float32x2_t v289 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], v475.u32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v290 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v289, 1), *(float *)(a1 + 16), v289.f32[0]);
  LODWORD(v28_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v291.i32[0] = *(_DWORD *)(a1 + 28);
  v292.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v293.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v289, 1), *(float *)v291.i32, v289.f32[0]);
  float64x2_t v294 = (float64x2_t)v464;
  float32x4_t v465 = vaddq_f32(v464, vmulq_laneq_f32(v287, a9, 3));
  v287.f32[0] = *(float *)&v288 + *(float *)&v290;
  *(float *)v294.f64 = *(float *)v292.i32 + *(float *)v293.i32;
  v287.f32[1] = *(float *)v292.i32 + *(float *)v293.i32;
  *(double *)v295.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v287.i64, v294, v288, v290, v291, v293, v292);
  HIDWORD(v296) = HIDWORD(v486.f64[0]);
  float32x2_t v297 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], v477.u32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v298 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v297, 1), *(float *)(a1 + 16), v297.f32[0]);
  LODWORD(v296) = *(_DWORD *)(a1 + 24);
  v299.i32[0] = *(_DWORD *)(a1 + 28);
  v300.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v301.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v297, 1), *(float *)v299.i32, v297.f32[0]);
  float64x2_t v302 = (float64x2_t)v465;
  float32x4_t v466 = vaddq_f32(v465, vmulq_n_f32(v295, a17.f32[0]));
  v295.f32[0] = *(float *)&v296 + *(float *)&v298;
  *(float *)v302.f64 = *(float *)v300.i32 + *(float *)v301.i32;
  v295.f32[1] = *(float *)v300.i32 + *(float *)v301.i32;
  *(double *)v303.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v295.i64, v302, v296, v298, v299, v301, v300);
  HIDWORD(v304) = HIDWORD(v486.f64[0]);
  float32x2_t v305 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], LODWORD(v476)), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v306 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v305, 1), *(float *)(a1 + 16), v305.f32[0]);
  LODWORD(v304) = *(_DWORD *)(a1 + 24);
  v307.i32[0] = *(_DWORD *)(a1 + 28);
  v308.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v309.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v305, 1), *(float *)v307.i32, v305.f32[0]);
  float64x2_t v310 = (float64x2_t)v466;
  float32x4_t v467 = vaddq_f32(v466, vmulq_lane_f32(v303, *(float32x2_t *)a17.f32, 1));
  v303.f32[0] = *(float *)&v304 + *(float *)&v306;
  *(float *)v310.f64 = *(float *)v308.i32 + *(float *)v309.i32;
  v303.f32[1] = *(float *)v308.i32 + *(float *)v309.i32;
  *(double *)v311.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v303.i64, v310, v304, v306, v307, v309, v308);
  HIDWORD(v312) = HIDWORD(v486.f64[0]);
  float32x2_t v313 = vadd_f32((float32x2_t)__PAIR64__(v477.u32[1], -*(float *)&v476), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v314 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v313, 1), *(float *)(a1 + 16), v313.f32[0]);
  LODWORD(v312) = *(_DWORD *)(a1 + 24);
  v315.i32[0] = *(_DWORD *)(a1 + 28);
  v316.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v317.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v313, 1), *(float *)v315.i32, v313.f32[0]);
  float64x2_t v318 = (float64x2_t)v467;
  float32x4_t v468 = vaddq_f32(v467, vmulq_laneq_f32(v311, a17, 2));
  v311.f32[0] = *(float *)&v312 + *(float *)&v314;
  *(float *)v318.f64 = *(float *)v316.i32 + *(float *)v317.i32;
  v311.f32[1] = *(float *)v316.i32 + *(float *)v317.i32;
  *(double *)v319.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v311.i64, v318, v312, v314, v315, v317, v316);
  HIDWORD(v32CI::NodeWithChildren::NodeWithChildren(this, 0) = HIDWORD(v486.f64[0]);
  float32x2_t v321 = vadd_f32((float32x2_t)__PAIR64__(v477.u32[1], -v477.f32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v322 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v321, 1), *(float *)(a1 + 16), v321.f32[0]);
  LODWORD(v32CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v323.i32[0] = *(_DWORD *)(a1 + 28);
  v324.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v325.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v321, 1), *(float *)v323.i32, v321.f32[0]);
  float64x2_t v326 = (float64x2_t)v468;
  float32x4_t v469 = vaddq_f32(v468, vmulq_laneq_f32(v319, a17, 3));
  v319.f32[0] = *(float *)&v320 + *(float *)&v322;
  *(float *)v326.f64 = *(float *)v324.i32 + *(float *)v325.i32;
  v319.f32[1] = *(float *)v324.i32 + *(float *)v325.i32;
  *(double *)v327.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v319.i64, v326, v320, v322, v323, v325, v324);
  HIDWORD(v32_Block_object_dispose(&STACK[0x3A0], 8) = HIDWORD(v486.f64[0]);
  float32x2_t v329 = vadd_f32((float32x2_t)__PAIR64__(v477.u32[1], -*(float *)&a21.i32[2]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v330 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v329, 1), *(float *)(a1 + 16), v329.f32[0]);
  LODWORD(v32_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v331.i32[0] = *(_DWORD *)(a1 + 28);
  v332.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v333.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v329, 1), *(float *)v331.i32, v329.f32[0]);
  float64x2_t v334 = (float64x2_t)v469;
  float32x4_t v470 = vaddq_f32(v469, vmulq_n_f32(v327, a18.f32[0]));
  v327.f32[0] = *(float *)&v328 + *(float *)&v330;
  *(float *)v334.f64 = *(float *)v332.i32 + *(float *)v333.i32;
  v327.f32[1] = *(float *)v332.i32 + *(float *)v333.i32;
  *(double *)v335.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v327.i64, v334, v328, v330, v331, v333, v332);
  v336.i32[1] = v477.i32[1];
  HIDWORD(v337) = HIDWORD(v486.f64[0]);
  v336.i32[0] = 0;
  float32x2_t v338 = vadd_f32(v336, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v339 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v338, 1), *(float *)(a1 + 16), v338.f32[0]);
  LODWORD(v337) = *(_DWORD *)(a1 + 24);
  v340.i32[0] = *(_DWORD *)(a1 + 28);
  v341.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v342.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v338, 1), *(float *)v340.i32, v338.f32[0]);
  float64x2_t v343 = (float64x2_t)v470;
  float32x4_t v471 = vaddq_f32(v470, vmulq_lane_f32(v335, *(float32x2_t *)a18.f32, 1));
  v335.f32[0] = *(float *)&v337 + *(float *)&v339;
  *(float *)v343.f64 = *(float *)v341.i32 + *(float *)v342.i32;
  v335.f32[1] = *(float *)v341.i32 + *(float *)v342.i32;
  *(double *)v344.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v335.i64, v343, v337, v339, v340, v342, v341);
  HIDWORD(v345) = HIDWORD(v486.f64[0]);
  float32x2_t v346 = vadd_f32((float32x2_t)__PAIR64__(v477.u32[1], v475.u32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v347 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v346, 1), *(float *)(a1 + 16), v346.f32[0]);
  LODWORD(v345) = *(_DWORD *)(a1 + 24);
  v348.i32[0] = *(_DWORD *)(a1 + 28);
  v349.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v350.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v346, 1), *(float *)v348.i32, v346.f32[0]);
  float64x2_t v351 = (float64x2_t)v471;
  float32x4_t v472 = vaddq_f32(v471, vmulq_laneq_f32(v344, a18, 2));
  v344.f32[0] = *(float *)&v345 + *(float *)&v347;
  *(float *)v351.f64 = *(float *)v349.i32 + *(float *)v350.i32;
  v344.f32[1] = *(float *)v349.i32 + *(float *)v350.i32;
  *(double *)v352.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v344.i64, v351, v345, v347, v348, v350, v349);
  HIDWORD(v353) = v477.i32[1];
  float32x2_t v354 = vadd_f32(v477, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v355 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v354, 1), *(float *)(a1 + 16), v354.f32[0]);
  LODWORD(v353) = *(_DWORD *)(a1 + 24);
  v356.i32[0] = *(_DWORD *)(a1 + 28);
  v357.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v358.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v354, 1), *(float *)v356.i32, v354.f32[0]);
  float64x2_t v359 = (float64x2_t)v472;
  float32x4_t v478 = vaddq_f32(v472, vmulq_laneq_f32(v352, a18, 3));
  v352.f32[0] = *(float *)&v353 + *(float *)&v355;
  *(float *)v359.f64 = *(float *)v357.i32 + *(float *)v358.i32;
  v352.f32[1] = *(float *)v357.i32 + *(float *)v358.i32;
  *(double *)v360.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v352.i64, v359, v353, v355, v356, v358, v357);
  HIDWORD(v361) = HIDWORD(v486.f64[0]);
  float32x2_t v362 = vadd_f32(vmul_f32(v475, (float32x2_t)0x4000000040400000), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v363 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v362, 1), *(float *)(a1 + 16), v362.f32[0]);
  LODWORD(v361) = *(_DWORD *)(a1 + 24);
  v364.i32[0] = *(_DWORD *)(a1 + 28);
  v365.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v366.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v362, 1), *(float *)v364.i32, v362.f32[0]);
  float64x2_t v367 = (float64x2_t)v478;
  float32x4_t v479 = vaddq_f32(v478, vmulq_n_f32(v360, a19.f32[0]));
  v360.f32[0] = *(float *)&v361 + *(float *)&v363;
  *(float *)v367.f64 = *(float *)v365.i32 + *(float *)v366.i32;
  v360.f32[1] = *(float *)v365.i32 + *(float *)v366.i32;
  *(double *)v368.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v360.i64, v367, v361, v363, v364, v366, v365);
  HIDWORD(v369) = HIDWORD(v486.f64[0]);
  float32x2_t v370 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v476), -*(float *)&v476), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v371 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v370, 1), *(float *)(a1 + 16), v370.f32[0]);
  LODWORD(v369) = *(_DWORD *)(a1 + 24);
  v372.i32[0] = *(_DWORD *)(a1 + 28);
  v373.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v374.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v370, 1), *(float *)v372.i32, v370.f32[0]);
  float64x2_t v375 = (float64x2_t)v479;
  float32x4_t v480 = vaddq_f32(v479, vmulq_lane_f32(v368, *(float32x2_t *)a19.f32, 1));
  v368.f32[0] = *(float *)&v369 + *(float *)&v371;
  *(float *)v375.f64 = *(float *)v373.i32 + *(float *)v374.i32;
  v368.f32[1] = *(float *)v373.i32 + *(float *)v374.i32;
  *(double *)v376.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v368.i64, v375, v369, v371, v372, v374, v373);
  HIDWORD(v377) = HIDWORD(v486.f64[0]);
  float32x2_t v378 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v476), v474), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v379 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v378, 1), *(float *)(a1 + 16), v378.f32[0]);
  LODWORD(v377) = *(_DWORD *)(a1 + 24);
  v380.i32[0] = *(_DWORD *)(a1 + 28);
  v381.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v382.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v378, 1), *(float *)v380.i32, v378.f32[0]);
  float64x2_t v383 = (float64x2_t)v480;
  float32x4_t v481 = vaddq_f32(v480, vmulq_laneq_f32(v376, a19, 2));
  v376.f32[0] = *(float *)&v377 + *(float *)&v379;
  *(float *)v383.f64 = *(float *)v381.i32 + *(float *)v382.i32;
  v376.f32[1] = *(float *)v381.i32 + *(float *)v382.i32;
  *(double *)v384.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v376.i64, v383, v377, v379, v380, v382, v381);
  HIDWORD(v385) = HIDWORD(v486.f64[0]);
  float32x2_t v386 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v476), -*(float *)&a21.i32[2]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v387 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v386, 1), *(float *)(a1 + 16), v386.f32[0]);
  LODWORD(v385) = *(_DWORD *)(a1 + 24);
  v388.i32[0] = *(_DWORD *)(a1 + 28);
  v389.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v390.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v386, 1), *(float *)v388.i32, v386.f32[0]);
  float64x2_t v391 = (float64x2_t)v481;
  float32x4_t v482 = vaddq_f32(v481, vmulq_laneq_f32(v384, a19, 3));
  v384.f32[0] = *(float *)&v385 + *(float *)&v387;
  *(float *)v391.f64 = *(float *)v389.i32 + *(float *)v390.i32;
  v384.f32[1] = *(float *)v389.i32 + *(float *)v390.i32;
  *(double *)v392.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v384.i64, v391, v385, v387, v388, v390, v389);
  v393.i32[1] = HIDWORD(v476);
  v393.i32[0] = 0;
  HIDWORD(v394) = HIDWORD(v486.f64[0]);
  float32x2_t v395 = vadd_f32(v393, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v396 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v395, 1), *(float *)(a1 + 16), v395.f32[0]);
  LODWORD(v394) = *(_DWORD *)(a1 + 24);
  v397.i32[0] = *(_DWORD *)(a1 + 28);
  v398.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v399.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v395, 1), *(float *)v397.i32, v395.f32[0]);
  float64x2_t v400 = (float64x2_t)v482;
  float32x4_t v483 = vaddq_f32(v482, vmulq_n_f32(v392, a20.f32[0]));
  v392.f32[0] = *(float *)&v394 + *(float *)&v396;
  *(float *)v400.f64 = *(float *)v398.i32 + *(float *)v399.i32;
  v392.f32[1] = *(float *)v398.i32 + *(float *)v399.i32;
  *(double *)v401.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v392.i64, v400, v394, v396, v397, v399, v398);
  HIDWORD(v402) = HIDWORD(v486.f64[0]);
  float32x2_t v403 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v476), v475.u32[0]), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v404 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v403, 1), *(float *)(a1 + 16), v403.f32[0]);
  LODWORD(v402) = *(_DWORD *)(a1 + 24);
  v405.i32[0] = *(_DWORD *)(a1 + 28);
  v406.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v407.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v403, 1), *(float *)v405.i32, v403.f32[0]);
  float64x2_t v408 = (float64x2_t)v483;
  float32x4_t v484 = vaddq_f32(v483, vmulq_lane_f32(v401, *(float32x2_t *)a20.f32, 1));
  v401.f32[0] = *(float *)&v402 + *(float *)&v404;
  *(float *)v408.f64 = *(float *)v406.i32 + *(float *)v407.i32;
  v401.f32[1] = *(float *)v406.i32 + *(float *)v407.i32;
  *(double *)v409.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v401.i64, v408, v402, v404, v405, v407, v406);
  HIDWORD(v41CI::NodeWithChildren::NodeWithChildren(this, 0) = HIDWORD(v486.f64[0]);
  float32x2_t v411 = vadd_f32(vmul_f32(v475, (float32x2_t)0x4040000040000000), *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v412 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v411, 1), *(float *)(a1 + 16), v411.f32[0]);
  LODWORD(v41CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v413.i32[0] = *(_DWORD *)(a1 + 28);
  v414.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v415.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v411, 1), *(float *)v413.i32, v411.f32[0]);
  float64x2_t v416 = (float64x2_t)v484;
  float32x4_t v485 = vaddq_f32(v484, vmulq_laneq_f32(v409, a20, 2));
  v409.f32[0] = *(float *)&v410 + *(float *)&v412;
  *(float *)v416.f64 = *(float *)v414.i32 + *(float *)v415.i32;
  v409.f32[1] = *(float *)v414.i32 + *(float *)v415.i32;
  *(double *)v417.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v409.i64, v416, v410, v412, v413, v415, v414);
  HIDWORD(v41_Block_object_dispose(&STACK[0x3A0], 8) = HIDWORD(v476);
  float32x2_t v419 = vadd_f32(*(float32x2_t *)&v476, *(float32x2_t *)&v486.f64[0]);
  *(float *)&double v420 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v419, 1), *(float *)(a1 + 16), v419.f32[0]);
  LODWORD(v41_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v421.i32[0] = *(_DWORD *)(a1 + 28);
  v422.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v423.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v419, 1), *(float *)v421.i32, v419.f32[0]);
  float64x2_t v424 = (float64x2_t)v485;
  float32x4_t v487 = vaddq_f32(v485, vmulq_laneq_f32(v417, a20, 3));
  v417.f32[0] = *(float *)&v418 + *(float *)&v420;
  *(float *)v424.f64 = *(float *)v422.i32 + *(float *)v423.i32;
  v417.f32[1] = *(float *)v422.i32 + *(float *)v423.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v417.i64, v424, v418, v420, v421, v423, v422);
  result.i64[0] = vaddq_f32(v487, vmulq_n_f32(result, *(float *)a21.i32)).u64[0];
  result.i32[3] = v429.i32[3];
  return result;
}

void CI::f4_sr_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float64x2_t v10 = *(double (**)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double))(a1 + 24);
  uint64_t v11 = *(void *)(v9 + 8);
  int v12 = *(_DWORD *)(v9 + 40);
  uint64_t v13 = *(void *)(v9 + 32);
  int v14 = *(_DWORD *)(v9 + 64);
  uint64_t v15 = *(void *)(v9 + 56);
  int8x16_t v16 = (const vec2 *)*(unsigned int *)(v9 + 88);
  uint64_t v17 = *(void *)(v9 + 80);
  int v18 = *(_DWORD *)(v9 + 112);
  uint64_t v19 = *(void *)(v9 + 104);
  int v20 = *(_DWORD *)(v9 + 136);
  uint64_t v21 = *(void *)(v9 + 128);
  int v22 = *(_DWORD *)(v9 + 160);
  uint64_t v23 = *(void *)(v9 + 152);
  uint64_t v24 = *(void *)(v9 + 176);
  int v75 = *(_DWORD *)(v9 + 208);
  int v76 = *(_DWORD *)(v9 + 184);
  uint64_t v25 = *(void *)(v9 + 200);
  uint64_t v26 = *(void *)(v9 + 224);
  int v73 = *(_DWORD *)(v9 + 256);
  int v74 = *(_DWORD *)(v9 + 232);
  uint64_t v27 = *(void *)(v9 + 248);
  int v72 = *(_DWORD *)(v9 + 280);
  uint64_t v28 = *(void *)(v9 + 272);
  int v29 = *(_DWORD *)(v9 + 304);
  uint64_t v30 = *(void *)(v9 + 296);
  int v31 = *(_DWORD *)(v9 + 328);
  uint64_t v32 = *(void *)(v9 + 320);
  if (*(unsigned char *)(a1 + 64))
  {
    double v71 = *(double (**)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double))(a1 + 24);
    uint64_t v68 = *(void *)(v9 + 56);
    uint64_t v69 = *(void *)(v9 + 8);
    uint64_t v33 = a4;
    int v66 = *(_DWORD *)(v9 + 112);
    int v34 = *(_DWORD *)(v9 + 40);
    uint64_t v70 = *(void *)(v9 + 32);
    uint64_t v64 = *(void *)(v9 + 128);
    uint64_t v65 = *(void *)(v9 + 104);
    int v35 = *(_DWORD *)(v9 + 64);
    uint64_t v67 = *(void *)(v9 + 80);
    int v36 = *(_DWORD *)(v9 + 88);
    uint64_t v62 = *(void *)(v9 + 176);
    uint64_t v63 = *(void *)(v9 + 152);
    uint64_t v60 = *(void *)(v9 + 224);
    uint64_t v61 = *(void *)(v9 + 200);
    uint64_t v59 = *(void *)(v9 + 248);
    int v57 = *(_DWORD *)(v9 + 328);
    int v58 = *(_DWORD *)(v9 + 304);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 344)), v16);
    int v31 = v57;
    int v29 = v58;
    uint64_t v27 = v59;
    uint64_t v26 = v60;
    uint64_t v25 = v61;
    uint64_t v24 = v62;
    uint64_t v23 = v63;
    LODWORD(v16) = v36;
    uint64_t v17 = v67;
    int v14 = v35;
    uint64_t v21 = v64;
    uint64_t v19 = v65;
    uint64_t v11 = v69;
    uint64_t v13 = v70;
    int v12 = v34;
    int v18 = v66;
    a4 = v33;
    uint64_t v15 = v68;
    float64x2_t v10 = v71;
  }
  double v37 = (double *)(a3 + 16 * v32);
  if (v31 != 5) {
    double v37 = (double *)(a2 + (v32 << 6));
  }
  int8x16_t v38 = (double *)(a3 + 16 * v30);
  if (v29 != 5) {
    int8x16_t v38 = (double *)(a2 + (v30 << 6));
  }
  int8x16_t v39 = (double *)(a3 + 16 * v28);
  if (v72 != 5) {
    int8x16_t v39 = (double *)(a2 + (v28 << 6));
  }
  int8x16_t v40 = (double *)(a3 + 16 * v27);
  float32x4_t v41 = (double *)(a2 + (v27 << 6));
  if (v73 != 5) {
    int8x16_t v40 = v41;
  }
  float32x2_t v42 = (double *)(a3 + 16 * v26);
  double v43 = (double *)(a2 + (v26 << 6));
  if (v74 != 5) {
    float32x2_t v42 = v43;
  }
  float32x2_t v44 = (__n128 *)(a3 + 16 * v25);
  double v45 = (__n128 *)(a2 + (v25 << 6));
  if (v75 != 5) {
    float32x2_t v44 = v45;
  }
  int8x16_t v46 = (__n128 *)(a3 + 16 * v24);
  int8x16_t v47 = (__n128 *)(a2 + (v24 << 6));
  if (v76 != 5) {
    int8x16_t v46 = v47;
  }
  int8x16_t v48 = (__n128 *)(a3 + 16 * v23);
  float64x2_t v49 = (__n128 *)(a2 + (v23 << 6));
  if (v22 != 5) {
    int8x16_t v48 = v49;
  }
  float32x4_t v50 = (__n128 *)(a3 + 16 * v21);
  float32x2_t v51 = (__n128 *)(a2 + (v21 << 6));
  if (v20 != 5) {
    float32x4_t v50 = v51;
  }
  double v52 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5) {
    double v52 = (__n128 *)(a2 + (v19 << 6));
  }
  float32x2_t v53 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    float32x2_t v53 = (__n128 *)(a2 + (v17 << 6));
  }
  double v54 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    double v54 = (__n128 *)(a2 + (v15 << 6));
  }
  int8x16_t v55 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5) {
    int8x16_t v55 = (__n128 *)(a2 + (v13 << 6));
  }
  *(double *)&long long v56 = v10(a4 + 80 * v11, *v55, *v54, *v53, *v52, *v50, *v48, *v46, *v44, *v42, v42[1], *v40, v40[1], *v39, v39[1], *v38, v38[1], *v37, v37[1]);
  *(_OWORD *)(a3 + 16 * a7) = v56;
}

double cikernel::_convolution7x7(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17, float32x4_t a18, float32x4_t a19, float32x4_t a20,int8x16_t a21)
{
  v22.i64[0] = *(void *)CI::getDC((CI *)a1);
  int8x16_t v488 = v22;
  float64x2_t v23 = (float64x2_t)vextq_s8(a21, a21, 8uLL);
  __asm { FMOV            V0.2S, #3.0 }
  float32x2_t v29 = vmul_f32(*(float32x2_t *)&v23.f64[0], _D0);
  float32x2_t v477 = *(float32x2_t *)&v23.f64[0];
  float32x2_t v478 = v29;
  v29.f32[0] = -v29.f32[0];
  float32_t v476 = v29.f32[0];
  v29.f32[1] = -v29.f32[1];
  float32_t v454 = v29.f32[1];
  float32x2_t v30 = vadd_f32(v29, *(float32x2_t *)v22.i8);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)&v31, v30.f32[0]);
  float32x2_t v479 = vadd_f32(*(float32x2_t *)&v23.f64[0], *(float32x2_t *)&v23.f64[0]);
  v30.f32[0] = *(float *)(a1 + 24) + *(float *)v22.i32;
  *(float *)v23.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v30.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v30, v23, *(double *)v22.i64, v31, v33, v32, a21);
  v35.f32[0] = -v479.f32[0];
  *(float *)&unsigned int v475 = -v479.f32[0];
  v35.f32[1] = v454;
  HIDWORD(v36) = v488.i32[1];
  float32x2_t v37 = vadd_f32(v35, *(float32x2_t *)v488.i8);
  *(float *)&double v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v37, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 24);
  v39.i32[0] = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v37, 1), *(float *)v39.i32, v37.f32[0]);
  float32x4_t v42 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a21.i8, 1);
  float32x4_t v427 = vaddq_f32(v42, vmulq_n_f32(v34, a2.f32[0]));
  v34.f32[0] = *(float *)&v36 + *(float *)&v38;
  v42.f32[0] = *(float *)v40.i32 + *(float *)v41.i32;
  v34.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, (float64x2_t)v42, v36, v38, v39, v41, v40);
  v44.f32[0] = -*(float *)&a21.i32[2];
  v44.f32[1] = v454;
  HIDWORD(v45) = v488.i32[1];
  float32x2_t v46 = vadd_f32(v44, *(float32x2_t *)v488.i8);
  *(float *)&double v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v46, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v45) = *(_DWORD *)(a1 + 24);
  v48.i32[0] = *(_DWORD *)(a1 + 28);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v46, 1), *(float *)v48.i32, v46.f32[0]);
  float64x2_t v51 = (float64x2_t)v427;
  float32x4_t v428 = vaddq_f32(v427, vmulq_lane_f32(v43, *(float32x2_t *)a2.f32, 1));
  v43.f32[0] = *(float *)&v45 + *(float *)&v47;
  *(float *)v51.f64 = *(float *)v49.i32 + *(float *)v50.i32;
  v43.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v51, v45, v47, v48, v50, v49);
  v53.i32[0] = 0;
  v53.f32[1] = v454;
  HIDWORD(v54) = v488.i32[1];
  float32x2_t v55 = vadd_f32(v53, *(float32x2_t *)v488.i8);
  *(float *)&double v56 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v55, 1), *(float *)(a1 + 16), v55.f32[0]);
  LODWORD(v54) = *(_DWORD *)(a1 + 24);
  v57.i32[0] = *(_DWORD *)(a1 + 28);
  v58.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v59.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v55, 1), *(float *)v57.i32, v55.f32[0]);
  float64x2_t v60 = (float64x2_t)v428;
  float32x4_t v429 = vaddq_f32(v428, vmulq_laneq_f32(v52, a2, 2));
  v52.f32[0] = *(float *)&v54 + *(float *)&v56;
  *(float *)v60.f64 = *(float *)v58.i32 + *(float *)v59.i32;
  v52.f32[1] = *(float *)v58.i32 + *(float *)v59.i32;
  *(double *)v61.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v60, v54, v56, v57, v59, v58);
  HIDWORD(v62) = v488.i32[1];
  float32x2_t v63 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v454), v477.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v64 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v63, 1), *(float *)(a1 + 16), v63.f32[0]);
  LODWORD(v62) = *(_DWORD *)(a1 + 24);
  v65.i32[0] = *(_DWORD *)(a1 + 28);
  v66.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v67.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v63, 1), *(float *)v65.i32, v63.f32[0]);
  float64x2_t v68 = (float64x2_t)v429;
  float32x4_t v431 = vaddq_f32(v429, vmulq_laneq_f32(v61, a2, 3));
  v61.f32[0] = *(float *)&v62 + *(float *)&v64;
  *(float *)v68.f64 = *(float *)v66.i32 + *(float *)v67.i32;
  v61.f32[1] = *(float *)v66.i32 + *(float *)v67.i32;
  *(double *)v69.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v61.i64, v68, v62, v64, v65, v67, v66);
  HIDWORD(v7CI::NodeWithChildren::NodeWithChildren(this, 0) = v488.i32[1];
  float32x2_t v71 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v454), v479.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v72 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v71, 1), *(float *)(a1 + 16), v71.f32[0]);
  LODWORD(v7CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v73.i32[0] = *(_DWORD *)(a1 + 28);
  v74.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v75.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v71, 1), *(float *)v73.i32, v71.f32[0]);
  float64x2_t v76 = (float64x2_t)v431;
  float32x4_t v432 = vaddq_f32(v431, vmulq_n_f32(v69, a3.f32[0]));
  v69.f32[0] = *(float *)&v70 + *(float *)&v72;
  *(float *)v76.f64 = *(float *)v74.i32 + *(float *)v75.i32;
  v69.f32[1] = *(float *)v74.i32 + *(float *)v75.i32;
  *(double *)v77.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v69.i64, v76, v70, v72, v73, v75, v74);
  HIDWORD(v7_Block_object_dispose(&STACK[0x3A0], 8) = v488.i32[1];
  float32x2_t v79 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v454), v478.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v80 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v79, 1), *(float *)(a1 + 16), v79.f32[0]);
  LODWORD(v7_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v81.i32[0] = *(_DWORD *)(a1 + 28);
  v82.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v83.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v79, 1), *(float *)v81.i32, v79.f32[0]);
  float64x2_t v84 = (float64x2_t)v432;
  float32x4_t v433 = vaddq_f32(v432, vmulq_lane_f32(v77, *(float32x2_t *)a3.f32, 1));
  v77.f32[0] = *(float *)&v78 + *(float *)&v80;
  *(float *)v84.f64 = *(float *)v82.i32 + *(float *)v83.i32;
  v77.f32[1] = *(float *)v82.i32 + *(float *)v83.i32;
  *(double *)v85.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v77.i64, v84, v78, v80, v81, v83, v82);
  v86.f32[0] = v476;
  v86.f32[1] = -v479.f32[1];
  HIDWORD(v87) = v488.i32[1];
  float32x2_t v88 = vadd_f32(v86, *(float32x2_t *)v488.i8);
  *(float *)&double v89 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v88, 1), *(float *)(a1 + 16), v88.f32[0]);
  LODWORD(v87) = *(_DWORD *)(a1 + 24);
  v90.i32[0] = *(_DWORD *)(a1 + 28);
  v91.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v92.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v88, 1), *(float *)v90.i32, v88.f32[0]);
  float64x2_t v93 = (float64x2_t)v433;
  float32x4_t v434 = vaddq_f32(v433, vmulq_laneq_f32(v85, a3, 2));
  v85.f32[0] = *(float *)&v87 + *(float *)&v89;
  *(float *)v93.f64 = *(float *)v91.i32 + *(float *)v92.i32;
  v85.f32[1] = *(float *)v91.i32 + *(float *)v92.i32;
  *(double *)v94.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v85.i64, v93, v87, v89, v90, v92, v91);
  HIDWORD(v95) = v488.i32[1];
  float32x2_t v96 = vadd_f32((float32x2_t)__PAIR64__(-v479.f32[1], -v479.f32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v97 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v96, 1), *(float *)(a1 + 16), v96.f32[0]);
  LODWORD(v95) = *(_DWORD *)(a1 + 24);
  v98.i32[0] = *(_DWORD *)(a1 + 28);
  v99.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v100.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v96, 1), *(float *)v98.i32, v96.f32[0]);
  float64x2_t v101 = (float64x2_t)v434;
  float32x4_t v436 = vaddq_f32(v434, vmulq_laneq_f32(v94, a3, 3));
  v94.f32[0] = *(float *)&v95 + *(float *)&v97;
  *(float *)v101.f64 = *(float *)v99.i32 + *(float *)v100.i32;
  v94.f32[1] = *(float *)v99.i32 + *(float *)v100.i32;
  *(double *)v102.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v94.i64, v101, v95, v97, v98, v100, v99);
  HIDWORD(v103) = v488.i32[1];
  float32x2_t v104 = vadd_f32((float32x2_t)__PAIR64__(-v479.f32[1], -*(float *)&a21.i32[2]), *(float32x2_t *)v488.i8);
  *(float *)&double v105 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v104, 1), *(float *)(a1 + 16), v104.f32[0]);
  LODWORD(v103) = *(_DWORD *)(a1 + 24);
  v106.i32[0] = *(_DWORD *)(a1 + 28);
  v107.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v108.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v104, 1), *(float *)v106.i32, v104.f32[0]);
  float64x2_t v109 = (float64x2_t)v436;
  float32x4_t v437 = vaddq_f32(v436, vmulq_n_f32(v102, a4.f32[0]));
  v102.f32[0] = *(float *)&v103 + *(float *)&v105;
  *(float *)v109.f64 = *(float *)v107.i32 + *(float *)v108.i32;
  v102.f32[1] = *(float *)v107.i32 + *(float *)v108.i32;
  *(double *)v110.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v102.i64, v109, v103, v105, v106, v108, v107);
  v111.i32[0] = 0;
  v111.f32[1] = -v479.f32[1];
  HIDWORD(v112) = v488.i32[1];
  float32x2_t v113 = vadd_f32(v111, *(float32x2_t *)v488.i8);
  *(float *)&double v114 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v113, 1), *(float *)(a1 + 16), v113.f32[0]);
  LODWORD(v112) = *(_DWORD *)(a1 + 24);
  v115.i32[0] = *(_DWORD *)(a1 + 28);
  v116.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v117.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v113, 1), *(float *)v115.i32, v113.f32[0]);
  float64x2_t v118 = (float64x2_t)v437;
  float32x4_t v438 = vaddq_f32(v437, vmulq_lane_f32(v110, *(float32x2_t *)a4.f32, 1));
  v110.f32[0] = *(float *)&v112 + *(float *)&v114;
  *(float *)v118.f64 = *(float *)v116.i32 + *(float *)v117.i32;
  v110.f32[1] = *(float *)v116.i32 + *(float *)v117.i32;
  *(double *)v119.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v110.i64, v118, v112, v114, v115, v117, v116);
  HIDWORD(v12CI::NodeWithChildren::NodeWithChildren(this, 0) = v488.i32[1];
  float32x2_t v121 = vadd_f32((float32x2_t)__PAIR64__(-v479.f32[1], v477.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v122 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v121, 1), *(float *)(a1 + 16), v121.f32[0]);
  LODWORD(v12CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v123.i32[0] = *(_DWORD *)(a1 + 28);
  v124.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v125.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v121, 1), *(float *)v123.i32, v121.f32[0]);
  float64x2_t v126 = (float64x2_t)v438;
  float32x4_t v439 = vaddq_f32(v438, vmulq_laneq_f32(v119, a4, 2));
  v119.f32[0] = *(float *)&v120 + *(float *)&v122;
  *(float *)v126.f64 = *(float *)v124.i32 + *(float *)v125.i32;
  v119.f32[1] = *(float *)v124.i32 + *(float *)v125.i32;
  *(double *)v127.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v119.i64, v126, v120, v122, v123, v125, v124);
  HIDWORD(v12_Block_object_dispose(&STACK[0x3A0], 8) = v488.i32[1];
  float32x2_t v129 = vadd_f32((float32x2_t)__PAIR64__(-v479.f32[1], v479.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v130 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v129, 1), *(float *)(a1 + 16), v129.f32[0]);
  LODWORD(v12_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v131.i32[0] = *(_DWORD *)(a1 + 28);
  v132.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v133.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v129, 1), *(float *)v131.i32, v129.f32[0]);
  float64x2_t v134 = (float64x2_t)v439;
  float32x4_t v441 = vaddq_f32(v439, vmulq_laneq_f32(v127, a4, 3));
  v127.f32[0] = *(float *)&v128 + *(float *)&v130;
  *(float *)v134.f64 = *(float *)v132.i32 + *(float *)v133.i32;
  v127.f32[1] = *(float *)v132.i32 + *(float *)v133.i32;
  *(double *)v135.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v127.i64, v134, v128, v130, v131, v133, v132);
  HIDWORD(v136) = v488.i32[1];
  float32x2_t v137 = vadd_f32((float32x2_t)__PAIR64__(-v479.f32[1], v478.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v138 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v137, 1), *(float *)(a1 + 16), v137.f32[0]);
  LODWORD(v136) = *(_DWORD *)(a1 + 24);
  v139.i32[0] = *(_DWORD *)(a1 + 28);
  v140.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v141.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v137, 1), *(float *)v139.i32, v137.f32[0]);
  float64x2_t v142 = (float64x2_t)v441;
  float32x4_t v442 = vaddq_f32(v441, vmulq_n_f32(v135, a5.f32[0]));
  v135.f32[0] = *(float *)&v136 + *(float *)&v138;
  *(float *)v142.f64 = *(float *)v140.i32 + *(float *)v141.i32;
  v135.f32[1] = *(float *)v140.i32 + *(float *)v141.i32;
  *(double *)v143.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v135.i64, v142, v136, v138, v139, v141, v140);
  v144.f32[0] = v476;
  v144.f32[1] = -*(float *)&a21.i32[3];
  HIDWORD(v145) = v488.i32[1];
  float32x2_t v146 = vadd_f32(v144, *(float32x2_t *)v488.i8);
  *(float *)&double v147 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v146, 1), *(float *)(a1 + 16), v146.f32[0]);
  LODWORD(v145) = *(_DWORD *)(a1 + 24);
  v148.i32[0] = *(_DWORD *)(a1 + 28);
  v149.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v150.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v146, 1), *(float *)v148.i32, v146.f32[0]);
  float64x2_t v151 = (float64x2_t)v442;
  float32x4_t v443 = vaddq_f32(v442, vmulq_lane_f32(v143, *(float32x2_t *)a5.f32, 1));
  v143.f32[0] = *(float *)&v145 + *(float *)&v147;
  *(float *)v151.f64 = *(float *)v149.i32 + *(float *)v150.i32;
  v143.f32[1] = *(float *)v149.i32 + *(float *)v150.i32;
  *(double *)v152.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v143.i64, v151, v145, v147, v148, v150, v149);
  HIDWORD(v153) = v488.i32[1];
  float32x2_t v154 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], -v479.f32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v155 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v154, 1), *(float *)(a1 + 16), v154.f32[0]);
  LODWORD(v153) = *(_DWORD *)(a1 + 24);
  v156.i32[0] = *(_DWORD *)(a1 + 28);
  v157.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v158.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v154, 1), *(float *)v156.i32, v154.f32[0]);
  float64x2_t v159 = (float64x2_t)v443;
  float32x4_t v444 = vaddq_f32(v443, vmulq_laneq_f32(v152, a5, 2));
  v152.f32[0] = *(float *)&v153 + *(float *)&v155;
  *(float *)v159.f64 = *(float *)v157.i32 + *(float *)v158.i32;
  v152.f32[1] = *(float *)v157.i32 + *(float *)v158.i32;
  *(double *)v160.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v152.i64, v159, v153, v155, v156, v158, v157);
  HIDWORD(v161) = v488.i32[1];
  float32x2_t v162 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], -*(float *)&a21.i32[2]), *(float32x2_t *)v488.i8);
  *(float *)&double v163 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v162, 1), *(float *)(a1 + 16), v162.f32[0]);
  LODWORD(v161) = *(_DWORD *)(a1 + 24);
  v164.i32[0] = *(_DWORD *)(a1 + 28);
  v165.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v166.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v162, 1), *(float *)v164.i32, v162.f32[0]);
  float64x2_t v167 = (float64x2_t)v444;
  float32x4_t v446 = vaddq_f32(v444, vmulq_laneq_f32(v160, a5, 3));
  v160.f32[0] = *(float *)&v161 + *(float *)&v163;
  *(float *)v167.f64 = *(float *)v165.i32 + *(float *)v166.i32;
  v160.f32[1] = *(float *)v165.i32 + *(float *)v166.i32;
  *(double *)v168.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v160.i64, v167, v161, v163, v164, v166, v165);
  LODWORD(v169) = 0;
  *((float *)&v169 + 1) = -*(float *)&a21.i32[3];
  float32x2_t v170 = vadd_f32(*(float32x2_t *)&v169, *(float32x2_t *)v488.i8);
  *(float *)&double v171 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v170, 1), *(float *)(a1 + 16), v170.f32[0]);
  LODWORD(v169) = *(_DWORD *)(a1 + 24);
  v172.i32[0] = *(_DWORD *)(a1 + 28);
  v173.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v174.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v170, 1), *(float *)v172.i32, v170.f32[0]);
  float64x2_t v175 = (float64x2_t)v446;
  float32x4_t v447 = vaddq_f32(v446, vmulq_n_f32(v168, a6.f32[0]));
  v168.f32[0] = *(float *)&v169 + *(float *)&v171;
  *(float *)v175.f64 = *(float *)v173.i32 + *(float *)v174.i32;
  v168.f32[1] = *(float *)v173.i32 + *(float *)v174.i32;
  *(double *)v176.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v168.i64, v175, v169, v171, v172, v174, v173);
  HIDWORD(v177) = v488.i32[1];
  float32x2_t v178 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], v477.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v179 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v178, 1), *(float *)(a1 + 16), v178.f32[0]);
  LODWORD(v177) = *(_DWORD *)(a1 + 24);
  v180.i32[0] = *(_DWORD *)(a1 + 28);
  v181.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v182.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v178, 1), *(float *)v180.i32, v178.f32[0]);
  float64x2_t v183 = (float64x2_t)v447;
  float32x4_t v448 = vaddq_f32(v447, vmulq_lane_f32(v176, *(float32x2_t *)a6.f32, 1));
  v176.f32[0] = *(float *)&v177 + *(float *)&v179;
  *(float *)v183.f64 = *(float *)v181.i32 + *(float *)v182.i32;
  v176.f32[1] = *(float *)v181.i32 + *(float *)v182.i32;
  *(double *)v184.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v176.i64, v183, v177, v179, v180, v182, v181);
  HIDWORD(v185) = v488.i32[1];
  float32x2_t v186 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], v479.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v187 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v186, 1), *(float *)(a1 + 16), v186.f32[0]);
  LODWORD(v185) = *(_DWORD *)(a1 + 24);
  v188.i32[0] = *(_DWORD *)(a1 + 28);
  v189.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v190.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v186, 1), *(float *)v188.i32, v186.f32[0]);
  float64x2_t v191 = (float64x2_t)v448;
  float32x4_t v449 = vaddq_f32(v448, vmulq_laneq_f32(v184, a6, 2));
  v184.f32[0] = *(float *)&v185 + *(float *)&v187;
  *(float *)v191.f64 = *(float *)v189.i32 + *(float *)v190.i32;
  v184.f32[1] = *(float *)v189.i32 + *(float *)v190.i32;
  *(double *)v192.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v184.i64, v191, v185, v187, v188, v190, v189);
  HIDWORD(v193) = v488.i32[1];
  float32x2_t v194 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], v478.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v195 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v194, 1), *(float *)(a1 + 16), v194.f32[0]);
  LODWORD(v193) = *(_DWORD *)(a1 + 24);
  v196.i32[0] = *(_DWORD *)(a1 + 28);
  v197.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v198.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v194, 1), *(float *)v196.i32, v194.f32[0]);
  float64x2_t v199 = (float64x2_t)v449;
  float32x4_t v455 = vaddq_f32(v449, vmulq_laneq_f32(v192, a6, 3));
  v192.f32[0] = *(float *)&v193 + *(float *)&v195;
  *(float *)v199.f64 = *(float *)v197.i32 + *(float *)v198.i32;
  v192.f32[1] = *(float *)v197.i32 + *(float *)v198.i32;
  *(double *)v200.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v192.i64, v199, v193, v195, v196, v198, v197);
  HIDWORD(v201) = v488.i32[1];
  float32x2_t v202 = vadd_f32((float32x2_t)LODWORD(v476), *(float32x2_t *)v488.i8);
  *(float *)&double v203 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v202, 1), *(float *)(a1 + 16), v202.f32[0]);
  LODWORD(v201) = *(_DWORD *)(a1 + 24);
  v204.i32[0] = *(_DWORD *)(a1 + 28);
  v205.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v206.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v202, 1), *(float *)v204.i32, v202.f32[0]);
  float64x2_t v207 = (float64x2_t)v455;
  float32x4_t v456 = vaddq_f32(v455, vmulq_n_f32(v200, a7.f32[0]));
  v200.f32[0] = *(float *)&v201 + *(float *)&v203;
  *(float *)v207.f64 = *(float *)v205.i32 + *(float *)v206.i32;
  v200.f32[1] = *(float *)v205.i32 + *(float *)v206.i32;
  *(double *)v208.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v200.i64, v207, v201, v203, v204, v206, v205);
  HIDWORD(v209) = v488.i32[1];
  float32x2_t v210 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-v479.f32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v211 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v210, 1), *(float *)(a1 + 16), v210.f32[0]);
  LODWORD(v209) = *(_DWORD *)(a1 + 24);
  v212.i32[0] = *(_DWORD *)(a1 + 28);
  v213.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v214.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v210, 1), *(float *)v212.i32, v210.f32[0]);
  float64x2_t v215 = (float64x2_t)v456;
  float32x4_t v457 = vaddq_f32(v456, vmulq_lane_f32(v208, *(float32x2_t *)a7.f32, 1));
  v208.f32[0] = *(float *)&v209 + *(float *)&v211;
  *(float *)v215.f64 = *(float *)v213.i32 + *(float *)v214.i32;
  v208.f32[1] = *(float *)v213.i32 + *(float *)v214.i32;
  *(double *)v216.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v208.i64, v215, v209, v211, v212, v214, v213);
  HIDWORD(v217) = v488.i32[1];
  float32x2_t v218 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a21.i32[2]), *(float32x2_t *)v488.i8);
  *(float *)&double v219 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v218, 1), *(float *)(a1 + 16), v218.f32[0]);
  LODWORD(v217) = *(_DWORD *)(a1 + 24);
  v220.i32[0] = *(_DWORD *)(a1 + 28);
  v221.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v222.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v218, 1), *(float *)v220.i32, v218.f32[0]);
  float64x2_t v223 = (float64x2_t)v457;
  float32x4_t v458 = vaddq_f32(v457, vmulq_laneq_f32(v216, a7, 2));
  v216.f32[0] = *(float *)&v217 + *(float *)&v219;
  *(float *)v223.f64 = *(float *)v221.i32 + *(float *)v222.i32;
  v216.f32[1] = *(float *)v221.i32 + *(float *)v222.i32;
  *(double *)v224.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v216.i64, v223, v217, v219, v220, v222, v221);
  float64x2_t v225 = (float64x2_t)v458;
  float32x4_t v459 = vaddq_f32(v458, vmulq_laneq_f32(v224, a7, 3));
  LODWORD(v226) = *(_DWORD *)(a1 + 28);
  v224.f32[0] = *(float *)(a1 + 24)
              + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v488.i8, 1), *(float *)(a1 + 16), *(float *)v488.i32);
  LODWORD(v227) = *(_DWORD *)(a1 + 36);
  *(float *)v225.f64 = *(float *)&v227
                     + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v488.i8, 1), *(float *)&v226, *(float *)v488.i32);
  v224.i32[1] = LODWORD(v225.f64[0]);
  *(double *)v230.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v224.i64, v225, v226, v227, v488, v228, v229);
  HIDWORD(v231) = v488.i32[1];
  float32x2_t v232 = vadd_f32((float32x2_t)v477.u32[0], *(float32x2_t *)v488.i8);
  *(float *)&double v233 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v232, 1), *(float *)(a1 + 16), v232.f32[0]);
  LODWORD(v231) = *(_DWORD *)(a1 + 24);
  v234.i32[0] = *(_DWORD *)(a1 + 28);
  v235.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v236.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v232, 1), *(float *)v234.i32, v232.f32[0]);
  float64x2_t v237 = (float64x2_t)v459;
  float32x4_t v460 = vaddq_f32(v459, vmulq_n_f32(v230, a8.f32[0]));
  v230.f32[0] = *(float *)&v231 + *(float *)&v233;
  *(float *)v237.f64 = *(float *)v235.i32 + *(float *)v236.i32;
  v230.f32[1] = *(float *)v235.i32 + *(float *)v236.i32;
  *(double *)v238.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v230.i64, v237, v231, v233, v234, v236, v235);
  HIDWORD(v239) = v488.i32[1];
  float32x2_t v240 = vadd_f32((float32x2_t)v479.u32[0], *(float32x2_t *)v488.i8);
  *(float *)&double v241 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v240, 1), *(float *)(a1 + 16), v240.f32[0]);
  LODWORD(v239) = *(_DWORD *)(a1 + 24);
  v242.i32[0] = *(_DWORD *)(a1 + 28);
  v243.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v244.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v240, 1), *(float *)v242.i32, v240.f32[0]);
  float64x2_t v245 = (float64x2_t)v460;
  float32x4_t v461 = vaddq_f32(v460, vmulq_lane_f32(v238, *(float32x2_t *)a8.f32, 1));
  v238.f32[0] = *(float *)&v239 + *(float *)&v241;
  *(float *)v245.f64 = *(float *)v243.i32 + *(float *)v244.i32;
  v238.f32[1] = *(float *)v243.i32 + *(float *)v244.i32;
  *(double *)v246.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v238.i64, v245, v239, v241, v242, v244, v243);
  HIDWORD(v247) = v488.i32[1];
  float32x2_t v248 = vadd_f32((float32x2_t)v478.u32[0], *(float32x2_t *)v488.i8);
  *(float *)&double v249 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v248, 1), *(float *)(a1 + 16), v248.f32[0]);
  LODWORD(v247) = *(_DWORD *)(a1 + 24);
  v250.i32[0] = *(_DWORD *)(a1 + 28);
  v251.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v252.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v248, 1), *(float *)v250.i32, v248.f32[0]);
  float64x2_t v253 = (float64x2_t)v461;
  float32x4_t v462 = vaddq_f32(v461, vmulq_laneq_f32(v246, a8, 2));
  v246.f32[0] = *(float *)&v247 + *(float *)&v249;
  *(float *)v253.f64 = *(float *)v251.i32 + *(float *)v252.i32;
  v246.f32[1] = *(float *)v251.i32 + *(float *)v252.i32;
  *(double *)v254.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v246.i64, v253, v247, v249, v250, v252, v251);
  HIDWORD(v255) = v488.i32[1];
  float32x2_t v256 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], LODWORD(v476)), *(float32x2_t *)v488.i8);
  *(float *)&double v257 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v256, 1), *(float *)(a1 + 16), v256.f32[0]);
  LODWORD(v255) = *(_DWORD *)(a1 + 24);
  v258.i32[0] = *(_DWORD *)(a1 + 28);
  v259.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v260.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v256, 1), *(float *)v258.i32, v256.f32[0]);
  float64x2_t v261 = (float64x2_t)v462;
  float32x4_t v463 = vaddq_f32(v462, vmulq_laneq_f32(v254, a8, 3));
  v254.f32[0] = *(float *)&v255 + *(float *)&v257;
  *(float *)v261.f64 = *(float *)v259.i32 + *(float *)v260.i32;
  v254.f32[1] = *(float *)v259.i32 + *(float *)v260.i32;
  *(double *)v262.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v254.i64, v261, v255, v257, v258, v260, v259);
  HIDWORD(v263) = v488.i32[1];
  float32x2_t v264 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], -v479.f32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v265 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v264, 1), *(float *)(a1 + 16), v264.f32[0]);
  LODWORD(v263) = *(_DWORD *)(a1 + 24);
  v266.i32[0] = *(_DWORD *)(a1 + 28);
  v267.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v268.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v264, 1), *(float *)v266.i32, v264.f32[0]);
  float64x2_t v269 = (float64x2_t)v463;
  float32x4_t v464 = vaddq_f32(v463, vmulq_n_f32(v262, a9.f32[0]));
  v262.f32[0] = *(float *)&v263 + *(float *)&v265;
  *(float *)v269.f64 = *(float *)v267.i32 + *(float *)v268.i32;
  v262.f32[1] = *(float *)v267.i32 + *(float *)v268.i32;
  *(double *)v270.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v262.i64, v269, v263, v265, v266, v268, v267);
  HIDWORD(v271) = v488.i32[1];
  float32x2_t v272 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], -*(float *)&a21.i32[2]), *(float32x2_t *)v488.i8);
  *(float *)&double v273 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v272, 1), *(float *)(a1 + 16), v272.f32[0]);
  LODWORD(v271) = *(_DWORD *)(a1 + 24);
  v274.i32[0] = *(_DWORD *)(a1 + 28);
  v275.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v276.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v272, 1), *(float *)v274.i32, v272.f32[0]);
  float64x2_t v277 = (float64x2_t)v464;
  float32x4_t v465 = vaddq_f32(v464, vmulq_lane_f32(v270, *(float32x2_t *)a9.f32, 1));
  v270.f32[0] = *(float *)&v271 + *(float *)&v273;
  *(float *)v277.f64 = *(float *)v275.i32 + *(float *)v276.i32;
  v270.f32[1] = *(float *)v275.i32 + *(float *)v276.i32;
  *(double *)v278.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v270.i64, v277, v271, v273, v274, v276, v275);
  v279.i32[1] = v477.i32[1];
  v279.i32[0] = 0;
  HIDWORD(v28CI::NodeWithChildren::NodeWithChildren(this, 0) = v488.i32[1];
  float32x2_t v281 = vadd_f32(v279, *(float32x2_t *)v488.i8);
  *(float *)&double v282 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v281, 1), *(float *)(a1 + 16), v281.f32[0]);
  LODWORD(v28CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v283.i32[0] = *(_DWORD *)(a1 + 28);
  v284.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v285.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v281, 1), *(float *)v283.i32, v281.f32[0]);
  float64x2_t v286 = (float64x2_t)v465;
  float32x4_t v466 = vaddq_f32(v465, vmulq_laneq_f32(v278, a9, 2));
  v278.f32[0] = *(float *)&v280 + *(float *)&v282;
  *(float *)v286.f64 = *(float *)v284.i32 + *(float *)v285.i32;
  v278.f32[1] = *(float *)v284.i32 + *(float *)v285.i32;
  *(double *)v287.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v278.i64, v286, v280, v282, v283, v285, v284);
  HIDWORD(v28_Block_object_dispose(&STACK[0x3A0], 8) = v488.i32[1];
  float32x2_t v289 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], v477.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v290 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v289, 1), *(float *)(a1 + 16), v289.f32[0]);
  LODWORD(v28_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v291.i32[0] = *(_DWORD *)(a1 + 28);
  v292.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v293.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v289, 1), *(float *)v291.i32, v289.f32[0]);
  float64x2_t v294 = (float64x2_t)v466;
  float32x4_t v467 = vaddq_f32(v466, vmulq_laneq_f32(v287, a9, 3));
  v287.f32[0] = *(float *)&v288 + *(float *)&v290;
  *(float *)v294.f64 = *(float *)v292.i32 + *(float *)v293.i32;
  v287.f32[1] = *(float *)v292.i32 + *(float *)v293.i32;
  *(double *)v295.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v287.i64, v294, v288, v290, v291, v293, v292);
  HIDWORD(v296) = v488.i32[1];
  float32x2_t v297 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], v479.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v298 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v297, 1), *(float *)(a1 + 16), v297.f32[0]);
  LODWORD(v296) = *(_DWORD *)(a1 + 24);
  v299.i32[0] = *(_DWORD *)(a1 + 28);
  v300.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v301.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v297, 1), *(float *)v299.i32, v297.f32[0]);
  float64x2_t v302 = (float64x2_t)v467;
  float32x4_t v468 = vaddq_f32(v467, vmulq_n_f32(v295, a17.f32[0]));
  v295.f32[0] = *(float *)&v296 + *(float *)&v298;
  *(float *)v302.f64 = *(float *)v300.i32 + *(float *)v301.i32;
  v295.f32[1] = *(float *)v300.i32 + *(float *)v301.i32;
  *(double *)v303.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v295.i64, v302, v296, v298, v299, v301, v300);
  HIDWORD(v304) = v488.i32[1];
  float32x2_t v305 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], v478.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v306 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v305, 1), *(float *)(a1 + 16), v305.f32[0]);
  LODWORD(v304) = *(_DWORD *)(a1 + 24);
  v307.i32[0] = *(_DWORD *)(a1 + 28);
  v308.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v309.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v305, 1), *(float *)v307.i32, v305.f32[0]);
  float64x2_t v310 = (float64x2_t)v468;
  float32x4_t v469 = vaddq_f32(v468, vmulq_lane_f32(v303, *(float32x2_t *)a17.f32, 1));
  v303.f32[0] = *(float *)&v304 + *(float *)&v306;
  *(float *)v310.f64 = *(float *)v308.i32 + *(float *)v309.i32;
  v303.f32[1] = *(float *)v308.i32 + *(float *)v309.i32;
  *(double *)v311.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v303.i64, v310, v304, v306, v307, v309, v308);
  HIDWORD(v312) = v488.i32[1];
  float32x2_t v313 = vadd_f32((float32x2_t)__PAIR64__(v479.u32[1], LODWORD(v476)), *(float32x2_t *)v488.i8);
  *(float *)&double v314 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v313, 1), *(float *)(a1 + 16), v313.f32[0]);
  LODWORD(v312) = *(_DWORD *)(a1 + 24);
  v315.i32[0] = *(_DWORD *)(a1 + 28);
  v316.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v317.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v313, 1), *(float *)v315.i32, v313.f32[0]);
  float64x2_t v318 = (float64x2_t)v469;
  float32x4_t v470 = vaddq_f32(v469, vmulq_laneq_f32(v311, a17, 2));
  v311.f32[0] = *(float *)&v312 + *(float *)&v314;
  *(float *)v318.f64 = *(float *)v316.i32 + *(float *)v317.i32;
  v311.f32[1] = *(float *)v316.i32 + *(float *)v317.i32;
  *(double *)v319.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v311.i64, v318, v312, v314, v315, v317, v316);
  HIDWORD(v32CI::NodeWithChildren::NodeWithChildren(this, 0) = v488.i32[1];
  float32x2_t v321 = vadd_f32((float32x2_t)__PAIR64__(v479.u32[1], -v479.f32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v322 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v321, 1), *(float *)(a1 + 16), v321.f32[0]);
  LODWORD(v32CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v323.i32[0] = *(_DWORD *)(a1 + 28);
  v324.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v325.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v321, 1), *(float *)v323.i32, v321.f32[0]);
  float64x2_t v326 = (float64x2_t)v470;
  float32x4_t v471 = vaddq_f32(v470, vmulq_laneq_f32(v319, a17, 3));
  v319.f32[0] = *(float *)&v320 + *(float *)&v322;
  *(float *)v326.f64 = *(float *)v324.i32 + *(float *)v325.i32;
  v319.f32[1] = *(float *)v324.i32 + *(float *)v325.i32;
  *(double *)v327.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v319.i64, v326, v320, v322, v323, v325, v324);
  HIDWORD(v32_Block_object_dispose(&STACK[0x3A0], 8) = v488.i32[1];
  float32x2_t v329 = vadd_f32((float32x2_t)__PAIR64__(v479.u32[1], -*(float *)&a21.i32[2]), *(float32x2_t *)v488.i8);
  *(float *)&double v330 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v329, 1), *(float *)(a1 + 16), v329.f32[0]);
  LODWORD(v32_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v331.i32[0] = *(_DWORD *)(a1 + 28);
  v332.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v333.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v329, 1), *(float *)v331.i32, v329.f32[0]);
  float64x2_t v334 = (float64x2_t)v471;
  float32x4_t v472 = vaddq_f32(v471, vmulq_n_f32(v327, a18.f32[0]));
  v327.f32[0] = *(float *)&v328 + *(float *)&v330;
  *(float *)v334.f64 = *(float *)v332.i32 + *(float *)v333.i32;
  v327.f32[1] = *(float *)v332.i32 + *(float *)v333.i32;
  *(double *)v335.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v327.i64, v334, v328, v330, v331, v333, v332);
  v336.i32[1] = v479.i32[1];
  HIDWORD(v337) = v488.i32[1];
  v336.i32[0] = 0;
  float32x2_t v338 = vadd_f32(v336, *(float32x2_t *)v488.i8);
  *(float *)&double v339 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v338, 1), *(float *)(a1 + 16), v338.f32[0]);
  LODWORD(v337) = *(_DWORD *)(a1 + 24);
  v340.i32[0] = *(_DWORD *)(a1 + 28);
  v341.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v342.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v338, 1), *(float *)v340.i32, v338.f32[0]);
  float64x2_t v343 = (float64x2_t)v472;
  float32x4_t v473 = vaddq_f32(v472, vmulq_lane_f32(v335, *(float32x2_t *)a18.f32, 1));
  v335.f32[0] = *(float *)&v337 + *(float *)&v339;
  *(float *)v343.f64 = *(float *)v341.i32 + *(float *)v342.i32;
  v335.f32[1] = *(float *)v341.i32 + *(float *)v342.i32;
  *(double *)v344.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v335.i64, v343, v337, v339, v340, v342, v341);
  HIDWORD(v345) = v488.i32[1];
  float32x2_t v346 = vadd_f32((float32x2_t)__PAIR64__(v479.u32[1], v477.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v347 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v346, 1), *(float *)(a1 + 16), v346.f32[0]);
  LODWORD(v345) = *(_DWORD *)(a1 + 24);
  v348.i32[0] = *(_DWORD *)(a1 + 28);
  v349.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v350.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v346, 1), *(float *)v348.i32, v346.f32[0]);
  float64x2_t v351 = (float64x2_t)v473;
  float32x4_t v474 = vaddq_f32(v473, vmulq_laneq_f32(v344, a18, 2));
  v344.f32[0] = *(float *)&v345 + *(float *)&v347;
  *(float *)v351.f64 = *(float *)v349.i32 + *(float *)v350.i32;
  v344.f32[1] = *(float *)v349.i32 + *(float *)v350.i32;
  *(double *)v352.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v344.i64, v351, v345, v347, v348, v350, v349);
  HIDWORD(v353) = v488.i32[1];
  float32x2_t v354 = vadd_f32(v479, *(float32x2_t *)v488.i8);
  *(float *)&double v355 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v354, 1), *(float *)(a1 + 16), v354.f32[0]);
  LODWORD(v353) = *(_DWORD *)(a1 + 24);
  v356.i32[0] = *(_DWORD *)(a1 + 28);
  v357.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v358.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v354, 1), *(float *)v356.i32, v354.f32[0]);
  float64x2_t v359 = (float64x2_t)v474;
  float32x4_t v480 = vaddq_f32(v474, vmulq_laneq_f32(v352, a18, 3));
  v352.f32[0] = *(float *)&v353 + *(float *)&v355;
  *(float *)v359.f64 = *(float *)v357.i32 + *(float *)v358.i32;
  v352.f32[1] = *(float *)v357.i32 + *(float *)v358.i32;
  *(double *)v360.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v352.i64, v359, v353, v355, v356, v358, v357);
  HIDWORD(v361) = v488.i32[1];
  float32x2_t v362 = vadd_f32(vmul_f32(v477, (float32x2_t)0x4000000040400000), *(float32x2_t *)v488.i8);
  *(float *)&double v363 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v362, 1), *(float *)(a1 + 16), v362.f32[0]);
  LODWORD(v361) = *(_DWORD *)(a1 + 24);
  v364.i32[0] = *(_DWORD *)(a1 + 28);
  v365.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v366.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v362, 1), *(float *)v364.i32, v362.f32[0]);
  float64x2_t v367 = (float64x2_t)v480;
  float32x4_t v481 = vaddq_f32(v480, vmulq_n_f32(v360, a19.f32[0]));
  v360.f32[0] = *(float *)&v361 + *(float *)&v363;
  *(float *)v367.f64 = *(float *)v365.i32 + *(float *)v366.i32;
  v360.f32[1] = *(float *)v365.i32 + *(float *)v366.i32;
  *(double *)v368.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v360.i64, v367, v361, v363, v364, v366, v365);
  HIDWORD(v369) = v488.i32[1];
  float32x2_t v370 = vadd_f32((float32x2_t)__PAIR64__(v478.u32[1], LODWORD(v476)), *(float32x2_t *)v488.i8);
  *(float *)&double v371 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v370, 1), *(float *)(a1 + 16), v370.f32[0]);
  LODWORD(v369) = *(_DWORD *)(a1 + 24);
  v372.i32[0] = *(_DWORD *)(a1 + 28);
  v373.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v374.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v370, 1), *(float *)v372.i32, v370.f32[0]);
  float64x2_t v375 = (float64x2_t)v481;
  float32x4_t v482 = vaddq_f32(v481, vmulq_lane_f32(v368, *(float32x2_t *)a19.f32, 1));
  v368.f32[0] = *(float *)&v369 + *(float *)&v371;
  *(float *)v375.f64 = *(float *)v373.i32 + *(float *)v374.i32;
  v368.f32[1] = *(float *)v373.i32 + *(float *)v374.i32;
  *(double *)v376.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v368.i64, v375, v369, v371, v372, v374, v373);
  HIDWORD(v377) = v488.i32[1];
  float32x2_t v378 = vadd_f32((float32x2_t)__PAIR64__(v478.u32[1], v475), *(float32x2_t *)v488.i8);
  *(float *)&double v379 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v378, 1), *(float *)(a1 + 16), v378.f32[0]);
  LODWORD(v377) = *(_DWORD *)(a1 + 24);
  v380.i32[0] = *(_DWORD *)(a1 + 28);
  v381.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v382.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v378, 1), *(float *)v380.i32, v378.f32[0]);
  float64x2_t v383 = (float64x2_t)v482;
  float32x4_t v483 = vaddq_f32(v482, vmulq_laneq_f32(v376, a19, 2));
  v376.f32[0] = *(float *)&v377 + *(float *)&v379;
  *(float *)v383.f64 = *(float *)v381.i32 + *(float *)v382.i32;
  v376.f32[1] = *(float *)v381.i32 + *(float *)v382.i32;
  *(double *)v384.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v376.i64, v383, v377, v379, v380, v382, v381);
  HIDWORD(v385) = v488.i32[1];
  float32x2_t v386 = vadd_f32((float32x2_t)__PAIR64__(v478.u32[1], -*(float *)&a21.i32[2]), *(float32x2_t *)v488.i8);
  *(float *)&double v387 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v386, 1), *(float *)(a1 + 16), v386.f32[0]);
  LODWORD(v385) = *(_DWORD *)(a1 + 24);
  v388.i32[0] = *(_DWORD *)(a1 + 28);
  v389.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v390.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v386, 1), *(float *)v388.i32, v386.f32[0]);
  float64x2_t v391 = (float64x2_t)v483;
  float32x4_t v484 = vaddq_f32(v483, vmulq_laneq_f32(v384, a19, 3));
  v384.f32[0] = *(float *)&v385 + *(float *)&v387;
  *(float *)v391.f64 = *(float *)v389.i32 + *(float *)v390.i32;
  v384.f32[1] = *(float *)v389.i32 + *(float *)v390.i32;
  *(double *)v392.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v384.i64, v391, v385, v387, v388, v390, v389);
  v393.i32[1] = v478.i32[1];
  v393.i32[0] = 0;
  HIDWORD(v394) = v488.i32[1];
  float32x2_t v395 = vadd_f32(v393, *(float32x2_t *)v488.i8);
  *(float *)&double v396 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v395, 1), *(float *)(a1 + 16), v395.f32[0]);
  LODWORD(v394) = *(_DWORD *)(a1 + 24);
  v397.i32[0] = *(_DWORD *)(a1 + 28);
  v398.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v399.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v395, 1), *(float *)v397.i32, v395.f32[0]);
  float64x2_t v400 = (float64x2_t)v484;
  float32x4_t v485 = vaddq_f32(v484, vmulq_n_f32(v392, a20.f32[0]));
  v392.f32[0] = *(float *)&v394 + *(float *)&v396;
  *(float *)v400.f64 = *(float *)v398.i32 + *(float *)v399.i32;
  v392.f32[1] = *(float *)v398.i32 + *(float *)v399.i32;
  *(double *)v401.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v392.i64, v400, v394, v396, v397, v399, v398);
  HIDWORD(v402) = v488.i32[1];
  float32x2_t v403 = vadd_f32((float32x2_t)__PAIR64__(v478.u32[1], v477.u32[0]), *(float32x2_t *)v488.i8);
  *(float *)&double v404 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v403, 1), *(float *)(a1 + 16), v403.f32[0]);
  LODWORD(v402) = *(_DWORD *)(a1 + 24);
  v405.i32[0] = *(_DWORD *)(a1 + 28);
  v406.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v407.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v403, 1), *(float *)v405.i32, v403.f32[0]);
  float64x2_t v408 = (float64x2_t)v485;
  float32x4_t v486 = vaddq_f32(v485, vmulq_lane_f32(v401, *(float32x2_t *)a20.f32, 1));
  v401.f32[0] = *(float *)&v402 + *(float *)&v404;
  *(float *)v408.f64 = *(float *)v406.i32 + *(float *)v407.i32;
  v401.f32[1] = *(float *)v406.i32 + *(float *)v407.i32;
  *(double *)v409.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v401.i64, v408, v402, v404, v405, v407, v406);
  HIDWORD(v41CI::NodeWithChildren::NodeWithChildren(this, 0) = v488.i32[1];
  float32x2_t v411 = vadd_f32(vmul_f32(v477, (float32x2_t)0x4040000040000000), *(float32x2_t *)v488.i8);
  *(float *)&double v412 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v411, 1), *(float *)(a1 + 16), v411.f32[0]);
  LODWORD(v41CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v413.i32[0] = *(_DWORD *)(a1 + 28);
  v414.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v415.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v411, 1), *(float *)v413.i32, v411.f32[0]);
  float64x2_t v416 = (float64x2_t)v486;
  float32x4_t v487 = vaddq_f32(v486, vmulq_laneq_f32(v409, a20, 2));
  v409.f32[0] = *(float *)&v410 + *(float *)&v412;
  *(float *)v416.f64 = *(float *)v414.i32 + *(float *)v415.i32;
  v409.f32[1] = *(float *)v414.i32 + *(float *)v415.i32;
  *(double *)v417.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v409.i64, v416, v410, v412, v413, v415, v414);
  HIDWORD(v41_Block_object_dispose(&STACK[0x3A0], 8) = v488.i32[1];
  float32x2_t v419 = vadd_f32(v478, *(float32x2_t *)v488.i8);
  *(float *)&double v420 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v419, 1), *(float *)(a1 + 16), v419.f32[0]);
  LODWORD(v41_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v421.i32[0] = *(_DWORD *)(a1 + 28);
  v422.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v423.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v419, 1), *(float *)v421.i32, v419.f32[0]);
  float64x2_t v424 = (float64x2_t)v487;
  float32x4_t v489 = vaddq_f32(v487, vmulq_laneq_f32(v417, a20, 3));
  v417.f32[0] = *(float *)&v418 + *(float *)&v420;
  *(float *)v424.f64 = *(float *)v422.i32 + *(float *)v423.i32;
  v417.f32[1] = *(float *)v422.i32 + *(float *)v423.i32;
  *(double *)v425.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v417.i64, v424, v418, v420, v421, v423, v422);
  *(void *)&double result = vaddq_f32(v489, vmulq_n_f32(v425, *(float *)a21.i32)).u64[0];
  return result;
}

double cikernel::_copyMachineTransition(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, __n128 a7)
{
  v7.i64[0] = *(void *)CI::getDC(a1);
  v7.i64[1] = __PAIR64__(1.0, a7.n128_u32[0]);
  int8x16_t v8 = (int8x16_t)vmulq_f32(a5, v7);
  float v9 = vaddv_f32(vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)));
  if (v9 <= 1.0) {
    float v10 = v9;
  }
  else {
    float v10 = 1.0;
  }
  BOOL v11 = v9 < 0.0;
  float v12 = 0.0;
  if (v11) {
    float v10 = 0.0;
  }
  float v13 = fminf(vmlas_n_f32(a4.f32[1], v10, a4.f32[0]), vmuls_lane_f32(v10, a4, 2));
  if (v13 <= 1.0) {
    float v14 = v13;
  }
  else {
    float v14 = 1.0;
  }
  if (v13 >= 0.0) {
    float v12 = v14;
  }
  float v15 = fmaxf(v10, a7.n128_f32[2]);
  *(void *)&double result = vaddq_f32(vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - v15), a3, v15), vmulq_n_f32(a6, vmuls_lane_f32(v12, (float32x2_t)a7.n128_u64[0], 1))).u64[0];
  return result;
}

void CI::f4_s_s_f3_f4_f4_f3(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128))(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = *(void *)(v9 + 56);
  int v16 = *(_DWORD *)(v9 + 88);
  uint64_t v17 = *(void *)(v9 + 80);
  int v18 = *(_DWORD *)(v9 + 112);
  uint64_t v19 = *(void *)(v9 + 104);
  uint64_t v20 = *(void *)(v9 + 128);
  if (*(unsigned char *)(a1 + 64))
  {
    int v27 = *(_DWORD *)(v9 + 88);
    int v28 = *(_DWORD *)(v9 + 16);
    int v26 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 152)), a2);
    int v13 = v26;
    int v16 = v27;
    int v11 = v28;
  }
  uint64_t v21 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5) {
    uint64_t v21 = (__n128 *)((char *)a2 + 64 * v19);
  }
  int8x16_t v22 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x16_t v22 = (__n128 *)((char *)a2 + 64 * v17);
  }
  float64x2_t v23 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    float64x2_t v23 = (__n128 *)((char *)a2 + 64 * v14);
  }
  uint64_t v24 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    uint64_t v24 = (__n128 *)((char *)a2 + 64 * v12);
  }
  *(double *)&long long v25 = v10(*v24, *v23, *((__n128 *)a2 + 4 * v15), *v22, *v21, *((__n128 *)a2 + 4 * v20));
  *(_OWORD *)(a3 + 16 * a7) = v25;
}

uint64_t getMLMultiArrayClass(void)
{
  uint64_t v3 = 0;
  float64x2_t v4 = &v3;
  uint64_t v5 = 0x3052000000;
  double v6 = __Block_byref_object_copy__2;
  float32x4_t v7 = __Block_byref_object_dispose__2;
  uint64_t v0 = getMLMultiArrayClass(void)::softClass;
  uint64_t v8 = getMLMultiArrayClass(void)::softClass;
  if (!getMLMultiArrayClass(void)::softClass)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = ___ZL20getMLMultiArrayClassv_block_invoke;
    v2[3] = &unk_1E57710B8;
    void v2[4] = &v3;
    ___ZL20getMLMultiArrayClassv_block_invoke((uint64_t)v2);
    uint64_t v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_193734204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getMLFeatureValueClass(void)
{
  uint64_t v3 = 0;
  float64x2_t v4 = &v3;
  uint64_t v5 = 0x3052000000;
  double v6 = __Block_byref_object_copy__2;
  float32x4_t v7 = __Block_byref_object_dispose__2;
  uint64_t v0 = getMLFeatureValueClass(void)::softClass;
  uint64_t v8 = getMLFeatureValueClass(void)::softClass;
  if (!getMLFeatureValueClass(void)::softClass)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = ___ZL22getMLFeatureValueClassv_block_invoke;
    v2[3] = &unk_1E57710B8;
    void v2[4] = &v3;
    ___ZL22getMLFeatureValueClassv_block_invoke((uint64_t)v2);
    uint64_t v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1937342F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_193735064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
}

uint64_t featureTypeOfName(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (void *)[a1 modelDescription];
  if (a3 == 1)
  {
    double v6 = (void *)[v5 outputDescriptionsByName];
  }
  else if (a3)
  {
    double v6 = 0;
  }
  else
  {
    double v6 = (void *)[v5 inputDescriptionsByName];
  }
  float32x4_t v7 = (void *)[v6 objectForKey:a2];

  return [v7 type];
}

CVPixelBufferRef copyProcessorInput(void *a1, OSType a2)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  CVPixelBufferRef pixelBuffer = 0;
  [a1 region];
  size_t v5 = (unint64_t)v4;
  [a1 region];
  unint64_t v7 = (unint64_t)v6;
  uint64_t v15 = *MEMORY[0x1E4F24D20];
  v16[0] = MEMORY[0x1E4F1CC08];
  CVPixelBufferCreate(0, v5, (unint64_t)v6, a2, (CFDictionaryRef)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v16 forKeys:&v15 count:1], &pixelBuffer);
  CVPixelBufferRef result = pixelBuffer;
  if (pixelBuffer)
  {
    CVPixelBufferLockBaseAddress(pixelBuffer, 0);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(pixelBuffer);
    size_t BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
    uint64_t v11 = [a1 baseAddress];
    if (v7)
    {
      uint64_t v12 = v11;
      for (uint64_t i = 0; i != v7; ++i)
      {
        memcpy(BaseAddress, (const void *)(v12 + [a1 bytesPerRow] * i), BytesPerRow);
        BaseAddress += BytesPerRow;
      }
    }
    CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
    return pixelBuffer;
  }
  return result;
}

uint64_t shapeForLayer(void *a1, uint64_t a2, uint64_t a3)
{
  size_t v5 = (void *)[a1 modelDescription];
  if (a3 == 1)
  {
    double v6 = (void *)[v5 outputDescriptionsByName];
  }
  else if (a3)
  {
    double v6 = 0;
  }
  else
  {
    double v6 = (void *)[v5 inputDescriptionsByName];
  }
  unint64_t v7 = (void *)[v6 objectForKey:a2];
  if ([v7 type] == 5)
  {
    uint64_t v8 = objc_msgSend((id)objc_msgSend(v7, "multiArrayConstraint"), "shapeConstraint");
    uint64_t result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v8, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "count");
    if ((unint64_t)(result - 2) <= 2)
    {
      uint64_t v10 = result - 1;
      objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v8, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "objectAtIndexedSubscript:", result - 2), "integerValue");
      return objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v8, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "objectAtIndexedSubscript:", v10), "integerValue");
    }
  }
  else
  {
    uint64_t result = [v7 type];
    if (result == 4)
    {
      objc_msgSend((id)objc_msgSend(v7, "imageConstraint"), "pixelsHigh");
      return objc_msgSend((id)objc_msgSend(v7, "imageConstraint"), "pixelsWide");
    }
  }
  return result;
}

void fillMultiArrayFloatToRh<float>(void *a1, void *a2)
{
  uint64_t v4 = [a2 dataPointer];
  size_t v5 = (void *)[a2 shape];
  uint64_t v6 = [v5 count];
  int v7 = objc_msgSend((id)objc_msgSend(v5, "objectAtIndexedSubscript:", v6 - 2), "intValue");
  uint64_t v8 = [a1 baseAddress];
  unint64_t v9 = [a1 bytesPerRow];
  [a1 region];
  double v11 = v10;
  double v13 = v12;
  double v15 = v14;
  double v17 = v16;
  uint64_t v18 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 3), "unsignedLongValue");
  uint64_t v19 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 2), "unsignedLongValue");
  uint64_t v20 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 1), "unsignedLongValue");
  [a1 region];
  uint64_t v22 = [a1 bytesPerRow] * ((int)v21 - 1);
  [a1 region];
  bzero((void *)[a1 baseAddress], v22 + 2 * (int)v23);
  if (v17 > 0.0)
  {
    int v24 = 0;
    do
    {
      if (v15 > 0.0)
      {
        uint64_t v25 = 0;
        int v26 = (int *)(v4 + 4 * (v20 * (int)v11 + v18 * ((v24 + (int)v13) / v7) + v19 * ((v24 + (int)v13) % v7)));
        do
        {
          _S0 = *v26;
          __asm { FCVT            H0, S0 }
          *(_WORD *)(v8 + 2 * v25++) = _S0;
          v26 += v20;
        }
        while (v15 > (double)(int)v25);
      }
      ++v24;
      v8 += 2 * (v9 >> 1);
    }
    while (v17 > (double)v24);
  }
}

void _ZL23fillMultiArrayFloatToRhIDF16_EvPU33objcproto22CIImageProcessorOutput11objc_objectP12MLMultiArray(void *a1, void *a2)
{
  uint64_t v4 = [a2 dataPointer];
  size_t v5 = (void *)[a2 shape];
  uint64_t v6 = [v5 count];
  int v7 = objc_msgSend((id)objc_msgSend(v5, "objectAtIndexedSubscript:", v6 - 2), "intValue");
  uint64_t v8 = [a1 baseAddress];
  unint64_t v9 = [a1 bytesPerRow];
  [a1 region];
  double v11 = v10;
  double v13 = v12;
  double v15 = v14;
  double v17 = v16;
  uint64_t v18 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 3), "unsignedLongValue");
  uint64_t v19 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 2), "unsignedLongValue");
  uint64_t v20 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 1), "unsignedLongValue");
  [a1 region];
  uint64_t v22 = [a1 bytesPerRow] * ((int)v21 - 1);
  [a1 region];
  bzero((void *)[a1 baseAddress], v22 + 2 * (int)v23);
  if (v17 > 0.0)
  {
    int v24 = 0;
    do
    {
      if (v15 > 0.0)
      {
        uint64_t v25 = 0;
        int v26 = (_WORD *)(v4 + 2 * (v20 * (int)v11 + v18 * ((v24 + (int)v13) / v7) + v19 * ((v24 + (int)v13) % v7)));
        do
        {
          *(_WORD *)(v8 + 2 * v25++) = *v26;
          v26 += v20;
        }
        while (v15 > (double)(int)v25);
      }
      ++v24;
      v8 += 2 * (v9 >> 1);
    }
    while (v17 > (double)v24);
  }
}

uint64_t channelCountOfName(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = featureTypeOfName(a1, a2, a3);
  if (v6 == 4) {
    return 1;
  }
  if (v6 != 5) {
    return 0xFFFFFFFFLL;
  }
  int v7 = (void *)[a1 modelDescription];
  if (a3 == 1) {
    uint64_t v8 = (void *)[v7 outputDescriptionsByName];
  }
  else {
    uint64_t v8 = a3 ? 0 : (void *)[v7 inputDescriptionsByName];
  }
  double v10 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v8, "objectForKey:", a2), "multiArrayConstraint"), "shapeConstraint");
  if ([v10 type] != 2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "count");
  if (v11 != 4)
  {
    if (v11 == 3) {
      return objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "objectAtIndexedSubscript:", 0), "integerValue");
    }
    return 0xFFFFFFFFLL;
  }
  return objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "objectAtIndexedSubscript:", 1), "integerValue");
}

CIImage *process(void *a1, void *a2, uint64_t a3, __CFString *a4, unsigned int a5, uint64_t a6)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = objc_msgSend((id)objc_msgSend(a1, "allKeys"), "sortedArrayUsingSelector:", sel_caseInsensitiveCompare_);
  int v71 = channelCountOfName(a2, a3, 1);
  double v78 = (void *)[MEMORY[0x1E4F1CA48] array];
  float32x4_t v77 = (void *)[MEMORY[0x1E4F1CA48] array];
  float64x2_t v76 = (void *)[MEMORY[0x1E4F1CA48] array];
  int8x16_t v75 = (void *)[MEMORY[0x1E4F1CA48] array];
  float32x2_t v79 = (void *)[MEMORY[0x1E4F1CA48] array];
  long long v80 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  long long v83 = 0u;
  obuint64_t j = v9;
  uint64_t v10 = [v9 countByEnumeratingWithState:&v80 objects:v90 count:16];
  uint64_t v11 = (double *)MEMORY[0x1E4F1DB30];
  if (v10)
  {
    uint64_t v12 = v10;
    uint64_t v13 = *(void *)v81;
    uint64_t v73 = a6;
LABEL_3:
    uint64_t v14 = 0;
    while (1)
    {
      if (*(void *)v81 != v13) {
        objc_enumerationMutation(obj);
      }
      uint64_t v15 = *(void *)(*((void *)&v80 + 1) + 8 * v14);
      shapeForLayer(a2, v15, 0);
      double v18 = v17;
      double v19 = v16;
      if (v17 == *v11 && v16 == v11[1]) {
        return 0;
      }
      uint64_t v21 = channelCountOfName(a2, v15, 0);
      if (v21 > 4 || ((1 << v21) & 0x1A) == 0) {
        return 0;
      }
      uint64_t v23 = v21;
      uint64_t v24 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "inputDescriptionsByName"), "objectForKey:", v15), "type");
      if (v24 != 4)
      {
        if (v24 != 5) {
          return 0;
        }
        uint64_t v25 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "inputDescriptionsByName"), "objectForKey:", v15), "multiArrayConstraint"), "shapeConstraint");
        if ([v25 type] != 2
          || objc_msgSend((id)objc_msgSend((id)objc_msgSend(v25, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "count") == 4&& objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v25, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "objectAtIndexedSubscript:", 0), "integerValue") != 1)
        {
          return 0;
        }
      }
      int v26 = (CIImage *)[a1 objectForKeyedSubscript:v15];
      [(CIImage *)v26 extent];
      double v28 = v27;
      double v30 = v29;
      double v32 = v31;
      double v34 = v33;
      shapeForLayer(a2, v15, 0);
      double v37 = v35;
      double v38 = v36;
      if (v28 != 0.0 || (v30 == 0.0 ? (BOOL v39 = v32 == v35) : (BOOL v39 = 0), v39 ? (v40 = v34 == v36) : (v40 = 0), !v40))
      {
        memset(&v87, 0, sizeof(v87));
        [(CIImage *)v26 extent];
        CGFloat v42 = -v41;
        [(CIImage *)v26 extent];
        CGAffineTransformMakeTranslation(&v87, v42, -v43);
        memset(&v86, 0, sizeof(v86));
        [(CIImage *)v26 extent];
        CGFloat v45 = v37 / v44;
        [(CIImage *)v26 extent];
        CGAffineTransformMakeScale(&v86, v45, v38 / v46);
        double v47 = [(CIImage *)v26 imageByClampingToExtent];
        CGAffineTransform v85 = v87;
        int8x16_t v48 = [(CIImage *)v47 imageByApplyingTransform:&v85];
        CGAffineTransform v84 = v86;
        int v26 = -[CIImage imageByCroppingToRect:]([(CIImage *)v48 imageByApplyingTransform:&v84 highQualityDownsample:1], "imageByCroppingToRect:", 0.0, 0.0, v37, v38);
      }
      if (a6) {
        int v26 = [(CIImage *)v26 imageByColorMatchingWorkingSpaceToColorSpace:a6];
      }
      uint64_t v49 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "inputDescriptionsByName"), "objectForKey:", v15), "type");
      int8x16_t v50 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "inputDescriptionsByName"), "objectForKey:", v15);
      if (v50) {
        uint64_t v51 = objc_msgSend((id)objc_msgSend(v50, "imageConstraint"), "pixelFormatType");
      }
      else {
        uint64_t v51 = 0;
      }
      if (v49 == 5)
      {
        a6 = v73;
        if (v23 == 3)
        {
          float32x4_t v52 = @"CIInterleavedToPlanar3";
          goto LABEL_39;
        }
        if (v23 == 4)
        {
          float32x4_t v52 = @"CIInterleavedToPlanar4";
LABEL_39:
          int v26 = [(CIImage *)v26 imageByApplyingFilter:v52];
        }
      }
      else
      {
        a6 = v73;
      }
      objc_msgSend(v78, "addObject:", objc_msgSend(NSNumber, "numberWithDouble:", v18));
      objc_msgSend(v77, "addObject:", objc_msgSend(NSNumber, "numberWithDouble:", v19));
      objc_msgSend(v76, "addObject:", objc_msgSend(NSNumber, "numberWithInt:", v23));
      objc_msgSend(v75, "addObject:", objc_msgSend(NSNumber, "numberWithUnsignedInt:", v51));
      if (!v26) {
        int v26 = +[CIImage emptyImage];
      }
      [v79 addObject:v26];
      if (v12 == ++v14)
      {
        uint64_t v12 = [obj countByEnumeratingWithState:&v80 objects:v90 count:16];
        if (v12) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
  shapeForLayer(a2, a3, 1);
  double v55 = v54;
  double v56 = v53;
  if (v54 == *v11 && v53 == v11[1]) {
    return 0;
  }
  uint64_t v58 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "inputDescriptionsByName"), "objectForKey:", objc_msgSend(obj, "objectAtIndexedSubscript:", 0)), "type");
  uint64_t v59 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "outputDescriptionsByName"), "objectForKey:", a3), "type");
  uint64_t v60 = v59;
  if (v58 == 4) {
    uint64_t v61 = 266;
  }
  else {
    uint64_t v61 = 2053;
  }
  if (v59 == 4) {
    uint64_t v62 = 266;
  }
  else {
    uint64_t v62 = 2053;
  }
  double v63 = v56 * (double)v71;
  double v64 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "outputDescriptionsByName"), "objectForKey:", a3);
  if (v64) {
    uint64_t v65 = objc_msgSend((id)objc_msgSend(v64, "imageConstraint"), "pixelFormatType");
  }
  else {
    uint64_t v65 = 0;
  }
  v87.CGFloat a = 0.0;
  v88[0] = @"model";
  v88[1] = @"logName";
  int8x16_t v67 = &stru_1EE465CC0;
  if (a4) {
    int8x16_t v67 = a4;
  }
  v89[0] = a2;
  v89[1] = v67;
  v88[2] = @"headName";
  v88[3] = @"inputNames";
  v89[2] = a3;
  v89[3] = obj;
  v89[4] = v75;
  v88[4] = @"inputFormats";
  v88[5] = @"inputCIFormat";
  v89[5] = [NSNumber numberWithInt:v61];
  v89[6] = v78;
  v88[6] = @"inputWidths";
  v88[7] = @"inputHeights";
  v89[7] = v77;
  v89[8] = v76;
  v88[8] = @"inputChans";
  v88[9] = @"outputFormat";
  v89[9] = [NSNumber numberWithUnsignedInt:v65];
  v88[10] = @"outputCIFormat";
  v89[10] = [NSNumber numberWithInt:v62];
  v88[11] = @"softmax";
  v89[11] = [NSNumber numberWithBool:a5];
  uint64_t result = +[CIImageProcessorKernel applyWithExtent:inputs:arguments:error:](CICoreMLProcessor, "applyWithExtent:inputs:arguments:error:", v79, [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v89 forKeys:v88 count:12], &v87, 0.0, 0.0, v55, v63);
  if (v60 == 5)
  {
    if (v71 == 3)
    {
      float64x2_t v68 = @"CIPlanarToInterleaved3";
    }
    else
    {
      if (v71 != 4) {
        goto LABEL_67;
      }
      float64x2_t v68 = @"CIPlanarToInterleaved4";
    }
    uint64_t result = [(CIImage *)result imageByApplyingFilter:v68];
  }
LABEL_67:
  if (a6) {
    return [(CIImage *)result imageByColorMatchingColorSpaceToWorkingSpace:a6];
  }
  return result;
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

Class ___ZL20getMLMultiArrayClassv_block_invoke(uint64_t a1)
{
  CoreMLLibrary();
  Class result = objc_getClass("MLMultiArray");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL20getMLMultiArrayClassv_block_invoke_cold_1();
  }
  getMLMultiArrayClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

void CoreMLLibrary(void)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  v0[0] = 0;
  if (!CoreMLLibraryCore(char **)::frameworkLibrary)
  {
    v0[1] = (void *)MEMORY[0x1E4F143A8];
    v0[2] = (void *)3221225472;
    v0[3] = ___ZL17CoreMLLibraryCorePPc_block_invoke;
    v0[4] = &__block_descriptor_40_e5_v8__0l;
    v0[5] = v0;
    long long v1 = xmmword_1E5771518;
    uint64_t v2 = 0;
    CoreMLLibraryCore(char **)::frameworkLibrardouble y = _sl_dlopen();
  }
  if (!CoreMLLibraryCore(char **)::frameworkLibrary) {
    CoreMLLibrary(v0);
  }
  if (v0[0]) {
    free(v0[0]);
  }
}

uint64_t ___ZL17CoreMLLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreMLLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

Class ___ZL22getMLFeatureValueClassv_block_invoke(uint64_t a1)
{
  CoreMLLibrary();
  Class result = objc_getClass("MLFeatureValue");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL22getMLFeatureValueClassv_block_invoke_cold_1();
  }
  getMLFeatureValueClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class ___ZL27getMLPredictionOptionsClassv_block_invoke(uint64_t a1)
{
  CoreMLLibrary();
  Class result = objc_getClass("MLPredictionOptions");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    ___ZL27getMLPredictionOptionsClassv_block_invoke_cold_1();
  }
  getMLPredictionOptionsClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

double cikernel::_crystallize(uint64_t a1, uint64_t a2, double a3, float32x2_t a4)
{
  float32x2_t v7 = *(float32x2_t *)CI::getDC((CI *)a1);
  HIDWORD(v_Block_object_dispose(&STACK[0x3A0], 8) = HIDWORD(a3);
  float32x2_t v9 = vadd_f32(vmul_n_f32(vadd_f32(vrndm_f32(vadd_f32(vmul_lane_f32(v7, *(float32x2_t *)&a3, 1), (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000), *(float *)&a3), (float32x2_t)0x3F0000003F000000);
  float32x2_t v10 = vadd_f32(vadd_f32(a4, vmul_lane_f32(v9, *(float32x2_t *)&a3, 1)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&_Q1.f64[0] = vadd_f32(v10, (float32x2_t)1065353216);
  float64x2_t v88 = _Q1;
  *(float32x2_t *)&_Q1.f64[0] = vadd_f32(v10, (float32x2_t)0x3F80000000000000);
  float64x2_t v87 = _Q1;
  __asm { FMOV            V1.2S, #1.0 }
  *(float32x2_t *)&_Q1.f64[0] = vadd_f32(v10, *(float32x2_t *)&_Q1.f64[0]);
  float64x2_t v89 = _Q1;
  float32x2_t v16 = (float32x2_t)vdup_n_s32(0x3B800000u);
  *(float32x2_t *)&_Q1.f64[0] = vrndm_f32(vmul_f32(v10, v16));
  float32x2_t v17 = (float32x2_t)vdup_n_s32(0xC3800000);
  float32x2_t v18 = vmla_f32(v10, v17, *(float32x2_t *)&_Q1.f64[0]);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v18, 1), *(float *)(a2 + 16), v18.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a2 + 28);
  v20.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v18, 1), *(float *)&v19, v18.f32[0]);
  v18.f32[0] = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)_Q1.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  v18.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  double v91 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v18, _Q1, v8, v19, v21, v20, v22);
  v23.i64[1] = *(void *)&v88.f64[1];
  *(float32x2_t *)v23.i8 = vmla_f32(*(float32x2_t *)&v88.f64[0], v17, vrndm_f32(vmul_f32(*(float32x2_t *)&v88.f64[0], v16)));
  float v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v23.i8, 1), *(float *)(a2 + 16), *(float *)v23.i32);
  int8x16_t v25 = v23;
  v23.i32[0] = *(_DWORD *)(a2 + 28);
  v26.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v25.i8, 1), *(float *)v23.i32, *(float *)v25.i32);
  *(float *)&double v28 = *(float *)(a2 + 24) + v24;
  *(float *)v29.f64 = *(float *)v26.i32 + *(float *)&v27;
  *((float *)&v28 + 1) = *(float *)v26.i32 + *(float *)&v27;
  v88.f64[0] = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v28, v29, *(double *)v23.i64, v27, v26, v25, v30);
  v31.i64[1] = *(void *)&v87.f64[1];
  *(float32x2_t *)v31.i8 = vmla_f32(*(float32x2_t *)&v87.f64[0], v17, vrndm_f32(vmul_f32(*(float32x2_t *)&v87.f64[0], v16)));
  float v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v31.i8, 1), *(float *)(a2 + 16), *(float *)v31.i32);
  int8x16_t v33 = v31;
  v31.i32[0] = *(_DWORD *)(a2 + 28);
  v34.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v33.i8, 1), *(float *)v31.i32, *(float *)v33.i32);
  *(float *)&double v36 = *(float *)(a2 + 24) + v32;
  *(float *)v37.f64 = *(float *)v34.i32 + *(float *)&v35;
  *((float *)&v36 + 1) = *(float *)v34.i32 + *(float *)&v35;
  v87.f64[0] = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v36, v37, *(double *)v31.i64, v35, v34, v33, v38);
  v39.i64[1] = *(void *)&v89.f64[1];
  *(float32x2_t *)v39.i8 = vmla_f32(*(float32x2_t *)&v89.f64[0], v17, vrndm_f32(vmul_f32(*(float32x2_t *)&v89.f64[0], v16)));
  float v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v39.i8, 1), *(float *)(a2 + 16), *(float *)v39.i32);
  int8x16_t v41 = v39;
  v39.i32[0] = *(_DWORD *)(a2 + 28);
  v42.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&double v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v41.i8, 1), *(float *)v39.i32, *(float *)v41.i32);
  *(float *)&double v44 = *(float *)(a2 + 24) + v40;
  *(float *)v45.f64 = *(float *)v42.i32 + *(float *)&v43;
  *((float *)&v44 + 1) = *(float *)v42.i32 + *(float *)&v43;
  double v47 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v44, v45, *(double *)v39.i64, v43, v42, v41, v46);
  float v48 = *(float *)&a3 * 0.65;
  *(float32x2_t *)v49.i8 = vadd_f32(v9, vmul_n_f32(vadd_f32(*(float32x2_t *)&v91, (float32x2_t)0xBF000000BF000000), v48));
  *(float32x2_t *)v50.i8 = vadd_f32(vadd_f32((float32x2_t)LODWORD(a3), v9), vmul_n_f32(vadd_f32(*(float32x2_t *)&v88.f64[0], (float32x2_t)0xBF000000BF000000), v48));
  float32x2_t v51 = vsub_f32(v7, *(float32x2_t *)v49.i8);
  int32x2_t v52 = (int32x2_t)vmul_f32(v51, v51);
  float32x2_t v53 = vsub_f32(v7, *(float32x2_t *)v50.i8);
  int32x2_t v54 = (int32x2_t)vmul_f32(v53, v53);
  int32x2_t v55 = (int32x2_t)vadd_f32((float32x2_t)vzip1_s32(v52, v54), (float32x2_t)vzip2_s32(v52, v54));
  v49.i64[1] = v55.u32[0];
  v50.i64[1] = v55.u32[1];
  *(float32x2_t *)v56.i8 = vadd_f32(vadd_f32((float32x2_t)vzip1_s32(0, *(int32x2_t *)&a3), v9), vmul_n_f32(vadd_f32(*(float32x2_t *)&v87.f64[0], (float32x2_t)0xBF000000BF000000), v48));
  *(float32x2_t *)v57.i8 = vadd_f32(vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0), v9), vmul_n_f32(vadd_f32(*(float32x2_t *)&v47, (float32x2_t)0xBF000000BF000000), v48));
  float32x2_t v58 = vsub_f32(v7, *(float32x2_t *)v56.i8);
  int32x2_t v59 = (int32x2_t)vmul_f32(v58, v58);
  float32x2_t v60 = vsub_f32(v7, *(float32x2_t *)v57.i8);
  int32x2_t v61 = (int32x2_t)vmul_f32(v60, v60);
  int32x2_t v62 = (int32x2_t)vadd_f32((float32x2_t)vzip1_s32(v59, v61), (float32x2_t)vzip2_s32(v59, v61));
  v56.i64[1] = v62.u32[0];
  v57.i64[1] = v62.u32[1];
  int8x16_t v63 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(vsub_f32((float32x2_t)v55, (float32x2_t)vdup_lane_s32(v55, 1)).f32[0] < 0.0)), 0x1FuLL));
  float32x4_t v64 = (float32x4_t)vbslq_s8(v63, v49, v50);
  float32x4_t v65 = (float32x4_t)vbslq_s8(v63, v50, v49);
  int8x16_t v66 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(vsub_f32((float32x2_t)v62, (float32x2_t)vdup_lane_s32(v62, 1)).f32[0] < 0.0)), 0x1FuLL));
  float32x4_t v67 = (float32x4_t)vbslq_s8(v66, v56, v57);
  float32x4_t v68 = (float32x4_t)vbslq_s8(v66, v57, v56);
  int8x16_t v69 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(COERCE_FLOAT(vsubq_f32(v64, v67).i32[2]) < 0.0)), 0x1FuLL));
  int8x16_t v70 = vbslq_s8(v69, (int8x16_t)v64, (int8x16_t)v67);
  float32x4_t v71 = (float32x4_t)vbslq_s8(v69, (int8x16_t)v67, (int8x16_t)v64);
  int8x16_t v72 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(COERCE_FLOAT(vsubq_f32(v65, v68).i32[2]) < 0.0)), 0x1FuLL));
  float32x4_t v73 = (float32x4_t)vbslq_s8(v72, (int8x16_t)v65, (int8x16_t)v68);
  float64x2_t v74 = (float64x2_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(COERCE_FLOAT(vsubq_f32(v71, v73).i32[2]) < 0.0)), 0x1FuLL));
  int8x16_t v92 = vbslq_s8((int8x16_t)v74, (int8x16_t)v71, (int8x16_t)v73);
  v74.f64[0] = 0.5;
  float v75 = (float)(sqrtf(*(float *)&v92.i32[2]) - sqrtf(*(float *)&v70.i32[2])) * 0.5 + 0.5;
  if (v75 <= 1.0) {
    float v76 = v75;
  }
  else {
    float v76 = 1.0;
  }
  _NF = v75 < 0.0;
  float v77 = 0.0;
  if (!_NF) {
    float v77 = v76;
  }
  float v94 = v77;
  v71.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)&double v78 = *(float *)(a1 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v70.i8, 1), *(float *)(a1 + 16), *(float *)v70.i32);
  v72.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v74.f64 = *(float *)v72.i32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v70.i8, 1), v71.f32[0], *(float *)v70.i32);
  HIDWORD(v7_Block_object_dispose(&STACK[0x3A0], 8) = LODWORD(v74.f64[0]);
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v78, v74, *(double *)v71.i64, *(double *)v70.i64, v72, v63, (int8x16_t)v64);
  float32x4_t v90 = v79;
  HIDWORD(v8CI::NodeWithChildren::NodeWithChildren(this, 0) = v92.i32[1];
  LODWORD(v8CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v81.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&double v82 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v92.i8, 1), *(float *)&v80, *(float *)v92.i32);
  v79.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v92.i8, 1), *(float *)(a1 + 16), *(float *)v92.i32);
  *(float *)v83.f64 = *(float *)v81.i32 + *(float *)&v82;
  v79.f32[1] = *(float *)v81.i32 + *(float *)&v82;
  *(double *)v85.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v79.i64, v83, v80, v82, v81, v92, v84);
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v85, 1.0 - v94), v90, v94).u64[0];
  return result;
}

void CI::f4_sr_sr_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = *(double (**)(uint64_t, uint64_t, double, double))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  int v14 = *(_DWORD *)(v10 + 64);
  uint64_t v15 = *(void *)(v10 + 56);
  int v16 = *(_DWORD *)(v10 + 88);
  uint64_t v17 = *(void *)(v10 + 80);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  float32x2_t v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    float32x2_t v18 = (double *)((char *)a2 + 64 * v17);
  }
  double v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    double v19 = (double *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v20 = v11(a4 + 80 * v12, a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_tiltShift(uint64_t a1, uint64_t a2, uint64_t a3, double a4, float32x2_t a5, double a6)
{
  float v56 = *((float *)&a6 + 1);
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v11 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v12) = *(_DWORD *)(a1 + 28);
  v13.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v12, COERCE_FLOAT(*DC));
  *(float *)&double v15 = *(float *)(a1 + 24) + *(float *)&v11;
  *(float *)v16.f64 = *(float *)v13.i32 + *(float *)v14.i32;
  float v52 = *(float *)v13.i32 + *(float *)v14.i32;
  float v53 = *(float *)&v15;
  *((float *)&v15 + 1) = *(float *)v13.i32 + *(float *)v14.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v15, v16, v11, v12, v14, v13, v17);
  float32x4_t v55 = v18;
  long long v20 = (float32x2_t *)CI::getDC(v19);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *v20, 1), *(float *)(a2 + 16), COERCE_FLOAT(*v20));
  LODWORD(v22) = *(_DWORD *)(a2 + 28);
  v23.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *v20, 1), *(float *)&v22, COERCE_FLOAT(*v20));
  *(float *)&double v25 = *(float *)(a2 + 24) + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  *((float *)&v25 + 1) = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v25, v26, v21, v22, v24, v23, v27);
  float32x4_t v51 = v28;
  int8x16_t v30 = (float32x2_t *)CI::getDC(v29);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *v30, 1), *(float *)(a3 + 16), COERCE_FLOAT(*v30));
  LODWORD(v32) = *(_DWORD *)(a3 + 28);
  v33.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *v30, 1), *(float *)&v32, COERCE_FLOAT(*v30));
  *(float *)&double v35 = *(float *)(a3 + 24) + *(float *)&v31;
  *(float *)v36.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  *((float *)&v35 + 1) = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), v35, v36, v31, v32, v34, v33, v37);
  float32x2_t v39 = vsub_f32(a5, *(float32x2_t *)&a4);
  float v40 = vmlas_n_f32(vmuls_lane_f32(v39.f32[1], v39, 1), v39.f32[0], v39.f32[0]);
  v39.f32[0] = (float)(sqrtf(v40)
                     * fabsf(vmlas_n_f32(vmuls_lane_f32(-(float)(*(float *)&a4 - v53), v39, 1), *((float *)&a4 + 1) - v52, v39.f32[0])/ v40))/ v56;
  float32x2_t v41 = vcvt_f32_f64(vmlaq_n_f64((float64x2_t)xmmword_193952450, (float64x2_t)xmmword_193952440, (float)(v39.f32[0] + v39.f32[0])));
  __asm { FMOV            V3.2S, #1.0 }
  float32x2_t v47 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v41, _D3), (int8x8_t)_D3, (int8x8_t)v41), (int8x8_t)vcltz_f32(v41));
  __asm { FMOV            V4.2S, #3.0 }
  float32x2_t v49 = vmul_f32(vmul_f32(v47, v47), vmla_f32(_D4, (float32x2_t)0xC0000000C0000000, v47));
  *(void *)&double result = vaddq_f32(vaddq_f32(vmulq_n_f32(v55, v49.f32[0]), vmulq_n_f32(v51, 1.0 - vaddv_f32(v49))), vmulq_lane_f32(v38, v49, 1)).u64[0];
  return result;
}

void CI::f4_sr_sr_sr_f2_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  double v11 = *(double (**)(uint64_t, uint64_t, uint64_t, double, double, double))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  uint64_t v14 = *(void *)(v10 + 56);
  int v15 = *(_DWORD *)(v10 + 88);
  uint64_t v16 = *(void *)(v10 + 80);
  int v17 = *(_DWORD *)(v10 + 112);
  uint64_t v18 = *(void *)(v10 + 104);
  int v19 = *(_DWORD *)(v10 + 136);
  uint64_t v20 = *(void *)(v10 + 128);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v26 = *(void *)(v10 + 32);
    int v27 = *(_DWORD *)(v10 + 88);
    int v25 = *(_DWORD *)(v10 + 136);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 152)), a2);
    int v19 = v25;
    int v15 = v27;
    uint64_t v13 = v26;
  }
  double v21 = (double *)(a3 + 16 * v20);
  if (v19 != 5) {
    double v21 = (double *)((char *)a2 + 64 * v20);
  }
  double v22 = (double *)(a3 + 16 * v18);
  if (v17 != 5) {
    double v22 = (double *)((char *)a2 + 64 * v18);
  }
  int8x16_t v23 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    int8x16_t v23 = (double *)((char *)a2 + 64 * v16);
  }
  *(double *)&long long v24 = v11(a4 + 80 * v12, a4 + 80 * v13, a4 + 80 * v14, *v23, *v22, *v21);
  *(_OWORD *)(a3 + 16 * a7) = v24;
}

double cikernel::_distanceColored(float *a1, double a2, float32x2_t a3)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  int32x2_t v6 = (int32x2_t)*DC;
  float32x2_t v7 = vsub_f32(a3, *(float32x2_t *)&a2);
  float v8 = vmlas_n_f32(vmuls_lane_f32(v7.f32[1], v7, 1), v7.f32[0], v7.f32[0]);
  *(float *)v6.i32 = fabsf(vmlas_n_f32(vmuls_lane_f32(-(float)(*(float *)&a2- (float)(a1[6] + vmlas_n_f32(vmuls_lane_f32(a1[5], *DC, 1), a1[4], COERCE_FLOAT(*DC)))), v7, 1), *((float *)&a2 + 1)- (float)(a1[9] + vmlas_n_f32(vmuls_lane_f32(a1[8], *DC, 1), a1[7], COERCE_FLOAT(*DC))), v7.f32[0])/ v8);
  float v9 = sqrtf(v8);
  *(float *)v6.i32 = (float)((float)(v9 * *(float *)v6.i32) / a1[19]) + (float)((float)(v9 * *(float *)v6.i32) / a1[19]);
  *(void *)&double result = vdupq_lane_s32(v6, 0).u64[0];
  return result;
}

void CI::f4_sr_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = *(double (**)(uint64_t, double, double))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  int v14 = *(_DWORD *)(v11 + 40);
  uint64_t v15 = *(void *)(v11 + 32);
  int v16 = *(_DWORD *)(v11 + 64);
  uint64_t v17 = *(void *)(v11 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 80)), a2);
  }
  uint64_t v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    uint64_t v18 = (double *)((char *)a2 + 64 * v17);
  }
  int v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5) {
    int v19 = (double *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v20 = v12(a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_alphaNormalize(float32x4_t a1)
{
  *(void *)&double result = vdivq_f32(a1, (float32x4_t)vdupq_laneq_s32((int32x4_t)a1, 3)).u64[0];
  return result;
}

uint64_t getAVDepthDataClass()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x3052000000;
  int32x2_t v6 = __Block_byref_object_copy__3;
  float32x2_t v7 = __Block_byref_object_dispose__3;
  uint64_t v0 = getAVDepthDataClass_softClass;
  uint64_t v8 = getAVDepthDataClass_softClass;
  if (!getAVDepthDataClass_softClass)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = __getAVDepthDataClass_block_invoke;
    v2[3] = &unk_1E57710B8;
    void v2[4] = &v3;
    __getAVDepthDataClass_block_invoke((uint64_t)v2);
    uint64_t v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_193738558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getAVCameraCalibrationDataClass()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x3052000000;
  int32x2_t v6 = __Block_byref_object_copy__3;
  float32x2_t v7 = __Block_byref_object_dispose__3;
  uint64_t v0 = getAVCameraCalibrationDataClass_softClass;
  uint64_t v8 = getAVCameraCalibrationDataClass_softClass;
  if (!getAVCameraCalibrationDataClass_softClass)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = __getAVCameraCalibrationDataClass_block_invoke;
    v2[3] = &unk_1E57710B8;
    void v2[4] = &v3;
    __getAVCameraCalibrationDataClass_block_invoke((uint64_t)v2);
    uint64_t v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_19373864C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t AVFDepthDataFromDictionary(const __CFDictionary *a1)
{
  if (!a1 || !CFDictionaryGetCount(a1)) {
    return 0;
  }
  AVDepthDataClass = (void *)getAVDepthDataClass();

  return [AVDepthDataClass depthDataFromDictionaryRepresentation:a1 error:0];
}

void *AVFDepthDataType(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 depthDataType];
  }
  return a1;
}

void *AVFDepthDataByConvertingToDepthDataType(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 depthDataByConvertingToDepthDataType:a2];
  }
  return a1;
}

void *AVFDepthDataByReplacingDepthDataMapWithPixelBuffer(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 depthDataByReplacingDepthDataMapWithPixelBuffer:a2 error:0];
  }
  return a1;
}

void *AVFDepthDataMap(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 depthDataMap];
  }
  return a1;
}

void *AVFDepthDataDictionaryRepresentation(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 dictionaryRepresentationForAuxiliaryDataType:a2];
  }
  return a1;
}

void *AVFDepthCameraCalibrationData(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 cameraCalibrationData];
  }
  return a1;
}

uint64_t AVFDepthCameraCalibrationDataInitWithDictionary(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  SEL v2 = NSSelectorFromString(&cfstr_Initwithcamera.isa);
  id v3 = objc_alloc((Class)getAVCameraCalibrationDataClass());
  if (!v3) {
    return 0;
  }

  return [v3 performSelector:v2 withObject:a1 withObject:0];
}

double AVCameraCalibrationDataIntrinsicMatrix(void *a1)
{
  if (!a1) {
    return 0.0;
  }
  [a1 intrinsicMatrix];
  return result;
}

double AVCameraCalibrationDataExtrinsicMatrix(void *a1)
{
  if (!a1) {
    return 0.0;
  }
  [a1 extrinsicMatrix];
  return result;
}

double AVCameraCalibrationDataPixelSize(void *a1, const char *a2)
{
  if (!a1) {
    return 0.0;
  }
  [a1 pixelSize];
  return result;
}

double AVCameraCalibrationDataIntrinsicMatrixReferenceDimensions(void *a1)
{
  if (!a1) {
    return 0.0;
  }
  [a1 intrinsicMatrixReferenceDimensions];
  return result;
}

void *AVCameraCalibrationDataLensDistortionLookupTable(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 lensDistortionLookupTable];
  }
  return a1;
}

void *AVCameraCalibrationDataInverseLensDistortionLookupTable(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 inverseLensDistortionLookupTable];
  }
  return a1;
}

double AVCameraCalibrationDataIntrinsicLensDistortionCenter(void *a1)
{
  if (!a1) {
    return *MEMORY[0x1E4F1DAD8];
  }
  [a1 lensDistortionCenter];
  return result;
}

uint64_t AVCameraCalibrationDataDictionary(void *a1)
{
  if (a1) {
    return [a1 cameraCalibrationDataDictionary];
  }
  else {
    return MEMORY[0x1E4F1CC08];
  }
}

uint64_t getAVPortraitEffectsMatteClass()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x3052000000;
  int32x2_t v6 = __Block_byref_object_copy__3;
  float32x2_t v7 = __Block_byref_object_dispose__3;
  uint64_t v0 = getAVPortraitEffectsMatteClass_softClass;
  uint64_t v8 = getAVPortraitEffectsMatteClass_softClass;
  if (!getAVPortraitEffectsMatteClass_softClass)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = __getAVPortraitEffectsMatteClass_block_invoke;
    v2[3] = &unk_1E57710B8;
    void v2[4] = &v3;
    __getAVPortraitEffectsMatteClass_block_invoke((uint64_t)v2);
    uint64_t v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_193738954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *AVFPortraitEffectsMatteImage(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 mattingImage];
  }
  return a1;
}

uint64_t AVPortraitEffectsMatteFromDictionary(const __CFDictionary *a1)
{
  if (!a1 || !CFDictionaryGetCount(a1)) {
    return 0;
  }
  AVPortraitEffectsMatteClass = (void *)getAVPortraitEffectsMatteClass();

  return [AVPortraitEffectsMatteClass portraitEffectsMatteFromDictionaryRepresentation:a1 error:0];
}

void *AVPortraitEffectsMatteDictionaryRepresentation(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 dictionaryRepresentationForAuxiliaryDataType:a2];
  }
  return a1;
}

uint64_t getAVSemanticSegmentationMatteClass()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x3052000000;
  int32x2_t v6 = __Block_byref_object_copy__3;
  float32x2_t v7 = __Block_byref_object_dispose__3;
  uint64_t v0 = getAVSemanticSegmentationMatteClass_softClass;
  uint64_t v8 = getAVSemanticSegmentationMatteClass_softClass;
  if (!getAVSemanticSegmentationMatteClass_softClass)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = __getAVSemanticSegmentationMatteClass_block_invoke;
    v2[3] = &unk_1E57710B8;
    void v2[4] = &v3;
    __getAVSemanticSegmentationMatteClass_block_invoke((uint64_t)v2);
    uint64_t v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_193738ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *AVSemanticSegmentationMatteImage(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 mattingImage];
  }
  return a1;
}

uint64_t AVSemanticSegmentationMatteFromDictionary(const __CFDictionary *a1, uint64_t a2)
{
  if (!a1 || !CFDictionaryGetCount(a1)) {
    return 0;
  }
  AVSemanticSegmentationMatteClass = (void *)getAVSemanticSegmentationMatteClass();

  return [AVSemanticSegmentationMatteClass semanticSegmentationMatteFromImageSourceAuxiliaryDataType:a2 dictionaryRepresentation:a1 error:0];
}

void *AVSemanticSegmentationMatteDictionaryRepresentationForAuxiliaryType(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 dictionaryRepresentationForAuxiliaryDataType:a2];
  }
  return a1;
}

void *AVSemanticSegmentationMatteType(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 matteType];
  }
  return a1;
}

void *AVSemanticSegmentationMatteDataType(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 pixelFormatType];
  }
  return a1;
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

Class __getAVDepthDataClass_block_invoke(uint64_t a1)
{
  AVFoundationLibrary();
  Class result = objc_getClass("AVDepthData");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getAVDepthDataClass_block_invoke_cold_1();
  }
  getAVDepthDataClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

void AVFoundationLibrary()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  v0[0] = 0;
  if (!AVFoundationLibraryCore_frameworkLibrary)
  {
    v0[1] = (void *)MEMORY[0x1E4F143A8];
    v0[2] = (void *)3221225472;
    v0[3] = __AVFoundationLibraryCore_block_invoke;
    v0[4] = &__block_descriptor_40_e5_v8__0l;
    v0[5] = v0;
    long long v1 = xmmword_1E5771530;
    uint64_t v2 = 0;
    AVFoundationLibraryCore_frameworkLibrardouble y = _sl_dlopen();
  }
  if (!AVFoundationLibraryCore_frameworkLibrary) {
    AVFoundationLibrary_cold_1(v0);
  }
  if (v0[0]) {
    free(v0[0]);
  }
}

uint64_t __AVFoundationLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  AVFoundationLibraryCore_frameworkLibrardouble y = result;
  return result;
}

Class __getAVCameraCalibrationDataClass_block_invoke(uint64_t a1)
{
  AVFoundationLibrary();
  Class result = objc_getClass("AVCameraCalibrationData");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getAVCameraCalibrationDataClass_block_invoke_cold_1();
  }
  getAVCameraCalibrationDataClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getAVPortraitEffectsMatteClass_block_invoke(uint64_t a1)
{
  AVFoundationLibrary();
  Class result = objc_getClass("AVPortraitEffectsMatte");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getAVPortraitEffectsMatteClass_block_invoke_cold_1();
  }
  getAVPortraitEffectsMatteClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getAVSemanticSegmentationMatteClass_block_invoke(uint64_t a1)
{
  AVFoundationLibrary();
  Class result = objc_getClass("AVSemanticSegmentationMatte");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 4CI::NodeWithChildren::NodeWithChildren(this, 0) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    __getAVSemanticSegmentationMatteClass_block_invoke_cold_1();
  }
  getAVSemanticSegmentationMatteClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t *loadACBS()
{
  if (loadACBS::onceToken != -1) {
    dispatch_once(&loadACBS::onceToken, &__block_literal_global_15);
  }
  if (loadACBS::ACBSLoaded) {
    return &loadACBS::ACBSFuncs;
  }
  else {
    return 0;
  }
}

size_t __loadACBS_block_invoke()
{
  size_t result = QuaggaLibraryCore(0);
  if (result)
  {
    loadACBS::ACBSFuncs = (uint64_t)soft_ACBSConfigCreate;
    qword_1E93310C0 = (uint64_t)soft_ACBSConfigFree;
    qword_1E93310C8 = (uint64_t)soft_ACBSConfigSetMaxQRModuleSamples;
    qword_1E93310D0 = (uint64_t)soft_ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer;
    qword_1E93310D8 = (uint64_t)soft_ACBSConfigSetSymbologiesEnabled;
    qword_1E93310E0 = (uint64_t)soft_ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding;
    loadACBS::ACBSLoaded = 1;
  }
  else
  {
    long long v1 = (FILE *)*MEMORY[0x1E4F143C8];
    return fwrite("Unable to load Quagga.framework\n", 0x20uLL, 1uLL, v1);
  }
  return result;
}

uint64_t soft_ACBSConfigCreate(void)
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000;
  uint64_t v0 = (uint64_t (*)(void))getACBSConfigCreateSymbolLoc(void)::ptr;
  int32x2_t v6 = getACBSConfigCreateSymbolLoc(void)::ptr;
  if (!getACBSConfigCreateSymbolLoc(void)::ptr)
  {
    long long v1 = (void *)QuaggaLibrary();
    v4[3] = (uint64_t)dlsym(v1, "ACBSConfigCreate");
    getACBSConfigCreateSymbolLoc(void)::ptr = (_UNKNOWN *)v4[3];
    uint64_t v0 = (uint64_t (*)(void))v4[3];
  }
  _Block_object_dispose(&v3, 8);
  if (!v0) {
    soft_ACBSConfigCreate();
  }
  return v0();
}

void sub_19373929C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_ACBSConfigFree(uint64_t a1)
{
  uint64_t v5 = 0;
  int32x2_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v2 = (uint64_t (*)(uint64_t))getACBSConfigFreeSymbolLoc(void)::ptr;
  uint64_t v8 = getACBSConfigFreeSymbolLoc(void)::ptr;
  if (!getACBSConfigFreeSymbolLoc(void)::ptr)
  {
    uint64_t v3 = (void *)QuaggaLibrary();
    v6[3] = (uint64_t)dlsym(v3, "ACBSConfigFree");
    getACBSConfigFreeSymbolLoc(void)::ptr = (_UNKNOWN *)v6[3];
    uint64_t v2 = (uint64_t (*)(uint64_t))v6[3];
  }
  _Block_object_dispose(&v5, 8);
  if (!v2) {
    soft_ACBSConfigFree();
  }
  return v2(a1);
}

void sub_1937393A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_ACBSConfigSetMaxQRModuleSamples(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))getACBSConfigSetMaxQRModuleSamplesSymbolLoc(void)::ptr;
  uint64_t v10 = getACBSConfigSetMaxQRModuleSamplesSymbolLoc(void)::ptr;
  if (!getACBSConfigSetMaxQRModuleSamplesSymbolLoc(void)::ptr)
  {
    uint64_t v5 = (void *)QuaggaLibrary();
    v8[3] = (uint64_t)dlsym(v5, "ACBSConfigSetMaxQRModuleSamples");
    getACBSConfigSetMaxQRModuleSamplesSymbolLoc(void)::ptr = (_UNKNOWN *)v8[3];
    uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))v8[3];
  }
  _Block_object_dispose(&v7, 8);
  if (!v4) {
    soft_ACBSConfigSetMaxQRModuleSamples();
  }
  return v4(a1, a2);
}

void sub_1937394B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2020000000;
  int v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, double, double, double, double))getACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBufferSymbolLoc(void)::ptr;
  long long v20 = getACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBufferSymbolLoc(void)::ptr;
  if (!getACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBufferSymbolLoc(void)::ptr)
  {
    uint64_t v15 = (void *)QuaggaLibrary();
    void v18[3] = (uint64_t)dlsym(v15, "ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer");
    getACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBufferSymbolLoc(void)::ptr = (_UNKNOWN *)v18[3];
    int v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, double, double, double, double))v18[3];
  }
  _Block_object_dispose(&v17, 8);
  if (!v14) {
    soft_ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer();
  }
  return v14(a1, a2, a3, a4, a5, a6, a7);
}

void sub_193739604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_ACBSConfigSetSymbologiesEnabled(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))getACBSConfigSetSymbologiesEnabledSymbolLoc(void)::ptr;
  uint64_t v10 = getACBSConfigSetSymbologiesEnabledSymbolLoc(void)::ptr;
  if (!getACBSConfigSetSymbologiesEnabledSymbolLoc(void)::ptr)
  {
    uint64_t v5 = (void *)QuaggaLibrary();
    v8[3] = (uint64_t)dlsym(v5, "ACBSConfigSetSymbologiesEnabled");
    getACBSConfigSetSymbologiesEnabledSymbolLoc(void)::ptr = (_UNKNOWN *)v8[3];
    uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))v8[3];
  }
  _Block_object_dispose(&v7, 8);
  if (!v4) {
    soft_ACBSConfigSetSymbologiesEnabled();
  }
  return v4(a1, a2);
}

void sub_193739714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding(const __CFDictionary *a1, const __CFString *a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v4 = (uint64_t (*)(const __CFDictionary *, const __CFString *))getACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncodingSymbolLoc(void)::ptr;
  uint64_t v10 = getACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncodingSymbolLoc(void)::ptr;
  if (!getACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncodingSymbolLoc(void)::ptr)
  {
    uint64_t v5 = (void *)QuaggaLibrary();
    v8[3] = (uint64_t)dlsym(v5, "ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding");
    getACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncodingSymbolLoc(void)::ptr = (_UNKNOWN *)v8[3];
    uint64_t v4 = (uint64_t (*)(const __CFDictionary *, const __CFString *))v8[3];
  }
  _Block_object_dispose(&v7, 8);
  if (!v4) {
    soft_ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding();
  }
  return v4(a1, a2);
}

void sub_193739824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t QuaggaLibraryCore(char **a1)
{
  if (!QuaggaLibraryCore(char **)::frameworkLibrary) {
    QuaggaLibraryCore(char **)::frameworkLibrardouble y = _sl_dlopen();
  }
  return QuaggaLibraryCore(char **)::frameworkLibrary;
}

uint64_t ___ZL17QuaggaLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  QuaggaLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

void *___ZL28getACBSConfigCreateSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)QuaggaLibrary();
  uint64_t result = dlsym(v2, "ACBSConfigCreate");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getACBSConfigCreateSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t QuaggaLibrary(void)
{
  uint64_t v3 = 0;
  uint64_t v0 = QuaggaLibraryCore(&v3);
  if (!v0) {
    QuaggaLibrary(&v3);
  }
  uint64_t v1 = v0;
  if (v3) {
    free(v3);
  }
  return v1;
}

void *___ZL26getACBSConfigFreeSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)QuaggaLibrary();
  uint64_t result = dlsym(v2, "ACBSConfigFree");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getACBSConfigFreeSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL43getACBSConfigSetMaxQRModuleSamplesSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)QuaggaLibrary();
  uint64_t result = dlsym(v2, "ACBSConfigSetMaxQRModuleSamples");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getACBSConfigSetMaxQRModuleSamplesSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL68getACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBufferSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)QuaggaLibrary();
  uint64_t result = dlsym(v2, "ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBufferSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                                 + 24);
  return result;
}

void *___ZL43getACBSConfigSetSymbologiesEnabledSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)QuaggaLibrary();
  uint64_t result = dlsym(v2, "ACBSConfigSetSymbologiesEnabled");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getACBSConfigSetSymbologiesEnabledSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *___ZL83getACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncodingSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)QuaggaLibrary();
  uint64_t result = dlsym(v2, "ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncodingSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

double convolutionAddROI(int a1, CGRect a2, NSArray *a3)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double y = a2.origin.y;
  double x = a2.origin.x;
  if (!a1)
  {
    v11.origin.double x = a2.origin.x + boundsForPointArray(a3);
    v11.origin.double y = y + v7;
    v11.size.double width = width + v8;
    v11.size.double height = height + v9;
    *(void *)&double x = (unint64_t)CGRectIntegral(v11);
  }
  return x;
}

id makeRecipe(float a1, float a2, float a3, float a4, float a5)
{
  v101[2] = *MEMORY[0x1E4F143B8];
  id v9 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  if (a1 <= 20.0)
  {
    double v12 = a4;
  }
  else
  {
    LODWORD(v1CI::NodeWithChildren::NodeWithChildren(this, 0) = 0;
    double v11 = 1.0;
    do
    {
      double v11 = v11 + v11;
      a1 = a1 * 0.5;
      uint64_t v10 = (v10 + 1);
    }
    while (a1 > 20.0);
    v101[0] = @"down";
    v101[1] = [NSNumber numberWithInt:v10];
    objc_msgSend(v9, "addObject:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v101, 2));
    double v12 = 0.0;
  }
  unsigned int v13 = vcvtps_s32_f32(fabsf(a1));
  switch(v13)
  {
    case 3u:
      double v22 = a1;
      double v23 = a2;
      double v24 = a3;
      double v49 = disc_multi(0.0, 0.0, v22, a2, a3, v12);
      double v48 = disc_multi(1.0, 0.0, v22, a2, a3, v12);
      double v47 = disc_multi(1.0, 1.0, v22, a2, a3, v12);
      double v46 = disc_multi(2.0, 0.0, v22, a2, a3, v12);
      double v25 = disc_multi(2.0, 1.0, v22, a2, a3, v12);
      double v45 = disc_multi(2.0, 2.0, v22, a2, a3, v12);
      double v26 = disc_multi(3.0, 0.0, v22, a2, a3, v12);
      double v27 = disc_multi(3.0, 1.0, v22, v23, a3, v12);
      double v28 = disc_multi(3.0, 2.0, v22, v23, a3, v12);
      double v29 = disc_multi(3.0, 3.0, v22, v23, v24, v12);
      double v30 = v49 + (v29 + v28 + v27 + v26 + v28 + v45 + v25 + v46 + v48 + v47 + v25 + v27) * 4.0;
      *(double *)float v53 = v29;
      *(double *)&v53[8] = v28 / v30;
      *(double *)&v53[16] = v27 / v30;
      *(double *)&v53[24] = v26 / v30;
      double v54 = v27 / v30;
      double v55 = v28 / v30;
      double v56 = v29;
      double v57 = v28 / v30;
      double v58 = v45 / v30;
      double v59 = v25 / v30;
      double v60 = v46 / v30;
      double v61 = v25 / v30;
      double v62 = v45 / v30;
      double v63 = v28 / v30;
      double v64 = v27 / v30;
      double v65 = v25 / v30;
      double v66 = v47 / v30;
      double v67 = v48 / v30;
      double v68 = v47 / v30;
      double v69 = v25 / v30;
      double v70 = v27 / v30;
      double v71 = v26 / v30;
      double v72 = v46 / v30;
      double v73 = v48 / v30;
      double v74 = v49 / v30;
      double v75 = v48 / v30;
      double v76 = v46 / v30;
      double v77 = v26 / v30;
      double v78 = v27 / v30;
      double v79 = v25 / v30;
      double v80 = v47 / v30;
      double v81 = v48 / v30;
      double v82 = v47 / v30;
      double v83 = v25 / v30;
      double v84 = v27 / v30;
      double v85 = v28 / v30;
      double v86 = v45 / v30;
      double v87 = v25 / v30;
      double v88 = v46 / v30;
      double v89 = v25 / v30;
      double v90 = v45 / v30;
      double v91 = v28 / v30;
      double v92 = v29;
      double v93 = v28 / v30;
      double v94 = v27 / v30;
      double v95 = v26 / v30;
      double v96 = v27 / v30;
      double v97 = v28 / v30;
      double v98 = v29;
      v52[0] = @"conv7";
      v52[1] = +[CIVector vectorWithValues:v53 count:49];
      objc_msgSend(v9, "addObject:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v52, 2));
      break;
    case 2u:
      double v31 = a1;
      double v32 = a2;
      double v33 = a3;
      double v50 = disc_multi(0.0, 0.0, v31, v32, v33, v12);
      double v34 = disc_multi(1.0, 0.0, v31, v32, v33, v12);
      double v35 = disc_multi(1.0, 1.0, v31, v32, v33, v12);
      double v36 = disc_multi(2.0, 0.0, v31, v32, v33, v12);
      double v37 = disc_multi(2.0, 1.0, v31, v32, v33, v12);
      double v38 = disc_multi(2.0, 2.0, v31, v32, v33, v12);
      double v39 = v50 + (v38 + v37 + v36 + v34 + v35 + v37) * 4.0;
      *(double *)float v53 = v38 / v39;
      *(double *)&v53[8] = v37 / v39;
      *(double *)&v53[16] = v36 / v39;
      *(double *)&v53[24] = v37 / v39;
      double v54 = v38 / v39;
      double v55 = v37 / v39;
      double v56 = v35 / v39;
      double v57 = v34 / v39;
      double v58 = v35 / v39;
      double v59 = v37 / v39;
      double v60 = v36 / v39;
      double v61 = v34 / v39;
      double v62 = v50 / v39;
      double v63 = v34 / v39;
      double v64 = v36 / v39;
      double v65 = v37 / v39;
      double v66 = v35 / v39;
      double v67 = v34 / v39;
      double v68 = v35 / v39;
      double v69 = v37 / v39;
      double v70 = v38 / v39;
      double v71 = v37 / v39;
      double v72 = v36 / v39;
      double v73 = v37 / v39;
      double v74 = v38 / v39;
      float v40 = +[CIVector vectorWithValues:v53 count:25];
      v99[0] = @"conv5";
      v99[1] = v40;
      objc_msgSend(v9, "addObject:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v99, 2));
      break;
    case 1u:
      double v14 = a1;
      double v15 = a2;
      double v16 = a3;
      double v17 = disc_multi(0.0, 0.0, a1, v15, v16, v12);
      double v18 = disc_multi(1.0, 0.0, v14, v15, v16, v12);
      double v19 = disc_multi(1.0, 1.0, v14, v15, v16, v12);
      double v20 = v17 + (v18 + v19) * 4.0;
      *(double *)float v53 = v19 / v20;
      *(double *)&v53[8] = v18 / v20;
      *(double *)&v53[16] = v19 / v20;
      *(double *)&v53[24] = v18 / v20;
      double v54 = v17 / v20;
      double v55 = v18 / v20;
      double v56 = v19 / v20;
      double v57 = v18 / v20;
      double v58 = v19 / v20;
      double v21 = +[CIVector vectorWithValues:v53 count:9];
      v100[0] = @"conv3";
      v100[1] = v21;
      objc_msgSend(v9, "addObject:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v100, 2));
      break;
    default:
      *(_OWORD *)float v53 = xmmword_193952708;
      *(_OWORD *)&v53[12] = *(long long *)((char *)&xmmword_193952708 + 12);
      int v41 = 1;
      *(_OWORD *)float32x4_t v51 = xmmword_193952708;
      *(_OWORD *)&v51[12] = *(long long *)((char *)&xmmword_193952708 + 12);
      uint64_t v42 = 4;
      int v43 = 1;
      do
      {
        v43 *= 9;
        *(_DWORD *)&v53[v42] = v43;
        v41 *= 3;
        *(_DWORD *)&v51[v42] = v41;
        v42 += 4;
      }
      while (v42 != 28);
      operator new();
  }
  return v9;
}

void sub_19373CBFC(_Unwind_Exception *a1)
{
  MEMORY[0x1997023B0](v1, 0x1010C400FFEF802);
  _Unwind_Resume(a1);
}

CIImage *applyRecipe(NSArray *a1, CIImage *a2)
{
  uint64_t v209 = *MEMORY[0x1E4F143B8];
  uint64_t v208 = 0;
  memset(v207, 0, sizeof(v207));
  long long v187 = 0u;
  long long v188 = 0u;
  long long v189 = 0u;
  long long v190 = 0u;
  uint64_t v168 = [(NSArray *)a1 countByEnumeratingWithState:&v187 objects:v206 count:16];
  if (v168)
  {
    uint64_t v167 = *(void *)v188;
    uint64_t v3 = &CI::_downhalf;
    do
    {
      uint64_t v4 = 0;
      do
      {
        uint64_t v5 = v3;
        if (*(void *)v188 != v167) {
          objc_enumerationMutation(a1);
        }
        uint64_t v169 = v4;
        int32x2_t v6 = *(void **)(*((void *)&v187 + 1) + 8 * v4);
        double v7 = (void *)[v6 objectAtIndex:0];
        if ([v7 isEqualToString:@"down"])
        {
          int v8 = objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 1), "intValue");
          a2 = [(CIImage *)a2 imageBySamplingLinear];
          if (v8 < 1) {
            goto LABEL_21;
          }
          uint64_t v3 = v5;
          do
          {
            memset(&v186, 0, sizeof(v186));
            CGAffineTransformMakeScale(&v186, 0.5, 0.5);
            memset(&v185, 0, sizeof(v185));
            CGAffineTransformMakeScale(&v185, 2.0, 2.0);
            id v9 = +[CIKernel kernelWithInternalRepresentation:v3];
            [(CIImage *)a2 extent];
            CGAffineTransform v184 = v186;
            CGRect v211 = CGRectApplyAffineTransform(v210, &v184);
            CGRect v212 = CGRectInset(v211, -1.0, -1.0);
            double x = v212.origin.x;
            double y = v212.origin.y;
            double width = v212.size.width;
            double height = v212.size.height;
            v182[0] = MEMORY[0x1E4F143A8];
            v182[1] = 3221225472;
            v182[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke;
            v182[3] = &__block_descriptor_80_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
            CGAffineTransform v183 = v185;
            int8x16_t v205 = a2;
            uint64_t v14 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v205 count:1];
            double v15 = v9;
            uint64_t v3 = v5;
            a2 = -[CIKernel applyWithExtent:roiCallback:arguments:](v15, "applyWithExtent:roiCallback:arguments:", v182, v14, x, y, width, height);
            --v8;
          }
          while (v8);
        }
        else
        {
          if ([v7 isEqualToString:@"up"])
          {
            objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 1), "floatValue");
            double v203 = @"inputScale";
            uint64_t v204 = objc_msgSend(NSNumber, "numberWithFloat:");
            uint64_t v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v204 forKeys:&v203 count:1];
            double v17 = a2;
            double v18 = @"CISoftCubicUpsample";
LABEL_19:
            double v22 = [(CIImage *)v17 imageByApplyingFilter:v18 withInputParameters:v16];
            goto LABEL_20;
          }
          if ([v7 isEqualToString:@"conv3"])
          {
            uint64_t v19 = [v6 objectAtIndex:1];
            double v201 = @"inputWeights";
            uint64_t v202 = v19;
            uint64_t v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v202 forKeys:&v201 count:1];
            double v17 = a2;
            double v18 = @"CIConvolution3X3";
            goto LABEL_19;
          }
          if ([v7 isEqualToString:@"conv5"])
          {
            uint64_t v20 = [v6 objectAtIndex:1];
            float64x2_t v199 = @"inputWeights";
            uint64_t v200 = v20;
            uint64_t v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v200 forKeys:&v199 count:1];
            double v17 = a2;
            double v18 = @"CIConvolution5X5";
            goto LABEL_19;
          }
          if ([v7 isEqualToString:@"conv7"])
          {
            uint64_t v21 = [v6 objectAtIndex:1];
            int8x16_t v197 = @"inputWeights";
            uint64_t v198 = v21;
            uint64_t v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v198 forKeys:&v197 count:1];
            double v17 = a2;
            double v18 = @"CIConvolution7X7";
            goto LABEL_19;
          }
          if (![v7 isEqualToString:@"box"])
          {
            if ([v7 isEqualToString:@"add4"])
            {
              int v32 = objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 1), "intValue");
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 2), "floatValue");
              float v34 = v33;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 3), "floatValue");
              float v36 = v35;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 4), "doubleValue");
              double v161 = v37;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 5), "doubleValue");
              double v155 = v38;
              float v39 = ceilf(fmaxf(v34, v36));
              float v40 = (void *)*((void *)v207 + v32);
              int v41 = +[CIKernel kernelWithInternalRepresentation:&CI::_add4];
              [(CIImage *)a2 extent];
              CGFloat v43 = v42;
              CGFloat v45 = v44;
              CGFloat v47 = v46;
              CGFloat v49 = v48;
              [v40 extent];
              CGRect v230 = CGRectInset(v215, (float)-v39, (float)-v39);
              v216.origin.double x = v43;
              v216.origin.double y = v45;
              v216.size.double width = v47;
              v216.size.double height = v49;
              CGRect v217 = CGRectUnion(v216, v230);
              CGFloat v50 = v217.origin.x;
              CGFloat v51 = v217.origin.y;
              CGFloat v52 = v217.size.width;
              double v53 = v217.size.height;
              v178[0] = MEMORY[0x1E4F143A8];
              v178[1] = 3221225472;
              v178[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_3;
              v178[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              float v179 = v39;
              v195[0] = a2;
              v195[1] = v40;
              v195[2] = +[CIVector vectorWithX:v34 Y:v36];
              v195[3] = +[CIVector vectorWithX:v161 Y:v155];
              uint64_t v54 = [MEMORY[0x1E4F1C978] arrayWithObjects:v195 count:4];
              double v55 = v178;
              double v56 = v41;
              double v57 = v50;
              double v58 = v51;
              goto LABEL_33;
            }
            if ([v7 isEqualToString:@"add8"])
            {
              int v59 = objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 1), "intValue");
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 2), "floatValue");
              float v61 = v60;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 3), "floatValue");
              float v63 = v62;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 4), "doubleValue");
              double v162 = v64;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 5), "doubleValue");
              double v156 = v65;
              float v66 = ceilf(fmaxf(v61, v63));
              double v67 = (void *)*((void *)v207 + v59);
              double v68 = +[CIKernel kernelWithInternalRepresentation:&CI::_add8];
              [(CIImage *)a2 extent];
              CGFloat v70 = v69;
              CGFloat v72 = v71;
              CGFloat v74 = v73;
              CGFloat v76 = v75;
              [v67 extent];
              CGRect v231 = CGRectInset(v218, (float)-v66, (float)-v66);
              v219.origin.double x = v70;
              v219.origin.double y = v72;
              v219.size.double width = v74;
              v219.size.double height = v76;
              CGRect v220 = CGRectUnion(v219, v231);
              CGFloat v77 = v220.origin.x;
              CGFloat v78 = v220.origin.y;
              CGFloat v52 = v220.size.width;
              double v53 = v220.size.height;
              v176[0] = MEMORY[0x1E4F143A8];
              v176[1] = 3221225472;
              v176[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_4;
              v176[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              float v177 = v66;
              v194[0] = a2;
              v194[1] = v67;
              v194[2] = +[CIVector vectorWithX:v61 Y:v63];
              v194[3] = +[CIVector vectorWithX:v162 Y:v156];
              uint64_t v54 = [MEMORY[0x1E4F1C978] arrayWithObjects:v194 count:4];
              double v55 = v176;
              double v56 = v68;
              double v57 = v77;
              double v58 = v78;
LABEL_33:
              double v79 = v52;
LABEL_41:
              double v22 = -[CIKernel applyWithExtent:roiCallback:arguments:](v56, "applyWithExtent:roiCallback:arguments:", v55, v54, v57, v58, v79, v53);
LABEL_20:
              a2 = v22;
LABEL_21:
              uint64_t v3 = v5;
              goto LABEL_22;
            }
            if ([v7 isEqualToString:@"add4and4"])
            {
              int v80 = objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 1), "intValue");
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 2), "floatValue");
              float v82 = v81;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 3), "floatValue");
              float v84 = v83;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 4), "floatValue");
              float v163 = v85;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 5), "floatValue");
              float v152 = v86;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 6), "doubleValue");
              double v157 = v87;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 7), "doubleValue");
              double v149 = v88;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 8), "doubleValue");
              double v146 = v89;
              float v90 = ceilf(fmaxf(v82, v84));
              double v91 = (void *)*((void *)v207 + v80);
              double v92 = +[CIKernel kernelWithInternalRepresentation:&CI::_add4and4];
              [(CIImage *)a2 extent];
              CGFloat v94 = v93;
              CGFloat v96 = v95;
              CGFloat v98 = v97;
              CGFloat v100 = v99;
              [v91 extent];
              CGRect v232 = CGRectInset(v221, (float)-v90, (float)-v90);
              v222.origin.double x = v94;
              v222.origin.double y = v96;
              v222.size.double width = v98;
              v222.size.double height = v100;
              CGRect v223 = CGRectUnion(v222, v232);
              CGFloat v101 = v223.origin.x;
              CGFloat v102 = v223.origin.y;
              CGFloat v103 = v223.size.width;
              double v53 = v223.size.height;
              v174[0] = MEMORY[0x1E4F143A8];
              v174[1] = 3221225472;
              v174[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_5;
              v174[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              float v175 = v90;
              v193[0] = a2;
              v193[1] = v91;
              v193[2] = +[CIVector vectorWithX:v82 Y:v84 Z:v163 W:v152];
              v193[3] = +[CIVector vectorWithX:v157 Y:v149 Z:v146];
              uint64_t v54 = [MEMORY[0x1E4F1C978] arrayWithObjects:v193 count:4];
              double v55 = v174;
            }
            else if ([v7 isEqualToString:@"add4and8"])
            {
              int v104 = objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 1), "intValue");
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 2), "floatValue");
              float v106 = v105;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 3), "floatValue");
              float v108 = v107;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 4), "floatValue");
              float v164 = v109;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 5), "floatValue");
              float v153 = v110;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 6), "doubleValue");
              double v158 = v111;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 7), "doubleValue");
              double v150 = v112;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 8), "doubleValue");
              double v147 = v113;
              float v114 = ceilf(fmaxf(v106, v108));
              int8x16_t v115 = (void *)*((void *)v207 + v104);
              double v92 = +[CIKernel kernelWithInternalRepresentation:&CI::_add4and8];
              [(CIImage *)a2 extent];
              CGFloat v117 = v116;
              CGFloat v119 = v118;
              CGFloat v121 = v120;
              CGFloat v123 = v122;
              [v115 extent];
              CGRect v233 = CGRectInset(v224, (float)-v114, (float)-v114);
              v225.origin.double x = v117;
              v225.origin.double y = v119;
              v225.size.double width = v121;
              v225.size.double height = v123;
              CGRect v226 = CGRectUnion(v225, v233);
              CGFloat v101 = v226.origin.x;
              CGFloat v102 = v226.origin.y;
              CGFloat v103 = v226.size.width;
              double v53 = v226.size.height;
              v172[0] = MEMORY[0x1E4F143A8];
              v172[1] = 3221225472;
              v172[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_6;
              v172[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              float v173 = v114;
              v192[0] = a2;
              v192[1] = v115;
              v192[2] = +[CIVector vectorWithX:v106 Y:v108 Z:v164 W:v153];
              v192[3] = +[CIVector vectorWithX:v158 Y:v150 Z:v147];
              uint64_t v54 = [MEMORY[0x1E4F1C978] arrayWithObjects:v192 count:4];
              double v55 = v172;
            }
            else
            {
              if (![v7 isEqualToString:@"add8and8"]) {
                goto LABEL_21;
              }
              int v124 = objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 1), "intValue");
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 2), "floatValue");
              float v126 = v125;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 3), "floatValue");
              float v128 = v127;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 4), "floatValue");
              float v165 = v129;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 5), "floatValue");
              float v154 = v130;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 6), "doubleValue");
              double v159 = v131;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 7), "doubleValue");
              double v151 = v132;
              objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 8), "doubleValue");
              double v148 = v133;
              float v134 = ceilf(fmaxf(v126, v128));
              float32x4_t v135 = (void *)*((void *)v207 + v124);
              double v92 = +[CIKernel kernelWithInternalRepresentation:&CI::_add8and8];
              [(CIImage *)a2 extent];
              CGFloat v137 = v136;
              CGFloat v139 = v138;
              CGFloat v141 = v140;
              CGFloat v143 = v142;
              [v135 extent];
              CGRect v234 = CGRectInset(v227, (float)-v134, (float)-v134);
              v228.origin.double x = v137;
              v228.origin.double y = v139;
              v228.size.double width = v141;
              v228.size.double height = v143;
              CGRect v229 = CGRectUnion(v228, v234);
              CGFloat v101 = v229.origin.x;
              CGFloat v102 = v229.origin.y;
              CGFloat v103 = v229.size.width;
              double v53 = v229.size.height;
              v170[0] = MEMORY[0x1E4F143A8];
              v170[1] = 3221225472;
              v170[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_7;
              v170[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              float v171 = v134;
              v191[0] = a2;
              v191[1] = v135;
              v191[2] = +[CIVector vectorWithX:v126 Y:v128 Z:v165 W:v154];
              v191[3] = +[CIVector vectorWithX:v159 Y:v151 Z:v148];
              uint64_t v54 = [MEMORY[0x1E4F1C978] arrayWithObjects:v191 count:4];
              double v55 = v170;
            }
            double v56 = v92;
            double v57 = v101;
            double v58 = v102;
            double v79 = v103;
            goto LABEL_41;
          }
          int v23 = objc_msgSend((id)objc_msgSend(v6, "objectAtIndex:", 1), "intValue");
          *(void *)&v207[0] = a2;
          int v160 = v23;
          if (v23 >= 1)
          {
            uint64_t v24 = (v23 + 1) - 1;
            uint64_t v25 = 1;
            double v26 = (void *)v207 + 1;
            do
            {
              double v27 = +[CIKernel kernelWithInternalRepresentation:&CI::_box3];
              [(CIImage *)a2 extent];
              CGRect v214 = CGRectInset(v213, (double)-(int)v25, (double)-(int)v25);
              double v28 = v214.origin.x;
              double v29 = v214.origin.y;
              double v30 = v214.size.width;
              double v31 = v214.size.height;
              v180[0] = MEMORY[0x1E4F143A8];
              v180[1] = 3221225472;
              v180[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_2;
              v180[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              int v181 = v25;
              v196[0] = a2;
              v196[1] = [NSNumber numberWithInt:v25];
              a2 = -[CIKernel applyWithExtent:roiCallback:arguments:](v27, "applyWithExtent:roiCallback:arguments:", v180, [MEMORY[0x1E4F1C978] arrayWithObjects:v196 count:2], v28, v29, v30, v31);
              *v26++ = a2;
              uint64_t v25 = (3 * v25);
              --v24;
            }
            while (v24);
          }
          a2 = (CIImage *)*((void *)v207 + v160);
          uint64_t v3 = v5;
        }
LABEL_22:
        uint64_t v4 = v169 + 1;
      }
      while (v169 + 1 != v168);
      uint64_t v144 = [(NSArray *)a1 countByEnumeratingWithState:&v187 objects:v206 count:16];
      uint64_t v168 = v144;
    }
    while (v144);
  }
  return a2;
}

double cikernel::_convolutionAdd_1(uint64_t a1, uint64_t a2, float32x2_t a3, float a4)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v9) = *(_DWORD *)(a2 + 28);
  v10.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v9, COERCE_FLOAT(*DC));
  *(float *)&double v12 = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v12, v13, v8, v9, v11, v10, v14);
  float32x4_t v26 = v15;
  float32x2_t v17 = vadd_f32(a3, *(float32x2_t *)CI::getDC(v16));
  *(float *)&double v18 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v17, 1), *(float *)(a1 + 16), v17.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a1 + 28);
  v20.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v17, 1), *(float *)&v19, v17.f32[0]);
  v17.f32[0] = *(float *)(a1 + 24) + *(float *)&v18;
  *(float *)v22.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  v17.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v17, v22, v18, v19, v21, v20, v23);
  *(void *)&double result = vaddq_f32(v26, vmulq_n_f32(v24, a4)).u64[0];
  return result;
}

void CI::f4_sr_sr_f2_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  double v12 = *(double (**)(uint64_t, uint64_t, double, float))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  uint64_t v14 = *(void *)(v11 + 32);
  int v15 = *(_DWORD *)(v11 + 64);
  uint64_t v16 = *(void *)(v11 + 56);
  uint64_t v17 = *(void *)(v11 + 80);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 104)), a2);
  }
  double v18 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    double v18 = (double *)((char *)a2 + 64 * v16);
  }
  *(double *)&long long v19 = v12(a4 + 80 * v13, a4 + 80 * v14, *v18, *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_convolutionAdd_2(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4, double a5)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v11) = *(_DWORD *)(a2 + 28);
  v12.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  *(float *)&double v14 = *(float *)(a2 + 24) + *(float *)&v10;
  *(float *)v15.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  *((float *)&v14 + 1) = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v14, v15, v10, v11, v13, v12, v16);
  float32x4_t v37 = v17;
  float32x2_t v19 = *(float32x2_t *)CI::getDC(v18);
  float32x2_t v20 = vadd_f32(a3, v19);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)&v22, v20.f32[0]);
  v20.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v20.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v20, v25, v21, v22, v24, v23, v26);
  float32x4_t v36 = v27;
  *(float32x2_t *)v27.f32 = vadd_f32(a4, v19);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v27.f32, 1), *(float *)(a1 + 16), v27.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v27.f32, 1), *(float *)&v29, v27.f32[0]);
  v27.f32[0] = *(float *)(a1 + 24) + *(float *)&v28;
  *(float *)v32.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v27.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v32, v28, v29, v31, v30, v33);
  *(void *)&double result = vaddq_f32(vaddq_f32(v37, vmulq_n_f32(v36, *(float *)&a5)), vmulq_lane_f32(v34, *(float32x2_t *)&a5, 1)).u64[0];
  return result;
}

void CI::f4_sr_sr_f2_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  double v10 = *(double (**)(uint64_t, uint64_t, double, double, double))(a1 + 24);
  uint64_t v11 = *(void *)(v9 + 8);
  uint64_t v12 = *(void *)(v9 + 32);
  int v13 = *(_DWORD *)(v9 + 64);
  uint64_t v14 = *(void *)(v9 + 56);
  int v15 = *(_DWORD *)(v9 + 88);
  uint64_t v16 = *(void *)(v9 + 80);
  int v17 = *(_DWORD *)(v9 + 112);
  uint64_t v18 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v24 = a4;
    int v23 = *(_DWORD *)(v9 + 112);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v17 = v23;
    a4 = v24;
  }
  float32x2_t v19 = (double *)(a3 + 16 * v18);
  if (v17 != 5) {
    float32x2_t v19 = (double *)((char *)a2 + 64 * v18);
  }
  float32x2_t v20 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x2_t v20 = (double *)((char *)a2 + 64 * v16);
  }
  double v21 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    double v21 = (double *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v22 = v10(a4 + 80 * v11, a4 + 80 * v12, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_convolutionAdd_3(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, float32x4_t a6)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v13) = *(_DWORD *)(a2 + 28);
  v14.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v13, COERCE_FLOAT(*DC));
  *(float *)&double v16 = *(float *)(a2 + 24) + *(float *)&v12;
  *(float *)v17.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  *((float *)&v16 + 1) = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v16, v17, v12, v13, v15, v14, v18);
  float32x4_t v47 = v19;
  float32x2_t v21 = *(float32x2_t *)CI::getDC(v20);
  float32x2_t v22 = vadd_f32(a3, v21);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v22, v27, v23, v24, v26, v25, v28);
  float32x4_t v46 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32(a4, v21);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v29.f32, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v34, v30, v31, v33, v32, v35);
  float32x4_t v45 = v36;
  *(float32x2_t *)v36.f32 = vadd_f32(a5, v21);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v36.f32, 1), *(float *)(a1 + 16), v36.f32[0]);
  LODWORD(v3_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v36.f32, 1), *(float *)&v38, v36.f32[0]);
  v36.f32[0] = *(float *)(a1 + 24) + *(float *)&v37;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v36.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v41, v37, v38, v40, v39, v42);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(v47, vmulq_n_f32(v46, a6.f32[0])), vmulq_lane_f32(v45, *(float32x2_t *)a6.f32, 1)), vmulq_laneq_f32(v43, a6, 2)).u64[0];
  return result;
}

void CI::f4_sr_sr_f2_f2_f2_f3(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  double v10 = *(double (**)(uint64_t, uint64_t, double, double, double, __n128))(a1 + 24);
  uint64_t v11 = *(void *)(v9 + 8);
  uint64_t v12 = *(void *)(v9 + 32);
  int v13 = *(_DWORD *)(v9 + 64);
  uint64_t v14 = *(void *)(v9 + 56);
  int v15 = *(_DWORD *)(v9 + 88);
  uint64_t v16 = *(void *)(v9 + 80);
  int v17 = *(_DWORD *)(v9 + 112);
  uint64_t v18 = *(void *)(v9 + 104);
  uint64_t v19 = *(void *)(v9 + 128);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v26 = *(void *)(v9 + 32);
    uint64_t v24 = a4;
    int v25 = *(_DWORD *)(v9 + 88);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 152)), a2);
    int v15 = v25;
    a4 = v24;
    uint64_t v12 = v26;
  }
  float32x2_t v20 = (double *)(a3 + 16 * v18);
  if (v17 != 5) {
    float32x2_t v20 = (double *)((char *)a2 + 64 * v18);
  }
  float32x2_t v21 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    float32x2_t v21 = (double *)((char *)a2 + 64 * v16);
  }
  float32x2_t v22 = (double *)(a3 + 16 * v14);
  if (v13 != 5) {
    float32x2_t v22 = (double *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v23 = v10(a4 + 80 * v11, a4 + 80 * v12, *v22, *v21, *v20, *((__n128 *)a2 + 4 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

double cikernel::_convolutionAdd_4(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, float32x4_t a5)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v9) = *(_DWORD *)(a2 + 28);
  v10.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v9, COERCE_FLOAT(*DC));
  *(float *)&double v12 = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v12, v13, v8, v9, v11, v10, v14);
  float32x4_t v50 = v15;
  float32x2_t v17 = *(float32x2_t *)CI::getDC(v16);
  float32x2_t v18 = vadd_f32(*(float32x2_t *)a3.i8, v17);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v18, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v18, 1), *(float *)&v20, v18.f32[0]);
  v18.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v18.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v18, v23, v19, v20, v22, v21, v24);
  float32x4_t v49 = v25;
  *(float32x2_t *)v25.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v17);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.f32, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 28);
  v28.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.f32, 1), *(float *)&v27, v25.f32[0]);
  v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v26;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v30, v26, v27, v29, v28, v31);
  float32x4_t v53 = v32;
  *(float32x2_t *)v32.f32 = vadd_f32(*(float32x2_t *)a4.i8, v17);
  *(float *)&double v33 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v32.f32, 1), *(float *)(a1 + 16), v32.f32[0]);
  LODWORD(v34) = *(_DWORD *)(a1 + 28);
  v35.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v32.f32, 1), *(float *)&v34, v32.f32[0]);
  v32.f32[0] = *(float *)(a1 + 24) + *(float *)&v33;
  *(float *)v37.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v32.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v32.i64, v37, v33, v34, v36, v35, v38);
  float32x4_t v48 = v39;
  *(float32x2_t *)v39.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v17);
  *(float *)&double v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v39.f32, 1), *(float *)(a1 + 16), v39.f32[0]);
  LODWORD(v41) = *(_DWORD *)(a1 + 28);
  v42.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v39.f32, 1), *(float *)&v41, v39.f32[0]);
  v39.f32[0] = *(float *)(a1 + 24) + *(float *)&v40;
  *(float *)v44.f64 = *(float *)v42.i32 + *(float *)v43.i32;
  v39.f32[1] = *(float *)v42.i32 + *(float *)v43.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v39.i64, v44, v40, v41, v43, v42, v45);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v50, vmulq_n_f32(v49, a5.f32[0])), vmulq_lane_f32(v53, *(float32x2_t *)a5.f32, 1)), vmulq_laneq_f32(v48, a5, 2)), vmulq_laneq_f32(v46, a5, 3)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  int8x16_t v10 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128))(a1 + 24);
  uint64_t v11 = *(void *)(v9 + 8);
  uint64_t v12 = *(void *)(v9 + 32);
  int v13 = *(_DWORD *)(v9 + 64);
  uint64_t v14 = *(void *)(v9 + 56);
  int v15 = *(_DWORD *)(v9 + 88);
  uint64_t v16 = *(void *)(v9 + 80);
  int v17 = *(_DWORD *)(v9 + 112);
  uint64_t v18 = *(void *)(v9 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v24 = a4;
    int v23 = *(_DWORD *)(v9 + 112);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 128)), a2);
    int v17 = v23;
    a4 = v24;
  }
  double v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    double v19 = (__n128 *)((char *)a2 + 64 * v18);
  }
  double v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    double v20 = (__n128 *)((char *)a2 + 64 * v16);
  }
  int8x16_t v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    int8x16_t v21 = (__n128 *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v22 = v10(a4 + 80 * v11, a4 + 80 * v12, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_convolutionAdd_5(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, float32x2_t a5, float32x4_t a6, float a7)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v11 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v12) = *(_DWORD *)(a2 + 28);
  v13.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v12, COERCE_FLOAT(*DC));
  *(float *)&double v15 = *(float *)(a2 + 24) + *(float *)&v11;
  *(float *)v16.f64 = *(float *)v13.i32 + *(float *)v14.i32;
  *((float *)&v15 + 1) = *(float *)v13.i32 + *(float *)v14.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v15, v16, v11, v12, v14, v13, v17);
  float32x4_t v60 = v18;
  float32x2_t v20 = *(float32x2_t *)CI::getDC(v19);
  float32x2_t v21 = vadd_f32(*(float32x2_t *)a3.i8, v20);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v21, v26, v22, v23, v25, v24, v27);
  float32x4_t v59 = v28;
  *(float32x2_t *)v28.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v20);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v28.f32, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.f32, 1), *(float *)&v30, v28.f32[0]);
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v29;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v28.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v33, v29, v30, v32, v31, v34);
  float32x4_t v64 = v35;
  *(float32x2_t *)v35.f32 = vadd_f32(*(float32x2_t *)a4.i8, v20);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v35.f32, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 28);
  v38.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v35.f32, 1), *(float *)&v37, v35.f32[0]);
  v35.f32[0] = *(float *)(a1 + 24) + *(float *)&v36;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v35.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v40, v36, v37, v39, v38, v41);
  float32x4_t v58 = v42;
  *(float32x2_t *)v42.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v20);
  *(float *)&double v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v42.f32, 1), *(float *)(a1 + 16), v42.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a1 + 28);
  v45.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v42.f32, 1), *(float *)&v44, v42.f32[0]);
  v42.f32[0] = *(float *)(a1 + 24) + *(float *)&v43;
  *(float *)v47.f64 = *(float *)v45.i32 + *(float *)v46.i32;
  v42.f32[1] = *(float *)v45.i32 + *(float *)v46.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v47, v43, v44, v46, v45, v48);
  float32x4_t v66 = v49;
  *(float32x2_t *)v49.f32 = vadd_f32(a5, v20);
  *(float *)&double v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v49.f32, 1), *(float *)(a1 + 16), v49.f32[0]);
  LODWORD(v51) = *(_DWORD *)(a1 + 28);
  v52.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v49.f32, 1), *(float *)&v51, v49.f32[0]);
  v49.f32[0] = *(float *)(a1 + 24) + *(float *)&v50;
  *(float *)v54.f64 = *(float *)v52.i32 + *(float *)v53.i32;
  v49.f32[1] = *(float *)v52.i32 + *(float *)v53.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v49.i64, v54, v50, v51, v53, v52, v55);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v60, vmulq_n_f32(v59, a6.f32[0])), vmulq_lane_f32(v64, *(float32x2_t *)a6.f32, 1)), vmulq_laneq_f32(v58, a6, 2)), vmulq_laneq_f32(v66, a6, 3)), vmulq_n_f32(v56, a7)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4_f2_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  int8x16_t v10 = *(double (**)(uint64_t, uint64_t, __n128, __n128, double, __n128, float))(a1 + 24);
  uint64_t v11 = *(void *)(v9 + 8);
  uint64_t v12 = *(void *)(v9 + 32);
  int v13 = *(_DWORD *)(v9 + 64);
  uint64_t v14 = *(void *)(v9 + 56);
  int v15 = *(_DWORD *)(v9 + 88);
  uint64_t v16 = *(void *)(v9 + 80);
  int v17 = *(_DWORD *)(v9 + 112);
  uint64_t v18 = *(void *)(v9 + 104);
  int v19 = *(_DWORD *)(v9 + 136);
  uint64_t v20 = *(void *)(v9 + 128);
  uint64_t v21 = *(void *)(v9 + 152);
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v30 = *(void *)(v9 + 56);
    int8x16_t v31 = *(double (**)(uint64_t, uint64_t, __n128, __n128, double, __n128, float))(a1 + 24);
    uint64_t v29 = a4;
    uint64_t v27 = *(void *)(v9 + 152);
    int v28 = *(_DWORD *)(v9 + 112);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 176)), a2);
    int v17 = v28;
    a4 = v29;
    uint64_t v14 = v30;
    uint64_t v21 = v27;
    int8x16_t v10 = v31;
  }
  double v22 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    double v22 = (__n128 *)((char *)a2 + 64 * v20);
  }
  double v23 = (double *)(a3 + 16 * v18);
  if (v17 != 5) {
    double v23 = (double *)((char *)a2 + 64 * v18);
  }
  int8x16_t v24 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5) {
    int8x16_t v24 = (__n128 *)((char *)a2 + 64 * v16);
  }
  int8x16_t v25 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    int8x16_t v25 = (__n128 *)((char *)a2 + 64 * v14);
  }
  *(double *)&long long v26 = v10(a4 + 80 * v11, a4 + 80 * v12, *v25, *v24, *v23, *v22, *((float *)a2 + 16 * v21));
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

double cikernel::_convolutionAdd_6(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, float32x4_t a6, double a7)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v11) = *(_DWORD *)(a2 + 28);
  v12.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  *(float *)&double v14 = *(float *)(a2 + 24) + *(float *)&v10;
  *(float *)v15.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  *((float *)&v14 + 1) = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v14, v15, v10, v11, v13, v12, v16);
  float32x4_t v67 = v17;
  float32x2_t v19 = *(float32x2_t *)CI::getDC(v18);
  float32x2_t v20 = vadd_f32(*(float32x2_t *)a3.i8, v19);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)&v22, v20.f32[0]);
  v20.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v20.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v20, v25, v21, v22, v24, v23, v26);
  float32x4_t v66 = v27;
  *(float32x2_t *)v27.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v19);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v27.f32, 1), *(float *)(a1 + 16), v27.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v27.f32, 1), *(float *)&v29, v27.f32[0]);
  v27.f32[0] = *(float *)(a1 + 24) + *(float *)&v28;
  *(float *)v32.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v27.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v32, v28, v29, v31, v30, v33);
  float32x4_t v71 = v34;
  *(float32x2_t *)v34.f32 = vadd_f32(*(float32x2_t *)a4.i8, v19);
  *(float *)&double v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v34.f32, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 28);
  v37.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v34.f32, 1), *(float *)&v36, v34.f32[0]);
  v34.f32[0] = *(float *)(a1 + 24) + *(float *)&v35;
  *(float *)v39.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v34.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v39, v35, v36, v38, v37, v40);
  float32x4_t v65 = v41;
  *(float32x2_t *)v41.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v19);
  *(float *)&double v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v41.f32, 1), *(float *)(a1 + 16), v41.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 28);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v41.f32, 1), *(float *)&v43, v41.f32[0]);
  v41.f32[0] = *(float *)(a1 + 24) + *(float *)&v42;
  *(float *)v46.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  v41.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, v46, v42, v43, v45, v44, v47);
  float32x4_t v73 = v48;
  *(float32x2_t *)v48.f32 = vadd_f32(*(float32x2_t *)a5.i8, v19);
  *(float *)&double v49 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v48.f32, 1), *(float *)(a1 + 16), v48.f32[0]);
  LODWORD(v5CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v51.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v52.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v48.f32, 1), *(float *)&v50, v48.f32[0]);
  v48.f32[0] = *(float *)(a1 + 24) + *(float *)&v49;
  *(float *)v53.f64 = *(float *)v51.i32 + *(float *)v52.i32;
  v48.f32[1] = *(float *)v51.i32 + *(float *)v52.i32;
  *(double *)v55.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v53, v49, v50, v52, v51, v54);
  float32x4_t v64 = v55;
  *(float32x2_t *)v55.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v19);
  *(float *)&double v56 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v55.f32, 1), *(float *)(a1 + 16), v55.f32[0]);
  LODWORD(v57) = *(_DWORD *)(a1 + 28);
  v58.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v59.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v55.f32, 1), *(float *)&v57, v55.f32[0]);
  v55.f32[0] = *(float *)(a1 + 24) + *(float *)&v56;
  *(float *)v60.f64 = *(float *)v58.i32 + *(float *)v59.i32;
  v55.f32[1] = *(float *)v58.i32 + *(float *)v59.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v55.i64, v60, v56, v57, v59, v58, v61);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v67, vmulq_n_f32(v66, a6.f32[0])), vmulq_lane_f32(v71, *(float32x2_t *)a6.f32, 1)), vmulq_laneq_f32(v65, a6, 2)), vmulq_laneq_f32(v73, a6, 3)), vmulq_n_f32(v64, *(float *)&a7)), vmulq_lane_f32(v62, *(float32x2_t *)&a7, 1)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4_f4_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  double v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, double))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  int v14 = *(_DWORD *)(v10 + 64);
  uint64_t v15 = *(void *)(v10 + 56);
  int v16 = *(_DWORD *)(v10 + 88);
  uint64_t v17 = *(void *)(v10 + 80);
  int v18 = *(_DWORD *)(v10 + 112);
  uint64_t v19 = *(void *)(v10 + 104);
  int v20 = *(_DWORD *)(v10 + 136);
  uint64_t v21 = *(void *)(v10 + 128);
  int v22 = *(_DWORD *)(v10 + 160);
  uint64_t v23 = *(void *)(v10 + 152);
  if (*(unsigned char *)(a1 + 64))
  {
    int8x16_t v33 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, double))(a1 + 24);
    uint64_t v31 = *(void *)(v10 + 8);
    int v34 = *(_DWORD *)(v10 + 88);
    int v35 = *(_DWORD *)(v10 + 64);
    int v32 = *(_DWORD *)(v10 + 112);
    int v30 = *(_DWORD *)(v10 + 160);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 176)), a2);
    int v22 = v30;
    int v18 = v32;
    int v16 = v34;
    int v14 = v35;
    uint64_t v12 = v31;
    double v11 = v33;
  }
  int8x16_t v24 = (double *)(a3 + 16 * v23);
  if (v22 != 5) {
    int8x16_t v24 = (double *)((char *)a2 + 64 * v23);
  }
  float64x2_t v25 = (__n128 *)(a3 + 16 * v21);
  if (v20 != 5) {
    float64x2_t v25 = (__n128 *)((char *)a2 + 64 * v21);
  }
  int8x16_t v26 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5) {
    int8x16_t v26 = (__n128 *)((char *)a2 + 64 * v19);
  }
  float32x4_t v27 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    float32x4_t v27 = (__n128 *)((char *)a2 + 64 * v17);
  }
  double v28 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    double v28 = (__n128 *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v29 = v11(a4 + 80 * v12, a4 + 80 * v13, *v28, *v27, *v26, *v25, *v24);
  *(_OWORD *)(a3 + 16 * a7) = v29;
}

double cikernel::_convolutionAdd_7(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, float32x2_t a6, float32x4_t a7, float32x4_t a8)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v13) = *(_DWORD *)(a2 + 28);
  v14.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v13, COERCE_FLOAT(*DC));
  *(float *)&double v16 = *(float *)(a2 + 24) + *(float *)&v12;
  *(float *)v17.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  *((float *)&v16 + 1) = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v16, v17, v12, v13, v15, v14, v18);
  float32x4_t v76 = v19;
  float32x2_t v21 = *(float32x2_t *)CI::getDC(v20);
  float32x2_t v22 = vadd_f32(*(float32x2_t *)a3.i8, v21);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v22, v27, v23, v24, v26, v25, v28);
  float32x4_t v75 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v21);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v29.f32, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v34, v30, v31, v33, v32, v35);
  float32x4_t v80 = v36;
  *(float32x2_t *)v36.f32 = vadd_f32(*(float32x2_t *)a4.i8, v21);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v36.f32, 1), *(float *)(a1 + 16), v36.f32[0]);
  LODWORD(v3_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v36.f32, 1), *(float *)&v38, v36.f32[0]);
  v36.f32[0] = *(float *)(a1 + 24) + *(float *)&v37;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v36.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v41, v37, v38, v40, v39, v42);
  float32x4_t v74 = v43;
  *(float32x2_t *)v43.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v21);
  *(float *)&double v44 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v43.f32, 1), *(float *)(a1 + 16), v43.f32[0]);
  LODWORD(v45) = *(_DWORD *)(a1 + 28);
  v46.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v43.f32, 1), *(float *)&v45, v43.f32[0]);
  v43.f32[0] = *(float *)(a1 + 24) + *(float *)&v44;
  *(float *)v48.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  v43.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v48, v44, v45, v47, v46, v49);
  float32x4_t v82 = v50;
  *(float32x2_t *)v50.f32 = vadd_f32(*(float32x2_t *)a5.i8, v21);
  *(float *)&double v51 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v50.f32, 1), *(float *)(a1 + 16), v50.f32[0]);
  LODWORD(v52) = *(_DWORD *)(a1 + 28);
  v53.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v50.f32, 1), *(float *)&v52, v50.f32[0]);
  v50.f32[0] = *(float *)(a1 + 24) + *(float *)&v51;
  *(float *)v55.f64 = *(float *)v53.i32 + *(float *)v54.i32;
  v50.f32[1] = *(float *)v53.i32 + *(float *)v54.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v50.i64, v55, v51, v52, v54, v53, v56);
  float32x4_t v73 = v57;
  *(float32x2_t *)v57.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v21);
  *(float *)&double v58 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v57.f32, 1), *(float *)(a1 + 16), v57.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 28);
  v60.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v61.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v57.f32, 1), *(float *)&v59, v57.f32[0]);
  v57.f32[0] = *(float *)(a1 + 24) + *(float *)&v58;
  *(float *)v62.f64 = *(float *)v60.i32 + *(float *)v61.i32;
  v57.f32[1] = *(float *)v60.i32 + *(float *)v61.i32;
  *(double *)v64.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v57.i64, v62, v58, v59, v61, v60, v63);
  float32x4_t v84 = v64;
  *(float32x2_t *)v64.f32 = vadd_f32(a6, v21);
  *(float *)&double v65 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v64.f32, 1), *(float *)(a1 + 16), v64.f32[0]);
  LODWORD(v66) = *(_DWORD *)(a1 + 28);
  v67.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v68.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v64.f32, 1), *(float *)&v66, v64.f32[0]);
  v64.f32[0] = *(float *)(a1 + 24) + *(float *)&v65;
  *(float *)v69.f64 = *(float *)v67.i32 + *(float *)v68.i32;
  v64.f32[1] = *(float *)v67.i32 + *(float *)v68.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v64.i64, v69, v65, v66, v68, v67, v70);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v76, vmulq_n_f32(v75, a7.f32[0])), vmulq_lane_f32(v80, *(float32x2_t *)a7.f32, 1)), vmulq_laneq_f32(v74, a7, 2)), vmulq_laneq_f32(v82, a7, 3)), vmulq_n_f32(v73, a8.f32[0])), vmulq_lane_f32(v84, *(float32x2_t *)a8.f32, 1)), vmulq_laneq_f32(v71, a8, 2)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4_f4_f2_f4_f3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  double v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, double, __n128, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  int v14 = *(_DWORD *)(v10 + 64);
  int8x16_t v15 = *(const vec2 **)(v10 + 56);
  int v16 = *(_DWORD *)(v10 + 88);
  uint64_t v17 = *(void *)(v10 + 80);
  int v18 = *(_DWORD *)(v10 + 112);
  uint64_t v19 = *(void *)(v10 + 104);
  int v20 = *(_DWORD *)(v10 + 136);
  uint64_t v21 = *(void *)(v10 + 128);
  int v22 = *(_DWORD *)(v10 + 160);
  uint64_t v23 = *(void *)(v10 + 152);
  uint64_t v24 = *(void *)(v10 + 176);
  if (*(unsigned char *)(a1 + 64))
  {
    float32x4_t v36 = *(const vec2 **)(v10 + 56);
    double v37 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, double, __n128, __n128))(a1 + 24);
    uint64_t v33 = *(void *)(v10 + 8);
    uint64_t v34 = *(void *)(v10 + 80);
    uint64_t v35 = *(void *)(v10 + 176);
    int v31 = *(_DWORD *)(v10 + 160);
    int v32 = *(_DWORD *)(v10 + 136);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 200)), v15);
    int v22 = v31;
    int v20 = v32;
    uint64_t v17 = v34;
    uint64_t v24 = v35;
    int8x16_t v15 = v36;
    double v11 = v37;
    uint64_t v12 = v33;
  }
  int8x16_t v25 = (__n128 *)(a3 + 16 * v23);
  if (v22 != 5) {
    int8x16_t v25 = (__n128 *)(a2 + (v23 << 6));
  }
  int8x16_t v26 = (double *)(a3 + 16 * v21);
  if (v20 != 5) {
    int8x16_t v26 = (double *)(a2 + (v21 << 6));
  }
  float64x2_t v27 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5) {
    float64x2_t v27 = (__n128 *)(a2 + (v19 << 6));
  }
  int8x16_t v28 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x16_t v28 = (__n128 *)(a2 + (v17 << 6));
  }
  float32x4_t v29 = (__n128 *)(a3 + 16 * (void)v15);
  if (v14 != 5) {
    float32x4_t v29 = (__n128 *)(a2 + ((void)v15 << 6));
  }
  *(double *)&long long v30 = v11(a4 + 80 * v12, a4 + 80 * v13, *v29, *v28, *v27, *v26, *v25, *(__n128 *)(a2 + (v24 << 6)));
  *(_OWORD *)(a3 + 16 * a7) = v30;
}

double cikernel::_convolutionAdd_8(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, int8x16_t a6, float32x4_t a7, float32x4_t a8)
{
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v11 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v12) = *(_DWORD *)(a2 + 28);
  v13.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v12, COERCE_FLOAT(*DC));
  *(float *)&double v15 = *(float *)(a2 + 24) + *(float *)&v11;
  *(float *)v16.f64 = *(float *)v13.i32 + *(float *)v14.i32;
  *((float *)&v15 + 1) = *(float *)v13.i32 + *(float *)v14.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v15, v16, v11, v12, v14, v13, v17);
  float32x4_t v83 = v18;
  float32x2_t v20 = *(float32x2_t *)CI::getDC(v19);
  float32x2_t v21 = vadd_f32(*(float32x2_t *)a3.i8, v20);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v21, v26, v22, v23, v25, v24, v27);
  float32x4_t v82 = v28;
  *(float32x2_t *)v28.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v20);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v28.f32, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.f32, 1), *(float *)&v30, v28.f32[0]);
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v29;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v28.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v33, v29, v30, v32, v31, v34);
  float32x4_t v87 = v35;
  *(float32x2_t *)v35.f32 = vadd_f32(*(float32x2_t *)a4.i8, v20);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v35.f32, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 28);
  v38.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v35.f32, 1), *(float *)&v37, v35.f32[0]);
  v35.f32[0] = *(float *)(a1 + 24) + *(float *)&v36;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v35.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v40, v36, v37, v39, v38, v41);
  float32x4_t v81 = v42;
  *(float32x2_t *)v42.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v20);
  *(float *)&double v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v42.f32, 1), *(float *)(a1 + 16), v42.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a1 + 28);
  v45.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v42.f32, 1), *(float *)&v44, v42.f32[0]);
  v42.f32[0] = *(float *)(a1 + 24) + *(float *)&v43;
  *(float *)v47.f64 = *(float *)v45.i32 + *(float *)v46.i32;
  v42.f32[1] = *(float *)v45.i32 + *(float *)v46.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v47, v43, v44, v46, v45, v48);
  float32x4_t v89 = v49;
  *(float32x2_t *)v49.f32 = vadd_f32(*(float32x2_t *)a5.i8, v20);
  *(float *)&double v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v49.f32, 1), *(float *)(a1 + 16), v49.f32[0]);
  LODWORD(v51) = *(_DWORD *)(a1 + 28);
  v52.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v49.f32, 1), *(float *)&v51, v49.f32[0]);
  v49.f32[0] = *(float *)(a1 + 24) + *(float *)&v50;
  *(float *)v54.f64 = *(float *)v52.i32 + *(float *)v53.i32;
  v49.f32[1] = *(float *)v52.i32 + *(float *)v53.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v49.i64, v54, v50, v51, v53, v52, v55);
  float32x4_t v80 = v56;
  *(float32x2_t *)v56.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v20);
  *(float *)&double v57 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v56.f32, 1), *(float *)(a1 + 16), v56.f32[0]);
  LODWORD(v5_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 28);
  v59.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v56.f32, 1), *(float *)&v58, v56.f32[0]);
  v56.f32[0] = *(float *)(a1 + 24) + *(float *)&v57;
  *(float *)v61.f64 = *(float *)v59.i32 + *(float *)v60.i32;
  v56.f32[1] = *(float *)v59.i32 + *(float *)v60.i32;
  *(double *)v63.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v56.i64, v61, v57, v58, v60, v59, v62);
  float32x4_t v91 = v63;
  *(float32x2_t *)v63.f32 = vadd_f32(*(float32x2_t *)a6.i8, v20);
  *(float *)&double v64 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v63.f32, 1), *(float *)(a1 + 16), v63.f32[0]);
  LODWORD(v65) = *(_DWORD *)(a1 + 28);
  v66.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v67.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v63.f32, 1), *(float *)&v65, v63.f32[0]);
  v63.f32[0] = *(float *)(a1 + 24) + *(float *)&v64;
  *(float *)v68.f64 = *(float *)v66.i32 + *(float *)v67.i32;
  v63.f32[1] = *(float *)v66.i32 + *(float *)v67.i32;
  *(double *)v70.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v63.i64, v68, v64, v65, v67, v66, v69);
  float32x4_t v79 = v70;
  *(float32x2_t *)v70.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a6, a6, 8uLL), v20);
  *(float *)&double v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v70.f32, 1), *(float *)(a1 + 16), v70.f32[0]);
  LODWORD(v72) = *(_DWORD *)(a1 + 28);
  v73.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v70.f32, 1), *(float *)&v72, v70.f32[0]);
  v70.f32[0] = *(float *)(a1 + 24) + *(float *)&v71;
  *(float *)v75.f64 = *(float *)v73.i32 + *(float *)v74.i32;
  v70.f32[1] = *(float *)v73.i32 + *(float *)v74.i32;
  *(double *)v77.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v70.i64, v75, v71, v72, v74, v73, v76);
  *(void *)&double result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v83, vmulq_n_f32(v82, a7.f32[0])), vmulq_lane_f32(v87, *(float32x2_t *)a7.f32, 1)), vmulq_laneq_f32(v81, a7, 2)), vmulq_laneq_f32(v89, a7, 3)), vmulq_n_f32(v80, a8.f32[0])), vmulq_lane_f32(v91, *(float32x2_t *)a8.f32, 1)), vmulq_laneq_f32(v79, a8, 2)), vmulq_laneq_f32(v77, a8, 3)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4_f4_f4_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  double v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  int v14 = *(_DWORD *)(v10 + 64);
  uint64_t v15 = *(void *)(v10 + 56);
  int v16 = *(_DWORD *)(v10 + 88);
  uint64_t v17 = *(void *)(v10 + 80);
  int v18 = *(_DWORD *)(v10 + 112);
  uint64_t v19 = *(void *)(v10 + 104);
  int v20 = *(_DWORD *)(v10 + 136);
  uint64_t v21 = *(void *)(v10 + 128);
  int v22 = *(_DWORD *)(v10 + 160);
  uint64_t v23 = *(void *)(v10 + 152);
  int v24 = *(_DWORD *)(v10 + 184);
  uint64_t v25 = *(void *)(v10 + 176);
  if (*(unsigned char *)(a1 + 64))
  {
    double v37 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128))(a1 + 24);
    uint64_t v39 = *(void *)(v10 + 8);
    int v40 = *(_DWORD *)(v10 + 64);
    int v38 = *(_DWORD *)(v10 + 88);
    int v36 = *(_DWORD *)(v10 + 112);
    uint64_t v35 = *(void *)(v10 + 104);
    int v33 = *(_DWORD *)(v10 + 184);
    int v34 = *(_DWORD *)(v10 + 160);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 200)), a2);
    int v24 = v33;
    int v22 = v34;
    uint64_t v19 = v35;
    int v18 = v36;
    int v16 = v38;
    int v14 = v40;
    uint64_t v12 = v39;
    double v11 = v37;
  }
  float64x2_t v26 = (__n128 *)(a3 + 16 * v25);
  if (v24 != 5) {
    float64x2_t v26 = (__n128 *)((char *)a2 + 64 * v25);
  }
  int8x16_t v27 = (__n128 *)(a3 + 16 * v23);
  if (v22 != 5) {
    int8x16_t v27 = (__n128 *)((char *)a2 + 64 * v23);
  }
  float32x4_t v28 = (__n128 *)(a3 + 16 * v21);
  if (v20 != 5) {
    float32x4_t v28 = (__n128 *)((char *)a2 + 64 * v21);
  }
  double v29 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5) {
    double v29 = (__n128 *)((char *)a2 + 64 * v19);
  }
  double v30 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    double v30 = (__n128 *)((char *)a2 + 64 * v17);
  }
  int8x16_t v31 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    int8x16_t v31 = (__n128 *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v32 = v11(a4 + 80 * v12, a4 + 80 * v13, *v31, *v30, *v29, *v28, *v27, *v26);
  *(_OWORD *)(a3 + 16 * a7) = v32;
}

double boundsForPointArray(NSArray *a1)
{
  int v2 = [(NSArray *)a1 count];
  id v3 = [(NSArray *)a1 objectAtIndex:0];
  [v3 X];
  float v5 = v4;
  [v3 Y];
  float v7 = v6;
  if (v2 >= 2)
  {
    uint64_t v8 = v2;
    uint64_t v9 = 1;
    float v10 = v6;
    float v11 = v5;
    while (1)
    {
      id v12 = [(NSArray *)a1 objectAtIndex:v9];
      [v12 X];
      float v14 = v13;
      [v12 Y];
      float v16 = v15;
      float v17 = v5 < v14 ? v14 : v5;
      if (v11 <= v14) {
        float v5 = v17;
      }
      else {
        float v11 = v14;
      }
      if (v10 > v16) {
        break;
      }
      if (v7 >= v16) {
        goto LABEL_12;
      }
LABEL_13:
      ++v9;
      float v7 = v16;
      if (v8 == v9) {
        return v11;
      }
    }
    float v10 = v16;
LABEL_12:
    float v16 = v7;
    goto LABEL_13;
  }
  return v5;
}

double disc_multi(double a1, double a2, double a3, double a4, double a5, double a6)
{
  double v8 = a1;
  double v9 = a3 * a5;
  double v10 = 0.0;
  double v11 = -0.4;
  double v12 = 0.0;
  do
  {
    double v13 = -0.4;
    double v18 = v11;
    __double y = a2 + v11 * a6;
    do
    {
      double v14 = hypot(v8 + v13 * a6, __y);
      if (v14 < a3) {
        double v12 = v12 + 0.04;
      }
      if (v14 < v9) {
        double v10 = v10 + 0.04;
      }
      double v8 = a1;
      double v13 = v13 + 0.2;
    }
    while (v13 < 0.5);
    double v11 = v18 + 0.2;
  }
  while (v18 + 0.2 < 0.5);
  return v10 + (v12 - v10) * (a4 + 1.0);
}

uint64_t disc25(double a1, double a2, double a3, double a4, double a5, double a6)
{
  int v9 = 0;
  int v10 = 0;
  double v11 = a3 * a5;
  double v12 = -0.4;
  do
  {
    double v13 = -0.4;
    double v19 = v12;
    double v14 = a2 + v12 * a6;
    do
    {
      double v15 = hypot(a1 + v13 * a6, v14);
      if (v15 < a3) {
        ++v10;
      }
      if (v15 < v11) {
        ++v9;
      }
      double v13 = v13 + 0.2;
    }
    while (v13 < 0.5);
    double v12 = v19 + 0.2;
  }
  while (v19 + 0.2 < 0.5);
  return (int)((double)v10 + (double)(v10 - v9) * a4);
}

uint64_t ConvMap::setValue(uint64_t this, int a2, int a3, int a4)
{
  if (a4 | a3)
  {
    if (a3 >= 0) {
      int v4 = a3;
    }
    else {
      int v4 = -a3;
    }
    if (a4 >= 0) {
      int v5 = a4;
    }
    else {
      int v5 = -a4;
    }
    int v6 = *(_DWORD *)(this + 16);
    if (v4 <= v6 && v5 <= v6)
    {
      if (a4) {
        int v8 = v4;
      }
      else {
        int v8 = 0;
      }
      if (a4) {
        int v4 = v5;
      }
      *(_DWORD *)(*(void *)(this + 8) + 4 * (v4 - 1 + (v4 - 1) * v6 + v8)) = a2;
    }
  }
  else
  {
    *(_DWORD *)this = a2;
  }
  return this;
}

uint64_t ConvMap::value(ConvMap *this, int a2, int a3)
{
  if (!(a3 | a2)) {
    return *(unsigned int *)this;
  }
  if (a2 >= 0) {
    int v3 = a2;
  }
  else {
    int v3 = -a2;
  }
  if (a3 >= 0) {
    int v4 = a3;
  }
  else {
    int v4 = -a3;
  }
  int v5 = *((_DWORD *)this + 4);
  if (v3 > v5 || v4 > v5) {
    return 0;
  }
  if (a3) {
    int v8 = v3;
  }
  else {
    int v8 = 0;
  }
  if (a3) {
    int v3 = v4;
  }
  return *(unsigned int *)(*((void *)this + 1) + 4 * (v3 - 1 + (v3 - 1) * v5 + v8));
}

_DWORD *ConvMap::subtract(_DWORD *this, int a2, int a3)
{
  if (a2)
  {
    uint64_t v4 = (uint64_t)this;
    *this -= a2;
    if (a3 >= 2)
    {
      unsigned int v5 = a3 >> 1;
      int v6 = (a3 >> 1) + 1;
      int v7 = 1;
      do
      {
        int v8 = 0;
        do
          this = (_DWORD *)ConvMap::subtract(v4, a2, v8++, v7);
        while (v6 != v8);
      }
      while (v7++ != v5);
    }
  }
  return this;
}

uint64_t ConvMap::bestValue(ConvMap *this, int a2, int a3, int a4)
{
  if (a4 >= 0) {
    int v8 = a4;
  }
  else {
    int v8 = a4 + 1;
  }
  uint64_t v9 = ConvMap::value(this, a2, a3);
  if (v9 && a4 != 1)
  {
    int v10 = v8 >> 1;
    if (a4 == 3)
    {
      int v11 = a3 - v10;
      int v12 = v10 + a3;
      if (v11 <= v12)
      {
        int v16 = 0;
        int v17 = a2 - v10;
        int v18 = v10 + a2;
        int v19 = (2 * v10) | 1;
        do
        {
          int v20 = v19;
          int v21 = v17;
          if (v17 <= v18)
          {
            do
            {
              if (v9 == ConvMap::value(this, v21, v11)) {
                ++v16;
              }
              ++v21;
              --v20;
            }
            while (v20);
          }
          BOOL v22 = v11++ == v12;
        }
        while (!v22);
        if (v16 <= 4) {
          return 0;
        }
        else {
          return v9;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      int v29 = 6 * a4 * a4 / 9;
      int v13 = a3 - v10;
      int v14 = v10 + a3;
      if (a3 - v10 <= v10 + a3)
      {
        int v15 = 0;
        int v23 = a2 - v10;
        int v24 = v10 + a2;
        int v25 = (2 * v10) | 1;
        do
        {
          int v26 = v25;
          int v27 = v23;
          if (v23 <= v24)
          {
            do
            {
              if (v9 == ConvMap::value(this, v27, v13)) {
                ++v15;
              }
              ++v27;
              --v26;
            }
            while (v26);
          }
          BOOL v22 = v13++ == v14;
        }
        while (!v22);
      }
      else
      {
        int v15 = 0;
      }
      if (v15 >= v29) {
        return v9;
      }
      else {
        return 0;
      }
    }
  }
  return v9;
}

uint64_t ConvMap::subtract(uint64_t this, int a2, int a3, int a4, int a5)
{
  if (a2)
  {
    int v5 = a5 >= 0 ? a5 : a5 + 1;
    int v6 = a4 - (v5 >> 1);
    int v7 = a4 + (v5 >> 1);
    if (v6 <= v7)
    {
      uint64_t v9 = this;
      int v10 = v5 >> 1;
      int v11 = a3 - v10;
      int v12 = v10 + a3;
      int v13 = (2 * v10) | 1;
      do
      {
        int v14 = v13;
        int v15 = v11;
        if (v11 <= v12)
        {
          do
          {
            this = ConvMap::subtract(v9, a2, v15++, v6);
            --v14;
          }
          while (v14);
        }
      }
      while (v6++ != v7);
    }
  }
  return this;
}

uint64_t ConvMap::subtract(uint64_t this, int a2, int a3, int a4)
{
  if (a2)
  {
    if (a4 | a3)
    {
      if (a4 >= 0) {
        int v4 = a4;
      }
      else {
        int v4 = a3;
      }
      if (a4 < 0) {
        int v5 = -a4;
      }
      else {
        int v5 = a3;
      }
      if (a3 < 0)
      {
        int v4 = -a3;
        int v5 = a4;
      }
      if ((a4 & a3) < 0)
      {
        int v4 = -a4;
        int v5 = -a3;
      }
      if (!v4)
      {
        int v4 = v5;
        int v5 = 0;
      }
      int v6 = *(_DWORD *)(this + 16);
      if (v5 <= v6 && v4 <= v6)
      {
        int v7 = v4 - 1 + (v4 - 1) * v6 + v5;
        *(_DWORD *)(*(void *)(this + 8) + 4 * v7) -= a2;
      }
    }
    else
    {
      *(_DWORD *)this -= a2;
    }
  }
  return this;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke(_OWORD *a1, double a2, double a3, double a4, double a5)
{
  long long v5 = a1[3];
  *(_OWORD *)&v7.CGFloat a = a1[2];
  *(_OWORD *)&v7.c = v5;
  *(_OWORD *)&v7.tdouble x = a1[4];
  CGRect v8 = CGRectApplyAffineTransform(*(CGRect *)&a2, &v7);
  *(void *)&double result = (unint64_t)CGRectInset(v8, -1.0, -1.0);
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_2(uint64_t a1, double a2, double a3, double a4, double a5)
{
  *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)-*(_DWORD *)(a1 + 32), (double)-*(_DWORD *)(a1 + 32));
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_3(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2) {
    *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&result, (float)-*(float *)(a1 + 32), (float)-*(float *)(a1 + 32));
  }
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_4(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2) {
    *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&result, (float)-*(float *)(a1 + 32), (float)-*(float *)(a1 + 32));
  }
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_5(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2) {
    *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&result, (float)-*(float *)(a1 + 32), (float)-*(float *)(a1 + 32));
  }
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_6(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2) {
    *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&result, (float)-*(float *)(a1 + 32), (float)-*(float *)(a1 + 32));
  }
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_7(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2) {
    *(void *)&double result = (unint64_t)CGRectInset(*(CGRect *)&result, (float)-*(float *)(a1 + 32), (float)-*(float *)(a1 + 32));
  }
  return result;
}

double cikernel::_downhalf(cikernel *this, SamplerObj *a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  float32x2_t v4 = vadd_f32(*DC, *DC);
  float32x2_t v5 = vadd_f32(v4, (float32x2_t)3212836864);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v11);
  float32x4_t v42 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v4, (float32x2_t)1065353216);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x2_t v20 = vadd_f32(v4, (float32x2_t)0x3F80000000000000);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v20, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v22) = *((_DWORD *)this + 6);
  v23.i32[0] = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v42;
  float32x4_t v43 = vaddq_f32(v42, v19);
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  float32x2_t v28 = vadd_f32(v4, (float32x2_t)0xBF80000000000000);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v28, 1), *((float *)this + 4), v28.f32[0]);
  LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = *((_DWORD *)this + 6);
  v31.i32[0] = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v28, 1), *(float *)v31.i32, v28.f32[0]);
  float64x2_t v34 = (float64x2_t)v43;
  float32x4_t v44 = vaddq_f32(v43, v27);
  v27.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v34, v30, v29, v31, v33, v32);
  __asm { FMOV            V1.4S, #0.25 }
  *(void *)&double result = vmulq_f32(vaddq_f32(v44, v35), _Q1).u64[0];
  return result;
}

double cikernel::_box3(cikernel *this, SamplerObj *a2, int8x16_t a3)
{
  int32x2_t v90 = *(int32x2_t *)a3.i8;
  *(float *)a3.i32 = -*(float *)a3.i32;
  int8x16_t v87 = a3;
  float32x2_t v4 = *(float32x2_t *)CI::getDC(this);
  float32x2_t v5 = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v87.i8, 0), v4);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v87);
  float32x2_t v12 = vadd_f32((float32x2_t)v87.u32[0], v4);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v12, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 6);
  v15.i32[0] = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v12, 1), *(float *)v15.i32, v12.f32[0]);
  float32x4_t v82 = vaddq_f32(v11, (float32x4_t)0);
  v11.f32[0] = *(float *)&v14 + *(float *)&v13;
  v11.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v11.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v16.i32 + *(float *)v17.i32), v14, v13, v15, v17, v16);
  HIDWORD(v19) = v90.i32[1];
  float32x2_t v20 = vadd_f32((float32x2_t)__PAIR64__(v90.u32[0], v87.u32[0]), v4);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v20, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v19) = *((_DWORD *)this + 6);
  v22.i32[0] = *((_DWORD *)this + 7);
  v23.i32[0] = *((_DWORD *)this + 9);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v20, 1), *(float *)v22.i32, v20.f32[0]);
  float64x2_t v25 = (float64x2_t)v82;
  float32x4_t v83 = vaddq_f32(v82, v18);
  v18.f32[0] = *(float *)&v19 + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v18.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v18.i64, v25, v19, v21, v22, v24, v23);
  float32x2_t v27 = vadd_f32((float32x2_t)vrev64_s32((int32x2_t)v87.u32[0]), v4);
  *(float *)&double v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v27, 1), *((float *)this + 4), v27.f32[0]);
  LODWORD(v29) = *((_DWORD *)this + 6);
  v30.i32[0] = *((_DWORD *)this + 7);
  v31.i32[0] = *((_DWORD *)this + 9);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v27, 1), *(float *)v30.i32, v27.f32[0]);
  float64x2_t v33 = (float64x2_t)v83;
  float32x4_t v84 = vaddq_f32(v83, v26);
  v26.f32[0] = *(float *)&v29 + *(float *)&v28;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v26.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v26.i64, v33, v29, v28, v30, v32, v31);
  float32x2_t v35 = vadd_f32(v4, 0);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v35, 1), *((float *)this + 4), v35.f32[0]);
  LODWORD(v37) = *((_DWORD *)this + 6);
  v38.i32[0] = *((_DWORD *)this + 7);
  v39.i32[0] = *((_DWORD *)this + 9);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v35, 1), *(float *)v38.i32, v35.f32[0]);
  float64x2_t v41 = (float64x2_t)v84;
  float32x4_t v85 = vaddq_f32(v84, v34);
  v34.f32[0] = *(float *)&v37 + *(float *)&v36;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v34.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v34.i64, v41, v37, v36, v38, v40, v39);
  v43.i32[0] = 0;
  HIDWORD(v44) = v90.i32[1];
  v43.i32[1] = v90.i32[0];
  float32x2_t v45 = vadd_f32(v43, v4);
  *(float *)&double v46 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v45, 1), *((float *)this + 4), v45.f32[0]);
  LODWORD(v44) = *((_DWORD *)this + 6);
  v47.i32[0] = *((_DWORD *)this + 7);
  v48.i32[0] = *((_DWORD *)this + 9);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v45, 1), *(float *)v47.i32, v45.f32[0]);
  float64x2_t v50 = (float64x2_t)v85;
  float32x4_t v86 = vaddq_f32(v85, v42);
  v42.f32[0] = *(float *)&v44 + *(float *)&v46;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v42.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v42.i64, v50, v44, v46, v47, v49, v48);
  HIDWORD(v52) = v87.i32[1];
  float32x2_t v53 = vadd_f32((float32x2_t)__PAIR64__(v87.u32[0], v90.u32[0]), v4);
  *(float *)&double v54 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v53, 1), *((float *)this + 4), v53.f32[0]);
  LODWORD(v52) = *((_DWORD *)this + 6);
  v55.i32[0] = *((_DWORD *)this + 7);
  v56.i32[0] = *((_DWORD *)this + 9);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v53, 1), *(float *)v55.i32, v53.f32[0]);
  float64x2_t v58 = (float64x2_t)v86;
  float32x4_t v88 = vaddq_f32(v86, v51);
  v51.f32[0] = *(float *)&v52 + *(float *)&v54;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v51.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v51.i64, v58, v52, v54, v55, v57, v56);
  *(void *)&double v60 = v90.u32[0];
  float32x2_t v61 = vadd_f32((float32x2_t)v90.u32[0], v4);
  *(float *)&double v62 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v61, 1), *((float *)this + 4), v61.f32[0]);
  LODWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = *((_DWORD *)this + 6);
  v63.i32[0] = *((_DWORD *)this + 7);
  v64.i32[0] = *((_DWORD *)this + 9);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v61, 1), *(float *)v63.i32, v61.f32[0]);
  float64x2_t v66 = (float64x2_t)v88;
  float32x4_t v89 = vaddq_f32(v88, v59);
  v59.f32[0] = *(float *)&v60 + *(float *)&v62;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v59.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v59.i64, v66, v60, v62, v63, v65, v64);
  float32x2_t v68 = vadd_f32((float32x2_t)vdup_lane_s32(v90, 0), v4);
  *(float *)&double v69 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v68, 1), *((float *)this + 4), v68.f32[0]);
  LODWORD(v7CI::NodeWithChildren::NodeWithChildren(this, 0) = *((_DWORD *)this + 6);
  v71.i32[0] = *((_DWORD *)this + 7);
  v72.i32[0] = *((_DWORD *)this + 9);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v68, 1), *(float *)v71.i32, v68.f32[0]);
  float64x2_t v74 = (float64x2_t)v89;
  float32x4_t v91 = vaddq_f32(v89, v67);
  v67.f32[0] = *(float *)&v70 + *(float *)&v69;
  *(float *)v74.f64 = *(float *)v72.i32 + *(float *)v73.i32;
  v67.f32[1] = *(float *)v72.i32 + *(float *)v73.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v67.i64, v74, v70, v69, v71, v73, v72);
  __asm { FMOV            V1.4S, #9.0 }
  *(void *)&double result = vdivq_f32(vaddq_f32(v91, v75), _Q1).u64[0];
  return result;
}

double cikernel::_add4(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  int8x8_t v7 = (int8x8_t)vneg_f32(a3);
  float32x2_t v8 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v9 = vadd_f32(a3, v8);
  *(float *)&double v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v9, 1), *(float *)(a2 + 16), v9.f32[0]);
  LODWORD(v11) = *(_DWORD *)(a2 + 28);
  v12.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v9, 1), *(float *)&v11, v9.f32[0]);
  v9.f32[0] = *(float *)(a2 + 24) + *(float *)&v10;
  *(float *)v14.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  v9.f32[1] = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v9, v14, v10, v11, v13, v12, v15);
  float32x2_t v17 = vadd_f32((float32x2_t)vext_s8((int8x8_t)a3, v7, 4uLL), v8);
  *(float *)&double v18 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v17, 1), *(float *)(a2 + 16), v17.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a2 + 24);
  v20.i32[0] = *(_DWORD *)(a2 + 28);
  v21.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v17, 1), *(float *)v20.i32, v17.f32[0]);
  float32x4_t v51 = vaddq_f32(v16, (float32x4_t)0);
  v16.f32[0] = *(float *)&v19 + *(float *)&v18;
  v16.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v16.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v21.i32 + *(float *)v22.i32), v19, v18, v20, v22, v21);
  float32x2_t v24 = vsub_f32(v8, a3);
  *(float *)&double v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v24, 1), *(float *)(a2 + 16), v24.f32[0]);
  LODWORD(v26) = *(_DWORD *)(a2 + 24);
  v27.i32[0] = *(_DWORD *)(a2 + 28);
  v28.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v24, 1), *(float *)v27.i32, v24.f32[0]);
  float64x2_t v30 = (float64x2_t)v51;
  float32x4_t v52 = vaddq_f32(v51, v23);
  v23.f32[0] = *(float *)&v26 + *(float *)&v25;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v23.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v23.i64, v30, v26, v25, v27, v29, v28);
  float32x2_t v32 = vadd_f32((float32x2_t)vext_s8(v7, (int8x8_t)a3, 4uLL), v8);
  *(float *)&double v33 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v32, 1), *(float *)(a2 + 16), v32.f32[0]);
  LODWORD(v34) = *(_DWORD *)(a2 + 24);
  v35.i32[0] = *(_DWORD *)(a2 + 28);
  v36.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v32, 1), *(float *)v35.i32, v32.f32[0]);
  float64x2_t v38 = (float64x2_t)v52;
  float32x4_t v53 = vaddq_f32(v52, v31);
  v31.f32[0] = *(float *)&v34 + *(float *)&v33;
  *(float *)v38.f64 = *(float *)v36.i32 + *(float *)v37.i32;
  v31.f32[1] = *(float *)v36.i32 + *(float *)v37.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v31.i64, v38, v34, v33, v35, v37, v36);
  float32x4_t v54 = vmulq_lane_f32(vaddq_f32(v53, v39), *(float32x2_t *)&a4, 1);
  uint64_t DC = (float32x2_t *)CI::getDC(v40);
  *(float *)&double v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v43) = *(_DWORD *)(a1 + 28);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v43, COERCE_FLOAT(*DC));
  *(float *)&double v46 = *(float *)(a1 + 24) + *(float *)&v42;
  *(float *)v47.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  *((float *)&v46 + 1) = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v46, v47, v42, v43, v45, v44, v48);
  *(void *)&double result = vaddq_f32(v54, vmulq_n_f32(v49, *(float *)&a4)).u64[0];
  return result;
}

double cikernel::_add8(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  int32x2_t v88 = (int32x2_t)vneg_f32(a3);
  float32x2_t v6 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v7 = vadd_f32(a3, v6);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v7, 1), *(float *)(a2 + 16), v7.f32[0]);
  LODWORD(v9) = *(_DWORD *)(a2 + 28);
  v10.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v12.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v7, v12, v8, v9, v11, v10, v13);
  HIDWORD(v15) = a3.i32[1];
  float32x2_t v16 = vadd_f32((float32x2_t)vext_s8((int8x8_t)a3, (int8x8_t)v88, 4uLL), v6);
  *(float *)&double v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v16, 1), *(float *)(a2 + 16), v16.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a2 + 24);
  v18.i32[0] = *(_DWORD *)(a2 + 28);
  v19.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v16, 1), *(float *)v18.i32, v16.f32[0]);
  float32x4_t v81 = vaddq_f32(v14, (float32x4_t)0);
  v14.f32[0] = *(float *)&v15 + *(float *)&v17;
  v14.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v14.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v19.i32 + *(float *)v20.i32), v15, v17, v18, v20, v19);
  float32x2_t v22 = vsub_f32(v6, a3);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v22, 1), *(float *)(a2 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a2 + 24);
  v25.i32[0] = *(_DWORD *)(a2 + 28);
  v26.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v22, 1), *(float *)v25.i32, v22.f32[0]);
  float64x2_t v28 = (float64x2_t)v81;
  float32x4_t v82 = vaddq_f32(v81, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v21.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v21.i64, v28, v24, v23, v25, v27, v26);
  HIDWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = a3.i32[1];
  float32x2_t v31 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v88, (int8x8_t)a3, 4uLL), v6);
  *(float *)&double v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v31, 1), *(float *)(a2 + 16), v31.f32[0]);
  LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a2 + 24);
  v33.i32[0] = *(_DWORD *)(a2 + 28);
  v34.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v31, 1), *(float *)v33.i32, v31.f32[0]);
  float64x2_t v36 = (float64x2_t)v82;
  float32x4_t v83 = vaddq_f32(v82, v29);
  v29.f32[0] = *(float *)&v30 + *(float *)&v32;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v29.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v29.i64, v36, v30, v32, v33, v35, v34);
  float32x2_t v38 = vadd_f32((float32x2_t)vrev64_s32((int32x2_t)a3), v6);
  *(float *)&double v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v38, 1), *(float *)(a2 + 16), v38.f32[0]);
  LODWORD(v4CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a2 + 24);
  v41.i32[0] = *(_DWORD *)(a2 + 28);
  v42.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v38, 1), *(float *)v41.i32, v38.f32[0]);
  float64x2_t v44 = (float64x2_t)v83;
  float32x4_t v84 = vaddq_f32(v83, v37);
  v37.f32[0] = *(float *)&v40 + *(float *)&v39;
  *(float *)v44.f64 = *(float *)v42.i32 + *(float *)v43.i32;
  v37.f32[1] = *(float *)v42.i32 + *(float *)v43.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v37.i64, v44, v40, v39, v41, v43, v42);
  HIDWORD(v46) = a3.i32[1];
  float32x2_t v47 = vadd_f32((float32x2_t)__PAIR64__(a3.u32[1], v88.u32[0]), v6);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v47, 1), *(float *)(a2 + 16), v47.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a2 + 24);
  v49.i32[0] = *(_DWORD *)(a2 + 28);
  v50.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v47, 1), *(float *)v49.i32, v47.f32[0]);
  float64x2_t v52 = (float64x2_t)v84;
  float32x4_t v85 = vaddq_f32(v84, v45);
  v45.f32[0] = *(float *)&v46 + *(float *)&v48;
  *(float *)v52.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v45.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v45.i64, v52, v46, v48, v49, v51, v50);
  float32x2_t v54 = vadd_f32((float32x2_t)vrev64_s32(v88), v6);
  *(float *)&double v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v54, 1), *(float *)(a2 + 16), v54.f32[0]);
  LODWORD(v56) = *(_DWORD *)(a2 + 24);
  v57.i32[0] = *(_DWORD *)(a2 + 28);
  v58.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v59.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v54, 1), *(float *)v57.i32, v54.f32[0]);
  float64x2_t v60 = (float64x2_t)v85;
  float32x4_t v86 = vaddq_f32(v85, v53);
  v53.f32[0] = *(float *)&v56 + *(float *)&v55;
  *(float *)v60.f64 = *(float *)v58.i32 + *(float *)v59.i32;
  v53.f32[1] = *(float *)v58.i32 + *(float *)v59.i32;
  *(double *)v61.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v53.i64, v60, v56, v55, v57, v59, v58);
  HIDWORD(v62) = v88.i32[1];
  float32x2_t v63 = vadd_f32((float32x2_t)__PAIR64__(v88.u32[1], a3.u32[0]), v6);
  *(float *)&double v64 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v63, 1), *(float *)(a2 + 16), v63.f32[0]);
  LODWORD(v62) = *(_DWORD *)(a2 + 24);
  v65.i32[0] = *(_DWORD *)(a2 + 28);
  v66.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v67.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v63, 1), *(float *)v65.i32, v63.f32[0]);
  float64x2_t v68 = (float64x2_t)v86;
  float32x4_t v90 = vaddq_f32(v86, v61);
  v61.f32[0] = *(float *)&v62 + *(float *)&v64;
  *(float *)v68.f64 = *(float *)v66.i32 + *(float *)v67.i32;
  v61.f32[1] = *(float *)v66.i32 + *(float *)v67.i32;
  *(double *)v69.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v61.i64, v68, v62, v64, v65, v67, v66);
  float32x4_t v91 = vmulq_lane_f32(vaddq_f32(v90, v69), *(float32x2_t *)&a4, 1);
  uint64_t DC = (float32x2_t *)CI::getDC(v70);
  *(float *)&double v72 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v73) = *(_DWORD *)(a1 + 28);
  v74.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v75.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v73, COERCE_FLOAT(*DC));
  *(float *)&double v76 = *(float *)(a1 + 24) + *(float *)&v72;
  *(float *)v77.f64 = *(float *)v74.i32 + *(float *)v75.i32;
  *((float *)&v76 + 1) = *(float *)v74.i32 + *(float *)v75.i32;
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v76, v77, v72, v73, v75, v74, v78);
  *(void *)&double result = vaddq_f32(v91, vmulq_n_f32(v79, *(float *)&a4)).u64[0];
  return result;
}

double cikernel::_add4and4(uint64_t a1, uint64_t a2, int8x16_t a3, float32x4_t a4)
{
  int8x16_t v89 = a3;
  int8x8_t v6 = (int8x8_t)vneg_f32(*(float32x2_t *)a3.i8);
  float32x2_t v7 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v8 = vadd_f32(*(float32x2_t *)v89.i8, v7);
  *(float *)&double v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v8, 1), *(float *)(a2 + 16), v8.f32[0]);
  LODWORD(v1CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a2 + 28);
  v11.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *(float *)(a2 + 24) + *(float *)&v9;
  *(float *)v13.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v8, v13, v9, v10, v12, v11, v14);
  float32x4_t v84 = v15;
  *(float32x2_t *)v15.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v89.i8, v6, 4uLL), v7);
  *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v15.f32, 1), *(float *)(a2 + 16), v15.f32[0]);
  LODWORD(v17) = *(_DWORD *)(a2 + 28);
  v18.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v15.f32, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *(float *)(a2 + 24) + *(float *)&v16;
  *(float *)v20.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v15.i64, v20, v16, v17, v19, v18, v21);
  float32x2_t v23 = vsub_f32(v7, *(float32x2_t *)v89.i8);
  *(float *)&double v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v23, 1), *(float *)(a2 + 16), v23.f32[0]);
  LODWORD(v25) = *(_DWORD *)(a2 + 24);
  v26.i32[0] = *(_DWORD *)(a2 + 28);
  v27.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v23, 1), *(float *)v26.i32, v23.f32[0]);
  float64x2_t v29 = (float64x2_t)v84;
  float32x4_t v85 = vaddq_f32(v84, v22);
  v22.f32[0] = *(float *)&v25 + *(float *)&v24;
  *(float *)v29.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v22.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v22.i64, v29, v25, v24, v26, v28, v27);
  float32x2_t v31 = vadd_f32((float32x2_t)vext_s8(v6, *(int8x8_t *)v89.i8, 4uLL), v7);
  *(float *)&double v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v31, 1), *(float *)(a2 + 16), v31.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a2 + 24);
  v34.i32[0] = *(_DWORD *)(a2 + 28);
  v35.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v31, 1), *(float *)v34.i32, v31.f32[0]);
  float64x2_t v37 = (float64x2_t)v85;
  float32x4_t v86 = vaddq_f32(v85, v30);
  v30.f32[0] = *(float *)&v33 + *(float *)&v32;
  *(float *)v37.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v30.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v30.i64, v37, v33, v32, v34, v36, v35);
  float32x2_t v39 = (float32x2_t)vextq_s8(v89, v89, 8uLL).u64[0];
  float32x2_t v40 = vadd_f32(v39, v7);
  float32x2_t v41 = v39;
  *(float32x2_t *)v89.i8 = v39;
  *(float *)&double v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v40, 1), *(float *)(a2 + 16), v40.f32[0]);
  v39.i32[0] = *(_DWORD *)(a2 + 24);
  v43.i32[0] = *(_DWORD *)(a2 + 28);
  v44.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v40, 1), *(float *)v43.i32, v40.f32[0]);
  float32x4_t v87 = vaddq_f32(vmulq_lane_f32(vaddq_f32(v86, v38), *(float32x2_t *)a4.f32, 1), (float32x4_t)0);
  int8x8_t v46 = (int8x8_t)vneg_f32(v41);
  v38.f32[0] = v39.f32[0] + *(float *)&v42;
  v38.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v38.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v44.i32 + *(float *)v45.i32), *(double *)&v39, v42, v43, v45, v44);
  float32x4_t v82 = v47;
  *(float32x2_t *)v47.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v89.i8, v46, 4uLL), v7);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v47.f32, 1), *(float *)(a2 + 16), v47.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a2 + 28);
  v50.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v47.f32, 1), *(float *)&v49, v47.f32[0]);
  v47.f32[0] = *(float *)(a2 + 24) + *(float *)&v48;
  *(float *)v52.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v47.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v47.i64, v52, v48, v49, v51, v50, v53);
  float32x2_t v55 = vsub_f32(v7, *(float32x2_t *)v89.i8);
  *(float *)&double v56 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v55, 1), *(float *)(a2 + 16), v55.f32[0]);
  LODWORD(v57) = *(_DWORD *)(a2 + 24);
  v58.i32[0] = *(_DWORD *)(a2 + 28);
  v59.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v55, 1), *(float *)v58.i32, v55.f32[0]);
  float64x2_t v61 = (float64x2_t)v82;
  float32x4_t v83 = vaddq_f32(v82, v54);
  v54.f32[0] = *(float *)&v57 + *(float *)&v56;
  *(float *)v61.f64 = *(float *)v59.i32 + *(float *)v60.i32;
  v54.f32[1] = *(float *)v59.i32 + *(float *)v60.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v54.i64, v61, v57, v56, v58, v60, v59);
  float32x2_t v63 = vadd_f32((float32x2_t)vext_s8(v46, *(int8x8_t *)v89.i8, 4uLL), v7);
  *(float *)&double v64 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v63, 1), *(float *)(a2 + 16), v63.f32[0]);
  LODWORD(v65) = *(_DWORD *)(a2 + 24);
  v66.i32[0] = *(_DWORD *)(a2 + 28);
  v67.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v68.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v63, 1), *(float *)v66.i32, v63.f32[0]);
  float64x2_t v69 = (float64x2_t)v83;
  float32x4_t v90 = vaddq_f32(v83, v62);
  v62.f32[0] = *(float *)&v65 + *(float *)&v64;
  *(float *)v69.f64 = *(float *)v67.i32 + *(float *)v68.i32;
  v62.f32[1] = *(float *)v67.i32 + *(float *)v68.i32;
  *(double *)v70.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v62.i64, v69, v65, v64, v66, v68, v67);
  float32x4_t v91 = vaddq_f32(v87, vmulq_laneq_f32(vaddq_f32(v90, v70), a4, 2));
  uint64_t DC = (float32x2_t *)CI::getDC(v71);
  *(float *)&double v73 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v74) = *(_DWORD *)(a1 + 28);
  v75.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v76.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v74, COERCE_FLOAT(*DC));
  *(float *)&double v77 = *(float *)(a1 + 24) + *(float *)&v73;
  *(float *)v78.f64 = *(float *)v75.i32 + *(float *)v76.i32;
  *((float *)&v77 + 1) = *(float *)v75.i32 + *(float *)v76.i32;
  *(double *)v80.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v77, v78, v73, v74, v76, v75, v79);
  *(void *)&double result = vaddq_f32(v91, vmulq_n_f32(v80, a4.f32[0])).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  int8x16_t v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  int v14 = *(_DWORD *)(v10 + 64);
  uint64_t v15 = *(void *)(v10 + 56);
  int v16 = *(_DWORD *)(v10 + 88);
  uint64_t v17 = *(void *)(v10 + 80);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 104)), a2);
  }
  int8x16_t v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x16_t v18 = (__n128 *)((char *)a2 + 64 * v17);
  }
  int8x16_t v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    int8x16_t v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v20 = v11(a4 + 80 * v12, a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_add4and8(uint64_t a1, uint64_t a2, int8x16_t a3, float32x4_t a4)
{
  int8x8_t v6 = (int8x8_t)vneg_f32(*(float32x2_t *)a3.i8);
  float32x2_t v7 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v8 = vadd_f32(*(float32x2_t *)a3.i8, v7);
  *(float *)&double v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v8, 1), *(float *)(a2 + 16), v8.f32[0]);
  LODWORD(v1CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a2 + 28);
  v11.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *(float *)(a2 + 24) + *(float *)&v9;
  *(float *)v13.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v8, v13, v9, v10, v12, v11, v14);
  float32x4_t v121 = v15;
  *(float32x2_t *)v15.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)a3.i8, v6, 4uLL), v7);
  *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v15.f32, 1), *(float *)(a2 + 16), v15.f32[0]);
  LODWORD(v17) = *(_DWORD *)(a2 + 28);
  v18.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v15.f32, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *(float *)(a2 + 24) + *(float *)&v16;
  *(float *)v20.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v15.i64, v20, v16, v17, v19, v18, v21);
  float32x2_t v23 = vsub_f32(v7, *(float32x2_t *)a3.i8);
  *(float *)&double v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v23, 1), *(float *)(a2 + 16), v23.f32[0]);
  LODWORD(v25) = *(_DWORD *)(a2 + 24);
  v26.i32[0] = *(_DWORD *)(a2 + 28);
  v27.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v23, 1), *(float *)v26.i32, v23.f32[0]);
  float64x2_t v29 = (float64x2_t)v121;
  float32x4_t v122 = vaddq_f32(v121, v22);
  v22.f32[0] = *(float *)&v25 + *(float *)&v24;
  *(float *)v29.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v22.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v22.i64, v29, v25, v24, v26, v28, v27);
  float32x2_t v31 = vadd_f32((float32x2_t)vext_s8(v6, *(int8x8_t *)a3.i8, 4uLL), v7);
  *(float *)&double v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v31, 1), *(float *)(a2 + 16), v31.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a2 + 24);
  v34.i32[0] = *(_DWORD *)(a2 + 28);
  v35.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v31, 1), *(float *)v34.i32, v31.f32[0]);
  float64x2_t v37 = (float64x2_t)v122;
  float32x4_t v123 = vaddq_f32(v122, v30);
  v30.f32[0] = *(float *)&v33 + *(float *)&v32;
  *(float *)v37.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v30.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v30.i64, v37, v33, v32, v34, v36, v35);
  int8x16_t v39 = vextq_s8(a3, a3, 8uLL);
  float32x2_t v40 = vadd_f32(*(float32x2_t *)v39.i8, v7);
  float32x2_t v41 = *(float32x2_t *)v39.i8;
  int8x16_t v125 = v39;
  *(float *)&double v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v40, 1), *(float *)(a2 + 16), v40.f32[0]);
  v39.i32[0] = *(_DWORD *)(a2 + 24);
  v43.i32[0] = *(_DWORD *)(a2 + 28);
  v44.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v40, 1), *(float *)v43.i32, v40.f32[0]);
  float32x4_t v119 = vaddq_f32(vmulq_lane_f32(vaddq_f32(v123, v38), *(float32x2_t *)a4.f32, 1), (float32x4_t)0);
  *(float32x2_t *)v123.f32 = vneg_f32(v41);
  v38.f32[0] = *(float *)v39.i32 + *(float *)&v42;
  v38.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v38.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v44.i32 + *(float *)v45.i32), *(double *)v39.i64, v42, v43, v45, v44);
  float32x4_t v113 = v46;
  float64x2_t v47 = (float64x2_t)v125;
  *(float32x2_t *)v46.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v125.i8, *(int8x8_t *)v123.f32, 4uLL), v7);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v46.f32, 1), *(float *)(a2 + 16), v46.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a2 + 28);
  v50.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v46.f32, 1), *(float *)&v49, v46.f32[0]);
  v46.f32[0] = *(float *)(a2 + 24) + *(float *)&v48;
  *(float *)v47.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v46.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v46.i64, v47, v48, v49, v51, v50, v52);
  float32x2_t v54 = vsub_f32(v7, *(float32x2_t *)v125.i8);
  *(float *)&double v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v54, 1), *(float *)(a2 + 16), v54.f32[0]);
  LODWORD(v56) = *(_DWORD *)(a2 + 24);
  v57.i32[0] = *(_DWORD *)(a2 + 28);
  v58.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v59.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v54, 1), *(float *)v57.i32, v54.f32[0]);
  float64x2_t v60 = (float64x2_t)v113;
  float32x4_t v114 = vaddq_f32(v113, v53);
  v53.f32[0] = *(float *)&v56 + *(float *)&v55;
  *(float *)v60.f64 = *(float *)v58.i32 + *(float *)v59.i32;
  v53.f32[1] = *(float *)v58.i32 + *(float *)v59.i32;
  *(double *)v61.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v53.i64, v60, v56, v55, v57, v59, v58);
  HIDWORD(v62) = v125.i32[1];
  float32x2_t v63 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v123.f32, *(int8x8_t *)v125.i8, 4uLL), v7);
  *(float *)&double v64 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v63, 1), *(float *)(a2 + 16), v63.f32[0]);
  LODWORD(v62) = *(_DWORD *)(a2 + 24);
  v65.i32[0] = *(_DWORD *)(a2 + 28);
  v66.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v67.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v63, 1), *(float *)v65.i32, v63.f32[0]);
  float64x2_t v68 = (float64x2_t)v114;
  float32x4_t v115 = vaddq_f32(v114, v61);
  v61.f32[0] = *(float *)&v62 + *(float *)&v64;
  *(float *)v68.f64 = *(float *)v66.i32 + *(float *)v67.i32;
  v61.f32[1] = *(float *)v66.i32 + *(float *)v67.i32;
  *(double *)v69.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v61.i64, v68, v62, v64, v65, v67, v66);
  float32x2_t v70 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v125.i8), v7);
  *(float *)&double v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v70, 1), *(float *)(a2 + 16), v70.f32[0]);
  LODWORD(v72) = *(_DWORD *)(a2 + 24);
  v73.i32[0] = *(_DWORD *)(a2 + 28);
  v74.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v75.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v70, 1), *(float *)v73.i32, v70.f32[0]);
  float64x2_t v76 = (float64x2_t)v115;
  float32x4_t v116 = vaddq_f32(v115, v69);
  v69.f32[0] = *(float *)&v72 + *(float *)&v71;
  *(float *)v76.f64 = *(float *)v74.i32 + *(float *)v75.i32;
  v69.f32[1] = *(float *)v74.i32 + *(float *)v75.i32;
  *(double *)v77.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v69.i64, v76, v72, v71, v73, v75, v74);
  HIDWORD(v7_Block_object_dispose(&STACK[0x3A0], 8) = v125.i32[1];
  float32x2_t v79 = vadd_f32((float32x2_t)__PAIR64__(v125.u32[1], v123.u32[0]), v7);
  *(float *)&double v80 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v79, 1), *(float *)(a2 + 16), v79.f32[0]);
  LODWORD(v7_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a2 + 24);
  v81.i32[0] = *(_DWORD *)(a2 + 28);
  v82.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v83.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v79, 1), *(float *)v81.i32, v79.f32[0]);
  float64x2_t v84 = (float64x2_t)v116;
  float32x4_t v117 = vaddq_f32(v116, v77);
  v77.f32[0] = *(float *)&v78 + *(float *)&v80;
  *(float *)v84.f64 = *(float *)v82.i32 + *(float *)v83.i32;
  v77.f32[1] = *(float *)v82.i32 + *(float *)v83.i32;
  *(double *)v85.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v77.i64, v84, v78, v80, v81, v83, v82);
  float32x2_t v86 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v123.f32), v7);
  *(float *)&double v87 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v86, 1), *(float *)(a2 + 16), v86.f32[0]);
  LODWORD(v8_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a2 + 24);
  v89.i32[0] = *(_DWORD *)(a2 + 28);
  v90.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v91.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v86, 1), *(float *)v89.i32, v86.f32[0]);
  float64x2_t v92 = (float64x2_t)v117;
  float32x4_t v118 = vaddq_f32(v117, v85);
  v85.f32[0] = *(float *)&v88 + *(float *)&v87;
  *(float *)v92.f64 = *(float *)v90.i32 + *(float *)v91.i32;
  v85.f32[1] = *(float *)v90.i32 + *(float *)v91.i32;
  *(double *)v93.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v85.i64, v92, v88, v87, v89, v91, v90);
  HIDWORD(v94) = v123.i32[1];
  float32x2_t v95 = vadd_f32((float32x2_t)__PAIR64__(v123.u32[1], v125.u32[0]), v7);
  *(float *)&double v96 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v95, 1), *(float *)(a2 + 16), v95.f32[0]);
  LODWORD(v94) = *(_DWORD *)(a2 + 24);
  v97.i32[0] = *(_DWORD *)(a2 + 28);
  v98.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v99.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v95, 1), *(float *)v97.i32, v95.f32[0]);
  float64x2_t v100 = (float64x2_t)v118;
  float32x4_t v126 = vaddq_f32(v118, v93);
  v93.f32[0] = *(float *)&v94 + *(float *)&v96;
  *(float *)v100.f64 = *(float *)v98.i32 + *(float *)v99.i32;
  v93.f32[1] = *(float *)v98.i32 + *(float *)v99.i32;
  *(double *)v101.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v93.i64, v100, v94, v96, v97, v99, v98);
  float32x4_t v127 = vaddq_f32(v119, vmulq_laneq_f32(vaddq_f32(v126, v101), a4, 2));
  uint64_t DC = (float32x2_t *)CI::getDC(v102);
  *(float *)&double v104 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v105) = *(_DWORD *)(a1 + 28);
  v106.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v107.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v105, COERCE_FLOAT(*DC));
  *(float *)&double v108 = *(float *)(a1 + 24) + *(float *)&v104;
  *(float *)v109.f64 = *(float *)v106.i32 + *(float *)v107.i32;
  *((float *)&v108 + 1) = *(float *)v106.i32 + *(float *)v107.i32;
  *(double *)v111.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v108, v109, v104, v105, v107, v106, v110);
  *(void *)&double result = vaddq_f32(v127, vmulq_n_f32(v111, a4.f32[0])).u64[0];
  return result;
}

double cikernel::_add8and8(uint64_t a1, uint64_t a2, __n128 a3, float32x4_t a4)
{
  int8x16_t v160 = (int8x16_t)a3;
  a3.n128_u64[0] = (unint64_t)vneg_f32((float32x2_t)a3.n128_u64[0]);
  __n128 v158 = a3;
  float32x2_t v6 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v7 = vadd_f32(*(float32x2_t *)v160.i8, v6);
  *(float *)&double v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v7, 1), *(float *)(a2 + 16), v7.f32[0]);
  LODWORD(v9) = *(_DWORD *)(a2 + 28);
  v10.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v12.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v7, v12, v8, v9, v11, v10, v13);
  float32x4_t v150 = v14;
  float64x2_t v15 = (float64x2_t)v158;
  *(float32x2_t *)v14.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v160.i8, (int8x8_t)v158.n128_u64[0], 4uLL), v6);
  *(float *)&double v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v14.f32, 1), *(float *)(a2 + 16), v14.f32[0]);
  LODWORD(v17) = *(_DWORD *)(a2 + 28);
  v18.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v14.f32, 1), *(float *)&v17, v14.f32[0]);
  v14.f32[0] = *(float *)(a2 + 24) + *(float *)&v16;
  *(float *)v15.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v14.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v14.i64, v15, v16, v17, v19, v18, v20);
  float32x2_t v22 = vsub_f32(v6, *(float32x2_t *)v160.i8);
  *(float *)&double v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v22, 1), *(float *)(a2 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a2 + 24);
  v25.i32[0] = *(_DWORD *)(a2 + 28);
  v26.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v22, 1), *(float *)v25.i32, v22.f32[0]);
  float64x2_t v28 = (float64x2_t)v150;
  float32x4_t v151 = vaddq_f32(v150, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v21.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v21.i64, v28, v24, v23, v25, v27, v26);
  HIDWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = v158.n128_u32[1];
  float32x2_t v31 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v158.n128_u64[0], *(int8x8_t *)v160.i8, 4uLL), v6);
  *(float *)&double v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v31, 1), *(float *)(a2 + 16), v31.f32[0]);
  LODWORD(v3CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a2 + 24);
  v33.i32[0] = *(_DWORD *)(a2 + 28);
  v34.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v31, 1), *(float *)v33.i32, v31.f32[0]);
  float64x2_t v36 = (float64x2_t)v151;
  float32x4_t v152 = vaddq_f32(v151, v29);
  v29.f32[0] = *(float *)&v30 + *(float *)&v32;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v29.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v29.i64, v36, v30, v32, v33, v35, v34);
  float32x2_t v38 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v160.i8), v6);
  *(float *)&double v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v38, 1), *(float *)(a2 + 16), v38.f32[0]);
  LODWORD(v4CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a2 + 24);
  v41.i32[0] = *(_DWORD *)(a2 + 28);
  v42.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v38, 1), *(float *)v41.i32, v38.f32[0]);
  float64x2_t v44 = (float64x2_t)v152;
  float32x4_t v153 = vaddq_f32(v152, v37);
  v37.f32[0] = *(float *)&v40 + *(float *)&v39;
  *(float *)v44.f64 = *(float *)v42.i32 + *(float *)v43.i32;
  v37.f32[1] = *(float *)v42.i32 + *(float *)v43.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v37.i64, v44, v40, v39, v41, v43, v42);
  HIDWORD(v46) = v160.i32[1];
  float32x2_t v47 = vadd_f32((float32x2_t)__PAIR64__(v160.u32[1], v158.n128_u32[0]), v6);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v47, 1), *(float *)(a2 + 16), v47.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a2 + 24);
  v49.i32[0] = *(_DWORD *)(a2 + 28);
  v50.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v47, 1), *(float *)v49.i32, v47.f32[0]);
  float64x2_t v52 = (float64x2_t)v153;
  float32x4_t v154 = vaddq_f32(v153, v45);
  v45.f32[0] = *(float *)&v46 + *(float *)&v48;
  *(float *)v52.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v45.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v45.i64, v52, v46, v48, v49, v51, v50);
  float32x2_t v54 = vadd_f32((float32x2_t)vrev64_s32((int32x2_t)v158.n128_u64[0]), v6);
  *(float *)&double v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v54, 1), *(float *)(a2 + 16), v54.f32[0]);
  LODWORD(v56) = *(_DWORD *)(a2 + 24);
  v57.i32[0] = *(_DWORD *)(a2 + 28);
  v58.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v59.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v54, 1), *(float *)v57.i32, v54.f32[0]);
  float64x2_t v60 = (float64x2_t)v154;
  float32x4_t v155 = vaddq_f32(v154, v53);
  v53.f32[0] = *(float *)&v56 + *(float *)&v55;
  *(float *)v60.f64 = *(float *)v58.i32 + *(float *)v59.i32;
  v53.f32[1] = *(float *)v58.i32 + *(float *)v59.i32;
  *(double *)v61.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v53.i64, v60, v56, v55, v57, v59, v58);
  HIDWORD(v62) = v158.n128_u32[1];
  float32x2_t v63 = vadd_f32((float32x2_t)__PAIR64__(v158.n128_u32[1], v160.u32[0]), v6);
  *(float *)&double v64 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v63, 1), *(float *)(a2 + 16), v63.f32[0]);
  LODWORD(v62) = *(_DWORD *)(a2 + 24);
  v65.i32[0] = *(_DWORD *)(a2 + 28);
  v66.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v67.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v63, 1), *(float *)v65.i32, v63.f32[0]);
  float64x2_t v68 = (float64x2_t)v155;
  float32x4_t v159 = vaddq_f32(v155, v61);
  v61.f32[0] = *(float *)&v62 + *(float *)&v64;
  *(float *)v68.f64 = *(float *)v66.i32 + *(float *)v67.i32;
  v61.f32[1] = *(float *)v66.i32 + *(float *)v67.i32;
  *(double *)v69.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v61.i64, v68, v62, v64, v65, v67, v66);
  int8x16_t v70 = vextq_s8(v160, v160, 8uLL);
  float32x2_t v71 = vadd_f32(*(float32x2_t *)v70.i8, v6);
  float32x2_t v72 = *(float32x2_t *)v70.i8;
  int8x16_t v161 = v70;
  *(float *)&double v73 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v71, 1), *(float *)(a2 + 16), v71.f32[0]);
  v70.i32[0] = *(_DWORD *)(a2 + 24);
  v74.i32[0] = *(_DWORD *)(a2 + 28);
  v75.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v76.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v71, 1), *(float *)v74.i32, v71.f32[0]);
  float32x4_t v156 = vaddq_f32(vmulq_lane_f32(vaddq_f32(v159, v69), *(float32x2_t *)a4.f32, 1), (float32x4_t)0);
  *(float32x2_t *)v159.f32 = vneg_f32(v72);
  v69.f32[0] = *(float *)v70.i32 + *(float *)&v73;
  v69.f32[1] = *(float *)v75.i32 + *(float *)v76.i32;
  *(double *)v77.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v69.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v75.i32 + *(float *)v76.i32), *(double *)v70.i64, v73, v74, v76, v75);
  float32x4_t v144 = v77;
  float64x2_t v78 = (float64x2_t)v161;
  *(float32x2_t *)v77.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v161.i8, *(int8x8_t *)v159.f32, 4uLL), v6);
  *(float *)&double v79 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v77.f32, 1), *(float *)(a2 + 16), v77.f32[0]);
  LODWORD(v8CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a2 + 28);
  v81.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v82.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v77.f32, 1), *(float *)&v80, v77.f32[0]);
  v77.f32[0] = *(float *)(a2 + 24) + *(float *)&v79;
  *(float *)v78.f64 = *(float *)v81.i32 + *(float *)v82.i32;
  v77.f32[1] = *(float *)v81.i32 + *(float *)v82.i32;
  *(double *)v84.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v77.i64, v78, v79, v80, v82, v81, v83);
  float32x2_t v85 = vsub_f32(v6, *(float32x2_t *)v161.i8);
  *(float *)&double v86 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v85, 1), *(float *)(a2 + 16), v85.f32[0]);
  LODWORD(v87) = *(_DWORD *)(a2 + 24);
  v88.i32[0] = *(_DWORD *)(a2 + 28);
  v89.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v90.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v85, 1), *(float *)v88.i32, v85.f32[0]);
  float64x2_t v91 = (float64x2_t)v144;
  float32x4_t v145 = vaddq_f32(v144, v84);
  v84.f32[0] = *(float *)&v87 + *(float *)&v86;
  *(float *)v91.f64 = *(float *)v89.i32 + *(float *)v90.i32;
  v84.f32[1] = *(float *)v89.i32 + *(float *)v90.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v84.i64, v91, v87, v86, v88, v90, v89);
  HIDWORD(v93) = v161.i32[1];
  float32x2_t v94 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v159.f32, *(int8x8_t *)v161.i8, 4uLL), v6);
  *(float *)&double v95 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v94, 1), *(float *)(a2 + 16), v94.f32[0]);
  LODWORD(v93) = *(_DWORD *)(a2 + 24);
  v96.i32[0] = *(_DWORD *)(a2 + 28);
  v97.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v98.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v94, 1), *(float *)v96.i32, v94.f32[0]);
  float64x2_t v99 = (float64x2_t)v145;
  float32x4_t v146 = vaddq_f32(v145, v92);
  v92.f32[0] = *(float *)&v93 + *(float *)&v95;
  *(float *)v99.f64 = *(float *)v97.i32 + *(float *)v98.i32;
  v92.f32[1] = *(float *)v97.i32 + *(float *)v98.i32;
  *(double *)v100.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v92.i64, v99, v93, v95, v96, v98, v97);
  float32x2_t v101 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v161.i8), v6);
  *(float *)&double v102 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v101, 1), *(float *)(a2 + 16), v101.f32[0]);
  LODWORD(v103) = *(_DWORD *)(a2 + 24);
  v104.i32[0] = *(_DWORD *)(a2 + 28);
  v105.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v106.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v101, 1), *(float *)v104.i32, v101.f32[0]);
  float64x2_t v107 = (float64x2_t)v146;
  float32x4_t v147 = vaddq_f32(v146, v100);
  v100.f32[0] = *(float *)&v103 + *(float *)&v102;
  *(float *)v107.f64 = *(float *)v105.i32 + *(float *)v106.i32;
  v100.f32[1] = *(float *)v105.i32 + *(float *)v106.i32;
  *(double *)v108.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v100.i64, v107, v103, v102, v104, v106, v105);
  HIDWORD(v109) = v161.i32[1];
  float32x2_t v110 = vadd_f32((float32x2_t)__PAIR64__(v161.u32[1], v159.u32[0]), v6);
  *(float *)&double v111 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v110, 1), *(float *)(a2 + 16), v110.f32[0]);
  LODWORD(v109) = *(_DWORD *)(a2 + 24);
  v112.i32[0] = *(_DWORD *)(a2 + 28);
  v113.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v114.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v110, 1), *(float *)v112.i32, v110.f32[0]);
  float64x2_t v115 = (float64x2_t)v147;
  float32x4_t v148 = vaddq_f32(v147, v108);
  v108.f32[0] = *(float *)&v109 + *(float *)&v111;
  *(float *)v115.f64 = *(float *)v113.i32 + *(float *)v114.i32;
  v108.f32[1] = *(float *)v113.i32 + *(float *)v114.i32;
  *(double *)v116.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v108.i64, v115, v109, v111, v112, v114, v113);
  float32x2_t v117 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v159.f32), v6);
  *(float *)&double v118 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v117, 1), *(float *)(a2 + 16), v117.f32[0]);
  LODWORD(v119) = *(_DWORD *)(a2 + 24);
  v120.i32[0] = *(_DWORD *)(a2 + 28);
  v121.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v122.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v117, 1), *(float *)v120.i32, v117.f32[0]);
  float64x2_t v123 = (float64x2_t)v148;
  float32x4_t v149 = vaddq_f32(v148, v116);
  v116.f32[0] = *(float *)&v119 + *(float *)&v118;
  *(float *)v123.f64 = *(float *)v121.i32 + *(float *)v122.i32;
  v116.f32[1] = *(float *)v121.i32 + *(float *)v122.i32;
  *(double *)v124.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v116.i64, v123, v119, v118, v120, v122, v121);
  HIDWORD(v125) = v159.i32[1];
  float32x2_t v126 = vadd_f32((float32x2_t)__PAIR64__(v159.u32[1], v161.u32[0]), v6);
  *(float *)&double v127 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v126, 1), *(float *)(a2 + 16), v126.f32[0]);
  LODWORD(v125) = *(_DWORD *)(a2 + 24);
  v128.i32[0] = *(_DWORD *)(a2 + 28);
  v129.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v130.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v126, 1), *(float *)v128.i32, v126.f32[0]);
  float64x2_t v131 = (float64x2_t)v149;
  float32x4_t v162 = vaddq_f32(v149, v124);
  v124.f32[0] = *(float *)&v125 + *(float *)&v127;
  *(float *)v131.f64 = *(float *)v129.i32 + *(float *)v130.i32;
  v124.f32[1] = *(float *)v129.i32 + *(float *)v130.i32;
  *(double *)v132.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v124.i64, v131, v125, v127, v128, v130, v129);
  float32x4_t v163 = vaddq_f32(v156, vmulq_laneq_f32(vaddq_f32(v162, v132), a4, 2));
  uint64_t DC = (float32x2_t *)CI::getDC(v133);
  *(float *)&double v135 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v136) = *(_DWORD *)(a1 + 28);
  v137.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v138.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v136, COERCE_FLOAT(*DC));
  *(float *)&double v139 = *(float *)(a1 + 24) + *(float *)&v135;
  *(float *)v140.f64 = *(float *)v137.i32 + *(float *)v138.i32;
  *((float *)&v139 + 1) = *(float *)v137.i32 + *(float *)v138.i32;
  *(double *)v142.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v139, v140, v135, v136, v138, v137, v141);
  *(void *)&double result = vaddq_f32(v163, vmulq_n_f32(v142, a4.f32[0])).u64[0];
  return result;
}

double cikernel::_ringAvg8(uint64_t a1, float32x2_t a2)
{
  int32x2_t v75 = (int32x2_t)vneg_f32(a2);
  float32x2_t v3 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v4 = vadd_f32(a2, v3);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v4, 1), *(float *)(a1 + 16), v4.f32[0]);
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  v7.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *(float *)(a1 + 24) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v4, v9, v5, v6, v8, v7, v10);
  HIDWORD(v12) = a2.i32[1];
  float32x2_t v13 = vadd_f32((float32x2_t)vext_s8((int8x8_t)a2, (int8x8_t)v75, 4uLL), v3);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v12) = *(_DWORD *)(a1 + 24);
  v15.i32[0] = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)v15.i32, v13.f32[0]);
  float32x4_t v69 = vaddq_f32(v11, (float32x4_t)0);
  v11.f32[0] = *(float *)&v12 + *(float *)&v14;
  v11.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v16.i32 + *(float *)v17.i32), v12, v14, v15, v17, v16);
  float32x2_t v19 = vsub_f32(v3, a2);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v19, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 24);
  v22.i32[0] = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v19, 1), *(float *)v22.i32, v19.f32[0]);
  float64x2_t v25 = (float64x2_t)v69;
  float32x4_t v70 = vaddq_f32(v69, v18);
  v18.f32[0] = *(float *)&v21 + *(float *)&v20;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v18.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v25, v21, v20, v22, v24, v23);
  HIDWORD(v27) = a2.i32[1];
  float32x2_t v28 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v75, (int8x8_t)a2, 4uLL), v3);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 24);
  v30.i32[0] = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v30.i32, v28.f32[0]);
  float64x2_t v33 = (float64x2_t)v70;
  float32x4_t v71 = vaddq_f32(v70, v26);
  v26.f32[0] = *(float *)&v27 + *(float *)&v29;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v26.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v33, v27, v29, v30, v32, v31);
  float32x2_t v35 = vadd_f32((float32x2_t)vrev64_s32((int32x2_t)a2), v3);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v35, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 24);
  v38.i32[0] = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v35, 1), *(float *)v38.i32, v35.f32[0]);
  float64x2_t v41 = (float64x2_t)v71;
  float32x4_t v72 = vaddq_f32(v71, v34);
  v34.f32[0] = *(float *)&v37 + *(float *)&v36;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v34.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v41, v37, v36, v38, v40, v39);
  HIDWORD(v43) = a2.i32[1];
  float32x2_t v44 = vadd_f32((float32x2_t)__PAIR64__(a2.u32[1], v75.u32[0]), v3);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v44, 1), *(float *)(a1 + 16), v44.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 24);
  v46.i32[0] = *(_DWORD *)(a1 + 28);
  v47.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v44, 1), *(float *)v46.i32, v44.f32[0]);
  float64x2_t v49 = (float64x2_t)v72;
  float32x4_t v73 = vaddq_f32(v72, v42);
  v42.f32[0] = *(float *)&v43 + *(float *)&v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v42.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v49, v43, v45, v46, v48, v47);
  float32x2_t v51 = vadd_f32((float32x2_t)vrev64_s32(v75), v3);
  *(float *)&double v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v51, 1), *(float *)(a1 + 16), v51.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a1 + 24);
  v54.i32[0] = *(_DWORD *)(a1 + 28);
  v55.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v51, 1), *(float *)v54.i32, v51.f32[0]);
  float64x2_t v57 = (float64x2_t)v73;
  float32x4_t v74 = vaddq_f32(v73, v50);
  v50.f32[0] = *(float *)&v53 + *(float *)&v52;
  *(float *)v57.f64 = *(float *)v55.i32 + *(float *)v56.i32;
  v50.f32[1] = *(float *)v55.i32 + *(float *)v56.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v50.i64, v57, v53, v52, v54, v56, v55);
  HIDWORD(v59) = v75.i32[1];
  float32x2_t v60 = vadd_f32((float32x2_t)__PAIR64__(v75.u32[1], a2.u32[0]), v3);
  *(float *)&double v61 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v60, 1), *(float *)(a1 + 16), v60.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 24);
  v62.i32[0] = *(_DWORD *)(a1 + 28);
  v63.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v64.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v60, 1), *(float *)v62.i32, v60.f32[0]);
  float64x2_t v65 = (float64x2_t)v74;
  float32x4_t v77 = vaddq_f32(v74, v58);
  v58.f32[0] = *(float *)&v59 + *(float *)&v61;
  *(float *)v65.f64 = *(float *)v63.i32 + *(float *)v64.i32;
  v58.f32[1] = *(float *)v63.i32 + *(float *)v64.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v65, v59, v61, v62, v64, v63);
  v67.i64[0] = 0x3E0000003E000000;
  v67.i64[1] = 0x3E0000003E000000;
  *(void *)&double result = vmulq_f32(vaddq_f32(v77, v66), v67).u64[0];
  return result;
}

double cikernel::_ringAvg16(uint64_t a1, int8x16_t a2)
{
  int8x16_t v147 = a2;
  int32x2_t v145 = (int32x2_t)vneg_f32(*(float32x2_t *)a2.i8);
  float32x2_t v3 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v4 = vadd_f32(*(float32x2_t *)v147.i8, v3);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v4, 1), *(float *)(a1 + 16), v4.f32[0]);
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  v7.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *(float *)(a1 + 24) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v4, v9, v5, v6, v8, v7, v10);
  HIDWORD(v12) = v145.i32[1];
  float32x2_t v13 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v147.i8, (int8x8_t)v145, 4uLL), v3);
  *(float *)&double v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v12) = *(_DWORD *)(a1 + 24);
  v15.i32[0] = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)v15.i32, v13.f32[0]);
  float32x4_t v132 = vaddq_f32(v11, (float32x4_t)0);
  v11.f32[0] = *(float *)&v12 + *(float *)&v14;
  v11.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v16.i32 + *(float *)v17.i32), v12, v14, v15, v17, v16);
  float32x2_t v19 = vsub_f32(v3, *(float32x2_t *)v147.i8);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v19, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 24);
  v22.i32[0] = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v19, 1), *(float *)v22.i32, v19.f32[0]);
  float64x2_t v25 = (float64x2_t)v132;
  float32x4_t v133 = vaddq_f32(v132, v18);
  v18.f32[0] = *(float *)&v21 + *(float *)&v20;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v18.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v25, v21, v20, v22, v24, v23);
  HIDWORD(v27) = v145.i32[1];
  float32x2_t v28 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v145, *(int8x8_t *)v147.i8, 4uLL), v3);
  *(float *)&double v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 24);
  v30.i32[0] = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v30.i32, v28.f32[0]);
  float64x2_t v33 = (float64x2_t)v133;
  float32x4_t v134 = vaddq_f32(v133, v26);
  v26.f32[0] = *(float *)&v27 + *(float *)&v29;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v26.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v33, v27, v29, v30, v32, v31);
  float32x2_t v35 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v147.i8), v3);
  *(float *)&double v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v35, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 24);
  v38.i32[0] = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v35, 1), *(float *)v38.i32, v35.f32[0]);
  float64x2_t v41 = (float64x2_t)v134;
  float32x4_t v135 = vaddq_f32(v134, v34);
  v34.f32[0] = *(float *)&v37 + *(float *)&v36;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v34.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v41, v37, v36, v38, v40, v39);
  HIDWORD(v43) = v147.i32[1];
  float32x2_t v44 = vadd_f32((float32x2_t)__PAIR64__(v147.u32[1], v145.u32[0]), v3);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v44, 1), *(float *)(a1 + 16), v44.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 24);
  v46.i32[0] = *(_DWORD *)(a1 + 28);
  v47.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v44, 1), *(float *)v46.i32, v44.f32[0]);
  float64x2_t v49 = (float64x2_t)v135;
  float32x4_t v136 = vaddq_f32(v135, v42);
  v42.f32[0] = *(float *)&v43 + *(float *)&v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v42.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v49, v43, v45, v46, v48, v47);
  float32x2_t v51 = vadd_f32((float32x2_t)vrev64_s32(v145), v3);
  *(float *)&double v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v51, 1), *(float *)(a1 + 16), v51.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a1 + 24);
  v54.i32[0] = *(_DWORD *)(a1 + 28);
  v55.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v51, 1), *(float *)v54.i32, v51.f32[0]);
  float64x2_t v57 = (float64x2_t)v136;
  float32x4_t v137 = vaddq_f32(v136, v50);
  v50.f32[0] = *(float *)&v53 + *(float *)&v52;
  *(float *)v57.f64 = *(float *)v55.i32 + *(float *)v56.i32;
  v50.f32[1] = *(float *)v55.i32 + *(float *)v56.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v50.i64, v57, v53, v52, v54, v56, v55);
  HIDWORD(v59) = v145.i32[1];
  float32x2_t v60 = vadd_f32((float32x2_t)__PAIR64__(v145.u32[1], v147.u32[0]), v3);
  *(float *)&double v61 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v60, 1), *(float *)(a1 + 16), v60.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 24);
  v62.i32[0] = *(_DWORD *)(a1 + 28);
  v63.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v64.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v60, 1), *(float *)v62.i32, v60.f32[0]);
  float64x2_t v65 = (float64x2_t)v137;
  float32x4_t v146 = vaddq_f32(v137, v58);
  v58.f32[0] = *(float *)&v59 + *(float *)&v61;
  *(float *)v65.f64 = *(float *)v63.i32 + *(float *)v64.i32;
  v58.f32[1] = *(float *)v63.i32 + *(float *)v64.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v65, v59, v61, v62, v64, v63);
  float32x2_t v67 = (float32x2_t)vextq_s8(v147, v147, 8uLL).u64[0];
  float32x2_t v68 = vadd_f32(v67, v3);
  float32x2_t v69 = v67;
  *(float32x2_t *)v147.i8 = v67;
  *(float *)&double v70 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v68, 1), *(float *)(a1 + 16), v68.f32[0]);
  v67.i32[0] = *(_DWORD *)(a1 + 24);
  v71.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v68, 1), *(float *)(a1 + 28), v68.f32[0]);
  float64x2_t v73 = (float64x2_t)v146;
  float32x4_t v138 = vaddq_f32(v146, v66);
  *(float32x2_t *)v146.f32 = vneg_f32(v69);
  v66.f32[0] = v67.f32[0] + *(float *)&v70;
  *(float *)v73.f64 = *(float *)v71.i32 + *(float *)v72.i32;
  v66.f32[1] = *(float *)v71.i32 + *(float *)v72.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v66.i64, v73, *(double *)&v67, v70, (int8x16_t)v138, v72, v71);
  HIDWORD(v75) = v147.i32[1];
  float32x2_t v76 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v147.i8, *(int8x8_t *)v146.f32, 4uLL), v3);
  *(float *)&double v77 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v76, 1), *(float *)(a1 + 16), v76.f32[0]);
  LODWORD(v75) = *(_DWORD *)(a1 + 24);
  v78.i32[0] = *(_DWORD *)(a1 + 28);
  v79.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v80.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v76, 1), *(float *)v78.i32, v76.f32[0]);
  float64x2_t v81 = (float64x2_t)v138;
  float32x4_t v139 = vaddq_f32(v138, v74);
  v74.f32[0] = *(float *)&v75 + *(float *)&v77;
  *(float *)v81.f64 = *(float *)v79.i32 + *(float *)v80.i32;
  v74.f32[1] = *(float *)v79.i32 + *(float *)v80.i32;
  *(double *)v82.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v74.i64, v81, v75, v77, v78, v80, v79);
  float32x2_t v83 = vsub_f32(v3, *(float32x2_t *)v147.i8);
  *(float *)&double v84 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v83, 1), *(float *)(a1 + 16), v83.f32[0]);
  LODWORD(v85) = *(_DWORD *)(a1 + 24);
  v86.i32[0] = *(_DWORD *)(a1 + 28);
  v87.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v88.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v83, 1), *(float *)v86.i32, v83.f32[0]);
  float64x2_t v89 = (float64x2_t)v139;
  float32x4_t v140 = vaddq_f32(v139, v82);
  v82.f32[0] = *(float *)&v85 + *(float *)&v84;
  *(float *)v89.f64 = *(float *)v87.i32 + *(float *)v88.i32;
  v82.f32[1] = *(float *)v87.i32 + *(float *)v88.i32;
  *(double *)v90.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v82.i64, v89, v85, v84, v86, v88, v87);
  HIDWORD(v91) = v147.i32[1];
  float32x2_t v92 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v146.f32, *(int8x8_t *)v147.i8, 4uLL), v3);
  *(float *)&double v93 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v92, 1), *(float *)(a1 + 16), v92.f32[0]);
  LODWORD(v91) = *(_DWORD *)(a1 + 24);
  v94.i32[0] = *(_DWORD *)(a1 + 28);
  v95.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v96.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v92, 1), *(float *)v94.i32, v92.f32[0]);
  float64x2_t v97 = (float64x2_t)v140;
  float32x4_t v141 = vaddq_f32(v140, v90);
  v90.f32[0] = *(float *)&v91 + *(float *)&v93;
  *(float *)v97.f64 = *(float *)v95.i32 + *(float *)v96.i32;
  v90.f32[1] = *(float *)v95.i32 + *(float *)v96.i32;
  *(double *)v98.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v90.i64, v97, v91, v93, v94, v96, v95);
  float32x2_t v99 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v147.i8), v3);
  *(float *)&double v100 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v99, 1), *(float *)(a1 + 16), v99.f32[0]);
  LODWORD(v101) = *(_DWORD *)(a1 + 24);
  v102.i32[0] = *(_DWORD *)(a1 + 28);
  v103.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v104.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v99, 1), *(float *)v102.i32, v99.f32[0]);
  float64x2_t v105 = (float64x2_t)v141;
  float32x4_t v142 = vaddq_f32(v141, v98);
  v98.f32[0] = *(float *)&v101 + *(float *)&v100;
  *(float *)v105.f64 = *(float *)v103.i32 + *(float *)v104.i32;
  v98.f32[1] = *(float *)v103.i32 + *(float *)v104.i32;
  *(double *)v106.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v98.i64, v105, v101, v100, v102, v104, v103);
  HIDWORD(v107) = v147.i32[1];
  float32x2_t v108 = vadd_f32((float32x2_t)__PAIR64__(v147.u32[1], v146.u32[0]), v3);
  *(float *)&double v109 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v108, 1), *(float *)(a1 + 16), v108.f32[0]);
  LODWORD(v107) = *(_DWORD *)(a1 + 24);
  v110.i32[0] = *(_DWORD *)(a1 + 28);
  v111.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v112.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v108, 1), *(float *)v110.i32, v108.f32[0]);
  float64x2_t v113 = (float64x2_t)v142;
  float32x4_t v143 = vaddq_f32(v142, v106);
  v106.f32[0] = *(float *)&v107 + *(float *)&v109;
  *(float *)v113.f64 = *(float *)v111.i32 + *(float *)v112.i32;
  v106.f32[1] = *(float *)v111.i32 + *(float *)v112.i32;
  *(double *)v114.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v106.i64, v113, v107, v109, v110, v112, v111);
  float32x2_t v115 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v146.f32), v3);
  *(float *)&double v116 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v115, 1), *(float *)(a1 + 16), v115.f32[0]);
  LODWORD(v117) = *(_DWORD *)(a1 + 24);
  v118.i32[0] = *(_DWORD *)(a1 + 28);
  v119.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v120.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v115, 1), *(float *)v118.i32, v115.f32[0]);
  float64x2_t v121 = (float64x2_t)v143;
  float32x4_t v144 = vaddq_f32(v143, v114);
  v114.f32[0] = *(float *)&v117 + *(float *)&v116;
  *(float *)v121.f64 = *(float *)v119.i32 + *(float *)v120.i32;
  v114.f32[1] = *(float *)v119.i32 + *(float *)v120.i32;
  *(double *)v122.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v114.i64, v121, v117, v116, v118, v120, v119);
  HIDWORD(v123) = v146.i32[1];
  float32x2_t v124 = vadd_f32((float32x2_t)__PAIR64__(v146.u32[1], v147.u32[0]), v3);
  *(float *)&double v125 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v124, 1), *(float *)(a1 + 16), v124.f32[0]);
  LODWORD(v123) = *(_DWORD *)(a1 + 24);
  v126.i32[0] = *(_DWORD *)(a1 + 28);
  v127.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v128.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v124, 1), *(float *)v126.i32, v124.f32[0]);
  float64x2_t v129 = (float64x2_t)v144;
  float32x4_t v148 = vaddq_f32(v144, v122);
  v122.f32[0] = *(float *)&v123 + *(float *)&v125;
  *(float *)v129.f64 = *(float *)v127.i32 + *(float *)v128.i32;
  v122.f32[1] = *(float *)v127.i32 + *(float *)v128.i32;
  *(double *)v130.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v122.i64, v129, v123, v125, v126, v128, v127);
  *(void *)&double result = vmulq_f32(vaddq_f32(v148, v130), (float32x4_t)vdupq_n_s32(0x3D800000u)).u64[0];
  return result;
}

double cikernel::_ringAvg24(uint64_t a1, int8x16_t a2, float32x2_t a3)
{
  int8x16_t v225 = a2;
  int32x2_t v215 = (int32x2_t)vneg_f32(*(float32x2_t *)a2.i8);
  float32x2_t v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v5 = vadd_f32(*(float32x2_t *)v225.i8, v4);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v10, v6, v7, v9, v8, v11);
  HIDWORD(v13) = v215.i32[1];
  float32x2_t v14 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v225.i8, (int8x8_t)v215, 4uLL), v4);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 24);
  v16.i32[0] = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)v16.i32, v14.f32[0]);
  float32x4_t v202 = vaddq_f32(v12, (float32x4_t)0);
  v12.f32[0] = *(float *)&v13 + *(float *)&v15;
  v12.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v17.i32 + *(float *)v18.i32), v13, v15, v16, v18, v17);
  float32x2_t v20 = vsub_f32(v4, *(float32x2_t *)v225.i8);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 24);
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v202;
  float32x4_t v203 = vaddq_f32(v202, v19);
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  HIDWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = v215.i32[1];
  float32x2_t v29 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v215, *(int8x8_t *)v225.i8, 4uLL), v4);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v29, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v29, 1), *(float *)v31.i32, v29.f32[0]);
  float64x2_t v34 = (float64x2_t)v203;
  float32x4_t v204 = vaddq_f32(v203, v27);
  v27.f32[0] = *(float *)&v28 + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v34, v28, v30, v31, v33, v32);
  float32x2_t v36 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v225.i8), v4);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v36, 1), *(float *)(a1 + 16), v36.f32[0]);
  LODWORD(v3_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v39.i32[0] = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v36, 1), *(float *)v39.i32, v36.f32[0]);
  float64x2_t v42 = (float64x2_t)v204;
  float32x4_t v205 = vaddq_f32(v204, v35);
  v35.f32[0] = *(float *)&v38 + *(float *)&v37;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v35.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v42, v38, v37, v39, v41, v40);
  HIDWORD(v44) = v225.i32[1];
  float32x2_t v45 = vadd_f32((float32x2_t)__PAIR64__(v225.u32[1], v215.u32[0]), v4);
  *(float *)&double v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v45, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a1 + 24);
  v47.i32[0] = *(_DWORD *)(a1 + 28);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v45, 1), *(float *)v47.i32, v45.f32[0]);
  float64x2_t v50 = (float64x2_t)v205;
  float32x4_t v206 = vaddq_f32(v205, v43);
  v43.f32[0] = *(float *)&v44 + *(float *)&v46;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v43.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v50, v44, v46, v47, v49, v48);
  float32x2_t v52 = vadd_f32((float32x2_t)vrev64_s32(v215), v4);
  *(float *)&double v53 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v52, 1), *(float *)(a1 + 16), v52.f32[0]);
  LODWORD(v54) = *(_DWORD *)(a1 + 24);
  v55.i32[0] = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v52, 1), *(float *)v55.i32, v52.f32[0]);
  float64x2_t v58 = (float64x2_t)v206;
  float32x4_t v207 = vaddq_f32(v206, v51);
  v51.f32[0] = *(float *)&v54 + *(float *)&v53;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v51.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v51.i64, v58, v54, v53, v55, v57, v56);
  HIDWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = v215.i32[1];
  float32x2_t v61 = vadd_f32((float32x2_t)__PAIR64__(v215.u32[1], v225.u32[0]), v4);
  *(float *)&double v62 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v61, 1), *(float *)(a1 + 16), v61.f32[0]);
  LODWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v63.i32[0] = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v61, 1), *(float *)v63.i32, v61.f32[0]);
  float64x2_t v66 = (float64x2_t)v207;
  float32x4_t v216 = vaddq_f32(v207, v59);
  v59.f32[0] = *(float *)&v60 + *(float *)&v62;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v59.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v59.i64, v66, v60, v62, v63, v65, v64);
  float32x2_t v68 = (float32x2_t)vextq_s8(v225, v225, 8uLL).u64[0];
  float32x2_t v69 = vadd_f32(v68, v4);
  float32x2_t v70 = v68;
  *(float32x2_t *)v225.i8 = v68;
  *(float *)&double v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v69, 1), *(float *)(a1 + 16), v69.f32[0]);
  v68.i32[0] = *(_DWORD *)(a1 + 24);
  v72.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v69, 1), *(float *)(a1 + 28), v69.f32[0]);
  float64x2_t v74 = (float64x2_t)v216;
  float32x4_t v208 = vaddq_f32(v216, v67);
  *(float32x2_t *)v216.f32 = vneg_f32(v70);
  v67.f32[0] = v68.f32[0] + *(float *)&v71;
  *(float *)v74.f64 = *(float *)v72.i32 + *(float *)v73.i32;
  v67.f32[1] = *(float *)v72.i32 + *(float *)v73.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v67.i64, v74, *(double *)&v68, v71, (int8x16_t)v208, v73, v72);
  HIDWORD(v76) = v225.i32[1];
  float32x2_t v77 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v225.i8, *(int8x8_t *)v216.f32, 4uLL), v4);
  *(float *)&double v78 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v77, 1), *(float *)(a1 + 16), v77.f32[0]);
  LODWORD(v76) = *(_DWORD *)(a1 + 24);
  v79.i32[0] = *(_DWORD *)(a1 + 28);
  v80.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v81.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v77, 1), *(float *)v79.i32, v77.f32[0]);
  float64x2_t v82 = (float64x2_t)v208;
  float32x4_t v209 = vaddq_f32(v208, v75);
  v75.f32[0] = *(float *)&v76 + *(float *)&v78;
  *(float *)v82.f64 = *(float *)v80.i32 + *(float *)v81.i32;
  v75.f32[1] = *(float *)v80.i32 + *(float *)v81.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v75.i64, v82, v76, v78, v79, v81, v80);
  float32x2_t v84 = vsub_f32(v4, *(float32x2_t *)v225.i8);
  *(float *)&double v85 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v84, 1), *(float *)(a1 + 16), v84.f32[0]);
  LODWORD(v86) = *(_DWORD *)(a1 + 24);
  v87.i32[0] = *(_DWORD *)(a1 + 28);
  v88.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v84, 1), *(float *)v87.i32, v84.f32[0]);
  float64x2_t v90 = (float64x2_t)v209;
  float32x4_t v210 = vaddq_f32(v209, v83);
  v83.f32[0] = *(float *)&v86 + *(float *)&v85;
  *(float *)v90.f64 = *(float *)v88.i32 + *(float *)v89.i32;
  v83.f32[1] = *(float *)v88.i32 + *(float *)v89.i32;
  *(double *)v91.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v90, v86, v85, v87, v89, v88);
  HIDWORD(v92) = v225.i32[1];
  float32x2_t v93 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v216.f32, *(int8x8_t *)v225.i8, 4uLL), v4);
  *(float *)&double v94 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v93, 1), *(float *)(a1 + 16), v93.f32[0]);
  LODWORD(v92) = *(_DWORD *)(a1 + 24);
  v95.i32[0] = *(_DWORD *)(a1 + 28);
  v96.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v97.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v93, 1), *(float *)v95.i32, v93.f32[0]);
  float64x2_t v98 = (float64x2_t)v210;
  float32x4_t v211 = vaddq_f32(v210, v91);
  v91.f32[0] = *(float *)&v92 + *(float *)&v94;
  *(float *)v98.f64 = *(float *)v96.i32 + *(float *)v97.i32;
  v91.f32[1] = *(float *)v96.i32 + *(float *)v97.i32;
  *(double *)v99.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v91.i64, v98, v92, v94, v95, v97, v96);
  float32x2_t v100 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v225.i8), v4);
  *(float *)&double v101 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v100, 1), *(float *)(a1 + 16), v100.f32[0]);
  LODWORD(v102) = *(_DWORD *)(a1 + 24);
  v103.i32[0] = *(_DWORD *)(a1 + 28);
  v104.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v105.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v100, 1), *(float *)v103.i32, v100.f32[0]);
  float64x2_t v106 = (float64x2_t)v211;
  float32x4_t v212 = vaddq_f32(v211, v99);
  v99.f32[0] = *(float *)&v102 + *(float *)&v101;
  *(float *)v106.f64 = *(float *)v104.i32 + *(float *)v105.i32;
  v99.f32[1] = *(float *)v104.i32 + *(float *)v105.i32;
  *(double *)v107.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v99.i64, v106, v102, v101, v103, v105, v104);
  HIDWORD(v10_Block_object_dispose(&STACK[0x3A0], 8) = v225.i32[1];
  float32x2_t v109 = vadd_f32((float32x2_t)__PAIR64__(v225.u32[1], v216.u32[0]), v4);
  *(float *)&double v110 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v109, 1), *(float *)(a1 + 16), v109.f32[0]);
  LODWORD(v10_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v111.i32[0] = *(_DWORD *)(a1 + 28);
  v112.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v113.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v109, 1), *(float *)v111.i32, v109.f32[0]);
  float64x2_t v114 = (float64x2_t)v212;
  float32x4_t v213 = vaddq_f32(v212, v107);
  v107.f32[0] = *(float *)&v108 + *(float *)&v110;
  *(float *)v114.f64 = *(float *)v112.i32 + *(float *)v113.i32;
  v107.f32[1] = *(float *)v112.i32 + *(float *)v113.i32;
  *(double *)v115.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v107.i64, v114, v108, v110, v111, v113, v112);
  float32x2_t v116 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v216.f32), v4);
  *(float *)&double v117 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v116, 1), *(float *)(a1 + 16), v116.f32[0]);
  LODWORD(v11_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v119.i32[0] = *(_DWORD *)(a1 + 28);
  v120.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v121.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v116, 1), *(float *)v119.i32, v116.f32[0]);
  float64x2_t v122 = (float64x2_t)v213;
  float32x4_t v214 = vaddq_f32(v213, v115);
  v115.f32[0] = *(float *)&v118 + *(float *)&v117;
  *(float *)v122.f64 = *(float *)v120.i32 + *(float *)v121.i32;
  v115.f32[1] = *(float *)v120.i32 + *(float *)v121.i32;
  *(double *)v123.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v115.i64, v122, v118, v117, v119, v121, v120);
  HIDWORD(v124) = v216.i32[1];
  float32x2_t v125 = vadd_f32((float32x2_t)__PAIR64__(v216.u32[1], v225.u32[0]), v4);
  *(float *)&double v126 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v125, 1), *(float *)(a1 + 16), v125.f32[0]);
  LODWORD(v124) = *(_DWORD *)(a1 + 24);
  v127.i32[0] = *(_DWORD *)(a1 + 28);
  v128.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v129.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v125, 1), *(float *)v127.i32, v125.f32[0]);
  float64x2_t v130 = (float64x2_t)v214;
  float32x4_t v226 = vaddq_f32(v214, v123);
  v123.f32[0] = *(float *)&v124 + *(float *)&v126;
  *(float *)v130.f64 = *(float *)v128.i32 + *(float *)v129.i32;
  v123.f32[1] = *(float *)v128.i32 + *(float *)v129.i32;
  *(double *)v131.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v123.i64, v130, v124, v126, v127, v129, v128);
  float32x2_t v132 = vadd_f32(a3, v4);
  *(float *)&double v133 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v132, 1), *(float *)(a1 + 16), v132.f32[0]);
  LODWORD(v134) = *(_DWORD *)(a1 + 24);
  v135.i32[0] = *(_DWORD *)(a1 + 28);
  v136.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v137.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v132, 1), *(float *)v135.i32, v132.f32[0]);
  float64x2_t v138 = (float64x2_t)v226;
  float32x4_t v217 = vaddq_f32(v226, v131);
  *(float32x2_t *)v226.f32 = vneg_f32(a3);
  v131.f32[0] = *(float *)&v134 + *(float *)&v133;
  *(float *)v138.f64 = *(float *)v136.i32 + *(float *)v137.i32;
  v131.f32[1] = *(float *)v136.i32 + *(float *)v137.i32;
  *(double *)v139.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v131.i64, v138, v134, v133, v135, v137, v136);
  HIDWORD(v14CI::NodeWithChildren::NodeWithChildren(this, 0) = a3.i32[1];
  float32x2_t v141 = vadd_f32((float32x2_t)vext_s8((int8x8_t)a3, *(int8x8_t *)v226.f32, 4uLL), v4);
  *(float *)&double v142 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v141, 1), *(float *)(a1 + 16), v141.f32[0]);
  LODWORD(v14CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v143.i32[0] = *(_DWORD *)(a1 + 28);
  v144.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v145.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v141, 1), *(float *)v143.i32, v141.f32[0]);
  float64x2_t v146 = (float64x2_t)v217;
  float32x4_t v218 = vaddq_f32(v217, v139);
  v139.f32[0] = *(float *)&v140 + *(float *)&v142;
  *(float *)v146.f64 = *(float *)v144.i32 + *(float *)v145.i32;
  v139.f32[1] = *(float *)v144.i32 + *(float *)v145.i32;
  *(double *)v147.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v139.i64, v146, v140, v142, v143, v145, v144);
  float32x2_t v148 = vsub_f32(v4, a3);
  *(float *)&double v149 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v148, 1), *(float *)(a1 + 16), v148.f32[0]);
  LODWORD(v15CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v151.i32[0] = *(_DWORD *)(a1 + 28);
  v152.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v153.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v148, 1), *(float *)v151.i32, v148.f32[0]);
  float64x2_t v154 = (float64x2_t)v218;
  float32x4_t v219 = vaddq_f32(v218, v147);
  v147.f32[0] = *(float *)&v150 + *(float *)&v149;
  *(float *)v154.f64 = *(float *)v152.i32 + *(float *)v153.i32;
  v147.f32[1] = *(float *)v152.i32 + *(float *)v153.i32;
  *(double *)v155.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v147.i64, v154, v150, v149, v151, v153, v152);
  HIDWORD(v156) = a3.i32[1];
  float32x2_t v157 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v226.f32, (int8x8_t)a3, 4uLL), v4);
  *(float *)&double v158 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v157, 1), *(float *)(a1 + 16), v157.f32[0]);
  LODWORD(v156) = *(_DWORD *)(a1 + 24);
  v159.i32[0] = *(_DWORD *)(a1 + 28);
  v160.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v161.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v157, 1), *(float *)v159.i32, v157.f32[0]);
  float64x2_t v162 = (float64x2_t)v219;
  float32x4_t v220 = vaddq_f32(v219, v155);
  v155.f32[0] = *(float *)&v156 + *(float *)&v158;
  *(float *)v162.f64 = *(float *)v160.i32 + *(float *)v161.i32;
  v155.f32[1] = *(float *)v160.i32 + *(float *)v161.i32;
  *(double *)v163.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v155.i64, v162, v156, v158, v159, v161, v160);
  float32x2_t v164 = vadd_f32((float32x2_t)vrev64_s32((int32x2_t)a3), v4);
  *(float *)&double v165 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v164, 1), *(float *)(a1 + 16), v164.f32[0]);
  LODWORD(v166) = *(_DWORD *)(a1 + 24);
  v167.i32[0] = *(_DWORD *)(a1 + 28);
  v168.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v169.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v164, 1), *(float *)v167.i32, v164.f32[0]);
  float64x2_t v170 = (float64x2_t)v220;
  float32x4_t v221 = vaddq_f32(v220, v163);
  v163.f32[0] = *(float *)&v166 + *(float *)&v165;
  *(float *)v170.f64 = *(float *)v168.i32 + *(float *)v169.i32;
  v163.f32[1] = *(float *)v168.i32 + *(float *)v169.i32;
  *(double *)v171.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v163.i64, v170, v166, v165, v167, v169, v168);
  HIDWORD(v172) = a3.i32[1];
  float32x2_t v173 = vadd_f32((float32x2_t)__PAIR64__(a3.u32[1], v226.u32[0]), v4);
  *(float *)&double v174 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v173, 1), *(float *)(a1 + 16), v173.f32[0]);
  LODWORD(v172) = *(_DWORD *)(a1 + 24);
  v175.i32[0] = *(_DWORD *)(a1 + 28);
  v176.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v177.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v173, 1), *(float *)v175.i32, v173.f32[0]);
  float64x2_t v178 = (float64x2_t)v221;
  float32x4_t v222 = vaddq_f32(v221, v171);
  v171.f32[0] = *(float *)&v172 + *(float *)&v174;
  *(float *)v178.f64 = *(float *)v176.i32 + *(float *)v177.i32;
  v171.f32[1] = *(float *)v176.i32 + *(float *)v177.i32;
  *(double *)v179.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v171.i64, v178, v172, v174, v175, v177, v176);
  float32x2_t v180 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v226.f32), v4);
  *(float *)&double v181 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v180, 1), *(float *)(a1 + 16), v180.f32[0]);
  LODWORD(v182) = *(_DWORD *)(a1 + 24);
  v183.i32[0] = *(_DWORD *)(a1 + 28);
  v184.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v185.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v180, 1), *(float *)v183.i32, v180.f32[0]);
  float64x2_t v186 = (float64x2_t)v222;
  float32x4_t v223 = vaddq_f32(v222, v179);
  v179.f32[0] = *(float *)&v182 + *(float *)&v181;
  *(float *)v186.f64 = *(float *)v184.i32 + *(float *)v185.i32;
  v179.f32[1] = *(float *)v184.i32 + *(float *)v185.i32;
  *(double *)v187.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v179.i64, v186, v182, v181, v183, v185, v184);
  HIDWORD(v18_Block_object_dispose(&STACK[0x3A0], 8) = v226.i32[1];
  float32x2_t v189 = vadd_f32((float32x2_t)__PAIR64__(v226.u32[1], a3.u32[0]), v4);
  *(float *)&double v190 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v189, 1), *(float *)(a1 + 16), v189.f32[0]);
  LODWORD(v18_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v191.i32[0] = *(_DWORD *)(a1 + 28);
  v192.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v193.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v189, 1), *(float *)v191.i32, v189.f32[0]);
  float64x2_t v194 = (float64x2_t)v223;
  float32x4_t v227 = vaddq_f32(v223, v187);
  v187.f32[0] = *(float *)&v188 + *(float *)&v190;
  *(float *)v194.f64 = *(float *)v192.i32 + *(float *)v193.i32;
  v187.f32[1] = *(float *)v192.i32 + *(float *)v193.i32;
  *(double *)v195.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v187.i64, v194, v188, v190, v191, v193, v192);
  __asm { FMOV            V1.4S, #24.0 }
  *(void *)&double result = vdivq_f32(vaddq_f32(v227, v195), _Q1).u64[0];
  return result;
}

void CI::f4_sr_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = *(void *)(a1 + 48);
  float32x4_t v12 = *(double (**)(uint64_t, __n128, double))(a1 + 24);
  uint64_t v13 = *(void *)(v11 + 8);
  int v14 = *(_DWORD *)(v11 + 40);
  uint64_t v15 = *(void *)(v11 + 32);
  int v16 = *(_DWORD *)(v11 + 64);
  uint64_t v17 = *(void *)(v11 + 56);
  if (*(unsigned char *)(a1 + 64)) {
    CI::setDC((CI *)(a3 + 16 * *(void *)(v11 + 80)), a2);
  }
  int8x16_t v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5) {
    int8x16_t v18 = (double *)((char *)a2 + 64 * v17);
  }
  float32x4_t v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5) {
    float32x4_t v19 = (__n128 *)((char *)a2 + 64 * v15);
  }
  *(double *)&long long v20 = v12(a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_ringAvg32(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  int8x16_t v290 = a2;
  int32x2_t v274 = (int32x2_t)vneg_f32(*(float32x2_t *)a2.i8);
  float32x2_t v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  float32x2_t v5 = vadd_f32(*(float32x2_t *)v290.i8, v4);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v10, v6, v7, v9, v8, v11);
  HIDWORD(v13) = v274.i32[1];
  float32x2_t v14 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v290.i8, (int8x8_t)v274, 4uLL), v4);
  *(float *)&double v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 24);
  v16.i32[0] = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)v16.i32, v14.f32[0]);
  float32x4_t v261 = vaddq_f32(v12, (float32x4_t)0);
  v12.f32[0] = *(float *)&v13 + *(float *)&v15;
  v12.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)v17.i32 + *(float *)v18.i32), v13, v15, v16, v18, v17);
  float32x2_t v20 = vsub_f32(v4, *(float32x2_t *)v290.i8);
  *(float *)&double v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v20, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 24);
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v20, 1), *(float *)v23.i32, v20.f32[0]);
  float64x2_t v26 = (float64x2_t)v261;
  float32x4_t v262 = vaddq_f32(v261, v19);
  v19.f32[0] = *(float *)&v22 + *(float *)&v21;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v19.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v26, v22, v21, v23, v25, v24);
  HIDWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = v274.i32[1];
  float32x2_t v29 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v274, *(int8x8_t *)v290.i8, 4uLL), v4);
  *(float *)&double v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v29, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v29, 1), *(float *)v31.i32, v29.f32[0]);
  float64x2_t v34 = (float64x2_t)v262;
  float32x4_t v263 = vaddq_f32(v262, v27);
  v27.f32[0] = *(float *)&v28 + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v34, v28, v30, v31, v33, v32);
  float32x2_t v36 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v290.i8), v4);
  *(float *)&double v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v36, 1), *(float *)(a1 + 16), v36.f32[0]);
  LODWORD(v3_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v39.i32[0] = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v36, 1), *(float *)v39.i32, v36.f32[0]);
  float64x2_t v42 = (float64x2_t)v263;
  float32x4_t v264 = vaddq_f32(v263, v35);
  v35.f32[0] = *(float *)&v38 + *(float *)&v37;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v35.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v42, v38, v37, v39, v41, v40);
  HIDWORD(v44) = v290.i32[1];
  float32x2_t v45 = vadd_f32((float32x2_t)__PAIR64__(v290.u32[1], v274.u32[0]), v4);
  *(float *)&double v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v45, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a1 + 24);
  v47.i32[0] = *(_DWORD *)(a1 + 28);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v45, 1), *(float *)v47.i32, v45.f32[0]);
  float64x2_t v50 = (float64x2_t)v264;
  float32x4_t v265 = vaddq_f32(v264, v43);
  v43.f32[0] = *(float *)&v44 + *(float *)&v46;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v43.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v50, v44, v46, v47, v49, v48);
  float32x2_t v52 = vadd_f32((float32x2_t)vrev64_s32(v274), v4);
  *(float *)&double v53 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v52, 1), *(float *)(a1 + 16), v52.f32[0]);
  LODWORD(v54) = *(_DWORD *)(a1 + 24);
  v55.i32[0] = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v52, 1), *(float *)v55.i32, v52.f32[0]);
  float64x2_t v58 = (float64x2_t)v265;
  float32x4_t v266 = vaddq_f32(v265, v51);
  v51.f32[0] = *(float *)&v54 + *(float *)&v53;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v51.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v51.i64, v58, v54, v53, v55, v57, v56);
  HIDWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = v274.i32[1];
  float32x2_t v61 = vadd_f32((float32x2_t)__PAIR64__(v274.u32[1], v290.u32[0]), v4);
  *(float *)&double v62 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v61, 1), *(float *)(a1 + 16), v61.f32[0]);
  LODWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 24);
  v63.i32[0] = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v61, 1), *(float *)v63.i32, v61.f32[0]);
  float64x2_t v66 = (float64x2_t)v266;
  float32x4_t v275 = vaddq_f32(v266, v59);
  v59.f32[0] = *(float *)&v60 + *(float *)&v62;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v59.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v59.i64, v66, v60, v62, v63, v65, v64);
  float32x2_t v68 = (float32x2_t)vextq_s8(v290, v290, 8uLL).u64[0];
  float32x2_t v69 = vadd_f32(v68, v4);
  float32x2_t v70 = v68;
  *(float32x2_t *)v290.i8 = v68;
  *(float *)&double v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v69, 1), *(float *)(a1 + 16), v69.f32[0]);
  v68.i32[0] = *(_DWORD *)(a1 + 24);
  v72.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v69, 1), *(float *)(a1 + 28), v69.f32[0]);
  float64x2_t v74 = (float64x2_t)v275;
  float32x4_t v267 = vaddq_f32(v275, v67);
  *(float32x2_t *)v275.f32 = vneg_f32(v70);
  v67.f32[0] = v68.f32[0] + *(float *)&v71;
  *(float *)v74.f64 = *(float *)v72.i32 + *(float *)v73.i32;
  v67.f32[1] = *(float *)v72.i32 + *(float *)v73.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v67.i64, v74, *(double *)&v68, v71, (int8x16_t)v267, v73, v72);
  HIDWORD(v76) = v290.i32[1];
  float32x2_t v77 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v290.i8, *(int8x8_t *)v275.f32, 4uLL), v4);
  *(float *)&double v78 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v77, 1), *(float *)(a1 + 16), v77.f32[0]);
  LODWORD(v76) = *(_DWORD *)(a1 + 24);
  v79.i32[0] = *(_DWORD *)(a1 + 28);
  v80.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v81.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v77, 1), *(float *)v79.i32, v77.f32[0]);
  float64x2_t v82 = (float64x2_t)v267;
  float32x4_t v268 = vaddq_f32(v267, v75);
  v75.f32[0] = *(float *)&v76 + *(float *)&v78;
  *(float *)v82.f64 = *(float *)v80.i32 + *(float *)v81.i32;
  v75.f32[1] = *(float *)v80.i32 + *(float *)v81.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v75.i64, v82, v76, v78, v79, v81, v80);
  float32x2_t v84 = vsub_f32(v4, *(float32x2_t *)v290.i8);
  *(float *)&double v85 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v84, 1), *(float *)(a1 + 16), v84.f32[0]);
  LODWORD(v86) = *(_DWORD *)(a1 + 24);
  v87.i32[0] = *(_DWORD *)(a1 + 28);
  v88.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v84, 1), *(float *)v87.i32, v84.f32[0]);
  float64x2_t v90 = (float64x2_t)v268;
  float32x4_t v269 = vaddq_f32(v268, v83);
  v83.f32[0] = *(float *)&v86 + *(float *)&v85;
  *(float *)v90.f64 = *(float *)v88.i32 + *(float *)v89.i32;
  v83.f32[1] = *(float *)v88.i32 + *(float *)v89.i32;
  *(double *)v91.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v90, v86, v85, v87, v89, v88);
  HIDWORD(v92) = v290.i32[1];
  float32x2_t v93 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v275.f32, *(int8x8_t *)v290.i8, 4uLL), v4);
  *(float *)&double v94 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v93, 1), *(float *)(a1 + 16), v93.f32[0]);
  LODWORD(v92) = *(_DWORD *)(a1 + 24);
  v95.i32[0] = *(_DWORD *)(a1 + 28);
  v96.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v97.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v93, 1), *(float *)v95.i32, v93.f32[0]);
  float64x2_t v98 = (float64x2_t)v269;
  float32x4_t v270 = vaddq_f32(v269, v91);
  v91.f32[0] = *(float *)&v92 + *(float *)&v94;
  *(float *)v98.f64 = *(float *)v96.i32 + *(float *)v97.i32;
  v91.f32[1] = *(float *)v96.i32 + *(float *)v97.i32;
  *(double *)v99.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v91.i64, v98, v92, v94, v95, v97, v96);
  float32x2_t v100 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v290.i8), v4);
  *(float *)&double v101 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v100, 1), *(float *)(a1 + 16), v100.f32[0]);
  LODWORD(v102) = *(_DWORD *)(a1 + 24);
  v103.i32[0] = *(_DWORD *)(a1 + 28);
  v104.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v105.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v100, 1), *(float *)v103.i32, v100.f32[0]);
  float64x2_t v106 = (float64x2_t)v270;
  float32x4_t v271 = vaddq_f32(v270, v99);
  v99.f32[0] = *(float *)&v102 + *(float *)&v101;
  *(float *)v106.f64 = *(float *)v104.i32 + *(float *)v105.i32;
  v99.f32[1] = *(float *)v104.i32 + *(float *)v105.i32;
  *(double *)v107.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v99.i64, v106, v102, v101, v103, v105, v104);
  HIDWORD(v10_Block_object_dispose(&STACK[0x3A0], 8) = v290.i32[1];
  float32x2_t v109 = vadd_f32((float32x2_t)__PAIR64__(v290.u32[1], v275.u32[0]), v4);
  *(float *)&double v110 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v109, 1), *(float *)(a1 + 16), v109.f32[0]);
  LODWORD(v10_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v111.i32[0] = *(_DWORD *)(a1 + 28);
  v112.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v113.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v109, 1), *(float *)v111.i32, v109.f32[0]);
  float64x2_t v114 = (float64x2_t)v271;
  float32x4_t v272 = vaddq_f32(v271, v107);
  v107.f32[0] = *(float *)&v108 + *(float *)&v110;
  *(float *)v114.f64 = *(float *)v112.i32 + *(float *)v113.i32;
  v107.f32[1] = *(float *)v112.i32 + *(float *)v113.i32;
  *(double *)v115.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v107.i64, v114, v108, v110, v111, v113, v112);
  float32x2_t v116 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v275.f32), v4);
  *(float *)&double v117 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v116, 1), *(float *)(a1 + 16), v116.f32[0]);
  LODWORD(v11_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 24);
  v119.i32[0] = *(_DWORD *)(a1 + 28);
  v120.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v121.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v116, 1), *(float *)v119.i32, v116.f32[0]);
  float64x2_t v122 = (float64x2_t)v272;
  float32x4_t v273 = vaddq_f32(v272, v115);
  v115.f32[0] = *(float *)&v118 + *(float *)&v117;
  *(float *)v122.f64 = *(float *)v120.i32 + *(float *)v121.i32;
  v115.f32[1] = *(float *)v120.i32 + *(float *)v121.i32;
  *(double *)v123.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v115.i64, v122, v118, v117, v119, v121, v120);
  HIDWORD(v124) = v275.i32[1];
  float32x2_t v125 = vadd_f32((float32x2_t)__PAIR64__(v275.u32[1], v290.u32[0]), v4);
  *(float *)&double v126 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v125, 1), *(float *)(a1 + 16), v125.f32[0]);
  LODWORD(v124) = *(_DWORD *)(a1 + 24);
  v127.i32[0] = *(_DWORD *)(a1 + 28);
  v128.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v129.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v125, 1), *(float *)v127.i32, v125.f32[0]);
  float64x2_t v130 = (float64x2_t)v273;
  float32x4_t v291 = vaddq_f32(v273, v123);
  v123.f32[0] = *(float *)&v124 + *(float *)&v126;
  *(float *)v130.f64 = *(float *)v128.i32 + *(float *)v129.i32;
  v123.f32[1] = *(float *)v128.i32 + *(float *)v129.i32;
  *(double *)v131.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v123.i64, v130, v124, v126, v127, v129, v128);
  float32x2_t v132 = vadd_f32(*(float32x2_t *)a3.i8, v4);
  *(float *)&double v133 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v132, 1), *(float *)(a1 + 16), v132.f32[0]);
  LODWORD(v134) = *(_DWORD *)(a1 + 24);
  v135.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v136.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v132, 1), *(float *)(a1 + 28), v132.f32[0]);
  float64x2_t v137 = (float64x2_t)v291;
  float32x4_t v276 = vaddq_f32(v291, v131);
  *(float32x2_t *)v291.f32 = vneg_f32(*(float32x2_t *)a3.i8);
  v131.f32[0] = *(float *)&v134 + *(float *)&v133;
  *(float *)v137.f64 = *(float *)v135.i32 + *(float *)v136.i32;
  v131.f32[1] = *(float *)v135.i32 + *(float *)v136.i32;
  *(double *)v138.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v131.i64, v137, v134, v133, (int8x16_t)v276, v136, v135);
  HIDWORD(v139) = v291.i32[1];
  float32x2_t v140 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)a3.i8, *(int8x8_t *)v291.f32, 4uLL), v4);
  *(float *)&double v141 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v140, 1), *(float *)(a1 + 16), v140.f32[0]);
  LODWORD(v139) = *(_DWORD *)(a1 + 24);
  v142.i32[0] = *(_DWORD *)(a1 + 28);
  v143.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v144.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v140, 1), *(float *)v142.i32, v140.f32[0]);
  float64x2_t v145 = (float64x2_t)v276;
  float32x4_t v277 = vaddq_f32(v276, v138);
  v138.f32[0] = *(float *)&v139 + *(float *)&v141;
  *(float *)v145.f64 = *(float *)v143.i32 + *(float *)v144.i32;
  v138.f32[1] = *(float *)v143.i32 + *(float *)v144.i32;
  *(double *)v146.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v138.i64, v145, v139, v141, v142, v144, v143);
  float32x2_t v147 = vsub_f32(v4, *(float32x2_t *)a3.i8);
  *(float *)&double v148 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v147, 1), *(float *)(a1 + 16), v147.f32[0]);
  LODWORD(v149) = *(_DWORD *)(a1 + 24);
  v150.i32[0] = *(_DWORD *)(a1 + 28);
  v151.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v152.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v147, 1), *(float *)v150.i32, v147.f32[0]);
  float64x2_t v153 = (float64x2_t)v277;
  float32x4_t v278 = vaddq_f32(v277, v146);
  v146.f32[0] = *(float *)&v149 + *(float *)&v148;
  *(float *)v153.f64 = *(float *)v151.i32 + *(float *)v152.i32;
  v146.f32[1] = *(float *)v151.i32 + *(float *)v152.i32;
  *(double *)v154.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v146.i64, v153, v149, v148, v150, v152, v151);
  HIDWORD(v155) = v291.i32[1];
  float32x2_t v156 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v291.f32, *(int8x8_t *)a3.i8, 4uLL), v4);
  *(float *)&double v157 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v156, 1), *(float *)(a1 + 16), v156.f32[0]);
  LODWORD(v155) = *(_DWORD *)(a1 + 24);
  v158.i32[0] = *(_DWORD *)(a1 + 28);
  v159.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v160.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v156, 1), *(float *)v158.i32, v156.f32[0]);
  float64x2_t v161 = (float64x2_t)v278;
  float32x4_t v279 = vaddq_f32(v278, v154);
  v154.f32[0] = *(float *)&v155 + *(float *)&v157;
  *(float *)v161.f64 = *(float *)v159.i32 + *(float *)v160.i32;
  v154.f32[1] = *(float *)v159.i32 + *(float *)v160.i32;
  *(double *)v162.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v154.i64, v161, v155, v157, v158, v160, v159);
  float32x2_t v163 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)a3.i8), v4);
  *(float *)&double v164 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v163, 1), *(float *)(a1 + 16), v163.f32[0]);
  LODWORD(v165) = *(_DWORD *)(a1 + 24);
  v166.i32[0] = *(_DWORD *)(a1 + 28);
  v167.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v168.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v163, 1), *(float *)v166.i32, v163.f32[0]);
  float64x2_t v169 = (float64x2_t)v279;
  float32x4_t v280 = vaddq_f32(v279, v162);
  v162.f32[0] = *(float *)&v165 + *(float *)&v164;
  *(float *)v169.f64 = *(float *)v167.i32 + *(float *)v168.i32;
  v162.f32[1] = *(float *)v167.i32 + *(float *)v168.i32;
  *(double *)v170.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v162.i64, v169, v165, v164, v166, v168, v167);
  HIDWORD(v171) = a3.i32[1];
  float32x2_t v172 = vadd_f32((float32x2_t)__PAIR64__(a3.u32[1], v291.u32[0]), v4);
  *(float *)&double v173 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v172, 1), *(float *)(a1 + 16), v172.f32[0]);
  LODWORD(v171) = *(_DWORD *)(a1 + 24);
  v174.i32[0] = *(_DWORD *)(a1 + 28);
  v175.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v176.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v172, 1), *(float *)v174.i32, v172.f32[0]);
  float64x2_t v177 = (float64x2_t)v280;
  float32x4_t v281 = vaddq_f32(v280, v170);
  v170.f32[0] = *(float *)&v171 + *(float *)&v173;
  *(float *)v177.f64 = *(float *)v175.i32 + *(float *)v176.i32;
  v170.f32[1] = *(float *)v175.i32 + *(float *)v176.i32;
  *(double *)v178.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v170.i64, v177, v171, v173, v174, v176, v175);
  float32x2_t v179 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v291.f32), v4);
  *(float *)&double v180 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v179, 1), *(float *)(a1 + 16), v179.f32[0]);
  LODWORD(v181) = *(_DWORD *)(a1 + 24);
  v182.i32[0] = *(_DWORD *)(a1 + 28);
  v183.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v184.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v179, 1), *(float *)v182.i32, v179.f32[0]);
  float64x2_t v185 = (float64x2_t)v281;
  float32x4_t v282 = vaddq_f32(v281, v178);
  v178.f32[0] = *(float *)&v181 + *(float *)&v180;
  *(float *)v185.f64 = *(float *)v183.i32 + *(float *)v184.i32;
  v178.f32[1] = *(float *)v183.i32 + *(float *)v184.i32;
  *(double *)v186.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v178.i64, v185, v181, v180, v182, v184, v183);
  HIDWORD(v187) = v291.i32[1];
  float32x2_t v188 = vadd_f32((float32x2_t)__PAIR64__(v291.u32[1], a3.u32[0]), v4);
  *(float *)&double v189 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v188, 1), *(float *)(a1 + 16), v188.f32[0]);
  LODWORD(v187) = *(_DWORD *)(a1 + 24);
  v190.i32[0] = *(_DWORD *)(a1 + 28);
  v191.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v192.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v188, 1), *(float *)v190.i32, v188.f32[0]);
  float64x2_t v193 = (float64x2_t)v282;
  float32x4_t v292 = vaddq_f32(v282, v186);
  v186.f32[0] = *(float *)&v187 + *(float *)&v189;
  *(float *)v193.f64 = *(float *)v191.i32 + *(float *)v192.i32;
  v186.f32[1] = *(float *)v191.i32 + *(float *)v192.i32;
  *(double *)v194.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v186.i64, v193, v187, v189, v190, v192, v191);
  float32x2_t v195 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  float32x2_t v196 = vadd_f32(v195, v4);
  float32x2_t v197 = v195;
  *(float32x2_t *)a3.i8 = v195;
  *(float *)&double v198 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v196, 1), *(float *)(a1 + 16), v196.f32[0]);
  v195.i32[0] = *(_DWORD *)(a1 + 24);
  v199.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v200.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v196, 1), *(float *)(a1 + 28), v196.f32[0]);
  float64x2_t v201 = (float64x2_t)v292;
  float32x4_t v283 = vaddq_f32(v292, v194);
  *(float32x2_t *)v292.f32 = vneg_f32(v197);
  v194.f32[0] = v195.f32[0] + *(float *)&v198;
  *(float *)v201.f64 = *(float *)v199.i32 + *(float *)v200.i32;
  v194.f32[1] = *(float *)v199.i32 + *(float *)v200.i32;
  *(double *)v202.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v194.i64, v201, *(double *)&v195, v198, (int8x16_t)v283, v200, v199);
  HIDWORD(v203) = a3.i32[1];
  float32x2_t v204 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)a3.i8, *(int8x8_t *)v292.f32, 4uLL), v4);
  *(float *)&double v205 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v204, 1), *(float *)(a1 + 16), v204.f32[0]);
  LODWORD(v203) = *(_DWORD *)(a1 + 24);
  v206.i32[0] = *(_DWORD *)(a1 + 28);
  v207.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v208.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v204, 1), *(float *)v206.i32, v204.f32[0]);
  float64x2_t v209 = (float64x2_t)v283;
  float32x4_t v284 = vaddq_f32(v283, v202);
  v202.f32[0] = *(float *)&v203 + *(float *)&v205;
  *(float *)v209.f64 = *(float *)v207.i32 + *(float *)v208.i32;
  v202.f32[1] = *(float *)v207.i32 + *(float *)v208.i32;
  *(double *)v210.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v202.i64, v209, v203, v205, v206, v208, v207);
  float32x2_t v211 = vsub_f32(v4, *(float32x2_t *)a3.i8);
  *(float *)&double v212 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v211, 1), *(float *)(a1 + 16), v211.f32[0]);
  LODWORD(v213) = *(_DWORD *)(a1 + 24);
  v214.i32[0] = *(_DWORD *)(a1 + 28);
  v215.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v216.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v211, 1), *(float *)v214.i32, v211.f32[0]);
  float64x2_t v217 = (float64x2_t)v284;
  float32x4_t v285 = vaddq_f32(v284, v210);
  v210.f32[0] = *(float *)&v213 + *(float *)&v212;
  *(float *)v217.f64 = *(float *)v215.i32 + *(float *)v216.i32;
  v210.f32[1] = *(float *)v215.i32 + *(float *)v216.i32;
  *(double *)v218.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v210.i64, v217, v213, v212, v214, v216, v215);
  HIDWORD(v219) = a3.i32[1];
  float32x2_t v220 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v292.f32, *(int8x8_t *)a3.i8, 4uLL), v4);
  *(float *)&double v221 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v220, 1), *(float *)(a1 + 16), v220.f32[0]);
  LODWORD(v219) = *(_DWORD *)(a1 + 24);
  v222.i32[0] = *(_DWORD *)(a1 + 28);
  v223.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v224.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v220, 1), *(float *)v222.i32, v220.f32[0]);
  float64x2_t v225 = (float64x2_t)v285;
  float32x4_t v286 = vaddq_f32(v285, v218);
  v218.f32[0] = *(float *)&v219 + *(float *)&v221;
  *(float *)v225.f64 = *(float *)v223.i32 + *(float *)v224.i32;
  v218.f32[1] = *(float *)v223.i32 + *(float *)v224.i32;
  *(double *)v226.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v218.i64, v225, v219, v221, v222, v224, v223);
  float32x2_t v227 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)a3.i8), v4);
  *(float *)&double v228 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v227, 1), *(float *)(a1 + 16), v227.f32[0]);
  LODWORD(v229) = *(_DWORD *)(a1 + 24);
  v230.i32[0] = *(_DWORD *)(a1 + 28);
  v231.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v232.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v227, 1), *(float *)v230.i32, v227.f32[0]);
  float64x2_t v233 = (float64x2_t)v286;
  float32x4_t v287 = vaddq_f32(v286, v226);
  v226.f32[0] = *(float *)&v229 + *(float *)&v228;
  *(float *)v233.f64 = *(float *)v231.i32 + *(float *)v232.i32;
  v226.f32[1] = *(float *)v231.i32 + *(float *)v232.i32;
  *(double *)v234.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v226.i64, v233, v229, v228, v230, v232, v231);
  HIDWORD(v235) = a3.i32[1];
  float32x2_t v236 = vadd_f32((float32x2_t)__PAIR64__(a3.u32[1], v292.u32[0]), v4);
  *(float *)&double v237 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v236, 1), *(float *)(a1 + 16), v236.f32[0]);
  LODWORD(v235) = *(_DWORD *)(a1 + 24);
  v238.i32[0] = *(_DWORD *)(a1 + 28);
  v239.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v240.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v236, 1), *(float *)v238.i32, v236.f32[0]);
  float64x2_t v241 = (float64x2_t)v287;
  float32x4_t v288 = vaddq_f32(v287, v234);
  v234.f32[0] = *(float *)&v235 + *(float *)&v237;
  *(float *)v241.f64 = *(float *)v239.i32 + *(float *)v240.i32;
  v234.f32[1] = *(float *)v239.i32 + *(float *)v240.i32;
  *(double *)v242.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v234.i64, v241, v235, v237, v238, v240, v239);
  float32x2_t v243 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v292.f32), v4);
  *(float *)&double v244 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v243, 1), *(float *)(a1 + 16), v243.f32[0]);
  LODWORD(v245) = *(_DWORD *)(a1 + 24);
  v246.i32[0] = *(_DWORD *)(a1 + 28);
  v247.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v248.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v243, 1), *(float *)v246.i32, v243.f32[0]);
  float64x2_t v249 = (float64x2_t)v288;
  float32x4_t v289 = vaddq_f32(v288, v242);
  v242.f32[0] = *(float *)&v245 + *(float *)&v244;
  *(float *)v249.f64 = *(float *)v247.i32 + *(float *)v248.i32;
  v242.f32[1] = *(float *)v247.i32 + *(float *)v248.i32;
  *(double *)v250.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v242.i64, v249, v245, v244, v246, v248, v247);
  HIDWORD(v251) = v292.i32[1];
  float32x2_t v252 = vadd_f32((float32x2_t)__PAIR64__(v292.u32[1], a3.u32[0]), v4);
  *(float *)&double v253 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v252, 1), *(float *)(a1 + 16), v252.f32[0]);
  LODWORD(v251) = *(_DWORD *)(a1 + 24);
  v254.i32[0] = *(_DWORD *)(a1 + 28);
  v255.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v256.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v252, 1), *(float *)v254.i32, v252.f32[0]);
  float64x2_t v257 = (float64x2_t)v289;
  float32x4_t v294 = vaddq_f32(v289, v250);
  v250.f32[0] = *(float *)&v251 + *(float *)&v253;
  *(float *)v257.f64 = *(float *)v255.i32 + *(float *)v256.i32;
  v250.f32[1] = *(float *)v255.i32 + *(float *)v256.i32;
  *(double *)v258.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v250.i64, v257, v251, v253, v254, v256, v255);
  v259.i64[0] = 0x3D0000003D000000;
  v259.i64[1] = 0x3D0000003D000000;
  *(void *)&double result = vmulq_f32(vaddq_f32(v294, v258), v259).u64[0];
  return result;
}

double cikernel::_disintegrateWithMask(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float a6, float32x4_t a7)
{
  float v7 = 1.0 / (fmaxf(fabsf(vsubq_f32(a4, a3).f32[0]), fabsf(vsubq_f32(a5, a3).f32[0])) + 0.001);
  float v8 = a7.f32[3] + (float)(vmuls_lane_f32(a7.f32[3] - a6, *(float32x2_t *)a7.f32, 1) * v7);
  if (v8 <= 1.0) {
    float v9 = v8;
  }
  else {
    float v9 = 1.0;
  }
  if (v8 < 0.0) {
    float v9 = 0.0;
  }
  float v10 = a7.f32[2] * (v9 + -1.0) + 1.0;
  float v11 = vmuls_lane_f32(a7.f32[0], a7, 3);
  float32x4_t v12 = vmulq_n_f32(a1, v11 + 1.0);
  v12.i32[3] = a1.i32[3];
  float v13 = v11 + 1.0 - a7.f32[0];
  float32x4_t v14 = vmulq_n_f32(vmulq_n_f32(a2, v13), v10);
  v14.i32[3] = a2.i32[3];
  float v15 = a7.f32[3] + (float)((float)(a7.f32[3] - a3.f32[0]) * v7);
  if (v15 <= 1.0) {
    float v16 = a7.f32[3] + (float)((float)(a7.f32[3] - a3.f32[0]) * v7);
  }
  else {
    float v16 = 1.0;
  }
  if (v15 < 0.0) {
    float v16 = 0.0;
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v12, 1.0 - v16), v14, v16).u64[0];
  return result;
}

void CI::f4_s_s_s_s_s_s_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *(void *)(a1 + 48);
  float v10 = *(const vec2 **)(a1 + 24);
  int v11 = *(_DWORD *)(v9 + 16);
  uint64_t v12 = *(void *)(v9 + 8);
  int v13 = *(_DWORD *)(v9 + 40);
  uint64_t v14 = *(void *)(v9 + 32);
  int v15 = *(_DWORD *)(v9 + 64);
  uint64_t v16 = *(void *)(v9 + 56);
  int v17 = *(_DWORD *)(v9 + 88);
  uint64_t v18 = *(void *)(v9 + 80);
  int v19 = *(_DWORD *)(v9 + 112);
  uint64_t v20 = *(void *)(v9 + 104);
  int v21 = *(_DWORD *)(v9 + 136);
  uint64_t v22 = *(void *)(v9 + 128);
  int v23 = *(_DWORD *)(v9 + 160);
  uint64_t v24 = *(void *)(v9 + 152);
  if (*(unsigned char *)(a1 + 64))
  {
    int8x16_t v39 = *(const vec2 **)(a1 + 24);
    uint64_t v40 = *(void *)(v9 + 32);
    uint64_t v37 = *(void *)(v9 + 8);
    uint64_t v38 = *(void *)(v9 + 56);
    int v36 = *(_DWORD *)(v9 + 112);
    uint64_t v35 = *(void *)(v9 + 80);
    int v34 = *(_DWORD *)(v9 + 160);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v9 + 176)), v10);
    int v23 = v34;
    uint64_t v18 = v35;
    int v19 = v36;
    uint64_t v12 = v37;
    uint64_t v16 = v38;
    float v10 = v39;
    uint64_t v14 = v40;
  }
  int8x16_t v25 = (__n128 *)(a3 + 16 * v24);
  if (v23 != 5) {
    int8x16_t v25 = (__n128 *)(a2 + (v24 << 6));
  }
  float64x2_t v26 = (__n128 *)(a3 + 16 * v22);
  if (v21 != 5) {
    float64x2_t v26 = (__n128 *)(a2 + (v22 << 6));
  }
  float32x4_t v27 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5) {
    float32x4_t v27 = (__n128 *)(a2 + (v20 << 6));
  }
  double v28 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    double v28 = (__n128 *)(a2 + (v18 << 6));
  }
  float32x2_t v29 = (__n128 *)(a3 + 16 * v16);
  double v30 = (__n128 *)(a2 + (v16 << 6));
  if (v15 != 5) {
    float32x2_t v29 = v30;
  }
  int8x16_t v31 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5) {
    int8x16_t v31 = (__n128 *)(a2 + (v14 << 6));
  }
  int8x16_t v32 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5) {
    int8x16_t v32 = (__n128 *)(a2 + (v12 << 6));
  }
  *(double *)&long long v33 = ((double (*)(__n128, __n128, __n128, __n128, __n128, __n128, __n128))v10)(*v32, *v31, *v29, *v28, *v27, *v26, *v25);
  *(_OWORD *)(a3 + 16 * a7) = v33;
}

double cikernel::_disintegrateWithMaskG(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t a4, float32x4_t a5)
{
  float v9 = a5.f32[2];
  float v10 = a5.f32[3];
  uint64_t DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v13, COERCE_FLOAT(*DC));
  *(float *)&double v16 = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v17.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  *((float *)&v16 + 1) = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v16, v17, v12, v13, v15, v14, v18);
  float32x4_t v77 = v19;
  int v21 = (float32x2_t *)CI::getDC(v20);
  *(float *)&double v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *v21, 1), *(float *)(a2 + 16), COERCE_FLOAT(*v21));
  LODWORD(v23) = *(_DWORD *)(a2 + 28);
  v24.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *v21, 1), *(float *)&v23, COERCE_FLOAT(*v21));
  *(float *)&double v26 = *(float *)(a2 + 24) + *(float *)&v22;
  *(float *)v27.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  *((float *)&v26 + 1) = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v26, v27, v22, v23, v25, v24, v28);
  float32x4_t v76 = v29;
  int8x16_t v31 = (float32x2_t *)CI::getDC(v30);
  *(float32x2_t *)v32.i8 = *v31;
  float64x2_t v79 = (float64x2_t)v32;
  LODWORD(v33) = *(_DWORD *)(a3 + 28);
  *(float *)&double v34 = *(float *)(a3 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *v31, 1), *(float *)(a3 + 16), COERCE_FLOAT(*v31));
  LODWORD(v35) = *(_DWORD *)(a3 + 36);
  *(float *)v36.f64 = *(float *)&v35
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *v31, 1), *(float *)&v33, COERCE_FLOAT(*v31));
  HIDWORD(v34) = LODWORD(v36.f64[0]);
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), v34, v36, v33, v35, v32, v37, v38);
  float32x4_t v75 = v39;
  float64x2_t v40 = v79;
  *(float32x2_t *)v39.f32 = vadd_f32(*(float32x2_t *)&v79.f64[0], (float32x2_t)1065353216);
  *(float *)&double v41 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *(float32x2_t *)v39.f32, 1), *(float *)(a3 + 16), v39.f32[0]);
  LODWORD(v42) = *(_DWORD *)(a3 + 28);
  v43.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *(float32x2_t *)v39.f32, 1), *(float *)&v42, v39.f32[0]);
  v39.f32[0] = *(float *)(a3 + 24) + *(float *)&v41;
  *(float *)v40.f64 = *(float *)v43.i32 + *(float *)v44.i32;
  v39.f32[1] = *(float *)v43.i32 + *(float *)v44.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), *(double *)v39.i64, v40, v41, v42, v44, v43, v45);
  float32x4_t v74 = v46;
  float64x2_t v47 = v79;
  *(float32x2_t *)v46.f32 = vadd_f32(*(float32x2_t *)&v79.f64[0], (float32x2_t)0x3F80000000000000);
  *(float *)&double v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *(float32x2_t *)v46.f32, 1), *(float *)(a3 + 16), v46.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a3 + 28);
  v50.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *(float32x2_t *)v46.f32, 1), *(float *)&v49, v46.f32[0]);
  v46.f32[0] = *(float *)(a3 + 24) + *(float *)&v48;
  *(float *)v47.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v46.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), *(double *)v46.i64, v47, v48, v49, v51, v50, v52);
  float32x4_t v73 = v53;
  *(float32x2_t *)v53.f32 = vsub_f32(*(float32x2_t *)&v79.f64[0], a4);
  *(float *)&double v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *(float32x2_t *)v53.f32, 1), *(float *)(a3 + 16), v53.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a3 + 28);
  v56.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *(float32x2_t *)v53.f32, 1), *(float *)&v55, v53.f32[0]);
  v53.f32[0] = *(float *)(a3 + 24) + *(float *)&v54;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v53.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  double v60 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), *(double *)v53.i64, v58, v54, v55, v57, v56, v59);
  float v61 = 1.0 / (fmaxf(fabsf(vsubq_f32(v74, v75).f32[0]), fabsf(vsubq_f32(v73, v75).f32[0])) + 0.001);
  float v62 = v10 + (float)(vmuls_lane_f32(v10 - *(float *)&v60, *(float32x2_t *)a5.f32, 1) * v61);
  if (v62 <= 1.0) {
    float v63 = v62;
  }
  else {
    float v63 = 1.0;
  }
  if (v62 < 0.0) {
    float v63 = 0.0;
  }
  float v64 = v9 * (v63 + -1.0) + 1.0;
  float v65 = vmuls_lane_f32(a5.f32[0], a5, 3);
  float32x4_t v66 = vmulq_n_f32(v77, v65 + 1.0);
  v66.i32[3] = v77.i32[3];
  float v67 = v65 + 1.0 - a5.f32[0];
  float32x4_t v68 = vmulq_n_f32(vmulq_n_f32(v76, v67), v64);
  v68.i32[3] = v76.i32[3];
  float v69 = v10 + (float)((float)(v10 - v75.f32[0]) * v61);
  if (v69 <= 1.0) {
    float v70 = v69;
  }
  else {
    float v70 = 1.0;
  }
  if (v69 >= 0.0) {
    float v71 = v70;
  }
  else {
    float v71 = 0.0;
  }
  *(void *)&double result = vmlaq_n_f32(vmulq_n_f32(v66, 1.0 - v71), v68, v71).u64[0];
  return result;
}

void CI::f4_sr_sr_sr_f2_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(a1 + 48);
  int v11 = *(double (**)(uint64_t, uint64_t, uint64_t, double, __n128))(a1 + 24);
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v10 + 32);
  uint64_t v14 = *(void *)(v10 + 56);
  int v15 = *(_DWORD *)(v10 + 88);
  uint64_t v16 = *(void *)(v10 + 80);
  int v17 = *(_DWORD *)(v10 + 112);
  uint64_t v18 = *(void *)(v10 + 104);
  if (*(unsigned char *)(a1 + 64))
  {
    int v22 = *(_DWORD *)(v10 + 88);
    CI::setDC((CI *)(a3 + 16 * *(void *)(v10 + 128)), a2);
    int v15 = v22;
  }
  float32x4_t v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5) {
    float32x4_t v19 = (__n128 *)((char *)a2 + 64 * v18);
  }
  uint64_t v20 = (double *)(a3 + 16 * v16);
  if (v15 != 5) {
    uint64_t v20 = (double *)((char *)a2 + 64 * v16);
  }
  *(double *)&long long v21 = v11(a4 + 80 * v12, a4 + 80 * v13, a4 + 80 * v14, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

void saveImage(CIImage *a1, uint64_t a2, int a3)
{
  v38[1] = *MEMORY[0x1E4F143B8];
  if (saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::onceToken != -1) {
    dispatch_once(&saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::onceToken, &__block_literal_global_229);
  }
  if (saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::saveImages)
  {
    if (a1)
    {
      [(CIImage *)a1 extent];
      if (CGRectEqualToRect(v39, *MEMORY[0x1E4F1DB10]))
      {
        NSLog(&cfstr_InfiniteRectCa.isa);
      }
      else
      {
        double v6 = [(CIImage *)a1 colorSpace];
        if (!v6
          || (float v7 = v6, CGColorSpaceGetModel(v6) == kCGColorSpaceModelRGB) && (a3 & 1) != 0
          || (int v8 = 0, CGColorSpaceGetModel(v7) == kCGColorSpaceModelMonochrome) && (a3 & 1) == 0)
        {
          float v7 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88]);
          float v9 = +[CIKernel kernelWithInternalRepresentation:&CI::_gray];
          if (a3)
          {
            uint64_t v10 = v9;
            [(CIImage *)a1 extent];
            v38[0] = a1;
            int v8 = 1;
            a1 = -[CIColorKernel applyWithExtent:arguments:](v10, "applyWithExtent:arguments:", [MEMORY[0x1E4F1C978] arrayWithObjects:v38 count:1], v11, v12, v13, v14);
          }
          else
          {
            int v8 = 1;
          }
        }
        int v15 = (void *)MEMORY[0x1E4F1CBF0];
        uint64_t v16 = [MEMORY[0x1E4F1CBF0] count];
        uint64_t v17 = *MEMORY[0x1E4F2F430];
        double v35 = &unk_1EE4A8520;
        if (v16)
        {
          uint64_t v18 = *MEMORY[0x1E4F2FB80];
          uint64_t v32 = v17;
          uint64_t v33 = v18;
          uint64_t v30 = *MEMORY[0x1E4F2FBC0];
          int8x16_t v31 = v15;
          uint64_t v36 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v31 forKeys:&v30 count:1];
          uint64_t v34 = *MEMORY[0x1E4F2FD40];
          uint64_t v28 = *MEMORY[0x1E4F2FD28];
          float32x4_t v29 = &unk_1EE4AA6E8;
          uint64_t v37 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v29 forKeys:&v28 count:1];
          float32x4_t v19 = (void *)MEMORY[0x1E4F1C9E8];
          uint64_t v20 = 3;
        }
        else
        {
          uint64_t v21 = *MEMORY[0x1E4F2FD40];
          uint64_t v32 = v17;
          uint64_t v33 = v21;
          uint64_t v30 = *MEMORY[0x1E4F2FD28];
          int8x16_t v31 = &unk_1EE4AA6E8;
          uint64_t v36 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v31 forKeys:&v30 count:1];
          float32x4_t v19 = (void *)MEMORY[0x1E4F1C9E8];
          uint64_t v20 = 2;
        }
        CFDictionaryRef v22 = (const __CFDictionary *)[v19 dictionaryWithObjects:&v35 forKeys:&v32 count:v20];
        double v23 = (void *)saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::context;
        [(CIImage *)a1 extent];
        uint64_t v24 = objc_msgSend(v23, "createCGImage:fromRect:format:colorSpace:", a1, 2056, v7);
        if (v24)
        {
          int8x16_t v25 = (CGImage *)v24;
          double v26 = CGImageDestinationCreateWithURL((CFURLRef)[MEMORY[0x1E4F1CB10] fileURLWithPath:a2], @"public.tiff", 0, 0);
          if (v26)
          {
            float64x2_t v27 = v26;
            CGImageDestinationAddImage(v26, v25, v22);
            CGImageDestinationFinalize(v27);
            CFRelease(v27);
          }
          CGImageRelease(v25);
        }
        if (v8) {
          CGColorSpaceRelease(v7);
        }
      }
    }
    else
    {
      NSLog(&cfstr_CanTSaveNilIma.isa);
    }
  }
}

void sub_193744CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_193745B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

const char *___ZL21saveImageWithKeywordsP7CIImageP8NSStringbP7NSArray_block_invoke()
{
  v4[3] = *MEMORY[0x1E4F143B8];
  uint64_t v0 = getenv("CI_SAVE_IMAGES");
  if (v0) {
    int v1 = atoi(v0);
  }
  else {
    int v1 = saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::saveImages;
  }
  saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::saveImages = v1 != 0;
  double result = getenv("CI_METAL_SDOF");
  if (result) {
    double result = (const char *)atoi(result);
  }
  if (v1)
  {
    v3[0] = @"kCIContextUseMetalRenderer";
    v4[0] = [NSNumber numberWithBool:result != 0];
    v4[1] = @"CIDisparityRefinement-saveImageWithKeywords";
    v3[1] = @"kCIContextName";
    v3[2] = @"working_format";
    void v4[2] = [NSNumber numberWithInt:2056];
    double result = +[CIContext contextWithOptions:](CIContext, "contextWithOptions:", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v4 forKeys:v3 count:3]);
    saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::context = (uint64_t)result;
  }
  return result;
}

double cikernel::_gray(float a1)
{
  *(float *)&double v1 = a1;
  *((float *)&v1 + 1) = a1;
  return v1;
}

void cikernel::_CIInitialConversionRGB(uint64_t a1, float32x2_t a2)
{
  *(float32x2_t *)&v3.f64[0] = vmul_f32(a2, *(float32x2_t *)CI::getDC((CI *)a1));
  float64x2_t v39 = v3;
  float32x2_t v4 = vadd_f32(*(float32x2_t *)&v3.f64[0], (float32x2_t)3221225472);
  *(float *)&double v5 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v4, 1), *(float *)(a1 + 16), v4.f32[0]);
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  v7.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *(float *)(a1 + 24) + *(float *)&v5;
  *(float *)v3.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v10.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v4, v3, v5, v6, v8, v7, v9);
  float32x4_t v38 = v10;
  float64x2_t v11 = v39;
  *(float32x2_t *)v10.f32 = vadd_f32(*(float32x2_t *)&v39.f64[0], (float32x2_t)0x40000000);
  *(float *)&double v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v10.f32, 1), *(float *)(a1 + 16), v10.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v10.f32, 1), *(float *)&v13, v10.f32[0]);
  v10.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v11.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v10.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v10.i64, v11, v12, v13, v15, v14, v16);
  float32x4_t v37 = v17;
  float64x2_t v18 = v39;
  *(float32x2_t *)v17.f32 = vadd_f32(*(float32x2_t *)&v39.f64[0], (float32x2_t)0x4000000000000000);
  *(float *)&double v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v17.f32, 1), *(float *)(a1 + 16), v17.f32[0]);
  LODWORD(v2CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v17.f32, 1), *(float *)&v20, v17.f32[0]);
  v17.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v18.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v17.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, v18, v19, v20, v22, v21, v23);
  int8x16_t v36 = v24;
  float64x2_t v25 = v39;
  *(float32x2_t *)v24.i8 = vadd_f32(*(float32x2_t *)&v39.f64[0], (float32x2_t)0xC000000000000000);
  *(float *)&double v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v24.i8, 1), *(float *)(a1 + 16), *(float *)v24.i32);
  LODWORD(v27) = *(_DWORD *)(a1 + 28);
  v28.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v24.i8, 1), *(float *)&v27, *(float *)v24.i32);
  *(float *)v24.i32 = *(float *)(a1 + 24) + *(float *)&v26;
  *(float *)v25.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  *(float *)&v24.i32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v24.i64, v25, v26, v27, v29, v28, v30);
  *(float *)&double v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v39.f64[0], 1), *(float *)(a1 + 16), *(float *)v39.f64);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v39.f64[0], 1), *(float *)(a1 + 28), *(float *)v39.f64);
  *(float *)&double v34 = *(float *)(a1 + 24) + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  *((float *)&v34 + 1) = *(float *)v32.i32 + *(float *)v33.i32;
  CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v34, v35, v31, *(double *)vabdq_f32(v37, v38).i64, v33, v32, v36);
}

double cikernel::_CIPyramidGenerateLevel(cikernel *this, SamplerObj *a2)
{
  uint64_t DC = (float32x2_t *)CI::getDC(this);
  float32x2_t v4 = vadd_f32(*DC, *DC);
  float32x2_t v5 = vadd_f32(v4, (float32x2_t)0xBF000000BF000000);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v11);
  float32x4_t v39 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v4, (float32x2_t)0x3F000000BF000000);
  *(float *)&double v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18);
  float32x4_t v38 = v19;
  *(float32x2_t *)v19.f32 = vadd_f32(v4, (float32x2_t)0xBF0000003F000000);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v19.f32, 1), *((float *)this + 4), v19.f32[0]);
  LODWORD(v21) = *((_DWORD *)this + 7);
  v22.i32[0] = *((_DWORD *)this + 9);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v19.f32, 1), *(float *)&v21, v19.f32[0]);
  v19.f32[0] = *((float *)this + 6) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v19.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, v24, v20, v21, v23, v22, v25);
  float32x4_t v37 = v26;
  *(float32x2_t *)v26.f32 = vadd_f32(v4, (float32x2_t)0x3F0000003F000000);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v26.f32, 1), *((float *)this + 4), v26.f32[0]);
  LODWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = *((_DWORD *)this + 7);
  v29.i32[0] = *((_DWORD *)this + 9);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v26.f32, 1), *(float *)&v28, v26.f32[0]);
  v26.f32[0] = *((float *)this + 6) + *(float *)&v27;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v26.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v26.i64, v31, v27, v28, v30, v29, v32);
  float32x4_t v34 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v38, v39)), 3)), (int8x16_t)v38, (int8x16_t)v39);
  float32x4_t v35 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v37, v34)), 3)), (int8x16_t)v37, (int8x16_t)v34);
  *(void *)&double result = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v33, v35)), 3)), (int8x16_t)v33, (int8x16_t)v35).u64[0];
  return result;
}

double cikernel::_CISmoothDisparity(uint64_t a1, float32x4_t a2)
{
  float v3 = a2.f32[1];
  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  int8x16_t v82 = (int8x16_t)v4;
  float32x2_t v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)3212836864);
  *(float *)&double v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10);
  float32x4_t v80 = v11;
  LODWORD(v12) = *(_DWORD *)(a1 + 28);
  v11.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v82.i8, 1), *(float *)(a1 + 16), *(float *)v82.i32);
  LODWORD(v13) = *(_DWORD *)(a1 + 36);
  *(float *)v14.f64 = *(float *)&v13
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v82.i8, 1), *(float *)&v12, *(float *)v82.i32);
  v11.i32[1] = LODWORD(v14.f64[0]);
  double v17 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v14, v12, v13, v82, v15, v16);
  float v79 = *(float *)&v17;
  float64x2_t v18 = (float64x2_t)v82;
  float32x2_t v19 = vadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)0x3F80000000000000);
  *(float *)&double v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v19, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v19, 1), *(float *)&v21, v19.f32[0]);
  v19.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v18.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v19.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v19, v18, v20, v21, v23, v22, v24);
  float32x4_t v78 = v25;
  float64x2_t v26 = (float64x2_t)v82;
  *(float32x2_t *)v25.f32 = vadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)0x3F800000BF800000);
  *(float *)&double v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.f32, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v2_Block_object_dispose(&STACK[0x3A0], 8) = *(_DWORD *)(a1 + 28);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.f32, 1), *(float *)&v28, v25.f32[0]);
  v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v27;
  *(float *)v26.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v25.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v26, v27, v28, v30, v29, v31);
  float32x4_t v77 = v32;
  float64x2_t v33 = (float64x2_t)v82;
  *(float32x2_t *)v32.f32 = vadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)1065353216);
  *(float *)&double v34 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v32.f32, 1), *(float *)(a1 + 16), v32.f32[0]);
  LODWORD(v35) = *(_DWORD *)(a1 + 28);
  v36.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v32.f32, 1), *(float *)&v35, v32.f32[0]);
  v32.f32[0] = *(float *)(a1 + 24) + *(float *)&v34;
  *(float *)v33.f64 = *(float *)v36.i32 + *(float *)v37.i32;
  v32.f32[1] = *(float *)v36.i32 + *(float *)v37.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v32.i64, v33, v34, v35, v37, v36, v38);
  float32x4_t v76 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  float64x2_t v44 = (float64x2_t)v82;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)v82.i8, *(float32x2_t *)_Q0.f32);
  *(float *)&double v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a1 + 28);
  v47.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v46, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v45;
  *(float *)v44.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  _Q0.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v44, v45, v46, v48, v47, v49);
  float32x4_t v75 = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  float64x2_t v51 = (float64x2_t)v82;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)v82.i8, *(float32x2_t *)_Q0.f32);
  *(float *)&double v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a1 + 28);
  v54.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v53, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v52;
  *(float *)v51.f64 = *(float *)v54.i32 + *(float *)v55.i32;
  _Q0.f32[1] = *(float *)v54.i32 + *(float *)v55.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v51, v52, v53, v55, v54, v56);
  float32x4_t v74 = v57;
  float64x2_t v58 = (float64x2_t)v82;
  *(float32x2_t *)v57.f32 = vadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)0xBF80000000000000);
  *(float *)&double v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v57.f32, 1), *(float *)(a1 + 16), v57.f32[0]);
  LODWORD(v6CI::NodeWithChildren::NodeWithChildren(this, 0) = *(_DWORD *)(a1 + 28);
  v61.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v57.f32, 1), *(float *)&v60, v57.f32[0]);
  v57.f32[0] = *(float *)(a1 + 24) + *(float *)&v59;
  *(float *)v58.f64 = *(float *)v61.i32 + *(float *)v62.i32;
  v57.f32[1] = *(float *)v61.i32 + *(float *)v62.i32;
  *(double *)v64.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v57.i64, v58, v59, v60, v62, v61, v63);
  float32x4_t v73 = v64;
  float64x2_t v65 = (float64x2_t)v82;
  *(float32x2_t *)v64.f32 = vadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)0xBFC000003FC00000);
  *(float *)&double v66 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v64.f32, 1), *(float *)(a1 + 16), v64.f32[0]);
  LODWORD(v67) = *(_DWORD *)(a1 + 28);
  v68.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v64.f32, 1), *(float *)&v67, v64.f32[0]);
  v64.f32[0] = *(float *)(a1 + 24) + *(float *)&v66;
  *(float *)v65.f64 = *(float *)v68.i32 + *(float *)v69.i32;
  v64.f32[1] = *(float *)v68.i32 + *(float *)v69.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v64.i64, v65, v66, v67, v69, v68, v70);
  v71.i64[0] = vaddq_f32(vaddq_f32(vaddq_f32(v77, v75), v74), v71).u64[0];
  v71.f32[0] = vmuls_lane_f32(vmlas_n_f32(vmlas_n_f32(v79, a2.f32[0], vaddq_f32(vaddq_f32(vaddq_f32(v80, v78), v76), v73).f32[0]), v3, v71.f32[0]), a2, 2);
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)v71.f32, 0).u64[0];
  return result;
}