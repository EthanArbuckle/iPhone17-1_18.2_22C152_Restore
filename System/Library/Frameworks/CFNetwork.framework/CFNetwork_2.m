CFTypeRef URLDownload::_internal_copySuggestedFilenameFromOriginalFilename(URLDownload *this, CFTypeRef cf)
{
  CFTypeRef v3;
  CFArrayRef v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  char *ValueAtIndex;
  char *v9;
  char *v10;
  uint64_t v11;
  CFAllocatorRef v12;
  uint64_t v13;

  v3 = CFRetain(cf);
  v4 = (const __CFArray *)*((void *)this + 32);
  if (!v4) {
    return v3;
  }
  Count = CFArrayGetCount(v4);
  if (Count < 1) {
    return v3;
  }
  v6 = Count;
  for (i = 0; i != v6; ++i)
  {
    ValueAtIndex = (char *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), i);
    if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
      dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2928);
    }
    if (ValueAtIndex) {
      v9 = ValueAtIndex + 16;
    }
    else {
      v9 = 0;
    }
    v10 = v9 - 16;
    v11 = (*(uint64_t (**)(char *))(*(void *)v9 + 56))(v9);
    v12 = CFGetAllocator(v10);
    v13 = (*(uint64_t (**)(uint64_t, CFAllocatorRef, CFTypeRef))(*(void *)v11 + 48))(v11, v12, v3);
    if (v3) {
      CFRelease(v3);
    }
    v3 = (CFTypeRef)v13;
  }
  return (CFTypeRef)v13;
}

uint64_t AsyncTargetFile::equals(AsyncTargetFile *this, const CFAllocatedReferenceCountedObject *a2)
{
  return 0;
}

void AsyncTargetFile::~AsyncTargetFile(AsyncTargetFile *this)
{
  AsyncTargetFile::~AsyncTargetFile(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  uint8_t v2[16];

  *(void *)this = &unk_1ECF9D050;
  if (*((_DWORD *)this + 5) != -1 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "you should have closed the file by now", v2, 2u);
  }
  dispatch_release(*((dispatch_object_t *)this + 3));
}

uint64_t ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke_2;
  v5[3] = &__block_descriptor_60_e61_v16__0__CFURLDownloadClient_q_v_____________________________8l;
  v5[4] = v3;
  v5[5] = a2;
  v5[6] = *(void *)(a1 + 40);
  int v6 = a3;
  return URLDownload::_internal_withClientScheduling(v3, (uint64_t)v5);
}

uint64_t ___ZN15AsyncTargetFile5writeEPK8__CFDataS2_U13block_pointerFvmiE_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(_DWORD *)(v2 + 20) != -1)
  {
    CFDataRef v3 = (const __CFData *)a1[6];
    if (!v3) {
      goto LABEL_13;
    }
    BytePtr = CFDataGetBytePtr(v3);
    uint64_t v5 = a1[7];
    if (v5 < 1) {
      goto LABEL_13;
    }
    int v6 = BytePtr;
    v7 = &BytePtr[v5];
    do
    {
      while (1)
      {
        ssize_t v8 = write(*(_DWORD *)(v2 + 20), v6, v7 - v6);
        if (v8 == -1) {
          break;
        }
        v6 += v8;
        *(void *)(v2 + 32) += v8;
        if (v6 >= v7) {
          goto LABEL_13;
        }
      }
      int v9 = *__error();
      --v6;
      --*(void *)(v2 + 32);
    }
    while (v6 < v7);
    if (v9)
    {
      if (close(*(_DWORD *)(v2 + 20))) {
        __error();
      }
      *(_DWORD *)(v2 + 20) = -1;
    }
    else
    {
LABEL_13:
      CFDataRef v10 = (const __CFData *)a1[8];
      if (v10)
      {
        int v11 = *(_DWORD *)(v2 + 20);
        v12 = CFDataGetBytePtr(v10);
        if (fsetxattr(v11, "com.apple.ResourceFork", v12, a1[9], *(_DWORD *)(v2 + 40), 0))
        {
          if (close(*(_DWORD *)(v2 + 20))) {
            __error();
          }
          *(_DWORD *)(v2 + 20) = -1;
        }
        *(void *)(v2 + 40) += a1[9];
      }
    }
  }
  v13 = (const void *)a1[6];
  if (v13) {
    CFRelease(v13);
  }
  v14 = (const void *)a1[8];
  if (v14) {
    CFRelease(v14);
  }
  (*(void (**)(void))(a1[4] + 16))();
  v15 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 48);

  return v15(v2);
}

void ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 304));
  *(void *)(v2 + 296) -= v3;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 304));
  if (*(_DWORD *)(v2 + 308) && !(*(void *)(v2 + 296) >> 18))
  {
    *(_DWORD *)(v2 + 308) = 0;
    CFURLConnectionResume(*(void *)(a1 + 48));
  }
  if (!*(unsigned char *)(v2 + 287))
  {
    if (*(_DWORD *)(a1 + 56))
    {
      CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)(v2 - 16));
      CFError = __cfnCreateCFError(v5, @"kCFErrorDomainCFNetwork", -3003, v6, v7, v8, v9, v10, 0);
      URLDownload::_internal_downloadCancel((URLDownload *)v2, CFError);
      if (CFError) {
        CFRelease(CFError);
      }
    }
    else
    {
      uint64_t v12 = *(void *)(v2 + 168);
      if (v12)
      {
        v13 = *(void (**)(uint64_t, void, void))(v12 + 80);
        if (v13) {
          v13(v2 - 16, *(void *)(a1 + 40), *(void *)(v12 + 8));
        }
      }
    }
  }
  v4 = *(const void **)(a1 + 48);
  if (v4) {
    CFRelease(v4);
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

void DownloadConnectionClient::_didReceiveDataCallback(DownloadConnectionClient *this, CFDataRef theData, const __CFData *a3, URLDownload *a4, const void *a5)
{
  if ((const __CFData *)CFDataGetLength(theData) != a3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v9 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "originalLength is not really necessary here.", v9, 2u);
  }
  uint64_t v7 = URLDownload::_internal_downloadProcessData(a4, theData);
  if (v7)
  {
    uint64_t v8 = v7;
    URLDownload::_internal_downloadCancel(a4, v7);
    CFRelease(v8);
  }
}

void DownloadConnectionClient::_didReceiveResponseCallback(DownloadConnectionClient *this, _CFURLResponse *a2, _CFURLResponse *a3, const void *a4)
{
  if (!*((unsigned char *)a3 + 286))
  {
    *((unsigned char *)a3 + 286) = 1;
    uint64_t v12 = *((void *)a3 + 21);
    if (v12)
    {
      v13 = *(void (**)(char *, void))(v12 + 40);
      if (v13) {
        v13((char *)a3 - 16, *(void *)(v12 + 8));
      }
    }
  }
  URLDownload::_internal_setResponse((URLDownload *)a3, a2);
  int v6 = *((unsigned __int8 *)a3 + 285);
  uint64_t v7 = *(void *)([(_CFURLResponse *)a2 _inner] + 88);
  if (!v7)
  {
    if (v6)
    {
LABEL_14:
      *((void *)a3 + 34) = 0;
      v14 = (const void *)*((void *)a3 + 25);
      if (v14)
      {
        CFRelease(v14);
        char v11 = 0;
        *((void *)a3 + 25) = 0;
      }
      else
      {
        char v11 = 0;
      }
LABEL_24:
      if (*((unsigned char *)a3 + 285))
      {
        *((unsigned char *)a3 + 285) = v11;
        uint64_t v23 = *((void *)a3 + 21);
        if (v23)
        {
          v24 = *(void (**)(char *, _CFURLResponse *, uint64_t, uint64_t))(v23 + 72);
          if (v24)
          {
            uint64_t v25 = *((void *)a3 + 34);
            uint64_t v26 = *(void *)(v23 + 8);
            v24((char *)a3 - 16, a2, v25, v26);
          }
        }
      }
      else
      {
        v27 = (void *)*((void *)a3 + 21);
        if (v27 && v27[9])
        {
          v28 = (void (*)(char *, _CFURLResponse *, uint64_t))v27[8];
          uint64_t v29 = v27[1];
          v28((char *)a3 - 16, a2, v29);
        }
      }
      return;
    }
LABEL_9:
    char v11 = 1;
    goto LABEL_24;
  }
  CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)(v7 - 16));
  CFIndex v9 = ResponseStatusCode;
  if ((unint64_t)(ResponseStatusCode - 100) < 0x12C)
  {
    if (ResponseStatusCode != 206 && v6 != 0) {
      goto LABEL_14;
    }
    goto LABEL_9;
  }
  CFAllocatorRef v15 = CFGetAllocator((char *)a3 - 16);
  if (v9 == 403) {
    CFIndex v21 = -1102;
  }
  else {
    CFIndex v21 = -1100;
  }
  CFError = __cfnCreateCFError(v15, @"kCFErrorDomainCFNetwork", v21, v16, v17, v18, v19, v20, 0);
  URLDownload::_internal_downloadCancel((URLDownload *)a3, CFError);
  if (CFError)
  {
    CFRelease(CFError);
  }
}

void URLDownload::_internal_setResponse(URLDownload *this, _CFURLResponse *a2)
{
  uint64_t v2 = a2;
  v4 = (_CFURLResponse *)*((void *)this + 23);
  if (v4 != a2)
  {

    uint64_t v2 = v2;
    *((void *)this + 23) = v2;
  }
  if (v2 && ((v5 = *(void *)([(_CFURLResponse *)v2 _inner] + 88)) != 0 ? (uint64_t v6 = v5 - 16) : (uint64_t v6 = 0), v5))
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    uint64_t v7 = (HTTPMessage *)(v6 + 16);
    CFStringRef v8 = HTTPMessage::copyHeaderFieldValue(v7, 0x12609303u);
    if (v8)
    {
      CFStringRef v9 = v8;
      URLDownload::_internal_setEntityTag(this, v8);
      CFRelease(v9);
    }
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    CFStringRef v10 = HTTPMessage::copyHeaderFieldValue(v7, 0x12E1B32Cu);
    if (v10)
    {
      CFStringRef v11 = v10;
      URLDownload::_internal_setServerModificationDateString(this, v10);
      CFRelease(v11);
    }
  }
  else
  {
    uint64_t v12 = (const void *)*((void *)this + 29);
    if (v12)
    {
      CFRelease(v12);
      *((void *)this + 29) = 0;
    }
    v13 = (const void *)*((void *)this + 30);
    if (v13)
    {
      CFRelease(v13);
      *((void *)this + 30) = 0;
    }
  }
}

CFStringRef URLDownload::_internal_setEntityTag(URLDownload *this, const __CFString *a2)
{
  CFStringRef result = (CFStringRef)*((void *)this + 29);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2)
    {
      CFAllocatorRef v5 = CFGetAllocator((char *)this - 16);
      CFStringRef result = CFStringCreateCopy(v5, a2);
    }
    else
    {
      CFStringRef result = 0;
    }
    *((void *)this + 29) = result;
  }
  return result;
}

CFStringRef URLDownload::_internal_setServerModificationDateString(URLDownload *this, const __CFString *a2)
{
  CFStringRef result = (CFStringRef)*((void *)this + 30);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2)
    {
      CFAllocatorRef v5 = CFGetAllocator((char *)this - 16);
      CFStringRef result = CFStringCreateCopy(v5, a2);
    }
    else
    {
      CFStringRef result = 0;
    }
    *((void *)this + 30) = result;
  }
  return result;
}

CFTypeRef DownloadConnectionClient::_willSendRequestCallback(DownloadConnectionClient *this, CFTypeRef cf, const _CFURLRequest *a3, _CFURLResponse *a4, const void *a5)
{
  if (!*((unsigned char *)a4 + 286))
  {
    *((unsigned char *)a4 + 286) = 1;
    uint64_t v10 = *((void *)a4 + 21);
    if (v10)
    {
      CFStringRef v11 = *(void (**)(char *, void))(v10 + 40);
      if (v11) {
        v11((char *)a4 - 16, *(void *)(v10 + 8));
      }
    }
  }
  uint64_t v8 = *((void *)a4 + 21);
  if (v8
    && (CFStringRef v9 = *(uint64_t (**)(char *, CFTypeRef, const _CFURLRequest *, void, const void *))(v8 + 48)) != 0)
  {
    cf = (CFTypeRef)v9((char *)a4 - 16, cf, a3, *(void *)(v8 + 8), a5);
    if (cf) {
      return cf;
    }
  }
  else if (cf)
  {
    CFRetain(cf);
    return cf;
  }
  if (a3) {
    URLDownload::_internal_downloadFinished((URLDownload *)a4);
  }
  else {
    URLDownload::_internal_downloadFailed((URLDownload *)a4, 0);
  }
  return 0;
}

CFStringRef DownloadConnectionClient::_copyDescription(DownloadConnectionClient *this, const void *a2)
{
  CFStringRef v2 = CFCopyDescription((char *)this - 16);
  CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"CFURLConnectionClient[%@]", v2);
  CFRelease(v2);
  return v3;
}

void DownloadConnectionClient::_implRelease(DownloadConnectionClient *this, const void *a2)
{
}

DownloadConnectionClient *DownloadConnectionClient::_implRetain(DownloadConnectionClient *this, const void *a2)
{
  return this;
}

const _CFURLRequest *URLDownload::_internal_setRequest(URLDownload *this, _CFURLRequest *a2)
{
  CFStringRef result = (const _CFURLRequest *)*((void *)this + 3);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2)
    {
      CFGetAllocator((char *)this - 16);
      CFStringRef result = (const _CFURLRequest *)[(_CFURLRequest *)a2 copy];
    }
    else
    {
      CFStringRef result = 0;
    }
    *((void *)this + 3) = result;
  }
  return result;
}

void ___ZN9TCFObjectI13URLConnectionE5ClassEv_block_invoke_5473()
{
}

void sub_1841ED460(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void URLDownload::URLDownload(URLDownload *this)
{
  *(void *)this = &unk_1ECF9B1F8;
  *((void *)this + 1) = &unk_1ECF9B240;
  *((void *)this + 20) = 0;
  *((void *)this + 36) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)this);
  *((_DWORD *)this + 76) = 0;
  *((unsigned char *)this + 320) = 1;
}

void sub_1841ED4FC(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

BOOL objectExistsAtURL(CFURLRef url)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v3, url, 0, 0, 1u);
  return v3 && lstat(v4, &v2) == 0;
}

CFDictionaryRef URLDownload::_internal_downloadCreateResumeInfoDictionaryInternal(URLDownload *this, CFAllocatorRef allocator, const __CFURL *a3)
{
  CFNumberRef v6 = CFNumberCreate(allocator, kCFNumberSInt64Type, (char *)this + 272);
  if (v6)
  {
    CFNumberRef v7 = v6;
    CFStringRef v8 = CFURLGetString(a3);
    if (!v8) {
      goto LABEL_34;
    }
    CFStringRef v9 = v8;
    CFArrayRef v10 = (const __CFArray *)*((void *)this + 32);
    if (v10)
    {
      uint64_t Count = CFArrayGetCount(v10);
      if (Count)
      {
        Mutable = CFArrayCreateMutable(allocator, Count, MEMORY[0x1E4F1D510]);
        if (Mutable)
        {
          if (Count >= 1)
          {
            for (CFIndex i = 0; i != Count; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), i);
              if (ValueAtIndex)
              {
                CFAllocatorRef v15 = ValueAtIndex;
                if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
                  dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2928);
                }
                uint64_t v16 = (*(uint64_t (**)(void))(v15[2] + 56))();
                CFAllocatorRef v17 = CFGetAllocator(v15);
                uint64_t v18 = (const void *)(*(uint64_t (**)(uint64_t, CFAllocatorRef))(*(void *)v16 + 80))(v16, v17);
                if (v18)
                {
                  uint64_t v19 = v18;
                  CFArrayAppendValue(Mutable, v18);
                  CFRelease(v19);
                }
              }
            }
          }
          if (Count == CFArrayGetCount(Mutable)) {
            goto LABEL_18;
          }
          CFRelease(Mutable);
          Mutable = 0;
        }
        LOBYTE(Count) = 1;
      }
      else
      {
        Mutable = 0;
      }
LABEL_22:
      if (!*((void *)this + 28)
        || (CFIndex v21 = *(const void **)([*((id *)this + 3) _inner] + 32)) != 0
        && CFEqual(*((CFTypeRef *)this + 28), v21))
      {
        CFStringRef v22 = 0;
        if (Count) {
          goto LABEL_34;
        }
      }
      else
      {
        CFStringRef v22 = CFURLGetString(*((CFURLRef *)this + 28));
        if (Count) {
          goto LABEL_34;
        }
      }
      uint64_t v23 = CFDictionaryCreateMutable(allocator, 6, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
      if (v23)
      {
        v24 = v23;
        CFDictionarySetValue(v23, @"NSURLDownloadURL", v9);
        CFDictionarySetValue(v24, @"NSURLDownloadBytesReceived", v7);
        CFDictionarySetValue(v24, @"NSURLDownloadServerModificationDate", *((const void **)this + 30));
        CFDictionarySetValue(v24, @"NSURLDownloadEntityTag", *((const void **)this + 29));
        if (v22) {
          CFDictionarySetValue(v24, @"NSURLDownloadOriginatingURLString", v22);
        }
        if (Mutable) {
          CFDictionarySetValue(v24, @"NSURLDownloadDecoders", Mutable);
        }
        CFDictionaryRef Copy = CFDictionaryCreateCopy(allocator, v24);
        CFRelease(v24);
        goto LABEL_35;
      }
LABEL_34:
      CFDictionaryRef Copy = 0;
LABEL_35:
      CFRelease(v7);
      return Copy;
    }
    Mutable = 0;
LABEL_18:
    LOBYTE(Count) = 0;
    goto LABEL_22;
  }
  return 0;
}

CFDictionaryRef URLDownload::createResumeInformation(URLDownload *this, const __CFAllocator *a2)
{
  uint64_t v4 = [*((id *)this + 3) _inner];
  CFURLRef v5 = *(const __CFURL **)(v4 + 8);
  if (v5)
  {
    CFStringRef v6 = CFURLCopyScheme(*(CFURLRef *)(v4 + 8));
    if (v6)
    {
      CFStringRef v7 = v6;
      CFArrayRef v8 = (const __CFArray *)*((void *)this + 32);
      if (v8 && (CFIndex Count = CFArrayGetCount(v8)) != 0)
      {
        CFIndex v10 = Count;
        if (Count < 1)
        {
          CFIndex v11 = 0;
        }
        else
        {
          CFIndex v11 = 0;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), v11);
            if (ValueAtIndex)
            {
              v13 = ValueAtIndex;
              if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
                dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2928);
              }
              uint64_t v14 = (*(uint64_t (**)(void *))(v13[2] + 56))(v13 + 2);
              if (!(*(unsigned int (**)(uint64_t))(*(void *)v14 + 72))(v14)) {
                break;
              }
            }
            if (v10 == ++v11)
            {
              CFIndex v11 = v10;
              break;
            }
          }
        }
        BOOL v16 = v11 == v10;
      }
      else
      {
        BOOL v16 = 1;
      }
      if (!*((unsigned char *)this + 282) && !*((unsigned char *)this + 284) && *((void *)this + 29))
      {
        CFDictionaryRef ResumeInfoDictionaryInternal = 0;
        if (!v16 || !*((void *)this + 30)) {
          goto LABEL_20;
        }
        if (CFStringCompare(v7, @"http", 1uLL) == kCFCompareEqualTo
          || CFStringCompare(v7, (CFStringRef)&unk_1EC0A5D78, 1uLL) == kCFCompareEqualTo)
        {
          CFStringRef v18 = (const __CFString *)CFURLRequestCopyHTTPRequestMethod(*((void **)this + 3));
          if (v18)
          {
            CFStringRef v19 = v18;
            if (CFStringCompare(v18, @"GET", 1uLL)) {
              CFDictionaryRef ResumeInfoDictionaryInternal = 0;
            }
            else {
              CFDictionaryRef ResumeInfoDictionaryInternal = URLDownload::_internal_downloadCreateResumeInfoDictionaryInternal(this, a2, v5);
            }
            CFRelease(v19);
            goto LABEL_20;
          }
        }
      }
      CFDictionaryRef ResumeInfoDictionaryInternal = 0;
LABEL_20:
      CFRelease(v7);
      return ResumeInfoDictionaryInternal;
    }
  }
  return 0;
}

void URLDownload::useCredential(URLDownload *this, const _CFURLCredential *a2, CFTypeRef cf2)
{
  if (cf2)
  {
    uint64_t v4 = (const void *)*((void *)this + 24);
    if (v4)
    {
      if (CFEqual(v4, cf2))
      {
        CFRelease(*((CFTypeRef *)this + 24));
        *((void *)this + 24) = 0;
        uint64_t v7 = *((void *)this + 2);
        CFURLConnectionUseCredential(v7, (uint64_t)a2, (uint64_t)cf2);
      }
    }
  }
}

uint64_t _CFURLCreateDataAndPropertiesFromResource(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](a1, a2, a3);
  CFURLRef v5 = v4;
  CFArrayRef v7 = v6;
  CFStringRef v9 = v8;
  CFIndex v11 = v10;
  CFURLRef v13 = v12;
  CFAllocatorRef v14 = (const __CFAllocator *)v3;
  valuePtr[4500] = *MEMORY[0x1E4F143B8];
  CFStringRef v15 = CFURLCopyScheme(v12);
  if (v15)
  {
    CFStringRef v16 = v15;
    if (CFStringCompare(v15, @"http", 1uLL) && CFStringCompare(v16, (CFStringRef)&unk_1EC0A5D78, 1uLL))
    {
      if (CFStringCompare(v16, @"ftp", 1uLL))
      {
        if (v11) {
          *CFIndex v11 = 0;
        }
        if (v9) {
          *CFStringRef v9 = 0;
        }
        if (v5)
        {
          unsigned __int8 v17 = 0;
          int v18 = -11;
LABEL_69:
          *CFURLRef v5 = v18;
LABEL_81:
          CFRelease(v16);
          return v17;
        }
        goto LABEL_70;
      }
      if (v9) {
        *CFStringRef v9 = 0;
      }
      if (!v11)
      {
        if (v5)
        {
          unsigned __int8 v17 = 0;
          int v18 = -15;
          goto LABEL_69;
        }
        goto LABEL_70;
      }
      *CFIndex v11 = CFDataCreateMutable(v14, 0);
      v37 = CFReadStreamCreateWithFTPURL(v14, v13);
      CFReadStreamSetProperty(v37, @"kCFStreamPropertyFTPAttemptPersistentConnection", (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
      if (CFReadStreamOpen(v37))
      {
        while (1)
        {
          uint64_t v38 = CFReadStreamRead(v37, (UInt8 *)valuePtr, 36000);
          if (v38 < 1) {
            break;
          }
          CFDataAppendBytes(*v11, (const UInt8 *)valuePtr, v38);
        }
        CFReadStreamClose(v37);
      }
      CFStreamError Error = CFReadStreamGetError(v37);
      if (v5)
      {
        *CFURLRef v5 = Error.error;
        CFRelease(v37);
        if (!*v5) {
          goto LABEL_74;
        }
LABEL_72:
        CFRelease(*v11);
        unsigned __int8 v17 = 0;
        *CFIndex v11 = 0;
        goto LABEL_81;
      }
      CFRelease(v37);
      if (Error.error) {
        goto LABEL_72;
      }
LABEL_74:
      unsigned __int8 v17 = 1;
      goto LABEL_81;
    }
    if (v5) {
      *CFURLRef v5 = 0;
    }
    if (v11)
    {
      CFStringRef v19 = &kCFHTTPMethodGet;
    }
    else
    {
      if (!v9) {
        goto LABEL_74;
      }
      if (v7 && !CFArrayGetCount(v7))
      {
        *CFStringRef v9 = 0;
        goto LABEL_74;
      }
      CFStringRef v19 = &kCFHTTPMethodHead;
    }
    Request = CFHTTPMessageCreateRequest(v14, (CFStringRef)*v19, v13, @"HTTP/1.0");
    CFIndex v21 = _CFHTTPMessageSendRequest(Request);
    CFStringRef v22 = Request;
    uint64_t v23 = v21;
    CFRelease(v22);
    if (!v23)
    {
      if (v11) {
        *CFIndex v11 = 0;
      }
      if (v9) {
        *CFStringRef v9 = 0;
      }
      if (v5)
      {
        unsigned __int8 v17 = 0;
        int v18 = -14;
        goto LABEL_69;
      }
LABEL_70:
      unsigned __int8 v17 = 0;
      goto LABEL_81;
    }
    if (v11)
    {
      CFDataRef v24 = CFHTTPMessageCopyBody(v23);
      if (!v24) {
        CFDataRef v24 = CFDataCreate(v14, 0, 0);
      }
      *CFIndex v11 = v24;
    }
    CFStringRef v47 = v16;
    if (v9)
    {
      if (v7)
      {
        uint64_t Count = CFArrayGetCount(v7);
        *CFStringRef v9 = CFDictionaryCreateMutable(v14, Count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (Count >= 1)
        {
          CFAllocatorRef allocator = v14;
          CFIndex v26 = 0;
          CFStringRef v27 = (const __CFString *)*MEMORY[0x1E4F1D658];
          CFStringRef v28 = (const __CFString *)*MEMORY[0x1E4F1D650];
          unsigned __int8 v17 = 1;
          v49 = v23;
          while (1)
          {
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v26);
            if (ValueAtIndex == v27)
            {
              CFStringRef v33 = CFHTTPMessageCopyResponseStatusLine(v23);
              if (!v33)
              {
                unsigned __int8 v17 = 0;
                if (v5) {
                  *CFURLRef v5 = -17;
                }
                goto LABEL_45;
              }
              CFStringRef v34 = v33;
              CFDictionarySetValue(*v9, v27, v33);
              CFNumberRef v35 = (CFNumberRef)v34;
            }
            else
            {
              CFStringRef v30 = ValueAtIndex;
              if (ValueAtIndex != v28)
              {
                CFStringRef v31 = CFHTTPMessageCopyHeaderFieldValue(v23, ValueAtIndex);
                if (v31)
                {
                  CFStringRef v32 = v31;
                  CFDictionarySetValue(*v9, v30, v31);
                  CFRelease(v32);
                }
                else
                {
                  unsigned __int8 v17 = 0;
                  if (v5) {
                    *CFURLRef v5 = -17;
                  }
                }
                uint64_t v23 = v49;
                goto LABEL_45;
              }
              valuePtr[0] = 0;
              valuePtr[0] = CFHTTPMessageGetResponseStatusCode(v23);
              CFNumberRef v36 = CFNumberCreate(allocator, kCFNumberCFIndexType, valuePtr);
              CFDictionarySetValue(*v9, v28, v36);
              CFNumberRef v35 = v36;
              uint64_t v23 = v49;
            }
            CFRelease(v35);
LABEL_45:
            if (Count == ++v26) {
              goto LABEL_80;
            }
          }
        }
      }
      else
      {
        valuePtr[0] = CFHTTPMessageGetResponseStatusCode(v23);
        CFNumberRef v39 = CFNumberCreate(v14, kCFNumberCFIndexType, valuePtr);
        CFDictionaryRef v40 = CFHTTPMessageCopyAllHeaderFields(v23);
        if (v40)
        {
          CFDictionaryRef v41 = v40;
          CFIndex v42 = CFDictionaryGetCount(v40);
          *CFStringRef v9 = CFDictionaryCreateMutableCopy(v14, v42 + 2, v41);
          CFRelease(v41);
        }
        else
        {
          *CFStringRef v9 = CFDictionaryCreateMutable(v14, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        }
        CFStringRef v44 = CFHTTPMessageCopyResponseStatusLine(v23);
        if (v44)
        {
          CFStringRef v45 = v44;
          CFDictionarySetValue(*v9, (const void *)*MEMORY[0x1E4F1D658], v44);
          CFRelease(v45);
        }
        CFDictionarySetValue(*v9, (const void *)*MEMORY[0x1E4F1D650], v39);
        CFRelease(v39);
      }
    }
    unsigned __int8 v17 = 1;
LABEL_80:
    CFRelease(v23);
    CFStringRef v16 = v47;
    goto LABEL_81;
  }
  if (v5) {
    *CFURLRef v5 = -15;
  }
  if (v11) {
    *CFIndex v11 = 0;
  }
  unsigned __int8 v17 = 0;
  if (v9) {
    *CFStringRef v9 = 0;
  }
  return v17;
}

__CFHTTPMessage *_CFHTTPMessageSendRequest(__CFHTTPMessage *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = CFGetAllocator(a1);
  *(void *)buffer = MEMORY[0x1E4F143A8];
  uint64_t v15 = 3221225472;
  CFStringRef v16 = __CFReadStreamCreateForHTTPRequest_block_invoke;
  unsigned __int8 v17 = &__block_descriptor_48_e26__v16__0____CFReadStream__8l;
  CFAllocatorRef v18 = v2;
  CFStringRef v19 = a1;
  uint64_t v3 = (__CFReadStream *)CFReadStreamCreate();
  CFWriteStreamRef v4 = CFWriteStreamCreateWithAllocatedBuffers(v2, v2);
  CFURLRef v5 = v4;
  if (v3 && v4)
  {
    CFReadStreamSetProperty(v3, (CFStreamPropertyKey)&unk_1EC0A3F80, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
    if (!CFReadStreamOpen(v3) || !CFWriteStreamOpen(v5)) {
      goto LABEL_18;
    }
    CFStreamStatus Status = CFReadStreamGetStatus(v3);
    while ((Status | 2) != 7)
    {
      uint64_t v7 = CFReadStreamRead(v3, buffer, 512);
      BOOL v8 = v7 >= 1 && CFWriteStreamWrite(v5, buffer, v7) != v7;
      CFStreamStatus Status = CFReadStreamGetStatus(v3);
      if (v8)
      {
        CFReadStreamClose(v3);
        CFWriteStreamClose(v5);
        goto LABEL_18;
      }
    }
    CFStreamStatus v10 = CFReadStreamGetStatus(v3);
    CFReadStreamClose(v3);
    CFWriteStreamClose(v5);
    if (v10 != kCFStreamStatusError)
    {
      CFDataRef v12 = (const __CFData *)CFWriteStreamCopyProperty(v5, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
      CFURLRef v13 = (__CFHTTPMessage *)CFReadStreamCopyProperty(v3, @"kCFStreamPropertyHTTPResponseHeader");
      CFStringRef v9 = v13;
      if (v13) {
        CFHTTPMessageSetBody(v13, v12);
      }
      if (v12) {
        CFRelease(v12);
      }
    }
    else
    {
LABEL_18:
      CFStringRef v9 = 0;
    }
    CFRelease(v3);
    CFRelease(v5);
  }
  else
  {
    if (v3) {
      CFRelease(v3);
    }
    if (v5) {
      CFRelease(v5);
    }
    return 0;
  }
  return v9;
}

unint64_t _CFURLWriteDataAndPropertiesToResource(const __CFURL *a1, const __CFData *a2, const __CFDictionary *a3, SInt32 *a4)
{
  CFStringRef v8 = CFURLCopyScheme(a1);
  if (v8)
  {
    CFStringRef v9 = v8;
    if (CFStringCompare(v8, @"http", 1uLL) && CFStringCompare(v9, (CFStringRef)&unk_1EC0A5D78, 1uLL))
    {
      if (CFStringCompare(v9, @"ftp", 1uLL))
      {
        if (a4)
        {
          unint64_t v10 = 0;
          int v11 = -11;
          goto LABEL_39;
        }
LABEL_42:
        unint64_t v10 = 0;
        goto LABEL_40;
      }
      if (a2)
      {
        BytePtr = CFDataGetBytePtr(a2);
        CFIndex Length = CFDataGetLength(a2);
        CFAllocatorRef v26 = CFGetAllocator(a1);
        CFWriteStreamRef v27 = CFWriteStreamCreateWithFTPURL(v26, a1);
        if (a3) {
          CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)_ApplyWriteStreamProperties, v27);
        }
        CFWriteStreamSetProperty(v27, @"kCFStreamPropertyFTPAttemptPersistentConnection", (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
        if (CFWriteStreamOpen(v27))
        {
          do
          {
            if (!Length) {
              break;
            }
            CFIndex v28 = CFWriteStreamWrite(v27, BytePtr, Length);
            BytePtr += v28;
            Length -= v28;
          }
          while (v28 > 0);
          CFWriteStreamClose(v27);
        }
        CFStreamError Error = CFWriteStreamGetError(v27);
        SInt32 v30 = Error.error;
        if (a4)
        {
          *a4 = Error.error;
          CFRelease(v27);
          SInt32 v30 = *a4;
        }
        else
        {
          CFRelease(v27);
        }
        unint64_t v10 = v30 == 0;
        goto LABEL_40;
      }
      if (!a4) {
        goto LABEL_42;
      }
      unint64_t v10 = 0;
    }
    else
    {
      CFAllocatorRef v12 = CFGetAllocator(a1);
      if (a2)
      {
        CFAllocatorRef v13 = v12;
        Request = CFHTTPMessageCreateRequest(v12, @"PUT", a1, @"HTTP/1.0");
        CFIndex v15 = CFDataGetLength(a2);
        CFStringRef v16 = CFStringCreateWithFormat(v13, 0, @"%ld", v15);
        CFHTTPMessageSetHeaderFieldValue(Request, (CFStringRef)&unk_1EC0A20E0, v16);
        CFRelease(v16);
        if (a3)
        {
          CFIndex Count = CFDictionaryGetCount(a3);
          if (Count >= 1)
          {
            CFIndex v18 = Count;
            CFStringRef v19 = (const void **)CFAllocatorAllocate(v13, 16 * Count, 0);
            uint64_t v20 = &v19[v18];
            CFDictionaryGetKeysAndValues(a3, v19, v20);
            CFIndex v21 = (CFStringRef *)v19;
            do
            {
              CFTypeID v22 = CFGetTypeID(v21[v18]);
              if (v22 == CFStringGetTypeID()) {
                CFHTTPMessageSetHeaderFieldValue(Request, *v21, v21[v18]);
              }
              ++v21;
            }
            while (v21 < (CFStringRef *)v20);
            CFAllocatorDeallocate(v13, v19);
          }
        }
        unint64_t v10 = (unint64_t)_CFHTTPMessageSendRequest(Request);
        CFRelease(Request);
        if (v10)
        {
          int ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)v10);
          CFRelease((CFTypeRef)v10);
          unint64_t v10 = (ResponseStatusCode - 200) < 0x64;
          if ((ResponseStatusCode - 200) >= 0x64) {
            int v11 = ResponseStatusCode;
          }
          else {
            int v11 = 0;
          }
          if (!a4) {
            goto LABEL_40;
          }
        }
        else
        {
          if (!a4)
          {
LABEL_40:
            CFRelease(v9);
            return v10;
          }
          int v11 = -14;
        }
LABEL_39:
        *a4 = v11;
        goto LABEL_40;
      }
      unint64_t v10 = 0;
      if (!a4) {
        goto LABEL_40;
      }
    }
    int v11 = -15;
    goto LABEL_39;
  }
  unint64_t v10 = 0;
  if (a4) {
    *a4 = -15;
  }
  return v10;
}

CFTypeID _ApplyWriteStreamProperties(const __CFString *a1, const void *a2, __CFWriteStream *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  CFTypeID result = CFStringGetTypeID();
  if (v6 == result)
  {
    return CFWriteStreamSetProperty(a3, a1, a2);
  }
  return result;
}

unint64_t _CFURLDestroyResource(const __CFURL *a1, SInt32 *a2)
{
  CFStringRef v4 = CFURLCopyScheme(a1);
  if (v4)
  {
    CFStringRef v5 = v4;
    if (CFStringCompare(v4, @"http", 1uLL) && CFStringCompare(v5, (CFStringRef)&unk_1EC0A5D78, 1uLL))
    {
      if (CFStringCompare(v5, @"ftp", 1uLL) == kCFCompareEqualTo)
      {
        CFAllocatorRef v11 = CFGetAllocator(a1);
        CFAllocatorRef v12 = CFWriteStreamCreateWithFTPURL(v11, a1);
        CFWriteStreamSetProperty(v12, @"kCFStreamPropertyFTPAttemptPersistentConnection", (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
        CFWriteStreamSetProperty(v12, @"_kCFStreamPropertyFTPRemoveResource", (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
        if (CFWriteStreamOpen(v12))
        {
          UInt8 buffer = 0;
          CFWriteStreamWrite(v12, &buffer, 1);
          CFWriteStreamClose(v12);
        }
        CFStreamError Error = CFWriteStreamGetError(v12);
        SInt32 v14 = Error.error;
        if (a2)
        {
          *a2 = Error.error;
          CFRelease(v12);
          SInt32 v14 = *a2;
        }
        else
        {
          CFRelease(v12);
        }
        unint64_t v6 = v14 == 0;
        goto LABEL_24;
      }
      unint64_t v6 = 0;
      if (a2)
      {
        int v7 = -11;
LABEL_17:
        *a2 = v7;
      }
    }
    else
    {
      CFAllocatorRef v8 = CFGetAllocator(a1);
      Request = CFHTTPMessageCreateRequest(v8, @"DELETE", a1, @"HTTP/1.0");
      unint64_t v6 = (unint64_t)_CFHTTPMessageSendRequest(Request);
      CFRelease(Request);
      if (v6)
      {
        int ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)v6);
        CFRelease((CFTypeRef)v6);
        unint64_t v6 = (ResponseStatusCode - 200) < 0x64;
        if ((ResponseStatusCode - 200) >= 0x64) {
          int v7 = ResponseStatusCode;
        }
        else {
          int v7 = 0;
        }
        if (!a2) {
          goto LABEL_24;
        }
        goto LABEL_17;
      }
      if (a2)
      {
        int v7 = -14;
        goto LABEL_17;
      }
    }
LABEL_24:
    CFRelease(v5);
    return v6;
  }
  unint64_t v6 = 0;
  if (a2) {
    *a2 = -15;
  }
  return v6;
}

CFStringRef _CFNetworkCFStringCreateWithCFDataAddress(const __CFData *a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  BytePtr = (const sockaddr *)CFDataGetBytePtr(a1);
  socklen_t Length = CFDataGetLength(a1);
  int v4 = getnameinfo(BytePtr, Length, cStr, 0x401u, 0, 0, 2);
  CFStringRef result = 0;
  if (!v4) {
    return CFStringCreateWithCString(0, cStr, 0x600u);
  }
  return result;
}

CFStringRef _CFStringCreateRFC1123DateStringWithGregorianDate(const __CFAllocator *a1, CFGregorianDate *a2, CFTimeZoneRef tz)
{
  if (tz)
  {
    CFTimeInterval SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, 0.0);
    uint64_t v6 = ((int)SecondsFromGMT / 3600);
    int v7 = (int)SecondsFromGMT % 3600;
    if (v7 >= 0) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = -v7;
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v6 = 0;
  }
  if (CFGregorianDateIsValid(*a2, 0xFFFFFFuLL)) {
    return CFStringCreateWithFormat(a1, 0, @"%02d %s %04d %02d:%02d:%02d %+03d%02d", a2->day, kMonthStrs[a2->month + 11], a2->year, a2->hour, a2->minute, (int)a2->second, v6, v8);
  }
  else {
    return 0;
  }
}

CFURLRef cfnCreateSemiColonEscapedURLIfParamterIsPresent(const __CFURL *a1)
{
  if (CFURLGetByteRangeForComponent(a1, kCFURLComponentParameterString, 0).location == -1) {
    return 0;
  }
  CFStringRef v2 = CFURLGetString(a1);
  if (!v2) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v4 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2, 0, @";", 0x8000100u);
  if (!v4) {
    return 0;
  }
  CFStringRef v5 = v4;
  CFURLRef v6 = CFURLCreateWithString(v3, v4, 0);
  CFRelease(v5);
  return v6;
}

const void *_CFNetworkErrorGetLocalizedDescription(uint64_t a1)
{
  return _CFNetworkErrorGetLocalizedString(a1, 0);
}

uint64_t _CFStreamErrorFromCFNetworkErrorCode(__CFError *a1)
{
  unint64_t Code = CFErrorGetCode(a1);
  if ((uint64_t)Code <= 99)
  {
    if (Code + 72007 >= 8)
    {
      switch(Code)
      {
        case 0xFFFFFFFFFFFFFFFELL:
          int v3 = -2095;
          goto LABEL_66;
        case 0xFFFFFFFFFFFFFFFFLL:
          return -1;
        case 0uLL:
          goto LABEL_21;
        case 1uLL:
          goto LABEL_23;
        case 2uLL:
          CFDictionaryRef v17 = CFErrorCopyUserInfo(a1);
          if (!v17)
          {
            int v16 = -2;
            goto LABEL_52;
          }
          CFDictionaryRef v18 = v17;
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v17, @"kCFGetAddrInfoFailureKey");
          if (Value) {
            CFNumberGetValue(Value, kCFNumberCFIndexType, &v23);
          }
          else {
            LODWORD(v23) = -2;
          }
          CFRelease(v18);
          return 12;
        default:
          if (Code == -73000) {
            break;
          }
LABEL_21:
          if ((Code & 0x8000000000000000) != 0)
          {
            if (Code + 73000 <= 0x3E8) {
              goto LABEL_7;
            }
          }
          else
          {
            if (Code <= 0x63)
            {
LABEL_23:
              int v16 = 1;
LABEL_52:
              LODWORD(v23) = v16;
              return 12;
            }
            if (Code <= 0xC7)
            {
              uint64_t result = (int)*MEMORY[0x1E4F1D428];
              LODWORD(v23) = 3;
              return result;
            }
            if (Code <= 0x12B)
            {
LABEL_62:
              LODWORD(v23) = -1;
              return 6;
            }
            if (Code <= 0x18F)
            {
LABEL_65:
              int v3 = -4;
LABEL_66:
              LODWORD(v23) = v3;
              return 4;
            }
          }
          return -1;
      }
    }
    LODWORD(Code) = CFErrorGetCode(a1);
LABEL_7:
    LODWORD(v23) = Code;
    return 10;
  }
  else if (Code - 100 <= 0x18 && ((1 << (Code - 100)) & 0x1F03C03) != 0)
  {
    int valuePtr = 0;
    CFIndex v5 = CFErrorGetCode(a1);
    int v6 = 0;
    int v7 = 0x10000;
    int v8 = 3;
    switch(v5)
    {
      case 'd':
        break;
      case 'e':
        goto LABEL_42;
      case 'n':
        int v6 = 0x20000;
        int v8 = 91;
        break;
      case 'o':
        int v6 = 0x20000;
        int v8 = 92;
        break;
      case 'p':
        int v6 = 0x20000;
        int v8 = 93;
        break;
      case 'q':
        int v7 = 0x20000;
        goto LABEL_42;
      case 'x':
        int v6 = 0;
        int v8 = 2;
        break;
      case 'y':
        int v6 = 0;
        int v8 = 121;
        break;
      case 'z':
        int v7 = 196608;
        goto LABEL_42;
      case '{':
        int v7 = 0x40000;
LABEL_42:
        CFDictionaryRef v20 = CFErrorCopyUserInfo(a1);
        if (v20)
        {
          CFDictionaryRef v21 = v20;
          CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(v20, @"kCFSOCKSStatusCodeKey");
          if (v22) {
            CFNumberGetValue(v22, kCFNumberSInt32Type, &valuePtr);
          }
          else {
            int valuePtr = -1;
          }
          CFRelease(v21);
          int v8 = valuePtr;
        }
        else
        {
          int v8 = -1;
        }
        int v6 = v7;
        break;
      case '|':
        int v6 = 0x40000;
        int v8 = 255;
        break;
      default:
        int v6 = 0;
        int v8 = -1;
        break;
    }
    uint64_t result = (int)*MEMORY[0x1E4F1D428];
    uint64_t v23 = v6 | v8;
  }
  else
  {
    switch(Code)
    {
      case 0x12CuLL:
        int v3 = -1000;
        goto LABEL_66;
      case 0x12DuLL:
      case 0x133uLL:
        int v3 = -1002;
        goto LABEL_66;
      case 0x12EuLL:
        goto LABEL_65;
      case 0x12FuLL:
        int v3 = -1;
        goto LABEL_66;
      case 0x130uLL:
        int v3 = -2;
        goto LABEL_66;
      case 0x131uLL:
        int v3 = -3;
        goto LABEL_66;
      case 0x132uLL:
        int v3 = -2094;
        goto LABEL_66;
      case 0x134uLL:
      case 0x135uLL:
        goto LABEL_21;
      case 0x136uLL:
        int v3 = -2096;
        goto LABEL_66;
      case 0x137uLL:
        int v3 = -2098;
        goto LABEL_66;
      default:
        if (Code != 200) {
          goto LABEL_21;
        }
        CFDictionaryRef v9 = CFErrorCopyUserInfo(a1);
        if (!v9) {
          goto LABEL_62;
        }
        CFDictionaryRef v10 = v9;
        CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(v9, @"kCFFTPStatusCodeKey");
        if (v11 && (CFStringRef v12 = v11, v13 = CFGetTypeID(v11), v13 == CFStringGetTypeID()))
        {
          SInt32 IntValue = CFStringGetIntValue(v12);
          if (IntValue) {
            int v15 = IntValue;
          }
          else {
            int v15 = -1;
          }
        }
        else
        {
          int v15 = -1;
        }
        LODWORD(v23) = v15;
        CFRelease(v10);
        break;
    }
    return 6;
  }
  return result;
}

void non-virtual thunk to'HTTPMessage::parserAddHeader(HTTPMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  CFIndex v5 = (CFDictionaryRef *)HTTPMessage::mutableHeaders((HTTPMessage *)((char *)this - 16));

  HTTPHeaderDict::addValue(v5, a2, a3);
}

void HTTPMessage::parserAddHeader(HTTPMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  CFIndex v5 = (CFDictionaryRef *)HTTPMessage::mutableHeaders(this);

  HTTPHeaderDict::addValue(v5, a2, a3);
}

void HTTPMessage::visitAllHeaderFields(HTTPMessage *a1, uint64_t a2)
{
  HTTPMessage::ensureParserFinished(a1);
  uint64_t v4 = HTTPMessage::headers((os_unfair_lock_s *)a1);
  uint64_t context = a2;
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(v4 + 8), (CFDictionaryApplierFunction)visit, &context);
}

void HTTPHeaderValueMixedValue::~HTTPHeaderValueMixedValue(HTTPHeaderValueMixedValue *this)
{
  *(void *)this = &unk_1ECF9F718;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9F718;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

void HTTPMessage::addHeaderFieldStringValue(HTTPMessage *this, const __CFString *a2, const __CFString *a3)
{
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v8, a2);
  HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue((HTTPHeaderValueMixedValue *)&v6, a3);
  CFIndex v5 = (CFDictionaryRef *)HTTPMessage::mutableHeaders(this);
  HTTPHeaderDict::addValue(v5, (const HTTPHeaderKeyMixedValue *)&v8, (const HTTPHeaderValueMixedValue *)&v6);
  int v6 = &unk_1ECF9F718;
  if (cf) {
    CFRelease(cf);
  }
  int v8 = &unk_1ECF9F718;
  if (v9) {
    CFRelease(v9);
  }
}

void sub_1841EF318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef a10, uint64_t a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void HTTPMessage::logMsgHeaders(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v3 = HTTPMessage::headers(a1);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZN11HTTPMessage13logMsgHeadersEP17DiagnosticLoggingPKc_block_invoke;
  v4[3] = &__block_descriptor_40_e36_v24__0____CFString__8____CFArray__16l;
  v4[4] = a2;
  HTTPHeaderDict::visitHeaders(v3, 1, (uint64_t)v4);
}

uint64_t ___ZN11HTTPMessage13logMsgHeadersEP17DiagnosticLoggingPKc_block_invoke(uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  if (__CFNCanLogSensitiveContent::onceToken != -1) {
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_38);
  }
  if (!__CFNCanLogSensitiveContent::ok)
  {
    uint64_t v10 = *(void *)(a1 + 32);
    CFTypeRef v9 = *(uint64_t (**)(uint64_t, uint64_t, __CFString *))(*(void *)v10 + 64);
    CFStringRef ValueAtIndex = @"<redacted>";
LABEL_7:
    uint64_t v11 = a2;
    return v9(v10, v11, ValueAtIndex);
  }
  CFIndex Count = CFArrayGetCount(theArray);
  uint64_t v7 = *(void *)(a1 + 32);
  if (Count == 1)
  {
    CFStringRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(theArray, 0);
    CFTypeRef v9 = *(uint64_t (**)(uint64_t, uint64_t, __CFString *))(*(void *)v7 + 64);
    uint64_t v10 = v7;
    goto LABEL_7;
  }
  CFTypeRef v9 = *(uint64_t (**)(uint64_t, uint64_t, __CFString *))(*(void *)v7 + 88);
  uint64_t v10 = v7;
  uint64_t v11 = a2;
  CFStringRef ValueAtIndex = (__CFString *)theArray;

  return v9(v10, v11, ValueAtIndex);
}

void HTTPMessage::setTrailerFields(HTTPMessage *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v4 = (const void *)*((void *)this + 14);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 14) = cf;
}

void std::__shared_ptr_pointer<__CFDictionary *,Deleter_CFRelease,std::allocator<__CFDictionary>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void DomainAndPartition::~DomainAndPartition(DomainAndPartition *this)
{
  *(void *)this = &unk_1ECF9F1A0;
  CFStringRef v2 = (char *)*((void *)this + 35);
  if (v2) {
    BOOL v3 = v2 == (char *)this + 24;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    free(v2);
  }

  JUMPOUT(0x18531B6D0);
}

{
  char *v2;
  BOOL v3;

  *(void *)this = &unk_1ECF9F1A0;
  CFStringRef v2 = (char *)*((void *)this + 35);
  if (v2) {
    BOOL v3 = v2 == (char *)this + 24;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    free(v2);
  }
}

uint64_t DomainAndPartition::init(void *a1, uint64_t a2, uint64_t a3, char *__s, uint64_t a5, uint64_t a6)
{
  a1[1] = a2;
  a1[2] = a3;
  a1[35] = 0;
  a1[38] = 0;
  a1[39] = 0;
  a1[37] = 0;
  if (!a5 || !a6) {
    __assert_rtn("init", "HTTPCookiePartitionHelpers.cpp", 137, "partition != nil && partitionLen > 0");
  }
  size_t v10 = strlen(__s);
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  CFDictionaryRef v17 = ___ZN18DomainAndPartition4initE25CFAbsoluteTimeAsSpecifiedPKhS2_m_block_invoke;
  CFDictionaryRef v18 = &__block_descriptor_72_e11_v24__0_8_16l;
  uint64_t v11 = 2 * (v10 + a6);
  uint64_t v12 = v11 + 5;
  CFStringRef v19 = a1;
  CFDictionaryRef v20 = __s;
  size_t v21 = v10;
  uint64_t v22 = a5;
  uint64_t v23 = a6;
  if ((unint64_t)(v11 + 5) > 0xFF)
  {
    a1[36] = v12;
    SInt32 v14 = (char *)malloc_type_malloc(v11 + 5, 0xE61DE4C8uLL);
    CFTypeID v13 = v17;
  }
  else
  {
    CFTypeID v13 = ___ZN18DomainAndPartition4initE25CFAbsoluteTimeAsSpecifiedPKhS2_m_block_invoke;
    SInt32 v14 = (char *)(a1 + 3);
  }
  a1[35] = v14;
  return v13((uint64_t)v16, v14, (uint64_t)&v14[v12]);
}

uint64_t ___ZN18DomainAndPartition4initE25CFAbsoluteTimeAsSpecifiedPKhS2_m_block_invoke(uint64_t a1, char *__dst, uint64_t a3)
{
  int v6 = *(void **)(a1 + 32);
  v6[37] = __dst;
  strncpy(__dst, *(const char **)(a1 + 40), *(void *)(a1 + 48));
  uint64_t v7 = *(void *)(a1 + 48);
  __dst[v7] = 0;
  int v8 = &__dst[v7 + 1];
  v6[38] = v8;
  CFTypeRef v9 = &strncpy(v8, *(const char **)(a1 + 56), *(void *)(a1 + 64))[*(void *)(a1 + 64)];
  *v9++ = 0;
  v6[39] = v9;
  return snprintf(v9, a3 - (void)v9, "%.*s{%.*s}", *(void *)(a1 + 48), *(const char **)(a1 + 40), *(void *)(a1 + 64), *(const char **)(a1 + 56));
}

void *DomainAndPartition::DomainAndPartition(void *a1, char *__s, char *a3, uint64_t a4, uint64_t a5)
{
  *a1 = &unk_1ECF9F1A0;
  if (a3 && *a3)
  {
    size_t v10 = strlen(a3);
    DomainAndPartition::init(a1, a4, a5, __s, (uint64_t)a3, v10);
  }
  else
  {
    DomainAndPartition::init(a1, a4, a5, __s);
  }
  return a1;
}

CFStringRef HTTPCookieStoragePolicy::init(uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, const __CFDictionary *a9, char a10)
{
  *(void *)(a1 + 56) = a7;
  *(void *)(a1 + 64) = a8;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 40) = a5;
  if (cf) {
    CFTypeRef v14 = CFRetain(cf);
  }
  else {
    CFTypeRef v14 = 0;
  }
  *(void *)(a1 + CFRetain((char *)this - 16) = v14;
  if (a3) {
    CFTypeRef v15 = CFRetain(a3);
  }
  else {
    CFTypeRef v15 = 0;
  }
  *(void *)(a1 + 24) = v15;
  int v16 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (a4) {
    CFStringRef result = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@", a4);
  }
  else {
    CFStringRef result = 0;
  }
  *(void *)(a1 + 32) = result;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 72) = a6;
  if (a9)
  {
    CFDictionaryCreateMutableCopy(*v16, 0, a9);
    operator new();
  }
  if (*(unsigned char *)(a1 + 97)) {
    *(unsigned char *)(a1 + 97) = 0;
  }
  *(unsigned char *)(a1 + 98) = a10;
  return result;
}

uint64_t HTTPCookieStoragePolicy::HTTPCookieStoragePolicy(uint64_t a1, const void *a2, const void *a3, uint64_t a4, int a5, int a6, const __CFDictionary *a7, char a8)
{
  *(void *)a1 = &unk_1ECFA2990;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(_WORD *)(a1 + 96) = 0;
  HTTPCookieStoragePolicy::init(a1, a2, a3, a4, a5, a6, 0, 0, a7, a8);
  return a1;
}

void sub_1841EFAB4(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(std::__shared_weak_count **)(v1 + 88);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPCookieStoragePolicy::isTopLevelNavigation(HTTPCookieStoragePolicy *this)
{
  int valuePtr = 0;
  if (this
    && (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(this, @"_kCFHTTPCookiePolicyPropertyIsTopLevelNavigation")) != 0)
  {
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    return valuePtr;
  }
  else
  {
    return 0;
  }
}

uint64_t HTTPCookieStoragePolicy::isURLInSiteForCookie(HTTPCookieStoragePolicy *this, uint64_t a2, const __CFURL *a3)
{
  if (*((unsigned char *)this + 97)) {
    return *((unsigned __int8 *)this + 96);
  }
  CFIndex v5 = (HTTPCookieStorage *)*((void *)this + 2);
  CFDictionaryRef v6 = (const __CFDictionary *)*((void *)this + 10);
  if (v6) {
    CFURLRef Value = (const __CFURL *)CFDictionaryGetValue(v6, @"_kCFHTTPCookiePolicyPropertySiteForCookies");
  }
  else {
    CFURLRef Value = 0;
  }
  uint64_t result = HTTPCookieStorage::isURLInMainDocumentDomain(v5, Value, a3);
  *((_WORD *)this + 48) = result | 0x100;
  return result;
}

void non-virtual thunk to'HTTP3Connection::~HTTP3Connection(HTTP3Connection *this)
{
  HTTP3Connection::~HTTP3Connection((HTTP3Connection *)((char *)this - 24));

  JUMPOUT(0x18531B6D0);
}

{
  HTTP3Connection::~HTTP3Connection((HTTP3Connection *)((char *)this - 24));
}

void std::__shared_ptr_emplace<HTTP3Framer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6598;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTP3Framer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6598;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t HTTP3Connection::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 920) |= 2u;
  BOOL v3 = *(char **)(a1 + 1136);
  uint64_t v4 = *(char **)(a1 + 1144);
  if (v3 == v4)
  {
    HTTP3Connection::_cleanupConnection((HTTP3Connection *)a1, 256, 0);
    BOOL v3 = *(char **)(a1 + 1136);
    uint64_t v4 = *(char **)(a1 + 1144);
  }
  long long v15 = xmmword_1843D1780;
  uint64_t v12 = 0;
  CFTypeID v13 = 0;
  uint64_t v14 = 0;
  std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(&v12, v3, v4, (v4 - v3) >> 4);
  CFDictionaryRef v6 = v12;
  for (CFIndex i = v13; v6 != i; v6 += 2)
  {
    uint64_t v9 = *v6;
    int v8 = (std::__shared_weak_count *)v6[1];
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if ((a2 & 0xFFFFFFFD) == 1
      && (*(unsigned int (**)(void, long long *, void))(**(void **)(v9 + 296) + 280))(*(void *)(v9 + 296), &v15, 0)- 5 <= 5)
    {
      long long v10 = v15;
      HTTP3Stream::_cleanupStream(v9, 256, 0);
      *(_OWORD *)(v9 + 264) = v10;
      HTTP3Stream::_protocolCallback((HTTP3Stream *)v9);
    }
    else
    {
      (*(void (**)(void, uint64_t))(**(void **)(v9 + 296) + 248))(*(void *)(v9 + 296), a2);
    }
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
  }
  int v16 = (void **)&v12;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&v16);
  return 1;
}

void sub_1841EFDC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  a16 = (void **)&a10;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a16);
  _Unwind_Resume(a1);
}

void HTTP3Connection::_stopStallRecovery(HTTP3Connection *this)
{
  *((unsigned char *)this + 920) &= ~0x20u;
  CFStringRef v2 = *((void *)this + 124);
  if (v2)
  {
    dispatch_source_cancel(v2);
    BOOL v3 = (void *)*((void *)this + 124);
    *((void *)this + 124) = 0;
  }
}

void HTTP3Connection::connErrorOccurred(HTTP3Connection *this, CFStreamError a2)
{
  *(CFStreamError *)((char *)this + 1160) = a2;
  HTTP3Connection::_cleanupConnection(this, -1, 0);
}

void HTTP3Connection::connEventDisconnected(HTTP3Connection *this)
{
  *((unsigned char *)this + 920) |= 2u;
  if (*((void *)this + 142) == *((void *)this + 143)) {
    HTTP3Connection::_cleanupConnection(this, 256, 0);
  }
}

void HTTP3Connection::connEventReadClose(HTTP3Connection *this)
{
  *((unsigned char *)this + 920) |= 2u;
  if (*((void *)this + 142) == *((void *)this + 143)) {
    HTTP3Connection::_cleanupConnection(this, 256, 0);
  }
}

void ___ZN15HTTP3Connection10initializeEv_block_invoke(uint64_t a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    BOOL v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && *(void *)(v5 + 1008))
      {
        if ((*(unsigned char *)(v5 + 920) & 8) != 0)
        {
          *(_DWORD *)int valuePtr = 3;
          CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, valuePtr);
          v20[0] = MEMORY[0x1E4F143A8];
          v20[1] = 3221225472;
          size_t v21 = ___ZN15HTTP3Connection12_handleStallEv_block_invoke;
          uint64_t v22 = &__block_descriptor_40_e5_v8__0l;
          CFNumberRef v23 = v6;
          if (v6)
          {
            (*(void (**)(void, uint64_t, CFNumberRef))(**(void **)(v5 + 1008) + 200))(*(void *)(v5 + 1008), 0x1EC09EFE0, v6);
            v21((uint64_t)v20);
          }
          else
          {
            ___ZN15HTTP3Connection12_handleStallEv_block_invoke((uint64_t)v20);
          }
        }
        if (!*(void *)(v5 + 992))
        {
          uint64_t v7 = CFN_LOG_h3connection();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
          {
            uint64_t v8 = *(void *)(v5 + 1216);
            *(_DWORD *)int valuePtr = 134218240;
            *(void *)&valuePtr[4] = v5;
            *(_WORD *)&valuePtr[12] = 2048;
            *(void *)&valuePtr[14] = v8;
            _os_log_impl(&dword_184085000, v7, OS_LOG_TYPE_INFO, "%p %llu start stall recovery", valuePtr, 0x16u);
          }

          *(unsigned char *)(v5 + 920) |= 0x20u;
          dispatch_source_t v9 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(v5 + 1000));
          long long v10 = *(void **)(v5 + 992);
          *(void *)(v5 + 992) = v9;

          uint64_t v12 = *(void *)(v5 + 8);
          uint64_t v11 = *(std::__shared_weak_count **)(v5 + 16);
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          *(void *)int valuePtr = MEMORY[0x1E4F143A8];
          *(void *)&valuePtr[8] = 3321888768;
          *(void *)&valuePtr[16] = ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke;
          CFStringRef v31 = &__block_descriptor_56_ea8_40c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE_e5_v8__0l;
          uint64_t v32 = v5;
          uint64_t v33 = v12;
          CFStringRef v34 = v11;
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          CFTypeID v13 = _Block_copy(valuePtr);
          uint64_t v14 = *(NSObject **)(v5 + 992);
          handler[0] = MEMORY[0x1E4F143A8];
          handler[1] = 3221225472;
          handler[2] = ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_30;
          handler[3] = &unk_1E5257FD8;
          id v15 = v13;
          id v29 = v15;
          dispatch_source_set_cancel_handler(v14, handler);
          int v16 = *(NSObject **)(v5 + 992);
          v24[0] = MEMORY[0x1E4F143A8];
          v24[1] = 3321888768;
          v24[2] = ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_2;
          v24[3] = &unk_1ECFA96C8;
          id v17 = v15;
          id v25 = v17;
          uint64_t v26 = v12;
          CFWriteStreamRef v27 = v11;
          if (v11) {
            atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          dispatch_source_set_event_handler(v16, v24);
          CFDictionaryRef v18 = *(NSObject **)(v5 + 992);
          dispatch_time_t v19 = dispatch_time(0x8000000000000000, 4000000000);
          dispatch_source_set_timer(v18, v19, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
          (*(void (**)(void, void, uint64_t))(**(void **)(v5 + 1008) + 136))(*(void *)(v5 + 1008), 0, 1);
          dispatch_resume(*(dispatch_object_t *)(v5 + 992));
          if (v27) {
            std::__shared_weak_count::__release_weak(v27);
          }

          if (v34) {
            std::__shared_weak_count::__release_weak(v34);
          }
          if (v11) {
            std::__shared_weak_count::__release_weak(v11);
          }
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1841F0328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *), uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,std::__shared_weak_count *a33)
{
  a12(&a10);
  std::__shared_weak_count::__release_shared[abi:nn180100](v33);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke_2(uint64_t a1, void *a2, int a3, unint64_t a4)
{
  id v50 = a2;
  if (*(int *)(*(void *)(a1 + 40) + 792) - 1 < a4)
  {
    HTTP3Connection::_cleanupConnection(*(HTTP3Connection **)(a1 + 48), 264, 0);
    HTTP3Connection::reportServerProtocolViolation(*(void *)(a1 + 48), 55, -1);
    goto LABEL_98;
  }
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = (std::__shared_weak_count *)operator new(0xB8uLL);
  dispatch_source_t v9 = v8;
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6598;
  long long v10 = &v8[1].__vftable;
  uint64_t v11 = *(void *)(v7 + 1008);
  if (v11) {
    uint64_t v12 = v11 + 112;
  }
  else {
    uint64_t v12 = 0;
  }
  CFTypeID v13 = *(std::__shared_weak_count **)(v7 + 1016);
  v52[0] = v12;
  v52[1] = (uint64_t)v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HTTP3Framer::HTTP3Framer((uint64_t)&v8[1], v52, 0, 1, 1);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v13);
  }
  v51[0] = v10;
  v51[1] = v9;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)v51, v10, (uint64_t)v10);
  HTTP3Framer::setReadHandleBeforeReading((uint64_t)v10, *(void **)(a1 + 32), v50, a3);
  uint64_t v14 = *(void *)(a1 + 48);
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  if (*(_DWORD *)(v14 + 792) <= (int)a4) {
    goto LABEL_13;
  }
  unint64_t v15 = *(unsigned int *)(v14 + 796);
  if ((int)v15 <= (int)a4)
  {
    if ((int)v15 < (int)a4)
    {
      do
      {
        std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(v14 + 800, v15, v15);
        std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(v14 + 840, v15, v15);
        unint64_t v15 = (v15 + 1);
      }
      while (a4 != v15);
    }
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(v14 + 800, a4, a4);
    *(_DWORD *)(v14 + 796) = a4 + 1;
LABEL_17:
    *(void *)&long long v16 = v10;
    *((void *)&v16 + 1) = v9;
    long long v49 = v16;
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    unint64_t v17 = *(void *)(v14 + 888);
    if (v17)
    {
      uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
      v18.i16[0] = vaddlv_u8(v18);
      if (v18.u32[0] > 1uLL)
      {
        unint64_t v15 = (int)a4;
        if (v17 <= (int)a4) {
          unint64_t v15 = (int)a4 % v17;
        }
      }
      else
      {
        unint64_t v15 = (v17 - 1) & (int)a4;
      }
      dispatch_time_t v19 = *(uint64_t ***)(*(void *)(v14 + 880) + 8 * v15);
      if (v19)
      {
        for (CFIndex i = *v19; i; CFIndex i = (uint64_t *)*i)
        {
          unint64_t v21 = i[1];
          if (v21 == (int)a4)
          {
            if (*((_DWORD *)i + 4) == a4)
            {
              CFStringRef v47 = (std::__shared_weak_count *)*((void *)&v49 + 1);
              goto LABEL_90;
            }
          }
          else
          {
            if (v18.u32[0] > 1uLL)
            {
              if (v21 >= v17) {
                v21 %= v17;
              }
            }
            else
            {
              v21 &= v17 - 1;
            }
            if (v21 != v15) {
              break;
            }
          }
        }
      }
    }
    uint64_t v22 = (char *)operator new(0x28uLL);
    CFNumberRef v23 = (void *)(v14 + 896);
    *(void *)uint64_t v22 = 0;
    *((void *)v22 + 1) = (int)a4;
    *((_DWORD *)v22 + 4) = a4;
    *(_OWORD *)(v22 + 24) = v49;
    float v24 = (float)(unint64_t)(*(void *)(v14 + 904) + 1);
    float v25 = *(float *)(v14 + 912);
    if (v17 && (float)(v25 * (float)v17) >= v24)
    {
LABEL_80:
      uint64_t v42 = *(void *)(v14 + 880);
      v43 = *(void **)(v42 + 8 * v15);
      if (v43)
      {
        *(void *)uint64_t v22 = *v43;
      }
      else
      {
        *(void *)uint64_t v22 = *v23;
        *CFNumberRef v23 = v22;
        *(void *)(v42 + 8 * v15) = v23;
        if (!*(void *)v22) {
          goto LABEL_89;
        }
        unint64_t v44 = *(void *)(*(void *)v22 + 8);
        if ((v17 & (v17 - 1)) != 0)
        {
          if (v44 >= v17) {
            v44 %= v17;
          }
        }
        else
        {
          v44 &= v17 - 1;
        }
        v43 = (void *)(*(void *)(v14 + 880) + 8 * v44);
      }
      void *v43 = v22;
LABEL_89:
      ++*(void *)(v14 + 904);
      CFStringRef v47 = 0;
LABEL_90:
      if (v47) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v47);
      }
      CFStringRef v45 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((void *)(v14 + 672), a4);
      if (v45)
      {
        uint64_t v46 = v45[3];
        if (v46)
        {
          if (HTTP2ServerPushStream::_invokeCompletionHadlers(v46, 0)) {
            HTTP2ServerPush::_removeStream((HTTP2ServerPush *)(v14 + 624), a4, 1);
          }
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
      goto LABEL_97;
    }
    BOOL v26 = 1;
    if (v17 >= 3) {
      BOOL v26 = (v17 & (v17 - 1)) != 0;
    }
    unint64_t v27 = v26 | (2 * v17);
    unint64_t v28 = vcvtps_u32_f32(v24 / v25);
    if (v27 <= v28) {
      int8x8_t prime = (int8x8_t)v28;
    }
    else {
      int8x8_t prime = (int8x8_t)v27;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v17 = *(void *)(v14 + 888);
    if (*(void *)&prime > v17) {
      goto LABEL_46;
    }
    if (*(void *)&prime < v17)
    {
      unint64_t v36 = vcvtps_u32_f32((float)*(unint64_t *)(v14 + 904) / *(float *)(v14 + 912));
      if (v17 < 3 || (uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v17), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        unint64_t v36 = std::__next_prime(v36);
      }
      else
      {
        uint64_t v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2) {
          unint64_t v36 = v38;
        }
      }
      if (*(void *)&prime <= v36) {
        int8x8_t prime = (int8x8_t)v36;
      }
      if (*(void *)&prime >= v17)
      {
        unint64_t v17 = *(void *)(v14 + 888);
      }
      else
      {
        if (prime)
        {
LABEL_46:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          SInt32 v30 = operator new(8 * *(void *)&prime);
          CFStringRef v31 = *(void **)(v14 + 880);
          *(void *)(v14 + 880) = v30;
          if (v31) {
            operator delete(v31);
          }
          uint64_t v32 = 0;
          *(int8x8_t *)(v14 + 888) = prime;
          do
            *(void *)(*(void *)(v14 + 880) + 8 * v32++) = 0;
          while (*(void *)&prime != v32);
          uint64_t v33 = (void *)*v23;
          if (*v23)
          {
            unint64_t v34 = v33[1];
            uint8x8_t v35 = (uint8x8_t)vcnt_s8(prime);
            v35.i16[0] = vaddlv_u8(v35);
            if (v35.u32[0] > 1uLL)
            {
              if (v34 >= *(void *)&prime) {
                v34 %= *(void *)&prime;
              }
            }
            else
            {
              v34 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)(v14 + 880) + 8 * v34) = v23;
            CFNumberRef v39 = (void *)*v33;
            if (*v33)
            {
              do
              {
                unint64_t v40 = v39[1];
                if (v35.u32[0] > 1uLL)
                {
                  if (v40 >= *(void *)&prime) {
                    v40 %= *(void *)&prime;
                  }
                }
                else
                {
                  v40 &= *(void *)&prime - 1;
                }
                if (v40 != v34)
                {
                  uint64_t v41 = *(void *)(v14 + 880);
                  if (!*(void *)(v41 + 8 * v40))
                  {
                    *(void *)(v41 + 8 * v40) = v33;
                    goto LABEL_71;
                  }
                  *uint64_t v33 = *v39;
                  *CFNumberRef v39 = **(void **)(*(void *)(v14 + 880) + 8 * v40);
                  **(void **)(*(void *)(v14 + 880) + 8 * v40) = v39;
                  CFNumberRef v39 = v33;
                }
                unint64_t v40 = v34;
LABEL_71:
                uint64_t v33 = v39;
                CFNumberRef v39 = (void *)*v39;
                unint64_t v34 = v40;
              }
              while (v39);
            }
          }
          unint64_t v17 = (unint64_t)prime;
          goto LABEL_75;
        }
        v48 = *(void **)(v14 + 880);
        *(void *)(v14 + 880) = 0;
        if (v48) {
          operator delete(v48);
        }
        unint64_t v17 = 0;
        *(void *)(v14 + 888) = 0;
      }
    }
LABEL_75:
    if ((v17 & (v17 - 1)) != 0)
    {
      if (v17 <= (int)a4) {
        unint64_t v15 = (int)a4 % v17;
      }
      else {
        unint64_t v15 = (int)a4;
      }
    }
    else
    {
      unint64_t v15 = (v17 - 1) & (int)a4;
    }
    goto LABEL_80;
  }
  if (std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>((uint64_t *)(v14 + 840), a4))
  {
    goto LABEL_17;
  }
LABEL_13:
  std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  HTTP3Framer::cancelStream((uint64_t)v10, 268);
LABEL_97:
  std::__shared_weak_count::__release_shared[abi:nn180100](v9);
LABEL_98:
}

void sub_1841F09A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, id a11)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>>>::operator()[abi:nn180100](1, v12);
  std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  std::__shared_weak_count::__release_shared[abi:nn180100](v11);

  _Unwind_Resume(a1);
}

void HTTP3Connection::_readPushID(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  long long v10 = a3;
  uint64_t v11 = a5;
  uint64_t v32 = 0;
  uint64_t v33 = &v32;
  uint64_t v34 = 0x2020000000;
  char v35 = 0;
  uint64_t v28 = 0;
  id v29 = &v28;
  uint64_t v30 = 0x2810000000;
  CFStringRef v31 = &unk_18441BEED;
  uint64_t v24 = 0;
  float v25 = &v24;
  uint64_t v26 = 0x2020000000;
  char v27 = 0;
  applier[0] = MEMORY[0x1E4F143A8];
  applier[1] = 3221225472;
  applier[2] = ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke;
  applier[3] = &unk_1E5254798;
  applier[4] = &v24;
  applier[5] = &v28;
  applier[6] = &v32;
  dispatch_data_apply(v10, applier);
  if (*((unsigned char *)v33 + 24))
  {
    dispatch_data_t subrange = dispatch_data_create_subrange(v10, *((unsigned __int8 *)v25 + 24), 0xFFFFFFFFFFFFFFFFLL);

    long long v10 = subrange;
    v11[2](v11, subrange, a4, v29[4]);
  }
  else if (a4)
  {
    (*(void (**)(void, id))(**(void **)(a1 + 1008) + 80))(*(void *)(a1 + 1008), v9);
  }
  else
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v21, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
    uint64_t v13 = *(void *)(a1 + 1008);
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3321888768;
    v15[2] = ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke_2;
    v15[3] = &unk_1ECFAA258;
    uint64_t v19 = v21;
    CFDictionaryRef v20 = v22;
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    id v16 = v9;
    uint64_t v14 = v10;
    unint64_t v17 = v14;
    uint8x8_t v18 = v11;
    (*(void (**)(uint64_t, id, uint64_t, uint64_t, void *))(*(void *)v13 + 56))(v13, v16, 1, 132000, v15);

    if (v20) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v20);
    }
    if (v22) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v22);
    }
    long long v10 = v14;
  }
  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v32, 8);
}

void sub_1841F0CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  }
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose((const void *)(v31 - 136), 8);
  _Block_object_dispose((const void *)(v31 - 96), 8);

  _Unwind_Resume(a1);
}

uint64_t HTTP3Connection::reportServerProtocolViolation(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFNumberRef v6 = CFN_LOG_h3connection();
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  if (a3 == -1)
  {
    if (!v7) {
      goto LABEL_5;
    }
    uint64_t v13 = *(void *)(a1 + 1216);
    *(_DWORD *)buf = 134218496;
    uint64_t v15 = a1;
    __int16 v16 = 2048;
    uint64_t v17 = v13;
    __int16 v18 = 1024;
    int v19 = a2;
    id v9 = "%p %llu Server protocol violation 0x%02hhx";
    long long v10 = v6;
    uint32_t v11 = 28;
  }
  else
  {
    if (!v7) {
      goto LABEL_5;
    }
    uint64_t v8 = *(void *)(a1 + 1216);
    *(_DWORD *)buf = 134218752;
    uint64_t v15 = a1;
    __int16 v16 = 2048;
    uint64_t v17 = v8;
    __int16 v18 = 1024;
    int v19 = a2;
    __int16 v20 = 2048;
    uint64_t v21 = a3;
    id v9 = "%p %llu Server protocol violation 0x%02hhx on stream ID=%llu";
    long long v10 = v6;
    uint32_t v11 = 38;
  }
  _os_log_error_impl(&dword_184085000, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
LABEL_5:

  uint64_t result = *(void *)(a1 + 1008);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 344))();
  }
  return result;
}

uint64_t ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  CFNumberRef v6 = a4;
  uint64_t v7 = *(void *)(a1 + 32);
  int v19 = a4;
  uint64_t v8 = *(FILE **)(v7 + 232);
  if (v8)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
    fprintf(*(FILE **)(v7 + 232), "got %zu bytes of decoder stream", a5);
    fputc(10, *(FILE **)(v7 + 232));
  }
  if (a5 < 1)
  {
LABEL_18:
    *(_DWORD *)(v7 + 228) += a5;
    return 1;
  }
  unint64_t v9 = (unint64_t)&v6[a5];
  uint64_t v18 = 0;
  uint32_t v11 = (_DWORD *)(v7 + 192);
  int v10 = *(_DWORD *)(v7 + 192);
  char v12 = -1;
  while (1)
  {
    if (v10 != 1)
    {
      if (v10) {
        goto LABEL_17;
      }
      int v13 = (char)*v6;
      uint64_t v14 = enc_proc_header_ack;
      if (v13 < 0)
      {
        char v12 = 7;
      }
      else
      {
        uint64_t v14 = enc_proc_ici;
        int v15 = v13 & 0xC0;
        if (v15)
        {
          if (v15 != 64) {
            __assert_rtn("lsqpack_enc_decoder_in", "lsqpack.c", 2459, "(buf[0] & 0xC0) == 0x40");
          }
          char v12 = 6;
          uint64_t v14 = enc_proc_stream_cancel;
        }
        else
        {
          char v12 = 6;
        }
      }
      *(void *)(v7 + 2CFRetain((char *)this - 16) = v14;
    }
    int v16 = lsqpack_dec_int(&v19, v9, v12, &v18, (int *)(v7 + 192));
    if (v16) {
      break;
    }
    if ((*(unsigned int (**)(uint64_t, uint64_t))(v7 + 216))(v7 + 32, v18)) {
      goto LABEL_22;
    }
    int v10 = 0;
    *uint32_t v11 = 0;
    CFNumberRef v6 = v19;
LABEL_17:
    if ((unint64_t)v6 >= v9) {
      goto LABEL_18;
    }
  }
  if (v16 == -1)
  {
    *uint32_t v11 = 1;
    return 1;
  }
LABEL_22:
  HTTP3Connection::_cleanupConnection((HTTP3Connection *)v7, 514, 0);
  HTTP3Connection::reportServerProtocolViolation(v7, 32, -1);
  return 0;
}

void ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2(uint64_t a1, void *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v10 = a2;
  id v11 = a3;
  if (v11 && !a6)
  {
    char v12 = *(HTTP3Connection **)(a1 + 40);
    if (*((void *)v12 + 124))
    {
      HTTP3Connection::_stopStallRecovery(v12);
      char v12 = *(HTTP3Connection **)(a1 + 40);
    }
    HTTP3Connection::_readDecoderStream(v12, v11);
    goto LABEL_19;
  }
  if (!a6)
  {
    uint64_t v13 = *(void *)(a1 + 40);
    if ((*(unsigned char *)(v13 + 920) & 4) == 0)
    {
      uint64_t v14 = *(void *)(v13 + 1008);
      if (v14)
      {
        if ((*(uint64_t (**)(void))(*(void *)v14 + 120))(*(void *)(v13 + 1008)) != -1) {
          goto LABEL_10;
        }
        uint64_t v13 = *(void *)(a1 + 40);
      }
      *(void *)(v13 + 1160) = 4;
      *(_DWORD *)(v13 + 1168) = -1;
      HTTP3Connection::_cleanupConnection((HTTP3Connection *)v13, 260, 0);
      HTTP3Connection::reportServerProtocolViolation(*(void *)(a1 + 40), 34, -1);
      int v15 = CFN_LOG_h3connection();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      {
        uint64_t v19 = *(void *)(a1 + 40);
        uint64_t v20 = *(void *)(v19 + 1216);
        int v21 = 134218240;
        uint64_t v22 = v19;
        __int16 v23 = 2048;
        uint64_t v24 = v20;
        _os_log_fault_impl(&dword_184085000, v15, OS_LOG_TYPE_FAULT, "%p %llu Decoder stream closed but connection is alive", (uint8_t *)&v21, 0x16u);
      }
      goto LABEL_18;
    }
  }
LABEL_10:
  v26.domain = a5;
  *(void *)&v26.error = a6;
  if (HTTP3Connection::checkAndPerformFallback(*(HTTP3Connection **)(a1 + 40), v26))
  {
    int v15 = CFN_LOG_h3connection();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(void *)(a1 + 40);
      uint64_t v17 = *(void *)(v16 + 1216);
      int v21 = 134218240;
      uint64_t v22 = v16;
      __int16 v23 = 2048;
      uint64_t v24 = v17;
      _os_log_impl(&dword_184085000, v15, OS_LOG_TYPE_DEFAULT, "%p %llu Decoder stream fallback triggered", (uint8_t *)&v21, 0x16u);
    }
LABEL_18:

    goto LABEL_19;
  }
  uint64_t v18 = *(void *)(a1 + 40);
  *(unsigned char *)(v18 + 920) |= 2u;
  if (*(void *)(v18 + 1136) == *(void *)(v18 + 1144)) {
    HTTP3Connection::_cleanupConnection((HTTP3Connection *)v18, 256, 0);
  }
LABEL_19:
}

void sub_1841F1314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN15HTTP3Connection29reportServerProtocolViolationEN2H323ServerProtocolViolationEy_block_invoke(uint64_t a1, void *a2, char a3)
{
  if (a2 && (a3 & 1) == 0)
  {
    id v3 = a2;
    if (([v3 isEqualToString:@"localhost"] & 1) == 0)
    {
      id v5 = v3;
      AnalyticsSendEventLazy_delayInitStub(v4);
    }
  }
}

void sub_1841F13E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

BOOL ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke(void *a1, int a2, int a3, void *__src, unint64_t a5)
{
  uint64_t v6 = *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
  if (8 - v6 >= a5) {
    size_t v7 = a5;
  }
  else {
    size_t v7 = 8 - v6;
  }
  memcpy((void *)(*(void *)(a1[5] + 8) + v6 + 32), __src, v7);
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) += v7;
  uint64_t v8 = (unint64_t *)(*(void *)(a1[5] + 8) + 32);
  uint64_t v9 = *(void *)(a1[4] + 8);
  char v12 = (const unsigned __int8 *)*(unsigned __int8 *)(v9 + 24);
  uint64_t v13 = v8;
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = QUICUtilities::quic_vle_decode((QUICUtilities *)&v13, &v12, v8, (unint64_t *)(v9 + 24), v10);
  return *(unsigned char *)(*(void *)(a1[6] + 8) + 24) == 0;
}

void ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke_2(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v11 = a2;
  size_t v7 = a3;
  uint64_t v8 = *(void *)(a1 + 56);
  if (v7)
  {
    if (*(void *)(v8 + 992))
    {
      HTTP3Connection::_stopStallRecovery(*(HTTP3Connection **)(a1 + 56));
      uint64_t v8 = *(void *)(a1 + 56);
    }
    uint64_t v9 = *(void *)(a1 + 32);
    dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(a1 + 40), v7);
    HTTP3Connection::_readPushID(v8, v9, concat, a4, *(void *)(a1 + 48));
  }
  else
  {
    (*(void (**)(void, void))(**(void **)(v8 + 1008) + 80))(*(void *)(v8 + 1008), *(void *)(a1 + 32));
  }
}

void sub_1841F15D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_56c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 64);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_ea8_56c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 64);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(result + 64) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_ea8_48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t HTTP3Connection::_cleanupIfNoStreams(uint64_t this)
{
  *(unsigned char *)(this + 920) |= 2u;
  if (*(void *)(this + 1136) == *(void *)(this + 1144)) {
    return HTTP3Connection::_cleanupConnection((HTTP3Connection *)this);
  }
  return this;
}

void ___ZN15HTTP3Connection12_handleStallEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    double v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = a1[5];
      if (v6)
      {
        size_t v7 = CFN_LOG_h3connection();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          uint64_t v8 = *(void *)(v3 + 1216);
          unsigned int v9 = *(unsigned __int8 *)(v6 + 920);
          int v12 = 134218752;
          uint64_t v13 = v3;
          __int16 v14 = 2048;
          uint64_t v15 = v8;
          __int16 v16 = 1024;
          int v17 = (v9 >> 4) & 1;
          __int16 v18 = 1024;
          int v19 = (v9 >> 5) & 1;
          _os_log_impl(&dword_184085000, v7, OS_LOG_TYPE_INFO, "%p %llu stall recovery timer done (fb=%d sip=%d)", (uint8_t *)&v12, 0x22u);
        }

        char v10 = *(unsigned char *)(v6 + 920);
        if ((v10 & 0x30) == 0x20)
        {
          *(unsigned char *)(v6 + 920) = v10 & 0xDF;
          uint64_t v11 = *(void *)(v6 + 1008);
          if (v11) {
            (*(void (**)(uint64_t, void, void))(*(void *)v11 + 136))(v11, 0, 0);
          }
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    }
  }
}

void sub_1841F17FC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_30(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_2(void *a1)
{
  (*(void (**)(void))(a1[4] + 16))();
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      double v4 = v3;
      id v5 = (HTTP3Connection *)a1[5];
      if (v5 && *((void *)v5 + 124)) {
        HTTP3Connection::_stopStallRecovery(v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void __destroy_helper_block_ea8_40c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_40c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_emplace<HTTP3Stream>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA65D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTP3Stream>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA65D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'HTTP3StreamWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  id v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 120))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_1841F19B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'HTTP3StreamWrapper::~HTTP3StreamWrapper(HTTP3StreamWrapper *this)
{
  uint64_t v2 = (char *)this - 24;
  *((void *)this - 3) = &unk_1ECF9F1C0;
  *(void *)this = &unk_1ECF9F298;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v4, v2);
}

{
  std::__shared_weak_count *v1;

  *((void *)this - 3) = &unk_1ECF9F1C0;
  *(void *)this = &unk_1ECF9F298;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t HTTP3StreamWrapper::_meta_release(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

uint64_t HTTP3StreamWrapper::_meta_retain(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

uint64_t HTTP3StreamWrapper::setTransactionMetrics(HTTP3StreamWrapper *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(void, __CFN_TransactionMetrics *))(**((void **)this + 4) + 136))(*((void *)this + 4), a2);
}

uint64_t HTTP3StreamWrapper::getProxy(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 128))();
}

void HTTP3StreamWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  id v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 120))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_1841F1BB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTP3StreamWrapper::_conn_no_more_reqests_after_this_one_connectionLost(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 112))();
}

uint64_t HTTP3StreamWrapper::copyTrust(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 104))();
}

uint64_t HTTP3StreamWrapper::getConnectionIdentifier(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 96))();
}

uint64_t HTTP3StreamWrapper::rawBytesReceived(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 88))();
}

uint64_t HTTP3StreamWrapper::rawBytesSent(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 80))();
}

uint64_t HTTP3StreamWrapper::setPriorityHint(HTTP3StreamWrapper *this, float a2)
{
  return (*(uint64_t (**)(float))(**((void **)this + 4) + 72))(a2);
}

uint64_t HTTP3StreamWrapper::updateScheduling(HTTP3StreamWrapper *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(void, const CoreSchedulingSet *))(**((void **)this + 4) + 64))(*((void *)this + 4), a2);
}

uint64_t HTTP3StreamWrapper::closeAndClearHandler(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 56))();
}

uint64_t HTTP3StreamWrapper::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

uint64_t HTTP3StreamWrapper::canScheduleAndOpenWithHandlerAsync(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 40))();
}

uint64_t HTTP3StreamWrapper::setBodyStreamBeforeOpening(HTTP3StreamWrapper *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(void, __CFReadStream *))(**((void **)this + 4) + 32))(*((void *)this + 4), a2);
}

uint64_t HTTP3StreamWrapper::setProperty(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))();
}

uint64_t HTTP3StreamWrapper::copyProperty(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))();
}

uint64_t ___ZN15HTTP3Connection22logConnectionAtAPSleepEv_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 1008);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 432))();
  }
  return result;
}

uint64_t ___ZN15HTTP3Connection26markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 1008);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 160))();
  }
  return result;
}

uint64_t NetConnection::copyTrust(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
    uint64_t v3 = *((void *)this + 12);
    uint64_t v4 = *((void *)this + 18);
    if (v3) {
      pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
    }
    if (v4) {
      goto LABEL_5;
    }
    return 0;
  }
  uint64_t v4 = *((void *)this + 18);
  if (!v4) {
    return 0;
  }
LABEL_5:
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  ++*(void *)(v4 + 96);
  uint64_t result = (*(uint64_t (**)(void, void *))(**(void **)(v4 + 40) + 40))(*(void *)(v4 + 40), &unk_1EC0A1238);
  --*(void *)(v4 + 96);
  return result;
}

uint64_t NetConnection::cleanAbortRequestTransmission(uint64_t this)
{
  *(_WORD *)(this + 88) &= ~0x20u;
  if (*(void *)(this + 128) == *(void *)(this + 136)) {
    *(void *)(this + 136) = 0;
  }
  return this;
}

void NetConnection::closeConnectionStreams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    CoreStreamBase::_streamInterface_Close((CoreStreamBase *)(a3 + 16));
  }
  if (a4)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    CoreStreamBase::_streamInterface_Close((CoreStreamBase *)(a4 + 16));
  }
}

uint64_t NetConnection::pendingResponseCount(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  uint64_t v3 = (void *)((char *)this + 136);
  LODWORD(v4) = -1;
  do
  {
    uint64_t v3 = (void *)*v3;
    uint64_t v4 = (v4 + 1);
  }
  while (v3);
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  return v4;
}

uint64_t NetConnection::connectionLost(NetConnection *this)
{
  (*(void (**)(NetConnection *))(*(void *)this + 40))(this);
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  *((_WORD *)this + 44) = *((_WORD *)this + 44) & 0xFEFE | 0x100;
  uint64_t v3 = (uint64_t **)*((void *)this + 17);
  if (v3)
  {
    uint64_t v4 = *v3;
    if (*v3)
    {
      uint64_t v9 = 4;
      int v10 = -4;
      uint64_t v5 = *((void *)this + 16);
      if (v5 && (uint64_t **)v5 != v3)
      {
        *((void *)this + CFRetain((char *)this - 16) = 0;
        NetConnection::scheduleNewRequest(this, 0, v5, 0);
      }
      NetConnection::sendStateChanged((uint64_t)this, v4, (uint64_t)&v9);
    }
  }
  NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  }
  size_t v7 = (void (*)(NetConnection *, void))*((void *)this + 23);
  if (v7) {
    v7(this, *((void *)this + 27));
  }
  return (*(uint64_t (**)(NetConnection *))(*(void *)this + 48))(this);
}

void NetConnection::scheduleNewRequest(NetConnection *this, uint64_t a2, uint64_t a3, int a4)
{
  char v8 = *((unsigned char *)this + 88);
  if (!a3 || (*((unsigned char *)this + 88) & 2) != 0)
  {
    if (*((void *)this + 18))
    {
      uint64_t v9 = (const CoreSchedulingSet *)NetConnection::copySchedulingSetForRequest((uint64_t)this, (uint64_t **)a2);
      NetConnection::rescheduleStream(*((char **)this + 18), v9);
      if (v9) {
        (*(void (**)(const CoreSchedulingSet *))(*(void *)v9 + 48))(v9);
      }
    }
  }
  __int16 v10 = *((_WORD *)this + 44);
  if ((v8 & 0x40) != 0)
  {
    if ((v10 & 0x80) == 0) {
      NetConnection::setClient((uint64_t)this);
    }
  }
  else
  {
    *((_WORD *)this + 44) = v10 | 0x40;
    NetConnection::openConnectionStreams((uint64_t)this);
  }
  if (a3)
  {
    (*(void (**)(NetConnection *, void, uint64_t, void))(*(void *)this + 120))(this, *(void *)(a3 + 8), 3, 0);
    *((_WORD *)this + 44) &= ~0x20u;
    if (a4) {
      NetConnection::scheduleNewResponse((CFTypeRef *)this, a3, 0);
    }
  }
  if (a2)
  {
    *((_WORD *)this + 44) |= 0x20u;
    uint64_t v11 = *(void *)(a2 + 8);
    int v12 = *(void (**)(NetConnection *, uint64_t, uint64_t, void))(*(void *)this + 120);
    v12(this, v11, 2, 0);
  }
}

uint64_t NetConnection::sendStateChanged(uint64_t result, uint64_t *a2, uint64_t a3)
{
  for (uint64_t i = result; a2; a2 = (uint64_t *)*a2)
    *((unsigned char *)a2 + 16) |= 1u;
LABEL_3:
  uint64_t v5 = i + 112;
  while (1)
  {
    uint64_t v5 = *(void *)v5;
    if (!v5) {
      return result;
    }
    if (*(unsigned char *)(v5 + 16))
    {
      *(unsigned char *)(v5 + 16) &= ~1u;
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)i + 120))(i, *(void *)(v5 + 8), 7, a3);
      goto LABEL_3;
    }
  }
}

uint64_t NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 96);
  if (v2) {
    this = pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  if (*(_DWORD *)(v1 + 104) || *(_DWORD *)(v1 + 108)) {
    *(_WORD *)(v1 + 88) |= 0x800u;
  }
  else {
    this = NetConnection::shutdownConnectionStreams(v1, 0);
  }
  uint64_t v3 = *(void *)(v1 + 96);
  if (v3)
  {
    return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  }
  return this;
}

uint64_t NetConnection::shutdownConnectionStreams(uint64_t this, void *a2)
{
  __int16 v2 = *(_WORD *)(this + 88);
  *(_WORD *)(this + 88) = v2 & 0xFF7F;
  if ((v2 & 0x2000) != 0)
  {
    uint64_t v4 = this;
    uint64_t v5 = *(void *)(this + 144);
    if (v5)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v5 + 16)) <= 1)
      {
        uint64_t v6 = *(void *)(v4 + 144);
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        if (v6) {
          size_t v7 = (CoreStreamBase *)(v6 + 16);
        }
        else {
          size_t v7 = 0;
        }
        CoreStreamBase::_streamInterface_Open(v7);
      }
      uint64_t v8 = *(void *)(v4 + 144);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      if (v8) {
        uint64_t v9 = v8 + 16;
      }
      else {
        uint64_t v9 = 0;
      }
      (*(void (**)(uint64_t, void, void))(*(void *)v9 + 56))(v9, 0, 0);
      uint64_t v10 = *(void *)(v4 + 144);
    }
    else
    {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(void *)(v4 + 152);
    if (v11)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v11 + 16)) <= 1)
      {
        uint64_t v12 = *(void *)(v4 + 152);
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        if (v12) {
          uint64_t v13 = (CoreStreamBase *)(v12 + 16);
        }
        else {
          uint64_t v13 = 0;
        }
        CoreStreamBase::_streamInterface_Open(v13);
      }
      uint64_t v14 = *(void *)(v4 + 152);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      if (v14) {
        uint64_t v15 = v14 + 16;
      }
      else {
        uint64_t v15 = 0;
      }
      (*(void (**)(uint64_t, void, void))(*(void *)v15 + 56))(v15, 0, 0);
      uint64_t v16 = *(void *)(v4 + 152);
    }
    else
    {
      uint64_t v16 = 0;
    }
    this = (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)v4 + 176))(v4, a2, v16, v10);
    *(_WORD *)(v4 + 88) &= ~0x2000u;
  }
  return this;
}

uint64_t NetConnection::copySchedulingSetForRequest(uint64_t a1, uint64_t **a2)
{
  if (!a2) {
    return 0;
  }
  __int16 v2 = a2;
  while (((_BYTE)v2[2] & 2) != 0)
  {
    __int16 v2 = (uint64_t **)*v2;
    if (!v2)
    {
      __int16 v2 = a2;
      return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 160))(a1, v2[1]);
    }
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 160))(a1, v2[1]);
}

void NetConnection::rescheduleStream(char *cf, const CoreSchedulingSet *a2)
{
  __int16 v2 = a2;
  if (!cf)
  {
    uint64_t v4 = 0;
    if (a2) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  CFRetain(cf);
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  uint64_t v4 = (CoreStreamBase *)(cf + 16);
  if (!v2)
  {
LABEL_7:
    if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1) {
      dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
    }
    __int16 v2 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
  }
LABEL_10:
  CoreStreamBase::_streamInterface_UpdateScheduling(v4, v2);
  if (cf)
  {
    CFRelease(cf);
  }
}

uint64_t NetConnection::openConnectionStreams(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 144);
  if (v2)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    this = CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v2 + 16));
  }
  uint64_t v3 = *(void *)(v1 + 152);
  if (v3)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    this = CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v3 + 16));
  }
  *(_WORD *)(v1 + 88) |= 0x2000u;
  return this;
}

uint64_t NetConnection::setClient(uint64_t this)
{
  uint64_t v1 = this;
  *(_WORD *)(this + 88) |= 0x80u;
  v4.version = 0;
  v4.info = (void *)this;
  v4.retain = (void *(__cdecl *)(void *))NetConnection::_retainFilter;
  v4.release = (void (__cdecl *)(void *))NetConnection::_releaseFilter;
  v4.copyDescription = (CFStringRef (__cdecl *)(void *))NetConnection::_copyDescription;
  uint64_t v2 = *(void *)(this + 144);
  if (v2)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    this = CoreWriteStream::setClient(v2 + 16, -1, (uint64_t)NetConnection::_connectionRequestCallBack, &v4);
  }
  uint64_t v3 = *(void *)(v1 + 152);
  if (v3)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    return CoreReadStream::setClient(v3 + 16, -1, (uint64_t)NetConnection::_connectionResponseCallBack, &v4);
  }
  return this;
}

void NetConnection::scheduleNewResponse(CFTypeRef *a1, uint64_t a2, uint64_t a3)
{
  if (a1[19])
  {
    uint64_t v6 = NetConnection::copySchedulingSetForRequest((uint64_t)a1, (uint64_t **)a2);
    size_t v7 = (char *)a1[19];
    if (v7)
    {
      CFRetain(a1[19]);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      uint64_t v8 = (CoreStreamBase *)(v7 + 16);
    }
    else
    {
      uint64_t v8 = 0;
    }
    uint64_t v9 = (const CoreSchedulingSet *)v6;
    if (!v6)
    {
      if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
      {
        uint64_t v12 = v8;
        dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
        uint64_t v8 = v12;
      }
      uint64_t v9 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
    }
    CoreStreamBase::_streamInterface_UpdateScheduling(v8, v9);
    if (v7) {
      CFRelease(v7);
    }
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
    }
  }
  if (a3) {
    (*((void (**)(CFTypeRef *, void, uint64_t, void))*a1 + 15))(a1, *(void *)(a3 + 8), 5, 0);
  }
  if (a2)
  {
    uint64_t v10 = *(void *)(a2 + 8);
    uint64_t v11 = (void (*)(CFTypeRef *, uint64_t, uint64_t, void))*((void *)*a1 + 15);
    v11(a1, v10, 4, 0);
  }
}

uint64_t NetConnection::_connectionResponseCallBack(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t))(*(void *)a3 + 40))(a3);
  uint64_t v6 = *(void *)(a3 + 96);
  if (v6) {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  uint64_t v7 = *(void *)(a3 + 136);
  if (!v7 || (*(_WORD *)(a3 + 88) & 0x200) != 0)
  {
    if (a2 == 8)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      uint64_t v8 = a1 + 16;
      if (!a1) {
        uint64_t v8 = 0;
      }
      long long v11 = *(_OWORD *)(v8 + 56);
      (*(void (**)(uint64_t, long long *))(*(void *)a3 + 64))(a3, &v11);
    }
    else if (a2 == 16)
    {
      (*(void (**)(uint64_t))(*(void *)a3 + 72))(a3);
    }
  }
  else
  {
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 144))(a3, *(void *)(v7 + 8), a1, a2);
  }
  uint64_t v9 = *(void *)(a3 + 96);
  if (v9) {
    pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a3 + 48))(a3);
}

uint64_t NetConnection::_connectionRequestCallBack(uint64_t result, uint64_t a2, void *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = a3[12];
  if (v6) {
    uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  uint64_t v7 = a3[16];
  if (v7)
  {
    uint64_t result = (*(uint64_t (**)(void *, void, uint64_t, uint64_t))(*a3 + 152))(a3, *(void *)(v7 + 8), v5, a2);
  }
  else if (!a3[17])
  {
    if (a2 == 8)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      uint64_t v9 = v5 + 16;
      if (!v5) {
        uint64_t v9 = 0;
      }
      long long v10 = *(_OWORD *)(v9 + 56);
      uint64_t result = (*(uint64_t (**)(void *, long long *))(*a3 + 64))(a3, &v10);
    }
    else if (a2 == 16)
    {
      uint64_t result = (*(uint64_t (**)(void *))(*a3 + 72))(a3);
    }
  }
  uint64_t v8 = a3[12];
  if (v8) {
    return pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  }
  return result;
}

uint64_t NetConnection::_copyDescription(NetConnection *this, void *a2)
{
  return (*(uint64_t (**)(void))(*(void *)this + 16))();
}

uint64_t NetConnection::_releaseFilter(NetConnection *this, void *a2)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

NetConnection *NetConnection::_retainFilter(NetConnection *this, void *a2)
{
  return this;
}

uint64_t NetConnection::errorOccurred(NetConnection *this, CFStreamError *a2)
{
  (*(void (**)(NetConnection *))(*(void *)this + 40))(this);
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  *((_WORD *)this + 44) &= ~1u;
  uint64_t v5 = (uint64_t *)*((void *)this + 17);
  *((void *)this + CFRetain((char *)this - 16) = 0;
  *((void *)this + 17) = 0;
  NetConnection::sendStateChanged((uint64_t)this, v5, (uint64_t)a2);
  NetConnection::shutdownConnectionStreams((uint64_t)this, 0);
  *((_WORD *)this + 44) |= 0x800u;
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  }
  uint64_t v7 = (void (*)(NetConnection *, void))*((void *)this + 23);
  if (v7) {
    v7(this, *((void *)this + 27));
  }
  uint64_t v8 = *(uint64_t (**)(NetConnection *))(*(void *)this + 48);

  return v8(this);
}

uint64_t NetConnection::copyDescription(NetConnection *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 16))();
}

BOOL NetConnection::equals(NetConnection *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

__CFString *NetConnection::copyDebugDesc(NetConnection *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  (*(void (**)(NetConnection *))(*(void *)this + 40))(this);
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  (*(void (**)(NetConnection *))(*(void *)this + 48))(this);
  uint64_t v6 = (void *)*((void *)this + 14);
  if (v6)
  {
    LODWORD(v7) = 0;
    do
    {
      uint64_t v6 = (void *)*v6;
      uint64_t v7 = (v7 + 1);
    }
    while (v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  CFStringRef v8 = CFStringCreateWithFormat(v2, 0, @"<NetConnection@%p> { State = %s, Count = %d, requests = {", this, "", v7);
  uint64_t v9 = *((void *)this + 12);
  if (v9) {
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  }
  CFStringAppend(Mutable, v8);
  if (v8) {
    CFRelease(v8);
  }
  long long v10 = (void *)*((void *)this + 14);
  if (v10)
  {
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = (const void *)(*(uint64_t (**)(NetConnection *, void))(*(void *)this + 184))(this, v10[1]);
      CFStringRef v13 = CFStringCreateWithFormat(v2, 0, @"%d: %@, ", v11, v12);
      if (v12) {
        CFRelease(v12);
      }
      CFStringAppend(Mutable, v13);
      if (v13) {
        CFRelease(v13);
      }
      uint64_t v11 = (v11 + 1);
      long long v10 = (void *)*v10;
    }
    while (v10);
  }
  CFStringAppend(Mutable, @"}  }");
  uint64_t v14 = *((void *)this + 12);
  if (v14) {
    pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
  }
  return Mutable;
}

uint64_t NetConnection::pendingRequestCount(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  uint64_t v3 = (void *)((char *)this + 128);
  LODWORD(v4) = -1;
  do
  {
    uint64_t v3 = (void *)*v3;
    uint64_t v4 = (v4 + 1);
  }
  while (v3);
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  return v4;
}

void NetConnection::~NetConnection(NetConnection *this)
{
  *(void *)this = &unk_1ECF9C380;
  *((void *)this + 3) = &unk_1ECF9C460;
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);
    while (v2)
    {
      uint64_t v4 = (void *)*v2;
      CFAllocatorDeallocate(v3, v2);
      uint64_t v2 = v4;
    }
  }
  uint64_t v5 = (const void *)*((void *)this + 30);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  NetConnection::shutdownConnectionStreams((uint64_t)this, 0);
  uint64_t v7 = (const void *)*((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v7) {
    CFRelease(v7);
  }
  CFStringRef v8 = (const void *)*((void *)this + 19);
  *((void *)this + 19) = 0;
  if (v8) {
    CFRelease(v8);
  }
  *((void *)this + 3) = &unk_1ECF9B550;
}

void sub_1841F3304(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void NetConnection::initialize(NetConnection *this)
{
}

void sub_1841F343C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

uint64_t NetConnection::enqueue(NetConnection *this, void *a2, int a3)
{
  (*(void (**)(NetConnection *))(*(void *)this + 40))(this);
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  int v7 = *((_DWORD *)this + 27);
  *((_DWORD *)this + 27) = v7 + 1;
  __int16 v8 = *((_WORD *)this + 44);
  if ((v8 & 1) == 0)
  {
    *((_DWORD *)this + 27) = v7;
    int v9 = v8 & 0x800;
    if (*((_DWORD *)this + 26)) {
      BOOL v10 = 0;
    }
    else {
      BOOL v10 = v7 == 0;
    }
    if (v10 && v9 != 0) {
      NetConnection::shutdownConnectionStreams((uint64_t)this, 0);
    }
    uint64_t v12 = 0;
    goto LABEL_79;
  }
  CFStringRef v13 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 24, 0);
  uint64_t v14 = (uint64_t)v13;
  void *v13 = 0;
  v13[1] = a2;
  *((unsigned char *)v13 + CFRetain((char *)this - 16) = 0;
  if (a3)
  {
    uint64_t v15 = (uint64_t *)*((void *)this + 16);
    if (v15)
    {
      uint64_t v16 = *v15;
      *uint64_t v15 = (uint64_t)v13;
      void *v13 = v16;
      int v17 = (char *)this + 120;
      if (*((uint64_t **)this + 15) != v15) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
  }
  __int16 v18 = (void *)((char *)this + 112);
  if (*((void *)this + 14)) {
    __int16 v18 = (void *)*((void *)this + 15);
  }
  *__int16 v18 = v13;
  int v17 = (char *)this + 128;
  uint64_t v19 = *((void *)this + 16);
  *((void *)this + 15) = v13;
  void *v13 = 0;
  if (!v19) {
LABEL_20:
  }
    *(void *)int v17 = v13;
LABEL_21:
  if (!*((void *)this + 17)) {
    *((void *)this + 17) = v13;
  }
  ++*((_DWORD *)this + 26);
  ++_NetConnection_GlobalPendingResponses;
  if ((*((unsigned char *)this + 88) & 2) != 0) {
    NetConnection::doublecheckPipelining(this);
  }
  if (_pipelineShouldPackPackets(void)::haveChecked == 1)
  {
    if (!_pipelineShouldPackPackets(void)::shouldPackPackets) {
      goto LABEL_36;
    }
LABEL_29:
    if ((*((_WORD *)this + 44) & 2) != 0)
    {
      uint64_t v21 = *((void *)this + 18);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      if (v21) {
        uint64_t v22 = v21 + 16;
      }
      else {
        uint64_t v22 = 0;
      }
      ++*(void *)(v22 + 80);
      (*(void (**)(void, uint64_t))(**(void **)(v22 + 24) + 32))(*(void *)(v22 + 24), 0x1EC09F328);
      --*(void *)(v22 + 80);
    }
    goto LABEL_36;
  }
  BOOL v20 = getenv("CFNETWORK_PIPELINE_PACK") != 0;
  _pipelineShouldPackPackets(void)::shouldPackPackets = v20;
  _pipelineShouldPackPackets(void)::haveChecked = 1;
  if (v20) {
    goto LABEL_29;
  }
LABEL_36:
  (*(void (**)(NetConnection *, void *, uint64_t, void))(*(void *)this + 120))(this, a2, 1, 0);
  __int16 v23 = *((_WORD *)this + 44);
  if ((v23 & 0x400) == 0)
  {
    v23 &= ~1u;
    *((_WORD *)this + 44) = v23;
  }
  uint64_t v24 = *((void *)this + 16);
  if (v24 == *((void *)this + 17) || (v23 & 2) != 0)
  {
    if (v24 == v14)
    {
      NetConnection::scheduleNewRequest(this, v14, 0, 0);
    }
    else if (*((void *)this + 18))
    {
      if (v24)
      {
        uint64_t v25 = (uint64_t *)*((void *)this + 16);
        while ((v25[2] & 2) != 0)
        {
          uint64_t v25 = (uint64_t *)*v25;
          if (!v25)
          {
            uint64_t v25 = (uint64_t *)*((void *)this + 16);
            break;
          }
        }
      }
      else
      {
        uint64_t v25 = 0;
      }
      if (v25 == (uint64_t *)v14)
      {
        CFStreamError v26 = (const CoreSchedulingSet *)(*(uint64_t (**)(NetConnection *, void))(*(void *)this + 160))(this, *(void *)(v14 + 8));
        NetConnection::rescheduleStream(*((char **)this + 18), v26);
        if (v26) {
          (*(void (**)(const CoreSchedulingSet *))(*(void *)v26 + 48))(v26);
        }
        if ((*((_WORD *)this + 44) & 0x20) != 0) {
          (*(void (**)(NetConnection *, void))(*(void *)this + 128))(this, *(void *)(*((void *)this + 16) + 8));
        }
      }
    }
  }
  if (*((void *)this + 19))
  {
    uint64_t v27 = *((void *)this + 17);
    if (*((void *)this + 16) != v27)
    {
      if (v27)
      {
        uint64_t v28 = (uint64_t *)*((void *)this + 17);
        while ((v28[2] & 2) != 0)
        {
          uint64_t v28 = (uint64_t *)*v28;
          if (!v28)
          {
            uint64_t v28 = (uint64_t *)*((void *)this + 17);
            break;
          }
        }
      }
      else
      {
        uint64_t v28 = 0;
      }
      if (v28 == (uint64_t *)v14)
      {
        uint64_t v29 = (*(uint64_t (**)(NetConnection *, void))(*(void *)this + 160))(this, *(void *)(v14 + 8));
        uint64_t v30 = (char *)*((void *)this + 19);
        if (v30)
        {
          CFRetain(*((CFTypeRef *)this + 19));
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
          }
          uint64_t v31 = (CoreStreamBase *)(v30 + 16);
        }
        else
        {
          uint64_t v31 = 0;
        }
        uint64_t v32 = (const CoreSchedulingSet *)v29;
        if (!v29)
        {
          if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1) {
            dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
          }
          uint64_t v32 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
        }
        CoreStreamBase::_streamInterface_UpdateScheduling(v31, v32);
        if (v30) {
          CFRelease(v30);
        }
        if (v29) {
          (*(void (**)(uint64_t))(*(void *)v29 + 48))(v29);
        }
        if ((*((_WORD *)this + 44) & 0x200) == 0) {
          (*(void (**)(NetConnection *, void))(*(void *)this + 136))(this, *(void *)(*((void *)this + 17) + 8));
        }
      }
    }
  }
  --*((_DWORD *)this + 27);
  uint64_t v12 = 1;
LABEL_79:
  uint64_t v33 = *((void *)this + 12);
  if (v33) {
    pthread_mutex_unlock((pthread_mutex_t *)(v33 + 8));
  }
  (*(void (**)(NetConnection *))(*(void *)this + 48))(this);
  return v12;
}

void NetConnection::doublecheckPipelining(NetConnection *this)
{
  __int16 v1 = *((_WORD *)this + 44);
  if ((v1 & 4) != 0) {
    return;
  }
  if ((v1 & 0x10) != 0)
  {
    if ((v1 & 8) == 0) {
      return;
    }
    __int16 v11 = v1 & 0xFFFD;
    goto LABEL_16;
  }
  *((_WORD *)this + 44) = v1 | 0x10;
  *(_DWORD *)UInt8 buffer = -1;
  uint64_t v3 = *((void *)this + 18);
  if (!v3) {
    goto LABEL_15;
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  ++*(void *)(v3 + 96);
  CFDataRef v4 = (const __CFData *)(*(uint64_t (**)(void, void *))(**(void **)(v3 + 40) + 40))(*(void *)(v3 + 40), &unk_1EC0A0F98);
  --*(void *)(v3 + 96);
  if (!v4)
  {
LABEL_15:
    __int16 v11 = *((_WORD *)this + 44) & 0xFFF5 | 8;
LABEL_16:
    *((_WORD *)this + 44) = v11;
    return;
  }
  CFDataRef v5 = v4;
  if (CFDataGetLength(v4) != 4)
  {
    CFRelease(v5);
    goto LABEL_15;
  }
  v13.location = 0;
  v13.length = 4;
  CFDataGetBytes(v5, v13, buffer);
  uint64_t v6 = (CFNA *)SCNetworkSignatureCopyIdentifierForConnectedSocket();
  CFRelease(v5);
  if (!v6) {
    goto LABEL_15;
  }
  CFStringRef v8 = CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore(v6, (const __CFString *)"HTTPPipelining", v7);
  if (!v8)
  {
    if (CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once != -1) {
      dispatch_once(&CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once, &__block_literal_global_11694);
    }
    CFNA::CFNetworkAgentClient::executeLegacyQuery((CFNA::CFNetworkAgentClient *)CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client, (const __CFString *)v6);
  }
  CFStringRef v9 = v8;
  CFComparisonResult v10 = CFStringCompare(v8, @"TRUE", 0);
  CFRelease(v9);
  CFRelease(v6);
  if (v10) {
    goto LABEL_15;
  }
}

void **NetConnection::dequeue(NetConnection *this, void *a2)
{
  (*(void (**)(NetConnection *))(*(void *)this + 40))(this);
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  uint64_t v6 = (void **)((char *)this + 112);
  CFDataRef v5 = (void **)*((void *)this + 14);
  if (!v5) {
    goto LABEL_28;
  }
  if (v5[1] == a2)
  {
    if (v5 == *((void ***)this + 16))
    {
      int v7 = 0;
      CFComparisonResult v10 = 0;
      CFStringRef v9 = (void **)*((void *)this + 14);
LABEL_19:
      __int16 v12 = *((_WORD *)this + 44);
      if (v12 & 0x100 | v7)
      {
        CFDataRef v5 = v9;
        if (v10) {
          goto LABEL_24;
        }
        goto LABEL_30;
      }
      if ((v12 & 0x20) != 0 || v9 != v5) {
        goto LABEL_27;
      }
      *((void *)this + CFRetain((char *)this - 16) = *v5;
    }
    else
    {
      CFComparisonResult v10 = 0;
      __int16 v11 = (void **)*((void *)this + 17);
LABEL_16:
      CFStringRef v9 = v11;
      if (v5 == v11)
      {
LABEL_27:
        if (*(void **)(*((void *)this + 15) + 8) != a2)
        {
LABEL_28:
          CFStringRef v9 = 0;
          goto LABEL_78;
        }
        *((_WORD *)this + 44) &= ~1u;
        if (*((void *)this + 16))
        {
          uint64_t v14 = (void **)*((void *)this + 16);
          while (((_BYTE)v14[2] & 2) != 0)
          {
            uint64_t v14 = (void **)*v14;
            if (!v14)
            {
              uint64_t v14 = (void **)*((void *)this + 16);
              break;
            }
          }
          if (v14 == v9)
          {
            NetConnection::rescheduleStream(*((char **)this + 18), 0);
            *((_WORD *)this + 44) &= ~0x20u;
            *((void *)this + CFRetain((char *)this - 16) = 0;
          }
        }
        uint64_t v15 = (void **)*((void *)this + 17);
        if (v15)
        {
          uint64_t v16 = (void **)*((void *)this + 17);
          while (((_BYTE)v16[2] & 2) != 0)
          {
            uint64_t v16 = (void **)*v16;
            if (!v16)
            {
              uint64_t v16 = (void **)*((void *)this + 17);
              break;
            }
          }
          if (v16 == v9)
          {
            NetConnection::rescheduleStream(*((char **)this + 19));
            uint64_t v15 = 0;
            *((void *)this + 17) = 0;
          }
        }
        if (v10)
        {
          char v17 = *((unsigned char *)v10 + 16);
          *CFComparisonResult v10 = *v9;
          *CFStringRef v9 = 0;
          if (*((void ***)this + 15) == v9) {
            *((void *)this + 15) = v10;
          }
          if ((v17 & 2) != 0)
          {
            __int16 v18 = *v6;
            uint64_t v19 = (void *)**v6;
            if (!v19) {
              goto LABEL_65;
            }
            int v20 = 0;
            int v21 = 0;
            uint64_t v22 = 0;
            __int16 v23 = (void **)*v6;
            do
            {
              uint64_t v24 = v19;
              if (((_BYTE)v23[2] & 2) != 0)
              {
                if (v23 == *((void ***)this + 16)) {
                  int v21 = 1;
                }
                if (v23 == v15) {
                  int v20 = 1;
                }
              }
              else
              {
                int v21 = 0;
                int v20 = 0;
                uint64_t v22 = v23;
              }
              uint64_t v19 = (void *)*v19;
              __int16 v23 = (void **)v24;
            }
            while (*v24);
            if (v22)
            {
              __int16 v18 = *v22;
              if (v21) {
                *((void *)this + CFRetain((char *)this - 16) = 0;
              }
              if (v20) {
                *((void *)this + 17) = 0;
              }
            }
            else
            {
LABEL_65:
              *(_OWORD *)uint64_t v6 = 0u;
              *((_OWORD *)this + 8) = 0u;
            }
            int v25 = 0;
            if (v18)
            {
              do
              {
                uint64_t v36 = 4;
                int v37 = -4;
                (*(void (**)(NetConnection *, void, uint64_t, uint64_t *))(*(void *)this + 120))(this, v18[1], 7, &v36);
                CFStreamError v26 = (void *)*v18;
                CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), v18);
                ++v25;
                __int16 v18 = v26;
              }
              while (v26);
            }
            *((_DWORD *)this + 26) -= v25;
            _NetConnection_GlobalPendingResponses -= v25;
          }
          goto LABEL_69;
        }
LABEL_31:
        CFRange v13 = (void **)*v9;
        *((void *)this + 14) = *v9;
        *CFStringRef v9 = 0;
        if (*((void ***)this + 15) != v9)
        {
LABEL_70:
          if (v13)
          {
            uint64_t v27 = (void **)*((void *)this + 16);
          }
          else
          {
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            uint64_t v27 = 0;
            *((CFAbsoluteTime *)this + 20) = Current;
            *((void *)this + CFRetain((char *)this - 16) = 0;
            *((void *)this + 17) = 0;
          }
          if (v27 == v9) {
            *((void *)this + CFRetain((char *)this - 16) = 0;
          }
          if (*((void ***)this + 17) == v9) {
            *((void *)this + 17) = 0;
          }
          CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), v9);
          --*((_DWORD *)this + 26);
          --_NetConnection_GlobalPendingResponses;
          CFStringRef v9 = (void **)1;
          goto LABEL_78;
        }
        *((void *)this + 15) = 0;
LABEL_69:
        CFRange v13 = (void **)*v6;
        goto LABEL_70;
      }
    }
    if (v10)
    {
LABEL_24:
      *CFComparisonResult v10 = *v5;
      *CFDataRef v5 = 0;
      if (*((void ***)this + 15) == v5) {
        *((void *)this + 15) = v10;
      }
      CFStringRef v9 = v5;
      goto LABEL_69;
    }
LABEL_30:
    CFStringRef v9 = v5;
    goto LABEL_31;
  }
  int v7 = 0;
  int v8 = 0;
  CFStringRef v9 = (void **)*((void *)this + 14);
  while (1)
  {
    CFComparisonResult v10 = v9;
    CFStringRef v9 = (void **)*v9;
    if (!v9) {
      break;
    }
    CFDataRef v5 = (void **)*((void *)this + 16);
    __int16 v11 = (void **)*((void *)this + 17);
    if (v10 == v5) {
      int v7 = 1;
    }
    if (v10 == v11) {
      int v8 = 1;
    }
    if (v9[1] == a2)
    {
      if (v8) {
        goto LABEL_19;
      }
      CFDataRef v5 = v9;
      goto LABEL_16;
    }
  }
LABEL_78:
  uint64_t v29 = *((void *)this + 19);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (v29) {
    uint64_t v30 = v29 + 16;
  }
  else {
    uint64_t v30 = 0;
  }
  ++*(void *)(v30 + 80);
  uint64_t v31 = (const void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v30 + 24) + 40))(*(void *)(v30 + 24), 0x1EC09E8A8);
  --*(void *)(v30 + 80);
  if (v31)
  {
    uint64_t v32 = v31;
    CFTypeID v33 = CFGetTypeID(v31);
    if (v33 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v36) = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v36, 2u);
    }
    if ((const void *)*MEMORY[0x1E4F1CFD0] == v32) {
      *((_WORD *)this + 44) &= ~1u;
    }
    CFRelease(v32);
  }
  if (!*((_DWORD *)this + 26) && (*((_WORD *)this + 44) & 0x801) != 1) {
    NetConnection::shutdownConnectionStreams((uint64_t)this, a2);
  }
  uint64_t v34 = *((void *)this + 12);
  if (v34) {
    pthread_mutex_unlock((pthread_mutex_t *)(v34 + 8));
  }
  (*(void (**)(NetConnection *))(*(void *)this + 48))(this);
  return v9;
}

void NetConnection::rescheduleStream(char *cf)
{
  if (cf)
  {
    CFRetain(cf);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v2 = (CoreStreamBase *)(cf + 16);
  }
  else
  {
    uint64_t v2 = 0;
  }
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1) {
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
  }
  CoreStreamBase::_streamInterface_UpdateScheduling(v2, (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet);
  if (cf)
  {
    CFRelease(cf);
  }
}

uint64_t NetConnection::responseIsComplete(NetConnection *this, void *a2)
{
  (*(void (**)(NetConnection *))(*(void *)this + 40))(this);
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  ++*((void *)this + 28);
  CFDataRef v5 = (uint64_t *)*((void *)this + 17);
  if (v5 && (void *)v5[1] == a2)
  {
    CFComparisonResult v10 = (void *)*((void *)this + 16);
    if (v5 == v10)
    {
      *((_WORD *)this + 44) |= 0x200u;
      goto LABEL_5;
    }
    uint64_t v11 = *v5;
    *((void *)this + 17) = *v5;
    __int16 v12 = *((_WORD *)this + 44);
    if (v11)
    {
      if ((*((_WORD *)this + 44) & 0x100) == 0)
      {
        if ((v12 & 2) != 0 && v11 == (void)v10) {
          uint64_t v14 = 0;
        }
        else {
          uint64_t v14 = v11;
        }
        if ((v12 & 2) != 0) {
          goto LABEL_31;
        }
LABEL_25:
        if (*((void *)this + 18))
        {
          uint64_t v15 = (const CoreSchedulingSet *)NetConnection::copySchedulingSetForRequest((uint64_t)this, (uint64_t **)v14);
          NetConnection::rescheduleStream(*((char **)this + 18), v15);
          uint64_t v16 = (char *)*((void *)this + 19);
          if (v16)
          {
            CFRetain(*((CFTypeRef *)this + 19));
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
            }
            char v17 = (CoreStreamBase *)(v16 + 16);
          }
          else
          {
            char v17 = 0;
          }
          uint64_t v19 = v15;
          if (!v15)
          {
            if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
            {
              uint64_t v22 = v17;
              dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
              char v17 = v22;
            }
            uint64_t v19 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
          }
          CoreStreamBase::_streamInterface_UpdateScheduling(v17, v19);
          if (v16) {
            CFRelease(v16);
          }
          if (v15) {
            (*(void (**)(const CoreSchedulingSet *))(*(void *)v15 + 48))(v15);
          }
        }
        __int16 v20 = *((_WORD *)this + 44);
        if ((v12 & 0x40) != 0)
        {
          if ((v20 & 0x80) == 0) {
            NetConnection::setClient((uint64_t)this);
          }
        }
        else
        {
          *((_WORD *)this + 44) = v20 | 0x40;
          NetConnection::openConnectionStreams((uint64_t)this);
        }
        (*(void (**)(NetConnection *, uint64_t, uint64_t, void))(*(void *)this + 120))(this, v5[1], 5, 0);
        __int16 v21 = *((_WORD *)this + 44);
        *((_WORD *)this + 44) = v21 & 0xFFDF;
        if (v14)
        {
          *((_WORD *)this + 44) = v21 | 0x20;
          (*(void (**)(NetConnection *, void, uint64_t, void))(*(void *)this + 120))(this, *(void *)(v14 + 8), 2, 0);
        }
        goto LABEL_5;
      }
      uint64_t v11 = 0;
      uint64_t v14 = 0;
      *((void *)this + 17) = 0;
      if ((v12 & 2) == 0) {
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v14 = 0;
      if ((v12 & 2) == 0) {
        goto LABEL_25;
      }
    }
LABEL_31:
    if ((v12 & 4) == 0) {
      uint64_t v11 = 0;
    }
    if (v14) {
      uint64_t v18 = v14;
    }
    else {
      uint64_t v18 = v11;
    }
    NetConnection::scheduleNewResponse((CFTypeRef *)this, v18, (uint64_t)v5);
  }
LABEL_5:
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  }
  int v7 = (void (*)(NetConnection *, void))*((void *)this + 22);
  if (v7) {
    v7(this, *((void *)this + 27));
  }
  int v8 = *(uint64_t (**)(NetConnection *))(*(void *)this + 48);

  return v8(this);
}

uint64_t NetConnection::requestIsComplete(NetConnection *this, void *a2)
{
  (*(void (**)(NetConnection *))(*(void *)this + 40))(this);
  uint64_t v4 = (void (*)(NetConnection *, void))*((void *)this + 21);
  if (v4) {
    v4(this, *((void *)this + 27));
  }
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
  }
  uint64_t v6 = *((void *)this + 16);
  if (!v6 || *(void **)(v6 + 8) != a2)
  {
    CFLog();
    goto LABEL_18;
  }
  __int16 v7 = *((_WORD *)this + 44);
  BOOL v9 = (v7 & 0x200) == 0 && *(void *)(*((void *)this + 17) + 8) == (void)a2;
  if ((*((_WORD *)this + 44) & 0x100) != 0)
  {
    *((void *)this + CFRetain((char *)this - 16) = 0;
    uint64_t v11 = this;
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = *(void *)v6;
    *((void *)this + CFRetain((char *)this - 16) = *(void *)v6;
    if ((v7 & 2) == 0 || !v10)
    {
      NetConnection::scheduleNewRequest(this, 0, v6, v9);
      if (_pipelineShouldPackPackets(void)::haveChecked == 1)
      {
        int v15 = _pipelineShouldPackPackets(void)::shouldPackPackets;
      }
      else
      {
        int v15 = getenv("CFNETWORK_PIPELINE_PACK") != 0;
        _pipelineShouldPackPackets(void)::shouldPackPackets = v15;
        _pipelineShouldPackPackets(void)::haveChecked = 1;
      }
      if (v15 && (*((_WORD *)this + 44) & 2) != 0)
      {
        uint64_t v16 = *((void *)this + 18);
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        {
          uint64_t v18 = *((void *)this + 18);
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
          uint64_t v16 = v18;
        }
        if (v16) {
          uint64_t v17 = v16 + 16;
        }
        else {
          uint64_t v17 = 0;
        }
        ++*(void *)(v17 + 80);
        (*(void (**)(void, uint64_t))(**(void **)(v17 + 24) + 32))(*(void *)(v17 + 24), 0x1EC09F328);
        --*(void *)(v17 + 80);
      }
      goto LABEL_25;
    }
    uint64_t v11 = this;
  }
  NetConnection::scheduleNewRequest(v11, v10, v6, v9);
LABEL_25:
  if ((v7 & 0x200) != 0)
  {
    NetConnection::responseIsComplete(this, *(void **)(v6 + 8));
    *((_WORD *)this + 44) &= ~0x200u;
  }
LABEL_18:
  uint64_t v12 = *((void *)this + 12);
  if (v12) {
    pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8));
  }
  CFRange v13 = *(uint64_t (**)(NetConnection *))(*(void *)this + 48);

  return v13(this);
}

void NetConnection::setShouldPipeline(NetConnection *this, int a2)
{
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  __int16 v5 = *((_WORD *)this + 44);
  if (a2)
  {
    if ((v5 & 2) == 0)
    {
      NetConnection::doublecheckPipelining(this);
      __int16 v6 = *((_WORD *)this + 44);
      if ((v6 & 8) == 0)
      {
        *((_WORD *)this + 44) = v6 | 2;
        if ((v6 & 0x20) == 0)
        {
          uint64_t v7 = *((void *)this + 16);
          if (v7) {
            NetConnection::scheduleNewRequest(this, v7, *((void *)this + 17), 0);
          }
        }
      }
    }
  }
  else if ((v5 & 2) != 0)
  {
    *((_WORD *)this + 44) = v5 & 0xFFFD;
  }
  uint64_t v8 = *((void *)this + 12);
  if (v8)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  }
}

double NetConnection::getLastAccessTime(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  if (*((void *)this + 14)) {
    double Current = CFAbsoluteTimeGetCurrent();
  }
  else {
    double Current = *((double *)this + 20);
  }
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  }
  return Current;
}

uint64_t NetConnection::getState(NetConnection *this, int a2, uint64_t *a3)
{
  (*(void (**)(NetConnection *))(*(void *)this + 40))(this);
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  if (a2)
  {
    uint64_t v7 = *((void *)this + 16);
    if (v7 && (*((_WORD *)this + 44) & 0x20) != 0) {
      (*(void (**)(NetConnection *, void))(*(void *)this + 128))(this, *(void *)(v7 + 8));
    }
    uint64_t v8 = *((void *)this + 17);
    if (v8 && (v8 != *((void *)this + 16) || (*((_WORD *)this + 44) & 0x20) == 0)) {
      (*(void (**)(NetConnection *, void))(*(void *)this + 136))(this, *(void *)(v8 + 8));
    }
  }
  if (!*((void *)this + 18) && !*((void *)this + 19)) {
    goto LABEL_14;
  }
  __int16 v9 = *((_WORD *)this + 44);
  if ((v9 & 0x2000) == 0) {
    goto LABEL_14;
  }
  CFRange v13 = (uint64_t **)*((void *)this + 16);
  if (v13 && v13[1] == a3)
  {
    if ((v9 & 0x20) != 0) {
      uint64_t v10 = 2;
    }
    else {
      uint64_t v10 = 1;
    }
  }
  else
  {
    uint64_t v14 = (uint64_t **)*((void *)this + 17);
    if (v14 && v14[1] == a3)
    {
      uint64_t v10 = 4;
    }
    else if (v13)
    {
      while (v13[1] != a3)
      {
        CFRange v13 = (uint64_t **)*v13;
        if (!v13) {
          goto LABEL_25;
        }
      }
      if ((*((_WORD *)this + 44) & 0x100) != 0) {
        uint64_t v10 = 7;
      }
      else {
        uint64_t v10 = 1;
      }
    }
    else
    {
LABEL_25:
      if (v14)
      {
        while (v14[1] != a3)
        {
          uint64_t v14 = (uint64_t **)*v14;
          if (!v14) {
            goto LABEL_28;
          }
        }
        if ((*((_WORD *)this + 44) & 0x100) != 0) {
          uint64_t v10 = 7;
        }
        else {
          uint64_t v10 = 3;
        }
      }
      else
      {
LABEL_28:
        int v15 = (uint64_t **)*((void *)this + 14);
        if (!v15)
        {
LABEL_14:
          uint64_t v10 = 7;
          goto LABEL_15;
        }
        while (v15[1] != a3)
        {
          int v15 = (uint64_t **)*v15;
          if (!v15) {
            goto LABEL_14;
          }
        }
        uint64_t v10 = 5;
      }
    }
  }
LABEL_15:
  uint64_t v11 = *((void *)this + 12);
  if (v11) {
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
  }
  (*(void (**)(NetConnection *))(*(void *)this + 48))(this);
  return v10;
}

uint64_t NetConnection::schedule(uint64_t this, uint64_t *a2, CoreSchedulingSet *a3, const __CFString *cf1)
{
  uint64_t v7 = (void *)this;
  uint64_t v8 = *(void *)(this + 96);
  if (v8) {
    this = pthread_mutex_lock((pthread_mutex_t *)(v8 + 8));
  }
  if (v7[16])
  {
    this = v7[18];
    if (this)
    {
      __int16 v9 = (uint64_t **)v7[16];
      while (((_BYTE)v9[2] & 2) != 0)
      {
        __int16 v9 = (uint64_t **)*v9;
        if (!v9)
        {
          __int16 v9 = (uint64_t **)v7[16];
          break;
        }
      }
      if (v9[1] == a2) {
        this = CoreWriteStreamScheduleWithRunLoop((CoreStreamBase *)this, a3, cf1);
      }
    }
  }
  if (v7[17])
  {
    this = v7[19];
    if (this)
    {
      uint64_t v10 = (uint64_t **)v7[17];
      while (((_BYTE)v10[2] & 2) != 0)
      {
        uint64_t v10 = (uint64_t **)*v10;
        if (!v10)
        {
          uint64_t v10 = (uint64_t **)v7[17];
          break;
        }
      }
      if (v10[1] == a2) {
        this = CoreReadStreamScheduleWithRunLoop((CoreStreamBase *)this, a3, cf1);
      }
    }
  }
  uint64_t v11 = v7[12];
  if (v11)
  {
    return pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
  }
  return this;
}

void NetConnection::unschedule(NetConnection *this, uint64_t *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  uint64_t v7 = (CoreStreamBase *)*((void *)this + 18);
  if (v7)
  {
    uint64_t v8 = (uint64_t **)*((void *)this + 16);
    if (v8)
    {
      __int16 v9 = (uint64_t **)*((void *)this + 16);
      while (((_BYTE)v9[2] & 2) != 0)
      {
        __int16 v9 = (uint64_t **)*v9;
        if (!v9) {
          goto LABEL_8;
        }
      }
    }
    else
    {
      if ((*((_WORD *)this + 44) & 2) != 0) {
        goto LABEL_17;
      }
      uint64_t v8 = (uint64_t **)*((void *)this + 17);
      if (!v8) {
        goto LABEL_17;
      }
      __int16 v9 = (uint64_t **)*((void *)this + 17);
      while (((_BYTE)v9[2] & 2) != 0)
      {
        __int16 v9 = (uint64_t **)*v9;
        if (!v9)
        {
LABEL_8:
          __int16 v9 = v8;
          break;
        }
      }
    }
    if (v9[1] == a2) {
      CoreWriteStreamUnscheduleFromRunLoop(v7);
    }
  }
LABEL_17:
  if (*((void *)this + 17))
  {
    uint64_t v10 = (CoreStreamBase *)*((void *)this + 19);
    if (v10)
    {
      uint64_t v11 = (uint64_t **)*((void *)this + 17);
      while (((_BYTE)v11[2] & 2) != 0)
      {
        uint64_t v11 = (uint64_t **)*v11;
        if (!v11)
        {
          uint64_t v11 = (uint64_t **)*((void *)this + 17);
          break;
        }
      }
      if (v11[1] == a2) {
        CoreReadStreamUnscheduleFromRunLoop(v10);
      }
    }
  }
  uint64_t v12 = *((void *)this + 12);
  if (v12)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8));
  }
}

CFStringRef NetConnectionCache::Key::copyDescription(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat(this[1], 0, @"Host %@, port %d, type %d, properties = %@", this[3], *((unsigned int *)this + 8), *((unsigned int *)this + 9), this[5]);
}

CFHashCode NetConnectionCache::Key::hash(CFTypeRef *this)
{
  return CFHash(this[3]) | (int)(*((_DWORD *)this + 8) << 17) | (8 * *((_DWORD *)this + 9)) | (this[5] == 0);
}

BOOL NetConnectionCache::Key::equals(NetConnectionCache::Key *this, const CFAllocatedReferenceCountedObject *a2)
{
  if (*((_DWORD *)this + 9) != *((_DWORD *)a2 + 9)
    || *((_DWORD *)this + 8) != *((_DWORD *)a2 + 8)
    || CFStringCompare(*((CFStringRef *)this + 3), *((CFStringRef *)a2 + 3), 1uLL))
  {
    return 0;
  }
  uint64_t v5 = *((void *)this + 5);
  unint64_t v6 = *((void *)a2 + 5);
  BOOL result = (v5 | v6) == 0;
  if (v5)
  {
    if (v6) {
      return CFEqual(*((CFTypeRef *)this + 5), (CFTypeRef)v6) != 0;
    }
  }
  return result;
}

void NetConnectionCache::Key::~Key(NetConnectionCache::Key *this)
{
  NetConnectionCache::Key::~Key(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  const void *v2;
  const void *v3;

  *(void *)this = &unk_1ECFA5D58;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }
}

void NetConnectionCache::~NetConnectionCache(NetConnectionCache *this)
{
  *(void *)this = &unk_1ECF9F630;
  __int16 v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9F630;
  __int16 v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t NetConnection::willEnqueueRequests(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  if (*((_WORD *)this + 44))
  {
    uint64_t v4 = *((void *)this + 19);
    if (!v4) {
      goto LABEL_14;
    }
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    ++*(void *)(v4 + 96);
    uint64_t v5 = (const void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 40) + 40))(*(void *)(v4 + 40), 0x1EC09E8A8);
    --*(void *)(v4 + 96);
    if (v5)
    {
      unint64_t v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t v10 = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v10, 2u);
      }
      if ((const void *)*MEMORY[0x1E4F1CFD0] == v6)
      {
        *((_WORD *)this + 44) &= ~1u;
        NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
        uint64_t v3 = 0;
      }
      else
      {
        uint64_t v3 = 1;
      }
      CFRelease(v6);
    }
    else
    {
LABEL_14:
      uint64_t v3 = 1;
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  uint64_t v8 = *((void *)this + 12);
  if (v8) {
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  }
  return v3;
}

void non-virtual thunk to'NetConnection_Classic::~NetConnection_Classic(NetConnection_Classic *this)
{
  uint64_t v2 = (char *)this - 24;
  NetConnection_Classic::~NetConnection_Classic((NetConnection_Classic *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  NetConnection_Classic::~NetConnection_Classic((NetConnection_Classic *)((char *)this - 24));
}

void NetConnection_Classic::~NetConnection_Classic(NetConnection_Classic *this)
{
  *(void *)this = &unk_1ECFA1F70;
  *((void *)this + 3) = &unk_1ECFA2050;
  uint64_t v2 = *(void (**)(void))(*((void *)this + 31) + 16);
  if (v2 && *((void *)this + 32)) {
    v2(*((void *)this + 1));
  }

  NetConnection::~NetConnection(this);
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  NetConnection_Classic::~NetConnection_Classic(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1841F5060(_Unwind_Exception *a1)
{
  NetConnection::~NetConnection(v1);
  _Unwind_Resume(a1);
}

CFStringRef NetConnection_Classic::copyReqestDebugDesc(CFAllocatorRef *this, void *a2)
{
  return CFStringCreateWithFormat(this[1], 0, @"<request@%p>", a2);
}

uint64_t NetConnection_Classic::callTestFunc(NetConnection_Classic *this, unsigned __int8 (*a2)(void *, NetConnection *, const void *), void *a3)
{
  return ((uint64_t (*)(void *, NetConnection_Classic *, void))a2)(a3, this, *((void *)this + 32));
}

_OWORD *NetConnection_Classic::copySchedulingSetForRequest(NetConnection_Classic *this, void *a2)
{
  uint64_t v2 = (CoreSchedulingSet *)(*(uint64_t (**)(void *, NetConnection_Classic *, void))(*((void *)this + 31)
                                                                                               + 72))(a2, this, *((void *)this + 32));
  uint64_t v4 = CoreSchedulingSet::create(v2, v3);
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

uint64_t NetConnection_Classic::requestStreamCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 248) + 64))(a2, a3, a4, a1, *(void *)(a1 + 256));
}

uint64_t NetConnection_Classic::responseStreamCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 248) + 56))(a2, a3, a4, a1, *(void *)(a1 + 256));
}

uint64_t NetConnection_Classic::receiveResponse(NetConnection_Classic *this, void *a2)
{
  return (*(uint64_t (**)(void *, NetConnection_Classic *, void))(*((void *)this + 31) + 48))(a2, this, *((void *)this + 32));
}

uint64_t NetConnection_Classic::transmitRequest(NetConnection_Classic *this, void *a2)
{
  return (*(uint64_t (**)(void *, NetConnection_Classic *, void))(*((void *)this + 31) + 40))(a2, this, *((void *)this + 32));
}

uint64_t NetConnection_Classic::requestStateChanged(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 248) + 32))(a2, a3, a4, a1, *(void *)(a1 + 256));
}

uint64_t NetConnection_Classic::createStreams(void *a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(a1[31] + 24))(a1[1], a1[32], a2, a3);
}

uint64_t NetConnection_Classic::infoPointer(NetConnection_Classic *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (!v2) {
    return *((void *)this + 32);
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  uint64_t v3 = *((void *)this + 12);
  uint64_t v4 = *((void *)this + 32);
  if (v3) {
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  }
  return v4;
}

CFHashCode NetConnection_Classic::Cache::Key::hash(NetConnection_Classic::Cache::Key *this)
{
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFHashCode v3 = CFHash(v2);
  }
  else {
    CFHashCode v3 = 0;
  }
  int v4 = *((_DWORD *)this + 9);
  uint64_t v5 = *((int *)this + 8);
  CFHashCode v6 = *((void *)this + 5);
  if (v6) {
    CFHashCode v6 = CFHash((CFTypeRef)v6);
  }
  return v3 | v5 | v6 | (v4 << 14);
}

uint64_t NetConnection_Classic::Cache::Key::equals(NetConnection_Classic::Cache::Key *this, const CFAllocatedReferenceCountedObject *a2)
{
  uint64_t result = *((void *)this + 3);
  if (result)
  {
    uint64_t v5 = (const void *)*((void *)a2 + 3);
    if (!v5) {
      return 0;
    }
    uint64_t result = CFEqual((CFTypeRef)result, v5);
    if (!result) {
      return result;
    }
    if (*((_DWORD *)this + 8) == *((_DWORD *)a2 + 8) && *((_DWORD *)this + 9) == *((_DWORD *)a2 + 9))
    {
      CFHashCode v6 = (const void *)*((void *)this + 5);
      CFTypeID v7 = (const void *)*((void *)a2 + 5);
      if (v6 == v7)
      {
        return 1;
      }
      else
      {
        uint64_t result = 0;
        if (v6)
        {
          if (v7) {
            return CFEqual(*((CFTypeRef *)this + 5), v7) != 0;
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void NetConnection_Classic::Cache::Key::~Key(NetConnection_Classic::Cache::Key *this)
{
  NetConnection_Classic::Cache::Key::~Key(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  const void *v2;
  const void *v3;

  *(void *)this = &unk_1ECFA5E70;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }
}

void NetConnection_Classic::Cache::~Cache(NetConnection_Classic::Cache *this)
{
  *(void *)this = &unk_1ECFA5EB8;
  __int16 v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECFA5EB8;
  __int16 v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t createNewConnection(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  CFHashCode v6 = CFAllocatorAllocate(a1, 264, 0);
  *CFHashCode v6 = 0u;
  v6[1] = 0u;
  v6[2] = 0u;
  v6[3] = 0u;
  v6[4] = 0u;
  v6[5] = 0u;
  v6[6] = 0u;
  v6[7] = 0u;
  v6[8] = 0u;
  v6[9] = 0u;
  v6[10] = 0u;
  v6[11] = 0u;
  v6[12] = 0u;
  v6[13] = 0u;
  v6[14] = 0u;
  v6[15] = 0u;
  *((void *)v6 + 32) = 0;
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)v6, a1);
  void *v7 = &unk_1ECFA1F70;
  v7[3] = &unk_1ECFA2050;
  v7[31] = a2;
  if (a2)
  {
    uint64_t v8 = *(uint64_t (**)(void, uint64_t))(a2 + 8);
    if (v8) {
      a3 = v8(*((void *)v6 + 1), a3);
    }
  }
  *((void *)v6 + 32) = a3;
  if (a3) {
    NetConnection::initialize((NetConnection *)v6);
  }
  (*(void (**)(_OWORD *))(*(void *)v6 + 48))(v6);
  return 0;
}

void setConnectionProperties(NetConnection_Classic *a1, const __CFDictionary *a2)
{
  if (a2)
  {
    CFContainerEnumeratorBase::setup((unint64_t)v17, a2, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictKeyData);
    CFContainerEnumeratorBase::setup((unint64_t)&v19, a2, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
    uint64_t v4 = v20;
    if (v20 >= 1)
    {
      uint64_t v5 = 0;
      do
      {
        uint64_t v6 = *(void *)(v18 + 8 * v5);
        uint64_t v7 = *(void *)(v21 + 8 * v5);
        uint64_t v8 = *((void *)a1 + 12);
        if (v8)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v8 + 8));
          uint64_t v9 = *((void *)a1 + 12);
          uint64_t v10 = *((void *)a1 + 19);
          if (v9) {
            pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
          }
        }
        else
        {
          uint64_t v10 = *((void *)a1 + 19);
        }
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        if (v10) {
          uint64_t v11 = v10 + 16;
        }
        else {
          uint64_t v11 = 0;
        }
        ++*(void *)(v11 + 80);
        int v12 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v11 + 24) + 32))(*(void *)(v11 + 24), v6, v7);
        --*(void *)(v11 + 80);
        if (!v12)
        {
          uint64_t v13 = *((void *)a1 + 12);
          if (v13)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
            uint64_t v14 = *((void *)a1 + 12);
            uint64_t v15 = *((void *)a1 + 18);
            if (v14) {
              pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
            }
          }
          else
          {
            uint64_t v15 = *((void *)a1 + 18);
          }
          if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
          }
          if (v15) {
            uint64_t v16 = v15 + 16;
          }
          else {
            uint64_t v16 = 0;
          }
          ++*(void *)(v16 + 80);
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v16 + 24) + 32))(*(void *)(v16 + 24), v6, v7);
          --*(void *)(v16 + 80);
        }
        ++v5;
      }
      while (v4 != v5);
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v19);
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v17);
  }
}

void sub_1841F5804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v10);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a10);
  _Unwind_Resume(a1);
}

uint64_t HTTPNetConnection::getProxy@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 288);
  *a2 = *(void *)(this + 280);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

void HTTPNetConnection::setProxy(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (a1[35] != *a2)
  {
    uint64_t v4 = a2[1];
    if (v4) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v5 = (std::__shared_weak_count *)a1[36];
    a1[35] = v2;
    a1[36] = v4;
    if (v5)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
      uint64_t v2 = a1[35];
    }
    if (v2)
    {
      uint64_t v6 = a1[34];
      uint64_t v7 = (std::__shared_weak_count *)a1[36];
      uint64_t v12 = v2;
      uint64_t v13 = v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 56))(v6, &v12);
      if (v13) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v13);
      }
      uint64_t v8 = a1[12];
      if (v8)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v8 + 8));
        uint64_t v9 = a1[12];
        uint64_t v10 = a1[18];
        if (v9) {
          pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
        }
        if (!v10) {
          return;
        }
      }
      else
      {
        uint64_t v10 = a1[18];
        if (!v10) {
          return;
        }
      }
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      int v11 = (*(uint64_t (**)(void))(*(void *)a1[35] + 56))(a1[35]);
      if (v11 == 3)
      {
        HTTPWriteFilter::prepareHTTPSProxy((HTTPWriteFilter *)(v10 + 16));
      }
      else if (v11 == 2)
      {
        *(_WORD *)(v10 + 240) |= 0x200u;
      }
    }
  }
}

void sub_1841F59B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPNetConnection::receivedBytes(uint64_t this, uint64_t a2)
{
  if (*(unsigned char *)(this + 268))
  {
    uint64_t v3 = this;
    uint64_t v4 = *(void *)(this + 96);
    if (v4) {
      this = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    }
    uint64_t v5 = *(void *)(v3 + 136);
    if (v5) {
      uint64_t v6 = *(void *)(v5 + 8);
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(void *)(v3 + 96);
    if (v7) {
      this = pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
    }
    if (v6) {
      *(void *)(v6 + 112) += a2;
    }
  }
  return this;
}

uint64_t HTTPNetConnection::sentBytes(uint64_t this, uint64_t a2)
{
  if (*(unsigned char *)(this + 268))
  {
    uint64_t v3 = this;
    uint64_t v4 = *(void *)(this + 96);
    if (v4) {
      this = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    }
    uint64_t v5 = *(void *)(v3 + 128);
    if (v5) {
      uint64_t v6 = *(void *)(v5 + 8);
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(void *)(v3 + 96);
    if (v7) {
      this = pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
    }
    if (v6) {
      *(void *)(v6 + 104) += a2;
    }
  }
  return this;
}

uint64_t HTTPNetConnection::cleanAbortRequestTransmission(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 128);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 8);
    if (v2)
    {
      uint64_t v3 = this;
      *(_WORD *)(this + 88) &= ~0x20u;
      if (v1 == *(void *)(this + 136)) {
        *(void *)(this + 136) = 0;
      }
      *(_DWORD *)(v2 + 32) |= 8u;
      uint64_t v4 = *(void *)(v2 + 168);
      if (v4) {
        CoreSchedulingSet::_scheduleStream(v4, *(void *)(v2 + 8), (void (*)(uint64_t, uint64_t))_CFStreamUnscheduleFromDispatchQueue, MEMORY[0x1E4F1C270]);
      }
      CFReadStreamSetClient(*(CFReadStreamRef *)(v2 + 8), 0, 0, 0);
      uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v3 + 120);
      return v5(v3, v2, 5, 0);
    }
  }
  return this;
}

uint64_t HTTPNetConnection::copyReqestDebugDesc(HTTPNetConnection *this, void *a2)
{
  return (*(uint64_t (**)(void *))(*(void *)a2 + 104))(a2);
}

void HTTPNetConnection::closeConnectionStreams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 && *(unsigned char *)(a1 + 269))
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (a3) {
      uint64_t v7 = a3 + 16;
    }
    else {
      uint64_t v7 = 0;
    }
    ++*(void *)(v7 + 80);
    uint64_t v8 = (__CFReadStream *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), 0x1EC0A36C0);
    --*(void *)(v7 + 80);
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    if (a4) {
      uint64_t v9 = a4 + 16;
    }
    else {
      uint64_t v9 = 0;
    }
    ++*(void *)(v9 + 80);
    a1 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 24) + 40))(*(void *)(v9 + 24), 0x1EC0A36C0);
    uint64_t v10 = (__CFWriteStream *)a1;
    --*(void *)(v9 + 80);
    if (v8) {
      BOOL v11 = a1 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      ++*(void *)(v7 + 80);
      (*(void (**)(void, uint64_t, void))(**(void **)(v7 + 24) + 32))(*(void *)(v7 + 24), 0x1EC0A36C0, 0);
      --*(void *)(v7 + 80);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      ++*(void *)(v9 + 80);
      (*(void (**)(void, uint64_t, void))(**(void **)(v9 + 24) + 32))(*(void *)(v9 + 24), 0x1EC0A36C0, 0);
      --*(void *)(v9 + 80);
      uint64_t v12 = *(void *)(a2 + 120);
      if (v12)
      {
        (*(void (**)(uint64_t, __CFReadStream *, __CFWriteStream *))(*(void *)v12 + 264))(v12, v8, v10);
      }
      else
      {
        CFReadStreamClose(v8);
        CFWriteStreamClose(v10);
      }
      CFRelease(v8);
LABEL_30:
      CFRelease(v10);
      goto LABEL_31;
    }
    if (v8) {
      CFRelease(v8);
    }
    if (v10) {
      goto LABEL_30;
    }
  }
LABEL_31:

  NetConnection::closeConnectionStreams(a1, a2, a3, a4);
}

uint64_t HTTPNetConnection::callTestFunc(HTTPNetConnection *this, uint64_t (*a2)(void *, HTTPNetConnection *, HTTPNetConnection *), void *a3)
{
  return a2(a3, this, this);
}

uint64_t HTTPNetConnection::copySchedulingSetForRequest(HTTPNetConnection *this, void *a2)
{
  if (a2 && (uint64_t v2 = a2[21]) != 0) {
    return (*(uint64_t (**)(void))(*(void *)v2 + 88))();
  }
  else {
    return 0;
  }
}

uint64_t HTTPNetConnection::requestStreamCallback(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 == 16)
  {
    long long v14 = xmmword_1843D1950;
    uint64_t result = *(void *)(a2 + 128);
    if (!result) {
      return result;
    }
    return (*(uint64_t (**)(uint64_t, long long *))(*(void *)result + 64))(result, &v14);
  }
  if (a4 != 8)
  {
    if (a4 != 4) {
      return result;
    }
    uint64_t v6 = (NetConnection *)result;
    uint64_t result = HTTPNetConnection::transmitRequest(result, a2, a3);
    if (!result) {
      return result;
    }
    uint64_t result = *(void *)(a2 + 128);
    if (!result) {
      return result;
    }
    if (!DWORD2(v14))
    {
      uint64_t v7 = *((void *)v6 + 16);
      if (v7) {
        uint64_t v8 = *(void **)(v7 + 8);
      }
      else {
        uint64_t v8 = 0;
      }
      return NetConnection::requestIsComplete(v6, v8);
    }
    return (*(uint64_t (**)(uint64_t, long long *))(*(void *)result + 64))(result, &v14);
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  uint64_t v9 = a3 + 16;
  if (!a3) {
    uint64_t v9 = 0;
  }
  long long v13 = *(_OWORD *)(v9 + 56);
  uint64_t v10 = *(CapturedSSLState **)(a2 + 96);
  if (!v10)
  {
    CFAllocatorRef v11 = CFGetAllocator(*(CFTypeRef *)(a2 + 8));
    uint64_t v10 = (CapturedSSLState *)CFAllocatorAllocate(v11, 48, 0);
    *(_OWORD *)uint64_t v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    CFAllocatorRef v12 = CFGetAllocator(*(CFTypeRef *)(a2 + 8));
    CapturedSSLState::CapturedSSLState(v10, v12);
    *(void *)(a2 + 96) = v10;
  }
  *(void *)&long long v14 = MEMORY[0x1E4F143A8];
  *((void *)&v14 + 1) = 3221225472;
  uint64_t v15 = ___ZN16CapturedSSLState14grabFromStreamEP17__CoreWriteStream_block_invoke;
  uint64_t v16 = &__block_descriptor_40_e22__v16__0____CFString__8l;
  uint64_t v17 = a3;
  CapturedSSLState::grabFromStream(v10, (uint64_t)&v14);
  uint64_t result = *(void *)(a2 + 128);
  if (result) {
    return (*(uint64_t (**)(uint64_t, long long *))(*(void *)result + 64))(result, &v13);
  }
  return result;
}

uint64_t HTTPNetConnection::transmitRequest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](a1, a2, a3);
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(v6 + 8) = 0;
  if (*(unsigned char *)(v4 + 32)) {
    return 1;
  }
  uint64_t v7 = v6;
  uint64_t v8 = v5;
  uint64_t v9 = v4;
  uint64_t v10 = v3;
  p_opt_class_meths = &OBJC_PROTOCOL___NSURLDownloadDecoder.opt_class_meths;
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  uint64_t v12 = v8 ? v8 + 16 : 0;
  ++*(void *)(v12 + 80);
  long long v13 = (const void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v12 + 24) + 40))(*(void *)(v12 + 24), 0x1EC0A3650);
  --*(void *)(v12 + 80);
  if (v13)
  {
    long long v14 = v13;
    CFTypeID v15 = CFGetTypeID(v13);
    if (v15 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(clientContext.version) = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&clientContext, 2u);
    }
    uint64_t v16 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFRelease(v14);
    if (v16 == v14) {
      return 1;
    }
  }
  uint64_t v17 = *(__CFReadStream **)(v9 + 56);
  if (!v17) {
    goto LABEL_16;
  }
  if (CFReadStreamGetStatus(v17) == kCFStreamStatusNotOpen)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v12))
    {
      uint64_t v28 = *(__CFReadStream **)(v9 + 56);
      if (!v28) {
        goto LABEL_16;
      }
      if (!*(unsigned char *)(v9 + 64))
      {
        clientContext.version = 0;
        clientContext.info = (void *)v9;
        memset(&clientContext.retain, 0, 24);
        CFReadStreamSetClient(v28, 0x1AuLL, (CFReadStreamClientCallBack)HTTPNetStreamInfo::_httpRequestPayloadCallBack, &clientContext);
        uint64_t v29 = *(void *)(v9 + 168);
        if (v29) {
          CoreSchedulingSet::_scheduleStream(v29, *(void *)(v9 + 56), MEMORY[0x1E4F1C268], MEMORY[0x1E4F1C260]);
        }
        CFReadStreamOpen(*(CFReadStreamRef *)(v9 + 56));
      }
    }
  }
  if (*(void *)(v9 + 56) && !*(unsigned char *)(v9 + 64))
  {
    char v20 = 0;
    int v19 = 1;
    goto LABEL_18;
  }
LABEL_16:
  uint64_t result = HTTPNetConnection::isStreamReadyForWrite((HTTPNetConnection *)v10, v8, (CFHTTPMessageRef *)v9, (void *)v7);
  if (!result) {
    return result;
  }
  int v19 = 0;
  char v20 = 1;
LABEL_18:
  uint64_t v21 = *(void *)(v9 + 40);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t v22 = v21 + 16;
  if (!v21) {
    uint64_t v22 = 0;
  }
  __int16 v23 = *(const __CFDictionary ***)(v22 + 72);
  if (v23)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
    }
    unsigned int v24 = HTTPAuthentication::isKerberosThePreferredAuthScheme(v23[19]);
  }
  else
  {
    unsigned int v24 = 0;
  }
  if (v24) {
    char v25 = 1;
  }
  else {
    char v25 = v20;
  }
  if (v25)
  {
    if (!v19)
    {
      char v26 = 0;
      goto LABEL_55;
    }
  }
  else
  {
    uint64_t v27 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 80))(v10);
    if (_CFHTTPAuthenticationIsFirstNTLMTransaction((_CFHTTPAuthentication *)v23, v27))
    {
      uint64_t result = HTTPNetConnection::isStreamReadyForWrite((HTTPNetConnection *)v10, v8, (CFHTTPMessageRef *)v9, (void *)v7);
      if (!result) {
        return result;
      }
      char v26 = 1;
      goto LABEL_55;
    }
  }
  if (CFReadStreamGetStatus(*(CFReadStreamRef *)(v9 + 56)) == kCFStreamStatusError)
  {
    char v26 = 0;
    *(CFStreamError *)uint64_t v7 = CFReadStreamGetError((CFReadStreamRef)*(void *)(v9 + 56));
  }
  else
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    uint64_t Status = CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)v12);
    if (Status == 5)
    {
      char v26 = 0;
      *(void *)uint64_t v7 = 4;
      *(_DWORD *)(v7 + 8) = -1;
    }
    else
    {
      if (Status != 7)
      {
        char v26 = 0;
        int v31 = 0;
        goto LABEL_56;
      }
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      char v26 = 0;
      *(_OWORD *)uint64_t v7 = *(_OWORD *)(v12 + 56);
    }
  }
LABEL_55:
  int v31 = 1;
LABEL_56:
  if ((*(unsigned int (**)(void))(**(void **)(v10 + 272) + 88))(*(void *)(v10 + 272)) == 3)
  {
    uint64_t v32 = *(void *)(v10 + 96);
    if (v32)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v32 + 8));
      uint64_t v33 = *(void *)(v10 + 96);
      uint64_t v34 = *(void *)(v10 + 144);
      if (v33) {
        pthread_mutex_unlock((pthread_mutex_t *)(v33 + 8));
      }
    }
    else
    {
      uint64_t v34 = *(void *)(v10 + 144);
    }
    char v36 = v26;
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    if (v34) {
      uint64_t v37 = v34 + 16;
    }
    else {
      uint64_t v37 = 0;
    }
    ++*(void *)(v37 + 80);
    uint64_t v38 = (__CFHTTPMessage *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v37 + 24) + 40))(*(void *)(v37 + 24), 0x1EC0A5720);
    --*(void *)(v37 + 80);
    if (v38)
    {
      CFNumberRef v39 = v38;
      CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v38);
      char v26 = v36;
      p_opt_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NSURLDownloadDecoder + 48);
      if (ResponseStatusCode == 407)
      {
        unint64_t v40 = *(__CFHTTPMessage **)(v9 + 48);
        if (v40 == v39) {
          goto LABEL_74;
        }
        if (v40) {
          CFRelease(v40);
        }
        CFTypeRef v41 = CFRetain(v39);
        *(void *)(v9 + 48) = v41;
        if (v41) {
LABEL_74:
        }
          CFReadStreamSignalEvent();
        *(unsigned char *)(v10 + 250) = 0;
        updated = (unsigned char *)HTTPNetConnection::updateAuth((HTTPNetConnection *)v10, (CFHTTPMessageRef *)v9, v39);
        int v31 = 1;
        if (updated && updated != (unsigned char *)v9 && (updated[32] & 4) != 0) {
          NetConnection::responseIsComplete((NetConnection *)v10, updated);
        }
      }
      CFRelease(v39);
      if (v31) {
        goto LABEL_129;
      }
    }
    else
    {
      CFIndex ResponseStatusCode = 0;
      char v26 = v36;
      p_opt_class_meths = &OBJC_PROTOCOL___NSURLDownloadDecoder.opt_class_meths;
      if (v31) {
        goto LABEL_129;
      }
    }
  }
  else
  {
    CFIndex ResponseStatusCode = 0;
    if (v31) {
      goto LABEL_129;
    }
  }
  CFDataRef v43 = *(const __CFData **)(v9 + 80);
  if (!v43)
  {
    if (!CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)(v9 + 56))) {
      goto LABEL_127;
    }
    if (p_opt_class_meths[237] != (__objc2_meth_list *)-1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    if (!CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v12)) {
      goto LABEL_127;
    }
    CFDataRef v43 = *(const __CFData **)(v9 + 80);
    if (!v43)
    {
      CFIndex v49 = CFReadStreamRead(*(CFReadStreamRef *)(v9 + 56), (UInt8 *)&clientContext, 0x8000);
      CFIndex Length = v49;
      if (v49 < 0)
      {
        *(CFStreamError *)uint64_t v7 = CFReadStreamGetError((CFReadStreamRef)*(void *)(v9 + 56));
        int v48 = 1;
        p_CFStreamClientContext clientContext = (const unsigned __int8 *)&clientContext;
        goto LABEL_114;
      }
      if (!v49)
      {
        v52 = *(const void **)(v9 + 80);
        if (!v52) {
          goto LABEL_129;
        }
        int v48 = 1;
        goto LABEL_119;
      }
      p_CFStreamClientContext clientContext = (const unsigned __int8 *)&clientContext;
      goto LABEL_84;
    }
  }
  CFIndex Length = CFDataGetLength(v43);
  p_CFStreamClientContext clientContext = CFDataGetBytePtr(*(CFDataRef *)(v9 + 80));
  if (Length >= 1)
  {
LABEL_84:
    if (p_opt_class_meths[237] != (__objc2_meth_list *)-1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v12))
    {
      char v60 = v26;
      if (p_opt_class_meths[237] != (__objc2_meth_list *)-1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      uint64_t v46 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)v12, p_clientContext, Length);
      if (*(void *)(v10 + 216)) {
        (*(void (**)(uint64_t))(v10 + 192))(v10);
      }
      uint64_t v47 = *(void *)(v9 + 120);
      if (v47) {
        URLProtocol::uploadActivityOccurred((URLProtocol *)(v47 - 176), v46);
      }
      if (v46 < 0)
      {
        if (p_opt_class_meths[237] != (__objc2_meth_list *)-1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        char v26 = v60;
        *(_OWORD *)uint64_t v7 = *(_OWORD *)(v12 + 56);
        int v48 = 1;
      }
      else
      {
        if (v46)
        {
          int v48 = 0;
          Length -= v46;
          p_clientContext += v46;
          *(void *)(v9 + 88) += v46;
        }
        else
        {
          int v50 = (*(uint64_t (**)(void))(**(void **)(v10 + 272) + 88))(*(void *)(v10 + 272));
          *(void *)uint64_t v7 = 4;
          if (v50 == 1) {
            int v51 = -4;
          }
          else {
            int v51 = -1;
          }
          *(_DWORD *)(v7 + 8) = v51;
          int v48 = 1;
        }
        char v26 = v60;
      }
      goto LABEL_114;
    }
  }
  int v48 = 0;
LABEL_114:
  v52 = *(const void **)(v9 + 80);
  if (!v52)
  {
    if (Length >= 1)
    {
      CFAllocatorRef v54 = CFGetAllocator(*(CFTypeRef *)(v9 + 40));
      CFDataRef v55 = CFDataCreate(v54, p_clientContext, Length);
      HTTPNetStreamInfo::setRequestFragment((HTTPNetStreamInfo *)v9, v55);
      if (v55) {
        CFRelease(v55);
      }
    }
LABEL_123:
    if (v48) {
      goto LABEL_129;
    }
    goto LABEL_127;
  }
  if (Length < 1) {
    int v53 = 1;
  }
  else {
    int v53 = v48;
  }
  if (v53 == 1)
  {
LABEL_119:
    CFRelease(v52);
    *(void *)(v9 + 80) = 0;
    goto LABEL_123;
  }
  CFAllocatorRef v56 = CFGetAllocator(*(CFTypeRef *)(v9 + 40));
  CFDataRef v57 = CFDataCreate(v56, p_clientContext, Length);
  HTTPNetStreamInfo::setRequestFragment((HTTPNetStreamInfo *)v9, v57);
  if (v57) {
    CFRelease(v57);
  }
LABEL_127:
  if (*(void *)(v9 + 80) || CFReadStreamGetStatus(*(CFReadStreamRef *)(v9 + 56)) < kCFStreamStatusAtEnd)
  {
    v59 = *(__CFReadStream **)(v9 + 56);
    if (v59 && !*(unsigned char *)(v9 + 64)) {
      CFReadStreamHasBytesAvailable(v59);
    }
    if (p_opt_class_meths[237] != (__objc2_meth_list *)-1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v12);
    return 0;
  }
LABEL_129:
  if ((*(unsigned char *)(v9 + 33) & 8) != 0) {
    return 1;
  }
  if (v24) {
    char v58 = 1;
  }
  else {
    char v58 = v26;
  }
  uint64_t result = 1;
  if ((v58 & 1) == 0 && ResponseStatusCode != 407)
  {
    HTTPNetStreamInfo::closeRequestResources((HTTPNetStreamInfo *)v9);
    *(_DWORD *)(v9 + 32) |= 1u;
    return 1;
  }
  return result;
}

uint64_t HTTPNetConnection::isStreamReadyForWrite(HTTPNetConnection *a1, uint64_t a2, CFHTTPMessageRef *a3, void *a4)
{
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  if (a2) {
    uint64_t v8 = a2 + 16;
  }
  else {
    uint64_t v8 = 0;
  }
  if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v8)) {
    return 1;
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)v8) != 7) {
    return 0;
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  uint64_t v11 = *(void *)(v8 + 56);
  uint64_t v10 = *(void *)(v8 + 64);
  *a4 = v11;
  a4[1] = v10;
  uint64_t result = 1;
  if (v11 == 4 && (v10 + 2097) <= 1)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    ++*(void *)(v8 + 80);
    uint64_t v12 = (__CFHTTPMessage *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v8 + 24) + 40))(*(void *)(v8 + 24), 0x1EC0A5720);
    --*(void *)(v8 + 80);
    HTTPNetConnection::updateAuth(a1, a3, v12);
    if (v12) {
      CFRelease(v12);
    }
    uint64_t v13 = *((void *)a1 + 16);
    if (v13) {
      long long v14 = *(void **)(v13 + 8);
    }
    else {
      long long v14 = 0;
    }
    NetConnection::requestIsComplete(a1, v14);
    (*(void (**)(HTTPNetConnection *))(*(void *)a1 + 72))(a1);
    return 1;
  }
  return result;
}

uint64_t HTTPNetConnection::updateAuth(HTTPNetConnection *this, CFHTTPMessageRef *a2, __CFHTTPMessage *a3)
{
  CFURLRef v6 = CFHTTPMessageCopyRequestURL(a2[5]);
  _CFHTTPMessageSetResponseURL((uint64_t)a3, v6);
  if (CFHTTPMessageGetResponseStatusCode(a3) == 407)
  {
    uint64_t v7 = *((void *)this + 35);
    if (v7)
    {
      (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v7 + 48))(&cf);
      uint64_t v8 = cf;
      if (!cf) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
    CFAllocatorRef v11 = (const __CFAllocator *)*((void *)this + 1);
    int v12 = (*(uint64_t (**)(void))(**((void **)this + 34) + 88))(*((void *)this + 34));
    uint64_t v13 = **((void **)this + 34);
    if (v12 == 2)
    {
      uint64_t v14 = (*(uint64_t (**)(void))(v13 + 72))();
      uint64_t v15 = (*(uint64_t (**)(void))(**((void **)this + 34) + 80))(*((void *)this + 34));
      CFStringRef v16 = CFStringCreateWithFormat(v11, 0, @"http://%@:%d", v14, v15);
      if (!v16) {
        goto LABEL_5;
      }
    }
    else
    {
      if ((*(unsigned int (**)(void))(v13 + 88))() != 3) {
        goto LABEL_5;
      }
      if (!(*(uint64_t (**)(void))(**((void **)this + 34) + 64))(*((void *)this + 34))) {
        goto LABEL_5;
      }
      CFDictionaryRef v17 = (const __CFDictionary *)(*(uint64_t (**)(void))(**((void **)this + 34) + 64))(*((void *)this + 34));
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v17, &unk_1EC0A5678);
      CFDictionaryRef v19 = Value;
      if (!Value) {
        goto LABEL_5;
      }
      char v20 = CFDictionaryGetValue(Value, &unk_1EC0A56B0);
      uint64_t v21 = CFDictionaryGetValue(v19, &unk_1EC0A56E8);
      if (!v20 || v21 == 0) {
        goto LABEL_5;
      }
      CFStringRef v16 = CFStringCreateWithFormat(v11, 0, @"https://%@:%@", v20, v21);
      if (!v16) {
        goto LABEL_5;
      }
    }
    uint64_t v8 = CFURLCreateWithString(v11, v16, 0);
    CFRelease(v16);
    if (v8)
    {
LABEL_4:
      _CFHTTPMessageSetResponseProxyURL((uint64_t)a3, v8);
      CFRelease(v8);
    }
  }
LABEL_5:
  uint64_t v9 = (*(uint64_t (**)(HTTPNetConnection *, CFHTTPMessageRef *, __CFHTTPMessage *))(*(void *)this + 272))(this, a2, a3);
  if (v6) {
    CFRelease(v6);
  }
  return v9;
}

void sub_1841F6E68(_Unwind_Exception *a1)
{
  CFRelease(v2);
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(a1);
}

CFTypeRef HTTPNetStreamInfo::setRequestFragment(HTTPNetStreamInfo *this, CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 10);
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *((void *)this + 10) = result;
  }
  return result;
}

void HTTPNetConnection::responseStreamCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](a1, a2, a3);
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v9 = v8;
  uint64_t v10 = v3;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v11 = *(__CFRunLoopTimer **)(v8 + 176);
  if (v11)
  {
    CFRunLoopTimerInvalidate(v11);
    CFRelease(*(CFTypeRef *)(v9 + 176));
    *(void *)(v9 + 176) = 0;
  }
  if (*(void *)(v10 + 216)) {
    (*(void (**)(uint64_t))(v10 + 192))(v10);
  }
  if (HTTPNetConnection::handleReadEventsDuringRequestBodyTransmission((HTTPNetConnection *)v10, (void *)v9, v5))return; {
  int v12 = *(_DWORD *)(v9 + 32);
  }
  if ((v12 & 0x20) == 0) {
    HTTPNetConnection::prepareReception((HTTPNetConnection *)v10, v9, v7);
  }
  if (!*(void *)(v9 + 48) && v5 != 32 && (*(_DWORD *)(v9 + 32) & 4) == 0) {
    uint64_t v9 = HTTPNetConnection::updateForHeaders((HTTPNetConnection *)v10, v9, v7);
  }
  int v13 = *(_DWORD *)(v9 + 32);
  if ((v13 & 0x100) == 0)
  {
    *(_DWORD *)(v9 + 32) = v13 | 0x100;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v7) {
      uint64_t v14 = v7 + 16;
    }
    else {
      uint64_t v14 = 0;
    }
    ++*(void *)(v14 + 80);
    (*(void (**)(void, uint64_t))(**(void **)(v14 + 24) + 32))(*(void *)(v14 + 24), 0x1EC09F7C0);
    --*(void *)(v14 + 80);
    int v13 = *(_DWORD *)(v9 + 32);
  }
  if ((v13 & 0x200) == 0)
  {
    *(_DWORD *)(v9 + 32) = v13 | 0x200;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v7) {
      uint64_t v15 = v7 + 16;
    }
    else {
      uint64_t v15 = 0;
    }
    ++*(void *)(v15 + 80);
    (*(void (**)(void, uint64_t))(**(void **)(v15 + 24) + 32))(*(void *)(v15 + 24), 0x1EC09F440);
    --*(void *)(v15 + 80);
  }
  if (v5 <= 15)
  {
    if (v5 != 2)
    {
      if (v5 == 8)
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        uint64_t v16 = v7 + 16;
        if (!v7) {
          uint64_t v16 = 0;
        }
        *(_OWORD *)char v20 = *(_OWORD *)(v16 + 56);
        HTTPNetStreamInfo::grabReadStreamProperties(v9, v7);
        uint64_t v17 = *(void *)(v9 + 128);
        if (v17) {
          (*(void (**)(uint64_t, unsigned __int8 *))(*(void *)v17 + 64))(v17, v20);
        }
      }
      return;
    }
    if ((v12 & 0x20) == 0) {
      return;
    }
    if ((*(unsigned char *)(v9 + 32) & 4) != 0)
    {
      if (v7) {
        CFDictionaryRef v19 = (CoreStreamBase *)(v7 + 16);
      }
      else {
        CFDictionaryRef v19 = 0;
      }
      while (1)
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        if (!CoreStreamBase::_streamInterface_CanRead(v19)) {
          break;
        }
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        CoreStreamBase::_streamInterface_Read(v19, v20, 0x8000);
      }
      return;
    }
    goto LABEL_49;
  }
  if (v5 != 16)
  {
    if (v5 == 32 && (v12 & 0x20) != 0 && *(void *)(v9 + 128))
    {
      HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)v9);
    }
    return;
  }
  uint64_t v18 = *(void *)(v9 + 128);
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 72))(v18);
  }
  if ((*(unsigned char *)(v9 + 32) & 4) == 0)
  {
LABEL_49:
    _CFReadStreamSignalEventDelayed();
  }
}

uint64_t HTTPNetConnection::handleReadEventsDuringRequestBodyTransmission(HTTPNetConnection *this, void *a2, uint64_t a3)
{
  if (!*((unsigned char *)this + 264))
  {
    unsigned int v6 = *((unsigned __int8 *)this + 265);
    if (!*((unsigned char *)this + 265)) {
      goto LABEL_66;
    }
  }
  if (a3 != 2 && a3 != 16)
  {
    if (a3 == 64)
    {
      *((unsigned char *)this + 264) = 0;
      uint64_t v7 = (__CFRunLoopTimer *)*((void *)this + 32);
      if (v7)
      {
        CFRunLoopTimerInvalidate(v7);
        uint64_t v8 = (const void *)*((void *)this + 32);
        *((void *)this + 32) = 0;
        if (v8) {
          CFRelease(v8);
        }
      }
      uint64_t v9 = *((void *)this + 12);
      if (v9)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
        uint64_t v10 = *((void *)this + 12);
        uint64_t v11 = *((void *)this + 18);
        if (v10) {
          pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
        }
        if (!v11) {
          goto LABEL_52;
        }
        goto LABEL_49;
      }
      uint64_t v11 = *((void *)this + 18);
      if (v11)
      {
LABEL_49:
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        ++*(void *)(v11 + 96);
        (*(void (**)(void, uint64_t, void))(**(void **)(v11 + 40) + 32))(*(void *)(v11 + 40), 0x1EC0A36F8, 0);
        --*(void *)(v11 + 96);
        (*(void (**)(HTTPNetConnection *, void *))(*(void *)this + 128))(this, a2);
      }
    }
LABEL_52:
    unsigned int v6 = 0;
    goto LABEL_66;
  }
  uint64_t v12 = *((void *)this + 12);
  if (v12)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
    uint64_t v13 = *((void *)this + 12);
    uint64_t v14 = *((void *)this + 19);
    if (v13) {
      pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
    }
  }
  else
  {
    uint64_t v14 = *((void *)this + 19);
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (v14) {
    uint64_t v15 = v14 + 16;
  }
  else {
    uint64_t v15 = 0;
  }
  ++*(void *)(v15 + 80);
  uint64_t v16 = (unsigned char *)(*(uint64_t (**)(void, __CFString *))(**(void **)(v15 + 24) + 40))(*(void *)(v15 + 24), @"kCFStreamPropertyHTTPResponseHeader");
  --*(void *)(v15 + 80);
  if (v16)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
    {
      int v31 = v16;
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      uint64_t v16 = v31;
    }
    uint64_t v17 = v16 + 16;
    if (!v16[40]) {
      uint64_t v17 = 0;
    }
    if (*((void *)v17 + 11) || *((int *)v17 + 14) < 2)
    {
      BOOL v18 = 0;
    }
    else
    {
      int v29 = *((_DWORD *)v17 + 32);
      BOOL v18 = v29 != 407 && (v29 - 400) < 0xC8;
    }
    CFRelease(v16);
  }
  else
  {
    BOOL v18 = 0;
  }
  if (*((unsigned char *)this + 264))
  {
    BOOL v18 = 1;
    BOOL v19 = 0;
  }
  else
  {
    BOOL v19 = v18;
  }
  *((unsigned char *)this + 264) = 0;
  char v20 = (__CFRunLoopTimer *)*((void *)this + 32);
  if (v20)
  {
    CFRunLoopTimerInvalidate(v20);
    uint64_t v21 = (const void *)*((void *)this + 32);
    *((void *)this + 32) = 0;
    if (v21) {
      CFRelease(v21);
    }
  }
  if (v18)
  {
    NetConnection::requestIsComplete(this, a2);
    if (v19) {
      (*(void (**)(HTTPNetConnection *))(*(void *)this + 288))(this);
    }
    uint64_t v22 = *((void *)this + 12);
    if (v22)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v22 + 8));
      uint64_t v23 = *((void *)this + 12);
      uint64_t v24 = *((void *)this + 18);
      if (v23)
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v23 + 8));
        uint64_t v25 = *((void *)this + 12);
        if (v25)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v25 + 8));
          uint64_t v26 = *((void *)this + 12);
          uint64_t v27 = *((void *)this + 19);
          if (v26) {
            pthread_mutex_unlock((pthread_mutex_t *)(v26 + 8));
          }
          goto LABEL_55;
        }
      }
    }
    else
    {
      uint64_t v24 = *((void *)this + 18);
    }
    uint64_t v27 = *((void *)this + 19);
LABEL_55:
    if (v24)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      ++*(void *)(v24 + 96);
      (*(void (**)(void, uint64_t, void))(**(void **)(v24 + 40) + 32))(*(void *)(v24 + 40), 0x1EC0A36F8, 0);
      --*(void *)(v24 + 96);
    }
    if (v27)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      ++*(void *)(v27 + 96);
      (*(void (**)(void, uint64_t, void))(**(void **)(v27 + 40) + 32))(*(void *)(v27 + 40), 0x1EC0A36F8, 0);
      --*(void *)(v27 + 96);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      v32.domain = 0;
      *(void *)&v32.error = 0;
      CoreStreamBase::_signalEvent((CoreStreamBase *)(v27 + 16), 2, v32, 0);
    }
    goto LABEL_65;
  }
  *((unsigned char *)this + 266) = 1;
LABEL_65:
  unsigned int v6 = !v18;
LABEL_66:
  if (a3 == 64) {
    return 1;
  }
  else {
    return v6;
  }
}

void HTTPNetConnection::prepareReception(HTTPNetConnection *a1, uint64_t a2, uint64_t a3)
{
  if (*((unsigned char *)a1 + 266))
  {
    *((unsigned char *)a1 + 266) = 0;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (a3) {
      unsigned int v6 = (CoreStreamBase *)(a3 + 16);
    }
    else {
      unsigned int v6 = 0;
    }
    v33.CFIndex domain = 0;
    *(void *)&v33.error = 0;
    CoreStreamBase::_signalEvent(v6, 2, v33, 0);
  }
  int v7 = *(_DWORD *)(a2 + 32);
  if ((v7 & 0x20) != 0) {
    return;
  }
  *(_DWORD *)(a2 + 32) = v7 | 0x20;
  if (a3)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v8 = a3 + 16;
  }
  else
  {
    uint64_t v8 = 0;
  }
  CFIndex v30 = 0;
  uint64_t v31 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 136));
  if ((~*(unsigned __int16 *)(v8 + 232) & 0x201) == 0)
  {
    CFAllocatorRef v9 = CFGetAllocator(*(CFTypeRef *)(v8 + 224));
    Boolean IsRequest = CFHTTPMessageIsRequest(*(CFHTTPMessageRef *)(v8 + 224));
    CFHTTPMessageRef Empty = CFHTTPMessageCreateEmpty(v9, IsRequest);
    uint64_t v12 = *(const void **)(v8 + 224);
    if (v12) {
      CFRelease(v12);
    }
    int v13 = *(unsigned __int16 *)(v8 + 232);
    *(void *)(v8 + 224) = Empty;
    *(_OWORD *)(v8 + 240) = xmmword_1843D16E0;
    int v14 = v13 | (*(unsigned __int8 *)(v8 + 234) << 16);
    *(_WORD *)(v8 + 232) = v14 & 0x12DA;
    *(unsigned char *)(v8 + 234) = (v14 & 0xFFFD12DA) >> 16;
    if ((v14 & 0x40) != 0)
    {
      uint64_t v15 = *(const void **)(v8 + 208);
      if (v15)
      {
        int v16 = v14 & 0xFD129A;
        *(_WORD *)(v8 + 232) = v16;
        *(unsigned char *)(v8 + 234) = BYTE2(v16);
        CFRetain(v15);
        CFReadStreamSetProperty(*(CFReadStreamRef *)(v8 + 208), (CFStreamPropertyKey)&unk_1EC09F7C0, (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
        uint64_t v17 = *(const void **)(v8 + 208);
        if (v17) {
          CFRelease(v17);
        }
      }
    }
  }
  BOOL v18 = *(const void **)(v8 + 208);
  if (v18 && !*(unsigned char *)(v8 + 216))
  {
    CFTypeRef cf = CFRetain(v18);
    char v29 = 0;
    if (HTTPReadFilter::canReadNoSignal(v8, (uint64_t)&cf, (uint64_t)&v30))
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      v25.CFIndex domain = 0;
      *(void *)&v25.error = 0;
      uint64_t v26 = 2;
LABEL_68:
      CoreStreamBase::_signalEvent((CoreStreamBase *)v8, v26, v25, 0);
LABEL_69:
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      *(void *)(v8 + 40) &= ~0x20uLL;
      if (cf) {
        CFRelease(cf);
      }
      goto LABEL_26;
    }
    if (v31)
    {
      v25.CFIndex domain = v30;
      if (v30 != 1)
      {
LABEL_65:
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
        {
          CFIndex domain = v25.domain;
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
          v25.CFIndex domain = domain;
        }
        *(void *)&v25.error = v31;
        uint64_t v26 = 8;
        goto LABEL_68;
      }
      if (v31 != 54 && v31 != 32)
      {
        v25.CFIndex domain = 1;
        goto LABEL_65;
      }
    }
    else if (CFReadStreamGetStatus(*(CFReadStreamRef *)(v8 + 208)) != kCFStreamStatusAtEnd {
           || *(void *)(v8 + 248) == *(void *)(v8 + 240) && (*(_WORD *)(v8 + 232) & 0x20) == 0)
    }
    {
      goto LABEL_69;
    }
    LODWORD(v31) = -4;
    v25.CFIndex domain = 4;
    goto LABEL_65;
  }
  LODWORD(v31) = -4;
  *(_WORD *)(v8 + 232) |= 0x4000u;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  *(void *)&v34.error = v31;
  v34.CFIndex domain = 4;
  CoreStreamBase::_signalEvent((CoreStreamBase *)v8, 8, v34, 0);
LABEL_26:
  pthread_mutex_unlock((pthread_mutex_t *)(v8 + 136));
  CFStringRef v19 = CFHTTPMessageCopyRequestMethod(*(CFHTTPMessageRef *)(a2 + 40));
  if (v19)
  {
    CFStringRef v20 = v19;
    if (CFEqual(v19, &unk_1EC0A33B0))
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      if (a3) {
        uint64_t v21 = a3 + 16;
      }
      else {
        uint64_t v21 = 0;
      }
      ++*(void *)(v21 + 80);
      (*(void (**)(void, uint64_t))(**(void **)(v21 + 24) + 32))(*(void *)(v21 + 24), 0x1EC0A3768);
      --*(void *)(v21 + 80);
    }
    CFRelease(v20);
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (a3) {
    uint64_t v22 = (CoreStreamBase *)(a3 + 16);
  }
  else {
    uint64_t v22 = 0;
  }
  if (CoreStreamBase::_streamInterface_CanRead(v22))
  {
    if (!*(void *)(a2 + 48)) {
      HTTPNetConnection::updateForHeaders(a1, a2, a3);
    }
    uint64_t v23 = 2;
  }
  else
  {
    if (!_CFHTTPReadStreamIsAtMark(a3)) {
      return;
    }
    uint64_t v23 = 32;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  v24.CFIndex domain = 0;
  *(void *)&v24.error = 0;

  CoreStreamBase::_signalEvent(v22, v23, v24, 0);
}

void sub_1841F7D60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPNetConnection::updateForHeaders(HTTPNetConnection *a1, uint64_t updated, uint64_t a3)
{
  if (a3)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    ++*(void *)(a3 + 96);
    unsigned int v6 = (__CFHTTPMessage *)(*(uint64_t (**)(void, __CFString *))(**(void **)(a3 + 40) + 40))(*(void *)(a3 + 40), @"kCFStreamPropertyHTTPResponseHeader");
    int v7 = v6;
    --*(void *)(a3 + 96);
    if (v6)
    {
      if (!canKeepAlive(v6, *(__CFHTTPMessage **)(updated + 40))) {
        (*(void (**)(HTTPNetConnection *))(*(void *)a1 + 72))(a1);
      }
      updated = HTTPNetConnection::updateAuth(a1, (CFHTTPMessageRef *)updated, v7);
    }
    else
    {
      (*(void (**)(HTTPNetConnection *))(*(void *)a1 + 72))(a1);
    }
    uint64_t v8 = *(__CFHTTPMessage **)(updated + 48);
    CFTypeRef v9 = v7;
    if (v8 != v7)
    {
      if (v8) {
        CFRelease(*(CFTypeRef *)(updated + 48));
      }
      if (v7) {
        CFTypeRef v9 = CFRetain(v7);
      }
      else {
        CFTypeRef v9 = 0;
      }
      *(void *)(updated + 48) = v9;
    }
    if (v9) {
      CFReadStreamSignalEvent();
    }
    if (v7) {
      CFRelease(v7);
    }
    uint64_t v10 = *(void *)(updated + 48);
    if (v10)
    {
      uint64_t v11 = *(void *)(updated + 40);
      if (v11)
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        int v12 = *(unsigned __int8 *)(v10 + 40);
        if (*(unsigned char *)(v10 + 40)) {
          uint64_t v13 = v10 + 16;
        }
        else {
          uint64_t v13 = 0;
        }
        if (*(unsigned char *)(v11 + 40)) {
          uint64_t v14 = 0;
        }
        else {
          uint64_t v14 = v11 + 16;
        }
        if (v12 && !*(unsigned char *)(v11 + 40) && !*(void *)(v13 + 88) && *(int *)(v13 + 56) >= 2)
        {
          int v15 = *(_DWORD *)(v13 + 128);
          CFStringRef v16 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)v13, 0x11F1D2DBu);
          CFStringRef v17 = v16;
          if (v16) {
            CFRelease(v16);
          }
          if (v17) {
            BOOL v18 = 0;
          }
          else {
            BOOL v18 = v15 == 204;
          }
          char v19 = v18;
          if (v15 == 304
            || (v15 - 100) < 0x64
            || (v19 & 1) != 0
            || ((CFStringRef v20 = *(const __CFString **)(v14 + 152)) != 0
             || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
             && (*(_WORD *)buf = 0,
                 _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (CFStringRef v20 = *(const __CFString **)(v14 + 152)) != 0))&& CFEqual(v20, (CFStringRef)&gConstantCFStringValueTable[2611]))
          {
            *(_DWORD *)(updated + 32) |= 2u;
            HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)updated);
          }
        }
      }
    }
  }
  else
  {
    CFLog();
  }
  return updated;
}

void HTTPNetConnection::receiveResponse(HTTPNetConnection *this, void *a2, uint64_t a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](this, a2, a3);
  uint64_t v5 = v4;
  unsigned int v6 = (HTTPNetConnection *)v3;
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(v3 + 96);
  if (v7)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 8));
    uint64_t v8 = *((void *)v6 + 12);
    uint64_t v9 = *((void *)v6 + 19);
    if (v8) {
      pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
    }
  }
  else
  {
    uint64_t v9 = *(void *)(v3 + 152);
  }
  if ((*(unsigned char *)(v5 + 32) & 0x10) == 0 && (*(unsigned char *)(v5 + 32) & 0x40) == 0 && v9)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if ((CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v9 + 16)) & 0xFFFFFFFFFFFFFFFDLL) == 5) {
      goto LABEL_53;
    }
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v9 + 16))
      || _CFHTTPReadStreamIsAtMark(v9))
    {
LABEL_53:
      if (*(void *)(v5 + 48)
        || (*(unsigned char *)(v5 + 32) & 4) != 0
        || (uint64_t v5 = HTTPNetConnection::updateForHeaders(v6, v5, v9), (*(unsigned char *)(v5 + 32) & 2) == 0))
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        if (!CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v9 + 16)))
        {
          if (!_CFHTTPReadStreamIsAtMark(v9) || (*(unsigned char *)(v5 + 32) & 4) != 0)
          {
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
            }
            if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v9 + 16)) != 5)
            {
              if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
                dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
              }
              if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v9 + 16)) == 7)
              {
                if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
                  dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
                }
                *(_OWORD *)int v12 = *(_OWORD *)(v9 + 72);
                (*(void (**)(HTTPNetConnection *, unsigned __int8 *))(*(void *)v6 + 64))(v6, v12);
              }
              return;
            }
            (*(void (**)(HTTPNetConnection *))(*(void *)v6 + 72))(v6);
          }
          HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)v5);
          return;
        }
        if ((*(unsigned char *)(v5 + 32) & 4) != 0)
        {
          do
          {
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
            }
            if (!CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v9 + 16))) {
              break;
            }
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
            }
            uint64_t v10 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)(v9 + 16), v12, 0x8000);
            if (v10 < 0)
            {
              if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
                dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
              }
              long long v11 = *(_OWORD *)(v9 + 72);
              (*(void (**)(HTTPNetConnection *, long long *))(*(void *)v6 + 64))(v6, &v11);
              return;
            }
          }
          while (v10);
        }
        else
        {
          _CFReadStreamSignalEventDelayed();
        }
      }
    }
  }
}

uint64_t HTTPNetConnection::transmitRequest(uint64_t this, void *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *(void *)(this + 96);
  if (v4)
  {
    this = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    uint64_t v5 = *(void *)(v3 + 96);
    uint64_t v6 = *(void *)(v3 + 144);
    if (v5) {
      this = pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
    }
  }
  else
  {
    uint64_t v6 = *(void *)(this + 144);
  }
  if ((a2[4] & 0x40) == 0)
  {
    this = HTTPNetConnection::transmitRequest(v3, (uint64_t)a2, v6);
    int v7 = v19;
    if (v19)
    {
      *(unsigned char *)(v3 + 265) = 0;
      if (v18 == 4 && v7 == -2096)
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        if (v6) {
          uint64_t v8 = v6 + 16;
        }
        else {
          uint64_t v8 = 0;
        }
        ++*(void *)(v8 + 80);
        uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(v8 + 24) + 40))(*(void *)(v8 + 24));
        --*(void *)(v8 + 80);
        if (v9)
        {
          uint64_t v10 = (const void *)v9;
          long long v11 = (const void *)a2[6];
          if (v11 == v10) {
            goto LABEL_19;
          }
          if (v11) {
            CFRelease(v11);
          }
          CFTypeRef v12 = CFRetain(v10);
          a2[6] = v12;
          if (v12) {
LABEL_19:
          }
            CFReadStreamSignalEvent();
          CFRelease(v10);
        }
        uint64_t v13 = *(void *)(v3 + 128);
        if (v13) {
          uint64_t v14 = *(void **)(v13 + 8);
        }
        else {
          uint64_t v14 = 0;
        }
        NetConnection::requestIsComplete((NetConnection *)v3, v14);
        CFStringRef v17 = *(uint64_t (**)(uint64_t))(*(void *)v3 + 72);
        return v17(v3);
      }
      else
      {
        return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v3 + 64))(v3, &v18);
      }
    }
    else if (this)
    {
      *(unsigned char *)(v3 + 265) = 0;
      uint64_t v15 = *(void *)(v3 + 128);
      if (v15) {
        CFStringRef v16 = *(void **)(v15 + 8);
      }
      else {
        CFStringRef v16 = 0;
      }
      return NetConnection::requestIsComplete((NetConnection *)v3, v16);
    }
  }
  return this;
}

void HTTPNetConnection::requestStateChanged(void *a1, HTTPNetStreamInfo *this, int a3, uint64_t a4)
{
  uint64_t v148 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 8) = *((_DWORD *)this + 8) & 0xFFFE1FFF | ((a3 & 0xF) << 13);
  uint64_t v8 = (__CFRunLoopSource *)*((void *)this + 17);
  if (v8) {
    CFRunLoopSourceSignal(v8);
  }
  switch(a3)
  {
    case 1:
      if (*((unsigned char *)a1 + 250)) {
        return;
      }
      *((unsigned char *)a1 + 250) = 1;
      if ((*(unsigned int (**)(void))(*(void *)a1[34] + 88))(a1[34]) != 3) {
        return;
      }
      uint64_t v9 = (__CFHTTPMessage *)*((void *)this + 5);
      uint64_t v10 = a1[12];
      if (v10)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
        uint64_t v11 = a1[12];
        uint64_t v12 = a1[18];
        if (v11) {
          pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
        }
      }
      else
      {
        uint64_t v12 = a1[18];
      }
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      *(_WORD *)(v12 + 240) &= ~0x20u;
      uint64_t v102 = (*(uint64_t (**)(void *, __CFHTTPMessage *))(*a1 + 264))(a1, v9);
      if (!v102) {
        return;
      }
      uint64_t v103 = v102;
      CFAllocatorRef v104 = (const __CFAllocator *)a1[1];
      uint64_t v105 = a1[12];
      if (v105)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v105 + 8));
        uint64_t v106 = a1[12];
        uint64_t v107 = a1[19];
        if (v106) {
          pthread_mutex_unlock((pthread_mutex_t *)(v106 + 8));
        }
      }
      else
      {
        uint64_t v107 = a1[19];
      }
      v146.version = 0;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      if (v107) {
        uint64_t v117 = v107 + 16;
      }
      else {
        uint64_t v117 = 0;
      }
      ++*(void *)(v117 + 80);
      CFDictionaryRef v118 = (const __CFDictionary *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v117 + 24) + 40))(*(void *)(v117 + 24), 0x1EC0A5678);
      CFDictionaryRef v119 = v118;
      --*(void *)(v117 + 80);
      if (v118)
      {
        CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v118, &unk_1EC0A5640);
        CFDictionaryRef v121 = Value;
        if (Value)
        {
          v122 = CFDictionaryGetValue(Value, &unk_1EC0A2658);
          char v123 = 0;
          goto LABEL_228;
        }
      }
      else
      {
        CFDictionaryRef v121 = 0;
      }
      v122 = 0;
      char v123 = 1;
LABEL_228:
      CFHTTPMessageRef Copy = CFHTTPMessageCreateCopy(v104, v9);
      context.version = (*(uint64_t (**)(void *, CFHTTPMessageRef, uint64_t))(*a1 + 256))(a1, Copy, v103);
      context.info = v125;
      if (v125)
      {
        (*(void (**)(void *, CFRunLoopTimerContext *))(*a1 + 64))(a1, &context);
        v146.version = 0;
        CFRelease(Copy);
      }
      else
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        CFStringRef v126 = HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Copy + 16), 0x1382736Bu);
        v146.version = (CFIndex)v126;
        CFRelease(Copy);
        if (v126 && (!v122 || !CFEqual(v122, v126)))
        {
          uint64_t v127 = a1[12];
          if (v127)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v127 + 8));
            uint64_t v128 = a1[12];
            uint64_t v129 = a1[18];
            if (v128) {
              pthread_mutex_unlock((pthread_mutex_t *)(v128 + 8));
            }
          }
          else
          {
            uint64_t v129 = a1[18];
          }
          if (v123)
          {
            MutableCFHTTPMessageRef Copy = CFDictionaryCreate(v104, (const void **)&kCFHTTPHeaderProxyAuthorization, (const void **)&v146, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            values = MutableCopy;
          }
          else
          {
            CFIndex Count = CFDictionaryGetCount(v121);
            MutableCFHTTPMessageRef Copy = CFDictionaryCreateMutableCopy(v104, Count + 1, v121);
            values = MutableCopy;
            CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, &unk_1EC0A2658, v126);
          }
          if (v119)
          {
            CFIndex v137 = CFDictionaryGetCount(v119);
            v138 = CFDictionaryCreateMutableCopy(v104, v137 + 1, v119);
            CFDictionarySetValue(v138, &unk_1EC0A5640, MutableCopy);
          }
          else
          {
            v138 = CFDictionaryCreate(v104, (const void **)&kCFStreamPropertyCONNECTAdditionalHeaders, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            MutableCFHTTPMessageRef Copy = values;
          }
          if (MutableCopy) {
            CFRelease(MutableCopy);
          }
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
          }
          uint64_t v140 = *(void *)(v117 + 80);
          v139 = (void *)(v117 + 80);
          void *v139 = v140 + 1;
          (*(void (**)(void, uint64_t, __CFDictionary *))(*(void *)*(v139 - 7) + 32))(*(v139 - 7), 0x1EC0A5678, v138);
          --*v139;
          if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
          }
          if (v129) {
            uint64_t v141 = v129 + 16;
          }
          else {
            uint64_t v141 = 0;
          }
          uint64_t v143 = *(void *)(v141 + 80);
          v142 = (void *)(v141 + 80);
          void *v142 = v143 + 1;
          (*(void (**)(void, uint64_t, __CFDictionary *))(*(void *)*(v142 - 7) + 32))(*(v142 - 7), 0x1EC0A5678, v138);
          --*v142;
          if (v138) {
            CFRelease(v138);
          }
        }
      }
      if (v119) {
        CFRelease(v119);
      }
      if (v146.version) {
        CFRelease((CFTypeRef)v146.version);
      }
      return;
    case 2:
      uint64_t v19 = a1[12];
      if (!v19)
      {
        uint64_t v21 = a1[18];
LABEL_50:
        uint64_t v24 = a1[19];
        goto LABEL_51;
      }
      pthread_mutex_lock((pthread_mutex_t *)(v19 + 8));
      uint64_t v20 = a1[12];
      uint64_t v21 = a1[18];
      if (!v20) {
        goto LABEL_50;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8));
      uint64_t v22 = a1[12];
      if (!v22) {
        goto LABEL_50;
      }
      pthread_mutex_lock((pthread_mutex_t *)(v22 + 8));
      uint64_t v23 = a1[12];
      uint64_t v24 = a1[19];
      if (v23) {
        pthread_mutex_unlock((pthread_mutex_t *)(v23 + 8));
      }
LABEL_51:
      uint64_t v144 = v24;
      uint64_t v36 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_6258, 2);
      if (v36)
      {
        uint64_t v37 = v36;
        if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v36 + 16))(v36, "HTTPNetConnection::prepareTransmission", 0))
        {
          (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v37 + 72))(v37, "streamInfo", @"%p");
          (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v37 + 72))(v37, "requestStream", @"%p");
          CFAllocatorRef v38 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFNumberRef v39 = (const void *)*((void *)this + 5);
          context.version = (CFIndex)off_1ECF9A530;
          info = (void *)CFStringCreateWithCString(v38, "request: ", 0x8000100u);
          context.retain = 0;
          context.release = 0;
          context.info = info;
          if (v39)
          {
            CFStringRef v41 = CFCopyDescription(v39);
            info = context.info;
          }
          else
          {
            CFStringRef v41 = @"null";
          }
          (*(void (**)(uint64_t, void *, CFStringRef))(*(void *)v37 + 64))(v37, info, v41);
          if (v39 && v41) {
            CFRelease(v41);
          }
          AutoString::~AutoString((AutoString *)&context);
          (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
        }
      }
      uint64_t v49 = NetConnection::willEnqueueRequests((NetConnection *)a1);
      p_vtable = AVAssetDownloadURLSession.vtable;
      if ((*(unsigned int (**)(void))(*(void *)a1[34] + 88))(a1[34]) == 2)
      {
        *((unsigned char *)a1 + 267) = 0;
LABEL_80:
        int v52 = 1;
        goto LABEL_81;
      }
      int v51 = (*(uint64_t (**)(void))(*(void *)a1[34] + 88))(a1[34]);
      *((unsigned char *)a1 + 267) = 0;
      if (v51 == 3) {
        goto LABEL_80;
      }
      int v52 = 0;
      if ((*((unsigned char *)this + 33) & 4) != 0 && v49)
      {
        uint64_t v62 = *((void *)this + 5);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        if (v62) {
          v63 = (HTTPMessage *)(v62 + 16);
        }
        else {
          v63 = 0;
        }
        CFStringRef v64 = HTTPMessage::copyHeaderFieldValue(v63, 0x11B152B9u);
        CFStringRef v65 = v64;
        if (v64)
        {
          if (CFStringCompare(v64, @"close", 1uLL) == kCFCompareEqualTo)
          {
            uint64_t v66 = a1[12];
            if (v66) {
              pthread_mutex_lock((pthread_mutex_t *)(v66 + 8));
            }
            *((_WORD *)a1 + 44) &= ~1u;
            NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)a1);
            uint64_t v67 = a1[12];
            if (v67) {
              pthread_mutex_unlock((pthread_mutex_t *)(v67 + 8));
            }
            uint64_t v49 = 0;
          }
          CFRelease(v65);
        }
        int v52 = 0;
      }
LABEL_81:
      uint64_t v53 = *((void *)this + 5);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      if (v53) {
        CFAllocatorRef v54 = (HTTPMessage *)(v53 + 16);
      }
      else {
        CFAllocatorRef v54 = 0;
      }
      CFStringRef v55 = HTTPMessage::copyHeaderFieldValue(v54, 0x1270D306u);
      CFStringRef v56 = v55;
      if (v55)
      {
        if (CFStringFind(v55, (CFStringRef)&unk_1EC0A2D20, 1uLL).location == -1
          || (uint64_t v57 = (*(uint64_t (**)(void *, HTTPNetStreamInfo *))(*a1 + 160))(a1, this)) == 0)
        {
          int v61 = 0;
        }
        else
        {
          *((unsigned char *)a1 + 264) = 1;
          uint64_t v58 = a1[12];
          if (v58)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v58 + 8));
            uint64_t v59 = a1[12];
            uint64_t v60 = a1[18];
            if (v59) {
              pthread_mutex_unlock((pthread_mutex_t *)(v59 + 8));
            }
          }
          else
          {
            uint64_t v60 = a1[18];
          }
          if (v60)
          {
            uint64_t v68 = v49;
            int v69 = v52;
            v146.version = 0;
            v146.info = a1;
            memset(&v146.retain, 0, 24);
            uint64_t v70 = *MEMORY[0x1E4F1CFD0];
            if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
              dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
            }
            uint64_t v72 = *(void *)(v60 + 96);
            v71 = (void *)(v60 + 96);
            void *v71 = v72 + 1;
            (*(void (**)(void, uint64_t, uint64_t))(*(void *)*(v71 - 7) + 32))(*(v71 - 7), 0x1EC0A36F8, v70);
            int v52 = v69;
            uint64_t v49 = v68;
            --*v71;
            CFAllocatorRef v73 = (const __CFAllocator *)a1[1];
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            v75 = (CFStringRef (__cdecl *)(const void *))CFRunLoopTimerCreate(v73, Current + 5.0, -1.0, 0, 0, (CFRunLoopTimerCallBack)HTTPNetConnection::_OneHundredContinueTimeout, &v146);
            a1[32] = v75;
            context.version = MEMORY[0x1E4F143A8];
            context.info = (void *)3221225472;
            context.retain = (const void *(__cdecl *)(const void *))___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
            context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
            context.copyDescription = v75;
            CoreSchedulingSet::applyBlockWithPossibleEmulation(v57, &context);
          }
          (*(void (**)(uint64_t))(*(void *)v57 + 48))(v57);
          uint64_t v76 = a1[12];
          if (v76)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v76 + 8));
            uint64_t v77 = a1[12];
            uint64_t v78 = a1[19];
            if (v77) {
              pthread_mutex_unlock((pthread_mutex_t *)(v77 + 8));
            }
          }
          else
          {
            uint64_t v78 = a1[19];
          }
          if (v78 != v144) {
            __assert_rtn("prepareTransmission", "HTTPNetConnection.cpp", 899, "getResponseStream() == responseStream");
          }
          if (v144)
          {
            uint64_t v79 = *MEMORY[0x1E4F1CFD0];
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
            }
            ++*(void *)(v144 + 96);
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v144 + 40) + 32))(*(void *)(v144 + 40), 0x1EC0A36F8, v79);
            p_vtable = (void **)(AVAssetDownloadURLSession + 24);
            --*(void *)(v144 + 96);
            int v61 = 1;
          }
          else
          {
            int v61 = 0;
            p_vtable = AVAssetDownloadURLSession.vtable;
          }
        }
        CFRelease(v56);
      }
      else
      {
        int v61 = 0;
      }
      uint64_t v80 = *((void *)this + 5);
      if (p_vtable[503] != (void *)-1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      if (v80) {
        v81 = (HTTPMessage *)(v80 + 16);
      }
      else {
        v81 = 0;
      }
      CFStringRef v82 = HTTPMessage::copyHeaderFieldValue(v81, 0x1490F3F6u);
      if (v82)
      {
        CFRelease(v82);
        *((unsigned char *)a1 + 269) = 1;
        uint64_t v83 = *MEMORY[0x1E4F1CFD0];
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        if (v21) {
          uint64_t v84 = v21 + 16;
        }
        else {
          uint64_t v84 = 0;
        }
        uint64_t v86 = *(void *)(v84 + 80);
        v85 = (void *)(v84 + 80);
        void *v85 = v86 + 1;
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)*(v85 - 7) + 32))(*(v85 - 7), 0x1EC0A3688, v83);
        --*v85;
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        if (v144) {
          uint64_t v87 = v144 + 16;
        }
        else {
          uint64_t v87 = 0;
        }
        uint64_t v89 = *(void *)(v87 + 80);
        v88 = (void *)(v87 + 80);
        void *v88 = v89 + 1;
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)*(v88 - 7) + 32))(*(v88 - 7), 0x1EC0A3688, v83);
        --*v88;
      }
      if (*((void *)this + 7) && (a1[11] & 2) == 0)
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        if (v21) {
          uint64_t v90 = v21 + 16;
        }
        else {
          uint64_t v90 = 0;
        }
        uint64_t v92 = *(void *)(v90 + 80);
        v91 = (void *)(v90 + 80);
        void *v91 = v92 + 1;
        CFBooleanRef v93 = (const __CFBoolean *)(*(uint64_t (**)(void, uint64_t))(*(void *)*(v91 - 7) + 40))(*(v91 - 7), 0x1EC0A3490);
        CFBooleanRef v94 = v93;
        --*v91;
        if (v93)
        {
          if (CFBooleanGetValue(v93))
          {
            int v61 = 1;
            *((unsigned char *)a1 + 265) = 1;
          }
          CFRelease(v94);
        }
      }
      if (!v61) {
        goto LABEL_171;
      }
      uint64_t v95 = (*(uint64_t (**)(void *, HTTPNetStreamInfo *))(*a1 + 160))(a1, this);
      uint64_t v96 = a1[12];
      if (v96)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v96 + 8));
        uint64_t v97 = a1[12];
        uint64_t v98 = a1[19];
        if (v97) {
          pthread_mutex_unlock((pthread_mutex_t *)(v97 + 8));
        }
        if (v98) {
          goto LABEL_161;
        }
      }
      else
      {
        uint64_t v98 = a1[19];
        if (v98)
        {
LABEL_161:
          CFRetain((CFTypeRef)v98);
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
          }
          v99 = (const CoreSchedulingSet *)v95;
          if (!v95)
          {
            if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1) {
              dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
            }
            v99 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
          }
          CoreStreamBase::_streamInterface_UpdateScheduling((CoreStreamBase *)(v98 + 16), v99);
          CFRelease((CFTypeRef)v98);
          HTTPNetConnection::prepareReception((HTTPNetConnection *)a1, (uint64_t)this, v98);
          goto LABEL_170;
        }
      }
      HTTPNetConnection::prepareReception((HTTPNetConnection *)a1, (uint64_t)this, 0);
LABEL_170:
      (*(void (**)(uint64_t))(*(void *)v95 + 48))(v95);
LABEL_171:
      if (*((void *)this + 7) && !*((unsigned char *)this + 64)) {
        cleanUpRequest(*((__CFHTTPMessage **)this + 5), *((void *)this + 9), v49, v52, 0);
      }
      else {
        cleanUpRequest(*((__CFHTTPMessage **)this + 5), 0, v49, v52, 0);
      }
      (*(void (**)(void *, HTTPNetStreamInfo *, uint64_t))(*a1 + 248))(a1, this, v49);
      uint64_t v100 = *((void *)this + 5);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      if (v21) {
        uint64_t v101 = v21 + 16;
      }
      else {
        uint64_t v101 = 0;
      }
      ++*(void *)(v101 + 80);
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v101 + 24) + 32))(*(void *)(v101 + 24), 0x1EC0A35E0, v100);
      --*(void *)(v101 + 80);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v101))
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        v150.CFIndex domain = 0;
        *(void *)&v150.error = 0;
        CoreStreamBase::_signalEvent((CoreStreamBase *)v101, 4, v150, 0);
      }
      return;
    case 3:
      uint64_t v13 = a1[12];
      if (v13)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
        uint64_t v14 = a1[12];
        uint64_t v15 = a1[18];
        if (v14) {
          pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
        }
      }
      else
      {
        uint64_t v15 = a1[18];
      }
      *((unsigned char *)a1 + 265) = 0;
      HTTPNetStreamInfo::closeRequestResources(this);
      if (v15)
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        uint64_t v31 = v15 + 16;
      }
      else
      {
        uint64_t v31 = 0;
      }
      __int16 v32 = *(_WORD *)(v31 + 224);
      if ((v32 & 0x400) != 0)
      {
        __int16 v33 = v32 | 1;
        *(_WORD *)(v31 + 224) = v32 | 1;
        if ((v32 & 0x80) != 0)
        {
          if (*(void *)(v31 + 216))
          {
            CFStreamError v34 = *(__CFWriteStream **)(v31 + 208);
            if (v34)
            {
              CFWriteStreamWrite(v34, (const UInt8 *)"\r\n0\r\n\r\n", 7);
              *(void *)(v31 + 288) += 7;
              __int16 v33 = *(_WORD *)(v31 + 224);
            }
          }
        }
      }
      else
      {
        __int16 v33 = *(_WORD *)(v31 + 224);
      }
      *(_WORD *)(v31 + 224) = v33 | 4;
      if ((*(unsigned int (**)(uint64_t))(*(void *)v31 + 72))(v31))
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        v35.CFIndex domain = 0;
        *(void *)&v35.error = 0;
        CoreStreamBase::_signalEvent((CoreStreamBase *)v31, 4, v35, 0);
      }
      return;
    case 4:
      if (!*((void *)this + 22))
      {
        uint64_t v42 = *((void *)this + 21);
        if (v42)
        {
          if (*(_DWORD *)(v42 + 40))
          {
            uint64_t v43 = *((void *)this + 15);
            if (!v43 || (*(unsigned int (**)(uint64_t))(*(void *)v43 + 256))(v43))
            {
              CFStringRef v44 = CFHTTPMessageCopyRequestMethod(*((CFHTTPMessageRef *)this + 5));
              if (v44)
              {
                CFStringRef v45 = v44;
                if (CFStringCompare(v44, @"GET", 1uLL) == kCFCompareEqualTo)
                {
                  context.version = 0;
                  context.info = this;
                  memset(&context.retain, 0, 24);
                  CFAllocatorRef v46 = CFGetAllocator(*((CFTypeRef *)this + 1));
                  CFAbsoluteTime v47 = CFAbsoluteTimeGetCurrent();
                  int v48 = CFRunLoopTimerCreate(v46, v47 + 3.0, -1.0, 0, 0, (CFRunLoopTimerCallBack)HTTPNetStreamInfo::_stallTimerFired, &context);
                  *((void *)this + 22) = v48;
                  CoreSchedulingSet::scheduleTimer(*((CoreSchedulingSet **)this + 21), v48);
                }
                CFRelease(v45);
              }
            }
          }
        }
      }
      uint64_t v25 = a1[12];
      if (v25)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v25 + 8));
        uint64_t v26 = a1[12];
        uint64_t v27 = a1[19];
        if (v26) {
          pthread_mutex_unlock((pthread_mutex_t *)(v26 + 8));
        }
      }
      else
      {
        uint64_t v27 = a1[19];
      }
      HTTPNetConnection::prepareReception((HTTPNetConnection *)a1, (uint64_t)this, v27);
      return;
    case 5:
      uint64_t v28 = a1[12];
      if (v28)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v28 + 8));
        uint64_t v29 = a1[12];
        uint64_t v30 = a1[19];
        if (v29) {
          pthread_mutex_unlock((pthread_mutex_t *)(v29 + 8));
        }
      }
      else
      {
        uint64_t v30 = a1[19];
      }
      if ((*((unsigned char *)this + 32) & 0xC) != 0) {
        goto LABEL_65;
      }
      if (!*((void *)this + 6)
        && (HTTPNetStreamInfo *)HTTPNetConnection::updateForHeaders((HTTPNetConnection *)a1, (uint64_t)this, v30) != this)
      {
        goto LABEL_212;
      }
      goto LABEL_211;
    case 7:
      HTTPNetStreamInfo::closeRequestResources(this);
      if ((*((unsigned char *)this + 32) & 4) != 0)
      {
LABEL_65:
        HTTPNetStreamInfo::dequeueFromConnection((NetConnection **)this);
      }
      else
      {
        if (*(void *)a4 == 4 && *(_DWORD *)(a4 + 8) == -2096)
        {
          uint64_t v16 = a1[12];
          if (v16)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
            uint64_t v17 = a1[12];
            uint64_t v18 = a1[18];
            if (v17) {
              pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
            }
          }
          else
          {
            uint64_t v18 = a1[18];
          }
          if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
          }
          if (v18) {
            uint64_t v108 = v18 + 16;
          }
          else {
            uint64_t v108 = 0;
          }
          ++*(void *)(v108 + 80);
          uint64_t v109 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v108 + 24) + 40))(*(void *)(v108 + 24), 0x1EC0A5720);
          --*(void *)(v108 + 80);
          if (v109)
          {
            v110 = (const void *)v109;
            v111 = (const void *)*((void *)this + 6);
            if (v111 == v110) {
              goto LABEL_204;
            }
            if (v111) {
              CFRelease(v111);
            }
            CFTypeRef v112 = CFRetain(v110);
            *((void *)this + 6) = v112;
            if (v112) {
LABEL_204:
            }
              CFReadStreamSignalEvent();
            CFRelease(v110);
          }
          _CFReadStreamSignalEventDelayed();
          if (*(void *)a4 == 4 && *(_DWORD *)(a4 + 8) == -2096)
          {
            uint64_t v113 = a1[12];
            if (v113)
            {
              pthread_mutex_lock((pthread_mutex_t *)(v113 + 8));
              uint64_t v114 = a1[12];
              uint64_t v115 = a1[18];
              if (v114) {
                pthread_mutex_unlock((pthread_mutex_t *)(v114 + 8));
              }
            }
            else
            {
              uint64_t v115 = a1[18];
            }
            if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
              dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
            }
            if (v115) {
              uint64_t v130 = v115 + 16;
            }
            else {
              uint64_t v130 = 0;
            }
            ++*(void *)(v130 + 80);
            uint64_t v131 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v130 + 24) + 40))(*(void *)(v130 + 24), 0x1EC0A5720);
            --*(void *)(v130 + 80);
            if (v131)
            {
              v132 = (void *)v131;
              v133 = (const void *)*((void *)this + 6);
              if (v133 == v132) {
                goto LABEL_253;
              }
              if (v133) {
                CFRelease(v133);
              }
              CFTypeRef v134 = CFRetain(v132);
              *((void *)this + 6) = v134;
              if (v134) {
LABEL_253:
              }
                CFReadStreamSignalEvent();
              HTTPNetConnection::updateAuth((HTTPNetConnection *)a1, (CFHTTPMessageRef *)this, (__CFHTTPMessage *)v132);
              CFRelease(v132);
            }
          }
        }
LABEL_211:
        _CFReadStreamSignalEventDelayed();
      }
LABEL_212:
      if ((*((unsigned char *)this + 32) & 4) != 0)
      {
        v116 = *(void (**)(HTTPNetStreamInfo *))(*(void *)this + 168);
        v116(this);
      }
      return;
    default:
      CFLog();
      return;
  }
}

void sub_1841F9DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void HTTPNetConnection::_OneHundredContinueTimeout(HTTPNetConnection *this, __CFRunLoopTimer *a2, void *a3)
{
  uint64_t v4 = *((void *)a2 + 12);
  if (!v4)
  {
    uint64_t v6 = *((void *)a2 + 18);
LABEL_7:
    uint64_t v9 = *((void *)a2 + 19);
    goto LABEL_8;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  uint64_t v5 = *((void *)a2 + 12);
  uint64_t v6 = *((void *)a2 + 18);
  if (!v5) {
    goto LABEL_7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  uint64_t v7 = *((void *)a2 + 12);
  if (!v7) {
    goto LABEL_7;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 8));
  uint64_t v8 = *((void *)a2 + 12);
  uint64_t v9 = *((void *)a2 + 19);
  if (v8) {
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  }
LABEL_8:
  if (v9)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    ++*(void *)(v9 + 96);
    (*(void (**)(void, uint64_t, void))(**(void **)(v9 + 40) + 32))(*(void *)(v9 + 40), 0x1EC0A36F8, 0);
    --*(void *)(v9 + 96);
  }
  if (v6)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    ++*(void *)(v6 + 96);
    (*(void (**)(void, uint64_t, void))(**(void **)(v6 + 40) + 32))(*(void *)(v6 + 40), 0x1EC0A36F8, 0);
    --*(void *)(v6 + 96);
    uint64_t v10 = *((void *)a2 + 12);
    if (v10) {
      pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
    }
    uint64_t v11 = *((void *)a2 + 16);
    if (v11) {
      uint64_t v12 = *(void *)(v11 + 8);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = *((void *)a2 + 12);
    if (v13) {
      pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
    }
    uint64_t v14 = *(void (**)(__CFRunLoopTimer *, uint64_t))(*(void *)a2 + 128);
    v14(a2, v12);
  }
}

uint64_t ___ZN17HTTPNetConnection19prepareTransmissionEP17HTTPNetStreamInfoP17__CoreWriteStreamP16__CoreReadStream_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 856;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t HTTPNetConnection::createStreams(HTTPNetConnection *a1, uint64_t *a2, uint64_t *a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*((void *)a1 + 1);
  CFStringRef v41 = 0;
  uint64_t v42 = 0;
  uint64_t v7 = (void *)(*(uint64_t (**)(void *))(**((void **)a1 + 34) + 72))(*((void **)a1 + 34));
  *((void *)a1 + 30) = v7;
  CFRetain(v7);
  uint64_t v8 = (void *)*((void *)a1 + 38);
  if (v8)
  {
    *((unsigned char *)v8 + 176) = 0;
    uint64_t v9 = (__CFReadStream *)v8[29];
    CFStringRef v41 = (__CFWriteStream *)v8[30];
    uint64_t v42 = v9;
    v8[29] = 0;
    v8[30] = 0;
    if (!*((void *)a1 + 35))
    {
      uint64_t v11 = v8[25];
      uint64_t v10 = (std::__shared_weak_count *)v8[26];
      uint64_t v39 = v11;
      unint64_t v40 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(HTTPNetConnection *, uint64_t *))(*(void *)a1 + 232))(a1, &v39);
      if (v40) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v40);
      }
    }
    (*(void (**)(void *))(**((void **)a1 + 38) + 48))(*((void **)a1 + 38));
    *((void *)a1 + 38) = 0;
    uint64_t v12 = v41;
    uint64_t v13 = v42;
    if (!v42 || !v41) {
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v14 = (void *)*((void *)a1 + 34);
    CFStringRef v15 = (const __CFString *)v14[4];
    CFAllocatorRef v16 = (const __CFAllocator *)*((unsigned int *)v14 + 14);
    uint64_t v17 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(v6, v15, (const __CFAllocator *)(unsigned __int16)*((_DWORD *)v14 + 14));
    if (!v17)
    {
      uint64_t v17 = CFHostCreateWithName(v6, v15);
      if (!v17) {
        return 1;
      }
    }
    __CFStreamCreatePairWithSocketToCFHost(v6, v17, v16, &v42, &v41, 0);
    CFRelease(v17);
    uint64_t v12 = v41;
    uint64_t v13 = v42;
    if (!v42 || !v41)
    {
LABEL_19:
      if (v13)
      {
        CFRelease(v13);
        uint64_t v12 = v41;
      }
      if (v12) {
        CFRelease(v12);
      }
      return 1;
    }
    CFWriteStreamSetProperty(v41, (CFStreamPropertyKey)&unk_1EC0A0390, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
  }
  if ((*(unsigned int (**)(void *))(**((void **)a1 + 34) + 88))(*((void **)a1 + 34)) == 1) {
    CFReadStreamSetProperty(v42, (CFStreamPropertyKey)&unk_1EC0A10B0, &unk_1EC0A13C0);
  }
  int v18 = (*(unsigned int (**)(void *))(**((void **)a1 + 34) + 88))(*((void **)a1 + 34)) == 2
     || (*(uint64_t (**)(void *))(**((void **)a1 + 34) + 88))(*((void **)a1 + 34)) == 3;
  uint64_t v20 = __CoreWriteStreamCreateHTTPStreamWithConnInfo(v6, 0, v18, v41, a1);
  *a2 = v20;
  uint64_t v21 = *MEMORY[0x1E4F1CFD0];
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  if (v20) {
    uint64_t v22 = v20 + 16;
  }
  else {
    uint64_t v22 = 0;
  }
  ++*(void *)(v22 + 80);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v22 + 24) + 32))(*(void *)(v22 + 24), 0x1EC0A3618, v21);
  --*(void *)(v22 + 80);
  if (v41) {
    CFRelease(v41);
  }
  HTTPStreamWithConnInfo = __CoreReadStreamCreateHTTPStreamWithConnInfo(v6, v42, 1, a1);
  *a3 = (uint64_t)HTTPStreamWithConnInfo;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (HTTPStreamWithConnInfo) {
    uint64_t v24 = HTTPStreamWithConnInfo + 1;
  }
  else {
    uint64_t v24 = 0;
  }
  ++*((void *)v24 + 10);
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)v24 + 3) + 32))(*((void *)v24 + 3), 0x1EC0A3618, v21);
  --*((void *)v24 + 10);
  if (v42) {
    CFRelease(v42);
  }
  uint64_t result = (*(uint64_t (**)(void *))(**((void **)a1 + 34) + 64))(*((void **)a1 + 34));
  if (result)
  {
    uint64_t v25 = (const void *)result;
    CFContainerEnumeratorBase::setup((unint64_t)v34, (CFTypeRef)result, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictKeyData);
    CFContainerEnumeratorBase::setup((unint64_t)&v36, v25, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
    uint64_t v26 = v37;
    if (v37 >= 1)
    {
      uint64_t v27 = 0;
      do
      {
        uint64_t v28 = *(void *)(v35 + 8 * v27);
        uint64_t v29 = *(void *)(v38 + 8 * v27);
        uint64_t v30 = *a3;
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        if (v30) {
          uint64_t v31 = v30 + 16;
        }
        else {
          uint64_t v31 = 0;
        }
        ++*(void *)(v31 + 80);
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v31 + 24) + 32))(*(void *)(v31 + 24), v28, v29);
        --*(void *)(v31 + 80);
        uint64_t v32 = *a2;
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        if (v32) {
          uint64_t v33 = v32 + 16;
        }
        else {
          uint64_t v33 = 0;
        }
        ++*(void *)(v33 + 80);
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v33 + 24) + 32))(*(void *)(v33 + 24), v28, v29);
        --*(void *)(v33 + 80);
        ++v27;
      }
      while (v26 != v27);
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v36);
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v34);
    return 0;
  }
  return result;
}

void sub_1841FA610(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v12 = *(std::__shared_weak_count **)(v10 - 112);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPNetConnection::errorOccurred(HTTPNetConnection *this, CFStreamError *a2)
{
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  uint64_t v5 = *((void *)this + 16);
  if (v5) {
    CFAllocatorRef v6 = *(HTTPNetStreamInfo **)(v5 + 8);
  }
  else {
    CFAllocatorRef v6 = 0;
  }
  uint64_t v7 = *((void *)this + 12);
  if (v7) {
    pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  }
  if (v6) {
    HTTPNetStreamInfo::closeAndReleasePayload(v6);
  }

  return NetConnection::errorOccurred(this, a2);
}

void HTTPNetConnection::HTTPNetConnection(HTTPNetConnection *this, const __CFAllocator *a2, HTTPConnectionCacheKey *a3)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, a2);
  *uint64_t v5 = &unk_1ECF9E608;
  v5[3] = &unk_1ECF9E740;
  v5[35] = 0;
  v5[36] = 0;
  v5[34] = a3;
  (*(void (**)(HTTPConnectionCacheKey *))(*(void *)a3 + 40))(a3);
  *((void *)this + 38) = 0;
  *((_DWORD *)this + 62) = 0;
  *((_WORD *)this + 134) = 1;
  CFAllocatorRef v6 = (std::__shared_weak_count *)*((void *)this + 36);
  *((void *)this + 35) = 0;
  *((void *)this + 36) = 0;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_1841FA798(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)*((void *)v1 + 36);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  NetConnection::~NetConnection(v1);
  _Unwind_Resume(a1);
}

void HTTPNetConnection::~HTTPNetConnection(HTTPNetConnection *this)
{
  *(void *)this = &unk_1ECF9E608;
  *((void *)this + 3) = &unk_1ECF9E740;
  uint64_t v2 = *((void *)this + 34);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }
  uint64_t v3 = (__CFRunLoopTimer *)*((void *)this + 32);
  if (v3)
  {
    CFRunLoopTimerInvalidate(v3);
    uint64_t v4 = (const void *)*((void *)this + 32);
    if (v4) {
      CFRelease(v4);
    }
  }
  if (*((void *)this + 38)) {
    __assert_rtn("~HTTPNetConnection", "HTTPNetConnection.cpp", 47, "!fTube");
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }

  NetConnection::~NetConnection(this);
}

void sub_1841FA8A4(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)*((void *)v1 + 36);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  NetConnection::~NetConnection(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth(HTTPNetConnection_NoAuth *this)
{
  uint64_t v2 = (char *)this - 24;
  HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth((HTTPNetConnection_NoAuth *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth((HTTPNetConnection_NoAuth *)((char *)this - 24));
}

void HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth(HTTPNetConnection_NoAuth *this)
{
  *(void *)this = &unk_1ECFA2CF0;
  *((void *)this + 3) = &unk_1ECFA2E28;
  CFSetApplyFunction(*((CFSetRef *)this + 39), (CFSetApplierFunction)_authDisassociate, this);
  uint64_t v2 = (const void *)*((void *)this + 39);
  if (v2) {
    CFRelease(v2);
  }

  HTTPNetConnection::~HTTPNetConnection(this);
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1841FA9A0(_Unwind_Exception *a1)
{
  HTTPNetConnection::~HTTPNetConnection(v1);
  _Unwind_Resume(a1);
}

HTTPNetStreamInfo *HTTPNetConnection_NoAuth::updateAuthForReal(CFMutableSetRef *this, HTTPNetStreamInfo *a2, __CFHTTPMessage *a3)
{
  int v6 = NetConnection::willEnqueueRequests((NetConnection *)this);
  uint64_t v7 = *((void *)a2 + 5);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t v8 = v7 + 16;
  if (!v7) {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(const void **)(v8 + 72);
  if (v9)
  {
    if (!v6)
    {
      _CFHTTPAuthenticationDisassociateConnection(*(void *)(v8 + 72), this);
      CFSetRemoveValue(this[39], v9);
    }
    _CFHTTPAuthenticationUpdateFromResponse((uint64_t)v9, a3, this);
    uint64_t v10 = *((void *)a2 + 5);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
  }
  else
  {
    uint64_t v10 = *((void *)a2 + 5);
  }
  uint64_t v11 = v10 + 16;
  if (!v10) {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(const void **)(v11 + 80);
  if (v12)
  {
    if (!v6)
    {
      _CFHTTPAuthenticationDisassociateConnection(*(void *)(v11 + 80), this);
      CFSetRemoveValue(this[39], v12);
    }
    _CFHTTPAuthenticationUpdateFromResponse((uint64_t)v12, a3, this);
  }
  return a2;
}

uint64_t HTTPNetConnection_NoAuth::getProxyAuth(HTTPNetConnection_NoAuth *this, __CFHTTPMessage *a2)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  CFAllocatorRef v3 = (char *)a2 + 16;
  if (!a2) {
    CFAllocatorRef v3 = 0;
  }
  return *((void *)v3 + 10);
}

CFDictionaryRef HTTPNetConnection_NoAuth::applyCredentialsDictionary(HTTPNetConnection_NoAuth *this, __CFHTTPMessage *a2, _CFHTTPAuthentication *a3)
{
  return _CFHTTPAuthenticationApplyHeaderToRequest(a3, a2, this);
}

void HTTPNetConnection_NoAuth::applyAnyCredentials(CFMutableSetRef *this, HTTPNetStreamInfo *a2, int a3)
{
  v15[2] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *((void *)a2 + 5);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t v7 = 0;
  uint64_t v8 = v6 + 16;
  if (!v6) {
    uint64_t v8 = 0;
  }
  v15[0] = *(void *)(v8 + 72);
  uint64_t v9 = *((void *)a2 + 5);
  if (v9) {
    uint64_t v10 = v9 + 16;
  }
  else {
    uint64_t v10 = 0;
  }
  v15[1] = *(void *)(v10 + 80);
  char v11 = 1;
  do
  {
    char v12 = v11;
    uint64_t v13 = (const void *)v15[v7];
    if (v13)
    {
      if (a3)
      {
        _CFHTTPAuthenticationApplyHeaderToRequest((_CFHTTPAuthentication *)v15[v7], *((__CFHTTPMessage **)a2 + 5), this);
        if (!v14) {
          CFSetSetValue(this[39], v13);
        }
      }
      else
      {
        _CFHTTPAuthenticationDisassociateConnection(v15[v7], this);
        CFSetRemoveValue(this[39], v13);
      }
    }
    char v11 = 0;
    uint64_t v7 = 1;
  }
  while ((v12 & 1) != 0);
}

uint64_t HTTPNetConnection_NoAuth::isConnectionWithAuth(HTTPNetConnection_NoAuth *this)
{
  return 0;
}

void HTTPNetConnection_NoAuth::HTTPNetConnection_NoAuth(HTTPNetConnection_NoAuth *this, const __CFAllocator *a2, HTTPConnectionCacheKey *a3)
{
  HTTPNetConnection::HTTPNetConnection(this, a2, a3);
  *(void *)uint64_t v4 = &unk_1ECFA2CF0;
  *(void *)(v4 + 24) = &unk_1ECFA2E28;
  *((void *)this + 39) = CFSetCreateMutable(*(CFAllocatorRef *)(v4 + 8), 0, MEMORY[0x1E4F1D548]);
}

void sub_1841FAD38(_Unwind_Exception *a1)
{
  HTTPNetConnection::~HTTPNetConnection(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth(HTTPNetConnection_WithAuth *this)
{
  uint64_t v2 = (char *)this - 24;
  HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth((HTTPNetConnection_WithAuth *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth((HTTPNetConnection_WithAuth *)((char *)this - 24));
}

void HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth(HTTPNetConnection_WithAuth *this)
{
  *(void *)this = &unk_1ECFA3758;
  *((void *)this + 3) = &unk_1ECFA3890;
  uint64_t v2 = *((void *)this + 39);
  if (v2)
  {
    _CFHTTPAuthenticationDisassociateConnection(v2, this);
    CFAllocatorRef v3 = (const void *)*((void *)this + 39);
    if (v3) {
      CFRelease(v3);
    }
  }
  uint64_t v4 = (const void *)*((void *)this + 40);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *((void *)this + 41);
  if (v5)
  {
    _CFHTTPAuthenticationDisassociateConnection(v5, this);
    uint64_t v6 = (const void *)*((void *)this + 41);
    if (v6) {
      CFRelease(v6);
    }
  }
  uint64_t v7 = (const void *)*((void *)this + 42);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)*((void *)this + 44);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)*((void *)this + 45);
  if (v9) {
    CFRelease(v9);
  }

  HTTPNetConnection::~HTTPNetConnection(this);
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1841FAE68(_Unwind_Exception *a1)
{
  HTTPNetConnection::~HTTPNetConnection(v1);
  _Unwind_Resume(a1);
}

void HTTPNetConnection_WithAuth::applyRemoteCredentials(HTTPNetConnection_WithAuth *this, _CFURLCredential *a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    uint64_t v5 = URLCredential_PasswordBased::safelyCast(*((void *)this + 45), a2);
    if (v5) {
      CFStringRef v6 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 128))(v5);
    }
    else {
      CFStringRef v6 = 0;
    }
    uint64_t v7 = (_CFHTTPAuthentication *)*((void *)this + 44);
    if (v7)
    {
      CFStringRef Username = (const __CFString *)CFURLCredentialGetUsername(v2);
      CFHTTPMessageApplyCredentials((CFHTTPMessageRef)a2, v7, Username, v6, 0);
    }
    if (v6)
    {
      CFRelease(v6);
    }
  }
}

HTTPNetStreamInfo *HTTPNetConnection_WithAuth::updateAuthForReal(HTTPNetConnection_WithAuth *this, HTTPNetStreamInfo *a2, CFHTTPMessageRef response)
{
  if ((*((unsigned char *)a2 + 33) & 8) != 0) {
    return a2;
  }
  CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(response);
  uint64_t v7 = *((void *)this + 39);
  if (v7)
  {
    _CFHTTPAuthenticationUpdateFromResponse(v7, response, this);
    if (!CFHTTPAuthenticationIsValid(*((CFHTTPAuthenticationRef *)this + 39), &v34)) {
      *((unsigned char *)this + 248) = 1;
    }
  }
  uint64_t v8 = *((void *)this + 41);
  if (v8)
  {
    _CFHTTPAuthenticationUpdateFromResponse(v8, response, this);
    if (!CFHTTPAuthenticationIsValid(*((CFHTTPAuthenticationRef *)this + 41), 0)) {
      *((unsigned char *)this + 249) = 1;
    }
  }
  int v9 = NetConnection::willEnqueueRequests(this);
  *((void *)this + 46) = ResponseStatusCode;
  if (!v9
    || (*((unsigned char *)this + 248) || !*((void *)this + 39) || ResponseStatusCode != 401)
    && (*((unsigned char *)this + 249) || !*((void *)this + 41) || ResponseStatusCode != 407))
  {
    return a2;
  }
  uint64_t v10 = *((void *)this + 1);
  uint64_t v43 = 0;
  CFStringRef v44 = &v43;
  uint64_t v45 = 0x2020000000;
  uint64_t v46 = 0;
  uint64_t v35 = MEMORY[0x1E4F143A8];
  uint64_t v36 = 3221225472;
  uint64_t v37 = ___ZN17HTTPNetStreamInfo18createZombieDoubleEPK13__CFAllocatorP17HTTPNetConnection_block_invoke;
  uint64_t v38 = &unk_1E52547C0;
  uint64_t v39 = &v43;
  unint64_t v40 = a2;
  uint64_t v41 = v10;
  uint64_t v42 = this;
  CFReadStreamCreate();
  uint64_t v11 = v44[3];
  _Block_object_dispose(&v43, 8);
  if (!v11) {
    return a2;
  }
  *(_DWORD *)(v11 + 32) |= 0x840u;
  uint64_t v12 = *((void *)this + 12);
  if (v12) {
    pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
  }
  if (*((void *)this + 16) && (*((_WORD *)this + 44) & 0x20) != 0)
  {
    uint64_t v13 = (uint64_t *)*((void *)this + 16);
    while ((v13[2] & 2) != 0)
    {
      uint64_t v13 = (uint64_t *)*v13;
      if (!v13)
      {
        uint64_t v13 = (uint64_t *)*((void *)this + 16);
        break;
      }
    }
    CFAllocatorRef v16 = (HTTPNetStreamInfo *)v13[1];
    BOOL v14 = v16 == a2;
    if (v16 != a2) {
      uint64_t v13 = 0;
    }
  }
  else
  {
    uint64_t v13 = 0;
    BOOL v14 = 0;
  }
  if (!*((void *)this + 17) || (*((_WORD *)this + 44) & 0x200) != 0)
  {
    BOOL v19 = 0;
  }
  else
  {
    uint64_t v17 = (uint64_t *)*((void *)this + 17);
    while ((v17[2] & 2) != 0)
    {
      uint64_t v17 = (uint64_t *)*v17;
      if (!v17)
      {
        uint64_t v17 = (uint64_t *)*((void *)this + 17);
        break;
      }
    }
    int v18 = (HTTPNetStreamInfo *)v17[1];
    BOOL v19 = v18 == a2;
    if (v18 == a2) {
      uint64_t v13 = v17;
    }
  }
  if ((v19 || v14) && (uint64_t v20 = (uint64_t *)*v13) != 0)
  {
    uint64_t v21 = (uint64_t *)*v13;
    while ((v21[2] & 2) != 0)
    {
      uint64_t v21 = (uint64_t *)*v21;
      if (!v21)
      {
        uint64_t v21 = v20;
        break;
      }
    }
    uint64_t v22 = (const CoreSchedulingSet *)(*(uint64_t (**)(HTTPNetConnection_WithAuth *, uint64_t))(*(void *)this + 160))(this, v21[1]);
  }
  else
  {
    uint64_t v22 = 0;
  }
  uint64_t v23 = (char *)this + 112;
  while (1)
  {
    uint64_t v23 = *(char **)v23;
    if (!v23) {
      break;
    }
    if (*((HTTPNetStreamInfo **)v23 + 1) == a2)
    {
      *((void *)v23 + 1) = v11;
      v23[16] |= 2u;
      break;
    }
  }
  if (v14)
  {
    NetConnection::rescheduleStream(*((char **)this + 18), v22);
    uint64_t v24 = *((void *)this + 16);
    if (v24 && *(void *)(v24 + 8) == v11 && (*((_WORD *)this + 44) & 0x20) != 0) {
      (*(void (**)(HTTPNetConnection_WithAuth *, uint64_t))(*(void *)this + 128))(this, v11);
    }
  }
  else if (v19)
  {
    uint64_t v25 = (char *)*((void *)this + 19);
    if (v25)
    {
      CFRetain(*((CFTypeRef *)this + 19));
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      uint64_t v26 = (CoreStreamBase *)(v25 + 16);
    }
    else
    {
      uint64_t v26 = 0;
    }
    uint64_t v27 = v22;
    if (!v22)
    {
      if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
      {
        uint64_t v33 = v26;
        dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
        uint64_t v26 = v33;
      }
      uint64_t v27 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
    }
    CoreStreamBase::_streamInterface_UpdateScheduling(v26, v27);
    if (v25) {
      CFRelease(v25);
    }
    uint64_t v28 = *((void *)this + 17);
    if (v28 && *(void *)(v28 + 8) == v11 && (*((_WORD *)this + 44) & 0x200) == 0) {
      (*(void (**)(HTTPNetConnection_WithAuth *, uint64_t))(*(void *)this + 136))(this, v11);
    }
  }
  if (v22) {
    (*(void (**)(const CoreSchedulingSet *))(*(void *)v22 + 48))(v22);
  }
  uint64_t v29 = *((void *)this + 12);
  if (v29) {
    pthread_mutex_unlock((pthread_mutex_t *)(v29 + 8));
  }
  *(_DWORD *)(v11 + 32) &= ~0x40u;
  unsigned int v30 = *((_DWORD *)a2 + 8) & 0xFFFFFFFE;
  *((_DWORD *)a2 + 8) = v30;
  uint64_t v31 = (const void *)*((void *)a2 + 6);
  *((void *)a2 + 6) = 0;
  if (v31)
  {
    CFRelease(v31);
    unsigned int v30 = *((_DWORD *)a2 + 8);
  }
  *((_DWORD *)a2 + 8) = v30 & 0xFFFE1FDF | 0x2000;
  *((void *)a2 + 11) = 0;
  uint64_t v32 = (NetConnection *)*((void *)a2 + 16);
  if ((*(unsigned int (**)(void))(**((void **)this + 34) + 88))(*((void *)this + 34)) == 3) {
    *((unsigned char *)this + 250) = 0;
  }
  if (v32) {
    NetConnection::enqueue(v32, a2, 1);
  }
  return (HTTPNetStreamInfo *)v11;
}

void sub_1841FB408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HTTPNetConnection_WithAuth::getProxyAuth(HTTPNetConnection_WithAuth *this, __CFHTTPMessage *a2)
{
  return *((void *)this + 41);
}

CFIndex HTTPNetConnection_WithAuth::applyCredentialsDictionary(CFHTTPAuthenticationRef *this, __CFHTTPMessage *a2, _CFHTTPAuthentication *a3)
{
  int v5 = CFHTTPAuthenticationRequiresOrderedRequests(this[41]);
  CFHTTPMessageApplyCredentialDictionary(a2, this[41], this[42], &v8);
  if (v5 && !v8.error)
  {
    v8.CFIndex domain = (CFIndex)_CFHTTPAuthenticationApplyHeaderToRequest(this[41], a2, this);
    *(void *)&v8.error = v6;
  }
  return v8.domain;
}

CFDictionaryRef HTTPNetConnection_WithAuth::applyAnyCredentials(CFDictionaryRef this, CFHTTPMessageRef *a2)
{
  uint64_t v3 = (uint64_t)this;
  uint64_t v4 = *((void *)this + 46);
  if (v4 == 407) {
    goto LABEL_10;
  }
  int v5 = (_CFHTTPAuthentication *)*((void *)this + 39);
  if (v5)
  {
    CFHTTPMessageApplyCredentialDictionary(a2[5], v5, *((CFDictionaryRef *)this + 40), &v6);
    this = _CFHTTPAuthenticationApplyHeaderToRequest(*(_CFHTTPAuthentication **)(v3 + 312), a2[5], (const void *)v3);
    uint64_t v4 = *(void *)(v3 + 368);
  }
  if (v4 != 401)
  {
LABEL_10:
    if (*(void *)(v3 + 328))
    {
      this = (CFDictionaryRef)(*(uint64_t (**)(void))(**(void **)(v3 + 272) + 88))(*(void *)(v3 + 272));
      if (this != 3)
      {
        CFHTTPMessageApplyCredentialDictionary(a2[5], *(CFHTTPAuthenticationRef *)(v3 + 328), *(CFDictionaryRef *)(v3 + 336), &v6);
        return _CFHTTPAuthenticationApplyHeaderToRequest(*(_CFHTTPAuthentication **)(v3 + 328), a2[5], (const void *)v3);
      }
    }
  }
  return this;
}

uint64_t HTTPNetConnection_WithAuth::isConnectionWithAuth(HTTPNetConnection_WithAuth *this)
{
  return 1;
}

void HTTPNetConnection_WithAuth::responseStreamCallback(void (**this)(HTTPNetConnection *), void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (this[27]) {
    this[24]((HTTPNetConnection *)this);
  }
  if (HTTPNetConnection::handleReadEventsDuringRequestBodyTransmission((HTTPNetConnection *)this, a2, a4)) {
    return;
  }
  int v8 = *((_DWORD *)a2 + 8);
  if ((v8 & 0x20) == 0) {
    HTTPNetConnection::prepareReception((HTTPNetConnection *)this, (uint64_t)a2, a3);
  }
  if (!*((void *)a2 + 6) && (*((unsigned char *)a2 + 32) & 4) == 0) {
    a2 = (void *)HTTPNetConnection::updateForHeaders((HTTPNetConnection *)this, (uint64_t)a2, a3);
  }
  int v9 = *((_DWORD *)a2 + 8);
  if ((v9 & 0x100) == 0)
  {
    *((_DWORD *)a2 + 8) = v9 | 0x100;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (a3) {
      uint64_t v10 = a3 + 16;
    }
    else {
      uint64_t v10 = 0;
    }
    ++*(void *)(v10 + 80);
    (*(void (**)(void, uint64_t))(**(void **)(v10 + 24) + 32))(*(void *)(v10 + 24), 0x1EC09F7C0);
    --*(void *)(v10 + 80);
    int v9 = *((_DWORD *)a2 + 8);
  }
  if ((v9 & 0x200) == 0)
  {
    *((_DWORD *)a2 + 8) = v9 | 0x200;
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (a3) {
      uint64_t v11 = a3 + 16;
    }
    else {
      uint64_t v11 = 0;
    }
    ++*(void *)(v11 + 80);
    (*(void (**)(void, uint64_t))(**(void **)(v11 + 24) + 32))(*(void *)(v11 + 24), 0x1EC09F440);
    --*(void *)(v11 + 80);
  }
  if (a4 <= 15)
  {
    if (a4 != 2)
    {
      if (a4 == 8)
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        uint64_t v12 = a3 + 16;
        if (!a3) {
          uint64_t v12 = 0;
        }
        *(_OWORD *)CFStringRef v15 = *(_OWORD *)(v12 + 56);
        HTTPNetStreamInfo::grabReadStreamProperties((uint64_t)a2, a3);
        (*(void (**)(void, unsigned __int8 *))(**((void **)a2 + 16) + 64))(*((void *)a2 + 16), v15);
      }
      return;
    }
    if ((v8 & 0x20) == 0) {
      return;
    }
    if ((*((unsigned char *)a2 + 32) & 4) != 0)
    {
      if (a3) {
        BOOL v14 = (CoreStreamBase *)(a3 + 16);
      }
      else {
        BOOL v14 = 0;
      }
      while (1)
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        if (!CoreStreamBase::_streamInterface_CanRead(v14)) {
          break;
        }
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        CoreStreamBase::_streamInterface_Read(v14, v15, 2048);
      }
      return;
    }
    goto LABEL_45;
  }
  if (a4 != 16)
  {
    if (a4 == 32 && (v8 & 0x20) != 0 && *((void *)a2 + 16))
    {
      HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)a2);
    }
    return;
  }
  uint64_t v13 = *((void *)a2 + 16);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 72))(v13);
  }
  if ((*((unsigned char *)a2 + 32) & 4) == 0)
  {
LABEL_45:
    _CFReadStreamSignalEventDelayed();
  }
}

CFDictionaryRef HTTPNetConnection_WithAuth::setConnectionCredsAndAuth(CFDictionaryRef this, const __CFDictionary *a2, CFTypeRef cf)
{
  if (!*((void *)this + 39))
  {
    CFDictionaryRef v3 = this;
    if (!*((void *)this + 40))
    {
      if (cf) {
        CFTypeRef v5 = CFRetain(cf);
      }
      else {
        CFTypeRef v5 = 0;
      }
      *((void *)v3 + 39) = v5;
      if (a2)
      {
        CFAllocatorRef v6 = CFGetAllocator(a2);
        this = CFDictionaryCreateCopy(v6, a2);
      }
      else
      {
        this = 0;
      }
      *((void *)v3 + 40) = this;
    }
  }
  return this;
}

void *HTTPNetConnection_WithAuth::setRemoteCredsAndAuth(void *this, CFTypeRef cf, _CFHTTPAuthentication *a3)
{
  if (cf)
  {
    if (a3)
    {
      uint64_t v4 = (uint64_t)this;
      this[45] = CFRetain(cf);
      this = CFRetain(a3);
      *(void *)(v4 + 352) = this;
    }
  }
  return this;
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::getProxy@<X0>(HTTPNetStreamInfo *this@<X0>, void *a2@<X8>)
{
  return HTTPNetStreamInfo::getProxy((uint64_t)this - 16, a2);
}

uint64_t HTTPNetStreamInfo::getProxy@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 152);
  if (!v2) {
    return (*(uint64_t (**)(void))(**(void **)(this + 128) + 240))();
  }
  uint64_t v3 = *(void *)(this + 160);
  *a2 = v2;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

void non-virtual thunk to'HTTPNetStreamInfo::setProxy(uint64_t a1, uint64_t *a2)
{
}

void HTTPNetStreamInfo::setProxy(void *a1, uint64_t *a2)
{
  if (a1[19] != *a2)
  {
    uint64_t v4 = a1[16];
    if (v4)
    {
      CFTypeRef v5 = (std::__shared_weak_count *)a2[1];
      uint64_t v9 = *a2;
      uint64_t v10 = v5;
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 232))(v4, &v9);
      if (v10) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v10);
      }
    }
    uint64_t v7 = *a2;
    uint64_t v6 = a2[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    int v8 = (std::__shared_weak_count *)a1[20];
    a1[19] = v7;
    a1[20] = v6;
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
  }
}

void sub_1841FBBC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::_conn_no_more_reqests_after_this_one_connectionLost(HTTPNetStreamInfo *this)
{
  uint64_t result = *((void *)this + 14);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 288))();
  }
  return result;
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::copyTrust(HTTPNetStreamInfo *this)
{
  uint64_t result = *((void *)this + 14);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 200))();
  }
  return result;
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::getConnectionIdentifier(HTTPNetStreamInfo *this)
{
  return *((void *)this + 14);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::rawBytesReceived(HTTPNetStreamInfo *this)
{
  return *((void *)this + 12);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::rawBytesSent(HTTPNetStreamInfo *this)
{
  return *((void *)this + 11);
}

void non-virtual thunk to'HTTPNetStreamInfo::setBodyStreamBeforeOpening(HTTPNetStreamInfo *this, __CFReadStream *a2)
{
}

void HTTPNetStreamInfo::setBodyStreamBeforeOpening(HTTPNetStreamInfo *this, CFTypeRef cf)
{
  if (cf)
  {
    *((void *)this + 7) = CFRetain(cf);
    *((unsigned char *)this + 64) = 0;
    *((void *)this + 9) = -1;
  }
  else
  {
    uint64_t v3 = *((void *)this + 5);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (v3) {
      uint64_t v4 = (HTTPMessage *)(v3 + 16);
    }
    else {
      uint64_t v4 = 0;
    }
    HTTPMessage::ensureParserFinished(v4);
    uint64_t v5 = *((void *)v4 + 6);
    if (v5)
    {
      CFDataRef v6 = *(const __CFData **)(v5 + 16);
      if (v6 || (CFDataRef v6 = *(const __CFData **)(v5 + 24)) != 0)
      {
        CFIndex Length = CFDataGetLength(v6);
        *((void *)this + 9) = Length;
        if (Length >= 1)
        {
          CFAllocatorRef v8 = CFGetAllocator(v6);
          BytePtr = CFDataGetBytePtr(v6);
          *((void *)this + 7) = CFReadStreamCreateWithBytesNoCopy(v8, BytePtr, *((void *)this + 9), (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
          *((unsigned char *)this + 64) = 0;
        }
      }
    }
  }
}

void non-virtual thunk to'HTTPNetStreamInfo::updateScheduling(HTTPNetStreamInfo *this, const CoreSchedulingSet *a2)
{
}

void HTTPNetStreamInfo::updateScheduling(HTTPNetStreamInfo *this, const CoreSchedulingSet *a2)
{
  uint64_t v2 = a2;
  if (!CoreSchedulingSet::isEqualTo(*((CoreSchedulingSet **)this + 21), a2))
  {
    uint64_t v4 = *((void *)this + 22);
    if (v4)
    {
      uint64_t v5 = *((void *)this + 21);
      uint64_t v11 = MEMORY[0x1E4F143A8];
      uint64_t v12 = 3221225472;
      uint64_t v13 = ___ZNK17CoreSchedulingSet15unscheduleTimerEP16__CFRunLoopTimer_block_invoke;
      BOOL v14 = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
      uint64_t v15 = v4;
      CoreSchedulingSet::applyBlockWithPossibleEmulation(v5, &v11);
    }
    CoreSchedulingSet::_scheduleStream(*((void *)this + 21), *((void *)this + 1), (void (*)(uint64_t, uint64_t))_CFStreamUnscheduleFromDispatchQueue, MEMORY[0x1E4F1C270]);
    uint64_t v6 = *((void *)this + 21);
    (*(void (**)(const CoreSchedulingSet *))(*(void *)v2 + 40))(v2);
    (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
    *((void *)this + 21) = v2;
    uint64_t v7 = *((void *)this + 22);
    if (v7)
    {
      uint64_t v11 = MEMORY[0x1E4F143A8];
      uint64_t v12 = 3221225472;
      uint64_t v13 = ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
      BOOL v14 = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
      uint64_t v15 = v7;
      CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)v2, &v11);
      uint64_t v2 = (const CoreSchedulingSet *)*((void *)this + 21);
    }
    uint64_t v8 = *((void *)this + 1);
    uint64_t v9 = (void (*)(uint64_t, uint64_t))MEMORY[0x1E4F1C268];
    uint64_t v10 = MEMORY[0x1E4F1C260];
    CoreSchedulingSet::_scheduleStream((uint64_t)v2, v8, v9, v10);
  }
}

void non-virtual thunk to'HTTPNetStreamInfo::closeAndClearHandler(HTTPNetStreamInfo *this)
{
}

void HTTPNetStreamInfo::closeAndClearHandler(HTTPNetStreamInfo *this)
{
  uint64_t v2 = (__CFReadStream *)*((void *)this + 1);
  if (v2)
  {
    CFReadStreamSetClient(v2, 0, 0, 0);
    CFReadStreamClose(*((CFReadStreamRef *)this + 1));
  }
  uint64_t v3 = *((void *)this + 15);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  *((void *)this + 15) = 0;
  uint64_t v4 = (const void *)*((void *)this + 3);
  if (v4)
  {
    _Block_release(v4);
    *((void *)this + 3) = 0;
  }
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::scheduleAndOpenWithHandler(uint64_t a1, uint64_t a2, void *a3)
{
  return HTTPNetStreamInfo::scheduleAndOpenWithHandler(a1 - 16, a2, a3);
}

uint64_t HTTPNetStreamInfo::scheduleAndOpenWithHandler(uint64_t a1, uint64_t a2, void *aBlock)
{
  if (*(void *)(a1 + 24)) {
    __assert_rtn("scheduleAndOpenWithHandler", "HTTPNetStreamInfo.cpp", 925, "_metaClientCallback == NULL");
  }
  *(void *)(a1 + 24) = _Block_copy(aBlock);
  clientContext.version = 0;
  clientContext.info = (void *)a1;
  clientContext.retain = (void *(__cdecl *)(void *))_CFNetworkReadStream_retain;
  clientContext.release = (void (__cdecl *)(void *))_CFNetworkReadStream_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))_CFNetworkReadStream_copyDesc;
  CFReadStreamSetClient(*(CFReadStreamRef *)(a1 + 8), 0x1AuLL, (CFReadStreamClientCallBack)CFNetworkReadStream::_readStreamClientCallBackCallBack, &clientContext);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 208))(a1, a2);
  return CFReadStreamOpen(*(CFReadStreamRef *)(a1 + 8));
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::canScheduleAndOpenWithHandlerAsync(HTTPNetStreamInfo *this)
{
  return 0;
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::setProperty(uint64_t a1, int a2, const void *a3)
{
  uint64_t v4 = *(__CFReadStream **)(a1 - 8);
  CFStringRef v5 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);

  return CFReadStreamSetProperty(v4, v5, a3);
}

CFTypeRef non-virtual thunk to'HTTPNetStreamInfo::copyProperty(uint64_t a1, int a2)
{
  uint64_t v2 = *(__CFReadStream **)(a1 - 8);
  CFStringRef v3 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);

  return CFReadStreamCopyProperty(v2, v3);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::_meta_release(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(void))(*((void *)this - 2) + 168))();
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::_meta_retain(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(void))(*((void *)this - 2) + 160))();
}

void non-virtual thunk to'HTTPNetStreamInfo::~HTTPNetStreamInfo(HTTPNetStreamInfo *this)
{
  HTTPNetStreamInfo::~HTTPNetStreamInfo((HTTPNetStreamInfo *)((char *)this - 16));

  JUMPOUT(0x18531B6D0);
}

{
  HTTPNetStreamInfo::~HTTPNetStreamInfo((HTTPNetStreamInfo *)((char *)this - 16));
}

void HTTPNetStreamInfo::~HTTPNetStreamInfo(HTTPNetStreamInfo *this)
{
  *(void *)this = &unk_1ECF9E760;
  *((void *)this + 2) = &unk_1ECF9E880;
  uint64_t v2 = *((void *)this + 15);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 15) = 0;
  }
  HTTPNetStreamInfo::dequeueFromConnection((NetConnection **)this);
  CFStringRef v3 = (const void *)*((void *)this + 6);
  if (v3) {
    CFRelease(v3);
  }
  HTTPNetStreamInfo::closeAndReleasePayload(this);
  uint64_t v4 = (const void *)*((void *)this + 5);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  if ((*((unsigned char *)this + 32) & 4) != 0)
  {
    uint64_t v6 = (__CFReadStream *)*((void *)this + 1);
    if (v6)
    {
      uint64_t v7 = *((void *)this + 21);
      if (v7) {
        CoreSchedulingSet::_scheduleStream(v7, *((void *)this + 1), (void (*)(uint64_t, uint64_t))_CFStreamUnscheduleFromDispatchQueue, MEMORY[0x1E4F1C270]);
      }
      CFReadStreamSetClient(v6, 0, 0, 0);
    }
  }
  uint64_t v8 = (const void *)*((void *)this + 10);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)*((void *)this + 17);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = (const void *)*((void *)this + 18);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = (const void *)*((void *)this + 7);
  if (v11)
  {
    if (*((unsigned char *)this + 64)
      || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
      || (*(_WORD *)uint64_t v15 = 0,
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "payload was never closed?", v15, 2u), (uint64_t v11 = (const void *)*((void *)this + 7)) != 0))
    {
      CFRelease(v11);
    }
  }
  uint64_t v12 = (__CFRunLoopTimer *)*((void *)this + 22);
  if (v12)
  {
    CFRunLoopTimerInvalidate(v12);
    CFRelease(*((CFTypeRef *)this + 22));
    *((void *)this + 22) = 0;
  }
  uint64_t v13 = *((void *)this + 21);
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 48))(v13);
    *((void *)this + 21) = 0;
  }
  BOOL v14 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + 1) = 0;
}

{
  uint64_t vars8;

  HTTPNetStreamInfo::~HTTPNetStreamInfo(this);

  JUMPOUT(0x18531B6D0);
}

void sub_1841FC3EC(_Unwind_Exception *exception_object)
{
  CFStringRef v3 = (std::__shared_weak_count *)v1[20];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  *uint64_t v1 = &unk_1ECF9B550;
  v1[1] = 0;
  _Unwind_Resume(exception_object);
}

NetConnection **HTTPNetStreamInfo::dequeueFromConnection(NetConnection **this)
{
  uint64_t v1 = this[16];
  if (v1)
  {
    uint64_t v2 = this;
    this[16] = 0;
    CFStringRef v3 = (__CFRunLoopTimer *)*((void *)v1 + 32);
    if (v3)
    {
      CFRunLoopTimerInvalidate(v3);
      uint64_t v4 = (const void *)*((void *)v1 + 32);
      *((void *)v1 + 32) = 0;
      if (v4) {
        CFRelease(v4);
      }
    }
    if (!NetConnection::dequeue(v1, v2))
    {
      uint64_t v5 = 4;
      int v6 = -4;
      (*(void (**)(NetConnection *, uint64_t *))(*(void *)v1 + 64))(v1, &v5);
    }
    return (NetConnection **)(*(uint64_t (**)(NetConnection *))(*(void *)v1 + 48))(v1);
  }
  return this;
}

void HTTPNetStreamInfo::closeAndReleasePayload(HTTPNetStreamInfo *this)
{
  uint64_t v2 = (__CFReadStream *)*((void *)this + 7);
  if (v2)
  {
    CFReadStreamSetClient(v2, 0, 0, 0);
    CFReadStreamClose(*((CFReadStreamRef *)this + 7));
    *((unsigned char *)this + 64) = 1;
  }
  *((void *)this + 9) = -1;
}

uint64_t HTTPNetStreamInfo::_conn_no_more_reqests_after_this_one_connectionLost(HTTPNetStreamInfo *this)
{
  uint64_t result = *((void *)this + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 288))();
  }
  return result;
}

uint64_t HTTPNetStreamInfo::copyTrust(HTTPNetStreamInfo *this)
{
  uint64_t result = *((void *)this + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 200))();
  }
  return result;
}

uint64_t HTTPNetStreamInfo::getConnectionIdentifier(HTTPNetStreamInfo *this)
{
  return *((void *)this + 16);
}

uint64_t HTTPNetStreamInfo::canScheduleAndOpenWithHandlerAsync(HTTPNetStreamInfo *this)
{
  return 0;
}

uint64_t HTTPNetStreamInfo::setProperty(uint64_t a1, int a2, const void *a3)
{
  uint64_t v4 = *(__CFReadStream **)(a1 + 8);
  CFStringRef v5 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);

  return CFReadStreamSetProperty(v4, v5, a3);
}

CFTypeRef HTTPNetStreamInfo::copyProperty(uint64_t a1, int a2)
{
  uint64_t v2 = *(__CFReadStream **)(a1 + 8);
  CFStringRef v3 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);

  return CFReadStreamCopyProperty(v2, v3);
}

uint64_t HTTPNetStreamInfo::_meta_release(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 168))();
}

uint64_t HTTPNetStreamInfo::_meta_retain(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 160))();
}

void HTTPNetStreamInfo::release(CFTypeRef *this)
{
}

CFTypeRef HTTPNetStreamInfo::retain(CFTypeRef *this)
{
  return CFRetain(this[1]);
}

uint64_t HTTPNetStreamInfo::rawBytesReceived(HTTPNetStreamInfo *this)
{
  return *((void *)this + 14);
}

uint64_t HTTPNetStreamInfo::rawBytesSent(HTTPNetStreamInfo *this)
{
  return *((void *)this + 13);
}

__CFString *HTTPNetStreamInfo::copyDebugDesc(CFHTTPMessageRef *this)
{
  CFURLRef v2 = CFHTTPMessageCopyRequestURL(this[5]);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if ((this[4] & 4) != 0) {
    CFStringRef v5 = "Yes";
  }
  else {
    CFStringRef v5 = "No";
  }
  CFStringRef v6 = CFStringCreateWithFormat(v3, 0, @"<HTTP stream context %p>{url = %@, state = %s, conn=%p, isZombie=%s}", this, v2, "", this[16], v5);
  CFStringAppend(Mutable, v6);
  if (v6) {
    CFRelease(v6);
  }
  if (v2) {
    CFRelease(v2);
  }
  return Mutable;
}

void HTTPNetStreamInfo::_readStreamClientCallBack(HTTPNetStreamInfo *this, __CFReadStream *a2, uint64_t a3)
{
  if (!*((void *)this + 3)) {
    return;
  }
  CFStringRef v5 = (const void *)(*(uint64_t (**)(HTTPNetStreamInfo *, uint64_t))(*(void *)this + 192))(this, 34);
  if (a3 == 16)
  {
    (*(void (**)(void, const void *))(*((void *)this + 3) + 16))(*((void *)this + 3), v5);
    goto LABEL_15;
  }
  if (a3 == 8)
  {
    CFReadStreamGetError(*((CFReadStreamRef *)this + 1));
    (*(void (**)(void, const void *))(*((void *)this + 3) + 16))(*((void *)this + 3), v5);
LABEL_15:
    uint64_t v12 = (const void *)*((void *)this + 3);
    if (v12)
    {
      _Block_release(v12);
      *((void *)this + 3) = 0;
      if (!v5) {
        return;
      }
      goto LABEL_20;
    }
LABEL_19:
    if (!v5) {
      return;
    }
    goto LABEL_20;
  }
  if (a3 != 2) {
    goto LABEL_19;
  }
  CFStringRef v6 = (UInt8 *)malloc_type_malloc(0x203A0uLL, 0x33F32B96uLL);
  if (!v6)
  {
    (*(void (**)(void, const void *))(*((void *)this + 3) + 16))(*((void *)this + 3), v5);
    goto LABEL_19;
  }
  uint64_t v7 = v6;
  size_t v8 = CFReadStreamRead(*((CFReadStreamRef *)this + 1), v6, 132000);
  if ((v8 & 0x8000000000000000) != 0)
  {
    CFReadStreamGetError(*((CFReadStreamRef *)this + 1));
    (*(void (**)(void, const void *))(*((void *)this + 3) + 16))(*((void *)this + 3), v5);
    goto LABEL_24;
  }
  size_t v9 = v8;
  if (!v8)
  {
    (*(void (**)(void, const void *))(*((void *)this + 3) + 16))(*((void *)this + 3), v5);
LABEL_24:
    free(v7);
    if (!v5) {
      return;
    }
    goto LABEL_20;
  }
  if (v8 < 0x203A0)
  {
    uint64_t v10 = (UInt8 *)malloc_type_realloc(v7, v8, 0x669B83F0uLL);
    if (v10) {
      uint64_t v7 = v10;
    }
  }
  uint64_t v11 = dispatch_data_create(v7, v9, 0, (dispatch_block_t)*MEMORY[0x1E4F143F0]);
  (*(void (**)(void))(*((void *)this + 3) + 16))();
  dispatch_release(v11);
  if (v5) {
LABEL_20:
  }
    CFRelease(v5);
}

void HTTPNetStreamInfo::_streamImpl_deprecated_Unschedule(HTTPNetStreamInfo *this, __CFReadStream *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  uint64_t v7 = *((void *)this + 21);
  if (v7) {
    *((void *)this + 21) = (*(uint64_t (**)(uint64_t, CFRunLoopRef, CFRunLoopMode))(*(void *)v7 + 64))(v7, rl, mode);
  }
  if (((*((_DWORD *)this + 8) >> 13) & 0xFu) <= 4)
  {
    size_t v8 = (NetConnection *)*((void *)this + 16);
    if (v8)
    {
      NetConnection::unschedule(v8, (uint64_t *)this, rl, mode);
      size_t v9 = (__CFReadStream *)*((void *)this + 7);
      if (v9)
      {
        if (!*((unsigned char *)this + 64)) {
          CFReadStreamUnscheduleFromRunLoop(v9, rl, mode);
        }
      }
    }
  }
  uint64_t v10 = (__CFRunLoopTimer *)*((void *)this + 22);
  if (v10)
  {
    CFRunLoopRemoveTimer(rl, v10, mode);
  }
}

void HTTPNetStreamInfo::_streamImpl_deprecated_Schedule(HTTPNetStreamInfo *this, __CFReadStream *a2, CoreSchedulingSet *a3, const __CFString *cf1)
{
  uint64_t v7 = *((void *)this + 21);
  if (v7) {
    *((void *)this + 21) = (*(uint64_t (**)(uint64_t, CoreSchedulingSet *, const __CFString *))(*(void *)v7 + 56))(v7, a3, cf1);
  }
  if (((*((_DWORD *)this + 8) >> 13) & 0xFu) <= 4)
  {
    uint64_t v8 = *((void *)this + 16);
    if (v8) {
      NetConnection::schedule(v8, (uint64_t *)this, a3, cf1);
    }
  }
  size_t v9 = (__CFReadStream *)*((void *)this + 7);
  if (v9 && !*((unsigned char *)this + 64)) {
    CFReadStreamScheduleWithRunLoop(v9, (CFRunLoopRef)a3, cf1);
  }
  uint64_t v10 = (__CFRunLoopTimer *)*((void *)this + 22);
  if (v10)
  {
    CFRunLoopAddTimer((CFRunLoopRef)a3, v10, cf1);
  }
}

CFStreamStatus HTTPNetStreamInfo::_streamImpl_SetProperty(HTTPNetStreamInfo *this, __CFReadStream *a2, CFStringRef theString, const void *a4)
{
  int ExactString = _findExactString(theString, 0);
  int v8 = ExactString;
  if (ExactString > 119892108)
  {
    if (ExactString > 135580084)
    {
      if (ExactString == 135580085 || ExactString == 401003905) {
        goto LABEL_19;
      }
      int v9 = 408311313;
    }
    else
    {
      if (ExactString == 119892109 || ExactString == 120965283) {
        goto LABEL_19;
      }
      int v9 = 129296697;
    }
LABEL_18:
    if (ExactString == v9) {
      goto LABEL_19;
    }
    goto LABEL_48;
  }
  if (ExactString <= 87361087)
  {
    if (ExactString == 11870276)
    {
      uint64_t v24 = *((void *)this + 5);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      if (v24) {
        uint64_t v25 = (HTTPMessage *)(v24 + 16);
      }
      else {
        uint64_t v25 = 0;
      }
      HTTPMessage::setHeaderFieldStringValue(v25, 0x1191B2ABu, a4);
      return 1;
    }
    int v9 = 83273191;
    goto LABEL_18;
  }
  switch(ExactString)
  {
    case 87361088:
      uint64_t v22 = (const void *)*((void *)this + 18);
      *((void *)this + 18) = 0;
      if (v22) {
        CFRelease(v22);
      }
      if (a4) {
        CFTypeRef v23 = CFRetain(a4);
      }
      else {
        CFTypeRef v23 = 0;
      }
      *((void *)this + 18) = v23;
      unsigned int v11 = *((_DWORD *)this + 8) & 0xFFFFFDFF;
      goto LABEL_54;
    case 90506882:
LABEL_19:
      uint64_t v12 = *((void *)this + 16);
      if (!v12) {
        return 0;
      }
      uint64_t v13 = *(void *)(v12 + 96);
      if (v13)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
        uint64_t v14 = *(void *)(v12 + 96);
        uint64_t v15 = *(void *)(v12 + 152);
        if (v14) {
          pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
        }
        if (!v15) {
          goto LABEL_29;
        }
      }
      else
      {
        uint64_t v15 = *(void *)(v12 + 152);
        if (!v15)
        {
LABEL_29:
          uint64_t v17 = *((void *)this + 16);
          uint64_t v18 = *(void *)(v17 + 96);
          if (v18)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v18 + 8));
            uint64_t v19 = *(void *)(v17 + 96);
            uint64_t v20 = *(void *)(v17 + 144);
            if (v19) {
              pthread_mutex_unlock((pthread_mutex_t *)(v19 + 8));
            }
            if (!v20) {
              return 0;
            }
LABEL_35:
            if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1) {
              goto LABEL_36;
            }
LABEL_74:
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
LABEL_36:
            ++*(void *)(v20 + 96);
            int v21 = (*(uint64_t (**)(void, CFStringRef, const void *))(**(void **)(v20 + 40) + 32))(*(void *)(v20 + 40), theString, a4);
            --*(void *)(v20 + 96);
            return v21 != 0;
          }
          uint64_t v20 = *(void *)(v17 + 144);
          if (v20) {
            goto LABEL_35;
          }
          return 0;
        }
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      ++*(void *)(v15 + 96);
      int v16 = (*(uint64_t (**)(void, CFStringRef, const void *))(**(void **)(v15 + 40) + 32))(*(void *)(v15 + 40), theString, a4);
      --*(void *)(v15 + 96);
      if (!v16) {
        goto LABEL_29;
      }
      return 1;
    case 104064896:
      int v10 = *((_DWORD *)this + 8);
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a4)
      {
        if ((v10 & 0x80) != 0) {
          return 1;
        }
        unsigned int v11 = v10 & 0xFFFFFE7F | 0x80;
      }
      else
      {
        if ((v10 & 0x80) == 0) {
          return 1;
        }
        unsigned int v11 = v10 & 0xFFFFFE7F;
      }
      goto LABEL_54;
  }
LABEL_48:
  CFStreamStatus result = CFReadStreamGetStatus(*((CFReadStreamRef *)this + 1));
  if (result) {
    return 0;
  }
  if (v8 != 216338253 && v8 != 223645657)
  {
    if (v8 != 415626914)
    {
      uint64_t v28 = *((void *)this + 16);
      if (!v28) {
        return 0;
      }
      uint64_t v29 = *(void *)(v28 + 96);
      if (v29)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v29 + 8));
        uint64_t v30 = *(void *)(v28 + 96);
        uint64_t v31 = *(void *)(v28 + 152);
        if (v30) {
          pthread_mutex_unlock((pthread_mutex_t *)(v30 + 8));
        }
      }
      else
      {
        uint64_t v31 = *(void *)(v28 + 152);
      }
      if (!v31) {
        goto LABEL_72;
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      ++*(void *)(v31 + 96);
      int v32 = (*(uint64_t (**)(void, CFStringRef, const void *))(**(void **)(v31 + 40) + 32))(*(void *)(v31 + 40), theString, a4);
      --*(void *)(v31 + 96);
      if (!v32)
      {
LABEL_72:
        uint64_t RequestStream = NetConnection::getRequestStream(*((NetConnection **)this + 16));
        if (RequestStream)
        {
          uint64_t v20 = RequestStream;
          if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1) {
            goto LABEL_36;
          }
          goto LABEL_74;
        }
        return 0;
      }
      return 1;
    }
    int v27 = *((_DWORD *)this + 8);
    if ((const void *)*MEMORY[0x1E4F1CFD0] == a4) {
      unsigned int v11 = v27 | 0x400;
    }
    else {
      unsigned int v11 = v27 & 0xFFFFFBFF;
    }
LABEL_54:
    *((_DWORD *)this + 8) = v11;
    return 1;
  }
  return result;
}

uint64_t NetConnection::getRequestStream(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (!v2) {
    return *((void *)this + 18);
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  uint64_t v3 = *((void *)this + 12);
  uint64_t v4 = *((void *)this + 18);
  if (v3) {
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  }
  return v4;
}

CFNumberRef HTTPNetStreamInfo::_streamImpl_CopyProperty(CFTypeRef *this, __CFReadStream *a2, CFStringRef theString)
{
  int ExactString = _findExactString(theString, 8u);
  if (ExactString == 446019561)
  {
    CFAllocatorRef v7 = CFGetAllocator(this[1]);
    return CFNumberCreate(v7, kCFNumberLongLongType, this + 11);
  }
  else
  {
    if (ExactString == 446986240)
    {
      CFNumberRef result = (CFNumberRef)this[6];
      if (result)
      {
        return (CFNumberRef)CFRetain(result);
      }
      return result;
    }
    CFTypeRef v8 = this[12];
    if (!v8) {
      goto LABEL_16;
    }
    CFDictionaryRef EmptyDict = (const __CFDictionary *)*((void *)v8 + 5);
    if (!EmptyDict)
    {
      CFDictionaryRef EmptyDict = (const __CFDictionary *)*((void *)v8 + 4);
      if (!EmptyDict) {
        CFDictionaryRef EmptyDict = (const __CFDictionary *)AutoDict::getEmptyDict(0);
      }
    }
    CFDictionaryRef Value = CFDictionaryGetValue(EmptyDict, theString);
    if (!Value || (CFNumberRef result = (CFNumberRef)CFRetain(Value)) == 0)
    {
LABEL_16:
      unsigned int v11 = this[16];
      if (!v11) {
        return 0;
      }
      uint64_t v12 = v11[12];
      if (v12)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
        uint64_t v13 = v11[12];
        uint64_t v14 = v11[19];
        if (v13) {
          pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
        }
        if (!v14)
        {
LABEL_26:
          uint64_t v15 = this[16];
          uint64_t v16 = v15[12];
          if (v16)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
            uint64_t v17 = v15[12];
            uint64_t v18 = v15[18];
            if (v17) {
              pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
            }
            if (v18) {
              goto LABEL_30;
            }
          }
          else
          {
            uint64_t v18 = v15[18];
            if (v18)
            {
LABEL_30:
              if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
                dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
              }
              ++*(void *)(v18 + 96);
              CFNumberRef result = (CFNumberRef)(*(uint64_t (**)(void, CFStringRef))(**(void **)(v18 + 40) + 40))(*(void *)(v18 + 40), theString);
              --*(void *)(v18 + 96);
              return result;
            }
          }
          return 0;
        }
      }
      else
      {
        uint64_t v14 = v11[19];
        if (!v14) {
          goto LABEL_26;
        }
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      ++*(void *)(v14 + 96);
      CFNumberRef result = (CFNumberRef)(*(uint64_t (**)(void, CFStringRef))(**(void **)(v14 + 40) + 40))(*(void *)(v14 + 40), theString);
      --*(void *)(v14 + 96);
      if (!result) {
        goto LABEL_26;
      }
    }
  }
  return result;
}

BOOL HTTPNetStreamInfo::_streamImpl_CanRead(HTTPNetStreamInfo *this, __CFReadStream *a2)
{
  if ((*((unsigned char *)this + 32) & 4) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Don't open zombies", v13, 2u);
    }
    return 0;
  }
  uint64_t v3 = (NetConnection *)*((void *)this + 16);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = 1;
  unsigned int State = NetConnection::getState(v3, 1, (uint64_t *)this);
  if (State > 4) {
    return v4;
  }
  if (State != 4) {
    return 0;
  }
  uint64_t v6 = *((void *)this + 16);
  uint64_t v7 = *(void *)(v6 + 96);
  if (v7)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 8));
    uint64_t v8 = *(void *)(v6 + 96);
    uint64_t v9 = *(void *)(v6 + 152);
    if (v8) {
      pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
    }
  }
  else
  {
    uint64_t v9 = *(void *)(v6 + 152);
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  unsigned int v11 = v9 ? (CoreStreamBase *)(v9 + 16) : 0;
  if (!CoreStreamBase::_streamInterface_CanRead(v11)) {
    return 0;
  }
  if (*((void *)this + 6)) {
    return 1;
  }
  uint64_t v12 = (HTTPNetConnection *)(*(uint64_t (**)(void))(**((void **)this + 16) + 80))(*((void *)this + 16));
  return HTTPNetConnection::updateForHeaders(v12, (uint64_t)this, v9) == (void)this;
}

uint64_t HTTPNetStreamInfo::_streamImpl_Read(HTTPNetStreamInfo *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  unsigned int v6 = *((_DWORD *)this + 8);
  if ((v6 & 4) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Don't open zombies", buf, 2u);
    }
    return -1;
  }
  if (!*((void *)this + 6) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v22 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Then he shouldn't be reading.", v22, 2u);
    unsigned int v6 = *((_DWORD *)this + 8);
  }
  int v12 = (v6 >> 13) & 0xF;
  if (v12 == 7) {
    goto LABEL_14;
  }
  if (v12 == 5)
  {
    uint64_t v13 = 0;
    a5->error = 0;
LABEL_32:
    *a6 = 1;
    return v13;
  }
  uint64_t v14 = *((void *)this + 16);
  if (!v14)
  {
LABEL_14:
    CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*((void *)this + 1));
    *a5 = Error;
    if (!Error.error)
    {
      a5->CFIndex domain = 1;
      a5->error = 54;
    }
    return -1;
  }
  uint64_t v15 = *(void *)(v14 + 96);
  if (v15)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
    uint64_t v16 = *(void *)(v14 + 96);
    uint64_t v17 = *(void *)(v14 + 152);
    if (v16) {
      pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
    }
  }
  else
  {
    uint64_t v17 = *(void *)(v14 + 152);
  }
  a5->error = 0;
  *a6 = 0;
  if (!v17)
  {
    a5->CFIndex domain = 4;
    a5->error = -4;
LABEL_22:
    uint64_t v13 = -1;
    goto LABEL_31;
  }
  if (_CFHTTPReadStreamIsAtMark(v17))
  {
    HTTPNetStreamInfo::sendStreamIsComplete(this);
    uint64_t v13 = 0;
LABEL_30:
    *a6 = 1;
    goto LABEL_31;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t v19 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)(v17 + 16), a3, a4);
  uint64_t v13 = v19;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    if ((v13 & 0x8000000000000000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_35;
  }
  if (v19 < 0)
  {
LABEL_35:
    *a5 = *(CFStreamError *)(v17 + 72);
    uint64_t v21 = *((void *)this + 16);
    if (v21) {
      (*(void (**)(uint64_t, CFStreamError *))(*(void *)v21 + 64))(v21, a5);
    }
    goto LABEL_22;
  }
LABEL_27:
  if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v17 + 16)) == 5 || _CFHTTPReadStreamIsAtMark(v17))
  {
    HTTPNetStreamInfo::sendStreamIsComplete(this);
    goto LABEL_30;
  }
LABEL_31:
  if ((*((unsigned char *)this + 32) & 2) != 0) {
    goto LABEL_32;
  }
  return v13;
}

void HTTPNetStreamInfo::sendStreamIsComplete(HTTPNetStreamInfo *this)
{
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2 && (int v3 = *((_DWORD *)this + 8), (v3 & 0x100) != 0))
  {
    *((_DWORD *)this + 8) = v3 & 0xFFFFFEFF;
    uint64_t v4 = (__CFReadStream *)CFRetain(v2);
  }
  else
  {
    uint64_t v4 = 0;
  }
  int v5 = *((_DWORD *)this + 8);
  if ((v5 & 0x200) != 0) {
    *((_DWORD *)this + 8) = v5 & 0xFFFFFDFF;
  }
  unsigned int v6 = (NetConnection *)*((void *)this + 16);
  if (v6) {
    NetConnection::responseIsComplete(v6, this);
  }
  if (v4)
  {
    CFReadStreamSetProperty(v4, (CFStreamPropertyKey)&unk_1EC09F7C0, (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
    CFRelease(v4);
  }
}

uint64_t HTTPNetStreamInfo::_streamImpl_OpenCompleted(HTTPNetStreamInfo *this, __CFReadStream *a2, CFStreamError *a3)
{
  if ((*((unsigned char *)this + 32) & 4) != 0)
  {
    uint64_t result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    *(_WORD *)uint64_t v7 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Don't open zombies", v7, 2u);
    return 0;
  }
  if ((*((unsigned char *)this + 32) & 8) != 0) {
    return 0;
  }
  uint64_t result = *((void *)this + 16);
  if (!result) {
    return result;
  }
  int State = NetConnection::getState((NetConnection *)result, 1, (uint64_t *)this);
  if ((State - 5) >= 2)
  {
    if (State != 7)
    {
      if (State == 4) {
        return *((void *)this + 6) != 0;
      }
      return 0;
    }
    a3->CFIndex domain = 4;
    a3->error = -4;
  }
  return 1;
}

BOOL HTTPNetStreamInfo::_streamImpl_Open(HTTPNetStreamInfo *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  if ((*((unsigned char *)this + 32) & 4) != 0)
  {
    BOOL result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    *(_WORD *)int v10 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Don't open zombies", v10, 2u);
    return 0;
  }
  *a4 = 0;
  a3->error = 0;
  a3->CFIndex domain = 0;
  uint64_t v7 = (NetConnection *)*((void *)this + 16);
  if (!v7 || !NetConnection::enqueue(v7, this, 0))
  {
    BOOL result = 0;
    *a4 = 1;
    a3->CFIndex domain = 4;
    a3->error = -4;
    return result;
  }
  int v8 = (*((_DWORD *)this + 8) >> 13) & 0xF;
  BOOL result = 1;
  if (v8 == 7)
  {
    *a4 = 1;
    a3->CFIndex domain = 4;
    a3->error = -4;
    return 0;
  }
  if (v8 == 5) {
    goto LABEL_8;
  }
  if (v8 != 4) {
    return result;
  }
  if (*((void *)this + 6)) {
LABEL_8:
  }
    *a4 = 1;
  else {
    *a4 = 0;
  }
  return result;
}

void HTTPNetStreamInfo::HTTPNetStreamInfo(HTTPNetStreamInfo *this, __CFReadStream *a2, CFTypeRef cf, HTTPNetConnection *a4)
{
  *(void *)this = &unk_1ECF9E760;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = &unk_1ECF9E880;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 8) &= 0xFFFE1FFF;
  if (cf) {
    CFTypeRef v6 = CFRetain(cf);
  }
  else {
    CFTypeRef v6 = 0;
  }
  *((void *)this + 5) = v6;
  if (a4) {
    (*(void (**)(HTTPNetConnection *))(*(void *)a4 + 40))(a4);
  }
  *((void *)this + 6) = 0;
  *((void *)this + CFRetain((char *)this - 16) = a4;
  *((void *)this + 17) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 20);
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  *((void *)this + 21) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)v7);
}

void sub_1841FD9F4(_Unwind_Exception *exception_object)
{
  int v3 = (std::__shared_weak_count *)v1[20];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  *uint64_t v1 = &unk_1ECF9B550;
  v1[1] = 0;
  _Unwind_Resume(exception_object);
}

void HTTPNetStreamInfo::grabReadStreamProperties(uint64_t a1, uint64_t a2)
{
  int v3 = *(CapturedSSLState **)(a1 + 96);
  if (!v3)
  {
    CFAllocatorRef v5 = CFGetAllocator(*(CFTypeRef *)(a1 + 8));
    int v3 = (CapturedSSLState *)CFAllocatorAllocate(v5, 48, 0);
    *(_OWORD *)int v3 = 0u;
    *((_OWORD *)v3 + 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    CFAllocatorRef v6 = CFGetAllocator(*(CFTypeRef *)(a1 + 8));
    CapturedSSLState::CapturedSSLState(v3, v6);
    *(void *)(a1 + 96) = v3;
  }
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = ___ZN16CapturedSSLState14grabFromStreamEP16__CoreReadStream_block_invoke;
  v7[3] = &__block_descriptor_40_e22__v16__0____CFString__8l;
  v7[4] = a2;
  CapturedSSLState::grabFromStream(v3, (uint64_t)v7);
}

void CapturedSSLState::CapturedSSLState(CapturedSSLState *this, CFTypeRef cf)
{
  *(void *)this = &unk_1ECF9DDA8;
  *((void *)this + 1) = cf;
  *((void *)this + 2) = &unk_1ECFA5A28;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = v3;
}

uint64_t ___ZN16CapturedSSLState14grabFromStreamEP16__CoreReadStream_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (v3) {
    uint64_t v4 = v3 + 16;
  }
  else {
    uint64_t v4 = 0;
  }
  ++*(void *)(v4 + 80);
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 24) + 40))(*(void *)(v4 + 24), a2);
  --*(void *)(v4 + 80);
  return result;
}

void CapturedSSLState::grabFromStream(void *a1, uint64_t a2)
{
  {
    CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[0] = (uint64_t)&unk_1EC0A1238;
    *(void *)algn_1E8F7FCC8 = 0x1EC09FD38;
    qword_1E8F7FCD0 = (uint64_t)&unk_1EC0A11C8;
  }
  for (uint64_t i = 0; i != 3; ++i)
  {
    CFAllocatorRef v5 = (const void *)CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[i];
    CFDictionaryRef EmptyDict = (const __CFDictionary *)a1[5];
    if (!EmptyDict)
    {
      CFDictionaryRef EmptyDict = (const __CFDictionary *)a1[4];
      if (!EmptyDict) {
        CFDictionaryRef EmptyDict = (const __CFDictionary *)AutoDict::getEmptyDict(0);
      }
    }
    if (!CFDictionaryGetValue(EmptyDict, v5))
    {
      uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[i]);
      if (v7)
      {
        int v8 = (const void *)v7;
        uint64_t v9 = (const void *)CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[i];
        MutableDict = AutoDict::getMutableDict((AutoDict *)(a1 + 2));
        CFDictionarySetValue(MutableDict, v9, v8);
        CFRelease(v8);
      }
    }
  }
}

void CapturedSSLState::~CapturedSSLState(CapturedSSLState *this)
{
  *(void *)this = &unk_1ECF9DDA8;
  AutoDict::~AutoDict((CapturedSSLState *)((char *)this + 16));
  CFAllocatorRef v2 = (const __CFAllocator *)*((void *)this + 1);

  CFAllocatorDeallocate(v2, this);
}

{
  *(void *)this = &unk_1ECF9DDA8;
  AutoDict::~AutoDict((CapturedSSLState *)((char *)this + 16));
}

uint64_t ___ZN16CapturedSSLState14grabFromStreamEP17__CoreWriteStream_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  if (v3) {
    uint64_t v4 = v3 + 16;
  }
  else {
    uint64_t v4 = 0;
  }
  ++*(void *)(v4 + 80);
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 24) + 40))(*(void *)(v4 + 24), a2);
  --*(void *)(v4 + 80);
  return result;
}

uint64_t ___ZN17HTTPNetStreamInfo18createZombieDoubleEPK13__CFAllocatorP17HTTPNetConnection_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  CFAllocatorRef v5 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 48), 184, 0);
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  v5[22] = 0;
  *(_OWORD *)CFAllocatorRef v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  uint64_t v6 = *(void *)(a1 + 56);
  *CFAllocatorRef v5 = &unk_1ECF9E760;
  v5[1] = a2;
  v5[2] = &unk_1ECF9E880;
  v5[19] = 0;
  v5[20] = 0;
  *((_DWORD *)v5 + 8) = *(_DWORD *)(v4 + 32) | 4;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  v5[16] = v6;
  v5[11] = *(void *)(v4 + 88);
  CFTypeRef v7 = *(CFTypeRef *)(v4 + 40);
  if (v7) {
    CFTypeRef v7 = CFRetain(v7);
  }
  v5[5] = v7;
  CFTypeRef v8 = *(CFTypeRef *)(v4 + 80);
  if (v8) {
    CFTypeRef v8 = CFRetain(v8);
  }
  v5[10] = v8;
  if (*(void *)(v4 + 56))
  {
    uint64_t v9 = *(void *)(v4 + 40);
    if (v9)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      HTTPMessage::setHeaderFieldScalarValue((HTTPMessage *)(v9 + 16), *(void *)(v9 + 80));
    }
    int v10 = (const void *)v5[16];
    uint64_t v11 = v5[5];
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    uint64_t v12 = v11 + 16;
    if (!v11) {
      uint64_t v12 = 0;
    }
    uint64_t v13 = *(void *)(v12 + 72);
    if (v13 && v10)
    {
      if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
        dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
      }
      CFDictionaryRef v14 = *(const __CFDictionary **)(v13 + 168);
      if (v14)
      {
        CFDictionaryRef Value = CFDictionaryGetValue(v14, v10);
        if (Value) {
          Value[24] = 0;
        }
      }
    }
    clientContext.version = 0;
    clientContext.info = v5;
    clientContext.retain = (void *(__cdecl *)(void *))_CFNetworkReadStream_retain;
    clientContext.release = (void (__cdecl *)(void *))_CFNetworkReadStream_release;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))_CFNetworkReadStream_copyDesc;
    CFReadStreamSetClient(*(CFReadStreamRef *)(v4 + 56), 0x1AuLL, (CFReadStreamClientCallBack)HTTPNetStreamInfo::_httpRequestPayloadCallBack, &clientContext);
  }
  uint64_t v16 = *(void *)(v4 + 168);
  if (!v16)
  {
    v5[21] = 0;
    uint64_t v18 = v5 + 21;
LABEL_28:
    *uint64_t v18 = CoreSchedulingSet::createEmpty(0);
    goto LABEL_29;
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 88))(v16);
  v5[21] = v17;
  uint64_t v18 = v5 + 21;
  if (!v17) {
    goto LABEL_28;
  }
LABEL_29:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void sub_1841FE0DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (std::__shared_weak_count *)v1[20];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  *uint64_t v1 = &unk_1ECF9B550;
  v1[1] = 0;
  _Unwind_Resume(exception_object);
}

__CFReadStream *HTTPNetStreamInfo::_httpRequestPayloadCallBack(__CFReadStream *this, __CFReadStream *a2, void *a3, void *a4)
{
  if (a3)
  {
    uint64_t v6 = this;
    (*(void (**)(void *))(*a3 + 160))(a3);
    if (a2 == (__CFReadStream *)16) {
      goto LABEL_22;
    }
    if (a2 == (__CFReadStream *)8)
    {
      CFStreamError Error = CFReadStreamGetError(v6);
      uint64_t v12 = a3[16];
      if (v12) {
        (*(void (**)(uint64_t, CFStreamError *))(*(void *)v12 + 64))(v12, &Error);
      }
      return (__CFReadStream *)(*(uint64_t (**)(void *))(*a3 + 168))(a3);
    }
    if (a2 == (__CFReadStream *)2)
    {
LABEL_22:
      CFTypeRef v7 = (NetConnection *)a3[16];
      if (v7)
      {
        uint64_t v8 = (*(uint64_t (**)(void))(*(void *)v7 + 80))(a3[16]);
        uint64_t v9 = *((void *)v7 + 12);
        if (v9)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
          uint64_t v10 = *((void *)v7 + 12);
          uint64_t v11 = *((void *)v7 + 18);
          if (v10) {
            pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
          }
          if (!v11) {
            return (__CFReadStream *)(*(uint64_t (**)(void *))(*a3 + 168))(a3);
          }
          goto LABEL_14;
        }
        uint64_t v11 = *((void *)v7 + 18);
        if (v11)
        {
LABEL_14:
          if (HTTPNetConnection::transmitRequest(v8, a3, v11, &Error))
          {
            if (Error.error) {
              (*(void (**)(NetConnection *, CFStreamError *))(*(void *)v7 + 64))(v7, &Error);
            }
            else {
              NetConnection::requestIsComplete(v7, a3);
            }
          }
        }
      }
    }
    return (__CFReadStream *)(*(uint64_t (**)(void *))(*a3 + 168))(a3);
  }
  return this;
}

void HTTPNetStreamInfo::closeRequestResources(HTTPNetStreamInfo *this)
{
  uint64_t v2 = *((void *)this + 16);
  if (!v2) {
    goto LABEL_16;
  }
  uint64_t v3 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 80))(v2);
  uint64_t v4 = *((void *)this + 5);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t v5 = v4 + 16;
  if (!v4) {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(void *)(v5 + 72);
  if (v6)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
    }
    if (HTTPAuthentication::isKerberosThePreferredAuthScheme(*(const __CFDictionary **)(v6 + 152))) {
      goto LABEL_16;
    }
    uint64_t v7 = *((void *)this + 5);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
  }
  else
  {
    uint64_t v7 = *((void *)this + 5);
  }
  uint64_t v8 = v7 + 16;
  if (!v7) {
    uint64_t v8 = 0;
  }
  if (!_CFHTTPAuthenticationIsFirstNTLMTransaction(*(_CFHTTPAuthentication **)(v8 + 72), v3))
  {
LABEL_16:
    uint64_t v9 = (__CFReadStream *)*((void *)this + 7);
    if (v9 && !*((unsigned char *)this + 64))
    {
      CFReadStreamSetClient(v9, 0, 0, 0);
      CFReadStreamClose(*((CFReadStreamRef *)this + 7));
      *((unsigned char *)this + 64) = 1;
    }
    *((void *)this + 9) = -1;
    uint64_t v10 = (const void *)*((void *)this + 10);
    if (v10)
    {
      CFRelease(v10);
      *((void *)this + 10) = 0;
    }
  }
}

void HTTPNetStreamInfo::_stallTimerFired(HTTPNetStreamInfo *this, __CFRunLoopTimer *a2, void *a3)
{
  uint64_t v4 = *((void *)a2 + 16);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(v4 + 96);
  if (!v5)
  {
    uint64_t v7 = *(void *)(v4 + 152);
    if (!v7) {
      goto LABEL_12;
    }
    goto LABEL_8;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
  uint64_t v6 = *(void *)(v4 + 96);
  uint64_t v7 = *(void *)(v4 + 152);
  if (v6) {
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  }
  if (v7)
  {
LABEL_8:
    int valuePtr = 3;
    CFNumberRef v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    if (v8)
    {
      CFNumberRef v9 = v8;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      ++*(void *)(v7 + 96);
      (*(void (**)(void))(**(void **)(v7 + 40) + 32))(*(void *)(v7 + 40));
      --*(void *)(v7 + 96);
      CFRelease(v9);
    }
  }
LABEL_12:
  uint64_t v10 = (const void *)*((void *)a2 + 22);
  *((void *)a2 + 22) = 0;
  if (v10) {
    CFRelease(v10);
  }
}

uint64_t HTTPFilter::expectedSizeFromHeaders(HTTPFilter *this, __CFHTTPMessage *a2)
{
  if (CFHTTPMessageIsRequest(this))
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    uint64_t v3 = (char *)this + 16;
    uint64_t v4 = *((unsigned char *)this + 40) ? 0 : (char *)this + 16;
    CFStringRef v5 = (const __CFString *)*((void *)v4 + 19);
    if (v5
      || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
      && (*(_WORD *)uint64_t v24 = 0,
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", v24, 2u), (CFStringRef v5 = (const __CFString *)*((void *)v4 + 19)) != 0))
    {
      if (CFEqual(v5, (CFStringRef)&gConstantCFStringValueTable[2604])) {
        return 0;
      }
    }
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*((unsigned char *)this + 40)) {
      uint64_t v3 = 0;
    }
    CFStringRef v6 = (const __CFString *)*((void *)v3 + 19);
    if (v6
      || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
      && (*(_WORD *)buf = 0,
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (CFStringRef v6 = (const __CFString *)*((void *)v3 + 19)) != 0))
    {
      if (CFEqual(v6, (CFStringRef)&gConstantCFStringValueTable[2611])) {
        return 0;
      }
    }
  }
  int IsRequest = CFHTTPMessageIsRequest(this);
  int ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(this);
  int v9 = ResponseStatusCode;
  if (!IsRequest && ResponseStatusCode == 304) {
    return 0;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (this) {
    uint64_t v11 = (HTTPFilter *)((char *)this + 16);
  }
  else {
    uint64_t v11 = 0;
  }
  CFStringRef v12 = HTTPMessage::copyHeaderFieldValue(v11, 0x11F1D2DBu);
  if (!v12) {
    goto LABEL_46;
  }
  CFStringRef v13 = v12;
  CFIndex Length = CFStringGetLength(v12);
  if (Length < 1)
  {
    CFIndex v16 = 0;
    BOOL v15 = 1;
  }
  else
  {
    BOOL v15 = 0;
    CFIndex v16 = 0;
    while (1)
    {
      int CharacterAtIndex = CFStringGetCharacterAtIndex(v13, v16);
      if (CharacterAtIndex != 32 && CharacterAtIndex != 9) {
        break;
      }
      BOOL v15 = ++v16 >= Length;
      if (Length == v16)
      {
        uint64_t v10 = 0;
        char v18 = v16 >= Length;
        goto LABEL_43;
      }
    }
  }
  char v18 = v15;
  if (v16 >= Length)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    while (1)
    {
      unsigned int v19 = CFStringGetCharacterAtIndex(v13, v16);
      if (v19 - 48 > 9) {
        break;
      }
      ++v16;
      uint64_t v20 = 10 * v10 + v19;
      if (v16 < Length && v20 >= 0xCCCCCCCCCCCCCF3)
      {
        CFRelease(v13);
        goto LABEL_46;
      }
      uint64_t v10 = v20 - 48;
      char v18 = 1;
      if (Length == v16)
      {
        CFRelease(v13);
        return v10;
      }
    }
  }
LABEL_43:
  CFRelease(v13);
  if (!v18)
  {
LABEL_46:
    if (IsRequest) {
      BOOL v21 = 0;
    }
    else {
      BOOL v21 = v9 == 204;
    }
    uint64_t v22 = !v21;
    return v22 << 63 >> 63;
  }
  return v10;
}

void HTTP3Stream::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 288);
  *(void *)(a1 + 280) = v3;
  *(void *)(a1 + 288) = v2;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

BOOL ___ZN11HTTP3Stream9_receivedEN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamError_block_invoke(uint64_t a1, int a2, int a3, void *__src, size_t a5)
{
  uint64_t v6 = *(void *)(a1 + 40);
  unsigned int v9 = *(unsigned __int8 *)(v6 + 176);
  CFNumberRef v8 = (unint64_t *)(v6 + 176);
  uint64_t v7 = v9;
  unint64_t v10 = 8 - v9;
  if (v10 >= a5) {
    size_t v11 = a5;
  }
  else {
    size_t v11 = v10;
  }
  memcpy((char *)v8 + v7 - 8, __src, v11);
  unsigned __int8 v12 = *(unsigned char *)v8 + v11;
  *(unsigned char *)CFNumberRef v8 = v12;
  unint64_t v15 = v12;
  CFIndex v16 = v8 - 1;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = QUICUtilities::quic_vle_decode((QUICUtilities *)&v16, (const unsigned __int8 **)&v15, v8 - 1, v8, v13);
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void HTTP3Stream::_100ContinueReceived(HTTP3Stream *this)
{
  if (*((_DWORD *)this + 28) == 1)
  {
    *((_DWORD *)this + 28) = 2;
    HTTP3Stream::_resumeRequestBody(this);
    (*(void (**)(void, void, void))(**((void **)this + 12) + 40))(*((void *)this + 12), *((void *)this + 39), 0);
  }
  uint64_t v2 = *((void *)this + 17);
  if (v2)
  {
    dispatch_source_cancel(v2);
    uint64_t v3 = (void *)*((void *)this + 17);
    *((void *)this + 17) = 0;
  }
}

void HTTP3Stream::_resumeRequestBody(HTTP3Stream *this)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v6, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
  uint64_t v2 = *((void *)this + 12);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3321888768;
  v4[2] = ___ZN11HTTP3Stream18_resumeRequestBodyEv_block_invoke;
  v4[3] = &__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
  v4[4] = v6;
  CFStringRef v5 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v2 + 16))(v2, v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
}

void sub_1841FEBB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(v15 - 24);
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN11HTTP3Stream18_resumeRequestBodyEv_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8 = *(void *)(a1 + 32);
  unsigned int v9 = a2;
  if (*(_DWORD *)(v8 + 112) == 4) {
    goto LABEL_39;
  }
  if (a5) {
    unint64_t v10 = (void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v8 + 96) + 32))(*(void *)(v8 + 96), 0x1EC09F718);
  }
  else {
    unint64_t v10 = 0;
  }
  if (v10) {
    a5 = 0;
  }
  if (v9 && (size_t size = dispatch_data_get_size(v9)) != 0)
  {
    size_t v12 = size;
    -[__CFN_TransactionMetrics requestBody:](*(void *)(v8 + 344), v9);
    ++*(void *)(v8 + 144);
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v22, *(void *)(v8 + 8), *(std::__shared_weak_count **)(v8 + 16));
    uint64_t v13 = *(void *)(v8 + 24);
    uint64_t v31 = (void (*)(void *))MEMORY[0x1E4F143A8];
    uint64_t v32 = 3321888768;
    uint64_t v33 = ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke;
    CFStreamError v34 = &__block_descriptor_57_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e16_v32__0Q8___qi_16l;
    uint64_t v35 = v22;
    uint64_t v36 = (std::__shared_weak_count *)v23;
    if (v23) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
    }
    size_t v37 = v12;
    char v38 = a5;
    HTTP3Framer::writeFrame(v13, 0, v9, a5, &v31);
    if (*(_DWORD *)(v8 + 112) == 2 && *(void *)(v8 + 144) >= 4uLL)
    {
      *(_DWORD *)(v8 + 112) = 3;
      (*(void (**)(void))(**(void **)(v8 + 96) + 24))(*(void *)(v8 + 96));
    }
    if (v36) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v36);
    }
    if (v23) {
      std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v23);
    }
  }
  else if (a5)
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v31, *(void *)(v8 + 8), *(std::__shared_weak_count **)(v8 + 16));
    uint64_t v14 = *(void *)(v8 + 24);
    uint64_t v22 = MEMORY[0x1E4F143A8];
    uint64_t v23 = 3321888768;
    uint64_t v24 = (uint64_t)___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_33;
    uint64_t v25 = (__n128 (*)(void *, uint64_t))&__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e13_v24__0___qi_8l;
    uint64_t v26 = v31;
    int v27 = (std::__shared_weak_count *)v32;
    if (v32) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v15 = &v22;
    nw_content_context_set_is_final(*(nw_content_context_t *)(v14 + 56), 1);
    (*(void (**)(void, void, void, void, uint64_t *))(**(void **)(v14 + 16) + 32))(*(void *)(v14 + 16), *(void *)(v14 + 56), 0, 0, v15);

    if (v27) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v27);
    }
    if (v32) {
      std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v32);
    }
    goto LABEL_36;
  }
  if (v10)
  {
    uint64_t v22 = 0;
    uint64_t v23 = (uint64_t)&v22;
    uint64_t v24 = 0x6012000000;
    uint64_t v25 = __Block_byref_object_copy__6403;
    uint64_t v26 = __Block_byref_object_dispose__6404;
    int v27 = (std::__shared_weak_count *)&unk_18441BEED;
    HTTP3Fields::HTTP3Fields((HTTP3Fields *)v28);
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_39;
    v21[3] = &unk_1E5254838;
    v21[4] = &v22;
    [v10 enumerateKeysAndObjectsUsingBlock:v21];
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v19, *(void *)(v8 + 8), *(std::__shared_weak_count **)(v8 + 16));
    CFIndex v16 = (std::__shared_weak_count *)(v23 + 48);
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 3321888768;
    v17[2] = ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_2;
    v17[3] = &__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e16_v32__0Q8___qi_16l;
    v17[4] = v19;
    char v18 = v20;
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    HTTP3Stream::_sendHEADERS((void *)v8, v16, 1, v17);
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v18);
    }
    if (v20) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v20);
    }
    _Block_object_dispose(&v22, 8);
    if (__p)
    {
      uint64_t v30 = __p;
      operator delete(__p);
    }
    if (v28[0])
    {
      v28[1] = v28[0];
      operator delete(v28[0]);
    }
  }
LABEL_36:
  if (a4)
  {
    HTTP3Stream::_cleanupStream(v8, 258, 0);
    *(void *)(v8 + 264) = a3;
    *(void *)(v8 + 272) = a4;
    HTTP3Stream::_protocolCallback((HTTP3Stream *)v8);
  }

LABEL_39:
}

void sub_1841FF014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33)
{
  size_t v37 = *(std::__shared_weak_count **)(v35 - 88);
  if (v37) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v37);
  }
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a24);
  }

  _Unwind_Resume(a1);
}

uint64_t ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke(uint64_t a1, uint64_t a2, CFStreamError a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t result = HTTP3Stream::_handleSendError((HTTP3Stream *)v4, a3, *(unsigned __int8 *)(a1 + 56));
  if (!result)
  {
    unint64_t v7 = *(void *)(v4 + 144) - 1;
    *(void *)(v4 + 144) = v7;
    uint64_t v8 = *(void *)(v4 + 344);
    if (v8) {
      *(void *)(v8 + 112) += v5 + a2;
    }
    if (*(_DWORD *)(v4 + 112) == 3 && v7 <= 2)
    {
      *(_DWORD *)(v4 + 112) = 2;
      return HTTP3Stream::_resumeRequestBody((HTTP3Stream *)v4);
    }
  }
  return result;
}

uint64_t ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_33(uint64_t a1, CFStreamError a2)
{
  return HTTP3Stream::_handleSendError(*(HTTP3Stream **)(a1 + 32), a2, 1);
}

__n128 __Block_byref_object_copy__6403(void *a1, uint64_t a2)
{
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  *((_OWORD *)a1 + 3) = *(_OWORD *)(a2 + 48);
  a1[8] = *(void *)(a2 + 64);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  __n128 result = *(__n128 *)(a2 + 72);
  *(__n128 *)(a1 + 9) = result;
  a1[11] = *(void *)(a2 + 88);
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  return result;
}

void __Block_byref_object_dispose__6404(void *a1)
{
  uint64_t v2 = (void *)a1[9];
  if (v2)
  {
    a1[10] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }
}

void ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_39(uint64_t a1, NSString *a2, NSString *a3)
{
}

uint64_t ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_2(uint64_t a1, int a2, CFStreamError a3)
{
  return HTTP3Stream::_handleSendError(*(HTTP3Stream **)(a1 + 32), a3, 1);
}

void HTTP3Fields::~HTTP3Fields(HTTP3Fields *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v3;
    operator delete(v3);
  }
}

uint64_t __Block_byref_object_copy__18(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
}

void __destroy_helper_block_ea8_96c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 104);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_ea8_96c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 104);
  *(void *)(result + 96) = *(void *)(a2 + 96);
  *(void *)(result + 104) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_pointer<CoreSchedulingSet *,Deleter_release<CoreSchedulingSet>,std::allocator<CoreSchedulingSet>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void ___ZN11HTTP3Stream22_start100ContinueTimerEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(HTTP3Stream **)(a1 + 32);
      if (v5) {
        HTTP3Stream::_100ContinueReceived(v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1841FF3CC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c36_ZTSNSt3__18weak_ptrI11HTTP3StreamEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_32c36_ZTSNSt3__18weak_ptrI11HTTP3StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_emplace<RequestBodyData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<RequestBodyData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA68E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<RequestBodyData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA68E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<RequestBodyStream>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA69C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<RequestBodyStream>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA69C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_pointer<__CFReadStream *,Deleter_CFRelease,std::allocator<__CFReadStream>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<MetaConnectionCacheClient *,Deleter_meta_release<MetaConnectionCacheClient>,std::allocator<MetaConnectionCacheClient>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void non-virtual thunk to'TubeManager::~TubeManager(TubeManager *this)
{
  uint64_t v2 = (char *)this - 24;
  TubeManager::~TubeManager((TubeManager *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  TubeManager::~TubeManager((TubeManager *)((char *)this - 24));
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,MetaConnectionCache *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0330;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,MetaConnectionCache *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0330;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,__CFString const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA03D0;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,__CFString const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA03D0;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

CFMutableArrayRef __Block_byref_object_copy__6477(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v4 = CFGetAllocator(*(CFTypeRef *)(a2 + 48));
  CFMutableArrayRef result = CFArrayCreateMutableCopy(v4, 0, *(CFArrayRef *)(a2 + 48));
  *(void *)(a1 + 48) = result;
  return result;
}

void __Block_byref_object_dispose__6478(uint64_t a1)
{
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_37(uint64_t a1, const void *a2)
{
  uint64_t v4 = (*(uint64_t (**)(const void *))(*(void *)a2 + 64))(a2);
  uint64_t v5 = 40;
  if (v4 == *(void *)(a1 + 48)) {
    uint64_t v5 = 32;
  }
  uint64_t v6 = *(__CFArray **)(*(void *)(*(void *)(a1 + v5) + 8) + 48);

  CFArrayAppendValue(v6, a2);
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_2(uint64_t a1, BaseAwaitingTube *a2)
{
}

uint64_t ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80))(a2);
  if (v4) {
    uint64_t v5 = (void *)(v4 - 176);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 136);
  if (v6) {
    (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v6 + 280))(v6, v5[10], 3, 0);
  }
  (*(void (**)(void *, uint64_t, uint64_t, void))(*v5 + 280))(v5, 4, 4294965096, 0);
  unint64_t v7 = *(uint64_t (**)(uint64_t, void))(*(void *)a2 + 56);

  return v7(a2, 0);
}

__n128 __Block_byref_object_copy__41(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

void TubeManager::_onqueue_rdar53306264_logWaiters(CFArrayRef *this)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFArrayGetCount(this[17]);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134217984;
    CFIndex v23 = Count;
    _os_log_error_impl(&dword_184085000, v2, OS_LOG_TYPE_ERROR, "[rdar53306264-LW-S] %ld", buf, 0xCu);
  }
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(this[17], i);
      uint64_t v5 = ValueAtIndex;
      if (ValueAtIndex)
      {
        uint64_t v6 = (*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 72))(ValueAtIndex);
        uint64_t v7 = (*(uint64_t (**)(const void *))(*(void *)v5 + 80))(v5);
        uint64_t v8 = v7;
        if (v7)
        {
          uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
          (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v8 + 72))(&v20, v8);
        }
        else
        {
          uint64_t v9 = 0;
          uint64_t v20 = 0;
          BOOL v21 = 0;
        }
        size_t v12 = (Tube *)(*(uint64_t (**)(const void *))(*(void *)v5 + 64))(v5);
        unint64_t v10 = v12;
        if (v12) {
          uint64_t v11 = Tube::copyWaiter(v12);
        }
        else {
          uint64_t v11 = 0;
        }
      }
      else
      {
        unint64_t v10 = 0;
        uint64_t v9 = 0;
        uint64_t v6 = 0;
        uint64_t v8 = 0;
        uint64_t v11 = 0;
        uint64_t v20 = 0;
        BOOL v21 = 0;
      }
      v16[0] = MEMORY[0x1E4F143A8];
      v16[1] = 3221225472;
      uint64_t v17 = ___ZN11TubeManager32_onqueue_rdar53306264_logWaitersEv_block_invoke;
      char v18 = &__block_descriptor_40_e5_v8__0l;
      uint64_t v19 = v11;
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v13 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134219778;
        CFIndex v23 = i;
        __int16 v24 = 2048;
        uint64_t v25 = v5;
        __int16 v26 = 2048;
        uint64_t v27 = v6;
        __int16 v28 = 2048;
        uint64_t v29 = v8;
        __int16 v30 = 2048;
        uint64_t v31 = v9;
        __int16 v32 = 2114;
        uint64_t v33 = v20;
        __int16 v34 = 2048;
        uint64_t v35 = v10;
        __int16 v36 = 2048;
        uint64_t v37 = v11;
        _os_log_error_impl(&dword_184085000, v13, OS_LOG_TYPE_ERROR, "[rdar53306264-LW] W(%ld/%p) K(%p) C(%p) C.K(%p) C.T(%{public}@) T(%p) T.FW(%p)", buf, 0x52u);
      }
      v17((uint64_t)v16);
      if (v21) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v21);
      }
    }
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v14 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134217984;
    CFIndex v23 = Count;
    _os_log_error_impl(&dword_184085000, v14, OS_LOG_TYPE_ERROR, "[rdar53306264-LW-F] %ld", buf, 0xCu);
  }
}

void sub_1841FFDE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<TubeManager *,TubeManager::_onqueue_createNewTube(HTTPConnectionCacheKey *)::$_0,std::allocator<TubeManager>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t ___ZN11TubeManager32_onqueue_rdar53306264_logWaitersEv_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

void std::__shared_ptr_emplace<HTTP3ConnectionCache>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6AA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTP3ConnectionCache>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6AA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void HTTP3ConnectionCacheWrapper::enableCellTimer(HTTP3ConnectionCache **this)
{
}

void HTTP3ConnectionCacheWrapper::markReusedAfterAPSleepWake(HTTP3ConnectionCacheWrapper *this)
{
}

void HTTP3ConnectionCacheWrapper::purgeIdleConnections(CFDictionaryRef **this)
{
}

void HTTP3ConnectionCacheWrapper::logConnectionsAtAPSleep(HTTP3ConnectionCacheWrapper *this)
{
}

CFStringRef HTTP3ConnectionCacheWrapper::copyDebugDesc(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat(this[1], 0, @"HTTP3ConnectionCacheWrapper<@%p> for HTTP3ConnectionCache<@%p>", this, this[4]);
}

void ___ZN11TubeManager24invalidateAllConnectionsEb_block_invoke_2(int a1, Tube *this)
{
  *((unsigned char *)this + 2CFRetain((char *)this - 16) = 0;
  Tube::_onqueue_cancel(this);
}

void non-virtual thunk to'HTTPReadFilter::~HTTPReadFilter(HTTPReadFilter *this)
{
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 128));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 120));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 120));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 8));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 8));
}

void HTTPReadFilter::~HTTPReadFilter(HTTPReadFilter *this)
{
  *(void *)this = &unk_1ECF9CAD8;
  *((void *)this + 1) = &unk_1ECF9CB78;
  *((void *)this + 15) = &unk_1ECF9CB98;
  *((void *)this + CFRetain((char *)this - 16) = &unk_1ECF9CC50;
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  CFAllocatorRef v3 = (__CFReadStream *)*((void *)this + 26);
  if (!v3)
  {
    *((void *)this + 26) = 0;
    goto LABEL_7;
  }
  if (*((unsigned char *)this + 216))
  {
    *((void *)this + 26) = 0;
  }
  else
  {
    CFReadStreamSetClient(v3, 0, 0, 0);
    CFReadStreamClose(*((CFReadStreamRef *)this + 26));
    CFAllocatorRef v3 = (__CFReadStream *)*((void *)this + 26);
    *((void *)this + 26) = 0;
    if (!v3) {
      goto LABEL_7;
    }
  }
  CFRelease(v3);
LABEL_7:
  uint64_t v4 = (const void *)*((void *)this + 28);
  *((void *)this + 28) = 0;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 32);
  *((void *)this + 32) = 0;
  if (v5) {
    CFRelease(v5);
  }
  pthread_mutex_unlock(v2);
  *((void *)this + CFRetain((char *)this - 16) = &unk_1ECF9C6A8;
  pthread_mutex_destroy(v2);
  *(void *)this = &unk_1ECF9F028;
  *((void *)this + 1) = &unk_1ECF9F090;
  *((void *)this + 15) = &unk_1ECF9F0B0;

  CoreStreamBase::~CoreStreamBase(this);
}

void sub_1842001B0(_Unwind_Exception *a1)
{
  *((void *)v1 + CFRetain((char *)this - 16) = &unk_1ECF9C6A8;
  pthread_mutex_destroy(v2);
  CoreReadStreamBase::~CoreReadStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_deprecated_Unschedule(HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPReadFilter::_streamImpl_deprecated_Unschedule((HTTPReadFilter *)((char *)this - 120), a2, a3);
}

uint64_t HTTPReadFilter::_streamImpl_deprecated_Unschedule(HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v7 = (__CFReadStream *)*((void *)this + 26);
  if (v7 && !*((unsigned char *)this + 216)) {
    CFReadStreamUnscheduleFromRunLoop(v7, a2, a3);
  }

  return pthread_mutex_unlock(v6);
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_deprecated_Schedule(HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPReadFilter::_streamImpl_deprecated_Schedule((HTTPReadFilter *)((char *)this - 120), a2, a3);
}

uint64_t HTTPReadFilter::_streamImpl_deprecated_Schedule(HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v7 = (__CFReadStream *)*((void *)this + 26);
  if (v7 && !*((unsigned char *)this + 216)) {
    CFReadStreamScheduleWithRunLoop(v7, a2, a3);
  }

  return pthread_mutex_unlock(v6);
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_CanRead(HTTPReadFilter *this)
{
  return HTTPReadFilter::_streamImpl_CanRead((HTTPReadFilter *)((char *)this - 120));
}

uint64_t HTTPReadFilter::_streamImpl_CanRead(HTTPReadFilter *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  CFAllocatorRef v3 = (const void *)*((void *)this + 26);
  if (v3 && !*((unsigned char *)this + 216))
  {
    CFTypeRef cf = CFRetain(v3);
    char v7 = 0;
    uint64_t NoSignal = HTTPReadFilter::canReadNoSignal((uint64_t)this, (uint64_t)&cf, (uint64_t)&v8);
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    uint64_t NoSignal = 0;
    v8.CFIndex domain = 4;
    v8.error = -4;
    *((_WORD *)this + 116) |= 0x4000u;
  }
  pthread_mutex_unlock(v2);
  if (*((void *)this + 33))
  {
    (*(void (**)(void))(**((void **)this + 25) + 224))(*((void *)this + 25));
    *((void *)this + 33) = 0;
  }
  if (v8.error)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    CoreStreamBase::_signalEvent(this, 8, v8, 1);
  }
  return NoSignal;
}

void sub_184200408(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPReadFilter::canReadNoSignal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = MEMORY[0x1F4188790](a1, a2, a3);
  uint64_t result = 0;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(v4 + 8) = 0;
  int v8 = *(unsigned __int16 *)(v6 + 232);
  unsigned int v9 = v8 | (*(unsigned __int8 *)(v6 + 234) << 16);
  if ((v8 & 1) == 0)
  {
    int v10 = v5;
    uint64_t v11 = (CFStreamError *)v4;
    size_t v12 = (CFReadStreamRef *)v3;
    uint64_t v13 = *(void *)(v6 + 240);
    if (v13 != -2)
    {
LABEL_6:
      if ((v9 & 0x20) != 0 && (v13 != -3 ? (BOOL v14 = v13 == *(void *)(v6 + 248)) : (BOOL v14 = 1), v14))
      {
        if ((v9 & 0x100) != 0) {
          return 1;
        }
        uint64_t result = HTTPReadFilter::readChunkedHeader(v6, (uint64_t)v12, 0, __dst, 4096, v11);
        if (!result) {
          return result;
        }
        uint64_t v13 = *(void *)(v6 + 240);
        if (v13 == -3) {
          return 0;
        }
        unsigned int v9 = *(unsigned __int16 *)(v6 + 232) | (*(unsigned __int8 *)(v6 + 234) << 16);
        int v15 = (v9 >> 8) & 1;
      }
      else
      {
        LOBYTE(v15) = 0;
      }
      if ((v15 & 1) == 0 && v13 == *(void *)(v6 + 248))
      {
        if ((v9 & 0x200) != 0)
        {
          uint64_t result = 0;
          *(unsigned char *)(v6 + 234) = BYTE2(v9);
          *(_WORD *)(v6 + 232) = v9 | 1;
          return result;
        }
        return 1;
      }
      CFDataRef v16 = *(const __CFData **)(v6 + 256);
      if (v16 && CFDataGetLength(v16)) {
        return 1;
      }
      if (v10) {
        return CFReadStreamHasBytesAvailable(*v12) != 0;
      }
      return 0;
    }
    uint64_t result = HTTPReadFilter::readHeaderBytes(v6, v3, 0, __dst, 4096, v4);
    if (result)
    {
      uint64_t result = CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(v6 + 224));
      if (result)
      {
        unsigned int v9 = *(unsigned __int16 *)(v6 + 232) | (*(unsigned __int8 *)(v6 + 234) << 16);
        uint64_t v13 = *(void *)(v6 + 240);
        goto LABEL_6;
      }
    }
  }
  return result;
}

uint64_t HTTPReadFilter::readHeaderBytes(uint64_t a1, uint64_t a2, int a3, UInt8 *a4, CFIndex a5, uint64_t a6)
{
  CFStringRef v12 = (const __CFString *)&unk_1EC0A5720;
  p_vtable = AVAssetDownloadURLSession.vtable;
  while (2)
  {
    CFDataRef v14 = *(const __CFData **)(a1 + 256);
    if (!v14)
    {
      uint64_t v19 = (__CFHTTPMessage *)CFReadStreamCopyProperty(*(CFReadStreamRef *)a2, v12);
      if (!v19) {
        goto LABEL_18;
      }
      uint64_t v20 = v19;
      CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v19);
      if (p_vtable[503] != (void *)-1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      if (*((void *)v20 + 13))
      {
        CFRelease(v20);
        goto LABEL_18;
      }
      if (ResponseStatusCode == 200)
      {
        CFRelease(v20);
        int v22 = *(_WORD *)(a1 + 232) & 0xEFFF | (*(unsigned __int8 *)(a1 + 234) << 16);
        *(_WORD *)(a1 + 232) &= ~0x1000u;
        *(unsigned char *)(a1 + 234) = BYTE2(v22);
        goto LABEL_18;
      }
      CFIndex v23 = *(const void **)(a1 + 224);
      if (v23) {
        CFRelease(v23);
      }
      *(void *)(a1 + 224) = v20;
      int v24 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
      if (ResponseStatusCode == 407)
      {
        *(unsigned char *)(a1 + 234) = BYTE2(v24);
        *(_WORD *)(a1 + 232) = v24 | 8;
        goto LABEL_18;
      }
      uint64_t result = 0;
      *(unsigned char *)(a1 + 234) = BYTE2(v24);
      *(_WORD *)(a1 + 232) = v24 | 0x10;
      *(void *)a6 = 4;
      *(_DWORD *)(a6 + 8) = -2096;
      return result;
    }
    CFIndex Length = CFDataGetLength(v14);
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 256));
    int appended = CFHTTPMessageAppendBytes(*(CFHTTPMessageRef *)(a1 + 224), BytePtr, Length);
    uint64_t v18 = *(const void **)(a1 + 256);
    if (v18) {
      CFRelease(v18);
    }
    *(void *)(a1 + 256) = 0;
    if (!appended)
    {
LABEL_81:
      uint64_t result = 0;
      *(void *)a6 = 4;
      *(_DWORD *)(a6 + 8) = -1;
      __int16 v54 = *(_WORD *)(a1 + 232);
      uint64_t v53 = (_WORD *)(a1 + 232);
      __int16 v55 = v54 | 0x800;
LABEL_95:
      *uint64_t v53 = v55;
      return result;
    }
LABEL_18:
    while (!CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(a1 + 224))
         && (a3 || CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2)))
    {
      *(unsigned char *)(a2 + 8) = 1;
      CFIndex v25 = CFReadStreamRead(*(CFReadStreamRef *)a2, a4, a5);
      if (v25)
      {
        if (v25 < 0) {
          break;
        }
        *(void *)(a1 + 264) += v25;
        if (!CFHTTPMessageAppendBytes(*(CFHTTPMessageRef *)(a1 + 224), a4, v25)) {
          goto LABEL_81;
        }
      }
      else
      {
        uint64_t v26 = *(void *)(a1 + 224);
        if (v26)
        {
          if (p_vtable[503] != (void *)-1) {
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
          }
          if (*(unsigned char *)(v26 + 40)) {
            v26 += 16;
          }
          else {
            uint64_t v26 = 0;
          }
        }
        HTTPMessage::ensureParserFinished((HTTPMessage *)v26);
        if (*(void *)(v26 + 40)
          && (__int16 v28 = *(const __CFData ***)(v26 + 48)) != 0
          && HTTPBodyData::getLength(v28, v27))
        {
          if (!*(void *)(v26 + 288)) {
            goto LABEL_43;
          }
        }
        else
        {
          if (*(void *)(v26 + 88)) {
            goto LABEL_94;
          }
          if (!*(void *)(v26 + 288))
          {
            if (!*(unsigned char *)(v26 + 160))
            {
              int v29 = *(_DWORD *)(v26 + 128);
              if (v29 == -1 || v29 == 200) {
                goto LABEL_94;
              }
            }
LABEL_43:
            if (!*(unsigned char *)(v26 + 160)
              && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v26 + 80))(v26, "", 0))
            {
              break;
            }
          }
        }
      }
    }
    if (CFReadStreamGetStatus(*(CFReadStreamRef *)a2) == kCFStreamStatusError)
    {
      CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
      *(CFStreamError *)a6 = Error;
      if (Error.domain != 1 || Error.error != 54 && Error.error != 32) {
        return 0;
      }
      uint64_t v57 = *(void *)(a1 + 224);
      if (p_vtable[503] != (void *)-1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      uint64_t v58 = v57 ? (HTTPMessage *)(v57 + 16) : 0;
      HTTPMessage::ensureParserFinished(v58);
      if (*((void *)v58 + 5))
      {
        uint64_t v60 = (const __CFData **)*((void *)v58 + 6);
        if (v60)
        {
          if (HTTPBodyData::getLength(v60, v59)) {
            return 0;
          }
        }
      }
      goto LABEL_94;
    }
    if (!CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(a1 + 224))) {
      return 1;
    }
    uint64_t v31 = *(void *)(a1 + 224);
    if (v31)
    {
      if (p_vtable[503] != (void *)-1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      uint64_t v32 = v31 + 16;
      if (!*(unsigned char *)(v31 + 40)) {
        uint64_t v32 = 0;
      }
    }
    else
    {
      uint64_t v32 = 0;
    }
    if (*(void *)(v32 + 288) || *(unsigned char *)(v32 + 160) || (int v51 = *(_DWORD *)(v32 + 128), v51 != -1) && v51 != 200)
    {
      *(_WORD *)(a1 + 232) |= 0x1000u;
    }
    else if ((*(_WORD *)(a1 + 232) & 0x1000) != 0)
    {
LABEL_94:
      uint64_t result = 0;
      *(void *)a6 = 4;
      *(_DWORD *)(a6 + 8) = -4;
      __int16 v61 = *(_WORD *)(a1 + 232);
      uint64_t v53 = (_WORD *)(a1 + 232);
      __int16 v55 = v61 | 0x4000;
      goto LABEL_95;
    }
    uint64_t v33 = *(const void **)(a1 + 256);
    *(void *)(a1 + 256) = 0;
    if (v33) {
      CFRelease(v33);
    }
    uint64_t v34 = *(void *)(a1 + 224);
    if (p_vtable[503] != (void *)-1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (v34) {
      uint64_t v35 = (HTTPMessage *)(v34 + 16);
    }
    else {
      uint64_t v35 = 0;
    }
    HTTPMessage::ensureParserFinished(v35);
    uint64_t v37 = (HTTPBodyData *)*((void *)v35 + 6);
    *((void *)v35 + 6) = 0;
    if (v37)
    {
      BOOL v38 = HTTPBodyData::captureData(v37, v36);
      CFStringRef v87 = v12;
      uint64_t v39 = p_vtable;
      uint64_t v40 = a6;
      uint64_t v42 = v41;
      (*(void (**)(HTTPBodyData *))(*(void *)v37 + 8))(v37);
      int v43 = *(_WORD *)(a1 + 232) & 0xFFFD | (*(unsigned __int8 *)(a1 + 234) << 16);
      *(_WORD *)(a1 + 232) = *(_WORD *)(a1 + 232) & 0xFFFD | (2 * v38);
      *(unsigned char *)(a1 + 234) = BYTE2(v43);
      *(void *)(a1 + 256) = v42;
      a6 = v40;
      p_vtable = v39;
      CFStringRef v12 = v87;
    }
    CFIndex v44 = CFHTTPMessageGetResponseStatusCode(*(CFHTTPMessageRef *)(a1 + 224));
    CFIndex v45 = v44;
    if (v44 != 101)
    {
      if ((unint64_t)(v44 - 100) > 0x63)
      {
        int v63 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
        BOOL v62 = v44 == 304;
        goto LABEL_97;
      }
LABEL_71:
      CFAllocatorRef v47 = CFGetAllocator(*(CFTypeRef *)(a1 + 224));
      CFHTTPMessageRef Empty = CFHTTPMessageCreateEmpty(v47, 0);
      uint64_t v49 = *(const void **)(a1 + 224);
      *(void *)(a1 + 224) = 0;
      if (v49) {
        CFRelease(v49);
      }
      *(void *)(a1 + 224) = Empty;
      if (v45 == 100)
      {
        unsigned int v50 = (*(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16)) & 0xFFFEFFFF;
        *(_WORD *)(a1 + 232) = *(_WORD *)(a1 + 232);
        *(unsigned char *)(a1 + 234) = BYTE2(v50);
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        v88.CFIndex domain = 0;
        *(void *)&v88.error = 0;
        CoreStreamBase::_signalEvent((CoreStreamBase *)a1, 64, v88, 1);
      }
      continue;
    }
    break;
  }
  int v46 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
  if ((v46 & 0x20000) == 0) {
    goto LABEL_71;
  }
  BOOL v62 = 0;
  int v63 = v46 | 0x2000;
  *(unsigned char *)(a1 + 234) = BYTE2(v46);
  *(_WORD *)(a1 + 232) = v46 | 0x2000;
LABEL_97:
  if (v62 || (v63 & 0x2000) != 0)
  {
    unsigned int v75 = v63 & 0xFFFFDFFF;
    *(_WORD *)(a1 + 232) = v75;
    *(unsigned char *)(a1 + 234) = BYTE2(v75);
    goto LABEL_137;
  }
  uint64_t v64 = *(void *)(a1 + 224);
  if (p_vtable[503] != (void *)-1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (v64) {
    CFStringRef v65 = (HTTPMessage *)(v64 + 16);
  }
  else {
    CFStringRef v65 = 0;
  }
  CFStringRef v66 = HTTPMessage::copyHeaderFieldValue(v65, 0x148233EDu);
  if (v66)
  {
    CFStringRef v68 = v66;
    CFAllocatorRef v69 = CFGetAllocator(v66);
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v69, v68, @",");
    CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
    if (Count >= 1)
    {
      CFIndex v72 = Count;
      CFIndex v73 = 0;
      while (1)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v73);
        v89.length = CFStringGetLength(ValueAtIndex);
        v89.location = 0;
        if (CFStringFindWithOptions(ValueAtIndex, (CFStringRef)&unk_1EC0A2E00, v89, 1uLL, 0)) {
          break;
        }
        if (v72 == ++v73) {
          goto LABEL_124;
        }
      }
      if (v72 == 1)
      {
        uint64_t v76 = CFRetain(&unk_1EC0A2F50);
      }
      else
      {
        CFAllocatorRef v77 = CFGetAllocator(v68);
        MutableCFHTTPMessageRef Copy = CFArrayCreateMutableCopy(v77, v72, ArrayBySeparatingStrings);
        CFArrayRemoveValueAtIndex(MutableCopy, v73);
        CFAllocatorRef v79 = CFGetAllocator(v68);
        uint64_t v76 = CFStringCreateByCombiningStrings(v79, ArrayBySeparatingStrings, @",");
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
      }
      uint64_t v80 = *(void *)(a1 + 224);
      if (p_vtable[503] != (void *)-1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      if (v80) {
        v81 = (HTTPMessage *)(v80 + 16);
      }
      else {
        v81 = 0;
      }
      HTTPMessage::setHeaderFieldStringValue(v81, 0x148233EDu, v76);
      if (v76) {
        CFRelease(v76);
      }
      *(_WORD *)(a1 + 232) |= 0x20u;
    }
LABEL_124:
    if (ArrayBySeparatingStrings) {
      CFRelease(ArrayBySeparatingStrings);
    }
    CFRelease(v68);
  }
  int v82 = *(unsigned __int16 *)(a1 + 232);
  int v83 = v82 | (*(unsigned __int8 *)(a1 + 234) << 16);
  if ((v82 & 0x20) != 0)
  {
    *(unsigned char *)(a1 + 234) = BYTE2(v83);
    *(_WORD *)(a1 + 232) = v83 | 4;
    goto LABEL_137;
  }
  uint64_t v84 = HTTPFilter::expectedSizeFromHeaders(*(HTTPFilter **)(a1 + 224), v67);
  *(void *)(a1 + 240) = v84;
  if (v84 == -1)
  {
    if (CFReadStreamGetStatus(*(CFReadStreamRef *)a2) != kCFStreamStatusAtEnd
      || (CFDataRef v85 = *(const __CFData **)(a1 + 256)) != 0 && CFDataGetLength(v85))
    {
      uint64_t v84 = *(void *)(a1 + 240);
      goto LABEL_133;
    }
LABEL_137:
    *(void *)(a1 + 240) = 0;
  }
  else
  {
LABEL_133:
    if (v84 > 0x4000)
    {
      int v86 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
      if ((*(_WORD *)(a1 + 232) & 0x8040) == 0x8000)
      {
        *(unsigned char *)(a1 + 234) = BYTE2(v86);
        *(_WORD *)(a1 + 232) = v86 | 0x40;
        CFReadStreamSetProperty(*(CFReadStreamRef *)a2, (CFStreamPropertyKey)&unk_1EC09F7C0, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
      }
    }
  }
  return 1;
}

uint64_t HTTPReadFilter::readChunkedHeader(uint64_t a1, uint64_t a2, int a3, unsigned char *__dst, CFIndex bufferLength, CFStreamError *a6)
{
  CFDataRef v12 = *(const __CFData **)(a1 + 256);
  if (!v12)
  {
    BytePtr = 0;
    CFIndex Length = 0;
LABEL_10:
    int v17 = 0;
    char v18 = 1;
    char v39 = 1;
LABEL_11:
    uint64_t v16 = 1;
    goto LABEL_15;
  }
  CFIndex Length = CFDataGetLength(v12);
  if (!Length)
  {
    BytePtr = 0;
    goto LABEL_10;
  }
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 256));
  if (!BytePtr)
  {
    char v39 = 0;
    int v17 = 0;
    char v18 = 1;
    goto LABEL_11;
  }
  CFIndex range = 0;
  if (HTTPReadFilter::setFilterForChunkedHeaderBytes((HTTPReadFilter *)a1, BytePtr, Length, &range, a6))
  {
    v15.location = range;
    uint64_t v16 = range != -1;
    if ((unint64_t)(range - 1) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v15.length = Length - range;
      HTTPReadFilter::setDataForRange((HTTPReadFilter *)a1, v15);
    }
    int v17 = 1;
  }
  else
  {
    int v17 = 0;
    uint64_t v16 = 1;
  }
  char v18 = 0;
  char v39 = 0;
LABEL_15:
  if (v17 | a3)
  {
    if (v17)
    {
LABEL_41:
      int v24 = 1;
      goto LABEL_44;
    }
  }
  else if (!CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2) {
         && CFReadStreamGetStatus(*(CFReadStreamRef *)a2) != kCFStreamStatusError)
  }
  {
    *(void *)(a1 + 240) = -3;
    goto LABEL_31;
  }
  unsigned int v38 = v16;
  CFIndex v19 = bufferLength - Length;
  if (bufferLength <= Length) {
    goto LABEL_43;
  }
  if (v18)
  {
    CFIndex v20 = 0;
    CFIndex v19 = bufferLength;
  }
  else
  {
    memmove(__dst, BytePtr, Length);
    CFIndex v20 = Length;
  }
  *(unsigned char *)(a2 + 8) = 1;
  CFIndex v21 = CFReadStreamRead(*(CFReadStreamRef *)a2, &__dst[v20], v19);
  if (v21 < 0)
  {
    uint64_t v16 = 0;
    *a6 = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
    goto LABEL_41;
  }
  CFIndex v22 = v21;
  if (!v21)
  {
    if (v20 == 2 && *__dst == 13 && __dst[1] == 10)
    {
      __int16 v25 = *(_WORD *)(a1 + 232);
      *(void *)(a1 + 240) = 0;
      *(void *)(a1 + 248) = 0;
      *(_WORD *)(a1 + 232) = v25 | 0x100;
      goto LABEL_31;
    }
    uint64_t v16 = 0;
    a6->CFIndex domain = 4;
    a6->error = -1;
    *(_WORD *)(a1 + 232) |= 0x800u;
    goto LABEL_41;
  }
  *(void *)(a1 + 264) += v21;
  CFIndex range = 0;
  CFIndex v23 = v21 + Length;
  if (HTTPReadFilter::setFilterForChunkedHeaderBytes((HTTPReadFilter *)a1, __dst, v21 + Length, &range, a6))
  {
    if (range != -1)
    {
      HTTPReadFilter::setDataForBytes((HTTPReadFilter *)a1, &__dst[range], v23 - range);
LABEL_31:
      int v24 = 1;
      uint64_t v16 = 1;
      goto LABEL_44;
    }
    uint64_t v16 = 0;
    goto LABEL_41;
  }
  if ((v39 & 1) == 0 && (*(_WORD *)(a1 + 232) & 2) != 0) {
    CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 256), &__dst[Length], v22);
  }
  else {
    HTTPReadFilter::setDataForBytes((HTTPReadFilter *)a1, __dst, v22 + Length);
  }
LABEL_43:
  int v24 = 0;
  uint64_t v16 = v38;
LABEL_44:
  uint64_t v26 = *(const void **)(a1 + 256);
  if (v26)
  {
    if ((*(_WORD *)(a1 + 232) & 2) != 0) {
      goto LABEL_50;
    }
    CFAllocatorRef v27 = CFGetAllocator(v26);
    MutableCFHTTPMessageRef Copy = CFDataCreateMutableCopy(v27, 0, *(CFDataRef *)(a1 + 256));
    int v29 = *(const void **)(a1 + 256);
    if (v29) {
      CFRelease(v29);
    }
  }
  else
  {
    CFAllocatorRef v30 = CFGetAllocator(*(CFTypeRef *)(a1 + 224));
    MutableCFHTTPMessageRef Copy = CFDataCreateMutable(v30, 0);
  }
  __int16 v31 = *(_WORD *)(a1 + 232);
  *(void *)(a1 + 256) = MutableCopy;
  *(_WORD *)(a1 + 232) = v31 | 2;
LABEL_50:
  if (!v24)
  {
    if (a3) {
      goto LABEL_55;
    }
LABEL_53:
    if (CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2)
      || CFReadStreamGetStatus(*(CFReadStreamRef *)a2) == kCFStreamStatusError)
    {
      while (1)
      {
LABEL_55:
        CFIndex v33 = CFDataGetLength(*(CFDataRef *)(a1 + 256));
        CFDataSetLength(*(CFMutableDataRef *)(a1 + 256), v33 + bufferLength);
        MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 256));
        *(unsigned char *)(a2 + 8) = 1;
        CFIndex v35 = CFReadStreamRead(*(CFReadStreamRef *)a2, &MutableBytePtr[v33], bufferLength);
        if (v35 < 0)
        {
          uint64_t v16 = 0;
          *a6 = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
          return v16;
        }
        if (!v35)
        {
          uint64_t v16 = 0;
          a6->CFIndex domain = 4;
          a6->error = -1;
          *(_WORD *)(a1 + 232) |= 0x800u;
          return v16;
        }
        CFIndex range = 0;
        CFIndex v36 = v35 + v33;
        if (HTTPReadFilter::setFilterForChunkedHeaderBytes((HTTPReadFilter *)a1, MutableBytePtr, v35 + v33, &range, a6))break; {
        CFDataSetLength(*(CFMutableDataRef *)(a1 + 256), v36);
        }
        if (!a3) {
          goto LABEL_53;
        }
      }
      CFIndex v37 = range;
      uint64_t v16 = range != -1;
      if ((unint64_t)(range - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v41.location = 0;
        v41.length = range;
        CFDataDeleteBytes(*(CFMutableDataRef *)(a1 + 256), v41);
        CFDataSetLength(*(CFMutableDataRef *)(a1 + 256), v36 - v37);
      }
    }
    else
    {
      *(void *)(a1 + 240) = -3;
      return 1;
    }
  }
  return v16;
}

uint64_t HTTPReadFilter::setFilterForChunkedHeaderBytes(HTTPReadFilter *this, const unsigned __int8 *a2, uint64_t a3, uint64_t *a4, CFStreamError *a5)
{
  if ((*((_WORD *)this + 116) & 4) != 0)
  {
    uint64_t v8 = parseChunkedHeader(a2, a3, 1, a4);
    if (v8 == -3) {
      return 0;
    }
    int v9 = *((_WORD *)this + 116) & 0xFFFB | (*((unsigned __int8 *)this + 234) << 16);
    *((_WORD *)this + 116) &= ~4u;
    *((unsigned char *)this + 234) = BYTE2(v9);
  }
  else
  {
    uint64_t v8 = parseChunkedHeader(a2, a3, 0, a4);
  }
  if (v8 == -3) {
    return 0;
  }
  if (v8 == -1)
  {
    *a4 = -1;
    a5->CFIndex domain = 4;
    a5->error = -1;
    __int16 v10 = 2048;
LABEL_11:
    *((_WORD *)this + 116) |= v10;
    return 1;
  }
  a5->error = 0;
  *((void *)this + 30) = v8;
  *((void *)this + 31) = 0;
  if (!v8)
  {
    __int16 v10 = 256;
    goto LABEL_11;
  }
  return 1;
}

void HTTPReadFilter::setDataForRange(HTTPReadFilter *this, CFRange a2)
{
  if (a2.length <= 0)
  {
    uint64_t v11 = (const void *)*((void *)this + 32);
    if (v11) {
      CFRelease(v11);
    }
    *((void *)this + 32) = 0;
  }
  else
  {
    CFIndex length = a2.length;
    CFIndex location = a2.location;
    if ((*((_WORD *)this + 116) & 2) != 0)
    {
      if (a2.location >= 1)
      {
        v14.CFIndex location = 0;
        v14.CFIndex length = location;
        CFDataDeleteBytes(*((CFMutableDataRef *)this + 32), v14);
      }
      CFDataRef v12 = (__CFData *)*((void *)this + 32);
      CFDataSetLength(v12, length);
    }
    else
    {
      CFAllocatorRef v5 = CFGetAllocator(*((CFTypeRef *)this + 32));
      Mutable = CFDataCreateMutable(v5, 0);
      BytePtr = CFDataGetBytePtr(*((CFDataRef *)this + 32));
      CFDataAppendBytes(Mutable, &BytePtr[location], length);
      uint64_t v8 = (const void *)*((void *)this + 32);
      if (v8) {
        CFRelease(v8);
      }
      __int16 v10 = *((_WORD *)this + 116);
      int v9 = (char *)this + 232;
      *((void *)v9 + 3) = Mutable;
      *(_WORD *)int v9 = v10 | 2;
    }
  }
}

void HTTPReadFilter::setDataForBytes(HTTPReadFilter *this, const unsigned __int8 *a2, CFIndex a3)
{
  uint64_t v6 = (const void *)*((void *)this + 32);
  if (v6) {
    CFRelease(v6);
  }
  if (a3)
  {
    CFAllocatorRef v7 = CFGetAllocator(*((CFTypeRef *)this + 28));
    Mutable = CFDataCreateMutable(v7, 0);
    *((void *)this + 32) = Mutable;
    CFDataAppendBytes(Mutable, a2, a3);
    *((_WORD *)this + 116) |= 2u;
  }
  else
  {
    *((void *)this + 32) = 0;
  }
}

uint64_t parseChunkedHeader(const unsigned __int8 *a1, uint64_t a2, int a3, uint64_t *a4)
{
  uint64_t v4 = &a1[a2];
  CFIndex i = a1;
  if (!a3)
  {
    CFIndex i = a1;
    if (a2)
    {
      uint64_t v10 = a2;
      for (CFIndex i = a1; ; ++i)
      {
        unsigned int v11 = *i;
        BOOL v12 = v11 > 0x20;
        uint64_t v13 = (1 << v11) & 0x100002600;
        if (v12 || v13 == 0) {
          break;
        }
        if (!--v10) {
          return -3;
        }
      }
    }
    if (i == v4) {
      return -3;
    }
  }
  if (i >= v4)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    CFAllocatorRef v7 = (const unsigned __int8 *)(&a1[a2] - i);
    do
    {
      int v8 = *i;
      if ((v8 - 48) >= 0xA)
      {
        if ((v8 - 65) >= 6)
        {
          int v9 = -87;
          if ((v8 - 97) > 5) {
            goto LABEL_20;
          }
        }
        else
        {
          int v9 = -55;
        }
      }
      else
      {
        int v9 = -48;
      }
      uint64_t v6 = (v9 + v8) + 16 * v6;
      ++i;
      --v7;
    }
    while (v7);
    CFIndex i = &a1[a2];
  }
LABEL_20:
  if (i < v4)
  {
    CFRange v15 = (const unsigned __int8 *)(&a1[a2] - i);
    while (1)
    {
      int v16 = *i;
      if (v16 != 32 && v16 != 9) {
        break;
      }
      ++i;
      if (!--v15)
      {
        CFIndex i = &a1[a2];
        break;
      }
    }
  }
  if (i == v4) {
    return -3;
  }
  int v18 = *i;
  if (v18 == 59)
  {
    CFIndex v19 = &a1[a2];
    CFIndex v20 = &a1[a2 - 1];
    while (1)
    {
      CFIndex v21 = i + 1;
      if (i + 1 < v4)
      {
        int64_t v22 = v20 - i;
        while (1)
        {
          int v23 = *v21;
          if (v23 != 32 && v23 != 9) {
            break;
          }
          ++v21;
          if (!--v22)
          {
            CFIndex v21 = v19;
            break;
          }
        }
      }
      if (v21 == v4) {
        return -3;
      }
      int v18 = *v21;
      if (v18 == 10 || v18 == 13)
      {
        CFIndex i = v21;
        goto LABEL_119;
      }
      if (v21 < v4)
      {
        int64_t v26 = v19 - v21;
        while (1)
        {
          unsigned int v27 = *v21;
          unsigned int v28 = v27 - 32;
          if (v27 < 0x20 || v27 == 127) {
            break;
          }
          BOOL v12 = v28 > 0x3D;
          uint64_t v29 = (1 << v28) & 0x38000001FC009305;
          BOOL v30 = v12 || v29 == 0;
          if (!v30 || v27 == 123 || v27 == 125) {
            break;
          }
          ++v21;
          if (!--v26)
          {
            CFIndex v21 = v19;
            break;
          }
        }
      }
      if (v21 < v4)
      {
        int64_t v31 = v19 - v21;
        while (1)
        {
          int v32 = *v21;
          if (v32 != 32 && v32 != 9) {
            break;
          }
          ++v21;
          if (!--v31)
          {
            CFIndex v21 = v19;
            break;
          }
        }
      }
      if (v21 == v4) {
        return -3;
      }
      int v18 = *v21;
      if (v18 == 61)
      {
        if (v21 < v4)
        {
          int64_t v34 = v19 - v21;
          while (1)
          {
            int v35 = *v21;
            if (v35 != 32 && v35 != 9) {
              break;
            }
            ++v21;
            if (!--v34)
            {
              CFIndex v21 = v19;
              break;
            }
          }
        }
        if (v21 == v4) {
          return -3;
        }
        if (*v21 == 34)
        {
          for (CFIndex i = v21 + 1; i < v4; ++i)
          {
            int v37 = v21[1];
            if (v37 == 92)
            {
              CFIndex i = v21 + 2;
            }
            else if (v37 == 34)
            {
              CFIndex i = v21 + 2;
              break;
            }
            CFIndex v21 = i;
          }
        }
        else if (v21 >= v4)
        {
          CFIndex i = v21;
        }
        else
        {
          int64_t v38 = v19 - v21;
          CFIndex i = v21;
          while (1)
          {
            unsigned int v39 = *i;
            unsigned int v40 = v39 - 32;
            if (v39 < 0x20 || v39 == 127) {
              break;
            }
            BOOL v12 = v40 > 0x3D;
            uint64_t v41 = (1 << v40) & 0x38000001FC009305;
            BOOL v42 = v12 || v41 == 0;
            if (!v42 || v39 == 123 || v39 == 125) {
              break;
            }
            ++i;
            if (!--v38)
            {
              CFIndex i = v19;
              break;
            }
          }
        }
        if (i < v4)
        {
          int64_t v43 = v19 - i;
          while (1)
          {
            int v44 = *i;
            if (v44 != 32 && v44 != 9) {
              break;
            }
            ++i;
            if (!--v43)
            {
              CFIndex i = v19;
              break;
            }
          }
        }
        if (i == v4) {
          return -3;
        }
        int v18 = *i;
      }
      else
      {
        CFIndex i = v21;
      }
      if (v18 != 59) {
        goto LABEL_119;
      }
    }
  }
  if (v18 != 13) {
    return -1;
  }
LABEL_119:
  if (i + 1 == v4) {
    return -3;
  }
  if (i[1] != 10) {
    return -1;
  }
  *a4 = i - a1 + 2;
  if (v6 < 0) {
    return -1;
  }
  else {
    return v6;
  }
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_Read(HTTPReadFilter *this, unsigned __int8 *a2, CFIndex a3, CFStreamError *a4, unsigned __int8 *a5)
{
  return HTTPReadFilter::_streamImpl_Read((HTTPReadFilter *)((char *)this - 120), a2, a3, a4, a5);
}

uint64_t HTTPReadFilter::_streamImpl_Read(HTTPReadFilter *this, unsigned __int8 *a2, CFIndex a3, CFStreamError *a4, unsigned __int8 *a5)
{
  uint64_t v10 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  __int16 v11 = *((_WORD *)this + 116);
  if ((v11 & 0x800) != 0)
  {
    a4->CFIndex domain = 4;
    SInt32 v14 = -1;
LABEL_12:
    a4->error = v14;
    *a5 = 1;
    pthread_mutex_unlock(v10);
    return -1;
  }
  if ((*((_WORD *)this + 116) & 0x4000) != 0)
  {
    a4->CFIndex domain = 4;
    SInt32 v14 = -4;
    goto LABEL_12;
  }
  if (v11)
  {
    a4->CFIndex domain = 4;
    SInt32 v14 = -2095;
    goto LABEL_12;
  }
  BOOL v12 = (const void *)*((void *)this + 26);
  if (v12 && !*((unsigned char *)this + 216))
  {
    CFTypeRef cf = CFRetain(v12);
    char v20 = 0;
    if (*((void *)this + 30) == -2
      && !HTTPReadFilter::readHeaderBytes((uint64_t)this, (uint64_t)&cf, 1, a2, a3, (uint64_t)a4))
    {
      char v17 = 1;
      *a5 = 1;
      pthread_mutex_unlock(v10);
      uint64_t v13 = 0;
LABEL_34:
      if (cf) {
        CFRelease(cf);
      }
      if ((v17 & 1) == 0) {
        goto LABEL_7;
      }
      return -1;
    }
    if ((*((_WORD *)this + 116) & 0x20) != 0) {
      uint64_t v16 = HTTPReadFilter::doChunkedRead((uint64_t)this, (uint64_t)&cf, (char *)a2, a3, a4, a5);
    }
    else {
      uint64_t v16 = HTTPReadFilter::doPlainRead((uint64_t)this, (uint64_t)&cf, a2, a3, a4, a5);
    }
    uint64_t v13 = v16;
    if (*a5)
    {
      if (!a4->error && (*((_WORD *)this + 116) & 0x200) != 0)
      {
        *a5 = 0;
        *((_WORD *)this + 116) |= 0x401u;
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        v22.CFIndex domain = 0;
        *(void *)&v22.error = 0;
        CoreStreamBase::_signalEvent(this, 32, v22, 1);
        HTTPReadFilter::clearLargeDownloadFlag((uint64_t)this);
        goto LABEL_33;
      }
      v18.CFIndex domain = 0;
      *(void *)&v18.error = 0;
    }
    else
    {
      v18.CFIndex domain = 0;
      *(void *)&v18.error = 0;
      if (v16 >= 1 && HTTPReadFilter::canReadNoSignal((uint64_t)this, (uint64_t)&cf, (uint64_t)&v18))
      {
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        v21.CFIndex domain = 0;
        *(void *)&v21.error = 0;
        CoreStreamBase::_signalEvent(this, 2, v21, 1);
      }
    }
    if (v18.error)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      CoreStreamBase::_signalEvent(this, 8, v18, 1);
    }
LABEL_33:
    char v17 = 0;
    goto LABEL_34;
  }
  a4->CFIndex domain = 4;
  a4->error = -4;
  *((_WORD *)this + 116) |= 0x4000u;
  *a5 = 1;
  uint64_t v13 = -1;
LABEL_7:
  pthread_mutex_unlock(v10);
  if (*((void *)this + 33))
  {
    (*(void (**)(void))(**((void **)this + 25) + 224))(*((void *)this + 25));
    *((void *)this + 33) = 0;
  }
  return v13;
}

void sub_184201B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPReadFilter::doChunkedRead(uint64_t a1, uint64_t a2, char *__dst, CFIndex bufferLength, CFStreamError *a5, unsigned char *a6)
{
  *a6 = 0;
  a5->error = 0;
  if (bufferLength < 1) {
    return 0;
  }
  CFIndex v7 = bufferLength;
  uint64_t v11 = 0;
  while ((*(_WORD *)(a1 + 232) & 0x100) == 0)
  {
    uint64_t v12 = *(void *)(a1 + 240);
    if (v12 == -3 || (uint64_t v13 = *(void *)(a1 + 248), v12 == v13))
    {
      if (!HTTPReadFilter::readChunkedHeader(a1, a2, v11 < 1, __dst, v7, a5)) {
        return -1;
      }
      uint64_t v12 = *(void *)(a1 + 240);
      if (v12 == -3) {
        return v11;
      }
      if (!v12) {
        break;
      }
      uint64_t v13 = *(void *)(a1 + 248);
    }
    CFIndex v14 = v12 - v13;
    CFDataRef v15 = *(const __CFData **)(a1 + 256);
    if (v15)
    {
      BytePtr = CFDataGetBytePtr(v15);
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 256));
      CFIndex v18 = Length;
      if (Length >= v14) {
        int64_t v19 = v14;
      }
      else {
        int64_t v19 = Length;
      }
      if (v19 >= v7) {
        size_t v20 = v7;
      }
      else {
        size_t v20 = v19;
      }
      memmove(__dst, BytePtr, v20);
      v7 -= v20;
      v11 += v20;
      *(void *)(a1 + 248) += v20;
      v25.CFIndex length = v18 - v20;
      v25.CFIndex location = v20;
      HTTPReadFilter::setDataForRange((HTTPReadFilter *)a1, v25);
      if (!v7) {
        return v11;
      }
      __dst += v20;
      v14 -= v20;
    }
    if (v14)
    {
      if (v11 >= 1
        && !CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2)
        && CFReadStreamGetStatus(*(CFReadStreamRef *)a2) != kCFStreamStatusError)
      {
        return v11;
      }
      if (v14 >= v7) {
        CFIndex v21 = v7;
      }
      else {
        CFIndex v21 = v14;
      }
      *(unsigned char *)(a2 + 8) = 1;
      CFIndex v22 = CFReadStreamRead(*(CFReadStreamRef *)a2, (UInt8 *)__dst, v21);
      if (v22 < 0)
      {
        *a5 = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
        return -1;
      }
      if (!v22)
      {
        a5->CFIndex domain = 4;
        a5->error = -1;
        *(_WORD *)(a1 + 232) |= 0x800u;
        return -1;
      }
      *(void *)(a1 + 264) += v22;
      __dst += v22;
      v7 -= v22;
      v11 += v22;
      *(void *)(a1 + 248) += v22;
    }
    if (v7 <= 0) {
      return v11;
    }
  }
  *a6 = 1;
  if (HTTPReadFilter::readChunkedTrailers(a1, a2, a5)) {
    return v11;
  }
  return -1;
}

uint64_t HTTPReadFilter::doPlainRead(uint64_t a1, uint64_t a2, void *a3, int64_t a4, CFStreamError *a5, unsigned char *a6)
{
  int64_t v8 = a4;
  *a6 = 0;
  a5->error = 0;
  uint64_t v12 = *(void *)(a1 + 240);
  if (v12 != -1)
  {
    int64_t v13 = v12 - *(void *)(a1 + 248);
    if (v13 < a4) {
      int64_t v8 = v13;
    }
  }
  if (!v8)
  {
    uint64_t v18 = 0;
    *a6 = 1;
    return v18;
  }
  CFDataRef v14 = *(const __CFData **)(a1 + 256);
  if (!v14)
  {
    uint64_t v18 = 0;
    goto LABEL_15;
  }
  BytePtr = CFDataGetBytePtr(v14);
  int64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 256));
  CFIndex v17 = Length - v8;
  if (Length <= v8)
  {
    uint64_t v18 = Length;
    memcpy(a3, BytePtr, Length);
    int64_t v19 = *(const void **)(a1 + 256);
    if (v19) {
      CFRelease(v19);
    }
    *(void *)(a1 + 256) = 0;
    if (v18 && (v18 >= v8 || !CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2))) {
      goto LABEL_19;
    }
LABEL_15:
    *(unsigned char *)(a2 + 8) = 1;
    CFIndex v20 = CFReadStreamRead(*(CFReadStreamRef *)a2, (UInt8 *)a3 + v18, v8 - v18);
    if (v20 < 0)
    {
      *a5 = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
      *a6 = 1;
      return -1;
    }
    if (!v20
      || (*(void *)(a1 + 264) += v20, v18 += v20,
                                        CFReadStreamGetStatus(*(CFReadStreamRef *)a2) == kCFStreamStatusAtEnd))
    {
      *a6 = 1;
    }
    goto LABEL_19;
  }
  memcpy(a3, BytePtr, v8);
  v25.CFIndex location = v8;
  v25.CFIndex length = v17;
  HTTPReadFilter::setDataForRange((HTTPReadFilter *)a1, v25);
  uint64_t v18 = v8;
LABEL_19:
  if (v18 >= 1)
  {
    uint64_t v21 = *(void *)(a1 + 240);
    uint64_t v22 = *(void *)(a1 + 248) + v18;
    *(void *)(a1 + 248) = v22;
    if (v21 != -1 && v22 >= v21)
    {
      *a6 = 1;
      uint64_t v21 = *(void *)(a1 + 240);
    }
    if (v21 > 0x4000)
    {
      int v23 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
      if ((*(_WORD *)(a1 + 232) & 0x8040) == 0x8000)
      {
        *(unsigned char *)(a1 + 234) = BYTE2(v23);
        *(_WORD *)(a1 + 232) = v23 | 0x40;
        CFReadStreamSetProperty(*(CFReadStreamRef *)a2, (CFStreamPropertyKey)&unk_1EC09F7C0, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
      }
    }
  }
  return v18;
}

uint64_t HTTPReadFilter::clearLargeDownloadFlag(uint64_t this)
{
  int v1 = *(unsigned __int16 *)(this + 232);
  if ((v1 & 0x40) != 0)
  {
    unsigned int v2 = v1 & 0xFFFFFFBF | (*(unsigned __int8 *)(this + 234) << 16);
    *(_WORD *)(this + 232) = v1 & 0xFFBF;
    *(unsigned char *)(this + 234) = BYTE2(v2);
    if (*(void *)(this + 208))
    {
      if (!*(unsigned char *)(this + 216)) {
        return CFReadStreamSetProperty(*(CFReadStreamRef *)(this + 208), (CFStreamPropertyKey)&unk_1EC09F7C0, (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
      }
    }
  }
  return this;
}

uint64_t HTTPReadFilter::readChunkedTrailers(uint64_t a1, uint64_t a2, CFStreamError *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)(a1 - 16));
  CFHTTPMessageRef Empty = CFHTTPMessageCreateEmpty(v6, 0);
  CFHTTPMessageAppendBytes(Empty, (const UInt8 *)"HTTP/1.0 200 OK\r\n", 17);
  CFDataRef v8 = *(const __CFData **)(a1 + 256);
  if (!v8)
  {
    LOBYTE(appended) = 1;
    goto LABEL_7;
  }
  CFIndex Length = CFDataGetLength(v8);
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 256));
  int appended = CFHTTPMessageAppendBytes(Empty, BytePtr, Length);
  uint64_t v12 = *(const void **)(a1 + 256);
  if (v12) {
    CFRelease(v12);
  }
  *(void *)(a1 + 256) = 0;
  if (appended)
  {
    while (1)
    {
LABEL_7:
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      if (!*((void *)Empty + 13)) {
        break;
      }
      *(unsigned char *)(a2 + 8) = 1;
      uint64_t v13 = CFReadStreamRead(*(CFReadStreamRef *)a2, buffer, 2048);
      if (v13 <= 0)
      {
        if (v13)
        {
          *a3 = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
        }
        else
        {
          a3->CFIndex domain = 4;
          a3->error = -1;
          *(_WORD *)(a1 + 232) |= 0x800u;
        }
        LOBYTE(appended) = 0;
        goto LABEL_21;
      }
      *(void *)(a1 + 264) += v13;
      int v14 = CFHTTPMessageAppendBytes(Empty, buffer, v13);
      LOBYTE(appended) = v14;
      if (!v14) {
        goto LABEL_21;
      }
    }
    HTTPMessage::ensureParserFinished((CFHTTPMessageRef)((char *)Empty + 16));
    uint64_t v16 = (HTTPBodyData *)*((void *)Empty + 8);
    *((void *)Empty + 8) = 0;
    if (v16)
    {
      BOOL v17 = HTTPBodyData::captureData(v16, v15);
      uint64_t v19 = v18;
      (*(void (**)(HTTPBodyData *))(*(void *)v16 + 8))(v16);
      int v20 = *(_WORD *)(a1 + 232) & 0xFFFD | (*(unsigned __int8 *)(a1 + 234) << 16);
      *(_WORD *)(a1 + 232) = *(_WORD *)(a1 + 232) & 0xFFFD | (2 * v17);
      *(unsigned char *)(a1 + 234) = BYTE2(v20);
      *(void *)(a1 + 256) = v19;
    }
    CFDictionaryRef v21 = CFHTTPMessageCopyAllHeaderFields(Empty);
    if (v21)
    {
      CFDictionaryRef v22 = v21;
      CFDictionaryApplyFunction(v21, (CFDictionaryApplierFunction)_addTrailingHeader, *(void **)(a1 + 224));
      CFRelease(v22);
    }
  }
LABEL_21:
  CFRelease(Empty);
  return appended;
}

void _addTrailingHeader(CFStringRef headerField, CFStringRef a2, CFHTTPMessageRef message)
{
  CFStringRef v6 = CFHTTPMessageCopyHeaderFieldValue(message, headerField);
  if (v6)
  {
    CFStringRef v7 = v6;
    CFAllocatorRef v8 = CFGetAllocator(message);
    a2 = CFStringCreateWithFormat(v8, 0, @"%@, %@", v7, a2);
    CFRelease(v7);
  }
  else
  {
    CFRetain(a2);
  }
  CFHTTPMessageSetHeaderFieldValue(message, headerField, a2);

  CFRelease(a2);
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_Close(HTTPReadFilter *this)
{
  return HTTPReadFilter::_streamImpl_Close((HTTPReadFilter *)((char *)this - 120));
}

uint64_t HTTPReadFilter::_streamImpl_Close(HTTPReadFilter *this)
{
  unsigned int v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v3 = (__CFReadStream *)*((void *)this + 26);
  if (v3 && !*((unsigned char *)this + 216))
  {
    CFReadStreamSetClient(v3, 0, 0, 0);
    CFReadStreamClose(*((CFReadStreamRef *)this + 26));
    *((unsigned char *)this + 2CFRetain((char *)this - 16) = 1;
  }

  return pthread_mutex_unlock(v2);
}

BOOL non-virtual thunk to'HTTPReadFilter::_streamImpl_OpenCompleted(HTTPReadFilter *this, CFStreamError *a2)
{
  return HTTPReadFilter::_streamImpl_OpenCompleted((HTTPReadFilter *)((char *)this - 120), a2);
}

BOOL HTTPReadFilter::_streamImpl_OpenCompleted(HTTPReadFilter *this, CFStreamError *a2)
{
  uint64_t v3 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v4 = (__CFReadStream *)*((void *)this + 26);
  BOOL v5 = v4 && !*((unsigned char *)this + 216) && CFReadStreamGetStatus(v4) > kCFStreamStatusOpening;
  pthread_mutex_unlock(v3);
  return v5;
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_Open(CFReadStreamRef *this, CFStreamError *a2, unsigned __int8 *a3)
{
  return HTTPReadFilter::_streamImpl_Open(this - 15, a2, a3);
}

uint64_t HTTPReadFilter::_streamImpl_Open(CFReadStreamRef *this, CFStreamError *a2, unsigned __int8 *a3)
{
  clientContext.version = 0;
  clientContext.info = this;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  CFStringRef v6 = (pthread_mutex_t *)(this + 17);
  pthread_mutex_lock((pthread_mutex_t *)(this + 17));
  CFReadStreamRef v7 = this[26];
  if (v7 && !*((unsigned char *)this + 216))
  {
    CFRetain(v7);
    CFReadStreamSetClient(this[26], 0x1BuLL, (CFReadStreamClientCallBack)HTTPReadFilter::_httpRdFilterStreamCallBack, &clientContext);
    uint64_t v8 = 1;
    if (CFReadStreamGetStatus(this[26]) || (uint64_t v8 = CFReadStreamOpen(this[26]), v8))
    {
      a2->error = 0;
      *a3 = 1;
    }
    else
    {
      *a3 = 1;
      *a2 = CFReadStreamGetError(this[26]);
    }
    CFReadStreamRef v10 = this[26];
    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
    uint64_t v8 = 0;
    a2->CFIndex domain = 4;
    a2->error = -4;
    *((_WORD *)this + 116) |= 0x4000u;
  }
  pthread_mutex_unlock(v6);
  return v8;
}

void HTTPReadFilter::_httpRdFilterStreamCallBack(HTTPReadFilter *this, __CFReadStream *a2, uint64_t a3, void *a4)
{
  CFReadStreamRef v7 = (pthread_mutex_t *)(a3 + 136);
  pthread_mutex_lock((pthread_mutex_t *)(a3 + 136));
  if (*(HTTPReadFilter **)(a3 + 208) != this || !this)
  {
    pthread_mutex_unlock(v7);
    return;
  }
  int v8 = *(unsigned __int8 *)(a3 + 216);
  pthread_mutex_unlock(v7);
  if (v8) {
    return;
  }
  int v9 = (const void *)(a3 - 16);
  CFRetain((CFTypeRef)(a3 - 16));
  if (a2 == (__CFReadStream *)16)
  {
    if (!(*(unsigned int (**)(uint64_t))(*(void *)a3 + 72))(a3))
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      v30.CFIndex domain = 0;
      *(void *)&v30.error = 0;
      CoreStreamBase::_signalEvent((CoreStreamBase *)a3, 16, v30, 1);
    }
    goto LABEL_39;
  }
  if (a2 == (__CFReadStream *)8)
  {
    pthread_mutex_lock(v7);
    uint64_t v12 = *(__CFReadStream **)(a3 + 208);
    if (v12 && !*(unsigned char *)(a3 + 216))
    {
      CFStreamError Error = CFReadStreamGetError(v12);
      CFIndex domain = Error.domain;
      unint64_t v14 = *(void *)&Error.error;
      if (Error.domain == 1 && (Error.error == 54 || Error.error == 32))
      {
        uint64_t v22 = *(void *)(a3 + 224);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        if (v22) {
          int v23 = (HTTPMessage *)(v22 + 16);
        }
        else {
          int v23 = 0;
        }
        HTTPMessage::ensureParserFinished(v23);
        if (!*((void *)v23 + 5)
          || (uint64_t v25 = (const __CFData **)*((void *)v23 + 6)) == 0
          || !HTTPBodyData::getLength(v25, v24))
        {
          unint64_t v14 = *(void *)&Error.error & 0xFFFFFFFF00000000 | 0xFFFFFFFC;
          CFIndex domain = 4;
        }
      }
    }
    else
    {
      *(_WORD *)(a3 + 232) |= 0x4000u;
      CFIndex domain = 4;
      unint64_t v14 = 4294967292;
    }
    CFDataRef v15 = (char *)CFRetain(v9);
    pthread_mutex_unlock(v7);
    if (!v15) {
      goto LABEL_39;
    }
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v16 = (CoreStreamBase *)(v15 + 16);
    uint64_t v17 = 8;
    v18.CFIndex domain = domain;
    *(void *)&v18.error = v14;
    goto LABEL_32;
  }
  if (a2 != (__CFReadStream *)2)
  {
    pthread_mutex_lock(v7);
    CFDataRef v15 = (char *)CFRetain((CFTypeRef)(a3 - 16));
    pthread_mutex_unlock(v7);
    if (!v15) {
      goto LABEL_39;
    }
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v16 = (CoreStreamBase *)(v15 + 16);
    uint64_t v17 = (uint64_t)a2;
    v18.CFIndex domain = 0;
    *(void *)&v18.error = 0;
LABEL_32:
    CoreStreamBase::_signalEvent(v16, v17, v18, 1);
    uint64_t v19 = v15;
LABEL_38:
    CFRelease(v19);
    goto LABEL_39;
  }
  pthread_mutex_lock(v7);
  CFReadStreamRef v10 = (char *)CFRetain((CFTypeRef)(a3 - 16));
  pthread_mutex_unlock(v7);
  if (v10 && (*(unsigned int (**)(uint64_t))(*(void *)a3 + 72))(a3))
  {
    uint64_t v11 = 2;
    goto LABEL_13;
  }
  pthread_mutex_lock(v7);
  int v20 = *(__CFReadStream **)(a3 + 208);
  if (v20 && !*(unsigned char *)(a3 + 216))
  {
    unint64_t v26 = CFReadStreamGetStatus(v20) - 8;
    pthread_mutex_unlock(v7);
    if (v26 <= 0xFFFFFFFFFFFFFFFCLL)
    {
      pthread_mutex_lock(v7);
      int v27 = *(unsigned __int16 *)(a3 + 232) | (*(unsigned __int8 *)(a3 + 234) << 16);
      if ((*(_WORD *)(a3 + 232) & 0x601) == 0x201)
      {
        *(unsigned char *)(a3 + 234) = BYTE2(v27);
        *(_WORD *)(a3 + 232) = v27 | 0x400;
        HTTPReadFilter::clearLargeDownloadFlag(a3);
        uint64_t v11 = 32;
      }
      else
      {
        uint64_t v11 = 0;
      }
      pthread_mutex_unlock(v7);
      if (v10)
      {
LABEL_13:
        if (v11)
        {
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
          }
          v29.CFIndex domain = 0;
          *(void *)&v29.error = 0;
          CoreStreamBase::_signalEvent((CoreStreamBase *)(v10 + 16), v11, v29, 1);
          goto LABEL_37;
        }
      }
    }
  }
  else
  {
    pthread_mutex_unlock(v7);
  }
  if (v10)
  {
LABEL_37:
    uint64_t v19 = v10;
    goto LABEL_38;
  }
LABEL_39:

  CFRelease(v9);
}

CFTypeRef non-virtual thunk to'HTTPReadFilter::_streamImpl_CopyProperty(HTTPReadFilter *this, const __CFString *a2)
{
  return HTTPReadFilter::_streamImpl_CopyProperty((HTTPReadFilter *)((char *)this - 120), a2);
}

CFTypeRef HTTPReadFilter::_streamImpl_CopyProperty(HTTPReadFilter *this, const __CFString *a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  int ExactString = _findExactString(a2, 0);
  if (ExactString <= 406091237)
  {
    if (ExactString == 398808402)
    {
      CFDataRef v9 = (const __CFData *)*((void *)this + 32);
      if (v9 && CFDataGetLength(v9) >= 1)
      {
        CFReadStreamRef v7 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      }
      else
      {
        CFReadStreamRef v10 = (__CFReadStream *)*((void *)this + 26);
        if (v10 && !*((unsigned char *)this + 216))
        {
LABEL_25:
          CFTypeRef v8 = CFReadStreamCopyProperty(v10, a2);
          goto LABEL_26;
        }
        CFReadStreamRef v7 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
      }
    }
    else
    {
      if (ExactString != 402920877)
      {
LABEL_18:
        CFReadStreamRef v10 = (__CFReadStream *)*((void *)this + 26);
        if (!v10 || *((unsigned char *)this + 216)) {
          goto LABEL_20;
        }
        goto LABEL_25;
      }
      if ((*((_WORD *)this + 116) & 0x200) != 0) {
        CFReadStreamRef v7 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
      }
      else {
        CFReadStreamRef v7 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
      }
    }
    CFTypeRef v11 = *v7;
    goto LABEL_27;
  }
  if (ExactString == 446986240 || ExactString == 444831706)
  {
    if (!CFHTTPMessageIsHeaderComplete(*((CFHTTPMessageRef *)this + 28))) {
      goto LABEL_20;
    }
    CFStringRef v6 = (const void *)*((void *)this + 28);
    if (!v6) {
      goto LABEL_20;
    }
    goto LABEL_14;
  }
  if (ExactString != 406091238) {
    goto LABEL_18;
  }
  CFStringRef v6 = (const void *)*((void *)this + 26);
  if (v6)
  {
LABEL_14:
    CFTypeRef v8 = CFRetain(v6);
LABEL_26:
    CFTypeRef v11 = v8;
    goto LABEL_27;
  }
LABEL_20:
  CFTypeRef v11 = 0;
LABEL_27:
  pthread_mutex_unlock(v4);
  return v11;
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_SetProperty(HTTPReadFilter *this, const __CFString *a2, const void *a3)
{
  return HTTPReadFilter::_streamImpl_SetProperty((HTTPReadFilter *)((char *)this - 120), a2, a3);
}

uint64_t HTTPReadFilter::_streamImpl_SetProperty(HTTPReadFilter *this, const __CFString *a2, const void *a3)
{
  CFStringRef v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v7 = 0;
  int ExactString = _findExactString(a2, 0);
  if (ExactString <= 405050834)
  {
    if (ExactString <= 228814902)
    {
      if (ExactString != 104064896)
      {
        if (ExactString == 224669676) {
          goto LABEL_42;
        }
        goto LABEL_31;
      }
      int v10 = *((unsigned __int16 *)this + 116) | (*((unsigned __int8 *)this + 234) << 16);
      if ((const void *)*MEMORY[0x1E4F1CFD0] != a3)
      {
        *((unsigned char *)this + 234) = BYTE2(v10);
        *((_WORD *)this + 1CFRetain((char *)this - 16) = v10 & 0x7FFF;
        uint64_t v12 = (const void *)*((void *)this + 26);
        if (v12)
        {
          if (!*((unsigned char *)this + 216))
          {
            CFRetain(v12);
            CFReadStreamSetProperty(*((CFReadStreamRef *)this + 26), a2, a3);
            uint64_t v13 = (const void *)*((void *)this + 26);
            if (v13) {
              CFRelease(v13);
            }
          }
        }
        goto LABEL_41;
      }
      __int16 v11 = *((_WORD *)this + 116) | 0x8000;
      goto LABEL_37;
    }
    if (ExactString == 228814903) {
      goto LABEL_42;
    }
    if (ExactString == 402920877)
    {
      int v10 = *((unsigned __int16 *)this + 116) | (*((unsigned __int8 *)this + 234) << 16);
      if ((const void *)*MEMORY[0x1E4F1CFD0] == a3) {
        __int16 v11 = *((_WORD *)this + 116) | 0x200;
      }
      else {
        __int16 v11 = *((_WORD *)this + 116) & 0xFDFF;
      }
LABEL_37:
      *((unsigned char *)this + 234) = BYTE2(v10);
      *((_WORD *)this + 1CFRetain((char *)this - 16) = v11;
LABEL_41:
      uint64_t v7 = 1;
      goto LABEL_42;
    }
LABEL_31:
    uint64_t v16 = (const void *)*((void *)this + 26);
    if (v16 && !*((unsigned char *)this + 216))
    {
      CFRetain(v16);
      uint64_t v7 = CFReadStreamSetProperty(*((CFReadStreamRef *)this + 26), a2, a3);
      CFStreamError v18 = (const void *)*((void *)this + 26);
      if (v18) {
        CFRelease(v18);
      }
    }
    else
    {
      uint64_t v7 = 0;
    }
    goto LABEL_42;
  }
  if (ExactString > 407246327)
  {
    if (ExactString != 407246328)
    {
      if (ExactString == 409343531)
      {
        if ((const void *)*MEMORY[0x1E4F1CFD0] == a3) {
          *((_WORD *)this + 116) |= 0x2000u;
        }
        goto LABEL_41;
      }
      goto LABEL_31;
    }
    int v14 = *((unsigned __int16 *)this + 116) | (*((unsigned __int8 *)this + 234) << 16);
    if ((const void *)*MEMORY[0x1E4F1CFD0] == a3) {
      char v15 = BYTE2(v14) | 1;
    }
    else {
      char v15 = BYTE2(v14) & 0xFE;
    }
LABEL_40:
    *((_WORD *)this + 1CFRetain((char *)this - 16) = v14;
    *((unsigned char *)this + 234) = v15;
    goto LABEL_41;
  }
  if (ExactString == 405050835)
  {
    int v14 = *((unsigned __int16 *)this + 116) | (*((unsigned __int8 *)this + 234) << 16);
    if ((const void *)*MEMORY[0x1E4F1CFD0] == a3) {
      char v15 = BYTE2(v14) | 2;
    }
    else {
      char v15 = BYTE2(v14) & 0xFD;
    }
    goto LABEL_40;
  }
  if (ExactString != 406091238) {
    goto LABEL_31;
  }
  CFDataRef v9 = (const void *)*((void *)this + 26);
  if (v9 != a3)
  {
    *((void *)this + 26) = 0;
    if (v9) {
      CFRelease(v9);
    }
  }
  uint64_t v7 = 0;
  if (a3) {
    *((void *)this + 26) = CFRetain(a3);
  }
  else {
    *((unsigned char *)this + 2CFRetain((char *)this - 16) = 1;
  }
LABEL_42:
  pthread_mutex_unlock(v6);
  return v7;
}

void non-virtual thunk to'HTTPWriteFilter::~HTTPWriteFilter(HTTPWriteFilter *this)
{
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 128));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 120));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 120));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 8));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 8));
}

void HTTPWriteFilter::~HTTPWriteFilter(HTTPWriteFilter *this)
{
  *(void *)this = &unk_1ECF9D768;
  *((void *)this + 1) = &unk_1ECF9D808;
  *((void *)this + 15) = &unk_1ECF9D828;
  *((void *)this + CFRetain((char *)this - 16) = &unk_1ECF9D8E0;
  unsigned int v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v3 = (const void *)*((void *)this + 27);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 32);
  if (v4) {
    CFRelease(v4);
  }
  BOOL v5 = (__CFWriteStream *)*((void *)this + 26);
  if (v5)
  {
    CFWriteStreamClose(v5);
    CFWriteStreamSetClient(*((CFWriteStreamRef *)this + 26), 0, 0, 0);
    CFStringRef v6 = (const void *)*((void *)this + 26);
    *((void *)this + 26) = 0;
    if (v6) {
      CFRelease(v6);
    }
  }
  uint64_t v7 = (const void *)*((void *)this + 33);
  if (v7) {
    CFRelease(v7);
  }
  CFTypeRef v8 = (const void *)*((void *)this + 35);
  if (v8) {
    CFRelease(v8);
  }
  CFDataRef v9 = (const void *)*((void *)this + 29);
  if (v9) {
    _Block_release(v9);
  }
  pthread_mutex_unlock(v2);
  *((void *)this + CFRetain((char *)this - 16) = &unk_1ECF9C6A8;
  pthread_mutex_destroy(v2);

  CoreStreamBase::~CoreStreamBase(this);
}

void sub_184202EF0(_Unwind_Exception *a1)
{
  *((void *)v1 + CFRetain((char *)this - 16) = &unk_1ECF9C6A8;
  pthread_mutex_destroy(v2);
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_deprecated_Unschedule(HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPWriteFilter::_streamImpl_deprecated_Unschedule((HTTPWriteFilter *)((char *)this - 120), a2, a3);
}

uint64_t HTTPWriteFilter::_streamImpl_deprecated_Unschedule(HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFStringRef v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v7 = (__CFWriteStream *)*((void *)this + 26);
  if (v7) {
    CFWriteStreamUnscheduleFromRunLoop(v7, a2, a3);
  }

  return pthread_mutex_unlock(v6);
}

uint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_deprecated_Schedule(HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPWriteFilter::_streamImpl_deprecated_Schedule((HTTPWriteFilter *)((char *)this - 120), a2, a3);
}

uint64_t HTTPWriteFilter::_streamImpl_deprecated_Schedule(HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFStringRef v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v7 = (__CFWriteStream *)*((void *)this + 26);
  if (v7) {
    CFWriteStreamScheduleWithRunLoop(v7, a2, a3);
  }

  return pthread_mutex_unlock(v6);
}

uint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_CanWrite(HTTPWriteFilter *this)
{
  return HTTPWriteFilter::socketStreamCanWrite((HTTPWriteFilter *)((char *)this - 120));
}

uint64_t HTTPWriteFilter::socketStreamCanWrite(HTTPWriteFilter *this)
{
  unsigned int v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v3 = (__CFWriteStream *)*((void *)this + 26);
  if (!v3) {
    goto LABEL_27;
  }
  CFStreamStatus Status = CFWriteStreamGetStatus(v3);
  BOOL v5 = (__CFWriteStream *)*((void *)this + 26);
  if (Status == kCFStreamStatusError)
  {
    CFStreamError Error = CFWriteStreamGetError(v5);
    CFIndex domain = Error.domain;
    unint64_t v8 = *(void *)&Error.error;
    if (Error.domain != *MEMORY[0x1E4F1D430])
    {
      if ((*((_WORD *)this + 112) & 0x100) != 0)
      {
        CFDataRef v9 = &_kCFStreamErrorHTTPSProxyFailure;
        goto LABEL_16;
      }
      if ((*((_WORD *)this + 112) & 0x200) != 0)
      {
        CFDataRef v9 = &_kCFStreamErrorHTTPProxyFailure;
LABEL_16:
        unint64_t v8 = *(void *)&Error.error & 0xFFFFFFFF00000000 | *v9;
        CFIndex domain = 4;
      }
    }
    pthread_mutex_unlock(v2);
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    char v15 = this;
    v16.CFIndex domain = domain;
    *(void *)&v16.error = v8;
LABEL_20:
    CoreStreamBase::_signalEvent(v15, 8, v16, 1);
    return 0;
  }
  if (!CFWriteStreamCanAcceptBytes(v5)) {
    goto LABEL_27;
  }
  int v10 = *((unsigned __int16 *)this + 112);
  if ((~v10 & 0x401) == 0 || !*((void *)this + 27)) {
    goto LABEL_27;
  }
  if ((v10 & 0x10) == 0)
  {
    CFIndex v11 = HTTPWriteFilter::transmitHeader(this, 0);
    uint64_t v13 = v12;
    if (v12)
    {
      CFIndex v14 = v11;
      pthread_mutex_unlock(v2);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      char v15 = this;
      v16.CFIndex domain = v14;
      *(void *)&v16.error = v13;
      goto LABEL_20;
    }
    if ((*((_WORD *)this + 112) & 0x10) == 0) {
      goto LABEL_27;
    }
  }
  if (!CFWriteStreamCanAcceptBytes(*((CFWriteStreamRef *)this + 26)))
  {
LABEL_27:
    pthread_mutex_unlock(v2);
    return 0;
  }
  __int16 v17 = *((_WORD *)this + 112);
  pthread_mutex_unlock(v2);
  if ((v17 & 0x1000) != 0) {
    return 0;
  }
  if (*((void *)this + 36))
  {
    (*(void (**)(void))(**((void **)this + 25) + 216))(*((void *)this + 25));
    *((void *)this + 36) = 0;
  }
  return 1;
}

CFIndex HTTPWriteFilter::transmitHeader(HTTPWriteFilter *this, __CFHTTPMessage *a2)
{
  __int16 v2 = *((_WORD *)this + 112);
  if ((v2 & 0x10) != 0) {
    return 0;
  }
  if (!*((void *)this + 26)) {
    return 4;
  }
  if ((*((_WORD *)this + 112) & 0x4000) != 0)
  {
    *((_WORD *)this + 112) = v2 & 0xBFFF;
    unint64_t v8 = (const void *)*((void *)this + 27);
    *((void *)this + 27) = 0;
    if (v8) {
      CFRelease(v8);
    }
    CFDataRef v9 = (const void *)*((void *)this + 32);
    *((void *)this + 32) = 0;
    if (v9) {
      CFRelease(v9);
    }
    uint64_t v10 = *((void *)this + 25);
    *(CFAbsoluteTime *)(v10 + 296) = CFAbsoluteTimeGetCurrent() + 10.0;
    (*(void (**)(void))(**((void **)this + 25) + 192))(*((void *)this + 25));
    uint64_t v11 = *((void *)this + 29);
    if (v11)
    {
      (*(void (**)(uint64_t, void))(v11 + 16))(v11, 0);
      _Block_release(*((const void **)this + 29));
      CFIndex domain = 0;
      *((void *)this + 29) = 0;
      return domain;
    }
    return 0;
  }
  int v4 = (int)a2;
  uint64_t v5 = *((void *)this + 29);
  if (v5)
  {
    (*(void (**)(uint64_t, void))(v5 + 16))(v5, 0);
    _Block_release(*((const void **)this + 29));
    *((void *)this + 29) = 0;
  }
  if (!*((void *)this + 27)) {
    return 4;
  }
  if ((*((_WORD *)this + 112) & 0x100) != 0)
  {
    uint64_t v13 = (__CFWriteStream *)*((void *)this + 26);
    if (!v13 || (CFIndex v14 = (__CFHTTPMessage *)CFWriteStreamCopyProperty(v13, (CFStreamPropertyKey)&unk_1EC0A5720)) == 0)
    {
      *((void *)this + 31) = 0;
      *((void *)this + 32) = 0;
      return 4;
    }
    char v15 = v14;
    CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v14);
    CFRelease(v15);
    if (ResponseStatusCode != 200)
    {
      *((void *)this + 31) = 0;
      *((void *)this + 32) = 0;
      if (ResponseStatusCode == 407)
      {
        CFIndex domain = 0;
        __int16 v23 = *((_WORD *)this + 112) | 0x30;
LABEL_99:
        *((_WORD *)this + 112) = v23;
        return domain;
      }
      return 4;
    }
    *((_WORD *)this + 112) &= ~0x100u;
    __int16 v17 = (const void *)*((void *)this + 34);
    if (v17)
    {
      CFStreamError v18 = (__CFWriteStream *)*((void *)this + 26);
      if (v18)
      {
        CFWriteStreamSetProperty(v18, @"kCFStreamPropertySSLContext", v17);
        __int16 v17 = (const void *)*((void *)this + 34);
        *((void *)this + 34) = 0;
        if (!v17) {
          goto LABEL_142;
        }
      }
      else
      {
        *((void *)this + 34) = 0;
      }
      goto LABEL_141;
    }
    __int16 v17 = (const void *)*((void *)this + 33);
    if (v17)
    {
      int v37 = (__CFWriteStream *)*((void *)this + 26);
      if (!v37)
      {
        *((void *)this + 33) = 0;
        goto LABEL_141;
      }
      CFWriteStreamSetProperty(v37, @"kCFStreamPropertySocketSSLContext", v17);
      __int16 v17 = (const void *)*((void *)this + 33);
      *((void *)this + 33) = 0;
      if (!v17)
      {
LABEL_142:
        if ((*(unsigned int (**)(void))(**((void **)this + 25) + 208))(*((void *)this + 25))) {
          (*(void (**)(void, void))(**((void **)this + 25) + 280))(*((void *)this + 25), *((void *)this + 27));
        }
        goto LABEL_8;
      }
    }
    else
    {
      __int16 v17 = (const void *)*((void *)this + 35);
      if (!v17)
      {
        CFURLRef v60 = CFHTTPMessageCopyRequestURL(*((CFHTTPMessageRef *)this + 27));
        CFStringRef v61 = CFURLCopyHostName(v60);
        if (v61)
        {
          CFStringRef v62 = v61;
          int v63 = (__CFWriteStream *)*((void *)this + 26);
          if (v63) {
            CFWriteStreamSetProperty(v63, (CFStreamPropertyKey)&unk_1EC09FBB0, v62);
          }
          CFRelease(v62);
        }
        if (v60) {
          CFRelease(v60);
        }
        uint64_t v64 = (__CFWriteStream *)*((void *)this + 26);
        if (v64) {
          CFWriteStreamSetProperty(v64, @"kCFStreamPropertySocketSecurityLevel", &unk_1EC0A13C0);
        }
        goto LABEL_142;
      }
      uint64_t v59 = (__CFWriteStream *)*((void *)this + 26);
      if (!v59)
      {
        *((void *)this + 35) = 0;
        goto LABEL_141;
      }
      CFWriteStreamSetProperty(v59, @"kCFStreamPropertySSLSettings", v17);
      __int16 v17 = (const void *)*((void *)this + 35);
      *((void *)this + 35) = 0;
      if (!v17) {
        goto LABEL_142;
      }
    }
LABEL_141:
    CFRelease(v17);
    goto LABEL_142;
  }
LABEL_8:
  CFStringRef v6 = (__CFData *)*((void *)this + 32);
  if (v6)
  {
    int v7 = 0;
    goto LABEL_85;
  }
  uint64_t v19 = *((void *)this + 27);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t v20 = v19 + 16;
  if (!v19) {
    uint64_t v20 = 0;
  }
  CFDictionaryRef v21 = *(const __CFDictionary ***)(v20 + 72);
  if (v21)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
    }
    unsigned int v22 = HTTPAuthentication::isKerberosThePreferredAuthScheme(v21[19]);
  }
  else
  {
    unsigned int v22 = 0;
  }
  uint64_t v24 = HTTPFilter::expectedSizeFromHeaders(*((HTTPFilter **)this + 27), a2);
  if (v24 == -1)
  {
    uint64_t v30 = *((void *)this + 27);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (v30) {
      int64_t v31 = (HTTPMessage *)(v30 + 16);
    }
    else {
      int64_t v31 = 0;
    }
    CFStringRef v32 = HTTPMessage::copyHeaderFieldValue(v31, 0x148233EDu);
    if (v32)
    {
      CFStringRef v33 = v32;
      v66.CFIndex length = CFStringGetLength(v32);
      v66.CFIndex location = 0;
      if (!CFStringFindWithOptions(v33, (CFStringRef)&unk_1EC0A2E00, v66, 1uLL, 0))
      {
        MutableCFHTTPMessageRef Copy = CFStringCreateMutableCopy(0, 0, v33);
        CFStringAppend(MutableCopy, @", Chunked");
        uint64_t v35 = *((void *)this + 27);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
        {
          uint64_t v65 = *((void *)this + 27);
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
          uint64_t v35 = v65;
        }
        if (v35) {
          CFIndex v36 = (HTTPMessage *)(v35 + 16);
        }
        else {
          CFIndex v36 = 0;
        }
        HTTPMessage::setHeaderFieldStringValue(v36, 0x148233EDu, MutableCopy);
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
      }
      CFRelease(v33);
    }
    else
    {
      uint64_t v38 = *((void *)this + 27);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      if (v38) {
        unsigned int v39 = (HTTPMessage *)(v38 + 16);
      }
      else {
        unsigned int v39 = 0;
      }
      HTTPMessage::setHeaderFieldStringValue(v39, 0x148233EDu, &unk_1EC0A2E38);
    }
    *((_WORD *)this + 112) |= 0x80u;
    *((void *)this + 30) = 0;
  }
  else
  {
    uint64_t v25 = v24;
    if (!v22)
    {
      uint64_t v26 = *((void *)this + 27);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      uint64_t v27 = v26 + 16;
      if (!v26) {
        uint64_t v27 = 0;
      }
      if (_CFHTTPAuthenticationIsFirstNTLMTransaction(*(_CFHTTPAuthentication **)(v27 + 72), *((void **)this + 25)))
      {
        uint64_t v28 = *((void *)this + 27);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        uint64_t v29 = v28 + 16;
        if (!v28) {
          uint64_t v29 = 0;
        }
        *(void *)(v29 + 64) = v25;
        uint64_t v25 = 0;
      }
    }
    *((void *)this + 30) = v25;
    *((_WORD *)this + 112) &= ~0x80u;
  }
  if (!v22
    && _CFHTTPAuthenticationIsFirstNTLMTransaction((_CFHTTPAuthentication *)v21, *((void **)this + 25)))
  {
    uint64_t v51 = *((void *)this + 27);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (v51) {
      int v52 = (HTTPMessage *)(v51 + 16);
    }
    else {
      int v52 = 0;
    }
    CFStringRef v53 = HTTPMessage::copyHeaderFieldValue(v52, 0x11F1D2DBu);
    if (v53)
    {
      CFStringRef v54 = v53;
      uint64_t v55 = *((void *)this + 27);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      if (v55) {
        CFStringRef v56 = (HTTPMessage *)(v55 + 16);
      }
      else {
        CFStringRef v56 = 0;
      }
      HTTPMessage::setHeaderFieldStringValue(v56, 0x11F1D2DBu, @"0");
      CFRelease(v54);
    }
  }
  uint64_t v40 = *((void *)this + 27);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (v40) {
    uint64_t v41 = (HTTPMessage *)(v40 + 16);
  }
  else {
    uint64_t v41 = 0;
  }
  CFStringRef v6 = HTTPMessage::copySerializedHeaders(v41, (*((unsigned __int16 *)this + 112) >> 9) & 1);
  *((void *)this + 31) = 0;
  *((void *)this + 32) = v6;
  if (!v6) {
    return 4;
  }
  int v7 = 1;
LABEL_85:
  CFIndex Length = CFDataGetLength(v6);
  BytePtr = CFDataGetBytePtr(*((CFDataRef *)this + 32));
  CFIndex v45 = (CFIndex *)((char *)this + 248);
  CFIndex v44 = *((void *)this + 31);
  if (v44 < Length)
  {
    int v46 = BytePtr;
    do
    {
      CFAllocatorRef v47 = (__CFWriteStream *)*((void *)this + 26);
      if (!v47) {
        break;
      }
      if (!v4)
      {
        if (!CFWriteStreamCanAcceptBytes(v47)) {
          break;
        }
        CFAllocatorRef v47 = (__CFWriteStream *)*((void *)this + 26);
        CFIndex v44 = *((void *)this + 31);
      }
      CFIndex v48 = CFWriteStreamWrite(v47, &v46[v44], Length - v44);
      if (v48 < 0)
      {
        CFStreamError Error = CFWriteStreamGetError((CFWriteStreamRef)*((void *)this + 26));
        CFIndex domain = Error.domain;
        SInt32 v58 = Error.error;
        if (v7 && Error.domain == 1)
        {
          if (Error.error == 54 || Error.error == 32)
          {
            SInt32 v58 = -4;
            CFIndex domain = 4;
          }
          else
          {
            CFIndex domain = 1;
          }
        }
        if (v58) {
          goto LABEL_96;
        }
        goto LABEL_95;
      }
      if (!v48)
      {
        if (!v7) {
          *((_WORD *)this + 112) |= 0x2000u;
        }
        CFIndex domain = 4;
        goto LABEL_96;
      }
      int v7 = 0;
      *((void *)this + 36) += v48;
      CFIndex v44 = *((void *)this + 31) + v48;
      *((void *)this + 31) = v44;
    }
    while (v44 < Length);
  }
  CFIndex domain = 0;
LABEL_95:
  if (*v45 >= Length)
  {
LABEL_96:
    uint64_t v49 = (const void *)*((void *)this + 32);
    if (v49) {
      CFRelease(v49);
    }
    *CFIndex v45 = 0;
    *((void *)this + 32) = 0;
    __int16 v23 = *((_WORD *)this + 112) | 0x10;
    goto LABEL_99;
  }
  return domain;
}

CFIndex non-virtual thunk to'HTTPWriteFilter::_streamImpl_Write(HTTPWriteFilter *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  return HTTPWriteFilter::_streamImpl_Write((HTTPWriteFilter *)((char *)this - 120), a2, a3, a4);
}

CFIndex HTTPWriteFilter::_streamImpl_Write(HTTPWriteFilter *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  a4->error = 0;
  unint64_t v8 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  __int16 v9 = *((_WORD *)this + 112);
  if ((v9 & 0x20) != 0)
  {
    pthread_mutex_unlock(v8);
    return 0;
  }
  if ((v9 & 0x40) != 0)
  {
    a4->CFIndex domain = 4;
    SInt32 v10 = -2096;
    goto LABEL_8;
  }
  if (*((_WORD *)this + 112) & 0x400) != 0 && (v9)
  {
    a4->CFIndex domain = 4;
    SInt32 v10 = -2095;
LABEL_8:
    a4->error = v10;
LABEL_9:
    pthread_mutex_unlock(v8);
    return -1;
  }
  if (!*((void *)this + 26)) {
    goto LABEL_9;
  }
  if ((v9 & 0x10) != 0)
  {
    if (a4->error) {
      goto LABEL_9;
    }
  }
  else
  {
    a4->CFIndex domain = HTTPWriteFilter::transmitHeader(this, (__CFHTTPMessage *)1);
    *(void *)&a4->error = v13;
    if (v13) {
      goto LABEL_9;
    }
  }
  if ((*((_WORD *)this + 112) & 0x80) == 0)
  {
    uint64_t v15 = *((void *)this + 30);
    uint64_t v14 = *((void *)this + 31);
    BOOL v16 = __OFSUB__(v15, v14);
    uint64_t v17 = v15 - v14;
    if ((v17 < 0) ^ v16 | (v17 == 0))
    {
      pthread_mutex_unlock(v8);
      (*(void (**)(void, void))(**((void **)this + 25) + 216))(*((void *)this + 25), *((void *)this + 36));
      CFIndex v11 = 0;
    }
    else
    {
      if (v17 >= a3) {
        CFIndex v18 = a3;
      }
      else {
        CFIndex v18 = v17;
      }
      CFIndex v19 = CFWriteStreamWrite(*((CFWriteStreamRef *)this + 26), a2, v18);
      if (v19 < 0)
      {
        *a4 = CFWriteStreamGetError((CFWriteStreamRef)*((void *)this + 26));
        goto LABEL_9;
      }
      CFIndex v11 = v19;
      *((void *)this + 31) += v19;
      *((void *)this + 36) += v19;
      pthread_mutex_unlock(v8);
      (*(void (**)(void, void))(**((void **)this + 25) + 216))(*((void *)this + 25), *((void *)this + 36));
    }
    *((void *)this + 36) = 0;
    return v11;
  }
  uint64_t v20 = HTTPWriteFilter::doChunkedWrite(this, a2, a3, a4);
  pthread_mutex_unlock(v8);
  (*(void (**)(void, void))(**((void **)this + 25) + 216))(*((void *)this + 25), *((void *)this + 36));
  *((void *)this + 36) = 0;
  return v20;
}

uint64_t HTTPWriteFilter::doChunkedWrite(HTTPWriteFilter *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  uint64_t v5 = a3;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *((void *)this + 30);
  CFIndex v8 = *((void *)this + 31);
  if (v9 <= v8)
  {
    SInt32 v10 = (__CFWriteStream *)*((void *)this + 26);
    __int16 v11 = *((_WORD *)this + 112);
    a4->error = 0;
    *(_WORD *)&v24[1] = 2573;
    uint64_t v12 = v24;
    if (a3 >= 1)
    {
      unint64_t v13 = a3;
      do
      {
        if ((v13 & 0xF) >= 0xA) {
          char v14 = (v13 & 0xF) + 55;
        }
        else {
          char v14 = v13 & 0xF | 0x30;
        }
        *v12-- = v14;
        BOOL v15 = v13 > 0xF;
        v13 >>= 4;
      }
      while (v15);
    }
    if ((v11 & 4) != 0)
    {
      BOOL v16 = v12 + 1;
    }
    else
    {
      *(_WORD *)(v12 - 1) = 2573;
      BOOL v16 = v12 - 1;
    }
    while (v16 < (const UInt8 *)&v25)
    {
      CFIndex v17 = CFWriteStreamWrite(v10, v16, (char *)&v25 - (char *)v16);
      if (v17 < 0)
      {
        *a4 = CFWriteStreamGetError(v10);
        break;
      }
      if (!v17)
      {
        a4->CFIndex domain = 4;
        a4->error = -1;
        break;
      }
      v16 += v17;
      *((void *)this + 36) += v17;
    }
    *((_WORD *)this + 112) &= ~4u;
    if (a4->error) {
      return -1;
    }
    CFIndex v8 = 0;
    *((void *)this + 30) = v5;
    *((void *)this + 31) = 0;
    uint64_t v9 = v5;
  }
  if (v9 <= v8)
  {
    uint64_t v18 = 0;
  }
  else
  {
    uint64_t v18 = 0;
    while (1)
    {
      CFIndex v19 = (__CFWriteStream *)*((void *)this + 26);
      if (!v19) {
        break;
      }
      if (v18)
      {
        if (!CFWriteStreamCanAcceptBytes(v19)) {
          break;
        }
        uint64_t v9 = *((void *)this + 30);
        CFIndex v8 = *((void *)this + 31);
        CFIndex v19 = (__CFWriteStream *)*((void *)this + 26);
      }
      uint64_t v20 = v9 - v8;
      if (v20 >= v5) {
        LODWORD(v20) = v5;
      }
      CFIndex v21 = CFWriteStreamWrite(v19, a2, (int)v20);
      if (v21 < 0)
      {
        *a4 = CFWriteStreamGetError((CFWriteStreamRef)*((void *)this + 26));
        return -1;
      }
      if (v21)
      {
        uint64_t v9 = *((void *)this + 30);
        CFIndex v8 = *((void *)this + 31) + v21;
        *((void *)this + 36) += v21;
        *((void *)this + 31) = v8;
        v18 += v21;
        a2 += v21;
        v5 -= v21;
        if (v9 > v8) {
          continue;
        }
      }
      break;
    }
  }
  if (v5 && CFWriteStreamCanAcceptBytes(*((CFWriteStreamRef *)this + 26)))
  {
    uint64_t v22 = HTTPWriteFilter::doChunkedWrite(this, a2, v5, a4);
    if (v22 < 0) {
      return -1;
    }
    else {
      v18 += v22;
    }
  }
  return v18;
}

uint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_Close(HTTPWriteFilter *this)
{
  return HTTPWriteFilter::_streamImpl_Close((HTTPWriteFilter *)((char *)this - 120));
}

uint64_t HTTPWriteFilter::_streamImpl_Close(HTTPWriteFilter *this)
{
  __int16 v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v3 = (__CFWriteStream *)*((void *)this + 26);
  if (v3)
  {
    CFWriteStreamClose(v3);
    CFWriteStreamSetClient(*((CFWriteStreamRef *)this + 26), 0, 0, 0);
    int v4 = (const void *)*((void *)this + 26);
    *((void *)this + 26) = 0;
    if (v4) {
      CFRelease(v4);
    }
  }

  return pthread_mutex_unlock(v2);
}

BOOL non-virtual thunk to'HTTPWriteFilter::_streamImpl_OpenCompleted(HTTPWriteFilter *this, CFStreamError *a2)
{
  return HTTPWriteFilter::_streamImpl_OpenCompleted((HTTPWriteFilter *)((char *)this - 120), a2);
}

BOOL HTTPWriteFilter::_streamImpl_OpenCompleted(HTTPWriteFilter *this, CFStreamError *a2)
{
  uint64_t v3 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  int v4 = (__CFWriteStream *)*((void *)this + 26);
  if (v4) {
    BOOL v5 = CFWriteStreamGetStatus(v4) > kCFStreamStatusOpening;
  }
  else {
    BOOL v5 = 0;
  }
  pthread_mutex_unlock(v3);
  return v5;
}

uint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_Open(__CFWriteStream **this, CFStreamError *a2, unsigned __int8 *a3)
{
  return HTTPWriteFilter::_streamImpl_Open(this - 15, a2, a3);
}

uint64_t HTTPWriteFilter::_streamImpl_Open(__CFWriteStream **this, CFStreamError *a2, unsigned __int8 *a3)
{
  clientContext.version = 0;
  clientContext.info = this;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  CFStringRef v6 = (pthread_mutex_t *)(this + 17);
  pthread_mutex_lock((pthread_mutex_t *)(this + 17));
  int v7 = this[26];
  if (v7)
  {
    CFWriteStreamSetClient(v7, 0x1CuLL, (CFWriteStreamClientCallBack)HTTPWriteFilter::_httpWrFilterSocketStreamCallBack, &clientContext);
    uint64_t v8 = 1;
    if (CFWriteStreamGetStatus(this[26]) || (uint64_t v8 = CFWriteStreamOpen(this[26]), v8))
    {
      a2->error = 0;
      *a3 = 1;
    }
    else
    {
      *a3 = 1;
      *a2 = CFWriteStreamGetError(this[26]);
    }
  }
  else
  {
    uint64_t v8 = 0;
    a2->CFIndex domain = 4;
    a2->error = -4;
  }
  pthread_mutex_unlock(v6);
  return v8;
}

void HTTPWriteFilter::_httpWrFilterSocketStreamCallBack(HTTPWriteFilter *this, __CFWriteStream *a2, uint64_t a3, void *a4)
{
  int v7 = (const void *)(a3 - 16);
  CFRetain((CFTypeRef)(a3 - 16));
  if (a2 == (__CFWriteStream *)4)
  {
    if (!HTTPWriteFilter::socketStreamCanWrite((HTTPWriteFilter *)a3)) {
      goto LABEL_33;
    }
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    __int16 v11 = (CoreStreamBase *)a3;
    uint64_t v12 = 4;
  }
  else
  {
    if (a2 == (__CFWriteStream *)8)
    {
      CFStreamError Error = CFWriteStreamGetError(this);
      CFIndex domain = Error.domain;
      unint64_t v10 = *(void *)&Error.error;
      pthread_mutex_lock((pthread_mutex_t *)(a3 + 136));
      if ((*(_WORD *)(a3 + 224) & 0x10) == 0)
      {
        if ((*(_WORD *)(a3 + 224) & 0x100) == 0)
        {
          if ((*(_WORD *)(a3 + 224) & 0x200) != 0)
          {
            unint64_t v10 = (*(void *)&Error.error & 0xFFFFFFFF00000000 | 0xFFFFF7CE) + 4;
            CFIndex domain = 4;
          }
          goto LABEL_29;
        }
        char v14 = *(__CFWriteStream **)(a3 + 208);
        if (v14
          && (BOOL v15 = (__CFHTTPMessage *)CFWriteStreamCopyProperty(v14, (CFStreamPropertyKey)&unk_1EC0A5720)) != 0)
        {
          BOOL v16 = v15;
          CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v15);
          CFRelease(v16);
          if (ResponseStatusCode == 200) {
            goto LABEL_29;
          }
        }
        else
        {
          CFIndex ResponseStatusCode = 500;
        }
        if (!*(void *)(a3 + 248))
        {
          uint64_t v18 = *(const void **)(a3 + 256);
          if (v18) {
            CFRelease(v18);
          }
          *(void *)(a3 + 256) = 0;
          *(_WORD *)(a3 + 224) |= 0x10u;
        }
        if (ResponseStatusCode == 407)
        {
          *(_WORD *)(a3 + 224) |= 0x20u;
        }
        else
        {
          uint64_t v19 = 4294965198;
          *(_WORD *)(a3 + 224) |= 0x40u;
          if ((unint64_t)(ResponseStatusCode - 300) > 0x63) {
            uint64_t v19 = 4294965200;
          }
          unint64_t v10 = *(void *)&Error.error & 0xFFFFFFFF00000000 | v19;
          CFIndex domain = 4;
        }
      }
LABEL_29:
      pthread_mutex_unlock((pthread_mutex_t *)(a3 + 136));
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      __int16 v11 = (CoreStreamBase *)a3;
      uint64_t v12 = 8;
      v13.CFIndex domain = domain;
      *(void *)&v13.error = v10;
      goto LABEL_32;
    }
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    __int16 v11 = (CoreStreamBase *)a3;
    uint64_t v12 = (uint64_t)a2;
  }
  v13.CFIndex domain = 0;
  *(void *)&v13.error = 0;
LABEL_32:
  CoreStreamBase::_signalEvent(v11, v12, v13, 1);
LABEL_33:

  CFRelease(v7);
}

CFTypeRef non-virtual thunk to'HTTPWriteFilter::_streamImpl_CopyProperty(HTTPWriteFilter *this, const __CFString *a2)
{
  return HTTPWriteFilter::_streamImpl_CopyProperty((HTTPWriteFilter *)((char *)this - 120), a2);
}

CFTypeRef HTTPWriteFilter::_streamImpl_CopyProperty(HTTPWriteFilter *this, const __CFString *a2)
{
  int v4 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  int ExactString = _findExactString(a2, 0);
  if (ExactString <= 404035005)
  {
    if (ExactString <= 395834626)
    {
      if (ExactString == 224669676)
      {
        if ((*((_WORD *)this + 112) & 0x108) == 8) {
          goto LABEL_29;
        }
        int v7 = (const void *)*((void *)this + 33);
        if (!v7) {
          goto LABEL_39;
        }
      }
      else
      {
        if (ExactString != 228814903 || (*((_WORD *)this + 112) & 0x108) == 8) {
          goto LABEL_29;
        }
        int v7 = (const void *)*((void *)this + 34);
        if (!v7) {
          goto LABEL_39;
        }
      }
LABEL_36:
      CFTypeRef v9 = CFRetain(v7);
      goto LABEL_37;
    }
    if (ExactString != 395834627)
    {
      if (ExactString != 402920877) {
        goto LABEL_29;
      }
      if ((*((_WORD *)this + 112) & 0x400) == 0) {
        goto LABEL_34;
      }
      goto LABEL_32;
    }
    if (*((__int16 *)this + 112) < 0) {
      goto LABEL_32;
    }
LABEL_34:
    unint64_t v10 = (const void **)MEMORY[0x1E4F1CFC8];
LABEL_35:
    int v7 = *v10;
    if (!*v10) {
      goto LABEL_39;
    }
    goto LABEL_36;
  }
  if (ExactString <= 408311312)
  {
    if (ExactString != 404035006)
    {
      if (ExactString != 406091238) {
        goto LABEL_29;
      }
      int v7 = (const void *)*((void *)this + 26);
      if (!v7) {
        goto LABEL_39;
      }
      goto LABEL_36;
    }
    if ((*((_WORD *)this + 112) & 0x40) != 0) {
      goto LABEL_32;
    }
    goto LABEL_34;
  }
  if (ExactString == 408311313)
  {
    if ((*((_WORD *)this + 112) & 0x4000) == 0) {
      goto LABEL_34;
    }
LABEL_32:
    unint64_t v10 = (const void **)MEMORY[0x1E4F1CFD0];
    goto LABEL_35;
  }
  if (ExactString == 444831706 || ExactString == 446986240)
  {
    uint64_t v6 = *((void *)this + 27);
    if (!v6) {
      goto LABEL_39;
    }
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*(unsigned char *)(v6 + 40)) {
      goto LABEL_39;
    }
    int v7 = (const void *)*((void *)this + 27);
    if (!v7) {
      goto LABEL_39;
    }
    goto LABEL_36;
  }
LABEL_29:
  uint64_t v8 = (__CFWriteStream *)*((void *)this + 26);
  if (!v8)
  {
LABEL_39:
    CFTypeRef v11 = 0;
    goto LABEL_40;
  }
  CFTypeRef v9 = CFWriteStreamCopyProperty(v8, a2);
LABEL_37:
  CFTypeRef v11 = v9;
LABEL_40:
  pthread_mutex_unlock(v4);
  return v11;
}

unint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_SetProperty(HTTPWriteFilter *this, const __CFString *a2, unint64_t a3)
{
  return HTTPWriteFilter::_streamImpl_SetProperty((HTTPWriteFilter *)((char *)this - 120), a2, a3);
}

unint64_t HTTPWriteFilter::_streamImpl_SetProperty(HTTPWriteFilter *this, const __CFString *a2, unint64_t a3)
{
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  int ExactString = _findExactString(a2, 0);
  if (ExactString <= 401864092)
  {
    if (ExactString > 231968870)
    {
      if (ExactString != 231968871)
      {
        if (ExactString == 395834627)
        {
          __int16 v23 = *((_WORD *)this + 112);
          if (*MEMORY[0x1E4F1CFD0] == a3) {
            __int16 v12 = v23 | 0x8000;
          }
          else {
            __int16 v12 = v23 & 0x7FFF;
          }
          goto LABEL_73;
        }
        if (ExactString == 401003905)
        {
          unint64_t v10 = (const void *)*((void *)this + 29);
          if (v10) {
            _Block_release(v10);
          }
          if (a3) {
            CFTypeRef v11 = _Block_copy((const void *)a3);
          }
          else {
            CFTypeRef v11 = 0;
          }
          *((void *)this + 29) = v11;
          goto LABEL_74;
        }
        goto LABEL_64;
      }
      CFTypeID v20 = CFGetTypeID((CFTypeRef)a3);
      if (v20 != CFDictionaryGetTypeID()) {
        goto LABEL_66;
      }
      if ((*((_WORD *)this + 112) & 0x108) == 8) {
        goto LABEL_74;
      }
      CFIndex v21 = (const void *)*((void *)this + 35);
      if (v21 != (const void *)a3)
      {
        if (v21) {
          CFRelease(v21);
        }
        if (a3) {
          CFTypeRef v22 = CFRetain((CFTypeRef)a3);
        }
        else {
          CFTypeRef v22 = 0;
        }
        *((void *)this + 35) = v22;
      }
      BOOL v42 = (const void *)*((void *)this + 33);
      *((void *)this + 33) = 0;
      if (v42) {
        CFRelease(v42);
      }
      uint64_t v41 = (const void *)*((void *)this + 34);
      *((void *)this + 34) = 0;
      if (!v41) {
        goto LABEL_74;
      }
LABEL_107:
      CFRelease(v41);
      goto LABEL_74;
    }
    if (ExactString == 224669676)
    {
      CFTypeID v26 = CFGetTypeID((CFTypeRef)a3);
      if (v26 != CFDataGetTypeID()) {
        goto LABEL_66;
      }
      if ((*((_WORD *)this + 112) & 0x108) != 8)
      {
        uint64_t v27 = (const void *)*((void *)this + 33);
        if (v27 != (const void *)a3)
        {
          if (v27) {
            CFRelease(v27);
          }
          if (a3) {
            CFTypeRef v28 = CFRetain((CFTypeRef)a3);
          }
          else {
            CFTypeRef v28 = 0;
          }
          *((void *)this + 33) = v28;
        }
        uint64_t v40 = (const void *)*((void *)this + 34);
        *((void *)this + 34) = 0;
        if (v40) {
          goto LABEL_99;
        }
        goto LABEL_100;
      }
    }
    else
    {
      if (ExactString != 228814903) {
        goto LABEL_64;
      }
      CFTypeID v13 = CFGetTypeID((CFTypeRef)a3);
      if (v13 != SSLContextGetTypeID()) {
        goto LABEL_66;
      }
      if ((*((_WORD *)this + 112) & 0x108) != 8)
      {
        char v14 = (const void *)*((void *)this + 34);
        if (v14 != (const void *)a3)
        {
          if (v14) {
            CFRelease(v14);
          }
          if (a3) {
            CFTypeRef v15 = CFRetain((CFTypeRef)a3);
          }
          else {
            CFTypeRef v15 = 0;
          }
          *((void *)this + 34) = v15;
        }
        uint64_t v40 = (const void *)*((void *)this + 33);
        *((void *)this + 33) = 0;
        if (v40) {
LABEL_99:
        }
          CFRelease(v40);
LABEL_100:
        uint64_t v41 = (const void *)*((void *)this + 35);
        *((void *)this + 35) = 0;
        if (!v41) {
          goto LABEL_74;
        }
        goto LABEL_107;
      }
    }
LABEL_74:
    a3 = 1;
    goto LABEL_75;
  }
  if (ExactString > 407246327)
  {
    switch(ExactString)
    {
      case 407246328:
        __int16 v24 = *((_WORD *)this + 112);
        if (*MEMORY[0x1E4F1CFD0] == a3) {
          __int16 v12 = v24 | 0x1000;
        }
        else {
          __int16 v12 = v24 & 0xEFFF;
        }
        goto LABEL_73;
      case 408311313:
        __int16 v25 = *((_WORD *)this + 112);
        if (*MEMORY[0x1E4F1CFD0] == a3) {
          __int16 v12 = v25 | 0x4000;
        }
        else {
          __int16 v12 = v25 & 0xBFFF;
        }
        goto LABEL_73;
      case 558087215:
        if (*(unsigned char *)(*((void *)this + 25) + 251))
        {
          __int16 v12 = *((_WORD *)this + 112) & 0xFFCF;
LABEL_73:
          *((_WORD *)this + 112) = v12;
          goto LABEL_74;
        }
        goto LABEL_66;
    }
LABEL_64:
    uint64_t v29 = (__CFWriteStream *)*((void *)this + 26);
    if (v29)
    {
      a3 = CFWriteStreamSetProperty(v29, a2, (CFTypeRef)a3);
      goto LABEL_75;
    }
    goto LABEL_66;
  }
  if (ExactString == 401864093)
  {
    CFTypeID v16 = CFGetTypeID((CFTypeRef)a3);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (v16 == *(void *)(HTTPMessage::Class(void)::sClass_OBJTYPE + 96) && *((void *)this + 26))
    {
      CFIndex v17 = (const void *)*((void *)this + 27);
      if (!v17)
      {
        if (!a3) {
          goto LABEL_81;
        }
        goto LABEL_79;
      }
      if ((~*((unsigned __int16 *)this + 112) & 0x401) == 0)
      {
        if (v17 == (const void *)a3) {
          goto LABEL_81;
        }
        CFRelease(v17);
        if (!a3)
        {
          CFTypeRef v18 = 0;
LABEL_80:
          *((void *)this + 27) = v18;
LABEL_81:
          *((void *)this + 30) = 0;
          *((void *)this + 31) = 0;
          int64_t v31 = (const void *)*((void *)this + 32);
          if (v31)
          {
            CFRelease(v31);
            *((void *)this + 32) = 0;
          }
          __int16 v32 = *((_WORD *)this + 112);
          *((_WORD *)this + 112) = v32 & 0xFF2C;
          if ((v32 & 0xA00) != 0 && CFHTTPMessageIsRequest(*((CFHTTPMessageRef *)this + 27)))
          {
            CFURLRef v33 = CFHTTPMessageCopyRequestURL(*((CFHTTPMessageRef *)this + 27));
            CFStringRef v34 = CFURLCopyScheme(v33);
            if (v33) {
              CFRelease(v33);
            }
            if (CFStringCompare(v34, (CFStringRef)&unk_1EC0A5D78, 1uLL) == kCFCompareEqualTo) {
              HTTPWriteFilter::prepareHTTPSProxy(this);
            }
            if (v34) {
              CFRelease(v34);
            }
          }
          __int16 v35 = *((_WORD *)this + 112);
          if ((v35 & 8) != 0) {
            goto LABEL_122;
          }
          *((_WORD *)this + 112) = v35 | 8;
          if ((v35 & 0x100) != 0) {
            goto LABEL_122;
          }
          CFIndex v36 = (const void *)*((void *)this + 34);
          if (v36)
          {
            int v37 = (char *)this + 272;
            uint64_t v38 = (__CFWriteStream *)*((void *)this + 26);
            if (v38)
            {
              unsigned int v39 = (CFStreamPropertyKey *)&kCFStreamPropertySSLContext;
              goto LABEL_118;
            }
LABEL_120:
            *(void *)int v37 = 0;
LABEL_121:
            CFRelease(v36);
            goto LABEL_122;
          }
          CFIndex v36 = (const void *)*((void *)this + 33);
          if (v36)
          {
            int v37 = (char *)this + 264;
            uint64_t v38 = (__CFWriteStream *)*((void *)this + 26);
            if (!v38) {
              goto LABEL_120;
            }
            unsigned int v39 = (CFStreamPropertyKey *)&kCFStreamPropertySocketSSLContext;
          }
          else
          {
            CFIndex v36 = (const void *)*((void *)this + 35);
            if (!v36)
            {
LABEL_122:
              int64_t v43 = (__CFWriteStream *)*((void *)this + 26);
              if (v43 && CFWriteStreamCanAcceptBytes(v43)) {
                HTTPWriteFilter::transmitHeader(this, 0);
              }
              goto LABEL_74;
            }
            int v37 = (char *)this + 280;
            uint64_t v38 = (__CFWriteStream *)*((void *)this + 26);
            if (!v38) {
              goto LABEL_120;
            }
            unsigned int v39 = (CFStreamPropertyKey *)&kCFStreamPropertySSLSettings;
          }
LABEL_118:
          CFWriteStreamSetProperty(v38, *v39, v36);
          CFIndex v36 = *(const void **)v37;
          *(void *)int v37 = 0;
          if (!v36) {
            goto LABEL_122;
          }
          goto LABEL_121;
        }
LABEL_79:
        CFTypeRef v18 = CFRetain((CFTypeRef)a3);
        goto LABEL_80;
      }
    }
LABEL_66:
    a3 = 0;
    goto LABEL_75;
  }
  if (ExactString == 402920877)
  {
    __int16 v19 = *((_WORD *)this + 112);
    if (*MEMORY[0x1E4F1CFD0] == a3) {
      __int16 v12 = v19 | 0x400;
    }
    else {
      __int16 v12 = v19 & 0xFBFF;
    }
    goto LABEL_73;
  }
  if (ExactString != 406091238) {
    goto LABEL_64;
  }
  uint64_t v8 = (const void *)*((void *)this + 26);
  if (v8 != (const void *)a3)
  {
    *((void *)this + 26) = 0;
    if (v8) {
      CFRelease(v8);
    }
  }
  if (a3)
  {
    CFTypeRef v9 = CFRetain((CFTypeRef)a3);
    a3 = 0;
    *((void *)this + 26) = v9;
  }
LABEL_75:
  pthread_mutex_unlock(v6);
  if (*((void *)this + 36))
  {
    (*(void (**)(void))(**((void **)this + 25) + 216))(*((void *)this + 25));
    *((void *)this + 36) = 0;
  }
  return a3;
}

void HTTPWriteFilter::prepareHTTPSProxy(HTTPWriteFilter *this)
{
  uint64_t v2 = *((void *)this + 27);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (v2) {
    uint64_t v3 = (HTTPMessage *)(v2 + 16);
  }
  else {
    uint64_t v3 = 0;
  }
  CFStringRef v4 = HTTPMessage::copyHeaderFieldValue(v3, 0x1382736Bu);
  if (v4)
  {
    CFStringRef v5 = v4;
    uint64_t v6 = *((void *)this + 27);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (v6) {
      int v7 = (HTTPMessage *)(v6 + 16);
    }
    else {
      int v7 = 0;
    }
    HTTPMessage::removeHeaderFieldValue(v7, 0x1382736Bu);
    CFRelease(v5);
  }
  if ((*((_WORD *)this + 112) & 0x800) == 0) {
    *((_WORD *)this + 112) = *((_WORD *)this + 112) & 0xF4FF | 0x900;
  }
}

CFStringRef HTTPReadStream::copyDebugSummary(HTTPReadStream *this)
{
  uint64_t v2 = (__CFReadStream *)*((void *)this + 1);
  if (v2)
  {
    uint64_t v3 = "NotOpen";
    switch(CFReadStreamGetStatus(v2))
    {
      case kCFStreamStatusNotOpen:
        goto LABEL_13;
      case kCFStreamStatusOpening:
        uint64_t v3 = "Opening";
        goto LABEL_13;
      case kCFStreamStatusOpen:
        uint64_t v3 = "Open";
        goto LABEL_13;
      case kCFStreamStatusReading:
        uint64_t v3 = "Reading";
        goto LABEL_13;
      case kCFStreamStatusWriting:
        uint64_t v3 = "Writing";
        goto LABEL_13;
      case kCFStreamStatusAtEnd:
        uint64_t v3 = "AtEnd";
        goto LABEL_13;
      case kCFStreamStatusClosed:
        uint64_t v3 = "Closed";
        goto LABEL_13;
      case kCFStreamStatusError:
        CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*((void *)this + 1));
        CFAllocatorRef v7 = CFGetAllocator(*((CFTypeRef *)this + 1));
        return CFStringCreateWithFormat(v7, 0, @"read stream error { %ld, %d }", Error.domain, *(void *)&Error.error);
      default:
        uint64_t v3 = "?";
LABEL_13:
        CFAllocatorRef v5 = CFGetAllocator(*((CFTypeRef *)this + 1));
        CFStringRef result = CFStringCreateWithFormat(v5, 0, @"read stream status %s", v3);
        break;
    }
  }
  else
  {
    return (CFStringRef)CFRetain(@"null response stream");
  }
  return result;
}

CFStringRef HTTPReadStream::copyDebugDesc(HTTPReadStream *this)
{
  CFURLRef v2 = (const __CFURL *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*((void *)this + 3) + 128));
  CFAllocatorRef v3 = CFGetAllocator(*((CFTypeRef *)this + 1));
  CFStringRef v4 = CFURLGetString(v2);
  return CFStringCreateWithFormat(v3, 0, @"<HTTP request stream %p>{url = %@, flags=%p, connection stream = %p}", this, v4, (char *)this + 16, *((void *)this + 10));
}

void HTTPReadStream::_streamImpl_deprecated_Unschedule(HTTPReadStream *this, __CFReadStream *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  uint64_t v7 = *((void *)this + 18);
  if (v7) {
    *((void *)this + 18) = (*(uint64_t (**)(uint64_t, CFRunLoopRef, CFRunLoopMode))(*(void *)v7 + 64))(v7, rl, mode);
  }
  if ((*((_WORD *)this + 8) & 4) != 0)
  {
    CFTypeRef v9 = (__CFRunLoopSource *)*((void *)this + 14);
    CFRunLoopRemoveSource(rl, v9, mode);
  }
  else
  {
    uint64_t v8 = (__CFReadStream *)*((void *)this + 10);
    if (v8)
    {
      CFReadStreamUnscheduleFromRunLoop(v8, rl, mode);
    }
  }
}

void HTTPReadStream::_streamImpl_deprecated_Schedule(HTTPReadStream *this, __CFReadStream *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  uint64_t v7 = *((void *)this + 18);
  if (v7) {
    *((void *)this + 18) = (*(uint64_t (**)(uint64_t, CFRunLoopRef, CFRunLoopMode))(*(void *)v7 + 56))(v7, rl, mode);
  }
  if ((*((_WORD *)this + 8) & 4) != 0)
  {
    CFTypeRef v9 = (__CFRunLoopSource *)*((void *)this + 14);
    CFRunLoopAddSource(rl, v9, mode);
  }
  else
  {
    uint64_t v8 = (__CFReadStream *)*((void *)this + 10);
    if (v8)
    {
      CFReadStreamScheduleWithRunLoop(v8, rl, mode);
    }
  }
}

uint64_t HTTPReadStream::_streamImpl_SetProperty(CFReadStreamRef *this, __CFReadStream *a2, const __CFString *a3, const void *a4)
{
  valuePtr[7] = *MEMORY[0x1E4F143B8];
  if (CFReadStreamGetStatus(this[1]) > kCFStreamStatusNotOpen) {
    return 0;
  }
  int ExactString = _findExactString(a3, 0);
  uint64_t result = 0;
  if (ExactString <= 223645656)
  {
    if (ExactString > 104064895)
    {
      if (ExactString > 107284407)
      {
        if (ExactString == 107284408) {
          return result;
        }
        int v32 = 216338253;
      }
      else
      {
        if (ExactString == 104064896)
        {
          if (!a4) {
            goto LABEL_81;
          }
          CFTypeID v46 = CFGetTypeID(a4);
          if (v46 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            LOWORD(valuePtr[0]) = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
          }
          if ((const void *)*MEMORY[0x1E4F1CFD0] == a4) {
            __int16 v13 = *((_WORD *)this + 8) | 0x20;
          }
          else {
LABEL_81:
          }
            __int16 v13 = (_WORD)this[2] & 0xFFDF;
          goto LABEL_116;
        }
        int v32 = 106203045;
      }
    }
    else
    {
      if (ExactString <= 96814833)
      {
        if (ExactString == 83273191)
        {
          CFReadStreamRef v44 = this[9];
          if (v44) {
            _Block_release(v44);
          }
          if (a4) {
            CFIndex v45 = (__CFReadStream *)_Block_copy(a4);
          }
          else {
            CFIndex v45 = 0;
          }
          this[9] = v45;
          return 1;
        }
        if (ExactString == 90506882)
        {
          CFReadStreamRef v14 = this[8];
          if (v14) {
            _Block_release(v14);
          }
          if (a4) {
            CFTypeRef v15 = (__CFReadStream *)_Block_copy(a4);
          }
          else {
            CFTypeRef v15 = 0;
          }
          this[8] = v15;
          return 1;
        }
        goto LABEL_61;
      }
      if (ExactString == 96814834) {
        return result;
      }
      int v32 = 97904392;
    }
    if (ExactString == v32) {
      return result;
    }
LABEL_61:
    int v37 = this[6];
    if (a4) {
      CFDictionarySetValue(v37, a3, a4);
    }
    else {
      CFDictionaryRemoveValue(v37, a3);
    }
    return 1;
  }
  if (ExactString <= 442775482)
  {
    if (ExactString > 399906151)
    {
      if (ExactString == 399906152)
      {
        CFReadStreamRef v49 = this[7];
        if (v49) {
          _Block_release(v49);
        }
        if (a4) {
          unsigned int v50 = (__CFReadStream *)_Block_copy(a4);
        }
        else {
          unsigned int v50 = 0;
        }
        this[7] = v50;
        return 1;
      }
      if (ExactString == 439752578)
      {
        if (!a4) {
          goto LABEL_57;
        }
        CFTypeID v36 = CFGetTypeID(a4);
        if (v36 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr[0]) = 0;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
        }
        if ((const void *)*MEMORY[0x1E4F1CFD0] == a4) {
          __int16 v13 = *((_WORD *)this + 8) | 2;
        }
        else {
LABEL_57:
        }
          __int16 v13 = (_WORD)this[2] & 0xFFFD;
        goto LABEL_116;
      }
      goto LABEL_61;
    }
    if (ExactString == 223645657) {
      return result;
    }
    if (ExactString != 225669117) {
      goto LABEL_61;
    }
    if (a4)
    {
      CFTypeID v16 = CFGetTypeID(a4);
      if (v16 != CFDictionaryGetTypeID()) {
        return 0;
      }
      uint64_t v17 = 0;
      int v18 = 0;
      uint64_t v71 = 0;
      memset(v70, 0, sizeof(v70));
      uint64_t v69 = 0;
      uint64_t v19 = *MEMORY[0x1E4F1D468];
      valuePtr[0] = *MEMORY[0x1E4F1D460];
      valuePtr[1] = v19;
      uint64_t v20 = *MEMORY[0x1E4F1D470];
      valuePtr[2] = *MEMORY[0x1E4F1D478];
      valuePtr[3] = v20;
      valuePtr[4] = *MEMORY[0x1E4F1D450];
      valuePtr[5] = 0x1EC0A05F8;
      valuePtr[6] = *MEMORY[0x1E4F41EC8];
      memset(v68, 0, sizeof(v68));
      do
      {
        uint64_t v21 = valuePtr[v17];
        if (v21)
        {
          CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)a4, (const void *)valuePtr[v17]);
          if (Value)
          {
            *((void *)v70 + v18) = v21;
            *((void *)v68 + v18++) = Value;
          }
        }
        ++v17;
      }
      while (v17 != 7);
      uint64_t v23 = v18;
      CFReadStreamRef v24 = this[11];
      CFAllocatorRef v25 = CFGetAllocator(this[1]);
      CFAllocatorRef v26 = v25;
      if (v24 || !v18)
      {
        CFIndex Count = CFDictionaryGetCount(this[11]);
        MutableCFHTTPMessageRef Copy = CFDictionaryCreateMutableCopy(v26, Count + 4, this[11]);
        if (v18 >= 1)
        {
          CFStringRef v62 = (const void **)v68;
          int v63 = (const void **)v70;
          do
          {
            uint64_t v65 = *v63++;
            uint64_t v64 = v65;
            CFRange v66 = *v62++;
            CFDictionarySetValue(MutableCopy, v64, v66);
            --v23;
          }
          while (v23);
        }
        goto LABEL_120;
      }
      uint64_t v27 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      CFTypeRef v28 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      uint64_t v29 = (const void **)v70;
      uint64_t v30 = (const void **)v68;
      CFIndex v31 = v18;
      goto LABEL_113;
    }
    CFDictionaryRef v52 = this[11];
    if (!v52) {
      return 1;
    }
    CFStringRef v53 = (const void *)*MEMORY[0x1E4F1D460];
    if (!CFDictionaryGetValue(v52, (const void *)*MEMORY[0x1E4F1D460])) {
      return 1;
    }
    CFAllocatorRef v54 = CFGetAllocator(this[1]);
    CFIndex v55 = CFDictionaryGetCount(this[11]);
    MutableCFHTTPMessageRef Copy = CFDictionaryCreateMutableCopy(v54, v55, this[11]);
    CFDictionaryRemoveValue(MutableCopy, v53);
    CFStringRef v56 = (const void *)*MEMORY[0x1E4F1D468];
    uint64_t v57 = MutableCopy;
LABEL_103:
    CFDictionaryRemoveValue(v57, v56);
LABEL_120:
    CFReadStreamRef v67 = this[11];
    if (v67) {
      CFRelease(v67);
    }
    goto LABEL_122;
  }
  if (ExactString > 448067601)
  {
    if (ExactString != 457381991)
    {
      if (ExactString != 449148966)
      {
        if (ExactString == 448067602)
        {
          if (!a4) {
            goto LABEL_89;
          }
          CFTypeID v9 = CFGetTypeID(a4);
          if (v9 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            LOWORD(valuePtr[0]) = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
          }
          if ((const void *)*MEMORY[0x1E4F1CFC8] == a4)
          {
LABEL_89:
            CFReadStreamRef v51 = this[15];
            if (v51) {
              CFRelease(v51);
            }
            this[15] = 0;
            __int16 v13 = (_WORD)this[2] & 0xFFFE;
          }
          else
          {
            if (!this[15])
            {
              CFAllocatorRef v10 = CFGetAllocator(this[1]);
              Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x1E4F1D510]);
              this[15] = Mutable;
              __int16 v12 = (const void *)HTTPRequestParserClient::requestURL((CFReadStreamRef)((char *)this[3] + 128));
              CFArrayAppendValue(Mutable, v12);
            }
            __int16 v13 = *((_WORD *)this + 8) | 1;
          }
LABEL_116:
          *((_WORD *)this + 8) = v13;
          return 1;
        }
        goto LABEL_61;
      }
      if (a4)
      {
        CFTypeID v42 = CFGetTypeID(a4);
        if (v42 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr[0]) = 0;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
        }
        __int16 v43 = *((_WORD *)this + 8);
        if ((const void *)*MEMORY[0x1E4F1CFD0] == a4) {
          __int16 v13 = v43 | 0x100;
        }
        else {
          __int16 v13 = v43 & 0xFEFF;
        }
        goto LABEL_116;
      }
      return 0;
    }
    valuePtr[0] = a4;
    CFReadStreamRef v38 = this[11];
    if (a4)
    {
      CFAllocatorRef v25 = CFGetAllocator(this[1]);
      CFAllocatorRef v39 = v25;
      if (v38)
      {
        CFIndex v40 = CFDictionaryGetCount(this[11]);
        MutableCFHTTPMessageRef Copy = CFDictionaryCreateMutableCopy(v39, v40 + 1, this[11]);
        CFDictionarySetValue(MutableCopy, &unk_1EC0A4178, a4);
        goto LABEL_120;
      }
      uint64_t v29 = (const void **)&_kCFStreamPropertyHTTPProxyProxyAutoConfigURLString;
      uint64_t v27 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
      CFTypeRef v28 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
      uint64_t v30 = (const void **)valuePtr;
      CFIndex v31 = 1;
LABEL_113:
      MutableCFHTTPMessageRef Copy = CFDictionaryCreate(v25, v29, v30, v31, v27, v28);
LABEL_122:
      this[11] = MutableCopy;
      return 1;
    }
    if (!v38 || !CFDictionaryGetValue(this[11], &unk_1EC0A4178)) {
      return 1;
    }
    CFAllocatorRef v59 = CFGetAllocator(this[1]);
    CFIndex v60 = CFDictionaryGetCount(this[11]);
    uint64_t v57 = CFDictionaryCreateMutableCopy(v59, v60, this[11]);
    MutableCFHTTPMessageRef Copy = v57;
    CFStringRef v56 = &unk_1EC0A4178;
    goto LABEL_103;
  }
  if (ExactString != 442775483)
  {
    if (ExactString != 443766732) {
      goto LABEL_61;
    }
    if (!a4)
    {
      CFReadStreamRef v58 = this[11];
      if (v58) {
        CFRelease(v58);
      }
      this[11] = 0;
      return 1;
    }
    CFTypeID v33 = CFGetTypeID(a4);
    if (v33 == CFDictionaryGetTypeID())
    {
      CFReadStreamRef v34 = this[11];
      if (v34) {
        CFRelease(v34);
      }
      CFAllocatorRef v35 = CFGetAllocator(this[1]);
      this[11] = CFDictionaryCreateCopy(v35, (CFDictionaryRef)a4);
      return 1;
    }
    return 0;
  }
  if (a4)
  {
    CFTypeID v47 = CFGetTypeID(a4);
    if (v47 != CFNumberGetTypeID()) {
      return 0;
    }
    valuePtr[0] = 0;
    CFNumberGetValue((CFNumberRef)a4, kCFNumberCFIndexType, valuePtr);
    uint64_t v48 = valuePtr[0];
  }
  else
  {
    uint64_t v48 = 20;
  }
  this[16] = (CFReadStreamRef)v48;
  return 1;
}

CFTypeRef HTTPReadStream::_streamImpl_CopyProperty(HTTPReadStream *this, __CFReadStream *a2, CFStringRef theString)
{
  int ExactString = _findExactString(theString, 8u);
  if (ExactString > 442775482)
  {
    if (ExactString == 442775483)
    {
      AutoScalar::AutoScalar((AutoScalar *)&v12, (const __CFAllocator *)*((unsigned int *)this + 32));
      if (cf)
      {
        CFTypeRef v9 = CFRetain(cf);
        __int16 v12 = &unk_1ECF9A500;
        if (cf) {
          CFRelease(cf);
        }
      }
      else
      {
        CFTypeRef v9 = 0;
        __int16 v12 = &unk_1ECF9A500;
      }
      return v9;
    }
    if (ExactString != 443766732)
    {
      if (ExactString != 448067602) {
        goto LABEL_24;
      }
      uint64_t v8 = (const void **)MEMORY[0x1E4F1CFD0];
      if ((*((_WORD *)this + 8) & 1) == 0) {
        uint64_t v8 = (const void **)MEMORY[0x1E4F1CFC8];
      }
      uint64_t v7 = *v8;
      if (!*v8) {
        return 0;
      }
LABEL_21:
      return CFRetain(v7);
    }
    uint64_t v7 = (const void *)*((void *)this + 11);
    if (v7) {
      goto LABEL_21;
    }
    return 0;
  }
  switch(ExactString)
  {
    case 438523764:
      return 0;
    case 440678299:
      uint64_t v7 = (const void *)(*((void *)this + 4) - 16);
      goto LABEL_21;
    case 441694124:
      uint64_t v6 = *((void *)this + 4);
      if (!v6) {
        uint64_t v6 = *((void *)this + 3);
      }
      uint64_t v7 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(v6 + 128));
      if (!v7) {
        return 0;
      }
      goto LABEL_21;
  }
LABEL_24:
  CFTypeRef v11 = (__CFReadStream *)*((void *)this + 10);
  if (!v11) {
    return 0;
  }

  return CFReadStreamCopyProperty(v11, theString);
}

void sub_1842058B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void HTTPReadStream::_streamImpl_Close(__CFRunLoopSource **this, __CFReadStream *a2)
{
  if (this[10]) {
    HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 1);
  }
  __int16 v3 = *((_WORD *)this + 8);
  if ((v3 & 4) != 0)
  {
    CFStringRef v4 = this[14];
    if (v4)
    {
      CFRunLoopSourceInvalidate(v4);
      CFAllocatorRef v5 = this[14];
      if (v5) {
        CFRelease(v5);
      }
      this[14] = 0;
      __int16 v3 = *((_WORD *)this + 8);
    }
    *((_WORD *)this + 8) = v3 & 0xFFFB;
  }
}

void HTTPReadStream::dequeueRequestFromConnection(HTTPReadStream *this, int a2)
{
  CFURLRef v2 = (__CFReadStream *)*((void *)this + 10);
  if (!v2) {
    return;
  }
  if ((*((_WORD *)this + 8) & 2) == 0)
  {
    CFReadStreamSetClient(*((CFReadStreamRef *)this + 10), 0, 0, 0);
    if (a2)
    {
      CFAllocatorRef v5 = (__CFReadStream *)*((void *)this + 10);
      CFReadStreamClose(v5);
    }
    else
    {
      CFReadStreamClose(v2);
      CFRelease(v2);
      *((void *)this + 10) = 0;
    }
    return;
  }
  uint64_t InfoPointer = CFReadStreamGetInfoPointer();
  uint64_t v7 = *(void *)(InfoPointer + 128);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    uint64_t v8 = *(void *)(InfoPointer + 128);
  }
  else
  {
    uint64_t v8 = 0;
  }
  CFTypeRef v9 = (__CFReadStream *)*((void *)this + 10);
  if (a2)
  {
    if (v9)
    {
      CFReadStreamClose(*((CFReadStreamRef *)this + 10));
      CFReadStreamSetClient(*((CFReadStreamRef *)this + 10), 0, 0, 0);
    }
    if (v8) {
      goto LABEL_15;
    }
  }
  else
  {
    if (v9)
    {
      CFReadStreamSetClient(*((CFReadStreamRef *)this + 10), 0, 0, 0);
      CFReadStreamClose(v9);
      CFRelease(v9);
    }
    *((void *)this + 10) = 0;
    if (v8)
    {
LABEL_15:
      if (!NetConnection::willEnqueueRequests((NetConnection *)v8)) {
        goto LABEL_33;
      }
      uint64_t v10 = *(void *)(v8 + 96);
      if (v10) {
        pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
      }
      CFTypeRef v11 = (void *)(v8 + 136);
      do
        CFTypeRef v11 = (void *)*v11;
      while (v11
           && (*(unsigned int (**)(uint64_t, void, void))(*(void *)v8 + 168))(v8, _checkIsZombie, v11[1]));
      uint64_t v12 = *(void *)(v8 + 96);
      if (v12) {
        pthread_mutex_unlock((pthread_mutex_t *)(v12 + 8));
      }
      uint64_t v13 = *((void *)this + 4);
      CFReadStreamRef v14 = *(_CFHTTPAuthentication **)(v13 + 72);
      if (v14)
      {
        if (!_CFHTTPAuthenticationRequiresPersistentConnection(*(CFHTTPAuthenticationRef *)(v13 + 72))) {
          CFReadStreamRef v14 = 0;
        }
        uint64_t v13 = *((void *)this + 4);
      }
      CFTypeRef v15 = *(_CFHTTPAuthentication **)(v13 + 80);
      if (v15 && !_CFHTTPAuthenticationRequiresPersistentConnection(*(CFHTTPAuthenticationRef *)(v13 + 80))) {
        CFTypeRef v15 = 0;
      }
      if (!v14 && !v15 && !v11 || v14 && !CFHTTPAuthenticationIsValid(v14, 0)) {
        goto LABEL_33;
      }
      if (v15)
      {
        int IsValid = CFHTTPAuthenticationIsValid(v15, 0);
        if (!IsValid || v11)
        {
          if (!IsValid)
          {
LABEL_33:
            uint64_t v16 = *(void *)(v8 + 96);
            if (v16) {
              pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
            }
            *(_WORD *)(v8 + 88) &= ~1u;
            NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v8);
            uint64_t v17 = *(void *)(v8 + 96);
            if (v17) {
              pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
            }
            if (getNetConnectionCache(void)::sOnce != -1) {
              dispatch_once(&getNetConnectionCache(void)::sOnce, &__block_literal_global_42_6645);
            }
            uint64_t v18 = getNetConnectionCache(void)::gHTTPConnectionCache;
            uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 80))(v8);
            uint64_t v20 = *(NetConnectionCache **)(v8 + 8);
            CFStringRef v21 = (const __CFString *)(*(uint64_t (**)(void))(**(void **)(v19 + 272) + 72))(*(void *)(v19 + 272));
            CFStringRef v22 = (const __CFString *)(*(uint64_t (**)(void))(**(void **)(v19 + 272) + 80))(*(void *)(v19 + 272));
            int v23 = (*(uint64_t (**)(void))(**(void **)(v19 + 272) + 88))(*(void *)(v19 + 272));
            CFDictionaryRef v24 = (const __CFDictionary *)(*(uint64_t (**)(void))(**(void **)(v19 + 272) + 64))(*(void *)(v19 + 272));
            Key = NetConnectionCache::createKey(v20, v21, v22, v23, v24, v25);
            if (Key)
            {
              uint64_t v27 = Key;
              os_unfair_lock_lock((os_unfair_lock_t)(v18 + 8));
              CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v18 + 16), v27);
              if (Value) {
                BOOL v29 = Value == (const void *)v8;
              }
              else {
                BOOL v29 = 0;
              }
              if (v29)
              {
                uint64_t v30 = *(void *)(v8 + 96);
                if (v30) {
                  pthread_mutex_lock((pthread_mutex_t *)(v30 + 8));
                }
                *(_WORD *)(v8 + 88) &= ~1u;
                NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v8);
                uint64_t v31 = *(void *)(v8 + 96);
                if (v31) {
                  pthread_mutex_unlock((pthread_mutex_t *)(v31 + 8));
                }
                CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v18 + 16), v27);
              }
              os_unfair_lock_unlock((os_unfair_lock_t)(v18 + 8));
              (*(void (**)(CFAllocatedReferenceCountedObject *))(*(void *)v27 + 48))(v27);
            }
          }
LABEL_51:
          int v32 = *(void (**)(uint64_t))(*(void *)v8 + 48);
          v32(v8);
          return;
        }
      }
      else if (v11)
      {
        goto LABEL_51;
      }
      if (!v14
        || (CFReadStreamRef v34 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 80))(v8),
            _CFHTTPAuthenticationConnectionAuthenticated(v14, v34)))
      {
        if (!v15) {
          goto LABEL_33;
        }
        CFAllocatorRef v35 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 80))(v8);
        if (_CFHTTPAuthenticationConnectionAuthenticated(v15, v35)) {
          goto LABEL_33;
        }
      }
      goto LABEL_51;
    }
  }
}

CFAllocatedReferenceCountedObject *NetConnectionCache::createKey(NetConnectionCache *this, const __CFString *a2, const __CFString *a3, int a4, const __CFDictionary *a5, const __CFDictionary *a6)
{
  if (!a2) {
    return 0;
  }
  int v8 = (int)a3;
  CFTypeRef v11 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate(this, 48, 0);
  *(_OWORD *)CFTypeRef v11 = 0u;
  *((_OWORD *)v11 + 1) = 0u;
  *((_OWORD *)v11 + 2) = 0u;
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v11, this);
  void *v12 = &unk_1ECFA5D58;
  CFHTTPMessageRef Copy = (AutoDict *)CFStringCreateCopy(this, a2);
  *((void *)v11 + 3) = Copy;
  *((_DWORD *)v11 + 8) = v8;
  *((_DWORD *)v11 + 9) = a4;
  if (a5)
  {
    CFDictionaryRef EmptyDict = CFDictionaryCreateCopy(this, a5);
  }
  else
  {
    CFDictionaryRef EmptyDict = (const void *)AutoDict::getEmptyDict(Copy);
    if (EmptyDict) {
      CFDictionaryRef EmptyDict = CFRetain(EmptyDict);
    }
  }
  *((void *)v11 + 5) = EmptyDict;
  return v11;
}

void ___ZL21getNetConnectionCachev_block_invoke()
{
}

void sub_184205F8C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10A1C406B6A53AFLL);
  _Unwind_Resume(a1);
}

uint64_t _checkIsZombie(unsigned __int8 *a1, NetConnection *a2, const void *a3)
{
  return (a1[32] >> 2) & 1;
}

uint64_t HTTPReadStream::_streamImpl_CanRead(HTTPReadStream *this, __CFReadStream *a2)
{
  v6.CFIndex domain = 0;
  *(void *)&v6.error = 0;
  __int16 v3 = (__CFReadStream *)*((void *)this + 10);
  if (!v3)
  {
    v6.CFIndex domain = 4;
    v6.error = -4;
    goto LABEL_9;
  }
  CFStreamStatus Status = CFReadStreamGetStatus(v3);
  if (Status < kCFStreamStatusOpen) {
    return 0;
  }
  if ((unint64_t)Status > kCFStreamStatusWriting) {
    return 1;
  }
  uint64_t result = CFReadStreamHasBytesAvailable(*((CFReadStreamRef *)this + 10));
  if (!result) {
    return result;
  }
  if ((*((_WORD *)this + 8) & 8) != 0) {
    return 1;
  }
  uint64_t result = HTTPReadStream::readHeader(this, &v6);
  if (v6.error)
  {
LABEL_9:
    CFReadStreamSignalEvent();
    return 0;
  }
  return result;
}

uint64_t HTTPReadStream::readHeader(HTTPReadStream *this, CFStreamError *a2)
{
  if (!*((void *)this + 10) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFTypeID v33 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "readHeader(): no stream to read from!", v33, 2u);
  }
  __int16 v4 = *((_WORD *)this + 8);
  *((_WORD *)this + 8) = v4 | 8;
  if ((v4 & 1) == 0) {
    return 1;
  }
  CFURLRef v5 = (const __CFURL *)CFReadStreamCopyProperty(*((CFReadStreamRef *)this + 10), @"kCFStreamPropertyHTTPResponseHeader");
  if (!v5)
  {
    if (CFReadStreamGetStatus(*((CFReadStreamRef *)this + 10)) == kCFStreamStatusError)
    {
      CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*((void *)this + 10));
      uint64_t result = 0;
      *a2 = Error;
      return result;
    }
    return 0;
  }
  CFURLRef v6 = v5;
  uint64_t v7 = *((void *)this + 3);
  CFStringRef v8 = *(const __CFString **)(v7 + 152);
  if (v8
    || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
    && (*(_WORD *)buf = 0,
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (CFStringRef v8 = *(const __CFString **)(v7 + 152)) != 0))
  {
    if (CFEqual(v8, (CFStringRef)&gConstantCFStringValueTable[2611])) {
      goto LABEL_49;
    }
  }
  CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v6);
  if (ResponseStatusCode == 304 || (unint64_t)(ResponseStatusCode - 400) <= 0xFFFFFFFFFFFFFF9BLL) {
    goto LABEL_49;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  CFStringRef v12 = HTTPMessage::copyHeaderFieldValue((CFURLRef)((char *)v6 + 16), 0x13011336u);
  CFRelease(v6);
  if (!v12) {
    return 1;
  }
  CFAllocatorRef v13 = CFGetAllocator(v6);
  CFArrayRef v14 = (const __CFArray *)*((void *)this + 15);
  if (v14 && CFArrayGetCount(v14) >= 1)
  {
    CFArrayRef v15 = (const __CFArray *)*((void *)this + 15);
    CFIndex Count = CFArrayGetCount(v15);
    CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v15, Count - 1);
  }
  else
  {
    CFURLRef ValueAtIndex = 0;
  }
  CFIndex location = CFStringFind(v12, @", ", 0).location;
  if (location == -1)
  {
    CFStringEncoding v20 = 134217984;
    CFIndex Length = CFStringGetLength(v12);
    CFStringRef v22 = (UInt8 *)malloc_type_malloc(Length + 1, 0xD80B8DDDuLL);
    if (CFStringGetCString(v12, (char *)v22, Length + 1, 0x8000100u)
      || (CFStringEncoding v20 = 513, CFStringGetCString(v12, (char *)v22, Length + 1, 0x201u)))
    {
      CFURLRef v6 = CFURLCreateAbsoluteURLWithBytes(v13, v22, Length, v20, ValueAtIndex, 1u);
    }
    else
    {
      CFURLRef v6 = 0;
    }
    free(v22);
  }
  else
  {
    v35.CFIndex length = location;
    v35.CFIndex location = 0;
    CFStringRef v19 = CFStringCreateWithSubstring(v13, v12, v35);
    CFURLRef v6 = CFURLCreateWithString(v13, v19, ValueAtIndex);
    if (v19) {
      CFRelease(v19);
    }
  }
  CFRelease(v12);
  if (!v6) {
    return 1;
  }
  CFArrayRef v23 = (const __CFArray *)*((void *)this + 15);
  if (v23 && CFArrayGetCount(v23) >= *((void *)this + 16))
  {
    a2->CFIndex domain = 4;
    a2->error = -2;
LABEL_49:
    CFRelease(v6);
    return 1;
  }
  CFGetAllocator((CFTypeRef)(*((void *)this + 4) - 16));
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  CFDictionaryRef v25 = (HTTPRequestMessage *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    CFDictionaryRef v25 = (HTTPRequestMessage *)(Instance + 16);
    *(void *)(Instance + 192) = 0;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  HTTPRequestMessage::HTTPRequestMessage(v25, *((const HTTPRequestMessage **)this + 4), v6);
  HTTPMessage::removeHeaderFieldValue(v26, (const __CFString *)&unk_1EC0A2310);
  uint64_t v27 = (__CFArray *)*((void *)this + 15);
  if (v27) {
    CFArrayAppendValue(v27, v6);
  }
  CFDictionaryRef v28 = (const __CFDictionary *)*((void *)this + 6);
  if (v28)
  {
    if (CFDictionaryContainsKey(v28, @"kCFStreamPropertySSLSettings"))
    {
      CFStringRef v29 = CFURLCopyScheme(v6);
      if (v29)
      {
        CFStringRef v30 = v29;
        if (CFStringCompare(v29, (CFStringRef)&unk_1EC0A5D78, 1uLL)) {
          CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 6), @"kCFStreamPropertySSLSettings");
        }
        CFRelease(v30);
      }
    }
  }
  CFRelease(v6);
  HTTPReadStream::dequeueRequestFromConnection(this, 0);
  CFRelease((CFTypeRef)(*((void *)this + 4) - 16));
  *((void *)this + 4) = v25;
  uint64_t v31 = (const void *)*((void *)this + 12);
  if (v31)
  {
    CFRelease(v31);
    *((void *)this + 12) = 0;
  }
  int v32 = HTTPReadStream::constructProxyList(this, a2);
  if (!a2->error)
  {
    if (v32) {
      return 0;
    }
    HTTPReadStream::startRequest(this, a2);
    if (!a2->error) {
      return 0;
    }
  }
  return 1;
}

uint64_t HTTPReadStream::constructProxyList(HTTPReadStream *this, CFStreamError *a2)
{
  __int16 v4 = (const void *)*((void *)this + 5);
  if (!v4) {
    __int16 v4 = (const void *)*((void *)this + 1);
  }
  CFAllocatorRef v5 = CFGetAllocator(v4);
  if (*((void *)this + 12) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf.version) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "constructProxyList(): proxy list already constructed!", (uint8_t *)&buf, 2u);
  }
  uint64_t v6 = *((void *)this + 4);
  if (!v6)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(buf.version) = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "constructproxyList(): no request!", (uint8_t *)&buf, 2u);
      uint64_t v6 = *((void *)this + 4);
    }
    else
    {
      uint64_t v6 = 0;
    }
  }
  uint64_t v7 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(v6 + 128));
  if (v7 && (CFURLRef v8 = (const __CFURL *)CFRetain(v7)) != 0)
  {
    CFURLRef v9 = v8;
    CFStringRef v10 = CFURLCopyScheme(v8);
    if (v10)
    {
      CFRelease(v10);
      *((_WORD *)this + 8) &= ~4u;
      CFDictionaryRef Value = (__CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 6), &unk_1EC0A0A20);
      CFArrayRef v12 = (const __CFArray *)__CFNetworkCopyProxiesForURLWithInterface(v9, *((__CFDictionary **)this + 11), Value);
      CFIndex Count = CFArrayGetCount(v12);
      MutableCFHTTPMessageRef Copy = CFArrayCreateMutableCopy(v5, Count, v12);
      if (v12) {
        CFRelease(v12);
      }
      if (MutableCopy)
      {
        if (!CFArrayGetCount(MutableCopy))
        {
          CFRelease(MutableCopy);
          uint64_t v21 = 0;
          a2->CFIndex domain = 4;
          a2->error = -1;
LABEL_34:
          CFRelease(v9);
          return v21;
        }
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(MutableCopy, 0);
        uint64_t v16 = CFDictionaryGetValue(ValueAtIndex, @"kCFProxyTypeKey");
        if (!CFEqual(@"kCFProxyTypeAutoConfigurationURL", v16))
        {
          uint64_t v17 = CFDictionaryGetValue(ValueAtIndex, @"kCFProxyTypeKey");
          if (!CFEqual(@"kCFProxyTypeAutoConfigurationJavaScript", v17))
          {
            uint64_t v21 = 0;
            *((void *)this + 12) = MutableCopy;
            goto LABEL_34;
          }
        }
        v32[0] = 0;
        v32[1] = this;
        memset(&v32[2], 0, 24);
        uint64_t v18 = (PAC *)CFDictionaryGetValue(ValueAtIndex, @"kCFProxyAutoConfigurationURLKey");
        CFStringRef v19 = (PAC *)CFDictionaryGetValue(ValueAtIndex, @"kCFProxyAutoConfigurationJavaScriptKey");
        if (!v19) {
          CFStringRef v19 = v18;
        }
        *((void *)this + 14) = PAC::CreatePACTicket(v19, v9, 0, 0, (const __CFString *)HTTPReadStream::_PACExecutionComplete, (void (*)(void *, const __CFArray *, __CFError *))v32, v20);
        CFArrayRemoveValueAtIndex(MutableCopy, 0);
        *((void *)this + 12) = MutableCopy;
        __int16 v22 = *((_WORD *)this + 8);
        *((_WORD *)this + 8) = v22 | 4;
        uint64_t v23 = *((void *)this + 18);
        if (v23 && *(_DWORD *)(v23 + 40))
        {
          *((_WORD *)this + 8) = v22 | 0x84;
          CFDictionaryRef v24 = (CFStringRef (__cdecl *)(const void *))*((void *)this + 14);
          buf.version = MEMORY[0x1E4F143A8];
          buf.info = (void *)3221225472;
          buf.retain = (const void *(__cdecl *)(const void *))___ZNK17CoreSchedulingSet14scheduleSourceEP17__CFRunLoopSource_block_invoke;
          buf.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
          buf.copyDescription = v24;
          CoreSchedulingSet::applyBlockWithPossibleEmulation(v23, &buf);
          uint64_t v21 = 1;
          goto LABEL_34;
        }
        buf.version = 0;
        buf.info = this;
        memset(&buf.retain, 0, 24);
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        CFAllocatorRef v26 = CFRunLoopTimerCreate(v5, Current + 60.0, -1.0, 0, 0, (CFRunLoopTimerCallBack)HTTPReadStream::_PACExecutionCompleteTimer, &buf);
        uint64_t v27 = CFRunLoopGetCurrent();
        CFRunLoopAddTimer(v27, v26, @"_kProxySupportSyncPACExecutionRunLoopMode");
        CFDictionaryRef v28 = CFRunLoopGetCurrent();
        CFRunLoopAddSource(v28, *((CFRunLoopSourceRef *)this + 14), @"_kProxySupportSyncPACExecutionRunLoopMode");
        while ((*((_WORD *)this + 8) & 4) != 0)
          CFRunLoopRunInMode(@"_kProxySupportSyncPACExecutionRunLoopMode", 1.0e10, 1u);
        CFRunLoopTimerInvalidate(v26);
        if (v26) {
          CFRelease(v26);
        }
        CFStringRef v29 = (__CFError *)*((void *)this + 13);
        if (v29)
        {
          a2->CFIndex domain = _CFStreamErrorFromCFError(v29);
          *(void *)&a2->error = v30;
        }
      }
      uint64_t v21 = 0;
      goto LABEL_34;
    }
    a2->CFIndex domain = 4;
    a2->error = -3;
    CFRelease(v9);
    return 0;
  }
  else
  {
    uint64_t v21 = 0;
    a2->CFIndex domain = 4;
    a2->error = -3;
  }
  return v21;
}

void HTTPReadStream::startRequest(HTTPReadStream *this, CFStreamError *a2)
{
  if (!*((void *)this + 4) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf.version) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "startRequest(): no current request!", (uint8_t *)&buf, 2u);
  }
  __int16 v4 = *((_WORD *)this + 8);
  if ((v4 & 4) != 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf.version) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "startRequest(): called while waiting for proxy info!", (uint8_t *)&buf, 2u);
    __int16 v4 = *((_WORD *)this + 8);
  }
  LOBYTE(v5) = v4 & 0xF7;
  *((_WORD *)this + 8) = v4 & 0xFFF7;
  if (*((void *)this + 10))
  {
    HTTPReadStream::dequeueRequestFromConnection(this, 0);
    __int16 v5 = *((_WORD *)this + 8);
  }
  if ((v5 & 2) == 0)
  {
    uint64_t v6 = *((void *)this + 4);
    uint64_t v7 = *(_CFHTTPAuthentication **)(v6 + 72);
    if (v7)
    {
      if (_CFHTTPAuthenticationRequiresPersistentConnection(v7))
      {
LABEL_15:
        *((_WORD *)this + 8) |= 2u;
        goto LABEL_16;
      }
      uint64_t v6 = *((void *)this + 4);
    }
    CFURLRef v8 = *(_CFHTTPAuthentication **)(v6 + 80);
    if (!v8 || !_CFHTTPAuthenticationRequiresPersistentConnection(v8)) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_16:
  CFArrayRef v9 = (const __CFArray *)*((void *)this + 12);
  if (!v9) {
    goto LABEL_50;
  }
  if (!CFArrayGetCount(v9)) {
    goto LABEL_50;
  }
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 12), 0);
  if (!ValueAtIndex) {
    goto LABEL_50;
  }
  uint64_t v11 = *((void *)this + 4);
  if (!v11) {
    uint64_t v11 = *((void *)this + 3);
  }
  buf.version = 0;
  CFDictionaryRef v52 = 0;
  uint64_t v53 = 0;
  _getConnectionInfoForProxy(ValueAtIndex, (__CFHTTPMessage *)(v11 - 16), &buf, (SInt32 *)&v53 + 1, (BOOL *)&v53, &v52);
  CFDictionaryRef v12 = v52;
  MutableCFHTTPMessageRef Copy = (__CFDictionary *)*((void *)this + 6);
  if (v52)
  {
    if (MutableCopy)
    {
      CFIndex Count = CFDictionaryGetCount(v52);
      CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v16 = (const void **)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 16 * Count, 0);
      CFDictionaryGetKeysAndValues(v12, v16, &v16[Count]);
      CFIndex v17 = CFDictionaryGetCount(*((CFDictionaryRef *)this + 6));
      MutableCFHTTPMessageRef Copy = CFDictionaryCreateMutableCopy(v15, v17 + Count, *((CFDictionaryRef *)this + 6));
      if (Count >= 1)
      {
        uint64_t v18 = v16;
        CFIndex v19 = Count;
        do
        {
          CFDictionarySetValue(MutableCopy, *v18, v18[Count]);
          ++v18;
          --v19;
        }
        while (v19);
      }
      CFAllocatorDeallocate(v15, v16);
      CFStringEncoding v20 = MutableCopy;
    }
    else
    {
      CFStringEncoding v20 = 0;
      MutableCFHTTPMessageRef Copy = v52;
    }
  }
  else
  {
    CFStringEncoding v20 = 0;
  }
  uint64_t v21 = CFGetAllocator(*((CFTypeRef *)this + 1));
  version = (const void *)buf.version;
  Key = NetConnectionCache::createKey(v21, (const __CFString *)buf.version, (const __CFString *)HIDWORD(v53), v53, MutableCopy, v23);
  if (version) {
    CFRelease(version);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (!Key)
  {
LABEL_50:
    a2->CFIndex domain = 4;
    SInt32 v30 = -3;
LABEL_51:
    a2->error = v30;
    return;
  }
  CFAllocatorRef v25 = CFGetAllocator(*((CFTypeRef *)this + 1));
  if (getNetConnectionCache(void)::sOnce != -1) {
    dispatch_once(&getNetConnectionCache(void)::sOnce, &__block_literal_global_42_6645);
  }
  uint64_t v26 = getNetConnectionCache(void)::gHTTPConnectionCache;
  __int16 v27 = *((_WORD *)this + 8);
  buf.version = *((void *)Key + 3);
  buf.info = (void *)*((void *)Key + 4);
  buf.retain = (void *(__cdecl *)(void *))*((void *)Key + 5);
  if ((v27 & 2) == 0) {
    _constructNetConnection(v25, &buf);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(getNetConnectionCache(void)::gHTTPConnectionCache + 8));
  CFDictionaryRef Value = (NetConnection *)CFDictionaryGetValue(*(CFDictionaryRef *)(v26 + 16), Key);
  if (!Value) {
LABEL_44:
  }
    _constructNetConnection(v25, &buf);
  CFStringRef v29 = Value;
  if (!NetConnection::willEnqueueRequests(Value))
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v26 + 16), Key);
    goto LABEL_44;
  }
  (*(void (**)(NetConnection *))(*(void *)v29 + 40))(v29);
  os_unfair_lock_unlock((os_unfair_lock_t)(v26 + 8));
  (*(void (**)(CFAllocatedReferenceCountedObject *))(*(void *)Key + 48))(Key);
  if (a2->error) {
    return;
  }
  if ((*((_WORD *)this + 8) & 0x10) != 0)
  {
    uint64_t v46 = MEMORY[0x1E4F143A8];
    uint64_t v47 = 3221225472;
    uint64_t v48 = ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke;
    CFReadStreamRef v49 = &__block_descriptor_48_e26__v16__0____CFReadStream__8l;
    unsigned int v50 = this;
    CFReadStreamRef v51 = v29;
  }
  else
  {
    if (*((void *)this + 5)) {
      (*(void (**)(void))(**((void **)this + 4) + 64))(*((void *)this + 4));
    }
    uint64_t v40 = MEMORY[0x1E4F143A8];
    uint64_t v41 = 3221225472;
    CFTypeID v42 = ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_2;
    __int16 v43 = &__block_descriptor_48_e26__v16__0____CFReadStream__8l;
    CFReadStreamRef v44 = this;
    CFIndex v45 = v29;
  }
  *((void *)this + 10) = CFReadStreamCreate();
  (*(void (**)(NetConnection *))(*(void *)v29 + 48))(v29);
  uint64_t v31 = (__CFReadStream *)*((void *)this + 10);
  if (!v31)
  {
    a2->CFIndex domain = 4;
    SInt32 v30 = -1;
    goto LABEL_51;
  }
  buf.version = 0;
  buf.info = this;
  buf.retain = (void *(__cdecl *)(void *))_httpreadstream_retain;
  buf.release = (void (__cdecl *)(void *))_httpreadstream_release;
  buf.copyDescription = (CFStringRef (__cdecl *)(void *))_httpreadstream_copyDesc;
  CFReadStreamSetClient(v31, 0xFFFFFFFFFFFFFFFFLL, (CFReadStreamClientCallBack)HTTPReadStream::_streamCB, &buf);
  uint64_t v32 = *((void *)this + 18);
  if (v32) {
    CoreSchedulingSet::_scheduleStream(v32, *((void *)this + 10), MEMORY[0x1E4F1C268], MEMORY[0x1E4F1C260]);
  }
  if ((*((_WORD *)this + 8) & 0x20) != 0) {
    CFReadStreamSetProperty(*((CFReadStreamRef *)this + 10), (CFStreamPropertyKey)&unk_1EC09F7C0, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
  }
  if (*((void *)this + 7))
  {
    CFTypeID v33 = (__CFReadStream *)*((void *)this + 10);
    propertyValue[0] = MEMORY[0x1E4F143A8];
    propertyValue[1] = 3221225472;
    propertyValue[2] = ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_3;
    propertyValue[3] = &__block_descriptor_40_e25_v16__0____CFDictionary__8l;
    propertyValue[4] = this;
    CFReadStreamSetProperty(v33, (CFStreamPropertyKey)&unk_1EC0A35A8, propertyValue);
  }
  if (*((void *)this + 8))
  {
    CFReadStreamRef v34 = (__CFReadStream *)*((void *)this + 10);
    v37[0] = MEMORY[0x1E4F143A8];
    v37[1] = 3221225472;
    v37[2] = ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_4;
    v37[3] = &__block_descriptor_40_e28_v24__0____CFReadStream__8q16l;
    v37[4] = this;
    CFReadStreamSetProperty(v34, (CFStreamPropertyKey)&unk_1EC09F4E8, v37);
  }
  if (*((void *)this + 9))
  {
    CFRange v35 = (__CFReadStream *)*((void *)this + 10);
    v36[0] = MEMORY[0x1E4F143A8];
    v36[1] = 3221225472;
    v36[2] = ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_5;
    v36[3] = &__block_descriptor_40_e28_v20__0____CFReadStream__8C16l;
    v36[4] = this;
    CFReadStreamSetProperty(v35, (CFStreamPropertyKey)&unk_1EC09F360, v36);
  }
  CFReadStreamOpen(*((CFReadStreamRef *)this + 10));
}

_OWORD *___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke(uint64_t a1, __CFReadStream *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  __int16 v5 = CFAllocatorAllocate(*(CFAllocatorRef *)(*(void *)(a1 + 40) + 8), 184, 0);
  *__int16 v5 = 0u;
  v5[1] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[6] = 0u;
  void v5[7] = 0u;
  v5[8] = 0u;
  v5[9] = 0u;
  v5[10] = 0u;
  *((void *)v5 + 22) = 0;
  HTTPNetStreamInfo::HTTPNetStreamInfo((HTTPNetStreamInfo *)v5, a2, (CFTypeRef)(*(void *)(v4 + 32) - 16), *(HTTPNetConnection **)(a1 + 40));
  (*(void (**)(uint64_t, void, void))(*(void *)v6 + 112))(v6, *(void *)(v4 + 40), 0);
  return v5;
}

_OWORD *___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_2(uint64_t a1, __CFReadStream *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  __int16 v5 = CFAllocatorAllocate(*(CFAllocatorRef *)(*(void *)(a1 + 40) + 8), 184, 0);
  *__int16 v5 = 0u;
  v5[1] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[6] = 0u;
  void v5[7] = 0u;
  v5[8] = 0u;
  v5[9] = 0u;
  v5[10] = 0u;
  *((void *)v5 + 22) = 0;
  HTTPNetStreamInfo::HTTPNetStreamInfo((HTTPNetStreamInfo *)v5, a2, (CFTypeRef)(*(void *)(v4 + 32) - 16), *(HTTPNetConnection **)(a1 + 40));
  (*(void (**)(uint64_t, void, void))(*(void *)v6 + 112))(v6, 0, 0);
  return v5;
}

void ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  (*(void (**)(void))(*(void *)(v1 + 56) + 16))();
  _Block_release(*(const void **)(v1 + 56));
  *(void *)(v1 + 56) = 0;
}

uint64_t ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 64) + 16))();
}

uint64_t ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_5(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 72) + 16))();
}

void HTTPReadStream::_streamCB(HTTPReadStream *this, __CFReadStream *a2, HTTPReadStream *a3, void *a4)
{
  __int16 v4 = *((_WORD *)a3 + 8);
  if ((v4 & 0x40) != 0) {
    return;
  }
  if ((uint64_t)a2 > 7)
  {
    if (a2 == (__CFReadStream *)8)
    {
      CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*((void *)a3 + 10));
      if (HTTPReadStream::reattemptAfterError((CFReadStreamRef *)a3, &Error)) {
        return;
      }
      goto LABEL_18;
    }
    if (a2 != (__CFReadStream *)16) {
      return;
    }
    if ((v4 & 8) == 0)
    {
      Error.CFIndex domain = 0;
      *(void *)&Error.error = 0;
      int v7 = HTTPReadStream::readHeader(a3, &Error);
      if (Error.error || v7) {
        goto LABEL_18;
      }
      return;
    }
LABEL_22:
    CFReadStreamSignalEvent();
    return;
  }
  if (a2 == (__CFReadStream *)1) {
    goto LABEL_22;
  }
  if (a2 != (__CFReadStream *)2) {
    return;
  }
  if ((v4 & 8) != 0)
  {
    if ((*((_WORD *)a3 + 8) & 0x200) != 0) {
      return;
    }
    *((_WORD *)a3 + 8) = v4 | 0x200;
    goto LABEL_22;
  }
  Error.CFIndex domain = 0;
  *(void *)&Error.error = 0;
  int v6 = HTTPReadStream::readHeader(a3, &Error);
  if (Error.error)
  {
LABEL_18:
    CFReadStreamSignalEvent();
    return;
  }
  if (v6 && (*((_WORD *)a3 + 8) & 0x200) == 0)
  {
    *((_WORD *)a3 + 8) |= 0x200u;
    goto LABEL_18;
  }
}

const __CFArray *HTTPReadStream::reattemptAfterError(CFReadStreamRef *this, CFStreamError *a2)
{
  v4.CFIndex domain = 0;
  *(void *)&v4.error = 0;
  if (((_BYTE)this[2] & 2) != 0
    && a2->domain == 4
    && a2->error == -4
    && (((_BYTE)this[2] & 0x10) == 0 || CFReadStreamGetStatus(this[5]) == kCFStreamStatusNotOpen))
  {
    HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 0);
  }
  else
  {
    CFArrayRef result = this[12];
    if (!result) {
      return result;
    }
    if (CFArrayGetCount(result) < 2 || ((_WORD)this[2] & 0x10) != 0 && CFReadStreamGetStatus(this[5])) {
      return 0;
    }
    HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 0);
    if (CFArrayGetCount(this[12]) >= 1) {
      CFArrayRemoveValueAtIndex(this[12], 0);
    }
  }
  HTTPReadStream::startRequest((HTTPReadStream *)this, &v4);
  return (const __CFArray *)(v4.error == 0);
}

uint64_t _httpreadstream_copyDesc(void *a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 104))();
}

void _httpreadstream_release(CFTypeRef *a1)
{
}

CFTypeRef *_httpreadstream_retain(CFTypeRef *a1)
{
  return a1;
}

void _constructNetConnection(const __CFAllocator *a1, const void *a2)
{
  CFStreamError v4 = CFAllocatorAllocate(a1, 152, 0);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  void v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  *((void *)v4 + 18) = 0;
  HTTPConnectionCacheKey::HTTPConnectionCacheKey((uint64_t)v4, a1, *(const __CFString **)a2, *((_DWORD *)a2 + 2), *((_DWORD *)a2 + 3), *((const void **)a2 + 2), 0);
  __int16 v5 = (HTTPNetConnection_NoAuth *)CFAllocatorAllocate(a1, 320, 0);
  *(_OWORD *)__int16 v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  *((_OWORD *)v5 + 11) = 0u;
  *((_OWORD *)v5 + 12) = 0u;
  *((_OWORD *)v5 + 13) = 0u;
  *((_OWORD *)v5 + 14) = 0u;
  *((_OWORD *)v5 + 15) = 0u;
  *((_OWORD *)v5 + CFRetain((char *)this - 16) = 0u;
  *((_OWORD *)v5 + 17) = 0u;
  *((_OWORD *)v5 + 18) = 0u;
  *((_OWORD *)v5 + 19) = 0u;
  HTTPNetConnection_NoAuth::HTTPNetConnection_NoAuth(v5, a1, (HTTPConnectionCacheKey *)v4);
  (*(void (**)(_OWORD *))(*(void *)v4 + 48))(v4);
  NetConnection::initialize(v5);
}

void HTTPReadStream::_PACExecutionCompleteTimer(HTTPReadStream *this, __CFRunLoopTimer *a2, void *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CFStreamError v4 = (const void *)*((void *)a2 + 5);
  if (!v4) {
    CFStreamError v4 = (const void *)*((void *)a2 + 1);
  }
  CFAllocatorRef v5 = CFGetAllocator(v4);
  CFCFStreamError Error = __cfnCreateCFError(v5, @"kCFErrorDomainCFNetwork", 308, v6, v7, v8, v9, v10, 0);
  uint64_t v12 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_6657, 2);
  if (v12)
  {
    uint64_t v13 = v12;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v12 + 16))(v12, "Read Stream PAC Timeout", 0))
    {
      CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v15 = *((void *)a2 + 3);
      CFDictionaryRef v28 = off_1ECF9A530;
      CFStringRef v16 = CFStringCreateWithCString(v14, "Original Request", 0x8000100u);
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      CFStringRef v29 = v16;
      if (v15)
      {
        CFIndex v17 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 32))(v15);
        CFStringRef v16 = v29;
      }
      else
      {
        CFIndex v17 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v13 + 64))(v13, v16, v17);
      if (v15 && v17) {
        CFRelease(v17);
      }
      AutoString::~AutoString((AutoString *)&v28);
      uint64_t v18 = *((void *)a2 + 4);
      CFDictionaryRef v28 = off_1ECF9A530;
      CFStringRef v19 = CFStringCreateWithCString(v14, "Current Request", 0x8000100u);
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      CFStringRef v29 = v19;
      if (v18)
      {
        CFStringEncoding v20 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v18 + 32))(v18);
        CFStringRef v19 = v29;
      }
      else
      {
        CFStringEncoding v20 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v13 + 64))(v13, v19, v20);
      if (v18 && v20) {
        CFRelease(v20);
      }
      AutoString::~AutoString((AutoString *)&v28);
      uint64_t v21 = (const void *)*((void *)a2 + 11);
      CFDictionaryRef v28 = off_1ECF9A530;
      CFStringRef v22 = CFStringCreateWithCString(v14, "Proxy Configuration", 0x8000100u);
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      CFStringRef v29 = v22;
      if (v21)
      {
        CFStringRef v23 = CFCopyDescription(v21);
        CFStringRef v22 = v29;
      }
      else
      {
        CFStringRef v23 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(void *)v13 + 64))(v13, v22, v23);
      if (v21 && v23) {
        CFRelease(v23);
      }
      AutoString::~AutoString((AutoString *)&v28);
      CFDictionaryRef v24 = (const void *)*((void *)a2 + 12);
      CFDictionaryRef v28 = off_1ECF9A530;
      CFStringRef v25 = CFStringCreateWithCString(v14, "Proxy List", 0x8000100u);
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      CFStringRef v29 = v25;
      if (v24)
      {
        CFStringRef v26 = CFCopyDescription(v24);
        CFStringRef v25 = v29;
      }
      else
      {
        CFStringRef v26 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(void *)v13 + 64))(v13, v25, v26);
      if (v24 && v26) {
        CFRelease(v26);
      }
      AutoString::~AutoString((AutoString *)&v28);
      (*(void (**)(uint64_t, const char *, void))(*(void *)v13 + 56))(v13, "Proxy Error", *((void *)a2 + 13));
      (*(void (**)(uint64_t, const char *, CFErrorRef))(*(void *)v13 + 56))(v13, "Error", CFError);
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
  }
  HTTPReadStream::pacExecutionComplete((uint64_t)a2, 0, CFError);
  CFAbsoluteTime Current = CFRunLoopGetCurrent();
  CFRunLoopStop(Current);
  if (CFError) {
    CFRelease(CFError);
  }
}

void sub_184207A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

uint64_t HTTPReadStream::pacExecutionComplete(uint64_t this, CFTypeRef cf, void *a3)
{
  v12.CFIndex domain = 0;
  *(void *)&v12.error = 0;
  __int16 v3 = *(_WORD *)(this + 16);
  if ((v3 & 4) != 0)
  {
    uint64_t v6 = this;
    *(_WORD *)(this + CFRetain((char *)this - 16) = v3 & 0xFFFB;
    uint64_t v7 = *(__CFRunLoopSource **)(this + 112);
    if (v7)
    {
      CFRunLoopSourceInvalidate(v7);
      uint64_t v8 = *(const void **)(v6 + 112);
      if (v8) {
        CFRelease(v8);
      }
      *(void *)(v6 + 112) = 0;
    }
    CFArrayRef v9 = *(const __CFArray **)(v6 + 96);
    if (a3)
    {
      if (!v9 || (this = CFArrayGetCount(v9), this <= 0))
      {
        CFRetain(a3);
        *(void *)(v6 + 104) = a3;
        v12.CFIndex domain = _CFStreamErrorFromCFError((__CFError *)a3);
        *(void *)&v12.error = v10;
        return CFReadStreamSignalEvent();
      }
    }
    else
    {
      if (v9) {
        CFRelease(v9);
      }
      CFAllocatorRef v11 = CFGetAllocator(cf);
      this = (uint64_t)CFArrayCreateMutableCopy(v11, 0, (CFArrayRef)cf);
      *(void *)(v6 + 96) = this;
    }
    if ((*(_WORD *)(v6 + 16) & 0x80) == 0) {
      return this;
    }
    HTTPReadStream::startRequest((HTTPReadStream *)v6, &v12);
    if (v12.error) {
      return CFReadStreamSignalEvent();
    }
    return CFReadStreamSignalEvent();
  }
  return this;
}

uint64_t ___ZN14HTTPReadStream15pacTimerTimeoutEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  CFURLRef v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 834;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t HTTPReadStream::_streamImpl_Read(HTTPReadStream *this, __CFReadStream *a2, UInt8 *buffer, CFIndex bufferLength, CFStreamError *a5, BOOL *a6)
{
  a5->CFIndex domain = 0;
  a5->error = 0;
  CFStreamError v12 = (__CFReadStream *)*((void *)this + 10);
  if (!v12)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v18 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "httpRequestRead(): no stream to read from!", v18, 2u);
      CFStreamError v12 = (__CFReadStream *)*((void *)this + 10);
    }
    else
    {
      CFStreamError v12 = 0;
    }
  }
  *((_WORD *)this + 8) |= 0x40u;
  CFIndex v13 = CFReadStreamRead(v12, buffer, bufferLength);
  __int16 v14 = *((_WORD *)this + 8);
  *((_WORD *)this + 8) = v14 & 0xFFBF;
  if (v13 < 0)
  {
    *a5 = CFReadStreamGetError((CFReadStreamRef)*((void *)this + 10));
    if (HTTPReadStream::reattemptAfterError((CFReadStreamRef *)this, a5)) {
      goto LABEL_10;
    }
    goto LABEL_11;
  }
  uint64_t v15 = v13;
  if ((v14 & 8) == 0)
  {
    int Header = HTTPReadStream::readHeader(this, a5);
    if (!a5->error)
    {
      if (Header) {
        goto LABEL_8;
      }
LABEL_10:
      uint64_t v15 = (*(uint64_t (**)(HTTPReadStream *, __CFReadStream *, UInt8 *, CFIndex, CFStreamError *, BOOL *))(*(void *)this + 40))(this, a2, buffer, bufferLength, a5, a6);
      goto LABEL_12;
    }
LABEL_11:
    uint64_t v15 = -1;
    goto LABEL_12;
  }
LABEL_8:
  *a6 = CFReadStreamGetStatus(*((CFReadStreamRef *)this + 10)) > kCFStreamStatusWriting;
LABEL_12:
  *((_WORD *)this + 8) &= ~0x200u;
  return v15;
}

BOOL HTTPReadStream::_streamImpl_OpenCompleted(HTTPReadStream *this, __CFReadStream *a2, CFStreamError *a3)
{
  return (*((_WORD *)this + 8) & 4) == 0 && *((void *)this + 10) != 0;
}

BOOL HTTPReadStream::_streamImpl_Open(HTTPReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  CFGetAllocator(*((CFTypeRef *)this + 1));
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    Instance += 16;
    *(void *)(Instance + 176) = 0;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  HTTPRequestMessage::HTTPRequestMessage((HTTPRequestMessage *)Instance, *((const HTTPRequestMessage **)this + 3));
  *((void *)this + 4) = v8;
  if ((*((_WORD *)this + 8) & 0x100) != 0)
  {
    CFArrayRef v9 = (const void *)*((void *)this + 11);
    if (v9) {
      CFRelease(v9);
    }
    *((void *)this + 11) = CFNetworkCopySystemProxySettings();
  }
  int v10 = HTTPReadStream::constructProxyList(this, a3);
  if (a3->error)
  {
    BOOL result = 0;
    *a4 = 1;
    return result;
  }
  if (v10)
  {
    *a4 = 0;
    return 1;
  }
  HTTPReadStream::startRequest(this, a3);
  if (!a3->error)
  {
    CFStreamError v12 = (__CFReadStream *)*((void *)this + 10);
    if (v12) {
      BOOL v13 = CFReadStreamGetStatus(v12) > kCFStreamStatusOpening;
    }
    else {
      BOOL v13 = 0;
    }
    *a4 = v13;
    if (v13) {
      return a3->error == 0;
    }
    goto LABEL_15;
  }
  if (!*a4) {
LABEL_15:
  }
    *a4 = 1;
  return a3->error == 0;
}

void HTTPReadStream::~HTTPReadStream(CFReadStreamRef *this)
{
  HTTPReadStream::~HTTPReadStream(this);

  JUMPOUT(0x18531B6D0);
}

{
  CFReadStreamRef v2;
  CFReadStreamRef v3;
  __CFReadStream *v4;
  CFReadStreamRef v5;
  CFReadStreamRef v6;
  CFReadStreamRef v7;
  CFReadStreamRef v8;
  CFReadStreamRef v9;
  CFReadStreamRef v10;
  CFReadStreamRef v11;
  CFReadStreamRef v12;
  CFReadStreamRef v13;

  *this = (CFReadStreamRef)&unk_1ECF9CC70;
  HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 0);
  CFURLRef v2 = this[3];
  if (v2) {
    CFRelease((char *)v2 - 16);
  }
  __int16 v3 = this[4];
  if (v3) {
    CFRelease((char *)v3 - 16);
  }
  CFStreamError v4 = this[5];
  if (((_WORD)this[2] & 0x10) != 0)
  {
    if (!v4) {
      goto LABEL_11;
    }
    CFReadStreamSetClient(this[5], 0, 0, 0);
    CFReadStreamClose(v4);
    goto LABEL_10;
  }
  if (v4) {
LABEL_10:
  }
    CFRelease(v4);
LABEL_11:
  CFAllocatorRef v5 = this[6];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = this[11];
  if (v6) {
    CFRelease(v6);
  }
  if (((_WORD)this[2] & 4) == 0)
  {
    uint64_t v7 = this[12];
    if (v7) {
      CFRelease(v7);
    }
    uint64_t v8 = this[13];
    if (v8) {
      CFRelease(v8);
    }
  }
  CFArrayRef v9 = this[7];
  if (v9) {
    _Block_release(v9);
  }
  int v10 = this[8];
  if (v10) {
    _Block_release(v10);
  }
  CFAllocatorRef v11 = this[9];
  if (v11) {
    _Block_release(v11);
  }
  CFStreamError v12 = this[15];
  if (v12) {
    CFRelease(v12);
  }
  BOOL v13 = this[18];
  if (v13)
  {
    (*(void (**)(CFReadStreamRef))(*(void *)v13 + 48))(v13);
    this[18] = 0;
  }
  *this = (CFReadStreamRef)&unk_1ECF9B550;
  this[1] = 0;
}

void sub_184208038(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

void HTTPReadStream::HTTPReadStream(HTTPReadStream *this, CFTypeRef cf, HTTPRequestMessage *a3, __CFReadStream *a4)
{
  *(void *)this = &unk_1ECF9CC70;
  *((void *)this + 1) = cf;
  *((_WORD *)this + 8) = 0;
  CFGetAllocator(cf);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = (HTTPRequestMessage *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    uint64_t v8 = (HTTPRequestMessage *)(Instance + 16);
    *(void *)(Instance + 192) = 0;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  HTTPRequestMessage::HTTPRequestMessage(v8, a3);
  *((void *)this + 3) = v8;
  *((void *)this + 4) = 0;
  if (a4)
  {
    *((void *)this + 5) = CFRetain(a4);
    *((_WORD *)this + 8) |= 0x10u;
  }
  else
  {
    HTTPMessage::ensureParserFinished(v8);
    int v10 = (HTTPBodyData *)*((void *)v8 + 6);
    *((void *)v8 + 6) = 0;
    if (v10)
    {
      HTTPBodyData::captureData(v10, v9);
      uint64_t v12 = v11;
      (*(void (**)(HTTPBodyData *))(*(void *)v10 + 8))(v10);
      *((void *)this + 5) = v12;
    }
  }
  CFAllocatorRef v13 = CFGetAllocator(*((CFTypeRef *)this + 1));
  Mutable = (CoreSchedulingSet *)CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 15) = 0;
  *((void *)this + CFRetain((char *)this - 16) = 20;
  *((void *)this + 6) = Mutable;
  *((void *)this + 7) = 0;
  *((void *)this + 18) = CoreSchedulingSet::createEmpty(Mutable);
}

void sub_1842081E0(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

void non-virtual thunk to'SocketStream::~SocketStream(SocketStream *this)
{
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 32));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 24));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 24));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 16));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 16));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 8));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 8));
}

void SocketStream::~SocketStream(SocketStream *this)
{
  *(void *)this = &unk_1ECF9BF70;
  *((void *)this + 1) = &unk_1ECF9C070;
  *((void *)this + 2) = &unk_1ECF9C108;
  *((void *)this + 3) = &unk_1ECF9C208;
  *((void *)this + 4) = &unk_1ECF9C290;
  if (*((void *)this + 74))
  {
    tcp_connection_cancel();
    tcp_connection_release();
    *((void *)this + 74) = 0;
  }
  SocketStream::cleanupConnection_NoLock(this);
  if (*((unsigned char *)this + 644))
  {
    *((unsigned char *)this + 644) = 0;
    entr_act_end_delayInitStub(v2);
  }
  __int16 v3 = *((void *)this + 71);
  if (v3)
  {
    dispatch_release(v3);
    *((void *)this + 71) = 0;
  }
  CFStreamError v4 = *((void *)this + 48);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*((dispatch_object_t *)this + 48));
    *((void *)this + 48) = 0;
  }
  CFAllocatorRef v5 = *((void *)this + 49);
  if (v5)
  {
    dispatch_source_cancel(v5);
    dispatch_release(*((dispatch_object_t *)this + 49));
    *((void *)this + 49) = 0;
  }
  uint64_t v6 = *((void *)this + 41);
  if (v6)
  {
    v40.CFIndex length = *(void *)(v6 + 24);
    v40.CFIndex location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v6 + 16), v40, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction, *((void **)this + 38));
    uint64_t v7 = *((void *)this + 41);
    v41.CFIndex length = *(void *)(v7 + 24);
    v41.CFIndex location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v7 + 16), v41, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction, *((void **)this + 39));
    uint64_t v8 = *((void *)this + 41);
    v42.CFIndex length = *(void *)(v8 + 24);
    v42.CFIndex location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v8 + 16), v42, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction, *((void **)this + 40));
    uint64_t v9 = *((void *)this + 41);
    v43.CFIndex length = *(void *)(v9 + 24);
    v43.CFIndex location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v9 + 16), v43, (CFArrayApplierFunction)Schedulables::_SchedulablesInvalidateApplierFunction, 0);
    uint64_t v10 = *((void *)this + 41);
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
  if (*((void *)this + 36))
  {
    SocketStream::checkOutVoIPSocket(this, v2);
    *((_DWORD *)this + 62) |= 0x800u;
    CFSocketInvalidate(*((CFSocketRef *)this + 36));
    CFRelease(*((CFTypeRef *)this + 36));
    *((void *)this + 36) = 0;
  }
  uint64_t v11 = (const void *)*((void *)this + 67);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = (const void *)*((void *)this + 38);
  *((void *)this + 38) = 0;
  if (v12) {
    CFRelease(v12);
  }
  CFAllocatorRef v13 = (const void *)*((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v13) {
    CFRelease(v13);
  }
  __int16 v14 = (const void *)*((void *)this + 40);
  *((void *)this + 40) = 0;
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = (const void *)*((void *)this + 37);
  *((void *)this + 37) = 0;
  if (v15) {
    CFRelease(v15);
  }
  CFStringRef v16 = (const void *)*((void *)this + 42);
  *((void *)this + 42) = 0;
  if (v16) {
    CFRelease(v16);
  }
  CFIndex v17 = (const void *)*((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v17) {
    CFRelease(v17);
  }
  uint64_t v18 = (const void *)*((void *)this + 30);
  *((void *)this + 30) = 0;
  if (v18) {
    CFRelease(v18);
  }
  uint64_t v19 = *((void *)this + 65);
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  CFStringEncoding v20 = (const void *)*((void *)this + 72);
  *((void *)this + 72) = 0;
  if (v20) {
    CFRelease(v20);
  }
  uint64_t v21 = (const void *)*((void *)this + 73);
  *((void *)this + 73) = 0;
  if (v21) {
    CFRelease(v21);
  }
  uint64_t v22 = *((void *)this + 66);
  if (v22)
  {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
    *((void *)this + 66) = 0;
  }
  uint64_t v23 = *((void *)this + 75);
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  uint64_t v24 = *((void *)this + 27);
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  CFStringRef v25 = (const void *)*((void *)this + 54);
  if (v25) {
    _Block_release(v25);
  }
  CFStringRef v26 = (const void *)*((void *)this + 55);
  if (v26) {
    _Block_release(v26);
  }
  __int16 v27 = (const void *)*((void *)this + 56);
  if (v27) {
    _Block_release(v27);
  }
  CFDictionaryRef v28 = (const void *)*((void *)this + 57);
  if (v28) {
    _Block_release(v28);
  }
  CFStringRef v29 = (const void *)*((void *)this + 58);
  if (v29) {
    _Block_release(v29);
  }
  uint64_t v30 = (const void *)*((void *)this + 59);
  if (v30) {
    _Block_release(v30);
  }
  uint64_t v31 = (const void *)*((void *)this + 60);
  if (v31) {
    _Block_release(v31);
  }
  uint64_t v32 = (const void *)*((void *)this + 61);
  if (v32) {
    _Block_release(v32);
  }
  CFTypeID v33 = (const void *)*((void *)this + 62);
  if (v33) {
    _Block_release(v33);
  }
  CFReadStreamRef v34 = (const void *)*((void *)this + 63);
  if (v34) {
    _Block_release(v34);
  }
  CFRange v35 = (const void *)*((void *)this + 64);
  if (v35) {
    _Block_release(v35);
  }
  (*(void (**)(SocketStream *, void))(*(void *)this + 176))(this, 0);
  objc_storeWeak((id *)this + 34, 0);
  objc_storeWeak((id *)this + 35, 0);
  CFTypeID v36 = (const void *)*((void *)this + 86);
  *((void *)this + 86) = 0;
  if (v36) {
    CFRelease(v36);
  }
  int v37 = (std::__shared_weak_count *)*((void *)this + 84);
  if (v37) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v37);
  }
  CFReadStreamRef v38 = (const void *)*((void *)this + 81);
  *((void *)this + 81) = 0;
  if (v38) {
    CFRelease(v38);
  }
  uint64_t v39 = *((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v39) {
    (*((void (**)(void))this + 23))();
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 112));
  std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100]((uint64_t *)this + 13, 0);
  *((void *)this + 4) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 40));
  *((void *)this + 1) = &unk_1ECF9B550;
}

void sub_1842086F8(_Unwind_Exception *a1)
{
  __int16 v3 = *(const void **)(v1 + 688);
  *(void *)(v1 + 688) = 0;
  if (v3) {
    CFRelease(v3);
  }
  CFStreamError v4 = *(std::__shared_weak_count **)(v1 + 672);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  CFAllocatorRef v5 = *(const void **)(v1 + 648);
  *(void *)(v1 + 648) = 0;
  if (v5) {
    CFRelease(v5);
  }
  NotificationStation::~NotificationStation((NotificationStation *)(v1 + 104));
  *(void *)(v1 + 32) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
  *(void *)(v1 + 8) = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void SocketStream::cleanupConnection_NoLock(SocketStream *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 70))
  {
    *((_DWORD *)this + 62) |= 0x1000u;
    tcp_connection_cancel();
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    double v2 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *((void *)this + 70);
      int v4 = 134217984;
      uint64_t v5 = v3;
      _os_log_impl(&dword_184085000, v2, OS_LOG_TYPE_DEFAULT, "TCP Conn %p canceled", (uint8_t *)&v4, 0xCu);
    }
    *((void *)this + 70) = 0;
  }
}

uint64_t SocketStream::checkOutVoIPSocket(SocketStream *this, double a2)
{
  uint64_t result = *((void *)this + 69);
  if (result)
  {
    spd_client_checkout_socket_delayInitStub(a2);
    uint64_t result = spd_client_destroy_delayInitStub(v4);
    *((void *)this + 69) = 0;
  }
  return result;
}

BOOL virtual thunk to'SocketStream::canWrite(SocketStream *this, __CFWriteStream *a2)
{
  return SocketStream::canWrite((SocketStream *)((char *)this + *(void *)(*(void *)this - 128)), a2);
}

BOOL SocketStream::canWrite(SocketStream *this, __CFWriteStream *a2)
{
  return (*((_DWORD *)this + 62) & 0x60000000) == 0
      && SocketStream::streamCan((uint64_t)this, a2, 2, (const __CFString *)&unk_1EC0A02B0, &v3) != 0;
}

uint64_t SocketStream::streamCan(uint64_t a1, const void *a2, int a3, const __CFString *a4, void *a5)
{
  *a5 = 0;
  a5[1] = 0;
  uint64_t v10 = (pthread_mutex_t *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
  CFTypeID TypeID = CFReadStreamGetTypeID();
  CFTypeID v12 = CFGetTypeID(a2);
  unsigned int v13 = *(unsigned __int8 *)(a1 + 248);
  uint64_t v14 = (v13 >> (a3 + 1)) & 1;
  int v15 = *(_DWORD *)(a1 + 264);
  if (v15) {
    BOOL v16 = 0;
  }
  else {
    BOOL v16 = v14 == 0;
  }
  if (v16)
  {
    uint64_t v17 = 312;
    if (TypeID == v12) {
      uint64_t v17 = 304;
    }
    CFArrayRef v18 = *(const __CFArray **)(a1 + v17);
    if (((v13 >> a3) & 0x10) != 0
      || (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 320)), CFArrayGetCount(v18) + Count < 3))
    {
      CFRunLoopRef Current = CFRunLoopGetCurrent();
      _SchedulesAddRunLoopAndMode(v18, Current, a4);
      uint64_t v22 = *(__CFSocket **)(a1 + 288);
      if (v22
        && CFSocketIsValid(v22)
        && (uint64_t v23 = *(void *)(a1 + 328), *(void *)(v23 + 24) == 1)
        && (uint64_t v24 = *(const void **)(a1 + 288), v24 == CFArrayGetValueAtIndex(*(CFArrayRef *)(v23 + 16), 0)))
      {
        CFAllocatorRef v37 = CFGetAllocator((CFTypeRef)(a1 - 16));
        CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v37, *(CFSocketRef *)(a1 + 288), 0);
        if (RunLoopSource)
        {
          uint64_t v39 = RunLoopSource;
          CFRange v40 = CFRunLoopGetCurrent();
          CFRunLoopAddSource(v40, v39, a4);
          CFRelease(v39);
        }
      }
      else
      {
        uint64_t v25 = *(void *)(a1 + 328);
        CFRunLoopRef v45 = CFRunLoopGetCurrent();
        CFStringRef v46 = a4;
        v47.CFIndex length = *(void *)(v25 + 24);
        v47.CFIndex location = 0;
        CFArrayApplyFunction(*(CFArrayRef *)(v25 + 16), v47, (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction, &v45);
      }
      pthread_mutex_unlock(v10);
      CFRunLoopRunInMode(a4, 0.0, 0);
      pthread_mutex_lock(v10);
      CFStringRef v26 = *(__CFSocket **)(a1 + 288);
      if (v26
        && CFSocketIsValid(v26)
        && (uint64_t v27 = *(void *)(a1 + 328), *(void *)(v27 + 24) == 1)
        && (CFDictionaryRef v28 = *(const void **)(a1 + 288), v28 == CFArrayGetValueAtIndex(*(CFArrayRef *)(v27 + 16), 0)))
      {
        CFAllocatorRef v41 = CFGetAllocator((CFTypeRef)(a1 - 16));
        CFRunLoopSourceRef v42 = CFSocketCreateRunLoopSource(v41, *(CFSocketRef *)(a1 + 288), 0);
        if (v42)
        {
          CFRange v43 = v42;
          CFReadStreamRef v44 = CFRunLoopGetCurrent();
          CFRunLoopRemoveSource(v44, v43, a4);
          CFRelease(v43);
        }
      }
      else
      {
        uint64_t v29 = *(void *)(a1 + 328);
        CFRunLoopRef v45 = CFRunLoopGetCurrent();
        CFStringRef v46 = a4;
        v48.CFIndex length = *(void *)(v29 + 24);
        v48.CFIndex location = 0;
        CFArrayApplyFunction(*(CFArrayRef *)(v29 + 16), v48, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction, &v45);
      }
      CFRunLoopRef v30 = CFRunLoopGetCurrent();
      _SchedulesRemoveRunLoopAndMode(v18, v30, a4);
      uint64_t v14 = (*(unsigned __int8 *)(a1 + 248) >> (a3 + 1)) & 1;
    }
    else
    {
      if (a3)
      {
        if (a3 == 2)
        {
          int v20 = 64;
        }
        else
        {
          if (a3 != 1) {
            goto LABEL_53;
          }
          int v20 = 32;
        }
      }
      else
      {
        int v20 = 16;
      }
      uint64_t v14 = 0;
      *(_DWORD *)(a1 + 248) |= v20;
    }
    int v15 = *(_DWORD *)(a1 + 264);
  }
  if (!v15) {
    goto LABEL_45;
  }
  *(_OWORD *)a5 = *(_OWORD *)(a1 + 256);
  if (a3)
  {
    if (a3 != 2)
    {
      if (a3 == 1)
      {
        int v31 = 4;
        goto LABEL_33;
      }
LABEL_53:
      abort();
    }
    int v31 = 8;
  }
  else
  {
    int v31 = 2;
  }
LABEL_33:
  *(_DWORD *)(a1 + 248) |= v31;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 272));
  CFTypeID v33 = WeakRetained;
  if ((!*(void *)(a1 + 232) || *(uint64_t *)(a1 + 224) < 1) && WeakRetained)
  {
    if ((*(_DWORD *)(a1 + 248) & 0x200) != 0) {
      _CFReadStreamSignalEventDelayed();
    }
    goto LABEL_39;
  }
  if (WeakRetained) {
LABEL_39:
  }
    CFRelease(v33);
  id v34 = objc_loadWeakRetained((id *)(a1 + 280));
  if (v34)
  {
    CFRange v35 = v34;
    if ((*(_DWORD *)(a1 + 248) & 0x400) != 0) {
      _CFWriteStreamSignalEventDelayed();
    }
    CFRelease(v35);
  }
  uint64_t v14 = 1;
LABEL_45:
  pthread_mutex_unlock(v10);
  return v14;
}

uint64_t virtual thunk to'SocketStream::write(SocketStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, int64_t a4, CFStreamError *a5)
{
  return SocketStream::write((SocketStream *)((char *)this + *(void *)(*(void *)this - 120)), a2, a3, a4, a5);
}

uint64_t SocketStream::write(SocketStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, int64_t a4, CFStreamError *a5)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  if (nw_settings_get_signposts_enabled()) {
    kdebug_trace();
  }
  a5->CFIndex domain = 0;
  *(void *)&a5->error = 0;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  int64_t v9 = 0;
  uint64_t v10 = (CFStreamError *)((char *)this + 256);
  CFTypeRef cf = (char *)this - 16;
  uint64_t v71 = (int)*MEMORY[0x1E4F1D430];
  while (1)
  {
    while (1)
    {
      int v11 = *((_DWORD *)this + 66);
      unint64_t v12 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if (v11) {
        goto LABEL_91;
      }
      if ((*((_DWORD *)this + 62) & 8) != 0) {
        goto LABEL_23;
      }
      CFRunLoopRef Current = CFRunLoopGetCurrent();
      context.version = 0;
      context.info = Current;
      memset(&context.retain, 0, 56);
      context.perform = (void (__cdecl *)(void *))emptyPerform;
      CFAllocatorRef v14 = CFGetAllocator(cf);
      CFRunLoopSourceRef v15 = CFRunLoopSourceCreate(v14, 0, &context);
      *((void *)this + 73) = v15;
      if (!v15)
      {
        *((void *)this + 32) = 1;
        *((_DWORD *)this + 66) = 12;
        unint64_t v61 = *((_DWORD *)this + 62) & 0xFFFFFFF7 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        *((_DWORD *)this + 62) &= ~8u;
        *((_WORD *)this + 126) = WORD2(v61);
        goto LABEL_113;
      }
      double valuePtr = 0.0;
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A00B8);
      if (!Value || !CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr))
      {
        double valuePtr = 75.0;
LABEL_12:
        double v17 = CFAbsoluteTimeGetCurrent() + valuePtr;
        goto LABEL_13;
      }
      if (valuePtr != 0.0) {
        goto LABEL_12;
      }
      double v17 = 1.79769313e308;
LABEL_13:
      _SchedulesAddRunLoopAndMode(*((const __CFArray **)this + 39), Current, @"_kCFStreamSocketWritePrivateMode");
      uint64_t v18 = *((void *)this + 41);
      CFRunLoopRef v73 = Current;
      uint64_t v74 = 0x1EC0A0400;
      v83.CFIndex length = *(void *)(v18 + 24);
      v83.CFIndex location = 0;
      CFArrayApplyFunction(*(CFArrayRef *)(v18 + 16), v83, (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction, &v73);
      CFRunLoopAddSource(Current, *((CFRunLoopSourceRef *)this + 73), @"_kCFStreamSocketWritePrivateMode");
      do
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
        CFRunLoopRunInMode(@"_kCFStreamSocketWritePrivateMode", valuePtr, 1u);
        pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
        if (*((_DWORD *)this + 66)) {
          break;
        }
        if ((*((_DWORD *)this + 62) & 8) != 0) {
          break;
        }
        double valuePtr = v17 - CFAbsoluteTimeGetCurrent();
      }
      while (valuePtr > 0.0);
      CFRunLoopRemoveSource(Current, *((CFRunLoopSourceRef *)this + 73), @"_kCFStreamSocketWritePrivateMode");
      uint64_t v19 = *((void *)this + 41);
      CFRunLoopRef v73 = Current;
      uint64_t v74 = 0x1EC0A0400;
      v84.CFIndex length = *(void *)(v19 + 24);
      v84.CFIndex location = 0;
      CFArrayApplyFunction(*(CFArrayRef *)(v19 + 16), v84, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction, &v73);
      _SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 39), Current, @"_kCFStreamSocketWritePrivateMode");
      int v20 = (const void *)*((void *)this + 73);
      *((void *)this + 73) = 0;
      if (v20) {
        CFRelease(v20);
      }
      unint64_t v12 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      int v11 = *((_DWORD *)this + 66);
      if ((*((_DWORD *)this + 62) & 8) == 0) {
        break;
      }
      if (v11) {
        goto LABEL_91;
      }
LABEL_23:
      if ((v12 & 0x2000) == 0)
      {
        if ((v12 & 0x1000000) != 0)
        {
          int v31 = (void *)*((void *)this + 66);
          if (v31)
          {
            uint64_t v32 = v31[2];
            uint64_t v33 = v31[3];
            unint64_t v34 = v31[4];
          }
          else
          {
            CFAllocatorRef v37 = CFGetAllocator(cf);
            CFReadStreamRef v38 = CFAllocatorAllocate(v37, 36056, 0);
            bzero(v38, 0x8CD8uLL);
            CFAllocatorRef v39 = CFGetAllocator(cf);
            uint64_t v33 = 0;
            unint64_t v34 = ((unint64_t)(v38 + 5) & 0xFFFFFFFFFFFFFFF0) + 16;
            v38[4] = v34;
            *((_OWORD *)v38 + 1) = xmmword_1843D17C0;
            *CFReadStreamRef v38 = &unk_1ECFA0F80;
            v38[1] = v39;
            *((void *)this + 66) = v38;
            uint64_t v32 = 36000;
          }
          int64_t v40 = v32 - v33;
          if (v40 >= a4) {
            int64_t v9 = a4;
          }
          else {
            int64_t v9 = v40;
          }
          memcpy((void *)(v34 + v33), a3, v9);
          uint64_t v41 = *((void *)this + 66);
          *(void *)(v41 + 24) = v9 + v33;
          if (*(void *)(v41 + 16) == v9 + v33) {
            SocketStream::flushTransmissionBuffer_NoLock((CFStreamError *)this);
          }
          else {
            CFWriteStreamSignalEvent();
          }
        }
        else
        {
          int64_t v9 = SocketStream::sendToSocket(this, a3, a4, (CFStreamError *)this + 16);
        }
LABEL_90:
        int v11 = *((_DWORD *)this + 66);
        unint64_t v12 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        goto LABEL_91;
      }
      double valuePtr = 0.0;
      uint64_t v21 = (IOLogger *)*((void *)this + 27);
      if (v21) {
        IOLogger::logBytesSent(v21, 1, a3, a4);
      }
      while (1)
      {
        while (1)
        {
          uint64_t v22 = SSLWrite(*((SSLContextRef *)this + 37), a3, a4, (size_t *)&valuePtr);
          uint64_t v23 = v22;
          uint64_t v24 = *((unsigned int *)this + 62);
          unint64_t v25 = v24 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          int64_t v9 = *(void *)&valuePtr;
          if ((v24 & 0x20000) == 0 && valuePtr != 0.0)
          {
            unint64_t v26 = HIDWORD(v25);
            v25 |= 0x20000uLL;
            *((_WORD *)this + 126) = v26;
            *((_DWORD *)this + 62) = v25;
          }
          if (*((_DWORD *)this + 66)) {
            goto LABEL_89;
          }
          if (v22 == -9803 && v9 != 0) {
            goto LABEL_51;
          }
          if ((int)v22 > -9842) {
            break;
          }
          if (v22 != -9842) {
            goto LABEL_88;
          }
          *((_WORD *)this + 126) = WORD2(v25);
          *((_DWORD *)this + 62) = v25 | 0x20000000;
          uint64_t v29 = (*(uint64_t (**)(SocketStream *))(*(void *)this + 184))(this);
          if (v29)
          {
            uint64_t v51 = v29;
            CFTypeRef v79 = 0;
            if (SSLCopyDistinguishedNames(*((SSLContextRef *)this + 37), (CFArrayRef *)&v79))
            {
              CFTypeRef v52 = v79;
              CFTypeRef v79 = 0;
              if (v52) {
                CFRelease(v52);
              }
            }
            CFRetain(cf);
            CFRunLoopRef v73 = (CFRunLoopRef)MEMORY[0x1E4F143A8];
            uint64_t v74 = 3221225472;
            unsigned int v75 = ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_3;
            uint64_t v76 = &__block_descriptor_40_e20_v16__0____CFArray__8l;
            CFAllocatorRef v77 = this;
            (*(void (**)(uint64_t, CFTypeRef, CFRunLoopRef *))(*(void *)v51 + 48))(v51, v79, &v73);
            if (v79) {
              CFRelease(v79);
            }
            (*(void (**)(uint64_t))(*(void *)v51 + 24))(v51);
            SocketStream::unscheduleFromSSL(this);
            goto LABEL_89;
          }
          unint64_t v30 = *((_DWORD *)this + 62) & 0xDFFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          *((_DWORD *)this + 62) &= ~0x20000000u;
          *((_WORD *)this + 126) = WORD2(v30);
        }
        if ((int)v22 > -9807) {
          break;
        }
        if (v22 != -9841) {
          goto LABEL_88;
        }
        uint64_t v28 = (*(uint64_t (**)(SocketStream *))(*(void *)this + 184))(this);
        if (v28)
        {
          uint64_t v44 = v28;
          *((_DWORD *)this + 62) |= 0x40000000u;
          CFTypeRef v79 = 0;
          if (SocketStream::_copyPeerTrustWithPinning_NoLock((CFDictionaryRef *)this, *((SSLContextRef *)this + 37), (SecTrustRef *)&v79))
          {
            CFTypeRef v46 = v79;
            CFTypeRef v79 = 0;
            if (v46) {
              CFRelease(v46);
            }
          }
          CFDictionaryRef v47 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), @"kCFStreamPropertySSLSettings");
          CFDictionaryRef ATSVersion = StrictSecurity::getATSVersion(v47, v48);
          StrictSecurity::cloneSecTrust(&v78, (uint64_t)ATSVersion, (uint64_t)v79);
          unsigned int v50 = (const void *)*((void *)this + 86);
          *((void *)this + 86) = v78;
          if (v50) {
            CFRelease(v50);
          }
          logPeerCertAvailable(*((SSLContext **)this + 37));
          CFRetain(cf);
          context.version = MEMORY[0x1E4F143A8];
          context.info = (void *)3221225472;
          context.retain = (const void *(__cdecl *)(const void *))___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke;
          context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e8_v12__0i8l;
          context.copyDescription = (CFStringRef (__cdecl *)(const void *))this;
          (*(void (**)(uint64_t, CFTypeRef, CFRunLoopSourceContext *))(*(void *)v44 + 40))(v44, v79, &context);
          (*(void (**)(uint64_t))(*(void *)v44 + 24))(v44);
          SocketStream::unscheduleFromSSL(this);
          if (v79) {
            CFRelease(v79);
          }
          goto LABEL_89;
        }
      }
      if ((v22 + 9806) < 2)
      {
        *((_WORD *)this + 126) = WORD2(v25);
        *((_DWORD *)this + 62) = v25 | 0x100000;
        goto LABEL_90;
      }
      if (!v22) {
        goto LABEL_90;
      }
      if (v22 != -9803) {
        goto LABEL_88;
      }
      if ((v25 & 0x28000) != 0x8000)
      {
        uint64_t v23 = 4294957493;
LABEL_88:
        int v53 = translateSSLContextError(*((SSLContext **)this + 37), v23);
        *((void *)this + 32) = v71;
        *((_DWORD *)this + 66) = v53;
LABEL_89:
        int64_t v9 = -1;
        goto LABEL_90;
      }
LABEL_51:
      unint64_t v35 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if (v9 >= 1)
      {
        if ((*((_DWORD *)this + 62) & 0x2000) == 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          LOWORD(context.version) = 0;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "we're blocked on SSLWrite, so we must be using SSL", (uint8_t *)&context, 2u);
          uint64_t v56 = *((unsigned int *)this + 62);
          unint64_t v35 = v56 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          if ((v56 & 2) == 0) {
            goto LABEL_55;
          }
        }
        else if ((v35 & 2) == 0)
        {
LABEL_55:
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            LOWORD(context.version) = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "we've written bytes, so the socket must have been opened", (uint8_t *)&context, 2u);
            unint64_t v35 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          }
        }
        *((_WORD *)this + 126) = (v35 & 0xFFFFFFFFFFFFFFF7) >> 32;
        *((_DWORD *)this + 62) = v35 & 0xFFFFBFF7 | 0x4000;
        CFTypeID v36 = (__CFSocket *)*((void *)this + 36);
        if (v36 && CFSocketIsValid(v36)) {
          CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 9uLL);
        }
        goto LABEL_90;
      }
      if ((*((_DWORD *)this + 62) & 0x28000) != 0x8000) {
        goto LABEL_90;
      }
      CFRunLoopSourceRef v42 = (__CFSocket *)*((void *)this + 36);
      if (v42 && CFSocketIsValid(v42)) {
        CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
      }
      unint64_t v43 = *((_DWORD *)this + 62) & 0xFFFFFFF7 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      *((_DWORD *)this + 62) &= ~8u;
      *((_WORD *)this + 126) = WORD2(v43);
    }
    if (!v11)
    {
      *((void *)this + 32) = 1;
      int v11 = 60;
      *((_DWORD *)this + 66) = 60;
    }
LABEL_91:
    unint64_t v54 = v12 & 0xFFFFFFFFFFFFFFF7;
    *((_DWORD *)this + 62) = v54;
    *((_WORD *)this + 126) = WORD2(v54);
    if (v11 != 35) {
      break;
    }
    if (v10->domain != 1) {
      goto LABEL_113;
    }
    CFIndex v55 = (__CFSocket *)*((void *)this + 36);
    if (v55)
    {
      if (CFSocketIsValid(v55)) {
        CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 8uLL);
      }
    }
    v10->CFIndex domain = 0;
    *((void *)this + 33) = 0;
  }
  if (v11)
  {
LABEL_113:
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFStringRef v62 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      CFIndex v67 = *((void *)this + 70);
      CFStringRef v68 = (void *)*((void *)this + 32);
      int v69 = *((_DWORD *)this + 66);
      LODWORD(context.version) = 134218496;
      *(CFIndex *)((char *)&context.version + 4) = v67;
      WORD2(context.info) = 2048;
      *(void **)((char *)&context.info + 6) = v68;
      HIWORD(context.retain) = 1024;
      LODWORD(context.release) = v69;
      _os_log_error_impl(&dword_184085000, v62, OS_LOG_TYPE_ERROR, "SocketStream write error [%p]: %ld %d", (uint8_t *)&context, 0x1Cu);
    }
    if (!*((void *)this + 29) || *((uint64_t *)this + 28) <= 0)
    {
      *a5 = *v10;
      id WeakRetained = objc_loadWeakRetained((id *)this + 34);
      if (WeakRetained)
      {
        uint64_t v64 = WeakRetained;
        if ((*((_DWORD *)this + 62) & 0x200) != 0) {
          _CFReadStreamSignalEventDelayed();
        }
        CFRelease(v64);
      }
    }
    uint64_t v65 = (__CFSocket *)*((void *)this + 36);
    if (v65 && CFSocketIsValid(v65)) {
      CFSocketDisableCallBacks(*((CFSocketRef *)this + 36), 9uLL);
    }
    int64_t v9 = -1;
    goto LABEL_127;
  }
  if (!v9)
  {
    CFIndex v60 = (__CFSocket *)*((void *)this + 36);
    if (v60 && CFSocketIsValid(v60)) {
      CFSocketDisableCallBacks(*((CFSocketRef *)this + 36), 8uLL);
    }
    int64_t v9 = 0;
    goto LABEL_127;
  }
  SocketStream::touchWatchdogTimer_Locked(this, 0);
  if (*((_DWORD *)this + 103)
    || (uint64_t v57 = *((unsigned int *)this + 62),
        unint64_t v58 = v57 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32),
        (v57 & 0x4000) != 0))
  {
LABEL_127:
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
    goto LABEL_128;
  }
  if ((v57 & 0x100000) == 0)
  {
    CFAllocatorRef v59 = (__CFSocket *)*((void *)this + 36);
    if (!v59 || !CFSocketIsValid(v59) || _CFSocketCan(*((__CFSocket **)this + 36), 1))
    {
      unint64_t v58 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      goto LABEL_131;
    }
    CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 8uLL);
    goto LABEL_127;
  }
LABEL_131:
  unint64_t v70 = v58 & 0xFFFFFFFFFFFFFFBFLL;
  *((_WORD *)this + 126) = WORD2(v70);
  *((_DWORD *)this + 62) = v70 | 8;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
  CFWriteStreamSignalEvent();
LABEL_128:
  if (nw_settings_get_signposts_enabled()) {
    kdebug_trace();
  }
  return v9;
}

uint64_t SocketStream::sendToSocket(SocketStream *this, const unsigned __int8 *a2, size_t a3, CFStreamError *a4)
{
  uint64_t v5 = (__CFSocket *)*((void *)this + 36);
  a4->CFIndex domain = 0;
  *(void *)&a4->error = 0;
  if (!v5 || !CFSocketIsValid(v5))
  {
    SInt32 v15 = 22;
LABEL_12:
    a4->CFIndex domain = 1;
    a4->error = v15;
    return -1;
  }
  CFSocketNativeHandle Native = CFSocketGetNative(v5);
  ssize_t v10 = write(Native, a2, a3);
  if (v10 < 0)
  {
    SInt32 v15 = *__error();
    goto LABEL_12;
  }
  uint64_t v12 = v10;
  unsigned int v13 = (IOLogger *)*((void *)this + 27);
  BOOL v14 = v12 != 0;
  if (v13 && v12)
  {
    IOLogger::logBytes(v13, "RAW-SEND", 0x3Eu, a2, v12);
    BOOL v14 = 1;
  }
  if (*((unsigned char *)this + 644) && v14)
  {
    *((void *)this + 78) += v12;
    entr_act_modify_delayInitStub(v11);
  }
  return v12;
}

void SocketStream::touchWatchdogTimer_Locked(SocketStream *this, int a2)
{
  double v2 = *((double *)this + 45);
  if (v2 > 0.0)
  {
    if (!*((void *)this + 48))
    {
      *((void *)this + 48) = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *((dispatch_queue_t *)this + 71));
      CFRetain((char *)this - 16);
      uint64_t v5 = *((void *)this + 48);
      handler[0] = MEMORY[0x1E4F143A8];
      handler[1] = 3221225472;
      handler[2] = ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke;
      handler[3] = &__block_descriptor_40_e5_v8__0l;
      void handler[4] = this;
      dispatch_source_set_event_handler(v5, handler);
      uint64_t v6 = *((void *)this + 48);
      v10[0] = MEMORY[0x1E4F143A8];
      v10[1] = 3221225472;
      v10[2] = ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke_2;
      v10[3] = &__block_descriptor_40_e5_v8__0l;
      v10[4] = this;
      dispatch_source_set_cancel_handler(v6, v10);
      dispatch_resume(*((dispatch_object_t *)this + 48));
      double v2 = *((double *)this + 45);
    }
    double v7 = 10.0;
    if (v2 < 10.0) {
      double v7 = v2;
    }
    if (a2) {
      double v2 = v7;
    }
    uint64_t v8 = *((void *)this + 48);
    dispatch_time_t v9 = dispatch_time(0, (uint64_t)(v2 * 1000000000.0));
    dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  }
}

BOOL _CFSocketCan(__CFSocket *a1, int a2)
{
  CFSocketNativeHandle Native = CFSocketGetNative(a1);
  int v4 = Native;
  if (a2)
  {
    v10.tv_sec = 0;
    *(void *)&v10.tv_usec = 0;
    memset(v11, 0, sizeof(v11));
    if (Native < 1024)
    {
      double v7 = (fd_set *)v11;
    }
    else
    {
      unsigned int v5 = (Native + 1) >> 5;
      if (((Native + 1) & 0x1F) != 0) {
        ++v5;
      }
      size_t v6 = 4 * v5;
      double v7 = (fd_set *)malloc_type_malloc(v6, 0x25A76F04uLL);
      bzero(v7, v6);
    }
    if (__darwin_check_fd_set_overflow(v4, v7, 0)) {
      *(__int32_t *)((char *)v7->fds_bits + (((unint64_t)v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v4;
    }
    int v9 = select(v4 + 1, 0, v7, 0, &v10);
    if (v7 != (fd_set *)v11) {
      free(v7);
    }
    return v9 > 0;
  }
  else
  {
    LODWORD(v11[0]) = 0;
    LODWORD(v10.tv_sec) = 4;
    getsockopt(Native, 0xFFFF, 4128, v11, (socklen_t *)&v10);
    return LODWORD(v11[0]) != 0;
  }
}

uint64_t ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(SocketStream **)(a1 + 32);
  CFLog();
  v2.CFIndex domain = 4;
  *(void *)&v2.error = 4294965192;

  return SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(v1, v2);
}

void ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke_2(uint64_t a1)
{
}

uint64_t SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(SocketStream *this, CFStreamError a2)
{
  uint64_t v2 = *(void *)&a2.error;
  CFIndex domain = a2.domain;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  __int16 v6 = *((_WORD *)this + 126);
  *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
  *((_WORD *)this + 126) = v6 | 2;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  double v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = *((void *)this + 70);
    int v16 = 134218496;
    uint64_t v17 = v15;
    __int16 v18 = 2048;
    CFIndex v19 = domain;
    __int16 v20 = 1024;
    int v21 = v2;
    _os_log_error_impl(&dword_184085000, v7, OS_LOG_TYPE_ERROR, "TCP Conn %p timed out : error %ld %d", (uint8_t *)&v16, 0x1Cu);
  }
  SocketStream::cleanupConnection_NoLock(this);
  if (*((unsigned char *)this + 544))
  {
    *((unsigned char *)this + 544) = 0;
    CFRelease((char *)this - 16);
  }
  uint64_t v8 = *((void *)this + 48);
  if (v8)
  {
    dispatch_source_cancel(v8);
    dispatch_release(*((dispatch_object_t *)this + 48));
    *((void *)this + 48) = 0;
  }
  int v9 = *((void *)this + 49);
  if (v9)
  {
    dispatch_source_cancel(v9);
    dispatch_release(*((dispatch_object_t *)this + 49));
    *((void *)this + 49) = 0;
  }
  *((void *)this + 32) = domain;
  *((void *)this + 33) = v2;
  id WeakRetained = objc_loadWeakRetained((id *)this + 34);
  double v11 = WeakRetained;
  if (*((void *)this + 29) && *((uint64_t *)this + 28) >= 1 || !WeakRetained)
  {
    if (!WeakRetained) {
      goto LABEL_18;
    }
  }
  else if ((*((_DWORD *)this + 62) & 0x200) != 0)
  {
    _CFReadStreamSignalEventDelayed();
  }
  CFRelease(v11);
LABEL_18:
  id v12 = objc_loadWeakRetained((id *)this + 35);
  if (v12)
  {
    unsigned int v13 = v12;
    if ((*((_DWORD *)this + 62) & 0x400) != 0) {
      _CFWriteStreamSignalEventDelayed();
    }
    CFRelease(v13);
  }
  return pthread_mutex_unlock(v5);
}

CFStreamError *SocketStream::flushTransmissionBuffer_NoLock(CFStreamError *this)
{
  if ((this[15].error & 8) != 0)
  {
    uint64_t v1 = this;
    CFIndex domain = this[33].domain;
    if (domain)
    {
      int64_t v3 = *(void *)(domain + 24);
      if (v3 >= 1)
      {
        int v4 = *(unsigned __int8 **)(domain + 32);
        this = (CFStreamError *)SocketStream::sendToSocket((SocketStream *)this, v4, v3, this + 16);
        unsigned int v5 = this;
        CFIndex v6 = v1[33].domain;
        double v7 = *(CFStreamError **)(v6 + 24);
        if (v7 == this)
        {
          uint64_t v8 = this;
        }
        else
        {
          this = (CFStreamError *)memmove(v4, (char *)this + (void)v4, (char *)v7 - (char *)this);
          CFIndex v6 = v1[33].domain;
          uint64_t v8 = *(CFStreamError **)(v6 + 24);
        }
        *(void *)(v6 + 24) = (char *)v8 - (char *)v5;
      }
    }
  }
  return this;
}

void CFBufferConstantSize<36000l>::~CFBufferConstantSize(CFAllocatorRef *ptr)
{
}

uint64_t SocketStream::_copyPeerTrustWithPinning_NoLock(CFDictionaryRef *this, SSLContextRef context, SecTrustRef *trust)
{
  uint64_t result = SSLCopyPeerTrust(context, trust);
  if (trust && !result)
  {
    if (*trust)
    {
      uint64_t result = (uint64_t)CFDictionaryGetValue(this[42], &unk_1EC09FE50);
      if (result)
      {
        return SecTrustSetPinningPolicyName();
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t logPeerCertAvailable(SSLContext *a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_374, 1);
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void))(*(void *)result + 16))(result, "Peer certificate", 0);
    if (result)
    {
      SecTrustRef trust = 0;
      if (SSLCopyPeerTrust(a1, &trust))
      {
        (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v3 + 72))(v3, "Error", @"can't obtain peer certs (%d)");
      }
      else
      {
        CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        if (trust && SecTrustGetCertificateCount(trust))
        {
          CFArrayRef v5 = SecTrustCopyCertificateChain(trust);
          CFArrayRef v6 = v5;
          if (v5)
          {
            if (CFArrayGetCount(v5) >= 1)
            {
              CFDictionaryRef ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v6, 0);
              uint64_t v8 = ValueAtIndex;
              if (ValueAtIndex)
              {
                CFStringRef v9 = SecCertificateCopySubjectSummary(ValueAtIndex);
                uint64_t v23 = off_1ECF9A530;
                CFStringRef v10 = CFStringCreateWithCString(v4, "Subject Sum", 0x8000100u);
                uint64_t v25 = 0;
                uint64_t v26 = 0;
                uint64_t v24 = (uint64_t)v10;
                (*(void (**)(uint64_t))(*(void *)v3 + 64))(v3);
                AutoString::~AutoString((AutoString *)&v23);
                if (v9) {
                  CFRelease(v9);
                }
                CFStringRef commonName = 0;
                CFArrayRef emailAddresses = 0;
                if (SecCertificateCopyEmailAddresses(v8, &emailAddresses))
                {
                  CFArrayRef v11 = emailAddresses;
                  CFArrayRef emailAddresses = 0;
                  if (v11) {
                    CFRelease(v11);
                  }
                }
                OSStatus v12 = SecCertificateCopyCommonName(v8, &commonName);
                CFStringRef v13 = commonName;
                if (v12)
                {
                  CFStringRef commonName = 0;
                  if (v13) {
                    CFRelease(v13);
                  }
                }
                uint64_t v23 = off_1ECF9A530;
                CFStringRef v14 = CFStringCreateWithCString(v4, "Common Name", 0x8000100u);
                uint64_t v25 = 0;
                uint64_t v26 = 0;
                uint64_t v24 = (uint64_t)v14;
                (*(void (**)(uint64_t))(*(void *)v3 + 64))(v3);
                AutoString::~AutoString((AutoString *)&v23);
                if (emailAddresses)
                {
                  CFContainerEnumeratorBase::setup((unint64_t)&v23, emailAddresses, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
                  uint64_t v27 = 0;
                  if (v24 >= 1)
                  {
                    uint64_t v15 = 0;
                    do
                    {
                      uint64_t v27 = v15 + 1;
                      uint64_t v28 = off_1ECF9A530;
                      CFStringRef v29 = CFStringCreateWithCString(v4, "Email", 0x8000100u);
                      uint64_t v30 = 0;
                      uint64_t v31 = 0;
                      (*(void (**)(uint64_t))(*(void *)v3 + 64))(v3);
                      AutoString::~AutoString((AutoString *)&v28);
                      uint64_t v15 = v27;
                    }
                    while (v27 < v24);
                  }
                  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v23);
                }
                if (commonName) {
                  CFRelease(commonName);
                }
                if (emailAddresses) {
                  CFRelease(emailAddresses);
                }
                int v16 = (const void *)SecCertificateCopyIssuerSummary();
                uint64_t v23 = off_1ECF9A530;
                CFStringRef v17 = CFStringCreateWithCString(v4, "Summary", 0x8000100u);
                uint64_t v25 = 0;
                uint64_t v26 = 0;
                uint64_t v24 = (uint64_t)v17;
                (*(void (**)(uint64_t))(*(void *)v3 + 64))(v3);
                AutoString::~AutoString((AutoString *)&v23);
                if (v16) {
                  CFRelease(v16);
                }
              }
            }
            CFRelease(v6);
          }
        }
        else
        {
          uint64_t v23 = off_1ECF9A530;
          CFStringRef v18 = CFStringCreateWithCString(v4, "Error", 0x8000100u);
          uint64_t v25 = 0;
          uint64_t v26 = 0;
          uint64_t v24 = (uint64_t)v18;
          uint64_t v28 = off_1ECF9A530;
          CFStringRef v19 = CFStringCreateWithCString(v4, "NULL or empty trust returned", 0x8000100u);
          uint64_t v30 = 0;
          uint64_t v31 = 0;
          CFStringRef v29 = v19;
          (*(void (**)(uint64_t, uint64_t, CFStringRef))(*(void *)v3 + 64))(v3, v24, v19);
          AutoString::~AutoString((AutoString *)&v28);
          AutoString::~AutoString((AutoString *)&v23);
        }
      }
      if (trust) {
        CFRelease(trust);
      }
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  return result;
}

void sub_18420A508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  CFRelease(v6);
  _Unwind_Resume(a1);
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 568))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    CFAllocatorRef v4 = *(NSObject **)(v2 + 568);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_2;
    v5[3] = &__block_descriptor_44_e5_v8__0l;
    v5[4] = v2;
    int v6 = a2;
    dispatch_async(v4, v5);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

void SocketStream::unscheduleFromSSL(SocketStream *this)
{
  uint64_t v2 = 0;
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  long long v3 = *((_OWORD *)this + 19);
  uint64_t v4 = *((void *)this + 40);
  do
  {
    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)((char *)&v3 + v2));
    v2 += 8;
  }
  while (v2 != 24);
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_3(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 568))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    if (a2) {
      CFRetain(a2);
    }
    uint64_t v4 = *(NSObject **)(v2 + 568);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_4;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v2;
    void v5[5] = a2;
    dispatch_async(v4, v5);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t translateSSLContextError(SSLContext *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2 == -9809)
  {
    SSLClientCertificateState v5 = kSSLClientCertNone;
    if (!SSLGetClientCertificateState(a1, &v5) && v5 == kSSLClientCertSent) {
      return 4294957471;
    }
  }
  else if (a2 == -9824)
  {
    clientint State = kSSLClientCertNone;
    if (!SSLGetClientCertificateState(a1, &clientState) && clientState == kSSLClientCertRequested) {
      return 4294957467;
    }
  }
  return v2;
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_4(uint64_t a1)
{
  uint64_t v2 = *(SocketStream **)(a1 + 32);
  SocketStream::securitySetPeerCert(v2, *(const __CFArray **)(a1 + 40));
  long long v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }

  CFRelease((char *)v2 - 16);
}

void SocketStream::securitySetPeerCert(SocketStream *this, const __CFArray *a2)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  SocketStream::securitySetPeerCert_NoLock(this, a2, (SocketStreamSignalHolder *)v6);
  pthread_mutex_unlock(v4);
  SocketStream::dispatchSignalFromSocketCallbackUnlocked((CFRunLoopSourceRef *)v6, v5);
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)v6);
}

void sub_18420A8A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void SocketStream::securitySetPeerCert_NoLock(SocketStream *this, const __CFArray *a2, SocketStreamSignalHolder *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    SSLClientCertificateState v5 = (SSLContext *)*((void *)this + 37);
    if (v5) {
      SSLSetCertificate(v5, a2);
    }
  }
  uint64_t v6 = *((unsigned int *)this + 62);
  if ((v6 & 0x20000000) != 0)
  {
    uint64_t v7 = 0;
    unint64_t v8 = v6 & 0xFFFFFFFFDFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = v6 & 0xDFFFFFFF;
    *((_WORD *)this + 126) = WORD2(v8);
    long long v10 = *((_OWORD *)this + 19);
    uint64_t v11 = *((void *)this + 40);
    do
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)((char *)&v10 + v7));
      v7 += 8;
    }
    while (v7 != 24);
    if (!*((_DWORD *)this + 103))
    {
      SocketStream::socketCallbackReadLocked(this, a3, v9);
      SocketStream::prepareSignalFromSocketCallbackLocked(this, a3);
    }
  }
}

void SocketStream::dispatchSignalFromSocketCallbackUnlocked(CFRunLoopSourceRef *this, SocketStreamSignalHolder *a2)
{
  if (this[1])
  {
    if (this[5])
    {
      CFRunLoopSourceSignal(this[5]);
      CFRunLoopWakeUp(this[7]);
    }
    else
    {
      CFReadStreamSignalEvent();
    }
  }
  if (this[2])
  {
    if (this[6])
    {
      CFRunLoopSourceSignal(this[6]);
      long long v3 = this[8];
      CFRunLoopWakeUp(v3);
    }
    else
    {
      CFWriteStreamSignalEvent();
    }
  }
}

void SocketStreamSignalHolder::~SocketStreamSignalHolder(SocketStreamSignalHolder *this)
{
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  long long v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 5);
  if (v4) {
    CFRelease(v4);
  }
  SSLClientCertificateState v5 = (const void *)*((void *)this + 6);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 7);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)*((void *)this + 8);
  if (v7) {
    CFRelease(v7);
  }
}

void SocketStream::socketCallbackReadLocked(SocketStream *this, SocketStreamSignalHolder *a2, uint64_t a3)
{
  unsigned int v4 = *((_DWORD *)this + 103);
  if (!v4)
  {
    uint64_t v7 = *((unsigned int *)this + 62);
    unint64_t v8 = v7 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    if ((v7 & 0x800000) == 0)
    {
      *((_WORD *)this + 126) = (v7 & 0xFFFFFFFFFFFFFFDFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) >> 32;
      *((_DWORD *)this + 62) = v7 & 0xFFFFFFDB | 4;
LABEL_27:
      *(void *)a2 = 2;
      id WeakRetained = objc_loadWeakRetained((id *)this + 34);
      CFStringRef v18 = (const void *)*((void *)a2 + 1);
      if (v18) {
        CFRelease(v18);
      }
      *((void *)a2 + 1) = WeakRetained;
      return;
    }
    if ((v7 & 0x2000) != 0)
    {
      SocketStream::securityBufferedRead_NoLock(this);
      goto LABEL_26;
    }
    Mutable = (__CFData *)*((void *)this + 29);
    if (Mutable)
    {
      if (*((uint64_t *)this + 28) >= 0x8000)
      {
        int v10 = v8 | 0x2000000;
LABEL_24:
        *((_WORD *)this + 126) = WORD2(v8);
        *((_DWORD *)this + 62) = v10;
        goto LABEL_26;
      }
    }
    else
    {
      CFAllocatorRef v11 = CFGetAllocator((char *)this - 16);
      Mutable = CFDataCreateMutable(v11, 0x8000);
      *((void *)this + 28) = 0;
      *((void *)this + 29) = Mutable;
      if (!Mutable)
      {
        *((void *)this + 29) = 0;
        *((void *)this + 32) = 1;
        *((_DWORD *)this + 66) = 12;
        goto LABEL_26;
      }
    }
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    uint64_t v13 = SocketStream::recvBytes(this, &MutableBytePtr[*((void *)this + 28)], 0x8000 - *((void *)this + 28), (CFStreamError *)this + 16);
    unint64_t v8 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    unint64_t v14 = *((_DWORD *)this + 62) & 0xFDFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) &= ~0x2000000u;
    *((_WORD *)this + 126) = WORD2(v14);
    if (v13 < 1)
    {
      if (v13) {
        goto LABEL_26;
      }
      int v10 = v8 & 0xFDEFFFDB | 0x100004;
      goto LABEL_24;
    }
    *((void *)this + 28) += v13;
    uint64_t v15 = (__CFSocket *)*((void *)this + 36);
    if (v15 && CFSocketIsValid(v15)) {
      CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
    }
    unint64_t v16 = *((_DWORD *)this + 62) & 0xFFFFFFDF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = *((_DWORD *)this + 62) & 0xFFFFFFDB | 4;
    *((_WORD *)this + 126) = WORD2(v16);
LABEL_26:
    if ((*((_DWORD *)this + 62) & 4) == 0) {
      return;
    }
    goto LABEL_27;
  }
  uint64_t v5 = 0;
  while (((v4 >> v5) & 1) == 0)
  {
    if (++v5 == 8)
    {
      uint64_t v5 = 0;
      break;
    }
  }

  SocketStream::performHandshake((uint64_t)this, v5, a3);
}

void SocketStream::prepareSignalFromSocketCallbackLocked(SocketStream *this, SocketStreamSignalHolder *a2)
{
  if (*((_DWORD *)this + 66))
  {
    *(_OWORD *)((char *)a2 + 24) = *((_OWORD *)this + 16);
    *(void *)a2 = 8;
    id WeakRetained = objc_loadWeakRetained((id *)this + 34);
    uint64_t v5 = (const void *)*((void *)a2 + 1);
    if (v5) {
      CFRelease(v5);
    }
    *((void *)a2 + 1) = WeakRetained;
    id v6 = objc_loadWeakRetained((id *)this + 35);
    uint64_t v7 = (const void *)*((void *)a2 + 2);
    if (v7) {
      CFRelease(v7);
    }
    *((void *)a2 + 2) = v6;
  }
  unint64_t v8 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v8 & 0x1000000200) != 0x200)
  {
    uint64_t v9 = (const void *)*((void *)a2 + 1);
    if (v9) {
      CFRelease(v9);
    }
    *((void *)a2 + 1) = 0;
    unint64_t v8 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  }
  if ((v8 & 0x2000000400) != 0x400)
  {
    int v10 = (const void *)*((void *)a2 + 2);
    if (v10) {
      CFRelease(v10);
    }
    *((void *)a2 + 2) = 0;
  }
  if (*(void *)a2)
  {
    CFAllocatorRef v11 = (const void *)*((void *)this + 72);
    if (v11)
    {
      uint64_t v12 = (__CFRunLoopSource *)CFRetain(v11);
      *((void *)a2 + 5) = v12;
      if (v12)
      {
        memset(&cf, 0, sizeof(cf));
        CFRunLoopSourceGetContext(v12, &cf);
        info = cf.info;
        if (cf.info) {
          info = (void *)CFRetain(cf.info);
        }
        *((void *)a2 + 7) = info;
      }
    }
    else
    {
      *((void *)a2 + 5) = 0;
    }
    unint64_t v16 = (const void *)*((void *)this + 73);
    if (v16)
    {
      CFStringRef v17 = (__CFRunLoopSource *)CFRetain(v16);
      *((void *)a2 + 6) = v17;
      if (v17)
      {
        memset(&cf, 0, sizeof(cf));
        CFRunLoopSourceGetContext(v17, &cf);
        CFStringRef v18 = cf.info;
        if (cf.info) {
          CFStringRef v18 = (void *)CFRetain(cf.info);
        }
        *((void *)a2 + 8) = v18;
      }
    }
    else
    {
      *((void *)a2 + 6) = 0;
    }
    if (*((void *)a2 + 1) && *(void *)a2 == 8 && *((void *)this + 29) && *((uint64_t *)this + 28) >= 1)
    {
      *(void *)a2 = 2;
      *((void *)a2 + 3) = 0;
      *((void *)a2 + 4) = 0;
    }
  }
  else
  {
    unint64_t v14 = (const void *)*((void *)a2 + 1);
    if (v14) {
      CFRelease(v14);
    }
    *((void *)a2 + 1) = 0;
    uint64_t v15 = (const void *)*((void *)a2 + 2);
    if (v15) {
      CFRelease(v15);
    }
    *((void *)a2 + 2) = 0;
  }
}

void SocketStream::performHandshake(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](a1, a2, a3);
  uint64_t v223 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = v3;
  switch(v4)
  {
    case 1:
      CFNumberRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EC09FC90);
      uint64_t v7 = (__CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC09FC58);
      if (v7)
      {
        CFDataRef v8 = v7;
        MutableBytePtr = CFDataGetMutableBytePtr(v7);
        CFIndex Length = CFDataGetLength(v8);
        if (Length == 2) {
          goto LABEL_4;
        }
        CFIndex v76 = Length;
        *(void *)&buf[8] = 0;
        *(void *)CFStreamClientContext buf = 0;
        uint64_t v77 = SocketStream::recvBytes((SocketStream *)v5, &MutableBytePtr[Length], 2 - Length, (CFStreamError *)buf);
        if (v77)
        {
          if (v77 >= 1)
          {
            size_t v78 = v77 + v76;
            memcpy(__dst, MutableBytePtr, v78);
            CFDataSetLength(v8, v78);
            memcpy(MutableBytePtr, __dst, v78);
            CFTypeRef v79 = *(__CFSocket **)(v5 + 288);
            if (v79 && CFSocketIsValid(v79)) {
              CFSocketEnableCallBacks(*(CFSocketRef *)(v5 + 288), 1uLL);
            }
            if (v78 == 2)
            {
LABEL_4:
              int v11 = MutableBytePtr[1];
              if (v11 == 2)
              {
                CFDictionaryRef v107 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC0A1120);
                uint64_t v108 = CFDictionaryGetValue(v107, (const void *)*MEMORY[0x1E4F1D470]);
                uint64_t v109 = CFDictionaryGetValue(v107, (const void *)*MEMORY[0x1E4F1D450]);
                CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC58);
                if (v108) {
                  BOOL v110 = v109 == 0;
                }
                else {
                  BOOL v110 = 1;
                }
                if (!v110)
                {
                  SocketStream::addHandshake_NoLock(v5, 2);
LABEL_174:
                  SocketStream::addHandshake_NoLock(v5, 3);
                  uint64_t v103 = v5;
                  uint64_t v104 = 1;
LABEL_175:
                  SocketStream::removeHandshake_NoLock(v103, v104);
                  goto LABEL_176;
                }
                int v11 = MutableBytePtr[1];
              }
              else if (!MutableBytePtr[1])
              {
                CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC58);
                goto LABEL_174;
              }
              int v18 = v11 | 0x40000;
              uint64_t v17 = (int)*MEMORY[0x1E4F1D428];
              goto LABEL_141;
            }
LABEL_176:
            if (*(_DWORD *)(v5 + 264))
            {
              SocketStream::removeHandshake_NoLock(v5, 1);
            }
            return;
          }
          int v18 = *(_DWORD *)&buf[8];
          uint64_t v17 = *(void *)buf;
          if (*(_DWORD *)&buf[8] == 35 && *(void *)buf == 1) {
            goto LABEL_176;
          }
        }
        else
        {
          int v18 = 57;
          uint64_t v17 = 1;
        }
LABEL_141:
        *(void *)(v5 + 256) = v17;
      }
      else
      {
        *(void *)&buf[8] = 0;
        *(void *)CFStreamClientContext buf = 0;
        if (Value) {
          goto LABEL_161;
        }
        CFDictionaryRef v52 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC0A1120);
        CFStringRef v53 = (const __CFString *)CFDictionaryGetValue(v52, (const void *)*MEMORY[0x1E4F1D470]);
        CFStringRef v54 = (const __CFString *)CFDictionaryGetValue(v52, (const void *)*MEMORY[0x1E4F1D450]);
        CFAllocatorRef v55 = CFGetAllocator(*(CFTypeRef *)(v5 + 336));
        CFMutableDataRef Mutable = CFDataCreateMutable(v55, 4);
        if (Mutable)
        {
          CFNumberRef Value = Mutable;
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC90, Mutable);
          CFRelease(Value);
          uint64_t v57 = CFDataGetMutableBytePtr((CFMutableDataRef)Value);
          CFDataSetLength((CFMutableDataRef)Value, 4);
          *(_DWORD *)uint64_t v57 = 33554693;
          if (v53 && CFStringGetLength(v53) && v54 && CFStringGetLength(v54)) {
            v57[1] = 2;
          }
          else {
            CFDataSetLength((CFMutableDataRef)Value, 3);
          }
LABEL_161:
          size_t v116 = CFDataGetLength((CFDataRef)Value);
          BytePtr = CFDataGetBytePtr((CFDataRef)Value);
          uint64_t v118 = SocketStream::sendToSocket((SocketStream *)v5, BytePtr, v116, (CFStreamError *)buf);
          uint64_t v119 = v118;
          size_t v120 = v116 - v118;
          if (v120)
          {
            if (v118 < 1)
            {
              if (*(_DWORD *)&buf[8] != 35 || *(void *)buf != 1)
              {
                long long v115 = *(_OWORD *)buf;
LABEL_173:
                *(_OWORD *)(v5 + 256) = v115;
              }
            }
            else
            {
              v124 = CFDataGetMutableBytePtr((CFMutableDataRef)Value);
              memmove(v124, &v124[v119], v120);
              CFDataSetLength((CFMutableDataRef)Value, v120);
              v125 = *(__CFSocket **)(v5 + 288);
              if (v125 && CFSocketIsValid(v125)) {
                CFSocketEnableCallBacks(*(CFSocketRef *)(v5 + 288), 8uLL);
              }
            }
            goto LABEL_176;
          }
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC90);
          CFAllocatorRef v121 = CFGetAllocator(*(CFTypeRef *)(v5 + 336));
          CFMutableDataRef v122 = CFDataCreateMutable(v121, 2);
          if (v122)
          {
            CFMutableDataRef v123 = v122;
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC58, v122);
            CFRelease(v123);
            goto LABEL_176;
          }
        }
LABEL_168:
        *(void *)(v5 + 256) = 1;
        int v18 = 12;
      }
LABEL_169:
      *(_DWORD *)(v5 + 264) = v18;
      goto LABEL_176;
    case 2:
      CFNumberRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EC09FC90);
      uint64_t v13 = (__CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC09FC58);
      if (v13)
      {
        CFDataRef v14 = v13;
        uint64_t v15 = CFDataGetMutableBytePtr(v13);
        CFIndex v16 = CFDataGetLength(v14);
        if (v16 != 2)
        {
          CFIndex v80 = v16;
          *(void *)&buf[8] = 0;
          *(void *)CFStreamClientContext buf = 0;
          uint64_t v81 = SocketStream::recvBytes((SocketStream *)v5, &v15[v16], 2 - v16, (CFStreamError *)buf);
          if (!v81)
          {
            *(void *)(v5 + 256) = 1;
            int v18 = 57;
            goto LABEL_169;
          }
          if (v81 < 1)
          {
            if (*(_DWORD *)&buf[8] != 35 || *(void *)buf != 1)
            {
              long long v115 = *(_OWORD *)buf;
              goto LABEL_173;
            }
            goto LABEL_176;
          }
          size_t v82 = v81 + v80;
          memcpy(__dst, v15, v82);
          CFDataSetLength(v14, v82);
          memcpy(v15, __dst, v82);
          CFRange v83 = *(__CFSocket **)(v5 + 288);
          if (v83 && CFSocketIsValid(v83)) {
            CFSocketEnableCallBacks(*(CFSocketRef *)(v5 + 288), 1uLL);
          }
          if (v82 != 2) {
            goto LABEL_176;
          }
        }
        if (v15[1])
        {
          uint64_t v17 = (int)*MEMORY[0x1E4F1D428];
          int v18 = v15[1] | 0x30000;
          goto LABEL_141;
        }
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC58);
        uint64_t v103 = v5;
        uint64_t v104 = 2;
        goto LABEL_175;
      }
      *(void *)&buf[8] = 0;
      *(void *)CFStreamClientContext buf = 0;
      if (Value) {
        goto LABEL_161;
      }
      CFDictionaryRef v58 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC0A1120);
      CFStringRef v59 = (const __CFString *)CFDictionaryGetValue(v58, (const void *)*MEMORY[0x1E4F1D470]);
      CFStringRef v60 = (const __CFString *)CFDictionaryGetValue(v58, (const void *)*MEMORY[0x1E4F1D450]);
      CFAllocatorRef v61 = CFGetAllocator(*(CFTypeRef *)(v5 + 336));
      CFMutableDataRef v62 = CFDataCreateMutable(v61, 513);
      if (v62)
      {
        CFNumberRef Value = v62;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC90, v62);
        CFRelease(Value);
        int v63 = CFDataGetMutableBytePtr((CFMutableDataRef)Value);
        CFDataSetLength((CFMutableDataRef)Value, 513);
        UInt8 *v63 = 1;
        CFStringGetPascalString(v59, v63 + 1, 256, 0x8000100u);
        CFStringGetPascalString(v60, &v63[v63[1] + 2], 256, 0x8000100u);
        CFDataSetLength((CFMutableDataRef)Value, v63[1] + v63[v63[1] + 2] + 3);
        goto LABEL_161;
      }
      goto LABEL_168;
    case 3:
      CFStringRef v19 = (__CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_1EC09FC90);
      __int16 v20 = (__CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC09FC58);
      if (v20)
      {
        CFDataRef v21 = v20;
        __dst[0] = 0uLL;
        uint64_t v22 = CFDataGetMutableBytePtr(v20);
        CFIndex v23 = CFDataGetLength(v21);
        CFIndex v24 = v23;
        if (v23 > 1)
        {
          SInt32 error = 0;
          uint64_t v25 = 0;
        }
        else
        {
          uint64_t v25 = SocketStream::recvBytes((SocketStream *)v5, &v22[v23], 2 - v23, __dst);
          SInt32 error = __dst[0].error;
        }
        uint64_t v84 = v25 & ~(v25 >> 63);
        unint64_t v85 = v84 + v24;
        if (error || (uint64_t)v85 < 2) {
          goto LABEL_292;
        }
        if (*v22 != 5)
        {
          int v86 = 327935;
          goto LABEL_112;
        }
        if (v22[1])
        {
          int v86 = v22[1] | 0x50000;
LABEL_112:
          *(void *)(v5 + 256) = (int)*MEMORY[0x1E4F1D428];
LABEL_396:
          *(_DWORD *)(v5 + 264) = v86;
          goto LABEL_397;
        }
        if (v85 > 7)
        {
          SInt32 error = 0;
        }
        else
        {
          uint64_t v25 = SocketStream::recvBytes((SocketStream *)v5, &v22[v85], 8 - v85, __dst);
          uint64_t v84 = v25 & ~(v25 >> 63);
          SInt32 error = __dst[0].error;
        }
        v85 += v84;
        if (error || v85 < 5) {
          goto LABEL_292;
        }
        int v147 = v22[3];
        switch(v147)
        {
          case 1:
            unint64_t v148 = 10;
            break;
          case 4:
            unint64_t v148 = 22;
            break;
          case 3:
            unint64_t v148 = v22[4] + 7;
            break;
          default:
            unint64_t v148 = 0;
            *(void *)(v5 + 256) = (int)*MEMORY[0x1E4F1D428];
            *(_DWORD *)(v5 + 264) = 327681;
            break;
        }
        if (!*(_DWORD *)(v5 + 264))
        {
          if (v148 <= v85
            || (uint64_t v25 = SocketStream::recvBytes((SocketStream *)v5, &v22[v85], v148 - v85, __dst),
                (SInt32 error = __dst[0].error) == 0))
          {
            if (v25 + v85 == v148)
            {
              CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC58);
              SocketStream::removeHandshake_NoLock(v5, 3);
              return;
            }
            if (v25) {
              goto LABEL_397;
            }
            goto LABEL_395;
          }
LABEL_292:
          if (v25)
          {
            if (!error) {
              goto LABEL_397;
            }
            if (error == 35 && __dst[0].domain == 1)
            {
              memcpy(buf, v22, v85);
              CFDataSetLength(v21, v85);
              memcpy(v22, buf, v85);
              v161 = *(__CFSocket **)(v5 + 288);
              if (v161 && CFSocketIsValid(v161)) {
                CFSocketEnableCallBacks(*(CFSocketRef *)(v5 + 288), 1uLL);
              }
              goto LABEL_397;
            }
            CFStreamError v127 = __dst[0];
LABEL_300:
            *(CFStreamError *)(v5 + 256) = v127;
            goto LABEL_397;
          }
LABEL_395:
          *(void *)(v5 + 256) = 1;
          int v86 = 57;
          goto LABEL_396;
        }
LABEL_397:
        if (*(_DWORD *)(v5 + 264)) {
          SocketStream::removeHandshake_NoLock(v5, 1);
        }
        return;
      }
      *(void *)&buf[8] = 0;
      *(void *)CFStreamClientContext buf = 0;
      if (v19) {
        goto LABEL_62;
      }
      LODWORD(__dst[0].domain) = 0;
      uint64_t v92 = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC0A0FD0);
      CFBooleanRef v93 = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC0A1078);
      CFArrayRef Info = (const __CFArray *)CFHostGetInfo((uint64_t)v92, 1, 0);
      CFArrayRef ValueAtIndex = Info;
      if (Info)
      {
        if (CFArrayGetCount(Info)) {
          CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
        }
        else {
          CFArrayRef ValueAtIndex = 0;
        }
      }
      if (v93)
      {
        CFRetain(v93);
      }
      else
      {
        CFArrayRef v134 = (const __CFArray *)CFHostGetInfo((uint64_t)v92, 0, 0);
        if (!v134) {
          goto LABEL_237;
        }
        CFArrayRef v135 = v134;
        CFAllocatorRef v136 = CFGetAllocator(v92);
        CFIndex Count = CFArrayGetCount(v135);
        if (Count < 1) {
          goto LABEL_237;
        }
        CFIndex v138 = Count;
        uint64_t v139 = 1;
        do
        {
          CFDataRef v140 = (const __CFData *)CFArrayGetValueAtIndex(v135, v139 - 1);
          if (v140)
          {
            uint64_t v141 = CFDataGetBytePtr(v140);
            LODWORD(number.domain) = 0;
            LODWORD(number.domain) = bswap32(*((unsigned __int16 *)v141 + 1)) >> 16;
            CFBooleanRef v93 = CFNumberCreate(v136, kCFNumberSInt32Type, &number);
            if (v93) {
              break;
            }
          }
          else
          {
            CFBooleanRef v93 = 0;
          }
        }
        while (v139++ < v138);
        if (!v93) {
          goto LABEL_237;
        }
      }
      if (ValueAtIndex)
      {
        CFRetain(ValueAtIndex);
      }
      else
      {
        CFArrayRef v143 = (const __CFArray *)CFHostGetInfo((uint64_t)v92, 0, 0);
        CFArrayRef v144 = v143;
        if (!v143) {
          goto LABEL_236;
        }
        if (!CFArrayGetCount(v143)) {
          goto LABEL_236;
        }
        CFGetAllocator(v144);
        CFDataRef v145 = (const __CFData *)CFArrayGetValueAtIndex(v144, 0);
        CFArrayRef ValueAtIndex = (const __CFArray *)_CFNetworkCFStringCreateWithCFDataAddress(v145);
        if (!ValueAtIndex) {
          goto LABEL_236;
        }
      }
      CFAllocatorRef v131 = CFGetAllocator(*(CFTypeRef *)(v5 + 336));
      v132 = CFDataCreateMutable(v131, 262);
      CFStringRef v19 = v132;
      if (v132)
      {
        CFDataSetLength(v132, 262);
        v133 = CFDataGetMutableBytePtr(v19);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC90, v19);
        CFStringGetPascalString((CFStringRef)ValueAtIndex, v133 + 4, 256, 0x8000100u);
        *(_DWORD *)v133 = 50331909;
        CFNumberGetValue((CFNumberRef)v93, kCFNumberSInt32Type, __dst);
        *(_WORD *)&v133[v133[4] + 5] = bswap32(LOWORD(__dst[0].domain)) >> 16;
        CFDataSetLength(v19, v133[4] + 7);
        CFRelease(v19);
        CFRelease(v93);
        CFRelease(ValueAtIndex);
LABEL_62:
        size_t v64 = CFDataGetLength(v19);
        uint64_t v65 = CFDataGetBytePtr(v19);
        uint64_t v66 = SocketStream::sendToSocket((SocketStream *)v5, v65, v64, (CFStreamError *)buf);
        uint64_t v67 = v66;
        size_t v68 = v64 - v66;
        if (v68)
        {
          if (v66 >= 1)
          {
            uint64_t v105 = CFDataGetMutableBytePtr(v19);
            memmove(v105, &v105[v67], v68);
            CFDataSetLength(v19, v68);
            uint64_t v106 = *(__CFSocket **)(v5 + 288);
            if (v106 && CFSocketIsValid(v106)) {
              CFSocketEnableCallBacks(*(CFSocketRef *)(v5 + 288), 8uLL);
            }
            goto LABEL_397;
          }
          if (*(_DWORD *)&buf[8] != 35 || *(void *)buf != 1)
          {
            CFStreamError v127 = *(CFStreamError *)buf;
            goto LABEL_300;
          }
          goto LABEL_397;
        }
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC90);
        CFAllocatorRef v69 = CFGetAllocator(*(CFTypeRef *)(v5 + 336));
        CFMutableDataRef v70 = CFDataCreateMutable(v69, 262);
        if (v70)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09FC58, v70);
          CFRelease(v70);
          goto LABEL_397;
        }
LABEL_237:
        *(void *)(v5 + 256) = 1;
        int v86 = 12;
        goto LABEL_396;
      }
      CFRelease(ValueAtIndex);
LABEL_236:
      CFRelease(v93);
      goto LABEL_237;
    case 4:
      SocketStream::_PerformSOCKSv4Handshake_NoLock((CFDictionaryRef *)v3);
      return;
    case 5:
      id WeakRetained = objc_loadWeakRetained((id *)(v3 + 280));
      if (WeakRetained)
      {
        uint64_t v28 = WeakRetained;
        int v29 = *(_DWORD *)(v5 + 248);
        if ((v29 & 0x400) != 0)
        {
          *(_WORD *)(v5 + 252) = *(_WORD *)(v5 + 252);
          *(_DWORD *)(v5 + 248) = v29 | 8;
          _CFWriteStreamSignalEventDelayed();
        }
        CFRelease(v28);
      }
      id v30 = objc_loadWeakRetained((id *)(v5 + 272));
      if (v30)
      {
        uint64_t v31 = v30;
        int v32 = *(_DWORD *)(v5 + 248);
        if ((v32 & 0x200) != 0)
        {
          *(_WORD *)(v5 + 252) = *(_WORD *)(v5 + 252);
          *(_DWORD *)(v5 + 248) = v32 | 4;
          _CFReadStreamSignalEventDelayed();
        }
        CFRelease(v31);
      }
      return;
    case 6:
      *(void *)&number.SInt32 error = 0;
      number.CFIndex domain = 0;
      CFAllocatorRef v33 = CFGetAllocator(*(CFTypeRef *)(v3 + 336));
      unint64_t v34 = (char *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC0A5720);
      if (v34)
      {
        unint64_t v35 = v34;
        CFIndex v36 = SocketStream::socketRead((SocketStream *)v5, buf, 4096, &number);
        SInt32 v37 = number.error;
        if (number.error)
        {
          if (number.error != 35 || number.domain != 1)
          {
            *(void *)(v5 + 256) = number.domain;
LABEL_183:
            *(_DWORD *)(v5 + 264) = v37;
          }
LABEL_184:
          CFStringRef v126 = *(__CFSocket **)(v5 + 288);
          if (v126 && CFSocketIsValid(v126)) {
            CFSocketEnableCallBacks(*(CFSocketRef *)(v5 + 288), 1uLL);
          }
          return;
        }
        if (!v36)
        {
          *(void *)(v5 + 256) = 1;
          SInt32 v37 = 32;
          goto LABEL_183;
        }
        if (!CFHTTPMessageAppendBytes((CFHTTPMessageRef)v35, buf, v36))
        {
          *(void *)(v5 + 256) = 4;
          SInt32 v37 = -1;
          goto LABEL_183;
        }
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        if (*((void *)v35 + 13)) {
          goto LABEL_184;
        }
        CFStringRef v87 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)(v35 + 16), 0x11F1D2DBu);
        CFStreamError v88 = v87;
        if (v87)
        {
          CFStringGetCString(v87, (char *)__dst, 1024, 0x600u);
          CFRelease(v88);
          CFStreamError v88 = (const void *)atol((const char *)__dst);
        }
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        HTTPMessage::removeHeaderFieldValue((HTTPMessage *)(v35 + 16), 0x143153CAu);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        HTTPMessage::removeHeaderFieldValue((HTTPMessage *)(v35 + 16), 0x144173D0u);
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        if (v35[40])
        {
          HTTPMessage::ensureParserFinished((HTTPMessage *)(v35 + 16));
          if (*((void *)v35 + 8))
          {
            HTTPMessage::ensureParserFinished((HTTPMessage *)(v35 + 16));
            uint64_t v90 = (const __CFData **)*((void *)v35 + 8);
            if (v90) {
              uint64_t v90 = (const __CFData **)HTTPBodyData::getLength(v90, v89);
            }
            CFStreamError v88 = (const void *)((unsigned char *)v88 - (unsigned char *)v90);
          }
        }
        if (v88) {
          goto LABEL_184;
        }
        if ((unint64_t)(CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)v35) - 300) >= 0xFFFFFFFFFFFFFF9CLL)
        {
          unint64_t v162 = *(unsigned int *)(v5 + 248) | ((unint64_t)*(unsigned __int16 *)(v5 + 252) << 32);
          if ((v162 & 0x400000000) == 0 || !*(void *)(v5 + 296)) {
            goto LABEL_307;
          }
          *(_DWORD *)(v5 + 248) = *(_DWORD *)(v5 + 248);
          *(_WORD *)(v5 + 252) = (v162 | 0x800000000) >> 32;
          int v91 = 7;
        }
        else
        {
          int v91 = 5;
        }
        SocketStream::addHandshake_NoLock(v5, v91);
LABEL_307:
        SocketStream::removeHandshake_NoLock(v5, 6);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC0A5790);
        goto LABEL_184;
      }
      uint64_t v71 = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC09F520);
      if (v71) {
        goto LABEL_66;
      }
      *(void *)CFStreamClientContext buf = 0;
      __dst[0].CFIndex domain = 0;
      CFDictionaryRef v96 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC0A5678);
      CFStringRef v97 = (const __CFString *)CFDictionaryGetValue(v96, &unk_1EC0A5758);
      if (!SocketStream::_CreateNameAndPortForCONNECTProxy(*(SocketStream **)(v5 + 336), (const __CFDictionary *)__dst, (const __CFString **)buf, (const __CFNumber **)(v5 + 256), v98))goto LABEL_188; {
      LODWORD(v2CFRetain((char *)this - 16) = 0;
      }
      v99 = *(const void **)buf;
      if (CFNumberGetValue(*(CFNumberRef *)buf, kCFNumberSInt32Type, &v216)
        && (CFIndex domain = (const void *)__dst[0].domain,
            (CFStringRef v100 = CFStringCreateWithFormat(v33, 0, @"%@:%d", __dst[0].domain, (unsigned __int16)v216)) != 0))
      {
        CFURLRef v101 = CFURLCreateWithString(v33, v100, 0);
        if (v101)
        {
          if (v97) {
            CFStringRef v102 = v97;
          }
          else {
            CFStringRef v102 = @"HTTP/1.1";
          }
          CFHTTPMessageRef context = CFHTTPMessageCreateRequest(v33, @"CONNECT", v101, v102);
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
          }
          HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x13921375u, @"keep-alive");
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
          }
          HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x11B152B9u, @"keep-alive");
          CFRelease(v101);
        }
        else
        {
          CFHTTPMessageRef context = 0;
        }
        CFRelease(v100);
        CFRelease(v99);
        if (context)
        {
          CFDictionaryRef v149 = (const __CFDictionary *)CFDictionaryGetValue(v96, &unk_1EC0A5640);
          CFDictionaryRef v150 = v149;
          if (v149)
          {
            if (!CFDictionaryGetValue(v149, &unk_1EC0A2310))
            {
              if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
                dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
              }
              HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x1290930Eu, domain);
            }
            if (!CFDictionaryGetValue(v150, @"User-Agent"))
            {
              if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
                dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
              }
              pthread_once(&initControl, initializeUserAgentString);
              HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x14E15421u, (const void *)sUserAgentString);
            }
            CFDictionaryApplyFunction(v150, (CFDictionaryApplierFunction)_CONNECTHeaderApplier, context);
          }
          else
          {
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
            }
            HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x1290930Eu, domain);
            if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
              dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
            }
            pthread_once(&initControl, initializeUserAgentString);
            HTTPMessage::setHeaderFieldStringValue((CFHTTPMessageRef)((char *)context + 16), 0x14E15421u, (const void *)sUserAgentString);
          }
          CFRelease((CFTypeRef)__dst[0].domain);
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
          }
          uint64_t v71 = HTTPMessage::copySerializedHeaders((CFHTTPMessageRef)((char *)context + 16), 1);
          CFRelease(context);
          if (v71)
          {
            CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09F520, v71);
            CFRelease(v71);
LABEL_66:
            size_t v72 = CFDataGetLength((CFDataRef)v71);
            CFRunLoopRef v73 = CFDataGetBytePtr((CFDataRef)v71);
            uint64_t v74 = SocketStream::sendToSocket((SocketStream *)v5, v73, v72, &number);
            if (number.error)
            {
              if (number.error != 35 || number.domain != 1)
              {
                *(CFStreamError *)(v5 + 256) = number;
                return;
              }
              uint64_t v75 = 0;
            }
            else
            {
              uint64_t v75 = v74;
            }
            v111 = *(__CFSocket **)(v5 + 288);
            if (v111 && CFSocketIsValid(v111)) {
              CFSocketEnableCallBacks(*(CFSocketRef *)(v5 + 288), 8uLL);
            }
            if (v72 == v75)
            {
              CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09F520);
              CFHTTPMessageRef Empty = CFHTTPMessageCreateEmpty(v33, 0);
              CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC0A5720, Empty);
              CFRelease(Empty);
              goto LABEL_184;
            }
            if (!v75) {
              return;
            }
            uint64_t v113 = CFDataGetBytePtr((CFDataRef)v71);
            CFDataRef v114 = CFDataCreate(v33, &v113[v75], v72 - v75);
            if (v114)
            {
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(v5 + 336), &unk_1EC09F520, v114);
              CFRelease(v114);
              return;
            }
          }
LABEL_191:
          *(void *)(v5 + 256) = 1;
          *(_DWORD *)(v5 + 264) = 12;
          return;
        }
      }
      else
      {
        CFRelease(v99);
      }
LABEL_188:
      if (__dst[0].domain) {
        CFRelease((CFTypeRef)__dst[0].domain);
      }
      if (!*(_DWORD *)(v5 + 264)) {
        goto LABEL_191;
      }
      return;
    case 7:
      int v38 = *(_DWORD *)(v3 + 264);
      if (v38)
      {
        uint64_t v39 = *(void *)(v3 + 256);
        if ((v38 != 35 || v39 != 1) && (v38 != -9803 || v39 != *MEMORY[0x1E4F1D430]))
        {
          SocketStream::removeSSLHandshake((SocketStream *)v3);
          return;
        }
      }
      uint64_t v42 = *(unsigned int *)(v3 + 248);
      unint64_t v43 = v42 | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
      if ((v42 & 0x60000000) != 0) {
        return;
      }
      if ((v42 & 0x18000) != 0x8000) {
        goto LABEL_200;
      }
      CFSocketGetNative(*(CFSocketRef *)(v3 + 288));
      uint64_t v44 = (CFNA *)SCNetworkSignatureCopyIdentifierForConnectedSocket();
      if (v44)
      {
        CFStringRef v46 = (const __CFString *)v44;
        CFStringRef v47 = CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore(v44, (const __CFString *)"TLSFalseStart", v45);
        if (!v47)
        {
          if (CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once != -1) {
            dispatch_once(&CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once, &__block_literal_global_11694);
          }
          CFNA::CFNetworkAgentClient::executeLegacyQuery((CFNA::CFNetworkAgentClient *)CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client, v46);
        }
        CFStringRef v48 = v47;
        CFComparisonResult v49 = CFStringCompare(v47, @"TRUE", 0);
        CFRelease(v46);
        CFRelease(v48);
        uint64_t v50 = *(unsigned int *)(v5 + 248);
        unint64_t v51 = v50 | ((unint64_t)*(unsigned __int16 *)(v5 + 252) << 32);
        if (v49 == kCFCompareEqualTo)
        {
          *(_DWORD *)(v5 + 248) = v50 | 0x10000;
          *(_WORD *)(v5 + 252) = WORD2(v51);
          SSLSetSessionOption(*(SSLContextRef *)(v5 + 296), kSSLSessionOptionFalseStart, 1u);
          unint64_t v43 = *(unsigned int *)(v5 + 248) | ((unint64_t)*(unsigned __int16 *)(v5 + 252) << 32);
          goto LABEL_200;
        }
      }
      else
      {
        unint64_t v51 = *(unsigned int *)(v5 + 248) | ((unint64_t)*(unsigned __int16 *)(v5 + 252) << 32);
      }
      unint64_t v43 = v51 & 0xFFFFFFFFFFFF7FFFLL;
      *(_DWORD *)(v5 + 248) = v43;
      *(_WORD *)(v5 + 252) = WORD2(v43);
LABEL_200:
      if ((v43 & 0x80000) != 0) {
        goto LABEL_321;
      }
      uint64_t v128 = *(SSLContext **)(v5 + 296);
      v216 = 0;
      peerIDLen[0] = 0;
      if (SSLGetPeerID(v128, (const void **)&v216, peerIDLen) || v216) {
        goto LABEL_320;
      }
      CFAllocatorRef v129 = CFGetAllocator(*(CFTypeRef *)(v5 + 336));
      __dst[0].CFIndex domain = 0;
      if (SSLGetPeerDomainNameLength(v128, (size_t *)__dst))
      {
        CFStringRef v130 = 0;
      }
      else
      {
        if (__dst[0].domain >= 7uLL) {
          CFRunLoopTimerContext v146 = (UInt8 *)CFAllocatorAllocate(v129, __dst[0].domain, 0);
        }
        else {
          CFRunLoopTimerContext v146 = buf;
        }
        if (SSLGetPeerDomainName(v128, (char *)v146, (size_t *)__dst)) {
          CFStringRef v130 = 0;
        }
        else {
          CFStringRef v130 = CFStringCreateWithBytes(v129, v146, __dst[0].domain, 0x8000100u, 0);
        }
        if (v146 != buf) {
          CFAllocatorDeallocate(v129, v146);
        }
      }
      if (!CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC0A5678)
        && !CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), &unk_1EC0A1120))
      {
        goto LABEL_269;
      }
      __dst[0].CFIndex domain = 0;
      number.CFIndex domain = 0;
      SocketStream::_CreateNameAndPortForCONNECTProxy(*(SocketStream **)(v5 + 336), (const __CFDictionary *)__dst, (const __CFString **)&number, (const __CFNumber **)buf, v151);
      v152 = (const void *)__dst[0].domain;
      v153 = (const void *)number.domain;
      if (__dst[0].domain && number.domain)
      {
        LODWORD(valuePtr[0]) = 0;
        CFNumberGetValue((CFNumberRef)number.domain, kCFNumberSInt32Type, valuePtr);
        if (v130) {
          v154 = (__CFString *)v130;
        }
        else {
          v154 = @"nulldomain";
        }
        CFAllocatorRef v155 = CFGetAllocator((CFTypeRef)(v5 - 16));
        CFStringRef v156 = CFStringCreateWithFormat(v155, 0, @"{%@:%d}%@", v152, LOWORD(valuePtr[0]), v154);
      }
      else
      {
        CFStringRef v156 = 0;
        if (!__dst[0].domain) {
          goto LABEL_266;
        }
      }
      CFRelease(v152);
LABEL_266:
      if (v153) {
        CFRelease(v153);
      }
      if (v156) {
        goto LABEL_310;
      }
LABEL_269:
      LODWORD(__dst[0].domain) = 255;
      if (v130) {
        v157 = (__CFString *)v130;
      }
      else {
        v157 = @"nulldomain";
      }
      CFSocketNativeHandle Native = CFSocketGetNative(*(CFSocketRef *)(v5 + 288));
      if (getpeername(Native, (sockaddr *)buf, (socklen_t *)__dst)) {
        goto LABEL_273;
      }
      if (buf[1] == 30)
      {
        CFAllocatorRef v163 = CFGetAllocator((CFTypeRef)(v5 - 16));
        CFStringRef v160 = CFStringCreateWithFormat(v163, 0, @"{%8.8x:%8.8x:%8.8x:%8.8x:%d}%@", *(unsigned int *)&buf[8], *(unsigned int *)&buf[12], *(unsigned int *)&buf[16], *(unsigned int *)&buf[20], *(unsigned __int16 *)&buf[2], v157);
      }
      else
      {
        if (buf[1] != 2)
        {
LABEL_273:
          CFStringRef v156 = 0;
          goto LABEL_310;
        }
        CFAllocatorRef v159 = CFGetAllocator((CFTypeRef)(v5 - 16));
        CFStringRef v160 = CFStringCreateWithFormat(v159, 0, @"{%d.%d.%d.%d:%d}%@", buf[7], buf[6], buf[5], buf[4], *(unsigned __int16 *)&buf[2], v157);
      }
      CFStringRef v156 = v160;
LABEL_310:
      if (v156) {
        CFStringRef v164 = v156;
      }
      else {
        CFStringRef v164 = v130;
      }
      if (v156 && v130) {
        CFRelease(v130);
      }
      if (v164)
      {
        *(void *)CFStreamClientContext buf = v129;
        *(void *)&buf[8] = 1023;
        *(void *)&uint8_t buf[16] = _CFStringGetOrCreateCString(v129, v164, v215, (uint64_t *)&buf[8], 0x8000100u);
        CFRelease(v164);
        SSLSetPeerID(v128, *(const void **)&buf[16], *(size_t *)&buf[8]);
        if (*(void *)&buf[16])
        {
          if (v215 != *(UInt8 **)&buf[16]) {
            CFAllocatorDeallocate(*(CFAllocatorRef *)buf, *(void **)&buf[16]);
          }
        }
      }
LABEL_320:
      unint64_t v43 = *(unsigned int *)(v5 + 248) | ((unint64_t)*(unsigned __int16 *)(v5 + 252) << 32);
LABEL_321:
      CFAllocatorRef v165 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      while (2)
      {
        if ((v43 & 0x4000000000) == 0)
        {
          if ((v43 & 0x20000000000) != 0) {
            *(CFAbsoluteTime *)(v5 + 680) = CFAbsoluteTimeGetCurrent();
          }
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          v166 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v167 = *(void *)(v5 + 560);
            *(_DWORD *)CFStreamClientContext buf = 134217984;
            *(void *)&uint8_t buf[4] = v167;
            _os_log_impl(&dword_184085000, v166, OS_LOG_TYPE_DEFAULT, "TCP Conn %p starting SSL negotiation", buf, 0xCu);
          }
          if (nw_settings_get_signposts_enabled()) {
            kdebug_trace();
          }
          uint64_t v168 = *(unsigned int *)(v5 + 248);
          unint64_t v169 = v168 | ((unint64_t)*(unsigned __int16 *)(v5 + 252) << 32) | 0x4000000000;
          *(_DWORD *)(v5 + 248) = v168;
          *(_WORD *)(v5 + 252) = WORD2(v169);
        }
        uint64_t v170 = SSLHandshake(*(SSLContextRef *)(v5 + 296));
        int v171 = v170;
        if ((int)v170 > -9804)
        {
          if (v170 != -9803)
          {
            if (!v170)
            {
              SocketStream::removeSSLHandshake((SocketStream *)v5);
              if (((*(unsigned int *)(v5 + 248) | ((unint64_t)*(unsigned __int16 *)(v5 + 252) << 32)) & 0x20000000000) != 0)
              {
                *(_DWORD *)CFStreamClientContext buf = 0;
                *(_DWORD *)CFStreamClientContext buf = (int)((CFAbsoluteTimeGetCurrent() - *(double *)(v5 + 680)) * 1000.0);
                CFDictionaryRef v179 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 112))(v5, v5 - 16, 0x1EC09F478);
                if (v179)
                {
                  CFAllocatorRef v180 = CFGetAllocator((CFTypeRef)(v5 - 16));
                  MutableCFHTTPMessageRef Copy = CFDictionaryCreateMutableCopy(v180, 0, v179);
                  CFAllocatorRef v182 = CFGetAllocator((CFTypeRef)(v5 - 16));
                  CFNumberRef v183 = CFNumberCreate(v182, kCFNumberSInt32Type, buf);
                  CFDictionaryAddValue(MutableCopy, @"_kCFStreamStatsTLS_HandshakeTimeMs", v183);
                  (*(void (**)(uint64_t, uint64_t, __CFDictionary *))(*(void *)v5 + 200))(v5, 0x1EC09F478, MutableCopy);
                  CFRelease(v179);
                  if (v183) {
                    CFRelease(v183);
                  }
                  if (MutableCopy) {
                    CFRelease(MutableCopy);
                  }
                }
              }
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
              }
              v184 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v185 = *(void *)(v5 + 560);
                *(_DWORD *)CFStreamClientContext buf = 134217984;
                *(void *)&uint8_t buf[4] = v185;
                _os_log_impl(&dword_184085000, v184, OS_LOG_TYPE_DEFAULT, "TCP Conn %p SSL Handshake DONE", buf, 0xCu);
              }
              if (nw_settings_get_signposts_enabled()) {
                kdebug_trace();
              }
              goto LABEL_377;
            }
LABEL_385:
            int v200 = translateSSLContextError(*(SSLContext **)(v5 + 296), v170);
            if (v200 == v171)
            {
              CFLog();
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
              }
              uint64_t v201 = CFNLog::logger;
              if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR)) {
                goto LABEL_393;
              }
              uint64_t v202 = *(void *)(v5 + 560);
              *(_DWORD *)CFStreamClientContext buf = 134218240;
              *(void *)&uint8_t buf[4] = v202;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v171;
              v203 = "TCP Conn %p SSLHandshake failed (%d)";
              v204 = v201;
              uint32_t v205 = 18;
            }
            else
            {
              CFLog();
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
              }
              uint64_t v206 = CFNLog::logger;
              if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR)) {
                goto LABEL_393;
              }
              uint64_t v207 = *(void *)(v5 + 560);
              *(_DWORD *)CFStreamClientContext buf = 134218496;
              *(void *)&uint8_t buf[4] = v207;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v171;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v200;
              v203 = "TCP Conn %p SSLHandshake failed (%d -> %d)";
              v204 = v206;
              uint32_t v205 = 24;
            }
            _os_log_error_impl(&dword_184085000, v204, OS_LOG_TYPE_ERROR, v203, buf, v205);
LABEL_393:
            *(void *)(v5 + 256) = (int)*MEMORY[0x1E4F1D430];
            *(_DWORD *)(v5 + 264) = v200;
            SocketStream::removeSSLHandshake((SocketStream *)v5);
            return;
          }
          goto LABEL_377;
        }
        if (v170 == -9842)
        {
          uint64_t v186 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 184))(v5);
          if (v186)
          {
            *(_DWORD *)(v5 + 248) |= 0x20000000u;
            CFArrayRef names = 0;
            if (SSLCopyDistinguishedNames(*(SSLContextRef *)(v5 + 296), &names))
            {
              CFArrayRef v187 = names;
              CFArrayRef names = 0;
              if (!v187)
              {
                CFArrayRef v188 = 0;
                goto LABEL_364;
              }
              CFRelease(v187);
            }
            CFArrayRef v188 = names;
LABEL_364:
            uint64_t v190 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_386, 1);
            uint64_t v191 = v190;
            if (v190
              && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v190 + 16))(v190, "Client Cert Requested", 0))
            {
              if (v188)
              {
                CFContainerEnumeratorBase::setup((unint64_t)buf, v188, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
                uint64_t v192 = *(void *)&buf[8];
                if (*(uint64_t *)&buf[8] >= 1)
                {
                  (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v191 + 72))(v191, "Distinguished Names", @"%ld");
                  uint64_t v193 = 0;
                  do
                  {
                    v194 = *(const void **)(*(void *)&buf[16] + 8 * v193);
                    CFAllocatorRef v195 = CFGetAllocator(v194);
                    CFStringRef v196 = CFStringCreateWithFormat(v195, 0, @"<< DATA %@ >>", v194);
                    snprintf((char *)__dst, 0xFFuLL, "%d", v193);
                    number.CFIndex domain = (CFIndex)off_1ECF9A530;
                    *(void *)&number.SInt32 error = CFStringCreateWithCString(v165, (const char *)__dst, 0x8000100u);
                    uint64_t v221 = 0;
                    uint64_t v222 = 0;
                    if (v196)
                    {
                      (*(void (**)(uint64_t))(*(void *)v191 + 64))(v191);
                      AutoString::~AutoString((AutoString *)&number);
                      CFRelease(v196);
                    }
                    else
                    {
                      v216 = off_1ECF9A530;
                      CFStringRef v217 = CFStringCreateWithCString(v165, "invalid name", 0x8000100u);
                      uint64_t v218 = 0;
                      uint64_t v219 = 0;
                      (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v191 + 64))(v191, *(void *)&number.error, v217);
                      AutoString::~AutoString((AutoString *)&v216);
                      AutoString::~AutoString((AutoString *)&number);
                    }
                    ++v193;
                  }
                  while (v192 != v193);
                }
                CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)buf);
              }
              (*(void (**)(uint64_t))(*(void *)v191 + 8))(v191);
            }
            CFRetain((CFTypeRef)(v5 - 16));
            valuePtr[0] = MEMORY[0x1E4F143A8];
            valuePtr[1] = 3221225472;
            valuePtr[2] = ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_3;
            valuePtr[3] = &__block_descriptor_40_e20_v16__0____CFArray__8l;
            valuePtr[4] = v5;
            (*(void (**)(uint64_t, CFArrayRef, void *))(*(void *)v186 + 48))(v186, names, valuePtr);
            (*(void (**)(uint64_t))(*(void *)v186 + 24))(v186);
            SocketStream::unscheduleFromSSL((SocketStream *)v5);
            CFArrayRef v178 = names;
            if (!names) {
              goto LABEL_377;
            }
LABEL_376:
            CFRelease(v178);
          }
LABEL_377:
          int v189 = 1;
          goto LABEL_378;
        }
        if (v170 != -9841) {
          goto LABEL_385;
        }
        uint64_t v172 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 184))(v5);
        if (v172)
        {
          *(_DWORD *)(v5 + 248) |= 0x40000000u;
          *(void *)CFStreamClientContext buf = 0;
          if (SocketStream::_copyPeerTrustWithPinning_NoLock((CFDictionaryRef *)v5, *(SSLContextRef *)(v5 + 296), (SecTrustRef *)buf))
          {
            v173 = *(const void **)buf;
            *(void *)CFStreamClientContext buf = 0;
            if (v173) {
              CFRelease(v173);
            }
          }
          CFDictionaryRef v174 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 336), @"kCFStreamPropertySSLSettings");
          CFDictionaryRef ATSVersion = StrictSecurity::getATSVersion(v174, v175);
          StrictSecurity::cloneSecTrust(&__dst[0].domain, (uint64_t)ATSVersion, *(uint64_t *)buf);
          v177 = *(const void **)(v5 + 688);
          *(void *)(v5 + 688) = __dst[0].domain;
          if (v177) {
            CFRelease(v177);
          }
          logPeerCertAvailable(*(SSLContext **)(v5 + 296));
          CFRetain((CFTypeRef)(v5 - 16));
          peerIDLen[0] = MEMORY[0x1E4F143A8];
          peerIDLen[1] = 3221225472;
          peerIDLen[2] = (size_t)___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke;
          peerIDLen[3] = (size_t)&__block_descriptor_40_e8_v12__0i8l;
          peerIDLen[4] = v5;
          (*(void (**)(uint64_t, void, size_t *))(*(void *)v172 + 40))(v172, *(void *)buf, peerIDLen);
          (*(void (**)(uint64_t))(*(void *)v172 + 24))(v172);
          SocketStream::unscheduleFromSSL((SocketStream *)v5);
          CFArrayRef v178 = *(CFArrayRef *)buf;
          if (!*(void *)buf) {
            goto LABEL_377;
          }
          goto LABEL_376;
        }
        int v189 = 0;
LABEL_378:
        uint64_t v197 = *(unsigned int *)(v5 + 248);
        unint64_t v43 = v197 | ((unint64_t)*(unsigned __int16 *)(v5 + 252) << 32);
        if ((v197 & 0x8000) == 0)
        {
          if (v189) {
            return;
          }
          continue;
        }
        break;
      }
      SocketStream::removeSSLHandshake((SocketStream *)v5);
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      v198 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v199 = *(void *)(v5 + 560);
        *(_DWORD *)CFStreamClientContext buf = 134217984;
        *(void *)&uint8_t buf[4] = v199;
        _os_log_impl(&dword_184085000, v198, OS_LOG_TYPE_DEFAULT, "TCP Conn %p SSL Handshake DONE (fs)", buf, 0xCu);
      }
      return;
    default:
      int v12 = v4;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)CFStreamClientContext buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v12;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "h = %d", buf, 8u);
      }
      return;
  }
}

void sub_18420D288(_Unwind_Exception *a1)
{
  uint64_t v3 = (void *)STACK[0x4E0];
  if (STACK[0x4E0])
  {
    if (v1 != v3) {
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x4D0], v3);
    }
  }
  _Unwind_Resume(a1);
}

void SocketStream::securityBufferedRead_NoLock(SocketStream *this)
{
  CFMutableDataRef Mutable = (__CFData *)*((void *)this + 29);
  if (Mutable)
  {
    uint64_t v3 = (uint64_t *)((char *)this + 224);
    uint64_t v4 = *((void *)this + 28);
    if (v4 >= 0x8000)
    {
LABEL_59:
      int v30 = *((_DWORD *)this + 62);
      uint64_t v26 = (char *)this + 248;
      unint64_t v28 = v30 & 0xFFFFFFDF | ((unint64_t)*((unsigned __int16 *)v26 + 2) << 32);
      unsigned int v29 = v30 & 0xFFFFFFDB | 4;
      goto LABEL_60;
    }
  }
  else
  {
    CFAllocatorRef v5 = CFGetAllocator((char *)this - 16);
    CFMutableDataRef Mutable = CFDataCreateMutable(v5, 0x8000);
    *((void *)this + 28) = 0;
    *((void *)this + 29) = Mutable;
    uint64_t v3 = (uint64_t *)((char *)this + 224);
    if (!Mutable)
    {
      *((void *)this + 32) = 1;
      *((_DWORD *)this + 66) = 12;
      return;
    }
    uint64_t v4 = 0;
  }
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  int v7 = *((_DWORD *)this + 66);
  uint64_t v8 = *((void *)this + 28);
  if (v7)
  {
    int v9 = 0;
    int v7 = 0;
  }
  else
  {
    int v10 = MutableBytePtr;
    int v9 = 0;
    uint64_t v32 = (int)*MEMORY[0x1E4F1D430];
    do
    {
      if (v8 >= 0x8000) {
        break;
      }
      int v11 = &v10[v8];
      size_t v12 = 0x8000 - v8;
      size_t processed = 0;
      while (1)
      {
        while (1)
        {
          uint64_t v13 = SSLRead(*((SSLContextRef *)this + 37), v11, v12, &processed);
          uint64_t v14 = *((unsigned int *)this + 62);
          unint64_t v15 = v14 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          int64_t v16 = processed;
          if ((v14 & 0x40000) == 0 && processed)
          {
            unint64_t v17 = HIDWORD(v15);
            v15 |= 0x40000uLL;
            *((_WORD *)this + 126) = v17;
            *((_DWORD *)this + 62) = v15;
          }
          int v18 = (IOLogger *)*((void *)this + 27);
          if (v18) {
            BOOL v19 = v13 == 0;
          }
          else {
            BOOL v19 = 0;
          }
          if (v19 && v16 != 0)
          {
            IOLogger::logBytesRead(v18, 1, v11, v16);
            int v9 = 0;
            int v7 = 0;
            int64_t v16 = processed;
            goto LABEL_37;
          }
          if ((int)v13 > -9842) {
            break;
          }
          if (v13 != -9842) {
            goto LABEL_33;
          }
          *((_WORD *)this + 126) = WORD2(v15);
          *((_DWORD *)this + 62) = v15 | 0x20000000;
          uint64_t v21 = (*(uint64_t (**)(SocketStream *))(*(void *)this + 184))(this);
          if (v21)
          {
            uint64_t v23 = v21;
            CFArrayRef names = 0;
            if (SSLCopyDistinguishedNames(*((SSLContextRef *)this + 37), &names))
            {
              CFArrayRef v24 = names;
              CFArrayRef names = 0;
              if (v24) {
                CFRelease(v24);
              }
            }
            CFRetain((char *)this - 16);
            v33[0] = MEMORY[0x1E4F143A8];
            v33[1] = 3221225472;
            v33[2] = ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke;
            v33[3] = &__block_descriptor_40_e20_v16__0____CFArray__8l;
            v33[4] = this;
            (*(void (**)(uint64_t, CFArrayRef, void *))(*(void *)v23 + 48))(v23, names, v33);
            if (names) {
              CFRelease(names);
            }
            (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
            SocketStream::unscheduleFromSSL(this);
            goto LABEL_47;
          }
          unint64_t v22 = *((_DWORD *)this + 62) & 0xDFFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          *((_DWORD *)this + 62) &= ~0x20000000u;
          *((_WORD *)this + 126) = WORD2(v22);
        }
        if ((int)v13 > -9807) {
          break;
        }
        if (v13 != -9841) {
          goto LABEL_33;
        }
        if (SocketStream::doSettingsOverrideTrustEvaluation((CFDictionaryRef *)this))
        {
          *((void *)this + 32) = v32;
          *((_DWORD *)this + 66) = -9807;
LABEL_47:
          int v9 = 0;
          int v7 = 0;
          uint64_t v8 = *v3;
          goto LABEL_48;
        }
      }
      if ((v13 + 9806) < 2)
      {
        int v7 = 0;
        int v9 = 1;
      }
      else if (v13 == -9803)
      {
        int v9 = 0;
        int v7 = 1;
      }
      else
      {
        if (v13)
        {
LABEL_33:
          if (!*((_DWORD *)this + 66))
          {
            int v31 = translateSSLContextError(*((SSLContext **)this + 37), v13);
            *((void *)this + 32) = v32;
            *((_DWORD *)this + 66) = v31;
            goto LABEL_47;
          }
        }
        int v9 = 0;
        int v7 = 0;
      }
LABEL_37:
      uint64_t v8 = *v3;
      if (v16 < 1) {
        break;
      }
      v8 += v16;
      *((void *)this + 28) = v8;
    }
    while (!*((_DWORD *)this + 66));
  }
LABEL_48:
  if (v8 | v4 || (*((_DWORD *)this + 62) & 0x100000) != 0)
  {
    if (!v7) {
      goto LABEL_56;
    }
  }
  else if ((*((_DWORD *)this + 62) & 0x60000000) != 0)
  {
    goto LABEL_56;
  }
  uint64_t v25 = (__CFSocket *)*((void *)this + 36);
  if (v25)
  {
    if (CFSocketIsValid(v25)) {
      CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
    }
  }
LABEL_56:
  if (!v9)
  {
    if (!*v3) {
      return;
    }
    goto LABEL_59;
  }
  int v27 = *((_DWORD *)this + 62);
  uint64_t v26 = (char *)this + 248;
  unint64_t v28 = v27 & 0xFFFFFFDF | ((unint64_t)*((unsigned __int16 *)v26 + 2) << 32);
  unsigned int v29 = v27 & 0xFFEFFFDB | 0x100004;
LABEL_60:
  *(_DWORD *)uint64_t v26 = v29;
  *((_WORD *)v26 + 2) = WORD2(v28);
}

uint64_t SocketStream::recvBytes(SocketStream *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  a4->CFIndex domain = 0;
  *(void *)&a4->SInt32 error = 0;
  id v6 = (__CFSocket *)*((void *)this + 36);
  if (v6 && CFSocketIsValid(v6))
  {
    return SocketStream::socketRead(this, a2, a3, a4);
  }
  else
  {
    a4->CFIndex domain = 1;
    a4->SInt32 error = 22;
    return -1;
  }
}

uint64_t SocketStream::socketRead(SocketStream *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  uint64_t v7 = __CFSocketRead();
  if (v7 < 0)
  {
    a4->CFIndex domain = 1;
    a4->SInt32 error = 0;
  }
  else
  {
    int v9 = (IOLogger *)*((void *)this + 27);
    BOOL v10 = v7 != 0;
    if (v9) {
      BOOL v11 = v7 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      IOLogger::logBytes(v9, "RAW-READ", 0x3Cu, a2, v7);
      BOOL v10 = 1;
    }
    if (*((unsigned char *)this + 644) && v10) {
      entr_act_modify_delayInitStub(v8);
    }
  }
  return v7;
}

uint64_t SocketStream::doSettingsOverrideTrustEvaluation(CFDictionaryRef *this)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(this[42], @"kCFStreamPropertySSLSettings");
  CFTypeRef cf = 0;
  uint64_t v3 = SocketStream::_copyPeerTrustWithPinning_NoLock(this, this[37], (SecTrustRef *)&cf);
  if (v3)
  {
    CFTypeRef v4 = cf;
    CFTypeRef cf = 0;
    if (!v4) {
      return 4294957494;
    }
    CFRelease(v4);
  }
  if (!cf) {
    return 4294957494;
  }
  if (Value)
  {
    CFAllocatorRef v5 = CFDictionaryGetValue(Value, &unk_1EC0A1778);
    if (v5)
    {
      id v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        LOWORD(v23[0]) = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)v23, 2u);
      }
      if ((const void *)*MEMORY[0x1E4F1CFC8] == v6) {
        goto LABEL_15;
      }
    }
  }
  BOOL v27 = 0;
  CFDataRef v8 = copyPeerID(this[37]);
  if (v8)
  {
    CFDataRef v9 = v8;
    if (TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce != -1) {
      dispatch_once(&TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce, &__block_literal_global_1892);
    }
    TrustExceptionManager::applyTrustExceptions((TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton, v9, (__SecTrust *)cf, &v27);
    CFRelease(v9);
    if (v27)
    {
LABEL_15:
      uint64_t v3 = 0;
      goto LABEL_43;
    }
  }
  CFNetworkTrust::CFNetworkTrust((CFNetworkTrust *)v23, cf);
  if (Value)
  {
    BOOL v10 = CFDictionaryGetValue(Value, @"kCFStreamSSLAllowsExpiredCertificates");
    BOOL v11 = v10;
    size_t v12 = (const void **)MEMORY[0x1E4F1CFD0];
    if (v10)
    {
      CFTypeID v13 = CFGetTypeID(v10);
      if (v13 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)CFStreamClientContext buf = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      if (*v12 == v11) {
        v25 |= 1u;
      }
    }
    uint64_t v14 = CFDictionaryGetValue(Value, @"kCFStreamSSLAllowsExpiredRoots");
    unint64_t v15 = v14;
    if (v14)
    {
      CFTypeID v16 = CFGetTypeID(v14);
      if (v16 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)CFStreamClientContext buf = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      if (*v12 == v15) {
        v25 |= 2u;
      }
    }
    unint64_t v17 = CFDictionaryGetValue(Value, @"kCFStreamSSLAllowsAnyRoot");
    int v18 = v17;
    if (v17)
    {
      CFTypeID v19 = CFGetTypeID(v17);
      if (v19 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)CFStreamClientContext buf = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      if (*v12 == v18) {
        v25 |= 4u;
      }
    }
    __int16 v20 = CFDictionaryGetValue(Value, @"_kCFStreamSSLTrustedLeafCertificates");
    if (v20) {
      v23[3] = (SecTrustRef)CFRetain(v20);
    }
  }
  *(_DWORD *)CFStreamClientContext buf = 0;
  if (MEMORY[0x18531B160](v23[1], buf))
  {
    v24 |= 0x20u;
  }
  else
  {
    int v21 = CFNetworkTrust::processEvaluateResult(v23, *(SecTrustResultType *)buf);
    if ((v21 - 1) >= 2)
    {
      if (!v21) {
        uint64_t v3 = 0;
      }
      goto LABEL_42;
    }
  }
  uint64_t v3 = CFNetworkTrust::errorForEvaluationFalure((CFNetworkTrust *)v23);
LABEL_42:
  CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)v23);
LABEL_43:
  if (cf) {
    CFRelease(cf);
  }
  return v3;
}

void sub_18420DC5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 568))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    if (a2) {
      CFRetain(a2);
    }
    CFTypeRef v4 = *(NSObject **)(v2 + 568);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke_2;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v2;
    void v5[5] = a2;
    dispatch_async(v4, v5);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(SocketStream **)(a1 + 32);
  SocketStream::securitySetPeerCert(v2, *(const __CFArray **)(a1 + 40));
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }

  CFRelease((char *)v2 - 16);
}

CFDataRef copyPeerID(SSLContext *a1)
{
  CFIndex length = 0;
  peerID = 0;
  OSStatus v1 = SSLGetPeerID(a1, (const void **)&peerID, (size_t *)&length);
  CFDataRef result = 0;
  if (!v1)
  {
    if (peerID) {
      return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)peerID, length);
    }
  }
  return result;
}

void SocketStream::_PerformSOCKSv4Handshake_NoLock(CFDictionaryRef *this)
{
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(this[42], &unk_1EC09FC90);
  uint64_t v3 = (__CFData *)CFDictionaryGetValue(this[42], &unk_1EC09FC58);
  if (Value)
  {
    v26.CFIndex domain = 0;
    *(void *)&v26.SInt32 error = 0;
    size_t Length = CFDataGetLength(Value);
    BytePtr = CFDataGetBytePtr(Value);
    uint64_t v6 = SocketStream::sendToSocket((SocketStream *)this, BytePtr, Length, &v26);
    size_t v7 = Length - v6;
    if (!v7)
    {
      CFDataRef v8 = this[42];
      CFDataRef v9 = &unk_1EC09FC90;
LABEL_32:
      CFDictionaryRemoveValue(v8, v9);
      goto LABEL_33;
    }
    uint64_t v16 = v6;
    if (v6 >= 1)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(Value);
      memmove(MutableBytePtr, &MutableBytePtr[v16], v7);
      CFDataSetLength(Value, v7);
      int v18 = this[36];
      if (v18 && CFSocketIsValid(v18)) {
        CFSocketEnableCallBacks(this[36], 8uLL);
      }
      goto LABEL_33;
    }
    goto LABEL_21;
  }
  CFMutableDataRef v10 = v3;
  if (!v3)
  {
    CFAllocatorRef v11 = CFGetAllocator(this[42]);
    CFMutableDataRef Mutable = CFDataCreateMutable(v11, 8);
    if (!Mutable)
    {
      this[32] = (CFDictionaryRef)1;
      int v24 = 12;
      goto LABEL_28;
    }
    CFMutableDataRef v10 = Mutable;
    CFDictionaryAddValue(this[42], &unk_1EC09FC58, Mutable);
    CFRelease(v10);
  }
  CFTypeID v13 = CFDataGetMutableBytePtr(v10);
  CFIndex v14 = CFDataGetLength(v10);
  if (v14 == 8) {
    goto LABEL_8;
  }
  CFIndex v19 = v14;
  v26.CFIndex domain = 0;
  *(void *)&v26.SInt32 error = 0;
  uint64_t v20 = SocketStream::recvBytes((SocketStream *)this, &v13[v14], 8 - v14, &v26);
  if (!v20)
  {
    this[32] = (CFDictionaryRef)1;
    int v24 = 57;
LABEL_28:
    *((_DWORD *)this + 66) = v24;
    goto LABEL_33;
  }
  if (v20 < 1)
  {
LABEL_21:
    if (v26.error != 35 || v26.domain != 1) {
      *((CFStreamError *)this + CFRetain((char *)this - 16) = v26;
    }
    goto LABEL_33;
  }
  size_t v21 = v20 + v19;
  memcpy(__dst, v13, v21);
  CFDataSetLength(v10, v21);
  memcpy(v13, __dst, v21);
  unint64_t v22 = this[36];
  if (v22 && CFSocketIsValid(v22)) {
    CFSocketEnableCallBacks(this[36], 1uLL);
  }
  if (v21 == 8)
  {
LABEL_8:
    if (*v13)
    {
      int v15 = 196607;
    }
    else
    {
      int v23 = v13[1];
      if (v23 == 90)
      {
        SocketStream::removeHandshake_NoLock(this, 4);
LABEL_31:
        CFDataRef v8 = this[42];
        CFDataRef v9 = &unk_1EC09FC58;
        goto LABEL_32;
      }
      int v15 = v23 | 0x20000;
    }
    this[32] = (CFDictionaryRef)(int)*MEMORY[0x1E4F1D428];
    *((_DWORD *)this + 66) = v15;
    goto LABEL_31;
  }
LABEL_33:
  if (*((_DWORD *)this + 66))
  {
    SocketStream::removeHandshake_NoLock(this, 4);
  }
}

void SocketStream::removeSSLHandshake(SocketStream *this)
{
  *((_DWORD *)this + 62) |= 0x802000u;
  SocketStream::removeHandshake_NoLock((uint64_t)this, 7);
  uint64_t v2 = (SSLContext *)*((void *)this + 37);
  if (v2)
  {
    SSLProtocol protocol = kSSLProtocolUnknown;
    SSLGetNegotiatedProtocolVersion(v2, &protocol);
    setCFIndexProperty(*((__CFDictionary **)this + 42), @"_kCFStreamPropertySSLNegotiatedProtocol", protocol);
    SSLCipherSuite cipherSuite = 0;
    SSLGetNegotiatedCipher(*((SSLContextRef *)this + 37), &cipherSuite);
    setCFIndexProperty(*((__CFDictionary **)this + 42), @"_kCFStreamPropertySSLNegotiatedCipher", cipherSuite);
    if ((((unint64_t)*((unsigned __int16 *)this + 126) << 32) & 0xC0000000000) != 0
      && (protocol < kTLSProtocol12 || !StrictSecurityPolicy::isATSCompliantCipher((StrictSecurityPolicy *)cipherSuite)))
    {
      CFDataRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09FBB0);
      logAppleATSViolation((*((unsigned __int16 *)this + 126) >> 10) & 1, Value, protocol, cipherSuite);
    }
  }
  else
  {
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), @"_kCFStreamPropertySSLNegotiatedProtocol");
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), @"_kCFStreamPropertySSLNegotiatedCipher");
  }
  if ((*((_DWORD *)this + 62) & 0x8000000) == 0) {
    ++gNonCellularSSLAttempts;
  }
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 568))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    CFTypeRef v4 = *(NSObject **)(v2 + 568);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_2;
    v5[3] = &__block_descriptor_44_e5_v8__0l;
    v5[4] = v2;
    int v6 = a2;
    dispatch_async(v4, v5);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_3(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 568))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    if (a2) {
      CFRetain(a2);
    }
    CFTypeRef v4 = *(NSObject **)(v2 + 568);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_4;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v2;
    void v5[5] = a2;
    dispatch_async(v4, v5);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_4(uint64_t a1)
{
  uint64_t v2 = *(SocketStream **)(a1 + 32);
  SocketStream::securitySetPeerCert(v2, *(const __CFArray **)(a1 + 40));
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }

  CFRelease((char *)v2 - 16);
}

uint64_t ___ZL22logClientCertRequestedPK9__CFArray_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 8247;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  SocketStream::securityAcceptPeerTrust_NoLock((SocketStream *)v1);
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));

  CFRelease((CFTypeRef)(v1 - 16));
}

void SocketStream::securityAcceptPeerTrust_NoLock(SocketStream *this, int a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((unsigned int *)this + 62);
  if ((v4 & 0x40000000) != 0)
  {
    uint64_t v5 = 0;
    unint64_t v6 = v4 & 0xFFFFFFFFBFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = v4 & 0xBFFFFFFF;
    *((_WORD *)this + 126) = WORD2(v6);
    *(_OWORD *)CFTypeRef cf = *((_OWORD *)this + 19);
    *(void *)&cf[16] = *((void *)this + 40);
    do
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)&cf[v5]);
      v5 += 8;
    }
    while (v5 != 24);
  }
  if (a2 == 2)
  {
    CFTypeRef v28 = 0;
    SocketStream::_copyPeerTrustWithPinning_NoLock((CFDictionaryRef *)this, *((SSLContextRef *)this + 37), (SecTrustRef *)&v28);
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), @"kCFStreamPropertySSLSettings");
    if (v28)
    {
      CFDictionaryRef ATSVersion = StrictSecurity::getATSVersion(Value, v13);
      uint64_t v15 = (uint64_t)ATSVersion;
      uint64_t v16 = *((unsigned char *)this + 253) & 1;
      if (!*((void *)this + 86) || !ATSVersion || !dyld_program_sdk_at_least()) {
        goto LABEL_43;
      }
      CFTypeRef v29 = 0;
      unint64_t v17 = (const void *)SecTrustDeserialize();
      int v18 = v17;
      if (v29 || !v17)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        int v23 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          CFTypeRef v26 = v29;
          if (v29) {
            CFIndex Code = CFErrorGetCode((CFErrorRef)v29);
          }
          else {
            CFIndex Code = 0;
          }
          *(_DWORD *)CFTypeRef cf = 138412546;
          *(void *)&cf[4] = v26;
          *(_WORD *)&cf[12] = 2048;
          *(void *)&cf[14] = Code;
          _os_log_error_impl(&dword_184085000, v23, OS_LOG_TYPE_ERROR, "Failed to deserialize cloned ATS trust %@ [%ld]", cf, 0x16u);
        }
        BOOL v21 = 1;
        int v19 = -9802;
      }
      else
      {
        CFNetworkTrust::CFNetworkTrust((CFNetworkTrust *)cf, v17);
        int v19 = CFNetworkTrust::strictEvaluate((uint64_t)cf, 1, v16);
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        uint64_t v20 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CFStreamClientContext buf = 67109120;
          int v31 = v19;
          _os_log_impl(&dword_184085000, v20, OS_LOG_TYPE_DEFAULT, "System Trust Evaluation yielded status(%d)", buf, 8u);
        }
        BOOL v21 = v19 == 0;
        if (v19)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          unint64_t v22 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)CFStreamClientContext buf = 0;
            _os_log_error_impl(&dword_184085000, v22, OS_LOG_TYPE_ERROR, "ATS failed system trust", buf, 2u);
          }
        }
        CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)cf);
      }
      if (v29) {
        CFRelease(v29);
      }
      if (v18) {
        CFRelease(v18);
      }
      if (v21)
      {
LABEL_43:
        CFNetworkTrust::CFNetworkTrust((CFNetworkTrust *)cf, v28);
        int v19 = CFNetworkTrust::strictEvaluate((uint64_t)cf, v15, v16);
        CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)cf);
      }
      CFRelease(v28);
    }
    else
    {
      int v19 = -9802;
    }
  }
  else
  {
    if (a2 == 1)
    {
      size_t v7 = (SSLContext *)*((void *)this + 37);
      if (v7)
      {
        CFDataRef v8 = copyPeerID(v7);
        if (v8)
        {
          CFDataRef v9 = v8;
          *(void *)CFTypeRef cf = 0;
          int v10 = SocketStream::_copyPeerTrustWithPinning_NoLock((CFDictionaryRef *)this, *((SSLContextRef *)this + 37), (SecTrustRef *)cf);
          CFAllocatorRef v11 = *(const void **)cf;
          if (!v10 && *(void *)cf)
          {
            if (TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce != -1) {
              dispatch_once(&TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce, &__block_literal_global_1892);
            }
            TrustExceptionManager::storeTrustExceptions((TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton, v9, *(SecTrustRef *)cf);
            CFAllocatorRef v11 = *(const void **)cf;
          }
          if (v11) {
            CFRelease(v11);
          }
          CFRelease(v9);
        }
      }
LABEL_50:
      if ((*((_DWORD *)this + 62) & 0x8000) == 0) {
        return;
      }
      goto LABEL_51;
    }
    int v19 = SocketStream::doSettingsOverrideTrustEvaluation((CFDictionaryRef *)this);
  }
  if (!v19) {
    goto LABEL_50;
  }
  *((void *)this + 32) = (int)*MEMORY[0x1E4F1D430];
  *((_DWORD *)this + 66) = v19;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  int v24 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v25 = *((void *)this + 70);
    *(_DWORD *)CFTypeRef cf = 134218240;
    *(void *)&cf[4] = v25;
    *(_WORD *)&cf[12] = 1024;
    *(_DWORD *)&cf[14] = v19;
    _os_log_error_impl(&dword_184085000, v24, OS_LOG_TYPE_ERROR, "TCP Conn %p trust evalulation failed: %d", cf, 0x12u);
  }
LABEL_51:
  SocketStream::removeSSLHandshake(this);
}

void sub_18420E898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (v13) {
    CFRelease(v13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SocketStream::_CreateNameAndPortForCONNECTProxy(SocketStream *this, const __CFDictionary *a2, const __CFString **a3, const __CFNumber **a4, CFStreamError *a5)
{
  CFAllocatorRef v9 = CFGetAllocator(this);
  *a4 = 0;
  a4[1] = 0;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(this, &unk_1EC0A1078);
  CFAllocatorRef v11 = CFDictionaryGetValue(this, &unk_1EC0A1040);
  if (!v11)
  {
    CFArrayRef v15 = (const __CFArray *)CFDictionaryGetValue(this, &unk_1EC0A0FD0);
    CFArrayRef ValueAtIndex = v15;
    if (v15)
    {
      CFArrayRef Info = (const __CFArray *)CFHostGetInfo((uint64_t)v15, 1, 0);
      if (Info && (CFArrayRef v17 = Info, CFArrayGetCount(Info)))
      {
        CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v17, 0);
      }
      else
      {
        CFArrayRef v19 = (const __CFArray *)CFHostGetInfo((uint64_t)ValueAtIndex, 0, 0);
        CFArrayRef ValueAtIndex = v19;
        if (v19)
        {
          if (CFArrayGetCount(v19)) {
            CFArrayRef v14 = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
          }
          else {
            CFArrayRef v14 = 0;
          }
          CFArrayRef ValueAtIndex = 0;
          goto LABEL_18;
        }
      }
    }
LABEL_15:
    CFArrayRef v14 = 0;
    goto LABEL_18;
  }
  uint64_t v12 = (uint64_t)v11;
  CFArrayRef ValueAtIndex = (const __CFArray *)CFNetServiceGetInfo((uint64_t)v11, 5u);
  if (Value)
  {
    CFRetain(Value);
    if (!ValueAtIndex)
    {
      CFArrayRef v14 = 0;
      goto LABEL_31;
    }
LABEL_27:
    CFRetain(ValueAtIndex);
    goto LABEL_32;
  }
  CFArrayRef v18 = (const __CFArray *)CFNetServiceGetInfo(v12, 3u);
  CFArrayRef v14 = v18;
  if (v18)
  {
    if (CFArrayGetCount(v18))
    {
      CFArrayRef v14 = (const __CFArray *)CFArrayGetValueAtIndex(v14, 0);
      goto LABEL_18;
    }
    goto LABEL_15;
  }
LABEL_18:
  if (Value) {
    BOOL v20 = 0;
  }
  else {
    BOOL v20 = ValueAtIndex == 0;
  }
  if (v20 && v14 == 0) {
    goto LABEL_36;
  }
  if (!Value)
  {
    BytePtr = CFDataGetBytePtr(v14);
    int v23 = BytePtr[1];
    if (v23 == 30 || v23 == 2)
    {
      unsigned int valuePtr = bswap32(*((unsigned __int16 *)BytePtr + 1)) >> 16;
      CFStringRef Value = (const __CFString *)CFNumberCreate(v9, kCFNumberSInt32Type, &valuePtr);
      if (ValueAtIndex) {
        goto LABEL_27;
      }
      goto LABEL_31;
    }
LABEL_36:
    uint64_t result = 0;
    *a4 = (const __CFNumber *)1;
    int v26 = 22;
LABEL_42:
    *((_DWORD *)a4 + 2) = v26;
    return result;
  }
  CFRetain(Value);
  if (ValueAtIndex) {
    goto LABEL_27;
  }
LABEL_31:
  CFArrayRef ValueAtIndex = (const __CFArray *)_CFNetworkCFStringCreateWithCFDataAddress(v14);
  if (!ValueAtIndex)
  {
LABEL_37:
    if (ValueAtIndex) {
      CFRelease(ValueAtIndex);
    }
    if (Value) {
      CFRelease(Value);
    }
    uint64_t result = 0;
    *a4 = (const __CFNumber *)1;
    int v26 = 12;
    goto LABEL_42;
  }
LABEL_32:
  if (!Value) {
    goto LABEL_37;
  }
  if (_isIPAddress((const __CFString *)ValueAtIndex, 0))
  {
    CFStringRef v24 = CFStringCreateWithFormat(v9, 0, @"[%@]", ValueAtIndex);
    CFRelease(ValueAtIndex);
    CFArrayRef ValueAtIndex = (const __CFArray *)v24;
  }
  *(void *)a2 = ValueAtIndex;
  *a3 = Value;
  return 1;
}

void SocketStream::removeHandshake_NoLock(uint64_t a1, char a2)
{
  int v3 = *(_DWORD *)(a1 + 248);
  *(_DWORD *)(a1 + 412) &= ~(1 << a2);
  *(_DWORD *)(a1 + 248) = v3 & 0xFDFFFFF3;
  uint64_t v4 = *(__CFSocket **)(a1 + 288);
  if (!v4) {
    return;
  }
  if (!CFSocketIsValid(v4)) {
    return;
  }
  int v5 = *(_DWORD *)(a1 + 248);
  if ((v5 & 2) == 0) {
    return;
  }
  if ((v5 & 0x800000) == 0 || *(_DWORD *)(a1 + 412)) {
    goto LABEL_24;
  }
  BOOL v6 = *(void *)(a1 + 232) && *(uint64_t *)(a1 + 224) >= 1;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 272));
  CFDataRef v8 = WeakRetained;
  if ((*(_DWORD *)(a1 + 248) >> 20) & 1 | v6)
  {
    if (!WeakRetained) {
      goto LABEL_24;
    }
    if ((*(_DWORD *)(a1 + 248) & 0x200) == 0) {
      goto LABEL_23;
    }
LABEL_13:
    _CFReadStreamSignalEventDelayed();
LABEL_23:
    CFRelease(v8);
    goto LABEL_24;
  }
  if ((*(_DWORD *)(a1 + 248) & 0x2000) != 0)
  {
    SocketStream::securityBufferedRead_NoLock((SocketStream *)a1);
    int v9 = *(_DWORD *)(a1 + 248);
    if ((v9 & 4) != 0)
    {
      if (!v8) {
        goto LABEL_24;
      }
    }
    else if ((v9 & 0x100000) == 0 || !v8)
    {
      goto LABEL_15;
    }
    if ((v9 & 0x200) == 0) {
      goto LABEL_23;
    }
    goto LABEL_13;
  }
LABEL_15:
  if (v8) {
    goto LABEL_23;
  }
LABEL_24:
  int v10 = *(__CFSocket **)(a1 + 288);
  if (v10)
  {
    if (CFSocketIsValid(v10)) {
      CFSocketEnableCallBacks(*(CFSocketRef *)(a1 + 288), 9uLL);
    }
  }
}

void setCFIndexProperty(__CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberCFIndexType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  if (v5) {
    CFRelease(v5);
  }
}

void SocketStream::addHandshake_NoLock(uint64_t a1, int a2)
{
  uint64_t v3 = 0;
  unsigned int v4 = *(_DWORD *)(a1 + 412) | (1 << a2);
  *(_DWORD *)(a1 + 412) = v4;
  while (((v4 >> v3) & 1) == 0)
  {
    if (++v3 == 8)
    {
      LODWORD(v3) = 0;
      break;
    }
  }
  if (v3 == a2)
  {
    *(_DWORD *)(a1 + 248) &= 0xFDFFFFF3;
    CFNumberRef v5 = *(__CFSocket **)(a1 + 288);
    if (v5)
    {
      if (CFSocketIsValid(v5) && (*(_DWORD *)(a1 + 248) & 2) != 0)
      {
        BOOL v6 = *(__CFSocket **)(a1 + 288);
        CFSocketEnableCallBacks(v6, 9uLL);
      }
    }
  }
}

void _CONNECTHeaderApplier(CFStringRef headerField, CFStringRef value, CFHTTPMessageRef message)
{
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(_DWORD *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  SocketStream::securityAcceptPeerTrust_NoLock((SocketStream *)v1, v2);
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));

  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZL20logPeerCertAvailableP10SSLContext_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 7822;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t virtual thunk to'SocketStream::canRead(SocketStream *this, __CFReadStream *a2)
{
  return SocketStream::canRead((SocketStream *)((char *)this + *(void *)(*(void *)this - 112)), a2);
}

uint64_t SocketStream::canRead(SocketStream *this, __CFReadStream *a2)
{
  unsigned int v4 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  if (*((_DWORD *)this + 103)) {
    goto LABEL_3;
  }
  int v5 = *((_DWORD *)this + 62);
  if ((v5 & 0x800000) == 0) {
    goto LABEL_3;
  }
  if ((v5 & 0x100000) != 0 || *((void *)this + 29) && *((uint64_t *)this + 28) > 0)
  {
    BOOL v6 = 1;
LABEL_9:
    pthread_mutex_unlock(v4);
    return v6;
  }
  if ((v5 & 0x2000) != 0)
  {
    if ((*((_DWORD *)this + 62) & 0x60000000) != 0)
    {
      BOOL v6 = 0;
    }
    else
    {
      SocketStream::securityBufferedRead_NoLock(this);
      BOOL v6 = (*((_DWORD *)this + 62) & 0x100004) != 0;
    }
    goto LABEL_9;
  }
LABEL_3:
  pthread_mutex_unlock(v4);
  return SocketStream::streamCan((uint64_t)this, a2, 1, @"_kCFStreamSocketCanReadPrivateMode", &v8);
}

uint64_t virtual thunk to'SocketStream::read(SocketStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  return SocketStream::read((SocketStream *)((char *)this + *(void *)(*(void *)this - 104)), a2, a3, a4, a5, a6);
}

uint64_t SocketStream::read(SocketStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (nw_settings_get_signposts_enabled()) {
    kdebug_trace();
  }
  CFAllocatorRef v55 = a6;
  a5->CFIndex domain = 0;
  *(void *)&a5->SInt32 error = 0;
  *a6 = 0;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  int64_t v11 = 0;
  uint64_t v12 = (CFStreamError *)((char *)this + 256);
  for (int i = *((_DWORD *)this + 66); ; int i = 0)
  {
    unint64_t v14 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    if (i || (*((_DWORD *)this + 62) & 4) != 0 || *((void *)this + 29) && *((uint64_t *)this + 28) > 0) {
      goto LABEL_28;
    }
    CFRunLoopRef Current = CFRunLoopGetCurrent();
    context.version = 0;
    context.info = Current;
    memset(&context.retain, 0, 56);
    context.perform = (void (__cdecl *)(void *))emptyPerform;
    CFAllocatorRef v16 = CFGetAllocator((char *)this - 16);
    CFRunLoopSourceRef v17 = CFRunLoopSourceCreate(v16, 0, &context);
    *((void *)this + 72) = v17;
    if (!v17)
    {
      *((void *)this + 32) = 1;
      *((_DWORD *)this + 66) = 12;
      uint64_t v27 = *((unsigned int *)this + 62);
      unint64_t v14 = v27 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if ((v27 & 0x800000) == 0) {
        goto LABEL_29;
      }
LABEL_32:
      CFTypeRef v28 = (__CFData *)*((void *)this + 29);
      if (v28)
      {
        MutableBytePtr = CFDataGetMutableBytePtr(v28);
        uint64_t v30 = *((void *)this + 28);
        if (v30 >= a4) {
          int64_t v11 = a4;
        }
        else {
          int64_t v11 = *((void *)this + 28);
        }
        *((void *)this + 28) = v30 - v11;
        memmove(a3, MutableBytePtr, v11);
        memmove(MutableBytePtr, &MutableBytePtr[v11], *((void *)this + 28));
        bzero(&MutableBytePtr[*((void *)this + 28)], 0x8000 - *((void *)this + 28));
        if ((*((_DWORD *)this + 62) & 0x2000) != 0 && !*((void *)this + 28))
        {
          SocketStream::securityBufferedRead_NoLock(this);
          if (v11) {
            goto LABEL_39;
          }
        }
        else if (v11)
        {
LABEL_39:
          uint64_t v31 = *((unsigned int *)this + 62);
          if ((v31 & 0x2000000) != 0)
          {
            unint64_t v32 = v31 & 0xFFFFFFFFFDFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
            *((_DWORD *)this + 62) = v31 & 0xFDFFFFFF;
            *((_WORD *)this + 126) = WORD2(v32);
            uint64_t v33 = (__CFSocket *)*((void *)this + 36);
            if (v33)
            {
              if (CFSocketIsValid(v33)) {
                CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
              }
            }
          }
          goto LABEL_48;
        }
      }
      if (*((_DWORD *)this + 66) || (*((_DWORD *)this + 62) & 0x100000) != 0)
      {
        int64_t v11 = 0;
      }
      else
      {
        int64_t v11 = 0;
        *((void *)this + 32) = 1;
        *((_DWORD *)this + 66) = 35;
      }
      goto LABEL_48;
    }
    double valuePtr = 0.0;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09FA98);
    if (Value && CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr) && (double v19 = valuePtr, valuePtr <= 75.0))
    {
      double v20 = *((double *)this + 45);
      if (v20 > 0.0 && valuePtr == 0.0)
      {
        double valuePtr = *((double *)this + 45);
        double v19 = v20;
      }
      if (v19 == 0.0)
      {
        double v21 = 1.79769313e308;
        goto LABEL_19;
      }
    }
    else
    {
      double valuePtr = 75.0;
    }
    double v21 = CFAbsoluteTimeGetCurrent() + valuePtr;
LABEL_19:
    _SchedulesAddRunLoopAndMode(*((const __CFArray **)this + 38), Current, @"_kCFStreamSocketReadPrivateMode");
    uint64_t v22 = *((void *)this + 41);
    CFRunLoopRef v57 = Current;
    uint64_t v58 = 0x1EC0A0358;
    v61.CFIndex length = *(void *)(v22 + 24);
    v61.CFIndex location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v22 + 16), v61, (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction, &v57);
    CFRunLoopAddSource(Current, *((CFRunLoopSourceRef *)this + 72), @"_kCFStreamSocketReadPrivateMode");
    do
    {
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
      CFRunLoopRunInMode(@"_kCFStreamSocketReadPrivateMode", valuePtr, 1u);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
      if (*((_DWORD *)this + 66)) {
        break;
      }
      if ((*((_DWORD *)this + 62) & 4) != 0) {
        break;
      }
      double valuePtr = v21 - CFAbsoluteTimeGetCurrent();
    }
    while (valuePtr > 0.0);
    CFRunLoopRemoveSource(Current, *((CFRunLoopSourceRef *)this + 72), @"_kCFStreamSocketReadPrivateMode");
    uint64_t v23 = *((void *)this + 41);
    CFRunLoopRef v57 = Current;
    uint64_t v58 = 0x1EC0A0358;
    v62.CFIndex length = *(void *)(v23 + 24);
    v62.CFIndex location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v23 + 16), v62, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction, &v57);
    _SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 38), Current, @"_kCFStreamSocketReadPrivateMode");
    CFStringRef v24 = (const void *)*((void *)this + 72);
    *((void *)this + 72) = 0;
    if (v24) {
      CFRelease(v24);
    }
    uint64_t v25 = *((unsigned int *)this + 62);
    unint64_t v14 = v25 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    if ((v25 & 4) == 0 && !*((_DWORD *)this + 66))
    {
      *((void *)this + 32) = 1;
      *((_DWORD *)this + 66) = 60;
    }
LABEL_28:
    if ((v14 & 0x800000) != 0) {
      goto LABEL_32;
    }
LABEL_29:
    int v26 = *((_DWORD *)this + 66);
    if (!v26)
    {
      int64_t v11 = SocketStream::recvBytes(this, a3, a4, (CFStreamError *)this + 16);
LABEL_48:
      int v26 = *((_DWORD *)this + 66);
      unint64_t v14 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    }
    unint64_t v34 = v14 & 0xFFFFFFFFFFFFFFFBLL;
    *((_DWORD *)this + 62) = v34;
    *((_WORD *)this + 126) = WORD2(v34);
    if (v26 != 35) {
      break;
    }
    if (v12->domain != 1) {
      break;
    }
    unint64_t v35 = (__CFSocket *)*((void *)this + 36);
    if (!v35 || !CFSocketIsValid(v35)) {
      break;
    }
    CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
    v12->CFIndex domain = 0;
    *((void *)this + 33) = 0;
  }
  if (v11 < 1)
  {
    if (*((_DWORD *)this + 66))
    {
      *a5 = *v12;
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      int v38 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        CFIndex v52 = *((void *)this + 70);
        CFStringRef v53 = (void *)*((void *)this + 32);
        int v54 = *((_DWORD *)this + 66);
        LODWORD(context.version) = 134218496;
        *(CFIndex *)((char *)&context.version + 4) = v52;
        WORD2(context.info) = 2048;
        *(void **)((char *)&context.info + 6) = v53;
        HIWORD(context.retain) = 1024;
        LODWORD(context.release) = v54;
        _os_log_error_impl(&dword_184085000, v38, OS_LOG_TYPE_ERROR, "SocketStream read error [%p]: %ld %d", (uint8_t *)&context, 0x1Cu);
      }
      id WeakRetained = objc_loadWeakRetained((id *)this + 35);
      if (WeakRetained)
      {
        int64_t v40 = WeakRetained;
        if ((*((_DWORD *)this + 62) & 0x400) != 0) {
          _CFWriteStreamSignalEventDelayed();
        }
        CFRelease(v40);
      }
      *CFAllocatorRef v55 = 1;
      uint64_t v41 = (__CFSocket *)*((void *)this + 36);
      if (v41 && CFSocketIsValid(v41)) {
        CFSocketDisableCallBacks(*((CFSocketRef *)this + 36), 9uLL);
      }
      int64_t v11 = -1;
    }
    else if (!v11)
    {
      *CFAllocatorRef v55 = 1;
      CFStringRef v47 = (__CFSocket *)*((void *)this + 36);
      if (v47 && CFSocketIsValid(v47)) {
        CFSocketDisableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
      }
      int64_t v11 = 0;
    }
    goto LABEL_100;
  }
  SocketStream::touchWatchdogTimer_Locked(this, 0);
  unsigned int v36 = *((_DWORD *)this + 103);
  if (!v36)
  {
    uint64_t v42 = *((unsigned int *)this + 62);
    if ((v42 & 0x800000) == 0) {
      goto LABEL_78;
    }
    if (*((void *)this + 29) && *((uint64_t *)this + 28) >= 1)
    {
      char v43 = 0;
      unint64_t v44 = v42 & 0xFFFFFFFFFFFFFFDFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      *((_WORD *)this + 126) = WORD2(v44);
      *((_DWORD *)this + 62) = v44 | 4;
    }
    else
    {
      char v43 = 1;
      if ((v42 & 0x100000) != 0)
      {
        *CFAllocatorRef v55 = 1;
        CFStringRef v48 = (__CFSocket *)*((void *)this + 36);
        if (v48 && CFSocketIsValid(v48)) {
          CFSocketDisableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
        }
        char v43 = 0;
      }
    }
    uint64_t v49 = *((unsigned int *)this + 62);
    unint64_t v46 = v49 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    if ((v49 & 0x100000) != 0 || *((void *)this + 29) && *((uint64_t *)this + 28) >= 1)
    {
LABEL_95:
      unint64_t v50 = v46 & 0xFFFFFFFFFFFFFFDFLL;
      *((_WORD *)this + 126) = WORD2(v50);
      *((_DWORD *)this + 62) = v50 | 4;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
      if (v43) {
        goto LABEL_101;
      }
    }
    _CFReadStreamSignalEventDelayed();
    goto LABEL_101;
  }
  uint64_t v37 = 0;
  while (((v36 >> v37) & 1) == 0)
  {
    if (++v37 == 8) {
      goto LABEL_100;
    }
  }
  if (v37 == 5)
  {
LABEL_78:
    CFRunLoopRef v45 = (__CFSocket *)*((void *)this + 36);
    if (!v45 || !CFSocketIsValid(v45) || _CFSocketCan(*((__CFSocket **)this + 36), 0))
    {
      unint64_t v46 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      goto LABEL_95;
    }
    CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
  }
LABEL_100:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
LABEL_101:
  if (nw_settings_get_signposts_enabled()) {
    kdebug_trace();
  }
  return v11;
}

uint64_t virtual thunk to'SocketStream::unschedule(SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  size_t v7 = (char *)this + *(void *)(*(void *)this - 96);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 40));
  SocketStream::unschedule_NoLock((SocketStream *)v7, a2, a3, a4);

  return pthread_mutex_unlock((pthread_mutex_t *)(v7 + 40));
}

void SocketStream::unschedule_NoLock(SocketStream *this, CFTypeRef cf, __CFRunLoop *a3, const __CFString *a4)
{
  CFTypeID v7 = CFGetTypeID(cf);
  CFTypeID TypeID = CFReadStreamGetTypeID();
  uint64_t v9 = 312;
  if (v7 == TypeID) {
    uint64_t v10 = 304;
  }
  else {
    uint64_t v10 = 312;
  }
  if (v7 != TypeID) {
    uint64_t v9 = 304;
  }
  CFArrayRef v11 = *(const __CFArray **)((char *)this + v9);
  CFArrayRef v12 = *(const __CFArray **)((char *)this + v10);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 40), a3, a4))
  {
    _SchedulesAddRunLoopAndMode(v11, a3, a4);
  }
  else if (_SchedulesRemoveRunLoopAndMode(v12, a3, a4))
  {
    uint64_t v13 = *((void *)this + 41);
    v14[0] = a3;
    v14[1] = a4;
    v16.CFIndex length = *(void *)(v13 + 24);
    v16.CFIndex location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v13 + 16), v16, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction, v14);
  }
}

uint64_t virtual thunk to'SocketStream::schedule(SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  CFTypeID v7 = (char *)this + *(void *)(*(void *)this - 88);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 40));
  SocketStream::schedule_NoLock((SocketStream *)v7, a2, a3, a4);

  return pthread_mutex_unlock((pthread_mutex_t *)(v7 + 40));
}

void SocketStream::schedule_NoLock(SocketStream *this, CFTypeRef cf, __CFRunLoop *a3, const __CFString *a4)
{
  CFTypeID v8 = CFGetTypeID(cf);
  CFTypeID TypeID = CFReadStreamGetTypeID();
  if (v8 == TypeID) {
    CFTypeRef v10 = (CFTypeRef)*((void *)this + 34);
  }
  else {
    CFTypeRef v10 = (CFTypeRef)*((void *)this + 35);
  }
  if (v10 != cf && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v21[0]) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "What stream is this??", (uint8_t *)v21, 2u);
  }
  uint64_t v11 = 312;
  if (v8 == TypeID) {
    uint64_t v12 = 304;
  }
  else {
    uint64_t v12 = 312;
  }
  if (v8 != TypeID) {
    uint64_t v11 = 304;
  }
  CFArrayRef v13 = *(const __CFArray **)((char *)this + v11);
  CFArrayRef v14 = *(const __CFArray **)((char *)this + v12);
  if (_SchedulesFind(*((const __CFArray **)this + 40), a3, a4) == -1 && _SchedulesFind(v14, a3, a4) == -1)
  {
    uint64_t v15 = _SchedulesFind(v13, a3, a4);
    CFArrayRef v16 = v14;
    if (v15 != -1)
    {
      _SchedulesRemoveRunLoopAndMode(v13, a3, a4);
      CFArrayRef v16 = (const __CFArray *)*((void *)this + 40);
    }
    _SchedulesAddRunLoopAndMode(v16, a3, a4);
    uint64_t v17 = *((void *)this + 41);
    v21[0] = a3;
    v21[1] = a4;
    v22.CFIndex length = *(void *)(v17 + 24);
    v22.CFIndex location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v17 + 16), v22, (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction, v21);
    int v18 = *((_DWORD *)this + 62);
    if (v8 == TypeID)
    {
      if ((v18 & 4) != 0)
      {
        CFIndex Count = CFArrayGetCount(v14);
        if (CFArrayGetCount(*((CFArrayRef *)this + 40)) + Count == 4) {
          CFReadStreamSignalEvent();
        }
      }
    }
    else if ((v18 & 8) != 0)
    {
      CFIndex v20 = CFArrayGetCount(v14);
      if (CFArrayGetCount(*((CFArrayRef *)this + 40)) + v20 == 4) {
        CFWriteStreamSignalEvent();
      }
    }
  }
}

uint64_t virtual thunk to'SocketStream::setProperty(SocketStream *this, const void *a2, const __CFString *a3, __CFString *a4)
{
  return SocketStream::setProperty((SocketStream *)((char *)this + *(void *)(*(void *)this - 80)), a2, a3, a4);
}

uint64_t SocketStream::setProperty(SocketStream *this, const void *a2, const __CFString *a3, __CFString *a4)
{
  uint64_t v102 = 0;
  memset(v101, 0, sizeof(v101));
  CFTypeID v8 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  int ExactString = _findExactString(a3, 0);
  uint64_t v11 = 0;
  if (ExactString <= 131443042)
  {
    if (ExactString <= 97904391)
    {
      if (ExactString <= 84248065)
      {
        if (ExactString <= 77907339)
        {
          if (ExactString > 58057723)
          {
            if (ExactString == 58057724) {
              goto LABEL_174;
            }
            if (ExactString == 66307256)
            {
              if (a4)
              {
                if (*((void *)this + 70))
                {
                  valuePtr[0] = 3;
                  CFTypeID v43 = CFGetTypeID(a4);
                  if (v43 == CFNumberGetTypeID())
                  {
                    if (CFNumberGetValue((CFNumberRef)a4, kCFNumberSInt64Type, valuePtr))
                    {
                      xpc_object_t v44 = xpc_uint64_create(valuePtr[0]);
                      if (v44)
                      {
                        tcp_connection_log_event();
                        xpc_release(v44);
                      }
                    }
                  }
                }
              }
              goto LABEL_278;
            }
            int v17 = 76932468;
            goto LABEL_173;
          }
          if (ExactString == 22372625) {
            goto LABEL_174;
          }
          int v28 = 32842260;
LABEL_137:
          if (ExactString == v28) {
            goto LABEL_175;
          }
          goto LABEL_311;
        }
        if (ExactString <= 80020909)
        {
          if (ExactString == 77907340) {
            goto LABEL_174;
          }
          int v17 = 78857632;
          goto LABEL_173;
        }
        if (ExactString == 80020910) {
          goto LABEL_174;
        }
        if (ExactString != 82101715)
        {
          if (ExactString != 83273191) {
            goto LABEL_311;
          }
          goto LABEL_177;
        }
        if (CFBooleanGetValue((CFBooleanRef)a4))
        {
          uint64_t v11 = 0;
          *((_DWORD *)this + 62) |= 0x1000000u;
          goto LABEL_311;
        }
        SocketStream::flushTransmissionBuffer_NoLock((CFStreamError *)this);
        uint64_t v11 = 0;
        size_t v72 = (char *)this + 248;
        unint64_t v73 = *((_DWORD *)this + 62) & 0xFEFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        goto LABEL_330;
      }
      if (ExactString > 90506881)
      {
        if (ExactString <= 94627530)
        {
          if (ExactString != 90506882)
          {
            int v17 = 93587130;
            goto LABEL_173;
          }
LABEL_177:
          if (*((const void **)this + 34) == a2)
          {
            uint64_t v40 = 1;
          }
          else
          {
            uint64_t v40 = 0;
            uint64_t v11 = 0;
            if (*((const void **)this + 35) != a2) {
              goto LABEL_311;
            }
          }
          (*(void (**)(SocketStream *, uint64_t, const __CFString *, __CFString *))(*(void *)this + 216))(this, v40, a3, a4);
          goto LABEL_310;
        }
        if (ExactString == 94627531) {
          goto LABEL_174;
        }
        if (ExactString == 95782619)
        {
          if (a4)
          {
            CFTypeID v71 = CFGetTypeID(a4);
            if (v71 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
            {
              LOWORD(valuePtr[0]) = 0;
              _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
            }
            if ((__CFString *)*MEMORY[0x1E4F1CFD0] == a4)
            {
              uint64_t v11 = 0;
              size_t v72 = (char *)this + 248;
              __int16 v97 = *((_WORD *)this + 126);
              *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
              LOWORD(v94) = v97 | 0x200;
              goto LABEL_331;
            }
          }
          uint64_t v11 = 0;
          size_t v72 = (char *)this + 248;
          unint64_t v73 = (*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0xFFFFFDFFFFFFFFFFLL;
LABEL_330:
          *(_DWORD *)size_t v72 = v73;
          unint64_t v94 = HIDWORD(v73);
LABEL_331:
          *((_WORD *)v72 + 2) = v94;
          goto LABEL_311;
        }
        int v20 = 96814834;
        goto LABEL_107;
      }
      if (ExactString <= 87361087)
      {
        if (ExactString != 84248066)
        {
          if (ExactString != 86279725) {
            goto LABEL_311;
          }
          CFArrayRef v16 = (__CFDictionary *)*((void *)this + 42);
          if (!a4) {
            goto LABEL_309;
          }
          CFDictionarySetValue(v16, a3, a4);
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F440);
          SocketStream::updateTCPConnectionPoolPriority(this, a4, Value);
          goto LABEL_310;
        }
        goto LABEL_177;
      }
      if (ExactString == 87361088)
      {
        CFArrayRef v16 = (__CFDictionary *)*((void *)this + 42);
        if (a4)
        {
          CFDictionarySetValue(v16, a3, a4);
          CFStringRef v52 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F408);
          SocketStream::updateTCPConnectionPoolPriority(this, v52, (const __CFNumber *)a4);
          goto LABEL_310;
        }
        goto LABEL_309;
      }
      if (ExactString != 88393301)
      {
        int v20 = 89532009;
LABEL_107:
        if (ExactString != v20) {
          goto LABEL_311;
        }
LABEL_160:
        if ((*((_DWORD *)this + 62) & 3) != 0) {
          goto LABEL_278;
        }
        goto LABEL_177;
      }
LABEL_126:
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 42), a3, a4);
      goto LABEL_278;
    }
    if (ExactString <= 114509878)
    {
      if (ExactString > 106203044)
      {
        if (ExactString > 108242892)
        {
          if (ExactString == 108242893) {
            goto LABEL_174;
          }
          if (ExactString == 109373404)
          {
            if (a4)
            {
              CFTypeID v62 = CFGetTypeID(a4);
              if (v62 == CFArrayGetTypeID())
              {
                CFIndex Count = CFArrayGetCount((CFArrayRef)a4);
                if (Count < 1)
                {
LABEL_241:
                  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 42), a3, a4);
                  goto LABEL_310;
                }
                CFIndex v64 = 0;
                while (1)
                {
                  CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a4, v64);
                  CFTypeID v66 = CFGetTypeID(ValueAtIndex);
                  if (v66 != CFStringGetTypeID()) {
                    break;
                  }
                  if (Count == ++v64) {
                    goto LABEL_241;
                  }
                }
              }
              goto LABEL_278;
            }
            CFArrayRef v16 = (__CFDictionary *)*((void *)this + 42);
            goto LABEL_309;
          }
          int v17 = 113535013;
          goto LABEL_173;
        }
        if (ExactString != 106203045)
        {
          if (ExactString == 107284408)
          {
            int v38 = (__CFDictionary *)*((void *)this + 42);
            if (a4) {
              CFDictionarySetValue(v38, a3, a4);
            }
            else {
              CFDictionaryRemoveValue(v38, a3);
            }
            uint64_t v11 = 1;
            SocketStream::setupMinimumThroughput((uint64_t)this, 1);
          }
          goto LABEL_311;
        }
        goto LABEL_160;
      }
      if (ExactString > 102123346)
      {
        if (ExactString == 102123347)
        {
          CFArrayRef v16 = (__CFDictionary *)*((void *)this + 42);
          if (a4)
          {
            CFDictionarySetValue(v16, a3, a4);
            valuePtr[0] = 0;
            CFTypeID v45 = CFGetTypeID(a4);
            if (v45 == CFNumberGetTypeID()
              && CFNumberGetValue((CFNumberRef)a4, kCFNumberDoubleType, valuePtr)
              && *(double *)valuePtr > 0.0)
            {
              *((void *)this + 46) = valuePtr[0];
            }
            goto LABEL_310;
          }
          goto LABEL_309;
        }
        if (ExactString == 104064896)
        {
          if (!*((unsigned char *)this + 404))
          {
            int v46 = CFEqual(a4, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
            int v47 = v46 != 0;
            double v48 = 0.1;
            if (!v46) {
              double v48 = 0.0;
            }
            *((_DWORD *)this + 86) = v47 << 16;
            *((double *)this + 44) = v48;
            *((_DWORD *)this + 100) = v47;
            uint64_t v49 = (__CFSocket *)*((void *)this + 36);
            if (v49 && CFSocketIsValid(v49)) {
              __CFSocketSetSocketReadBufferAttrs();
            }
          }
          goto LABEL_310;
        }
        if (ExactString != 105187216) {
          goto LABEL_311;
        }
        if ((*((_DWORD *)this + 62) & 3) != 0) {
          goto LABEL_278;
        }
        goto LABEL_175;
      }
      if (ExactString == 97904392)
      {
        uint64_t v74 = (__CFDictionary *)*((void *)this + 42);
        if (a4) {
          CFDictionarySetValue(v74, a3, a4);
        }
        else {
          CFDictionaryRemoveValue(v74, a3);
        }
        SocketStream::updateExcessiveKeepalivesParameters((uint64_t)this, a4);
        goto LABEL_310;
      }
      if (ExactString != 100902724) {
        goto LABEL_311;
      }
      goto LABEL_126;
    }
    if (ExactString <= 121940154)
    {
      if (ExactString > 118835318)
      {
        switch(ExactString)
        {
          case 118835319:
            if (ObserverHolder::Class(void)::sOnce_ObserverHolder != -1) {
              dispatch_once(&ObserverHolder::Class(void)::sOnce_ObserverHolder, &__block_literal_global_12490);
            }
            p_data = &a4->data;
            CFStringRef length = (const __CFString *)a4->length;
            isa = a4[1].isa;
            info = (std::__shared_weak_count *)a4[1].info;
            v99[0] = isa;
            v99[1] = info;
            if (info) {
              atomic_fetch_add_explicit(&info->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v98[0] = MEMORY[0x1E4F143A8];
            v98[1] = 3221225472;
            v98[2] = ___ZN12SocketStream11setPropertyEPKvPK10__CFStringS1__block_invoke;
            v98[3] = &__block_descriptor_56_e6__v8__0l;
            v98[4] = this;
            v98[5] = a2;
            v98[6] = p_data;
            NotificationStation::registerForPropertyUpdates((uint64_t)this + 104, length, v99, (uint64_t)v98);
            if (info) {
              std::__shared_weak_count::__release_shared[abi:nn180100](info);
            }
            goto LABEL_278;
          case 119892109:
            LODWORD(valuePtr[0]) = 0;
            if (!a4) {
              goto LABEL_278;
            }
            CFTypeID v57 = CFGetTypeID(a4);
            if (v57 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)a4, kCFNumberSInt32Type, valuePtr)) {
              goto LABEL_278;
            }
            uint64_t v11 = 1;
            *((unsigned char *)this + 404) = 1;
            *((_DWORD *)this + 86) = valuePtr[0];
            uint64_t v58 = (__CFSocket *)*((void *)this + 36);
            if (!v58 || !CFSocketIsValid(v58)) {
              goto LABEL_311;
            }
            break;
          case 120965283:
            valuePtr[0] = 0;
            if (!a4) {
              goto LABEL_278;
            }
            CFTypeID v21 = CFGetTypeID(a4);
            if (v21 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)a4, kCFNumberDoubleType, valuePtr)) {
              goto LABEL_278;
            }
            uint64_t v11 = 1;
            *((unsigned char *)this + 404) = 1;
            *((void *)this + 44) = valuePtr[0];
            CFRange v22 = (__CFSocket *)*((void *)this + 36);
            if (!v22 || !CFSocketIsValid(v22)) {
              goto LABEL_311;
            }
            break;
          default:
            goto LABEL_311;
        }
        __CFSocketSetSocketReadBufferAttrs();
        goto LABEL_311;
      }
      if (ExactString == 114509879) {
        goto LABEL_174;
      }
      int v28 = 117680232;
      goto LABEL_137;
    }
    if (ExactString > 125004018)
    {
      if (ExactString != 125004019 && ExactString != 128272675)
      {
        if (ExactString != 129296697) {
          goto LABEL_311;
        }
        SocketStream::securitySetPeerCert_NoLock(this, (const __CFArray *)a4, (SocketStreamSignalHolder *)v101);
        goto LABEL_310;
      }
      goto LABEL_175;
    }
    if (ExactString != 121940155)
    {
      if (ExactString != 122947790) {
        goto LABEL_311;
      }
      CFArrayRef v16 = (__CFDictionary *)*((void *)this + 42);
      if (a4)
      {
        a3 = (const __CFString *)&unk_1EC09FBB0;
        goto LABEL_176;
      }
      a3 = @"kCFStreamPropertySSLSettings";
LABEL_309:
      CFDictionaryRemoveValue(v16, a3);
      goto LABEL_310;
    }
    *((_DWORD *)this + 100) = 0;
    *((unsigned char *)this + 404) = 1;
    if (CFEqual(a4, (CFTypeRef)*MEMORY[0x1E4F1CFD0]))
    {
      int v82 = 1;
    }
    else
    {
      CFTypeID v95 = CFGetTypeID(a4);
      if (v95 != CFNumberGetTypeID()
        || (LODWORD(valuePtr[0]) = 0, !CFNumberGetValue((CFNumberRef)a4, kCFNumberSInt32Type, valuePtr)))
      {
LABEL_335:
        CFDictionaryRef v96 = (__CFSocket *)*((void *)this + 36);
        if (v96 && CFSocketIsValid(v96)) {
          _CFSocketSetTrafficMgtBackground(*((__CFSocket **)this + 36), *((_DWORD *)this + 100) == 1);
        }
        goto LABEL_310;
      }
      int v82 = valuePtr[0];
    }
    *((_DWORD *)this + 100) = v82;
    goto LABEL_335;
  }
  if (ExactString <= 200625709)
  {
    if (ExactString > 161713009)
    {
      if (ExactString > 191171949)
      {
        if (ExactString <= 193334679)
        {
          if (ExactString != 191171950)
          {
            if (ExactString != 192228739) {
              goto LABEL_311;
            }
            uint64_t v41 = (__CFString *)*((void *)this + 67);
            if (v41 != a4)
            {
              if (v41) {
                CFRelease(v41);
              }
              if (a4) {
                CFTypeRef v42 = CFRetain(a4);
              }
              else {
                CFTypeRef v42 = 0;
              }
              *((void *)this + 67) = v42;
            }
            goto LABEL_310;
          }
          goto LABEL_175;
        }
        if (ExactString == 193334680 || ExactString == 195382725) {
          goto LABEL_174;
        }
        int v17 = 196464091;
      }
      else
      {
        if (ExactString <= 186928406)
        {
          if (ExactString == 161713010)
          {
            if (a4)
            {
              CFTypeID v77 = CFGetTypeID(a4);
              if (v77 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
              {
                LOWORD(valuePtr[0]) = 0;
                _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
              }
              BOOL v24 = *MEMORY[0x1E4F1CFD0] == (void)a4;
              *((unsigned char *)this + 406) = v24;
              if (v24)
              {
                size_t v78 = (__CFSocket *)*((void *)this + 36);
                if (v78)
                {
                  if (CFSocketIsValid(v78)) {
                    _CFSocketSetRecvAnyIf(*((__CFSocket **)this + 36));
                  }
                }
              }
            }
            else
            {
              *((unsigned char *)this + 406) = 0;
            }
          }
          else
          {
            if (ExactString != 174287922) {
              goto LABEL_311;
            }
            int v30 = stringToServiceType((uint64_t)a4);
            if (v30 != -1 && *((_DWORD *)this + 102) != v30)
            {
              *((_DWORD *)this + 102) = v30;
              if (*((void *)this + 70))
              {
                uint64_t v31 = (__CFSocket *)*((void *)this + 36);
                if (v31 && CFSocketIsValid(v31))
                {
                  if (*((_DWORD *)this + 102) == 1) {
                    SocketStream::checkInVoIPSocket(this);
                  }
                  else {
                    SocketStream::checkOutVoIPSocket(this, v32);
                  }
                }
                if (*((void *)this + 70)) {
                  tcp_connection_set_traffic_class();
                }
              }
            }
          }
          goto LABEL_310;
        }
        if (ExactString == 186928407 || ExactString == 188075305) {
          goto LABEL_174;
        }
        int v17 = 189107521;
      }
    }
    else
    {
      if (ExactString > 142936630)
      {
        if (ExactString <= 147049083)
        {
          if (ExactString != 142936631)
          {
            if (ExactString != 144976476) {
              goto LABEL_311;
            }
            CFArrayRef v16 = (__CFDictionary *)*((void *)this + 42);
            if (a4)
            {
              CFDictionarySetValue(v16, a3, a4);
              valuePtr[0] = 0;
              CFTypeID v39 = CFGetTypeID(a4);
              if (v39 == CFNumberGetTypeID()
                && CFNumberGetValue((CFNumberRef)a4, kCFNumberDoubleType, valuePtr)
                && *(double *)valuePtr > 0.0)
              {
                *((void *)this + 45) = valuePtr[0];
              }
              goto LABEL_310;
            }
            goto LABEL_309;
          }
          if (a4)
          {
            CFTypeID v79 = CFGetTypeID(a4);
            if (v79 != CFDictionaryGetTypeID()
              || !CFDictionaryContainsKey((CFDictionaryRef)a4, @"_kTCPKeepAliveParametersEnabled")
              || !CFDictionaryContainsKey((CFDictionaryRef)a4, @"_kTCPKeepAliveParametersEnabled")
              || !CFDictionaryContainsKey((CFDictionaryRef)a4, @"_kTCPKeepAliveParametersEnabled"))
            {
              goto LABEL_278;
            }
            CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 42), a3, a4);
          }
          else
          {
            CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), a3);
          }
          SocketStream::updateTCPKeepalivesParameters((uint64_t)this, a4);
          goto LABEL_310;
        }
        if (ExactString != 147049084)
        {
          if (ExactString != 157494066)
          {
            if (ExactString != 160648036) {
              goto LABEL_311;
            }
            if (a4)
            {
              CFTypeID v23 = CFGetTypeID(a4);
              if (v23 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
              {
                LOWORD(valuePtr[0]) = 0;
                _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
              }
              BOOL v24 = *MEMORY[0x1E4F1CFD0] == (void)a4;
              *((unsigned char *)this + 405) = v24;
              if (v24)
              {
                uint64_t v25 = (__CFSocket *)*((void *)this + 36);
                if (v25)
                {
                  if (CFSocketIsValid(v25)) {
                    _CFSocketSetNoDelay(*((__CFSocket **)this + 36));
                  }
                }
              }
            }
            else
            {
              *((unsigned char *)this + 405) = 0;
            }
            goto LABEL_310;
          }
          goto LABEL_174;
        }
LABEL_175:
        CFArrayRef v16 = (__CFDictionary *)*((void *)this + 42);
        if (a4)
        {
LABEL_176:
          CFDictionarySetValue(v16, a3, a4);
          goto LABEL_310;
        }
        goto LABEL_309;
      }
      if (ExactString > 137693656)
      {
        switch(ExactString)
        {
          case 137693657:
            unint64_t v50 = (__CFDictionary *)*((void *)this + 42);
            if (a4)
            {
              CFDictionarySetValue(v50, a3, a4);
              SocketStream::updateTCPAdaptiveParamters(this, (CFNumberRef)a4, 0);
              goto LABEL_310;
            }
            CFDictionaryRemoveValue(v50, a3);
            CFNumberRef v87 = 0;
            CFNumberRef v88 = (const __CFNumber *)*MEMORY[0x1E4F1D260];
            break;
          case 138750446:
            unint64_t v51 = (__CFDictionary *)*((void *)this + 42);
            if (a4)
            {
              CFDictionarySetValue(v51, a3, a4);
              SocketStream::updateTCPAdaptiveParamters(this, 0, (CFNumberRef)a4);
              goto LABEL_310;
            }
            CFDictionaryRemoveValue(v51, a3);
            CFNumberRef v88 = 0;
            CFNumberRef v87 = (const __CFNumber *)*MEMORY[0x1E4F1D260];
            break;
          case 141863460:
            int v18 = (__CFDictionary *)*((void *)this + 42);
            if (a4)
            {
              CFDictionarySetValue(v18, a3, a4);
              if (!*((void *)this + 70)) {
                goto LABEL_310;
              }
              CFTypeID v19 = CFGetTypeID(a4);
              if (v19 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
              {
                LOWORD(valuePtr[0]) = 0;
                _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)valuePtr, 2u);
              }
            }
            else
            {
              CFDictionaryRemoveValue(v18, a3);
              if (!*((void *)this + 70)) {
                goto LABEL_310;
              }
            }
            tcp_connection_set_keepalive_offload();
            goto LABEL_310;
          default:
            goto LABEL_311;
        }
        SocketStream::updateTCPAdaptiveParamters(this, v88, v87);
        goto LABEL_310;
      }
      if (ExactString == 131443043)
      {
        if (*((void *)this + 37))
        {
          LODWORD(valuePtr[0]) = 0;
          if (a4 && (CFTypeID v75 = CFGetTypeID(a4), v75 == CFNumberGetTypeID()))
          {
            CFNumberGetValue((CFNumberRef)a4, kCFNumberIntType, valuePtr);
            SSLAuthenticate v76 = valuePtr[0];
          }
          else
          {
            SSLAuthenticate v76 = kNeverAuthenticate;
            LODWORD(valuePtr[0]) = 0;
          }
          OSStatus v83 = SSLSetClientSideAuthenticate(*((SSLContextRef *)this + 37), v76);
          if (v83)
          {
            uint64_t v11 = 0;
            *((void *)this + 32) = (int)*MEMORY[0x1E4F1D430];
            *((_DWORD *)this + 66) = v83;
            goto LABEL_311;
          }
          goto LABEL_310;
        }
        goto LABEL_278;
      }
      int v17 = 135580085;
    }
    goto LABEL_173;
  }
  if (ExactString <= 217460577)
  {
    if (ExactString > 212037385)
    {
      if (ExactString > 214216492)
      {
        if (ExactString != 214216493)
        {
          if (ExactString != 215166784)
          {
            if (ExactString != 216338253) {
              goto LABEL_311;
            }
            int v26 = (__CFDictionary *)*((void *)this + 42);
            if (a4) {
              CFDictionarySetValue(v26, a3, a4);
            }
            else {
              CFDictionaryRemoveValue(v26, a3);
            }
            uint64_t v84 = (__CFSocket *)*((void *)this + 36);
            if (v84 && CFSocketIsValid(v84))
            {
              CFOptionFlags SocketFlags = CFSocketGetSocketFlags(*((CFSocketRef *)this + 36));
              if (a4)
              {
                if ((__CFString *)*MEMORY[0x1E4F1CFC8] == a4) {
                  CFOptionFlags v86 = SocketFlags & 0xFFFFFFFFFFFFFF7FLL;
                }
                else {
                  CFOptionFlags v86 = SocketFlags | 0x80;
                }
              }
              else if ((*((_DWORD *)this + 62) & 0x100) != 0)
              {
                CFOptionFlags v86 = SocketFlags & 0xFFFFFFFFFFFFFF7FLL;
              }
              else
              {
                CFOptionFlags v86 = SocketFlags | 0x80;
              }
              CFSocketSetSocketFlags(*((CFSocketRef *)this + 36), v86);
            }
            goto LABEL_310;
          }
          goto LABEL_174;
        }
        if (*((unsigned char *)this + 248)) {
          goto LABEL_310;
        }
        uint64_t v11 = 1;
        if (a4 && (*((unsigned char *)this + 248) & 2) == 0)
        {
          CFTypeID v67 = CFGetTypeID(a4);
          if (v67 == CFBooleanGetTypeID())
          {
            int v68 = CFBooleanGetValue((CFBooleanRef)a4);
            unint64_t v69 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
            if (v68) {
              __int16 v70 = WORD2(v69) | 1;
            }
            else {
              __int16 v70 = WORD2(v69) & 0xFFFE;
            }
            *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
            *((_WORD *)this + 126) = v70;
          }
          goto LABEL_310;
        }
        goto LABEL_311;
      }
      if (ExactString == 212037386)
      {
        if (*((unsigned char *)this + 248)) {
          goto LABEL_310;
        }
        uint64_t v11 = 1;
        if (a4 && (*((unsigned char *)this + 248) & 2) == 0)
        {
          CFTypeID v80 = CFGetTypeID(a4);
          if (v80 == CFBooleanGetTypeID())
          {
            if (CFBooleanGetValue((CFBooleanRef)a4)) {
              unsigned int v81 = *((_DWORD *)this + 62) | 0x80000000;
            }
            else {
              unsigned int v81 = *((_DWORD *)this + 62) & 0x7FFFFFFF;
            }
            *((_WORD *)this + 126) = *((_WORD *)this + 126);
            *((_DWORD *)this + 62) = v81;
          }
          goto LABEL_310;
        }
        goto LABEL_311;
      }
      int v17 = 213192472;
    }
    else if (ExactString <= 202673751)
    {
      if (ExactString == 200625710) {
        goto LABEL_174;
      }
      int v17 = 201641540;
    }
    else
    {
      if (ExactString == 202673752 || ExactString == 203689579) {
        goto LABEL_174;
      }
      int v17 = 205827726;
    }
LABEL_173:
    if (ExactString != v17) {
      goto LABEL_311;
    }
    goto LABEL_174;
  }
  if (ExactString <= 227954716)
  {
    if (ExactString <= 224669675)
    {
      if (ExactString == 217460578) {
        goto LABEL_174;
      }
      if (ExactString == 223645657)
      {
        CFAllocatorRef v33 = CFGetAllocator((char *)this - 16);
        CFMutableDataRef Mutable = CFDictionaryCreateMutable(v33, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        uint64_t v11 = (uint64_t)Mutable;
        if (Mutable)
        {
          CFDictionaryAddValue(Mutable, &unk_1EC0A1660, a4);
          int v36 = SocketStream::securitySetInfo_NoLock((CFDictionaryRef *)this, (const __CFDictionary *)v11, v35);
          CFRelease((CFTypeRef)v11);
          if (v36)
          {
            uint64_t v37 = (__CFDictionary *)*((void *)this + 42);
            if (a4) {
              CFDictionarySetValue(v37, @"kCFStreamPropertySocketSecurityLevel", a4);
            }
            else {
              CFDictionaryRemoveValue(v37, @"kCFStreamPropertySocketSecurityLevel");
            }
            goto LABEL_310;
          }
          goto LABEL_278;
        }
      }
      goto LABEL_311;
    }
    if (ExactString == 224669676)
    {
      CFTypeID v59 = CFGetTypeID(a4);
      if (v59 != CFDataGetTypeID()) {
        goto LABEL_278;
      }
      BytePtr = (SSLContextRef *)CFDataGetBytePtr((CFDataRef)a4);
      uint64_t v27 = SocketStream::securitySetContext_NoLock(this, *BytePtr, v61);
      goto LABEL_232;
    }
    if (ExactString == 225669117)
    {
      uint64_t v27 = SocketStream::_SOCKSSetInfo_NoLock((CFDictionaryRef *)this, (const __CFDictionary *)a4);
      goto LABEL_232;
    }
    int v17 = 226775051;
    goto LABEL_173;
  }
  if (ExactString <= 233173109)
  {
    if (ExactString != 227954717)
    {
      if (ExactString != 228814903)
      {
        if (ExactString != 231968871) {
          goto LABEL_311;
        }
        char v12 = dyld_program_sdk_at_least();
        if (a4) {
          char v14 = v12;
        }
        else {
          char v14 = 1;
        }
        if ((v14 & 1) == 0)
        {
          CFTypeID v15 = CFGetTypeID(a4);
          if (v15 == CFStringGetTypeID()) {
            a4 = (__CFString *)MEMORY[0x1E4F1CC08];
          }
        }
        if (SocketStream::securitySetInfo_NoLock((CFDictionaryRef *)this, (const __CFDictionary *)a4, v13))
        {
          CFArrayRef v16 = (__CFDictionary *)*((void *)this + 42);
          a3 = @"kCFStreamPropertySSLSettings";
          if (!a4) {
            goto LABEL_309;
          }
          goto LABEL_176;
        }
LABEL_278:
        uint64_t v11 = 0;
        goto LABEL_311;
      }
      uint64_t v27 = SocketStream::securitySetContext_NoLock(this, (SSLContextRef)a4, v10);
LABEL_232:
      uint64_t v11 = v27;
      goto LABEL_311;
    }
LABEL_174:
    if ((*((_DWORD *)this + 62) & 3) == 0) {
      goto LABEL_175;
    }
LABEL_310:
    uint64_t v11 = 1;
    goto LABEL_311;
  }
  if (ExactString != 233173110)
  {
    if (ExactString != 257143274)
    {
      if (ExactString != 558087215) {
        goto LABEL_311;
      }
      uint64_t v27 = SocketStream::_CONNECTSetInfo_NoLock((CFDictionaryRef *)this, (CFDictionaryRef)a4);
      goto LABEL_232;
    }
    goto LABEL_175;
  }
  uint64_t v11 = *((void *)this + 37);
  if (v11)
  {
    if (a4)
    {
      CFDataGetBytePtr((CFDataRef)a4);
      CFDataGetLength((CFDataRef)a4);
    }
    uint64_t v11 = _SSLSetDiffieHellmanParams() == 0;
  }
LABEL_311:
  if (!*((_DWORD *)this + 66)) {
    goto LABEL_323;
  }
  id WeakRetained = objc_loadWeakRetained((id *)this + 34);
  uint64_t v90 = WeakRetained;
  if (*((void *)this + 29) && *((uint64_t *)this + 28) >= 1 || !WeakRetained)
  {
    if (!WeakRetained) {
      goto LABEL_319;
    }
  }
  else if ((*((_DWORD *)this + 62) & 0x200) != 0)
  {
    _CFReadStreamSignalEventDelayed();
  }
  CFRelease(v90);
LABEL_319:
  id v91 = objc_loadWeakRetained((id *)this + 35);
  if (v91)
  {
    if ((*((_DWORD *)this + 62) & 0x400) != 0) {
      _CFWriteStreamSignalEventDelayed();
    }
    CFRelease(v91);
  }
LABEL_323:
  pthread_mutex_unlock(v8);
  SocketStream::dispatchSignalFromSocketCallbackUnlocked((CFRunLoopSourceRef *)v101, v92);
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)v101);
  return v11;
}

void sub_1842111D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)va);
  _Unwind_Resume(a1);
}

uint64_t _CFSocketSetNoDelay(__CFSocket *a1)
{
  int v3 = 1;
  CFSocketNativeHandle Native = CFSocketGetNative(a1);
  return setsockopt(Native, 6, 1, &v3, 4u);
}

uint64_t _CFSocketSetRecvAnyIf(__CFSocket *a1)
{
  int v3 = 1;
  CFSocketNativeHandle Native = CFSocketGetNative(a1);
  return setsockopt(Native, 0xFFFF, 4356, &v3, 4u);
}

uint64_t SocketStream::_CONNECTSetInfo_NoLock(CFDictionaryRef *this, CFDictionaryRef theDict)
{
  if (theDict)
  {
    CFNumberRef Value = CFDictionaryGetValue(theDict, &unk_1EC0A56B0);
    int v5 = CFDictionaryGetValue(theDict, &unk_1EC0A56E8);
    BOOL v6 = CFDictionaryGetValue(this[42], &unk_1EC0A5678);
    if (Value) {
      BOOL v7 = v5 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (v7) {
      return 0;
    }
    CFTypeID v8 = this + 42;
  }
  else
  {
    CFTypeID v8 = this + 42;
    BOOL v6 = CFDictionaryGetValue(this[42], &unk_1EC0A5678);
  }
  uint64_t v9 = *((unsigned int *)this + 62);
  unint64_t v10 = v9 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v9 & 0x100) != 0) {
    return 0;
  }
  if ((v9 & 3) != 0)
  {
    unsigned int v11 = *((_DWORD *)this + 103);
    if (v11)
    {
      uint64_t v12 = 0;
      while (((v11 >> v12) & 1) == 0)
      {
        if (++v12 == 8) {
          goto LABEL_18;
        }
      }
      if (v12 == 5)
      {
        char v13 = 0;
        if (!v6) {
          goto LABEL_21;
        }
        goto LABEL_20;
      }
    }
LABEL_18:
    if ((v10 & 0xC00000000) != 0x400000000) {
      return 0;
    }
  }
  char v13 = 1;
  if (!v6) {
    goto LABEL_21;
  }
LABEL_20:
  if (CFEqual(v6, theDict)) {
    return 1;
  }
LABEL_21:
  char v14 = *v8;
  if (!theDict)
  {
    CFDictionaryRemoveValue(v14, &unk_1EC0A5678);
    SocketStream::removeHandshake_NoLock((uint64_t)this, 6);
    return 1;
  }
  CFTypeID v15 = CFDictionaryGetValue(v14, &unk_1EC0A0FD0);
  if (!v15)
  {
    uint64_t result = (uint64_t)CFDictionaryGetValue(*v8, &unk_1EC0A1040);
    if (!result) {
      return result;
    }
    uint64_t result = (uint64_t)CFNetServiceGetInfo(result, 5u);
    if (!result) {
      return result;
    }
    goto LABEL_32;
  }
  uint64_t v16 = (uint64_t)v15;
  CFArrayRef Info = (const __CFArray *)CFHostGetInfo((uint64_t)v15, 1, 0);
  if (Info && CFArrayGetCount(Info)
    || (uint64_t result = (uint64_t)CFHostGetInfo(v16, 0, 0)) != 0 && (uint64_t result = CFArrayGetCount((CFArrayRef)result)) != 0)
  {
LABEL_32:
    SocketStream::addHandshake_NoLock((uint64_t)this, 6);
    if ((v13 & 1) == 0)
    {
      CFTypeID v19 = CFDictionaryGetValue(*v8, &unk_1EC0A5720);
      if (v19) {
        CFDictionarySetValue(*v8, &unk_1EC0A5790, v19);
      }
      CFDictionaryRemoveValue(this[42], &unk_1EC0A5720);
      SocketStream::removeHandshake_NoLock((uint64_t)this, 5);
    }
    CFDictionarySetValue(*v8, &unk_1EC0A5678, theDict);
    return 1;
  }
  return result;
}

uint64_t SocketStream::securitySetInfo_NoLock(CFDictionaryRef *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  if (!SocketStream::securitySetContext_NoLock((SocketStream *)this, 0, a3)) {
    return 0;
  }
  if (a2)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EC0A1628);
    CFAllocatorRef v6 = CFGetAllocator(this - 2);
    if (Value) {
      BOOL v7 = CFBooleanGetValue(Value) != 0;
    }
    else {
      BOOL v7 = 0;
    }
    SSLContextRef v9 = SSLCreateContext(v6, (SSLProtocolSide)!v7, kSSLStreamType);
    if (v9)
    {
      unint64_t v10 = v9;
      unsigned int v11 = CFDictionaryGetValue(a2, &unk_1EC0A01D0);
      uint64_t v12 = (const void **)MEMORY[0x1E4F1CFD0];
      if (v11)
      {
        char v13 = v11;
        CFTypeID v14 = CFGetTypeID(v11);
        if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr) = 0;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&valuePtr, 2u);
        }
        if (*v12 == v13)
        {
          uint64_t v15 = *((unsigned int *)this + 62);
          unint64_t v16 = v15 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x40000000000;
          *((_DWORD *)this + 62) = v15;
          *((_WORD *)this + 126) = WORD2(v16);
        }
      }
      int v17 = CFDictionaryGetValue(a2, &unk_1EC0A0198);
      int v18 = v17;
      if (v17)
      {
        CFTypeID v19 = CFGetTypeID(v17);
        if (v19 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr) = 0;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&valuePtr, 2u);
        }
        if (*v12 == v18)
        {
          uint64_t v20 = *((unsigned int *)this + 62);
          unint64_t v21 = v20 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x80000000000;
          *((_DWORD *)this + 62) = v20;
          *((_WORD *)this + 126) = WORD2(v21);
        }
      }
      CFRange v22 = CFDictionaryGetValue(a2, &unk_1EC0A0160);
      CFTypeID v23 = v22;
      if (v22)
      {
        CFTypeID v24 = CFGetTypeID(v22);
        if (v24 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr) = 0;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&valuePtr, 2u);
        }
        if (*v12 == v23)
        {
          uint64_t v25 = *((unsigned int *)this + 62);
          unint64_t v26 = v25 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x10000000000;
          *((_DWORD *)this + 62) = v25;
          *((_WORD *)this + 126) = WORD2(v26);
        }
      }
      CFStringRef v27 = (const __CFString *)CFDictionaryGetValue(a2, &unk_1EC0A1740);
      if (v27 && SSLSetSessionConfig(v10, v27)) {
        goto LABEL_96;
      }
      CFDataRef v28 = (const __CFData *)CFDictionaryGetValue(a2, &unk_1EC0A00F0);
      CFDataRef v29 = v28;
      if (v28)
      {
        BytePtr = CFDataGetBytePtr(v28);
        unint64_t Length = CFDataGetLength(v29);
        OSStatus v32 = SSLSetEnabledCiphers(v10, (const SSLCipherSuite *)BytePtr, Length >> 1);
        if (v32) {
          CFLog();
        }
      }
      else
      {
        OSStatus v32 = 0;
      }
      CFNumberRef v33 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_1EC0A05C0);
      CFNumberRef v34 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_1EC0A0588);
      if ((unint64_t)v33 | (unint64_t)v34)
      {
        if (!v33) {
          goto LABEL_41;
        }
        CFAllocatorRef valuePtr = 0;
        CFNumberGetValue(v33, kCFNumberCFIndexType, &valuePtr);
        if ((int)valuePtr <= 4) {
          SSLProtocol v35 = kTLSProtocol1;
        }
        else {
          SSLProtocol v35 = (int)valuePtr;
        }
        if (SSLSetProtocolVersionMin(v10, v35)) {
          goto LABEL_96;
        }
        int v36 = setTLSMaxVersion_ifNeeded(v27, v10, v34, v35);
        uint64_t v8 = 0;
        if (!v36)
        {
          OSStatus v32 = 0;
LABEL_41:
          if (v34)
          {
            CFAllocatorRef valuePtr = 0;
            CFNumberGetValue(v34, kCFNumberCFIndexType, &valuePtr);
            if (valuePtr)
            {
              CFAllocatorRef valuePtr = 0;
              CFNumberGetValue(v34, kCFNumberCFIndexType, &valuePtr);
              uint64_t v8 = 0;
              if (SSLSetProtocolVersionMax(v10, (SSLProtocol)valuePtr)) {
                goto LABEL_97;
              }
            }
            OSStatus v32 = 0;
          }
          goto LABEL_68;
        }
LABEL_97:
        CFRelease(v10);
        return v8;
      }
      BOOL v37 = v27 != 0;
      CFStringRef v38 = (const __CFString *)CFDictionaryGetValue(a2, &unk_1EC0A1660);
      if (v38) {
        int v39 = 1;
      }
      else {
        int v39 = v37;
      }
      if (!v39) {
        CFStringRef v38 = (const __CFString *)&unk_1EC0A13C0;
      }
      if (!v38) {
        goto LABEL_68;
      }
      int ExactString = _findExactString(v38, 2u);
      SSLProtocol v41 = kTLSProtocol1;
      SSLProtocol v42 = kTLSProtocol12;
      if (ExactString <= 239366374)
      {
        if (ExactString == 235147427)
        {
          uint64_t v8 = 1;
          goto LABEL_97;
        }
        if (ExactString == 236204212 || ExactString == 237252805) {
          goto LABEL_65;
        }
      }
      else
      {
        if (ExactString <= 241463565)
        {
          if (ExactString != 239366375)
          {
            if (ExactString == 240455929) {
              SSLProtocol v42 = kTLSProtocol1;
            }
            goto LABEL_66;
          }
          goto LABEL_65;
        }
        if (ExactString == 242512160)
        {
          SSLProtocol v41 = kTLSProtocol12;
          goto LABEL_65;
        }
        if (ExactString == 241463566)
        {
          SSLProtocol v41 = kTLSProtocol11;
LABEL_65:
          SSLProtocol v42 = v41;
        }
      }
LABEL_66:
      if (SSLSetProtocolVersionMax(v10, v42)) {
        goto LABEL_96;
      }
      OSStatus v32 = SSLSetProtocolVersionMin(v10, v41);
LABEL_68:
      CFBooleanRef v43 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EC0A0470);
      if (v43 && CFBooleanGetValue(v43)) {
        SSLSetSessionOption(v10, kSSLSessionOptionFallback, 1u);
      }
      CFBooleanRef v44 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EC0A0518);
      if (v44 && CFBooleanGetValue(v44))
      {
        *((_DWORD *)this + 62) |= 0x8000u;
      }
      else
      {
        unint64_t v45 = this[31] & 0xFFFF7FFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        *((_DWORD *)this + 62) &= ~0x8000u;
        *((_WORD *)this + 126) = WORD2(v45);
      }
      CFBooleanRef v46 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EC0A0550);
      if (v46 && CFBooleanGetValue(v46))
      {
        *((_DWORD *)this + 62) |= 0x18000u;
        SSLSetSessionOption(v10, kSSLSessionOptionFalseStart, 1u);
      }
      else
      {
        unint64_t v47 = this[31] & 0xFFFEFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        *((_DWORD *)this + 62) &= ~0x10000u;
        *((_WORD *)this + 126) = WORD2(v47);
      }
      double v48 = CFDictionaryGetValue(a2, &unk_1EC0A04A8);
      if (v48 && CFEqual(v48, (CFTypeRef)*MEMORY[0x1E4F1CFC8]))
      {
        *((_DWORD *)this + 62) |= 0x80000u;
      }
      else
      {
        unint64_t v49 = this[31] & 0xFFF7FFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        *((_DWORD *)this + 62) &= ~0x80000u;
        *((_WORD *)this + 126) = WORD2(v49);
      }
      CFDataRef v50 = (const __CFData *)CFDictionaryGetValue(a2, &unk_1EC0A1708);
      CFDataRef v51 = (const __CFData *)CFDictionaryGetValue(a2, &unk_1EC0A16D0);
      if (v50)
      {
        CFDataRef v52 = v51;
        if (v51)
        {
          CFDataGetBytePtr(v50);
          CFDataGetLength(v50);
          if (SSLSetPSKSharedSecret()
            || (CFDataGetBytePtr(v52), CFDataGetLength(v52), SSLSetPSKIdentity()))
          {
            CFLog();
            goto LABEL_96;
          }
          OSStatus v32 = 0;
        }
      }
      if (v29 || (CFDataRef v54 = (const __CFData *)CFDictionaryGetValue(a2, &unk_1EC0A15F0), (v55 = v54) == 0))
      {
        int v53 = 1;
      }
      else
      {
        uint64_t v56 = CFDataGetBytePtr(v54);
        unint64_t v57 = CFDataGetLength(v55);
        OSStatus v32 = SSLSetEnabledCiphers(v10, (const SSLCipherSuite *)v56, v57 >> 1);
        int v53 = 0;
      }
      CFBooleanRef v58 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EC0A0438);
      if (v58)
      {
        CFBooleanGetValue(v58);
        SSLSetDHEEnabled();
      }
      if (v32) {
        goto LABEL_96;
      }
      uint64_t v60 = (*((uint64_t (**)(CFDictionaryRef *))*this + 23))(this);
      if (v60)
      {
        SSLSetSessionOption(v10, kSSLSessionOptionBreakOnCertRequested, 1u);
        SSLSetSessionOption(v10, kSSLSessionOptionBreakOnServerAuth, 1u);
        (*(void (**)(uint64_t))(*(void *)v60 + 24))(v60);
      }
      CFBooleanRef v61 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EC0A1548);
      if (v61)
      {
        if (CFBooleanGetValue(v61) && _SSLSetAllowsExpiredCerts()) {
          goto LABEL_96;
        }
      }
      CFBooleanRef v62 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EC0A1580);
      if (v62)
      {
        if (CFBooleanGetValue(v62) && _SSLSetAllowsExpiredRoots()) {
          goto LABEL_96;
        }
      }
      CFBooleanRef v63 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EC0A1510);
      if (v63)
      {
        if (CFBooleanGetValue(v63) && _SSLSetAllowsAnyRoot()) {
          goto LABEL_96;
        }
      }
      CFBooleanRef v64 = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_1EC0A1778);
      if (v64)
      {
        if (!CFBooleanGetValue(v64) && SSLSetSessionOption(v10, kSSLSessionOptionBreakOnServerAuth, 1u)) {
          goto LABEL_96;
        }
      }
      CFArrayRef v65 = (const __CFArray *)CFDictionaryGetValue(a2, &unk_1EC0A15B8);
      if (v65)
      {
        if (SSLSetCertificate(v10, v65)) {
          goto LABEL_96;
        }
      }
      CFStringRef v66 = (const __CFString *)CFDictionaryGetValue(a2, &unk_1EC0A1698);
      if (!v66)
      {
        CFStringRef v66 = (const __CFString *)CFDictionaryGetValue(this[42], &unk_1EC09FBB0);
        CFTypeID v67 = CFDictionaryGetValue(this[42], &unk_1EC0A0FD0);
        if (!v66)
        {
          if (v67)
          {
            CFArrayRef Info = (const __CFArray *)CFHostGetInfo((uint64_t)v67, 1, 0);
            if (!Info) {
              goto LABEL_132;
            }
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(Info, 0);
          }
          else
          {
            CFTypeID v71 = CFDictionaryGetValue(this[42], &unk_1EC0A1040);
            if (!v71) {
              goto LABEL_132;
            }
            CFStringRef ValueAtIndex = (const __CFString *)CFNetServiceGetInfo((uint64_t)v71, 5u);
          }
          CFStringRef v66 = ValueAtIndex;
          if (!ValueAtIndex) {
            goto LABEL_132;
          }
        }
      }
      if (CFEqual(v66, (CFTypeRef)*MEMORY[0x1E4F1D260]))
      {
        if (!SSLSetPeerDomainName(v10, 0, 0)) {
          goto LABEL_132;
        }
LABEL_96:
        uint64_t v8 = 0;
        goto LABEL_97;
      }
      CFAllocatorRef valuePtr = CFGetAllocator(this[42]);
      size_t v78 = 1023;
      ptr = _CFStringGetOrCreateCString(valuePtr, v66, v80, (uint64_t *)&v78, 0x8000100u);
      OSStatus v68 = SSLSetPeerDomainName(v10, (const char *)ptr, v78);
      if (ptr && v80 != ptr) {
        CFAllocatorDeallocate(valuePtr, ptr);
      }
      if (v68) {
        goto LABEL_96;
      }
LABEL_132:
      if (v29) {
        goto LABEL_145;
      }
      CFBooleanRef v72 = (const __CFBoolean *)CFDictionaryGetValue(this[42], &unk_1EC09FCC8);
      int v73 = v72 ? 1 : v53;
      if (v73 != 1) {
        goto LABEL_145;
      }
      if (v72) {
        CFBooleanGetValue(v72);
      }
      if (!SSLSetAllowAnonymousCiphers())
      {
LABEL_145:
        CFDataRef v74 = (const __CFData *)CFDictionaryGetValue(a2, &unk_1EC0A12A8);
        CFDataRef v76 = v74;
        if (!v74 || (CFDataGetBytePtr(v74), CFDataGetLength(v76), !_SSLSetDiffieHellmanParams()))
        {
          uint64_t v8 = SocketStream::securitySetContext_NoLock((SocketStream *)this, v10, v75);
          goto LABEL_97;
        }
      }
      goto LABEL_96;
    }
    return 0;
  }
  return 1;
}

void sub_184212048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  if (ptr)
  {
    if (v13 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t SocketStream::_SOCKSSetInfo_NoLock(CFDictionaryRef *this, const __CFDictionary *a2)
{
  CFBooleanRef Value = CFDictionaryGetValue(this[42], &unk_1EC0A1120);
  if (a2)
  {
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (TypeID != CFGetTypeID(a2)) {
      return 0;
    }
  }
  if ((this[31] & 0x103) != 0) {
    return 0;
  }
  if (Value && CFEqual(Value, a2)) {
    return 1;
  }
  if (!a2)
  {
    CFDictionaryRemoveValue(this[42], &unk_1EC0A1120);
    SocketStream::removeHandshake_NoLock((uint64_t)this, 4);
    uint64_t v6 = 1;
    SocketStream::removeHandshake_NoLock((uint64_t)this, 1);
    return v6;
  }
  CFStringRef v8 = (const __CFString *)CFDictionaryGetValue(a2, (const void *)*MEMORY[0x1E4F1D470]);
  CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(a2, (const void *)*MEMORY[0x1E4F1D450]);
  unint64_t v10 = CFDictionaryGetValue(a2, (const void *)*MEMORY[0x1E4F1D478]);
  unsigned int v11 = (const void *)*MEMORY[0x1E4F1D4B0];
  if (v10) {
    uint64_t v12 = v10;
  }
  else {
    uint64_t v12 = (const void *)*MEMORY[0x1E4F1D4B0];
  }
  char v13 = CFDictionaryGetValue(this[42], &unk_1EC0A0FD0);
  CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_1EC0A17E8);
  int valuePtr = 0;
  uint64_t v15 = (const void *)*MEMORY[0x1E4F1D4A8];
  if (CFEqual(v12, (CFTypeRef)*MEMORY[0x1E4F1D4A8]) || CFEqual(v12, v11))
  {
    if (v14 && CFNumberGetValue(v14, kCFNumberSInt32Type, &valuePtr) && !valuePtr)
    {
      CFDictionaryRemoveValue(this[42], &unk_1EC0A1120);
      return 1;
    }
    if (!v13)
    {
      if (CFDictionaryGetValue(this[42], &unk_1EC0A1040)) {
        return 0;
      }
      goto LABEL_33;
    }
    CFArrayRef Info = (const __CFArray *)CFHostGetInfo((uint64_t)v13, 1, 0);
    if (Info && (CFArrayRef v17 = Info, CFArrayGetCount(Info)))
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v17, 0);
      if (!ValueAtIndex) {
        goto LABEL_33;
      }
      CFStringRef v19 = (const __CFString *)CFRetain(ValueAtIndex);
    }
    else
    {
      CFArrayRef v20 = (const __CFArray *)CFHostGetInfo((uint64_t)v13, 0, 0);
      if (!v20) {
        goto LABEL_33;
      }
      CFArrayRef v21 = v20;
      if (!CFArrayGetCount(v20)) {
        goto LABEL_33;
      }
      CFGetAllocator(v21);
      CFDataRef v22 = (const __CFData *)CFArrayGetValueAtIndex(v21, 0);
      CFStringRef v19 = _CFNetworkCFStringCreateWithCFDataAddress(v22);
    }
    CFStringRef v23 = v19;
    if (v19)
    {
      CFIndex Length = CFStringGetLength(v19);
      CFArrayRef v24 = (const __CFArray *)CFDictionaryGetValue(a2, &unk_1EC0A05F8);
      uint64_t v25 = CFDictionaryGetValue(a2, &unk_1EC0A0630);
      LODWORD(v24) = _CFNetworkDoesNeedProxy(v23, v24, v25);
      CFRelease(v23);
      if (!v24 || CFEqual(v12, v11) && (unint64_t)(Length - 256) < 0xFFFFFFFFFFFFFF01) {
        return 0;
      }
LABEL_34:
      if ((!CFEqual(v12, v11) || !v9 || CFStringGetLength(v9) <= 255)
        && (!v8
         || (!CFEqual(v12, v15) || CFStringGetLength(v8) <= 512) && (!CFEqual(v12, v11) || CFStringGetLength(v8) < 256)))
      {
        if (CFEqual(v12, v15)) {
          int v26 = 4;
        }
        else {
          int v26 = 1;
        }
        SocketStream::addHandshake_NoLock((uint64_t)this, v26);
        CFDictionarySetValue(this[42], &unk_1EC0A1120, a2);
        return 1;
      }
      return 0;
    }
LABEL_33:
    if (!CFEqual(v12, v15)) {
      return 0;
    }
    goto LABEL_34;
  }
  return 0;
}

uint64_t _CFSocketSetTrafficMgtBackground(__CFSocket *a1, int a2)
{
  BOOL v4 = a2 != 0;
  CFSocketNativeHandle Native = CFSocketGetNative(a1);
  return setsockopt(Native, 0xFFFF, 4357, &v4, 4u);
}

uint64_t SocketStream::securitySetContext_NoLock(SocketStream *this, SSLContextRef context, const __CFDictionary *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v5 = (SSLContext *)*((void *)this + 37);
  if (v5)
  {
    state[0] = kSSLIdle;
    OSStatus v6 = SSLGetSessionState(v5, state);
    if (v6 | state[0]) {
      return 0;
    }
    SSLContextRef v8 = (SSLContextRef)*((void *)this + 37);
    if (v8 != context)
    {
      *((void *)this + 37) = 0;
      if (v8) {
        CFRelease(v8);
      }
    }
  }
  else if (context)
  {
    *((void *)this + 37) = 0;
  }
  uint64_t v9 = *((void *)this + 75);
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    *((void *)this + 75) = 0;
  }
  if (context)
  {
    OSStatus v10 = SSLSetIOFuncs(context, (SSLReadFunc)SocketStream::_SecurityReadFunc_NoLock, (SSLWriteFunc)SocketStream::_SecurityWriteFunc_NoLock);
    *((_DWORD *)this + 66) = v10;
    if (v10) {
      goto LABEL_24;
    }
    OSStatus v10 = SSLSetConnection(context, this);
    *((_DWORD *)this + 66) = v10;
    if (v10) {
      goto LABEL_24;
    }
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F8D8);
    if (Value)
    {
      CFArrayRef v12 = Value;
      SSLSetNPNFunc();
      memset(&v30, 0, sizeof(v30));
      int Count = CFArrayGetCount(v12);
      if (Count >= 1)
      {
        CFIndex v14 = 0;
        uint64_t v15 = Count;
        do
        {
          CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, v14);
          int Length = CFStringGetLength(ValueAtIndex);
          std::string::value_type v18 = Length;
          if (Length <= 31 && CFStringGetCString(ValueAtIndex, (char *)state, 32, 0x600u))
          {
            std::string::value_type __s = v18;
            std::string::append(&v30, &__s, 1uLL);
            std::string::append(&v30, (const std::string::value_type *)state);
          }
          ++v14;
        }
        while (v15 != v14);
      }
      SSLSetALPNFunc();
      SSLSetALPNData();
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }
    OSStatus v10 = *((_DWORD *)this + 66);
    if (v10)
    {
LABEL_24:
      uint64_t result = 0;
      *((void *)this + 32) = (int)*MEMORY[0x1E4F1D430];
      *((_DWORD *)this + 66) = v10;
      return result;
    }
    if (*((void *)this + 27))
    {
      CFAllocatorRef v19 = CFGetAllocator((char *)this - 16);
      CFArrayRef v20 = CFAllocatorAllocate(v19, 96, 0);
      v20[4] = 0u;
      v20[5] = 0u;
      void v20[2] = 0u;
      v20[3] = 0u;
      *CFArrayRef v20 = 0u;
      v20[1] = 0u;
      CFAllocatorRef v21 = CFGetAllocator((char *)this - 16);
      uint64_t v22 = *((void *)this + 27);
      uint64_t v23 = *(void *)(v22 + 272);
      CFArrayRef v24 = (long long *)(v22 + 280);
      uint64_t v25 = *(void *)(v22 + 328);
      long long v27 = v24[1];
      long long v26 = v24[2];
      long long v28 = *v24;
      *(void *)CFArrayRef v20 = &unk_1ECF9A900;
      *((void *)v20 + 1) = v21;
      *((void *)v20 + 3) = 0;
      *((void *)v20 + 4) = v23;
      *(_OWORD *)((char *)v20 + 40) = v28;
      *(_OWORD *)((char *)v20 + 56) = v27;
      *(_OWORD *)((char *)v20 + 72) = v26;
      *((void *)v20 + 11) = v25;
      *((void *)v20 + 2) = 0;
      *((void *)this + 75) = v20;
    }
    SocketStream::addHandshake_NoLock((uint64_t)this, 7);
    *((void *)this + 37) = CFRetain(context);
  }
  else
  {
    SocketStream::removeHandshake_NoLock((uint64_t)this, 7);
  }
  return 1;
}

void sub_184212760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void SocketStream::checkInVoIPSocket(SocketStream *this)
{
  int v2 = (__CFSocket *)*((void *)this + 36);
  if (v2
    && CFSocketIsValid(v2)
    && *((_DWORD *)this + 102) == 1
    && !*((void *)this + 69)
    && CFSocketGetNative(*((CFSocketRef *)this + 36)) != -1)
  {
    BOOL v4 = (void *)((char *)this + 552);
    double v5 = gotLoadHelper_x8__spd_client_create(v3);
    if (*(void *)(v6 + 2408) && !spd_client_create_delayInitStub(v5))
    {
      if (!spd_client_checkin_socket_delayInitStub(v7)) {
        return;
      }
      spd_client_destroy_delayInitStub(v8);
    }
    void *v4 = 0;
  }
}

uint64_t SocketStream::setupMinimumThroughput(uint64_t this, int a2)
{
  if (*(void *)(this + 560))
  {
    int valuePtr = 0;
    this = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(this + 336), &unk_1EC09F868);
    if (this)
    {
      CFNumberRef v3 = (const __CFNumber *)this;
      CFTypeID v4 = CFGetTypeID((CFTypeRef)this);
      this = CFNumberGetTypeID();
      if (v4 != this) {
        return this;
      }
      CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr);
    }
    else if (!a2)
    {
      return this;
    }
    return tcp_connection_set_minimum_throughput();
  }
  return this;
}

uint64_t SocketStream::updateExcessiveKeepalivesParameters(uint64_t this, CFTypeRef cf)
{
  if (*(void *)(this + 560))
  {
    uint64_t valuePtr = 0;
    if (cf)
    {
      CFTypeID v3 = CFGetTypeID(cf);
      if (v3 == CFDictionaryGetTypeID())
      {
        CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_kExcessiveKeepalivesParametersEnabled");
        if (Value) {
          CFBooleanGetValue(Value);
        }
        CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_kExcessiveKeepalivesParametersInterval");
        if (v5) {
          CFNumberGetValue(v5, kCFNumberSInt32Type, (char *)&valuePtr + 4);
        }
        CFNumberRef v6 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_kExcessiveKeepalivesParametersCount");
        if (v6) {
          CFNumberGetValue(v6, kCFNumberSInt32Type, &valuePtr);
        }
      }
    }
    return tcp_connection_add_event_excessive_keepalives();
  }
  return this;
}

uint64_t SocketStream::updateTCPKeepalivesParameters(uint64_t this, CFTypeRef cf)
{
  if (*(void *)(this + 560))
  {
    uint64_t valuePtr = 0;
    if (cf)
    {
      CFTypeID v3 = CFGetTypeID(cf);
      if (v3 == CFDictionaryGetTypeID())
      {
        CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_kTCPKeepAliveParametersEnabled");
        if (Value) {
          CFBooleanGetValue(Value);
        }
        CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_kTCPKeepAliveParametersIdleTime");
        if (v5) {
          CFNumberGetValue(v5, kCFNumberSInt32Type, (char *)&valuePtr + 4);
        }
        CFNumberRef v6 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_kTCPKeepAliveParametersInterval");
        if (v6) {
          CFNumberGetValue(v6, kCFNumberSInt32Type, &valuePtr);
        }
      }
    }
    return tcp_connection_set_keepalive();
  }
  return this;
}

uint64_t SocketStream::updateTCPAdaptiveParamters(SocketStream *this, CFNumberRef number, CFNumberRef a3)
{
  uint64_t result = *((void *)this + 70);
  if (result)
  {
    CFNumberRef v5 = (CFNumberRef *)MEMORY[0x1E4F1D260];
    if (number)
    {
      if ((CFNumberRef)*MEMORY[0x1E4F1D260] == number)
      {
        uint64_t result = tcp_connection_add_event_adaptive_read_timeout();
      }
      else
      {
        int valuePtr = 0;
        CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
        tcp_connection_add_event_adaptive_read_timeout();
        uint64_t result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_145, 2);
        if (result)
        {
          uint64_t v6 = result;
          uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void))(*(void *)result + 16))(result, "updateTCPAdaptiveParamters", 0);
          if (result)
          {
            (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v6 + 72))(v6, "conn", @"%p");
            (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v6 + 72))(v6, "read count", @"%d");
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
          }
        }
      }
    }
    if (a3)
    {
      if (*v5 == a3)
      {
        return tcp_connection_add_event_adaptive_write_timeout();
      }
      else
      {
        int v8 = 0;
        CFNumberGetValue(a3, kCFNumberSInt32Type, &v8);
        tcp_connection_add_event_adaptive_write_timeout();
        uint64_t result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_149, 2);
        if (result)
        {
          uint64_t v7 = result;
          uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void))(*(void *)result + 16))(result, "updateTCPAdaptiveParamters", 0);
          if (result)
          {
            (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72))(v7, "conn", @"%p");
            (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72))(v7, "write count", @"%d");
            return (*(uint64_t (**)(uint64_t))(*(void *)v7 + 8))(v7);
          }
        }
      }
    }
  }
  return result;
}

void SocketStream::updateTCPConnectionPoolPriority(SocketStream *this, const __CFString *a2, const __CFNumber *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a2 && *((void *)this + 70))
  {
    CFAllocatorRef allocator = CFGetAllocator((char *)this - 16);
    uint64_t v8 = 1023;
    CFNumberRef v5 = _CFStringGetOrCreateCString(allocator, a2, v10, &v8, 0x8000100u);
    ptr = v5;
    uint64_t valuePtr = 300;
    if (a3) {
      CFNumberGetValue(a3, kCFNumberSInt64Type, &valuePtr);
    }
    if (v5) {
      tcp_connection_set_connection_pool();
    }
    if (ptr)
    {
      if (v10 != ptr) {
        CFAllocatorDeallocate(allocator, ptr);
      }
    }
  }
}

void sub_184212E44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
}

CFDictionaryRef ___ZN12SocketStream11setPropertyEPKvPK10__CFStringS1__block_invoke(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  return SocketStream::copyProperty_NoLock(*(SocketStream **)(a1 + 32), *(const __CFString **)(*(void *)(a1 + 48) + 8), a3);
}

CFDictionaryRef SocketStream::copyProperty_NoLock(SocketStream *this, const __CFString *a2, const __CFString *a3)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  CFArrayRef names = 0;
  CFBooleanRef Value = (char *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), a2);
  if (Value)
  {
LABEL_2:
    CFTypeID v6 = CFGetTypeID(Value);
    if (HostBase::Class(void)::sOnce_HostBase != -1) {
      dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
    }
    if (*(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96) == v6)
    {
      CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
      return CFHostCreateCopy(v7, (CFHostRef)Value);
    }
    if (CFNetServiceGetTypeID() == v6)
    {
      CFAllocatorRef v13 = CFGetAllocator((char *)this - 16);
      return CFNetServiceCreateCopy(v13, (CFNetServiceRef)Value);
    }
    if (CFDictionaryGetTypeID() == v6)
    {
      CFAllocatorRef v15 = CFGetAllocator((char *)this - 16);
      return CFDictionaryCreateCopy(v15, (CFDictionaryRef)Value);
    }
    if (CFArrayGetTypeID() == v6)
    {
      CFAllocatorRef v19 = CFGetAllocator((char *)this - 16);
      return CFArrayCreateCopy(v19, (CFArrayRef)Value);
    }
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*(void *)(HTTPMessage::Class(void)::sClass_OBJTYPE + 96) == v6)
    {
      CFAllocatorRef v21 = CFGetAllocator((char *)this - 16);
      return CFHTTPMessageCreateCopy(v21, (CFHTTPMessageRef)Value);
    }
    uint64_t v8 = Value;
    return (CFDictionaryRef)CFRetain(v8);
  }
  int ExactString = _findExactString(a2, 0);
  if (ExactString <= 198495749)
  {
    if (ExactString <= 131443042)
    {
      if (ExactString <= 99878706)
      {
        if (ExactString <= 85255704)
        {
          if (ExactString != 31695365)
          {
            if (ExactString != 56869868) {
              return names;
            }
            uint64_t v22 = (__CFSocket *)*((void *)this + 36);
            if (v22 && CFSocketIsValid(v22)) {
              return CFSocketCopyPeerAddress(*((CFSocketRef *)this + 36));
            }
            return 0;
          }
          unint64_t v16 = (void **)MEMORY[0x1E4F1CFD0];
          CFArrayRef v17 = (void **)MEMORY[0x1E4F1CFC8];
          BOOL v18 = ((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x200000000) == 0;
          goto LABEL_131;
        }
        if (ExactString == 85255705)
        {
LABEL_100:
          if (!*((void *)this + 70)) {
            return names;
          }
          int is_expensive = tcp_connection_is_expensive();
          goto LABEL_144;
        }
        int v26 = 88393301;
      }
      else
      {
        if (ExactString > 124045534)
        {
          if (ExactString == 124045535)
          {
            uint64_t v8 = (char *)this - 16;
            return (CFDictionaryRef)CFRetain(v8);
          }
          if (ExactString == 129296697)
          {
            if (*((void *)this + 37)) {
              SSLGetCertificate();
            }
            return names;
          }
          if (ExactString != 130378061) {
            return names;
          }
          CFIndex v14 = (SSLContext *)*((void *)this + 37);
          if (!v14) {
            return names;
          }
          *(_DWORD *)&clientState.sa_len = 0;
          if (SSLGetClientCertificateState(v14, (SSLClientCertificateState *)&clientState)) {
            return 0;
          }
LABEL_137:
          CFAllocatorRef v27 = CFGetAllocator((char *)this - 16);
          CFNumberType v28 = kCFNumberIntType;
          return CFNumberCreate(v27, v28, &clientState);
        }
        if (ExactString == 99878707)
        {
          if (!*((void *)this + 70)) {
            return names;
          }
          int is_expensive = tcp_connection_has_better_route();
LABEL_144:
          CFDataRef v29 = (void **)MEMORY[0x1E4F1CFD0];
          if (!is_expensive) {
            CFDataRef v29 = (void **)MEMORY[0x1E4F1CFC8];
          }
          goto LABEL_154;
        }
        int v26 = 100902724;
      }
      if (ExactString == v26) {
        return (CFDictionaryRef)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), a2);
      }
      return names;
    }
    if (ExactString <= 161713009)
    {
      if (ExactString <= 140716566)
      {
        if (ExactString != 131443043)
        {
          if (ExactString != 132442490) {
            return names;
          }
          CFArrayRef v24 = (SSLContext *)*((void *)this + 37);
          if (!v24 || !SSLCopyDistinguishedNames(v24, &names)) {
            return names;
          }
          return 0;
        }
        if (!*((void *)this + 37)) {
          return names;
        }
        *(_DWORD *)&clientState.sa_len = 0;
        if (SSLGetClientSideAuthenticate()) {
          *(_DWORD *)&clientState.sa_len = 0;
        }
        goto LABEL_137;
      }
      if (ExactString == 140716567)
      {
        if (!*((void *)this + 70)) {
          return names;
        }
        uint64_t v46 = tcp_connection_copy_tcp_info();
        if (!v46) {
          return names;
        }
        unint64_t v47 = (void *)v46;
        if (MEMORY[0x18531EBC0]() == MEMORY[0x1E4F14590] && xpc_dictionary_get_count(v47)) {
          CFArrayRef names = (CFArrayRef)_CFXPCCreateCFObjectFromXPCObject();
        }
        int v36 = v47;
        goto LABEL_175;
      }
      if (ExactString != 160648036) {
        return names;
      }
      CFDataRef v29 = (void **)MEMORY[0x1E4F1CFD0];
      int v30 = *((unsigned __int8 *)this + 405);
    }
    else
    {
      if (ExactString > 192228738)
      {
        if (ExactString == 192228739)
        {
          CFBooleanRef Value = (char *)*((void *)this + 67);
          if (!Value) {
            return names;
          }
          goto LABEL_2;
        }
        if (ExactString != 194301361)
        {
          if (ExactString != 197438963) {
            return names;
          }
          unint64_t v16 = (void **)MEMORY[0x1E4F1CFD0];
          CFArrayRef v17 = (void **)MEMORY[0x1E4F1CFC8];
          BOOL v18 = (*((_DWORD *)this + 62) & 0x8000000) == 0;
LABEL_131:
          if (v18) {
            CFDataRef v29 = v17;
          }
          else {
            CFDataRef v29 = v16;
          }
          goto LABEL_154;
        }
        if (!*((void *)this + 70))
        {
          CFDataRef v29 = (void **)MEMORY[0x1E4F1CFC8];
          goto LABEL_154;
        }
        int is_expensive = tcp_connection_did_fallback();
        goto LABEL_144;
      }
      if (ExactString != 161713010)
      {
        if (ExactString != 174287922) {
          return names;
        }
        uint64_t RemoteHostName_NoLock = serviceTypeToString(*((_DWORD *)this + 102));
        goto LABEL_104;
      }
      CFDataRef v29 = (void **)MEMORY[0x1E4F1CFD0];
      int v30 = *((unsigned __int8 *)this + 406);
    }
    if (!v30) {
      CFDataRef v29 = (void **)MEMORY[0x1E4F1CFC8];
    }
    goto LABEL_154;
  }
  if (ExactString <= 218394490)
  {
    if (ExactString > 209071817)
    {
      if (ExactString > 211103476)
      {
        if (ExactString != 211103477)
        {
          if (ExactString != 212037386)
          {
            if (ExactString != 214216493) {
              return names;
            }
            unint64_t v16 = (void **)MEMORY[0x1E4F1CFD0];
            CFArrayRef v17 = (void **)MEMORY[0x1E4F1CFC8];
            BOOL v18 = ((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x100000000) == 0;
            goto LABEL_131;
          }
          CFDataRef v29 = (void **)MEMORY[0x1E4F1CFD0];
          if (*((int *)this + 62) >= 0) {
            CFDataRef v29 = (void **)MEMORY[0x1E4F1CFC8];
          }
LABEL_154:
          CFBooleanRef Value = (char *)*v29;
          if (!*v29) {
            return names;
          }
          goto LABEL_2;
        }
        if (!*((void *)this + 70)) {
          return names;
        }
        uint64_t v31 = tcp_connection_multipath_copy_subflow_switch_counts();
        if (!v31) {
          return names;
        }
        uint64_t v32 = (void *)v31;
        if (MEMORY[0x18531EBC0]() == MEMORY[0x1E4F14590] && xpc_dictionary_get_count(v32))
        {
          CFAllocatorRef v33 = CFGetAllocator((char *)this - 16);
          size_t count = xpc_dictionary_get_count(v32);
          CFArrayRef Mutable = CFDictionaryCreateMutable(v33, count, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          v48[0] = MEMORY[0x1E4F143A8];
          v48[1] = 3221225472;
          v48[2] = ___ZN12SocketStream19copyProperty_NoLockEPKvPK10__CFString_block_invoke;
          v48[3] = &__block_descriptor_48_e37_B24__0r_8__NSObject_OS_xpc_object__16l;
          v48[4] = this;
          v48[5] = Mutable;
          xpc_dictionary_apply(v32, v48);
          CFArrayRef names = Mutable;
        }
        int v36 = v32;
LABEL_175:
        xpc_release(v36);
        return names;
      }
      if (ExactString != 209071818)
      {
        if (ExactString != 209997539) {
          return names;
        }
        *(void *)&clientState.sa_len = 0;
        if (!*((void *)this + 70)) {
          goto LABEL_95;
        }
LABEL_94:
        *(void *)&clientState.sa_len = tcp_connection_multipath_get_subflow_count();
LABEL_95:
        CFAllocatorRef v27 = CFGetAllocator((char *)this - 16);
        CFNumberType v28 = kCFNumberCFIndexType;
        return CFNumberCreate(v27, v28, &clientState);
      }
      if (!*((void *)this + 70)) {
        return names;
      }
      unsigned int primary_subflow_ifindex = tcp_connection_multipath_get_primary_subflow_ifindex();
      if (!if_indextoname(primary_subflow_ifindex, (char *)&clientState)) {
        return names;
      }
      CFAllocatorRef v40 = CFGetAllocator((char *)this - 16);
      p_clientint State = &clientState;
      return (CFDictionaryRef)CFStringCreateWithCString(v40, (const char *)p_clientState, 0x8000100u);
    }
    if (ExactString > 206868128)
    {
      if (ExactString != 206868129)
      {
        if (ExactString != 207974068) {
          return names;
        }
        *(void *)&clientState.sa_len = 0;
        if (!*((void *)this + 70)) {
          goto LABEL_95;
        }
        goto LABEL_94;
      }
      CFBooleanRef v43 = (__CFSocket *)*((void *)this + 36);
      if (!v43) {
        return names;
      }
      if (!CFSocketIsValid(v43)) {
        return names;
      }
      CFSocketNativeHandle Native = CFSocketGetNative(*((CFSocketRef *)this + 36));
      socklen_t v51 = 128;
      if (getsockname(Native, &clientState, &v51)) {
        return names;
      }
      socklen_t v49 = 4;
      unsigned int v50 = 0;
      int v45 = clientState.sa_family == 30 ? 41 : 0;
      if (getsockopt(Native, v45, 9696, &v50, &v49) || !if_indextoname(v50, v53)) {
        return names;
      }
      CFAllocatorRef v40 = CFGetAllocator((char *)this - 16);
      p_clientint State = (sockaddr *)v53;
      return (CFDictionaryRef)CFStringCreateWithCString(v40, (const char *)p_clientState, 0x8000100u);
    }
    if (ExactString != 198495750)
    {
      if (ExactString != 199544346 || !*((void *)this + 70)) {
        return names;
      }
      int is_expensive = tcp_connection_is_multipath();
      goto LABEL_144;
    }
    goto LABEL_100;
  }
  if (ExactString > 228814902)
  {
    if (ExactString <= 230928471)
    {
      if (ExactString == 228814903)
      {
        uint64_t v8 = (char *)*((void *)this + 37);
        if (!v8) {
          return (CFDictionaryRef)v8;
        }
        return (CFDictionaryRef)CFRetain(v8);
      }
      if (ExactString != 229937221 || !*((void *)this + 37) || !_SSLCopyPeerCertificates()) {
        return names;
      }
    }
    else
    {
      if (ExactString != 230928472)
      {
        if (ExactString == 233173110)
        {
          if (*((void *)this + 37))
          {
            *(void *)&clientState.sa_len = 0;
            *(void *)int v53 = 0;
            if (!_SSLGetDiffieHellmanParams())
            {
              CFAllocatorRef v10 = CFGetAllocator((char *)this - 16);
              uint64_t v11 = 0;
              CFIndex v12 = *(void *)v53;
              return CFDataCreate(v10, &v11->sa_len, v12);
            }
          }
        }
        else if (ExactString == 561257568 && CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A5678))
        {
          CFAllocatorRef v20 = CFGetAllocator((char *)this - 16);
          return CFHTTPMessageCreateEmpty(v20, 0);
        }
        return names;
      }
      BOOL v37 = (SSLContext *)*((void *)this + 37);
      if (!v37 || !SocketStream::_copyPeerTrustWithPinning_NoLock((CFDictionaryRef *)this, v37, &names)) {
        return names;
      }
    }
    if (!names) {
      return names;
    }
    CFRelease(names);
    return 0;
  }
  if (ExactString <= 222621636)
  {
    if (ExactString == 218394491)
    {
      CFStringRef v38 = (__CFSocket *)*((void *)this + 36);
      if (v38 && CFSocketIsValid(v38))
      {
        *(_DWORD *)&clientState.sa_len = CFSocketGetNative(*((CFSocketRef *)this + 36));
        CFAllocatorRef v10 = CFGetAllocator((char *)this - 16);
        uint64_t v11 = &clientState;
        CFIndex v12 = 4;
        return CFDataCreate(v10, &v11->sa_len, v12);
      }
      return names;
    }
    if (ExactString != 220508062) {
      return names;
    }
    uint64_t RemoteHostName_NoLock = (uint64_t)SocketStream::getRemoteHostName_NoLock((CFDictionaryRef *)this);
LABEL_104:
    CFBooleanRef Value = (char *)RemoteHostName_NoLock;
    if (!RemoteHostName_NoLock) {
      return names;
    }
    goto LABEL_2;
  }
  switch(ExactString)
  {
    case 222621637:
      uint64_t RemoteHostName_NoLock = (uint64_t)SocketStream::getRemoteHostPort_NoLock((CFDictionaryRef *)this);
      goto LABEL_104;
    case 223645657:
      uint64_t RemoteHostName_NoLock = (uint64_t)SocketStream::securityGetProtocol(this);
      goto LABEL_104;
    case 224669676:
      if (*((void *)this + 37))
      {
        CFAllocatorRef v10 = CFGetAllocator((char *)this - 16);
        uint64_t v11 = (sockaddr *)((char *)this + 296);
        CFIndex v12 = 8;
        return CFDataCreate(v10, &v11->sa_len, v12);
      }
      return 0;
  }
  return names;
}

const void *SocketStream::getRemoteHostName_NoLock(CFDictionaryRef *this)
{
  CFBooleanRef Value = CFDictionaryGetValue(this[42], &unk_1EC0A0FD0);
  if (Value)
  {
    CFArrayRef Info = (const __CFArray *)CFHostGetInfo((uint64_t)Value, 1, 0);
    if (Info)
    {
      CFArrayRef v4 = Info;
      if (CFArrayGetCount(Info))
      {
        return CFArrayGetValueAtIndex(v4, 0);
      }
    }
    return 0;
  }
  CFTypeID v6 = CFDictionaryGetValue(this[42], &unk_1EC0A1040);
  if (!v6) {
    return 0;
  }

  return CFNetServiceGetInfo((uint64_t)v6, 5u);
}

const __CFArray *SocketStream::getRemoteHostPort_NoLock(CFDictionaryRef *this)
{
  CFBooleanRef Value = CFDictionaryGetValue(this[42], &unk_1EC0A0FD0);
  if (!Value)
  {
    CFAllocatorRef v10 = CFDictionaryGetValue(this[42], &unk_1EC0A1040);
    if (v10)
    {
      int valuePtr = v10[14];
      CFAllocatorRef v8 = CFGetAllocator(this - 2);
      p_int valuePtr = (unsigned int *)&valuePtr;
      goto LABEL_9;
    }
    return 0;
  }
  CFArrayRef Info = (const __CFArray *)CFHostGetInfo((uint64_t)Value, 0, 0);
  CFArrayRef v4 = Info;
  if (!Info) {
    return v4;
  }
  if (!CFArrayGetCount(Info)) {
    return 0;
  }
  CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v4, 0);
  BytePtr = CFDataGetBytePtr(ValueAtIndex);
  int v7 = BytePtr[1];
  if (v7 != 30)
  {
    CFArrayRef v4 = 0;
    if (v7 != 2) {
      return v4;
    }
  }
  unsigned int v13 = bswap32(*((unsigned __int16 *)BytePtr + 1)) >> 16;
  CFAllocatorRef v8 = CFGetAllocator(this - 2);
  p_int valuePtr = &v13;
LABEL_9:
  CFArrayRef v4 = CFNumberCreate(v8, kCFNumberSInt32Type, p_valuePtr);
  if (v4)
  {
    CFDictionarySetValue(this[42], &unk_1EC0A1078, v4);
    CFRelease(v4);
  }
  return v4;
}

SSLContext *SocketStream::securityGetProtocol(SocketStream *this)
{
  uint64_t result = (SSLContext *)*((void *)this + 37);
  if (result)
  {
    *(void *)SSLProtocol protocol = 0;
    SSLProtocol maxVersion = kSSLProtocolUnknown;
    SSLGetNegotiatedProtocolVersion(result, &protocol[1]);
    SSLGetProtocolVersionMin(*((SSLContextRef *)this + 37), protocol);
    SSLGetProtocolVersionMax(*((SSLContextRef *)this + 37), &maxVersion);
    if (protocol[1] == kSSLProtocol3)
    {
      SSLProtocol v3 = maxVersion;
    }
    else
    {
      if (protocol[1] == kSSLProtocol2)
      {
LABEL_6:
        CFArrayRef v4 = &kCFStreamSocketSecurityLevelSSLv2;
        return (SSLContext *)*v4;
      }
      if (protocol[1])
      {
LABEL_10:
        if (protocol[0] == kSSLProtocol2) {
          CFArrayRef v4 = &kCFStreamSocketSecurityLevelNegotiatedSSL;
        }
        else {
          CFArrayRef v4 = &kCFStreamSocketSecurityLevelTLSv1;
        }
        return (SSLContext *)*v4;
      }
      SSLProtocol v3 = maxVersion;
      if (maxVersion == kSSLProtocol2) {
        goto LABEL_6;
      }
    }
    if (v3 == kSSLProtocol3)
    {
      CFArrayRef v4 = &kCFStreamSocketSecurityLevelSSLv3;
      return (SSLContext *)*v4;
    }
    goto LABEL_10;
  }
  return result;
}

uint64_t ___ZN12SocketStream19copyProperty_NoLockEPKvPK10__CFString_block_invoke(uint64_t a1, const char *a2, void *a3)
{
  CFTypeID v6 = (const void *)(*(void *)(a1 + 32) - 16);
  CFAllocatorRef v7 = CFGetAllocator(v6);
  CFStringRef v8 = CFStringCreateWithCString(v7, a2, 0x8000100u);
  uint64_t valuePtr = xpc_uint64_get_value(a3);
  CFAllocatorRef v9 = CFGetAllocator(v6);
  CFNumberRef v10 = CFNumberCreate(v9, kCFNumberCFIndexType, &valuePtr);
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 40), v8, v10);
  if (v8) {
    CFRelease(v8);
  }
  if (v10) {
    CFRelease(v10);
  }
  return 1;
}

uint64_t ___ZN12SocketStream26updateTCPAdaptiveParamtersEPK10__CFNumberS2__block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 5943;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream26updateTCPAdaptiveParamtersEPK10__CFNumberS2__block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 5929;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void SocketStream::_SecurityALPNFunc(SocketStream *this, CFMutableDictionaryRef *a2, const UInt8 *a3, const void *a4)
{
  CFTypeID v6 = a2 - 2;
  CFRetain(a2 - 2);
  if (a3)
  {
    CFStringRef v7 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a3 + 1, *(char *)a3, 0x600u, 0);
    CFDictionarySetValue(a2[42], &unk_1EC09F910, v7);
    CFRelease(v7);
  }
  else
  {
    CFDictionarySetValue(a2[42], &unk_1EC09F910, &stru_1ECFAD558);
  }

  CFRelease(v6);
}

void SocketStream::_SecurityNPNFunc(SocketStream *this, SSLContext *a2, const UInt8 *a3, unint64_t a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  CFStringRef v7 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  CFDictionaryRef v8 = (const __CFDictionary *)*((void *)a2 + 42);
  v28[0] = MEMORY[0x1E4F143A8];
  v28[1] = 3221225472;
  CFDataRef v29 = ___ZN12SocketStream16_SecurityNPNFuncEP10SSLContextPvPKvm_block_invoke;
  int v30 = &__block_descriptor_40_e12_B24__0r_8Q16l;
  uint64_t v31 = this;
  uint64_t v32 = 0x2E312F7074746808;
  char v33 = 49;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v8, &unk_1EC09F8D8);
  if (Value)
  {
    CFArrayRef v10 = Value;
    uint64_t v25 = v7;
    theDict = v8;
    CFIndex Count = CFArrayGetCount(Value);
    CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (a4)
    {
      uint64_t v12 = Count;
      unint64_t v13 = 0;
      do
      {
        CFIndex v14 = a3[v13];
        CFStringRef v15 = CFStringCreateWithBytes(alloc, &a3[v13 + 1], v14, 0x8000100u, 0);
        if (v12 < 1)
        {
LABEL_9:
          CFRelease(v15);
        }
        else
        {
          CFIndex v16 = 0;
          while (1)
          {
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v16);
            CFIndex Length = CFStringGetLength(v15);
            if (Length == CFStringGetLength(ValueAtIndex)
              && CFStringCompare(v15, ValueAtIndex, 1uLL) == kCFCompareEqualTo)
            {
              break;
            }
            if (v12 == ++v16) {
              goto LABEL_9;
            }
          }
          char v19 = ((uint64_t (*)(void *, const UInt8 *, CFIndex))v29)(v28, &a3[v13 + 1], v14);
          CFRelease(v15);
          if (v19)
          {
            uint64_t v23 = theDict;
            uint64_t v22 = (__CFString *)ValueAtIndex;
LABEL_17:
            CFDictionarySetValue(v23, &unk_1EC09F910, v22);
            goto LABEL_18;
          }
        }
        v13 += v14 + 1;
      }
      while (v13 < a4);
    }
    ((void (*)(void *, uint64_t *, uint64_t))v29)(v28, &v32, 9);
    CFStringRef v20 = CFStringCreateWithBytes(alloc, (const UInt8 *)&v32 + 1, 8, 0x8000100u, 0);
    if (!v20)
    {
      uint64_t v22 = &stru_1ECFAD558;
      uint64_t v23 = theDict;
      goto LABEL_17;
    }
    CFStringRef v21 = v20;
    CFDictionarySetValue(theDict, &unk_1EC09F910, v20);
    CFRelease(v21);
LABEL_18:
    CFStringRef v7 = v25;
  }
  else
  {
    ((void (*)(void *, uint64_t *, uint64_t))v29)(v28, &v32, 9);
  }
  CFRelease(v7);
}

BOOL ___ZN12SocketStream16_SecurityNPNFuncEP10SSLContextPvPKvm_block_invoke()
{
  return SSLSetNPNData() == 0;
}

uint64_t SocketStream::_SecurityWriteFunc_NoLock(CFAllocatorRef **this, unsigned __int8 *a2, size_t *a3, unint64_t *a4)
{
  CFStringRef v7 = this - 2;
  CFRetain(this - 2);
  unsigned long long v16 = 0uLL;
  size_t v8 = *a3;
  uint64_t v9 = SocketStream::sendToSocket((SocketStream *)this, a2, *a3, (CFStreamError *)&v16);
  *a3 = v9;
  SInt32 v10 = DWORD2(v16);
  if (DWORD2(v16))
  {
    *a3 = 0;
    if (v10 == 35 && (void)v16 == 1)
    {
      uint64_t v12 = 4294957493;
    }
    else
    {
      *((_OWORD *)this + CFRetain((char *)this - 16) = v16;
      uint64_t v12 = 4294957486;
    }
  }
  else
  {
    size_t v13 = v9;
    CFIndex v14 = this[75];
    if (v14)
    {
      SSLDecoder::processBytes(v14, v14 + 2, a2, v13, "SENT");
      size_t v13 = *a3;
    }
    if (v8 == v13) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = 4294957493;
    }
  }
  CFRelease(v7);
  return v12;
}

uint64_t SocketStream::_SecurityReadFunc_NoLock(SocketStream *this, void *a2, size_t *a3, unint64_t *a4)
{
  CFStringRef v7 = (char *)this - 16;
  CFRetain((char *)this - 16);
  size_t v8 = *a3;
  unsigned long long v28 = 0uLL;
  uint64_t v9 = (void *)*((void *)this + 65);
  if (v9)
  {
    uint64_t v11 = v9[2];
    size_t v10 = v9[3];
    size_t v12 = v8;
  }
  else
  {
    CFAllocatorRef v13 = CFGetAllocator(v7);
    uint64_t v9 = CFAllocatorAllocate(v13, 32824, 0);
    bzero(v9, 0x8038uLL);
    CFAllocatorRef v14 = CFGetAllocator(v7);
    size_t v10 = 0;
    v9[4] = ((unint64_t)(v9 + 5) & 0xFFFFFFFFFFFFFFF0) + 16;
    *((_OWORD *)v9 + 1) = xmmword_1843D17D0;
    *uint64_t v9 = &unk_1ECFA0F60;
    v9[1] = v14;
    *((void *)this + 65) = v9;
    size_t v12 = *a3;
    uint64_t v11 = 0x8000;
  }
  if (v10 >= v12)
  {
    *((_DWORD *)this + 62) |= 0x2000000u;
  }
  else
  {
    uint64_t v15 = SocketStream::recvBytes(this, (unsigned __int8 *)(v9[4] + v10), v11 - v10, (CFStreamError *)&v28);
    unint64_t v16 = *((_DWORD *)this + 62) & 0xFDFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) &= ~0x2000000u;
    *((_WORD *)this + 126) = WORD2(v16);
    SInt32 v17 = DWORD2(v28);
    if (DWORD2(v28))
    {
      *a3 = 0;
      if (v17 == 35 && (void)v28 == 1)
      {
        BOOL v18 = (__CFSocket *)*((void *)this + 36);
        if (v18 && CFSocketIsValid(v18)) {
          CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
        }
        uint64_t v19 = 4294957493;
      }
      else
      {
        *((_OWORD *)this + CFRetain((char *)this - 16) = v28;
        uint64_t v19 = 4294957486;
      }
      goto LABEL_29;
    }
    size_t v20 = v15;
    CFStringRef v21 = (CFAllocatorRef *)*((void *)this + 75);
    if (v21) {
      SSLDecoder::processBytes(v21, v21 + 3, (UInt8 *)(*(void *)(*((void *)this + 65) + 32) + v10), v20, "READ");
    }
    v10 += v20;
  }
  uint64_t v22 = *(char **)(*((void *)this + 65) + 32);
  if (*a3 >= v10) {
    size_t v23 = v10;
  }
  else {
    size_t v23 = *a3;
  }
  *a3 = v23;
  size_t v24 = v10 - v23;
  memmove(a2, v22, v23);
  memmove(v22, &v22[*a3], v24);
  bzero(&v22[v24], v11 - v24);
  *(void *)(*((void *)this + 65) + 24) = v24;
  if (*a3)
  {
    uint64_t v25 = (__CFSocket *)*((void *)this + 36);
    if (v25)
    {
      if (CFSocketIsValid(v25)) {
        CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
      }
    }
  }
  if (v8 == *a3) {
    unsigned int v26 = 0;
  }
  else {
    unsigned int v26 = -9803;
  }
  if (*a3) {
    uint64_t v19 = v26;
  }
  else {
    uint64_t v19 = 4294957490;
  }
LABEL_29:
  CFRelease(v7);
  return v19;
}

void CFBufferConstantSize<32768l>::~CFBufferConstantSize(CFAllocatorRef *ptr)
{
}

uint64_t setTLSMaxVersion_ifNeeded(CFStringRef theString2, SSLContext *a2, const __CFNumber *a3, SSLProtocol a4)
{
  if (a3 || CFStringCompare((CFStringRef)*MEMORY[0x1E4F3B528], theString2, 0)) {
    return 0;
  }

  return SSLSetProtocolVersionMax(a2, a4);
}

CFDictionaryRef virtual thunk to'SocketStream::copyProperty(SocketStream *this, const void *a2, const __CFString *a3)
{
  return SocketStream::copyProperty((SocketStream *)((char *)this + *(void *)(*(void *)this - 72)), a2, a3);
}

CFDictionaryRef SocketStream::copyProperty(SocketStream *this, const void *a2, const __CFString *a3)
{
  CFNumberRef v5 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  CFDictionaryRef v7 = SocketStream::copyProperty_NoLock(this, a3, v6);
  pthread_mutex_unlock(v5);
  return v7;
}

void sub_184214450(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void virtual thunk to'SocketStream::close(SocketStream *this, const void *a2)
{
}

void SocketStream::close(SocketStream *this, const void *a2)
{
  CFArrayRef v4 = (char *)this - 16;
  CFRetain((char *)this - 16);
  CFNumberRef v5 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  CFDictionaryRef v7 = (__CFRunLoop *)*((void *)this + 30);
  if (v7) {
    SocketStream::unschedule_NoLock(this, a2, v7, @"_kCFStreamSocketBogusPrivateMode");
  }
  if (*((const void **)this + 34) == a2)
  {
    size_t v8 = (void **)((char *)this + 304);
    uint64_t v9 = (__CFArray **)((char *)this + 312);
    uint64_t v10 = 0x1000000000;
  }
  else
  {
    if (*((const void **)this + 35) != a2) {
      goto LABEL_12;
    }
    size_t v8 = (void **)((char *)this + 312);
    uint64_t v9 = (__CFArray **)((char *)this + 304);
    uint64_t v10 = 0x2000000000;
  }
  uint64_t v11 = *v8;
  size_t v12 = *v9;
  unint64_t v13 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | v10;
  *((_DWORD *)this + 62) = v13;
  *((_WORD *)this + 126) = WORD2(v13);
  if (v11 && v12)
  {
    uint64_t v14 = *((void *)this + 41);
    v22.CFStringRef length = *(void *)(v14 + 24);
    v22.CFIndex location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v14 + 16), v22, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction, v11);
    CFArrayRemoveAllValues((CFMutableArrayRef)v11);
    CFIndex Count = CFArrayGetCount(*((CFArrayRef *)this + 40));
    if (Count)
    {
      v23.CFStringRef length = Count;
      v23.CFIndex location = 0;
      CFArrayAppendArray(v12, *((CFArrayRef *)this + 40), v23);
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)this + 40));
    }
    *((_DWORD *)this + 103) = 0;
  }
LABEL_12:
  uint64_t v16 = *((unsigned int *)this + 62);
  if ((v16 & 0x80) == 0
    || ((v16 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x3000000000) == 0x3000000000)
  {
    if (*((void *)this + 70) && *((void *)this + 71))
    {
      SocketStream::cleanupConnection_NoLock(this);
      CFRetain(v4);
      SInt32 v17 = *((void *)this + 71);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZN12SocketStream5closeEPKv_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = this;
      dispatch_async(v17, block);
    }
    BOOL v18 = *((void *)this + 71);
    if (v18)
    {
      dispatch_release(v18);
      *((void *)this + 71) = 0;
    }
    if (*((void *)this + 36))
    {
      SocketStream::checkOutVoIPSocket(this, v6);
      int v20 = *((_DWORD *)this + 62);
      uint64_t v19 = (CFSocketRef *)((char *)this + 248);
      *(_DWORD *)uint64_t v19 = v20 | 0x800;
      CFSocketInvalidate(v19[5]);
    }
  }
  pthread_mutex_unlock(v5);
  CFRelease(v4);
}

void ___ZN12SocketStream5closeEPKv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  if (*(unsigned char *)(v1 + 544))
  {
    *(unsigned char *)(v1 + 544) = 0;
    CFRelease((CFTypeRef)(v1 - 16));
  }
  if (*(unsigned char *)(v1 + 644))
  {
    *(unsigned char *)(v1 + 644) = 0;
    entr_act_end_delayInitStub(v2);
  }
  SSLProtocol v3 = *(NSObject **)(v1 + 384);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(v1 + 384));
    *(void *)(v1 + 384) = 0;
  }
  CFArrayRef v4 = *(NSObject **)(v1 + 392);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(v1 + 392));
    *(void *)(v1 + 392) = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));

  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t virtual thunk to'SocketStream::openCompleted(SocketStream *this, const void *a2, CFStreamError *a3)
{
  return SocketStream::streamCan((uint64_t)this + *(void *)(*(void *)this - 56), a2, 0, @"_kCFStreamSocketOpenCompletedPrivateMode", a3);
}

uint64_t virtual thunk to'SocketStream::open(SocketStream *this, const void *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  return SocketStream::open((SocketStream *)((char *)this + *(void *)(*(void *)this - 48)), a2, a3, a4);
}

uint64_t SocketStream::open(SocketStream *this, const void *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  a3->CFIndex domain = 0;
  *(void *)&a3->SInt32 error = 0;
  *a4 = 0;
  size_t v8 = (pthread_mutex_t *)((char *)this + 40);
  uint64_t delayInitStub = pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  if (*((_DWORD *)this + 102) == 1 && (*((_DWORD *)this + 62) & 0x80000000) == 0)
  {
    block[0].version = 0;
    block[0].info = (char *)this - 16;
    block[0].retain = (CFAllocatorRetainCallBack)MEMORY[0x1E4F1C280];
    block[0].release = (CFAllocatorReleaseCallBack)MEMORY[0x1E4F1C278];
    block[0].copyDescription = (CFAllocatorCopyDescriptionCallBack)MEMORY[0x1E4F1C220];
    gotLoadHelper_x8___CTServerConnectionCreate(v10);
    if (*(void *)(v11 + 2712))
    {
      CFGetAllocator((CFTypeRef)delayInitStub);
      uint64_t delayInitStub = _CTServerConnectionCreate_delayInitStub(v12);
      uint64_t v14 = (const void *)delayInitStub;
      if (delayInitStub)
      {
        BOOLean[0] = 0;
        _CTServerConnectionCarrierSettingsCopyValue_delayInitStub(v13);
        CFRelease(v14);
      }
    }
  }
  uint64_t v15 = 1024;
  if (*((const void **)this + 34) == a2) {
    uint64_t v15 = 512;
  }
  unint64_t v16 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | v15;
  *((_DWORD *)this + 62) |= v15;
  if (*((void *)this + 30))
  {
    if ((v16 & 2) == 0) {
      goto LABEL_10;
    }
LABEL_14:
    *a3 = *((CFStreamError *)this + 16);
    *a4 = 1;
    goto LABEL_60;
  }
  uint64_t v17 = CoreSchedulingSet::copyRunloopEmulationSet((CoreSchedulingSet *)delayInitStub);
  v66[0] = MEMORY[0x1E4F143A8];
  v66[1] = 3221225472;
  v66[2] = ___ZN12SocketStream4openEPKvP13CFStreamErrorPh_block_invoke;
  v66[3] = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v66[4] = this;
  CoreSchedulingSet::applyBlockWithPossibleEmulation(v17, v66);
  (*(void (**)(uint64_t))(*(void *)v17 + 48))(v17);
  uint64_t v18 = *((unsigned int *)this + 62);
  unint64_t v16 = v18 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v18 & 2) != 0) {
    goto LABEL_14;
  }
LABEL_10:
  if (v16) {
    goto LABEL_60;
  }
  *((_WORD *)this + 126) = WORD2(v16);
  *((_DWORD *)this + 62) = v16 | 1;
  if (!*((_DWORD *)this + 66))
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F9F0);
    if (!Value) {
      goto LABEL_43;
    }
    LODWORD(valuePtr) = 0;
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    int v20 = valuePtr;
    CFStringRef v21 = (CFStringRef (__cdecl *)(const void *))dispatch_queue_attr_make_with_qos_class(0, (dispatch_qos_class_t)valuePtr, 0);
    if (v20 > 20)
    {
      switch(v20)
      {
        case 21:
          block[0].version = MEMORY[0x1E4F143A8];
          block[0].info = (void *)3221225472;
          block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_3;
          block[0].release = (CFAllocatorReleaseCallBack)&unk_1E5258228;
          block[0].copyDescription = v21;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1) {
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
          }
          CFRange v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sDefaultTCPConnWorkQueue;
          break;
        case 25:
          block[0].version = MEMORY[0x1E4F143A8];
          block[0].info = (void *)3221225472;
          block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_2;
          block[0].release = (CFAllocatorReleaseCallBack)&unk_1E5258228;
          block[0].copyDescription = v21;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1) {
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
          }
          CFRange v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInitiatedTCPConnWorkQueue;
          break;
        case 33:
          block[0].version = MEMORY[0x1E4F143A8];
          block[0].info = (void *)3221225472;
          block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke;
          block[0].release = (CFAllocatorReleaseCallBack)&unk_1E5258228;
          block[0].copyDescription = v21;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1) {
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
          }
          CFRange v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInteractiveTCPConnWorkQueue;
          break;
        default:
          goto LABEL_49;
      }
    }
    else if (v20)
    {
      if (v20 != 9)
      {
        if (v20 == 17)
        {
          block[0].version = MEMORY[0x1E4F143A8];
          block[0].info = (void *)3221225472;
          block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_4;
          block[0].release = (CFAllocatorReleaseCallBack)&unk_1E5258228;
          block[0].copyDescription = v21;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1) {
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
          }
          CFRange v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUtilityTCPConnWorkQueue;
          goto LABEL_41;
        }
LABEL_49:
        dispatch_object_t v23 = (dispatch_object_t)copyGlobalTCPConnWorkQueue();
        if (!v23)
        {
LABEL_43:
          if (*((void *)this + 36)) {
            goto LABEL_54;
          }
          if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0F98))
          {
            LODWORD(valuePtr) = -1;
            CFDataRef v25 = (const __CFData *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0F98);
            if (v25)
            {
              v76.CFIndex location = 0;
              v76.CFStringRef length = 4;
              CFDataGetBytes(v25, v76, (UInt8 *)&valuePtr);
              int v26 = valuePtr;
            }
            else
            {
              int v26 = -1;
            }
            socklen_t v70 = 128;
            if (!getsockname(v26, (sockaddr *)block, &v70)
              && (BYTE1(block[0].version) == 30 || BYTE1(block[0].version) == 2))
            {
              socklen_t v68 = 4;
              int v69 = 0;
              if (!getsockopt(valuePtr, 0xFFFF, 4104, &v69, &v68) && v69 == 1)
              {
                if (dup(valuePtr) != -1)
                {
                  uint64_t v36 = tcp_connection_create_with_connected_fd();
                  *((void *)this + 70) = v36;
                  if (v36)
                  {
                    SocketStream::startTCPConnection(this);
                    CFRetain((char *)this - 16);
                    BOOL v37 = *((void *)this + 71);
                    BOOLean[0] = (CFBooleanRef)MEMORY[0x1E4F143A8];
                    BOOLean[1] = (CFBooleanRef)3221225472;
                    BOOLean[2] = (CFBooleanRef)___ZN12SocketStream25startLookupForOpen_NoLockEv_block_invoke;
                    BOOLean[3] = (CFBooleanRef)&__block_descriptor_40_e5_v8__0l;
                    BOOLean[4] = this;
                    dispatch_async(v37, BOOLean);
                    goto LABEL_56;
                  }
                }
                *((void *)this + 32) = 1;
                int v52 = 9;
LABEL_87:
                *((_DWORD *)this + 66) = v52;
                goto LABEL_56;
              }
            }
            *((unsigned char *)this + 407) = 1;
LABEL_54:
            if (!*((_DWORD *)this + 66)) {
              SocketStream::attemptNextConnection_NoLock(this);
            }
            goto LABEL_56;
          }
          uint64_t v27 = *((void *)this + 74);
          if (v27)
          {
            *((void *)this + 70) = v27;
            *((void *)this + 74) = 0;
            tcp_connection_accept();
            SocketStream::startTCPConnection(this);
            goto LABEL_56;
          }
          CFDictionaryRef v38 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A1120);
          CFDictionaryRef v39 = v38;
          if (!v38)
          {
            CFDictionaryRef v53 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A5678);
            if (v53)
            {
              SocketStream::startTCPConnection_Proxy_Connect(this, v53);
              goto LABEL_56;
            }
            CFDataRef v54 = (__CFHost *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0FD0);
            CFDictionaryRef v55 = (const __CFDictionary *)*((void *)this + 42);
            if (v54)
            {
              CFNumberRef v56 = (const __CFNumber *)CFDictionaryGetValue(v55, &unk_1EC0A1078);
              SocketStream::startTCPConnection_Host(this, v54, v56);
              goto LABEL_56;
            }
            unint64_t v57 = (__CFNetService *)CFDictionaryGetValue(v55, &unk_1EC0A1040);
            if (v57)
            {
              SocketStream::startTCPConnection_NetService(this, v57);
              goto LABEL_56;
            }
            if (*__error())
            {
              int v52 = *__error();
              *((void *)this + 32) = 1;
            }
            else
            {
              *((void *)this + 32) = 1;
              int v52 = 12;
            }
            goto LABEL_87;
          }
          CFStringRef v40 = (const __CFString *)CFDictionaryGetValue(v38, (const void *)*MEMORY[0x1E4F1D460]);
          CFNumberRef v41 = (const __CFNumber *)CFDictionaryGetValue(v39, (const void *)*MEMORY[0x1E4F1D468]);
          if (!v40
            || (CFNumberRef v42 = v41, v43 = CFGetAllocator((char *)this - 16), (v44 = CFHostCreateWithName(v43, v40)) == 0))
          {
            *((void *)this + 32) = 1;
            int v52 = 22;
            goto LABEL_87;
          }
          SocketStream::startTCPConnection_Host(this, v44, v42);
          int v45 = CFDictionaryGetValue(v39, (const void *)*MEMORY[0x1E4F1D478]);
          if (!v45) {
            int v45 = (const void *)*MEMORY[0x1E4F1D4B0];
          }
          if (CFEqual(v45, (CFTypeRef)*MEMORY[0x1E4F1D4A8]))
          {
            uint64_t v46 = (__CFHost *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0FD0);
            unint64_t v47 = v46;
            if (v46)
            {
              long long v65 = *((_OWORD *)this + 19);
              long long valuePtr = v65;
              uint64_t v73 = *((void *)this + 40);
              uint64_t v74 = 0;
              CFArrayRef Info = (const __CFArray *)CFHostGetInfo((uint64_t)v46, 0, 0);
              CFArrayRef v49 = Info;
              if (Info)
              {
                if (CFArrayGetCount(Info)) {
                  goto LABEL_105;
                }
                CFAllocatorRef v50 = CFGetAllocator(v49);
                *(_OWORD *)&block[0].version = xmmword_1843D17E0;
                CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v50, (int *)block);
              }
              else
              {
                block[0].version = 0;
                block[0].info = (char *)this - 16;
                block[0].retain = (CFAllocatorRetainCallBack)MEMORY[0x1E4F1C280];
                block[0].release = (CFAllocatorReleaseCallBack)MEMORY[0x1E4F1C278];
                block[0].copyDescription = (CFAllocatorCopyDescriptionCallBack)MEMORY[0x1E4F1C220];
                _CFHostSetClientInfoCallback(v47, (unint64_t)SocketStream::_SocksHostCallBack, block);
                CFArrayRef v58 = (const __CFArray *)v65;
                if ((void)v65)
                {
                  CFTypeID v59 = (const __CFArray **)&valuePtr + 1;
                  CFArrayRef v60 = (const __CFArray *)v65;
                  do
                  {
                    _CFTypeScheduleOnMultipleRunLoops(v47, v60);
                    CFArrayRef v61 = *v59++;
                    CFArrayRef v60 = v61;
                  }
                  while (v61);
                }
                if (HostBase::Class(void)::sOnce_HostBase != -1) {
                  dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
                }
                CFErrorWithStreamCFStreamError Error = (__CFError *)(*(uint64_t (**)(void *, uint64_t, void, void))(*((void *)v47 + 2) + 56))((void *)v47 + 2, 0x1EC0A4920, 0, 0);
                if (CFErrorWithStreamError)
                {
                  if ((void)v65)
                  {
                    CFBooleanRef v62 = (const __CFArray **)&valuePtr + 1;
                    do
                    {
                      _CFTypeUnscheduleFromMultipleRunLoops(v47, v58);
                      CFArrayRef v63 = *v62++;
                      CFArrayRef v58 = v63;
                    }
                    while (v63);
                  }
                  _CFTypeInvalidate((char *)v47);
                }
              }
              if (CFErrorWithStreamError)
              {
                *((void *)this + 32) = _CFStreamErrorFromCFError(CFErrorWithStreamError);
                *((void *)this + 33) = v64;
                CFRelease(CFErrorWithStreamError);
                goto LABEL_106;
              }
LABEL_105:
              Schedulables::_add(*((Schedulables **)this + 41), v47);
              goto LABEL_106;
            }
            *((void *)this + 32) = 1;
            *((_DWORD *)this + 66) = 22;
          }
LABEL_106:
          CFRelease(v44);
          goto LABEL_56;
        }
LABEL_42:
        size_t v24 = *((void *)this + 71);
        *((void *)this + 71) = v23;
        dispatch_release(v24);
        goto LABEL_43;
      }
      block[0].version = MEMORY[0x1E4F143A8];
      block[0].info = (void *)3221225472;
      block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_5;
      block[0].release = (CFAllocatorReleaseCallBack)&unk_1E5258228;
      block[0].copyDescription = v21;
      if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1) {
        dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
      }
      CFRange v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sBackgroundTCPConnWorkQueue;
    }
    else
    {
      block[0].version = MEMORY[0x1E4F143A8];
      block[0].info = (void *)3221225472;
      block[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_6;
      block[0].release = (CFAllocatorReleaseCallBack)&unk_1E5258228;
      block[0].copyDescription = v21;
      if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1) {
        dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, block);
      }
      CFRange v22 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUnspecifiedTCPConnWorkQueue;
    }
LABEL_41:
    dispatch_object_t v23 = (dispatch_object_t)*v22;
    dispatch_retain((dispatch_object_t)*v22);
    if (!v23) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  *((_WORD *)this + 126) = WORD2(v16);
  *((_DWORD *)this + 62) = v16 & 0xFFFFFFEC | 3;
LABEL_56:
  uint64_t v28 = *((unsigned int *)this + 62);
  unint64_t v29 = v28 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v28 & 2) != 0)
  {
    *((_WORD *)this + 126) = WORD2(v29);
    *((_DWORD *)this + 62) = v29 & 0xFFFFFFFE;
    *a4 = 1;
  }
  if (*((_DWORD *)this + 66)) {
    *a3 = *((CFStreamError *)this + 16);
  }
LABEL_60:
  if (a3->error)
  {
    uint64_t v30 = 0;
    int v32 = *((_DWORD *)this + 62);
    uint64_t v31 = (char *)this + 248;
    unint64_t v33 = v32 & 0xFFFFFFEF | ((unint64_t)*((unsigned __int16 *)v31 + 2) << 32);
    *(_DWORD *)uint64_t v31 = v32 & 0xFFFFFFED | 2;
    *((_WORD *)v31 + 2) = WORD2(v33);
    *a4 = 1;
  }
  else
  {
    uint64_t v34 = (__CFRunLoop *)*((void *)this + 30);
    if (v34) {
      SocketStream::schedule_NoLock(this, a2, v34, @"_kCFStreamSocketBogusPrivateMode");
    }
    uint64_t v30 = 1;
  }
  pthread_mutex_unlock(v8);
  return v30;
}

CFTypeRef ___ZN12SocketStream4openEPKvP13CFStreamErrorPh_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (cf) {
    CFTypeRef result = CFRetain(cf);
  }
  else {
    CFTypeRef result = 0;
  }
  *(void *)(v2 + 240) = result;
  return result;
}

uint64_t SocketStream::attemptNextConnection_NoLock(SocketStream *this)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  long long v32 = *((_OWORD *)this + 19);
  uint64_t v33 = *((void *)this + 40);
  if (*((void *)this + 36)) {
    goto LABEL_2;
  }
  uint64_t result = (uint64_t)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0F98);
  if (!result)
  {
    *((void *)this + 32) = 1;
    int v29 = 22;
LABEL_37:
    *((_DWORD *)this + 66) = v29;
    return result;
  }
  CFDataRef v3 = (const __CFData *)result;
  context.version = 0;
  context.info = (char *)this - 16;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
  context.copyDescription = (CFStringRef (__cdecl *)(const void *))MEMORY[0x1E4F1C220];
  CFAllocatorRef v4 = CFGetAllocator((char *)this - 16);
  BytePtr = (CFSocketNativeHandle *)CFDataGetBytePtr(v3);
  CFSocketRef v6 = CFSocketCreateWithNative(v4, *BytePtr, 0xDuLL, (CFSocketCallBack)SocketStream::_SocketCallBack_stream, &context);
  *((void *)this + 36) = v6;
  if (!v6)
  {
    uint64_t v30 = __error();
    uint64_t result = 0;
    int v29 = *v30;
    *((void *)this + 32) = 1;
    if (!v29) {
      int v29 = 12;
    }
    goto LABEL_37;
  }
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), &unk_1EC0A0F98);
LABEL_2:
  if (*((void *)this + 70)) {
    tcp_connection_set_traffic_class();
  }
  SocketStream::checkInVoIPSocket(this);
  *((_DWORD *)this + 62) = *((_DWORD *)this + 62) & 0xFFFFF7ED | 2;
  CFDictionaryRef v7 = (__CFSocket *)*((void *)this + 36);
  LODWORD(context.version) = 1;
  CFSocketNativeHandle Native = CFSocketGetNative(v7);
  setsockopt(Native, 0xFFFF, 4130, &context, 4u);
  uint64_t v9 = (__CFSocket *)*((void *)this + 36);
  LODWORD(context.version) = 1;
  CFSocketNativeHandle v10 = CFSocketGetNative(v9);
  ioctl(v10, 0x8004667EuLL, &context);
  if (*((_DWORD *)this + 100) == 1)
  {
    uint64_t v11 = (__CFSocket *)*((void *)this + 36);
    LODWORD(context.version) = 1;
    CFSocketNativeHandle v12 = CFSocketGetNative(v11);
    setsockopt(v12, 0xFFFF, 4357, &context, 4u);
  }
  if (*((_DWORD *)this + 86) && *((double *)this + 44) != 0.0) {
    __CFSocketSetSocketReadBufferAttrs();
  }
  CFOptionFlags v13 = CFSocketGetSocketFlags(*((CFSocketRef *)this + 36)) & 0xFFFFFFFFFFFFFF76;
  CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0F28);
  if (Value != (const void *)*MEMORY[0x1E4F1CFC8] || Value == 0) {
    CFOptionFlags v16 = v13 | 0x80;
  }
  else {
    CFOptionFlags v16 = v13;
  }
  CFSocketSetSocketFlags(*((CFSocketRef *)this + 36), v16);
  CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 0xDuLL);
  for (uint64_t i = 0; i != 24; i += 8)
    _CFTypeScheduleOnMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)((char *)&v32 + i));
  Schedulables::_add(*((Schedulables **)this + 41), *((const void **)this + 36));
  CFAllocatorRef v18 = CFGetAllocator(*((CFTypeRef *)this + 36));
  CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v18, *((CFSocketRef *)this + 36), 0);
  if (RunLoopSource)
  {
    int v20 = RunLoopSource;
    for (uint64_t j = 0; j != 3; ++j)
    {
      CFArrayRef v22 = (const __CFArray *)*((void *)&v32 + j);
      if (v22)
      {
        CFIndex Count = CFArrayGetCount(*((CFArrayRef *)&v32 + j));
        if (Count >= 1)
        {
          CFIndex v24 = Count;
          for (CFIndex k = 0; k < v24; k += 2)
          {
            CFStringRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v22, k);
            if (CFRunLoopIsWaiting(ValueAtIndex))
            {
              CFStringRef v27 = CFRunLoopCopyCurrentMode(ValueAtIndex);
              if (v27)
              {
                CFStringRef v28 = v27;
                if (CFRunLoopContainsSource(ValueAtIndex, v20, v27)) {
                  CFRunLoopWakeUp(ValueAtIndex);
                }
                CFRelease(v28);
              }
            }
          }
        }
      }
    }
    CFRelease(v20);
  }
  SocketStream::touchWatchdogTimer_Locked(this, 0);
  return 1;
}

void SocketStream::_SocketCallBack_stream(SocketStream *this, __CFSocket *a2, unint64_t a3, const __CFData *a4, char *cf, void *a6)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    return;
  }
  if (TCFObject<SocketStream>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_406);
  }
  CFRetain(cf);
  pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
  if ((*((_DWORD *)cf + 66) & 0x800) != 0)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
    goto LABEL_12;
  }
  if (*((SocketStream **)cf + 38) != this && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v41[0]) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "What socket signalled us?", (uint8_t *)v41, 2u);
  }
  uint64_t v45 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  *(_OWORD *)CFNumberRef v41 = 0u;
  *(_OWORD *)cfa = 0u;
  if (!*((_DWORD *)cf + 70))
  {
    CFSocketNativeHandle v12 = (unsigned int *)(cf + 264);
    if (a2 == (__CFSocket *)1)
    {
      SocketStream::socketCallbackReadLocked((SocketStream *)(cf + 16), (SocketStreamSignalHolder *)v41, v10);
      if ((*v12 & 0x28000) != 0x8000) {
        goto LABEL_9;
      }
    }
    else if (a2 != (__CFSocket *)8)
    {
      if (a2 == (__CFSocket *)4)
      {
        uint64_t v13 = *v12;
        unint64_t v14 = v13 & 0xFFFFFFFFEFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
        unsigned int *v12 = v13 & 0xEFFFFFFF;
        *((_WORD *)cf + 134) = WORD2(v14);
        if (a4 && (int v15 = *(_DWORD *)a4) != 0)
        {
          *(_OWORD *)size_t processed = *((_OWORD *)cf + 20);
          CFOptionFlags v16 = (Schedulables *)*((void *)cf + 43);
          uint64_t v47 = *((void *)cf + 42);
          *((_DWORD *)cf + 70) = v15;
          *((void *)cf + 34) = 1;
          Schedulables::_remove(v16, *((const void **)cf + 38));
          for (uint64_t i = 0; i != 3; ++i)
            _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 38), (const __CFArray *)processed[i]);
          _CFTypeInvalidate(*((char **)cf + 38));
          CFAllocatorRef v18 = (const void *)*((void *)cf + 38);
          *((void *)cf + 38) = 0;
          if (v18) {
            CFRelease(v18);
          }
          if (SocketStream::attemptNextConnection_NoLock((SocketStream *)(cf + 16)))
          {
            *((void *)cf + 34) = 0;
            *((void *)cf + 35) = 0;
          }
        }
        else
        {
          if (*((void *)cf + 72)) {
            tcp_connection_set_traffic_class();
          }
          SocketStream::checkInVoIPSocket((SocketStream *)(cf + 16));
          unsigned int *v12 = *v12 & 0xFFFFFFEC | 2;
          v41[0] = (CFTypeRef)1;
          id WeakRetained = objc_loadWeakRetained((id *)cf + 36);
          if (v41[1]) {
            CFRelease(v41[1]);
          }
          v41[1] = WeakRetained;
          id v35 = objc_loadWeakRetained((id *)cf + 37);
          if (cfa[0]) {
            CFRelease(cfa[0]);
          }
          cfa[0] = v35;
          if ((*v12 & 0x8000000) == 0 && *((void *)cf + 72) && tcp_connection_is_cellular())
          {
            *v12 |= 0x8000000u;
            CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 44), @"_kCFStreamPropertyForcedConnection", (const void *)*MEMORY[0x1E4F1CFD0]);
          }
          if (*((void *)cf + 29))
          {
            uint64_t Native = CFSocketGetNative(*((CFSocketRef *)cf + 38));
            SocketStream::setLoggerPrefixWithNativeHandle((SocketStream *)(cf + 16), Native);
          }
        }
      }
      goto LABEL_9;
    }
    unsigned int v19 = *((_DWORD *)cf + 107);
    if (v19)
    {
      uint64_t v20 = 0;
      while (((v19 >> v20) & 1) == 0)
      {
        if (++v20 == 8)
        {
          uint64_t v20 = 0;
          break;
        }
      }
      SocketStream::performHandshake((uint64_t)(cf + 16), v20, v10);
      goto LABEL_9;
    }
    uint64_t v21 = *v12;
    unint64_t v22 = v21 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
    if ((v21 & 0x4000) == 0)
    {
      uint64_t v23 = *((void *)cf + 68);
      if (v23 && (uint64_t v24 = *(void *)(v23 + 24), v24 >= 1) && ((v22 & 0x800000) == 0 || *(void *)(v23 + 16) == v24))
      {
        SocketStream::flushTransmissionBuffer_NoLock((CFStreamError *)cf + 1);
      }
      else
      {
        unint64_t v32 = v22 & 0xFFFFFFFFFFFFFFBFLL;
        *((_WORD *)cf + 134) = WORD2(v32);
        unsigned int *v12 = v32 | 8;
        v41[0] = (CFTypeRef)4;
        id v33 = objc_loadWeakRetained((id *)cf + 37);
        if (cfa[0]) {
          CFRelease(cfa[0]);
        }
        cfa[0] = v33;
      }
      goto LABEL_9;
    }
    int v25 = *((_DWORD *)cf + 70);
    if (!v25 || (uint64_t v26 = *((void *)cf + 34), v25 == 35) && v26 == 1 || v25 == -9803 && v26 == *MEMORY[0x1E4F1D430])
    {
      processed[0] = 0;
      uint64_t v27 = SSLWrite(*((SSLContextRef *)cf + 39), 0, 0, processed);
      int v28 = v27;
      if (v27 != -9803 && v27)
      {
        int v29 = translateSSLContextError(*((SSLContext **)cf + 39), v27);
        *((void *)cf + 34) = (int)*MEMORY[0x1E4F1D430];
        *((_DWORD *)cf + 70) = v29;
      }
      if (v28 == -9803)
      {
        uint64_t v30 = (__CFSocket *)*((void *)cf + 38);
        if (!v30 || !CFSocketIsValid(v30)) {
          goto LABEL_9;
        }
        CFOptionFlags v31 = 8;
        goto LABEL_74;
      }
    }
    uint64_t v37 = *v12;
    unint64_t v38 = v37 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
    if ((v37 & 0x2000) == 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(processed[0]) = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "we're blocked on SSLWrite, so we must be using SSL", (uint8_t *)processed, 2u);
      uint64_t v40 = *v12;
      unint64_t v38 = v40 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
      if ((v40 & 2) == 0)
      {
LABEL_69:
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          LOWORD(processed[0]) = 0;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "we've written bytes, so the socket must have been opened", (uint8_t *)processed, 2u);
          unint64_t v38 = *v12 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
        }
      }
    }
    else if ((v38 & 2) == 0)
    {
      goto LABEL_69;
    }
    unsigned int *v12 = v38 & 0xFFFFBFFF;
    *((_WORD *)cf + 134) = (v38 & 0xFFFFFFFFFFFFBFFFLL) >> 32;
    CFDictionaryRef v39 = (__CFSocket *)*((void *)cf + 38);
    if (!v39 || !CFSocketIsValid(v39)) {
      goto LABEL_9;
    }
    CFOptionFlags v31 = 9;
LABEL_74:
    CFSocketEnableCallBacks(*((CFSocketRef *)cf + 38), v31);
  }
LABEL_9:
  SocketStream::prepareSignalFromSocketCallbackLocked((SocketStream *)(cf + 16), (SocketStreamSignalHolder *)v41);
  pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
  SocketStream::dispatchSignalFromSocketCallbackUnlocked((CFRunLoopSourceRef *)v41, v11);
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)v41);
LABEL_12:

  CFRelease(cf);
}

void sub_184215C5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void SocketStream::setLoggerPrefixWithNativeHandle(SocketStream *this, uint64_t a2)
{
  v13[19] = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = (char *)this - 16;
  CFAllocatorRef v5 = CFGetAllocator((char *)this - 16);
  v13[0] = off_1ECF9A530;
  v13[1] = createStringFromSomeAddr(v5, MEMORY[0x1E4F14888], "local", a2);
  v13[2] = 0;
  v13[3] = 0;
  CFAllocatorRef v6 = CFGetAllocator(v4);
  v12[0] = off_1ECF9A530;
  v12[1] = createStringFromSomeAddr(v6, MEMORY[0x1E4F14878], "peer", a2);
  v12[2] = 0;
  v12[3] = 0;
  if (*((void *)this + 70))
  {
    CFDictionaryRef v7 = &v11;
    tcp_connection_get_hostname();
  }
  else
  {
    CFDictionaryRef v7 = "";
  }
  uint64_t v8 = *((void *)this + 27);
  CString = (const char *)AutoString::getCString((AutoString *)v13);
  uint64_t v10 = (const char *)AutoString::getCString((AutoString *)v12);
  *(_DWORD *)(v8 + 8) = a2;
  snprintf((char *)(v8 + 12), 0x100uLL, "{ fd: %d, local %s => peer %s %s}", a2, CString, v10, v7);
  AutoString::~AutoString((AutoString *)v12);
  AutoString::~AutoString((AutoString *)v13);
}

void sub_184215DE8(_Unwind_Exception *a1)
{
  AutoString::~AutoString((AutoString *)(v1 - 208));
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke_6793()
{
}

void sub_184215E74(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_UserInteractive", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInteractiveTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_2(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_UserInitiated", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInitiatedTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_3(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_Default", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sDefaultTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_4(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_Utility", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUtilityTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_5(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_Background", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sBackgroundTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_6(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_Unspecified", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUnspecifiedTCPConnWorkQueue = (uint64_t)result;
  return result;
}

uint64_t copyGlobalTCPConnWorkQueue(void)
{
  if (copyGlobalTCPConnWorkQueue(void)::onceToken != -1) {
    dispatch_once(&copyGlobalTCPConnWorkQueue(void)::onceToken, &__block_literal_global_338);
  }
  dispatch_retain((dispatch_object_t)copyGlobalTCPConnWorkQueue(void)::sTCPConnWorkQueue);
  return copyGlobalTCPConnWorkQueue(void)::sTCPConnWorkQueue;
}

void SocketStream::startTCPConnection(SocketStream *this)
{
  v82[128] = *MEMORY[0x1E4F143B8];
  tcp_connection_allow_client_socket_access();
  uint64_t v2 = tcp_connection_copy_parameters();
  uint64_t v76 = MEMORY[0x1E4F143A8];
  uint64_t v77 = 3221225472;
  size_t v78 = ___ZN12SocketStream18startTCPConnectionEh_block_invoke;
  CFTypeID v79 = &__block_descriptor_40_e13_v20__0I8r_v12l;
  CFTypeID v80 = this;
  tcp_connection_set_event_handler();
  uint64_t v3 = *((void *)this + 70);
  uint64_t v71 = MEMORY[0x1E4F143A8];
  uint64_t v72 = 3221225472;
  uint64_t v73 = ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2;
  uint64_t v74 = &unk_1E5258228;
  uint64_t v75 = v3;
  tcp_connection_set_cancel_handler();
  if (!*((void *)this + 67))
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0BE0);
    CFStringRef v12 = Value;
    if (Value && CFStringGetLength(Value) >= 1)
    {
      *(void *)CFAllocatorRef allocator = CFGetAllocator((char *)this - 16);
      *(void *)&allocator[8] = 1023;
      *(void *)&allocator[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)allocator, v12, (UInt8 *)v82, (uint64_t *)&allocator[8], 0x8000100u);
      tcp_connection_set_cellular_service();
      if (*(void *)&allocator[16] && v82 != *(void **)&allocator[16]) {
        CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
      }
    }
    else
    {
      CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0C18);
      if (v13)
      {
        *(void *)CFAllocatorRef allocator = 0;
        *(void *)&allocator[8] = (char *)this - 16;
        *(void *)&allocator[16] = MEMORY[0x1E4F1C280];
        v82[0] = MEMORY[0x1E4F1C278];
        v82[1] = MEMORY[0x1E4F1C220];
        gotLoadHelper_x8___CTServerConnectionCreate(v14);
        if (*(void *)(v16 + 2712))
        {
          CFGetAllocator(v15);
          uint64_t delayInitStub = (const void *)_CTServerConnectionCreate_delayInitStub(v17);
          if (delayInitStub)
          {
            CFTypeRef cf = 0;
            uint64_t inited = 0;
            int valuePtr = 0;
            CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr);
            CFTypeRef v20 = cf;
            CFTypeRef cf = 0;
            if (v20) {
              CFRelease(v20);
            }
            uint64_t inited = _CTServerConnectionCopyPacketContextInterfaceName_delayInitStub(v19);
            CFRelease(delayInitStub);
            if (cf)
            {
              CFTypeRef v21 = CFRetain(cf);
              CFTypeRef v22 = cf;
              *((void *)this + 67) = v21;
              if (v22) {
                CFRelease(v22);
              }
            }
            else
            {
              *((void *)this + 67) = 0;
            }
          }
        }
      }
    }
  }
  CFBooleanRef v4 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0978);
  CFBooleanRef v5 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F248);
  if (v4 && !CFBooleanGetValue(v4) || v5 && !CFBooleanGetValue(v5)) {
    tcp_connection_set_no_expensive();
  }
  CFBooleanRef v6 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0940);
  CFBooleanRef v7 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F210);
  if (v2)
  {
    if ((CFBooleanRef v8 = v7, v6) && !CFBooleanGetValue(v6) || v8 && !CFBooleanGetValue(v8)) {
      nw_parameters_set_prohibit_constrained(v2, 1);
    }
  }
  CFBooleanRef v9 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F280);
  if (v2 && v9 && CFBooleanGetValue(v9)) {
    nw_parameters_set_allow_ultra_constrained();
  }
  CFBooleanRef v10 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F2B8);
  if (v2 && v10)
  {
    if (CFBooleanGetValue(v10)) {
      removeProhibitedNetworkType((uint64_t)v2, 0);
    }
    else {
      addProhibitedNetworkType((uint64_t)v2, 0);
    }
  }
  CFBooleanRef v23 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F5C8);
  CFBooleanRef v24 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F590);
  if ((unint64_t)v23 | (unint64_t)v24)
  {
    if (v23) {
      CFBooleanGetValue(v23);
    }
    if (v24) {
      CFBooleanGetValue(v24);
    }
    tcp_connection_override_obscure();
  }
  CFBooleanRef v25 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F8A0);
  if (v25)
  {
    int v26 = CFBooleanGetValue(v25);
    if (v2)
    {
      if (v26) {
        addProhibitedNetworkSubtype((uint64_t)v2, 0x1389u);
      }
    }
  }
  CFNumberRef v27 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F7F8);
  if (v2)
  {
    if (v27)
    {
      *(_DWORD *)CFAllocatorRef allocator = 0;
      if (CFNumberGetValue(v27, kCFNumberIntType, allocator))
      {
        int v28 = nw_parameters_copy_default_protocol_stack(v2);
        int v29 = v28;
        if (v28)
        {
          uint64_t v30 = nw_protocol_stack_copy_internet_protocol(v28);
          CFOptionFlags v31 = v30;
          if (v30)
          {
            nw_ip_options_set_local_address_preference(v30, *(nw_ip_local_address_preference_t *)allocator);
            nw_release(v31);
          }
          nw_release(v29);
        }
      }
    }
  }
  CFBooleanRef v32 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F9B8);
  if (v32)
  {
    int v33 = CFBooleanGetValue(v32);
    if (v2)
    {
      if (v33) {
        addProhibitedNetworkSubtype((uint64_t)v2, 0x3E9u);
      }
    }
  }
  tcp_connection_set_no_cellular();
  CFBooleanRef v34 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0AC8);
  if (v34)
  {
    CFBooleanGetValue(v34);
    tcp_connection_set_no_fallback();
  }
  CFBooleanRef v35 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0B00);
  if (v35)
  {
    CFBooleanGetValue(v35);
    tcp_connection_set_fallback_fast();
  }
  CFBooleanRef v36 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0F60);
  if (v36)
  {
    CFBooleanGetValue(v36);
    tcp_connection_set_extended_background_idle();
  }
  tcp_connection_set_persistent();
  if (((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x8000000000) != 0) {
    tcp_connection_set_usage_model();
  }
  CFBooleanRef v37 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A02E8);
  if (v37)
  {
    CFBooleanGetValue(v37);
    tcp_connection_set_ecn_enabled();
  }
  if (*((unsigned char *)this + 406)) {
    tcp_connection_set_receive_any_interface();
  }
  if (*((void *)this + 67))
  {
    CFAllocatorRef v38 = CFGetAllocator((char *)this - 16);
    CFStringRef v39 = (const __CFString *)*((void *)this + 67);
    *(void *)CFAllocatorRef allocator = v38;
    *(void *)&allocator[8] = 1023;
    if (v39)
    {
      *(void *)&allocator[16] = _CFStringGetOrCreateCString(v38, v39, (UInt8 *)v82, (uint64_t *)&allocator[8], 0x8000100u);
      if (!*(void *)&allocator[16]) {
        goto LABEL_76;
      }
    }
    else
    {
      LOBYTE(v82[0]) = 0;
      *(void *)&allocator[8] = 0;
      *(void *)&allocator[16] = v82;
    }
    tcp_connection_set_interface_by_name();
    if (*(void *)&allocator[16] && v82 != *(void **)&allocator[16]) {
      CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
    }
  }
LABEL_76:
  CFBooleanRef v40 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0E80);
  if (v40 && CFBooleanGetValue(v40))
  {
    int v41 = 1;
    tcp_connection_set_opportunistic();
  }
  else
  {
    int v41 = 0;
  }
  CFDataRef v42 = (const __CFData *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A1158);
  if (v42)
  {
    BytePtr = CFDataGetBytePtr(v42);
    if (BytePtr)
    {
      long long v44 = *((_OWORD *)BytePtr + 1);
      long long v66 = *(_OWORD *)BytePtr;
      long long v67 = v44;
      tcp_connection_set_source_application();
    }
  }
  CFStringRef v45 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0908);
  if (v45)
  {
    *(void *)CFAllocatorRef allocator = CFGetAllocator((char *)this - 16);
    *(void *)&allocator[8] = 1023;
    *(void *)&allocator[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)allocator, v45, (UInt8 *)v82, (uint64_t *)&allocator[8], 0x8000100u);
    if (*(void *)&allocator[16])
    {
      tcp_connection_set_account_identifier();
      if (*(void *)&allocator[16])
      {
        if (v82 != *(void **)&allocator[16]) {
          CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
        }
      }
    }
  }
  CFStringRef v46 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A1190);
  if (v46)
  {
    *(void *)CFAllocatorRef allocator = CFGetAllocator((char *)this - 16);
    *(void *)&allocator[8] = 1023;
    *(void *)&allocator[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)allocator, v46, (UInt8 *)v82, (uint64_t *)&allocator[8], 0x8000100u);
    if (*(void *)&allocator[16])
    {
      tcp_connection_set_source_application_by_bundle();
      if (*(void *)&allocator[16])
      {
        if (v82 != *(void **)&allocator[16]) {
          CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
        }
      }
    }
  }
  CFBooleanRef v47 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0CF8);
  if (v47)
  {
    CFBooleanGetValue(v47);
    tcp_connection_set_indefinite();
  }
  CFNumberRef v48 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09E6B0);
  CFNumberRef v49 = v48;
  if (v48)
  {
    *(void *)CFAllocatorRef allocator = 0;
    CFTypeID v50 = CFGetTypeID(v48);
    if (v50 == CFNumberGetTypeID()
      && CFNumberGetValue(v49, kCFNumberDoubleType, allocator)
      && *(double *)allocator > 0.0)
    {
      tcp_connection_set_connection_attempt_timeout();
    }
  }
  if (*((void *)this + 70)) {
    tcp_connection_set_traffic_class();
  }
  socklen_t v51 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09F670);
  if (v51) {
    SocketStream::updateExcessiveKeepalivesParameters((uint64_t)this, v51);
  }
  int v52 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09FFD8);
  if (v52) {
    SocketStream::updateTCPKeepalivesParameters((uint64_t)this, v52);
  }
  CFDictionaryRef v53 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09FFA0);
  if (v53)
  {
    CFTypeID v54 = CFGetTypeID(v53);
    if (v54 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)CFAllocatorRef allocator = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", allocator, 2u);
    }
    tcp_connection_set_keepalive_offload();
  }
  CFNumberRef v55 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09FEC0);
  CFNumberRef v56 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09FEF8);
  if ((unint64_t)v55 | (unint64_t)v56) {
    SocketStream::updateTCPAdaptiveParamters(this, v55, v56);
  }
  *((unsigned char *)this + 544) = 1;
  CFRetain((char *)this - 16);
  uint64_t v57 = (*(uint64_t (**)(SocketStream *))(*(void *)this + 184))(this);
  if (v57)
  {
    CFRetain((char *)this - 16);
    (*(void (**)(uint64_t))(*(void *)v57 + 16))(v57);
    CFArrayRef v58 = *((void *)this + 71);
    dispatch_retain(v58);
    uint64_t v59 = *((void *)this + 70);
    v63[0] = MEMORY[0x1E4F143A8];
    v63[1] = 3221225472;
    v63[2] = ___ZN12SocketStream18startTCPConnectionEh_block_invoke_109;
    v63[3] = &unk_1E5254AD8;
    v63[5] = this;
    v63[6] = v57;
    v63[4] = v58;
    char v64 = 0;
    char v65 = v41;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v57 + 32))(v57, v59, v63);
    (*(void (**)(uint64_t))(*(void *)v57 + 24))(v57);
  }
  else
  {
    ProxyConnectionEstablishment::SetProxies(*((void *)this + 70), 0, 0);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFArrayRef v60 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v61 = tcp_connection_id();
      uint64_t v62 = *((void *)this + 70);
      *(_DWORD *)CFAllocatorRef allocator = 134218240;
      *(void *)&allocator[4] = v61;
      *(_WORD *)&allocator[12] = 2048;
      *(void *)&allocator[14] = v62;
      _os_log_impl(&dword_184085000, v60, OS_LOG_TYPE_DEFAULT, "Stream client bypassing proxies on TCP Conn [%llu:%p]", allocator, 0x16u);
    }
    SocketStream::_onqueue_startTCPConnectionConditional((CFDictionaryRef *)this, 0, v41);
  }
  if (v2) {
    nw_release(v2);
  }
}

void sub_184216BC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,CFTypeRef cf,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,CFAllocatorRef allocator,uint64_t a36,void *ptr)
{
  nw_release(v39);
  nw_release(v38);
  nw_release(v37);
  _Unwind_Resume(a1);
}

void ___ZN12SocketStream25startLookupForOpen_NoLockEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(SocketStream **)(a1 + 32);
  SocketStream::_onqueue_completeTCPConnection(v1);

  CFRelease((char *)v1 - 16);
}

uint64_t SocketStream::startTCPConnection_Proxy_Connect(SocketStream *this, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator((char *)this - 16);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, &unk_1EC0A56B0);
  CFBooleanRef v6 = CFHostCreateWithName(v4, Value);
  CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_1EC0A56E8);
  if (v6)
  {
    uint64_t started = SocketStream::startTCPConnection_Host(this, v6, v7);
    CFRelease(v6);
    return started;
  }
  else
  {
    *((void *)this + 32) = 1;
    *((_DWORD *)this + 66) = 22;
    return 0;
  }
}

uint64_t SocketStream::startTCPConnection_Host(SocketStream *this, __CFHost *a2, const __CFNumber *a3)
{
  v26[128] = *MEMORY[0x1E4F143B8];
  CFArrayRef Info = (const __CFArray *)CFHostGetInfo((uint64_t)a2, 0, 0);
  CFTypeRef v7 = CFHostGetInfo((uint64_t)a2, 1, 0);
  if (!((unint64_t)Info | (unint64_t)v7))
  {
    uint64_t result = 0;
    *((void *)this + 32) = 1;
    int v14 = 22;
LABEL_15:
    *((_DWORD *)this + 66) = v14;
    return result;
  }
  CFArrayRef v8 = (const __CFArray *)v7;
  __int16 valuePtr = 0;
  if (a3) {
    CFNumberGetValue(a3, kCFNumberSInt16Type, &valuePtr);
  }
  if (v8 && CFArrayGetCount(v8) >= 1 && (CFStringRef v9 = (const __CFString *)CFArrayGetValueAtIndex(v8, 0), (v10 = v9) != 0))
  {
    if (hostnameIsValid(v9))
    {
      CFAllocatorRef allocator = CFGetAllocator((char *)this - 16);
      uint64_t v24 = 1023;
      ptr = _CFStringGetOrCreateCString(allocator, v10, (UInt8 *)v26, &v24, 0x8000100u);
      *((void *)this + 70) = tcp_connection_create();
      uint64_t v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_113_6802, 2);
      uint64_t v12 = v11;
      if (v11
        && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v11 + 16))(v11, "TCP Connection Created", 0))
      {
        (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v12 + 72))(v12, "conn", @"%p for name %s, port %d");
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
      }
      if (ptr && v26 != ptr) {
        CFAllocatorDeallocate(allocator, ptr);
      }
    }
    else
    {
      uint64_t v18 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_119, 2);
      uint64_t v19 = v18;
      if (v18
        && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v18 + 16))(v18, "TCP Connection Not Created - invalid host name", 0))
      {
        CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFAllocatorRef allocator = (CFAllocatorRef)off_1ECF9A530;
        CFStringRef v21 = CFStringCreateWithCString(v20, "host", 0x8000100u);
        ptr = 0;
        v26[0] = 0;
        uint64_t v24 = (uint64_t)v21;
        (*(void (**)(uint64_t))(*(void *)v19 + 64))(v19);
        AutoString::~AutoString((AutoString *)&allocator);
        (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
      }
      *((void *)this + 32) = 12;
      *((_DWORD *)this + 66) = 1;
    }
  }
  else if (Info)
  {
    if (CFArrayGetCount(Info) >= 1)
    {
      CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Info, 0);
      if (ValueAtIndex)
      {
        if (CFDataGetBytePtr(ValueAtIndex))
        {
          *((void *)this + 70) = tcp_connection_create_with_sockaddr();
          uint64_t v16 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_123, 2);
          uint64_t v17 = v16;
          if (v16)
          {
            if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v16 + 16))(v16, "TCP Connection Created", 0))
            {
              (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v17 + 72))(v17, "conn", @"%p for sockaddr %@");
              (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
            }
          }
        }
      }
    }
  }
  if (*((void *)this + 70))
  {
    SocketStream::startTCPConnection(this);
    return 1;
  }
  if (!*((_DWORD *)this + 66))
  {
    uint64_t result = 0;
    if (valuePtr) {
      int v14 = 12;
    }
    else {
      int v14 = 49;
    }
    *((void *)this + 32) = 1;
    goto LABEL_15;
  }
  return 0;
}

void sub_184217270(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFAllocatorRef allocator, uint64_t a14, void *ptr)
{
}

uint64_t SocketStream::startTCPConnection_NetService(SocketStream *this, __CFNetService *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CFStringRef Info = (const __CFString *)CFNetServiceGetInfo((uint64_t)a2, 2u);
  CFStringRef v5 = (const __CFString *)CFNetServiceGetInfo((uint64_t)a2, 4u);
  CFStringRef v6 = (const __CFString *)CFNetServiceGetInfo((uint64_t)a2, 0);
  if (Info && v5 && (CFStringRef v7 = v6) != 0)
  {
    CFAllocatorRef v26 = CFGetAllocator((char *)this - 16);
    uint64_t v27 = 1023;
    int v28 = _CFStringGetOrCreateCString(v26, Info, v29, &v27, 0x8000100u);
    CFAllocatorRef v22 = CFGetAllocator((char *)this - 16);
    uint64_t v23 = 1023;
    uint64_t v24 = _CFStringGetOrCreateCString(v22, v5, v25, &v23, 0x8000100u);
    CFAllocatorRef allocator = CFGetAllocator((char *)this - 16);
    uint64_t v19 = 1023;
    ptr = _CFStringGetOrCreateCString(allocator, v7, v21, &v19, 0x8000100u);
    *((void *)this + 70) = tcp_connection_create_with_service();
    uint64_t v8 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_128, 2);
    uint64_t v9 = v8;
    if (v8
      && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v8 + 16))(v8, "TCP Connection Created", 0))
    {
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v9 + 72))(v9, "conn", @"%p for netservice %s %s %s");
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    if (*((void *)this + 70))
    {
      CFBooleanRef v10 = (const __CFBoolean *)CFNetServiceGetInfo((uint64_t)a2, 7u);
      if (v10 && CFBooleanGetValue(v10)) {
        tcp_connection_override_obscure();
      }
      CFBooleanRef v11 = (const __CFBoolean *)CFNetServiceGetInfo((uint64_t)a2, 9u);
      if (v11 && CFBooleanGetValue(v11)) {
        tcp_connection_override_obscure();
      }
    }
    else
    {
      *((void *)this + 32) = 10;
      *((_DWORD *)this + 66) = -72004;
    }
    if (ptr && v21 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
    if (v24 && v25 != v24) {
      CFAllocatorDeallocate(v22, v24);
    }
    if (v28 && v29 != v28) {
      CFAllocatorDeallocate(v26, v28);
    }
  }
  else
  {
    CFArrayRef v12 = (const __CFArray *)CFNetServiceGetInfo((uint64_t)a2, 3u);
    if (!v12) {
      goto LABEL_21;
    }
    CFArrayRef v13 = v12;
    if (CFArrayGetCount(v12) < 1) {
      goto LABEL_21;
    }
    CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v13, 0);
    if (!ValueAtIndex) {
      goto LABEL_21;
    }
    CFDataGetBytePtr(ValueAtIndex);
    *((void *)this + 70) = tcp_connection_create_with_sockaddr();
    uint64_t v15 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_133, 2);
    if (v15)
    {
      uint64_t v16 = v15;
      if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v15 + 16))(v15, "TCP Connection Created", 0))
      {
        (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v16 + 72))(v16, "conn", @"%p for sockaddr %@");
        (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
      }
    }
    if (!*((void *)this + 70))
    {
LABEL_21:
      *((void *)this + 32) = 10;
      *((_DWORD *)this + 66) = -72004;
    }
  }
  if (!*((void *)this + 70)) {
    return 0;
  }
  SocketStream::startTCPConnection(this);
  return 1;
}

void sub_1842176D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const __CFAllocator *allocator, uint64_t a14, void *ptr)
{
  if (ptr && v17 != ptr) {
    CFAllocatorDeallocate(allocator, ptr);
  }
  uint64_t v19 = (void *)STACK[0x448];
  if (STACK[0x448] && v16 != v19) {
    CFAllocatorDeallocate((CFAllocatorRef)STACK[0x438], v19);
  }
  CFAllocatorRef v20 = (void *)STACK[0x860];
  if (STACK[0x860])
  {
    if (v15 != v20) {
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x850], v20);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t ___ZN12SocketStream29startTCPConnection_NetServiceEP14__CFNetService_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 4552;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream29startTCPConnection_NetServiceEP14__CFNetService_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 4529;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream23startTCPConnection_HostEP8__CFHostPK10__CFNumber_block_invoke_3@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 4489;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream23startTCPConnection_HostEP8__CFHostPK10__CFNumber_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 4474;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream23startTCPConnection_HostEP8__CFHostPK10__CFNumber_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 4470;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void SocketStream::_SocksHostCallBack(SocketStream *this, __CFHost *a2, const __CFString *a3, char *cf, void *a5)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    return;
  }
  if (TCFObject<SocketStream>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_406);
  }
  CFRetain(cf);
  if (a2 == (__CFHost *)&unk_1EC0A4920)
  {
    uint64_t v8 = (pthread_mutex_t *)(cf + 56);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)cf + 44), &unk_1EC0A1120);
    CFStringRef v10 = (const __CFString *)CFDictionaryGetValue(Value, (const void *)*MEMORY[0x1E4F1D470]);
    CFNumberRef number = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)cf + 44), &unk_1EC0A1078);
    Schedulables::_remove(*((Schedulables **)cf + 43), this);
    _CFTypeInvalidate((char *)this);
    uint64_t v11 = 0;
    long long v34 = *((_OWORD *)cf + 20);
    uint64_t v35 = *((void *)cf + 42);
    do
    {
      _CFTypeUnscheduleFromMultipleRunLoops(this, *(const __CFArray **)((char *)&v34 + v11));
      v11 += 8;
    }
    while (v11 != 24);
    CFArrayRef Info = (const __CFArray *)CFHostGetInfo((uint64_t)this, 0, 0);
    CFArrayRef v13 = Info;
    if (Info && CFArrayGetCount(Info))
    {
      CFStringRef ValueAtIndex = 0;
      if (!v10) {
        goto LABEL_14;
      }
    }
    else
    {
      CFArrayRef v17 = (const __CFArray *)CFHostGetInfo((uint64_t)this, 1, 0);
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v17, 0);
      if (!v10)
      {
LABEL_14:
        CFIndex Bytes = 0;
        if (!ValueAtIndex)
        {
LABEL_15:
          CFIndex v16 = 0;
          goto LABEL_19;
        }
LABEL_18:
        v39.CFStringRef length = CFStringGetLength(ValueAtIndex);
        v39.CFIndex location = 0;
        CFIndex v16 = CFStringGetBytes(ValueAtIndex, v39, 0x8000100u, 0, 0, 0, 0, 0) + 1;
LABEL_19:
        CFAllocatorRef v18 = CFGetAllocator(cf);
        CFArrayRef Mutable = CFDataCreateMutable(v18, Bytes + v16 + 9);
        if (!Mutable)
        {
          *((void *)cf + 34) = 1;
          *((_DWORD *)cf + 70) = 12;
          goto LABEL_44;
        }
        CFAllocatorRef v20 = Mutable;
        CFDataSetLength(Mutable, Bytes + v16 + 9);
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)cf + 44), &unk_1EC09FC90, v20);
        CFRelease(v20);
        MutableBytePtr = CFDataGetMutableBytePtr(v20);
        size_t Length = CFDataGetLength(v20);
        bzero(MutableBytePtr, Length);
        if (ValueAtIndex)
        {
          v40.CFStringRef length = CFStringGetLength(ValueAtIndex);
          v40.CFIndex location = 0;
          CFStringGetBytes(ValueAtIndex, v40, 0x8000100u, 0, 0, &MutableBytePtr[Bytes + 9], v16, 0);
          MutableBytePtr[Bytes + 8 + v16] = 0;
          MutableBytePtr[7] = 16;
        }
        else
        {
          CFIndex Count = CFArrayGetCount(v13);
          if (Count < 1)
          {
            CFIndex v26 = 0;
          }
          else
          {
            CFIndex v26 = 0;
            while (1)
            {
              CFDataRef v27 = (const __CFData *)CFArrayGetValueAtIndex(v13, v26);
              BytePtr = CFDataGetBytePtr(v27);
              if (BytePtr[1] == 2) {
                break;
              }
              if (Count == ++v26) {
                goto LABEL_43;
              }
            }
            *((_DWORD *)MutableBytePtr + 1) = *((_DWORD *)BytePtr + 1);
            if (!number) {
              *((_WORD *)MutableBytePtr + 1) = *((_WORD *)BytePtr + 1);
            }
          }
          if (v26 == Count) {
            goto LABEL_43;
          }
        }
        *(_WORD *)MutableBytePtr = 260;
        if (!number) {
          goto LABEL_25;
        }
        unsigned int valuePtr = 0;
        CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
        if (!HIWORD(valuePtr))
        {
          *((_WORD *)MutableBytePtr + 1) = bswap32(valuePtr) >> 16;
LABEL_25:
          if (v10)
          {
            v41.CFStringRef length = CFStringGetLength(v10);
            v41.CFIndex location = 0;
            CFStringGetBytes(v10, v41, 0x8000100u, 0, 0, MutableBytePtr + 8, Bytes, 0);
          }
          uint64_t v8 = (pthread_mutex_t *)(cf + 56);
          if ((*((_DWORD *)cf + 66) & 2) != 0)
          {
            unsigned int v23 = *((_DWORD *)cf + 107);
            if (v23)
            {
              uint64_t v24 = 0;
              while (((v23 >> v24) & 1) == 0)
              {
                if (++v24 == 8) {
                  goto LABEL_44;
                }
              }
              if (v24 == 4) {
                SocketStream::_PerformSOCKSv4Handshake_NoLock((CFDictionaryRef *)cf + 2);
              }
            }
          }
LABEL_44:
          CFHostCancelInfoResolution(this, kCFHostAddresses);
          if (!*((_DWORD *)cf + 70))
          {
            pthread_mutex_unlock(v8);
            goto LABEL_5;
          }
          int v29 = *((_DWORD *)cf + 66);
          *((_DWORD *)cf + 66) = v29 & 0xFFFFFFEC | 2;
          long long v34 = *((_OWORD *)cf + 17);
          if ((v29 & 0x200) != 0)
          {
            id WeakRetained = objc_loadWeakRetained((id *)cf + 36);
            if ((*((_DWORD *)cf + 66) & 0x400) != 0) {
              goto LABEL_47;
            }
          }
          else
          {
            id WeakRetained = 0;
            if ((v29 & 0x400) != 0)
            {
LABEL_47:
              id v31 = objc_loadWeakRetained((id *)cf + 37);
LABEL_51:
              pthread_mutex_unlock(v8);
              if (WeakRetained)
              {
                CFReadStreamSignalEvent();
                CFRelease(WeakRetained);
              }
              if (v31)
              {
                CFWriteStreamSignalEvent();
                CFRelease(v31);
              }
              goto LABEL_5;
            }
          }
          id v31 = 0;
          goto LABEL_51;
        }
LABEL_43:
        *((void *)cf + 34) = 1;
        *((_DWORD *)cf + 70) = 22;
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)cf + 44), &unk_1EC09FC90);
        uint64_t v8 = (pthread_mutex_t *)(cf + 56);
        goto LABEL_44;
      }
    }
    v38.CFStringRef length = CFStringGetLength(v10);
    v38.CFIndex location = 0;
    CFIndex Bytes = CFStringGetBytes(v10, v38, 0x8000100u, 0, 0, 0, 0, 0);
    if (!ValueAtIndex) {
      goto LABEL_15;
    }
    goto LABEL_18;
  }
LABEL_5:

  CFRelease(cf);
}

void SocketStream::_onqueue_completeTCPConnection(SocketStream *this)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 49);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 49));
    *((void *)this + 49) = 0;
  }
  uint64_t v3 = (*(uint64_t (**)(SocketStream *))(*(void *)this + 184))(this);
  if (v3)
  {
    uint64_t v4 = v3;
    CFRetain((char *)this - 16);
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC09EE20);
    if (Value && CFBooleanGetValue(Value))
    {
      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"SocketStream %p", this);
      int v16 = 60;
      int valuePtr = 255;
      *(_OWORD *)keys = xmmword_1E5254B38;
      long long v20 = *(_OWORD *)off_1E5254B48;
      CFStringRef v21 = @"TimeoutAction";
      values[0] = (void *)CFRetain(@"PreventUserIdleSystemSleep");
      values[1] = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      if (v7) {
        CFTypeRef v8 = CFRetain(v7);
      }
      else {
        CFTypeRef v8 = 0;
      }
      values[2] = (void *)v8;
      values[3] = CFNumberCreate(v6, kCFNumberIntType, &v16);
      values[4] = (void *)CFRetain(@"TimeoutActionTurnOff");
      CFDictionaryRef v9 = CFDictionaryCreate(v6, (const void **)keys, (const void **)values, 5, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      for (uint64_t i = 0; i != 5; ++i)
      {
        uint64_t v11 = values[i];
        if (v11) {
          CFRelease(v11);
        }
      }
      IOPMAssertionCreateWithProperties(v9, (IOPMAssertionID *)this + 153);
      if (v9) {
        CFRelease(v9);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
    CFArrayRef v12 = *((void *)this + 71);
    dispatch_retain(v12);
    uint64_t v13 = *((void *)this + 70);
    tcp_connection_retain();
    uint64_t v14 = *((void *)this + 70);
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke;
    void v15[3] = &unk_1E5254A70;
    v15[6] = this;
    v15[7] = v4;
    void v15[4] = v12;
    v15[5] = v13;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v4 + 56))(v4, v14, v15);
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  else
  {
    SocketStream::_onqueue_completeTCPConnection0((uint64_t)this, 0);
  }
}

void SocketStream::_onqueue_completeTCPConnection0(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (a2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFStreamClientContext buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "SocketStream doesn't know how to deal with leftover bytes here yet", buf, 2u);
  }
  if (*(unsigned char *)(a1 + 544))
  {
    if (!*(void *)(a1 + 560))
    {
LABEL_58:
      *(unsigned char *)(a1 + 544) = 0;
      CFRelease((CFTypeRef)(a1 - 16));
      return;
    }
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 336), &unk_1EC0A0F98))
    {
      SocketStream::setupMinimumThroughput(a1, 0);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
      SocketStream::attemptNextConnection_NoLock((SocketStream *)a1);
      uint64_t v3 = (pthread_mutex_t *)(a1 + 40);
LABEL_57:
      pthread_mutex_unlock(v3);
      goto LABEL_58;
    }
    *(_DWORD *)bytes = tcp_connection_get_socket();
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 560);
      int error = tcp_connection_get_error();
      *(_DWORD *)CFStreamClientContext buf = 134218496;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = *(_DWORD *)bytes;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = error;
      _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "TCP Conn %p complete. fd: %d, err: %d", buf, 0x18u);
    }
    uint64_t v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_32, 2);
    if (v7)
    {
      uint64_t v8 = v7;
      if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v7 + 16))(v7, "SocketStream TCP Connection Complete", 0))
      {
        (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v8 + 72))(v8, "conn", @"%p");
        (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v8 + 72))(v8, "fd", @"%d");
        tcp_connection_get_error();
        (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v8 + 72))(v8, "error", @"%d");
        (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
      }
    }
    if (*(_DWORD *)bytes != -1)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
      if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 336), &unk_1EC0A0F98)
        && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)CFStreamClientContext buf = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Musn't have a native handle right now", buf, 2u);
      }
      CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)(a1 - 16));
      CFDataRef v10 = CFDataCreate(v9, bytes, 4);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 336), &unk_1EC0A0F98, v10);
      if (v10) {
        CFRelease(v10);
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 336), &unk_1EC0A0F28, (const void *)*MEMORY[0x1E4F1CFD0]);
      if (*(unsigned char *)(a1 + 405))
      {
        *(_DWORD *)CFStreamClientContext buf = 1;
        setsockopt(*(int *)bytes, 6, 1, buf, 4u);
      }
      SocketStream::setupMinimumThroughput(a1, 0);
      SocketStream::attemptNextConnection_NoLock((SocketStream *)a1);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40));
      if (*(_DWORD *)bytes != -1) {
        goto LABEL_58;
      }
    }
    int v11 = tcp_connection_get_error();
    uint64_t v12 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_48, 1);
    if (v12)
    {
      uint64_t v13 = v12;
      if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v12 + 16))(v12, "TCP Connection Failed", 0))
      {
        tcp_connection_get_error();
        (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v13 + 72))(v13, "error", @"%d [%d]");
        (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
      }
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v14 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = *(void *)(a1 + 560);
      int v23 = tcp_connection_get_error();
      *(_DWORD *)CFStreamClientContext buf = 134218752;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = 0;
      *(_WORD *)&buf[22] = 1024;
      int v31 = v11;
      __int16 v32 = 1024;
      int v33 = v23;
      _os_log_error_impl(&dword_184085000, v14, OS_LOG_TYPE_ERROR, "TCP Conn %p Failed : error %ld:%d [%d]", buf, 0x22u);
      if (v11)
      {
LABEL_31:
        if (v11 == 536870913)
        {
LABEL_39:
          int v11 = 57;
LABEL_47:
          uint64_t v19 = 1;
          goto LABEL_48;
        }
        if (v11 == 57)
        {
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 336), &unk_1EC0A0A58);
          if (Value)
          {
            CFDictionaryRef v16 = Value;
            CFArrayRef v17 = CFDictionaryGetValue(Value, @"kConditionalConnectionRequirementTimeWindowStartTime");
            CFNumberRef v18 = (const __CFNumber *)CFDictionaryGetValue(v16, @"kConditionalConnectionRequirementTimeWindowDuration");
            int v11 = 57;
            uint64_t v19 = 1;
            if (!v17 || !v18) {
              goto LABEL_48;
            }
            *(void *)CFStreamClientContext buf = 0;
            CFNumberGetValue(v18, kCFNumberDoubleType, buf);
            double v20 = MEMORY[0x185319AB0](v17);
            CFAbsoluteTime v21 = v20 + *(double *)buf;
            if (v21 <= CFAbsoluteTimeGetCurrent()) {
              int v11 = 60;
            }
            else {
              int v11 = 57;
            }
            goto LABEL_47;
          }
          goto LABEL_39;
        }
        if (v11 > 0) {
          goto LABEL_47;
        }
        if (v11 > -65549)
        {
          if (v11 == -65548)
          {
            int v11 = -72001;
            goto LABEL_66;
          }
          if (v11 == -65540)
          {
            int v11 = -72004;
LABEL_66:
            uint64_t v19 = 10;
            goto LABEL_48;
          }
        }
        else
        {
          if (v11 == -65555)
          {
            int v11 = -72008;
            goto LABEL_66;
          }
          if (v11 == -65554)
          {
            int v11 = 8;
            uint64_t v19 = 12;
LABEL_48:
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
            int v24 = *(_DWORD *)(a1 + 248);
            *(void *)(a1 + 256) = v19;
            *(_DWORD *)(a1 + 264) = v11;
            *(_DWORD *)(a1 + 248) = v24 & 0xFFFFFFEC | 2;
            *(_OWORD *)CFStreamClientContext buf = *(_OWORD *)(a1 + 256);
            id WeakRetained = objc_loadWeakRetained((id *)(a1 + 272));
            if (WeakRetained)
            {
              CFIndex v26 = WeakRetained;
              if ((*(_DWORD *)(a1 + 248) & 0x200) != 0) {
                _CFReadStreamSignalEventDelayed();
              }
              CFRelease(v26);
            }
            id v27 = objc_loadWeakRetained((id *)(a1 + 280));
            if (v27)
            {
              int v28 = v27;
              if ((*(_DWORD *)(a1 + 248) & 0x400) != 0) {
                _CFWriteStreamSignalEventDelayed();
              }
              CFRelease(v28);
            }
            uint64_t v3 = (pthread_mutex_t *)(a1 + 40);
            goto LABEL_57;
          }
        }
        int v11 = -72000;
        goto LABEL_66;
      }
    }
    else if (v11)
    {
      goto LABEL_31;
    }
    int v11 = 2;
    goto LABEL_47;
  }
}

void ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke(uint64_t a1, NSObject *a2, const void *a3, char a4)
{
  uint64_t v8 = *(void *)(a1 + 48);
  (*(void (**)(void))(**(void **)(a1 + 56) + 24))(*(void *)(a1 + 56));
  if (a2) {
    dispatch_retain(a2);
  }
  if (a3) {
    CFRetain(a3);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke_2;
  CFHostClientContext block[3] = &unk_1E5254A48;
  block[6] = v8;
  block[7] = a3;
  char v12 = a4;
  CFAllocatorRef v9 = *(NSObject **)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  block[4] = a2;
  void block[5] = v10;
  dispatch_async(v9, block);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke_2(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 48);
  IOPMAssertionID v3 = *(_DWORD *)(v2 + 612);
  if (v3)
  {
    IOPMAssertionRelease(v3);
    *(_DWORD *)(v2 + 612) = 0;
  }
  IOPMAssertionID v4 = *(_DWORD *)(v2 + 616);
  if (v4)
  {
    IOPMAssertionRelease(v4);
    *(_DWORD *)(v2 + 6CFRetain((char *)this - 16) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 56);
  if (v5)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 40));
    CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 336), &unk_1EC0A5678);
    if (Value) {
      uint64_t v5 = Value;
    }
    CFRetain(v5);
    SocketStream::removeHandshake_NoLock(v2, 7);
    uint64_t v7 = *(unsigned int *)(v2 + 248);
    unint64_t v8 = v7 | ((unint64_t)*(unsigned __int16 *)(v2 + 252) << 32) | 0x400000000;
    *(_DWORD *)(v2 + 248) = v7;
    *(_WORD *)(v2 + 252) = WORD2(v8);
    SocketStream::_CONNECTSetInfo_NoLock((CFDictionaryRef *)v2, (CFDictionaryRef)v5);
    CFRelease(v5);
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 40));
    CFRelease(*(CFTypeRef *)(a1 + 56));
  }
  if (*(unsigned char *)(a1 + 64))
  {
    *(void *)(v2 + 256) = 1;
    *(_DWORD *)(v2 + 264) = 57;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFAllocatorRef v9 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(v2 + 560);
      int v12 = 134217984;
      uint64_t v13 = v10;
      _os_log_impl(&dword_184085000, v9, OS_LOG_TYPE_DEFAULT, "TCP Conn %p canceled by ceClient", (uint8_t *)&v12, 0xCu);
    }
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 40));
    SocketStream::cleanupConnection_NoLock((SocketStream *)v2);
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 40));
  }
  else
  {
    SocketStream::_onqueue_completeTCPConnection0(v2, *(void *)(a1 + 32));
  }
  int v11 = *(NSObject **)(a1 + 32);
  if (v11) {
    dispatch_release(v11);
  }
  tcp_connection_release();
  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t ___ZN12SocketStream31_onqueue_completeTCPConnection0EPU27objcproto16OS_dispatch_data8NSObject_block_invoke_46@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 3515;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream31_onqueue_completeTCPConnection0EPU27objcproto16OS_dispatch_data8NSObject_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 3484;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN12SocketStream18startTCPConnectionEh_block_invoke(uint64_t a1, int a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 40));
  int v4 = *(_DWORD *)(v3 + 248);
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 40));
  if ((v4 & 0x1000) == 0)
  {
    switch(a2)
    {
      case 1073741825:
        if (*(void *)(v3 + 464) || *(void *)(v3 + 472))
        {
          *(void *)CFTypeRef cf = 0;
          CFTypeRef v47 = 0;
          SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v47);
          uint64_t v18 = *(void *)(v3 + 464);
          if (v18) {
            BOOL v19 = *(void *)cf == 0;
          }
          else {
            BOOL v19 = 1;
          }
          if (!v19) {
            (*(void (**)(void))(v18 + 16))();
          }
          uint64_t v20 = *(void *)(v3 + 472);
          if (v20) {
            BOOL v21 = v47 == 0;
          }
          else {
            BOOL v21 = 1;
          }
          if (!v21) {
            (*(void (**)(void))(v20 + 16))();
          }
          if (*(void *)cf) {
            CFRelease(*(CFTypeRef *)cf);
          }
          CFTypeRef v22 = v47;
          if (v47) {
            goto LABEL_115;
          }
        }
        break;
      case 1073741826:
        if (*(void *)(v3 + 448) || *(void *)(v3 + 456))
        {
          uint64_t v23 = tcp_connection_conditions_met();
          *(void *)CFTypeRef cf = 0;
          CFTypeRef v47 = 0;
          SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v47);
          uint64_t v24 = *(void *)(v3 + 448);
          if (v24) {
            BOOL v25 = *(void *)cf == 0;
          }
          else {
            BOOL v25 = 1;
          }
          if (!v25) {
            (*(void (**)(void))(v24 + 16))();
          }
          uint64_t v26 = *(void *)(v3 + 456);
          if (v26 && v47) {
            (*(void (**)(uint64_t, CFTypeRef, uint64_t))(v26 + 16))(v26, v47, v23);
          }
          if (*(void *)cf) {
            CFRelease(*(CFTypeRef *)cf);
          }
          CFTypeRef v22 = v47;
          if (v47) {
            goto LABEL_115;
          }
        }
        break;
      case 1073741827:
      case 1073741831:
        return;
      case 1073741828:
      case 1073741829:
        if (a2 == 1073741828) {
          *(void *)&v5.int error = 4294965195;
        }
        else {
          *(void *)&v5.int error = 4294965196;
        }
        CFAllocatorRef v6 = (SocketStream *)v3;
        v5.CFIndex domain = 4;
        goto LABEL_72;
      case 1073741830:
        if (*(void *)(v3 + 480) || *(void *)(v3 + 488))
        {
          *(void *)CFTypeRef cf = 0;
          CFTypeRef v47 = 0;
          SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v47);
          uint64_t v27 = *(void *)(v3 + 480);
          if (v27) {
            BOOL v28 = *(void *)cf == 0;
          }
          else {
            BOOL v28 = 1;
          }
          if (!v28) {
            (*(void (**)(void))(v27 + 16))();
          }
          uint64_t v29 = *(void *)(v3 + 488);
          if (v29) {
            BOOL v30 = v47 == 0;
          }
          else {
            BOOL v30 = 1;
          }
          if (!v30) {
            (*(void (**)(void))(v29 + 16))();
          }
          if (*(void *)cf) {
            CFRelease(*(CFTypeRef *)cf);
          }
          CFTypeRef v22 = v47;
          if (v47) {
LABEL_115:
          }
            CFRelease(v22);
        }
        break;
      case 1073741832:
        CFAllocatorRef v6 = (SocketStream *)v3;
        v5.CFIndex domain = 4;
        *(void *)&v5.int error = 4294965190;
LABEL_72:
        SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(v6, v5);
        break;
      case 1073741833:
        if (tcp_connection_get_connection_quality() == 1)
        {
          unsigned int v32 = *(_DWORD *)(v3 + 248);
          uint64_t v31 = v3 + 248;
          unint64_t v33 = v32 | ((unint64_t)*(unsigned __int16 *)(v31 + 4) << 32) | 0x200000000;
          *(_DWORD *)uint64_t v31 = v32;
          *(_WORD *)(v31 + 4) = WORD2(v33);
        }
        break;
      default:
        switch(a2)
        {
          case 1:
            CFTypeRef v47 = 0;
            uint64_t v48 = 0;
            uint64_t v49 = 0;
            if (*(void *)(v3 + 560)
              && tcp_connection_get_statistics()
              && ((*(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32)) & 0x20000000000) != 0)
            {
              CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)(v3 - 16));
              CFArrayRef Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              *(void *)CFTypeRef cf = @"_kCFStreamStatsDNS_ResolutionTimeMs";
              *(_DWORD *)&cf[8] = v47;
              *(void *)&uint64_t v52[2] = @"_kCFStreamStatsConnectionEstablishmentTimeMs";
              int v53 = v48;
              CFAllocatorRef v9 = (char *)operator new(0x20uLL);
              uint64_t v10 = v9;
              for (uint64_t i = 0; i != 32; i += 16)
                *(_OWORD *)&v9[i] = *(_OWORD *)&cf[i];
              for (uint64_t j = 0; j != 32; j += 16)
              {
                CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)(v3 - 16));
                CFNumberRef v14 = CFNumberCreate(v13, kCFNumberSInt32Type, &v10[j + 8]);
                CFDictionaryAddValue(Mutable, *(const void **)&v10[j], v14);
                if (v14) {
                  CFRelease(v14);
                }
              }
              operator delete(v10);
              (*(void (**)(uint64_t, uint64_t, __CFDictionary *))(*(void *)v3 + 200))(v3, 0x1EC09F478, Mutable);
              if (Mutable) {
                CFRelease(Mutable);
              }
            }
            goto LABEL_19;
          case 3:
LABEL_19:
            SocketStream::cancelSIMScheduler((SocketStream *)v3);
            if (*(unsigned char *)(v3 + 544))
            {
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
              }
              uint64_t v15 = CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v16 = *(void *)(v3 + 560);
                if (v16) {
                  int error = tcp_connection_get_error();
                }
                else {
                  int error = 0;
                }
                *(_DWORD *)CFTypeRef cf = 134218496;
                *(void *)&cf[4] = v16;
                __int16 v51 = 1024;
                *(_DWORD *)int v52 = a2;
                *(_WORD *)&v52[4] = 1024;
                *(_DWORD *)&v52[6] = error;
                _os_log_impl(&dword_184085000, v15, OS_LOG_TYPE_DEFAULT, "TCP Conn %p event %d. err: %d", cf, 0x18u);
              }
              SocketStream::_onqueue_completeTCPConnection((SocketStream *)v3);
            }
            break;
          case 5:
            uint64_t v34 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_88, 2);
            if (v34)
            {
              uint64_t v35 = v34;
              if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v34 + 16))(v34, "better route detected", 0))
              {
                diagnosticLogTCPConnectionInfo(v35, *(void *)(v3 + 560));
                (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
              }
            }
            uint64_t v36 = *(void *)(v3 + 512);
            if (v36) {
              (*(void (**)(void))(v36 + 16))();
            }
            SocketStream::terminateConnectionIfAppropriate((SocketStream *)v3, 1);
            break;
          case 6:
            uint64_t is_viable = tcp_connection_is_viable();
            uint64_t v38 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_79, 2);
            if (v38)
            {
              uint64_t v39 = v38;
              if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v38 + 16))(v38, "Connection viability changed", 0))
              {
                diagnosticLogTCPConnectionInfo(v39, *(void *)(v3 + 560));
                (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v39 + 72))(v39, "viable", @"%s");
                (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
              }
            }
            if (*(void *)(v3 + 496) || *(void *)(v3 + 504))
            {
              *(void *)CFTypeRef cf = 0;
              CFTypeRef v47 = 0;
              SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v47);
              uint64_t v40 = *(void *)(v3 + 496);
              if (v40 && *(void *)cf) {
                (*(void (**)(uint64_t, void, uint64_t))(v40 + 16))(v40, *(void *)cf, is_viable);
              }
              uint64_t v41 = *(void *)(v3 + 504);
              if (v41 && v47) {
                (*(void (**)(uint64_t, CFTypeRef, uint64_t))(v41 + 16))(v41, v47, is_viable);
              }
              if (*(void *)cf) {
                CFRelease(*(CFTypeRef *)cf);
              }
              if (v47) {
                CFRelease(v47);
              }
            }
            if ((is_viable & 1) == 0) {
              SocketStream::terminateConnectionIfAppropriate((SocketStream *)v3, 0);
            }
            break;
          case 7:
            uint64_t unmet_reason = tcp_connection_conditions_get_unmet_reason();
            uint64_t v43 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 184))(v3);
            if (v43)
            {
              uint64_t v44 = v43;
              (*(void (**)(uint64_t, uint64_t))(*(void *)v43 + 72))(v43, unmet_reason);
              (*(void (**)(uint64_t))(*(void *)v44 + 24))(v44);
            }
            if (*(void *)(v3 + 432) || *(void *)(v3 + 440))
            {
              *(void *)CFTypeRef cf = 0;
              CFTypeRef v47 = 0;
              SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v47);
              uint64_t v45 = *(void *)(v3 + 432);
              if (v45 && *(void *)cf) {
                (*(void (**)(uint64_t, void, uint64_t))(v45 + 16))(v45, *(void *)cf, unmet_reason);
              }
              uint64_t v46 = *(void *)(v3 + 440);
              if (v46 && v47) {
                (*(void (**)(uint64_t, CFTypeRef, uint64_t))(v46 + 16))(v46, v47, unmet_reason);
              }
              if (*(void *)cf) {
                CFRelease(*(CFTypeRef *)cf);
              }
              CFTypeRef v22 = v47;
              if (v47) {
                goto LABEL_115;
              }
            }
            break;
          default:
            return;
        }
        break;
    }
  }
}

void sub_184219588(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    int v5 = 134217984;
    uint64_t v6 = v4;
    _os_log_debug_impl(&dword_184085000, v2, OS_LOG_TYPE_DEBUG, "TCP Conn %p released", (uint8_t *)&v5, 0xCu);
  }
  return tcp_connection_release();
}

uint64_t SocketStream::_onqueue_startTCPConnectionConditional(CFDictionaryRef *this, int a2, int a3)
{
  if (CFDictionaryGetValue(this[42], &unk_1EC0A0A58))
  {
    gotLoadHelper_x8__OBJC_CLASS____DASActivity(v6);
    if (objc_opt_class())
    {
      CFRetain(this - 2);
      operator new();
    }
    CFRetain(this - 2);
    operator new();
  }

  return SocketStream::_onqueue_startTCPConnectionCompletion((SocketStream *)this, a2, a3);
}

void sub_184219B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  _Unwind_Resume(a1);
}

void ___ZN12SocketStream18startTCPConnectionEh_block_invoke_109(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(void))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48));
  uint64_t v3 = *(NSObject **)(a1 + 32);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2_110;
  v4[3] = &__block_descriptor_42_e5_v8__0l;
  v4[4] = v2;
  __int16 v5 = *(_WORD *)(a1 + 56);
  dispatch_async(v3, v4);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2_110(uint64_t a1)
{
  uint64_t v1 = *(CFDictionaryRef **)(a1 + 32);
  SocketStream::_onqueue_startTCPConnectionConditional(v1, *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41));

  CFRelease(v1 - 2);
}

uint64_t SocketStream::_onqueue_startTCPConnectionCompletion(SocketStream *this, int a2, int a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)this + 656) = 1;
  if (*((void *)this + 70))
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    double v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *((void *)this + 70);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v7;
      _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "TCP Conn %p started", (uint8_t *)&buf, 0xCu);
    }
    tcp_connection_start();
    SocketStream::touchWatchdogTimer_Locked(this, 1);
    if (entr_shouldtrace_delayInitStub(v8))
    {
      *((void *)this + 79) = atomic_fetch_add(&gSocketStreamEnergyTraceIdentifier, 1uLL);
      *((unsigned char *)this + 644) = 1;
      int v10 = ~(*((_DWORD *)this + 62) >> 30) & 2;
      *((_DWORD *)this + 160) = v10;
      unsigned int v11 = *((_DWORD *)this + 102) - 1;
      if (v11 <= 9) {
        *((_DWORD *)this + 160) = (v10 | (v11 << 20)) + 0x100000;
      }
      entr_act_begin_delayInitStub(v9);
    }
  }
  double v12 = *((double *)this + 46);
  if (v12 > 0.0)
  {
    *((double *)this + 47) = v12;
    CFAllocatorRef v13 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *((dispatch_queue_t *)this + 71));
    *((void *)this + 49) = v13;
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 3221225472;
    handler[2] = ___ZN12SocketStream37_onqueue_startTCPConnectionCompletionEhh_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    void handler[4] = this;
    dispatch_source_set_event_handler(v13, handler);
    CFNumberRef v14 = *((void *)this + 49);
    dispatch_time_t v15 = dispatch_time(0, (uint64_t)(*((double *)this + 47) * 1000000000.0));
    dispatch_source_set_timer(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    dispatch_resume(*((dispatch_object_t *)this + 49));
  }
  uint64_t result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_91, 2);
  uint64_t v17 = result;
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void))(*(void *)result + 16))(result, "TCP Connection Start", 0);
    if (result)
    {
      BOOL v18 = a2 == 0;
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v17 + 72))(v17, "conn", @"%p");
      CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (!v18)
      {
        *(void *)&long long buf = off_1ECF9A530;
        CFStringRef v20 = CFStringCreateWithCString(v19, "from existing connection", 0x8000100u);
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        *((void *)&buf + 1) = v20;
        uint64_t v35 = off_1ECF9A530;
        CFStringRef v21 = CFStringCreateWithCString(v19, "true", 0x8000100u);
        uint64_t v37 = 0;
        uint64_t v38 = 0;
        CFStringRef v36 = v21;
        (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v17 + 64))(v17, *((void *)&buf + 1), v21);
        AutoString::~AutoString((AutoString *)&v35);
        AutoString::~AutoString((AutoString *)&buf);
      }
      uint64_t v22 = *((unsigned int *)this + 62);
      unint64_t v23 = v22 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if ((v22 & 0x80000000) != 0)
      {
        *(void *)&long long buf = off_1ECF9A530;
        CFStringRef v24 = CFStringCreateWithCString(v19, "no cellular", 0x8000100u);
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        *((void *)&buf + 1) = v24;
        uint64_t v35 = off_1ECF9A530;
        CFStringRef v25 = CFStringCreateWithCString(v19, "true", 0x8000100u);
        uint64_t v37 = 0;
        uint64_t v38 = 0;
        CFStringRef v36 = v25;
        (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v17 + 64))(v17, *((void *)&buf + 1), v25);
        AutoString::~AutoString((AutoString *)&v35);
        AutoString::~AutoString((AutoString *)&buf);
        unint64_t v23 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      }
      if ((v23 & 0x100000000) != 0)
      {
        *(void *)&long long buf = off_1ECF9A530;
        CFStringRef v26 = CFStringCreateWithCString(v19, "persistent connection", 0x8000100u);
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        *((void *)&buf + 1) = v26;
        uint64_t v35 = off_1ECF9A530;
        CFStringRef v27 = CFStringCreateWithCString(v19, "true", 0x8000100u);
        uint64_t v37 = 0;
        uint64_t v38 = 0;
        CFStringRef v36 = v27;
        (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v17 + 64))(v17, *((void *)&buf + 1), v27);
        AutoString::~AutoString((AutoString *)&v35);
        AutoString::~AutoString((AutoString *)&buf);
      }
      if (*((void *)this + 67)) {
        goto LABEL_24;
      }
      if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0BE0))
      {
        *(void *)&long long buf = off_1ECF9A530;
        CFStringRef v28 = CFStringCreateWithCString(v19, "data connection service type", 0x8000100u);
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        *((void *)&buf + 1) = v28;
        (*(void (**)(uint64_t))(*(void *)v17 + 64))(v17);
        AutoString::~AutoString((AutoString *)&buf);
      }
      if (*((void *)this + 67))
      {
LABEL_24:
        *(void *)&long long buf = off_1ECF9A530;
        CFStringRef v29 = CFStringCreateWithCString(v19, "scoped interface", 0x8000100u);
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        *((void *)&buf + 1) = v29;
        (*(void (**)(uint64_t))(*(void *)v17 + 64))(v17);
        AutoString::~AutoString((AutoString *)&buf);
      }
      if (*((unsigned char *)this + 406))
      {
        *(void *)&long long buf = off_1ECF9A530;
        CFStringRef v30 = CFStringCreateWithCString(v19, "SO_RECV_ANYIF", 0x8000100u);
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        *((void *)&buf + 1) = v30;
        uint64_t v35 = off_1ECF9A530;
        CFStringRef v31 = CFStringCreateWithCString(v19, "set", 0x8000100u);
        uint64_t v37 = 0;
        uint64_t v38 = 0;
        CFStringRef v36 = v31;
        (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v17 + 64))(v17, *((void *)&buf + 1), v31);
        AutoString::~AutoString((AutoString *)&v35);
        AutoString::~AutoString((AutoString *)&buf);
      }
      if (a3)
      {
        *(void *)&long long buf = off_1ECF9A530;
        CFStringRef v32 = CFStringCreateWithCString(v19, "opportunistic", 0x8000100u);
        uint64_t v40 = 0;
        uint64_t v41 = 0;
        *((void *)&buf + 1) = v32;
        uint64_t v35 = off_1ECF9A530;
        CFStringRef v33 = CFStringCreateWithCString(v19, "true", 0x8000100u);
        uint64_t v37 = 0;
        uint64_t v38 = 0;
        CFStringRef v36 = v33;
        (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v17 + 64))(v17, *((void *)&buf + 1), v33);
        AutoString::~AutoString((AutoString *)&v35);
        AutoString::~AutoString((AutoString *)&buf);
      }
      return (*(uint64_t (**)(uint64_t))(*(void *)v17 + 8))(v17);
    }
  }
  return result;
}

void sub_18421A480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

void ___ZN12SocketStream37_onqueue_startTCPConnectionCompletionEhh_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  tcp_connection_retry();
  double v2 = *(double *)(v1 + 376) + *(double *)(v1 + 376);
  *(double *)(v1 + 376) = v2;
  uint64_t v3 = *(NSObject **)(v1 + 392);
  dispatch_time_t v4 = dispatch_time(0, (uint64_t)(v2 * 1000000000.0));

  dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
}

uint64_t ___ZN12SocketStream37_onqueue_startTCPConnectionCompletionEhh_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  double v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 4161;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream17setupSIMSchedulerEPK14__CFDictionaryhh_block_invoke(uint64_t a1)
{
  return SocketStream::_onqueue_startTCPConnectionCompletion(*(SocketStream **)(a1 + 32), *(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49));
}

uint64_t ___ZN12SocketStream17setupSIMSchedulerEPK14__CFDictionaryhh_block_invoke_236(uint64_t a1)
{
  v2.CFIndex domain = 1;
  *(void *)&v2.int error = 60;
  return SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(*(SocketStream **)(a1 + 32), v2);
}

void __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_pointer<SocketStream *,Deleter_release<SocketStream>,std::allocator<SocketStream>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    CFRelease((CFTypeRef)(v1 - 16));
  }
}

void std::__shared_ptr_pointer<SocketStream *,Deleter_release<SocketStream>,std::allocator<SocketStream>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke(uint64_t a1)
{
  return 1;
}

void ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke_228(uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  if (*(void *)(v3 + 448) || *(void *)(v3 + 456))
  {
    CFTypeRef v9 = 0;
    CFTypeRef cf = 0;
    SocketStream::retainOpenClientStreamsSafer(v2, (__CFReadStream **)&cf, (__CFWriteStream **)&v9);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(v4 + 448);
    if (v5) {
      BOOL v6 = cf == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (!v6)
    {
      (*(void (**)(void))(v5 + 16))();
      uint64_t v4 = *(void *)(a1 + 40);
    }
    uint64_t v7 = *(void *)(v4 + 456);
    if (v7) {
      BOOL v8 = v9 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8) {
      (*(void (**)(void))(v7 + 16))();
    }
    if (cf) {
      CFRelease(cf);
    }
    if (v9) {
      CFRelease(v9);
    }
  }
}

void ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke_231(uint64_t a1, int a2, CFTypeRef cf)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    CFTypeRef v4 = cf ? CFRetain(cf) : 0;
    uint64_t v5 = *(const void **)(v3 + 648);
    *(void *)(v3 + 648) = v4;
    if (v5)
    {
      CFRelease(v5);
    }
  }
}

void __destroy_helper_block_e8_40c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t SocketStream::retainOpenClientStreamsSafer(id *this, __CFReadStream **a2, __CFWriteStream **a3)
{
  BOOL v6 = (pthread_mutex_t *)(this + 5);
  pthread_mutex_lock((pthread_mutex_t *)(this + 5));
  if (a2)
  {
    if (((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x1000000000) != 0) {
      id WeakRetained = 0;
    }
    else {
      id WeakRetained = (__CFReadStream *)objc_loadWeakRetained(this + 34);
    }
    *a2 = WeakRetained;
  }
  if (a3)
  {
    if (((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x2000000000) != 0) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = (__CFWriteStream *)objc_loadWeakRetained(this + 35);
    }
    *a3 = v8;
  }

  return pthread_mutex_unlock(v6);
}

void SocketStream::cancelSIMScheduler(SocketStream *this)
{
  uint64_t v2 = (ConditionalConnectionSIMScheduler *)*((void *)this + 83);
  if (v2)
  {
    ConditionalConnectionSIMScheduler::cancel(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 84);
    *((void *)this + 83) = 0;
    *((void *)this + 84) = 0;
    if (v3)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
  }
}

uint64_t diagnosticLogTCPConnectionInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if ((tcp_connection_get_local() & 1) == 0)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      int v11 = 0;
      uint64_t v10 = 0;
    }
    if ((tcp_connection_get_remote() & 1) == 0)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 0;
      int v7 = 0;
      uint64_t v6 = 0;
    }
    tcp_connection_get_hostname();
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    int v11 = 0;
    uint64_t v10 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v4 = 0;
    int v7 = 0;
  }
  IOLogger::addrToName((uint64_t)&v8, __str);
  IOLogger::addrToName((uint64_t)&v4, v12);
  return (*(uint64_t (**)(uint64_t, const char *, __CFString *))(*(void *)a1 + 72))(a1, "connection", @"{ conn: %p, local %s => peer %s %s}");
}

uint64_t SocketStream::terminateConnectionIfAppropriate(SocketStream *this, int a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  CFDictionaryRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A09E8);
  if (Value)
  {
    uint64_t v6 = Value;
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
    }
    if ((const void *)*MEMORY[0x1E4F1CFD0] != v6) {
      goto LABEL_7;
    }
  }
  if (*((void *)this + 62))
  {
LABEL_7:
    BOOL v8 = 0;
    if (a2) {
      goto LABEL_8;
    }
LABEL_18:
    if (!v8) {
      return pthread_mutex_unlock(v4);
    }
    uint64_t v9 = (unsigned int *)((char *)this + 248);
    int v10 = (*((unsigned __int16 *)this + 126) >> 1) & 1;
    goto LABEL_20;
  }
  BOOL v8 = *((void *)this + 63) == 0;
  if (!a2) {
    goto LABEL_18;
  }
LABEL_8:
  if ((v8 & ~tcp_connection_is_multipath() & 1) == 0) {
    return pthread_mutex_unlock(v4);
  }
  uint64_t v9 = (unsigned int *)((char *)this + 248);
  int v10 = (*((unsigned __int16 *)this + 126) >> 1) & 1;
  if (!tcp_connection_is_cellular())
  {
LABEL_20:
    uint64_t v13 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_68, 2);
    if (v13)
    {
      uint64_t v14 = v13;
      if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v13 + 16))(v13, "_networkReachabilityChanged", 0))
      {
        diagnosticLogTCPConnectionInfo(v14, *((void *)this + 70));
        (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v14 + 72))(v14, "conn", @"%p -- setting stream error to ENOTCONN");
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      }
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    dispatch_time_t v15 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *((void *)this + 70);
      *(_DWORD *)long long buf = 134217984;
      uint64_t v27 = v16;
      _os_log_impl(&dword_184085000, v15, OS_LOG_TYPE_DEFAULT, "TCP Conn %p network reachability changed : setting stream error to ENOTCONN", buf, 0xCu);
    }
    __int16 v17 = *((_WORD *)this + 126);
    *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
    *((_WORD *)this + 126) = v17 | 2;
    BOOL v18 = 1;
    *((void *)this + 32) = 1;
    *((_DWORD *)this + 66) = 57;
    SocketStream::cleanupConnection_NoLock(this);
    id WeakRetained = objc_loadWeakRetained((id *)this + 34);
    CFStringRef v20 = WeakRetained;
    if (*((void *)this + 29)) {
      BOOL v18 = *((void *)this + 28) < 1;
    }
    if (v18 && WeakRetained)
    {
      if ((*v9 & 0x200) != 0) {
        _CFReadStreamSignalEventDelayed();
      }
    }
    else if (!WeakRetained)
    {
      goto LABEL_35;
    }
    CFRelease(v20);
LABEL_35:
    id v21 = objc_loadWeakRetained((id *)this + 35);
    if (v21)
    {
      uint64_t v22 = v21;
      if ((*v9 & 0x400) != 0) {
        _CFWriteStreamSignalEventDelayed();
      }
      CFRelease(v22);
    }
    goto LABEL_39;
  }
  uint64_t v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_62_6874, 2);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v11 + 16))(v11, "_networkReachabilityChanged", 0))
    {
      diagnosticLogTCPConnectionInfo(v12, *((void *)this + 70));
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v12 + 72))(v12, "conn", @"%p -- keeping alive");
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  if (!*((void *)this + 67)
    && !CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0BE0)
    && !CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_1EC0A0C18))
  {
    *((_WORD *)this + 126) = (*v9 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x200000000) >> 32;
  }
LABEL_39:
  unint64_t v23 = *v9 | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
  if (((v10 ^ ((v23 & 0x200000000) == 0)) & 1) == 0)
  {
    if ((v23 & 0x200000000) != 0) {
      CFStringRef v24 = (const void **)MEMORY[0x1E4F1CFD0];
    }
    else {
      CFStringRef v24 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    NotificationStation::notifyPropertyChanged((SocketStream *)((char *)this + 104), @"__kCFStreamPropertyDoNotReuse", *v24);
  }
  return pthread_mutex_unlock(v4);
}

uint64_t ___ZN12SocketStream33_onqueue_HandleTCPConnectionEventEjPKv_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 4024;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream32terminateConnectionIfAppropriateEh_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 3778;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream32terminateConnectionIfAppropriateEh_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 3764;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream33_onqueue_HandleTCPConnectionEventEjPKv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 4000;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

dispatch_queue_t ___ZL26copyGlobalTCPConnWorkQueuev_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue", 0);
  copyGlobalTCPConnWorkQueue(void)::sTCPConnWorkQueue = (uint64_t)result;
  return result;
}

CFStringRef virtual thunk to'SocketStream::copyDescription(SocketStream *this, const void *a2)
{
  return SocketStream::copyDescription((SocketStream *)((char *)this + *(void *)(*(void *)this - 40)), a2);
}

CFStringRef SocketStream::copyDescription(SocketStream *this, const void *a2)
{
  CFAllocatorRef v4 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v4, 0, @"<SocketStream %p>{flags = %p, read = %p, write = %p, socket = %@, properties = %p }", a2, (char *)this + 248, *((void *)this + 34), *((void *)this + 35), *((void *)this + 36), *((void *)this + 42));
}

void virtual thunk to'SocketStream::finalize(SocketStream *this, const void *a2)
{
}

void SocketStream::finalize(SocketStream *this, const void *a2)
{
  CFAllocatorRef v4 = (char *)this - 16;
  CFRetain((char *)this - 16);
  (*(void (**)(SocketStream *, const void *))(*(void *)this + 104))(this, a2);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  uint64_t v5 = (id *)((char *)this + 272);
  if (*((const void **)this + 34) != a2)
  {
    if (*((const void **)this + 35) != a2) {
      goto LABEL_5;
    }
    uint64_t v5 = (id *)((char *)this + 280);
  }
  objc_storeWeak(v5, 0);
  CFRelease(v4);
LABEL_5:
  uint64_t v6 = *((unsigned int *)this + 62);
  if ((v6 & 0x80) != 0)
  {
    unint64_t v8 = v6 & 0xFFFFFFFFFFFFFF7FLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = v6 & 0xFFFFFF7F;
    *((_WORD *)this + 126) = WORD2(v8);
    CFRelease(v4);
    goto LABEL_12;
  }
  if (!*((void *)this + 34) && !*((void *)this + 35))
  {
    CFTypeID v7 = (const void *)*((void *)this + 37);
    if (v7)
    {
      if (*((_DWORD *)this + 66))
      {
        *((void *)this + 37) = 0;
      }
      else
      {
        do
        {
          if (SSLClose(*((SSLContextRef *)this + 37)) != -9803) {
            break;
          }
          CFArrayRef v9 = (const __CFArray *)*((void *)this + 40);
          if (!v9) {
            break;
          }
          if (!CFArrayGetCount(v9)) {
            break;
          }
          CFRunLoopRef Current = CFRunLoopGetCurrent();
          _SchedulesAddRunLoopAndMode(*((const __CFArray **)this + 40), Current, @"_kCFStreamSocketSecurityClosePrivateMode");
          uint64_t v11 = *((void *)this + 41);
          CFRunLoopRef context = Current;
          uint64_t v20 = @"_kCFStreamSocketSecurityClosePrivateMode";
          v25.CFStringRef length = *(void *)(v11 + 24);
          v25.CFIndex location = 0;
          CFArrayApplyFunction(*(CFArrayRef *)(v11 + 16), v25, (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction, &context);
          pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
          CFRunLoopRunInMode(@"_kCFStreamSocketSecurityClosePrivateMode", 1.0e20, 1u);
          pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
          uint64_t v12 = *((void *)this + 41);
          CFRunLoopRef context = Current;
          uint64_t v20 = @"_kCFStreamSocketSecurityClosePrivateMode";
          v26.CFStringRef length = *(void *)(v12 + 24);
          v26.CFIndex location = 0;
          CFArrayApplyFunction(*(CFArrayRef *)(v12 + 16), v26, (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction, &context);
          _SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 40), Current, @"_kCFStreamSocketSecurityClosePrivateMode");
        }
        while (!*((_DWORD *)this + 66));
        CFTypeID v7 = (const void *)*((void *)this + 37);
        *((void *)this + 37) = 0;
        if (!v7) {
          goto LABEL_21;
        }
      }
      CFRelease(v7);
    }
LABEL_21:
    uint64_t v13 = *((void *)this + 41);
    v27.CFStringRef length = *(void *)(v13 + 24);
    v27.CFIndex location = 0;
    CFArrayApplyFunction(*(CFArrayRef *)(v13 + 16), v27, (CFArrayApplierFunction)Schedulables::_SchedulablesInvalidateApplierFunction, 0);
    uint64_t v14 = *((void *)this + 41);
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v14 + 16));
    *(void *)(v14 + 24) = 0;
    if (*((void *)this + 70) && *((void *)this + 71))
    {
      SocketStream::cleanupConnection_NoLock(this);
      CFRetain(v4);
      uint64_t v16 = *((void *)this + 71);
      CFRunLoopRef context = (CFRunLoopRef)MEMORY[0x1E4F143A8];
      uint64_t v20 = 3221225472;
      id v21 = ___ZN12SocketStream31finalizeCancelConnection_LockedEv_block_invoke;
      uint64_t v22 = &__block_descriptor_40_e5_v8__0l;
      unint64_t v23 = this;
      dispatch_async(v16, &context);
    }
    __int16 v17 = *((void *)this + 71);
    if (v17)
    {
      dispatch_release(v17);
      *((void *)this + 71) = 0;
    }
    if (*((void *)this + 36))
    {
      SocketStream::checkOutVoIPSocket(this, v15);
      *((_DWORD *)this + 62) |= 0x800u;
      CFSocketInvalidate(*((CFSocketRef *)this + 36));
    }
    BOOL v18 = (const void *)*((void *)this + 30);
    if (v18) {
      CFRelease(v18);
    }
    *((void *)this + 30) = 0;
  }
LABEL_12:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));

  CFRelease(v4);
}

void ___ZN12SocketStream31finalizeCancelConnection_LockedEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  if (*(unsigned char *)(v1 + 544))
  {
    *(unsigned char *)(v1 + 544) = 0;
    CFRelease((CFTypeRef)(v1 - 16));
  }
  if (*(unsigned char *)(v1 + 644))
  {
    *(unsigned char *)(v1 + 644) = 0;
    entr_act_end_delayInitStub(v2);
  }
  uint64_t v3 = *(NSObject **)(v1 + 384);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(v1 + 384));
    *(void *)(v1 + 384) = 0;
  }
  CFAllocatorRef v4 = *(NSObject **)(v1 + 392);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(v1 + 392));
    *(void *)(v1 + 392) = 0;
  }
  uint64_t v5 = *(void *)(v1 + 648);
  if (v5)
  {
    int v6 = *(unsigned __int8 *)(v1 + 656);
    double Helper_x8__OBJC_CLASS____DASScheduler = gotLoadHelper_x8__OBJC_CLASS____DASScheduler(v2);
    CFArrayRef v9 = objc_msgSend(*(id *)(v8 + 2648), "sharedScheduler", Helper_x8__OBJC_CLASS____DASScheduler);
    if (v6) {
      [v9 activityCompleted:v5];
    }
    else {
      [v9 activityCanceled:v5];
    }
    int v10 = *(const void **)(v1 + 648);
    *(void *)(v1 + 648) = 0;
    if (v10) {
      CFRelease(v10);
    }
  }
  SocketStream::cancelSIMScheduler((SocketStream *)v1);
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));

  CFRelease((CFTypeRef)(v1 - 16));
}

void SocketStream::closeStreams(SocketStream *this)
{
  CFRetain((char *)this - 16);
  double v2 = *((void *)this + 71);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN12SocketStream12closeStreamsEv_block_invoke;
  CFHostClientContext block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
}

void ___ZN12SocketStream12closeStreamsEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  double v2 = *(__CFReadStream **)(v1 + 200);
  if (v2)
  {
    if (CFReadStreamGetStatus(v2) <= kCFStreamStatusOpening) {
      CFReadStreamOpen(*(CFReadStreamRef *)(v1 + 200));
    }
    CFReadStreamClose(*(CFReadStreamRef *)(v1 + 200));
  }
  uint64_t v3 = *(__CFWriteStream **)(v1 + 208);
  if (v3)
  {
    if (CFWriteStreamGetStatus(v3) <= kCFStreamStatusOpening) {
      CFWriteStreamOpen(*(CFWriteStreamRef *)(v1 + 208));
    }
    CFWriteStreamClose(*(CFWriteStreamRef *)(v1 + 208));
  }
  CFAllocatorRef v4 = *(const void **)(v1 + 200);
  *(void *)(v1 + 200) = 0;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(v1 + 208);
  *(void *)(v1 + 208) = 0;
  if (v5) {
    CFRelease(v5);
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t SocketStream::copyProperty(id *this, const __CFString *a2)
{
  id WeakRetained = objc_loadWeakRetained(this + 34);
  if (!WeakRetained) {
    id WeakRetained = objc_loadWeakRetained(this + 35);
  }
  uint64_t v5 = (*((uint64_t (**)(id *, id, const __CFString *))*this + 14))(this, WeakRetained, a2);
  if (WeakRetained) {
    CFRelease(WeakRetained);
  }
  return v5;
}

void SocketStream::setNotificationProperty(SocketStream *this, int a2, CFStringRef theString, const void *a4)
{
  int ExactString = _findExactString(theString, 2u);
  if (ExactString > 90506881)
  {
    switch(ExactString)
    {
      case 106203045:
        uint64_t v8 = (const void **)((char *)this + 488);
        CFArrayRef v9 = (const void **)((char *)this + 480);
        break;
      case 96814834:
        uint64_t v8 = (const void **)((char *)this + 472);
        CFArrayRef v9 = (const void **)((char *)this + 464);
        break;
      case 90506882:
        uint64_t v8 = (const void **)((char *)this + 440);
        CFArrayRef v9 = (const void **)((char *)this + 432);
        break;
      default:
        return;
    }
    goto LABEL_14;
  }
  if (ExactString == 83273191)
  {
    uint64_t v8 = (const void **)((char *)this + 456);
    CFArrayRef v9 = (const void **)((char *)this + 448);
LABEL_14:
    if (a2) {
      int v10 = v9;
    }
    else {
      int v10 = v8;
    }
    goto LABEL_17;
  }
  if (ExactString != 84248066)
  {
    if (ExactString != 89532009) {
      return;
    }
    uint64_t v8 = (const void **)((char *)this + 504);
    CFArrayRef v9 = (const void **)((char *)this + 496);
    goto LABEL_14;
  }
  int v10 = (const void **)((char *)this + 512);
LABEL_17:
  if (*v10)
  {
    _Block_release(*v10);
    *int v10 = 0;
  }
  if (a4) {
    *int v10 = _Block_copy(a4);
  }
}

void SocketStream::setProperties(SocketStream *this, CFDictionaryRef theDict)
{
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = ___ZN12SocketStream13setPropertiesEPK14__CFDictionary_block_invoke;
  context[3] = &__block_descriptor_40_e25_v24__0____CFString__8_v16l;
  context[4] = this;
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)_apply_block, context);
}

uint64_t ___ZN12SocketStream13setPropertiesEPK14__CFDictionary_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 200))();
}

uint64_t SocketStream::setProperty(id *this, const __CFString *a2, const void *a3)
{
  id WeakRetained = objc_loadWeakRetained(this + 34);
  if (!WeakRetained) {
    id WeakRetained = objc_loadWeakRetained(this + 35);
  }
  uint64_t v7 = (*((uint64_t (**)(id *, id, const __CFString *, const void *))*this + 15))(this, WeakRetained, a2, a3);
  if (WeakRetained) {
    CFRelease(WeakRetained);
  }
  return v7;
}

uint64_t SocketStream::beginConnection(SocketStream *this)
{
  CFRetain((char *)this - 16);
  double v2 = *((void *)this + 71);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN12SocketStream15beginConnectionEv_block_invoke;
  CFHostClientContext block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
  return 1;
}

void ___ZN12SocketStream15beginConnectionEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(CFWriteStreamRef **)(a1 + 32);
  (*((void (**)(CFWriteStreamRef *, unsigned char *, unsigned char *))*v1 + 8))(v1, (unsigned char *)v1 + 200, (unsigned char *)v1 + 208);
  *((unsigned char *)v1 + 193) = 1;
  clientContext.version = 0;
  clientContext.info = v1;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  CFWriteStreamSetClient(v1[26], 0xCuLL, (CFWriteStreamClientCallBack)SocketStream::_beginConnection_streamEvent, &clientContext);
  MEMORY[0x18531A970](v1[26], v1[71]);
  CFWriteStreamOpen(v1[26]);
  CFRelease(v1 - 2);
}

void SocketStream::_beginConnection_streamEvent(SocketStream *this, __CFWriteStream *a2, uint64_t a3, void *a4)
{
  uint64_t v5 = (const void *)(a3 - 16);
  CFRetain((CFTypeRef)(a3 - 16));
  uint64_t v6 = *(void *)(a3 + 208);
  if (v6)
  {
    MEMORY[0x18531A970](v6, 0);
    CFWriteStreamSetClient(*(CFWriteStreamRef *)(a3 + 208), 0, 0, 0);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 184))(a3);
  if (v7)
  {
    uint64_t v8 = v7;
    (*(void (**)(uint64_t, void, void))(*(void *)v7 + 64))(v7, *(void *)(a3 + 200), *(void *)(a3 + 208));
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  CFArrayRef v9 = *(const void **)(a3 + 200);
  *(void *)(a3 + 200) = 0;
  if (v9) {
    CFRelease(v9);
  }
  int v10 = *(const void **)(a3 + 208);
  *(void *)(a3 + 208) = 0;
  if (v10) {
    CFRelease(v10);
  }

  CFRelease(v5);
}

uint64_t SocketStream::copyConnectionEstablishment(os_unfair_lock_s *this)
{
  double v2 = this + 106;
  os_unfair_lock_lock(this + 106);
  uint64_t v3 = *(void *)&this[104]._os_unfair_lock_opaque;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

void SocketStream::setConnectionEstablishment(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v4 = (os_unfair_lock_s *)(a1 + 424);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 424));
  uint64_t v5 = *(void *)(a1 + 416);
  if (v5 != a2)
  {
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    }
    *(void *)(a1 + 4CFRetain((char *)this - 16) = a2;
    if (a2) {
      (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
    }
  }
  os_unfair_lock_unlock(v4);
  if (*(void *)(a1 + 296))
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 184))(a1);
    SSLSetSessionOption(*(SSLContextRef *)(a1 + 296), kSSLSessionOptionBreakOnCertRequested, v6 != 0);
    SSLSetSessionOption(*(SSLContextRef *)(a1 + 296), kSSLSessionOptionBreakOnServerAuth, v6 != 0);
    if (v6)
    {
      uint64_t v7 = *(void (**)(uint64_t))(*(void *)v6 + 24);
      v7(v6);
    }
  }
}

uint64_t SocketStream::unschedule(SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v8 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  SocketStream::unschedule_NoLock(this, a2, a3, a4);

  return pthread_mutex_unlock(v8);
}

uint64_t SocketStream::schedule(SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v8 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  SocketStream::schedule_NoLock(this, a2, a3, a4);

  return pthread_mutex_unlock(v8);
}

uint64_t SocketStream::openCompleted(SocketStream *this, const void *a2, CFStreamError *a3)
{
  return SocketStream::streamCan((uint64_t)this, a2, 0, @"_kCFStreamSocketOpenCompletedPrivateMode", a3);
}

uint64_t SocketStream::captureStreams(SocketStream *this, __CFReadStream **a2, __CFWriteStream **a3)
{
  if (*((unsigned char *)this + 193)) {
    return 0;
  }
  if (a2)
  {
    CFGetAllocator((char *)this - 16);
    uint64_t v7 = (__CFReadStream *)CFReadStreamCreate();
    *a2 = v7;
    objc_storeWeak((id *)this + 34, v7);
    if (*a2) {
      CFRetain((char *)this - 16);
    }
  }
  if (a3)
  {
    CFGetAllocator((char *)this - 16);
    uint64_t v8 = (__CFWriteStream *)CFWriteStreamCreate();
    *a3 = v8;
    objc_storeWeak((id *)this + 35, v8);
    if (*a3) {
      CFRetain((char *)this - 16);
    }
  }
  if (!a2) {
    return 1;
  }
  uint64_t result = 1;
  if (a3 && *a2 && *a3)
  {
    int v10 = *((_DWORD *)this + 62);
    CFArrayRef v9 = (int *)((char *)this + 248);
    *CFArrayRef v9 = v10 | 0x80;
    CFRetain(v9 - 66);
    return 1;
  }
  return result;
}

__CFHost *SocketStream::initialize(CFMutableDictionaryRef *this, const __CFString *a2, const __CFAllocator *a3)
{
  uint64_t v6 = this - 2;
  CFAllocatorRef v7 = CFGetAllocator(this - 2);
  uint64_t v8 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(v7, a2, (const __CFAllocator *)(unsigned __int16)a3);
  if (v8 || (v9 = CFGetAllocator(v6), result = CFHostCreateWithName(v9, a2), (uint64_t v8 = result) != 0))
  {
    SocketStream::initialize(this, v8, a3);
    CFRelease(v8);
    return (__CFHost *)1;
  }
  return result;
}

void SocketStream::initialize(CFMutableDictionaryRef *this, __CFHost *a2, const __CFAllocator *a3)
{
  SocketStream::commonInitialization((SocketStream *)this);
  CFAllocatorRef v6 = CFGetAllocator(this - 2);
  CFHostRef Copy = CFHostCreateCopy(v6, a2);
  CFDictionaryAddValue(this[42], &unk_1EC0A0FD0, Copy);
  uint64_t v8 = this[42];
  AutoScalar::AutoScalar((AutoScalar *)&v9, a3);
  CFDictionaryAddValue(v8, &unk_1EC0A1078, value);
  CFAllocatorRef v9 = &unk_1ECF9A500;
  if (value) {
    CFRelease(value);
  }
  CFRelease(Copy);
}

void sub_18421C07C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SocketStream::commonInitialization(SocketStream *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  uint64_t v3 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  *((void *)this + 38) = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  *((void *)this + 39) = CFArrayCreateMutable(v2, 0, v3);
  *((void *)this + 40) = CFArrayCreateMutable(v2, 0, v3);
  CFAllocatorRef v4 = CFAllocatorAllocate(v2, 32, 0);
  v4[2] = 0;
  v4[3] = 0;
  void *v4 = &unk_1ECF9BF48;
  v4[1] = v2;
  v4[2] = CFArrayCreateMutable(v2, 0, v3);
  v4[3] = 0;
  *((void *)this + 41) = v4;
  CFArrayRef Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((void *)this + 42) = Mutable;
  CFDictionarySetValue(Mutable, &unk_1EC0A0C50, (const void *)*MEMORY[0x1E4F1CFD0]);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFAllocatorRef v6 = pthread_self();
  mach_port_t v10 = pthread_mach_thread_np(v6);
  pid_t v11 = getpid();
  uint64_t v12 = "CFSocketStream";
  uint64_t v13 = "ioLogger";
  uint64_t v14 = 0;
  double v15 = this;
  uint64_t v16 = "socketstream";
  *((void *)this + 27) = IOLogger::newLogger((IOLogger *)&Current, v7);
  uint64_t result = copyGlobalTCPConnWorkQueue();
  *((void *)this + 71) = result;
  return result;
}

void Schedulables::~Schedulables(Schedulables *this)
{
  *(void *)this = &unk_1ECF9BF48;
  CFAllocatorRef v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);

  CFAllocatorDeallocate(v3, this);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9BF48;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

CFStringRef SocketStream::copyDebugDesc(SocketStream *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = (__CFSocket *)*((void *)this + 36);
  if (v2) {
    CFSocketNativeHandle Native = CFSocketGetNative(v2);
  }
  else {
    CFSocketNativeHandle Native = -1;
  }
  snprintf(__str, 0x100uLL, "{ fd %d }", Native);
  CFAllocatorRef v4 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v4, 0, @"<SocketStream@%p> %s", this, __str);
}

CFSetRef ___ZN12SocketStream20observablePropertiesEv_block_invoke()
{
  if ((_ZGVZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable & 1) == 0)
  {
    _ZZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable = 0x1EC09E8A8;
    _ZGVZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable = 1;
  }
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&_ZZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable, 1, MEMORY[0x1E4F1D548]);
  SocketStream::observableProperties(void)::observableProps = (uint64_t)result;
  return result;
}

void SocketStream::initialize(CFMutableDictionaryRef *this, __CFNetService *a2)
{
  SocketStream::commonInitialization((SocketStream *)this);
  CFAllocatorRef v4 = CFGetAllocator(this - 2);
  CFNetServiceRef Copy = CFNetServiceCreateCopy(v4, a2);
  CFDictionaryAddValue(this[42], &unk_1EC0A1040, Copy);

  CFRelease(Copy);
}

uint64_t ReadStreamCallbacks::_finalize(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(void *)((char *)a2
                                                                              + *(void *)(*(void *)a2 - 136))
                                                                  + 16))((char *)a2 + *(void *)(*(void *)a2 - 136), this);
}

uint64_t ReadStreamCallbacks::_copyDescription(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(void *)((char *)a2
                                                                              + *(void *)(*(void *)a2 - 136))
                                                                  + 24))((char *)a2 + *(void *)(*(void *)a2 - 136), this);
}

uint64_t ReadStreamCallbacks::_open(ReadStreamCallbacks *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(unsigned __int8 *, ReadStreamCallbacks *, __CFReadStream *, CFStreamError *))(*(void *)&a4[*(void *)(*(void *)a4 - 136)] + 32))(&a4[*(void *)(*(void *)a4 - 136)], this, a2, a3);
}

uint64_t ReadStreamCallbacks::_openCompleted(ReadStreamCallbacks *this, __CFReadStream *a2, CFStreamError *a3, void *a4)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *, __CFReadStream *))(*(CFIndex *)((char *)&a3->domain
                                                                                                 + *(void *)(a3->domain - 136))
                                                                                    + 40))((char *)a3 + *(void *)(a3->domain - 136), this, a2);
}

uint64_t ReadStreamCallbacks::_read(ReadStreamCallbacks *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6, void *a7)
{
  return (*(uint64_t (**)(unsigned __int8 *, ReadStreamCallbacks *, __CFReadStream *, unsigned __int8 *, uint64_t, CFStreamError *))(*(void *)&a6[*(void *)(*(void *)a6 - 136)] + 88))(&a6[*(void *)(*(void *)a6 - 136)], this, a2, a3, a4, a5);
}

uint64_t ReadStreamCallbacks::_canRead(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(void *)((char *)a2
                                                                              + *(void *)(*(void *)a2 - 136))
                                                                  + 96))((char *)a2 + *(void *)(*(void *)a2 - 136), this);
}

uint64_t ReadStreamCallbacks::_close(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(void *)((char *)a2
                                                                              + *(void *)(*(void *)a2 - 136))
                                                                  + 48))((char *)a2 + *(void *)(*(void *)a2 - 136), this);
}

uint64_t ReadStreamCallbacks::_copyProperty(ReadStreamCallbacks *this, __CFReadStream *a2, const __CFString *a3, void *a4)
{
  return (*(uint64_t (***)(char *, ReadStreamCallbacks *, __CFReadStream *))((char *)&a3->isa
                                                                                     + *((void *)a3->isa - 17)))[7]((char *)a3 + *((void *)a3->isa - 17), this, a2);
}

uint64_t ReadStreamCallbacks::_setProperty(ReadStreamCallbacks *this, __CFReadStream *a2, const __CFString *a3, char *a4, void *a5)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *, __CFReadStream *, const __CFString *))(*(void *)&a4[*(void *)(*(void *)a4 - 136)] + 64))(&a4[*(void *)(*(void *)a4 - 136)], this, a2, a3);
}

uint64_t ReadStreamCallbacks::_schedule(ReadStreamCallbacks *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, ReadStreamCallbacks *, __CFReadStream *, __CFRunLoop *))((char *)&a4->isa + *((void *)a4->isa - 17)))[9]((char *)a4 + *((void *)a4->isa - 17), this, a2, a3);
}

uint64_t ReadStreamCallbacks::_unschedule(ReadStreamCallbacks *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, ReadStreamCallbacks *, __CFReadStream *, __CFRunLoop *))((char *)&a4->isa + *((void *)a4->isa - 17)))[10]((char *)a4 + *((void *)a4->isa - 17), this, a2, a3);
}

uint64_t WriteStreamCallbacks::_finalize(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(void *)((char *)a2
                                                                               + *(void *)(*(void *)a2 - 136))
                                                                   + 16))((char *)a2 + *(void *)(*(void *)a2 - 136), this);
}

uint64_t WriteStreamCallbacks::_copyDescription(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(void *)((char *)a2
                                                                               + *(void *)(*(void *)a2 - 136))
                                                                   + 24))((char *)a2 + *(void *)(*(void *)a2 - 136), this);
}

uint64_t WriteStreamCallbacks::_open(WriteStreamCallbacks *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(unsigned __int8 *, WriteStreamCallbacks *, __CFWriteStream *, CFStreamError *))(*(void *)&a4[*(void *)(*(void *)a4 - 136)] + 32))(&a4[*(void *)(*(void *)a4 - 136)], this, a2, a3);
}

uint64_t WriteStreamCallbacks::_openCompleted(WriteStreamCallbacks *this, __CFWriteStream *a2, CFStreamError *a3, void *a4)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *, __CFWriteStream *))(*(CFIndex *)((char *)&a3->domain + *(void *)(a3->domain - 136))
                                                                                      + 40))((char *)a3 + *(void *)(a3->domain - 136), this, a2);
}

uint64_t WriteStreamCallbacks::_write(WriteStreamCallbacks *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, void *a6)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *, __CFWriteStream *, const unsigned __int8 *, uint64_t))(*(CFIndex *)((char *)&a5->domain + *(void *)(a5->domain - 136)) + 104))((char *)a5 + *(void *)(a5->domain - 136), this, a2, a3, a4);
}

uint64_t WriteStreamCallbacks::_canWrite(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(void *)((char *)a2
                                                                               + *(void *)(*(void *)a2 - 136))
                                                                   + 112))((char *)a2 + *(void *)(*(void *)a2 - 136), this);
}

uint64_t WriteStreamCallbacks::_close(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(void *)((char *)a2
                                                                               + *(void *)(*(void *)a2 - 136))
                                                                   + 48))((char *)a2 + *(void *)(*(void *)a2 - 136), this);
}

uint64_t WriteStreamCallbacks::_copyProperty(WriteStreamCallbacks *this, __CFWriteStream *a2, const __CFString *a3, void *a4)
{
  return (*(uint64_t (***)(char *, WriteStreamCallbacks *, __CFWriteStream *))((char *)&a3->isa
                                                                                       + *((void *)a3->isa - 17)))[7]((char *)a3 + *((void *)a3->isa - 17), this, a2);
}

uint64_t WriteStreamCallbacks::_setProperty(WriteStreamCallbacks *this, __CFWriteStream *a2, const __CFString *a3, char *a4, void *a5)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *, __CFWriteStream *, const __CFString *))(*(void *)&a4[*(void *)(*(void *)a4 - 136)] + 64))(&a4[*(void *)(*(void *)a4 - 136)], this, a2, a3);
}

uint64_t WriteStreamCallbacks::_schedule(WriteStreamCallbacks *this, __CFWriteStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, WriteStreamCallbacks *, __CFWriteStream *, __CFRunLoop *))((char *)&a4->isa + *((void *)a4->isa - 17)))[9]((char *)a4 + *((void *)a4->isa - 17), this, a2, a3);
}

uint64_t WriteStreamCallbacks::_unschedule(WriteStreamCallbacks *this, __CFWriteStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, WriteStreamCallbacks *, __CFWriteStream *, __CFRunLoop *))((char *)&a4->isa + *((void *)a4->isa - 17)))[10]((char *)a4 + *((void *)a4->isa - 17), this, a2, a3);
}

void sub_18421D328(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30)
{
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  }
  if (a30) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a30);
  }
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v30);
  }
  _Unwind_Resume(exception_object);
}

void std::allocate_shared[abi:nn180100]<TCPIO_Delegate,std::allocator<TCPIO_Delegate>,std::shared_ptr<TransportConnectionObjCPP> &,void>(void *a1, uint64_t a2, std::__shared_weak_count *a3)
{
  CFAllocatorRef v6 = operator new(0x78uLL);
  uint64_t v7 = v6;
  v6[1] = 0;
  v6[2] = 0;
  *CFAllocatorRef v6 = &unk_1ECFA6800;
  uint64_t v8 = v6 + 3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v6[6] = 0;
  _OWORD v6[4] = 0;
  v6[5] = 0;
  v6[3] = &unk_1ECF9D030;
  v6[7] = 0;
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    v6[6] = a2;
    v6[7] = a3;
  }
  else
  {
    v6[6] = a2;
  }
  uint64_t v9 = *(void *)(a2 + 24);
  uint64_t v10 = *(void *)(v9 + 120);
  if (v10) {
    dispatch_retain(*(dispatch_object_t *)(v9 + 120));
  }
  v7[8] = v10;
  v7[9] = 0;
  *((_DWORD *)v7 + 20) = 0;
  *((_WORD *)v7 + 44) = 0;
  *((unsigned char *)v7 + 90) = 0;
  v7[12] = 0;
  *((_DWORD *)v7 + 26) = 0;
  *((_WORD *)v7 + 56) = 0;
  if (a3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a3);
  }
  *a1 = v8;
  a1[1] = v7;
  pid_t v11 = (std::__shared_weak_count *)v7[5];
  if (v11)
  {
    if (v11->__shared_owners_ != -1) {
      return;
    }
    atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(v7 + 2, 1uLL, memory_order_relaxed);
    v7[4] = v8;
    void v7[5] = v7;
    std::__shared_weak_count::__release_weak(v11);
  }
  else
  {
    atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(v7 + 2, 1uLL, memory_order_relaxed);
    v7[4] = v8;
    void v7[5] = v7;
  }

  std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v7);
}

void sub_18421D64C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_18421D708(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t __NSCFTCPIOWriteStream::__NSCFTCPIOWriteStream(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  *(void *)(a1 + CFRetain((char *)this - 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_1ECFA0FA0;
  *(void *)(a1 + 8) = a2;
  uint64_t v6 = a1 + 32;
  *(void *)(a1 + 32) = &unk_1ECFA4A88;
  *(void *)(a1 + 88) = a4;
  *(_DWORD *)(a1 + 96) = 1;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)a1 = &unk_1ECFA2660;
  *(void *)(a1 + 32) = &unk_1ECFA26E0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  uint64_t v7 = *a3;
  uint64_t v8 = a3[1];
  if (v8)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 112);
    *(void *)(a1 + 104) = v7;
    *(void *)(a1 + 112) = v8;
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
    }
  }
  else
  {
    *(void *)(a1 + 104) = v7;
    *(void *)(a1 + 112) = 0;
  }
  uint64_t v10 = *(void *)(a1 + 88);
  if (v10)
  {
    uint64_t v11 = 16;
    if (!*(_DWORD *)(a1 + 96)) {
      uint64_t v11 = 8;
    }
    *(void *)(v10 + v11) = v6;
  }
  return a1;
}

void sub_18421D8A0(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_1ECF9B550;
  v1[1] = 0;
  CFAllocatorRef v3 = (std::__shared_weak_count *)v1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'__NSCFTCPIOWriteStream::streamObject(__NSCFTCPIOWriteStream *this)
{
  return *((void *)this - 3);
}

void non-virtual thunk to'__NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream(__NSCFTCPIOWriteStream *this)
{
  __NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream((__NSCFTCPIOWriteStream *)((char *)this - 32));

  JUMPOUT(0x18531B6D0);
}

{
  __NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream((__NSCFTCPIOWriteStream *)((char *)this - 32));
}

void __NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream(__NSCFTCPIOWriteStream *this)
{
  *(void *)this = &unk_1ECFA2660;
  uint64_t v2 = (TCPIO_BlockCallbacks_Listener *)((char *)this + 32);
  *((void *)this + 4) = &unk_1ECFA26E0;
  uint64_t v3 = *((void *)this + 13);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v10, *(void *)(v3 + 8), *(std::__shared_weak_count **)(v3 + 16));
  CFAllocatorRef v4 = *(NSObject **)(v3 + 40);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3321888768;
  v8[2] = ___ZN14TCPIO_Delegate18writeSideFinalizedEv_block_invoke;
  v8[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  v8[4] = v10;
  uint64_t v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_async(v4, v8);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 14);
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 14);
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }
  *((void *)this + 4) = &unk_1ECFA4A88;
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(v2);

  *(void *)this = &unk_1ECF9B550;
  *((void *)this + 1) = 0;
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

{
  uint64_t vars8;

  __NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream(this);

  JUMPOUT(0x18531B6D0);
}

void sub_18421DA88(_Unwind_Exception *a1)
{
  CFAllocatorRef v4 = (std::__shared_weak_count *)v1[14];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  TCPIO_BlockCallbacks_Listener::~TCPIO_BlockCallbacks_Listener(v2);
  *uint64_t v1 = &unk_1ECF9B550;
  v1[1] = 0;
  uint64_t v5 = (std::__shared_weak_count *)v1[3];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

void TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(TCPIO_BlockCallbacks_Listener *this)
{
  id var0 = this->var1.var0;
  if (var0)
  {
    _Block_release(var0);
    this->var1.id var0 = 0;
  }
  id var1 = this->var1.var1;
  if (var1)
  {
    _Block_release(var1);
    this->var1.id var1 = 0;
  }
  id var2 = this->var1.var2;
  if (var2)
  {
    _Block_release(var2);
    this->var1.id var2 = 0;
  }
  id var3 = this->var1.var3;
  if (var3)
  {
    _Block_release(var3);
    this->var1.id var3 = 0;
  }
  id var4 = this->var1.var4;
  if (var4)
  {
    _Block_release(var4);
    this->var1.id var4 = 0;
  }
  id var5 = this->var1.var5;
  if (var5)
  {
    _Block_release(var5);
    this->var1.id var5 = 0;
  }
  uint64_t v8 = (char *)this->var2;
  if (v8)
  {
    uint64_t v9 = 16;
    if (!this->var3) {
      uint64_t v9 = 8;
    }
    *(void *)&v8[v9] = 0;
  }
}

void TCPIO_BlockCallbacks_Listener::~TCPIO_BlockCallbacks_Listener(TCPIO_BlockCallbacks_Listener *this)
{
  this->id var0 = (void **)&unk_1ECFA4A88;
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(this);
}

void ___ZN14TCPIO_Delegate18writeSideFinalizedEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(TCPIO_Delegate **)(a1 + 32);
  *((unsigned char *)v1 + 89) = 1;
  if (*((unsigned char *)v1 + 66)) {
    TCPIO_Delegate::_onqueue_bothSidesFinalized(v1);
  }
}

void __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void TCPIO_Delegate::_onqueue_bothSidesFinalized(TCPIO_Delegate *this)
{
  if (!*((unsigned char *)this + 66) || !*((unsigned char *)this + 89)) {
    __assert_rtn("_onqueue_bothSidesFinalized", "LocalTCPIOStreamTask.mm", 769, "_readFinalized && _writeFinalized");
  }
  if (!*((unsigned char *)this + 65))
  {
    *((unsigned char *)this + 65) = 1;
    if (*((unsigned char *)this + 88))
    {
      uint64_t v5 = *((void *)this + 3);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 24);
        if (v6)
        {
          if (!*(unsigned char *)(v5 + 40))
          {
            *(unsigned char *)(v5 + 40) = 1;
            (*(void (**)(uint64_t, void))(*(void *)v6 + 152))(v6, 0);
          }
        }
      }
    }
  }
  if (!*((unsigned char *)this + 88))
  {
    *((unsigned char *)this + 88) = 1;
    if (*((unsigned char *)this + 65))
    {
      uint64_t v7 = *((void *)this + 3);
      if (v7)
      {
        uint64_t v8 = *(void *)(v7 + 24);
        if (v8)
        {
          if (!*(unsigned char *)(v7 + 40))
          {
            *(unsigned char *)(v7 + 40) = 1;
            (*(void (**)(uint64_t, void))(*(void *)v8 + 152))(v8, 0);
          }
        }
      }
    }
  }
  uint64_t v2 = (void *)((char *)this + 24);
  if (*((void *)this + 3))
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 4);
    if (v3)
    {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
      CFAllocatorRef v4 = (std::__shared_weak_count *)*((void *)this + 4);
      *uint64_t v2 = 0;
      *((void *)this + 4) = 0;
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v4);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
    else
    {
      *uint64_t v2 = 0;
      *((void *)this + 4) = 0;
    }
  }
}

uint64_t __NSCFTCPIOWriteStream::streamObject(__NSCFTCPIOWriteStream *this)
{
  return *((void *)this + 1);
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_SetProperty(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2, const __CFString *a3, const void *a4)
{
  return 1;
}

void **TCPIO_BlockCallbacks_Listener::listenerSetProperty(TCPIO_BlockCallbacks_Listener *this, const __CFString *a2, const void *a3)
{
  CFSetRef result = TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(this, a2);
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = *result;
    if (v6)
    {
      _Block_release(v6);
      *uint64_t v5 = 0;
    }
    if (a3) {
      *uint64_t v5 = _Block_copy(a3);
    }
    return (void **)1;
  }
  return result;
}

void TCPIO_Delegate::setProperty(TCPIO_Delegate *this, CFTypeRef cf, CFTypeRef a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  uint64_t v6 = *((void *)this + 3);
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = *((void *)this + 5);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3321888768;
  v9[2] = ___ZN14TCPIO_Delegate11setPropertyEPK10__CFStringPKv_block_invoke;
  v9[3] = &__block_descriptor_64_e8_32c53_ZTSNSt3__110shared_ptrI25TransportConnectionObjCPPEE_e5_v8__0l;
  v9[4] = v6;
  uint64_t v10 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CFTypeRef v11 = cf;
  CFTypeRef v12 = a3;
  dispatch_async(v8, v9);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
}

void ___ZN14TCPIO_Delegate11setPropertyEPK10__CFStringPKv_block_invoke(void *a1)
{
  (*(void (**)(void, void, void))(**(void **)(a1[4] + 24) + 200))(*(void *)(a1[4] + 24), a1[6], a1[7]);
  uint64_t v2 = (const void *)a1[6];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[7];
  if (v3)
  {
    CFRelease(v3);
  }
}

void __destroy_helper_block_e8_32c53_ZTSNSt3__110shared_ptrI25TransportConnectionObjCPPEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c53_ZTSNSt3__110shared_ptrI25TransportConnectionObjCPPEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

id *TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(TCPIO_BlockCallbacks_Listener *this, CFStringRef theString)
{
  int ExactString = _findExactString(theString, 2u);
  p_id var1 = &this->var1;
  if (ExactString != 96814834) {
    p_id var1 = 0;
  }
  if (ExactString == 106203045) {
    p_id var0 = &this->var1.var1;
  }
  else {
    p_id var0 = &p_var1->var0;
  }
  if (ExactString == 90506882) {
    p_id var4 = &this->var1.var4;
  }
  else {
    p_id var4 = p_var0;
  }
  p_id var2 = &this->var1.var2;
  if (ExactString != 89532009) {
    p_id var2 = 0;
  }
  if (ExactString == 84248066) {
    p_id var3 = &this->var1.var3;
  }
  else {
    p_id var3 = p_var2;
  }
  if (ExactString == 83273191) {
    p_id var5 = &this->var1.var5;
  }
  else {
    p_id var5 = p_var3;
  }
  if (ExactString <= 90506881) {
    return p_var5;
  }
  else {
    return p_var4;
  }
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_CopyProperty(TCPIO_Delegate **this, __CFWriteStream *a2, const __CFString *a3)
{
  return TCPIO_Delegate::copyProperty(this[13], a3);
}

uint64_t TCPIO_Delegate::copyProperty(TCPIO_Delegate *this, const __CFString *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  uint64_t v2 = *((void *)this + 5);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZNK14TCPIO_Delegate12copyPropertyEPK10__CFString_block_invoke;
  CFHostClientContext block[3] = &unk_1E5257A50;
  block[4] = &v6;
  void block[5] = this;
  block[6] = a2;
  dispatch_sync(v2, block);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t ___ZNK14TCPIO_Delegate12copyPropertyEPK10__CFString_block_invoke(void *a1)
{
  uint64_t v2 = a1[6];
  uint64_t v3 = *(void *)(*(void *)(a1[5] + 24) + 24);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 216))(v3, v2);
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

void __NSCFTCPIOWriteStream::_streamImpl_Close(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2)
{
  TCPIO_Delegate::closeWriteSide(*((TCPIO_Delegate **)this + 13));

  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks((TCPIO_BlockCallbacks_Listener *)((char *)this + 32));
}

void TCPIO_Delegate::closeWriteSide(TCPIO_Delegate *this)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v5, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
  uint64_t v2 = *((void *)this + 5);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3321888768;
  v3[2] = ___ZN14TCPIO_Delegate14closeWriteSideEv_block_invoke;
  v3[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  v3[4] = v5;
  CFAllocatorRef v4 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_async(v2, v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void *___ZN14TCPIO_Delegate14closeWriteSideEv_block_invoke(void *result)
{
  uint64_t v1 = result[4];
  *(unsigned char *)(v1 + 88) = 1;
  if (*(unsigned char *)(v1 + 65))
  {
    uint64_t v2 = *(void *)(v1 + 24);
    if (v2)
    {
      uint64_t result = *(void **)(v2 + 24);
      if (result)
      {
        if (!*(unsigned char *)(v2 + 40))
        {
          *(unsigned char *)(v2 + 40) = 1;
          return (void *)(*(uint64_t (**)(void *, void))(*result + 152))(result, 0);
        }
      }
    }
  }
  return result;
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_CanWrite(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2)
{
  return 1;
}

size_t __NSCFTCPIOWriteStream::_streamImpl_Write(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, size_t a4, CFStreamError *a5)
{
  uint64_t v9 = *((void *)this + 13);
  uint64_t v10 = *(NSObject **)(v9 + 40);
  blocCFIndex k = MEMORY[0x1E4F143A8];
  uint64_t v18 = 3221225472;
  CFAllocatorRef v19 = ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke;
  uint64_t v20 = &__block_descriptor_48_e5_v8__0l;
  id v21 = v9;
  uint64_t v22 = a5;
  dispatch_sync(v10, &block);
  if (a5->domain && a5->error) {
    return -1;
  }
  CFTypeRef v11 = dispatch_data_create(a3, a4, 0, 0);
  uint64_t v12 = *((void *)this + 1);
  if (v12) {
    CFRetain(*((CFTypeRef *)this + 1));
  }
  uint64_t v13 = *((void *)this + 13);
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  void v16[2] = ___ZN22__NSCFTCPIOWriteStream17_streamImpl_WriteEP15__CFWriteStreamPKhlP13CFStreamError_block_invoke;
  v16[3] = &__block_descriptor_40_e5_v8__0l;
  v16[4] = v12;
  dispatch_retain(v11);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v25, *(void *)(v13 + 8), *(std::__shared_weak_count **)(v13 + 16));
  uint64_t v14 = *(NSObject **)(v13 + 40);
  blocCFIndex k = MEMORY[0x1E4F143A8];
  uint64_t v18 = 3321888768;
  CFAllocatorRef v19 = ___ZN14TCPIO_Delegate9writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke;
  uint64_t v20 = &unk_1ECFA9BF8;
  uint64_t v23 = v25;
  CFStringRef v24 = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v21 = v11;
  uint64_t v22 = (CFStreamError *)v16;
  dispatch_async(v14, &block);
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v24);
  }
  if (v26) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v26);
  }
  dispatch_release(v11);
  return a4;
}

__n128 ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke(uint64_t a1)
{
  __n128 result = *(__n128 *)(*(void *)(a1 + 32) + 72);
  *(__n128 *)*(void *)(a1 + 40) = result;
  return result;
}

void ___ZN22__NSCFTCPIOWriteStream17_streamImpl_WriteEP15__CFWriteStreamPKhlP13CFStreamError_block_invoke(uint64_t a1)
{
  CFWriteStreamSignalEvent();
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
  }
}

void ___ZN14TCPIO_Delegate9writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = a1[4];
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v9, *(void *)(v3 + 8), *(std::__shared_weak_count **)(v3 + 16));
  uint64_t v5 = *(void *)(v3 + 24);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3321888768;
  v7[2] = ___ZN14TCPIO_Delegate18_onqueue_writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke;
  v7[3] = &unk_1ECFA8CF8;
  void v7[5] = v9;
  uint64_t v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v7[4] = v2;
  TransportConnectionObjCPP::write(v5, v4, (uint64_t)v7);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  uint64_t v6 = a1[4];

  dispatch_release(v6);
}

void sub_18421E5F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 40);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN14TCPIO_Delegate18_onqueue_writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  *(void *)(v3 + 72) = a2;
  *(void *)(v3 + 80) = a3;
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_OpenCompleted(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2, CFStreamError *a3)
{
  uint64_t v3 = *((void *)this + 13);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  _OWORD v6[4] = v3;
  v6[5] = a3;
  dispatch_sync(v4, v6);
  return 1;
}

BOOL __NSCFTCPIOWriteStream::_streamImpl_Open(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  uint64_t v6 = *((void *)this + 13);
  uint64_t v7 = *(NSObject **)(v6 + 40);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke;
  v9[3] = &__block_descriptor_48_e5_v8__0l;
  v9[4] = v6;
  void v9[5] = a3;
  dispatch_sync(v7, v9);
  *a4 = 1;
  CFWriteStreamSignalEvent();
  return !a3->domain && a3->error == 0;
}

CFStringRef __NSCFTCPIOWriteStream::copyDescription(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<TransportConnection@%p>", *((void *)this + 13) + 24);
}

uint64_t __NSCFTCPIOReadStream::__NSCFTCPIOReadStream(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  *(void *)a1 = &unk_1ECF9F960;
  *(void *)(a1 + 8) = a2;
  uint64_t v6 = a1 + 16;
  *(void *)(a1 + CFRetain((char *)this - 16) = &unk_1ECFA4A88;
  uint64_t v7 = a4;
  *(void *)(a1 + 72) = v7;
  *(_DWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)a1 = &unk_1ECFA2110;
  *(void *)(a1 + CFRetain((char *)this - 16) = &unk_1ECFA2190;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  uint64_t v8 = *a3;
  uint64_t v9 = a3[1];
  if (v9)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 96);
    *(void *)(a1 + 88) = v8;
    *(void *)(a1 + 96) = v9;
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
  }
  else
  {
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 88) = v8;
  }
  *(void *)(a1 + 112) = 0xFFFF00000000;
  *(void *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 120) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)v7);
  uint64_t v10 = *(void *)(a1 + 72);
  if (v10)
  {
    uint64_t v11 = 16;
    if (!*(_DWORD *)(a1 + 80)) {
      uint64_t v11 = 8;
    }
    *(void *)(v10 + v11) = v6;
  }
  return a1;
}

void sub_18421E95C(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  if (*v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](*v4);
  }
  TCPIO_BlockCallbacks_Listener::~TCPIO_BlockCallbacks_Listener(v2);
  *uint64_t v1 = &unk_1ECF9B550;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'__NSCFTCPIOReadStream::streamObject(__NSCFTCPIOReadStream *this)
{
  return *((void *)this - 1);
}

void non-virtual thunk to'__NSCFTCPIOReadStream::~__NSCFTCPIOReadStream(__NSCFTCPIOReadStream *this)
{
  __NSCFTCPIOReadStream::~__NSCFTCPIOReadStream((__NSCFTCPIOReadStream *)((char *)this - 16));

  JUMPOUT(0x18531B6D0);
}

{
  __NSCFTCPIOReadStream::~__NSCFTCPIOReadStream((__NSCFTCPIOReadStream *)((char *)this - 16));
}

void __NSCFTCPIOReadStream::~__NSCFTCPIOReadStream(__NSCFTCPIOReadStream *this)
{
  *(void *)this = &unk_1ECFA2110;
  uint64_t v2 = (TCPIO_BlockCallbacks_Listener *)((char *)this + 16);
  *((void *)this + 2) = &unk_1ECFA2190;
  uint64_t v3 = *((void *)this + 11);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v10, *(void *)(v3 + 8), *(std::__shared_weak_count **)(v3 + 16));
  uint64_t v4 = *(NSObject **)(v3 + 40);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3321888768;
  v8[2] = ___ZN14TCPIO_Delegate17readSideFinalizedEv_block_invoke;
  v8[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  v8[4] = v10;
  uint64_t v9 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_async(v4, v8);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 12);
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  (*(void (**)(void))(**((void **)this + 15) + 48))(*((void *)this + 15));
  uint64_t v6 = *((void *)this + 13);
  if (v6) {
    dispatch_release(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  *((void *)this + 2) = &unk_1ECFA4A88;
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(v2);

  *(void *)this = &unk_1ECF9B550;
  *((void *)this + 1) = 0;
}

{
  uint64_t vars8;

  __NSCFTCPIOReadStream::~__NSCFTCPIOReadStream(this);

  JUMPOUT(0x18531B6D0);
}

void sub_18421EB80(_Unwind_Exception *a1)
{
  uint64_t v4 = (std::__shared_weak_count *)v1[12];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  TCPIO_BlockCallbacks_Listener::~TCPIO_BlockCallbacks_Listener(v2);
  *uint64_t v1 = &unk_1ECF9B550;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

void ___ZN14TCPIO_Delegate17readSideFinalizedEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(TCPIO_Delegate **)(a1 + 32);
  *((unsigned char *)v1 + 66) = 1;
  if (*((unsigned char *)v1 + 89)) {
    TCPIO_Delegate::_onqueue_bothSidesFinalized(v1);
  }
}

uint64_t __NSCFTCPIOReadStream::streamObject(__NSCFTCPIOReadStream *this)
{
  return *((void *)this + 1);
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_deprecated_Unschedule(__NSCFTCPIOReadStream *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t result = (*(uint64_t (**)(void, __CFRunLoop *, const __CFString *))(**((void **)this + 15) + 64))(*((void *)this + 15), a3, a4);
  *((void *)this + 15) = result;
  return result;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_deprecated_Schedule(__NSCFTCPIOReadStream *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v5 = (_DWORD *)*((void *)this + 15);
  int v6 = v5[10];
  uint64_t result = (*(uint64_t (**)(_DWORD *, __CFRunLoop *, const __CFString *))(*(void *)v5 + 56))(v5, a3, a4);
  *((void *)this + 15) = result;
  if (!v6)
  {
    if (*(_DWORD *)(result + 40))
    {
      CFRetain(*((CFTypeRef *)this + 1));
      uint64_t v8 = *((void *)this + 15);
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 3221225472;
      v9[2] = ___ZN21__NSCFTCPIOReadStream31_streamImpl_deprecated_ScheduleEP14__CFReadStreamP11__CFRunLoopPK10__CFString_block_invoke;
      v9[3] = &__block_descriptor_40_e5_v8__0l;
      v9[4] = this;
      return (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, v9);
    }
  }
  return result;
}

void ___ZN21__NSCFTCPIOReadStream31_streamImpl_deprecated_ScheduleEP14__CFReadStreamP11__CFRunLoopPK10__CFString_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(__NSCFTCPIOReadStream **)(a1 + 32);
  __NSCFTCPIOReadStream::_onss_excite(v1);
  uint64_t v2 = (const void *)*((void *)v1 + 1);

  CFRelease(v2);
}

void __NSCFTCPIOReadStream::_onss_excite(__NSCFTCPIOReadStream *this)
{
  if (*(_DWORD *)(*((void *)this + 15) + 40)
    && (CFReadStreamGetStatus(*((CFReadStreamRef *)this + 1)) & 0xFFFFFFFFFFFFFFFELL) == 2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 28);
    uint64_t v2 = *((void *)this + 13);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 28);
    if (v2)
    {
      CFReadStreamSignalEvent();
    }
    else
    {
      char v7 = 0;
      uint64_t v3 = *((void *)this + 11);
      uint64_t v4 = *(NSObject **)(v3 + 40);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
      CFHostClientContext block[3] = &__block_descriptor_56_e5_v8__0l;
      block[4] = v3;
      void block[5] = &v5;
      block[6] = &v7;
      dispatch_sync(v4, block);
      if (v7 || v5 && v6) {
        CFReadStreamSignalEvent();
      }
      else {
        __NSCFTCPIOReadStream::issueDelegateRead(this);
      }
    }
  }
}

__n128 ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(__n128 **)(a1 + 32);
  __n128 result = v1[3];
  *(__n128 *)*(void *)(a1 + 40) = result;
  **(unsigned char **)(a1 + 48) = v1[4].n128_u8[0];
  return result;
}

void __NSCFTCPIOReadStream::issueDelegateRead(__NSCFTCPIOReadStream *this)
{
  uint64_t v2 = (_DWORD *)*((void *)this + 15);
  if (!v2[10])
  {
    CFRetain(*((CFTypeRef *)this + 1));
    operator new();
  }
  uint64_t v3 = (*(uint64_t (**)(_DWORD *))(*(void *)v2 + 88))(v2);
  CFRetain(*((CFTypeRef *)this + 1));
  uint64_t v4 = *((void *)this + 11);
  int v5 = *((_DWORD *)this + 29);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_275;
  v6[3] = &__block_descriptor_48_e72_v24__0__NSObject_OS_dispatch_data__8__NSObject_OS_nw_content_context__16l;
  _OWORD v6[4] = this;
  v6[5] = v3;
  TCPIO_Delegate::bufferedRead(v4, v5, (uint64_t)v6);
}

void sub_18421F048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  _Unwind_Resume(a1);
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke(uint64_t a1, NSObject *a2, uint64_t a3)
{
  if (*(unsigned char *)(*(void *)(a1 + 40) + 128))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 112));
    if (a2)
    {
      int v6 = *(NSObject **)(v5 + 104);
      if (v6)
      {
        if (a3)
        {
          int is_wake_packet = nw_content_context_get_is_wake_packet();
          int v6 = *(NSObject **)(v5 + 104);
          if (is_wake_packet)
          {
            size_t size = dispatch_data_get_size(*(dispatch_data_t *)(v5 + 104));
            *(void *)(v5 + 136) = size;
            *(void *)(v5 + 144) = dispatch_data_get_size(a2) + size;
          }
        }
        dispatch_data_t concat = dispatch_data_create_concat(v6, a2);
        dispatch_release(*(dispatch_object_t *)(v5 + 104));
        *(void *)(v5 + 104) = concat;
      }
      else
      {
        *(void *)(v5 + 104) = a2;
        dispatch_retain(a2);
        if (a3 && nw_content_context_get_is_wake_packet())
        {
          *(void *)(v5 + 136) = 0;
          *(void *)(v5 + 144) = dispatch_data_get_size(a2);
        }
      }
    }
    else
    {
      *(unsigned char *)(v5 + 129) = 1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 112));
  }
}

void TCPIO_Delegate::bufferedRead(uint64_t a1, int a2, uint64_t a3)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v10, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
  int v6 = *(NSObject **)(a1 + 40);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3321888768;
  v7[2] = ___ZN14TCPIO_Delegate12bufferedReadEjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke;
  v7[3] = &unk_1ECFA9880;
  void v7[5] = v10;
  uint64_t v8 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v9 = a2;
  v7[4] = a3;
  dispatch_async(v6, v7);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_275(uint64_t a1, dispatch_object_t object, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (object)
  {
    dispatch_retain(object);
    CFRetain(*(CFTypeRef *)(v4 + 8));
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v7 = a1 + 40;
    v22[5] = a3;
    v22[6] = v4;
    v22[4] = object;
    (*(void (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, void (*)(uint64_t), void *))(*(void *)v8 + 96))(v8, v22, v9, v10, v11, v12, v13, v14, MEMORY[0x1E4F143A8], 3221225472, ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_3, &unk_1E5257B78);
  }
  else
  {
    CFRetain(*(CFTypeRef *)(v4 + 8));
    uint64_t v15 = *(void *)(a1 + 40);
    uint64_t v7 = a1 + 40;
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 3221225472;
    v23[2] = ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_2;
    v23[3] = &__block_descriptor_40_e5_v8__0l;
    SecTrustRef v23[4] = v4;
    (*(void (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, void, void))(*(void *)v15 + 96))(v15, v23, v16, v17, v18, v19, v20, v21, v22[0], v22[1], v22[2], v22[3]);
  }
  (*(void (**)(void))(**(void **)v7 + 48))();
  CFRelease(*(CFTypeRef *)(v4 + 8));
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(__NSCFTCPIOReadStream **)(a1 + 32);
  __NSCFTCPIOReadStream::_onss_excite(v1);
  uint64_t v2 = (const void *)*((void *)v1 + 1);

  CFRelease(v2);
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_3(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v4 = *(NSObject **)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 112));
  uint64_t v5 = *(NSObject **)(v2 + 104);
  if (v5)
  {
    if (v3)
    {
      int is_wake_packet = nw_content_context_get_is_wake_packet();
      uint64_t v5 = *(NSObject **)(v2 + 104);
      if (is_wake_packet)
      {
        size_t size = dispatch_data_get_size(*(dispatch_data_t *)(v2 + 104));
        *(void *)(v2 + 136) = size;
        *(void *)(v2 + 144) = dispatch_data_get_size(v4) + size;
      }
    }
    dispatch_data_t concat = dispatch_data_create_concat(v5, v4);
    dispatch_release(*(dispatch_object_t *)(v2 + 104));
    *(void *)(v2 + 104) = concat;
  }
  else
  {
    *(void *)(v2 + 104) = v4;
    dispatch_retain(v4);
    if (v3 && nw_content_context_get_is_wake_packet())
    {
      *(void *)(v2 + 136) = 0;
      *(void *)(v2 + 144) = dispatch_data_get_size(v4);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 112));
  __NSCFTCPIOReadStream::_onss_excite((__NSCFTCPIOReadStream *)v2);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  uint64_t v9 = *(const void **)(v2 + 8);

  CFRelease(v9);
}

void ___ZN14TCPIO_Delegate12bufferedReadEjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 56);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v7, *(void *)(v3 + 8), *(std::__shared_weak_count **)(v3 + 16));
  uint64_t v4 = *(void *)(v3 + 24);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3321888768;
  v5[2] = ___ZN14TCPIO_Delegate13bufferedRead0EjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke;
  v5[3] = &unk_1ECFA8D30;
  void v5[5] = v7;
  int v6 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v5[4] = v2;
  TransportConnectionObjCPP::read(v4, 1, v1, (uint64_t)v5);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
}

void sub_18421F5B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 40);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN14TCPIO_Delegate13bufferedRead0EjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(v5 + 48) = a4;
  *(void *)(v5 + 56) = a5;
  if (!a2) {
    *(unsigned char *)(v5 + 64) = 1;
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __destroy_helper_block_e8_40c49_ZTSNSt3__110shared_ptrI21__NSCFTCPIOReadStreamEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c49_ZTSNSt3__110shared_ptrI21__NSCFTCPIOReadStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_pointer<__NSCFTCPIOReadStream *,__NSCFTCPIOReadStream::issueDelegateRead(void)::{lambda(__NSCFTCPIOReadStream *)#1},std::allocator<__NSCFTCPIOReadStream>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    CFRelease(*(CFTypeRef *)(v1 + 8));
  }
}

void std::__shared_ptr_pointer<__NSCFTCPIOReadStream *,__NSCFTCPIOReadStream::issueDelegateRead(void)::{lambda(__NSCFTCPIOReadStream *)#1},std::allocator<__NSCFTCPIOReadStream>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_SetProperty(__NSCFTCPIOReadStream *this, __CFReadStream *a2, const __CFString *a3, const void *a4)
{
  return 1;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_CopyProperty(TCPIO_Delegate **this, __CFReadStream *a2, const __CFString *a3)
{
  return TCPIO_Delegate::copyProperty(this[11], a3);
}

void __NSCFTCPIOReadStream::_streamImpl_Close(__NSCFTCPIOReadStream *this, __CFReadStream *a2)
{
  *((unsigned char *)this + 128) = 0;
}

void TCPIO_Delegate::closeReadSide(TCPIO_Delegate *this)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v5, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
  uint64_t v2 = *((void *)this + 5);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3321888768;
  v3[2] = ___ZN14TCPIO_Delegate13closeReadSideEv_block_invoke;
  v3[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  v3[4] = v5;
  uint64_t v4 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_async(v2, v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void *___ZN14TCPIO_Delegate13closeReadSideEv_block_invoke(void *result)
{
  uint64_t v1 = result[4];
  *(unsigned char *)(v1 + 65) = 1;
  if (*(unsigned char *)(v1 + 88))
  {
    uint64_t v2 = *(void *)(v1 + 24);
    if (v2)
    {
      __n128 result = *(void **)(v2 + 24);
      if (result)
      {
        if (!*(unsigned char *)(v2 + 40))
        {
          *(unsigned char *)(v2 + 40) = 1;
          return (void *)(*(uint64_t (**)(void *, void))(*result + 152))(result, 0);
        }
      }
    }
  }
  return result;
}

BOOL __NSCFTCPIOReadStream::_streamImpl_CanRead(os_unfair_lock_s *this, __CFReadStream *a2)
{
  uint64_t v4 = this + 28;
  os_unfair_lock_lock(this + 28);
  if (*(void *)&this[26]._os_unfair_lock_opaque) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = CFReadStreamGetStatus(a2) == kCFStreamStatusOpen;
  }
  os_unfair_lock_unlock(v4);
  return v5;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_Read(__NSCFTCPIOReadStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  a5->CFIndex domain = 0;
  a5->SInt32 error = 0;
  *a6 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = &v42;
  uint64_t v44 = 0x2020000000;
  uint64_t v45 = 0;
  uint64_t v12 = (os_unfair_lock_s *)((char *)this + 112);
  os_unfair_lock_lock((os_unfair_lock_t)this + 28);
  if (*((unsigned char *)this + 129))
  {
    v43[3] = 0;
    uint64_t v13 = *((void *)this + 13);
    if (v13)
    {
      dispatch_release(v13);
      int v14 = 0;
      *((void *)this + 13) = 0;
      goto LABEL_29;
    }
    goto LABEL_8;
  }
  uint64_t v15 = *((void *)this + 13);
  if (v15)
  {
    size_t size = dispatch_data_get_size(*((dispatch_data_t *)this + 13));
    if (!size)
    {
LABEL_8:
      int v14 = 0;
      goto LABEL_29;
    }
    size_t v17 = size;
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 3221225472;
    applier[2] = ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke;
    applier[3] = &unk_1E5256720;
    applier[4] = &v42;
    applier[5] = a4;
    applier[6] = a3;
    dispatch_data_apply(v15, applier);
    size_t v18 = v43[3];
    uint64_t v19 = *((void *)this + 13);
    if (v17 == v18)
    {
      dispatch_data_t subrange = 0;
      int v14 = 1;
    }
    else
    {
      dispatch_data_t subrange = dispatch_data_create_subrange(v19, v18, v17 - v18);
      int v14 = 0;
      uint64_t v19 = *((void *)this + 13);
    }
    dispatch_release(v19);
    *((void *)this + 13) = subrange;
    uint64_t v25 = v43;
    unint64_t v26 = v43[3];
    unint64_t v28 = *((void *)this + 17);
    uint64_t v27 = *((void *)this + 18);
    BOOL v29 = v28 >= v26;
    unint64_t v30 = v28 - v26;
    if (v30 != 0 && v29)
    {
      if (v27 != v28)
      {
        *((void *)this + 17) = v30;
        *((void *)this + 18) = v27 - v25[3];
      }
      goto LABEL_25;
    }
    if (v27 == v28)
    {
LABEL_25:
      TCPIO_Delegate::setProperty(*((TCPIO_Delegate **)this + 11), &unk_1EC0A0010, (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
      goto LABEL_29;
    }
    TCPIO_Delegate::setProperty(*((TCPIO_Delegate **)this + 11), &unk_1EC0A0010, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
    *((void *)this + 17) = 0;
    unint64_t v31 = v43[3];
    unint64_t v32 = *((void *)this + 18);
    BOOL v29 = v32 >= v31;
    unint64_t v33 = v32 - v31;
    if (!v29) {
      unint64_t v33 = 0;
    }
    *((void *)this + 18) = v33;
  }
  else
  {
    uint64_t v21 = (const void *)(*(uint64_t (**)(__NSCFTCPIOReadStream *, __CFReadStream *))(*(void *)this + 16))(this, a2);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v22 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v21;
      _os_log_impl(&dword_184085000, v22, OS_LOG_TYPE_INFO, "StreamTask polling read of %@", (uint8_t *)&buf, 0xCu);
    }
    if (v21) {
      CFRelease(v21);
    }
    uint64_t v23 = *((void *)this + 11);
    CFStringRef v24 = *(NSObject **)(v23 + 40);
    *(void *)&long long buf = MEMORY[0x1E4F143A8];
    *((void *)&buf + 1) = 3221225472;
    CFTypeRef v47 = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
    uint64_t v48 = &__block_descriptor_56_e5_v8__0l;
    uint64_t v49 = v23;
    CFTypeID v50 = a5;
    __int16 v51 = a6;
    dispatch_sync(v24, &buf);
    if (!a5->error && !a5->domain)
    {
      a5->CFIndex domain = 1;
      a5->SInt32 error = 57;
    }
    int v14 = 0;
    *a6 = 1;
    v43[3] = -1;
  }
LABEL_29:
  if (*((void *)this + 13)) {
    goto LABEL_30;
  }
  uint64_t v35 = *((void *)this + 11);
  CFStringRef v36 = *(NSObject **)(v35 + 40);
  *(void *)&long long buf = MEMORY[0x1E4F143A8];
  *((void *)&buf + 1) = 3221225472;
  CFTypeRef v47 = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
  uint64_t v48 = &__block_descriptor_56_e5_v8__0l;
  uint64_t v49 = v35;
  CFTypeID v50 = a5;
  __int16 v51 = a6;
  dispatch_sync(v36, &buf);
  if (a5->domain)
  {
    SInt32 error = a5->error;
    if (error)
    {
      if (a5->domain == 1 && error == 57)
      {
        a5->CFIndex domain = 0;
        a5->SInt32 error = 0;
        *a6 = 1;
      }
      goto LABEL_40;
    }
  }
  if (*a6)
  {
LABEL_40:
    os_unfair_lock_unlock(v12);
    goto LABEL_41;
  }
LABEL_30:
  os_unfair_lock_unlock(v12);
  if (*(_DWORD *)(*((void *)this + 15) + 40))
  {
    CFRetain(*((CFTypeRef *)this + 1));
    uint64_t v34 = *((void *)this + 15);
    v40[0] = MEMORY[0x1E4F143A8];
    v40[1] = 3221225472;
    v40[2] = ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke_2;
    v40[3] = &__block_descriptor_40_e5_v8__0l;
    v40[4] = this;
    (*(void (**)(uint64_t, void *))(*(void *)v34 + 96))(v34, v40);
  }
  else if (v14)
  {
    __NSCFTCPIOReadStream::issueDelegateRead(this);
  }
LABEL_41:
  uint64_t v38 = v43[3];
  _Block_object_dispose(&v42, 8);
  return v38;
}

void sub_18421FD64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke(void *a1, int a2, uint64_t a3, void *__src, size_t a5)
{
  size_t v5 = a1[5] - *(void *)(*(void *)(a1[4] + 8) + 24);
  if (!v5) {
    return 0;
  }
  if (v5 >= a5) {
    size_t v8 = a5;
  }
  else {
    size_t v8 = a1[5] - *(void *)(*(void *)(a1[4] + 8) + 24);
  }
  memcpy((void *)(a1[6] + a3), __src, v8);
  *(void *)(*(void *)(a1[4] + 8) + 24) += v8;
  return a1[5] > *(void *)(*(void *)(a1[4] + 8) + 24);
}

void ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(__NSCFTCPIOReadStream **)(a1 + 32);
  __NSCFTCPIOReadStream::_onss_excite(v1);
  uint64_t v2 = (const void *)*((void *)v1 + 1);

  CFRelease(v2);
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_OpenCompleted(__NSCFTCPIOReadStream *this, __CFReadStream *a2, CFStreamError *a3)
{
  char v6 = 0;
  uint64_t v3 = *((void *)this + 11);
  uint64_t v4 = *(NSObject **)(v3 + 40);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
  CFHostClientContext block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = v3;
  void block[5] = a3;
  block[6] = &v6;
  dispatch_sync(v4, block);
  return 1;
}

BOOL __NSCFTCPIOReadStream::_streamImpl_Open(__NSCFTCPIOReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  char v9 = 0;
  uint64_t v6 = *((void *)this + 11);
  uint64_t v7 = *(NSObject **)(v6 + 40);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
  CFHostClientContext block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = v6;
  void block[5] = a3;
  block[6] = &v9;
  dispatch_sync(v7, block);
  *a4 = 1;
  if (*((void *)this + 13) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(block[0]) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "should only open this stream once", (uint8_t *)block, 2u);
  }
  __NSCFTCPIOReadStream::issueDelegateRead(this);
  return v9 == 0;
}

CFStringRef __NSCFTCPIOReadStream::copyDescription(__NSCFTCPIOReadStream *this, __CFReadStream *a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<TransportConnection@%p>", *((void *)this + 11) + 24);
}

void TCPIO_Delegate::~TCPIO_Delegate(TCPIO_Delegate *this)
{
  TCPIO_Delegate::~TCPIO_Delegate(this);

  JUMPOUT(0x18531B6D0);
}

{
  void *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  void block[5];
  void v9[7];
  std::__shared_weak_count *v10;

  *(void *)this = &unk_1ECF9D030;
  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x4012000000;
  v9[3] = __Block_byref_object_copy__7147;
  v9[4] = __Block_byref_object_dispose__7148;
  void v9[5] = &unk_18441BEED;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 4);
  uint64_t v2 = (void *)((char *)this + 24);
  void v9[6] = *((void *)this + 3);
  uint64_t v10 = v3;
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 4);
    *uint64_t v2 = 0;
    v2[1] = 0;
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
  else
  {
    *uint64_t v2 = 0;
    *((void *)this + 4) = 0;
  }
  size_t v5 = *((void *)this + 5);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN14TCPIO_DelegateD2Ev_block_invoke;
  CFHostClientContext block[3] = &unk_1E5257868;
  block[4] = v9;
  dispatch_async(v5, block);
  dispatch_release(*((dispatch_object_t *)this + 5));
  _Block_object_dispose(v9, 8);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  *(void *)this = &unk_1ECF9B550;
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

__n128 __Block_byref_object_copy__7147(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__7148(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void ___ZN14TCPIO_DelegateD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 56);
  *(void *)(v1 + 48) = 0;
  *(void *)(v1 + 56) = 0;
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

uint64_t std::__shared_ptr_emplace<TCPIO_Delegate>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<TCPIO_Delegate>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6800;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<TCPIO_Delegate>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6800;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t __NSCFTCPIOErroredWriteStream::_streamImpl_Write(CFStreamError *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5)
{
  *a5 = this[1];
  return -1;
}

uint64_t __NSCFTCPIOErroredWriteStream::_streamImpl_OpenCompleted(CFStreamError *this, __CFWriteStream *a2, CFStreamError *a3)
{
  *a3 = this[1];
  return 0;
}

uint64_t __NSCFTCPIOErroredWriteStream::_streamImpl_Open(CFStreamError *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a3 = this[1];
  *a4 = 1;
  return 0;
}

void __NSCFTCPIOErroredWriteStream::~__NSCFTCPIOErroredWriteStream(__NSCFTCPIOErroredWriteStream *this)
{
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + 1) = 0;
  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + 1) = 0;
}

uint64_t __NSCFTCPIOErroredReadStream::_streamImpl_Read(CFStreamError *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  *a5 = this[1];
  *a6 = 1;
  return -1;
}

uint64_t __NSCFTCPIOErroredReadStream::_streamImpl_OpenCompleted(CFStreamError *this, __CFReadStream *a2, CFStreamError *a3)
{
  *a3 = this[1];
  return 0;
}

uint64_t __NSCFTCPIOErroredReadStream::_streamImpl_Open(CFStreamError *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a3 = this[1];
  *a4 = 1;
  return 0;
}

void __NSCFTCPIOErroredReadStream::~__NSCFTCPIOErroredReadStream(__NSCFTCPIOErroredReadStream *this)
{
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + 1) = 0;
  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + 1) = 0;
}

void sub_184220A6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  if (v2) {
    CFRelease(v2);
  }
  _Unwind_Resume(a1);
}

void sub_184221B60(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<HTTPProtocol *,Deleter_release<HTTPProtocol>,std::allocator<HTTPProtocol>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_7167()
{
}

void sub_184221C44(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void sub_184221E08(_Unwind_Exception *a1)
{
  CFRelease(v2);
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_184223138(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  }
  if (v36) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v36);
  }
  _Unwind_Resume(exception_object);
}

void sub_18422328C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1842233B0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_184224314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18422475C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_184224C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v20);
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:nn180100]<TCPIO_Establish,std::allocator<TCPIO_Establish>,__NSCFTCPIOStreamTask *&,void>(void *a1, uint64_t a2)
{
  uint64_t v4 = (char *)operator new(0x60uLL);
  *(_OWORD *)(v4 + 8) = 0u;
  *(void *)uint64_t v4 = &unk_1ECFA6918;
  size_t v5 = v4 + 24;
  *((_OWORD *)v4 + 2) = 0u;
  *((void *)v4 + 3) = &unk_1ECF9D990;
  *((void *)v4 + 6) = &unk_1ECF9DA50;
  *((void *)v4 + 8) = a2;
  *((void *)v4 + 7) = objc_alloc_init(__NSCFTCPIO_BlockCallbacks_Referent);
  *((void *)v4 + 9) = 0;
  *((void *)v4 + 10) = 0;
  *((_WORD *)v4 + 44) = 0;
  *a1 = v4 + 24;
  a1[1] = v4;
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 5);
  if (v6)
  {
    if (v6->__shared_owners_ != -1) {
      return;
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 2, 1uLL, memory_order_relaxed);
    *((void *)v4 + 4) = v5;
    *((void *)v4 + 5) = v4;
    std::__shared_weak_count::__release_weak(v6);
  }
  else
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 2, 1uLL, memory_order_relaxed);
    *((void *)v4 + 4) = v5;
    *((void *)v4 + 5) = v4;
  }

  std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v4);
}

void sub_184224E08(_Unwind_Exception *a1)
{
  v1[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECF9B550;
  shared_weak_owners = (std::__shared_weak_count *)v1[1].__shared_weak_owners_;
  if (shared_weak_owners) {
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'TCPIO_Establish::setTransportConnection(uint64_t a1, uint64_t *a2)
{
}

void TCPIO_Establish::setTransportConnection(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 40);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  size_t v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  objc_msgSend(v2, "_onqueue_setTransportConnection:", &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184224EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'TCPIO_Establish::connectionWaitingNotification(uint64_t a1)
{
}

void TCPIO_Establish::connectionWaitingNotification(uint64_t a1)
{
  if (objc_msgSend((id)objc_msgSend(*(id *)(a1 + 40), "_effectiveConfiguration"), "waitsForConnectivity")
    && !*(unsigned char *)(a1 + 64))
  {
    *(unsigned char *)(a1 + 64) = 1;
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2)
    {
      uint64_t v3 = v2[88];
      if (!v3) {
        uint64_t v3 = v2[87];
      }
    }
    else
    {
      uint64_t v3 = 0;
    }
    -[__NSCFURLSessionDelegateWrapper taskIsWaitingForConnectivity:](v3, v2);
  }
}

uint64_t non-virtual thunk to'TCPIO_Establish::connectionTLSDisabled(id *this)
{
  return objc_msgSend(this[2], "_onqueue_tlsDisabled");
}

uint64_t non-virtual thunk to'TCPIO_Establish::connectionTLSEnabled(id *this)
{
  return objc_msgSend(this[2], "_onqueue_tlsCompletion");
}

uint64_t non-virtual thunk to'TCPIO_Establish::connectionEstablished(id *this, CFStreamError a2)
{
  uint64_t v2 = *(void *)&a2.error;
  CFIndex domain = a2.domain;
  uint64_t result = objc_msgSend(this[2], "_onqueue_cleanUpConnectionEstablishmentState");
  if (!*((unsigned char *)this + 41))
  {
    *((unsigned char *)this + 41) = 1;
    id v7 = this[1];
    id v6 = this[2];
    return objc_msgSend(v6, "_onqueue_connectionEstablishedWithError:callbackReferent:", domain, v2, v7);
  }
  return result;
}

uint64_t non-virtual thunk to'TCPIO_Establish::needClientCert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return TCPIO_Establish::needClientCert((void *)(a1 - 24), a2, a3);
}

uint64_t TCPIO_Establish::needClientCert(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1[5])
  {
    CFStringRef v6 = (const __CFString *)a1[6];
    uint64_t v5 = a1[7];
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = ___ZN22HTTPProtocolSSLSupport40CreateClientCertChallengeWithHostAndPortEPK10__CFStringlPK9__CFArray_block_invoke;
    v13[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
    v13[4] = a2;
    Challenge = (const void *)createChallenge(7, v6, v5, (uint64_t)v13);
    id v8 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:Challenge sender:0];
    if (Challenge) {
      CFRelease(Challenge);
    }
    char v9 = (void *)a1[5];
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = ___ZN15TCPIO_Establish14needClientCertEPK9__CFArrayU13block_pointerFvS2_bE_block_invoke;
    v12[3] = &unk_1E5256FC8;
    v12[4] = a3;
    return objc_msgSend(v9, "_onqueue_needClientCert:completionHandler:", v8, v12);
  }
  else
  {
    uint64_t v11 = *(uint64_t (**)(uint64_t, void, uint64_t))(a3 + 16);
    return v11(a3, 0, 1);
  }
}

uint64_t ___ZN15TCPIO_Establish14needClientCertEPK9__CFArrayU13block_pointerFvS2_bE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t non-virtual thunk to'TCPIO_Establish::needServerTrust(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return TCPIO_Establish::needServerTrust((void *)(a1 - 24), a2, a3);
}

uint64_t TCPIO_Establish::needServerTrust(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1[5])
  {
    CFStringRef v6 = (const __CFString *)a1[6];
    uint64_t v5 = a1[7];
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = ___ZN22HTTPProtocolSSLSupport35CreateTrustChallengeWithHostAndPortEPK10__CFStringlP10__SecTrust_block_invoke;
    v12[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
    v12[4] = a2;
    Challenge = (const void *)createChallenge(8, v6, v5, (uint64_t)v12);
    id v8 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:Challenge sender:0];
    if (Challenge) {
      CFRelease(Challenge);
    }
    char v9 = (void *)a1[5];
    return objc_msgSend(v9, "_onqueue_needServerTrust:completionHandler:", v8, a3);
  }
  else
  {
    uint64_t v11 = *(uint64_t (**)(uint64_t, void, uint64_t))(a3 + 16);
    return v11(a3, 0, 1);
  }
}

uint64_t non-virtual thunk to'TCPIO_Establish::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(a1 + 16);
  if (v4) {
    return objc_msgSend(v4, "_onqueue_postConnectConfiguration:parameters:completionHandler:", a2, a3, a4);
  }
  else {
    return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
  }
}

uint64_t non-virtual thunk to'TCPIO_Establish::preConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return TCPIO_Establish::preConnectConfiguration(a1 - 24, a2, a3, a4);
}

uint64_t TCPIO_Establish::preConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  id v8 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(a1 + 40);
    int v12 = 134218240;
    uint64_t v13 = a1;
    __int16 v14 = 2048;
    uint64_t v15 = v9;
    _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "Establish Object : %p .Task : %p", (uint8_t *)&v12, 0x16u);
  }
  uint64_t v10 = *(void **)(a1 + 40);
  if (v10) {
    return objc_msgSend(v10, "_onqueue_preConnectionConfiguration:parameters:completionHandler:", a2, a3, a4);
  }
  else {
    return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
  }
}

void non-virtual thunk to'TCPIO_Establish::~TCPIO_Establish(TCPIO_Establish *this)
{
  TCPIO_Establish::~TCPIO_Establish((TCPIO_Establish *)((char *)this - 24));

  JUMPOUT(0x18531B6D0);
}

{
  TCPIO_Establish::~TCPIO_Establish((TCPIO_Establish *)((char *)this - 24));
}

void TCPIO_Establish::~TCPIO_Establish(TCPIO_Establish *this)
{
  *(void *)this = &unk_1ECF9D990;
  *((void *)this + 3) = &unk_1ECF9DA50;

  *(void *)this = &unk_1ECF9B550;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

{
  uint64_t vars8;

  TCPIO_Establish::~TCPIO_Establish(this);

  JUMPOUT(0x18531B6D0);
}

void sub_1842254C8(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_1ECF9B550;
  uint64_t v3 = (std::__shared_weak_count *)v1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TCPIO_Establish::connectionTLSDisabled(id *this)
{
  return objc_msgSend(this[5], "_onqueue_tlsDisabled");
}

uint64_t TCPIO_Establish::connectionTLSEnabled(id *this)
{
  return objc_msgSend(this[5], "_onqueue_tlsCompletion");
}

uint64_t TCPIO_Establish::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(a1 + 40);
  if (v4) {
    return objc_msgSend(v4, "_onqueue_postConnectConfiguration:parameters:completionHandler:", a2, a3, a4);
  }
  else {
    return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
  }
}

uint64_t TCPIO_Establish::getBlockCallbackReferent(TCPIO_Establish *this)
{
  return *((void *)this + 4);
}

void TCPIO_Establish::endSecureConnection(TCPIO_Establish *this)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v5, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 792);
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3321888768;
  v4[2] = ___ZN15TCPIO_Establish19endSecureConnectionEv_block_invoke;
  v4[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
  v4[4] = v5;
  void v4[5] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  _Block_copy(v4);
  operator new();
}

void sub_184225704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<TransportConnection::ConnectionEstablishmentDelegate *,Deleter_CustomBlock,std::allocator<TransportConnection::ConnectionEstablishmentDelegate>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void __destroy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void TCPIO_Establish::beginSecureConnection(TCPIO_Establish *this)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v5, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 792);
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3321888768;
  v4[2] = ___ZN15TCPIO_Establish21beginSecureConnectionEv_block_invoke;
  v4[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
  v4[4] = v5;
  void v4[5] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  _Block_copy(v4);
  operator new();
}

void sub_18422595C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(a1);
}

uint64_t TCPIO_Establish::connectionEstablished(id *this, CFStreamError a2)
{
  uint64_t v2 = *(void *)&a2.error;
  CFIndex domain = a2.domain;
  uint64_t result = objc_msgSend(this[5], "_onqueue_cleanUpConnectionEstablishmentState");
  if (!*((unsigned char *)this + 65))
  {
    *((unsigned char *)this + 65) = 1;
    id v7 = this[4];
    id v6 = this[5];
    return objc_msgSend(v6, "_onqueue_connectionEstablishedWithError:callbackReferent:", domain, v2, v7);
  }
  return result;
}

void TCPIO_Establish::endConnection(TCPIO_Establish *this)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 5);
    int v10 = 134218240;
    uint64_t v11 = this;
    __int16 v12 = 2048;
    uint64_t v13 = v3;
    _os_log_impl(&dword_184085000, v2, OS_LOG_TYPE_DEFAULT, "Establish Object : %p .Task : %p", (uint8_t *)&v10, 0x16u);
  }
  uint64_t v4 = *((void *)this + 5);
  if (v4)
  {
    uint64_t v5 = v4 + 784;
    uint64_t v6 = *(void *)(v4 + 784);
    id v7 = *(std::__shared_weak_count **)(v5 + 8);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6)
    {
      uint64_t v8 = *(void *)(v6 + 24);
      uint64_t v9 = *(std::__shared_weak_count **)(v8 + 152);
      *(void *)(v8 + 144) = 0;
      *(void *)(v8 + 152) = 0;
      if (v9) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v9);
      }
    }
    if (*((void *)this + 5)) {
      *((void *)this + 5) = 0;
    }
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
  }
}

void TCPIO_Establish::beginConnection(TCPIO_Establish *this)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 792);
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *((void *)this + 5);
    buf[0] = 134218240;
    *(void *)&buf[1] = this;
    __int16 v10 = 2048;
    uint64_t v11 = v5;
    _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "Establish Object : %p .Task : %p", (uint8_t *)buf, 0x16u);
  }
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v7, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN15TCPIO_Establish15beginConnectionEb_block_invoke;
  aBlock[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
  aBlock[4] = v7;
  aBlock[5] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  _Block_copy(aBlock);
  operator new();
}

void sub_18422630C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17)
{
  uint64_t v22 = *(std::__shared_weak_count **)(v20 - 128);
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = *(std::__shared_weak_count **)(v20 - 144);
  if (v23)
  {
    std::__shared_weak_count::__release_weak(v23);
    if (!v17)
    {
LABEL_5:
      if (!v19) {
        goto LABEL_6;
      }
      goto LABEL_10;
    }
  }
  else if (!v17)
  {
    goto LABEL_5;
  }
  std::__shared_weak_count::__release_weak(v17);
  if (!v19)
  {
LABEL_6:
    if (!v17)
    {
LABEL_12:
      std::__shared_weak_count::__release_shared[abi:nn180100](v18);
      if (a15) {
        std::__shared_weak_count::__release_shared[abi:nn180100](a15);
      }
      if (a17) {
        std::__shared_weak_count::__release_shared[abi:nn180100](a17);
      }
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v17);
      }
      _Unwind_Resume(a1);
    }
LABEL_11:
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
    goto LABEL_12;
  }
LABEL_10:
  std::__shared_weak_count::__release_weak(v19);
  if (!v17) {
    goto LABEL_12;
  }
  goto LABEL_11;
}

TCPIO_BlockCallbacks_Listener *___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke(TCPIO_BlockCallbacks_Listener *result)
{
  id var3 = result->var1.var3;
  if (var3)
  {
    uint64_t v2 = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 1);
    if (v2) {
      TCPIO_BlockCallbacks_Listener::receiveEvent(v2, @"_kCFStreamPropertyExcessiveKeepalivesBlock");
    }
    uint64_t result = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 2);
    if (result)
    {
      return (TCPIO_BlockCallbacks_Listener *)TCPIO_BlockCallbacks_Listener::receiveEvent(result, @"_kCFStreamPropertyExcessiveKeepalivesBlock");
    }
  }
  return result;
}

TCPIO_BlockCallbacks_Listener *___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_3(TCPIO_BlockCallbacks_Listener *result)
{
  id var3 = result->var1.var3;
  if (var3)
  {
    uint64_t v2 = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 1);
    if (v2) {
      TCPIO_BlockCallbacks_Listener::receiveEvent(v2, @"_kCFStreamPropertyLowThroughputBlock");
    }
    uint64_t result = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 2);
    if (result)
    {
      return (TCPIO_BlockCallbacks_Listener *)TCPIO_BlockCallbacks_Listener::receiveEvent(result, @"_kCFStreamPropertyLowThroughputBlock");
    }
  }
  return result;
}

void ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_5(void *a1, int a2, uint64_t a3)
{
  int v3 = a3;
  uint64_t v5 = a1[4];
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 3221225472;
  uint64_t v21 = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_6;
  uint64_t v22 = &__block_descriptor_33_e63_B16__0__TCPIO_BlockCallbacks_Listener_____CBs_______________i_8l;
  char v23 = a3;
  if (!v5)
  {
    char v7 = 0;
    if (a3) {
      return;
    }
LABEL_8:
    if (v7) {
      return;
    }
    uint64_t v8 = (std::__shared_weak_count *)a1[6];
    if (v8 && (uint64_t v9 = std::__shared_weak_count::lock(v8)) != 0)
    {
      __int16 v10 = v9;
      uint64_t v11 = a1[5];
      if (v11)
      {
        uint64_t v12 = *(dispatch_object_t **)(v11 + 24);
        uint64_t v13 = v12[15];
        if (!v13 || (dispatch_retain(v12[15]), (uint64_t v12 = *(dispatch_object_t **)(v11 + 24)) != 0))
        {
          if (!*(unsigned char *)(v11 + 40))
          {
            *(unsigned char *)(v11 + 40) = 1;
            ((void (*)(dispatch_object_t *, void))(*v12)[19].isa)(v12, 0);
          }
        }
      }
      else
      {
        uint64_t v13 = 0;
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = (std::__shared_weak_count *)a1[8];
    if (v14)
    {
      uint64_t v15 = std::__shared_weak_count::lock(v14);
      if (v15)
      {
        uint64_t v16 = v15;
        uint64_t v17 = a1[7];
        if (v17 && v13)
        {
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 3321888768;
          block[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_7;
          CFHostClientContext block[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
          block[4] = v17;
          uint64_t v19 = v15;
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          dispatch_async(v13, block);
          if (v19) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v19);
          }
          std::__shared_weak_count::__release_shared[abi:nn180100](v16);
LABEL_28:
          dispatch_release(v13);
          return;
        }
        std::__shared_weak_count::__release_shared[abi:nn180100](v15);
      }
    }
    if (!v13) {
      return;
    }
    goto LABEL_28;
  }
  uint64_t v6 = *(TCPIO_BlockCallbacks_Listener **)(v5 + 8);
  if (v6) {
    char v7 = TCPIO_BlockCallbacks_Listener::receiveEvent(v6, @"_kCFStreamPropertyConnectionViabilityChangedBlock", a3);
  }
  else {
    char v7 = 0;
  }
  if (*(void *)(v5 + 16)) {
    v7 |= ((uint64_t (*)(void *))v21)(v20);
  }
  if (!v3) {
    goto LABEL_8;
  }
}

void sub_184226698(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

TCPIO_BlockCallbacks_Listener *___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_313(TCPIO_BlockCallbacks_Listener *result, uint64_t a2, uint64_t a3)
{
  id var3 = result->var1.var3;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  uint64_t v5 = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_2_314;
  uint64_t v6 = &__block_descriptor_40_e63_B16__0__TCPIO_BlockCallbacks_Listener_____CBs_______________i_8l;
  uint64_t v7 = a3;
  if (var3)
  {
    uint64_t result = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 1);
    if (result) {
      uint64_t result = (TCPIO_BlockCallbacks_Listener *)TCPIO_BlockCallbacks_Listener::receiveEvent(result, @"_kCFStreamPropertyConnectionWaitingBlock", a3);
    }
    if (*((void *)var3 + 2)) {
      return (TCPIO_BlockCallbacks_Listener *)((uint64_t (*)(void *))v5)(v4);
    }
  }
  return result;
}

TCPIO_BlockCallbacks_Listener *___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_3_317(TCPIO_BlockCallbacks_Listener *result, uint64_t a2, uint64_t a3)
{
  id var3 = result->var1.var3;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  uint64_t v5 = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_4_318;
  uint64_t v6 = &__block_descriptor_33_e63_B16__0__TCPIO_BlockCallbacks_Listener_____CBs_______________i_8l;
  char v7 = a3;
  if (var3)
  {
    uint64_t result = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 1);
    if (result) {
      uint64_t result = (TCPIO_BlockCallbacks_Listener *)TCPIO_BlockCallbacks_Listener::receiveEvent(result, (const __CFString *)&unk_1EC09F360, a3);
    }
    if (*((void *)var3 + 2)) {
      return (TCPIO_BlockCallbacks_Listener *)((uint64_t (*)(void *))v5)(v4);
    }
  }
  return result;
}

TCPIO_BlockCallbacks_Listener *___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_5_319(TCPIO_BlockCallbacks_Listener *result)
{
  id var3 = result->var1.var3;
  if (var3)
  {
    uint64_t v2 = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 1);
    if (v2)
    {
      PropertyBlockPtr = TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(v2, (CFStringRef)&unk_1EC09F398);
      if (PropertyBlockPtr)
      {
        uint64_t v4 = (void (**)(void))*PropertyBlockPtr;
        if (v4) {
          v4[2]();
        }
      }
    }
    uint64_t result = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 2);
    if (result)
    {
      uint64_t result = (TCPIO_BlockCallbacks_Listener *)TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(result, (CFStringRef)&unk_1EC09F398);
      if (result)
      {
        uint64_t result = (TCPIO_BlockCallbacks_Listener *)result->var0;
        if (result)
        {
          id var1 = (uint64_t (*)(void))result->var1.var1;
          return (TCPIO_BlockCallbacks_Listener *)var1();
        }
      }
    }
  }
  return result;
}

uint64_t ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_4_318(uint64_t a1, TCPIO_BlockCallbacks_Listener *this)
{
  return TCPIO_BlockCallbacks_Listener::receiveEvent(this, (const __CFString *)&unk_1EC09F360, *(unsigned __int8 *)(a1 + 32));
}

uint64_t TCPIO_BlockCallbacks_Listener::receiveEvent(TCPIO_BlockCallbacks_Listener *this, const __CFString *a2, uint64_t a3)
{
  uint64_t result = (uint64_t)TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(this, a2);
  if (result)
  {
    uint64_t v6 = *(void *)result;
    if (*(void *)result)
    {
      uint64_t v7 = (*((uint64_t (**)(TCPIO_BlockCallbacks_Listener *))this->var0 + 2))(this);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16))(v6, v7, a3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_2_314(uint64_t a1, TCPIO_BlockCallbacks_Listener *this)
{
  return TCPIO_BlockCallbacks_Listener::receiveEvent(this, @"_kCFStreamPropertyConnectionWaitingBlock", *(unsigned __int8 *)(a1 + 32));
}

void __destroy_helper_block_e8_40c50_ZTSNSt3__18weak_ptrI25TransportConnectionObjCPPEE56c44_ZTSNSt3__18weak_ptrI19TCPIO_EstablishBaseEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *__copy_helper_block_e8_40c50_ZTSNSt3__18weak_ptrI25TransportConnectionObjCPPEE56c44_ZTSNSt3__18weak_ptrI19TCPIO_EstablishBaseEE(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_6(uint64_t a1, TCPIO_BlockCallbacks_Listener *this)
{
  return TCPIO_BlockCallbacks_Listener::receiveEvent(this, @"_kCFStreamPropertyConnectionViabilityChangedBlock", *(unsigned __int8 *)(a1 + 32));
}

uint64_t ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_7(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 32) + 40))(*(void *)(a1 + 32), 1, 57);
}

id *TCPIO_BlockCallbacks_Listener::receiveEvent(TCPIO_BlockCallbacks_Listener *this, const __CFString *a2)
{
  uint64_t result = TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(this, a2);
  if (result)
  {
    uint64_t v4 = *result;
    if (*result)
    {
      uint64_t v5 = (*((uint64_t (**)(TCPIO_BlockCallbacks_Listener *))this->var0 + 2))(this);
      uint64_t v6 = (uint64_t (*)(void *, uint64_t))v4[2];
      return (id *)v6(v4, v5);
    }
  }
  return result;
}

void TCPIO_Establish::initialize(TCPIO_Establish *this, NSString *a2, uint64_t a3)
{
  uint64_t v5 = (const void *)[(NSString *)a2 copy];
  *((void *)this + 6) = v5;
  *((void *)this + 7) = a3;
  uint64_t v6 = *((void *)this + 5);
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 + 792);
    if (v7)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      uint64_t v5 = (const void *)*((void *)this + 6);
    }
    if (v5) {
      goto LABEL_5;
    }
  }
  else if (v5)
  {
LABEL_5:
    CFRetain(v5);
  }
  operator new();
}

void sub_184226C90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
    if (v12)
    {
LABEL_3:
      if (!v10) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if (v12)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  if (!v10) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_4:
  std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  goto LABEL_5;
}

uint64_t std::__shared_ptr_emplace<TCPIO_Establish>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<TCPIO_Establish>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6918;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<TCPIO_Establish>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6918;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<TransportConnectionObjCPP>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<TransportConnectionObjCPP>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6BF0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<TransportConnectionObjCPP>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6BF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1842272C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v20);
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t subclassMissingImplementation(objc_selector *a1, objc_class *a2)
{
  uint64_t v3 = (void *)MEMORY[0x1E4F1CA00];
  uint64_t v4 = *MEMORY[0x1E4F1C3C8];
  Name = sel_getName((SEL)a1);
  return objc_msgSend(v3, "raise:format:", v4, @"*** -%s cannot be sent to an abstract object of class %s: Create a concrete instance!", Name, class_getName(a2));
}

void sub_1842278D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void HandySSLSettings::~HandySSLSettings(HandySSLSettings *this)
{
  *(void *)this = &unk_1ECF9DDC8;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9DDC8;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

void *std::__tree<std::string>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      *uint64_t result = 0;
      while (1)
      {
        uint64_t v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          uint64_t result = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          uint64_t result = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t std::__tree<std::string>::_DetachedTreeCache::~_DetachedTreeCache[abi:nn180100](uint64_t a1)
{
  std::__tree<std::string>::destroy(*(char **)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    std::__tree<std::string>::destroy((char *)v2);
  }
  return a1;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::string,void *>>>::operator()[abi:nn180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 55) < 0) {
      operator delete(__p[4]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::__shared_ptr_emplace<__CoalescingConnectionKey>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6C28;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<__CoalescingConnectionKey>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6C28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t __NSURLSession_CoalescingHelperIsOnDNSNameList(void *a1, void *a2)
{
  uint64_t v3 = a1;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t result = [a1 countByEnumeratingWithState:&v23 objects:v28 count:16];
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)v24;
    uint64_t v17 = *(void *)v24;
    size_t v18 = v3;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v24 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = (id)SecCertificateCopyDNSNames();
        long long v19 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        long long v22 = 0u;
        uint64_t v9 = [v8 countByEnumeratingWithState:&v19 objects:v27 count:16];
        if (v9)
        {
          uint64_t v10 = v9;
          uint64_t v11 = *(void *)v20;
          while (2)
          {
            for (uint64_t j = 0; j != v10; ++j)
            {
              if (*(void *)v20 != v11) {
                objc_enumerationMutation(v8);
              }
              uint64_t v13 = *(void **)(*((void *)&v19 + 1) + 8 * j);
              if ((objc_msgSend(v13, "isEqualToString:", a2, v17) & 1) == 0)
              {
                if (![v13 hasPrefix:@"*"]) {
                  continue;
                }
                if ((unint64_t)[v13 length] < 2) {
                  continue;
                }
                uint64_t v14 = [v13 substringFromIndex:1];
                uint64_t v15 = [a2 rangeOfString:@"."];
                if (!v16
                  || (objc_msgSend((id)objc_msgSend(a2, "substringFromIndex:", v15), "isEqualToString:", v14) & 1) == 0)
                {
                  continue;
                }
              }
              return 1;
            }
            uint64_t v10 = [v8 countByEnumeratingWithState:&v19 objects:v27 count:16];
            if (v10) {
              continue;
            }
            break;
          }
        }
        uint64_t v6 = v17;
        uint64_t v3 = v18;
      }
      uint64_t v5 = [v18 countByEnumeratingWithState:&v23 objects:v28 count:16];
      uint64_t result = 0;
    }
    while (v5);
  }
  return result;
}

void std::__tree<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,std::__map_value_compare<std::shared_ptr<__CoalescingConnectionKey>,std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>,CoalescingConnectionKeyComparator,true>,std::allocator<std::__value_type<std::shared_ptr<__CoalescingConnectionKey>,std::set<std::string>>>>::__erase_unique<std::shared_ptr<__CoalescingConnectionKey>>(void *a1, void *a2)
{
  uint64_t v3 = a1 + 1;
  uint64_t v2 = (uint64_t *)a1[1];
  if (v2)
  {
    uint64_t v6 = a1 + 1;
    uint64_t v7 = a1[1];
    do
    {
      BOOL v8 = std::less<std::string>::operator()[abi:nn180100](*(void **)(v7 + 32), a2);
      uint64_t v9 = (uint64_t *)(v7 + 8);
      if (!v8)
      {
        uint64_t v9 = (uint64_t *)v7;
        uint64_t v6 = (void *)v7;
      }
      uint64_t v7 = *v9;
    }
    while (*v9);
    if (v6 != v3 && !std::less<std::string>::operator()[abi:nn180100](a2, (void *)v6[4]))
    {
      uint64_t v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        char v12 = v6;
        do
        {
          uint64_t v11 = (void *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          char v12 = v11;
        }
        while (!v13);
      }
      if ((void *)*a1 == v6) {
        *a1 = v11;
      }
      --a1[2];
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v2, v6);
      std::__destroy_at[abi:nn180100]<std::pair<std::shared_ptr<__CoalescingConnectionKey> const,std::set<std::string>>,0>((uint64_t)(v6 + 4));
      operator delete(v6);
    }
  }
}

void Schedulables::_SchedulablesScheduleApplierFunction(Schedulables *this, uint64_t *a2, void *a3)
{
}

void Schedulables::_SchedulablesUnscheduleApplierFunction(Schedulables *this, uint64_t *a2, void *a3)
{
}

void Schedulables::_SchedulablesInvalidateApplierFunction(Schedulables *this, const void *a2, void *a3)
{
  CFTypeID v4 = CFGetTypeID(this);
  _CFTypeInvalidate((char *)this);
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  if (*(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96) == v4)
  {
    CFHostCancelInfoResolution(this, kCFHostAddresses);
  }
  else if (CFNetServiceGetTypeID() == v4)
  {
    CFNetServiceCancel(this);
  }
}

void Schedulables::_add(Schedulables *this, const void *value)
{
  v4.CFStringRef length = *((void *)this + 3);
  v4.CFIndex location = 0;
  if (!CFArrayContainsValue(*((CFArrayRef *)this + 2), v4, value))
  {
    CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), value);
    ++*((void *)this + 3);
  }
}

void Schedulables::_remove(Schedulables *this, const void *value)
{
  v5.CFStringRef length = *((void *)this + 3);
  v5.CFIndex location = 0;
  FirstIndexOfCFDictionaryRef Value = CFArrayGetFirstIndexOfValue(*((CFArrayRef *)this + 2), v5, value);
  if (FirstIndexOfValue != -1)
  {
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 2), FirstIndexOfValue);
    --*((void *)this + 3);
  }
}

CFStringRef createStringFromSomeAddr(const __CFAllocator *a1, int (*a2)(int, sockaddr *, unsigned int *), const char *a3, uint64_t a4)
{
  int v4 = a4;
  v17[31] = *MEMORY[0x1E4F143B8];
  int v11 = 255;
  if (a2(a4, (sockaddr *)&v13, (unsigned int *)&v11))
  {
    __error();
    snprintf(__str, 0x400uLL, "error %d resolving %s address for socket %d");
    return CFStringCreateWithFormat(a1, 0, @"%s", __str, v10);
  }
  if (v14 == 2)
  {
    BOOL v8 = &v16;
  }
  else
  {
    if (v14 != 30)
    {
      snprintf(__str, 0x400uLL, "[error %d converting %s address for socket %d]");
      return CFStringCreateWithFormat(a1, 0, @"%s", __str, v10);
    }
    BOOL v8 = (int *)v17;
  }
  if (!inet_ntop(v14, v8, __str, 0x400u))
  {
    uint64_t v9 = __error();
    snprintf(__str, 0x400uLL, "[error %d converting %s address for socket %d]", *v9, a3, v4);
  }
  return CFStringCreateWithFormat(a1, 0, @"%s:%d", __str, bswap32(v15) >> 16);
}

void sub_184228CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__7431(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__7432(uint64_t a1)
{
}

void non-virtual thunk to'HTTP2ConnectionCacheEntry::~HTTP2ConnectionCacheEntry(HTTP2ConnectionCacheEntry *this)
{
}

{
  HTTP2ConnectionCacheEntry::~HTTP2ConnectionCacheEntry((HTTP2ConnectionCacheEntry *)((char *)this - 8));
}

void ___ZN25HTTP2ConnectionCacheEntry21releaseAllConnectionsEv_block_invoke(uint64_t a1, uint64_t a2)
{
}

CFStringRef HTTP2ConnectionCacheEntry::copyDebugDesc(HTTP2ConnectionCacheEntry *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v3 = (const __CFString *)(*(uint64_t (**)(void))(**((void **)this + 3) + 16))(*((void *)this + 3));
  int v4 = _cfnAutoreleaseInDebug(v3);
  return CFStringCreateWithFormat(v2, 0, @"HTTP2ConnectionCacheEntry(@%p, key=%s)", this, v4);
}

uint64_t HTTP2ConnectionCacheEntry::hash(HTTP2ConnectionCacheEntry *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 32))();
}

uint64_t HTTP2ConnectionCacheEntry::equals(HTTP2ConnectionCacheEntry *this, const CFObject *a2)
{
  CFTypeID v4 = CFGetTypeID((char *)this - 16);
  if (v4 != CFGetTypeID((char *)a2 - 16)) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(void, void))(**((void **)this + 3) + 24))(*((void *)this + 3), *((void *)a2 + 3));
  if (!result) {
    return result;
  }
  if (*((_DWORD *)this + 27) == *((_DWORD *)a2 + 27)
    && (CFIndex Count = CFArrayGetCount(*((CFArrayRef *)this + 11)), Count == CFArrayGetCount(*((CFArrayRef *)this + 11)))
    && *((unsigned __int8 *)this + 104) == *((unsigned __int8 *)a2 + 104))
  {
    return *((unsigned __int8 *)this + 105) == *((unsigned __int8 *)a2 + 105);
  }
  else
  {
    return 0;
  }
}

uint64_t ___ZN25HTTP2ConnectionCacheEntry23shouldOpenNewConnectionEv_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(result + 32) + 8);
  if (*(unsigned char *)(v2 + 24)) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = !*(unsigned char *)(a2 + 264)
  }
      && (*(_DWORD *)(a2 + 176) - 3) >= 2
      && (*(void *)(a2 + 144) | *(unsigned int *)(a2 + 152)) == 0;
  *(unsigned char *)(v2 + 24) = v3;
  return result;
}

void ___ZN25HTTP2ConnectionCacheEntry26markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  if (v2 && *(_DWORD *)v2 == 1)
  {
    uint64_t v3 = *(void *)(v2 + 8);
    CFTypeID v4 = *(std::__shared_weak_count **)(v2 + 16);
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 160))(v3);
    }
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_184228FC4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN25HTTP2ConnectionCacheEntry23logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  if (v2 && *(_DWORD *)v2 == 1)
  {
    uint64_t v3 = *(void *)(v2 + 8);
    CFTypeID v4 = *(std::__shared_weak_count **)(v2 + 16);
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 432))(v3);
    }
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_184229074(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

CFRunLoopSourceRef PAC::CreatePACTicket(PAC *this, const void *a2, const __CFURL *a3, const __CFData *a4, const __CFString *a5, void (*a6)(void *, const __CFArray *, __CFError *), CFStreamClientContext *a7)
{
  CFRunLoopRef context = (void *)MEMORY[0x18531D6D0](this, a2, a3, a4, a5, a6, a7);
  uint64_t v9 = (void *)[MEMORY[0x1E4F29088] componentsWithURL:a2 resolvingAgainstBaseURL:1];
  uint64_t v10 = (void *)[v9 string];
  uint64_t v11 = [v9 rangeOfHost];
  uint64_t v13 = v12;
  uint64_t v14 = [v9 rangeOfPort];
  uint64_t v16 = v15;
  uint64_t v17 = [v9 rangeOfScheme];
  long long v19 = NSString;
  if (v17 == 0x7FFFFFFFFFFFFFFFLL) {
    long long v20 = &stru_1ECFAD558;
  }
  else {
    long long v20 = (__CFString *)objc_msgSend(v10, "substringWithRange:", v17, v18);
  }
  if (v11 == 0x7FFFFFFFFFFFFFFFLL) {
    long long v21 = &stru_1ECFAD558;
  }
  else {
    long long v21 = (__CFString *)objc_msgSend(v10, "substringWithRange:", v11, v13);
  }
  if (v14 == 0x7FFFFFFFFFFFFFFFLL) {
    long long v22 = &stru_1ECFAD558;
  }
  else {
    long long v22 = (__CFString *)[NSString stringWithFormat:@":%@", objc_msgSend(v10, "substringWithRange:", v14, v16)];
  }
  CFStringRef v23 = (const __CFString *)(id)[v19 stringWithFormat:@"%@://%@%@/", v20, v21, v22];
  CFURLRef contexta = CFURLCreateWithString(0, v23, 0);
  long long v24 = (char *)operator new(0xE0uLL);
  *(_OWORD *)(v24 + 8) = 0u;
  long long v25 = *((_OWORD *)a6 + 1);
  *(_OWORD *)(v24 + 40) = *(_OWORD *)a6;
  *(void *)long long v24 = &unk_1ECFA6DB0;
  *(_OWORD *)(v24 + 24) = 0u;
  *(_OWORD *)(v24 + 56) = v25;
  *((void *)v24 + 9) = *((void *)a6 + 4);
  *((_OWORD *)v24 + 5) = 0u;
  *((void *)v24 + 12) = a5;
  *(_OWORD *)(v24 + 104) = 0u;
  long long v26 = (const void **)(v24 + 104);
  *((void *)v24 + 20) = 850045863;
  *(_OWORD *)(v24 + 120) = 0u;
  *(_OWORD *)(v24 + 136) = 0u;
  *((_WORD *)v24 + 76) = 0;
  *(_OWORD *)(v24 + 168) = 0u;
  *(_OWORD *)(v24 + 184) = 0u;
  *(_OWORD *)(v24 + 200) = 0u;
  *((void *)v24 + 27) = 0;
  if (!*((void *)v24 + 6) || (uint64_t v27 = (void (*)(void))*((void *)v24 + 7)) == 0)
  {
    uint64_t v29 = (std::__shared_weak_count **)(v24 + 32);
    goto LABEL_16;
  }
  v27();
  uint64_t v29 = (std::__shared_weak_count **)(v24 + 32);
  unint64_t v28 = (std::__shared_weak_count *)*((void *)v24 + 4);
  if (!v28)
  {
LABEL_16:
    atomic_fetch_add_explicit((atomic_ullong *volatile)v24 + 1, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_ullong *volatile)v24 + 2, 1uLL, memory_order_relaxed);
    *((void *)v24 + 3) = v24 + 24;
    *((void *)v24 + 4) = v24;
    goto LABEL_17;
  }
  if (v28->__shared_owners_ != -1) {
    goto LABEL_18;
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)v24 + 1, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit((atomic_ullong *volatile)v24 + 2, 1uLL, memory_order_relaxed);
  *((void *)v24 + 3) = v24 + 24;
  *((void *)v24 + 4) = v24;
  std::__shared_weak_count::__release_weak(v28);
LABEL_17:
  std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v24);
LABEL_18:
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v40, *((void *)v24 + 3), *v29);
  if ((void)v40)
  {
    aBlock.version = MEMORY[0x1E4F143A8];
    aBlock.info = (void *)3321888768;
    aBlock.retain = (const void *(__cdecl *)(const void *))___ZN3PAC9PACClient10initializeEPKvPK7__CFURLPK8__CFDataPK10__CFString_block_invoke;
    aBlock.release = (void (__cdecl *)(const void *))&__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrIN3PAC9PACClientEEE_e161_v56__0____CFString__8____CFData__16_shared_ptr_const___CFArray______CFArray_____shared_weak_count__24_shared_ptr___CFError______CFError_____shared_weak_count__40l;
    *(_OWORD *)&aBlock.copyDescription = v40;
    if (*((void *)&v40 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v30 = operator new(0x78uLL);
    v30[1] = 0;
    v30[2] = 0;
    *unint64_t v30 = &unk_1ECFA6D78;
    if (*((void *)&v40 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v40 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    operator new();
  }
  if (*((void *)&v40 + 1)) {
    std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v40 + 1));
  }
  memset(&aBlock.retain, 0, 40);
  aBlock.version = 0;
  aBlock.info = v24 + 24;
  aBlock.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))PAC::rlsSchedule;
  aBlock.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))PAC::rlsCancel;
  aBlock.perform = (void (__cdecl *)(void *))PAC::rlsPerform;
  CFRunLoopSourceRef v31 = CFRunLoopSourceCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &aBlock);
  CFRunLoopSourceRef v32 = v31;
  if (v31) {
    CFTypeRef v33 = CFRetain(v31);
  }
  else {
    CFTypeRef v33 = 0;
  }
  uint64_t v34 = *v26;
  *long long v26 = v33;
  if (v34) {
    CFRelease(v34);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v24);
  if (contexta) {
    CFRelease(contexta);
  }
  if (v23) {
    CFRelease(v23);
  }
  return v32;
}

void sub_1842295CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFTypeRef a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, CFTypeRef cf, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  shared_owners = (const void *)v27[2].__shared_owners_;
  v27[2].__shared_owners_ = 0;
  if (shared_owners) {
    CFRelease(shared_owners);
  }
  CFTypeRef v33 = v27[2].__vftable;
  v27[2].__vftable = 0;
  if (v33) {
    CFRelease(v33);
  }
  uint64_t v34 = *v24;
  char *v24 = 0;
  if (v34) {
    CFRelease(v34);
  }
  uint64_t v35 = (const void *)v27[1].__shared_owners_;
  v27[1].__shared_owners_ = 0;
  if (v35) {
    CFRelease(v35);
  }
  CFStringRef v36 = *v26;
  *long long v26 = 0;
  if (v36) {
    CFRelease(v36);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v29);
  if (v28) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v28);
  }
  std::__shared_weak_count::~__shared_weak_count(v27);
  operator delete(v37);
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a24);
  }
  uint64_t v38 = *(std::__shared_weak_count **)(v30 - 96);
  if (v38) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v38);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v25);
  if (cf) {
    CFRelease(cf);
  }
  if (a13) {
    CFRelease(a13);
  }
  _Unwind_Resume(a1);
}

void PAC::rlsPerform(PAC *this, void *a2)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v4, *(void *)this, *((std::__shared_weak_count **)this + 1));
  uint64_t v2 = v4;
  uint64_t v3 = (std::mutex *)(v4 + 136);
  std::mutex::lock((std::mutex *)(v4 + 136));
  *(unsigned char *)(v2 + 128) = 1;
  std::mutex::unlock(v3);
  (*(void (**)(void, void, void))(v2 + 72))(*(void *)(v2 + 24), *(void *)(v2 + 96), *(void *)(v2 + 112));
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184229818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void PAC::rlsCancel(PAC *this, void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v8, *(void *)this, *((std::__shared_weak_count **)this + 1));
  uint64_t v4 = v8;
  CFRange v5 = (std::mutex *)(v8 + 136);
  std::mutex::lock((std::mutex *)(v8 + 136));
  if (*(unsigned char *)(v4 + 128))
  {
    uint64_t v6 = *(void *)(v4 + 56);
    uint64_t v7 = *(std::__shared_weak_count **)(v6 + 64);
    *(void *)(v6 + 56) = 0;
    *(void *)(v6 + 64) = 0;
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
  }
  else
  {
    *(unsigned char *)(v4 + 129) = 1;
  }
  std::mutex::unlock(v5);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
}

void sub_1842298AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void PAC::rlsSchedule(PAC *this, void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v9, *(void *)this, *((std::__shared_weak_count **)this + 1));
  uint64_t v5 = v9;
  CFTypeRef v6 = CFRetain(a2);
  uint64_t v7 = *(const void **)(v5 + 88);
  *(void *)(v5 + 88) = v6;
  if (v7) {
    CFRelease(v7);
  }
  if (CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once != -1) {
    dispatch_once(&CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once, &__block_literal_global_11694);
  }
  uint64_t v8 = *(void *)(v5 + 64);
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  xpc_dictionary_create(0, 0, 0);
  operator new();
}

void sub_184229D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(a1);
}

void ___ZN3PAC9PACClient10initializeEPKvPK7__CFURLPK8__CFDataPK10__CFString_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v7 = *a4;
  CFTypeRef v6 = (std::__shared_weak_count *)a4[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *a5;
  uint64_t v8 = (std::__shared_weak_count *)a5[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (std::mutex *)(v5 + 136);
  std::mutex::lock((std::mutex *)(v5 + 136));
  if (!*(void *)(v5 + 96) && !*(void *)(v5 + 112))
  {
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v11 = *(std::__shared_weak_count **)(v5 + 104);
    *(void *)(v5 + 96) = v7;
    *(void *)(v5 + 104) = v6;
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v12 = *(std::__shared_weak_count **)(v5 + 120);
    *(void *)(v5 + 112) = v9;
    *(void *)(v5 + 120) = v8;
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
    }
  }
  std::mutex::unlock((std::mutex *)(v5 + 136));
  std::mutex::lock((std::mutex *)(v5 + 136));
  if (!*(unsigned char *)(v5 + 129))
  {
    uint64_t v15 = *(const void **)(v5 + 80);
    if (v15) {
      uint64_t v16 = (__CFRunLoopSource *)CFRetain(v15);
    }
    else {
      uint64_t v16 = 0;
    }
    uint64_t v17 = *(const void **)(v5 + 88);
    if (v17)
    {
      uint64_t v18 = (void *)CFRetain(v17);
      std::mutex::unlock(v10);
      if (!v16)
      {
        if (!v18) {
          goto LABEL_31;
        }
LABEL_29:
        CFRelease(v18);
        if (!v16) {
          goto LABEL_31;
        }
        goto LABEL_30;
      }
      if (v18)
      {
        CFRunLoopSourceSignal(v16);
        CFRunLoopWakeUp((CFRunLoopRef)v18);
        goto LABEL_29;
      }
    }
    else
    {
      std::mutex::unlock((std::mutex *)(v5 + 136));
      if (!v16) {
        goto LABEL_31;
      }
    }
LABEL_30:
    CFRelease(v16);
    goto LABEL_31;
  }
  uint64_t v13 = *(void *)(v5 + 56);
  uint64_t v14 = *(std::__shared_weak_count **)(v13 + 64);
  *(void *)(v13 + 56) = 0;
  *(void *)(v13 + 64) = 0;
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  std::mutex::unlock((std::mutex *)(v5 + 136));
LABEL_31:
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_184229F18(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;
  CFRelease(v5);
  CFRelease(v3);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
    if (!v1) {
LABEL_4:
    }
      _Unwind_Resume(a1);
  }
  else if (!v1)
  {
    goto LABEL_4;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  goto LABEL_4;
}

uint64_t std::__shared_ptr_pointer<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>> *,SmartBlockWithArgs<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::Deleter,std::allocator<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v3 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *, uint64_t *))(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | (unint64_t)v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if (v3 == BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_initial
    && v5 != 0)
  {
    uint64_t v7 = (uint64_t *)(v1 + (v2 >> 1));
    if (v2) {
      uint64_t v8 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *, uint64_t *))(*v7
    }
                                                                                    + BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_initial);
    else {
      uint64_t v8 = BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_initial;
    }
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    v8(v7, 0, 0, &v12, &v10);
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v13);
    }
  }
  _Block_release(*(const void **)v1);
  return MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
}

void sub_18422A084(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>> *,SmartBlockWithArgs<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::Deleter,std::allocator<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_initial(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  a1[1] = (uint64_t)BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_normal;
  a1[2] = 0;
  uint64_t v5 = *a1;
  CFTypeRef v6 = (std::__shared_weak_count *)a4[1];
  uint64_t v10 = *a4;
  uint64_t v11 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::__shared_weak_count *)a5[1];
  uint64_t v8 = *a5;
  uint64_t v9 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *))(v5 + 16))(v5, a2, a3, &v10, &v8);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
}

void sub_18422A17C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_normal(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *a1;
  CFTypeRef v6 = (std::__shared_weak_count *)a4[1];
  uint64_t v10 = *a4;
  uint64_t v11 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::__shared_weak_count *)a5[1];
  uint64_t v8 = *a5;
  uint64_t v9 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *))(v5 + 16))(v5, a2, a3, &v10, &v8);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
}

void sub_18422A224(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<PAC::PACQuery>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[13];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[11];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  BOOL v4 = (const void *)a1[9];
  a1[9] = 0;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[8];
  a1[8] = 0;
  if (v5) {
    CFRelease(v5);
  }
  CFTypeRef v6 = (const void *)a1[7];
  a1[7] = 0;
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[6];
  a1[6] = 0;
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)a1[5];
  a1[5] = 0;
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)a1[4];
  a1[4] = 0;
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = (const void *)a1[3];
  a1[3] = 0;
  if (v10)
  {
    CFRelease(v10);
  }
}

void std::__shared_ptr_emplace<PAC::PACQuery>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6D78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<PAC::PACQuery>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6D78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrIN3PAC9PACClientEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrIN3PAC9PACClientEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_emplace<PAC::PACClient>::__on_zero_shared(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v2 = *(void (**)(void))(a1 + 64);
    if (v2) {
      v2();
    }
  }
  std::mutex::~mutex((std::mutex *)(a1 + 160));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 144);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 128);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  uint64_t v5 = *(const void **)(a1 + 112);
  *(void *)(a1 + 112) = 0;
  if (v5) {
    CFRelease(v5);
  }
  CFTypeRef v6 = *(const void **)(a1 + 104);
  *(void *)(a1 + 104) = 0;
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 32);
  if (v8)
  {
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_18422A454(_Unwind_Exception *a1)
{
  std::mutex::~mutex((std::mutex *)(v1 + 160));
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 144);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  BOOL v4 = *(std::__shared_weak_count **)(v1 + 128);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  uint64_t v5 = *(const void **)(v1 + 112);
  *(void *)(v1 + 112) = 0;
  if (v5) {
    CFRelease(v5);
  }
  CFTypeRef v6 = *(const void **)(v1 + 104);
  *(void *)(v1 + 104) = 0;
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 88);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(v1 + 32);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PAC::PACClient>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6DB0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<PAC::PACClient>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6DB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

CFArrayRef CFNetworkCopyProxiesForAutoConfigurationScript(CFStringRef proxyAutoConfigurationScript, CFURLRef targetURL, CFErrorRef *error)
{
  CFArrayRef v10 = 0;
  CFTypeRef cf = 0;
  CFRunLoopRef rl = 0;
  v9[0] = 0;
  v9[1] = &v10;
  memset(&v9[2], 0, 24);
  CFRunLoopRef rl = CFRunLoopGetCurrent();
  PACTicket = PAC::CreatePACTicket((PAC *)proxyAutoConfigurationScript, targetURL, 0, 0, (const __CFString *)CFNetworkCopyProxiesForAutoConfigurationScriptCallback, (void (*)(void *, const __CFArray *, __CFError *))v9, v6);
  CFRunLoopAddSource(rl, PACTicket, @"__CFNetworkCopyProxiesForAutoConfigurationScript_privatemode__");
  CFRunLoopRunInMode(@"__CFNetworkCopyProxiesForAutoConfigurationScript_privatemode__", 1.0e10, 0);
  CFRunLoopSourceInvalidate(PACTicket);
  CFRelease(PACTicket);
  if (error)
  {
    *SInt32 error = (CFErrorRef)cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v10;
}

void CFNetworkCopyProxiesForAutoConfigurationScriptCallback(void *a1, CFTypeRef cf, __CFError *a3)
{
  if (cf) {
    CFTypeRef v5 = CFRetain(cf);
  }
  else {
    CFTypeRef v5 = 0;
  }
  *a1 = v5;
  if (a3) {
    CFTypeRef v6 = CFRetain(a3);
  }
  else {
    CFTypeRef v6 = 0;
  }
  a1[1] = v6;
  uint64_t v7 = (__CFRunLoop *)a1[2];

  CFRunLoopStop(v7);
}

void ClassicStreamClient::~ClassicStreamClient(ClassicStreamClient *this)
{
  *(void *)this = &unk_1ECF9FA48;
  if (*((void *)this + 4))
  {
    uint64_t v2 = (void (*)(void))*((void *)this + 6);
    if (v2) {
      v2();
    }
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);

  CFAllocatorDeallocate(v3, this);
}

{
  void (*v1)(void);

  *(void *)this = &unk_1ECF9FA48;
  if (*((void *)this + 4))
  {
    uint64_t v1 = (void (*)(void))*((void *)this + 6);
    if (v1) {
      v1();
    }
  }
}

void ClassicStreamClient::ClassicStreamClient(ClassicStreamClient *this, const __CFAllocator *a2, const CFStreamClientContext *a3)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, a2);
  *(void *)uint64_t v5 = &unk_1ECF9FA48;
  copyDescription = a3->copyDescription;
  long long v7 = *(_OWORD *)&a3->retain;
  *(_OWORD *)(v5 + 24) = *(_OWORD *)&a3->version;
  *(void *)(v5 + 56) = copyDescription;
  *(_OWORD *)(v5 + 40) = v7;
  if (*(void *)(v5 + 32))
  {
    uint64_t v8 = (uint64_t (*)(void))*((void *)this + 5);
    if (v8) {
      *((void *)this + 4) = v8();
    }
  }
}

CFStringRef ClassicStreamClient::clientCopyDescription(ClassicStreamClient *this)
{
  uint64_t v2 = (uint64_t (*)(void))*((void *)this + 7);
  if (!v2) {
    return CFStringCreateWithFormat(*((CFAllocatorRef *)this + 1), 0, @"Classic Stream Client <%p>", *((void *)this + 4));
  }
  CFStringRef result = (CFStringRef)v2(*((void *)this + 4));
  if (!result) {
    return CFStringCreateWithFormat(*((CFAllocatorRef *)this + 1), 0, @"Classic Stream Client <%p>", *((void *)this + 4));
  }
  return result;
}

void non-virtual thunk to'KerberosAccountStore::~KerberosAccountStore(KerberosAccountStore *this)
{
  uint64_t v2 = (char *)this - 24;
  KerberosAccountStore::~KerberosAccountStore((KerberosAccountStore *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  KerberosAccountStore::~KerberosAccountStore((KerberosAccountStore *)((char *)this - 24));
}

void KerberosAccountStore::~KerberosAccountStore(KerberosAccountStore *this)
{
  *(void *)this = &unk_1ECFA1788;
  *((void *)this + 3) = &unk_1ECFA17E0;
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    dispatch_release(v2);
  }
  CFAllocatorRef v3 = *((void *)this + 11);
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = *((void *)this + 10);
  if (v4) {
    CFRelease((CFTypeRef)(v4 - 16));
  }
  uint64_t v5 = (const void *)*((void *)this + 9);
  if (v5) {
    CFRelease(v5);
  }
  CFTypeRef v6 = (const void *)*((void *)this + 8);
  if (v6) {
    CFRelease(v6);
  }
  long long v7 = (const void *)*((void *)this + 7);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)*((void *)this + 6);
  if (v8) {
    CFRelease(v8);
  }

  CFNAccountStore::~CFNAccountStore(this);
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  KerberosAccountStore::~KerberosAccountStore(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_18422A904(_Unwind_Exception *a1)
{
  CFNAccountStore::~CFNAccountStore(v1);
  _Unwind_Resume(a1);
}

CFStringRef KerberosAccountStore::copyDebugDesc(KerberosAccountStore *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<KerberosAccountStore@%p>", this);
}

uint64_t ___ZN20KerberosAccountStore42getKerberosCredentialWithCompletionHandlerEPK16_CFURLCredentialU13block_pointerFvS2_E_block_invoke(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v2 = *(const void **)(a1 + 48);
  if (v2 && (uint64_t v4 = *(const void **)(v3 + 72)) != 0) {
    CFURLRef v5 = (const __CFURL *)(CFEqual(v2, v4) != 0);
  }
  else {
    CFURLRef v5 = 0;
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 56), *(const void **)(a1 + 32));
  CFArrayRef v6 = *(const __CFArray **)(v3 + 56);
  if (!v6 || CFArrayGetCount(v6) <= 1) {
    KerberosAccountStore::fetchKerberosCredential((KerberosAccountStore *)v3, v5);
  }
  long long v7 = *(const void **)(a1 + 48);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t))(*(void *)v3 + 48);

  return v8(v3);
}

void KerberosAccountStore::fetchKerberosCredential(KerberosAccountStore *this, const __CFURL *a2)
{
  if (a2)
  {
    if (*(unsigned char *)(*((void *)this + 10) + 48))
    {
      KerberosAccountStore::useCredentialFromNextAccountOrDieTrying(this, a2);
      return;
    }
    (*(void (**)(KerberosAccountStore *))(*(void *)this + 40))(this);
    uint64_t v4 = *((void *)this + 12);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    v7[2] = ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke;
    v7[3] = &__block_descriptor_40_e5_v8__0l;
    v7[4] = this;
    CFURLRef v5 = v7;
    goto LABEL_10;
  }
  uint64_t v3 = (const _CFURLCredential *)*((void *)this + 9);
  if (!v3)
  {
    (*(void (**)(KerberosAccountStore *))(*(void *)this + 40))(this);
    uint64_t v4 = *((void *)this + 12);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke;
    v6[3] = &__block_descriptor_40_e5_v8__0l;
    _OWORD v6[4] = this;
    CFURLRef v5 = v6;
LABEL_10:
    dispatch_async(v4, v5);
    return;
  }

  KerberosAccountStore::sendKerberosCredentialToClients(this, v3);
}

void KerberosAccountStore::sendKerberosCredentialToClients(KerberosAccountStore *this, const _CFURLCredential *a2)
{
  CFArrayRef v3 = (const __CFArray *)*((void *)this + 7);
  if (v3)
  {
    CFArrayRef Copy = CFArrayCreateCopy(*((CFAllocatorRef *)this + 1), v3);
    if (Copy)
    {
      CFArrayRef v6 = Copy;
      dispatch_queue_t v7 = dispatch_queue_create("com.apple.kerberosaccountstore.cbqueue", 0);
      if (v7)
      {
        uint64_t v8 = v7;
        if (a2) {
          CFRetain(a2);
        }
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = ___ZN20KerberosAccountStore31sendKerberosCredentialToClientsEPK16_CFURLCredential_block_invoke;
        CFHostClientContext block[3] = &unk_1E5255EB0;
        void block[5] = v6;
        block[6] = a2;
        block[4] = v8;
        dispatch_async(v8, block);
      }
      else
      {
        CFRelease(v6);
      }
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)this + 7));
    }
  }
}

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void **)(a1 + 32);
  (*(void (**)(void *))(*v1 + 40))(v1);
  uint64_t v2 = v1[8];
  CFArrayRef v3 = v1[11];
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_2;
  v10[3] = &__block_descriptor_40_e35_v24__0____CFArray__8____CFError__16l;
  v10[4] = v1;
  (*(void (**)(void *))(*v1 + 40))(v1);
  dispatch_retain(v3);
  uint64_t v4 = (void *)v1[4];
  *(void *)&long long buf = MEMORY[0x1E4F143A8];
  *((void *)&buf + 1) = 3221225472;
  uint64_t v12 = ___ZN15CFNAccountStore32kerberosAccountsForDomainFromURLEPK7__CFURLPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvPK9__CFArrayP9__CFErrorE_block_invoke;
  uint64_t v13 = &unk_1E52567E8;
  uint64_t v15 = v10;
  uint64_t v16 = v1;
  uint64_t v14 = v3;
  [v4 kerberosAccountsForDomainFromURL:v2 completion:&buf];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFURLRef v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = v1[8];
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "Fetching Account for domain %p", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_15_7553, 3);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v7 + 16))(v7, "Fetching Account for domain", 0))
    {
      (*(void (**)(uint64_t, const char *, void))(*(void *)v8 + 40))(v8, "URL", v1[8]);
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
  }
  return (*(uint64_t (**)(void *))(*v1 + 48))(v1);
}

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_2(uint64_t a1, const __CFArray *a2, __CFError *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    if (a2)
    {
      CFIndex Count = CFArrayGetCount(a2);
      if (a3)
      {
LABEL_6:
        CFIndex Code = CFErrorGetCode(a3);
LABEL_9:
        *(_DWORD *)uint64_t v16 = 134218498;
        *(void *)&v16[4] = Count;
        *(_WORD *)&v16[12] = 2112;
        *(void *)&v16[14] = a3;
        *(_WORD *)&v16[22] = 2048;
        CFIndex v17 = Code;
        _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "Accounts sent %ld account(s), error=%@ [%ld]", v16, 0x20u);
        goto LABEL_10;
      }
    }
    else
    {
      CFIndex Count = 0;
      if (a3) {
        goto LABEL_6;
      }
    }
    CFIndex Code = 0;
    goto LABEL_9;
  }
LABEL_10:
  uint64_t v9 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_7562, 3);
  uint64_t v11 = v9;
  if (v9
    && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v9 + 16))(v9, "Received Accounts", 0))
  {
    (*(void (**)(uint64_t, const char *, void))(*(void *)v11 + 40))(v11, "URL", *(void *)(v5 + 64));
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *(void *)uint64_t v16 = off_1ECF9A530;
    CFStringRef v13 = CFStringCreateWithCString(v12, "Accounts", 0x8000100u);
    CFIndex v17 = 0;
    *(_OWORD *)&v16[8] = (unint64_t)v13;
    if (a2)
    {
      CFStringRef v14 = CFCopyDescription(a2);
      CFStringRef v13 = *(CFStringRef *)&v16[8];
    }
    else
    {
      CFStringRef v14 = @"null";
    }
    (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(void *)v11 + 64))(v11, v13, v14);
    if (a2 && v14) {
      CFRelease(v14);
    }
    AutoString::~AutoString((AutoString *)v16);
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  if (a2 && !a3 && CFArrayGetCount(a2) >= 1) {
    *(void *)(v5 + 48) = CFArrayCreateMutableCopy(*(CFAllocatorRef *)(v5 + 8), 0, a2);
  }
  KerberosAccountStore::useCredentialFromNextAccountOrDieTrying((KerberosAccountStore *)v5, v10);
  return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5);
}

void sub_18422B220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_13@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 112;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void KerberosAccountStore::useCredentialFromNextAccountOrDieTrying(KerberosAccountStore *this, const __CFURL *a2)
{
  uint64_t v3 = *((void *)this + 10);
  if (v3)
  {
    CFRelease((CFTypeRef)(v3 - 16));
    *((void *)this + 10) = 0;
  }
  *((void *)this + 9) = 0;
  CFArrayRef v4 = (const __CFArray *)*((void *)this + 6);
  if (v4 && CFArrayGetCount(v4) >= 1)
  {
    CFStringRef ValueAtIndex = (objc_object *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 6), 0);
    if (ValueAtIndex)
    {
      uint64_t v6 = ValueAtIndex;
      if (CFNAccountKerberos::Class(void)::sOnce_CFNAccountKerberos != -1) {
        dispatch_once(&CFNAccountKerberos::Class(void)::sOnce_CFNAccountKerberos, &__block_literal_global_20297);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      Instance += 16;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(void *)(Instance + CFRetain((char *)this - 16) = 0;
      *(void *)(Instance + 24) = 0;
      *(void *)(Instance + 32) = 0;
      *(void *)uint64_t Instance = &unk_1ECF9EE70;
      *(void *)(Instance + 8) = &unk_1ECF9EEC0;
      *(void *)(Instance + 56) = 0;
      *((void *)this + 10) = Instance;
      if (!CFNAccountKerberos::initialize((CFNAccountKerberos *)Instance, v6))
      {
        CFRelease((CFTypeRef)(*((void *)this + 10) - 16));
        *((void *)this + 10) = 0;
      }
    }
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 6), 0);
  }
  uint64_t v8 = (CFNAccountKerberos *)*((void *)this + 10);
  if (v8)
  {
    uint64_t v9 = CFNAccountKerberos::kerberosCredential(v8, a2);
    *((void *)this + 9) = v9;
    KerberosAccountStore::fetchKerberosCredential(this, v9 == 0);
  }
  else
  {
    CFURLRef v10 = (const void *)*((void *)this + 6);
    *((void *)this + 6) = 0;
    if (v10) {
      CFRelease(v10);
    }
    KerberosAccountStore::sendKerberosCredentialToClients(this, 0);
  }
}

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_4@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 101;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN20KerberosAccountStore31sendKerberosCredentialToClientsEPK16_CFURLCredential_block_invoke(uint64_t a1)
{
  for (CFIndex i = 0; ; ++i)
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    CFArrayRef v4 = *(const __CFArray **)(a1 + 40);
    if (i >= Count) {
      break;
    }
    CFStringRef ValueAtIndex = (void (**)(const void *, void))CFArrayGetValueAtIndex(v4, i);
    ValueAtIndex[2](ValueAtIndex, *(void *)(a1 + 48));
    _Block_release(ValueAtIndex);
  }
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v6 = *(const void **)(a1 + 48);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = *(NSObject **)(a1 + 32);

  dispatch_release(v7);
}

uint64_t ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  (*(void (**)(void *))(*v1 + 40))(v1);
  uint64_t v2 = v1[11];
  uint64_t v3 = *(void **)(v1[10] + 16);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke_2;
  v8[3] = &__block_descriptor_40_e23_v24__0q8____CFError__16l;
  v8[4] = v1;
  (*(void (**)(void *))(*v1 + 40))(v1);
  dispatch_retain(v2);
  id v4 = v3;
  uint64_t v5 = (void *)v1[4];
  *(void *)long long buf = MEMORY[0x1E4F143A8];
  uint64_t v10 = 3221225472;
  uint64_t v11 = ___ZN15CFNAccountStore26renewCredentialsForAccountEP11objc_objectPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvlP9__CFErrorE_block_invoke;
  CFAllocatorRef v12 = &unk_1E52567C0;
  uint64_t v15 = v8;
  uint64_t v16 = v1;
  CFStringRef v13 = v2;
  CFStringRef v14 = v3;
  [v5 renewCredentialsForAccount:v3 completion:buf];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "Renewing current credential for account", buf, 2u);
  }
  return (*(uint64_t (**)(void *))(*v1 + 48))(v1);
}

uint64_t ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke_2(uint64_t a1, uint64_t a2, __CFError *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(KerberosAccountStore **)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      CFIndex Code = CFErrorGetCode(a3);
    }
    else {
      CFIndex Code = 0;
    }
    int v16 = 134218498;
    uint64_t v17 = a2;
    __int16 v18 = 2112;
    long long v19 = a3;
    __int16 v20 = 2048;
    CFIndex v21 = Code;
    _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "Accounts renewed credential result=%ld, error=%@ [%ld]", (uint8_t *)&v16, 0x20u);
  }
  if (a2 == 1)
  {
    CFStringRef v14 = v5;
    CFStringRef v13 = 0;
  }
  else
  {
    if (a2)
    {
      KerberosAccountStore::useCredentialFromNextAccountOrDieTrying(v5, v7);
      return (*(uint64_t (**)(KerberosAccountStore *))(*(void *)v5 + 48))(v5);
    }
    uint64_t v9 = *((void *)v5 + 10);
    uint64_t v10 = *(const void **)(v9 + 32);
    *(void *)(v9 + 32) = 0;
    if (v10) {
      CFRelease(v10);
    }
    uint64_t v11 = *(void **)(v9 + 24);
    if (v11)
    {

      *(void *)(v9 + 24) = 0;
    }
    CFAllocatorRef v12 = (CFNAccountKerberos *)*((void *)v5 + 10);
    *((unsigned char *)v12 + 48) = 1;
    CFStringRef v13 = (const _CFURLCredential *)CFNAccountKerberos::kerberosCredential(v12, v7);
    *((void *)v5 + 9) = v13;
    CFStringRef v14 = v5;
  }
  KerberosAccountStore::sendKerberosCredentialToClients(v14, v13);
  return (*(uint64_t (**)(KerberosAccountStore *))(*(void *)v5 + 48))(v5);
}

uint64_t ___ZN20KerberosAccountStore24clearAccountRefreshStateEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = v1[10];
  if (v2) {
    *(unsigned char *)(v2 + 48) = 0;
  }
  return (*(uint64_t (**)(void))(*v1 + 48))();
}

unsigned __int8 *_DNSServiceConvertDomainLabelToCString_withescape(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v5 = *a1;
  uint64_t v3 = a1 + 1;
  uint64_t v4 = v5;
  if (v5 > 0x3F) {
    return 0;
  }
  if (v4)
  {
    uint64_t v6 = &v3[v4];
    do
    {
      unsigned __int8 v8 = *v3++;
      unsigned __int8 v7 = v8;
      if (a3)
      {
        if (v7 == 46 || v7 == a3)
        {
          *a2++ = a3;
        }
        else if (v7 <= 0x20u)
        {
          *a2 = a3;
          a2[1] = 48;
          a2[2] = (v7 / 0xAu) | 0x30;
          a2 += 3;
          unsigned __int8 v7 = (v7 % 0xAu) | 0x30;
        }
      }
      *a2++ = v7;
    }
    while (v3 < v6);
  }
  *a2 = 0;
  return a2;
}

unsigned __int8 *_DNSServiceConvertDomainNameToCString_withescape(unsigned __int8 *result, unsigned __int8 *a2)
{
  uint64_t v2 = result;
  unsigned int v3 = *result;
  if (*result || (*a2 = 46, ++a2, (unsigned int v3 = *result) != 0))
  {
    uint64_t v4 = 0;
    while (v4 + 1 + (unint64_t)v3 <= 0xFF)
    {
      uint64_t result = _DNSServiceConvertDomainLabelToCString_withescape(result, a2, 92);
      if (!result) {
        break;
      }
      v4 += 1 + v2[v4];
      *uint64_t result = 46;
      a2 = result + 1;
      uint64_t result = &v2[v4];
      unsigned int v3 = v2[v4];
      if (!v2[v4]) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    *a2 = 0;
  }
  return result;
}

uint64_t non-virtual thunk to'Tube::clientDescription(Tube *this)
{
  return Tube::clientDescription((Tube *)((char *)this - 96));
}

uint64_t Tube::clientDescription(Tube *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 14) + 80))(*((void *)this + 14));
  if (result)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)(result - 176) + 264);
    return v2();
  }
  return result;
}

uint64_t non-virtual thunk to'Tube::resetAuthState(Tube *this)
{
  return Tube::resetAuthState((Tube *)((char *)this - 96));
}

uint64_t Tube::resetAuthState(Tube *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 14) + 80))(*((void *)this + 14));
  if (result)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)(result - 176) + 256);
    return v2();
  }
  return result;
}

void non-virtual thunk to'Tube::generateProxyAuthentication(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
}

void Tube::generateProxyAuthentication(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (a1[14])
  {
    (*(void (**)(void *))(*a1 + 40))(a1);
    operator new();
  }
  uint64_t v4 = *a4;
  if (*a4)
  {
    unsigned int v5 = *(void (**)(void *, uint64_t *))(v4 + 8);
    uint64_t v6 = *(void *)(v4 + 16);
    unsigned __int8 v7 = (void *)(v4 + (v6 >> 1));
    if (v6) {
      unsigned int v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
    }
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    v5(v7, &v8);
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
    }
  }
}

void sub_18422BDD8(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 56);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke(void *a1, uint64_t *a2)
{
  unsigned int v3 = *(NSObject **)(a1[4] + 160);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3321888768;
  v7[2] = ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke_2;
  v7[3] = &__block_descriptor_64_e8_32c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE48c47_ZTSNSt3__110shared_ptrI19AuthenticationStateEE_e5_v8__0l;
  uint64_t v5 = a1[6];
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  v7[4] = v5;
  uint64_t v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_async(v3, v7);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
}

void __destroy_helper_block_e8_32c31_ZTSNSt3__110shared_ptrI4TubeEE48c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  unsigned int v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_e8_32c31_ZTSNSt3__110shared_ptrI4TubeEE48c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke_2(void *a1)
{
  uint64_t v1 = a1[6];
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = a1[4];
    if (!v3)
    {
LABEL_13:
      std::__shared_weak_count::__release_shared[abi:nn180100](v2);
      return;
    }
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v3 = a1[4];
    if (!v3) {
      return;
    }
  }
  uint64_t v4 = *(void (**)(void *, uint64_t *))(v3 + 8);
  uint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = (void *)(v3 + (v5 >> 1));
  if (v5) {
    uint64_t v4 = *(void (**)(void *, uint64_t *))(*v6 + v4);
  }
  uint64_t v7 = v1;
  uint64_t v8 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v4(v6, &v7);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
    goto LABEL_13;
  }
}

void sub_18422C048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_32c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE48c47_ZTSNSt3__110shared_ptrI19AuthenticationStateEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_e8_32c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE48c47_ZTSNSt3__110shared_ptrI19AuthenticationStateEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<Tube *,Tube::generateProxyAuthentication(std::shared_ptr<NetworkProxy>,std::shared_ptr<HTTPResponseMessage>,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>)::$_0,std::allocator<Tube>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

void std::__shared_ptr_pointer<Tube *,Tube::generateProxyAuthentication(std::shared_ptr<NetworkProxy>,std::shared_ptr<HTTPResponseMessage>,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>)::$_0,std::allocator<Tube>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void non-virtual thunk to'Tube::~Tube(Tube *this)
{
  uint64_t v2 = (char *)this - 96;
  Tube::~Tube((Tube *)((char *)this - 96));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 11);

  CFAllocatorDeallocate(v3, v2);
}

{
  Tube::~Tube((Tube *)((char *)this - 96));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 40;
  Tube::~Tube((Tube *)((char *)this - 40));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 4);

  CFAllocatorDeallocate(v3, v2);
}

{
  Tube::~Tube((Tube *)((char *)this - 40));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 32;
  Tube::~Tube((Tube *)((char *)this - 32));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 3);

  CFAllocatorDeallocate(v3, v2);
}

{
  Tube::~Tube((Tube *)((char *)this - 32));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 24;
  Tube::~Tube((Tube *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  Tube::~Tube((Tube *)((char *)this - 24));
}

uint64_t ___ZN4Tube27_onqueue_saveSSLCertContextEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 136) + 216))();
}

void non-virtual thunk to'Tube::needClientCert(uint64_t a1, const void *a2, void *a3)
{
}

{
  Tube::needClientCert(a1 - 32, a2, a3);
}

void Tube::needClientCert(uint64_t a1, CFTypeRef cf, void *aBlock)
{
  if (*(void *)(a1 + 248)) {
    __assert_rtn("needClientCert", "Tube.cpp", 1773, "!fSSLDistNames");
  }
  *(void *)(a1 + 248) = cf;
  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 304) = _Block_copy(aBlock);
  if (*(int *)(a1 + 220) < 10)
  {
    *(_DWORD *)(a1 + 220) = 8;
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 80))(*(void *)(a1 + 112));
    if (v5) {
      CFRetain((CFTypeRef)(v5 - 192));
    }
    operator new();
  }

  Tube::_onqueue_complete_needClientCert((Tube *)a1, 0, 1);
}

void sub_18422C420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  _Unwind_Resume(a1);
}

void Tube::_onqueue_complete_needClientCert(Tube *this, const __CFArray *a2, uint64_t a3)
{
  uint64_t v6 = (void (**)(void, void, void))*((void *)this + 38);
  *((void *)this + 38) = 0;
  uint64_t v7 = (const void *)*((void *)this + 31);
  *((void *)this + 31) = 0;
  if (v7) {
    CFRelease(v7);
  }
  if (v6)
  {
    ((void (**)(void, const __CFArray *, uint64_t))v6)[2](v6, a2, a3);
    _Block_release(v6);
  }
  if (a3)
  {
    Tube::_onqueue_cancel(this);
  }
}

uint64_t ___ZN4Tube23_onqueue_needClientCertEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(int *)(v1 + 220) < 10)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    uint64_t v3 = *(void *)(v1 + 248);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN4Tube23_onqueue_needClientCertEv_block_invoke_2;
    v5[3] = &__block_descriptor_40_e23_v20__0____CFArray__8B16l;
    v5[4] = v1;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v2 + 40))(v2, v3, v5);
  }
  else
  {
    Tube::_complete_needClientCert(*(NSObject ***)(a1 + 32), 0, 1);
    (*(void (**)(uint64_t))(*(void *)v1 + 48))(v1);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 48))(v1);
}

void Tube::_complete_needClientCert(NSObject **this, const __CFArray *a2, char a3)
{
  ((void (*)(NSObject **))(*this)[5].isa)(this);
  if (a2) {
    CFRetain(a2);
  }
  uint64_t v6 = this[20];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN4Tube24_complete_needClientCertEPK9__CFArrayb_block_invoke;
  CFHostClientContext block[3] = &__block_descriptor_49_e5_v8__0l;
  block[4] = this;
  void block[5] = a2;
  char v8 = a3;
  dispatch_async(v6, block);
}

uint64_t ___ZN4Tube23_onqueue_needClientCertEv_block_invoke_2(uint64_t a1, const __CFArray *a2, char a3)
{
  uint64_t v3 = *(NSObject ***)(a1 + 32);
  Tube::_complete_needClientCert(v3, a2, a3);
  isa = (uint64_t (*)(NSObject **))(*v3)[6].isa;

  return isa(v3);
}

uint64_t ___ZN4Tube24_complete_needClientCertEPK9__CFArrayb_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(Tube **)(a1 + 32);
  Tube::_onqueue_complete_needClientCert(v2, *(const __CFArray **)(a1 + 40), *(unsigned __int8 *)(a1 + 48));
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(uint64_t (**)(Tube *))(*(void *)v2 + 48);

  return v4(v2);
}

void std::__shared_ptr_pointer<Tube *,Tube::postConnectConfiguration(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,void({block_pointer})(void))::$_0,std::allocator<Tube>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void ___ZN4Tube16_onqueue_connectEv_block_invoke_3(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    __assert_rtn("_onqueue_errorHandler", "Tube.cpp", 1112, "posixErrorCode != 0");
  }
  uint64_t v2 = *(Tube **)(a1 + 32);
  *(void *)&v3.SInt32 error = a2;
  v3.CFIndex domain = 1;

  Tube::_onqueue_errorHandler(v2, v3);
}

void std::__shared_ptr_pointer<Tube *,Deleter_CustomBlock,std::allocator<Tube>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN4Tube23preConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke(uint64_t result, int a2, int a3, CFTypeRef cf, uint64_t a5, uint64_t *a6)
{
  uint64_t v7 = *(void *)(result + 40);
  if (v7)
  {
    if (*(_DWORD *)(*(void *)(result + 32) + 88) == 2
      || (uint64_t v9 = *(void *)(v7 + 80)) != 0
      && (uint64_t v9 = [(id)v9 _preventsSystemHTTPProxyAuthentication], (v9 & 1) != 0)
      || ((*(unsigned int *)(v7 + 192) | ((unint64_t)*(unsigned __int16 *)(v7 + 196) << 32)) & 0x2000000000) != 0
      || (uint64_t result = (uint64_t)AuthBrokerAgentClient::AuthBrokerIsAvailable((AuthBrokerAgentClient *)v9), (result & 1) == 0))
    {
      uint64_t v14 = a6[1];
      if (v14) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
      }
      if (cf) {
        CFRetain(cf);
      }
      operator new();
    }
  }
  uint64_t v10 = *a6;
  if (*a6)
  {
    uint64_t v11 = *(uint64_t (**)(void *, void, void))(v10 + 8);
    uint64_t v12 = *(void *)(v10 + 16);
    CFStringRef v13 = (void *)(v10 + (v12 >> 1));
    if (v12) {
      uint64_t v11 = *(uint64_t (**)(void *, void, void))(*v13 + v11);
    }
    return v11(v13, 0, 0);
  }
  return result;
}

void sub_18422CB98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  }
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a21);
  }
  if (a19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a19);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a17);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v26);
  std::__shared_weak_count::__release_shared[abi:nn180100](v25);
  std::__shared_weak_count::__release_shared[abi:nn180100](v24);
  if (v23) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v23);
  }
  _Unwind_Resume(a1);
}

uint64_t BlockHolderVar<void *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_normal(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v6 = *a1;
  uint64_t v7 = (std::__shared_weak_count *)a6[1];
  uint64_t v8 = *a6;
  uint64_t v9 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(v6 + 16))(v6, a2, a3, a4, a5, &v8);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
}

void sub_18422CC80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>> *,SmartBlockWithArgs<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::Deleter,std::allocator<BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_initial(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  a1[1] = (uint64_t)BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_normal;
  a1[2] = 0;
  uint64_t v6 = *a1;
  uint64_t v7 = (std::__shared_weak_count *)a6[1];
  uint64_t v8 = *a6;
  uint64_t v9 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(v6 + 16))(v6, a2, a3, a4, a5, &v8);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
}

void sub_18422CD44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void GlueConnectionEstablishment::ssConnectionWaitingNotification()
{
}

void GlueConnectionEstablishment::ssPostHandshakesStreamsAvailable(GlueConnectionEstablishment *this, __CFReadStream *a2, __CFWriteStream *a3)
{
}

void GlueConnectionEstablishment::ssPostConnectConfiguration()
{
}

void GlueConnectionEstablishment::ssNeedClientCert()
{
}

void GlueConnectionEstablishment::ssNeedServerTrust()
{
}

void GlueConnectionEstablishment::ssPreConnectConfiguration()
{
}

void GlueConnectionEstablishment::ceRelease(GlueConnectionEstablishment *this)
{
}

void GlueConnectionEstablishment::ceRetain(GlueConnectionEstablishment *this)
{
}

void ___ZN4Tube14clientCanceledEP25MetaConnectionCacheClient_block_invoke(uint64_t a1)
{
}

uint64_t ___ZN4Tube7copyKeyEv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(*(void *)(a1 + 40) + 104);
  uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t ___ZN4Tube10copyWaiterEv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(*(void *)(a1 + 40) + 112);
  uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t ___ZN4Tube21isExplicitlyRequestedEv_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(unsigned char *)(*(void *)(result + 40) + 216);
  return result;
}

CFTypeRef ___ZN4Tube18copySSLCertContextEv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(*(void *)(a1 + 40) + 232);
  CFTypeRef result = *(CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void ___ZN4Tube6cancelEv_block_invoke(uint64_t a1)
{
}

uint64_t ___ZN4Tube10isCanceledEv_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(*(void *)(result + 40) + 220) == 10;
  return result;
}

uint64_t ___ZN4Tube16canAcceptWaitersEv_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(*(void *)(result + 40) + 220) < 10;
  return result;
}

void sub_18422D9A8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void sub_18422DC3C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void __Block_byref_object_copy__7856(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__7857(uint64_t a1)
{
}

void sub_18423163C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t FTPProtocol::_instantiateProtocol(FTPProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  if (TCFObject<URLProtocol>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLProtocol>::Class(void)::sOnce, &__block_literal_global_37_8111);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    uint64_t v8 = Instance + 16;
    *(void *)(Instance + 176) = 0;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  *(_OWORD *)(v8 + 152) = 0u;
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 24) = 0u;
  *(void *)uint64_t v8 = &unk_1ECF9AAF0;
  *(void *)(v8 + 8) = &unk_1ECF9ABF0;
  *(void *)(v8 + CFRetain((char *)this - 16) = &unk_1ECF9AC10;
  URLProtocol::initialize((URLProtocol *)v8, a2, a3);
  return v8 - 16;
}

void non-virtual thunk to'FTPProtocol::~FTPProtocol(FTPProtocol *this)
{
}

{
  FTPProtocol::~FTPProtocol((FTPProtocol *)((char *)this - 16));
}

{
  FTPProtocol::~FTPProtocol((FTPProtocol *)((char *)this - 8));
}

{
  FTPProtocol::~FTPProtocol((FTPProtocol *)((char *)this - 8));
}

void FTPProtocol::~FTPProtocol(FTPProtocol *this)
{
  *(void *)this = &unk_1ECF9AAF0;
  *((void *)this + 1) = &unk_1ECF9ABF0;
  *((void *)this + 2) = &unk_1ECF9AC10;
  uint64_t v2 = (const void *)*((void *)this + 15);
  if (v2) {
    CFRelease(v2);
  }
  FTPProtocol::destroyReadStream(this);
  CFStreamError v3 = (const void *)*((void *)this + 20);
  if (v3) {
    CFRelease(v3);
  }

  URLProtocol::~URLProtocol((URLProtocol *)this);
}

void sub_1842319C8(_Unwind_Exception *a1)
{
  URLProtocol::~URLProtocol(v1);
  _Unwind_Resume(a1);
}

void FTPProtocol::destroyReadStream(FTPProtocol *this)
{
  uint64_t v2 = (__CFReadStream *)*((void *)this + 18);
  if (v2)
  {
    CFReadStreamSetClient(v2, 0, 0, 0);
    CFReadStreamClose(*((CFReadStreamRef *)this + 18));
    CFStreamError v3 = (const void *)*((void *)this + 18);
    if (v3) {
      CFRelease(v3);
    }
    *((void *)this + 18) = 0;
  }
}

uint64_t FTPProtocol::needsThrottler(FTPProtocol *this)
{
  return 1;
}

void FTPProtocol::subclassUpdateScheduling(FTPProtocol *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  if (*((unsigned char *)this + 112))
  {
    uint64_t v4 = *((void *)this + 18);
    if (v4)
    {
      uint64_t v6 = *((void *)this + 3);
      if (v6)
      {
        CoreSchedulingSet::_scheduleStream(v6, v4, (void (*)(uint64_t, uint64_t))_CFStreamUnscheduleFromDispatchQueue, MEMORY[0x1E4F1C270]);
        uint64_t v4 = *((void *)this + 18);
      }
      uint64_t v7 = (void (*)(uint64_t, uint64_t))MEMORY[0x1E4F1C268];
      uint64_t v8 = MEMORY[0x1E4F1C260];
      CoreSchedulingSet::_scheduleStream((uint64_t)a3, v4, v7, v8);
    }
  }
}

void FTPProtocol::_protocolInterface_resumeLoad(FTPProtocol *this, uint64_t a2, uint64_t a3)
{
  *((unsigned char *)this + 112) &= ~1u;
  if (*((void *)this + 18))
  {
    uint64_t v4 = *((void *)this + 19);
    if (v4)
    {
      FTPProtocol::ftpReadStreamEvent(this, v4, a3);
      *((void *)this + 19) = 0;
    }
  }
}

void FTPProtocol::ftpReadStreamEvent(FTPProtocol *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](this, a2, a3);
  unint64_t v5 = v4;
  uint64_t v6 = v3;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if ((v4 > 0x10 || ((1 << v4) & 0x10104) == 0) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)UInt8 buffer = 136315138;
    uint64_t v37 = "ftpReadStreamEvent";
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s(): Called back for an event we don't recognize!", buffer, 0xCu);
  }
  if (*(unsigned char *)(v6 + 112))
  {
    *(void *)(v6 + 152) = v5;
    return;
  }
  if (v5 == 16)
  {
    if ((*(unsigned char *)(v6 + 112) & 4) == 0)
    {
      FTPProtocol::checkAndSendDidReceiveResponse((unsigned char *)v6);
      URLProtocol::sendDidFinishLoading((URLProtocol *)v6);
      return;
    }
    goto LABEL_28;
  }
  if (v5 != 8)
  {
    if (v5 != 2) {
      return;
    }
    if ((*(unsigned char *)(v6 + 112) & 4) == 0)
    {
      FTPProtocol::checkAndSendDidReceiveResponse((unsigned char *)v6);
      uint64_t v7 = CFReadStreamRead(*(CFReadStreamRef *)(v6 + 144), buffer, 0x10000);
      if (v7 >= 1)
      {
        CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)(v6 - 16));
        CFDataRef v9 = CFDataCreate(v8, buffer, v7);
        CFDataRef v10 = v9;
        if (v9)
        {
          uint64_t v11 = *(Throttler **)(v6 + 64);
          if (v11)
          {
            CFIndex Length = CFDataGetLength(v9);
            Throttler::noteOutstandingBytes(v11, Length);
          }
        }
        v31[0] = MEMORY[0x1E4F143A8];
        v31[1] = 3221225472;
        CFRunLoopSourceRef v32 = ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke_8136;
        CFTypeRef v33 = &__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
        CFDataRef v34 = v10;
        uint64_t v35 = v7;
        uint64_t v13 = *(void *)(v6 + 96);
        if (v13)
        {
          uint64_t v14 = (*(uint64_t (**)(void))(*(void *)v13 + 16))(*(void *)(v6 + 96));
          uint64_t v15 = (void *)MEMORY[0x18531D6D0](v14);
          v32((uint64_t)v31, *(void *)(v6 + 96));
          (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
        }
        CFRelease(v10);
      }
      return;
    }
LABEL_28:
    FTPProtocol::redirectToCurrentURL((FTPProtocol *)v6);
    return;
  }
  CFErrorRef v16 = CFReadStreamCopyError(*(CFReadStreamRef *)(v6 + 144));
  CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*(void *)(v6 + 144));
  *(CFStreamError *)(v6 + 128) = Error;
  if ((*(unsigned char *)(v6 + 112) & 0xC) == 0)
  {
    if (Error.domain == 6 || Error.error == 550)
    {
      *(unsigned char *)(v6 + 112) |= 4u;
      (*(void (**)(uint64_t))(*(void *)v6 + 96))(v6);
      CFAllocatorRef v26 = CFGetAllocator((CFTypeRef)(v6 - 16));
      CFStringRef v27 = CFURLGetString(*(CFURLRef *)(v6 + 160));
      CFStringRef v28 = CFStringCreateWithFormat(v26, 0, @"%@/", v27);
      uint64_t v29 = *(const void **)(v6 + 160);
      if (v29) {
        CFRelease(v29);
      }
      CFAllocatorRef v30 = CFGetAllocator((CFTypeRef)(v6 - 16));
      *(void *)(v6 + 160) = CFURLCreateWithString(v30, v28, 0);
      if (v28) {
        CFRelease(v28);
      }
      (*(void (**)(uint64_t, void))(*(void *)v6 + 88))(v6, 0);
      goto LABEL_40;
    }
    goto LABEL_32;
  }
  if (Error.domain != 6) {
    goto LABEL_32;
  }
  CFIndex v18 = -1004;
  if (Error.error > 521)
  {
    if (Error.error <= 549)
    {
      if (Error.error == 522) {
        goto LABEL_33;
      }
      if (Error.error == 530)
      {
        CFIndex v18 = -1102;
        goto LABEL_33;
      }
      goto LABEL_32;
    }
    if (Error.error != 550 && Error.error != 553) {
      goto LABEL_32;
    }
LABEL_51:
    CFIndex v18 = -1008;
    goto LABEL_33;
  }
  if (Error.error > 425)
  {
    if (Error.error == 426)
    {
      CFIndex v18 = -1005;
      goto LABEL_33;
    }
    if (Error.error != 450)
    {
LABEL_32:
      CFIndex v18 = -998;
      goto LABEL_33;
    }
    goto LABEL_51;
  }
  if (Error.error != 421 && Error.error != 425) {
    goto LABEL_32;
  }
LABEL_33:
  CFAllocatorRef v19 = CFGetAllocator((CFTypeRef)(v6 - 16));
  CFCFStreamError Error = __cfnCreateCFError(v19, @"kCFErrorDomainCFNetwork", v18, v20, v21, v22, v23, v24, 0);
  URLProtocol::sendDidFail((URLProtocol *)v6, CFError);
  if (CFError) {
    CFRelease(CFError);
  }
LABEL_40:
  if (v16) {
    CFRelease(v16);
  }
}

void FTPProtocol::redirectToCurrentURL(FTPProtocol *this)
{
  uint64_t v2 = (void *)*((void *)this + 11);
  if (v2)
  {
    CFGetAllocator((char *)this - 16);
    uint64_t v2 = (void *)[v2 mutableCopy];
  }
  CFURLRequestSetURL(v2, *((const void **)this + 20));
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  id v4 = CFURLResponseCreate((uint64_t)v3, *((const void **)this + 20), @"application/x-ftp-directory", -1, 0, 0);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  CFDataRef v9 = ___ZN11URLProtocol17sendWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_8141;
  CFDataRef v10 = &unk_1E5255ED8;
  uint64_t v11 = v2;
  id v12 = v4;
  uint64_t v5 = *((void *)this + 12);
  if (v5)
  {
    uint64_t v6 = (*(uint64_t (**)(void))(*(void *)v5 + 16))(*((void *)this + 12));
    uint64_t v7 = (void *)MEMORY[0x18531D6D0](v6);
    v9((uint64_t)v8, *((void *)this + 12));
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v2) {
    CFRelease(v2);
  }
  *((unsigned char *)this + 112) &= ~4u;
}

unsigned char *FTPProtocol::checkAndSendDidReceiveResponse(unsigned char *this)
{
  char v1 = this[112];
  if ((v1 & 2) == 0)
  {
    uint64_t v2 = (uint64_t)this;
    this[112] = v1 | 2;
    this = (unsigned char *)*((void *)this + 15);
    if (!this)
    {
      valuePtr[0] = -1;
      if ((v1 & 8) != 0) {
        CFStringRef v3 = (const __CFString *)CFRetain(@"application/x-ftp-directory");
      }
      else {
        CFStringRef v3 = 0;
      }
      id v4 = *(__CFReadStream **)(v2 + 144);
      if (v4)
      {
        CFNumberRef v5 = (const __CFNumber *)CFReadStreamCopyProperty(v4, @"kCFStreamPropertyFTPResourceSize");
        if (v5)
        {
          CFNumberRef v6 = v5;
          CFNumberGetValue(v5, kCFNumberLongLongType, valuePtr);
          CFRelease(v6);
        }
      }
      CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)(v2 - 16));
      this = CFURLResponseCreate((uint64_t)v7, *(const void **)(v2 + 160), v3, valuePtr[0], 0, 0);
      *(void *)(v2 + 120) = this;
      if (v3)
      {
        CFRelease(v3);
        this = *(unsigned char **)(v2 + 120);
      }
    }
    valuePtr[0] = MEMORY[0x1E4F143A8];
    valuePtr[1] = 3221225472;
    id v12 = ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8140;
    uint64_t v13 = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
    id v14 = this;
    uint64_t v8 = *(void *)(v2 + 96);
    if (v8)
    {
      uint64_t v9 = (*(uint64_t (**)(void))(*(void *)v8 + 16))(*(void *)(v2 + 96));
      CFDataRef v10 = (void *)MEMORY[0x18531D6D0](v9);
      v12((uint64_t)valuePtr, *(void *)(v2 + 96));
      return (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 24))(v8);
    }
  }
  return this;
}

uint64_t ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke_8136(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 72))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8140(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 64))(a2, *(void *)(a1 + 32));
}

uint64_t ___ZN11URLProtocol17sendWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_8141(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 40))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t FTPProtocol::_protocolInterface_haltLoad(uint64_t this)
{
  *(unsigned char *)(this + 112) |= 1u;
  return this;
}

void FTPProtocol::_protocolInterface_cancelLoad(FTPProtocol *this)
{
  if ((*((unsigned char *)this + 112) & 0x20) == 0)
  {
    *((unsigned char *)this + 112) |= 0x20u;
    FTPProtocol::destroyReadStream(this);
  }
}

void FTPProtocol::_protocolInterface_startLoad(FTPProtocol *this, const _CFCachedURLResponse *a2)
{
  if ((*((unsigned char *)this + 112) & 4) == 0)
  {
    CFStringRef v3 = (void *)*((void *)this + 11);
    CFTypeRef v4 = (CFTypeRef)[v3 cfURL];
    if (v4) {
      CFTypeRef v4 = CFRetain(v4);
    }
    *((void *)this + 20) = v4;
    CFURLRef v5 = _CFURLRequestCopyProtocolPropertyForKey(v3, @"kCFFTPProtocolPropertyReturnDirectoryListing");
    if (v5)
    {
      CFURLRef v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        LOWORD(clientContext.version) = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&clientContext, 2u);
      }
      CFURLRef v8 = (CFURLRef)*MEMORY[0x1E4F1CFC8];
      CFRelease(v6);
      if (v8 == v6) {
        *((unsigned char *)this + 112) |= 0x10u;
      }
    }
  }
  CFStringRef v9 = CFURLCopyPath(*((CFURLRef *)this + 20));
  if (v9)
  {
    CFStringRef v10 = v9;
    if (CFStringGetLength(v9) && !CFURLHasDirectoryPath(*((CFURLRef *)this + 20))) {
      char v11 = *((unsigned char *)this + 112) & 0xF7;
    }
    else {
      char v11 = *((unsigned char *)this + 112) | 8;
    }
    *((unsigned char *)this + 112) = v11;
    CFRelease(v10);
    char v12 = *((unsigned char *)this + 112);
  }
  else
  {
    char v12 = *((unsigned char *)this + 112) | 8;
    *((unsigned char *)this + 112) = v12;
  }
  if ((v12 & 0x1C) == 0x18)
  {
    FTPProtocol::checkAndSendDidReceiveResponse(this);
    URLProtocol::sendDidFinishLoading((URLProtocol *)this);
    return;
  }
  CFAllocatorRef v13 = CFGetAllocator((char *)this - 16);
  id v14 = CFReadStreamCreateWithFTPURL(v13, *((CFURLRef *)this + 20));
  *((void *)this + 18) = v14;
  if (v14)
  {
    clientContext.version = 0;
    clientContext.info = this;
    memset(&clientContext.retain, 0, 24);
    CFReadStreamSetClient(v14, 0x1AuLL, (CFReadStreamClientCallBack)FTPProtocol::_ftpReadStreamCB, &clientContext);
    CFReadStreamSetProperty(*((CFReadStreamRef *)this + 18), @"kCFStreamPropertyFTPFetchResourceInfo", (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
    *((void *)this + 19) = 0;
    CoreSchedulingSet::_scheduleStream(*((void *)this + 3), *((void *)this + 18), MEMORY[0x1E4F1C268], MEMORY[0x1E4F1C260]);
    if (CFReadStreamOpen(*((CFReadStreamRef *)this + 18))) {
      return;
    }
    CFCFStreamError Error = CFReadStreamCopyError(*((CFReadStreamRef *)this + 18));
  }
  else
  {
    CFAllocatorRef v16 = CFGetAllocator((char *)this - 16);
    CFCFStreamError Error = __cfnCreateCFError(v16, @"kCFErrorDomainCFNetwork", -998, v17, v18, v19, v20, v21, 0);
  }
  uint64_t v22 = CFError;
  URLProtocol::sendDidFail((URLProtocol *)this, CFError);
  if (v22) {
    CFRelease(v22);
  }
}

void FTPProtocol::_ftpReadStreamCB(FTPProtocol *this, __CFReadStream *a2, FTPProtocol *a3, void *a4)
{
}

CFStringRef FTPProtocol::copyDebugDesc(FTPProtocol *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<FTP protocol instance %p>", this);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_8152()
{
}

void sub_184232654(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t FTPProtocol::_requestsAreCacheEquivalent(FTPProtocol *this, const _CFURLRequest *a2, const _CFURLRequest *a3, const void *a4)
{
  return 0;
}

const __CFAllocator *FTPProtocol::_createCanonicalRequest(FTPProtocol *this, const __CFAllocator *a2, const _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  CFAllocatorRef v5 = a2;
  CFURLRef v6 = *(const __CFURL **)([(__CFAllocator *)a2 _inner] + 8);
  unsigned __int8 v11 = 0;
  CFURLRef v7 = _createCanonicalURL(v6, 1, 0, &v11);
  CFURLRef v8 = v7;
  if (v7) {
    BOOL v9 = v7 == v6;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    CFAllocatorRef v5 = (const __CFAllocator *)[(__CFAllocator *)v5 mutableCopy];
    CFURLRequestSetURL(v5, v8);
    CFRelease(v8);
    return v5;
  }
  if (v7) {
    CFRelease(v7);
  }
  if (!v5) {
    return v5;
  }

  return (const __CFAllocator *)CFRetain(v5);
}

_OWORD *DataProtocol::_instantiateProtocol(DataProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  if (TCFObject<URLProtocol>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLProtocol>::Class(void)::sOnce, &__block_literal_global_40);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  CFURLRef v8 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    CFURLRef v8 = Instance + 1;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  *((void *)v8 + 13) = 0;
  *(_OWORD *)((char *)v8 + 88) = 0u;
  *(_OWORD *)((char *)v8 + 72) = 0u;
  *(_OWORD *)((char *)v8 + 56) = 0u;
  *(_OWORD *)((char *)v8 + 40) = 0u;
  *(_OWORD *)((char *)v8 + 24) = 0u;
  *(void *)CFURLRef v8 = &unk_1ECF9B570;
  *((void *)v8 + 1) = &unk_1ECF9B670;
  *((void *)v8 + 2) = &unk_1ECF9B690;
  URLProtocol::initialize((URLProtocol *)v8, a2, a3);
  return v8 - 1;
}

void non-virtual thunk to'DataProtocol::~DataProtocol(DataProtocol *this)
{
}

{
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 16));
}

{
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 8));
}

{
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 8));
}

void DataProtocol::_protocolInterface_startLoad(id *this, const _CFCachedURLResponse *a2)
{
  CFStringRef v3 = (const void *)[this[11] cfURL];
  CFDictionaryRef properties = 0;
  errorCFIndex Code = 0;
  CFDataRef resourceData = 0;
  CFAllocatorRef v4 = CFGetAllocator(this - 2);
  if (CFURLCreateDataAndPropertiesFromResource(v4, (CFURLRef)v3, &resourceData, &properties, 0, &errorCode))
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(properties, @"kCFDataURLMimeType");
    if (Value) {
      CFStringRef v6 = Value;
    }
    else {
      CFStringRef v6 = @"text/plain";
    }
    CFStringRef v7 = (const __CFString *)CFDictionaryGetValue(properties, @"kCFDataURLTextEncodingName");
    CFIndex Length = CFDataGetLength(resourceData);
    CFAllocatorRef v9 = CFGetAllocator(this - 2);
    CFStringRef v10 = (__CFError *)CFURLResponseCreate((uint64_t)v9, v3, v6, Length, v7, 2);
    if (v10)
    {
      CFCFStreamError Error = v10;
      uint64_t v37 = MEMORY[0x1E4F143A8];
      uint64_t v38 = 3221225472;
      uint64_t v39 = ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8184;
      long long v40 = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
      CFDataRef v41 = v10;
      id v12 = this[12];
      if (v12)
      {
        uint64_t v13 = (*(uint64_t (**)(id))(*(void *)v12 + 16))(this[12]);
        id v14 = (void *)MEMORY[0x18531D6D0](v13);
        v39((uint64_t)&v37, (uint64_t)this[12]);
        (*(void (**)(id))(*(void *)v12 + 24))(v12);
      }
      CFDataRef v15 = resourceData;
      if (resourceData)
      {
        CFAllocatorRef v16 = (Throttler *)this[8];
        if (v16)
        {
          CFIndex v17 = CFDataGetLength(resourceData);
          Throttler::noteOutstandingBytes(v16, v17);
        }
      }
      uint64_t v37 = MEMORY[0x1E4F143A8];
      uint64_t v38 = 3221225472;
      uint64_t v39 = ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke_8185;
      long long v40 = &__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
      CFDataRef v41 = v15;
      CFIndex v42 = Length;
      id v18 = this[12];
      if (v18)
      {
        uint64_t v19 = (*(uint64_t (**)(id))(*(void *)v18 + 16))(this[12]);
        uint64_t v20 = (void *)MEMORY[0x18531D6D0](v19);
        v39((uint64_t)&v37, (uint64_t)this[12]);
        (*(void (**)(id))(*(void *)v18 + 24))(v18);
      }
      URLProtocol::sendDidFinishLoading((URLProtocol *)this);
    }
    else
    {
      CFAllocatorRef v28 = CFGetAllocator(this - 2);
      CFCFStreamError Error = __cfnCreateCFError(v28, @"kCFErrorDomainCFNetwork", -998, v29, v30, v31, v32, v33, 0);
      URLProtocol::sendDidFail((URLProtocol *)this, CFError);
      if (!CFError) {
        goto LABEL_18;
      }
    }
    CFRelease(CFError);
LABEL_18:
    CFRelease(properties);
    CFStringRef v27 = resourceData;
    if (!resourceData) {
      return;
    }
    goto LABEL_19;
  }
  CFAllocatorRef v21 = CFGetAllocator(this - 2);
  CFStringRef v27 = __cfnCreateCFError(v21, @"kCFErrorDomainCFNetwork", errorCode, v22, v23, v24, v25, v26, 0);
  URLProtocol::sendDidFail((URLProtocol *)this, v27);
  if (v27) {
LABEL_19:
  }
    CFRelease(v27);
}

uint64_t ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8184(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 64))(a2, *(void *)(a1 + 32));
}

uint64_t ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke_8185(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 72))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
}

CFStringRef DataProtocol::copyDebugDesc(DataProtocol *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<data URL instance at %p>", this);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_8196()
{
}

void sub_184232CB4(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t DataProtocol::_requestsAreCacheEquivalent(DataProtocol *this, const _CFURLRequest *a2, const _CFURLRequest *a3, const void *a4)
{
  return 0;
}

CFTypeRef DataProtocol::_createCanonicalRequest(DataProtocol *this, CFTypeRef cf, const _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  if (cf) {
    return CFRetain(cf);
  }
  else {
    return 0;
  }
}

void non-virtual thunk to'FileURLProtocol::~FileURLProtocol(FileURLProtocol *this)
{
}

{
  FileURLProtocol::~FileURLProtocol((FileURLProtocol *)((char *)this - 16));
}

{
  FileURLProtocol::~FileURLProtocol((FileURLProtocol *)((char *)this - 8));
}

{
  FileURLProtocol::~FileURLProtocol((FileURLProtocol *)((char *)this - 8));
}

void FileURLProtocol::_protocolInterface_resumeLoad(FileURLProtocol *this, uint64_t a2, uint64_t a3)
{
  *((unsigned char *)this + 112) &= ~1u;
  if (*((void *)this + 16))
  {
    uint64_t v4 = *((void *)this + 17);
    if (v4)
    {
      FileURLProtocol::fileStreamEvent(this, v4, a3);
      *((void *)this + 17) = 0;
    }
  }
}

uint64_t FileURLProtocol::checkAndSendDidReceiveResponse(uint64_t this)
{
  if ((*(unsigned char *)(this + 112) & 2) == 0)
  {
    uint64_t v1 = this;
    *(unsigned char *)(this + 112) |= 2u;
    uint64_t v2 = *(void *)(this + 120);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    CFStringRef v7 = ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8227;
    CFURLRef v8 = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
    uint64_t v9 = v2;
    uint64_t v3 = *(void *)(this + 96);
    if (v3)
    {
      uint64_t v4 = (*(uint64_t (**)(void))(*(void *)v3 + 16))(*(void *)(this + 96));
      CFAllocatorRef v5 = (void *)MEMORY[0x18531D6D0](v4);
      v7((uint64_t)v6, *(void *)(v1 + 96));
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);
    }
  }
  return this;
}

uint64_t FileURLProtocol::_protocolInterface_haltLoad(uint64_t this)
{
  *(unsigned char *)(this + 112) |= 1u;
  return this;
}

void FileURLProtocol::_protocolInterface_cancelLoad(FileURLProtocol *this)
{
  if ((*((unsigned char *)this + 112) & 4) == 0)
  {
    *((unsigned char *)this + 112) |= 4u;
    if (*((void *)this + 16)) {
      FileURLProtocol::destroyReadStream(this);
    }
  }
}

CFStringRef FileURLProtocol::copyDebugDesc(FileURLProtocol *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<File protocol instance %p>", this);
}

uint64_t FileURLProtocol::_requestsAreCacheEquivalent(FileURLProtocol *this, const _CFURLRequest *a2, const _CFURLRequest *a3, const void *a4)
{
  return 0;
}

void sub_184233590(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184233760(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184233808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_184233B20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184233C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_184233F74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_18423407C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_18423411C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1842343CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'HTTPProtocol::clientDescription(HTTPProtocol *this)
{
  return *((void *)this + 76);
}

void non-virtual thunk to'HTTPProtocol::resetAuthState(HTTPProtocol *this)
{
}

void HTTPProtocol::resetAuthState(HTTPProtocol *this)
{
  if (this) {
    CFRetain((char *)this - 16);
  }
  operator new();
}

void sub_184234508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol14resetAuthStateEv_block_invoke()
{
}

void __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_emplace<AuthenticationState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6A68;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<AuthenticationState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6A68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'HTTPProtocol::generateProxyAuthentication(uint64_t a1)
{
}

void HTTPProtocol::generateProxyAuthentication(uint64_t a1)
{
  if (a1) {
    CFRetain((CFTypeRef)(a1 - 16));
  }
  operator new();
}

void sub_1842347C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  unsigned int v3 = *(_DWORD *)(v2 + 192);
  unint64_t v4 = v3 | ((unint64_t)*(unsigned __int16 *)(v2 + 196) << 32) | 0x8000000000;
  *(_DWORD *)(v2 + 192) = v3;
  *(_WORD *)(v2 + 196) = WORD2(v4);
  CFAllocatorRef v5 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 600))(v2, &v12);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v13);
  }
  if (!*(void *)(v2 + 776)) {
    _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_();
  }
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 64);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(v2 + 624) = v7;
  CFURLRef v8 = *(std::__shared_weak_count **)(v2 + 632);
  *(void *)(v2 + 632) = v6;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  int HasCredentialsForChallenge = HTTPProtocol::_CFHTTPProtHasCredentialsForChallenge(*(HTTPProtocol **)(a1 + 72), (__CFHTTPMessage *)(*(void *)(a1 + 88) - 16));
  if ((*(_DWORD *)(v2 + 192) & 0x200000) == 0 && *(void *)(v2 + 776))
  {
    if (HasCredentialsForChallenge)
    {
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 616))(v2);
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 648))(v2);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 120))(v2, v10, v11);
    }
    else
    {
      HTTPProtocol::challengeDelegateOrFinishBrokeringProxyAuth((HTTPProtocol *)v2);
    }
  }
}

void sub_1842349D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c41_ZTSKNSt3__110shared_ptrI12NetworkProxyEE56c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE72c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE88c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  unsigned int v3 = (std::__shared_weak_count *)a1[10];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  unint64_t v4 = (std::__shared_weak_count *)a1[8];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  CFAllocatorRef v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void *__copy_helper_block_e8_40c41_ZTSKNSt3__110shared_ptrI12NetworkProxyEE56c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE72c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE88c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[10];
  result[9] = a2[9];
  result[10] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a2[12];
  result[11] = a2[11];
  result[12] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t HTTPProtocol::_CFHTTPProtHasCredentialsForChallenge(HTTPProtocol *this, __CFHTTPMessage *a2)
{
  uint64_t v163 = *MEMORY[0x1E4F143B8];
  if (((*((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32)) & 0x4000000000) != 0) {
    return 0;
  }
  if ((*(unsigned int (**)(HTTPProtocol *))(*(void *)this + 520))(this)) {
    return 0;
  }
  CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(a2);
  CFIndex v9 = ResponseStatusCode;
  BOOL v10 = ResponseStatusCode == 407;
  if (ResponseStatusCode != 407 && ResponseStatusCode != 401) {
    return 0;
  }
  if (ResponseStatusCode == 407 || (uint64_t v11 = *((void *)this + 34)) == 0)
  {
    uint64_t v157 = 0;
    v158 = 0;
  }
  else
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v11 + 176))(&v157);
    if (v157)
    {
      uint64_t v12 = *(void *)(v157 + 104);
      uint64_t v13 = *(std::__shared_weak_count **)(v157 + 112);
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      BOOL v15 = v12
         && (*(_DWORD *)(v12 + 24) & 0xFFFFFFFE) == 2
         && (id v14 = *(HTTPAuthentication **)(v12 + 8)) != 0
         && HTTPAuthentication::isConnectionBasedAuth(v14) != 0;
      if (v13) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v13);
      }
      if (v15)
      {
        uint64_t EndpointCred = AuthenticationState::getEndpointCred(*(AuthenticationState **)(v157 + 104), *(std::__shared_weak_count **)(v157 + 112));
        if (EndpointCred)
        {
          uint64_t v32 = (const void *)EndpointCred;
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          uint64_t v33 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            CFIndex v34 = *((void *)this + 99);
            LODWORD(error.domain) = 138543362;
            *(CFIndex *)((char *)&error.domain + 4) = v34;
            _os_log_impl(&dword_184085000, v33, OS_LOG_TYPE_DEFAULT, "%{public}@ will use existing endpoint credentials", (uint8_t *)&error, 0xCu);
          }
          setTypeProperty<_CFURLCredential const*>((CFTypeRef *)this + 44, v32);
          _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_();
        }
      }
    }
  }
  if (AppSSO::AppSSODisabled == 1
    || (double Helper_x8__SOErrorDomain = gotLoadHelper_x8__SOErrorDomain(v8), !*(void *)(v17 + 2112))
    || v9 != 401
    || *((unsigned char *)this + 856))
  {
    if (v9 == 407)
    {
      BOOL v29 = CFHTTPMessageGetResponseStatusCode(a2) == 407;
      Authentication = (_CFHTTPAuthentication *)_CFHTTPMessageGetAuthentication(a2, v29);
      if (Authentication)
      {
        CFHTTPAuthenticationIsValid(Authentication, &error);
      }
      else
      {
        error.CFStreamError error = 0;
        error.CFIndex domain = 0;
      }
    }
  }
  else
  {
    uint64_t v18 = *((void *)this + 35);
    if (!v18
      || (CFDictionaryRef v19 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, double))(*(void *)v18 + 64))(v18, Helper_x8__SOErrorDomain)) == 0|| (Value = (const __CFBoolean *)CFDictionaryGetValue(v19, &unk_1EC09F980), (v21 = Value) == 0)|| (v22 = CFGetTypeID(Value), v22 != CFBooleanGetTypeID())|| !CFBooleanGetValue(v21))
    {
      uint64_t v23 = (void *)*((void *)this + 11);
      if (v23)
      {
        CFStringRef v24 = (const __CFString *)objc_msgSend(v23, "cfURL", Helper_x8__SOErrorDomain);
        if (v24)
        {
          uint64_t v25 = objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_sourceApplicationAuditTokenData");
          if (AppSSO::shouldManageURL(*((AppSSO **)this + 99), v24, (const __CFURL *)0x191, v25, v26, v27))
          {
            CFAllocatorRef v28 = CFGetAllocator((char *)this - 16);
            CFURLResponseCreateWithHTTPResponse((uint64_t)v28, v24, (uint64_t)a2, 0);
            operator new();
          }
        }
      }
    }
  }
  CFAllocatorRef v155 = (char *)this + 40;
  if (*((unsigned char *)this + 41)) {
    uint64_t v35 = (unsigned __int8 *)&HTTPProtocol::inUnitTestMode;
  }
  else {
    uint64_t v35 = (unsigned __int8 *)this + 40;
  }
  int v36 = *v35;
  uint64_t KerberosAccountBroker = KerberosAccountBroker::getKerberosAccountBroker(*((KerberosAccountBroker **)this + 10), v7);
  BOOL v38 = 0;
  if (v9 != 407 && KerberosAccountBroker) {
    BOOL v38 = (*((_DWORD *)this + 48) & 0x8000000) == 0;
  }
  for (char i = 0; ; char i = 1)
  {
    uint64_t v40 = *((void *)this + 97);
    int v41 = (*(uint64_t (**)(void))(**((void **)this + 35) + 88))(*((void *)this + 35));
    AuthenticationState::setConnectionType(v40, v41);
    AuthenticationState::setOption(*((void *)this + 97), 0, v36 != 0);
    AuthenticationState::setOption(*((void *)this + 97), 1, v38);
    AuthenticationState::setOption(*((void *)this + 97), 2, objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_enableOAuthBearerTokenChallenges"));
    uint64_t v42 = *((void *)this + 97);
    if (a2)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      uint64_t v43 = *((unsigned char *)a2 + 40) ? (char *)a2 + 16 : 0;
    }
    else
    {
      uint64_t v43 = 0;
    }
    uint64_t v44 = *((void *)this + 34);
    uint64_t v45 = v44 ? (*(uint64_t (**)(uint64_t))(*(void *)v44 + 112))(v44) : 0;
    (*(void (**)(uint64_t, char *, uint64_t))(*(void *)v42 + 16))(v42, v43, v45);
    if ((i & 1) != 0
      || AuthenticationState::isEmpty(*((AuthenticationState **)this + 97))
      || AuthenticationState::isValid(*((void *)this + 97), 0))
    {
      break;
    }
    if (v9 == 407 && (*((_DWORD *)this + 48) & 0x400000) == 0)
    {
      uint64_t Auth = AuthenticationState::getAuth(*((AuthenticationState **)this + 97), 1);
      if (Auth)
      {
        if (*(void *)(Auth + 88) == 4 && *(_DWORD *)(Auth + 96) == 4294966295)
        {
          uint64_t v47 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648))(this);
          if (v47)
          {
            if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
              dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
            }
            uint64_t v48 = *(void *)(v47 + 40);
            if (v48)
            {
              uint64_t v49 = (const void *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)this + 87) + 80))(*((void *)this + 87), v48, *((void *)this + 10));
              if (v49)
              {
                (*(void (**)(void, const void *, uint64_t, void))(**((void **)this + 87) + 72))(*((void *)this + 87), v49, v48, *((void *)this + 10));
                CFRelease(v49);
              }
            }
          }
        }
      }
    }
    AuthenticationState::resetInvalid(*((AuthenticationState **)this + 97));
  }
  if (v9 == 407)
  {
    if (!(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this)) {
      goto LABEL_91;
    }
  }
  else if (!*((void *)this + 44))
  {
    goto LABEL_91;
  }
  CFTypeID v50 = (AuthenticationState *)*((void *)this + 97);
  if (a2)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*((unsigned char *)a2 + 40)) {
      __int16 v51 = (char *)a2 + 16;
    }
    else {
      __int16 v51 = 0;
    }
  }
  else
  {
    __int16 v51 = 0;
  }
  if (v9 == 407) {
    uint64_t v52 = (const _CFURLCredential *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this);
  }
  else {
    uint64_t v52 = (const _CFURLCredential *)*((void *)this + 44);
  }
  AuthenticationState::updateState(v50, (uint64_t)v51, 0, v52, *((__SecTrust **)this + 57));
LABEL_91:
  uint64_t v53 = AuthenticationState::getAuth(*((AuthenticationState **)this + 97), v9 == 407);
  uint64_t v55 = v53;
  if (!v53)
  {
    uint64_t v4 = 0;
    goto LABEL_319;
  }
  int v56 = URLProtectionSpace::authSchemeForAuth((URLProtectionSpace *)(v53 - 16), v54);
  int v57 = v56;
  if (v56 == 9)
  {
    if (!*((void *)this + 44) && (*((_DWORD *)this + 48) & 0x40000000) != 0)
    {
      CFURLRef v58 = *(const __CFURL **)([*((id *)this + 11) _inner] + 8);
      if (v58) {
        CFStringRef v59 = CFURLCopyUserName(v58);
      }
      else {
        CFStringRef v59 = 0;
      }
      CFStringRef v86 = (const __CFString *)HTTPAuthentication::copyRealm((HTTPAuthentication *)v55);
      CFAllocatorRef v87 = CFGetAllocator((char *)this - 16);
      XMobileMeAuthToken = _CFURLCredentialCreateXMobileMeAuthToken((uint64_t)v87, v59, 0, v86);
      *((void *)this + 44) = XMobileMeAuthToken;
      if (XMobileMeAuthToken)
      {
        if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
        }
        if (XMobileMeAuthToken[12] != 4
          || !(*(unsigned int (**)(_DWORD *))(*((void *)XMobileMeAuthToken + 2) + 144))(XMobileMeAuthToken + 4))
        {
          CFRange v89 = (const void *)*((void *)this + 44);
          *((void *)this + 44) = 0;
          if (v89) {
            CFRelease(v89);
          }
        }
      }
      else
      {
        *((void *)this + 44) = 0;
      }
      int v91 = *((_DWORD *)this + 48);
      uint64_t v90 = (char *)this + 192;
      __int16 v92 = *((_WORD *)v90 + 2);
      *(_DWORD *)uint64_t v90 = v91 & 0xBFFFFFFF;
      *((_WORD *)v90 + 2) = v92;
      if (v59) {
        CFRelease(v59);
      }
      if (v86) {
        CFRelease(v86);
      }
      uint64_t v4 = 1;
      goto LABEL_319;
    }
  }
  else if (v9 == 401 && !*((unsigned char *)this + 857) && v56 == 11)
  {
    if (HTTPConnectionCacheKey::isFirstPartyResource(*((HTTPConnectionCacheKey **)this + 35))
      || ([*((id *)this + 11) _allowPrivateAccessTokensForThirdParty] & 1) != 0
      || (double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(v60),
          CFArrayRef v63 = *(void **)(v62 + 312),
          CFStringRef v64 = CFURLCopyHostName(*(CFURLRef *)(objc_msgSend(*((id *)this + 11), "_inner", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher)+ 8)), objc_msgSend(v63, "checkOriginAllowedAsThirdParty:", (id)CFMakeCollectable(v64))))
    {
      if (*((void *)this + 10))
      {
        char v65 = (void *)*((void *)this + 11);
        long long v66 = *(__CFArray **)(v55 + 232);
        BOOL isFirstPartyResource = HTTPConnectionCacheKey::isFirstPartyResource(*((HTTPConnectionCacheKey **)this + 35));
        HTTPProtocol::askPATForCreds(this, a2, v66, !isFirstPartyResource, [v65 _allowPrivateAccessTokensForThirdParty], *(const __CFURL **)(objc_msgSend(v65, "_inner") + 32));
      }
      uint64_t v4 = 0;
      *((_DWORD *)this + 48) |= 0x40000u;
      goto LABEL_319;
    }
  }
  if (AuthenticationState::isValid(*((void *)this + 97), 0))
  {
    CFArrayRef v161 = 0;
    unint64_t v162 = 0;
    if (v9 == 407
      || !(*(unsigned int (**)(void))(**((void **)this + 35) + 88))(*((void *)this + 35))
      || (*(unsigned int (**)(void))(**((void **)this + 35) + 88))(*((void *)this + 35)) == 1)
    {
      socklen_t v68 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 35) + 72))(*((void *)this + 35));
      if (v68) {
        CFStringRef v153 = (const __CFString *)CFRetain(v68);
      }
      else {
        CFStringRef v153 = 0;
      }
      int v70 = (*(uint64_t (**)(void))(**((void **)this + 35) + 80))(*((void *)this + 35));
      int v71 = (*(uint64_t (**)(void))(**((void **)this + 35) + 88))(*((void *)this + 35));
      CFDictionaryRef v72 = (const __CFDictionary *)(*(uint64_t (**)(void))(**((void **)this + 35) + 64))(*((void *)this + 35));
    }
    else
    {
      CFURLRef v83 = *(const __CFURL **)([*((id *)this + 11) _inner] + 8);
      int v71 = connectionTypeFromURL(v83);
      CFStringRef v153 = CFURLCopyHostName(v83);
      SInt32 v84 = CFURLGetPortNumber(v83);
      CFDictionaryRef v72 = 0;
      if (v71) {
        int v85 = 443;
      }
      else {
        int v85 = 80;
      }
      if (v84 == -1) {
        int v70 = v85;
      }
      else {
        int v70 = v84;
      }
    }
    CFStringRef v151 = 0;
    if (*v155) {
      BOOL v73 = v57 == 6;
    }
    else {
      BOOL v73 = 0;
    }
    char v74 = !v73;
    char v152 = v74;
    if (v57 == 9 && *v155)
    {
      CFStringRef v151 = (const __CFString *)HTTPAuthentication::copyRealm((HTTPAuthentication *)v55);
      char v152 = 0;
    }
    if ((v71 - 1) > 3) {
      int v75 = 1;
    }
    else {
      int v75 = dword_1843D1980[v71 - 1];
    }
    CFStringRef v154 = (const __CFString *)HTTPAuthentication::copyRealm((HTTPAuthentication *)v55);
    if (v75 == 6)
    {
      int valuePtr = 0;
      CFDictionaryRef v76 = (const __CFDictionary *)CFDictionaryGetValue(v72, &unk_1EC0A5678);
      CFDictionaryRef v77 = v76;
      if (v76
        && (CFStringRef v78 = (const __CFString *)CFDictionaryGetValue(v76, &unk_1EC0A56B0),
            CFNumberRef v79 = (const __CFNumber *)CFDictionaryGetValue(v77, &unk_1EC0A56E8),
            CFNumberGetValue(v79, kCFNumberSInt32Type, &valuePtr),
            v78))
      {
        int v70 = valuePtr;
        CFStringRef v80 = v153;
      }
      else
      {
        int valuePtr = v70;
        CFStringRef v80 = v153;
        CFStringRef v78 = v153;
      }
      HTTPAuthentication::buildProtectionSpacesFromAuthSchemes((CFArrayRef *)&cf, v55 - 16, v78, v70, 6, v154);
      std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>((uint64_t)&v161, &cf);
      if (cf) {
        CFRelease(cf);
      }
      if (v161)
      {
        if (CFArrayGetValueAtIndex(v161, 0))
        {
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v161, 0);
          CFRetain(ValueAtIndex);
        }
        operator new();
      }
    }
    else
    {
      CFStringRef v81 = v154;
      if (!v154)
      {
        if (v57 == 12 || v57 == 10) {
          CFStringRef v81 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &stru_1ECFAD558, v151);
        }
        else {
          CFStringRef v81 = 0;
        }
      }
      HTTPAuthentication::buildProtectionSpacesFromAuthSchemes((CFArrayRef *)&cf, v55 - 16, v153, v70, v75, v81);
      std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>((uint64_t)&v161, &cf);
      CFStringRef v80 = v153;
      if (cf) {
        CFRelease(cf);
      }
      CFStringRef v154 = v81;
      if (v161)
      {
        if (CFArrayGetValueAtIndex(v161, 0))
        {
          CFBooleanRef v93 = CFArrayGetValueAtIndex(v161, 0);
          CFRetain(v93);
        }
        operator new();
      }
    }
    if (v80) {
      CFRelease(v80);
    }
    if (v154) {
      CFRelease(v154);
    }
    if (v9 == 407)
    {
      if (v57 != 6)
      {
        if ((*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this))
        {
          uint64_t v94 = *((void *)this + 43);
          if (v94 != 0x7FFFFFFFFFFFFFFFLL) {
            *((void *)this + 43) = v94 + 1;
          }
        }
        if (a2) {
          CFTypeRef v95 = CFRetain(a2);
        }
        else {
          CFTypeRef v95 = 0;
        }
        uint64_t v102 = (const void *)*((void *)this + 42);
        *((void *)this + 42) = v95;
        if (v102) {
          CFRelease(v102);
        }
        if ((v152 & 1) == 0)
        {
          CFAllocatorRef v109 = CFGetAllocator((char *)this - 16);
          uint64_t v104 = CFURLCredentialCreate((uint64_t)v109, (uint64_t)&stru_1ECFAD558, (uint64_t)&stru_1ECFAD558, v110, 1);
          (*(void (**)(HTTPProtocol *, const void *))(*(void *)this + 624))(this, v104);
          if (v104)
          {
            CFRelease(v104);
            LODWORD(v104) = 0;
          }
          goto LABEL_201;
        }
        if ((*(unsigned int (**)(HTTPProtocol *))(*(void *)this + 664))(this)) {
          goto LABEL_193;
        }
        (*(void (**)(HTTPProtocol *, void))(*(void *)this + 632))(this, 0);
        size_t v120 = (void *)*((void *)this + 10);
        if (v120 && [v120 _preventsSystemHTTPProxyAuthentication])
        {
          if ((*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this)) {
            (*(void (**)(HTTPProtocol *, void))(*(void *)this + 624))(this, 0);
          }
LABEL_193:
          LODWORD(v104) = 0;
LABEL_194:
          uint64_t v105 = *((void *)this + 46);
          if (v105)
          {
            uint64_t v106 = *(void *)(v105 + 40);
            if (v106)
            {
              uint64_t v107 = *(void *)(v106 + 32);
              if (v107)
              {
                uint64_t v108 = (const void *)CFURLCredentialCopyPassword(v107, v103);
                if (v108)
                {
                  CFRelease(v108);
                }
                else
                {
                  (*(void (**)(void))(**((void **)this + 46) + 48))(*((void *)this + 46));
                  *((void *)this + 46) = 0;
                }
              }
            }
          }
LABEL_201:
          uint64_t v111 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this);
          if (v104 || !v111)
          {
            CFGetAllocator((char *)this - 16);
            uint64_t v112 = [*((id *)this + 11) _inner];
            id v113 = CFURLResponseCreateWithHTTPResponse(v112, *(const void **)(v112 + 8), (uint64_t)a2, 2);
            (*(void (**)(HTTPProtocol *, void))(*(void *)this + 640))(this, 0);
            CFAllocatorRef v114 = CFGetAllocator((char *)this - 16);
            long long v115 = (const void *)CFURLAuthChallengeCreate((uint64_t)v114, 0, 0, *((void *)this + 43), v113, 0);
            if (v115)
            {
              (*(void (**)(HTTPProtocol *, const void *))(*(void *)this + 640))(this, v115);
              uint64_t v116 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648))(this);
              if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
                dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
              }
              if (v116) {
                uint64_t v117 = (URLAuthChallenge *)(v116 + 16);
              }
              else {
                uint64_t v117 = 0;
              }
              URLAuthChallenge::setListOfProtectionSpaces(v117, v161);
              CFRelease(v115);
            }
          }
          BOOL v69 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this) != 0;
LABEL_314:
          uint64_t v4 = 1;
          char v101 = 1;
LABEL_315:
          if (v162) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v162);
          }
          if ((v101 & 1) == 0) {
            goto LABEL_319;
          }
          goto LABEL_318;
        }
        uint64_t v133 = *((void *)this + 46);
        if (v133 && (CFArrayRef v134 = *(_CFURLProtectionSpace **)(v133 + 48)) != 0 && !*((void *)this + 43))
        {
          AuthBrokerAgentClient::cachedProxyCredentialForProtectionSpace((AuthBrokerAgentClient *)&cf, v134);
          if (cf)
          {
            (*(void (**)(HTTPProtocol *, CFTypeRef))(*(void *)this + 608))(this, cf);
            *((_DWORD *)this + 48) |= 0x400000u;
            goto LABEL_323;
          }
        }
        else
        {
          CFTypeRef cf = 0;
        }
        if (HTTPProtocol::asynchronouslyQueryAuthBroker(this))
        {
          LODWORD(v104) = 0;
          goto LABEL_324;
        }
        CFIndex v137 = (const void *)(*(uint64_t (**)(void, void, void))(**((void **)this + 87) + 80))(*((void *)this + 87), 0, *((void *)this + 10));
        (*(void (**)(HTTPProtocol *, const void *))(*(void *)this + 624))(this, v137);
        if (v137) {
          CFRelease(v137);
        }
LABEL_323:
        LODWORD(v104) = 1;
LABEL_324:
        if (cf) {
          (*(void (**)(CFTypeRef))(*(void *)cf + 48))(cf);
        }
        goto LABEL_194;
      }
LABEL_187:
      uint64_t v4 = HTTPProtocol::handleKerberosChallenge(this, *(unsigned __int8 *)(v55 + 224), a2, 0, v161, v10);
      char v101 = 0;
      BOOL v69 = v4;
      goto LABEL_315;
    }
    if (v57 == 6) {
      goto LABEL_187;
    }
    uint64_t v96 = [*((id *)this + 11) _inner];
    uint64_t v99 = *(void *)(v96 + 8);
    if (v99) {
      CFStringRef v100 = CFURLCopyUserName(*(CFURLRef *)(v96 + 8));
    }
    else {
      CFStringRef v100 = 0;
    }
    if (*((void *)this + 44) && (*((void *)this + 47) || !*((unsigned char *)this + 41)))
    {
      if (v100) {
        BOOL v118 = CFStringGetLength(v100) == 0;
      }
      else {
        BOOL v118 = 1;
      }
      uint64_t v121 = *((void *)this + 40);
      if (v121 != 0x7FFFFFFFFFFFFFFFLL) {
        *((void *)this + 40) = v121 + 1;
      }
      HTTPProtocol::RemoveCredentialPasswordForProtectionSpace(this, *((const _CFURLCredential **)this + 44), 0, v118);
      uint64_t v119 = (const void *)*((void *)this + 44);
      *((void *)this + 44) = 0;
    }
    else
    {
      uint64_t v119 = 0;
    }
    if (a2) {
      CFTypeRef v122 = CFRetain(a2);
    }
    else {
      CFTypeRef v122 = 0;
    }
    CFMutableDataRef v123 = (const void *)*((void *)this + 39);
    *((void *)this + 39) = v122;
    if (v123) {
      CFRelease(v123);
    }
    if (v57 == 9)
    {
      uint64_t v124 = *((void *)this + 40);
      if (v124 < 1 || !*((void *)this + 44)) {
        *((_DWORD *)this + 48) |= 0x40000000u;
      }
      if (v119 && v124 == 1)
      {
        CFTypeRef v125 = CFRetain(v119);
        uint64_t v126 = *((unsigned int *)this + 48);
        *((void *)this + 44) = v125;
        unint64_t v127 = v126 & 0xFFFFFFFFBFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        *((_DWORD *)this + 48) = v127;
        *((_WORD *)this + 98) = WORD2(v127);
      }
      if ((v152 & 1) == 0)
      {
        if (!*((unsigned char *)this + 41)) {
          goto LABEL_282;
        }
        if (*v155 && v100 && v151)
        {
          if ((*((_DWORD *)this + 48) & 0x40000000) != 0)
          {
            CFAllocatorRef v128 = CFGetAllocator((char *)this - 16);
            CFAllocatorRef v129 = _CFURLCredentialCreateXMobileMeAuthToken((uint64_t)v128, v100, 0, v151);
            *((void *)this + 44) = v129;
            if (v129)
            {
              if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
                dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
              }
              if (v129[12] != 4
                || !(*(unsigned int (**)(_DWORD *))(*((void *)v129 + 2) + 144))(v129 + 4))
              {
                CFStringRef v130 = (const void *)*((void *)this + 44);
                *((void *)this + 44) = 0;
                if (v130) {
                  CFRelease(v130);
                }
              }
            }
            else
            {
              *((void *)this + 44) = 0;
            }
            unint64_t v150 = *((_DWORD *)this + 48) & 0xBFFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
            *((_DWORD *)this + 48) &= ~0x40000000u;
            *((_WORD *)this + 98) = WORD2(v150);
            goto LABEL_283;
          }
        }
        else if (!*v155)
        {
          goto LABEL_282;
        }
        CFArrayRef v135 = (void *)*((void *)this + 10);
        if (v135) {
          unsigned __int8 v136 = [v135 _prohibitAuthUI] ^ 1;
        }
        else {
          unsigned __int8 v136 = 1;
        }
        *((_DWORD *)this + 48) |= 0x20000000u;
        uint64_t v138 = *((void *)this + 44);
        if (v138) {
          CFStringRef v139 = (const __CFString *)CFURLCredentialCopyPassword(v138, v97);
        }
        else {
          CFStringRef v139 = 0;
        }
        HTTPProtocol::performAsyncCallout(this, v100, v139, v154, v136, a2, v98);
        if (v139) {
          CFRelease(v139);
        }
LABEL_282:
        if (!v100)
        {
LABEL_284:
          if (v151) {
            CFRelease(v151);
          }
          if (*((void *)this + 44) && !*((unsigned char *)this + 41) && *((uint64_t *)this + 40) < 1) {
            goto LABEL_300;
          }
          CFGetAllocator((char *)this - 16);
          uint64_t v140 = [*((id *)this + 11) _inner];
          id v141 = CFURLResponseCreateWithHTTPResponse(v140, *(const void **)(v140 + 8), (uint64_t)a2, 2);
          v142 = (const void *)*((void *)this + 47);
          if (v142) {
            CFRelease(v142);
          }
          CFAllocatorRef v143 = CFGetAllocator((char *)this - 16);
          CFArrayRef v144 = *((void *)this + 44) ? (const void *)*((void *)this + 44) : v119;
          uint64_t v145 = CFURLAuthChallengeCreate((uint64_t)v143, 0, v144, *((void *)this + 40), v141, 0);
          *((void *)this + 47) = v145;
          if (v145)
          {
            if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
              dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
            }
            URLAuthChallenge::setListOfProtectionSpaces((URLAuthChallenge *)(v145 + 16), v161);
            BOOL v146 = 0;
          }
          else
          {
            BOOL v146 = *((void *)this + 44) != 0;
          }

          if (v146)
          {
LABEL_300:
            BOOL v69 = 1;
          }
          else
          {
            int v147 = (const _CFURLCredential *)*((void *)this + 44);
            if (v147)
            {
              unint64_t v148 = (AuthenticationState *)*((void *)this + 97);
              if (a2)
              {
                if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
                  dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
                }
                if (*((unsigned char *)a2 + 40)) {
                  CFDictionaryRef v149 = (char *)a2 + 16;
                }
                else {
                  CFDictionaryRef v149 = 0;
                }
                int v147 = (const _CFURLCredential *)*((void *)this + 44);
              }
              else
              {
                CFDictionaryRef v149 = 0;
              }
              AuthenticationState::updateState(v148, (uint64_t)v149, *((void *)this + 47), v147, *((__SecTrust **)this + 57));
            }
            BOOL v69 = 0;
          }
          if (v119) {
            CFRelease(v119);
          }
          goto LABEL_314;
        }
LABEL_283:
        CFRelease(v100);
        goto LABEL_284;
      }
    }
    else if ((v152 & 1) == 0)
    {
      if (v57 == 10 && *((unsigned char *)this + 41) && *v155 && v99) {
        *((void *)this + 44) = (*(uint64_t (**)(void, void, void))(**((void **)this + 87) + 80))(*((void *)this + 87), 0, *((void *)this + 10));
      }
      goto LABEL_282;
    }
    uint64_t v131 = *((void *)this + 44);
    if (v131)
    {
      v132 = (const void *)CFURLCredentialCopyPassword(v131, v97);
      if (!v132 && v57 != 9)
      {
        v132 = (const void *)*((void *)this + 44);
        *((void *)this + 44) = 0;
      }
      if (v132) {
        CFRelease(v132);
      }
    }
    goto LABEL_282;
  }
  BOOL v69 = 0;
  *((_DWORD *)this + 48) |= 0x40000u;
LABEL_318:
  uint64_t v4 = v69;
LABEL_319:
  if (v158) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v158);
  }
  return v4;
}

void sub_184236728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, CFTypeRef cf, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, CFTypeRef a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a11);
  }
  uint64_t v30 = *(std::__shared_weak_count **)(v28 - 104);
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v30);
  }
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  }
  _Unwind_Resume(exception_object);
}

void HTTPProtocol::challengeDelegateOrFinishBrokeringProxyAuth(HTTPProtocol *this)
{
  uint64_t v2 = *((unsigned int *)this + 48);
  unint64_t v3 = v2 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32) | 0x10000000000;
  *((_DWORD *)this + 48) = v2;
  *((_WORD *)this + 98) = WORD2(v3);
  uint64_t v4 = (_CFURLAuthChallenge *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648))(this);
  if (!v4)
  {
    *((_DWORD *)this + 48) |= 0x8000u;
    uint64_t v6 = *((void *)this + 78);
    if (v6)
    {
      uint64_t v7 = *(void (**)(void *, long long *))(v6 + 8);
      uint64_t v8 = *(void *)(v6 + 16);
      CFIndex v9 = (void *)(v6 + (v8 >> 1));
      if (v8) {
        uint64_t v7 = *(void (**)(void *, long long *))(*v9 + v7);
      }
      long long v10 = 0uLL;
      v7(v9, &v10);
      if (*((void *)&v10 + 1)) {
        std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v10 + 1));
      }
    }
    SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs();
  }
  uint64_t v5 = v4;
  CFRetain(v4);
  HTTPProtocol::sendDidReceiveAuthChallenge(this, v5);

  CFRelease(v5);
}

void sub_184236A5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void setTypeProperty<_CFURLCredential const*>(CFTypeRef *a1, CFTypeRef cf)
{
  if (*a1) {
    CFRelease(*a1);
  }
  *a1 = cf;
}

void HTTPProtocol::askPATForCreds(HTTPProtocol *this, __CFHTTPMessage *a2, __CFArray *a3, BOOL a4, BOOL a5, const __CFURL *a6)
{
  uint64_t v8 = *((void *)this + 93);
  if (v8)
  {
    uint64_t v9 = *((void *)this + 35);
    if (v9)
    {
      uint64_t v10 = *(void *)(v8 + 168);
      if (v10)
      {
        uint64_t v11 = (const void *)*((void *)this + 3);
        v13[0] = 0;
        v13[1] = v13;
        v13[2] = 0x3052000000;
        v13[3] = __Block_byref_object_copy_;
        v13[4] = __Block_byref_object_dispose_;
        void v13[5] = 0;
        v12[0] = MEMORY[0x1E4F143A8];
        v12[1] = 3221225472;
        v12[2] = ___ZN12XTubeManager22getPATTimestampsForKeyEPK22HTTPConnectionCacheKeyPK17CoreSchedulingSet_block_invoke;
        v12[3] = &unk_1E5257A98;
        v12[4] = v13;
        void v12[5] = v9;
        XTubeManager::withTubeManager(v10, v11, (uint64_t)v12);
        _Block_object_dispose(v13, 8);
      }
    }
  }
  CFHTTPMessageCopyRequestURL(a2);
  CFRetain((char *)this - 16);
  operator new();
}

void sub_184236E00(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

BOOL connectionTypeFromURL(const __CFURL *a1)
{
  CFStringRef v1 = CFURLCopyScheme(a1);
  CFComparisonResult v2 = CFStringCompare(v1, (CFStringRef)&unk_1EC0A5D78, 1uLL);
  if (v1) {
    CFRelease(v1);
  }
  return v2 == kCFCompareEqualTo;
}

uint64_t HTTPProtocol::handleKerberosChallenge(HTTPProtocol *this, int a2, __CFHTTPMessage *a3, _CFURLProtectionSpace *a4, const __CFArray *a5, int a6)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (a6)
  {
    if ((*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648))(this))
    {
      uint64_t v12 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648))(this);
      CFTypeRef v13 = CFRetain(v12);
    }
    else
    {
      CFTypeRef v13 = 0;
    }
    BOOL v15 = (uint64_t *)((char *)this + 344);
    if ((*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this))
    {
      CFAllocatorRef v16 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this);
      goto LABEL_11;
    }
LABEL_13:
    CFTypeRef cf = 0;
    if (!v13) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }
  id v14 = (const void *)*((void *)this + 47);
  if (v14) {
    CFTypeRef v13 = CFRetain(v14);
  }
  else {
    CFTypeRef v13 = 0;
  }
  BOOL v15 = (uint64_t *)((char *)this + 320);
  CFAllocatorRef v16 = (const void *)*((void *)this + 44);
  if (!v16) {
    goto LABEL_13;
  }
LABEL_11:
  CFTypeRef cf = CFRetain(v16);
  if (!v13) {
    goto LABEL_16;
  }
LABEL_14:
  if (*v15 != 0x7FFFFFFFFFFFFFFFLL) {
    ++*v15;
  }
LABEL_16:
  CFTypeRef v45 = v13;
  if (*((unsigned char *)this + 40) && *v15 <= 1)
  {
    if (HTTPAuthentication::isSafariProcess(void)::onceToken != -1) {
      dispatch_once(&HTTPAuthentication::isSafariProcess(void)::onceToken, &__block_literal_global_3_9474);
    }
    if (HTTPAuthentication::isSafariProcess(void)::isSafari) {
      BOOL v17 = a2 == 0;
    }
    else {
      BOOL v17 = *((unsigned char *)this + 41) == 0;
    }
    uint64_t v18 = v17;
  }
  else
  {
    uint64_t v18 = 0;
  }
  CFGetAllocator((char *)this - 16);
  uint64_t v19 = [*((id *)this + 11) _inner];
  id v20 = CFURLResponseCreateWithHTTPResponse(v19, *(const void **)(v19 + 8), (uint64_t)a3, 2);
  CFAllocatorRef v21 = CFGetAllocator((char *)this - 16);
  uint64_t v22 = CFURLAuthChallengeCreate((uint64_t)v21, a4, cf, *v15, v20, 0);
  if (v22)
  {
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
    }
    URLAuthChallenge::setListOfProtectionSpaces((URLAuthChallenge *)(v22 + 16), a5);
  }
  if (a6)
  {
    (*(void (**)(HTTPProtocol *, uint64_t))(*(void *)this + 640))(this, v22);
  }
  else
  {
    uint64_t v23 = (const void *)*((void *)this + 47);
    if (v23) {
      CFRelease(v23);
    }
    *((void *)this + 47) = v22;
    if (v22) {
      CFRetain((CFTypeRef)v22);
    }
  }
  uint64_t v24 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 592))(this);
  if (a2 || v24)
  {
    uint64_t KerberosAccountBroker = KerberosAccountBroker::getKerberosAccountBroker(*((KerberosAccountBroker **)this + 10), v25);
    if (KerberosAccountBroker)
    {
      double v27 = (void *)KerberosAccountBroker;
      if (a6)
      {
        if ((*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this)
          && (uint64_t v28 = *((unsigned int *)this + 48), (v28 & 0x1000000) != 0))
        {
          unint64_t v31 = v28 & 0xFFFFFFFFFEFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
          *((_DWORD *)this + 48) = v28 & 0xFEFFFFFF;
          *((_WORD *)this + 98) = WORD2(v31);
        }
        else
        {
          (*(void (**)(HTTPProtocol *, void))(*(void *)this + 624))(this, 0);
        }
        CFRetain((char *)this - 16);
        uint64_t v32 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this);
      }
      else
      {
        uint64_t v29 = *((unsigned int *)this + 48);
        if ((v29 & 0x800000) != 0)
        {
          unint64_t v33 = v29 & 0xFFFFFFFFFF7FFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
          *((_DWORD *)this + 48) = v29 & 0xFF7FFFFF;
          *((_WORD *)this + 98) = WORD2(v33);
        }
        else
        {
          uint64_t v30 = (const void *)*((void *)this + 44);
          *((void *)this + 44) = 0;
          if (v30) {
            CFRelease(v30);
          }
        }
        CFRetain((char *)this - 16);
        uint64_t v32 = (const void *)*((void *)this + 44);
      }
      CFIndex v34 = (const void *)objc_msgSend(*((id *)this + 11), "cfURL", v45);
      v47[0] = MEMORY[0x1E4F143A8];
      v47[1] = 3221225472;
      v47[2] = ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke;
      v47[3] = &__block_descriptor_41_e27_v16__0___CFURLCredential__8l;
      v47[4] = this;
      char v48 = a6;
      KerberosAccountBroker::getKerberosCredentialForURL(v27, v32, v34, (uint64_t)v47);
      *((_DWORD *)this + 48) |= 0x4000000u;
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v35 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = this;
        _os_log_impl(&dword_184085000, v35, OS_LOG_TYPE_DEFAULT, "Waiting for Accounts to provide credential %p", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v36 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_79_8564, 3);
      uint64_t v37 = v36;
      if (v36
        && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v36 + 16))(v36, "Waiting for Accounts", 0))
      {
        CFAllocatorRef v38 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        *(void *)&long long buf = off_1ECF9A530;
        CFStringRef v39 = CFStringCreateWithCString(v38, "Protocol", 0x8000100u);
        uint64_t v50 = 0;
        uint64_t v51 = 0;
        *((void *)&buf + 1) = v39;
        uint64_t v40 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 32))(this);
        (*(void (**)(uint64_t, void, const void *))(*(void *)v37 + 64))(v37, *((void *)&buf + 1), v40);
        if (v40) {
          CFRelease(v40);
        }
        AutoString::~AutoString((AutoString *)&buf);
        (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
      }
      HTTPProtocol::destroyReadStream(this);
      uint64_t v18 = 0;
    }
  }
  if (a6)
  {
    if (a3) {
      CFTypeRef v41 = CFRetain(a3);
    }
    else {
      CFTypeRef v41 = 0;
    }
    uint64_t v43 = (const void *)*((void *)this + 42);
    *((void *)this + 42) = v41;
    if (v43) {
LABEL_68:
    }
      CFRelease(v43);
  }
  else
  {
    if (a3) {
      CFTypeRef v42 = CFRetain(a3);
    }
    else {
      CFTypeRef v42 = 0;
    }
    uint64_t v43 = (const void *)*((void *)this + 39);
    *((void *)this + 39) = v42;
    if (v43) {
      goto LABEL_68;
    }
  }
  if (v22) {
    CFRelease((CFTypeRef)v22);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v45) {
    CFRelease(v45);
  }
  return v18;
}

void sub_1842375E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef a9, CFTypeRef cf, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (v18) {
    CFRelease(v18);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (a9) {
    CFRelease(a9);
  }
  _Unwind_Resume(exception_object);
}

void HTTPProtocol::RemoveCredentialPasswordForProtectionSpace(HTTPProtocol *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, int a4)
{
  CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
  uint64_t Username = CFURLCredentialGetUsername((uint64_t)a2);
  uint64_t v10 = CFURLCredentialCreate((uint64_t)v7, Username, 0, v9, 2);
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = **((void **)this + 87);
    if (a4) {
      (*(void (**)(void))(v12 + 56))();
    }
    else {
      (*(void (**)(void))(v12 + 64))();
    }
    CFRelease(v11);
  }
}

void HTTPProtocol::performAsyncCallout(HTTPProtocol *this, const __CFString *a2, const __CFString *a3, const __CFString *a4, unsigned __int8 a5, __CFHTTPMessage *a6, double a7)
{
  values[1] = *(void **)MEMORY[0x1E4F143B8];
  double Helper_x8__kAOSAuthTrustInfoKey = gotLoadHelper_x8__kAOSAuthTrustInfoKey(a7);
  uint64_t v12 = *(void **)(v11 + 792);
  if (v12) {
    BOOL v13 = v8 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13) {
    goto LABEL_19;
  }
  id v14 = v9;
  BOOL v15 = (void *)*((void *)this + 57);
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v15)
  {
    *(void *)keys = *v12;
    values[0] = v15;
    CFDictionaryRef v17 = CFDictionaryCreate(v16, (const void **)keys, (const void **)values, 1, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  }
  else
  {
    CFDictionaryRef v17 = 0;
  }
  uint64_t delayInitStub = AOSAccountCreate_delayInitStub(Helper_x8__kAOSAuthTrustInfoKey);
  if (v14) {
    BOOL v19 = delayInitStub == 0;
  }
  else {
    BOOL v19 = 1;
  }
  int v20 = v19;
  if (!v19)
  {
    CFHTTPMessageCopyRequestURL(v14);
    uint64_t v26 = 0;
    long long v25 = 0u;
    long long v24 = 0u;
    *(_OWORD *)&keys[8] = 0u;
    *(void *)keys = 1;
    CFRetain((char *)this - 16);
    operator new();
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v20)
  {
LABEL_19:
    *((_DWORD *)this + 48) &= 0xDFFFFFFB;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFAllocatorRef v21 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = *((void *)this + 99);
      *(_DWORD *)keys = 138543362;
      *(void *)&keys[4] = v22;
      _os_log_error_impl(&dword_184085000, v21, OS_LOG_TYPE_ERROR, "%{public}@ AOS authentication failed, canceling auth", keys, 0xCu);
    }
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC0CLL);
  }
}

void sub_184237A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  _Unwind_Resume(a1);
}

char *HTTPProtocol::asynchronouslyQueryAuthBroker(HTTPProtocol *this)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  CFComparisonResult v2 = (AuthBrokerAgentClient *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 656))(this);
  unint64_t v3 = AuthBrokerAgentClient::AuthBrokerIsAvailable(v2);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v4 = CFNLog::logger;
  if (v3)
  {
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *((void *)this + 99);
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v5;
      _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "%{public}@ querying AuthBrokerAgent", (uint8_t *)&buf, 0xCu);
    }
    CFRetain((char *)this - 16);
    operator new();
  }
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v12 = *((void *)this + 99);
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v12;
    _os_log_error_impl(&dword_184085000, v4, OS_LOG_TYPE_ERROR, "Failed to query AuthBrokerAgent %{public}@", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_67, 3);
  uint64_t v7 = v6;
  if (v6
    && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v6 + 16))(v6, "Failed to query AuthBrokerAgent", 0))
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *(void *)&long long buf = off_1ECF9A530;
    CFStringRef v9 = CFStringCreateWithCString(v8, "Protocol", 0x8000100u);
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    *((void *)&buf + 1) = v9;
    uint64_t v10 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 32))(this);
    (*(void (**)(uint64_t, void, const void *))(*(void *)v7 + 64))(v7, *((void *)&buf + 1), v10);
    if (v10) {
      CFRelease(v10);
    }
    AutoString::~AutoString((AutoString *)&buf);
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  return v3;
}

void sub_184237E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 792);
    *(_DWORD *)long long buf = 138543362;
    uint64_t v7 = v5;
    _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "AuthBrokerAgent query finished %{public}@", buf, 0xCu);
  }
  if (a2) {
    (*(void (**)(uint64_t))(*(void *)a2 + 40))(a2);
  }
  operator new();
}

void sub_1842380BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18)
{
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_65@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  CFComparisonResult v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1219;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke_8505()
{
}

void sub_1842381BC(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectIN19TransportConnection17RefCountedWrapperEE5ClassEv_block_invoke()
{
}

void sub_184238244(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HTTPProtocol17destroyReadStreamEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  CFComparisonResult v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 2457;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_56(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    uint64_t v4 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
  }
  else {
    uint64_t v4 = 0;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(v3 + 792);
    *(_DWORD *)CFAllocatorRef v21 = 138412546;
    *(void *)&v21[4] = v4;
    *(_WORD *)&v21[12] = 2114;
    *(void *)&v21[14] = v6;
    _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "AuthBrokerAgent sent cred %@ %{public}@", v21, 0x16u);
  }
  uint64_t v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_59, 3);
  uint64_t v8 = v7;
  if (v7
    && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v7 + 16))(v7, "AuthBrokerAgent Callback", 0))
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v10 = *(void *)(a1 + 56);
    *(void *)CFAllocatorRef v21 = off_1ECF9A530;
    CFStringRef v11 = CFStringCreateWithCString(v9, "Protocol", 0x8000100u);
    uint64_t v22 = 0;
    *(_OWORD *)&v21[8] = (unint64_t)v11;
    if (v10)
    {
      uint64_t v12 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 32))(v10);
      CFStringRef v11 = *(CFStringRef *)&v21[8];
    }
    else
    {
      uint64_t v12 = @"null";
    }
    (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v8 + 64))(v8, v11, v12);
    if (v10 && v12) {
      CFRelease(v12);
    }
    AutoString::~AutoString((AutoString *)v21);
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v13 = *(void *)(a1 + 56);
  int v14 = *(_DWORD *)(v13 + 192);
  v13 += 192;
  __int16 v15 = *(_WORD *)(v13 + 4);
  *(_DWORD *)uint64_t v13 = v14 & 0xFFDFFFFF;
  *(_WORD *)(v13 + 4) = v15;
  uint64_t v16 = *(void *)(a1 + 56);
  if (((*(unsigned int *)(v16 + 192) | ((unint64_t)*(unsigned __int16 *)(v16 + 196) << 32)) & 0x4000000000) == 0
    && !(*(unsigned int (**)(uint64_t))(*(void *)v16 + 520))(v16))
  {
    (*(void (**)(void, void))(**(void **)(a1 + 56) + 608))(*(void *)(a1 + 56), *(void *)(a1 + 40));
    if (!*(void *)(a1 + 40)) {
      goto LABEL_26;
    }
    if ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 648))(*(void *)(a1 + 56)))
    {
      *(_DWORD *)(*(void *)(a1 + 56) + 192) |= 0x400000u;
      uint64_t v17 = *(void *)(a1 + 56);
      uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 32);
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 648))(v17);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17 + 120))(v17, v18, v19);
      goto LABEL_19;
    }
    if (!*(void *)(a1 + 40)) {
LABEL_26:
    }
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 56) + 672))(*(void *)(a1 + 56), 1);
    uint64_t v20 = *(void *)(a1 + 56);
    if (((*(unsigned int *)(v20 + 192) | ((unint64_t)*(unsigned __int16 *)(v20 + 196) << 32)) & 0x8000000000) != 0)
    {
      HTTPProtocol::challengeDelegateOrFinishBrokeringProxyAuth((HTTPProtocol *)v20);
    }
    else
    {
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*(void *)(v20 + 832), 3, 0);
      HTTPProtocol::createAndOpenStream(*(HTTPProtocol **)(a1 + 56), 0);
    }
  }
LABEL_19:
  if (v4) {
    CFRelease(v4);
  }
}

void sub_184238710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  AutoString::~AutoString((AutoString *)&a9);
  if (v9) {
    CFRelease(v9);
  }
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_40c50_ZTSNSt3__110shared_ptrI22NetworkProxyCredentialEE56c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_e8_40c50_ZTSNSt3__110shared_ptrI22NetworkProxyCredentialEE56c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN12HTTPProtocol48asynchronouslyAddAuthenticatorHeadersAndContinueEP15__CFHTTPMessage_block_invoke(int a1, int a2, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  operator new();
}

void sub_1842389D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a21);
  }
  if (a19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a19);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a17);
  }
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN12HTTPProtocol48asynchronouslyAddAuthenticatorHeadersAndContinueEP15__CFHTTPMessage_block_invoke_2(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 792);
    int v4 = *(unsigned __int8 *)(a1 + 96);
    uint64_t v5 = *(void *)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 64);
    int v10 = 138544130;
    uint64_t v11 = v3;
    __int16 v12 = 1024;
    int v13 = v4;
    __int16 v14 = 2112;
    uint64_t v15 = v5;
    __int16 v16 = 2112;
    uint64_t v17 = v6;
    _os_log_impl(&dword_184085000, v2, OS_LOG_TYPE_DEFAULT, "%{public}@ protocol received continueLoad=%d, headers=%@ req=%@", (uint8_t *)&v10, 0x26u);
  }
  if (*(unsigned char *)(a1 + 96))
  {
    CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 48);
    if (v7)
    {
      if (CFDictionaryGetCount(v7)) {
        _CFHTTPMessageSetMultipleHeaderFields(*(__CFHTTPMessage **)(a1 + 80), *(CFDictionaryRef *)(a1 + 48));
      }
    }
    HTTPProtocol::asynchronouslyCreateAndOpenStream_WithMessage_AfterCookiesAndAuthenticatorHeaders(*(HTTPProtocol **)(a1 + 32), *(os_unfair_lock_s **)(a1 + 80));
  }
  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v8 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 792);
      int v10 = 138543362;
      uint64_t v11 = v9;
      _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@ authentication client does not want to continue load", (uint8_t *)&v10, 0xCu);
    }
    HTTPProtocol::sendError(*(HTTPProtocol **)(a1 + 32), (const __CFString *)0xFFFFFFFFFFFFFC19);
  }
}

void __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE64c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  int v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[5];
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void *__copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE64c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[9];
  result[8] = a2[8];
  result[9] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a2[11];
  result[10] = a2[10];
  result[11] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_pointer<_CFURLRequest const*,Deleter_CFRelease,std::allocator<_CFURLRequest const>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void std::__shared_ptr_pointer<_CFURLRequest const*,Deleter_CFRelease,std::allocator<_CFURLRequest const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t std::__shared_ptr_emplace<APSRelayTransaction>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<APSRelayTransaction>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6A30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<APSRelayTransaction>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6A30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::setTransactionMetrics(uint64_t this, __CFN_TransactionMetrics *a2)
{
  uint64_t v2 = *(void *)(this + 8);
  *(void *)(v2 + 280) = a2;
  *(void *)(*(void *)(v2 + 48) + 176) = a2;
  return this;
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::getProxy@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 8);
  uint64_t v4 = *(void *)(v2 + 128);
  uint64_t v3 = *(void *)(v2 + 136);
  *a2 = v4;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

void non-virtual thunk to'APSRelayTransactionWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 136);
  *(void *)(v2 + 128) = v3;
  *(void *)(v2 + 136) = v4;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::copyTrust(APSRelayTransactionWrapper *this)
{
  return 0;
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::getConnectionIdentifier(APSRelayTransactionWrapper *this)
{
  return 0;
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::rawBytesReceived(APSRelayTransactionWrapper *this)
{
  return *(void *)(*((void *)this + 1) + 256);
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::rawBytesSent(APSRelayTransactionWrapper *this)
{
  return *(void *)(*((void *)this + 1) + 248);
}

void non-virtual thunk to'APSRelayTransactionWrapper::setBodyStreamBeforeOpening(APSRelayTransaction **this, __CFReadStream *a2)
{
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::updateScheduling(APSRelayTransaction **this, const CoreSchedulingSet *a2)
{
  return APSRelayTransaction::_updateScheduling(this[1], a2);
}

void non-virtual thunk to'APSRelayTransactionWrapper::closeAndClearHandler(APSRelayTransaction **this)
{
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::scheduleAndOpenWithHandler(uint64_t a1, const CoreSchedulingSet *a2, void *a3, void *a4)
{
  return 1;
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::canScheduleAndOpenWithHandlerAsync(APSRelayTransactionWrapper *this)
{
  return 1;
}

BOOL non-virtual thunk to'APSRelayTransactionWrapper::setProperty(uint64_t a1, int a2, const void *a3)
{
  return APSRelayTransaction::setProperty(*(void *)(a1 + 8), a2, a3);
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::copyProperty()
{
  return 0;
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::_meta_release(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(*((void *)this - 3) + 48))();
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::_meta_retain(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(*((void *)this - 3) + 40))();
}

void non-virtual thunk to'APSRelayTransactionWrapper::~APSRelayTransactionWrapper(APSRelayTransactionWrapper *this)
{
  uint64_t v2 = (char *)this - 24;
  *((void *)this - 3) = &unk_1ECFA3570;
  *(void *)this = &unk_1ECFA3648;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v4, v2);
}

{
  std::__shared_weak_count *v1;

  *((void *)this - 3) = &unk_1ECFA3570;
  *(void *)this = &unk_1ECFA3648;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t APSRelayTransactionWrapper::_meta_release(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

uint64_t APSRelayTransactionWrapper::_meta_retain(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

uint64_t APSRelayTransactionWrapper::setTransactionMetrics(uint64_t this, __CFN_TransactionMetrics *a2)
{
  uint64_t v2 = *(void *)(this + 32);
  *(void *)(v2 + 280) = a2;
  *(void *)(*(void *)(v2 + 48) + 176) = a2;
  return this;
}

uint64_t APSRelayTransactionWrapper::getProxy@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 32);
  uint64_t v4 = *(void *)(v2 + 128);
  uint64_t v3 = *(void *)(v2 + 136);
  *a2 = v4;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

void APSRelayTransactionWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *a2;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 136);
  *(void *)(v2 + 128) = v3;
  *(void *)(v2 + 136) = v4;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

uint64_t APSRelayTransactionWrapper::copyTrust(APSRelayTransactionWrapper *this)
{
  return 0;
}

uint64_t APSRelayTransactionWrapper::getConnectionIdentifier(APSRelayTransactionWrapper *this)
{
  return 0;
}

uint64_t APSRelayTransactionWrapper::rawBytesReceived(APSRelayTransactionWrapper *this)
{
  return *(void *)(*((void *)this + 4) + 256);
}

uint64_t APSRelayTransactionWrapper::rawBytesSent(APSRelayTransactionWrapper *this)
{
  return *(void *)(*((void *)this + 4) + 248);
}

void APSRelayTransactionWrapper::setBodyStreamBeforeOpening(APSRelayTransaction **this, __CFReadStream *a2)
{
}

uint64_t APSRelayTransactionWrapper::updateScheduling(APSRelayTransaction **this, const CoreSchedulingSet *a2)
{
  return APSRelayTransaction::_updateScheduling(this[4], a2);
}

void APSRelayTransactionWrapper::closeAndClearHandler(APSRelayTransaction **this)
{
}

uint64_t APSRelayTransactionWrapper::scheduleAndOpenWithHandler(uint64_t a1, const CoreSchedulingSet *a2, void *a3, void *a4)
{
  return 1;
}

uint64_t APSRelayTransactionWrapper::canScheduleAndOpenWithHandlerAsync(APSRelayTransactionWrapper *this)
{
  return 1;
}

BOOL APSRelayTransactionWrapper::setProperty(uint64_t a1, int a2, const void *a3)
{
  return APSRelayTransaction::setProperty(*(void *)(a1 + 32), a2, a3);
}

uint64_t APSRelayTransactionWrapper::copyProperty()
{
  return 0;
}

void APSRelayTransactionWrapper::~APSRelayTransactionWrapper(APSRelayTransactionWrapper *this)
{
  *(void *)this = &unk_1ECFA3570;
  *((void *)this + 3) = &unk_1ECFA3648;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);

  CFAllocatorDeallocate(v3, this);
}

{
  std::__shared_weak_count *v1;

  *(void *)this = &unk_1ECFA3570;
  *((void *)this + 3) = &unk_1ECFA3648;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t ___ZN12HTTPProtocol81asynchronouslyCreateAndOpenStream_WithMessage_AfterCookiesAndAuthenticatorHeadersEP15__CFHTTPMessage_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 3196;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void std::__shared_ptr_pointer<__CFHTTPMessage *,Deleter_CFRelease,std::allocator<__CFHTTPMessage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t ___ZN12HTTPProtocol35asynchronouslyAddCookiesAndContinueEP15__CFHTTPMessage_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 3650;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_57@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1183;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t std::__shared_ptr_pointer<NetworkProxyCredential *,Deleter_release<NetworkProxyCredential>,std::allocator<NetworkProxyCredential>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

void std::__shared_ptr_pointer<NetworkProxyCredential *,Deleter_release<NetworkProxyCredential>,std::allocator<NetworkProxyCredential>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void ___ZN12HTTPProtocol19performAsyncCalloutEPK10__CFStringS2_S2_hP15__CFHTTPMessage_block_invoke(uint64_t a1, double a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  int v5 = *(_DWORD *)(v3 + 192);
  v3 += 192;
  __int16 v6 = *(_WORD *)(v3 + 4);
  *(_DWORD *)uint64_t v3 = v5 & 0xDFFFFFFF;
  *(_WORD *)(v3 + 4) = v6;
  if (AOSTransactionSuccessful_delayInitStub(a2))
  {
    *(_DWORD *)(*(void *)(a1 + 40) + 192) |= 0x40000000u;
    uint64_t v8 = *(HTTPProtocol **)(a1 + 40);
    HTTPProtocol::createAndOpenStream(v8, 0);
  }
  else
  {
    Error_uint64_t delayInitStub = AOSTransactionGetError_delayInitStub(v7);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    int v10 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(v4 + 792);
      int v12 = 138543618;
      uint64_t v13 = v11;
      __int16 v14 = 2112;
      uint64_t v15 = Error_delayInitStub;
      _os_log_impl(&dword_184085000, v10, OS_LOG_TYPE_DEFAULT, "%{public}@ _AOSAccountResolveAuthFailure failed with error %@, canceling auth", (uint8_t *)&v12, 0x16u);
    }
    HTTPProtocol::sendError((HTTPProtocol *)v4, (const __CFString *)0xFFFFFFFFFFFFFC0CLL);
  }
}

void ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  CFRetain((CFTypeRef)(v4 - 16));
  if (a2)
  {
    CFRetain(a2);
  }
  else
  {
    if (*(unsigned char *)(a1 + 40)) {
      int v5 = *(_DWORD *)(v4 + 192) | 0x10000000;
    }
    else {
      int v5 = *(_DWORD *)(v4 + 192) | 0x8000000;
    }
    *(_WORD *)(v4 + 196) = *(_WORD *)(v4 + 196);
    *(_DWORD *)(v4 + 192) = v5;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  __int16 v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = a2;
    _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "Accounts sent cred %p", (uint8_t *)&buf, 0xCu);
  }
  uint64_t v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_71, 3);
  uint64_t v8 = v7;
  if (v7
    && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v7 + 16))(v7, "Accounts Completed Credential Fetch", 0))
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *(void *)&long long buf = off_1ECF9A530;
    CFStringRef v10 = CFStringCreateWithCString(v9, "Protocol", 0x8000100u);
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    *((void *)&buf + 1) = v10;
    if (v4)
    {
      uint64_t v11 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4);
      CFStringRef v10 = (CFStringRef)*((void *)&buf + 1);
    }
    else
    {
      uint64_t v11 = @"null";
    }
    (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v8 + 64))(v8, v10, v11);
    if (v4 && v11) {
      CFRelease(v11);
    }
    AutoString::~AutoString((AutoString *)&buf);
    *(void *)&long long buf = off_1ECF9A530;
    CFStringRef v12 = CFStringCreateWithCString(v9, "Credential", 0x8000100u);
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    *((void *)&buf + 1) = v12;
    if (a2)
    {
      CFStringRef v13 = CFCopyDescription(a2);
      CFStringRef v12 = (CFStringRef)*((void *)&buf + 1);
    }
    else
    {
      CFStringRef v13 = @"null";
    }
    (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(void *)v8 + 64))(v8, v12, v13);
    if (a2 && v13) {
      CFRelease(v13);
    }
    AutoString::~AutoString((AutoString *)&buf);
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v14 = *(void *)(v4 + 24);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  v15[2] = ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_2;
  void v15[3] = &__block_descriptor_49_e5_v8__0l;
  char v16 = *(unsigned char *)(a1 + 40);
  void v15[4] = v4;
  v15[5] = a2;
  (*(void (**)(uint64_t, void *))(*(void *)v14 + 96))(v14, v15);
  CFRelease((CFTypeRef)(v4 - 16));
}

void sub_1842399D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_77@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1316;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(HTTPProtocol **)(a1 + 32);
  int v3 = *((_DWORD *)v2 + 48);
  unint64_t v4 = v3 & 0xFBFFFFFF | ((unint64_t)*((unsigned __int16 *)v2 + 98) << 32);
  *((_DWORD *)v2 + 48) = v3 & 0xFBFFFFFF;
  if (*(unsigned char *)(a1 + 48))
  {
    *((_WORD *)v2 + 98) = WORD2(v4);
    *((_DWORD *)v2 + 48) = v4 | 0x1000000;
    (*(void (**)(HTTPProtocol *, void))(*(void *)v2 + 624))(v2, 0);
  }
  else
  {
    *((_WORD *)v2 + 98) = WORD2(v4);
    *((_DWORD *)v2 + 48) = v4 | 0x800000;
    int v5 = (const void *)*((void *)v2 + 44);
    *((void *)v2 + 44) = 0;
    if (v5) {
      CFRelease(v5);
    }
  }
  uint64_t v6 = *(void *)(a1 + 40);
  int v7 = *(unsigned __int8 *)(a1 + 48);
  if (v6)
  {
    if (!*(unsigned char *)(a1 + 48))
    {
      uint64_t v9 = *((void *)v2 + 47);
      if (v9)
      {
LABEL_29:
        (*(void (**)(HTTPProtocol *, uint64_t, uint64_t))(*(void *)v2 + 120))(v2, v6, v9);
        goto LABEL_30;
      }
      goto LABEL_18;
    }
    uint64_t v8 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)v2 + 648))(v2);
    int v7 = *(unsigned __int8 *)(a1 + 48);
    if (v8)
    {
      uint64_t v6 = *(void *)(a1 + 40);
      if (*(unsigned char *)(a1 + 48)) {
        uint64_t v9 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)v2 + 648))(v2);
      }
      else {
        uint64_t v9 = *((void *)v2 + 47);
      }
      goto LABEL_29;
    }
  }
  if (v7 && (*(uint64_t (**)(HTTPProtocol *))(*(void *)v2 + 648))(v2))
  {
    uint64_t v10 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)v2 + 648))(v2);
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
    }
    if (v10) {
      uint64_t v11 = (URLAuthChallenge *)(v10 + 16);
    }
    else {
      uint64_t v11 = 0;
    }
LABEL_22:
    URLAuthChallenge::tryNextProtectionSpace(v11);
    goto LABEL_23;
  }
LABEL_18:
  uint64_t v12 = *((void *)v2 + 47);
  if (v12)
  {
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
    }
    uint64_t v11 = (URLAuthChallenge *)(v12 + 16);
    goto LABEL_22;
  }
LABEL_23:
  CFStringRef v13 = *(const void **)(a1 + 40);
  if (*(unsigned char *)(a1 + 48))
  {
    (*(void (**)(HTTPProtocol *, const void *))(*(void *)v2 + 624))(v2, v13);
  }
  else
  {
    *((void *)v2 + 44) = v13;
    if (v13) {
      CFRetain(v13);
    }
  }
  -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((void *)v2 + 104), 3, 0);
  HTTPProtocol::createAndOpenStream(v2, 0);
LABEL_30:
  uint64_t v14 = *(const void **)(a1 + 40);
  if (v14) {
    CFRelease(v14);
  }

  CFRelease((char *)v2 - 16);
}

uint64_t ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_69@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1267;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void std::__shared_ptr_pointer<_CFURLProtectionSpace *,Deleter_CFRelease,std::allocator<_CFURLProtectionSpace>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void std::__shared_ptr_pointer<_CFURLProtectionSpace *,Deleter_CFRelease,std::allocator<_CFURLProtectionSpace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void ___ZN12HTTPProtocol14askPATForCredsEP15__CFHTTPMessageP9__CFArraybbPK7__CFURL_block_invoke(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 792);
    *(_DWORD *)long long buf = 138543874;
    uint64_t v9 = v7;
    __int16 v10 = 2112;
    uint64_t v11 = a2;
    __int16 v12 = 2112;
    uint64_t v13 = a3;
    _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "%{public}@ received PAT headers %@ error %@", buf, 0x20u);
  }
  if (a2) {
    CFRetain(a2);
  }
  operator new();
}

void sub_18423A098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol14askPATForCredsEP15__CFHTTPMessageP9__CFArraybbPK7__CFURL_block_invoke_85(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1[4];
  uint64_t v2 = (__CFHTTPMessage *)a1[6];
  int v3 = (const void *)a1[8];
  uint64_t v4 = a1[10];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  int v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(v1 + 792);
    int v14 = 138543874;
    uint64_t v15 = v6;
    __int16 v16 = 2112;
    *(void *)uint64_t v17 = v3;
    *(_WORD *)&v17[8] = 2112;
    *(void *)&v17[10] = v4;
    _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@ handling PAT headers %@ error %@", (uint8_t *)&v14, 0x20u);
  }
  unint64_t v7 = (*(unsigned int *)(v1 + 192) | ((unint64_t)*(unsigned __int16 *)(v1 + 196) << 32)) & 0xEFFFFFFFFFFDLL;
  *(_DWORD *)(v1 + 192) &= ~2u;
  *(_WORD *)(v1 + 196) = WORD2(v7);
  if (v4)
  {
    *(unsigned char *)(v1 + 857) = 1;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v8 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(v1 + 792);
      int v10 = *(_DWORD *)(v1 + 732);
      size_t size = *(NSObject **)(v1 + 720);
      if (size) {
        size_t size = dispatch_data_get_size(size);
      }
      int v14 = 138543874;
      uint64_t v15 = v9;
      __int16 v16 = 1024;
      *(_DWORD *)uint64_t v17 = v10;
      *(_WORD *)&v17[4] = 2048;
      *(void *)&v17[6] = size;
      _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@ PAT default delivering response recorded(%d, %zu)", (uint8_t *)&v14, 0x1Cu);
    }
    HTTPProtocol::performHeaderReadPostProcessing((HTTPProtocol *)v1, v2, 1);
    HTTPProtocol::deliverUnhandledResponse((HTTPProtocol *)v1);
  }
  else
  {
    if (v3) {
      CFTypeRef v12 = CFRetain(v3);
    }
    else {
      CFTypeRef v12 = 0;
    }
    uint64_t v13 = *(const void **)(v1 + 848);
    *(void *)(v1 + 848) = v12;
    if (v13) {
      CFRelease(v13);
    }
    -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*(void *)(v1 + 832), 3, 0);
    HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
    HTTPProtocol::createAndOpenStream((HTTPProtocol *)v1, 0);
  }
}

void __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE64c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  int v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  int v5 = (std::__shared_weak_count *)a1[5];
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void *__copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE64c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[9];
  result[8] = a2[8];
  result[9] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a2[11];
  result[10] = a2[10];
  result[11] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void HTTPProtocol::deliverUnhandledResponse(HTTPProtocol *this)
{
  if ((*((_DWORD *)this + 183) | 2) == 2)
  {
    uint64_t v2 = *((void *)this + 90);
    if (v2)
    {
      HTTPProtocol::bytesAvailable((uint64_t)this, v2);
      dispatch_release(*((dispatch_object_t *)this + 90));
      *((void *)this + 90) = 0;
    }
    uint64_t v3 = *((unsigned int *)this + 48);
    uint64_t v4 = *((unsigned __int16 *)this + 98);
    *((_DWORD *)this + 48) = v3;
    *((_WORD *)this + 98) = v4 & 0xDBFF;
    *((_DWORD *)this + 183) = 0;
    if ((v3 & 0x80) == 0)
    {
      *((_DWORD *)this + 48) = v3 & 0xFFFFFFFB;
      *((_WORD *)this + 98) = ((v3 | (v4 << 32)) & 0xDBFFFFFFFFFBuLL) >> 32;
      HTTPProtocol::endEncountered(this);
    }
  }
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_10(uint64_t a1)
{
  CFAllocatorRef v1 = CFGetAllocator((CFTypeRef)(*(void *)(a1 + 32) - 16));
  return __cfnCreateCFError(v1, @"kCFErrorDomainCFNetwork", -1003, v2, v3, v4, v5, v6, 0);
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_12(uint64_t a1)
{
  CFAllocatorRef v1 = CFGetAllocator((CFTypeRef)(*(void *)(a1 + 32) - 16));
  return __cfnCreateCFError(v1, @"kCFErrorDomainCFNetwork", -1003, v2, v3, v4, v5, v6, 0);
}

uint64_t HTTPProtocol::nextTLSFallbackMethod(HTTPProtocol *this)
{
  CFDictionaryRef v2 = HTTPProtocol::copySSLPropertiesForStream(this, 0);
  CFDictionaryRef v3 = v2;
  if (v2)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v2, &unk_1EC0A05C0);
    CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue(v3, &unk_1EC0A0588);
    if (Value)
    {
      uint64_t valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
      LODWORD(v2) = valuePtr;
    }
    else
    {
      LODWORD(v2) = 0;
    }
  }
  else
  {
    CFNumberRef v5 = 0;
  }
  unsigned int v6 = tlsProtocolVersionForSSLProtocol((SSLProtocol)v2, 1);
  if (v5)
  {
    uint64_t valuePtr = 0;
    CFNumberGetValue(v5, kCFNumberCFIndexType, &valuePtr);
    SSLProtocol v7 = (int)valuePtr;
  }
  else
  {
    SSLProtocol v7 = kSSLProtocolUnknown;
  }
  unsigned int v8 = tlsProtocolVersionForSSLProtocol(v7, 0);
  uint64_t v9 = (const void *)*((void *)this + 36);
  if (v9)
  {
    if (CFEqual(v9, (CFTypeRef)*MEMORY[0x1E4F3B540]) && v6 <= 0x303 && v8 >= 0x303)
    {
      uint64_t v10 = *MEMORY[0x1E4F3B500];
      goto LABEL_25;
    }
    uint64_t v11 = (const void *)*((void *)this + 36);
    if (v11)
    {
      int v12 = CFEqual(v11, (CFTypeRef)*MEMORY[0x1E4F3B500]);
      if (v8 <= 0x300 || v6 >= 0x302 || v12 == 0) {
        uint64_t v10 = 0;
      }
      else {
        uint64_t v10 = *MEMORY[0x1E4F3B528];
      }
      goto LABEL_25;
    }
  }
  uint64_t v10 = 0;
LABEL_25:
  if (v3) {
    CFRelease(v3);
  }
  return v10;
}

void sub_18423A72C(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

const unsigned __int8 *_findDelimiterInBytes(unsigned __int8 *__s, size_t __n, const unsigned __int8 *a3, size_t a4, const unsigned __int8 **a5, unsigned __int8 *a6)
{
  size_t v10 = __n;
  uint64_t v11 = __s;
  int v12 = &__s[__n];
  *a5 = 0;
  *a6 = 0;
  int v13 = *a3;
  while (1)
  {
    int v14 = (char *)memchr(v11, v13, v10);
    unint64_t v15 = (unint64_t)v14;
    if (!v14) {
      break;
    }
    __int16 v16 = (const unsigned __int8 *)&v14[a4];
    if (&v14[a4] >= (char *)v12) {
      break;
    }
    if (!memcmp(a3, v14, a4))
    {
      if (v16 + 2 < v12 && *v16 == 45 && v16[1] == 45)
      {
        *a5 = v16 + 2;
        *a6 = 1;
      }
      else
      {
        uint64_t v17 = (char *)memchr((void *)(v15 + a4), 10, v12 - v16);
        if (!v17) {
          uint64_t v17 = (char *)memchr((void *)(v15 + a4), 13, v12 - v16 - 1);
        }
        if (v17) {
          uint64_t v18 = (const unsigned __int8 *)(v17 + 1);
        }
        else {
          uint64_t v18 = 0;
        }
        *a5 = v18;
      }
      return (const unsigned __int8 *)v15;
    }
    v10 += (size_t)&v11[~v15];
    uint64_t v11 = (unsigned __int8 *)(v15 + 1);
  }
  if (!v14) {
    return v12;
  }
  return (const unsigned __int8 *)v15;
}

void HTTPProtocol::fixupAndSendMultiPartData(HTTPProtocol *this, UInt8 *newBytes, CFIndex numBytes, int a4)
{
  if (a4)
  {
    unint64_t v7 = *((_DWORD *)this + 48) & 0xFFFFF7FF | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    *((_DWORD *)this + 48) &= ~0x800u;
    *((_WORD *)this + 98) = WORD2(v7);
    unsigned int v8 = (__CFHTTPMessage *)*((void *)this + 31);
    if (v8)
    {
      CFDataRef v9 = CFHTTPMessageCopyBody(v8);
      theData[0] = v9;
      size_t v10 = (const void *)*((void *)this + 31);
      *((void *)this + 31) = 0;
      if (v10) {
        CFRelease(v10);
      }
      if (v9)
      {
        CFAllocatorRef v11 = CFGetAllocator((char *)this - 16);
        BOOL v12 = _checkForDataToDeliver(v11, (uint64_t *)this + 33, theData);
        int v13 = (char *)theData[0];
        if (v12)
        {
          CFIndex Length = CFDataGetLength(theData[0]);
          HTTPProtocol::sendDidLoadData(this, v13, Length);
        }
        if (v13) {
          CFRelease(v13);
        }
      }
    }
  }
  if (numBytes)
  {
    if ((*((_DWORD *)this + 48) & 0x800) != 0)
    {
      CFDataRef v25 = (const __CFData *)*((void *)this + 32);
      if (v25 && CFDataGetLength(v25) == numBytes)
      {
        CFAllocatorRef v26 = CFGetAllocator((char *)this - 16);
        if (_checkForDataToDeliver(v26, (uint64_t *)this + 33, (const __CFData **)this + 32))
        {
          double v27 = (char *)*((void *)this + 32);
          HTTPProtocol::sendDidLoadData(this, v27, numBytes);
        }
      }
      else
      {
        CFAllocatorRef v28 = CFGetAllocator((char *)this - 16);
        theData[0] = CFDataCreate(v28, newBytes, numBytes);
        CFAllocatorRef v29 = CFGetAllocator((char *)this - 16);
        BOOL v30 = _checkForDataToDeliver(v29, (uint64_t *)this + 33, theData);
        CFDataRef v31 = theData[0];
        if (v30) {
          HTTPProtocol::sendDidLoadData(this, (char *)theData[0], numBytes);
        }
        if (v31) {
          CFRelease(v31);
        }
      }
    }
    else
    {
      Response = (__CFHTTPMessage *)*((void *)this + 31);
      if (!Response)
      {
        CFAllocatorRef v16 = CFGetAllocator((char *)this - 16);
        Response = CFHTTPMessageCreateResponse(v16, 200, 0, @"HTTP/1.0");
        *((void *)this + 31) = Response;
      }
      CFHTTPMessageAppendBytes(Response, newBytes, numBytes);
      if (CFHTTPMessageIsHeaderComplete(*((CFHTTPMessageRef *)this + 31)))
      {
        *((_DWORD *)this + 48) |= 0x800u;
        CFAllocatorRef v17 = CFGetAllocator((char *)this - 16);
        uint64_t v18 = *(void *)([*((id *)this + 26) _inner] + 88);
        if (v18) {
          uint64_t v19 = (__CFHTTPMessage *)(v18 - 16);
        }
        else {
          uint64_t v19 = 0;
        }
        CFArrayRef Copy = CFHTTPMessageCreateCopy(v17, v19);
        CFDictionaryRef v21 = CFHTTPMessageCopyAllHeaderFields(*((CFHTTPMessageRef *)this + 31));
        CFContainerEnumeratorBase::setup((unint64_t)theData, v21, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictKeyData);
        uint64_t v50 = 0;
        while (1)
        {
          uint64_t v22 = v50;
          if (v50 >= (uint64_t)theData[1]) {
            break;
          }
          ++v50;
          CFStringRef v23 = (const __CFString *)*((void *)theData[2] + v22);
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v21, v23);
          CFHTTPMessageSetHeaderFieldValue(Copy, v23, Value);
        }
        if (v21) {
          CFRelease(v21);
        }
        CFGetAllocator((char *)this - 16);
        uint64_t v32 = [*((id *)this + 26) _inner];
        id v33 = CFURLResponseCreateWithHTTPResponse(v32, *(const void **)(v32 + 8), (uint64_t)Copy, 2);
        *((void *)this + 33) = CFURLResponseGetExpectedContentLength(v33);
        if (*((void *)this + 59))
        {
          uint64_t v34 = [v33 _inner];
          uint64_t v35 = (const void *)*((void *)this + 59);
          uint64_t v36 = *(const void **)(v34 + 80);
          if (v36 != v35)
          {
            if (v36) {
              CFRelease(v36);
            }
            if (v35) {
              CFTypeRef v37 = CFRetain(v35);
            }
            else {
              CFTypeRef v37 = 0;
            }
            *(void *)(v34 + 80) = v37;
          }
        }
        unint64_t v38 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        if ((v38 & 0x200000000) != 0)
        {
          *(unsigned char *)([v33 _inner] + 97) = 1;
          unint64_t v38 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        }
        if ((v38 & 0x400000000) != 0) {
          *(unsigned char *)([v33 _inner] + 96) = 1;
        }
        CFRelease(Copy);
        v51[0] = (__CFData *)MEMORY[0x1E4F143A8];
        v51[1] = (__CFData *)3221225472;
        uint64_t v52 = ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8582;
        uint64_t v53 = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
        id v54 = v33;
        uint64_t v39 = *((void *)this + 12);
        if (v39)
        {
          uint64_t v40 = (*(uint64_t (**)(void))(*(void *)v39 + 16))(*((void *)this + 12));
          CFTypeRef v41 = (void *)MEMORY[0x18531D6D0](v40);
          v52((uint64_t)v51, *((void *)this + 12));
          (*(void (**)(uint64_t))(*(void *)v39 + 24))(v39);
        }

        CFTypeRef v42 = (__CFHTTPMessage *)*((void *)this + 31);
        if (v42)
        {
          uint64_t v43 = CFHTTPMessageCopyBody(v42);
          v51[0] = v43;
          uint64_t v44 = (const void *)*((void *)this + 31);
          *((void *)this + 31) = 0;
          if (v44) {
            CFRelease(v44);
          }
          if (v43)
          {
            CFAllocatorRef v45 = CFGetAllocator((char *)this - 16);
            BOOL v46 = _checkForDataToDeliver(v45, (uint64_t *)this + 33, v51);
            uint64_t v47 = (char *)v51[0];
            if (v46)
            {
              CFIndex v48 = CFDataGetLength(v51[0]);
              HTTPProtocol::sendDidLoadData(this, v47, v48);
            }
            if (v47) {
              CFRelease(v47);
            }
          }
        }
        CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)theData);
      }
    }
  }
}

void sub_18423AD20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL _checkForDataToDeliver(const __CFAllocator *a1, uint64_t *a2, const __CFData **a3)
{
  if (*a2 < 0)
  {
    CFIndex Length = CFDataGetLength(*a3);
  }
  else if (*a2)
  {
    CFIndex v6 = CFDataGetLength(*a3);
    CFIndex Length = *a2;
    if (v6 <= *a2)
    {
      CFIndex Length = CFDataGetLength(*a3);
    }
    else
    {
      CFArrayRef Mutable = CFDataCreateMutable(a1, *a2);
      BytePtr = CFDataGetBytePtr(*a3);
      CFDataAppendBytes(Mutable, BytePtr, Length);
      if (*a3) {
        CFRelease(*a3);
      }
      *a3 = Mutable;
    }
    *a2 -= Length;
  }
  else
  {
    CFIndex Length = 0;
  }
  return Length > 0;
}

void HTTPProtocol::storeCredentials(HTTPProtocol *this)
{
  uint64_t v1 = *((void *)this + 44);
  if (v1 && *((void *)this + 47))
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    if (*(_DWORD *)(v1 + 52) != 1)
    {
      if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
        dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
      }
      CFDictionaryRef v3 = *(void (**)(void))(**((void **)this + 87) + 56);
      v3();
    }
  }
}

void ___ZN12HTTPProtocol17askAppSSOForCredsElP15__CFHTTPMessage_block_invoke(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFIndex v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 792);
    *(_DWORD *)long long buf = 138543874;
    uint64_t v9 = v7;
    __int16 v10 = 2112;
    CFAllocatorRef v11 = a2;
    __int16 v12 = 2112;
    uint64_t v13 = a3;
    _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "%{public}@ received AppSSO headers %@ error %@", buf, 0x20u);
  }
  if (a2) {
    CFRetain(a2);
  }
  operator new();
}

void sub_18423B194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol17askAppSSOForCredsElP15__CFHTTPMessage_block_invoke_81(void *a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1[4];
  CFDictionaryRef v2 = (__CFHTTPMessage *)a1[6];
  CFDictionaryRef v3 = (const __CFDictionary *)a1[8];
  uint64_t v4 = (void *)a1[10];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFNumberRef v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(v1 + 792);
    int v40 = 138543874;
    uint64_t v41 = v7;
    __int16 v42 = 2112;
    *(void *)uint64_t v43 = v3;
    *(_WORD *)&v43[8] = 2112;
    *(void *)&v43[10] = v4;
    _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@ handling AppSSO headers %@ error %@", (uint8_t *)&v40, 0x20u);
  }
  uint64_t v8 = *(void *)(v1 + 328);
  if (v8 != 0x7FFFFFFFFFFFFFFFLL) {
    *(void *)(v1 + 328) = v8 + 1;
  }
  unint64_t v9 = (*(unsigned int *)(v1 + 192) | ((unint64_t)*(unsigned __int16 *)(v1 + 196) << 32)) & 0xFDFFFFFFFFFDLL;
  *(_DWORD *)(v1 + 192) &= ~2u;
  *(_WORD *)(v1 + 196) = WORD2(v9);
  if (!v3 || v4)
  {
    if (AppSSO::isPerformDefaultHandlingError((AppSSO *)v4, v6))
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v19 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = *(void *)(v1 + 792);
        int v40 = 138543618;
        uint64_t v41 = v20;
        __int16 v42 = 2112;
        *(void *)uint64_t v43 = v2;
        _os_log_impl(&dword_184085000, v19, OS_LOG_TYPE_DEFAULT, "%{public}@ AppSSO performing default handling for %@", (uint8_t *)&v40, 0x16u);
      }
      *(unsigned char *)(v1 + 856) = 1;
      if (HTTPProtocol::_CFHTTPProtHasCredentialsForChallenge((HTTPProtocol *)v1, v2))
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        CFDictionaryRef v21 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v22 = *(void *)(v1 + 792);
          uint64_t v23 = *(void *)(v1 + 352);
          uint64_t v24 = *(void *)(v1 + 376);
          int v40 = 138543874;
          uint64_t v41 = v22;
          __int16 v42 = 2112;
          *(void *)uint64_t v43 = v23;
          *(_WORD *)&v43[8] = 2112;
          *(void *)&v43[10] = v24;
          _os_log_impl(&dword_184085000, v21, OS_LOG_TYPE_DEFAULT, "%{public}@ AppSSO default handling has creds %@ challenge %@", (uint8_t *)&v40, 0x20u);
        }
        HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
        (*(void (**)(uint64_t, void, void))(*(void *)v1 + 120))(v1, *(void *)(v1 + 352), *(void *)(v1 + 376));
      }
      else if (((*(unsigned int *)(v1 + 192) | ((unint64_t)*(unsigned __int16 *)(v1 + 196) << 32)) & 0x100004000000) != 0)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        CFAllocatorRef v29 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v30 = *(void *)(v1 + 792);
          int v40 = 138543362;
          uint64_t v41 = v30;
          _os_log_impl(&dword_184085000, v29, OS_LOG_TYPE_DEFAULT, "%{public}@ AppSSO default handling is waiting for Accounts or Private Acccess Tokens", (uint8_t *)&v40, 0xCu);
        }
        HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
      }
      else
      {
        uint64_t v31 = *(void *)(v1 + 376);
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        uint64_t v32 = CFNLog::logger;
        BOOL v33 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
        if (v31)
        {
          if (v33)
          {
            uint64_t v34 = *(void *)(v1 + 792);
            uint64_t v35 = *(void *)(v1 + 376);
            int v40 = 138543618;
            uint64_t v41 = v34;
            __int16 v42 = 2112;
            *(void *)uint64_t v43 = v35;
            _os_log_impl(&dword_184085000, v32, OS_LOG_TYPE_DEFAULT, "%{public}@ AppSSO default handling did not find creds, will send challenge %@", (uint8_t *)&v40, 0x16u);
          }
          HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
          HTTPProtocol::sendDidReceiveAuthChallenge((HTTPProtocol *)v1, *(_CFURLAuthChallenge **)(v1 + 376));
        }
        else
        {
          if (v33)
          {
            uint64_t v37 = *(void *)(v1 + 792);
            int v38 = *(_DWORD *)(v1 + 732);
            size_t size = *(NSObject **)(v1 + 720);
            if (size) {
              size_t size = dispatch_data_get_size(size);
            }
            int v40 = 138543874;
            uint64_t v41 = v37;
            __int16 v42 = 1024;
            *(_DWORD *)uint64_t v43 = v38;
            *(_WORD *)&v43[4] = 2048;
            *(void *)&v43[6] = size;
            _os_log_impl(&dword_184085000, v32, OS_LOG_TYPE_DEFAULT, "%{public}@ AppSSO default deliverying response recorded(%d, %zu)", (uint8_t *)&v40, 0x1Cu);
          }
          HTTPProtocol::performHeaderReadPostProcessing((HTTPProtocol *)v1, v2, 1);
          HTTPProtocol::deliverUnhandledResponse((HTTPProtocol *)v1);
        }
      }
    }
    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFDataRef v25 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        uint64_t v36 = *(void *)(v1 + 792);
        int v40 = 138543874;
        uint64_t v41 = v36;
        __int16 v42 = 2112;
        *(void *)uint64_t v43 = v3;
        *(_WORD *)&v43[8] = 2112;
        *(void *)&v43[10] = v4;
        _os_log_error_impl(&dword_184085000, v25, OS_LOG_TYPE_ERROR, "%{public}@ AppSSO received headers %@ error %@ canceling", (uint8_t *)&v40, 0x20u);
      }
      CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (v4)
      {
        CFArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F28A50], v4);
      }
      else
      {
        CFArrayRef Mutable = 0;
      }
      CFAllocatorRef v28 = CFErrorCreate(v26, @"kCFErrorDomainCFNetwork", -1012, Mutable);
      URLProtocol::sendDidFail((URLProtocol *)v1, v28);
      if (v28) {
        CFRelease(v28);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
  }
  else
  {
    CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)(v1 - 16));
    CFIndex Count = CFDictionaryGetCount(v3);
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(v10, Count, v3);
    CFStringRef Value = CFDictionaryGetValue(v3, &unk_1EC0A28C0);
    if (Value)
    {
      CFAllocatorRef v14 = CFGetAllocator((CFTypeRef)(v1 - 16));
      unint64_t v15 = CFArrayCreateMutable(v14, 1, MEMORY[0x1E4F1D510]);
      CFArrayAppendValue(v15, Value);
      HTTPProtocol::updateCookieStoreDuringHeaderRead((HTTPProtocol *)v1, v15);
      if (v15) {
        CFRelease(v15);
      }
    }
    if (MutableCopy)
    {
      CFDictionaryRemoveValue(MutableCopy, &unk_1EC0A28C0);
      CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)(v1 - 16));
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v16, MutableCopy);
      uint64_t v18 = *(const void **)(v1 + 840);
      *(void *)(v1 + 840) = Copy;
      if (v18) {
        CFRelease(v18);
      }
      CFRelease(MutableCopy);
    }
    -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*(void *)(v1 + 832), 3, 0);
    HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
    HTTPProtocol::createAndOpenStream((HTTPProtocol *)v1, 0);
  }
}

void sub_18423B858(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'HTTPProtocol::~HTTPProtocol(HTTPProtocol *this)
{
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 184));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 176));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 176));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 120));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 120));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 112));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 112));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 16));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 16));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 8));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 8));
}

uint64_t ___ZN12HTTPProtocolD2Ev_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  CFDictionaryRef v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 563;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t non-virtual thunk to'HTTPProtocol::canRetryRequestAfterError(HTTPProtocol *this, const CFStreamError *a2, int a3)
{
  return HTTPProtocol::canRetryRequestAfterError((HTTPProtocol *)((char *)this - 176), a2, a3);
}

uint64_t ___ZN12HTTPProtocol25canRetryRequestAfterErrorEPK13CFStreamErrorb_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  CFDictionaryRef v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 2130;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void non-virtual thunk to'HTTPProtocol::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

void HTTPProtocol::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3321888768;
  unint64_t v9 = ___ZN12HTTPProtocol38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  CFAllocatorRef v10 = &unk_1ECFA8F48;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  uint64_t v12 = *a2;
  uint64_t v13 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = a3;
  uint64_t v5 = *(void *)(a1 + 96);
  if (v5)
  {
    uint64_t v6 = (*(uint64_t (**)(void))(*(void *)v5 + 16))(*(void *)(a1 + 96));
    uint64_t v7 = (void *)MEMORY[0x18531D6D0](v6);
    v9(v8, *(void *)(a1 + 96));
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v13);
  }
}

void sub_18423BAB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN12HTTPProtocol38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(void *a1, uint64_t a2)
{
  if (a2)
  {
    CFDictionaryRef v2 = (std::__shared_weak_count *)a1[6];
    uint64_t v5 = a1[5];
    uint64_t v6 = v2;
    if (v2) {
      atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *, void))(*(void *)a2 + 168))(a2, &v5, a1[4]);
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }
  else
  {
    CFDictionaryRef v3 = *(void (**)(uint64_t))(*(void *)a1[5] + 152);
    uint64_t v4 = a1[5];
    v3(v4);
  }
}

void sub_18423BB90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

HTTPProtocol *non-virtual thunk to'HTTPProtocol::socketStreamsForUpgradeHeaderAvailable(HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return HTTPProtocol::socketStreamsForUpgradeHeaderAvailable((HTTPProtocol *)((char *)this - 176), a2, a3);
}

HTTPProtocol *HTTPProtocol::socketStreamsForUpgradeHeaderAvailable(HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  uint64_t v8 = ___ZN12HTTPProtocol38socketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke;
  unint64_t v9 = &__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
  CFAllocatorRef v10 = a2;
  uint64_t v11 = a3;
  uint64_t v3 = *((void *)this + 12);
  if (v3)
  {
    uint64_t v4 = this;
    uint64_t v5 = (*(uint64_t (**)(void))(*(void *)v3 + 16))(*((void *)this + 12));
    uint64_t v6 = (void *)MEMORY[0x18531D6D0](v5);
    v8((uint64_t)v7, *((void *)v4 + 12));
    return (HTTPProtocol *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  return this;
}

void ___ZN12HTTPProtocol38socketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (a2)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 160);
    v6(a2, v4, v5);
  }
  else
  {
    if (v4) {
      CFReadStreamClose(*(CFReadStreamRef *)(a1 + 32));
    }
    uint64_t v7 = *(__CFWriteStream **)(a1 + 40);
    if (v7)
    {
      CFWriteStreamClose(v7);
    }
  }
}

uint64_t non-virtual thunk to'HTTPProtocol::handleAlternatePathNotification(uint64_t a1, int a2)
{
  return HTTPProtocol::handleAlternatePathNotification(a1 - 176, a2);
}

uint64_t HTTPProtocol::handleAlternatePathNotification(uint64_t result, int a2)
{
  if (*(unsigned char *)(result + 45))
  {
    uint64_t v3 = result;
    CFRetain((CFTypeRef)(result - 16));
    uint64_t v4 = *(void *)(v3 + 24);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN12HTTPProtocol31handleAlternatePathNotificationE36nw_connection_alternate_path_state_t_block_invoke;
    v5[3] = &__block_descriptor_44_e5_v8__0l;
    v5[4] = v3;
    int v6 = a2;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, v5);
  }
  return result;
}

void ___ZN12HTTPProtocol31handleAlternatePathNotificationE36nw_connection_alternate_path_state_t_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(_DWORD *)(a1 + 40);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  uint64_t v7 = ___ZN11URLProtocol26sendAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke;
  uint64_t v8 = &__block_descriptor_44_e31_v16__0__URLProtocolClient_____8l;
  uint64_t v9 = v1;
  int v10 = v2;
  uint64_t v3 = *(void *)(v1 + 96);
  if (v3)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*(void *)v3 + 16))(*(void *)(v1 + 96));
    uint64_t v5 = (void *)MEMORY[0x18531D6D0](v4);
    ((void (*)(void *, void))v7)(v6, *(void *)(v1 + 96));
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  *(CFAbsoluteTime *)(v1 + 32) = CFAbsoluteTimeGetCurrent();
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN11URLProtocol26sendAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 96) + 152))(*(void *)(*(void *)(a1 + 32) + 96), *(unsigned int *)(a1 + 40));
}

void ___ZN12HTTPProtocol35handleConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 40);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  uint64_t v7 = ___ZN11URLProtocol21sendConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke;
  uint64_t v8 = &__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
  uint64_t v9 = v2;
  uint64_t v10 = v1;
  uint64_t v3 = *(void *)(v2 + 96);
  if (v3)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*(void *)v3 + 16))(*(void *)(v2 + 96));
    uint64_t v5 = (void *)MEMORY[0x18531D6D0](v4);
    ((void (*)(void *, void))v7)(v6, *(void *)(v2 + 96));
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  *(CFAbsoluteTime *)(v2 + 32) = CFAbsoluteTimeGetCurrent();
  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t ___ZN11URLProtocol21sendConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 96) + 136))(*(void *)(*(void *)(a1 + 32) + 96), *(void *)(a1 + 40));
}

uint64_t non-virtual thunk to'HTTPProtocol::getUUID(HTTPProtocol *this)
{
  return HTTPProtocol::getUUID((HTTPProtocol *)((char *)this - 176));
}

uint64_t non-virtual thunk to'HTTPProtocol::getServicePrincipal(HTTPProtocol *this)
{
  return HTTPProtocol::getServicePrincipal((HTTPProtocol *)((char *)this - 176));
}

uint64_t HTTPProtocol::getServicePrincipal(HTTPProtocol *this)
{
  if (!*((void *)this + 44) && !(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this)) {
    return 0;
  }
  uint64_t v2 = (__CFHTTPMessage *)*((void *)this + 39);
  if (v2 && CFHTTPMessageGetResponseStatusCode(v2) == 407)
  {
    uint64_t v3 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this);
    if (!v3) {
      return 0;
    }
  }
  else
  {
    uint64_t v3 = *((void *)this + 44);
    if (!v3) {
      return 0;
    }
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if (*(_DWORD *)(v3 + 48) != 2) {
    return 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)(v3 + 16) + 136);

  return v4(v3 + 16);
}

uint64_t non-virtual thunk to'HTTPProtocol::getUserPrincipal(HTTPProtocol *this)
{
  return HTTPProtocol::getUserPrincipal((HTTPProtocol *)((char *)this - 176));
}

uint64_t HTTPProtocol::getUserPrincipal(HTTPProtocol *this)
{
  if (!*((void *)this + 44) && !(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this)) {
    return 0;
  }
  uint64_t v2 = (__CFHTTPMessage *)*((void *)this + 39);
  if (v2 && CFHTTPMessageGetResponseStatusCode(v2) == 407)
  {
    uint64_t v3 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this);
    if (!v3) {
      return 0;
    }
  }
  else
  {
    uint64_t v3 = *((void *)this + 44);
    if (!v3) {
      return 0;
    }
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if (*(_DWORD *)(v3 + 48) != 2) {
    return 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)(v3 + 16) + 128);

  return v4(v3 + 16);
}

uint64_t non-virtual thunk to'HTTPProtocol::getUserName(HTTPProtocol *this)
{
  return HTTPProtocol::getUserName((HTTPProtocol *)((char *)this - 176));
}

uint64_t HTTPProtocol::getUserName(HTTPProtocol *this)
{
  if (!*((void *)this + 44) && !(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this)) {
    return 0;
  }
  if (*((void *)this + 74)
    || (*(unsigned int (**)(void))(**((void **)this + 35) + 88))(*((void *)this + 35)) == 2
    || (*(unsigned int (**)(void))(**((void **)this + 35) + 88))(*((void *)this + 35)) == 3)
  {
    uint64_t v3 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this);
    if (!v3) {
      return 0;
    }
  }
  else
  {
    uint64_t v3 = *((void *)this + 44);
    if (!v3) {
      return 0;
    }
  }
  uint64_t v4 = URLCredential_PasswordBased::safelyCast(v3, v2);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)v4 + 112);

  return v5();
}

BOOL HTTPProtocol::isValidForTube(HTTPProtocol *this)
{
  return !(*(unsigned int (**)(HTTPProtocol *))(*(void *)this + 520))(this)
      && !*((void *)this + 34)
      && *((void *)this + 11) != 0;
}

uint64_t non-virtual thunk to'HTTPProtocol::hcc_getUseCredentialStorage(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this - 136);
}

uint64_t non-virtual thunk to'HTTPProtocol::trustRef(HTTPProtocol *this)
{
  return *((void *)this + 35);
}

BOOL non-virtual thunk to'HTTPProtocol::requiresConnectionBasedAuth(HTTPProtocol *this)
{
  return HTTPProtocol::requiresConnectionBasedAuth((HTTPProtocol *)((char *)this - 176));
}

BOOL HTTPProtocol::requiresConnectionBasedAuth(HTTPProtocol *this)
{
  uint64_t v2 = *((void *)this + 35);
  if (v2 && ((*(uint64_t (**)(uint64_t))(*(void *)v2 + 88))(v2) & 0xFFFFFFFE) == 2) {
    uint64_t v3 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648))(this);
  }
  else {
    uint64_t v3 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 472))(this);
  }
  uint64_t v4 = v3;
  if (!v3) {
    return 0;
  }
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t v5 = *(void *)(v4 + 40);
  if (!v5) {
    return 0;
  }
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  return (*(_DWORD *)(v5 + 72) - 5) < 2;
}

uint64_t non-virtual thunk to'HTTPProtocol::proxyAuthFailureResponse(HTTPProtocol *this)
{
  return *((void *)this + 20);
}

uint64_t non-virtual thunk to'HTTPProtocol::proxyChallenge(HTTPProtocol *this)
{
  uint64_t v1 = *((void *)this + 24);
  if (v1) {
    return *(void *)(v1 + 56);
  }
  else {
    return 0;
  }
}

uint64_t non-virtual thunk to'HTTPProtocol::proxyCreds(HTTPProtocol *this)
{
  uint64_t v1 = *((void *)this + 24);
  if (v1 && (uint64_t v2 = *(void *)(v1 + 40)) != 0) {
    return *(void *)(v2 + 32);
  }
  else {
    return 0;
  }
}

uint64_t non-virtual thunk to'HTTPProtocol::authFailureResponse(HTTPProtocol *this)
{
  return *((void *)this + 17);
}

uint64_t non-virtual thunk to'HTTPProtocol::challenge(HTTPProtocol *this)
{
  return *((void *)this + 25);
}

uint64_t non-virtual thunk to'HTTPProtocol::creds(HTTPProtocol *this)
{
  return *((void *)this + 22);
}

URLProtocol *URLProtocol::sendNeedNewBodyStream(URLProtocol *this)
{
  uint64_t v1 = *((void *)this + 12);
  if (v1)
  {
    uint64_t v2 = this;
    uint64_t v3 = (*(uint64_t (**)(void))(*(void *)v1 + 16))(*((void *)this + 12));
    uint64_t v4 = (void *)MEMORY[0x18531D6D0](v3);
    (*(void (**)(void))(**((void **)v2 + 12) + 112))(*((void *)v2 + 12));
    uint64_t v5 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 24);
    return (URLProtocol *)v5(v1);
  }
  return this;
}

void ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_147(void *a1, uint64_t a2, int a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1[4];
  uint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_150, 2);
  if (v6)
  {
    uint64_t v7 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)v6 + 24))(v6, "_kCFStreamPropertyConditionalRequirementsChangedBlock called", v5))
    {
      if (a3) {
        uint64_t v8 = "true";
      }
      else {
        uint64_t v8 = "false";
      }
      (*(void (**)(uint64_t, const char *, void))(*(void *)v7 + 48))(v7, "Request", *(void *)(v5 + 88));
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v20 = off_1ECF9A530;
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      CFStringRef v21 = CFStringCreateWithCString(v9, "satisfied", 0x8000100u);
      CFAllocatorRef v16 = off_1ECF9A530;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      CFStringRef v17 = CFStringCreateWithCString(v9, v8, 0x8000100u);
      (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(void *)v7 + 64))(v7, v21, v17);
      AutoString::~AutoString((AutoString *)&v16);
      AutoString::~AutoString((AutoString *)&v20);
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  uint64_t v10 = a1[5];
  uint64_t v11 = *(void *)(v10 + 24);
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3321888768;
  v13[2] = ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_3_155;
  v13[3] = &__block_descriptor_57_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  char v15 = a3;
  v13[4] = v5;
  void v13[5] = v10;
  uint64_t v12 = (std::__shared_weak_count *)a1[6];
  CFAllocatorRef v14 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v11 + 96))(v11, v13);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
}

void sub_18423C9C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

void ___ZN12HTTPProtocol10openStreamEv_block_invoke_2(uint64_t a1, uint64_t a2, NSObject *a3, const CFStreamError *a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(void *)(v5 + 272) == *(void *)(a1 + 40)) {
    HTTPProtocol::handleStreamEvent(v5, a2, a3, a4);
  }
}

uint64_t ___ZN12HTTPProtocol30attemptToCacheMovedPermanentlyEP15__CFHTTPMessage23CFURLCacheStoragePolicyPK13_CFURLRequest_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 24))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
}

void ___ZN12HTTPProtocol42asynchronouslyHandleHTTPResponseExternallyEP15__CFHTTPMessage_block_invoke(int a1, int a2, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  operator new();
}

void sub_18423CC20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19)
{
  if (a19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a19);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a17);
  }
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  std::__shared_weak_count::__release_shared[abi:nn180100](v19);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol42asynchronouslyHandleHTTPResponseExternallyEP15__CFHTTPMessage_block_invoke_2(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 64);
  *(_DWORD *)(v2 + 728) = 3;
  if (*(unsigned char *)(a1 + 80))
  {
    uint64_t v4 = *(const void **)(a1 + 32);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 56);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v7 = *(_DWORD *)(v2 + 192) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)(v2 + 196) << 32);
    *(_DWORD *)(v2 + 192) &= ~2u;
    *(_WORD *)(v2 + 196) = WORD2(v7);
    *(void *)(v2 + 728) = 1;
    uint64_t v8 = *(NSObject **)(v2 + 720);
    if (v8)
    {
      dispatch_release(v8);
      *(void *)(v2 + 720) = 0;
    }
    if (!v6)
    {
      if (v4)
      {
        if (CFDictionaryGetCount((CFDictionaryRef)v4))
        {
          CFTypeRef v9 = CFRetain(v4);
          uint64_t v10 = *(const void **)(v2 + 704);
          *(void *)(v2 + 704) = v9;
          if (v10) {
            CFRelease(v10);
          }
        }
      }
    }
    HTTPProtocol::destroyReadStream((HTTPProtocol *)v2);
    if (v6)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v11 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = *(void *)(v2 + 792);
        *(_DWORD *)uint64_t v22 = 138543618;
        *(void *)&v22[4] = v12;
        *(_WORD *)&v22[12] = 2112;
        *(void *)&v22[14] = v6;
        _os_log_impl(&dword_184085000, v11, OS_LOG_TYPE_DEFAULT, "%{public}@ external auth will start new request %@", v22, 0x16u);
      }
      uint64_t v13 = *(void **)(v2 + 80);
      if (v13) {
        objc_msgSend(v13, "set_appleIDContextRedirect:", 1);
      }
      *(void *)uint64_t v22 = MEMORY[0x1E4F143A8];
      *(void *)&v22[8] = 3221225472;
      *(void *)&uint8_t v22[16] = ___ZN11URLProtocol17sendWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_8656;
      uint64_t v23 = &unk_1E5255ED8;
      uint64_t v24 = v6;
      uint64_t v25 = 0;
      uint64_t v14 = *(void *)(v2 + 96);
      if (v14)
      {
        uint64_t v15 = (*(uint64_t (**)(void))(*(void *)v14 + 16))(*(void *)(v2 + 96));
        CFAllocatorRef v16 = (void *)MEMORY[0x18531D6D0](v15);
        (*(void (**)(unsigned char *, void))&v22[16])(v22, *(void *)(v2 + 96));
        (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
      }
    }
    else
    {
      HTTPProtocol::createAndOpenStream((HTTPProtocol *)v2, 0);
    }
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    }
    if (v3)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
  }
  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFStringRef v17 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = *(void *)(*(void *)(a1 + 64) + 792);
      *(_DWORD *)uint64_t v22 = 138543362;
      *(void *)&v22[4] = v18;
      _os_log_impl(&dword_184085000, v17, OS_LOG_TYPE_DEFAULT, "%{public}@ authentication client does not want to continue load", v22, 0xCu);
    }
    uint64_t v19 = *(void *)(a1 + 64);
    HTTPProtocol::performHeaderReadPostProcessing((HTTPProtocol *)v19, *(__CFHTTPMessage **)(v19 + 712), 1);
    uint64_t v20 = *(NSObject **)(v19 + 720);
    if (v20) {
      HTTPProtocol::bytesAvailable(v19, v20);
    }
    if (*(_DWORD *)(v19 + 732) == 2)
    {
      HTTPProtocol::destroyReadStream((HTTPProtocol *)v19);
      if ((*(_DWORD *)(v19 + 192) & 0x80) == 0) {
        HTTPProtocol::endEncountered((HTTPProtocol *)v19);
      }
    }
    *(void *)(v19 + 728) = 1;
    CFStringRef v21 = *(NSObject **)(v19 + 720);
    if (v21)
    {
      dispatch_release(v21);
      *(void *)(v19 + 720) = 0;
    }
  }
}

void sub_18423D024(_Unwind_Exception *exception_object)
{
}

void __destroy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE48c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE64c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[9];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void *__copy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE48c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE64c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[9];
  result[8] = a2[8];
  result[9] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN11URLProtocol17sendWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_8656(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 40))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t ___ZN12HTTPProtocol17performHeaderReadEP15__CFHTTPMessage_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 4111;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_3_155(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = *(unsigned char *)(a1 + 56);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  CFTypeRef v9 = ___ZN11URLProtocol34sendConditionalRequirementsChangedEh_block_invoke;
  uint64_t v10 = &__block_descriptor_41_e31_v16__0__URLProtocolClient_____8l;
  uint64_t v11 = v2;
  char v12 = v3;
  uint64_t v4 = *(void *)(v2 + 96);
  if (v4)
  {
    uint64_t v5 = (*(uint64_t (**)(void))(*(void *)v4 + 16))(*(void *)(v2 + 96));
    uint64_t v6 = (void *)MEMORY[0x18531D6D0](v5);
    ((void (*)(void *, void))v9)(v8, *(void *)(v2 + 96));
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v7 = *(void *)(a1 + 40);
  *(CFAbsoluteTime *)(v7 + 32) = CFAbsoluteTimeGetCurrent();
}

uint64_t ___ZN11URLProtocol34sendConditionalRequirementsChangedEh_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(a1 + 32) + 96) + 144))(*(void *)(*(void *)(a1 + 32) + 96), *(unsigned __int8 *)(a1 + 40));
}

uint64_t ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_2_148@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 3494;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 3475;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN11URLProtocol31sendNeedNewBodyStreamFromOffsetEx_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 120))(a2, *(void *)(a1 + 32));
}

void non-virtual thunk to'HTTPProtocol::handleStreamError(HTTPProtocol *this, CFStreamError a2, const __CFDictionary *a3)
{
}

uint64_t non-virtual thunk to'HTTPProtocol::proxyAuthenticationIsComplete(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this + 440);
}

void non-virtual thunk to'HTTPProtocol::setProxy(uint64_t a1, uint64_t *a2)
{
}

void HTTPProtocol::setProxy(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (a1[74] != *a2)
  {
    uint64_t v4 = a2[1];
    if (v4) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    }
    a1[74] = v2;
    uint64_t v5 = (std::__shared_weak_count *)a1[75];
    a1[75] = v4;
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    }
    uint64_t v6 = a1[35];
    if (v6)
    {
      uint64_t v7 = (std::__shared_weak_count *)a1[75];
      uint64_t v8 = a1[74];
      CFTypeRef v9 = v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 56))(v6, &v8);
      if (v9) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v9);
      }
    }
  }
}

void sub_18423D498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'HTTPProtocol::connectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 - 120) + 408))();
}

{
  return (*(uint64_t (**)(void))(*(void *)(a1 - 112) + 408))();
}

void non-virtual thunk to'HTTPProtocol::connectionEstablished(HTTPProtocol *this, CFStreamError a2)
{
}

{
  abort();
}

void non-virtual thunk to'HTTPProtocol::needClientCert(uint64_t a1, uint64_t a2, void *a3)
{
}

{
  HTTPProtocol::needClientCert(a1 - 112, a2, a3);
}

void HTTPProtocol::needClientCert(uint64_t a1, uint64_t a2, void *a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 520))(a1) || (uint64_t v7 = *(void **)(a1 + 88)) == 0)
  {
    uint64_t v6 = (void (*)(void *, void, uint64_t))a3[2];
    v6(a3, 0, 1);
  }
  else
  {
    if (*(void *)(a1 + 408)) {
      __assert_rtn("needClientCert", "HTTPProtocol.cpp", 7157, "fClientCertChallenge == nullptr");
    }
    if (*(void *)(a1 + 416)) {
      __assert_rtn("needClientCert", "HTTPProtocol.cpp", 7158, "fClientCertChallengeCompletion == nullptr");
    }
    CFURLRef v8 = *(const __CFURL **)([v7 _inner] + 8);
    CFStringRef v9 = CFURLCopyHostName(v8);
    SInt32 v10 = CFURLGetPortNumber(v8);
    if (v10 == -1) {
      int v11 = 443;
    }
    else {
      int v11 = v10;
    }
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    void v14[2] = ___ZN22HTTPProtocolSSLSupport40CreateClientCertChallengeWithHostAndPortEPK10__CFStringlPK9__CFArray_block_invoke;
    v14[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
    v14[4] = a2;
    uint64_t Challenge = createChallenge(7, v9, v11, (uint64_t)v14);
    if (v9) {
      CFRelease(v9);
    }
    *(void *)(a1 + 408) = Challenge;
    *(void *)(a1 + 4CFRetain((char *)this - 16) = _Block_copy(a3);
    uint64_t v13 = *(_CFURLAuthChallenge **)(a1 + 408);
    HTTPProtocol::sendDidReceiveAuthChallenge((HTTPProtocol *)a1, v13);
  }
}

void non-virtual thunk to'HTTPProtocol::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

{
  HTTPProtocol::postConnectConfiguration(a1 - 112, a2, a3, a4);
}

void HTTPProtocol::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFHTTPMessageRef v7 = CFURLRequestCopyHTTPRequest(*(void **)(a1 + 88));
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)(a1 - 16));
  uint64_t v9 = *(void *)(a1 + 280);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN12HTTPProtocol24postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke;
  v10[3] = &unk_1E5257DD0;
  v10[4] = a4;
  void v10[5] = a1;
  (*(void (**)(uint64_t, CFAllocatorRef, uint64_t, CFHTTPMessageRef, uint64_t, void *))(*(void *)(a1 + 112)
                                                                                                + 144))(a1 + 112, v8, a2, v7, v9, v10);
  if (v7) {
    CFRelease(v7);
  }
}

uint64_t ___ZN12HTTPProtocol24postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void **)(a1 + 40);
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  uint64_t v11 = *a2;
  char v12 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(void *, uint64_t *))(*v4 + 600))(v4, &v11);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  uint64_t v6 = v4[34];
  CFHTTPMessageRef v7 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  SInt32 v10 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 136))(v6, &v9);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
}

void sub_18423D898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'HTTPProtocol::preConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return HTTPProtocol::preConnectConfiguration((void *)(a1 - 120), a2, a3, a4);
}

{
  return HTTPProtocol::preConnectConfiguration((void *)(a1 - 112), a2, a3, a4);
}

uint64_t HTTPProtocol::preConnectConfiguration(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFAllocatorRef v8 = (void *)a1[11];
  if (v8)
  {
    uint64_t v9 = *(void *)([v8 _inner] + 8);
    if (a2)
    {
LABEL_3:
      uint64_t v10 = tcp_connection_id();
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v9 = 0;
    if (a2) {
      goto LABEL_3;
    }
  }
  uint64_t v10 = 0;
LABEL_6:
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, void))(a1[14] + 128))(a1 + 14, v10, a2, a3, v9, a1[76]);
  uint64_t v11 = *(uint64_t (**)(uint64_t))(a4 + 16);

  return v11(a4);
}

uint64_t non-virtual thunk to'HTTPProtocol::ssConnectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 - 112) + 392))();
}

void non-virtual thunk to'HTTPProtocol::ssPostHandshakesStreamsAvailable(HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
}

uint64_t non-virtual thunk to'HTTPProtocol::ssPostConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  return HTTPProtocol::ssPostConnectConfiguration(a1 - 112, a2, a3);
}

uint64_t HTTPProtocol::ssPostConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  CFRetain((CFTypeRef)(a1 - 16));
  nw_retain(a2);
  uint64_t v6 = *(void *)(a1 + 24);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
  v8[3] = &unk_1E5257DA8;
  void v8[5] = a3;
  v8[6] = a1;
  v8[4] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v8);
}

void ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 48);
  uint64_t v5 = MEMORY[0x1E4F143A8];
  uint64_t v6 = 3221225472;
  CFHTTPMessageRef v7 = ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke_2;
  CFAllocatorRef v8 = &unk_1E5257FD8;
  uint64_t v4 = v2 - 2;
  uint64_t v3 = *v2;
  uint64_t v9 = *(void *)(a1 + 40);
  (*(void (**)(void))(v3 + 376))();
  nw_release(*(void **)(a1 + 32));
  CFRelease(v4);
}

uint64_t ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t non-virtual thunk to'HTTPProtocol::ssNeedClientCert(uint64_t a1, const void *a2, uint64_t a3)
{
  return HTTPProtocol::ssNeedClientCert(a1 - 112, a2, a3);
}

uint64_t HTTPProtocol::ssNeedClientCert(uint64_t a1, const void *a2, uint64_t a3)
{
  CFRetain((CFTypeRef)(a1 - 16));
  if (a2) {
    CFRetain(a2);
  }
  uint64_t v6 = *(void *)(a1 + 24);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke;
  v8[3] = &unk_1E5257CF8;
  void v8[5] = a1;
  v8[6] = a2;
  v8[4] = a3;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v8);
}

void ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke(void *a1)
{
  uint64_t v3 = a1[5];
  uint64_t v2 = a1[6];
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke_2;
  v5[3] = &unk_1E52551A8;
  v5[4] = a1[4];
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 368))(v3, v2, v5);
  uint64_t v4 = (const void *)a1[6];
  if (v4) {
    CFRelease(v4);
  }
  CFRelease((CFTypeRef)(v3 - 16));
}

uint64_t ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t non-virtual thunk to'HTTPProtocol::ssNeedServerTrust(uint64_t a1, const void *a2, uint64_t a3)
{
  return HTTPProtocol::ssNeedServerTrust(a1 - 112, a2, a3);
}

uint64_t HTTPProtocol::ssNeedServerTrust(uint64_t a1, const void *a2, uint64_t a3)
{
  CFRetain((CFTypeRef)(a1 - 16));
  if (a2) {
    CFRetain(a2);
  }
  uint64_t v6 = *(void *)(a1 + 24);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke;
  v8[3] = &unk_1E5257CF8;
  void v8[5] = a1;
  v8[6] = a2;
  v8[4] = a3;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v8);
}

void ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke(void *a1)
{
  uint64_t v3 = a1[5];
  uint64_t v2 = a1[6];
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke_2;
  v5[3] = &unk_1E52551D0;
  v5[4] = a1[4];
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 360))(v3, v2, v5);
  uint64_t v4 = (const void *)a1[6];
  if (v4) {
    CFRelease(v4);
  }
  CFRelease((CFTypeRef)(v3 - 16));
}

uint64_t ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t non-virtual thunk to'HTTPProtocol::ssPreConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  return HTTPProtocol::ssPreConnectConfiguration(a1 - 112, a2, a3);
}

uint64_t HTTPProtocol::ssPreConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  CFRetain((CFTypeRef)(a1 - 16));
  nw_retain(a2);
  uint64_t v6 = *(void *)(a1 + 24);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = ___ZN12HTTPProtocol25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke;
  v8[3] = &unk_1E5257DA8;
  void v8[5] = a3;
  v8[6] = a1;
  v8[4] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v8);
}

void ___ZN12HTTPProtocol25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = (const void *)(v2 - 16);
  (*(void (**)(uint64_t, void, void, void))(*(void *)v2 + 352))(v2, *(void *)(a1 + 32), 0, *(void *)(a1 + 40));
  nw_release(*(void **)(a1 + 32));

  CFRelease(v3);
}

void non-virtual thunk to'HTTPProtocol::ceRelease(HTTPProtocol *this)
{
}

CFTypeRef non-virtual thunk to'HTTPProtocol::ceRetain(HTTPProtocol *this)
{
  return CFRetain((char *)this - 128);
}

uint64_t HTTPProtocol::proxyAuthenticationIsComplete(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this + 616);
}

void HTTPProtocol::setFailedProxyAuth(HTTPProtocol *this, char a2)
{
  uint64_t v3 = (NetworkProxyAuthorizationElements *)*((void *)this + 46);
  if (!v3)
  {
    uint64_t v5 = (char *)this - 16;
    CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
    uint64_t v3 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(v6, 80, 0);
    *(_OWORD *)uint64_t v3 = 0u;
    *((_OWORD *)v3 + 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    CFAllocatorRef v7 = CFGetAllocator(v5);
    NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v3, v7, 0, 0, 0, *((const __CFString **)this + 99));
    *((void *)this + 46) = v3;
  }
  *((unsigned char *)v3 + 32) = a2;
}

uint64_t HTTPProtocol::failedProxyAuth(HTTPProtocol *this)
{
  uint64_t v1 = *((void *)this + 46);
  if (v1) {
    return *(unsigned __int8 *)(v1 + 32);
  }
  else {
    return 0;
  }
}

HTTPProtocol *HTTPProtocol::markProxyAuthorizationUnviable(HTTPProtocol *this)
{
  if ((*((_DWORD *)this + 48) & 0x400000) != 0)
  {
    uint64_t v1 = *((void *)this + 46);
    if (v1)
    {
      uint64_t v2 = *(void *)(v1 + 40);
      if (v2) {
        *(_DWORD *)(v2 + 40) = 2;
      }
    }
  }
  return this;
}

uint64_t HTTPProtocol::proxyChallenge(HTTPProtocol *this)
{
  uint64_t v1 = *((void *)this + 46);
  if (v1) {
    return *(void *)(v1 + 56);
  }
  else {
    return 0;
  }
}

void HTTPProtocol::setProxyChallenge(HTTPProtocol *this, _CFURLAuthChallenge *cf)
{
  uint64_t v3 = (NetworkProxyAuthorizationElements *)*((void *)this + 46);
  if (cf)
  {
    if (v3)
    {
      NetworkProxyAuthorizationElements::setChallenge(v3, cf);
    }
    else
    {
      CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
      CFAllocatorRef v7 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(v6, 80, 0);
      *(_OWORD *)CFAllocatorRef v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      *((_OWORD *)v7 + 2) = 0u;
      *((_OWORD *)v7 + 3) = 0u;
      *((_OWORD *)v7 + 4) = 0u;
      CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
      NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v7, v8, 0, 0, cf, *((const __CFString **)this + 99));
      *((void *)this + 46) = v7;
    }
  }
  else if (v3)
  {
    uint64_t v5 = (const void *)*((void *)v3 + 7);
    *((void *)v3 + 7) = 0;
    if (v5)
    {
      CFRelease(v5);
    }
  }
}

void HTTPProtocol::setProxyProtectionSpace(HTTPProtocol *this, _CFURLProtectionSpace *cf)
{
  uint64_t v3 = (NetworkProxyAuthorizationElements *)*((void *)this + 46);
  if (cf)
  {
    if (v3)
    {
      NetworkProxyAuthorizationElements::setProtectionSpace(v3, cf);
    }
    else
    {
      CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
      CFAllocatorRef v7 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(v6, 80, 0);
      *(_OWORD *)CFAllocatorRef v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      *((_OWORD *)v7 + 2) = 0u;
      *((_OWORD *)v7 + 3) = 0u;
      *((_OWORD *)v7 + 4) = 0u;
      CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
      NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v7, v8, 0, cf, 0, *((const __CFString **)this + 99));
      *((void *)this + 46) = v7;
    }
  }
  else if (v3)
  {
    uint64_t v5 = (const void *)*((void *)v3 + 6);
    *((void *)v3 + 6) = 0;
    if (v5)
    {
      CFRelease(v5);
    }
  }
}

uint64_t HTTPProtocol::setProxyCFCreds(HTTPProtocol *this, const _CFURLCredential *a2)
{
  if (a2)
  {
    if ((*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this))
    {
      uint64_t v4 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this);
      uint64_t result = CFEqual(a2, v4);
      if (result) {
        return result;
      }
    }
    CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
    CFAllocatorRef v7 = CFAllocatorAllocate(v6, 56, 0);
    _OWORD *v7 = 0u;
    v7[1] = 0u;
    void v7[2] = 0u;
    *((void *)v7 + 6) = 0;
    CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
    NetworkProxyCredential::NetworkProxyCredential((NetworkProxyCredential *)v7, v8, a2);
  }
  else
  {
    CFAllocatorRef v7 = 0;
  }
  uint64_t result = (*(uint64_t (**)(HTTPProtocol *, _OWORD *))(*(void *)this + 608))(this, v7);
  if (v7)
  {
    uint64_t v9 = *(uint64_t (**)(_OWORD *))(*(void *)v7 + 48);
    return v9(v7);
  }
  return result;
}

void HTTPProtocol::setProxyCreds(HTTPProtocol *this, NetworkProxyCredential *a2)
{
  uint64_t v2 = *((void *)this + 46);
  if (a2)
  {
    if (v2)
    {
      uint64_t v4 = (NetworkProxyAuthorizationElements *)*((void *)this + 46);
      NetworkProxyAuthorizationElements::setCredential(v4, a2);
    }
    else
    {
      CFAllocatorRef v7 = (char *)this - 16;
      CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
      uint64_t v9 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(v8, 80, 0);
      *(_OWORD *)uint64_t v9 = 0u;
      *((_OWORD *)v9 + 1) = 0u;
      *((_OWORD *)v9 + 2) = 0u;
      *((_OWORD *)v9 + 3) = 0u;
      *((_OWORD *)v9 + 4) = 0u;
      CFAllocatorRef v10 = CFGetAllocator(v7);
      NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v9, v10, a2, 0, 0, *((const __CFString **)this + 99));
      *((void *)this + 46) = v9;
    }
  }
  else if (v2)
  {
    uint64_t v5 = *(void *)(v2 + 40);
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 48))(v5);
      *(void *)(v2 + 40) = 0;
    }
  }
}

HTTPProtocol *HTTPProtocol::copyTaskLoggableDescription@<X0>(HTTPProtocol *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *((void *)this + 100);
  *a2 = *((void *)this + 99);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

void HTTPProtocol::hcc_touchProtocol(HTTPProtocol *this)
{
  *((CFAbsoluteTime *)this + 4) = CFAbsoluteTimeGetCurrent();
}

uint64_t HTTPProtocol::proxyAuthFailureResponse(HTTPProtocol *this)
{
  return *((void *)this + 42);
}

uint64_t HTTPProtocol::hcc_getUseCredentialStorage(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this + 40);
}

uint64_t HTTPProtocol::trustRef(HTTPProtocol *this)
{
  return *((void *)this + 57);
}

uint64_t HTTPProtocol::authFailureResponse(HTTPProtocol *this)
{
  return *((void *)this + 39);
}

uint64_t HTTPProtocol::creds(HTTPProtocol *this)
{
  return *((void *)this + 44);
}

void HTTPProtocol::_meta_release(HTTPProtocol *this)
{
}

CFTypeRef HTTPProtocol::_meta_retain(HTTPProtocol *this)
{
  return CFRetain((char *)this - 16);
}

uint64_t HTTPProtocol::waitsForConnectivity(HTTPProtocol *this)
{
  if (!*((void *)this + 93)) {
    return 0;
  }
  uint64_t v1 = (void *)[*((id *)this + 10) _effectiveConfiguration];
  if (!v1) {
    return 0;
  }

  return [v1 waitsForConnectivity];
}

uint64_t HTTPProtocol::connectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 408))();
}

void HTTPProtocol::connectionEstablished(HTTPProtocol *this, CFStreamError a2)
{
}

uint64_t HTTPProtocol::ssConnectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 392))();
}

void HTTPProtocol::ssPostHandshakesStreamsAvailable(HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
}

void HTTPProtocol::ceRelease(HTTPProtocol *this)
{
}

CFTypeRef HTTPProtocol::ceRetain(HTTPProtocol *this)
{
  return CFRetain((char *)this - 16);
}

uint64_t HTTPProtocol::clientDescription(HTTPProtocol *this)
{
  return *((void *)this + 99);
}

uint64_t HTTPProtocol::attemptRedirection(HTTPProtocol *this, __CFHTTPMessage *a2)
{
  if ((*(unsigned int (**)(HTTPProtocol *))(*(void *)this + 520))(this) || !*((void *)this + 11)) {
    return 0;
  }
  CFURLRef relativeURL = 0;
  if (a2)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*((unsigned char *)a2 + 40)) {
      CFAllocatorRef v6 = (__CFHTTPMessage *)((char *)a2 + 16);
    }
    else {
      CFAllocatorRef v6 = 0;
    }
  }
  else
  {
    CFAllocatorRef v6 = 0;
  }
  HeaderFieldCFStringRef Value = HTTPMessage::copyLastHeaderFieldValue(v6, 0x13011336u);
  if (!HeaderFieldValue)
  {
LABEL_18:
    int v15 = *((_DWORD *)this + 48);
    uint64_t v14 = (char *)this + 192;
    __int16 v16 = *((_WORD *)v14 + 2);
    *(_DWORD *)uint64_t v14 = v15 & 0xFFFFFFFB;
    *((_WORD *)v14 + 2) = v16;
    return 1;
  }
  CFStringRef v8 = HeaderFieldValue;
  if (!CFStringGetLength(HeaderFieldValue))
  {
    CFRelease(v8);
    goto LABEL_18;
  }
  CFAllocatorRef v9 = CFGetAllocator((char *)this - 16);
  CFStringRef v10 = CFURLCreateStringByAddingPercentEscapes(v9, v8, @"%#?:;/@=&[]", 0, 0x201u);
  CFRelease(v8);
  if (!v10) {
    goto LABEL_31;
  }
  int v11 = dyld_program_sdk_at_least();
  char v12 = (void *)*((void *)this + 10);
  uint64_t v13 = v11 ? [v12 currentRequest] : objc_msgSend(v12, "originalRequest");
  CFStringRef v17 = (void *)v13;
  CFAllocatorRef v18 = CFGetAllocator((char *)this - 16);
  CFURLRef v19 = CFURLCreateWithString(v18, v10, *(CFURLRef *)([*((id *)this + 11) _inner] + 8));
  if (v19)
  {
    CFURLRef v20 = v19;
    CFURLRef relativeURL = CFURLCopyAbsoluteURL(v19);
    _ApplyOriginalComponents(v17, (CFTypeRef *)&relativeURL);
    CFRelease(v20);
  }
  else
  {
    CFIndex Length = CFStringGetLength(v10);
    uint64_t v22 = (UInt8 *)malloc_type_malloc(Length + 1, 0xA9011058uLL);
    CFStringEncoding v23 = 513;
    if (CFStringGetCString(v10, (char *)v22, Length + 1, 0x201u)
      || (CFStringEncoding v23 = 134217984, CFStringGetCString(v10, (char *)v22, Length + 1, 0x8000100u)))
    {
      CFURLRef v24 = *(const __CFURL **)([*((id *)this + 11) _inner] + 8);
      CFAllocatorRef v25 = CFGetAllocator((char *)this - 16);
      CFURLRef relativeURL = CFURLCreateAbsoluteURLWithBytes(v25, v22, Length, v23, v24, 0);
      _ApplyOriginalComponents(v17, (CFTypeRef *)&relativeURL);
    }
    free(v22);
  }
  CFRelease(v10);
  CFURLRef v26 = relativeURL;
  if (!relativeURL)
  {
LABEL_31:
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC0ELL);
    HTTPProtocol::destroyReadStream(this);
    return 0;
  }
  CFURLRef v27 = CFURLCopyAbsoluteURL(relativeURL);
  CFStringRef v28 = CFURLCopyScheme(v27);
  CFStringRef v29 = v28;
  if (v28 && CFStringCompare(v28, @"file", 1uLL) == kCFCompareEqualTo)
  {
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFBB2);
    BOOL v39 = 0;
  }
  else
  {
    CFGetAllocator((char *)this - 16);
    uint64_t v30 = (void *)[*((id *)this + 11) mutableCopy];
    CFURLRequestSetURL(v30, v27);
    CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(a2);
    if (ResponseStatusCode == 303
      || (unint64_t)(ResponseStatusCode - 301) <= 1
      && (CFStringRef v32 = (const __CFString *)CFURLRequestCopyHTTPRequestMethod(v30), (v33 = v32) != 0)
      && (CFComparisonResult v34 = CFStringCompare(v32, @"POST", 1uLL), CFRelease(v33), v34 == kCFCompareEqualTo))
    {
      CFURLRequestSetHTTPRequestMethod(v30, @"GET");
      CFURLRequestSetHTTPRequestBody(v30, 0);
      URLRequest::_setHTTPBodyParts((URLRequest *)[v30 _inner], 0, 0);
      CFURLRequestSetHTTPRequestBodyStream(v30, 0);
      CFURLRequestSetHTTPHeaderFieldValue(v30, (const __CFString *)&unk_1EC0A20E0, 0);
      CFURLRequestSetHTTPHeaderFieldValue(v30, @"Content-Type", 0);
    }
    if (!haveTheSameOrigin(*(NSURL **)([*((id *)this + 11) _inner] + 8), (NSURL *)v27)) {
      CFURLRequestSetHTTPHeaderFieldValue(v30, (const __CFString *)&unk_1EC0A2540, 0);
    }
    CFURLRequestSetHTTPHeaderFieldValue(v30, (const __CFString *)&unk_1EC0A1F90, 0);
    CFURLRequestSetHTTPHeaderFieldValue(v30, @"Proxy-Authorization", 0);
    uint64_t v35 = *(void *)([*((id *)this + 11) _inner] + 56);
    if (v35 && *(unsigned char *)(v35 + 216))
    {
      CFStringRef v36 = *(const __CFString **)(v35 + 152);
      char v38 = v36
         && (CFEqual(v36, (CFStringRef)&gConstantCFStringValueTable[2604])
          || ((CFStringRef v37 = *(const __CFString **)(v35 + 152)) != 0
           || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
           && (*(_WORD *)long long buf = 0,
               _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (CFStringRef v37 = *(const __CFString **)(v35 + 152)) != 0))&& CFEqual(v37, (CFStringRef)&gConstantCFStringValueTable[2611]))|| *(unsigned char *)(v35 + 218) != 0;
    }
    else
    {
      char v38 = 0;
    }
    CFURLRequestSetShouldPipelineHTTP(v30, v38, 1);
    uint64_t v40 = *(void *)([*((id *)this + 11) _inner] + 88);
    *(void *)([v30 _inner] + 88) = v40;
    uint64_t v41 = *((void *)this + 10);
    if (v41)
    {
      __int16 v42 = (const void *)[*((id *)this + 10) _copyHSTSPolicy];
      uint64_t v43 = [v30 _inner];
      if (v42) {
        CFTypeRef v44 = CFRetain(v42);
      }
      else {
        CFTypeRef v44 = 0;
      }
      CFAllocatorRef v45 = *(const void **)(v43 + 208);
      *(void *)(v43 + 208) = v44;
      if (v45) {
        CFRelease(v45);
      }
      if (v42) {
        CFRelease(v42);
      }
    }
    HTTPProtocol::updateForHeader(this, a2);
    uint64_t v46 = [v30 _inner];
    *(_WORD *)(v46 + 64) &= ~2u;
    id v47 = [[NSURLRequest alloc] _initWithCFURLRequest:v30];
    CFIndex v48 = -[__NSURLSessionLocal _protocolClassForRequest:](*((void *)this + 93), (uint64_t)v47);
    if (v41 && v48) {
      id v47 = (id)[v48 canonicalRequestForRequest:v47 task:v41];
    }
    uint64_t v49 = *((void *)this + 26);
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    uint64_t v61 = 3221225472;
    uint64_t v62 = ___ZN11URLProtocol17sendWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_8656;
    CFArrayRef v63 = &unk_1E5255ED8;
    id v64 = v47;
    uint64_t v65 = v49;
    uint64_t v50 = *((void *)this + 12);
    if (v50)
    {
      uint64_t v51 = (*(uint64_t (**)(void))(*(void *)v50 + 16))(*((void *)this + 12));
      uint64_t v52 = (void *)MEMORY[0x18531D6D0](v51);
      v62((uint64_t)buf, *((void *)this + 12));
      (*(void (**)(uint64_t))(*(void *)v50 + 24))(v50);
    }
    __int16 v53 = *((_WORD *)this + 98);
    *((_DWORD *)this + 48) = *((_DWORD *)this + 48);
    *((_WORD *)this + 98) = v53 | 0x10;
    BOOL v39 = *((void *)this + 34) != 0;
    if (v30) {
      CFRelease(v30);
    }
  }
  if (v27) {
    CFRelease(v27);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (v39)
  {
    id v54 = (void *)*((void *)this + 11);
    if (v54)
    {
      CFBooleanRef v55 = (const __CFBoolean *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 34) + 32))(*((void *)this + 34), 32);
      if (v55)
      {
        CFBooleanRef v56 = v55;
        if (!CFBooleanGetValue(v55))
        {
          [v54 _inner];
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
          }
          __CFNReportRedirectSymptom(v57);
        }
        CFRelease(v56);
      }
      else
      {
        [v54 _inner];
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        __CFNReportRedirectSymptom(v58);
      }
    }
    uint64_t v4 = 1;
  }
  else
  {
    HTTPProtocol::destroyReadStream(this);
    uint64_t v4 = 0;
  }
  CFRelease(v26);
  return v4;
}

void sub_18423EF08(_Unwind_Exception *a1)
{
  CFRelease(v2);
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(a1);
}

void _ApplyOriginalComponents(void *a1, CFTypeRef *a2)
{
  if (!a1) {
    return;
  }
  CFTypeRef v3 = *a2;
  uint64_t v4 = [a1 cfURL];
  if (!v3 || v4 == 0) {
    return;
  }
  long long v18 = 0u;
  *(_OWORD *)CFTypeRef cf = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  memset(theString1, 0, sizeof(theString1));
  long long v13 = 0u;
  long long v14 = 0u;
  memset(theString2, 0, sizeof(theString2));
  if (_CFURLCopyComponents() && _CFURLCopyComponents())
  {
    if (cf[0]) {
      BOOL v6 = (void)v15 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    int v7 = v6;
    if (v6) {
      *(void *)&long long v15 = CFRetain(cf[0]);
    }
    if (theString1[0])
    {
      if (theString2[0])
      {
        if (theString1[3])
        {
          if (theString2[3])
          {
            if (CFStringCompare(theString1[0], theString2[0], 1uLL) == kCFCompareEqualTo
              && CFStringCompare(theString1[3], theString2[3], 1uLL) == kCFCompareEqualTo)
            {
              int32x4_t v9 = (int32x4_t)vtstq_s64(*(int64x2_t *)&theString1[1], *(int64x2_t *)&theString1[1]);
              *(int32x2_t *)v9.i8 = vmovn_s64((int64x2_t)v9);
              v9.i32[0] = vmovn_s32(v9).u32[0];
              int64x2_t v10 = vceqzq_s64(*(int64x2_t *)&theString2[1]);
              v9.i32[1] = vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v10, v10)).i32[1];
              if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(*(int16x4_t *)v9.i8, 0xFuLL))) & 1) != 0
                && (void)v17 == (void)v13)
              {
                theString2[1] = (CFStringRef)CFRetain(theString1[1]);
                CFStringRef v11 = theString1[2];
                if (theString1[2]) {
                  CFStringRef v11 = (const __CFString *)CFRetain(theString1[2]);
                }
                theString2[2] = v11;
                goto LABEL_24;
              }
            }
          }
        }
      }
    }
    if (v7)
    {
LABEL_24:
      CFStringRef v8 = (const void *)_CFURLCreateFromComponents();
      goto LABEL_26;
    }
  }
  CFStringRef v8 = 0;
LABEL_26:
  _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper((uint64_t)theString2);
  _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper((uint64_t)theString1);
  if (v8)
  {
    CFRetain(v8);
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = v8;
    CFRelease(v8);
  }
}

void sub_18423F0F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  CFRelease(v19);
  _Unwind_Resume(a1);
}

uint64_t HTTPProtocol::expectedProgressTargetChanged(HTTPProtocol *this)
{
  uint64_t v2 = *((void *)this + 34);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v2 + 40))(v2, 7, *MEMORY[0x1E4F1CFD0]);
  }
  uint64_t result = *((void *)this + 111);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)result + 56))(result, 0x1EC09EA68, *MEMORY[0x1E4F1CFD0]);
  }
  return result;
}

void DiagnosticLogging::logPair(DiagnosticLogging *this, const char *a2, const char *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  int64x2_t v10 = off_1ECF9A530;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  CFStringRef v11 = CFStringCreateWithCString(v5, a2, 0x8000100u);
  if (a3)
  {
    BOOL v6 = off_1ECF9A530;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    CFStringRef v7 = CFStringCreateWithCString(v5, a3, 0x8000100u);
    (*(void (**)(DiagnosticLogging *, CFStringRef, CFStringRef))(*(void *)this + 64))(this, v11, v7);
    AutoString::~AutoString((AutoString *)&v6);
  }
  else
  {
    (*(void (**)(DiagnosticLogging *))(*(void *)this + 64))(this);
  }
  AutoString::~AutoString((AutoString *)&v10);
}

void sub_18423F300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t HTTPRequestParserClient::isHeadRequest(HTTPRequestParserClient *this)
{
  uint64_t result = *((void *)this + 3);
  if (result) {
    return CFEqual((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2611]);
  }
  uint64_t result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT);
  if (result)
  {
    *(_WORD *)CFTypeRef v3 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", v3, 2u);
    uint64_t result = *((void *)this + 3);
    if (result) {
      return CFEqual((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2611]);
    }
  }
  return result;
}

uint64_t ___ZN12HTTPProtocol29validateCachedResponseForLoadEPK20_CFCachedURLResponse_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 755;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

intptr_t ___ZN12HTTPProtocol22copyCookiesForThisTaskEP16NSURLSessionTask_block_invoke(uint64_t a1, CFTypeRef cf)
{
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v3;
  uint64_t v4 = *(NSObject **)(a1 + 32);

  return dispatch_semaphore_signal(v4);
}

void HTTPProtocol::_protocolInterface_setIsDownload(HTTPProtocol *this, int a2)
{
  if (!*((void *)this + 34)) {
    return;
  }
  if (!*((void *)this + 10) || (uint64_t v4 = (const void *)*((void *)this + 94)) == 0)
  {
    CFDictionaryRef v6 = 0;
    goto LABEL_11;
  }
  CFDictionaryRef v5 = (const __CFDictionary *)CFRetain(v4);
  CFDictionaryRef v6 = v5;
  if (!v5)
  {
LABEL_11:
    char v7 = 1;
    goto LABEL_12;
  }
  if (CFDictionaryGetCount(v5)
    && (CFDictionaryContainsKey(v6, &unk_1EC09FB08)
     || CFDictionaryContainsKey(v6, &unk_1EC09FB40)
     || CFDictionaryContainsKey(v6, &unk_1EC09F7C0)))
  {
LABEL_18:
    CFRelease(v6);
    return;
  }
  char v7 = 0;
LABEL_12:
  int v9 = *((_DWORD *)this + 48);
  uint64_t v8 = (char *)this + 192;
  __int16 v10 = *((_WORD *)v8 + 2);
  *(_DWORD *)uint64_t v8 = v9 & 0xFFFDFFFF | ((a2 != 0) << 17);
  *((_WORD *)v8 + 2) = v10;
  CFStringRef v11 = (void *)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    CFStringRef v11 = (void *)MEMORY[0x1E4F1CFC8];
  }
  (*(void (**)(void, uint64_t, void))(**((void **)v8 + 10) + 40))(*((void *)v8 + 10), 16, *v11);
  uint64_t v12 = *((void *)v8 + 10);
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 128))(v12);
  }
  if ((v7 & 1) == 0) {
    goto LABEL_18;
  }
}

void std::deque<SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::pop_front(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  CFTypeRef v3 = *(std::__shared_weak_count **)(*(void *)(*(void *)(a1 + 8) + ((v2 >> 5) & 0x7FFFFFFFFFFFFF8))
                                    + 16 * v2
                                    + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    unint64_t v2 = *(void *)(a1 + 32);
  }
  uint64_t v4 = *(void *)(a1 + 40) - 1;
  unint64_t v5 = v2 + 1;
  *(void *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = v4;
  if (v5 >= 0x200)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 256;
  }
}

void setTypeProperty<_CFURLAuthChallenge *>(CFTypeRef *a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  if (*a1) {
    CFRelease(*a1);
  }
  *a1 = cf;
}

void HTTPProtocol::executePACQuery(HTTPProtocol *this, void *cf, __CFString *a3)
{
  CFDictionaryRef v6 = (void *)*((void *)this + 11);
  CFTypeRef v7 = (CFTypeRef)*((void *)this + 49);
  if (v7 != cf)
  {
    if (v7) {
      CFRelease(v7);
    }
    if (cf) {
      CFTypeRef v8 = CFRetain(cf);
    }
    else {
      CFTypeRef v8 = 0;
    }
    *((void *)this + 49) = v8;
  }
  int v9 = *(const void **)(objc_msgSend(v6, "_inner", 0, this, 0, 0, 0) + 8);
  if (a3) {
    CFStringRef v11 = (PAC *)a3;
  }
  else {
    CFStringRef v11 = (PAC *)cf;
  }
  *((void *)this + 38) = PAC::CreatePACTicket(v11, v9, 0, 0, (const __CFString *)HTTPProtocol::_PACExecutionComplete, (void (*)(void *, const __CFArray *, __CFError *))&v34, v10);
  uint64_t v12 = *((void *)this + 45);
  if (v12)
  {
    uint64_t Username = (const void *)CFURLCredentialGetUsername(v12);
    uint64_t v15 = URLCredential_PasswordBased::safelyCast(*((void *)this + 45), v14);
    if (v15) {
      __int16 v16 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 128))(v15);
    }
    else {
      __int16 v16 = 0;
    }
    long long v17 = (__CFRunLoopSource *)*((void *)this + 38);
    memset(&context, 0, sizeof(context));
    CFRunLoopSourceGetContext(v17, &context);
    uint64_t v18 = *((void *)context.info + 7);
    if (Username) {
      CFTypeRef v19 = CFRetain(Username);
    }
    else {
      CFTypeRef v19 = 0;
    }
    CFURLRef v20 = *(const void **)(v18 + 16);
    *(void *)(v18 + CFRelease((char *)this - 16) = v19;
    if (v20) {
      CFRelease(v20);
    }
    if (v16) {
      CFTypeRef v21 = CFRetain(v16);
    }
    else {
      CFTypeRef v21 = 0;
    }
    uint64_t v22 = *(const void **)(v18 + 24);
    *(void *)(v18 + 24) = v21;
    if (v22) {
      CFRelease(v22);
    }
    if (v16) {
      CFRelease(v16);
    }
  }
  uint64_t v23 = *((void *)this + 3);
  if (v23 && *(_DWORD *)(v23 + 40))
  {
    CFURLRef v24 = (CFStringRef (__cdecl *)(const void *))*((void *)this + 38);
    context.version = MEMORY[0x1E4F143A8];
    context.info = (void *)3221225472;
    context.retain = (const void *(__cdecl *)(const void *))___ZNK17CoreSchedulingSet14scheduleSourceEP17__CFRunLoopSource_block_invoke;
    context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
    context.copyDescription = v24;
    CoreSchedulingSet::applyBlockWithPossibleEmulation(v23, &context);
  }
  else
  {
    context.version = 0;
    memset(&context.retain, 0, 24);
    context.info = this;
    CFAllocatorRef v25 = CFGetAllocator((char *)this - 16);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFURLRef v27 = CFRunLoopTimerCreate(v25, Current + 60.0, -1.0, 0, 0, (CFRunLoopTimerCallBack)HTTPProtocol::_PacTimerCallback, (CFRunLoopTimerContext *)&context);
    CFStringRef v28 = CFRunLoopGetCurrent();
    CFRunLoopAddTimer(v28, v27, @"_kProxySupportSyncPACExecutionRunLoopMode");
    CFStringRef v29 = CFRunLoopGetCurrent();
    CFRunLoopAddSource(v29, *((CFRunLoopSourceRef *)this + 38), @"_kProxySupportSyncPACExecutionRunLoopMode");
    uint64_t v30 = (const void *)*((void *)this + 38);
    if (v30)
    {
      CFTypeRef v31 = CFRetain(v30);
      while (*((void *)this + 38))
        CFRunLoopRunInMode(@"_kProxySupportSyncPACExecutionRunLoopMode", 1.0e10, 1u);
    }
    else
    {
      CFTypeRef v31 = 0;
    }
    CFStringRef v32 = CFRunLoopGetCurrent();
    CFRunLoopRemoveTimer(v32, v27, @"_kProxySupportSyncPACExecutionRunLoopMode");
    CFStringRef v33 = CFRunLoopGetCurrent();
    CFRunLoopRemoveSource(v33, *((CFRunLoopSourceRef *)this + 38), @"_kProxySupportSyncPACExecutionRunLoopMode");
    if (v27) {
      CFRelease(v27);
    }
    if (v31) {
      CFRelease(v31);
    }
  }
}

void SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a1)
  {
    if (a3) {
      atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v4 = *(void (**)(void *, uint64_t *))(a1 + 8);
    uint64_t v5 = *(void *)(a1 + 16);
    CFDictionaryRef v6 = (void *)(a1 + (v5 >> 1));
    if (v5) {
      uint64_t v4 = *(void (**)(void *, uint64_t *))(*v6 + v4);
    }
    uint64_t v7 = a2;
    CFTypeRef v8 = a3;
    if (a3) {
      atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v4(v6, &v7);
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
    if (a3) {
      std::__shared_weak_count::__release_shared[abi:nn180100](a3);
    }
  }
}

void sub_18423FA60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void HTTPProtocol::_PacTimerCallback(HTTPProtocol *this, __CFRunLoopTimer *a2, void *a3)
{
  CFAllocatorRef v4 = CFGetAllocator((char *)a2 - 16);
  CFCFStreamError Error = __cfnCreateCFError(v4, @"kCFErrorDomainCFNetwork", 308, v5, v6, v7, v8, v9, 0);
  uint64_t v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_175, 2);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((*(unsigned int (**)(uint64_t, const char *, __CFRunLoopTimer *))(*(void *)v11 + 24))(v11, "Protocol PAC Timeout", a2))
    {
      (*(void (**)(uint64_t, const char *, void))(*(void *)v12 + 48))(v12, "Request", *((void *)a2 + 11));
      (*(void (**)(uint64_t, const char *, __CFError *))(*(void *)v12 + 56))(v12, "Error", CFError);
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  HTTPProtocol::pacExecutionComplete((HTTPProtocol *)a2, 0, CFError);
  if (CFError) {
    CFRelease(CFError);
  }
  CFAbsoluteTime Current = CFRunLoopGetCurrent();

  CFRunLoopStop(Current);
}

void HTTPProtocol::pacExecutionComplete(HTTPProtocol *this, const __CFArray *a2, CFErrorRef err)
{
  uint64_t v6 = (__CFRunLoopSource *)*((void *)this + 38);
  if (v6)
  {
    CFRunLoopSourceInvalidate(v6);
    uint64_t v7 = (const void *)*((void *)this + 38);
    if (v7) {
      CFRelease(v7);
    }
  }
  *((void *)this + 38) = 0;
  if (err)
  {
    if (CFErrorGetDomain(err) == @"kCFErrorDomainCFNetwork" && CFErrorGetCode(err) == 309)
    {
      CFDictionaryRef v8 = CFErrorCopyUserInfo(err);
      CFStringRef Value = CFDictionaryGetValue(v8, @"kCFProxyAutoConfigurationURLKey");
      __int16 v10 = (const void *)*((void *)this + 48);
      if (v10) {
        CFRelease(v10);
      }
      uint64_t v11 = (__CFHTTPMessage *)CFDictionaryGetValue(v8, @"kCFProxyAutoConfigurationHTTPResponse");
      CFAllocatorRef v12 = CFGetAllocator((char *)this - 16);
      uint64_t v13 = (_CFHTTPAuthentication *)_CFHTTPAuthenticationCreateFromResponseInternal(v12, v11, 0, 1, 0, 0, 0, 0, 0, v46);
      if (v13)
      {
        uint64_t v14 = v13;
        if (CFHTTPAuthenticationIsValid(v13, 0))
        {
          CFIndex v48 = Value;
          CFDictionaryRef v49 = v8;
          CFURLRef v15 = CFHTTPMessageCopyRequestURL(v11);
          BOOL v16 = connectionTypeFromURL(v15);
          CFStringRef v17 = CFURLCopyHostName(v15);
          SInt32 v18 = CFURLGetPortNumber(v15);
          if (v16) {
            int v19 = 443;
          }
          else {
            int v19 = 80;
          }
          if (v18 != -1) {
            int v19 = v18;
          }
          int v47 = v19;
          CFStringRef v20 = CFHTTPAuthenticationCopyRealm(v14);
          CFAllocatorRef v22 = CFGetAllocator((char *)this - 16);
          if ((v16 - 1) > 3) {
            int v23 = 1;
          }
          else {
            int v23 = dword_1843D1980[v16 - 1];
          }
          int v33 = URLProtectionSpace::authSchemeForAuth(v14, v21);
          long long v34 = (const void *)CFURLProtectionSpaceCreate((uint64_t)v22, v17, v47, v23, v20, v33);
          if (v15) {
            CFRelease(v15);
          }
          if (v17) {
            CFRelease(v17);
          }
          if (v20) {
            CFRelease(v20);
          }
          CFAllocatorRef v35 = CFGetAllocator((char *)this - 16);
          id v36 = CFURLResponseCreateWithHTTPResponse((uint64_t)v35, v48, (uint64_t)v11, 2);
          CFAllocatorRef v37 = CFGetAllocator((char *)this - 16);
          uint64_t v38 = CFURLAuthChallengeCreate((uint64_t)v37, v34, 0, 0, v36, 0);

          if (v34) {
            CFRelease(v34);
          }
          CFRelease(v14);
          *((void *)this + 48) = v38;
          CFDictionaryRef v8 = v49;
          if (v38)
          {
            if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
              dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
            }
            BOOL v39 = *(_CFURLProtectionSpace **)(v38 + 40);
            uint64_t v40 = (const _CFURLCredential *)*((void *)this + 45);
            if (v40)
            {
              HTTPProtocol::RemoveCredentialPasswordForProtectionSpace(this, v40, v39, 1);
              uint64_t v41 = (const void *)*((void *)this + 45);
              *((void *)this + 45) = 0;
              if (v41) {
                CFRelease(v41);
              }
            }
            if (*((void *)this + 48))
            {
              uint64_t v42 = (*(uint64_t (**)(void, _CFURLProtectionSpace *, void))(**((void **)this + 87) + 80))(*((void *)this + 87), v39, *((void *)this + 10));
              *((void *)this + 45) = v42;
              if (!v42) {
                goto LABEL_65;
              }
              uint64_t v44 = URLCredential_PasswordBased::safelyCast(v42, v43);
              if (!v44 || !(*(unsigned int (**)(uint64_t))(*(void *)v44 + 136))(v44))
              {
                CFAllocatorRef v45 = (const void *)*((void *)this + 45);
                *((void *)this + 45) = 0;
                if (!v45) {
                  goto LABEL_65;
                }
                CFRelease(v45);
              }
            }
            if (*((void *)this + 45))
            {
              HTTPProtocol::executePACQuery(this, v48, 0);
              goto LABEL_37;
            }
LABEL_65:
            HTTPProtocol::sendDidReceiveAuthChallenge(this, *((_CFURLAuthChallenge **)this + 48));
LABEL_37:
            if (v8)
            {
              CFRelease(v8);
            }
            return;
          }
LABEL_36:
          URLProtocol::sendDidFail((URLProtocol *)this, err);
          goto LABEL_37;
        }
        CFRelease(v14);
      }
      *((void *)this + 48) = 0;
      goto LABEL_36;
    }
    if (!*((void *)this + 37))
    {
      URLProtocol::sendDidFail((URLProtocol *)this, err);
      return;
    }
  }
  else
  {
    CFArrayRef v24 = (const __CFArray *)*((void *)this + 37);
    if (v24)
    {
      CFIndex Count = CFArrayGetCount(v24);
      CFIndex v26 = CFArrayGetCount(a2);
      CFAllocatorRef v27 = CFGetAllocator((char *)this - 16);
      CFArrayRef Mutable = CFArrayCreateMutable(v27, v26 + Count, MEMORY[0x1E4F1D510]);
      v51.CFIndex location = 0;
      v51.CFStringRef length = v26;
      CFArrayAppendArray(Mutable, a2, v51);
      v52.CFIndex location = 0;
      v52.CFStringRef length = Count;
      CFArrayAppendArray(Mutable, *((CFArrayRef *)this + 37), v52);
      CFStringRef v29 = (const void *)*((void *)this + 37);
      if (v29) {
        CFRelease(v29);
      }
    }
    else
    {
      CFAllocatorRef v30 = CFGetAllocator((char *)this - 16);
      CFIndex v31 = CFArrayGetCount(a2);
      CFArrayRef Mutable = CFArrayCreateMutableCopy(v30, v31, a2);
    }
    *((void *)this + 37) = Mutable;
    if (*((void *)this + 45))
    {
      uint64_t v32 = *((void *)this + 48);
      if (v32)
      {
        if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
          dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
        }
        (*(void (**)(void, void, void, void))(**((void **)this + 87) + 56))(*((void *)this + 87), *((void *)this + 45), *(void *)(v32 + 40), *((void *)this + 10));
      }
    }
  }

  HTTPProtocol::createAndOpenStream(this, 0);
}

uint64_t ___ZN12HTTPProtocol19pacExecutionTimeoutEP16__CFRunLoopTimer_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  unint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 3800;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN12HTTPProtocol28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFTypeRef v3 = (const void *)(v2 - 16);
  (*(void (**)(uint64_t, void))(*(void *)v2 + 88))(v2, *(void *)(a1 + 40));
  CFRelease(v3);
  CFAllocatorRef v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t HTTPProtocol::initialize(HTTPProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3)
{
  return (*(uint64_t (**)(HTTPProtocol *, NSURLSessionTask *, URLProtocolClient *, void))(*(void *)this + 240))(this, a2, a3, 0);
}

CFTypeRef HTTPProtocol::copyDebugSummary(HTTPProtocol *this)
{
  uint64_t v1 = (void *)*((void *)this + 11);
  if (v1)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)[v1 _inner] + 24);
    return (CFTypeRef)v2();
  }
  else
  {
    return CFRetain(@"nullptr request");
  }
}

CFStringRef HTTPProtocol::copyDebugDesc(HTTPProtocol *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<HTTP protocol instance %p>", this);
}

void std::__shared_ptr_pointer<BlockHolderVar<void *> *,SmartBlockWithArgs<void *>::Deleter,std::allocator<BlockHolderVar<void *>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t BlockHolderVar<void *>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<void *>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void ___ZN12HTTPProtocol24handleProxyAuthChallengeEP15__CFHTTPMessagejPK10__CFStringi18SmartBlockWithArgsIJPK16_CFURLCredentialbEE_block_invoke(uint64_t a1)
{
  uint64_t v134 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = *(void **)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFTypeRef v3 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v43 = v2[99];
    uint64_t v44 = *(void *)(a1 + 40);
    uint64_t v45 = *(void *)(a1 + 48);
    int v46 = *(_DWORD *)(a1 + 112);
    *(_DWORD *)long long buf = 138544130;
    uint64_t v127 = v43;
    __int16 v128 = 2112;
    uint64_t v129 = v44;
    __int16 v130 = 2112;
    uint64_t v131 = v45;
    __int16 v132 = 1024;
    int v133 = v46;
    _os_log_debug_impl(&dword_184085000, v3, OS_LOG_TYPE_DEBUG, "%{public}@ handling proxy auth challenge for %@ host %@ port %d", buf, 0x26u);
  }
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 72);
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  if (v4)
  {
    *(void *)(v4 + 8) = BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_normal;
    *(void *)(v4 + CFRelease((char *)this - 16) = 0;
  }
  uint64_t v117 = v2 + 80;
  uint64_t v6 = (char **)(v2 + 81);
  uint64_t v7 = (char *)v2[82];
  CFDictionaryRef v8 = (char *)v2[81];
  uint64_t v9 = v7 - v8;
  if (v7 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = 32 * (v7 - v8) - 1;
  }
  unint64_t v11 = v2[84];
  uint64_t v12 = v2[85];
  unint64_t v13 = v12 + v11;
  uint64_t v121 = v5;
  if (v10 != v12 + v11)
  {
LABEL_93:
    uint64_t v103 = (void *)(*(void *)&v8[(v13 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v13);
    *uint64_t v103 = v4;
    v103[1] = v5;
    if (v5)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      uint64_t v12 = v2[85];
    }
    v2[85] = v12 + 1;
    CFAllocatorRef v104 = CFGetAllocator(v2 - 2);
    CFStringCreateWithFormat(v104, 0, @"https://%@:%d/", *(void *)(a1 + 48), *(unsigned __int16 *)(a1 + 112));
    operator new();
  }
  if (v11 < 0x100)
  {
    uint64_t v116 = v4;
    uint64_t v27 = v9 >> 3;
    CFStringRef v28 = (char *)v2[83];
    CFStringRef v29 = (char *)v2[80];
    uint64_t v30 = v28 - v29;
    if (v9 >> 3 >= (unint64_t)((v28 - v29) >> 3))
    {
      if (v28 == v29) {
        unint64_t v31 = 1;
      }
      else {
        unint64_t v31 = v30 >> 2;
      }
      uint64_t v32 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v31);
      uint64_t v34 = v33;
      CFAllocatorRef v35 = &v32[8 * v27];
      *(void *)&long long v36 = v32;
      *((void *)&v36 + 1) = v35;
      *(_OWORD *)CFTypeRef cf = v36;
      CFAllocatorRef v37 = operator new(0x1000uLL);
      *(void *)&long long v38 = v35;
      *((void *)&v38 + 1) = &v32[8 * v34];
      if (v27 == v34)
      {
        uint64_t v39 = 8 * v27;
        uint64_t v4 = v116;
        *(CFTypeRef *)&long long v40 = cf[0];
        if (v9 < 1)
        {
          CFNumberRef v79 = v37;
          uint64_t v80 = v39 >> 2;
          if (v7 == v8) {
            unint64_t v81 = 1;
          }
          else {
            unint64_t v81 = v80;
          }
          int v82 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v81);
          CFAllocatorRef v35 = &v82[8 * (v81 >> 2)];
          *(void *)&long long v40 = v82;
          *((void *)&v40 + 1) = v35;
          *(void *)&long long v38 = v35;
          *((void *)&v38 + 1) = &v82[8 * v83];
          if (v32)
          {
            *(_OWORD *)cfa = v40;
            long long v118 = v38;
            operator delete(v32);
            long long v38 = v118;
            long long v40 = *(_OWORD *)cfa;
          }
          CFAllocatorRef v37 = v79;
        }
        else
        {
          uint64_t v41 = v39 >> 3;
          if (v41 >= -1) {
            unint64_t v42 = v41 + 1;
          }
          else {
            unint64_t v42 = v41 + 2;
          }
          v35 -= 8 * (v42 >> 1);
          *(void *)&long long v38 = v35;
          *((void *)&v40 + 1) = v35;
        }
      }
      else
      {
        uint64_t v4 = v116;
        long long v40 = *(_OWORD *)cf;
      }
      *(void *)CFAllocatorRef v35 = v37;
      *(void *)&long long v38 = v38 + 8;
      SInt32 v84 = (char *)v2[82];
      uint64_t v5 = v121;
      while (v84 != *v6)
      {
        int v85 = (void *)*((void *)&v40 + 1);
        if (*((void *)&v40 + 1) == (void)v40)
        {
          CFAllocatorRef v87 = (unsigned char *)v38;
          if ((unint64_t)v38 >= *((void *)&v38 + 1))
          {
            if (*((void *)&v38 + 1) == *((void *)&v40 + 1)) {
              unint64_t v92 = 1;
            }
            else {
              unint64_t v92 = (uint64_t)(*((void *)&v38 + 1) - *((void *)&v40 + 1)) >> 2;
            }
            CFBooleanRef v93 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v92);
            CFStringRef v86 = &v93[(2 * v92 + 6) & 0xFFFFFFFFFFFFFFF8];
            CFTypeRef v95 = v86;
            uint64_t v96 = v87 - (unsigned char *)v85;
            if (v87 != (unsigned char *)v85)
            {
              CFTypeRef v95 = &v86[v96 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v97 = 8 * (v96 >> 3);
              double v98 = &v93[(2 * v92 + 6) & 0xFFFFFFFFFFFFFFF8];
              uint64_t v99 = v85;
              do
              {
                uint64_t v100 = *v99++;
                *(void *)double v98 = v100;
                v98 += 8;
                v97 -= 8;
              }
              while (v97);
            }
            *(void *)&long long v40 = v93;
            *((void *)&v40 + 1) = &v93[(2 * v92 + 6) & 0xFFFFFFFFFFFFFFF8];
            *(void *)&long long v38 = v95;
            *((void *)&v38 + 1) = &v93[8 * v94];
            if (v85)
            {
              *(_OWORD *)cfc = v40;
              long long v119 = v38;
              operator delete(v85);
              long long v38 = v119;
              long long v40 = *(_OWORD *)cfc;
            }
          }
          else
          {
            uint64_t v88 = (uint64_t)(*((void *)&v38 + 1) - v38) >> 3;
            if (v88 >= -1) {
              uint64_t v89 = v88 + 1;
            }
            else {
              uint64_t v89 = v88 + 2;
            }
            uint64_t v90 = v89 >> 1;
            uint64_t v91 = v38 + 8 * (v89 >> 1);
            CFStringRef v86 = (char *)(v91 - (v38 - *((void *)&v40 + 1)));
            if ((void)v38 == *((void *)&v40 + 1))
            {
              CFAllocatorRef v87 = (unsigned char *)*((void *)&v40 + 1);
            }
            else
            {
              uint64_t cfb = v40;
              uint64_t v120 = *((void *)&v38 + 1);
              memmove((void *)(v91 - (v38 - *((void *)&v40 + 1))), *((const void **)&v40 + 1), v38 - *((void *)&v40 + 1));
              *((void *)&v38 + 1) = v120;
              *(void *)&long long v40 = cfb;
            }
            *((void *)&v40 + 1) = v86;
            *(void *)&long long v38 = &v87[8 * v90];
          }
        }
        else
        {
          CFStringRef v86 = (char *)*((void *)&v40 + 1);
        }
        uint64_t v101 = *((void *)v84 - 1);
        v84 -= 8;
        *((void *)v86 - 1) = v101;
        *((void *)&v40 + 1) -= 8;
      }
      uint64_t v102 = (void *)v2[80];
      *((_OWORD *)v2 + 40) = v40;
      *((_OWORD *)v2 + 41) = v38;
      if (v102) {
        operator delete(v102);
      }
      goto LABEL_92;
    }
    if (v28 != v7)
    {
      *(void *)uint64_t v7 = operator new(0x1000uLL);
      v2[82] += 8;
      uint64_t v4 = v116;
LABEL_92:
      CFDictionaryRef v8 = (char *)v2[81];
      uint64_t v12 = v2[85];
      unint64_t v13 = v12 + v2[84];
      goto LABEL_93;
    }
    double v57 = operator new(0x1000uLL);
    if (v29 == v8)
    {
      if (v7 == v8) {
        unint64_t v58 = 1;
      }
      else {
        unint64_t v58 = v30 >> 2;
      }
      CFStringRef v59 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v58);
      CFDictionaryRef v8 = &v59[(2 * v58 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v61 = (uint64_t *)v2[81];
      uint64_t v62 = v8;
      uint64_t v63 = v2[82] - (void)v61;
      if (v63)
      {
        uint64_t v62 = &v8[v63 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v64 = 8 * (v63 >> 3);
        uint64_t v65 = &v59[(2 * v58 + 6) & 0xFFFFFFFFFFFFFFF8];
        do
        {
          uint64_t v66 = *v61++;
          *(void *)uint64_t v65 = v66;
          v65 += 8;
          v64 -= 8;
        }
        while (v64);
      }
      long long v67 = (void *)v2[80];
      v2[80] = v59;
      v2[81] = v8;
      v2[82] = v62;
      v2[83] = &v59[8 * v60];
      if (v67)
      {
        operator delete(v67);
        CFDictionaryRef v8 = *v6;
      }
    }
    *((void *)v8 - 1) = v57;
    socklen_t v68 = (char *)v2[81];
    v2[81] = v68 - 8;
    uint64_t v69 = *((void *)v68 - 1);
    v2[81] = v68;
    int v70 = (char *)v2[82];
    uint64_t v4 = v116;
    if (v70 == (char *)v2[83])
    {
      uint64_t v71 = (uint64_t)&v68[-*v117];
      if ((unint64_t)v68 <= *v117)
      {
        if (v70 == (char *)*v117) {
          unint64_t v105 = 1;
        }
        else {
          unint64_t v105 = (uint64_t)&v70[-*v117] >> 2;
        }
        uint64_t v106 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v105);
        uint64_t v108 = &v106[8 * (v105 >> 2)];
        CFAllocatorRef v109 = (uint64_t *)v2[81];
        int v70 = v108;
        uint64_t v110 = v2[82] - (void)v109;
        if (v110)
        {
          int v70 = &v108[v110 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v111 = 8 * (v110 >> 3);
          uint64_t v112 = &v106[8 * (v105 >> 2)];
          do
          {
            uint64_t v113 = *v109++;
            *(void *)uint64_t v112 = v113;
            v112 += 8;
            v111 -= 8;
          }
          while (v111);
        }
        CFAllocatorRef v114 = (void *)v2[80];
        v2[80] = v106;
        v2[81] = v108;
        v2[82] = v70;
        v2[83] = &v106[8 * v107];
        uint64_t v4 = v116;
        if (v114)
        {
          operator delete(v114);
          int v70 = (char *)v2[82];
        }
      }
      else
      {
        uint64_t v72 = v71 >> 3;
        BOOL v19 = v71 >> 3 < -1;
        uint64_t v73 = (v71 >> 3) + 2;
        if (v19) {
          uint64_t v74 = v73;
        }
        else {
          uint64_t v74 = v72 + 1;
        }
        uint64_t v75 = -(v74 >> 1);
        uint64_t v76 = v74 >> 1;
        CFDictionaryRef v77 = &v68[-8 * v76];
        int64_t v78 = v70 - v68;
        if (v70 != v68)
        {
          memmove(&v68[-8 * v76], v68, v70 - v68);
          socklen_t v68 = *v6;
        }
        int v70 = &v77[v78];
        v2[82] = &v77[v78];
        v2[81] = &v68[8 * v75];
      }
    }
    *(void *)int v70 = v69;
  }
  else
  {
    v2[84] = v11 - 256;
    uint64_t v16 = *(void *)v8;
    uint64_t v14 = v8 + 8;
    uint64_t v15 = v16;
    v2[81] = v14;
    if ((char *)v2[83] == v7)
    {
      uint64_t v115 = v4;
      uint64_t v17 = (uint64_t)&v14[-*v117];
      if ((unint64_t)v14 <= *v117)
      {
        if (v7 == (char *)*v117) {
          unint64_t v47 = 1;
        }
        else {
          unint64_t v47 = (uint64_t)&v7[-*v117] >> 2;
        }
        CFIndex v48 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v47);
        uint64_t v50 = &v48[8 * (v47 >> 2)];
        CFRange v51 = (uint64_t *)v2[81];
        uint64_t v7 = v50;
        uint64_t v52 = v2[82] - (void)v51;
        if (v52)
        {
          uint64_t v7 = &v50[v52 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v53 = 8 * (v52 >> 3);
          id v54 = &v48[8 * (v47 >> 2)];
          do
          {
            uint64_t v55 = *v51++;
            *(void *)id v54 = v55;
            v54 += 8;
            v53 -= 8;
          }
          while (v53);
        }
        CFBooleanRef v56 = (void *)v2[80];
        v2[80] = v48;
        v2[81] = v50;
        v2[82] = v7;
        v2[83] = &v48[8 * v49];
        if (v56)
        {
          operator delete(v56);
          uint64_t v7 = (char *)v2[82];
        }
      }
      else
      {
        uint64_t v18 = v17 >> 3;
        BOOL v19 = v17 >> 3 < -1;
        uint64_t v20 = (v17 >> 3) + 2;
        if (v19) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = v18 + 1;
        }
        uint64_t v22 = -(v21 >> 1);
        uint64_t v23 = v21 >> 1;
        CFArrayRef v24 = &v14[-8 * v23];
        int64_t v25 = v7 - v14;
        if (v7 == v14)
        {
          CFIndex v26 = v7;
        }
        else
        {
          memmove(&v14[-8 * v23], v14, v7 - v14);
          CFIndex v26 = *v6;
        }
        uint64_t v7 = &v24[v25];
        v2[82] = &v24[v25];
        v2[81] = &v26[8 * v22];
        uint64_t v4 = v115;
      }
    }
    *(void *)uint64_t v7 = v15;
  }
  v2[82] += 8;
  goto LABEL_92;
}

void sub_184240F34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, void *cf, uint64_t a18, uint64_t a19, uint64_t a20)
{
  operator delete(v20);
  if (cf) {
    operator delete(cf);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_48c39_ZTSNSt3__110shared_ptrIK10__CFStringEE64c49_ZTS18SmartBlockWithArgsIJPK16_CFURLCredentialbEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE96c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(void *a1)
{
  CFAllocatorRef v2 = (std::__shared_weak_count *)a1[13];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  CFTypeRef v3 = (std::__shared_weak_count *)a1[11];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[9];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[7];
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void *__copy_helper_block_e8_48c39_ZTSNSt3__110shared_ptrIK10__CFStringEE64c49_ZTS18SmartBlockWithArgsIJPK16_CFURLCredentialbEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE96c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(void *result, void *a2)
{
  uint64_t v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[9];
  result[8] = a2[8];
  result[9] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[11];
  result[10] = a2[10];
  result[11] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a2[13];
  result[12] = a2[12];
  result[13] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void HTTPProtocol::handleInformationalResponse(void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)a1[10];
  -[__NSCFResumableUploadState processResponse:]([v4 resumableUploadState], (__CFHTTPMessage *)(*(void *)a2 - 16));
  uint64_t v5 = objc_msgSend((id)objc_msgSend(v4, "resumableUploadState"), "isResumable");
  if (v5)
  {
    uint64_t v6 = a1[104];
    if (v6) {
      *(unsigned char *)(v6 + 12) = 1;
    }
  }
  id v7 = CFURLResponseCreateWithHTTPResponse(v5, *(const void **)(*(void *)a2 + 144), *(void *)a2 - 16, 2);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  uint64_t v12 = ___ZN11URLProtocol35sendDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke;
  unint64_t v13 = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  id v14 = v7;
  uint64_t v8 = a1[12];
  if (v8)
  {
    uint64_t v9 = (*(uint64_t (**)(void))(*(void *)v8 + 16))(a1[12]);
    uint64_t v10 = (void *)MEMORY[0x18531D6D0](v9);
    v12((uint64_t)v11, a1[12]);
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
}

uint64_t ___ZN11URLProtocol35sendDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 56))(a2, *(void *)(a1 + 32));
}

CFTypeRef ___ZN22HTTPProtocolSSLSupport40CreateClientCertChallengeWithHostAndPortEPK10__CFStringlPK9__CFArray_block_invoke(uint64_t a1, uint64_t a2)
{
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  if (a2) {
    uint64_t v4 = (URLProtectionSpace *)(a2 + 16);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 32);

  return URLProtectionSpace::setDistinguishedNames(v4, v5);
}

void sub_184241A78(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__8863(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__8864(uint64_t a1)
{
}

void non-virtual thunk to'CFNAccount::~CFNAccount(CFNAccount *this)
{
}

{
  CFNAccount::~CFNAccount((CFNAccount *)((char *)this - 8));
}

void CFNAccount::~CFNAccount(CFNAccount *this)
{
  *(void *)this = &unk_1ECF9A550;
  *((void *)this + 1) = &unk_1ECF9A5A0;
  uint64_t v2 = (const void *)*((void *)this + 4);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 3);
  if (v3) {

  }
  uint64_t v4 = (void *)*((void *)this + 2);
  if (v4) {

  }
  *((void *)this + 1) = &unk_1ECF9B550;
}

void sub_184242BA8(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t CFNAccount::initialize(CFNAccount *this, objc_object *a2)
{
  if (!a2) {
    return 0;
  }
  *((void *)this + 2) = a2;
  return 1;
}

CFStringRef CFNAccount::copyDebugDesc(CFNAccount *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFNAccount@%p> user-name:%@", this, *((void *)this + 5));
}

void *CFNAccount::username(CFNAccount *this)
{
  uint64_t result = (void *)*((void *)this + 5);
  if (!result)
  {
    uint64_t result = (void *)*((void *)this + 2);
    if (result)
    {
      uint64_t result = (void *)[result username];
      *((void *)this + 5) = result;
      if (result)
      {
        CFRetain(result);
        return (void *)*((void *)this + 5);
      }
    }
    else
    {
      *((void *)this + 5) = 0;
    }
  }
  return result;
}

void PAC::PACQuery::setStringInDict(xpc_object_t *a1, const char *a2, CFStringRef theString)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (theString)
  {
    uint64_t v5 = 1023;
    ptr = _CFStringGetOrCreateCString(0, theString, v7, &v5, 0x8000100u);
    xpc_dictionary_set_string(*a1, a2, (const char *)ptr);
    if (ptr)
    {
      if (v7 != ptr) {
        CFAllocatorDeallocate(0, ptr);
      }
    }
  }
}

void sub_184242D64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  if (ptr)
  {
    if (v11 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  _Unwind_Resume(exception_object);
}

void ___ZN3PAC8PACQuery7xpcDictEv_block_invoke()
{
  v0 = (const char **)_CFGetProgname();
  uint64_t v1 = *v0;
  if (!strncmp(*v0, "neagent", 7uLL))
  {
    PAC::PACQuery::xpcDict(void)::prefix = (uint64_t)v1;
  }
  else
  {
    uint64_t v2 = SecTaskCreateFromSelf((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    if (v2)
    {
      uint64_t v3 = v2;
      CFTypeRef v4 = SecTaskCopyValueForEntitlement(v2, @"com.apple.developer.networking.networkextension", 0);
      if (v4)
      {
        PAC::PACQuery::xpcDict(void)::prefix = (uint64_t)*v0;
        CFRelease(v4);
      }
      CFRelease(v3);
    }
  }
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_xpc_object}*,PAC::PACQuery::xpcDict(void)::$_0,std::allocator<NSObject  {objcproto13OS_xpc_object}>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    xpc_release(v1);
  }
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_xpc_object}*,PAC::PACQuery::xpcDict(void)::$_0,std::allocator<NSObject  {objcproto13OS_xpc_object}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void non-virtual thunk to'HTTPConnectionCache::~HTTPConnectionCache(HTTPConnectionCache *this)
{
  uint64_t v2 = (char *)this - 32;
  HTTPConnectionCache::~HTTPConnectionCache((HTTPConnectionCache *)((char *)this - 32));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 3);

  CFAllocatorDeallocate(v3, v2);
}

{
  HTTPConnectionCache::~HTTPConnectionCache((HTTPConnectionCache *)((char *)this - 32));
}

uint64_t HTTPConnectionCache::_meta_release(HTTPConnectionCache *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

uint64_t HTTPConnectionCache::_meta_retain(HTTPConnectionCache *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

void HTTPConnectionCache::markReusedAfterAPSleepWake(HTTPConnectionCache *this)
{
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,HTTPConnectionCacheEntryWrapper *>::_visit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void ___ZN29HTTPConnectionCacheDictionary26markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 24);
  CFAllocatorRef v3 = *(std::__shared_weak_count **)(a3 + 32);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(*(void *)(v4 + 96) + 16) - *(void *)(*(void *)(v4 + 96) + 8);
  if (v5 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = (unint64_t)v5 >> 4;
    if (v8 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v8;
    }
    do
    {
      uint64_t v10 = *(void *)(*(void *)(v4 + 96) + 8);
      if (v7 < (*(void *)(*(void *)(v4 + 96) + 16) - v10) >> 4)
      {
        uint64_t v11 = v10 + v6;
        uint64_t v12 = *(void *)(v10 + v6);
        unint64_t v13 = *(std::__shared_weak_count **)(v11 + 8);
        if (v13) {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v12) {
          (*(void (**)(void))(**(void **)(*(void *)(v12 + 64) + 56) + 160))(*(void *)(*(void *)(v12 + 64) + 56));
        }
        if (v13) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v13);
        }
      }
      ++v7;
      v6 += 16;
    }
    while (v9 != v7);
  }
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void sub_184243070(_Unwind_Exception *exception_object)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPConnectionCache::purgeIdleConnections(HTTPConnectionCache *this)
{
  uint64_t v1 = *((void *)this + 12);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN19HTTPConnectionCache20purgeIdleConnectionsEv_block_invoke;
  v3[3] = &__block_descriptor_40_e5_v8__0l;
  v3[4] = this;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v1 + 96))(v1, v3);
}

uint64_t ___ZN19HTTPConnectionCache20purgeIdleConnectionsEv_block_invoke(uint64_t a1)
{
  return HTTPConnectionCache::timeoutIdleConnections(*(HTTPConnectionCache **)(a1 + 32));
}

__CFDictionary *HTTPConnectionCache::invalidateUnpurgeableConnectionsForKey(__CFDictionary *this, const HTTPConnectionCacheKey *a2)
{
  if (a2)
  {
    CFAllocatorRef v3 = this;
    HTTPConnectionCache::ensureEntries(this);
    this = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(*((void *)v3 + 5) + 32), a2);
    if (this)
    {
      uint64_t v4 = this;
      (*(void (**)(__CFDictionary *))(*(void *)this + 40))(this);
      uint64_t v5 = (HTTPConnectionCacheEntry *)*((void *)v4 + 3);
      uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 4);
      if (v6)
      {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        HTTPConnectionCacheEntry::invalidateUnpurgeableConnections(v5);
        std::__shared_weak_count::__release_shared[abi:nn180100](v6);
      }
      else
      {
        HTTPConnectionCacheEntry::invalidateUnpurgeableConnections(v5);
      }
      uint64_t v7 = *(uint64_t (**)(__CFDictionary *))(*(void *)v4 + 48);
      return (__CFDictionary *)v7(v4);
    }
  }
  return this;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,HTTPConnectionCacheEntryWrapper *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0390;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,HTTPConnectionCacheEntryWrapper *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0390;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void non-virtual thunk to'HTTPConnectionCacheDictionary::~HTTPConnectionCacheDictionary(HTTPConnectionCacheDictionary *this)
{
  uint64_t v2 = (char *)this - 16;
  *((void *)this - 2) = &unk_1ECFA4A48;
  *(void *)this = &unk_1ECFA4A68;
  *((void *)this + 1) = &unk_1ECFA0390;
  CFRelease(*((CFTypeRef *)this + 2));
  *(void *)this = &unk_1ECF9B550;
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  *((void *)this - 2) = &unk_1ECFA4A48;
  *(void *)this = &unk_1ECFA4A68;
  *((void *)this + 1) = &unk_1ECFA0390;
  CFRelease(*((CFTypeRef *)this + 2));
  *(void *)this = &unk_1ECF9B550;
}

void ___ZN29HTTPConnectionCacheDictionary18forgetCacheEntriesEb_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(HTTPConnectionCacheEntry **)(a3 + 24);
  uint64_t v6 = *(std::__shared_weak_count **)(a3 + 32);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    HTTPConnectionCacheEntry::invalidateUnpurgeableConnections(v5);
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  else
  {
    HTTPConnectionCacheEntry::invalidateUnpurgeableConnections(v5);
  }
  uint64_t v8 = *(void *)(a3 + 24);
  uint64_t v7 = *(std::__shared_weak_count **)(a3 + 32);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(unsigned int *)(v8 + 120);
  if ((int)v9 >= 1)
  {
    unint64_t v10 = v9 + 1;
    do
    {
      if (((v10 - 2) & 0x80000000) == 0)
      {
        unint64_t v11 = (v10 - 2);
        uint64_t v12 = *(void *)(*(void *)(v8 + 104) + 8);
        if (v11 <= (*(void *)(*(void *)(v8 + 104) + 16) - v12) >> 4)
        {
          unint64_t v13 = (uint64_t *)(v12 + 16 * v11);
          uint64_t v14 = *v13;
          uint64_t v15 = (std::__shared_weak_count *)v13[1];
          if (v15) {
            atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v14)
          {
            uint64_t v17 = *(void *)(v14 + 16);
            uint64_t v18 = *(void *)(v14 + 24);
            uint64_t v16 = (uint64_t *)(v14 + 16);
            if (v18 - v17 >= 1) {
              std::vector<std::shared_ptr<HTTPConnectionCacheEntry::EnqueuedRequest>>::__clear[abi:nn180100](v16);
            }
          }
          if (v15) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v15);
          }
        }
      }
      --v10;
    }
    while (v10 > 1);
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  BOOL v19 = *(HTTPConnectionCacheEntry **)(a3 + 24);
  uint64_t v20 = *(std::__shared_weak_count **)(a3 + 32);
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HTTPConnectionCacheEntry::setHasBeenForgotten(v19, *(unsigned __int8 *)(a1 + 32));
  if (v20)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  }
}

void sub_1842435F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void HTTPConnectionCache::logConnectionsAtAPSleep(HTTPConnectionCache *this)
{
}

void ___ZN29HTTPConnectionCacheDictionary23logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 24);
  CFAllocatorRef v3 = *(std::__shared_weak_count **)(a3 + 32);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(*(void *)(v4 + 96) + 16) - *(void *)(*(void *)(v4 + 96) + 8);
  if (v5 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = (unint64_t)v5 >> 4;
    if (v8 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v8;
    }
    do
    {
      uint64_t v10 = *(void *)(*(void *)(v4 + 96) + 8);
      if (v7 < (*(void *)(*(void *)(v4 + 96) + 16) - v10) >> 4)
      {
        uint64_t v11 = v10 + v6;
        uint64_t v12 = *(void *)(v10 + v6);
        unint64_t v13 = *(std::__shared_weak_count **)(v11 + 8);
        if (v13) {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v12) {
          (*(void (**)(void))(**(void **)(*(void *)(v12 + 64) + 56) + 432))(*(void *)(*(void *)(v12 + 64) + 56));
        }
        if (v13) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v13);
        }
      }
      ++v7;
      v6 += 16;
    }
    while (v9 != v7);
  }
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void sub_184243750(_Unwind_Exception *exception_object)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<HTTPConnectionCacheEntry>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6B80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTPConnectionCacheEntry>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6B80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL HTTPConnectionCache::equals(HTTPConnectionCache *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

void non-virtual thunk to'HTTPConnectionCacheEntry::~HTTPConnectionCacheEntry(HTTPConnectionCacheEntry *this)
{
  HTTPConnectionCacheEntry::~HTTPConnectionCacheEntry((HTTPConnectionCacheEntry *)((char *)this - 24));

  JUMPOUT(0x18531B6D0);
}

{
  HTTPConnectionCacheEntry::~HTTPConnectionCacheEntry((HTTPConnectionCacheEntry *)((char *)this - 24));
}

void HTTPConnectionCacheEntry::copyDebugDesc(HTTPConnectionCacheEntry *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringRef v4 = CFStringCreateWithFormat(v2, 0, @"<HTTPConnectionCacheEntry@%p>{\n", this);
  CFStringAppend(Mutable, v4);
  operator new();
}

void sub_18424418C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, const void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,CFTypeRef *a25,CFTypeRef *a26)
{
  if (a17) {
    CFRelease(a17);
  }
  _Unwind_Resume(a1);
}

CFTypeRef **std::unique_ptr<AutoStringArray>::reset[abi:nn180100](CFTypeRef **result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    CFRelease(*v1);
    JUMPOUT(0x18531B6D0);
  }
  return result;
}

void ___ZN9TCFObjectIN19TransportConnection17RefCountedWrapperEE5ClassEv_block_invoke_8972()
{
}

void sub_1842444C4(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<HTTPTransaction>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA68A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTPTransaction>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA68A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t non-virtual thunk to'HTTPTransactionWrapper::resetConnAuthState(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 176))();
}

uint64_t non-virtual thunk to'HTTPTransactionWrapper::getAuthState(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 168))();
}

void non-virtual thunk to'HTTPTransactionWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  CFAllocatorRef v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  uint64_t v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 152))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184244620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'HTTPTransactionWrapper::copyTrust(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 136))();
}

uint64_t non-virtual thunk to'HTTPTransactionWrapper::updateScheduling(HTTPTransactionWrapper *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(void, const CoreSchedulingSet *))(**((void **)this + 1) + 104))(*((void *)this + 1), a2);
}

void non-virtual thunk to'HTTPTransactionWrapper::~HTTPTransactionWrapper(HTTPTransactionWrapper *this)
{
  uint64_t v2 = (char *)this - 24;
  *((void *)this - 3) = &unk_1ECFA2338;
  *(void *)this = &unk_1ECFA2420;
  CFAllocatorRef v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v4, v2);
}

{
  std::__shared_weak_count *v1;

  *((void *)this - 3) = &unk_1ECFA2338;
  *(void *)this = &unk_1ECFA2420;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t HTTPTransactionWrapper::_meta_release(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

uint64_t HTTPTransactionWrapper::_meta_retain(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

uint64_t HTTPTransactionWrapper::resetConnAuthState(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 176))();
}

uint64_t HTTPTransactionWrapper::getAuthState(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 168))();
}

uint64_t HTTPTransactionWrapper::setTransactionMetrics(HTTPTransactionWrapper *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(void, __CFN_TransactionMetrics *))(**((void **)this + 4) + 192))(*((void *)this + 4), a2);
}

uint64_t HTTPTransactionWrapper::getProxy(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 160))();
}

void HTTPTransactionWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFAllocatorRef v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  uint64_t v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 152))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_1842448C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPTransactionWrapper::_conn_no_more_reqests_after_this_one_connectionLost(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 144))();
}

uint64_t HTTPTransactionWrapper::copyTrust(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 136))();
}

uint64_t HTTPTransactionWrapper::getConnectionIdentifier(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 128))();
}

uint64_t HTTPTransactionWrapper::rawBytesReceived(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 120))();
}

uint64_t HTTPTransactionWrapper::rawBytesSent(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 112))();
}

uint64_t HTTPTransactionWrapper::setBodyStreamBeforeOpening(HTTPTransactionWrapper *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(void, __CFReadStream *))(**((void **)this + 4) + 72))(*((void *)this + 4), a2);
}

uint64_t HTTPTransactionWrapper::setPriorityHint(HTTPTransactionWrapper *this, float a2)
{
  return (*(uint64_t (**)(float))(**((void **)this + 4) + 64))(a2);
}

uint64_t HTTPTransactionWrapper::updateScheduling(HTTPTransactionWrapper *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(void, const CoreSchedulingSet *))(**((void **)this + 4) + 104))(*((void *)this + 4), a2);
}

uint64_t HTTPTransactionWrapper::closeAndClearHandler(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 96))();
}

uint64_t HTTPTransactionWrapper::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 88))();
}

uint64_t HTTPTransactionWrapper::canScheduleAndOpenWithHandlerAsync(HTTPTransactionWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 80))();
}

uint64_t HTTPTransactionWrapper::setProperty(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 56))();
}

uint64_t HTTPTransactionWrapper::copyProperty(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

uint64_t HTTPConnectionCacheEntry::EnqueuedRequest::hash(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (!v2)
  {
    uint64_t v3 = *((void *)this + 4);
    if (!v3) {
      return v3 ^ *((void *)this + 3);
    }
    goto LABEL_9;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (!*(unsigned char *)(v2 + 40))
  {
    uint64_t v3 = v2 + 16;
LABEL_9:
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8))(v3);
    return v3 ^ *((void *)this + 3);
  }
  uint64_t v3 = 0;
  return v3 ^ *((void *)this + 3);
}

CFStringRef HTTPConnectionCacheEntry::EnqueuedRequest::copyDebugDesc(HTTPConnectionCacheEntry::EnqueuedRequest *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*((void *)this + 1);
  uint64_t v3 = *((void *)this + 3);
  uint64_t v4 = *((void *)this + 5);
  if (!v4)
  {
    uint64_t v5 = *((void *)this + 4);
    if (!v5) {
      return CFStringCreateWithFormat(v2, 0, @"<%p client=%p request=%@>", this, v3, v5);
    }
    goto LABEL_9;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (!*(unsigned char *)(v4 + 40))
  {
    uint64_t v5 = v4 + 16;
LABEL_9:
    v5 -= 16;
    return CFStringCreateWithFormat(v2, 0, @"<%p client=%p request=%@>", this, v3, v5);
  }
  uint64_t v5 = 0;
  return CFStringCreateWithFormat(v2, 0, @"<%p client=%p request=%@>", this, v3, v5);
}

void std::__shared_ptr_emplace<HTTPConnectionCacheEntry::RequestQueue>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6D40;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTPConnectionCacheEntry::RequestQueue>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6D40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_pointer<HTTPConnectionCacheEntry::EnqueuedRequest *,HTTPConnectionCacheEntry::_prepareNewRequest(MetaConnectionCacheClient *,HTTPRequestMessage const*,MetaConnectionOptions)::$_0,std::allocator<HTTPConnectionCacheEntry::EnqueuedRequest>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTPConnection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6758;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTPConnection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6758;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ___ZN24HTTPConnectionCacheEntry19setHasBeenForgottenEb_block_invoke(int a1, Tube *this)
{
  *((unsigned char *)this + 2CFRelease((char *)this - 16) = 0;
  Tube::_onqueue_cancel(this);
}

void HTTPConnectionCacheEntry::invalidateUnpurgeableConnections(HTTPConnectionCacheEntry *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 12) + 16) - *(void *)(*((void *)this + 12) + 8);
  if (v1 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = (unint64_t)v1 >> 4;
    if (v5 <= 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = v5;
    }
    do
    {
      uint64_t v7 = *(void *)(*((void *)this + 12) + 8);
      if (v4 < (*(void *)(*((void *)this + 12) + 16) - v7) >> 4)
      {
        uint64_t v8 = v7 + v3;
        uint64_t v10 = *(void *)(v7 + v3);
        uint64_t v9 = *(std::__shared_weak_count **)(v8 + 8);
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v10) {
          *(void *)(v10 + 2CFRelease((char *)this - 16) = 0;
        }
        if (v9) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v9);
        }
      }
      ++v4;
      v3 += 16;
    }
    while (v6 != v4);
  }
}

void HTTPConnectionCacheKey::setMutableProxyThatDoesntAffectHashing(void *a1, uint64_t *a2)
{
  if (a1[11] != *a2)
  {
    uint64_t v4 = (std::__shared_weak_count *)a1[14];
    a1[13] = 0;
    a1[14] = 0;
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
    uint64_t v5 = (const void *)a1[10];
    a1[10] = 0;
    if (v5) {
      CFRelease(v5);
    }
    uint64_t v7 = *a2;
    uint64_t v6 = a2[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = (std::__shared_weak_count *)a1[12];
    a1[11] = v7;
    a1[12] = v6;
    if (v8)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
  }
}

CFStringRef HTTPConnectionCacheKey::copyDebugDesc(HTTPConnectionCacheKey *this)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v3 = *((unsigned int *)this + 15);
  if (v3 >= 5)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v11 = v3;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Unknown connection key type %d", buf, 8u);
    }
    uint64_t v4 = @"ERROR - Unkown Type";
  }
  else
  {
    uint64_t v4 = off_1E5255388[v3];
  }
  uint64_t v5 = *((void *)this + 4);
  uint64_t v6 = *((unsigned int *)this + 14);
  uint64_t v7 = *((void *)this + 11);
  if (v7) {
    uint64_t v8 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  else {
    uint64_t v8 = @"No";
  }
  return CFStringCreateWithFormat(v2, 0, @"%@ connection to %@:%d <%@ proxy to %@:%d>", v4, v5, v6, v8, *((void *)this + 13), *((unsigned int *)this + 30));
}

void sub_18424536C(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  MEMORY[0x18531B6D0](v1, 0x91C40C859B4A5);
  _Unwind_Resume(a1);
}

void sub_184245458(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x91C40C859B4A5);
  _Unwind_Resume(a1);
}

void sub_184245530(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x91C40C859B4A5);
  _Unwind_Resume(a1);
}

void sub_184245784(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  MEMORY[0x18531B6D0](v1, 0xE1C40243CB742);
  _Unwind_Resume(a1);
}

NSString *quoteMaybe(NSString *a1)
{
  if (-[NSString rangeOfCharacterFromSet:](a1, "rangeOfCharacterFromSet:", [MEMORY[0x1E4F28B88] whitespaceAndNewlineCharacterSet]) == 0x7FFFFFFFFFFFFFFFLL)return a1; {
  else
  }
    return (NSString *)[NSString stringWithFormat:@"'%@'", -[NSArray componentsJoinedByString:](-[NSString componentsSeparatedByString:](a1, "componentsSeparatedByString:", @"'", "componentsJoinedByString:", @"'"];
}

void non-virtual thunk to'HTTPAuthentication::~HTTPAuthentication(HTTPAuthentication *this)
{
}

{
  HTTPAuthentication::~HTTPAuthentication((HTTPAuthentication *)((char *)this - 80));
}

{
  HTTPAuthentication::~HTTPAuthentication((HTTPAuthentication *)((char *)this - 8));
}

{
  HTTPAuthentication::~HTTPAuthentication((HTTPAuthentication *)((char *)this - 8));
}

void HTTPAuthentication::~HTTPAuthentication(HTTPAuthentication *this)
{
  *(void *)this = &unk_1ECF9F368;
  *((void *)this + 1) = &unk_1ECF9F3B0;
  *((void *)this + 10) = &unk_1ECF9F3D0;
  CFAllocatorRef v2 = (const void *)*((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 27);
  *((void *)this + 27) = 0;
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 26);
  *((void *)this + 26) = 0;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 25);
  *((void *)this + 25) = 0;
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 24);
  *((void *)this + 24) = 0;
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)*((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)*((void *)this + 21);
  *((void *)this + 21) = 0;
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)*((void *)this + 19);
  *((void *)this + 19) = 0;
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = (const void *)*((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v10) {
    CFRelease(v10);
  }
  int v11 = (const void *)*((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v11) {
    CFRelease(v11);
  }
  for (uint64_t i = 128; i != 112; i -= 8)
  {
    unint64_t v13 = *(const void **)((char *)this + i);
    *(void *)((char *)this + i) = 0;
    if (v13) {
      CFRelease(v13);
    }
  }
  uint64_t v14 = (const void *)*((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = (const void *)*((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v15) {
    CFRelease(v15);
  }
  *((void *)this + 10) = &unk_1ECF9B550;
  *((void *)this + 1) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 16));
}

CFStringRef HTTPAuthentication::copyDebugDesc(HTTPAuthentication *this)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 17);
  if (v2) {
    CFStringRef Value = (__CFString *)CFDictionaryGetValue(v2, @"kCFHTTPAuthenticationPropertyMethod");
  }
  else {
    CFStringRef Value = @"<undecided>";
  }
  if (*((_DWORD *)this + 24)) {
    uint64_t v4 = "Failed";
  }
  else {
    uint64_t v4 = "InProgress";
  }
  if (*((unsigned char *)this + 160)) {
    uint64_t v5 = "true";
  }
  else {
    uint64_t v5 = "false";
  }
  uint64_t v6 = (char *)this - 16;
  CFAllocatorRef v7 = CFGetAllocator(v6);
  return CFStringCreateWithFormat(v7, 0, @"<CFHTTPAuthentication %p>{state = %s; scheme = %@, forProxy = %s}",
           v6,
           v4,
           Value,
           v5);
}

void ___ZN18HTTPAuthentication5ClassEv_block_invoke()
{
}

void sub_1842472F0(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t ___ZN18HTTPAuthentication15isSafariProcessEv_block_invoke()
{
  uint64_t result = _CFGetProgname();
  if (result)
  {
    uint64_t v1 = *(const char **)result;
    if (*(void *)result)
    {
      uint64_t result = strncmp(*(const char **)result, "com.apple.WebKit", 0x10uLL);
      if (result && (uint64_t result = strcmp(v1, "MobileSafari"), result))
      {
        uint64_t result = strncmp(v1, "com.apple.Safari", 0x10uLL);
        BOOL v2 = result == 0;
      }
      else
      {
        BOOL v2 = 1;
      }
      HTTPAuthentication::isSafariProcess(void)::isSafaruint64_t i = v2;
    }
  }
  return result;
}

void HTTPAuthentication::HTTPAuthentication(HTTPAuthentication *this)
{
  *(void *)this = &unk_1ECFA5A48;
  *((void *)this + 1) = &unk_1ECF9C6A8;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 16), 0);
  *(void *)this = &unk_1ECF9F368;
  *((void *)this + 1) = &unk_1ECF9F3B0;
  *((void *)this + 10) = &unk_1ECF9F3D0;
  *((void *)this + 29) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((void *)this + 19) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  *((unsigned char *)this + 161) = 1;
  *((unsigned char *)this + 225) = 0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
}

uint64_t HTTPAuthentication::_initialize(HTTPAuthentication *this, __CFHTTPMessage *a2, const __CFString *a3, const void *a4, const __CFString *a5, const __CFString *a6, const __CFUUID *a7)
{
  int v10 = (int)a3;
  CFAllocatorRef v13 = CFGetAllocator((char *)this - 16);
  memset(&keyCallBacks, 0, sizeof(keyCallBacks));
  CFDictionaryValueCallBacks v31 = *(CFDictionaryValueCallBacks *)byte_1ECFABF98;
  if (a4)
  {
    CFTypeRef v14 = CFRetain(a4);
    uint64_t v15 = (const void *)*((void *)this + 24);
    *((void *)this + 24) = v14;
    if (v15) {
      CFRelease(v15);
    }
  }
  if (a5)
  {
    CFTypeRef v16 = CFRetain(a5);
    uint64_t v17 = (const void *)*((void *)this + 25);
    *((void *)this + 25) = v16;
    if (v17) {
      CFRelease(v17);
    }
  }
  if (a6)
  {
    CFTypeRef v18 = CFRetain(a6);
    BOOL v19 = (const void *)*((void *)this + 26);
    *((void *)this + 26) = v18;
    if (v19) {
      CFRelease(v19);
    }
  }
  *((_DWORD *)this + 46) = v10;
  if (!*((void *)this + 19))
  {
    CFMutableDictionaryRef v20 = CFDictionaryCreateMutable(v13, 0, &keyCallBacks, &v31);
    uint64_t v21 = (const void *)*((void *)this + 19);
    *((void *)this + 19) = v20;
    if (v21) {
      CFRelease(v21);
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (a2) {
    uint64_t v22 = (__CFHTTPMessage *)((char *)a2 + 16);
  }
  else {
    uint64_t v22 = 0;
  }
  CFStringRef v23 = HTTPMessage::copyHeaderFieldValue(v22, 0x1522142Fu);
  if (v23)
  {
    CFStringRef v24 = v23;
    *((unsigned char *)this + 160) = 0;
  }
  else
  {
    *((unsigned char *)this + 160) = 1;
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    CFStringRef v24 = HTTPMessage::copyHeaderFieldValue(v22, 0x13625354u);
    if (!v24)
    {
      *((void *)this + 11) = 4;
      *((_DWORD *)this + 24) = -1;
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
      return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 16));
    }
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  CFIndex v26 = (const void *)*((void *)this + 18);
  *((void *)this + 18) = Mutable;
  if (v26) {
    CFRelease(v26);
  }
  uint64_t v27 = CFArrayCreateMutable(v13, 0, MEMORY[0x1E4F1D510]);
  CFStringRef v29 = (const void *)*((void *)this + 29);
  *((void *)this + 29) = v27;
  if (v29)
  {
    CFRelease(v29);
    uint64_t v27 = (__CFDictionary *)*((void *)this + 29);
  }
  if (!HTTPAuthentication::parseHeader(v24, 0, *((void **)this + 18), v27, v28))
  {
    *((void *)this + 11) = 4;
    *((_DWORD *)this + 24) = -1;
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
  }
  CFRelease(v24);
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 16));
}

uint64_t HTTPAuthentication::initializeSchemes(HTTPAuthentication *this, __CFHTTPMessage *a2, const __CFString *a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](this, a2, a3);
  char v5 = v4;
  int v7 = v6;
  CFStringRef v9 = v8;
  CFURLRef v11 = v10;
  uint64_t v12 = v3;
  uint64_t v132 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v13 = (pthread_mutex_t *)(v3 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 16));
  if (*(_DWORD *)(v12 + 96)) {
    return pthread_mutex_unlock(v13);
  }
  CFTypeRef v14 = *(const void **)(v12 + 136);
  *(void *)(v12 + 136) = 0;
  if (v14) {
    CFRelease(v14);
  }
  *(unsigned char *)(v12 + 225) = v5;
  if (*(unsigned char *)(v12 + 160))
  {
    if (!v11) {
      goto LABEL_223;
    }
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (!*((unsigned char *)v11 + 40) || (uint64_t v15 = (const void *)*((void *)v11 + 21)) == 0)
    {
      CFURLRef v11 = 0;
      goto LABEL_223;
    }
    CFURLRef v16 = (const __CFURL *)CFRetain(v15);
  }
  else
  {
    CFURLRef v16 = CFHTTPMessageCopyRequestURL(v11);
  }
  CFURLRef v11 = v16;
  if (!v16) {
    goto LABEL_223;
  }
  CFTypeRef v17 = CFRetain(v16);
  CFTypeRef v18 = *(const void **)(v12 + 176);
  *(void *)(v12 + 176) = v17;
  if (v18) {
    CFRelease(v18);
  }
  if (CFURLGetBaseURL(v11))
  {
    CFURLRef v19 = CFURLCopyAbsoluteURL(v11);
    if (v19)
    {
      CFURLRef v20 = v19;
      CFRelease(v11);
      CFURLRef v11 = v20;
    }
  }
  if ((dyld_program_sdk_at_least() & 1) == 0)
  {
    CFRange v21 = CFURLGetByteRangeForComponent(v11, kCFURLComponentUserInfo, 0);
    if (v21.location != -1)
    {
      CFAllocatorRef v22 = CFGetAllocator((CFTypeRef)(v12 - 16));
      URLBytes::URLBytes((URLBytes *)&v128, v22, v11);
      memmove(&URLBytes[v21.location], &URLBytes[v21.length + 1 + v21.location], (size_t)v128 + -v21.length - v21.location - 1);
      CFRelease(v11);
      CFURLRef v11 = CFURLCreateWithBytes(v22, URLBytes, (CFIndex)v128 + ~v21.length, 0x201u, 0);
      if (URLBytes != v131) {
        CFAllocatorDeallocate(allocator, URLBytes);
      }
    }
  }
  if (*(unsigned char *)(v12 + 225))
  {
    if (v9 && CFStringCompare(v9, (CFStringRef)&gConstantCFStringValueTable[7], 1uLL))
    {
      CFStringRef Value = 0;
      if (!v11) {
        goto LABEL_30;
      }
    }
    else
    {
      CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), &gConstantCFStringValueTable[7]);
      if (!v11) {
        goto LABEL_30;
      }
    }
    if (!*(void *)(v12 + 136))
    {
      if (v9 && CFStringCompare(v9, (CFStringRef)&gConstantCFStringValueTable[7], 1uLL)) {
        goto LABEL_31;
      }
      if (Value) {
        CFTypeRef v27 = CFRetain(Value);
      }
      else {
        CFTypeRef v27 = 0;
      }
      uint64_t v55 = *(const void **)(v12 + 136);
      *(void *)(v12 + 136) = v27;
      if (v55) {
        CFRelease(v55);
      }
    }
  }
LABEL_30:
  if (!v9)
  {
    char v24 = 1;
    goto LABEL_35;
  }
LABEL_31:
  char v24 = 0;
  if (CFStringCompare(v9, @"OAuth", 1uLL))
  {
    int64_t v25 = 0;
    if (!v11) {
      goto LABEL_48;
    }
    goto LABEL_36;
  }
LABEL_35:
  int64_t v25 = CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), @"OAuth");
  if (!v11) {
    goto LABEL_48;
  }
LABEL_36:
  if (!*(void *)(v12 + 136) && ((v24 & 1) != 0 || CFStringCompare(v9, @"OAuth", 1uLL) == kCFCompareEqualTo))
  {
    CFTypeRef v26 = v25 ? CFRetain(v25) : 0;
    CFStringRef v28 = *(const void **)(v12 + 136);
    *(void *)(v12 + 136) = v26;
    if (v28) {
      CFRelease(v28);
    }
  }
LABEL_48:
  BOOL v114 = v9 == 0;
  if (v9)
  {
    if (CFStringCompare(v9, @"Negotiate", 1uLL) == kCFCompareEqualTo)
    {
      CFDictionaryRef v30 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), @"Negotiate");
      if (v30) {
        goto LABEL_56;
      }
    }
    if (CFStringCompare(v9, @"Kerberos", 1uLL)) {
      goto LABEL_51;
    }
  }
  else
  {
    CFDictionaryRef v30 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), @"Negotiate");
    if (v30) {
      goto LABEL_56;
    }
  }
  CFDictionaryRef v30 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), @"Kerberos");
  if (!v30) {
    goto LABEL_127;
  }
LABEL_56:
  if (!v11) {
    goto LABEL_126;
  }
  if (!*(unsigned char *)(v12 + 160))
  {
    if (HTTPAuthentication::isSafariProcess(void)::onceToken != -1) {
      dispatch_once(&HTTPAuthentication::isSafariProcess(void)::onceToken, &__block_literal_global_3_9474);
    }
    if (!HTTPAuthentication::isSafariProcess(void)::isSafari
      && !*(unsigned char *)(v12 + 161)
      && !*(void *)(v12 + 192)
      && !*(void *)(v12 + 200)
      && !*(void *)(v12 + 208))
    {
      *(unsigned char *)(v12 + 224) = 1;
      if (v7) {
        goto LABEL_111;
      }
LABEL_126:
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v12 + 144), @"Negotiate");
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v12 + 144), @"Kerberos");
      goto LABEL_127;
    }
  }
  CFAllocatorRef v31 = CFGetAllocator((CFTypeRef)(v12 - 16));
  CFStringRef v32 = CFURLCopyHostName(v11);
  CFTypeRef cf = lowercaseStringCopy(v31, v32);
  CFStringRef v33 = CFURLCopyScheme(v11);
  uint64_t v34 = lowercaseStringCopy(v31, v33);
  CFAllocatorRef v35 = cf;
  if (cf && v34)
  {
    int v116 = 0;
    uint64_t v115 = 0;
    int v107 = *(_DWORD *)(v12 + 184);
    CFAllocatorRef v128 = v31;
    CFAllocatorRef allocator = (CFAllocatorRef)1023;
    CString = _CFStringGetOrCreateCString(v31, cf, v131, (uint64_t *)&allocator, 0x600u);
    CFArrayRef theArray = v30;
    URLCFIndex Bytes = CString;
    if (allocator) {
      CFAllocatorRef v37 = CString;
    }
    else {
      CFAllocatorRef v37 = 0;
    }
    key = v37;
    v125.CFIndex location = (CFIndex)v31;
    v125.CFStringRef length = 1023;
    long long v38 = _CFStringGetOrCreateCString(v31, v34, v127, &v125.length, 0x600u);
    uint64_t v126 = v38;
    if (v125.length) {
      long long v40 = (const char *)v38;
    }
    else {
      long long v40 = 0;
    }
    CFStringRef v41 = *(const __CFString **)(v12 + 192);
    CFAllocatorRef v121 = v31;
    uint64_t v122 = 1023;
    if (v41)
    {
      unint64_t v42 = _CFStringGetOrCreateCString(v31, v41, v124, &v122, 0x600u);
      CFMutableDataRef v123 = v42;
      if (v122) {
        uint64_t v43 = v42;
      }
      else {
        uint64_t v43 = 0;
      }
      CFAllocatorRef alloc = (CFAllocatorRef)v43;
    }
    else
    {
      CFAllocatorRef alloc = 0;
      v124[0] = 0;
      uint64_t v122 = 0;
      CFMutableDataRef v123 = v124;
    }
    CFStringRef v45 = *(const __CFString **)(v12 + 200);
    CFAllocatorRef v117 = v31;
    uint64_t v118 = 1023;
    if (v45)
    {
      int v46 = _CFStringGetOrCreateCString(v31, v45, v120, &v118, 0x600u);
      ptr = v46;
      if (v118) {
        uint64_t v47 = (uint64_t)v46;
      }
      else {
        uint64_t v47 = 0;
      }
    }
    else
    {
      uint64_t v47 = 0;
      v120[0] = 0;
      uint64_t v118 = 0;
      ptr = v120;
    }
    uint64_t v48 = v107 | 0x8000u;
    if (v40 && !strncmp("http", v40, 4uLL))
    {
      CFDictionaryRef v30 = theArray;
      if (!GetSvcTicketForHostWithPassword(v39, (uint64_t)key, (uint64_t)"HTTP", (uint64_t)alloc, v47, (uint64_t)&v116, (uint64_t)&v115, v48, 0, *(void *)(v12 + 208)))
      {
        BOOL v44 = 1;
LABEL_92:
        if (v115) {
          free(v115);
        }
        if (ptr && v120 != ptr) {
          CFAllocatorDeallocate(v117, ptr);
        }
        if (v123 && v124 != v123) {
          CFAllocatorDeallocate(v121, v123);
        }
        if (v126 && v127 != v126) {
          CFAllocatorDeallocate((CFAllocatorRef)v125.location, v126);
        }
        if (URLBytes && v131 != URLBytes) {
          CFAllocatorDeallocate(v128, URLBytes);
        }
        CFAllocatorRef v35 = cf;
        goto LABEL_107;
      }
      int SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(v54, (uint64_t)key, (uint64_t)"http", (uint64_t)alloc, v47, (uint64_t)&v116, (uint64_t)&v115, v48, 0, *(void *)(v12 + 208));
    }
    else
    {
      int SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(v39, (uint64_t)key, (uint64_t)v40, (uint64_t)alloc, v47, (uint64_t)&v116, (uint64_t)&v115, v48, 0, *(void *)(v12 + 208));
      CFDictionaryRef v30 = theArray;
    }
    BOOL v44 = SvcTicketForHostWithPassword == 0;
    if (v7 && SvcTicketForHostWithPassword)
    {
      BOOL v44 = 1;
      *(unsigned char *)(v12 + 224) = 1;
    }
    goto LABEL_92;
  }
  BOOL v44 = 0;
  if (cf) {
LABEL_107:
  }
    CFRelease(v35);
  if (v34) {
    CFRelease(v34);
  }
  if (!v44) {
    goto LABEL_126;
  }
LABEL_111:
  CFAllocatorRef v50 = CFGetAllocator((CFTypeRef)(v12 - 16));
  if (CFURLHasDirectoryPath(v11))
  {
    HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v30, v11);
  }
  else
  {
    CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(v50, v11);
    HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v30, PathComponent);
    CFRelease(PathComponent);
  }
  if (!*(void *)(v12 + 136))
  {
    if (!v9 || CFStringCompare(v9, @"Negotiate", 1uLL) == kCFCompareEqualTo)
    {
      CFTypeRef v52 = CFRetain(v30);
      uint64_t v53 = *(const void **)(v12 + 136);
      *(void *)(v12 + 136) = v52;
      if (v53) {
        CFRelease(v53);
      }
      goto LABEL_127;
    }
LABEL_51:
    BOOL v29 = v9 == 0;
    goto LABEL_129;
  }
LABEL_127:
  if (!v9)
  {
    BOOL v29 = 1;
    goto LABEL_132;
  }
  BOOL v29 = 0;
LABEL_129:
  if (CFStringCompare(v9, @"NTLM", 1uLL))
  {
    BOOL v56 = v9 == 0;
    goto LABEL_143;
  }
LABEL_132:
  CFDictionaryRef v57 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), @"NTLM");
  if (v57)
  {
    CFAllocatorRef v58 = CFGetAllocator((CFTypeRef)(v12 - 16));
    if (CFURLHasDirectoryPath(v11))
    {
      HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v57, v11);
    }
    else
    {
      CFURLRef v59 = CFURLCreateCopyDeletingLastPathComponent(v58, v11);
      HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v57, v59);
      CFRelease(v59);
    }
    if (!*(void *)(v12 + 136) && (v29 || CFStringCompare(v9, @"NTLM", 1uLL) == kCFCompareEqualTo))
    {
      CFTypeRef v60 = CFRetain(v57);
      uint64_t v61 = *(const void **)(v12 + 136);
      *(void *)(v12 + 136) = v60;
      if (v61) {
        CFRelease(v61);
      }
    }
  }
  if (!v9)
  {
    BOOL v56 = 1;
    goto LABEL_146;
  }
  BOOL v56 = 0;
LABEL_143:
  if (CFStringCompare(v9, @"X-MobileMe-AuthToken", 1uLL))
  {
    BOOL v108 = v9 == 0;
    goto LABEL_157;
  }
LABEL_146:
  CFDictionaryRef v62 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), @"X-MobileMe-AuthToken");
  CFDictionaryRef v63 = v62;
  if (v62)
  {
    if (v11 && CFDictionaryContainsKey(v62, &unk_1EC0A41E8))
    {
      CFStringRef v64 = (const __CFString *)CFDictionaryGetValue(v63, &unk_1EC0A41E8);
      CFTypeRef v66 = AuthStringUtils::_CFStringUnquote(v64, v65);
      CFDictionarySetValue(v63, &unk_1EC0A41E8, v66);
      CFRelease(v66);
      if (!*(void *)(v12 + 136)
        && (v56 || CFStringCompare(v9, @"X-MobileMe-AuthToken", 1uLL) == kCFCompareEqualTo))
      {
        CFTypeRef v67 = CFRetain(v63);
        socklen_t v68 = *(const void **)(v12 + 136);
        *(void *)(v12 + 136) = v67;
        if (v68) {
          CFRelease(v68);
        }
      }
    }
    else
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v12 + 144), @"X-MobileMe-AuthToken");
    }
  }
  if (!v9)
  {
    BOOL v108 = 1;
    goto LABEL_160;
  }
  BOOL v108 = 0;
LABEL_157:
  if (CFStringCompare(v9, @"Digest", 1uLL))
  {
    BOOL v69 = v9 == 0;
    goto LABEL_190;
  }
LABEL_160:
  CFDictionaryRef cfa = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), @"Digest");
  if (!cfa) {
    goto LABEL_188;
  }
  CFAllocatorRef alloca = CFGetAllocator((CFTypeRef)(v12 - 16));
  if (!v11) {
    goto LABEL_187;
  }
  if (!CFDictionaryContainsKey(cfa, &unk_1EC0A41E8)) {
    goto LABEL_187;
  }
  if (!CFDictionaryContainsKey(cfa, &unk_1EC0A4108)) {
    goto LABEL_187;
  }
  CFStringRef v70 = (const __CFString *)CFDictionaryGetValue(cfa, &unk_1EC0A39D0);
  CFStringRef v71 = v70;
  if (v70)
  {
    if (CFStringCompare(v70, (CFStringRef)&unk_1EC0A4028, 1uLL)
      && CFStringCompare(v71, (CFStringRef)&unk_1EC0A4060, 1uLL))
    {
      goto LABEL_187;
    }
  }
  CFStringRef v72 = (const __CFString *)CFDictionaryGetValue(cfa, &unk_1EC0A41B0);
  if (v72)
  {
    CFArrayRef theArraya = CFStringCreateArrayBySeparatingStrings(alloca, v72, @",");
    CFIndex Count = CFArrayGetCount(theArraya);
    if (Count < 1)
    {
      CFRelease(theArraya);
    }
    else
    {
      uint64_t v74 = 1;
      do
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArraya, v74 - 1);
        MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(alloca, 0, ValueAtIndex);
        CFStringTrimWhitespace(MutableCopy);
        CFComparisonResult v77 = CFStringCompare(MutableCopy, @"auth", 1uLL);
        if (v77 == kCFCompareEqualTo) {
          CFDictionarySetValue(cfa, &unk_1EC0A41B0, MutableCopy);
        }
        CFRelease(MutableCopy);
      }
      while (v74++ < Count && v77 != kCFCompareEqualTo);
      CFRelease(theArraya);
      if (v77 == kCFCompareEqualTo) {
        goto LABEL_177;
      }
    }
LABEL_187:
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v12 + 144), @"Digest");
    goto LABEL_188;
  }
LABEL_177:
  CFStringRef v79 = CFStringCreateWithFormat(alloca, 0, @"%lx", v12);
  CFStringRef MD5HashWithString = HTTPAuthentication::createMD5HashWithString(alloca, v79, v80);
  CFRelease(v79);
  CFDictionarySetValue(cfa, &unk_1EC0A3AB0, MD5HashWithString);
  CFRelease(MD5HashWithString);
  CFStringRef v82 = (const __CFString *)CFDictionaryGetValue(cfa, &unk_1EC0A41E8);
  CFTypeRef v84 = AuthStringUtils::_CFStringUnquote(v82, v83);
  CFDictionarySetValue(cfa, &unk_1EC0A41E8, v84);
  CFRelease(v84);
  CFStringRef v85 = (const __CFString *)CFDictionaryGetValue(cfa, &unk_1EC0A4108);
  CFTypeRef v87 = AuthStringUtils::_CFStringUnquote(v85, v86);
  CFDictionarySetValue(cfa, &unk_1EC0A4108, v87);
  CFRelease(v87);
  AutoScalar::AutoScalar((AutoScalar *)&v128, 0);
  CFDictionarySetValue(cfa, &unk_1EC0A4098, allocator);
  CFAllocatorRef v128 = (CFAllocatorRef)&unk_1ECF9A500;
  if (allocator) {
    CFRelease(allocator);
  }
  CFURLGetByteRangeForComponent(v11, kCFURLComponentPath, &v125);
  URLBytes::URLBytes((URLBytes *)&v128, alloca, v11);
  CFURLRef v88 = CFURLCreateWithBytes(alloca, URLBytes, v125.location, 0x201u, 0);
  HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, cfa, v88);
  CFRelease(v88);
  if (!*(void *)(v12 + 136) && (v108 || CFStringCompare(v9, @"Digest", 1uLL) == kCFCompareEqualTo))
  {
    CFTypeRef v89 = CFRetain(cfa);
    uint64_t v90 = *(const void **)(v12 + 136);
    *(void *)(v12 + 136) = v89;
    if (v90) {
      CFRelease(v90);
    }
  }
  if (URLBytes != v131) {
    CFAllocatorDeallocate(allocator, URLBytes);
  }
LABEL_188:
  if (v9)
  {
    BOOL v69 = 0;
LABEL_190:
    if (CFStringCompare(v9, (CFStringRef)gConstantCFStringValueTable, 1uLL)) {
      goto LABEL_210;
    }
    goto LABEL_193;
  }
  BOOL v69 = 1;
LABEL_193:
  CFDictionaryRef v91 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), gConstantCFStringValueTable);
  unint64_t v92 = v91;
  if (v91)
  {
    if (v11)
    {
      if (!CFDictionaryContainsKey(v91, &unk_1EC0A41E8))
      {
        CFBooleanRef v93 = CFURLCopyHostName(v11);
        if (!v93) {
          CFBooleanRef v93 = CFRetain(&unk_1EC0A41E8);
        }
        CFDictionarySetValue(v92, &unk_1EC0A41E8, v93);
        CFRelease(v93);
      }
      if (CFURLHasDirectoryPath(v11))
      {
        HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v92, v11);
      }
      else
      {
        CFAllocatorRef v94 = CFGetAllocator((CFTypeRef)(v12 - 16));
        CFURLRef v95 = CFURLCreateCopyDeletingLastPathComponent(v94, v11);
        HTTPAuthentication::parseDomains((HTTPAuthentication *)v12, v92, v95);
        CFRelease(v95);
      }
      if (!*(void *)(v12 + 136)
        && (v69 || CFStringCompare(v9, (CFStringRef)gConstantCFStringValueTable, 1uLL) == kCFCompareEqualTo))
      {
        CFTypeRef v96 = CFRetain(v92);
        uint64_t v97 = *(const void **)(v12 + 136);
        *(void *)(v12 + 136) = v96;
        if (v97) {
          CFRelease(v97);
        }
      }
    }
    else
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v12 + 144), gConstantCFStringValueTable);
    }
  }
  if (!v9)
  {
    BOOL v114 = 1;
LABEL_214:
    double v98 = CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 144), @"PrivateToken");
    if (v11) {
      goto LABEL_215;
    }
LABEL_223:
    CFTypeRef v99 = *(CFTypeRef *)(v12 + 136);
    goto LABEL_224;
  }
  BOOL v114 = 0;
LABEL_210:
  if (CFStringCompare(v9, @"PrivateToken", 1uLL) == kCFCompareEqualTo) {
    goto LABEL_214;
  }
  double v98 = 0;
  if (!v11) {
    goto LABEL_223;
  }
LABEL_215:
  if (*(void *)(v12 + 136)) {
    goto LABEL_228;
  }
  if (!v114 && CFStringCompare(v9, @"PrivateToken", 1uLL)) {
    goto LABEL_223;
  }
  if (v98) {
    CFTypeRef v99 = CFRetain(v98);
  }
  else {
    CFTypeRef v99 = 0;
  }
  uint64_t v100 = *(const void **)(v12 + 136);
  *(void *)(v12 + 136) = v99;
  if (v100)
  {
    CFRelease(v100);
    goto LABEL_223;
  }
LABEL_224:
  if (!v99 && !*(_DWORD *)(v12 + 96))
  {
    *(void *)(v12 + 88) = 4;
    *(_DWORD *)(v12 + 96) = -1000;
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v12 + 152));
  }
  if (!v11)
  {
    CFTypeRef v101 = 0;
    char v102 = 1;
    goto LABEL_230;
  }
LABEL_228:
  CFTypeRef v101 = CFRetain(v11);
  char v102 = 0;
LABEL_230:
  uint64_t v103 = *(const void **)(v12 + 168);
  *(void *)(v12 + 168) = v101;
  if (v103) {
    CFRelease(v103);
  }
  if ((v102 & 1) == 0) {
    CFRelease(v11);
  }
  return pthread_mutex_unlock(v13);
}

void sub_1842486E8(_Unwind_Exception *a1)
{
  if ((unint64_t *)STACK[0xCC8] != &STACK[0xCD0]) {
    CFAllocatorDeallocate((CFAllocatorRef)STACK[0xCC0], (void *)STACK[0xCC8]);
  }
  _Unwind_Resume(a1);
}

void URLBytes::URLBytes(URLBytes *this, const __CFAllocator *a2, CFURLRef url)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = (char *)this + 24;
  CFIndex v6 = CFURLGetBytes(url, (UInt8 *)this + 24, 1024);
  *(void *)this = v6;
  if (v6 == -1)
  {
    CFIndex v7 = CFURLGetBytes(url, 0, 0);
    *(void *)this = v7;
    CFStringRef v8 = (UInt8 *)CFAllocatorAllocate(a2, v7, 0);
    *((void *)this + 2) = v8;
    CFURLGetBytes(url, v8, *(void *)this);
  }
}

void HTTPAuthentication::parseDomains(HTTPAuthentication *this, CFDictionaryRef theDict, const __CFURL *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, &unk_1EC0A3AE8);
  if (Value)
  {
    CFStringRef v7 = Value;
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFStringGetTypeID())
    {
      CFAllocatorRef v9 = CFGetAllocator((char *)this - 16);
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v9, 0, MEMORY[0x1E4F1D510]);
      uint64_t v19 = 1023;
      CFURLRef v11 = (AuthStringUtils *)_CFStringGetOrCreateCString(v9, v7, v21, &v19, 0x201u);
      ptr = v11;
      CFAllocatorRef v13 = AuthStringUtils::SkipToLWS(v11, v12);
      do
      {
        CFURLRef v15 = CFURLCreateWithBytes(v9, (const UInt8 *)v11, v13 - v11, 0x201u, a3);
        if (v15)
        {
          CFArrayAppendValue(Mutable, v15);
          CFRelease(v15);
        }
        CFURLRef v11 = AuthStringUtils::SkipLWS(v13, v14);
        CFAllocatorRef v13 = AuthStringUtils::SkipToLWS(v11, v16);
      }
      while (v11 != v13);
      CFDictionarySetValue(theDict, &unk_1EC0A3AE8, Mutable);
      CFRelease(Mutable);
      if (ptr)
      {
        if (v21 != ptr) {
          CFAllocatorDeallocate(v9, ptr);
        }
      }
    }
  }
  else
  {
    CFAllocatorRef v17 = CFGetAllocator((char *)this - 16);
    CFTypeRef v18 = CFArrayCreateMutable(v17, 0, MEMORY[0x1E4F1D510]);
    CFArrayAppendValue(v18, a3);
    CFDictionarySetValue(theDict, &unk_1EC0A3AE8, v18);
    CFRelease(v18);
  }
}

void sub_184248A74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
}

CFStringRef HTTPAuthentication::createMD5HashWithString(HTTPAuthentication *this, const __CFString *a2, const __CFString *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef allocator = this;
  uint64_t v13 = 1023;
  if (a2)
  {
    char v4 = _CFStringGetOrCreateCString(this, a2, v15, &v13, 0x8000100u);
    CC_LONG v5 = v13;
  }
  else
  {
    CC_LONG v5 = 0;
    v15[0] = 0;
    uint64_t v13 = 0;
    char v4 = v15;
  }
  ptr = v4;
  CC_MD5_Init(&c);
  CC_MD5_Update(&c, v4, v5);
  CC_MD5_Final(v11, &c);
  uint64_t v6 = 0;
  p_CC_MD5_CTX c = &c;
  do
  {
    unint64_t v8 = v11[v6];
    LOBYTE(p_c->A) = copyHexLog(__CFAllocator const*,unsigned char const*,long)::niceHex[v8 >> 4];
    BYTE1(p_c->A) = copyHexLog(__CFAllocator const*,unsigned char const*,long)::niceHex[v8 & 0xF];
    p_CC_MD5_CTX c = (CC_MD5_CTX *)((char *)p_c + 2);
    ++v6;
  }
  while (v6 != 16);
  LOBYTE(p_c->A) = 0;
  CFStringRef v9 = CFStringCreateWithCString(this, (const char *)&c, 0x8000100u);
  if (ptr && v15 != ptr) {
    CFAllocatorDeallocate(allocator, ptr);
  }
  return v9;
}

void sub_184248BF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
}

__CFString *lowercaseStringCopy(const __CFAllocator *a1, CFStringRef theString)
{
  if (!theString) {
    return 0;
  }
  MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(a1, 0, theString);
  CFStringLowercase(MutableCopy, 0);
  CFRelease(theString);
  return MutableCopy;
}

uint64_t HTTPAuthentication::parseHeader(const __CFString *this, const __CFString *a2, void *cf, __CFDictionary *a4, __CFArray *a5)
{
  int v46 = (int)a2;
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef allocator = CFGetAllocator(cf);
  uint64_t v52 = 1023;
  CFAllocatorRef alloc = allocator;
  uint64_t v6 = _CFStringGetOrCreateCString(allocator, this, v54, &v52, 0x201u);
  ptr = v6;
  unint64_t v7 = *v6;
  if (!*v6)
  {
LABEL_102:
    uint64_t v42 = 1;
    goto LABEL_103;
  }
  char v48 = 0;
  CFStringRef v8 = 0;
  BOOL v9 = 0;
  BOOL v10 = 0;
  if (v46) {
    CFMutableDictionaryRef Mutable = (__CFDictionary *)cf;
  }
  else {
    CFMutableDictionaryRef Mutable = 0;
  }
  uint64_t v12 = MEMORY[0x1E4F14390];
  value = (void *)*MEMORY[0x1E4F1CFD0];
  while (!v10)
  {
    if (v8 && v48)
    {
      if (v7 != 34) {
        break;
      }
    }
    else if (v7 != 34)
    {
      if ((char)v7 < 32) {
        goto LABEL_98;
      }
      uint64_t v13 = (AuthStringUtils *)v6;
      do
      {
        if (memchr("()<>@,;:\\\"[]?={} \t", v7, 0x13uLL)) {
          break;
        }
        int v41 = *((char *)v13 + 1);
        uint64_t v13 = (AuthStringUtils *)((char *)v13 + 1);
        LODWORD(v7) = v41;
      }
      while (v41 > 31);
      CFIndex v16 = v13 - (AuthStringUtils *)v6;
      if (v13 == (AuthStringUtils *)v6) {
        goto LABEL_98;
      }
LABEL_19:
      CFStringRef v18 = CFStringCreateWithBytes(alloc, v6, v16, 0x201u, 0);
      char v19 = 1;
      if (!v18) {
        goto LABEL_98;
      }
      goto LABEL_20;
    }
    CFAllocatorRef v31 = v6 + 1;
    for (uint64_t i = (AuthStringUtils *)v31; ; uint64_t i = (AuthStringUtils *)((char *)v33 + 1))
    {
      CFStringRef v33 = AuthStringUtils::SkipLWS(i, (const unsigned __int8 *)v7);
      uint64_t v34 = v33;
      unsigned int v35 = *(unsigned __int8 *)v33;
      if (v35 < 0x20 || v35 == 34 && *((unsigned char *)v33 - 1) != 92) {
        break;
      }
    }
    CFStringRef v36 = CFStringCreateWithBytes(alloc, v31, v33 - (AuthStringUtils *)v31, 0x201u, 0);
    CFStringRef v18 = v36;
    char v19 = 0;
    if (*(unsigned char *)v34 == 34) {
      uint64_t v13 = (AuthStringUtils *)((char *)v34 + 1);
    }
    else {
      uint64_t v13 = v34;
    }
    if (!v36) {
      goto LABEL_98;
    }
LABEL_20:
    if (v9)
    {
      int v20 = *(unsigned __int8 *)v13;
      if (v20 != 61) {
        CFMutableDictionaryRef Mutable = 0;
      }
      if (v46 && v20 != 61)
      {
        CFRelease(v18);
        goto LABEL_98;
      }
    }
    if (Mutable)
    {
      if (v10 || v8)
      {
        if (v8)
        {
          if (v10 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "_CFHTTPAuthenticationParseHeader(): No scheme or not expecting base64", buf, 2u);
          }
          unsigned int CanonicalString = _findCanonicalString(v8, 0);
          if (CanonicalString == 571) {
            CFStringRef v30 = v8;
          }
          else {
            CFStringRef v30 = (const __CFString *)&gConstantCFStringValueTable[7 * ((CanonicalString >> 20) & 0x3FF)];
          }
          CFDictionarySetValue(Mutable, v30, v18);
          if ((v19 & 1) == 0) {
            CFDictionarySetValue(Mutable, @"kCFHTTPAuthenticationUsedQuotes", value);
          }
          CFRelease(v8);
        }
        else
        {
          if (!v10 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "_CFHTTPAuthenticationParseHeader(): Parse error", buf, 2u);
          }
          CFDictionarySetValue(Mutable, &unk_1EC0A3A40, v18);
        }
        CFStringRef v8 = 0;
      }
      else
      {
        uint64_t v13 = AuthStringUtils::SkipLWS(v13, v17);
        if (*(unsigned char *)v13 == 61)
        {
          CFStringRef v8 = (const __CFString *)CFRetain(v18);
          BOOL v10 = 0;
          uint64_t v13 = (AuthStringUtils *)((char *)v13 + 1);
        }
        else
        {
          CFAllocatorRef v37 = (__CFString *)AuthStringUtils::_canonicalSchemeName(v18, v21);
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
          CFDictionarySetValue(Mutable, @"kCFHTTPAuthenticationPropertyMethod", v37);
          CFDictionarySetValue((CFMutableDictionaryRef)cf, v37, Mutable);
          CFRelease(v37);
          CFRelease(Mutable);
          CFStringRef v8 = 0;
          BOOL v10 = v37 == @"Negotiate" || v37 == @"NTLM";
        }
      }
    }
    else
    {
      if (v8 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "_CFHTTPAuthenticationParseHeader() no key found!", buf, 2u);
      }
      uint64_t v22 = (__CFString *)AuthStringUtils::_canonicalSchemeName(v18, (const __CFString *)v17);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
      CFDictionarySetValue(Mutable, @"kCFHTTPAuthenticationPropertyMethod", v22);
      CFDictionarySetValue((CFMutableDictionaryRef)cf, v22, Mutable);
      BOOL v10 = v22 == @"Negotiate" || v22 == @"NTLM" || v22 == @"Nego2";
      gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v23);
      if (objc_opt_class())
      {
        Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenuint64_t Challenge = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v26);
        char v48 = -[__CFString isEqualToString:](v22, "isEqualToString:", objc_msgSend(*(id *)(v28 + 304), "httpAuthenticationScheme", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge));
      }
      if (v48) {
        CFArrayAppendValue(a4, Mutable);
      }
      CFRelease(v22);
      CFRelease(Mutable);
    }
    CFRelease(v18);
    long long v40 = AuthStringUtils::SkipLWS(v13, v39);
    uint64_t v6 = (UInt8 *)v40;
    unint64_t v7 = *(unsigned __int8 *)v40;
    if (v7 == 44)
    {
      if (v8) {
        goto LABEL_99;
      }
      BOOL v9 = !v10;
      if (v10) {
        CFMutableDictionaryRef Mutable = 0;
      }
      uint64_t v6 = (UInt8 *)AuthStringUtils::SkipLWS((AuthStringUtils *)((char *)v40 + 1), (const unsigned __int8 *)v7);
      BOOL v10 = 0;
      unint64_t v7 = *v6;
      if (!*v6) {
        goto LABEL_102;
      }
    }
    else
    {
      BOOL v9 = 0;
      if (!*(unsigned char *)v40)
      {
        if (v8) {
          goto LABEL_99;
        }
        goto LABEL_102;
      }
    }
  }
  if ((v7 & 0x80) != 0) {
    goto LABEL_98;
  }
  uint64_t v13 = (AuthStringUtils *)v6;
  while (2)
  {
    int v14 = *(_DWORD *)(v12 + 4 * v7 + 60) & 0x500;
    if (v10)
    {
      if (!v14 && (v7 > 0x3D || ((1 << v7) & 0x2000880000000000) == 0)) {
        break;
      }
      goto LABEL_17;
    }
    if (v14 || (v7 - 45) <= 0x32 && ((1 << (v7 - 45)) & 0x4000000010001) != 0)
    {
LABEL_17:
      int v15 = *((char *)v13 + 1);
      uint64_t v13 = (AuthStringUtils *)((char *)v13 + 1);
      LODWORD(v7) = v15;
      if (v15 < 0) {
        break;
      }
      continue;
    }
    break;
  }
  CFIndex v16 = v13 - (AuthStringUtils *)v6;
  if (v13 != (AuthStringUtils *)v6) {
    goto LABEL_19;
  }
LABEL_98:
  if (v8) {
LABEL_99:
  }
    CFRelease(v8);
  CFDictionaryRemoveAllValues((CFMutableDictionaryRef)cf);
  CFArrayRemoveAllValues(a4);
  uint64_t v42 = 0;
LABEL_103:
  if (ptr && v54 != ptr) {
    CFAllocatorDeallocate(allocator, ptr);
  }
  return v42;
}

void sub_1842492D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,CFAllocatorRef allocator,uint64_t a23,void *ptr)
{
  if (ptr)
  {
    if (a12 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  _Unwind_Resume(exception_object);
}

void _AuthConnectionSpecificRelease(CFAllocatorRef allocator, void *ptr)
{
  char v4 = (const void *)ptr[2];
  if (v4) {
    CFRelease(v4);
  }
  CC_LONG v5 = (const void *)ptr[1];
  if (v5) {
    CFRelease(v5);
  }
  if (*ptr) {
    NtlmGeneratorRelease();
  }

  CFAllocatorDeallocate(allocator, ptr);
}

void *_AuthConnectionSpecificRetain(const __CFAllocator *a1, void *a2)
{
  uint64_t v3 = CFAllocatorAllocate(a1, 32, 0);
  *uint64_t v3 = *a2;
  CFTypeRef v4 = (CFTypeRef)a2[2];
  if (v4) {
    CFTypeRef v4 = CFRetain(v4);
  }
  v3[2] = v4;
  CFTypeRef v5 = (CFTypeRef)a2[1];
  if (v5) {
    CFTypeRef v5 = CFRetain(v5);
  }
  v3[1] = v5;
  return v3;
}

BOOL HTTPAuthentication::isSecondNTLMTransaction(HTTPAuthentication *this)
{
  BOOL v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 17);
  BOOL v5 = v3
    && (CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v3, @"kCFHTTPAuthenticationPropertyMethod")) != 0
    && CFStringCompare(Value, @"NTLM", 1uLL) == kCFCompareEqualTo
    && CFDictionaryGetValue(*((CFDictionaryRef *)this + 17), &unk_1EC0A3A40) != 0;
  pthread_mutex_unlock(v2);
  return v5;
}

const void *HTTPAuthentication::getProperty_Locked(HTTPAuthentication *this, CFStringRef theString)
{
  int CanonicalString = _findCanonicalString(theString, 8u);
  if (CanonicalString == 396743971)
  {
    uint64_t v6 = &kCFHTTPHeaderProxyAuthenticate;
    if (!*((unsigned char *)this + 160)) {
      uint64_t v6 = &kCFHTTPHeaderWWWAuthenticate;
    }
    return *(const void **)v6;
  }
  else if (CanonicalString == 397784379)
  {
    return (const void *)*((void *)this + 17);
  }
  else if (*((void *)this + 17))
  {
    CFDictionaryRef v7 = (const __CFDictionary *)*((void *)this + 17);
    return CFDictionaryGetValue(v7, theString);
  }
  else if (CanonicalString == 422655784)
  {
    return (const void *)*((void *)this + 18);
  }
  else
  {
    return 0;
  }
}

BOOL HTTPAuthentication::requiresAccountDomain(HTTPAuthentication *this)
{
  BOOL v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  BOOL v3 = HTTPAuthentication::getProperty_Locked(this, @"kCFHTTPAuthenticationPropertyMethod") == @"NTLM";
  pthread_mutex_unlock(v2);
  return v3;
}

const __CFArray *HTTPAuthentication::copyRealm(HTTPAuthentication *this)
{
  BOOL v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  CFStringRef Property_Locked = (const __CFString *)HTTPAuthentication::getProperty_Locked(this, @"Realm");
  if (Property_Locked)
  {
    CFStringRef v4 = Property_Locked;
    CFAllocatorRef v5 = CFGetAllocator((char *)this - 16);
    CFStringRef Copy = CFStringCreateCopy(v5, v4);
  }
  else
  {
    CFArrayRef v9 = (const __CFArray *)HTTPAuthentication::getProperty_Locked(this, @"Domain");
    CFArrayRef v7 = v9;
    if (!v9) {
      goto LABEL_4;
    }
    if (!CFArrayGetCount(v9))
    {
      CFArrayRef v7 = 0;
      goto LABEL_4;
    }
    CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v7, 0);
    CFStringRef Copy = CFURLCopyHostName(ValueAtIndex);
  }
  CFArrayRef v7 = (const __CFArray *)Copy;
LABEL_4:
  pthread_mutex_unlock(v2);
  return v7;
}

void *HTTPAuthentication::copyServerSupportedSchemes(HTTPAuthentication *this)
{
  BOOL v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  int v3 = *((_DWORD *)this + 24);
  pthread_mutex_unlock(v2);
  if (v3) {
    return 0;
  }
  pthread_mutex_lock(v2);
  if (*((void *)this + 18))
  {
    CFAllocatorRef v5 = CFGetAllocator((char *)this - 16);
    CFDictionaryRef v6 = (const __CFDictionary *)*((void *)this + 18);
    CFIndex Count = CFDictionaryGetCount(v6);
    if (Count)
    {
      CFIndex v8 = Count;
      CFArrayRef v9 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      CFDictionaryGetKeysAndValues(v6, v9, 0);
      CFStringRef v4 = CFArrayCreate(v5, v9, v8, MEMORY[0x1E4F1D510]);
      free(v9);
    }
    else
    {
      EmptyArray = (const void *)AutoArray::getEmptyArray(0);
      CFStringRef v4 = (void *)CFRetain(EmptyArray);
    }
  }
  else
  {
    CFStringRef v4 = 0;
  }
  pthread_mutex_unlock(v2);
  return v4;
}

CFDictionaryRef HTTPAuthentication::applyHeaderToRequest(CFDictionaryRef *this, __CFHTTPMessage *a2, const void *a3)
{
  CFDictionaryRef v6 = (pthread_mutex_t *)(this + 2);
  pthread_mutex_lock((pthread_mutex_t *)(this + 2));
  if (!*((_DWORD *)this + 24))
  {
    CFStringRef Property_Locked = (void *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"kCFHTTPAuthenticationPropertyMethod");
    if (Property_Locked == &unk_1EC09E368)
    {
      CFStringRef Value = CFDictionaryGetValue(this[19], a3);
      NTLMHeaderForRequest_MaCC_MD5_CTX c = HTTPAuthentication::createNTLMHeaderForRequest_Mac((uint64_t)this, Value, a3);
    }
    else
    {
      if (Property_Locked != &unk_1EC09E330) {
        goto LABEL_2;
      }
      CFDictionaryGetValue(this[19], a3);
      NTLMHeaderForRequest_MaCC_MD5_CTX c = HTTPAuthentication::createNegotiateHeaderForRequest_Mac();
    }
    CFStringRef v12 = NTLMHeaderForRequest_Mac;
    if (NTLMHeaderForRequest_Mac)
    {
      int v13 = *((unsigned __int8 *)this + 160);
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
      {
        int v16 = *((unsigned __int8 *)this + 160);
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        int v13 = v16;
      }
      if (a2) {
        int v14 = (__CFHTTPMessage *)((char *)a2 + 16);
      }
      else {
        int v14 = 0;
      }
      if (v13) {
        unsigned int v15 = 327316331;
      }
      else {
        unsigned int v15 = 294761131;
      }
      HTTPMessage::setHeaderFieldStringValue(v14, v15, v12);
      CFRelease(v12);
    }
  }
LABEL_2:
  CFDictionaryRef v7 = this[11];
  pthread_mutex_unlock(v6);
  return v7;
}

CFStringRef HTTPAuthentication::createNTLMHeaderForRequest_Mac(uint64_t a1, unsigned char *a2, const void *a3)
{
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)(a1 - 16));
  if (a2)
  {
    a2[24] = 0;
  }
  else
  {
    id v13 = 0;
    long long value = 0u;
    *(_OWORD *)CFTypeRef cf = 0u;
    int ClientRequest = NtlmGeneratorCreate();
    if (ClientRequest || (int ClientRequest = NtlmCreateClientRequest()) != 0)
    {
      *(void *)(a1 + 88) = 2;
      *(_DWORD *)(a1 + 96) = ClientRequest;
      CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 152));
      return 0;
    }
    cf[0] = (id)[v13 base64EncodedStringWithOptions:0];
    CFRelease(v13);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 152), a3, &value);
    CFRelease(cf[0]);
    a2 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 152), a3);
    a2[24] = 1;
  }
  if (!*((void *)a2 + 2) || !*(void *)a2 && !*((void *)a2 + 1)) {
    return 0;
  }
  CFStringRef v7 = CFStringCreateWithFormat(v6, 0, @"NTLM %@", *((void *)a2 + 2));
  if (!*(void *)a2)
  {
    CFIndex v8 = (const void *)*((void *)a2 + 1);
    if (v8)
    {
      CFRelease(v8);
      *((void *)a2 + 1) = 0;
    }
  }
  if (!v7)
  {
    *(void *)(a1 + 88) = 1;
    *(_DWORD *)(a1 + 96) = 12;
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 152));
  }
  return v7;
}

CFStringRef HTTPAuthentication::createNegotiateHeaderForRequest_Mac()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  int v3 = v2;
  CFAllocatorRef v5 = v4;
  uint64_t v6 = v0;
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  if (!v4)
  {
    CFStringRef v7 = v1;
    v66[0] = 0u;
    long long value = 0u;
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v0 + 152), v1, &value);
    CFAllocatorRef v5 = CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 152), v7);
    v5[24] = 1;
  }
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)(v6 - 16));
  if (*(unsigned char *)(v6 + 160)) {
    CFURLRef v9 = (const __CFURL *)CFRetain(*(CFTypeRef *)(v6 + 168));
  }
  else {
    CFURLRef v9 = CFHTTPMessageCopyRequestURL(v3);
  }
  CFURLRef v10 = v9;
  if (!v9)
  {
    CFStringRef v17 = 0;
    CFURLRef v12 = 0;
LABEL_14:
    LOBYTE(v15) = 1;
    goto LABEL_15;
  }
  CFURLRef v11 = CFURLCopyAbsoluteURL(v9);
  CFURLRef v12 = v11;
  if (!v11)
  {
    CFStringRef v17 = 0;
    goto LABEL_14;
  }
  CFStringRef v13 = CFURLCopyHostName(v11);
  CFStringRef v14 = CFURLCopyScheme(v12);
  CFStringRef v15 = v14;
  if (!v13)
  {
    CFStringRef v17 = 0;
    if (!v14) {
      goto LABEL_15;
    }
    goto LABEL_26;
  }
  MutableCFStringRef Copy = CFStringCreateMutableCopy(v8, 0, v13);
  CFStringRef v17 = MutableCopy;
  if (!MutableCopy)
  {
    CFStringRef v17 = v13;
    if (v15) {
      goto LABEL_26;
    }
LABEL_15:
    int v18 = 0;
    CFStringRef v19 = 0;
    BOOL v20 = v17 != 0;
    goto LABEL_16;
  }
  CFStringLowercase(MutableCopy, 0);
  CFRelease(v13);
  if (!v15) {
    goto LABEL_15;
  }
LABEL_26:
  uint64_t v22 = CFStringCreateMutableCopy(v8, 0, v15);
  CFStringRef v19 = v22;
  if (v22)
  {
    CFStringLowercase(v22, 0);
    CFRelease(v15);
    if (v17) {
      goto LABEL_28;
    }
  }
  else
  {
    CFStringRef v19 = v15;
    if (v17)
    {
LABEL_28:
      memset(length, 0, sizeof(length));
      *(void *)&long long value = v8;
      *((void *)&value + 1) = 1023;
      CString = _CFStringGetOrCreateCString(v8, v17, (UInt8 *)v66 + 8, (uint64_t *)&value + 1, 0x600u);
      *(void *)&v66[0] = CString;
      if (*((void *)&value + 1)) {
        char v24 = CString;
      }
      else {
        char v24 = 0;
      }
      CFAllocatorRef v61 = v8;
      uint64_t v62 = 1023;
      int64_t v25 = _CFStringGetOrCreateCString(v8, v19, v64, &v62, 0x600u);
      CFDictionaryRef v63 = v25;
      if (v62) {
        CFTypeRef v27 = (char *)v25;
      }
      else {
        CFTypeRef v27 = 0;
      }
      CFStringRef v28 = *(const __CFString **)(v6 + 192);
      CFAllocatorRef v57 = v8;
      uint64_t v58 = 1023;
      __s2 = v27;
      if (v28)
      {
        BOOL v29 = _CFStringGetOrCreateCString(v8, v28, v60, &v58, 0x600u);
        CFURLRef v59 = v29;
        if (v58) {
          CFStringRef v30 = v29;
        }
        else {
          CFStringRef v30 = 0;
        }
      }
      else
      {
        CFStringRef v30 = 0;
        v60[0] = 0;
        uint64_t v58 = 0;
        CFURLRef v59 = v60;
      }
      CFStringRef v31 = *(const __CFString **)(v6 + 200);
      CFAllocatorRef allocator = v8;
      uint64_t v54 = 1023;
      uint64_t v49 = (uint64_t)v30;
      uint64_t v51 = (uint64_t)v24;
      if (v31)
      {
        CFStringRef v32 = _CFStringGetOrCreateCString(v8, v31, v56, &v54, 0x600u);
        ptr = v32;
        if (v54) {
          uint64_t v33 = (uint64_t)v32;
        }
        else {
          uint64_t v33 = 0;
        }
        uint64_t v34 = (*(_DWORD *)(v6 + 184) + 0x8000);
        if (*(unsigned char *)(v6 + 161) || v33) {
          goto LABEL_51;
        }
      }
      else
      {
        v56[0] = 0;
        uint64_t v54 = 0;
        ptr = v56;
        uint64_t v34 = (*(_DWORD *)(v6 + 184) + 0x8000);
        if (*(unsigned char *)(v6 + 161))
        {
          uint64_t v33 = 0;
          goto LABEL_51;
        }
      }
      uint64_t v33 = 0;
      if (!*(void *)(v6 + 208))
      {
        int v35 = 0;
        goto LABEL_52;
      }
LABEL_51:
      int v35 = 1;
      if (*(unsigned char *)(v6 + 160)) {
        goto LABEL_93;
      }
LABEL_52:
      if (HTTPAuthentication::isSafariProcess(void)::onceToken != -1)
      {
        uint64_t v47 = v34;
        uint64_t v48 = v33;
        dispatch_once(&HTTPAuthentication::isSafariProcess(void)::onceToken, &__block_literal_global_3_9474);
        uint64_t v33 = v48;
        uint64_t v34 = v47;
      }
      if (((HTTPAuthentication::isSafariProcess(void)::isSafari == 0) & ~v35) != 0)
      {
        int SvcTicketForHostWithPassword = -1;
      }
      else
      {
LABEL_93:
        if (__s2 && (v36 = v34, v37 = v33, v38 = strncmp("http", __s2, 4uLL), uint64_t v33 = v37, v34 = v36, !v38))
        {
          int SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(v26, v51, (uint64_t)"HTTP", v49, v37, (uint64_t)length, (uint64_t)&length[1], v36, 0, *(void *)(v6 + 208));
          if (SvcTicketForHostWithPassword) {
            int SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(v40, v51, (uint64_t)"http", v49, v37, (uint64_t)length, (uint64_t)&length[1], v36, 0, *(void *)(v6 + 208));
          }
        }
        else
        {
          int SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(v26, v51, (uint64_t)__s2, v49, v33, (uint64_t)length, (uint64_t)&length[1], v34, 0, *(void *)(v6 + 208));
        }
      }
      int v41 = *(void **)&length[1];
      if (!SvcTicketForHostWithPassword && *(void *)&length[1] && length[0])
      {
        CFDataRef v42 = CFDataCreateWithBytesNoCopy(v8, *(const UInt8 **)&length[1], length[0], (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
        uint64_t v43 = (const void *)*((void *)v5 + 2);
        if (v43) {
          CFRelease(v43);
        }
        id v44 = (id)[(__CFData *)v42 base64EncodedStringWithOptions:0];
        *((void *)v5 + 2) = v44;
        if (!v44 || (CFStringRef v45 = CFStringCreateWithFormat(v8, 0, @"Negotiate %@", v44)) == 0)
        {
          *(void *)(v6 + 88) = 1;
          *(_DWORD *)(v6 + 96) = 12;
          CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v6 + 152));
          CFStringRef v45 = 0;
        }
        CFRelease(v42);
      }
      else
      {
        *(void *)(v6 + 88) = 4;
        *(_DWORD *)(v6 + 96) = -1001;
        CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v6 + 152));
        CFStringRef v45 = 0;
        CFStringRef v21 = 0;
        if (!v41) {
          goto LABEL_73;
        }
      }
      free(v41);
      CFStringRef v21 = v45;
LABEL_73:
      if (ptr && v56 != ptr) {
        CFAllocatorDeallocate(allocator, ptr);
      }
      if (v59 && v60 != v59) {
        CFAllocatorDeallocate(v57, v59);
      }
      if (v63 && v64 != v63) {
        CFAllocatorDeallocate(v61, v63);
      }
      if (*(void *)&v66[0] && (_OWORD *)((char *)v66 + 8) != *(_OWORD **)&v66[0]) {
        CFAllocatorDeallocate((CFAllocatorRef)value, *(void **)&v66[0]);
      }
      CFRelease(v19);
      CFRelease(v17);
      goto LABEL_86;
    }
  }
  LOBYTE(v15) = 0;
  BOOL v20 = 0;
  int v18 = 1;
LABEL_16:
  *(void *)(v6 + 88) = 1;
  *(_DWORD *)(v6 + 96) = 12;
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v6 + 152));
  if (!v18)
  {
    if (!v20) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  CFRelease(v19);
  if (v20) {
LABEL_20:
  }
    CFRelease(v17);
LABEL_21:
  CFStringRef v21 = 0;
  if ((v15 & 1) == 0) {
LABEL_86:
  }
    CFRelease(v12);
  if (v10) {
    CFRelease(v10);
  }
  return v21;
}

void sub_184249FE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  CFStringRef v15 = (void *)STACK[0x480];
  if (STACK[0x480] && (void *)a12 != v15) {
    CFAllocatorDeallocate((CFAllocatorRef)STACK[0x470], v15);
  }
  int v16 = (void *)STACK[0x898];
  if (STACK[0x898] && (void *)a13 != v16) {
    CFAllocatorDeallocate((CFAllocatorRef)STACK[0x888], v16);
  }
  CFStringRef v17 = (void *)STACK[0xCB0];
  if (STACK[0xCB0])
  {
    if ((void *)a14 != v17) {
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0xCA0], v17);
    }
  }
  _Unwind_Resume(a1);
}

const __CFString *HTTPAuthentication::lockAndCopyProperty(HTTPAuthentication *this, const __CFString *a2)
{
  CFStringRef v4 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  CFStringRef Property_Locked = (const __CFString *)HTTPAuthentication::getProperty_Locked(this, a2);
  CFStringRef v6 = Property_Locked;
  if (Property_Locked)
  {
    CFTypeID v7 = CFGetTypeID(Property_Locked);
    if (v7 == CFStringGetTypeID())
    {
      CFAllocatorRef v8 = CFGetAllocator(v6);
      CFStringRef Copy = CFStringCreateCopy(v8, v6);
    }
    else if (v7 == CFArrayGetTypeID())
    {
      CFAllocatorRef v10 = CFGetAllocator(v6);
      CFStringRef Copy = (const __CFString *)CFArrayCreateCopy(v10, (CFArrayRef)v6);
    }
    else
    {
      CFStringRef Copy = (const __CFString *)CFRetain(v6);
    }
    CFStringRef v6 = Copy;
  }
  pthread_mutex_unlock(v4);
  return v6;
}

__n128 HTTPAuthentication::applyCredentials_Locked(CFMutableDictionaryRef *this, __CFHTTPMessage *a2, CFDictionaryRef theDict, CFStreamError *a4)
{
  if (theDict)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"kCFHTTPAuthenticationUsername");
    CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(theDict, @"kCFHTTPAuthenticationPassword");
    CFStringRef v10 = (const __CFString *)CFDictionaryGetValue(theDict, @"kCFHTTPAuthenticationAccountDomain");
    CFURLRef v11 = CFDictionaryGetValue(theDict, @"kCFHTTPAuthenticationOAuthToken");
    CFNumberRef number = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kCFHTTPAuthenticationOAuth1PID");
    CFURLRef v12 = CFDictionaryGetValue(theDict, @"kCFHTTPAuthenticationOAuth1Account");
  }
  else
  {
    CFNumberRef number = 0;
    CFStringRef v10 = 0;
    CFStringRef Value = 0;
    CFStringRef v9 = 0;
    CFURLRef v11 = 0;
    CFURLRef v12 = 0;
  }
  CFStringRef v13 = (CFStreamError *)v44;
  if (a4) {
    CFStringRef v14 = a4;
  }
  else {
    CFStringRef v14 = (CFStreamError *)v44;
  }
  CFStringRef v15 = (__n128 *)(this + 11);
  if (!*((_DWORD *)this + 24))
  {
    if (a4) {
      CFStringRef v13 = a4;
    }
    v13->CFStreamError error = 0;
    v14->CFIndex domain = 0;
    CFStringRef Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"kCFHTTPAuthenticationPropertyMethod");
    CFStringRef v17 = Property_Locked;
    if (!Property_Locked
      || (Property_Locked != @"Negotiate" ? (BOOL v18 = Property_Locked == @"NTLM") : (BOOL v18 = 1),
          !v18 ? (BOOL v19 = Property_Locked == @"OAuth") : (BOOL v19 = 1),
          !v19 ? (BOOL v20 = Property_Locked == @"PrivateToken") : (BOOL v20 = 1),
          !v20 ? (BOOL v21 = Property_Locked == (__CFString *)&gConstantCFStringValueTable[7]) : (BOOL v21 = 1),
          !v21))
    {
      if (!Value || Value == @"Single Sign-On")
      {
        this[11] = (CFMutableDictionaryRef)4;
        *((_DWORD *)this + 24) = -1001;
        CFDictionaryRemoveAllValues(this[19]);
      }
      if (CFEqual(v17, @"X-MobileMe-AuthToken")) {
        BOOL v22 = 0;
      }
      else {
        BOOL v22 = v9 == 0;
      }
      if (v22)
      {
        this[11] = (CFMutableDictionaryRef)4;
        *((_DWORD *)this + 24) = -1002;
        CFDictionaryRemoveAllValues(this[19]);
      }
    }
    if (!*((_DWORD *)this + 24))
    {
      int CanonicalString = _findCanonicalString(v17, 1u);
      if (CanonicalString <= 5316626)
      {
        if (CanonicalString == 40960)
        {
          int v40 = HTTPAuthentication::setBasicAuthenticationOnRequest_NoAuthFromResponse(a2, Value, v9, (const __CFString *)*((unsigned __int8 *)this + 160), this + 11, v28);
          goto LABEL_74;
        }
        if (CanonicalString != 1097731)
        {
          if (CanonicalString == 2146311)
          {
            CFStringRef v29 = (const __CFString *)AuthStringUtils::_CFStringQuote(Value, v25);
            if (v29)
            {
              CFStringRef v30 = v29;
              HTTPAuthentication::setDigestAuthenticationOnRequest(this, (char *)a2, v29, v9);
              CFRelease(v30);
              goto LABEL_75;
            }
            this[11] = (CFMutableDictionaryRef)4;
            int v41 = -1001;
LABEL_70:
            *((_DWORD *)this + 24) = v41;
            CFDictionaryRemoveAllValues(this[19]);
            goto LABEL_34;
          }
LABEL_67:
          this[11] = (CFMutableDictionaryRef)4;
          int v41 = -1000;
          goto LABEL_70;
        }
      }
      else
      {
        if (CanonicalString <= 7381018)
        {
          if (CanonicalString == 5316627)
          {
            HTTPAuthentication::setNegotiateAuthenticationOnRequest((HTTPAuthentication *)this, a2, v26, v27);
            goto LABEL_73;
          }
          if (CanonicalString == 6324248)
          {
            HTTPAuthentication::setNTLMAuthenticationOnRequest(this, a2, Value, v9, v10);
LABEL_73:
            int v40 = *((_DWORD *)this + 24) == 0;
LABEL_74:
            if (!v40) {
              goto LABEL_34;
            }
LABEL_75:
            _CFHTTPMessageSetAuthentication(a2, this - 2, *((unsigned __int8 *)this + 160));
            goto LABEL_34;
          }
          goto LABEL_67;
        }
        if (CanonicalString != 7381019)
        {
          if (CanonicalString == 9601061)
          {
            CFDictionaryRef v31 = this[17];
            if (v31) {
              CFStringRef v32 = (const __CFString *)CFDictionaryGetValue(v31, @"Realm");
            }
            else {
              CFStringRef v32 = 0;
            }
            HTTPAuthentication::setXMobileMeAuthTokenOnRequest((const __CFString **)this, (char *)a2, Value, v9, v32);
            goto LABEL_73;
          }
          goto LABEL_67;
        }
      }
      int valuePtr = 0;
      CFDictionaryRef v33 = this[17];
      if (v33) {
        CFDictionaryGetValue(v33, @"Realm");
      }
      if (v11)
      {
        CFAllocatorRef v34 = CFGetAllocator(a2);
        CFStringRef v35 = CFStringCreateWithFormat(v34, 0, @"Bearer %@", v11);
        if (v35)
        {
          CFStringRef v36 = v35;
          int v37 = *((unsigned __int8 *)this + 160);
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
          }
          if (a2) {
            int v38 = (__CFHTTPMessage *)((char *)a2 + 16);
          }
          else {
            int v38 = 0;
          }
          if (v37) {
            unsigned int v39 = 327316331;
          }
          else {
            unsigned int v39 = 294761131;
          }
          HTTPMessage::setHeaderFieldStringValue(v38, v39, v36);
          CFRelease(v36);
        }
      }
      if (v12)
      {
        if (CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr))
        {
          HTTPAuthentication::setOAuth1AuthenticationOnRequest((uint64_t)this, a2, v12, valuePtr);
        }
        else
        {
          this[11] = (CFMutableDictionaryRef)4;
          *((_DWORD *)this + 24) = -1001;
          CFDictionaryRemoveAllValues(this[19]);
        }
      }
      goto LABEL_73;
    }
  }
LABEL_34:
  __n128 result = *v15;
  CFStreamError *v14 = *(CFStreamError *)v15;
  return result;
}

uint64_t HTTPAuthentication::setBasicAuthenticationOnRequest_NoAuthFromResponse(HTTPAuthentication *this, const __CFString *a2, const __CFString *a3, const __CFString *a4, void *a5, CFStreamError *a6)
{
  int v28 = (int)a4;
  CFAllocatorRef v9 = CFGetAllocator(this);
  CFIndex usedBufLen = 0;
  CFIndex Length = CFStringGetLength(a2);
  CFIndex v11 = CFStringGetLength(a3);
  if (a5) {
    CFURLRef v12 = a5;
  }
  else {
    CFURLRef v12 = v29;
  }
  void *v12 = 0;
  v12[1] = 0;
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFIndex v14 = CFStringGetMaximumSizeForEncoding(v11, 0x8000100u) + MaximumSizeForEncoding;
  CFStringRef v15 = (UInt8 *)CFAllocatorAllocate(v9, v14 + 1, 0);
  v31.CFIndex location = 0;
  v31.CFStringRef length = Length;
  CFIndex Bytes = CFStringGetBytes(a2, v31, 0x8000100u, 0, 0, v15, v14 + 1, &usedBufLen);
  if (Length <= v14 && Bytes == Length)
  {
    CFIndex v17 = usedBufLen;
    v15[usedBufLen] = 58;
    CFIndex v18 = v17 + 1;
    CFIndex usedBufLen = v17 + 1;
    v32.CFIndex location = 0;
    v32.CFStringRef length = v11;
    if (CFStringGetBytes(a3, v32, 0x8000100u, 0, 0, &v15[v17 + 1], v14 - v17, &usedBufLen) == v11)
    {
      uint64_t result = (uint64_t)CFDataCreateWithBytesNoCopy(v9, v15, usedBufLen + v18, v9);
      if (result)
      {
        BOOL v20 = (const void *)result;
        id v21 = (id)[(id)result base64EncodedStringWithOptions:0];
        CFRelease(v20);
        if (v21)
        {
          CFStringRef v22 = CFStringCreateWithFormat(v9, 0, @"Basic %@", v21);
          CFRelease(v21);
          if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
            dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
          }
          if (this) {
            double v23 = (HTTPAuthentication *)((char *)this + 16);
          }
          else {
            double v23 = 0;
          }
          if (v28) {
            unsigned int v24 = 327316331;
          }
          else {
            unsigned int v24 = 294761131;
          }
          HTTPMessage::setHeaderFieldStringValue(v23, v24, v22);
          CFRelease(v22);
          return 1;
        }
        else
        {
          return 0;
        }
      }
      return result;
    }
    CFAllocatorDeallocate(v9, v15);
    int v25 = -1002;
  }
  else
  {
    CFAllocatorDeallocate(v9, v15);
    int v25 = -1001;
  }
  uint64_t result = 0;
  void *v12 = 4;
  CFStringRef v26 = v29;
  if (a5) {
    CFStringRef v26 = a5;
  }
  *((_DWORD *)v26 + 2) = v25;
  return result;
}

void HTTPAuthentication::setDigestAuthenticationOnRequest(__CFDictionary **this, char *cf, const __CFString *a3, const __CFString *a4)
{
  CFAllocatorRef v8 = CFGetAllocator(cf);
  CFTypeRef v10 = AuthStringUtils::_CFStringUnquote(a3, v9);
  CFStringRef Property_Locked = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Realm");
  CFStringRef v12 = CFStringCreateWithFormat(v8, 0, @"%@:%@:%@", v10, Property_Locked, a4);
  CFStringRef MD5HashWithString = HTTPAuthentication::createMD5HashWithString(v8, v12, v13);
  CFRelease(v12);
  CFRelease(v10);
  CFStringRef v15 = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Algorithm");
  if (v15 && CFStringCompare(v15, @"MD5-sess", 1uLL) == kCFCompareEqualTo)
  {
    int v16 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Nonce");
    CFIndex v17 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Cnonce");
    CFStringRef v18 = CFStringCreateWithFormat(v8, 0, @"%@:%@:%@", MD5HashWithString, v16, v17);
    CFRelease(MD5HashWithString);
    CFStringRef MD5HashWithString = HTTPAuthentication::createMD5HashWithString(v8, v18, v19);
    CFRelease(v18);
  }
  CFTypeRef cfa = CFHTTPMessageCopyRequestMethod((CFHTTPMessageRef)cf);
  CFURLRef v20 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)cf);
  CFStringRef v21 = HTTPAuthentication::createDigestURI((HTTPAuthentication *)*((unsigned __int8 *)this + 160), v8, v20, &cfa);
  if (v20) {
    CFRelease(v20);
  }
  CFStringRef v22 = CFStringCreateWithFormat(v8, 0, @"%@:%@", cfa, v21);
  CFRelease(cfa);
  if (v21) {
    CFRelease(v21);
  }
  CFStringRef v24 = HTTPAuthentication::createMD5HashWithString(v8, v22, v23);
  CFRelease(v22);
  CFStringRef v57 = a3;
  if (HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Qop"))
  {
    CFNumberRef v25 = (const __CFNumber *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Nc");
    unsigned int valuePtr = 0;
    CFNumberGetValue(v25, kCFNumberSInt32Type, &valuePtr);
    ++valuePtr;
    CFStringRef v26 = this[17];
    AutoScalar::AutoScalar((AutoScalar *)&cfa, (const __CFAllocator *)valuePtr);
    CFDictionarySetValue(v26, @"Nc", value);
    CFTypeRef cfa = &unk_1ECF9A500;
    if (value) {
      CFRelease(value);
    }
    CFStringRef v27 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Nonce");
    uint64_t v28 = (int)valuePtr;
    CFStringRef v29 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Cnonce");
    BOOL v56 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Qop");
    CFStringRef v30 = CFStringCreateWithFormat(v8, 0, @"%@:%@:%08lx:%@:%@:%@", MD5HashWithString, v27, v28, v29, v56, v24);
  }
  else
  {
    uint64_t v55 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Nonce");
    CFStringRef v30 = CFStringCreateWithFormat(v8, 0, @"%@:%@:%@", MD5HashWithString, v55, v24);
  }
  CFStringRef v32 = v30;
  CFStringRef v33 = HTTPAuthentication::createMD5HashWithString(v8, v30, v31);
  CFRelease(v32);
  CFRelease(MD5HashWithString);
  CFRelease(v24);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(v8, 0);
  CFURLRef v35 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)cf);
  CFTypeRef cfa = 0;
  CFStringRef v36 = HTTPAuthentication::createDigestURI((HTTPAuthentication *)*((unsigned __int8 *)this + 160), v8, v35, &cfa);
  if (cfa) {
    CFRelease(cfa);
  }
  CFRelease(v35);
  CFStringRef v37 = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Realm");
  CFTypeRef v39 = AuthStringUtils::_CFStringQuote(v37, v38);
  CFStringRef v40 = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Nonce");
  CFTypeRef v42 = AuthStringUtils::_CFStringQuote(v40, v41);
  uint64_t v43 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"kCFHTTPAuthenticationPropertyMethod");
  CFStringAppendFormat(Mutable, 0, @"%@ username=\"%@\", realm=\"%@\", nonce=\"%@\", uri=\"%@\", response=\"%@\"", v43, v57, v39, v42, v36, v33);
  if (v36) {
    CFRelease(v36);
  }
  CFRelease(v42);
  CFRelease(v39);
  id v44 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Opaque");
  if (v44) {
    CFStringAppendFormat(Mutable, 0, @", opaque=\"%@\"", v44);
  }
  CFStringRef v45 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Algorithm");
  if (v45) {
    CFStringAppendFormat(Mutable, 0, @", algorithm=\"%@\"", v45);
  }
  int v46 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Qop");
  if (v46)
  {
    uint64_t v47 = v46;
    unsigned int valuePtr = 0;
    CFStringRef v48 = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Cnonce");
    CFTypeRef v50 = AuthStringUtils::_CFStringQuote(v48, v49);
    CFNumberRef v51 = (const __CFNumber *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)this, @"Nc");
    CFNumberGetValue(v51, kCFNumberSInt32Type, &valuePtr);
    CFStringAppendFormat(Mutable, 0, @", cnonce=\"%@\", nc=%08lx, qop=\"%@\"", v50, valuePtr, v47);
    CFRelease(v50);
  }
  CFRelease(v33);
  int v52 = *((unsigned __int8 *)this + 160);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (cf) {
    uint64_t v53 = (HTTPMessage *)(cf + 16);
  }
  else {
    uint64_t v53 = 0;
  }
  if (v52) {
    unsigned int v54 = 327316331;
  }
  else {
    unsigned int v54 = 294761131;
  }
  HTTPMessage::setHeaderFieldStringValue(v53, v54, Mutable);

  CFRelease(Mutable);
}

void sub_18424AD80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void HTTPAuthentication::setNegotiateAuthenticationOnRequest(HTTPAuthentication *this, __CFHTTPMessage *a2, const __CFString *a3, const __CFString *a4)
{
  if (*((unsigned char *)this + 160) && (CFURLRef v6 = (const __CFURL *)*((void *)this + 21)) != 0)
  {
    CFStringRef v7 = CFURLCopyScheme(v6);
    CFStringRef v8 = v7;
    if (v7)
    {
      if (CFStringCompare(v7, (CFStringRef)&unk_1EC0A5D78, 1uLL) == kCFCompareEqualTo)
      {
        CFURLRef v9 = (const __CFURL *)*((void *)this + 21);
        if (v9)
        {
          CFURLRef v10 = 0;
          goto LABEL_10;
        }
      }
    }
  }
  else
  {
    CFStringRef v8 = 0;
  }
  CFURLRef v9 = CFHTTPMessageCopyRequestURL(a2);
  if (!v9)
  {
    CFURLRef v10 = 0;
    goto LABEL_18;
  }
  CFURLRef v10 = v9;
LABEL_10:
  CFURLRef v11 = CFURLCopyAbsoluteURL(v9);
  CFURLRef v12 = v11;
  if (v11)
  {
    CFStringRef v13 = CFURLCopyHostName(v11);
    CFStringRef v14 = v13;
    if (v13)
    {
      if (v8)
      {
        CFRelease(v13);
        CFStringRef v15 = v8;
LABEL_16:
        CFRelease(v12);
        CFStringRef v8 = v15;
        goto LABEL_19;
      }
      CFStringRef v15 = CFURLCopyScheme(v12);
      CFRelease(v14);
      if (v15) {
        goto LABEL_16;
      }
    }
    CFRelease(v12);
  }
LABEL_18:
  *((void *)this + 11) = 4;
  *((_DWORD *)this + 24) = -3;
  CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
LABEL_19:
  if (v10) {
    CFRelease(v10);
  }
  if (v8)
  {
    CFRelease(v8);
  }
}

void sub_18424AF00(_Unwind_Exception *a1)
{
  CFRelease(v4);
  CFRelease(v3);
  if (v2) {
    CFRelease(v2);
  }
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(a1);
}

void HTTPAuthentication::setNTLMAuthenticationOnRequest(CFDictionaryRef *this, __CFHTTPMessage *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFDictionaryGetCount(this[19]);
  long long v35 = 0u;
  long long v36 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  *(_OWORD *)values = 0u;
  CFAllocatorRef v11 = CFGetAllocator(a2);
  if (!this[15])
  {
    if (!a3 || !a4)
    {
      if (a3) {
        int v22 = -1002;
      }
      else {
        int v22 = -1001;
      }
      this[11] = (CFDictionaryRef)4;
      *((_DWORD *)this + 24) = v22;
      CFStringRef v23 = this[19];
      CFDictionaryRemoveAllValues(v23);
      return;
    }
    v26[0] = MEMORY[0x1E4F143A8];
    v26[1] = 3221225472;
    v26[2] = ___ZN18HTTPAuthentication30setNTLMAuthenticationOnRequestEP15__CFHTTPMessagePK10__CFStringS4_S4__block_invoke;
    v26[3] = &__block_descriptor_40_e37_v24__0____CFString__8____CFString__16l;
    v26[4] = this;
    AuthStringUtils::downLevelLogonName((uint64_t)a5, a3, (uint64_t)v26);
    CFTypeRef cf = 0;
    CFDictionaryRef v28 = 0;
    int PasswordHashes = NtlmGeneratePasswordHashes();
    if (PasswordHashes)
    {
      this[11] = (CFDictionaryRef)2;
      *((_DWORD *)this + 24) = PasswordHashes;
LABEL_32:
      CFDictionaryRemoveAllValues(this[19]);
      return;
    }
    CFDictionaryRef v24 = this[15];
    this[15] = (CFDictionaryRef)cf;
    if (v24) {
      CFRelease(v24);
    }
    CFDictionaryRef v25 = this[16];
    this[16] = v28;
    if (v25) {
      CFRelease(v25);
    }
  }
  if (Count < 17)
  {
    CFStringRef v13 = values;
    CFDictionaryGetKeysAndValues(this[19], 0, (const void **)values);
    if (Count < 1) {
      return;
    }
    goto LABEL_10;
  }
  CFURLRef v12 = (const void **)CFAllocatorAllocate(v11, 8 * Count, 0);
  if (!v12)
  {
    this[11] = (CFDictionaryRef)1;
    *((_DWORD *)this + 24) = 12;
    goto LABEL_32;
  }
  CFStringRef v13 = (void **)v12;
  CFDictionaryGetKeysAndValues(this[19], 0, v12);
LABEL_10:
  uint64_t v15 = 0;
  while (1)
  {
    CFTypeRef cf = 0;
    int v16 = v13[v15];
    if (!*v16) {
      break;
    }
    uint64_t v17 = v16[1];
    if (v17)
    {
      CFStringRef v18 = (const void *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBase64EncodedString:v17 options:0];
      int ClientResponse = _NtlmCreateClientResponse();
      CFRelease(v18);
      NtlmGeneratorRelease();
      *(void *)v13[v15] = 0;
      if (ClientResponse) {
        goto LABEL_38;
      }
LABEL_14:
      CFURLRef v20 = (void *)cf;
      if (cf)
      {
        if (*((void *)v13[v15] + 2))
        {
          CFRelease(*((CFTypeRef *)v13[v15] + 2));
          CFURLRef v20 = (void *)cf;
        }
        *((void *)v13[v15] + 2) = (id)[v20 base64EncodedStringWithOptions:0];
        CFRelease(cf);
      }
    }
LABEL_20:
    if (Count == ++v15) {
      goto LABEL_39;
    }
  }
  if (v16[2] || v16[1]) {
    goto LABEL_20;
  }
  int v21 = NtlmGeneratorCreate();
  if (!v21)
  {
    int ClientResponse = NtlmCreateClientRequest();
    if (ClientResponse) {
      goto LABEL_38;
    }
    goto LABEL_14;
  }
  int ClientResponse = v21;
LABEL_38:
  this[11] = (CFDictionaryRef)2;
  *((_DWORD *)this + 24) = ClientResponse;
  CFDictionaryRemoveAllValues(this[19]);
LABEL_39:
  if (v13 != values) {
    CFAllocatorDeallocate(v11, v13);
  }
}

void HTTPAuthentication::setXMobileMeAuthTokenOnRequest(const __CFString **this, char *cf, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  CFURLRef v10 = (HTTPProtocol *)CFGetAllocator(cf);
  if (cf)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    CFAllocatorRef v11 = cf + 16;
    if (cf[40]) {
      CFAllocatorRef v11 = 0;
    }
  }
  else
  {
    CFAllocatorRef v11 = 0;
  }
  CFAllocatorRef v12 = (const __CFAllocator *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(v11 + 128));
  XMobileMeAuthTokenForHTTPint Header = HTTPAuthentication::createXMobileMeAuthTokenForHTTPHeader(0, v10, v12, (const __CFURL *)a3, a4, a5, this[27], v13, v14);
  if (XMobileMeAuthTokenForHTTPHeader)
  {
    int v16 = XMobileMeAuthTokenForHTTPHeader;
    int v17 = *((unsigned __int8 *)this + 160);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (cf) {
      CFStringRef v18 = (HTTPMessage *)(cf + 16);
    }
    else {
      CFStringRef v18 = 0;
    }
    if (v17) {
      unsigned int v19 = 327316331;
    }
    else {
      unsigned int v19 = 294761131;
    }
    HTTPMessage::setHeaderFieldStringValue(v18, v19, v16);
    CFRelease(v16);
  }
  else
  {
    this[11] = (const __CFString *)4;
    *((_DWORD *)this + 24) = -1001;
    CFURLRef v20 = (__CFDictionary *)this[19];
    CFDictionaryRemoveAllValues(v20);
  }
}

void HTTPAuthentication::setOAuth1AuthenticationOnRequest(uint64_t a1, void *cf, void *a3, int a4)
{
  int valuePtr = a4;
  CFAllocatorRef v8 = CFGetAllocator(cf);
  CFURLRef v9 = (const void **)CFHTTPMessageCopyBody((CFHTTPMessageRef)cf);
  if (v9) {
    CFURLRef v10 = CFArrayCreate(v8, v9, 1, MEMORY[0x1E4F1D510]);
  }
  else {
    CFURLRef v10 = 0;
  }
  uint64_t v11 = _constructRequestFromParts((const __CFAllocator *)cf, v10, 0, NSURLRequestUseProtocolCachePolicy, 30.0, 0);
  if (v11)
  {
    CFAllocatorRef v12 = (void *)v11;
    CFStringRef v13 = (const void *)(a1 - 16);
    CFGetAllocator((CFTypeRef)(a1 - 16));
    if (TCFObject<CFNACOAuthSigner>::Class(void)::sOnce != -1) {
      dispatch_once(&TCFObject<CFNACOAuthSigner>::Class(void)::sOnce, &__block_literal_global_103);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    *(void *)(Instance + 48) = 0;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + CFRelease((char *)this - 16) = 0u;
    *(void *)(Instance + CFRelease((char *)this - 16) = &unk_1ECF9DB50;
    *(void *)(Instance + 24) = &unk_1ECF9DBA0;
    *(void *)(Instance + 32) = 0;
    *(void *)(Instance + 40) = 0;
    CFNACOAuthSigner::initialize(Instance + 16, a3, 0.0);
    if (*(void *)(Instance + 32)) {
      [*(id *)(Instance + 32) setShouldIncludeAppIdInRequest:0];
    }
    if (a4 < 1) {
      CFNumberRef v15 = 0;
    }
    else {
      CFNumberRef v15 = CFNumberCreate(v8, kCFNumberSInt32Type, &valuePtr);
    }
    CFGetAllocator(v13);
    if (TCFObject<CFNNSURLRequest>::Class(void)::sOnce != -1) {
      dispatch_once(&TCFObject<CFNNSURLRequest>::Class(void)::sOnce, &__block_literal_global_105);
    }
    int v17 = (void *)_CFRuntimeCreateInstance();
    CFStringRef v18 = v17;
    if (v17)
    {
      v17[2] = 0;
      v17[3] = 0;
      CFStringRef v18 = v17 + 2;
      v17[4] = 0;
    }
    *CFStringRef v18 = &unk_1ECF9D110;
    v18[1] = &unk_1ECF9D158;
    v18[2] = 0;
    id v19 = v12;
    v18[2] = v19;
    if (!v19
      || !v15
      || (uint64_t v20 = [*(id *)(Instance + 32) signedURLRequestWithURLRequest:v19 callingPID:v15 timestamp:0]) == 0)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFStringRef v29 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_error_impl(&dword_184085000, v29, OS_LOG_TYPE_ERROR, "OAuth signer did not return a signed request.", buf, 2u);
      }
      goto LABEL_51;
    }
    int v21 = (void *)v20;
    CFGetAllocator((CFTypeRef)Instance);
    if (TCFObject<CFNNSURLRequest>::Class(void)::sOnce != -1) {
      dispatch_once(&TCFObject<CFNNSURLRequest>::Class(void)::sOnce, &__block_literal_global_13_14092);
    }
    int v22 = (void *)_CFRuntimeCreateInstance();
    CFStringRef v23 = v22;
    if (v22)
    {
      v22[2] = 0;
      v22[3] = 0;
      CFStringRef v23 = v22 + 2;
      v22[4] = 0;
    }
    *CFStringRef v23 = &unk_1ECF9D110;
    v23[1] = &unk_1ECF9D158;
    v23[2] = 0;
    v23[2] = v21;
    CFDictionaryRef v24 = v23 - 2;
    if (TCFObject<CFNNSURLRequest>::Class(void)::sOnce != -1) {
      dispatch_once(&TCFObject<CFNNSURLRequest>::Class(void)::sOnce, &__block_literal_global_105);
    }
    CFDictionaryRef v25 = (void *)v23[2];
    if (v25)
    {
      uint64_t v26 = *(void *)([v25 _inner] + 56);
      if (v26)
      {
        CFDictionaryRef v27 = CFHTTPMessageCopyAllHeaderFields((CFHTTPMessageRef)(v26 - 16));
        if (v27)
        {
          CFDictionaryRef v28 = v27;
          _CFHTTPMessageSetMultipleHeaderFields((__CFHTTPMessage *)cf, v27);
          CFRelease(v28);
LABEL_50:
          CFRelease(v24);
LABEL_51:
          CFRelease((CFTypeRef)Instance);
          CFRelease(v12);
          if (v15) {
            CFRelease(v15);
          }
          goto LABEL_53;
        }
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        long long v30 = CFNLog::logger;
        if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR)) {
          goto LABEL_50;
        }
        *(_WORD *)uint64_t v37 = 0;
        long long v31 = "unable to extract authorized headers from signed message.";
        long long v32 = v37;
      }
      else
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        long long v30 = CFNLog::logger;
        if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR)) {
          goto LABEL_50;
        }
        __int16 v36 = 0;
        long long v31 = "unable to extract signed message from request.";
        long long v32 = (uint8_t *)&v36;
      }
    }
    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      long long v30 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR)) {
        goto LABEL_50;
      }
      __int16 v35 = 0;
      long long v31 = "unable to extract CF request from Obj-C request.";
      long long v32 = (uint8_t *)&v35;
    }
    _os_log_error_impl(&dword_184085000, v30, OS_LOG_TYPE_ERROR, v31, v32, 2u);
    goto LABEL_50;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  int v16 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long v33 = 0;
    _os_log_error_impl(&dword_184085000, v16, OS_LOG_TYPE_ERROR, "failed to create a CF request from an HTTP message.", v33, 2u);
  }
LABEL_53:
  if (v9) {
    CFRelease(v9);
  }
  if (v10) {
    CFRelease(v10);
  }
}

void ___ZN9TCFObjectI15CFNNSURLRequestE5ClassEv_block_invoke()
{
}

void sub_18424BA54(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI16CFNACOAuthSignerE5ClassEv_block_invoke()
{
}

void sub_18424BAD4(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

__CFString *HTTPAuthentication::createXMobileMeAuthTokenForHTTPHeader(HTTPAuthentication *this, HTTPProtocol *a2, const __CFAllocator *a3, const __CFURL *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, __SecTrust *a8, double a9)
{
  CFURLRef v10 = 0;
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  gotLoadHelper_x27__kAOSMMeAuthTokenKey(a9);
  int v17 = *(const void ***)(v9 + 800);
  if (v17) {
    BOOL v18 = v13 == 0;
  }
  else {
    BOOL v18 = 1;
  }
  if (v18) {
    return v10;
  }
  id v19 = v14;
  CFAllocatorRef v20 = v12;
  uint64_t v21 = v11;
  CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v15)
  {
    gotLoadHelper_x8__kAOSAuthTrustInfoKey(v16);
    CFDictionaryRef v24 = **(void ***)(v23 + 792);
    values = v25;
    keys[0] = v24;
    CFDictionaryRef v26 = CFDictionaryCreate(v22, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  }
  else
  {
    CFDictionaryRef v26 = 0;
  }
  [v19 stringByRemovingPercentEncoding];
  uint64_t delayInitStub = AOSAccountCreate_delayInitStub(v27);
  if (!delayInitStub)
  {
    CFURLRef v10 = 0;
    if (!v26) {
      return v10;
    }
    goto LABEL_58;
  }
  CFStringRef v29 = (const void *)delayInitStub;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  long long v30 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(keys[0]) = 0;
    _os_log_impl(&dword_184085000, v30, OS_LOG_TYPE_DEFAULT, "CFNetwork-AOSKit: Reaching out to AOSKit for X-mobile me token", (uint8_t *)keys, 2u);
  }
  CFDictionaryRef inited = (const __CFDictionary *)AOSAccountCopyAuthInfo_delayInitStub(v31);
  if (inited)
  {
    CFDictionaryRef v33 = inited;
    CFStringRef Value = CFDictionaryGetValue(inited, *v17);
    gotLoadHelper_x8__kAOSPersonIDKey(v35);
    uint64_t v37 = CFDictionaryGetValue(v33, **(const void ***)(v36 + 808));
    if (Value) {
      BOOL v38 = v37 == 0;
    }
    else {
      BOOL v38 = 1;
    }
    if (v38)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFTypeRef v39 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(keys[0]) = 0;
        _os_log_impl(&dword_184085000, v39, OS_LOG_TYPE_DEFAULT, "CFNetwork-AOSKit: X-mobile me auth token or authPersonId is not valid", (uint8_t *)keys, 2u);
      }
      CFURLRef v10 = 0;
      goto LABEL_56;
    }
    CFStringRef v41 = v37;
    if (v21)
    {
      CFTypeRef v42 = *(const void **)(v21 + 464);
      if (v42) {
        CFRelease(v42);
      }
      *(void *)(v21 + 464) = CFRetain(Value);
    }
    CFStringRef v43 = CFStringCreateWithFormat(v20, 0, @"%@:%@", v41, Value);
    CFIndex Length = CFStringGetLength(v43);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    int v46 = (char *)CFAllocatorAllocate(v20, MaximumSizeForEncoding, 0);
    if (CFStringGetCString(v43, v46, MaximumSizeForEncoding, 0x8000100u))
    {
      size_t v47 = strlen(v46);
      CFDataRef v48 = CFDataCreateWithBytesNoCopy(v20, (const UInt8 *)v46, v47, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
      if (v48)
      {
        CFDataRef v49 = v48;
        id v50 = (id)[(__CFData *)v48 base64EncodedStringWithOptions:0];
        CFDataRef v58 = v49;
        if (v50)
        {
          CFNumberRef v51 = v50;
          CFMutableDictionaryRef Mutable = CFStringCreateMutable(v20, 0);
          CFURLRef v10 = Mutable;
          if (Mutable)
          {
            CFStringAppendFormat(Mutable, 0, @"X-MobileMe-AuthToken %@", v51);
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
            }
            uint64_t v53 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(keys[0]) = 0;
              _os_log_impl(&dword_184085000, v53, OS_LOG_TYPE_DEFAULT, "CFNetwork-AOSKit: Applied X-mobile me auth to request", (uint8_t *)keys, 2u);
            }
          }
          CFRelease(v51);
        }
        else
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          CFStringRef v57 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(keys[0]) = 0;
            _os_log_impl(&dword_184085000, v57, OS_LOG_TYPE_DEFAULT, "CFNetwork-AOSKit: Base-64 encoding of token data failed.", (uint8_t *)keys, 2u);
          }
          CFURLRef v10 = 0;
        }
        CFRelease(v58);
        if (!v43) {
          goto LABEL_55;
        }
        goto LABEL_54;
      }
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      unsigned int v54 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(keys[0]) = 0;
        uint64_t v55 = "CFNetwork-AOSKit: unable to allocate CFDataRef to hold raw token data.";
        goto LABEL_52;
      }
    }
    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      unsigned int v54 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(keys[0]) = 0;
        uint64_t v55 = "CFNetwork-AOSKit: unable to convert auth-token to UTF8 string.";
LABEL_52:
        _os_log_impl(&dword_184085000, v54, OS_LOG_TYPE_DEFAULT, v55, (uint8_t *)keys, 2u);
      }
    }
    CFURLRef v10 = 0;
    if (!v43)
    {
LABEL_55:
      CFAllocatorDeallocate(v20, v46);
LABEL_56:
      CFRelease(v33);
      goto LABEL_57;
    }
LABEL_54:
    CFRelease(v43);
    goto LABEL_55;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFStringRef v40 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(keys[0]) = 0;
    _os_log_impl(&dword_184085000, v40, OS_LOG_TYPE_DEFAULT, "CFNetwork-AOSKit: Failed to get a X-mobile me token from AOSkit", (uint8_t *)keys, 2u);
  }
  CFURLRef v10 = 0;
LABEL_57:
  CFRelease(v29);
  if (v26) {
LABEL_58:
  }
    CFRelease(v26);
  return v10;
}

void ___ZN18HTTPAuthentication30setNTLMAuthenticationOnRequestEP15__CFHTTPMessagePK10__CFStringS4_S4__block_invoke(uint64_t a1, const void *a2, CFTypeRef cf)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (cf) {
    CFTypeRef v5 = CFRetain(cf);
  }
  else {
    CFTypeRef v5 = 0;
  }
  CFURLRef v6 = *(const void **)(v4 + 104);
  *(void *)(v4 + 104) = v5;
  if (v6) {
    CFRelease(v6);
  }
  if (a2) {
    CFTypeRef v7 = CFRetain(a2);
  }
  else {
    CFTypeRef v7 = 0;
  }
  CFAllocatorRef v8 = *(const void **)(v4 + 112);
  *(void *)(v4 + 112) = v7;
  if (v8)
  {
    CFRelease(v8);
  }
}

CFStringRef HTTPAuthentication::createDigestURI(HTTPAuthentication *this, const __CFAllocator *a2, CFURLRef anURL, CFTypeRef *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!(_BYTE)this) {
    goto LABEL_17;
  }
  CFStringRef v7 = CFURLCopyScheme(anURL);
  if (!v7)
  {
LABEL_6:
    int v9 = 1;
    goto LABEL_18;
  }
  CFStringRef v8 = v7;
  if (CFStringCompare(v7, (CFStringRef)&unk_1EC0A5D78, 1uLL) && CFStringCompare(v8, @"wss", 1uLL))
  {
    CFRelease(v8);
    goto LABEL_6;
  }
  unsigned int v10 = CFURLGetPortNumber(anURL);
  CFStringRef v11 = CFURLCopyHostName(anURL);
  if (a4)
  {
    if (*a4) {
      CFRelease(*a4);
    }
    *a4 = CFRetain(&unk_1EC0A3308);
  }
  if (v10 == -1) {
    uint64_t v12 = 443;
  }
  else {
    uint64_t v12 = v10;
  }
  CFStringRef v13 = CFStringCreateWithFormat(a2, 0, @"%@:%d", v11, v12);
  if (v11) {
    CFRelease(v11);
  }
  CFRelease(v8);
  if (!v13)
  {
LABEL_17:
    int v9 = 0;
LABEL_18:
    URLPortion::URLPortion((URLPortion *)&allocator, a2, anURL, v9);
    size_t v14 = strlen(__s);
    CFStringRef v13 = CFStringCreateWithBytes(a2, (const UInt8 *)__s, v14, 0x201u, 0);
    if (ptr != &v17) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  return v13;
}

void sub_18424C298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const __CFAllocator *allocator, uint64_t a12)
{
  if ((uint64_t *)STACK[0x218] != &a12) {
    CFAllocatorDeallocate(allocator, (void *)STACK[0x218]);
  }
  _Unwind_Resume(a1);
}

void HTTPAuthentication::setSecTrust(HTTPAuthentication *this, CFTypeRef cf)
{
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  uint64_t v4 = (const void *)*((void *)this + 27);
  *((void *)this + 27) = v3;
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t HTTPAuthentication::appliesToRequest(HTTPAuthentication *this, __CFHTTPMessage *a2)
{
  CFTypeRef v3 = this;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  v52[0] = MEMORY[0x1E4F143A8];
  v52[1] = 3221225472;
  uint64_t v53 = ___ZN18HTTPAuthentication16appliesToRequestEP15__CFHTTPMessage_block_invoke;
  unsigned int v54 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v55 = v3;
  if (*((unsigned char *)v3 + 160))
  {
    LOBYTE(HasPrefix) = 1;
LABEL_3:
    LOBYTE(v3) = HasPrefix;
    goto LABEL_4;
  }
  if (!dyld_program_sdk_at_least())
  {
    CFURLRef v11 = CFHTTPMessageCopyRequestURL(a2);
    CFURLRef v12 = v11;
    if (v11)
    {
      CFURLRef v13 = CFURLCopyAbsoluteURL(v11);
      CFURLRef v14 = v13;
      if (v13)
      {
        if (!*((void *)v3 + 22)) {
          goto LABEL_15;
        }
        CFStringRef v15 = CFURLGetString(v13);
        CFURLRef v16 = CFURLCopyAbsoluteURL(*((CFURLRef *)v3 + 22));
        CFStringRef v17 = CFURLGetString(v16);
        int HasPrefix = CFStringHasPrefix(v15, v17);
        if (v16) {
          CFRelease(v16);
        }
        if (!HasPrefix)
        {
LABEL_15:
          CFStringRef Property_Locked = HTTPAuthentication::getProperty_Locked(v3, @"Domain");
          if (Property_Locked)
          {
            CFStringRef v19 = CFURLGetString(v14);
            CFContainerEnumeratorBase::setup((unint64_t)v48, Property_Locked, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
            uint64_t v51 = 0;
            while (1)
            {
              uint64_t v20 = v51;
              if (v51 >= v49) {
                break;
              }
              ++v51;
              CFURLRef v21 = CFURLCopyAbsoluteURL(*(CFURLRef *)(v50 + 8 * v20));
              CFStringRef v22 = CFURLGetString(v21);
              int HasPrefix = CFStringHasPrefix(v19, v22);
              if (v21) {
                CFRelease(v21);
              }
              if (HasPrefix) {
                goto LABEL_46;
              }
            }
            LOBYTE(HasPrefix) = 0;
LABEL_46:
            CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v48);
          }
          else
          {
            LOBYTE(HasPrefix) = 0;
          }
        }
        CFRelease(v14);
      }
      else
      {
        LOBYTE(HasPrefix) = 0;
      }
      CFRelease(v12);
    }
    else
    {
      LOBYTE(HasPrefix) = 0;
    }
    goto LABEL_3;
  }
  CFURLRef v6 = CFHTTPMessageCopyRequestURL(a2);
  CFURLRef v7 = v6;
  if (v6)
  {
    CFURLRef v8 = CFURLCopyAbsoluteURL(v6);
    CFURLRef v9 = (const __CFURL *)*((void *)v3 + 22);
    if (!v9)
    {
      CFURLRef v10 = 0;
LABEL_29:
      LOBYTE(HasPrefix) = 0;
      goto LABEL_30;
    }
  }
  else
  {
    CFURLRef v8 = 0;
    CFURLRef v9 = (const __CFURL *)*((void *)v3 + 22);
    if (!v9)
    {
      LOBYTE(HasPrefix) = 0;
      CFURLRef v10 = 0;
      goto LABEL_30;
    }
  }
  CFURLRef v23 = CFURLCopyAbsoluteURL(v9);
  CFURLRef v10 = v23;
  if (!v8 || !v23) {
    goto LABEL_29;
  }
  CFStringRef v24 = CFURLCopyHostName(v8);
  CFStringRef v25 = CFURLCopyHostName(v10);
  CFStringRef v26 = v25;
  BOOL v27 = v24 != 0;
  if (!v24)
  {
    LOBYTE(HasPrefix) = 0;
    goto LABEL_42;
  }
  if (!v25)
  {
    CFRelease(v24);
    LOBYTE(v3) = 0;
    LOBYTE(HasPrefix) = 0;
    char v29 = 0;
LABEL_31:
    CFRelease(v10);
    goto LABEL_32;
  }
  if (CFStringCompare(v24, v25, 0))
  {
    BOOL v28 = 0;
LABEL_52:
    LOBYTE(HasPrefix) = 0;
    BOOL v27 = 0;
    goto LABEL_53;
  }
  if (HTTPAuthentication::isConnectionBasedAuth_unlocked(v3))
  {
    BOOL v28 = compareSchemeAndNetLocation(v10, v8);
    goto LABEL_52;
  }
  CFStringRef theString = CFURLCopyStrictPath(v8, 0);
  CFStringRef str = CFURLCopyStrictPath(v10, 0);
  int HasPrefix = 0;
  BOOL v30 = 1;
  if (theString && str)
  {
    CFRange v31 = CFStringFind(theString, @"/", 4uLL);
    CFRange v32 = CFStringFind(str, @"/", 4uLL);
    if (v31.length < 1 || v32.length < 1)
    {
      if (!CFStringGetLength(str))
      {
LABEL_74:
        BOOL v30 = compareSchemeAndNetLocation(v10, v8);
        int HasPrefix = v30;
        goto LABEL_76;
      }
      if (!CFStringGetLength(theString)) {
        goto LABEL_75;
      }
      int v37 = CFStringHasPrefix(theString, str);
LABEL_73:
      if (v37) {
        goto LABEL_74;
      }
LABEL_75:
      int HasPrefix = 0;
      BOOL v30 = 1;
      goto LABEL_76;
    }
    CFAllocatorRef v33 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    v56.CFIndex location = 0;
    v56.CFStringRef length = v31.location;
    CFStringRef v44 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, v56);
    v57.CFIndex location = 0;
    v57.CFStringRef length = v32.location;
    CFStringRef v34 = CFStringCreateWithSubstring(v33, str, v57);
    CFStringRef v35 = v34;
    if (v44 && v34)
    {
      int v36 = CFStringHasPrefix(v44, v34);
    }
    else
    {
      int v36 = 0;
      int v37 = 0;
      if (!v44) {
        goto LABEL_71;
      }
    }
    int v37 = v36;
    CFRelease(v44);
LABEL_71:
    if (v35) {
      CFRelease(v35);
    }
    goto LABEL_73;
  }
LABEL_76:
  if (v30 && !HasPrefix)
  {
    BOOL v38 = HTTPAuthentication::getProperty_Locked(v3, @"Domain");
    LOBYTE(HasPrefix) = 0;
    if (v7)
    {
      CFTypeRef v39 = v38;
      if (v38)
      {
        CFURLRef v45 = CFURLCopyAbsoluteURL(v7);
        CFStringRef v40 = CFURLGetString(v45);
        CFContainerEnumeratorBase::setup((unint64_t)v48, v39, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
        uint64_t v51 = 0;
        if (v40)
        {
          while (1)
          {
            uint64_t v41 = v51;
            if (v51 >= v49) {
              break;
            }
            ++v51;
            CFURLRef v42 = CFURLCopyAbsoluteURL(*(CFURLRef *)(v50 + 8 * v41));
            CFStringRef v43 = CFURLGetString(v42);
            int HasPrefix = CFStringHasPrefix(v40, v43);
            if (v42) {
              CFRelease(v42);
            }
            if (HasPrefix) {
              goto LABEL_87;
            }
          }
        }
        LOBYTE(HasPrefix) = 0;
LABEL_87:
        if (v45) {
          CFRelease(v45);
        }
        CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v48);
      }
    }
  }
  if (str) {
    CFRelease(str);
  }
  if (theString) {
    CFRelease(theString);
  }
LABEL_42:
  BOOL v28 = 0;
  LOBYTE(v3) = 0;
  if (v26)
  {
LABEL_53:
    CFRelease(v26);
    LOBYTE(v3) = v28;
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v27)
  {
LABEL_30:
    char v29 = 1;
    if (!v10) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  char v29 = 0;
  if (v10) {
    goto LABEL_31;
  }
LABEL_32:
  if (v8) {
    CFRelease(v8);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v29) {
    goto LABEL_3;
  }
LABEL_4:
  v53((uint64_t)v52);
  return v3;
}

void sub_18424C8B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf, CFTypeRef a13, char a14)
{
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a14);
  if (cf) {
    CFRelease(cf);
  }
  if (a13) {
    CFRelease(a13);
  }
  CFRelease(v18);
  if (v17) {
    CFRelease(v17);
  }
  CFRelease(v16);
  if (v15) {
    CFRelease(v15);
  }
  if (v14) {
    CFRelease(v14);
  }
  (*(void (**)(uint64_t))(v19 - 112))(v19 - 128);
  _Unwind_Resume(a1);
}

uint64_t ___ZN18HTTPAuthentication16appliesToRequestEP15__CFHTTPMessage_block_invoke(uint64_t a1)
{
  return pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 32) + 16));
}

const __CFString *HTTPAuthentication::isConnectionBasedAuth_unlocked(HTTPAuthentication *this)
{
  CFStringRef result = (const __CFString *)HTTPAuthentication::getProperty_Locked(this, @"kCFHTTPAuthenticationPropertyMethod");
  if (result)
  {
    int ExactString = _findExactString(result, 1u);
    return (const __CFString *)(ExactString == 5316627 || ExactString == 6324248);
  }
  return result;
}

BOOL compareSchemeAndNetLocation(const __CFURL *a1, CFURLRef anURL)
{
  CFStringRef v4 = CFURLCopyScheme(anURL);
  CFStringRef v5 = CFURLCopyScheme(a1);
  CFStringRef v6 = v5;
  if (v4)
  {
    if (v5)
    {
      if (CFStringCompare(v4, v5, 1uLL) == kCFCompareEqualTo
        && ((v7 = CFURLGetPortNumber(anURL), SInt32 v8 = CFURLGetPortNumber(a1), v7 < 1) || v8 < 1 || v7 == v8))
      {
        CFStringRef v11 = CFURLCopyUserName(a1);
        CFStringRef v12 = CFURLCopyUserName(anURL);
        if (areStringsEqual(v11, v12))
        {
          CFStringRef v13 = CFURLCopyPassword(a1);
          CFStringRef v14 = CFURLCopyPassword(anURL);
          BOOL v9 = areStringsEqual(v13, v14);
          if (v14) {
            CFRelease(v14);
          }
          if (v13) {
            CFRelease(v13);
          }
        }
        else
        {
          BOOL v9 = 0;
        }
        if (v12) {
          CFRelease(v12);
        }
        if (v11) {
          CFRelease(v11);
        }
      }
      else
      {
        BOOL v9 = 0;
      }
      CFRelease(v6);
    }
    else
    {
      BOOL v9 = 0;
    }
  }
  else
  {
    BOOL v9 = 0;
    CFStringRef v4 = v5;
    if (!v5) {
      return v9;
    }
  }
  CFRelease(v4);
  return v9;
}

void sub_18424CB7C(_Unwind_Exception *a1)
{
  if (v6)
  {
    CFRelease(v6);
    if (!v5)
    {
LABEL_3:
      if (!v4) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if (!v5)
  {
    goto LABEL_3;
  }
  CFRelease(v5);
  if (!v4)
  {
LABEL_4:
    if (!v3)
    {
LABEL_10:
      CFRelease(v2);
      CFRelease(v1);
      _Unwind_Resume(a1);
    }
LABEL_9:
    CFRelease(v3);
    goto LABEL_10;
  }
LABEL_8:
  CFRelease(v4);
  if (!v3) {
    goto LABEL_10;
  }
  goto LABEL_9;
}

BOOL areStringsEqual(const __CFString *a1, const __CFString *a2)
{
  if (a1 && !a2) {
    return 0;
  }
  if (a1 && a2) {
    return CFEqual(a1, a2);
  }
  return a1 || a2 == 0;
}

const __CFString *HTTPAuthentication::isConnectionBasedAuth(HTTPAuthentication *this)
{
  BOOL v2 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  CFStringRef v3 = HTTPAuthentication::isConnectionBasedAuth_unlocked(this);
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t HTTPAuthentication::updateFromResponse(HTTPAuthentication *this, __CFHTTPMessage *a2, const void *a3)
{
  CFStringRef v6 = (pthread_mutex_t *)((char *)this + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 16));
  if (!*((_DWORD *)this + 24))
  {
    int ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(a2);
    if (!*((void *)this + 17) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(cf) = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "_CFHTTPAuthenticationUpdateFromResponse(): authentication context not properly configured", (uint8_t *)&cf, 2u);
    }
    _CFHTTPMessageSetAuthentication(a2, (char *)this - 16, *((unsigned __int8 *)this + 160));
    SInt32 v8 = (__CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 17), @"kCFHTTPAuthenticationPropertyMethod");
    BOOL v9 = (CFStringRef *)&kCFHTTPHeaderProxyAuthenticationInfo;
    if (!*((unsigned char *)this + 160)) {
      BOOL v9 = (CFStringRef *)&kCFHTTPHeaderAuthenticationInfo;
    }
    CFStringRef v10 = CFHTTPMessageCopyHeaderFieldValue(a2, *v9);
    if (v10)
    {
      CFStringRef v11 = v10;
      uint64_t v12 = 1;
      goto LABEL_13;
    }
    CFStringRef v13 = (CFStringRef *)&kCFHTTPHeaderProxyAuthenticate;
    if (!*((unsigned char *)this + 160)) {
      CFStringRef v13 = (CFStringRef *)&kCFHTTPHeaderWWWAuthenticate;
    }
    CFStringRef v14 = CFHTTPMessageCopyHeaderFieldValue(a2, *v13);
    if (v14)
    {
      CFStringRef v11 = v14;
      uint64_t v12 = 0;
LABEL_13:
      CFAllocatorRef v15 = CFGetAllocator((char *)this - 16);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v15, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
      CFAllocatorRef v17 = CFGetAllocator((char *)this - 16);
      BOOL v18 = CFArrayCreateMutable(v17, 0, MEMORY[0x1E4F1D510]);
      if (!HTTPAuthentication::parseHeader(v11, (const __CFString *)v12, Mutable, v18, v19))
      {
        *((void *)this + 11) = 4;
        int v21 = -1;
LABEL_77:
        *((_DWORD *)this + 24) = v21;
        goto LABEL_78;
      }
      int ExactString = _findExactString(v8, 1u);
      if (ExactString <= 5316626)
      {
        if (ExactString != 40960)
        {
          if (ExactString != 2146311)
          {
LABEL_48:
            *((void *)this + 11) = 4;
            int v21 = -1000;
            goto LABEL_77;
          }
          CFDictionaryRef v22 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, v8);
          if (v22)
          {
            CFDictionaryRef v23 = v22;
            CFStringRef v24 = (const __CFString *)CFDictionaryGetValue(v22, &unk_1EC0A40D0);
            if (v24)
            {
              CFTypeRef v26 = AuthStringUtils::_CFStringUnquote(v24, v25);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 17), &unk_1EC0A40D0, v26);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 17), &unk_1EC0A4108, v26);
              CFRelease(v26);
              BOOL v27 = (__CFDictionary *)*((void *)this + 17);
              AutoScalar::AutoScalar((AutoScalar *)&cf, 0);
              CFDictionarySetValue(v27, &unk_1EC0A4098, value);
              CFTypeRef cf = &unk_1ECF9A500;
              if (value) {
                CFRelease(value);
              }
            }
            CFStringRef v44 = (const __CFString *)CFDictionaryGetValue(v23, &unk_1EC0A4108);
            if (v44)
            {
              CFTypeRef v46 = AuthStringUtils::_CFStringUnquote(v44, v45);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 17), &unk_1EC0A4108, v46);
              CFRelease(v46);
              size_t v47 = (__CFDictionary *)*((void *)this + 17);
              AutoScalar::AutoScalar((AutoScalar *)&cf, 0);
              CFDictionarySetValue(v47, &unk_1EC0A4098, value);
              CFTypeRef cf = &unk_1ECF9A500;
              if (value) {
                CFRelease(value);
              }
            }
            CFStringRef v48 = (const __CFString *)CFDictionaryGetValue(v23, &unk_1EC0A4220);
            if (v48)
            {
              if (CFStringCompare(v48, (CFStringRef)&unk_1EC0A4290, 1uLL) == kCFCompareEqualTo) {
                goto LABEL_79;
              }
            }
          }
        }
        goto LABEL_72;
      }
      switch(ExactString)
      {
        case 5316627:
          BOOL v28 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 19), a3);
          CFDictionaryRef v29 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, v8);
          if (!v29 || (BOOL v30 = CFDictionaryGetValue(v29, &unk_1EC0A3A40), !v28) || !v30)
          {
            if (!v28) {
              break;
            }
LABEL_72:
            if ((ResponseStatusCode != 407 || !*((unsigned char *)this + 160))
              && (ResponseStatusCode != 401 || *((unsigned char *)this + 160)))
            {
              break;
            }
            goto LABEL_76;
          }
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 17), &unk_1EC0A3A40, v30);
          break;
        case 6324248:
          CFRange v31 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 19), a3);
          if (v31)
          {
            CFRange v32 = v31;
            CFDictionaryRef v33 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, v8);
            if (v33)
            {
              CFStringRef v34 = (const __CFString *)CFDictionaryGetValue(v33, &unk_1EC0A3A40);
              if (v34)
              {
                CFStringRef v35 = v34;
                CFGetAllocator((char *)this - 16);
                int v36 = (const void *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBase64EncodedString:v35 options:0];
                int v37 = (const void *)v32[1];
                if (v37)
                {
                  CFRelease(v37);
                  v32[1] = 0;
                }
                if (*v32)
                {
                  CFTypeRef cf = 0;
                  int ClientResponse = _NtlmCreateClientResponse();
                  NtlmGeneratorRelease();
                  *CFRange v32 = 0;
                  if (ClientResponse)
                  {
                    *((void *)this + 11) = 2;
                    *((_DWORD *)this + 24) = ClientResponse;
                    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
                    if (cf) {
                      CFRelease(cf);
                    }
                    if (!v36) {
                      break;
                    }
                    CFTypeRef v39 = v36;
LABEL_47:
                    CFRelease(v39);
                    break;
                  }
                  if (cf)
                  {
                    uint64_t v50 = (const void *)v32[2];
                    if (v50) {
                      CFRelease(v50);
                    }
                    CFGetAllocator((char *)this - 16);
                    v32[2] = (id)[(id)cf base64EncodedStringWithOptions:0];
                    CFRelease(cf);
                  }
                }
                CFRelease(v36);
                uint64_t v51 = (const void *)v32[1];
                if (v51)
                {
                  CFRelease(v51);
                  v32[1] = 0;
                }
                v32[1] = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v35);
                break;
              }
            }
            if ((ResponseStatusCode != 407 || !*((unsigned char *)this + 160))
              && (ResponseStatusCode != 401 || *((unsigned char *)this + 160))
              || *v32)
            {
              break;
            }
            if (v32[2])
            {
LABEL_76:
              *((void *)this + 11) = 4;
              int v21 = -1001;
              goto LABEL_77;
            }
            CFURLRef v42 = (const void *)v32[1];
            if (v42)
            {
              CFTypeRef cf = 0;
              CFRelease(v42);
              v32[1] = 0;
              int ClientRequest = NtlmGeneratorCreate();
              if (ClientRequest || (int ClientRequest = NtlmCreateClientRequest()) != 0)
              {
                *((void *)this + 11) = 2;
                *((_DWORD *)this + 24) = ClientRequest;
LABEL_78:
                CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
                break;
              }
              CFGetAllocator((char *)this - 16);
              v32[2] = (id)[(id)cf base64EncodedStringWithOptions:0];
              CFTypeRef v39 = cf;
              goto LABEL_47;
            }
          }
          break;
        case 9601061:
          goto LABEL_72;
        default:
          goto LABEL_48;
      }
LABEL_79:
      CFRelease(Mutable);
      CFRelease(v18);
      CFRelease(v11);
      return pthread_mutex_unlock(v6);
    }
    if (*((unsigned char *)this + 160) && ResponseStatusCode == 407 || !*((unsigned char *)this + 160) && ResponseStatusCode == 401)
    {
      *((void *)this + 11) = 4;
      *((_DWORD *)this + 24) = -1001;
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 19));
    }
    else if (v8 == @"NTLM")
    {
      CFStringRef v40 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 19), a3);
      if (v40)
      {
        if (!*v40 && !v40[1])
        {
          uint64_t v41 = v40[2];
          if (v41)
          {
            v40[1] = v41;
            v40[2] = 0;
          }
        }
      }
    }
  }
  return pthread_mutex_unlock(v6);
}

void sub_18424D368(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

const __CFDictionary *HTTPAuthentication::isKerberosThePreferredAuthScheme(const __CFDictionary *this)
{
  if (this)
  {
    this = (const __CFDictionary *)CFDictionaryGetValue(this, @"kCFHTTPAuthenticationPropertyMethod");
    if (this) {
      return (const __CFDictionary *)(CFStringCompare((CFStringRef)this, @"Negotiate", 1uLL) == kCFCompareEqualTo);
    }
  }
  return this;
}

void HTTPAuthentication::buildProtectionSpacesFromAuthSchemes(CFArrayRef *a1, uint64_t a2, const __CFString *a3, int a4, int a5, const __CFString *a6)
{
  *a1 = 0;
  if (a2)
  {
    if (a3)
    {
      if (a6)
      {
        CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFArrayRef theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        if (theArray)
        {
          if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
            dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
          }
          CFArrayRef v12 = (const __CFArray *)HTTPAuthentication::copyServerSupportedSchemes((HTTPAuthentication *)(a2 + 16));
          if (v12)
          {
            CFArrayRef cf = v12;
            MutableCFStringRef Copy = CFArrayCreateMutableCopy(v11, 0, v12);
            uint64_t Count = CFArrayGetCount(MutableCopy);
            v24.CFIndex location = 0;
            v24.CFStringRef length = Count;
            CFArraySortValues(MutableCopy, v24, (CFComparatorFunction)sortArrayBySecurityStrength, 0);
            if (Count >= 1)
            {
              for (CFIndex i = 0; i != Count; ++i)
              {
                CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, i);
                int v18 = URLProtectionSpace::protSpaceAuthSchemeForCFStringRef(ValueAtIndex, v17);
                if (v18 == 12)
                {
                  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
                    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
                  }
                  if (*(unsigned char *)(a2 + 241)) {
                    int v18 = 12;
                  }
                  else {
                    int v18 = 1;
                  }
                }
                uint64_t v19 = (const void *)CFURLProtectionSpaceCreate((uint64_t)v11, a3, a4, a5, a6, v18);
                if (v19)
                {
                  CFArrayAppendValue(theArray, v19);
                  CFRelease(v19);
                }
              }
            }
            if (MutableCopy) {
              CFRelease(MutableCopy);
            }
            CFRelease(cf);
          }
          if (CFArrayGetCount(theArray) >= 1) {
            *a1 = CFArrayCreateCopy(v11, theArray);
          }
          CFRelease(theArray);
        }
      }
    }
  }
}

void sub_18424D624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef a10, void *a11, CFTypeRef cf)
{
  *a11 = 0;
  _Unwind_Resume(a1);
}

uint64_t sortArrayBySecurityStrength(const __CFString *a1, const __CFString *a2, void *a3)
{
  int v4 = URLProtectionSpace::protSpaceAuthSchemeForCFStringRef(a1, a2);
  int v6 = URLProtectionSpace::protSpaceAuthSchemeForCFStringRef(a2, v5);
  if (v4 == v6) {
    return 0;
  }
  if (v4 == 11) {
    return 1;
  }
  if (v6 == 11 || v4 == 6) {
    return -1;
  }
  if (v4 == 2 || v6 == 6) {
    return 1;
  }
  if (v6 == 2 || v4 == 5 && v6 == 3) {
    return -1;
  }
  return v6 == 5 && v4 == 3;
}

void ___ZN23HTTPProxyAuthenticationL17GetProxyAuthCacheEv_block_invoke()
{
}

void sub_18424D7B0(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void RetainableTypedDict<__CFString const* const,_CFHTTPAuthentication *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA01F0;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<__CFString const* const,_CFHTTPAuthentication *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA01F0;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void HTTPProxyAuthentication::SetCachedProxyAuth(HTTPProxyAuthentication *this, const __CFString *a2, _CFHTTPAuthentication *a3)
{
  os_unfair_lock_lock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
  if (a2)
  {
    if (HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken != -1) {
      dispatch_once(&HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken, &__block_literal_global_84);
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(HTTPProxyAuthentication::GetProxyAuthCache(void)::ProxyAuthCache + 8), this, a2);
  }
  else
  {
    if (HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken != -1) {
      dispatch_once(&HTTPProxyAuthentication::GetProxyAuthCache(void)::onceToken, &__block_literal_global_84);
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(HTTPProxyAuthentication::GetProxyAuthCache(void)::ProxyAuthCache + 8), this);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
}

void sub_18424D944(_Unwind_Exception *a1)
{
}

void proxyProtectionSpaceFromAuthentication(_CFHTTPAuthentication *a1, const __CFURL *a2, const __CFURL *a3)
{
  *(void *)a1 = 0;
  CFStringRef v6 = CFURLCopyHostName(a3);
  CFStringRef v7 = CFURLCopyScheme(a3);
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a2) {
    SInt32 v8 = (const __CFURL *)((char *)a2 + 16);
  }
  else {
    SInt32 v8 = 0;
  }
  CFStringRef v9 = (const __CFString *)HTTPAuthentication::copyRealm(v8);
  SInt32 v10 = CFURLGetPortNumber(a3);
  HTTPAuthentication::buildProtectionSpacesFromAuthSchemes(&theArray, (uint64_t)a2, v6, v10, 6, v9);
  CFArrayRef v11 = theArray;
  if (theArray) {
    CFArrayGetCount(theArray);
  }
  CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v11, 0);
  if (ValueAtIndex) {
    *(void *)a1 = CFRetain(ValueAtIndex);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v6)
  {
    CFRelease(v6);
  }
}

void sub_18424DA94(_Unwind_Exception *exception_object)
{
  if (v5)
  {
    CFRelease(v5);
    if (!v4)
    {
LABEL_3:
      if (!v3) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if (!v4)
  {
    goto LABEL_3;
  }
  CFRelease(v4);
  if (!v3)
  {
LABEL_4:
    if (!v1)
    {
LABEL_10:
      *BOOL v2 = 0;
      _Unwind_Resume(exception_object);
    }
LABEL_9:
    CFRelease(v1);
    goto LABEL_10;
  }
LABEL_8:
  CFRelease(v3);
  if (!v1) {
    goto LABEL_10;
  }
  goto LABEL_9;
}

__n128 __Block_byref_object_copy__9620(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__9621(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorEU13block_pointerFvP22NetworkProxyCredentialP33NetworkProxyAuthorizationElementsU13block_pointerFvSE_EE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

void HTTPProxyAuthentication::SetCachedProxyCred(const void *a1, const void *a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
  if (a2)
  {
    if (HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken != -1) {
      dispatch_once(&HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken, &__block_literal_global_94);
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(HTTPProxyAuthentication::GetProxyCredCache(void)::ProxyCredCache + 8), a1, a2);
  }
  else
  {
    if (HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken != -1) {
      dispatch_once(&HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken, &__block_literal_global_94);
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(HTTPProxyAuthentication::GetProxyCredCache(void)::ProxyCredCache + 8), a1);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
}

void sub_18424DC24(_Unwind_Exception *a1)
{
}

uint64_t ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorEU13block_pointerFvP22NetworkProxyCredentialP33NetworkProxyAuthorizationElementsU13block_pointerFvSE_EE_block_invoke_79(uint64_t a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  int v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v14 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v14;
    __int16 v21 = 2048;
    CFDictionaryRef v22 = a2;
    _os_log_debug_impl(&dword_184085000, v4, OS_LOG_TYPE_DEBUG, "UUID %@ fetched proxy cred %p", buf, 0x16u);
    if (!a2) {
      goto LABEL_17;
    }
  }
  else if (!a2)
  {
    goto LABEL_17;
  }
  proxyProtectionSpaceFromAuthentication((_CFHTTPAuthentication *)buf, *(const __CFURL **)(a1 + 64), *(const __CFURL **)(a1 + 80));
  CFStringRef v5 = *(const void **)buf;
  HTTPProxyAuthentication::SetCachedProxyCred(*(const void **)buf, a2);
  uint64_t v6 = a2[4];
  uint64_t Username = CFURLCredentialGetUsername(v6);
  uint64_t v9 = URLCredential_PasswordBased::safelyCast(v6, v8);
  if (v9)
  {
    SInt32 v10 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 128))(v9);
    if (Username) {
      goto LABEL_7;
    }
LABEL_11:
    if (v10) {
      CFRelease(v10);
    }
    goto LABEL_15;
  }
  SInt32 v10 = 0;
  if (!Username) {
    goto LABEL_11;
  }
LABEL_7:
  if (v10)
  {
    v18[0] = @"kCFHTTPAuthenticationUsername";
    v18[1] = @"kCFHTTPAuthenticationPassword";
    v19[0] = Username;
    v19[1] = v10;
    CFArrayRef v11 = (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v19 forKeys:v18 count:2];
    if (v11) {
      CFRetain(v11);
    }
    operator new();
  }
LABEL_15:
  if (v5) {
    CFRelease(v5);
  }
LABEL_17:
  v17.CFIndex domain = 0;
  *(void *)&v17.CFStreamError error = 0;
  if (CFHTTPMessageApplyCredentialDictionary(*(CFHTTPMessageRef *)(a1 + 88), *(CFHTTPAuthenticationRef *)(a1 + 64), *(CFDictionaryRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 48), &v17))
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFArrayRef v12 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v15 = *(void *)(a1 + 88);
      CFURLRef v16 = *(void **)(a1 + 96);
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v15;
      __int16 v21 = 2048;
      CFDictionaryRef v22 = v16;
      _os_log_debug_impl(&dword_184085000, v12, OS_LOG_TYPE_DEBUG, "Applied proxy credentials dictionary to request %@ handle %p", buf, 0x16u);
    }
    _CFHTTPAuthenticationApplyHeaderToRequest(*(_CFHTTPAuthentication **)(a1 + 64), *(__CFHTTPMessage **)(a1 + 88), *(const void **)(a1 + 96));
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_18424DF24(_Unwind_Exception *a1)
{
  CFRelease(v2);
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_48c39_ZTSNSt3__110shared_ptrIK10__CFStringEE64c49_ZTSNSt3__110shared_ptrI21_CFHTTPAuthenticationEE(uint64_t a1)
{
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  CFStringRef v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_e8_48c39_ZTSNSt3__110shared_ptrIK10__CFStringEE64c49_ZTSNSt3__110shared_ptrI21_CFHTTPAuthenticationEE(void *result, void *a2)
{
  uint64_t v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[9];
  result[8] = a2[8];
  result[9] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN23HTTPProxyAuthenticationL17GetProxyCredCacheEv_block_invoke()
{
}

void sub_18424E068(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void RetainableTypedDict<_CFURLProtectionSpace * const,NetworkProxyCredential *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA01D0;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<_CFURLProtectionSpace * const,NetworkProxyCredential *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA01D0;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void std::__shared_ptr_pointer<_CFHTTPAuthentication *,Deleter_CFRelease,std::allocator<_CFHTTPAuthentication>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void std::__shared_ptr_pointer<_CFHTTPAuthentication *,Deleter_CFRelease,std::allocator<_CFHTTPAuthentication>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a2) {
    SmartBlockWithArgs<NetworkProxyCredential *>::SmartBlockWithArgs();
  }
  int v4 = *(uint64_t (**)(uint64_t))(a4 + 16);

  return v4(a4);
}

void sub_18424E208(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

AuthStringUtils *AuthStringUtils::SkipLWS(AuthStringUtils *this, const unsigned __int8 *a2)
{
  uint64_t v2 = this;
  int v3 = *(unsigned __int8 *)this;
  if (*(unsigned char *)this)
  {
    do
    {
      if (!memchr(" \t\r\n", v3, 5uLL)) {
        break;
      }
      int v4 = *((unsigned __int8 *)v2 + 1);
      uint64_t v2 = (AuthStringUtils *)((char *)v2 + 1);
      int v3 = v4;
    }
    while (v4);
  }
  return v2;
}

AuthStringUtils *AuthStringUtils::SkipToLWS(AuthStringUtils *this, const unsigned __int8 *a2)
{
  uint64_t v2 = this;
  int v3 = *(unsigned __int8 *)this;
  if (*(unsigned char *)this)
  {
    do
    {
      if (memchr(" \t\r\n", v3, 5uLL)) {
        break;
      }
      int v4 = *((unsigned __int8 *)v2 + 1);
      uint64_t v2 = (AuthStringUtils *)((char *)v2 + 1);
      int v3 = v4;
    }
    while (v4);
  }
  return v2;
}

CFTypeRef AuthStringUtils::_CFStringQuote(const __CFString *this, const __CFString *a2)
{
  CFIndex Length = CFStringGetLength(this);
  if (Length)
  {
    uint64_t v4 = Length;
    CFAllocatorRef v5 = CFGetAllocator(this);
    uint64_t v6 = (UniChar *)CFAllocatorAllocate(v5, 4 * v4, 0);
    if (!v6) {
      return 0;
    }
    CFStringRef v7 = v6;
    CFStringRef theString = this;
    uint64_t v32 = 0;
    int64_t v33 = v4;
    CharactersPtr = CFStringGetCharactersPtr(this);
    CStringPtr = 0;
    BOOL v30 = CharactersPtr;
    if (!CharactersPtr) {
      CStringPtr = CFStringGetCStringPtr(this, 0x600u);
    }
    int64_t v34 = 0;
    int64_t v35 = 0;
    CFRange v31 = CStringPtr;
    if (v4 < 1) {
      goto LABEL_46;
    }
    uint64_t v10 = 0;
    int64_t v11 = 0;
    int64_t v12 = 0;
    CFIndex v13 = 0;
    uint64_t v14 = 64;
    do
    {
      if ((unint64_t)v12 >= 4) {
        uint64_t v15 = 4;
      }
      else {
        uint64_t v15 = v12;
      }
      int64_t v16 = v33;
      if (v33 <= v12) {
        goto LABEL_44;
      }
      if (v30)
      {
        UniChar v17 = v30[v12 + v32];
      }
      else if (v31)
      {
        UniChar v17 = v31[v32 + v12];
      }
      else
      {
        if (v35 <= v12 || v11 > v12)
        {
          uint64_t v19 = v15 + v10;
          uint64_t v20 = v14 - v15;
          int64_t v21 = v12 - v15;
          int64_t v22 = v21 + 64;
          if (v21 + 64 >= v33) {
            int64_t v22 = v33;
          }
          int64_t v34 = v21;
          int64_t v35 = v22;
          if (v33 >= v20) {
            int64_t v16 = v20;
          }
          v37.CFStringRef length = v16 + v19;
          v37.CFIndex location = v21 + v32;
          CFStringGetCharacters(theString, v37, buffer);
          int64_t v11 = v34;
        }
        UniChar v17 = buffer[v12 - v11];
      }
      if ((unsigned __int16)(v17 - 256) < 0xFF01u)
      {
LABEL_44:
        CFTypeRef v26 = 0;
        goto LABEL_49;
      }
      BOOL v24 = (unsigned __int16)(v17 - 14) >= 0x12u && v17 >= 9u && (unsigned __int16)(v17 - 11) >= 2u;
      if (!v24 || v17 == 34 || v17 == 127 || v17 == 92) {
        v7[v13++] = 92;
      }
      v7[v13++] = v17;
      ++v12;
      --v10;
      ++v14;
    }
    while (v4 != v12);
    if (v13 == v4) {
LABEL_46:
    }
      BOOL v27 = (void *)CFRetain(this);
    else {
      BOOL v27 = (void *)CFStringCreateWithCharacters(v5, v7, v13);
    }
    CFTypeRef v26 = v27;
LABEL_49:
    CFAllocatorDeallocate(v5, v7);
    return v26;
  }
  else
  {
    return CFRetain(this);
  }
}

CFTypeRef AuthStringUtils::_CFStringUnquote(const __CFString *this, const __CFString *a2)
{
  CFIndex Length = CFStringGetLength(this);
  if (!Length)
  {
    return CFRetain(this);
  }
  uint64_t v4 = Length;
  CFAllocatorRef v5 = CFGetAllocator(this);
  uint64_t v6 = (UniChar *)CFAllocatorAllocate(v5, 2 * v4, 0);
  if (!v6) {
    return 0;
  }
  CFStringRef v7 = v6;
  CFStringRef theString = this;
  uint64_t v31 = 0;
  int64_t v32 = v4;
  CharactersPtr = CFStringGetCharactersPtr(this);
  CStringPtr = 0;
  CFDictionaryRef v29 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(this, 0x600u);
  }
  int64_t v33 = 0;
  int64_t v34 = 0;
  BOOL v30 = CStringPtr;
  if (v4 < 1)
  {
LABEL_33:
    BOOL v24 = (void *)CFRetain(this);
    goto LABEL_39;
  }
  uint64_t v10 = 0;
  int64_t v11 = 0;
  int v12 = 0;
  int64_t v13 = 0;
  CFIndex v14 = 0;
  uint64_t v15 = 64;
  do
  {
    if ((unint64_t)v13 >= 4) {
      uint64_t v16 = 4;
    }
    else {
      uint64_t v16 = v13;
    }
    int64_t v17 = v32;
    if (v32 <= v13)
    {
      UniChar v18 = 0;
    }
    else
    {
      if (v29)
      {
        UniChar v18 = v29[v13 + v31];
      }
      else if (v30)
      {
        UniChar v18 = v30[v31 + v13];
      }
      else
      {
        if (v34 <= v13 || v11 > v13)
        {
          uint64_t v20 = v16 + v10;
          uint64_t v21 = v15 - v16;
          int64_t v22 = v13 - v16;
          int64_t v23 = v22 + 64;
          if (v22 + 64 >= v32) {
            int64_t v23 = v32;
          }
          int64_t v33 = v22;
          int64_t v34 = v23;
          if (v32 >= v21) {
            int64_t v17 = v21;
          }
          v36.CFStringRef length = v17 + v20;
          v36.CFIndex location = v22 + v31;
          CFStringGetCharacters(theString, v36, v27);
          int64_t v11 = v33;
        }
        UniChar v18 = v27[v13 - v11];
      }
      if (v18 == 92)
      {
        if (!v12)
        {
          int v12 = 1;
          goto LABEL_31;
        }
        UniChar v18 = 92;
      }
    }
    int v12 = 0;
    v7[v14++] = v18;
LABEL_31:
    ++v13;
    --v10;
    ++v15;
  }
  while (v4 != v13);
  if (v14 == v4) {
    goto LABEL_33;
  }
  BOOL v24 = (void *)CFStringCreateWithCharacters(v5, v7, v14);
LABEL_39:
  CFTypeRef v26 = v24;
  CFAllocatorDeallocate(v5, v7);
  return v26;
}

CFTypeRef AuthStringUtils::_canonicalSchemeName(const __CFString *this, const __CFString *a2)
{
  int v3 = @"Negotiate";
  if (CFStringCompare(this, @"Negotiate", 1uLL))
  {
    int v3 = @"NTLM";
    if (CFStringCompare(this, @"NTLM", 1uLL))
    {
      int v3 = (__CFString *)gConstantCFStringValueTable;
      if (CFStringCompare(this, (CFStringRef)gConstantCFStringValueTable, 1uLL))
      {
        int v3 = @"Digest";
        if (CFStringCompare(this, @"Digest", 1uLL))
        {
          int v3 = @"Nego2";
          if (CFStringCompare(this, @"Nego2", 1uLL))
          {
            int v3 = @"X-MobileMe-AuthToken";
            if (CFStringCompare(this, @"X-MobileMe-AuthToken", 1uLL))
            {
              int v3 = @"OAuth";
              if (CFStringCompare(this, @"OAuth", 1uLL))
              {
                int v3 = @"PrivateToken";
                if (CFStringCompare(this, @"PrivateToken", 1uLL))
                {
                  int v3 = (__CFString *)(gConstantCFStringValueTable + 56);
                  if (CFStringCompare(this, (CFStringRef)&gConstantCFStringValueTable[7], 1uLL)) {
                    int v3 = (__CFString *)this;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (!v3) {
    return 0;
  }

  return CFRetain(v3);
}

void AuthStringUtils::downLevelLogonName(uint64_t a1, CFStringRef theString, uint64_t a3)
{
  if (a1)
  {
    CFAllocatorRef v5 = *(void (**)(uint64_t, uint64_t, CFStringRef))(a3 + 16);
    v5(a3, a1, theString);
  }
  else
  {
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, @"\\"");
    CFArrayRef v7 = ArrayBySeparatingStrings;
    if (ArrayBySeparatingStrings && CFArrayGetCount(ArrayBySeparatingStrings) == 2)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v7, 0);
      uint64_t v9 = CFArrayGetValueAtIndex(v7, 1);
      (*(void (**)(uint64_t, const void *, const void *))(a3 + 16))(a3, ValueAtIndex, v9);
    }
    else
    {
      (*(void (**)(uint64_t, void, CFStringRef))(a3 + 16))(a3, 0, theString);
      if (!v7) {
        return;
      }
    }
    CFRelease(v7);
  }
}

void sub_18424E9D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'AuthenticationState::~AuthenticationState(AuthenticationState *this)
{
  AuthenticationState::~AuthenticationState((AuthenticationState *)((char *)this - 88));

  JUMPOUT(0x18531B6D0);
}

{
  AuthenticationState::~AuthenticationState((AuthenticationState *)((char *)this - 88));
}

BOOL AuthenticationState::applyToRequest(AuthenticationState *this, HTTPRequestMessage *a2, void *a3, char a4)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  if (this) {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  }
  if (*((void *)this + 13)) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = *((void *)this + 16) == 0;
  }
  BOOL v9 = 0;
  if (a2 && !v8)
  {
    char v12 = 1;
    uint64_t v10 = operator new(0x28uLL);
    *uint64_t v10 = &unk_1ECFA6210;
    v10[1] = a2;
    v10[2] = a3;
    *((unsigned char *)v10 + 24) = a4;
    v10[4] = &v12;
    v13[3] = v10;
    AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v13);
    std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](v13);
    BOOL v9 = v12 != 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return v9;
}

void sub_18424EB68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100]((uint64_t *)va);
  pthread_mutex_unlock((pthread_mutex_t *)(v2 + 8));
  _Unwind_Resume(a1);
}

uint64_t std::__throw_bad_function_call[abi:nn180100]()
{
  return std::__function::__func<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()();
}

uint64_t std::__function::__func<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, AuthenticationInfo **a3)
{
  CFAllocatorRef v5 = *a3;
  if (*((void *)*a3 + 1))
  {
    if (HTTPAuthentication::isConnectionBasedAuth(*((HTTPAuthentication **)*a3 + 1))) {
      BOOL v6 = *(unsigned char *)(a1 + 24) == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6) {
      return 1;
    }
    CFAllocatorRef v5 = *a3;
  }
  if (AuthenticationInfo::canApplyHeadersToRequest(v5, *(HTTPRequestMessage **)(a1 + 8)))
  {
    int v7 = AuthenticationInfo::applyToRequest(*a3, *(HTTPRequestMessage **)(a1 + 8), *(void **)(a1 + 16));
    BOOL v8 = *(BOOL **)(a1 + 32);
    if (v7) {
      BOOL v9 = *v8;
    }
    else {
      BOOL v9 = 0;
    }
    *BOOL v8 = v9;
  }
  return 1;
}

BOOL AuthenticationInfo::canApplyHeadersToRequest(AuthenticationInfo *this, HTTPRequestMessage *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 6);
  if (v4)
  {
    AuthenticationInfo::_getChallengeAuthScheme((uint64_t)&theString1, v4);
    CFStringRef v5 = theString1;
    if (theString1)
    {
      BOOL v6 = CFStringCompare(theString1, @"Negotiate", 0x80uLL) != kCFCompareEqualTo;
      CFRelease(v5);
    }
    else
    {
      BOOL v6 = 1;
    }
  }
  else
  {
    BOOL v6 = HTTPAuthentication::isKerberosThePreferredAuthScheme(*(const __CFDictionary **)(*((void *)this + 1) + 136)) == 0;
  }
  BOOL result = AuthenticationInfo::isValid(*((void *)this + 1));
  if (result)
  {
    if (*((void *)this + 2)) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = v6;
    }
    if (v8) {
      return 0;
    }
    return HTTPAuthentication::appliesToRequest(*((HTTPAuthentication **)this + 1), (HTTPRequestMessage *)((char *)a2 - 16)) != 0;
  }
  return result;
}

void sub_18424ECFC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

unint64_t AuthenticationInfo::applyToRequest(AuthenticationInfo *this, HTTPRequestMessage *a2, void *a3)
{
  unint64_t v4 = (unint64_t)a2;
  uint64_t v27 = 0;
  BOOL v28 = &v27;
  uint64_t v29 = 0x3812000000;
  BOOL v30 = __Block_byref_object_copy__9664;
  uint64_t v31 = __Block_byref_object_dispose__9665;
  uint64_t v32 = 0;
  BOOL v6 = (HTTPRequestMessage *)((char *)a2 - 16);
  if (a2) {
    int v7 = (char *)a2 - 16;
  }
  else {
    int v7 = 0;
  }
  CFAllocatorRef v8 = CFGetAllocator(v7);
  CFTypeRef Mutable = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!v4) {
    goto LABEL_39;
  }
  if (!v28[6] || !AuthenticationInfo::canApplyHeadersToRequest(this, (HTTPRequestMessage *)v4))
  {
    unint64_t v4 = 0;
    goto LABEL_39;
  }
  uint64_t v9 = *((void *)this + 2);
  if (v9)
  {
    uint64_t Username = (const void *)CFURLCredentialGetUsername(v9);
    if (Username && (CFStringRef v12 = (const __CFString *)CFRetain(Username)) != 0)
    {
      CFStringRef cf = v12;
      if (HTTPAuthentication::requiresAccountDomain(*((HTTPAuthentication **)this + 1)))
      {
        v26[0] = MEMORY[0x1E4F143A8];
        v26[1] = 3221225472;
        v26[2] = ___ZN18AuthenticationInfo14applyToRequestEP18HTTPRequestMessagePv_block_invoke;
        v26[3] = &unk_1E5255480;
        v26[4] = &v27;
        AuthStringUtils::downLevelLogonName(0, cf, (uint64_t)v26);
      }
      else
      {
        CFDictionaryAddValue((CFMutableDictionaryRef)v28[6], @"kCFHTTPAuthenticationUsername", cf);
      }
    }
    else
    {
      CFStringRef cf = 0;
    }
    uint64_t v13 = URLCredential_PasswordBased::safelyCast(*((void *)this + 2), v11);
    if (v13)
    {
      CFIndex v14 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v13 + 128))(v13);
      if (v14) {
        CFDictionaryAddValue((CFMutableDictionaryRef)v28[6], @"kCFHTTPAuthenticationPassword", v14);
      }
    }
    else
    {
      CFIndex v14 = 0;
    }
    int64_t v17 = (const void *)_CFURLCredentialCopyOAuthToken(*((const _CFURLCredential **)this + 2));
    if (v17) {
      CFDictionaryAddValue((CFMutableDictionaryRef)v28[6], @"kCFHTTPAuthenticationOAuthToken", v17);
    }
    uint64_t v16 = (const void *)_CFURLCredentialCopyOAuth1Account(*((const _CFURLCredential **)this + 2));
    if (v16)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)v28[6], @"kCFHTTPAuthenticationOAuth1Account", v16);
      int valuePtr = 0;
      int valuePtr = _CFURLCredentialGetOAuth1PID(*((const _CFURLCredential **)this + 2));
      CFAllocatorRef v18 = CFGetAllocator((CFTypeRef)v28[6]);
      CFNumberRef v15 = CFNumberCreate(v18, kCFNumberSInt32Type, &valuePtr);
      if (v15) {
        CFDictionaryAddValue((CFMutableDictionaryRef)v28[6], @"kCFHTTPAuthenticationOAuth1PID", v15);
      }
    }
    else
    {
      CFNumberRef v15 = 0;
    }
    uint64_t v19 = *((void *)this + 1);
    CFDictionaryRef v20 = (const __CFDictionary *)v28[6];
    pthread_mutex_lock((pthread_mutex_t *)(v19 + 16));
    HTTPAuthentication::applyCredentials_Locked((CFMutableDictionaryRef *)v19, v6, v20, 0);
    LODWORD(v20) = v21;
    pthread_mutex_unlock((pthread_mutex_t *)(v19 + 16));
    unint64_t v4 = v20 != 0;
    if (!a3) {
      goto LABEL_29;
    }
    goto LABEL_27;
  }
  CFNumberRef v15 = 0;
  uint64_t v16 = 0;
  int64_t v17 = 0;
  CFIndex v14 = 0;
  CFStringRef cf = 0;
  unint64_t v4 = 1;
  if (a3)
  {
LABEL_27:
    if (v4) {
      HTTPAuthentication::applyHeaderToRequest(*((CFDictionaryRef **)this + 1), v6, a3);
    }
  }
LABEL_29:
  if (v15) {
    CFRelease(v15);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (cf) {
    CFRelease(cf);
  }
LABEL_39:
  _Block_object_dispose(&v27, 8);
  CFTypeRef v22 = Mutable;
  CFTypeRef Mutable = 0;
  if (v22) {
    CFRelease(v22);
  }
  return v4;
}

void sub_18424F0C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,CFTypeRef a22)
{
  if (v25)
  {
    CFRelease(v25);
    if (!v24)
    {
LABEL_3:
      if (!v23) {
        goto LABEL_4;
      }
      goto LABEL_13;
    }
  }
  else if (!v24)
  {
    goto LABEL_3;
  }
  CFRelease(v24);
  if (!v23)
  {
LABEL_4:
    if (!v22) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_13:
  CFRelease(v23);
  if (!v22)
  {
LABEL_6:
    if (cf) {
      CFRelease(cf);
    }
    _Block_object_dispose(&a16, 8);
    CFTypeRef v27 = a22;
    a22 = 0;
    if (v27) {
      CFRelease(v27);
    }
    _Unwind_Resume(a1);
  }
LABEL_5:
  CFRelease(v22);
  goto LABEL_6;
}

uint64_t __Block_byref_object_copy__9664(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__9665(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v2) {
    CFRelease(v2);
  }
}

void ___ZN18AuthenticationInfo14applyToRequestEP18HTTPRequestMessagePv_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 48), @"kCFHTTPAuthenticationUsername", a3);
  if (a2)
  {
    CFStringRef v5 = *(__CFDictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 48);
    CFDictionaryAddValue(v5, @"kCFHTTPAuthenticationAccountDomain", a2);
  }
}

uint64_t AuthenticationInfo::_getChallengeAuthScheme(uint64_t this, uint64_t a2)
{
  *(void *)this = 0;
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 24);
    if (v2)
    {
      int v3 = (void *)this;
      if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
        dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
      }
      this = *(unsigned int *)(v2 + 72);
      if (this)
      {
        this = URLProtectionSpace::stringForProtSpaceAuthScheme(this);
        if (this) {
          this = (uint64_t)CFRetain((CFTypeRef)this);
        }
        *int v3 = this;
      }
    }
  }
  return this;
}

void sub_18424F280(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

BOOL AuthenticationInfo::isValid(BOOL this)
{
  if (this)
  {
    uint64_t v1 = this;
    uint64_t v2 = (pthread_mutex_t *)(this + 16);
    pthread_mutex_lock((pthread_mutex_t *)(this + 16));
    LODWORD(v1) = *(_DWORD *)(v1 + 96);
    pthread_mutex_unlock(v2);
    return v1 == 0;
  }
  return this;
}

__n128 std::__function::__func<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA6210;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1ECFA6210;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<AuthenticationState::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t AuthenticationInfo::_getCredentialFlags(AuthenticationInfo *this)
{
  if (!this) {
    return 0;
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if (*((_DWORD *)this + 12) != 2) {
    return 0;
  }
  uint64_t v2 = *(uint64_t (**)(char *))(*((void *)this + 2) + 120);

  return v2((char *)this + 16);
}

void AuthenticationInfo::_getCredentialUserPrincipal(AuthenticationInfo *this, uint64_t a2)
{
  *(void *)this = 0;
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    if (*(_DWORD *)(a2 + 48) == 2)
    {
      CFTypeRef v4 = (CFTypeRef)(*(uint64_t (**)(uint64_t))(*(void *)(a2 + 16) + 128))(a2 + 16);
      if (v4) {
        CFTypeRef v4 = CFRetain(v4);
      }
      *(void *)this = v4;
    }
  }
}

void sub_18424F4A4(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

void AuthenticationInfo::_getCredentialServicePrincipal(AuthenticationInfo *this, uint64_t a2)
{
  *(void *)this = 0;
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    if (*(_DWORD *)(a2 + 48) == 2)
    {
      CFTypeRef v4 = (CFTypeRef)(*(uint64_t (**)(uint64_t))(*(void *)(a2 + 16) + 136))(a2 + 16);
      if (v4) {
        CFTypeRef v4 = CFRetain(v4);
      }
      *(void *)this = v4;
    }
  }
}

void sub_18424F540(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

void AuthenticationInfo::_getCredentialUUID(AuthenticationInfo *this, uint64_t a2)
{
  *(void *)this = 0;
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    if (*(_DWORD *)(a2 + 48) == 2)
    {
      uint64_t v5 = *(void *)(a2 + 16);
      uint64_t v4 = a2 + 16;
      CFTypeRef v6 = (CFTypeRef)(*(uint64_t (**)(uint64_t))(v5 + 144))(v4);
      if (v6)
      {
        int v7 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 144))(v4);
        CFTypeRef v6 = CFRetain(v7);
      }
      *(void *)this = v6;
    }
  }
}

void sub_18424F604(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

CFIndex AuthenticationInfo::updateCredentialStatus(CFIndex this, HTTPResponseMessage *a2)
{
  uint64_t v2 = this;
  if (a2
    && ((this = CFHTTPMessageGetResponseStatusCode((HTTPResponseMessage *)((char *)a2 - 16)), this == 407) || this == 401))
  {
    if (*(_DWORD *)(v2 + 24) == 2) {
      int v3 = 3;
    }
    else {
      int v3 = 4;
    }
  }
  else
  {
    int v3 = 2;
  }
  *(_DWORD *)(v2 + 24) = v3;
  return this;
}

void std::__shared_ptr_emplace<AuthenticationInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA69F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<AuthenticationInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA69F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)a3 + 8);
  if (v3 && *(unsigned char *)(v3 + 224))
  {
    *(void *)(*(void *)a3 + 8) = 0;
    CFRelease((CFTypeRef)(v3 - 16));
  }
  return 1;
}

void std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ECFA6408;
}

void *std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1ECFA6408;
  return result;
}

void std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)a3 + 8);
  if (v3) {
    *(unsigned char *)(v3 + 161) = *(unsigned char *)(a1 + 8);
  }
  return 1;
}

uint64_t std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA63C0;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

unsigned char *std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_1ECFA63C0;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

void std::__function::__func<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0,std::allocator<AuthenticationState::setOption(AuthenticationConfiguration::Options,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t AuthenticationState::setConnectionType(uint64_t a1, int a2)
{
  if (a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  }
  *(_DWORD *)(*(void *)(a1 + 144) + 12) = a2;

  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
}

BOOL AuthenticationState::updateState(AuthenticationState *this, uint64_t a2, unint64_t a3, const _CFURLCredential *a4, __SecTrust *a5)
{
  if (this) {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  }
  BOOL v10 = (a2 | a3) == 0;
  if (!(a2 | a3)) {
    goto LABEL_25;
  }
  if (a3)
  {
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
    }
    uint64_t v11 = *(void *)(a3 + 40);
    if (v11)
    {
      if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
        dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
      }
      int v12 = (*(_DWORD *)(v11 + 60) - 5) >= 4 ? 1 : 2;
    }
    else
    {
      int v12 = 1;
    }
  }
  else
  {
    int v12 = AuthenticationState::_isLikelyForProxy((uint64_t)this, a2) ? 2 : 1;
  }
  if (!AuthenticationState::_haveAuthenticationInfo((uint64_t)this, v12))
  {
LABEL_25:
    if (!this) {
      return v10;
    }
    goto LABEL_78;
  }
  AuthenticationState::_authForType(&v45, (uint64_t)this, v12);
  uint64_t v13 = v45;
  if (*(void *)(v45 + 8) && *(void *)(v45 + 32))
  {
    if (a3 && (CFIndex v14 = (char *)CFRetain((CFTypeRef)a3)) != 0)
    {
      if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
        dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
      }
      CFNumberRef v15 = v14 + 16;
    }
    else
    {
      CFNumberRef v15 = 0;
    }
    uint64_t v16 = *(void *)(v13 + 48);
    *(void *)(v13 + 48) = v15;
    if (v16) {
      CFRelease((CFTypeRef)(v16 - 16));
    }
    if (a4) {
      CFTypeRef v17 = CFRetain(a4);
    }
    else {
      CFTypeRef v17 = 0;
    }
    CFAllocatorRef v18 = *(const void **)(v13 + 16);
    *(void *)(v13 + CFRelease((char *)this - 16) = v17;
    if (v18) {
      CFRelease(v18);
    }
    if (a5) {
      CFTypeRef v19 = CFRetain(a5);
    }
    else {
      CFTypeRef v19 = 0;
    }
    CFDictionaryRef v20 = *(const void **)(v13 + 56);
    *(void *)(v13 + 56) = v19;
    if (v20) {
      CFRelease(v20);
    }
    *(_DWORD *)(v13 + 24) = 1;
    AuthenticationInfo::_getChallengeAuthScheme((uint64_t)&theString1, *(void *)(v13 + 48));
    CFStringRef v21 = theString1;
    if (theString1) {
      BOOL v22 = CFStringCompare(theString1, @"Negotiate", 0x80uLL) == kCFCompareEqualTo;
    }
    else {
      BOOL v22 = 0;
    }
    uint64_t v23 = *(void *)(v13 + 32);
    if (v23) {
      BOOL v24 = (__CFHTTPMessage *)(v23 - 16);
    }
    else {
      BOOL v24 = 0;
    }
    if (!v21 || !*(void *)(v13 + 48))
    {
      uint64_t v31 = *(AuthenticationInfo **)(v13 + 16);
      if (v31)
      {
        uint64_t v32 = *(HTTPAuthentication **)(v13 + 8);
        CFStringRef CredentialFlags = (const __CFString *)AuthenticationInfo::_getCredentialFlags(v31);
        AuthenticationInfo::_getCredentialUserPrincipal((AuthenticationInfo *)v49, *(void *)(v13 + 16));
        int64_t v34 = *(const void **)v49;
        AuthenticationInfo::_getCredentialServicePrincipal((AuthenticationInfo *)&v48, *(void *)(v13 + 16));
        CFStringRef v35 = v48;
        AuthenticationInfo::_getCredentialUUID((AuthenticationInfo *)&v47, *(void *)(v13 + 16));
        CFRange v36 = v47;
        HTTPAuthentication::_initialize(v32, v24, CredentialFlags, v34, v35, v47, v37);
        if (v36) {
          CFRelease(v36);
        }
        if (v35) {
          CFRelease(v35);
        }
        if (v34) {
          CFRelease(v34);
        }
        HTTPAuthentication::initializeSchemes(*(HTTPAuthentication **)(v13 + 8), v24, 0);
      }
      if (!v21) {
        goto LABEL_75;
      }
      goto LABEL_74;
    }
    if (v22)
    {
      CFStringRef v25 = *(HTTPAuthentication **)(v13 + 8);
      CFStringRef v26 = (const __CFString *)AuthenticationInfo::_getCredentialFlags(*(AuthenticationInfo **)(v13 + 16));
      AuthenticationInfo::_getCredentialUserPrincipal((AuthenticationInfo *)v49, *(void *)(v13 + 16));
      CFTypeRef v27 = *(const void **)v49;
      AuthenticationInfo::_getCredentialServicePrincipal((AuthenticationInfo *)&v48, *(void *)(v13 + 16));
      CFStringRef v28 = v48;
      AuthenticationInfo::_getCredentialUUID((AuthenticationInfo *)&v47, *(void *)(v13 + 16));
      uint64_t v29 = v47;
      HTTPAuthentication::_initialize(v25, v24, v26, v27, v28, v47, v30);
      if (v29) {
        CFRelease(v29);
      }
      if (v28) {
        CFRelease(v28);
      }
    }
    else
    {
      if (CFStringCompare(v21, @"X-MobileMe-AuthToken", 1uLL) == kCFCompareEqualTo
        || CFStringCompare(v21, @"OAuth", 1uLL) == kCFCompareEqualTo
        || CFStringCompare(v21, (CFStringRef)&gConstantCFStringValueTable[7], 1uLL) == kCFCompareEqualTo)
      {
        CFStringRef v40 = *(HTTPAuthentication **)(v13 + 8);
        AuthenticationInfo::_getCredentialUserName(v49, *(const _CFURLCredential **)(v13 + 16));
        uint64_t v41 = *(const void **)v49;
        HTTPAuthentication::_initialize(v40, v24, 0, *(const void **)v49, 0, 0, v42);
        if (v41) {
          CFRelease(v41);
        }
        CFStringRef v43 = *(const void **)(v13 + 56);
        if (v43) {
          HTTPAuthentication::setSecTrust(*(HTTPAuthentication **)(v13 + 8), v43);
        }
        goto LABEL_73;
      }
      BOOL v38 = *(HTTPAuthentication **)(v13 + 8);
      AuthenticationInfo::_getCredentialUserName(v49, *(const _CFURLCredential **)(v13 + 16));
      CFTypeRef v27 = *(const void **)v49;
      HTTPAuthentication::_initialize(v38, v24, 0, *(const void **)v49, 0, 0, v39);
    }
    if (v27) {
      CFRelease(v27);
    }
LABEL_73:
    HTTPAuthentication::initializeSchemes(*(HTTPAuthentication **)(v13 + 8), v24, v21);
LABEL_74:
    CFRelease(v21);
  }
LABEL_75:
  if (v46) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v46);
  }
  BOOL v10 = 1;
LABEL_78:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return v10;
}

void sub_18424FD7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (v12) {
    CFRelease(v12);
  }
  CFRelease(v11);
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
  _Unwind_Resume(a1);
}

void *AuthenticationInfo::_getCredentialUserName(void *this, const _CFURLCredential *a2)
{
  *this = 0;
  if (a2)
  {
    uint64_t v2 = this;
    this = (void *)URLCredential_PasswordBased::safelyCast((uint64_t)a2, a2);
    if (this)
    {
      this = (void *)(*(uint64_t (**)(void *))(*this + 112))(this);
      if (this) {
        this = CFRetain(this);
      }
      *uint64_t v2 = this;
    }
  }
  return this;
}

void sub_18424FEE8(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

void AuthenticationState::_removeAuthenticationInfo(void *a1, int a2)
{
  if (a2 == 1)
  {
    uint64_t v4 = (std::__shared_weak_count *)a1[14];
    a1[13] = 0;
    a1[14] = 0;
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
  else
  {
    if (!a2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "assertion failure", v5, 2u);
    }
    uint64_t v3 = (std::__shared_weak_count *)a1[17];
    a1[16] = 0;
    a1[17] = 0;
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
  }
}

uint64_t std::__function::__func<AuthenticationState::resetInvalid(void)::$_0,std::allocator<AuthenticationState::resetInvalid(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, uint64_t a3)
{
  int v4 = *a2;
  if (!AuthenticationInfo::isValid(*(void *)(*(void *)a3 + 8)))
  {
    uint64_t v5 = *(uint64_t **)(a1 + 16);
    uint64_t v6 = *v5;
    int v7 = operator new(0x10uLL);
    *(void *)int v7 = v6;
    void v7[2] = v4;
    *uint64_t v5 = (uint64_t)v7;
  }
  return 1;
}

__n128 std::__function::__func<AuthenticationState::resetInvalid(void)::$_0,std::allocator<AuthenticationState::resetInvalid(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA61C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::resetInvalid(void)::$_0,std::allocator<AuthenticationState::resetInvalid(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECFA61C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<AuthenticationState::resetInvalid(void)::$_0,std::allocator<AuthenticationState::resetInvalid(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

BOOL AuthenticationState::isValid(uint64_t a1, int a2)
{
  if (a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  }
  BOOL isValid = AuthenticationState::_isValid(a1, a2);
  if (a1) {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
  }
  return isValid;
}

void sub_1842500E8(_Unwind_Exception *exception_object)
{
  if (v1) {
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

BOOL std::__function::__func<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0,std::allocator<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL result = AuthenticationInfo::isValid(*(void *)(*(void *)a3 + 8));
  **(unsigned char **)(a1 + CFRelease((char *)this - 16) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0,std::allocator<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA6378;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0,std::allocator<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECFA6378;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0,std::allocator<AuthenticationState::_isValid(AuthenticationState::AuthInfoType)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t AuthenticationState::getEndpointCred(AuthenticationState *this, std::__shared_weak_count *a2)
{
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!this)
  {
    uint64_t v2 = 0;
    if (!a2) {
      return v2;
    }
    goto LABEL_5;
  }
  uint64_t v2 = *((void *)this + 2);
  if (a2) {
LABEL_5:
  }
    std::__shared_weak_count::__release_shared[abi:nn180100](a2);
  return v2;
}

BOOL std::__function::__func<AuthenticationState::isConnectionBased(void)::$_0,std::allocator<AuthenticationState::isConnectionBased(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(HTTPAuthentication **)(*(void *)a3 + 8);
  if (v4) {
    BOOL v5 = HTTPAuthentication::isConnectionBasedAuth(v4) != 0;
  }
  else {
    BOOL v5 = 0;
  }
  **(unsigned char **)(a1 + 8) = v5;
  return !v5;
}

uint64_t std::__function::__func<AuthenticationState::isConnectionBased(void)::$_0,std::allocator<AuthenticationState::isConnectionBased(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECFA62A0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<AuthenticationState::isConnectionBased(void)::$_0,std::allocator<AuthenticationState::isConnectionBased(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1ECFA62A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<AuthenticationState::isConnectionBased(void)::$_0,std::allocator<AuthenticationState::isConnectionBased(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t AuthenticationState::getAuth(AuthenticationState *this, int a2)
{
  if (this)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
    if (a2) {
      int v4 = 2;
    }
    else {
      int v4 = 1;
    }
    if (!AuthenticationState::_haveAuthenticationInfo((uint64_t)this, v4))
    {
      uint64_t v5 = 0;
LABEL_14:
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
      return v5;
    }
  }
  else
  {
    if (a2) {
      int v4 = 2;
    }
    else {
      int v4 = 1;
    }
    uint64_t v5 = 0;
    if (!AuthenticationState::_haveAuthenticationInfo(0, v4)) {
      return v5;
    }
  }
  AuthenticationState::_authForType(&v7, (uint64_t)this, v4);
  uint64_t v5 = *(void *)(v7 + 8);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  if (this) {
    goto LABEL_14;
  }
  return v5;
}

void AuthenticationState::copyDebugSummary(AuthenticationState *this, uint64_t a2)
{
  _OWORD v6[4] = *MEMORY[0x1E4F143B8];
  if (a2) {
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 8));
  }
  int v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  v4->__shared_weak_owners_ = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6838;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  AutoStringArray::addFormat((CFTypeRef *)&v4[1].__vftable, @"<AuthenticationState@%p>{", a2);
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  v6[0] = &unk_1ECFA6258;
  v6[1] = v4 + 1;
  void v6[2] = v4;
  v6[3] = v6;
  AuthenticationState::_foreachAuthenticationInfo(a2, (uint64_t)v6);
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](v6);
  CFArrayAppendValue((CFMutableArrayRef)v4[1].__vftable, @"}");
  *(void *)this = CFStringCreateByCombiningStrings(v5, (CFArrayRef)v4[1].__vftable, @" ");
  std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  if (a2) {
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 8));
  }
}

void sub_1842504F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100]((uint64_t *)va);
  std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  if (v2) {
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 8));
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v4 = *(CFTypeRef **)(a1 + 8);
  uint64_t v5 = *a3;
  BOOL isValid = AuthenticationInfo::isValid(*(void *)(*a3 + 8));
  uint64_t v7 = *a3;
  int v8 = *(_DWORD *)(*a3 + 24);
  uint64_t v9 = *(HTTPAuthentication **)(v7 + 8);
  uint64_t v10 = 78;
  if (v9)
  {
    if (HTTPAuthentication::isConnectionBasedAuth(v9)) {
      uint64_t v10 = 89;
    }
    else {
      uint64_t v10 = 78;
    }
  }
  uint64_t v11 = 78;
  if (v8 == 2) {
    uint64_t v12 = 89;
  }
  else {
    uint64_t v12 = 78;
  }
  if (isValid) {
    uint64_t v11 = 89;
  }
  AutoStringArray::addFormat(v4, @"<AuthenticationInfo@%p>{%s - Valid(%c) Authenticated(%c) ConnAuth(%c)}", v5, "Unknown", v11, v12, v10);
  return 1;
}

void std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  operator delete(__p);
}

void std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_1ECFA6258;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *__n128 result = &unk_1ECFA6258;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func(void *a1)
{
  *a1 = &unk_1ECFA6258;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }

  JUMPOUT(0x18531B6D0);
}

void *std::__function::__func<AuthenticationState::copyDebugSummary(void)::$_0,std::allocator<AuthenticationState::copyDebugSummary(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func(void *a1)
{
  *a1 = &unk_1ECFA6258;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  return a1;
}

void std::__shared_ptr_emplace<AutoStringArray>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<AutoStringArray>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6838;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<AutoStringArray>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6838;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL std::__function::__func<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0,std::allocator<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, AuthenticationInfo **a3)
{
  BOOL canApplyHeadersToRequest = AuthenticationInfo::canApplyHeadersToRequest(*a3, *(HTTPRequestMessage **)(a1 + 8));
  **(unsigned char **)(a1 + CFRelease((char *)this - 16) = canApplyHeadersToRequest;
  return !canApplyHeadersToRequest;
}

__n128 std::__function::__func<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0,std::allocator<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA6330;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0,std::allocator<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECFA6330;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0,std::allocator<AuthenticationState::canApplyHeadersToRequest(HTTPRequestMessage *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 144);
  if (AuthenticationInfo::isValid(*(void *)(*a3 + 8))
    && !HTTPAuthentication::isConnectionBasedAuth(*(HTTPAuthentication **)(v3 + 8)))
  {
    if (*(unsigned char *)(*(void *)(v3 + 8) + 160)) {
      BOOL v5 = *(_DWORD *)(v4 + 12) == 3;
    }
    else {
      BOOL v5 = 0;
    }
    if (!v5) {
      operator new();
    }
  }
  return 1;
}

void sub_184250AA4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<AuthenticationInfo  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<AuthenticationInfo  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 24);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA60A8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(result + 8);
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(a2 + 24) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

char *std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = &unk_1ECFA60A8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func(void *a1)
{
  *a1 = &unk_1ECFA60A8;
  uint64_t v1 = (std::__shared_weak_count *)a1[3];
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }

  JUMPOUT(0x18531B6D0);
}

void *std::__function::__func<AuthenticationState::copyForCache(void)::$_0,std::allocator<AuthenticationState::copyForCache(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func(void *a1)
{
  *a1 = &unk_1ECFA60A8;
  uint64_t v2 = (std::__shared_weak_count *)a1[3];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  return a1;
}

BOOL AuthenticationState::incorporate(AuthenticationState *this, AuthenticationState *a2)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  if (this) {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  }
  if (!a2) {
    __assert_rtn("incorporate", "AuthenticationHelpers.cpp", 731, "other");
  }
  char v8 = 0;
  uint64_t v4 = (pthread_mutex_t *)((char *)a2 + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 8));
  v11[0] = &unk_1ECFA6018;
  v11[1] = this;
  void v11[2] = &v8;
  v11[3] = v11;
  AuthenticationState::_foreachAuthenticationInfo((uint64_t)a2, (uint64_t)v11);
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](v11);
  uint64_t v10 = 0;
  BOOL v5 = operator new(0x20uLL);
  *BOOL v5 = &unk_1ECFA6060;
  v5[1] = this;
  v5[2] = a2;
  v5[3] = &v8;
  uint64_t v10 = v5;
  AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v9);
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](v9);
  if (*((void *)a2 + 13) || *((void *)a2 + 16)) {
    operator new();
  }
  BOOL v7 = v8 != 0;
  pthread_mutex_unlock(v4);
  if (this) {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  }
  return v7;
}

void sub_184250EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  pthread_mutex_unlock(v15);
  if (v14) {
    pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
  }
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_1,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2)
{
  if (!AuthenticationState::_haveAuthenticationInfo(*(void *)(a1 + 16), *a2)) {
    **(unsigned char **)(a1 + 24) = 1;
  }
  return 1;
}

__n128 std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_1,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA6060;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_1,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ECFA6060;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_1,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_0,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, AuthenticationInfo **a3)
{
  int v5 = *a2;
  uint64_t v6 = *(void *)(a1 + 8);
  if (AuthenticationState::_haveAuthenticationInfo(v6, *a2))
  {
    AuthenticationState::_authForType(&v11, v6, v5);
    char v7 = AuthenticationInfo::incorporate(v11, *a3);
    char v8 = *(BOOL **)(a1 + 16);
    BOOL v9 = (v7 & 1) != 0 || *v8;
    *char v8 = v9;
  }
  else
  {
    AuthenticationState::_makeAuth(v6, v5, 0, 0);
    AuthenticationState::_authForType(&v11, v6, v5);
    AuthenticationInfo::incorporate(v11, *a3);
  }
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  return 1;
}

void sub_1842510BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AuthenticationInfo::incorporate(AuthenticationInfo *this, AuthenticationInfo *a2)
{
  if (!a2) {
    __assert_rtn("incorporate", "AuthenticationHelpers.cpp", 1684, "other");
  }
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *((void *)a2 + 1);
  if (v4)
  {
    uint64_t v5 = v4 != v5;
  }
  else if (v5)
  {
    CFRetain((CFTypeRef)(v5 - 16));
    uint64_t v6 = *((void *)this + 1);
    *((void *)this + 1) = v5;
    if (v6) {
      CFRelease((CFTypeRef)(v6 - 16));
    }
    uint64_t v5 = 0;
  }
  char v7 = (const void *)*((void *)this + 2);
  char v8 = (const void *)*((void *)a2 + 2);
  if (v7)
  {
    if (v7 == v8) {
      uint64_t v5 = v5;
    }
    else {
      uint64_t v5 = 1;
    }
  }
  else if (v8)
  {
    CFTypeRef v12 = CFRetain(v8);
    uint64_t v13 = (const void *)*((void *)this + 2);
    *((void *)this + 2) = v12;
    if (v13) {
      CFRelease(v13);
    }
  }
  uint64_t v9 = *((void *)this + 6);
  uint64_t v10 = *((void *)a2 + 6);
  if (v9)
  {
    if (v9 == v10) {
      return v5;
    }
    else {
      return 1;
    }
  }
  else if (v10)
  {
    CFRetain((CFTypeRef)(v10 - 16));
    uint64_t v14 = *((void *)this + 6);
    *((void *)this + 6) = v10;
    if (v14) {
      CFRelease((CFTypeRef)(v14 - 16));
    }
  }
  return v5;
}

__n128 std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_0,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA6018;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_0,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECFA6018;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<AuthenticationState::incorporate(AuthenticationState*)::$_0,std::allocator<AuthenticationState::incorporate(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t std::__function::__func<AuthenticationState::isCompatible(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isCompatible(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, uint64_t a3)
{
  int v5 = *a2;
  uint64_t v6 = *(void *)(a1 + 8);
  if (!AuthenticationState::_haveAuthenticationInfo(v6, *a2)) {
    return 1;
  }
  AuthenticationState::_authForType(&v17, v6, v5);
  uint64_t v7 = v17;
  char v8 = *(const void **)(v17 + 16);
  uint64_t v9 = *(const void **)(*(void *)a3 + 16);
  if (v8) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10 || !CFEqual(v8, v9)) {
    goto LABEL_15;
  }
  uint64_t v11 = *(HTTPAuthentication **)(v7 + 8);
  if (v11)
  {
    unsigned int v12 = HTTPAuthentication::isConnectionBasedAuth(v11);
    BOOL v13 = v12 != 0;
    uint64_t v14 = *(HTTPAuthentication **)(*(void *)a3 + 8);
    if (!v14)
    {
      if (!v12) {
        goto LABEL_19;
      }
LABEL_15:
      uint64_t v15 = 0;
      **(unsigned char **)(a1 + CFRelease((char *)this - 16) = 0;
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v14 = *(HTTPAuthentication **)(*(void *)a3 + 8);
    if (!v14) {
      goto LABEL_19;
    }
    BOOL v13 = 0;
  }
  if (v13 != (HTTPAuthentication::isConnectionBasedAuth(v14) != 0)) {
    goto LABEL_15;
  }
LABEL_19:
  uint64_t v15 = 1;
LABEL_16:
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  return v15;
}

void sub_184251364(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<AuthenticationState::isCompatible(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isCompatible(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA60F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::isCompatible(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isCompatible(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECFA60F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<AuthenticationState::isCompatible(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isCompatible(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

BOOL AuthenticationState::isEquivalent(AuthenticationState *this, AuthenticationState *a2)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  if (this)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
    BOOL v4 = a2 != 0;
    if (a2 == this || !a2)
    {
LABEL_15:
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
      return v4;
    }
LABEL_6:
    pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 8));
    char v10 = 1;
    int v5 = *((void *)this + 13) != 0;
    if (*((void *)this + 16)) {
      ++v5;
    }
    int v6 = *((void *)a2 + 13) != 0;
    if (*((void *)a2 + 16)) {
      ++v6;
    }
    if (v5 != v6) {
      goto LABEL_13;
    }
    uint64_t v7 = operator new(0x20uLL);
    void *v7 = &unk_1ECFA6138;
    v7[1] = this;
    void v7[2] = a2;
    v7[3] = &v10;
    v13[3] = v7;
    AuthenticationState::_foreachAuthenticationInfo((uint64_t)a2, (uint64_t)v13);
    std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](v13);
    if (v10)
    {
      unsigned int v12 = 0;
      char v8 = operator new(0x20uLL);
      *char v8 = &unk_1ECFA6180;
      v8[1] = this;
      void v8[2] = a2;
      v8[3] = &v10;
      unsigned int v12 = v8;
      AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v11);
      std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](v11);
      BOOL v4 = v10 != 0;
    }
    else
    {
LABEL_13:
      BOOL v4 = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)a2 + 8));
    goto LABEL_15;
  }
  BOOL v4 = a2 != 0;
  if (a2) {
    goto LABEL_6;
  }
  return v4;
}

void sub_1842515A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](va);
  pthread_mutex_unlock(v3);
  pthread_mutex_unlock((pthread_mutex_t *)(v2 + 8));
  _Unwind_Resume(a1);
}

BOOL std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_1,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2)
{
  BOOL result = AuthenticationState::_haveAuthenticationInfo(*(void *)(a1 + 16), *a2);
  if (!result) {
    **(unsigned char **)(a1 + 24) = 0;
  }
  return result;
}

__n128 std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_1,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA6180;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_1,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ECFA6180;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_1,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_1>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, void *a3)
{
  int v5 = *a2;
  uint64_t v6 = *(void *)(a1 + 8);
  if (AuthenticationState::_haveAuthenticationInfo(v6, *a2))
  {
    AuthenticationState::_authForType(&v10, v6, v5);
    uint64_t v7 = (void *)*a3;
    if (*a3 && v10[1] == v7[1] && v10[2] == v7[2] && v10[6] == v7[6])
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      **(unsigned char **)(a1 + 24) = 0;
    }
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
  }
  else
  {
    uint64_t v8 = 0;
    **(unsigned char **)(a1 + 24) = 0;
  }
  return v8;
}

__n128 std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA6138;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ECFA6138;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<AuthenticationState::isEquivalent(AuthenticationState*)::$_0,std::allocator<AuthenticationState::isEquivalent(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t std::__function::__func<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0,std::allocator<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, int *a2, uint64_t a3)
{
  BOOL v4 = *(HTTPAuthentication **)(*(void *)a3 + 8);
  if (!v4) {
    return 1;
  }
  int v5 = *a2;
  uint64_t v6 = *(void *)(a1 + 8);
  if (!HTTPAuthentication::isConnectionBasedAuth(v4)) {
    return 1;
  }
  if (AuthenticationState::_haveAuthenticationInfo(v6, v5))
  {
    AuthenticationState::_authForType(&v10, v6, v5);
    uint64_t v7 = *(HTTPAuthentication **)(v10 + 8);
    if (v7 && HTTPAuthentication::isConnectionBasedAuth(v7))
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      **(unsigned char **)(a1 + 24) = 1;
    }
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
  }
  else
  {
    uint64_t v8 = 0;
    **(unsigned char **)(a1 + 24) = 1;
  }
  return v8;
}

void sub_1842518FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0,std::allocator<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA62E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0,std::allocator<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ECFA62E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0,std::allocator<AuthenticationState::addsConnectionAuth(AuthenticationState*)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

void __ConditionalConnectionDUETSupport_ReportBytes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  v31[1] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (void *)MEMORY[0x18531D6D0]();
  double Helper_x8__OBJC_CLASS____DASScheduler = gotLoadHelper_x8__OBJC_CLASS____DASScheduler(v9);
  unsigned int v12 = objc_msgSend(*(id *)(v11 + 2648), "sharedScheduler", Helper_x8__OBJC_CLASS____DASScheduler);
  double Helper_x8___DASUpdateActivityCellTransferKey = gotLoadHelper_x8___DASUpdateActivityCellTransferKey(v13);
  double Helper_x9___DASUpdateActivityWifiTransferKey = gotLoadHelper_x9___DASUpdateActivityWifiTransferKey(Helper_x8___DASUpdateActivityCellTransferKey);
  double Helper_x9___DASUpdateActivityExpensiveTransferKey = gotLoadHelper_x9___DASUpdateActivityExpensiveTransferKey(Helper_x9___DASUpdateActivityWifiTransferKey);
  double Helper_x10___DASUpdateActivityInexpensiveTransferKey = gotLoadHelper_x10___DASUpdateActivityInexpensiveTransferKey(Helper_x9___DASUpdateActivityExpensiveTransferKey);
  double Helper_x10___DASUpdateActivityUploadedBytesKey = gotLoadHelper_x10___DASUpdateActivityUploadedBytesKey(Helper_x10___DASUpdateActivityInexpensiveTransferKey);
  double Helper_x11___DASUpdateActivityDownloadedBytesKey = gotLoadHelper_x11___DASUpdateActivityDownloadedBytesKey(Helper_x10___DASUpdateActivityUploadedBytesKey);
  BOOL v24 = *(uint64_t **)(v23 + 2888);
  if (!a5) {
    CFStringRef v21 = v24;
  }
  uint64_t v25 = *v21;
  uint64_t v30 = v19;
  uint64_t v28 = v20;
  uint64_t v26 = v25;
  uint64_t v27 = objc_msgSend(NSNumber, "numberWithUnsignedLong:", a2, Helper_x11___DASUpdateActivityDownloadedBytesKey);
  uint64_t v29 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v27 forKeys:&v26 count:1];
  v31[0] = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v29 forKeys:&v28 count:1];
  objc_msgSend(v12, "updateActivity:withParameters:", a1, objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v31, &v30, 1));
}

void non-virtual thunk to'HTTP2Stream::bufferDataAvailable(uint64_t a1, NSObject *a2)
{
}

void non-virtual thunk to'HTTP2Stream::~HTTP2Stream(HTTP2Stream *this)
{
  HTTP2Stream::~HTTP2Stream((HTTP2Stream *)((char *)this - 8));

  JUMPOUT(0x18531B6D0);
}

{
  HTTP2Stream::~HTTP2Stream((HTTP2Stream *)((char *)this - 8));
}

uint64_t HTTP2Stream::copyTrust(HTTP2Stream *this)
{
  uint64_t v1 = *((void *)this + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  uint64_t v2 = *(IOConnWrapper **)(v1 + 56);
  if (v2)
  {
    v6[3] = IOConnWrapper::copyProperty(v2, @"kCFStreamPropertySSLPeerTrust");
    uint64_t v3 = v6[3];
  }
  else
  {
    uint64_t v3 = 0;
  }
  _Block_object_dispose(&v5, 8);
  return v3;
}

void sub_184251DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11HTTP2Stream27_onqueue_notifyStreamClosedEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_DWORD *)(v1 + 192))
  {
    *(void *)(v1 + 184) = 4;
    *(_DWORD *)(v1 + 192) = -4;
  }
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 40) + 24) + 16))();
}

void non-virtual thunk to'HTTP2StreamBridge::~HTTP2StreamBridge(HTTP2StreamBridge *this)
{
}

{
  HTTP2StreamBridge::~HTTP2StreamBridge((HTTP2StreamBridge *)((char *)this - 16));
}

{
  HTTP2StreamBridge::~HTTP2StreamBridge((HTTP2StreamBridge *)((char *)this - 8));
}

{
  HTTP2StreamBridge::~HTTP2StreamBridge((HTTP2StreamBridge *)((char *)this - 8));
}

void non-virtual thunk to'HTTP2StreamBridge::setProxy(uint64_t a1, uint64_t *a2)
{
}

void HTTP2StreamBridge::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  uint64_t v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 112))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184251EA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'HTTP2StreamBridge::copyTrust(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 96))();
}

void HTTP2StreamBridge::_meta_release(HTTP2StreamBridge *this)
{
}

CFTypeRef HTTP2StreamBridge::_meta_retain(HTTP2StreamBridge *this)
{
  return CFRetain((char *)this - 16);
}

uint64_t HTTP2StreamBridge::getCurrentSuspensionThreshold(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 144))();
}

uint64_t HTTP2StreamBridge::getHTTPConnectionInfo(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 136))();
}

uint64_t HTTP2StreamBridge::setTransactionMetrics(HTTP2StreamBridge *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(void, __CFN_TransactionMetrics *))(**((void **)this + 3) + 16))(*((void *)this + 3), a2);
}

uint64_t HTTP2StreamBridge::getProxy(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 120))();
}

uint64_t HTTP2StreamBridge::_conn_no_more_reqests_after_this_one_connectionLost(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 104))();
}

uint64_t HTTP2StreamBridge::copyTrust(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 96))();
}

uint64_t HTTP2StreamBridge::getConnectionIdentifier(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 88))();
}

uint64_t HTTP2StreamBridge::rawBytesReceived(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 80))();
}

uint64_t HTTP2StreamBridge::rawBytesSent(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 72))();
}

uint64_t HTTP2StreamBridge::setBodyStreamBeforeOpening(HTTP2StreamBridge *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(void, __CFReadStream *))(**((void **)this + 3) + 64))(*((void *)this + 3), a2);
}

uint64_t HTTP2StreamBridge::setPriorityHint(HTTP2StreamBridge *this, float a2)
{
  return (*(uint64_t (**)(float))(**((void **)this + 3) + 128))(a2);
}

uint64_t HTTP2StreamBridge::updateScheduling(HTTP2StreamBridge *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(void, const CoreSchedulingSet *))(**((void **)this + 3) + 56))(*((void *)this + 3), a2);
}

uint64_t HTTP2StreamBridge::closeAndClearHandler(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 48))();
}

uint64_t HTTP2StreamBridge::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))();
}

uint64_t HTTP2StreamBridge::canScheduleAndOpenWithHandlerAsync(HTTP2StreamBridge *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 32))();
}

uint64_t HTTP2StreamBridge::setProperty(uint64_t a1, int a2, const void *a3)
{
  return HTTP2Stream::setProperty(*(void *)(a1 + 24), a2, a3);
}

CFNumberRef HTTP2StreamBridge::copyProperty(uint64_t a1, int a2)
{
  return HTTP2Stream::copyProperty(*(void **)(a1 + 24), a2);
}

__CFString *HTTP2StreamBridge::copyDebugDesc(HTTP2StreamBridge *this)
{
  return @"HTTP2MetaNetStreamInfoForwarder";
}

uint64_t HTTP2StreamBridge::hash(HTTP2StreamBridge *this)
{
  return *((void *)this + 3);
}

BOOL HTTP2StreamBridge::equals(HTTP2StreamBridge *this, const CFObject *a2)
{
  return *((void *)this + 3) == *((void *)a2 + 3);
}

void DataBuffer::_flushData(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *a1;
      if (*a1)
      {
        uint64_t v8 = *(void *)(a2 + 24);
        if (v8)
        {
          double v9 = *(void (**)(uint64_t))(a2 + 32);
          *(void *)(a2 + 24) = 0;
          (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 16))(v7, v8);
          v9(v8);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }
}

void sub_184252244(_Unwind_Exception *a1)
{
  v3(v2);
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void DataBuffer::initializeBuffering(uint64_t a1, dispatch_object_t object, uint64_t *a3)
{
  *(void *)(a1 + 48) = object;
  dispatch_retain(object);
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 64);
  *(void *)(a1 + 56) = v6;
  *(void *)(a1 + 64) = v5;
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(a1 + 48));
  *(void *)(a1 + 40) = v8;
  uint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 64);
  if (v10)
  {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v8 = *(NSObject **)(a1 + 40);
  }
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 3321888768;
  handler[2] = ___ZN10DataBuffer19initializeBufferingEPU28objcproto17OS_dispatch_queue8NSObjectNSt3__18weak_ptrI18DataBufferDelegateEE_block_invoke;
  handler[3] = &__block_descriptor_56_e8_40c43_ZTSNSt3__18weak_ptrI18DataBufferDelegateEE_e5_v8__0l;
  void handler[4] = a1;
  void handler[5] = v9;
  unsigned int v12 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_source_set_event_handler(v8, handler);
  dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 40), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(*(dispatch_object_t *)(a1 + 40));
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }
}

void ___ZN10DataBuffer19initializeBufferingEPU28objcproto17OS_dispatch_queue8NSObjectNSt3__18weak_ptrI18DataBufferDelegateEE_block_invoke(void *a1)
{
  uint64_t v1 = a1[4];
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  v3[0] = a1[5];
  v3[1] = (uint64_t)v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  DataBuffer::_flushData(v3, v1);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1842523F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c43_ZTSNSt3__18weak_ptrI18DataBufferDelegateEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_e8_40c43_ZTSNSt3__18weak_ptrI18DataBufferDelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void _release_dispatch_safe<NSObject  {objcproto18OS_dispatch_object}*>(dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
}

uint64_t ___ZN11HTTP2Stream10endHeadersEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 889;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void HTTP2Stream::didReceiveRSTStream(HTTP2Stream *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3) {
      uint64_t v4 = *((void *)this + 35);
    }
    else {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v3 = 0;
  }
  uint64_t v5 = *((void *)this + 9);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3321888768;
  void v6[2] = ___ZN11HTTP2Stream19didReceiveRSTStreamEv_block_invoke;
  v6[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
  _OWORD v6[4] = v4;
  uint64_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_async(v5, v6);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void ___ZN11HTTP2Stream19didReceiveRSTStreamEv_block_invoke(uint64_t a1)
{
}

void HTTP2Stream::handle_HTTP_1_1_REQUIRED_error(HTTP2Stream *this)
{
  CFURLRef v2 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(*((void *)this + 5) - 16));
  uint64_t v3 = (__CFString *)CFURLCopyHostName(v2);
  uint64_t v4 = *((void *)this + 2);
  if (v4) {
    uint64_t v5 = v4 - 176;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = [*(id *)(v5 + 80) session];
  if (v6) {
    -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:](v6, v3, 80);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v2)
  {
    CFRelease(v2);
  }
}

void sub_184252620(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<HTTP2Stream *,std::shared_ptr<HTTP2Stream>::__shared_ptr_default_delete<HTTP2Stream,HTTP2Stream>,std::allocator<HTTP2Stream>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t non-virtual thunk to'URLCredential::serializeToPropertyList(URLCredential *this, SerializableArchive **a2)
{
  return 1;
}

uint64_t URLCredential::serializeToPropertyList(URLCredential *this, SerializableArchive **a2)
{
  Serializable::serializeToPropertyList((URLCredential *)((char *)this + 8), a2);
  AutoScalar::AutoScalar((AutoScalar *)&v7, (const __CFAllocator *)*((unsigned int *)this + 8));
  CFTypeRef v4 = cf;
  SerializableArchive::assertEmpty(*a2, @"credKind");
  if (v4) {
    CFDictionarySetValue(*a2, @"credKind", v4);
  }
  uint64_t v7 = &unk_1ECF9A500;
  if (cf) {
    CFRelease(cf);
  }
  AutoScalar::AutoScalar((AutoScalar *)&v7, (const __CFAllocator *)*((unsigned int *)this + 9));
  CFTypeRef v5 = cf;
  SerializableArchive::assertEmpty(*a2, @"persistence");
  if (v5) {
    CFDictionarySetValue(*a2, @"persistence", v5);
  }
  uint64_t v7 = &unk_1ECF9A500;
  if (cf) {
    CFRelease(cf);
  }
  return 1;
}

void sub_1842527C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void SerializableArchive::assertEmpty(SerializableArchive *this, const __CFString *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (CFDictionaryGetValue(this, a2))
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      int v3 = 138412290;
      CFStringRef v4 = a2;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Key %@ already present", (uint8_t *)&v3, 0xCu);
    }
  }
}

BOOL non-virtual thunk to'URLCredential::initializeFromPropertyList(URLCredential *this, CFDictionaryRef *a2)
{
  return URLCredential::initializeFromPropertyList((URLCredential *)((char *)this - 8), a2);
}

BOOL URLCredential::initializeFromPropertyList(URLCredential *this, CFDictionaryRef *a2)
{
  BOOL result = Serializable::initializeFromPropertyList((uint64_t)this + 8, a2);
  if (result)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*a2, @"credKind");
    if (Value)
    {
      *(void *)uint64_t v9 = 0;
      CFNumberGetValue(Value, kCFNumberCFIndexType, v9);
      uint64_t v6 = *(void *)v9;
    }
    else
    {
      uint64_t v6 = 0;
    }
    if (v6 != *((_DWORD *)this + 8) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "unarchiving wrong type?", v9, 2u);
    }
    CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue(*a2, @"persistence");
    if (v7)
    {
      *(void *)uint64_t v9 = 0;
      CFNumberGetValue(v7, kCFNumberCFIndexType, v9);
      int v8 = *(_DWORD *)v9;
    }
    else
    {
      int v8 = 0;
    }
    *((_DWORD *)this + 9) = v8;
    return 1;
  }
  return result;
}

CFStringRef URLCredential::copyDebugSummary(URLCredential *this)
{
  int v2 = *((_DWORD *)this + 9);
  int v3 = "session";
  CFStringRef v4 = "Unknown";
  if (v2 == 3) {
    CFStringRef v4 = "permanent";
  }
  if (v2 != 2) {
    int v3 = v4;
  }
  if (v2 == 1) {
    uint64_t v5 = "none";
  }
  else {
    uint64_t v5 = v3;
  }
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v7 = *((void *)this + 7);
  if (!v7)
  {
    uint64_t v7 = (*(uint64_t (**)(URLCredential *))(*(void *)this + 104))(this);
    *((void *)this + 7) = v7;
  }
  return CFStringCreateWithFormat(v6, 0, @"Name: %@, Persistence: %s", v7, v5);
}

uint64_t URLCredential::hash(URLCredential *this)
{
  if (*((unsigned char *)this + 48)) {
    return *((void *)this + 5);
  }
  *((unsigned char *)this + 48) = 1;
  uint64_t result = (*(uint64_t (**)(URLCredential *, unint64_t))(*(void *)this + 96))(this, (8 * *((int *)this + 9)) | ((unint64_t)*((unsigned int *)this + 8) << 6));
  *((void *)this + 5) = result;
  return result;
}

void ___ZN13URLCredential5ClassEv_block_invoke()
{
}

void sub_184252B54(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void URLCredential::~URLCredential(URLCredential *this)
{
  *(void *)this = &unk_1ECF9C5D8;
  *((void *)this + 1) = &unk_1ECF9C658;
  *((void *)this + 3) = &unk_1ECF9C688;
  int v2 = (const void *)*((void *)this + 7);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 3) = &unk_1ECF9B550;
}

void sub_184252C20(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

BOOL URLCredential::equals(URLCredential *this, const CFObject *a2)
{
  if (*((_DWORD *)this + 8) == *((_DWORD *)a2 + 8)
    && (uint64_t v4 = (*(uint64_t (**)(URLCredential *))(*(void *)this + 8))(this),
        v4 == (*(uint64_t (**)(const CFObject *))(*(void *)a2 + 8))(a2)))
  {
    return *((_DWORD *)this + 9) == *((_DWORD *)a2 + 9);
  }
  else
  {
    return 0;
  }
}

void Archiver<URLCredential,_CFURLCredential const*>::~Archiver(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 8);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

uint64_t Archiver<URLCredential,_CFURLCredential const*>::~Archiver(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

URLCredentialInternetPassword *URLCredential::createFromPropertyList(URLCredential *this, CFDictionaryRef theDict, const void *a3)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"credKind");
  if (!Value) {
    return 0;
  }
  cf[0] = 0;
  CFNumberGetValue(Value, kCFNumberCFIndexType, cf);
  CFAllocatorRef v6 = 0;
  switch((unint64_t)cf[0])
  {
    case 0uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      CFAllocatorRef v6 = (URLCredentialInternetPassword *)Instance;
      if (Instance)
      {
        *(_OWORD *)(Instance + CFRelease((char *)this - 16) = 0u;
        CFAllocatorRef v6 = (URLCredentialInternetPassword *)(Instance + 16);
        *(void *)(Instance + 112) = 0;
        *(_OWORD *)(Instance + 80) = 0u;
        *(_OWORD *)(Instance + 96) = 0u;
        *(_OWORD *)(Instance + 48) = 0u;
        *(_OWORD *)(Instance + 64) = 0u;
        *(_OWORD *)(Instance + 32) = 0u;
      }
      URLCredentialInternetPassword::URLCredentialInternetPassword(v6);
      if (v6) {
        goto LABEL_45;
      }
      break;
    case 1uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      uint64_t v8 = _CFRuntimeCreateInstance();
      CFAllocatorRef v6 = (URLCredentialInternetPassword *)v8;
      if (v8)
      {
        *(_OWORD *)(v8 + CFRelease((char *)this - 16) = 0u;
        CFAllocatorRef v6 = (URLCredentialInternetPassword *)(v8 + 16);
        *(void *)(v8 + 80) = 0;
        *(_OWORD *)(v8 + 48) = 0u;
        *(_OWORD *)(v8 + 64) = 0u;
        *(_OWORD *)(v8 + 32) = 0u;
      }
      URLCredentialServerTrust::URLCredentialServerTrust(v6);
      if (v6) {
        goto LABEL_45;
      }
      break;
    case 2uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      uint64_t v9 = (_OWORD *)_CFRuntimeCreateInstance();
      CFAllocatorRef v6 = (URLCredentialInternetPassword *)v9;
      if (v9)
      {
        v9[1] = 0u;
        CFAllocatorRef v6 = (URLCredentialInternetPassword *)(v9 + 1);
        void v9[5] = 0u;
        void v9[6] = 0u;
        void v9[3] = 0u;
        v9[4] = 0u;
        v9[2] = 0u;
      }
      URLCredentialKerberosTicket::URLCredentialKerberosTicket(v6);
      if (v6) {
        goto LABEL_45;
      }
      break;
    case 3uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      uint64_t v10 = (_OWORD *)_CFRuntimeCreateInstance();
      CFAllocatorRef v6 = (URLCredentialInternetPassword *)v10;
      if (v10)
      {
        v10[1] = 0u;
        CFAllocatorRef v6 = (URLCredentialInternetPassword *)(v10 + 1);
        v10[4] = 0u;
        void v10[5] = 0u;
        v10[2] = 0u;
        v10[3] = 0u;
      }
      URLCredentialClientCertificate::URLCredentialClientCertificate(v6);
      if (v6) {
        goto LABEL_45;
      }
      break;
    case 4uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      uint64_t v11 = (_OWORD *)_CFRuntimeCreateInstance();
      CFAllocatorRef v6 = (URLCredentialInternetPassword *)v11;
      if (v11)
      {
        v11[1] = 0u;
        CFAllocatorRef v6 = (URLCredentialInternetPassword *)(v11 + 1);
        void v11[5] = 0u;
        v11[6] = 0u;
        void v11[3] = 0u;
        v11[4] = 0u;
        void v11[2] = 0u;
      }
      URLCredentialXMobileMeAuthToken::URLCredentialXMobileMeAuthToken(v6);
      if (v6) {
        goto LABEL_45;
      }
      break;
    case 6uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      unsigned int v12 = (_OWORD *)_CFRuntimeCreateInstance();
      CFAllocatorRef v6 = (URLCredentialInternetPassword *)v12;
      if (v12)
      {
        v12[1] = 0u;
        CFAllocatorRef v6 = (URLCredentialInternetPassword *)(v12 + 1);
        v12[4] = 0u;
        void v12[5] = 0u;
        v12[2] = 0u;
        v12[3] = 0u;
      }
      URLCredentialOAuth2::URLCredentialOAuth2(v6);
      if (v6) {
        goto LABEL_45;
      }
      break;
    case 7uLL:
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      uint64_t v13 = _CFRuntimeCreateInstance();
      CFAllocatorRef v6 = (URLCredentialInternetPassword *)v13;
      if (v13)
      {
        *(_OWORD *)(v13 + CFRelease((char *)this - 16) = 0u;
        CFAllocatorRef v6 = (URLCredentialInternetPassword *)(v13 + 16);
        *(void *)(v13 + 96) = 0;
        *(_OWORD *)(v13 + 64) = 0u;
        *(_OWORD *)(v13 + 80) = 0u;
        *(_OWORD *)(v13 + 32) = 0u;
        *(_OWORD *)(v13 + 48) = 0u;
      }
      URLCredentialOAuth1::URLCredentialOAuth1(v6);
      if (v6)
      {
LABEL_45:
        cf[1] = this;
        if (theDict) {
          CFTypeRef v14 = CFRetain(theDict);
        }
        else {
          CFTypeRef v14 = 0;
        }
        cf[0] = v14;
        if (!(*(unsigned int (**)(URLCredentialInternetPassword *, CFTypeRef *))(*(void *)v6 + 64))(v6, cf))
        {
          CFRelease((char *)v6 - 16);
          CFAllocatorRef v6 = 0;
        }
        if (cf[0]) {
          CFRelease(cf[0]);
        }
      }
      break;
    default:
      return v6;
  }
  return v6;
}

void sub_18425316C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t URLCredential_PasswordBased::safelyCast(uint64_t this, const _CFURLCredential *a2)
{
  if (!this) {
    goto LABEL_5;
  }
  uint64_t v2 = this;
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  this = v2 + 16;
  if (*(_DWORD *)(v2 + 48))
  {
LABEL_5:
    if (*(_DWORD *)(this + 32) != 4) {
      return 0;
    }
  }
  return this;
}

uint64_t non-virtual thunk to'URLAuthChallenge::serializeToPropertyList(URLAuthChallenge *this, SerializableArchive **a2)
{
  return 1;
}

uint64_t URLAuthChallenge::serializeToPropertyList(URLAuthChallenge *this, SerializableArchive **a2)
{
  Serializable::serializeToPropertyList((URLAuthChallenge *)((char *)this + 8), a2);
  SerializableArchive::add(a2, @"space", *((_CFURLProtectionSpace **)this + 3));
  SerializableArchive::add(a2, @"proposed", *((const _CFURLCredential **)this + 4));
  AutoScalar::AutoScalar((AutoScalar *)&v6, (const __CFAllocator *)*((unsigned int *)this + 10));
  CFTypeRef v4 = cf;
  SerializableArchive::assertEmpty(*a2, @"count");
  if (v4) {
    CFDictionarySetValue(*a2, @"count", v4);
  }
  CFAllocatorRef v6 = &unk_1ECF9A500;
  if (cf) {
    CFRelease(cf);
  }
  SerializableArchive::add(a2, @"response", *((void **)this + 6));
  SerializableArchive::add((CFTypeRef *)a2, @"error", *((__CFError **)this + 7));
  SerializableArchive::add((CFTypeRef *)a2, @"spaces", *((const __CFArray **)this + 8));
  return 1;
}

void sub_184253334(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2, _CFURLProtectionSpace *a3)
{
  if (a3)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
    }
    SerializableArchive::assertEmpty(*this, a2);
    CFAllocatorRef v6 = CFGetAllocator(*this);
    CFTypeRef cf = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if ((*(unsigned int (**)(char *, CFTypeRef *))(*((void *)a3 + 3) + 24))((char *)a3 + 24, &cf)) {
      SerializableArchive::add((SerializableArchive *)this, a2, (CFDictionaryRef)cf);
    }
    if (cf) {
      CFRelease(cf);
    }
  }
}

void sub_184253448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2, const _CFURLCredential *a3)
{
  if (a3)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    SerializableArchive::assertEmpty(*this, a2);
    CFAllocatorRef v6 = CFGetAllocator(*this);
    CFTypeRef cf = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if ((*(unsigned int (**)(char *, CFTypeRef *))(*((void *)a3 + 3) + 24))((char *)a3 + 24, &cf)) {
      SerializableArchive::add((SerializableArchive *)this, a2, (CFDictionaryRef)cf);
    }
    if (cf) {
      CFRelease(cf);
    }
  }
}

void sub_184253540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

BOOL non-virtual thunk to'URLAuthChallenge::initializeFromPropertyList(URLAuthChallenge *this, CFDictionaryRef *a2)
{
  return URLAuthChallenge::initializeFromPropertyList((URLAuthChallenge *)((char *)this - 8), a2);
}

BOOL URLAuthChallenge::initializeFromPropertyList(URLAuthChallenge *this, CFDictionaryRef *a2)
{
  BOOL result = Serializable::initializeFromPropertyList((uint64_t)this + 8, a2);
  if (result)
  {
    int valuePtr = 0;
    DeserializableArchive::decant(a2, @"space", (Serializable **)&valuePtr);
    if (valuePtr) {
      uint64_t v5 = valuePtr - 3;
    }
    else {
      uint64_t v5 = 0;
    }
    *((void *)this + 3) = v5;
    int valuePtr = 0;
    DeserializableArchive::decant(a2, @"proposed", (Serializable **)&valuePtr);
    if (valuePtr) {
      CFAllocatorRef v6 = valuePtr - 3;
    }
    else {
      CFAllocatorRef v6 = 0;
    }
    *((void *)this + 4) = v6;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*a2, @"count");
    if (Value)
    {
      int valuePtr = 0;
      CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
      uint64_t v8 = valuePtr;
    }
    else
    {
      uint64_t v8 = 0;
    }
    *((void *)this + 5) = v8;
    int valuePtr = 0;
    uint64_t v9 = (objc_class *)objc_opt_class();
    DeserializableArchive::decantClass(a2, @"response", v9, &valuePtr);
    *((void *)this + 6) = valuePtr;
    int valuePtr = 0;
    CFTypeID TypeID = CFErrorGetTypeID();
    DeserializableArchive::decant(a2, @"error", TypeID, (CFErrorRef *)&valuePtr);
    *((void *)this + 7) = valuePtr;
    int valuePtr = 0;
    CFTypeID v11 = CFArrayGetTypeID();
    DeserializableArchive::decant(a2, @"spaces", v11, (CFErrorRef *)&valuePtr);
    *((void *)this + 8) = valuePtr;
    return 1;
  }
  return result;
}

void non-virtual thunk to'URLAuthChallenge::~URLAuthChallenge(URLAuthChallenge *this)
{
}

{
  URLAuthChallenge::~URLAuthChallenge((URLAuthChallenge *)((char *)this - 8));
}

CFStringRef URLAuthChallenge::copyDebugSummary(URLAuthChallenge *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
    }
    uint64_t v2 = (void *)(*(uint64_t (**)(void *))(v2[2] + 32))(v2 + 2);
  }
  int v3 = (void *)*((void *)this + 6);
  if (!v3)
  {
    CFAllocatorRef v9 = CFGetAllocator((char *)this - 16);
    CFStringRef v7 = CFStringCreateWithFormat(v9, 0, @"challenge space %@", v2);
    if (!v2) {
      return v7;
    }
    goto LABEL_9;
  }
  uint64_t v4 = [v3 _inner];
  uint64_t v5 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
  CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
  CFStringRef v7 = CFStringCreateWithFormat(v6, 0, @"challenge space %@, failing response %@", v2, v5);
  if (v5) {
    CFRelease(v5);
  }
  if (v2) {
LABEL_9:
  }
    CFRelease(v2);
  return v7;
}

CFStringRef URLAuthChallenge::copyDebugDesc(URLAuthChallenge *this)
{
  uint64_t v2 = (char *)this - 16;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  uint64_t v4 = *((void *)this + 3);
  uint64_t v5 = *((void *)this + 4);
  uint64_t v6 = *((void *)this + 5);
  uint64_t v7 = *((void *)this + 6);
  CFIndex Code = (__CFError *)*((void *)this + 7);
  if (Code)
  {
    CFErrorDomain Domain = CFErrorGetDomain(Code);
    CFIndex Code = (__CFError *)*((void *)this + 7);
    if (Code) {
      CFIndex Code = (__CFError *)CFErrorGetCode(Code);
    }
  }
  else
  {
    CFErrorDomain Domain = @"none";
  }
  return CFStringCreateWithFormat(v3, 0, @"<CFURLAuthChallenge %p>{space = %@, proposedCredential = %@, previousFailureuint64_t Count = %ld, failureResponse = %@, error = %@/%ld}", v2, v4, v5, v6, v7, Domain, Code);
}

uint64_t URLAuthChallenge::equals(URLAuthChallenge *this, const CFObject *a2)
{
  if (*((void *)this + 5) != *((void *)a2 + 5)) {
    return 0;
  }
  uint64_t v4 = (const void *)*((void *)this + 3);
  uint64_t v5 = (const void *)*((void *)a2 + 3);
  if (v4 == v5 || (uint64_t result = CFEqual(v4, v5), result))
  {
    uint64_t v7 = (const void *)*((void *)this + 4);
    uint64_t v8 = (const void *)*((void *)a2 + 4);
    if (v7 == v8 || (uint64_t result = CFEqual(v7, v8), result))
    {
      CFAllocatorRef v9 = (const void *)*((void *)this + 6);
      uint64_t v10 = (const void *)*((void *)a2 + 6);
      if (v9 == v10 || (uint64_t result = CFEqual(v9, v10), result))
      {
        CFTypeID v11 = (const void *)*((void *)this + 7);
        unsigned int v12 = (const void *)*((void *)a2 + 7);
        if (v11 == v12 || (uint64_t result = CFEqual(v11, v12), result))
        {
          uint64_t v13 = (const void *)*((void *)this + 8);
          CFTypeRef v14 = (const void *)*((void *)a2 + 8);
          if (v13 == v14) {
            return *((void *)this + 9) == *((void *)a2 + 9);
          }
          uint64_t result = CFEqual(v13, v14);
          if (result) {
            return *((void *)this + 9) == *((void *)a2 + 9);
          }
        }
      }
    }
  }
  return result;
}

CFTypeRef URLAuthChallenge::setListOfProtectionSpaces(URLAuthChallenge *this, CFTypeRef cf)
{
  uint64_t v4 = (const void *)*((void *)this + 8);
  if (v4)
  {
    *((void *)this + 8) = 0;
    CFRelease(v4);
  }
  if (cf) {
    CFTypeRef result = CFRetain(cf);
  }
  else {
    CFTypeRef result = 0;
  }
  *((void *)this + 8) = result;
  return result;
}

uint64_t URLAuthChallenge::tryNextProtectionSpace(URLAuthChallenge *this)
{
  uint64_t result = *((void *)this + 8);
  if (result)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)result);
    CFIndex v4 = *((void *)this + 9) + 1;
    if (v4 >= Count)
    {
      return 0;
    }
    else
    {
      uint64_t v5 = (const void *)*((void *)this + 3);
      *((void *)this + 3) = 0;
      if (v5)
      {
        CFRelease(v5);
        CFIndex v4 = *((void *)this + 9) + 1;
      }
      uint64_t result = (uint64_t)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 8), v4);
      if (result)
      {
        *((void *)this + 3) = CFRetain((CFTypeRef)result);
        ++*((void *)this + 9);
        return 1;
      }
    }
  }
  return result;
}

void non-virtual thunk to'NetworkProxyCredential::~NetworkProxyCredential(NetworkProxyCredential *this)
{
  uint64_t v2 = (char *)this - 24;
  NetworkProxyCredential::~NetworkProxyCredential((NetworkProxyCredential *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  NetworkProxyCredential::~NetworkProxyCredential((NetworkProxyCredential *)((char *)this - 24));
}

void NetworkProxyCredential::~NetworkProxyCredential(NetworkProxyCredential *this)
{
  *(void *)this = &unk_1ECFA24F0;
  *((void *)this + 3) = &unk_1ECFA2538;
  uint64_t v2 = (const void *)*((void *)this + 4);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  NetworkProxyCredential::~NetworkProxyCredential(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_184253AE0(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t NetworkProxyCredential::hash(NetworkProxyCredential *this)
{
  return *((void *)this + 6);
}

BOOL NetworkProxyCredential::equals(NetworkProxyCredential *this, const CFAllocatedReferenceCountedObject *a2)
{
  if (!a2) {
    return 0;
  }
  unint64_t v2 = *((void *)this + 4);
  unint64_t v3 = *((void *)a2 + 4);
  BOOL result = (v2 | v3) == 0;
  if (v2) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    return CFEqual((CFTypeRef)v2, (CFTypeRef)v3) != 0;
  }
  return result;
}

void NetworkProxyCredential::copyDebugDesc(CFAllocatorRef *this)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((unsigned int *)this + 10);
  if (v1 >= 3)
  {
    *(_DWORD *)long long buf = 67109120;
    int v3 = v1;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Unknown viability type %d", buf, 8u);
    __break(1u);
  }
  else
  {
    CFStringCreateWithFormat(this[1], 0, @"<NetworkProxyCredential %p>{viability=%@, cred=%p}", this, *((void *)&off_1E5255580 + v1), this[4]);
  }
}

void NetworkProxyCredential::NetworkProxyCredential(NetworkProxyCredential *this, const __CFAllocator *a2, const _CFURLCredential *a3)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, a2);
  *BOOL v5 = &unk_1ECFA24F0;
  v5[3] = &unk_1ECFA2538;
  if (a3) {
    CFTypeRef v6 = CFRetain(a3);
  }
  else {
    CFTypeRef v6 = 0;
  }
  *((void *)this + 4) = v6;
  *((void *)this + 6) = CFHash(v6);
  *((_DWORD *)this + 10) = 0;
}

void sub_184253CF8(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void NetworkProxyCredential::NetworkProxyCredential(NetworkProxyCredential *this, const __CFAllocator *a2, const __CFDictionary *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, a2);
  *BOOL v5 = &unk_1ECFA24F0;
  v5[3] = &unk_1ECFA2538;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a3, @"kNetworkProxyCredentialKeyCredential");
  if (Value)
  {
    uint64_t v8 = URLCredential::createFromPropertyList(*((URLCredential **)this + 1), Value, v7);
    CFAllocatorRef v9 = (char *)v8 - 16;
    if (!v8) {
      CFAllocatorRef v9 = 0;
    }
    *((void *)this + 4) = v9;
  }
  CFNumberRef v10 = (const __CFNumber *)CFDictionaryGetValue(a3, @"kNetworkProxyCredentialKeyViability");
  CFNumberRef v11 = v10;
  if (v10)
  {
    CFTypeID v12 = CFGetTypeID(v10);
    if (v12 == CFNumberGetTypeID())
    {
      unint64_t valuePtr = 0;
      CFNumberGetValue(v11, kCFNumberCFIndexType, &valuePtr);
      int v13 = valuePtr;
      if (valuePtr > 2)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        CFTypeRef v14 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 134217984;
          unint64_t v18 = valuePtr;
          _os_log_error_impl(&dword_184085000, v14, OS_LOG_TYPE_ERROR, "Archived viability (%ld) outside of expected range", buf, 0xCu);
        }
        int v13 = 0;
      }
      *((_DWORD *)this + 10) = v13;
    }
  }
  uint64_t v15 = (const void *)*((void *)this + 4);
  if (v15) {
    uint64_t v15 = (const void *)CFHash(v15);
  }
  *((void *)this + 6) = v15;
}

void sub_184253ED0(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

__CFDictionary *NetworkProxyCredential::createSerializedCredential(CFAllocatorRef *this)
{
  CFTypeRef Mutable = CFDictionaryCreateMutable(this[1], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v3 = (uint64_t)this[4];
  if (v3)
  {
    CFTypeRef Archive = _CFURLCredentialCreateArchive(this[1], v3);
    if (Archive)
    {
      BOOL v5 = Archive;
      CFDictionaryAddValue(Mutable, @"kNetworkProxyCredentialKeyCredential", Archive);
      CFRelease(v5);
    }
  }
  CFNumberRef v6 = CFNumberCreate(this[1], kCFNumberCFIndexType, this + 5);
  if (v6)
  {
    CFNumberRef v7 = v6;
    CFDictionaryAddValue(Mutable, @"kNetworkProxyCredentialKeyViability", v6);
    CFRelease(v7);
  }
  return Mutable;
}

void CFNetworkProxyCredentialCreateWithCredential(const __CFAllocator *a1, const _CFURLCredential *a2)
{
  uint64_t v4 = CFAllocatorAllocate(a1, 56, 0);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  void v4[2] = 0u;
  *((void *)v4 + 6) = 0;

  NetworkProxyCredential::NetworkProxyCredential((NetworkProxyCredential *)v4, a1, a2);
}

uint64_t CFNetworkProxyCredentialRetain(uint64_t a1)
{
  return a1;
}

uint64_t CFNetworkProxyCredentialRelease(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t CFNetworkProxyCredentialEqual(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 24))();
}

uint64_t CFNetworkProxyCredentialCopyDebugDescription(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

CFDataRef CFNetworkProxyCredentialCreateData(CFAllocatorRef *a1)
{
  SerializedCredential = NetworkProxyCredential::createSerializedCredential(a1);
  if (!SerializedCredential) {
    return 0;
  }
  uint64_t v3 = SerializedCredential;
  CFErrorRef error = 0;
  CFDataRef v4 = CFPropertyListCreateData(a1[1], SerializedCredential, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  if (error) {
    CFRelease(error);
  }
  CFRelease(v3);
  return v4;
}

uint64_t CFNetworkProxyCredentialSetViability(uint64_t result, int a2)
{
  *(_DWORD *)(result + 40) = a2;
  return result;
}

uint64_t CFNetworkProxyCredentialGetCredential(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t non-virtual thunk to'URLProtectionSpace::serializeToPropertyList(URLProtectionSpace *this, SerializableArchive **a2)
{
  return 1;
}

uint64_t URLProtectionSpace::serializeToPropertyList(URLProtectionSpace *this, SerializableArchive **a2)
{
  Serializable::serializeToPropertyList((URLProtectionSpace *)((char *)this + 8), a2);
  CFDataRef v4 = (const void *)*((void *)this + 4);
  SerializableArchive::assertEmpty(*a2, @"host");
  if (v4) {
    CFDictionarySetValue(*a2, @"host", v4);
  }
  AutoScalar::AutoScalar((AutoScalar *)&v10, (const __CFAllocator *)*((unsigned int *)this + 10));
  CFTypeRef v5 = cf;
  SerializableArchive::assertEmpty(*a2, @"port");
  if (v5) {
    CFDictionarySetValue(*a2, @"port", v5);
  }
  CFNumberRef v10 = &unk_1ECF9A500;
  if (cf) {
    CFRelease(cf);
  }
  AutoScalar::AutoScalar((AutoScalar *)&v10, (const __CFAllocator *)*((unsigned int *)this + 11));
  CFTypeRef v6 = cf;
  SerializableArchive::assertEmpty(*a2, @"type");
  if (v6) {
    CFDictionarySetValue(*a2, @"type", v6);
  }
  CFNumberRef v10 = &unk_1ECF9A500;
  if (cf) {
    CFRelease(cf);
  }
  CFNumberRef v7 = (const void *)*((void *)this + 6);
  SerializableArchive::assertEmpty(*a2, @"realm");
  if (v7) {
    CFDictionarySetValue(*a2, @"realm", v7);
  }
  AutoScalar::AutoScalar((AutoScalar *)&v10, (const __CFAllocator *)*((unsigned int *)this + 14));
  CFTypeRef v8 = cf;
  SerializableArchive::assertEmpty(*a2, @"scheme");
  if (v8) {
    CFDictionarySetValue(*a2, @"scheme", v8);
  }
  CFNumberRef v10 = &unk_1ECF9A500;
  if (cf) {
    CFRelease(cf);
  }
  SerializableArchive::add((CFTypeRef *)a2, @"distnames", *((const __CFArray **)this + 8));
  SerializableArchive::add((CFTypeRef *)a2, @"trust", *((__SecTrust **)this + 9));
  return 1;
}

void sub_184254354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

BOOL non-virtual thunk to'URLProtectionSpace::initializeFromPropertyList(URLProtectionSpace *this, CFDictionaryRef *a2)
{
  return URLProtectionSpace::initializeFromPropertyList((URLProtectionSpace *)((char *)this - 8), a2);
}

BOOL URLProtectionSpace::initializeFromPropertyList(URLProtectionSpace *this, CFDictionaryRef *a2)
{
  BOOL result = Serializable::initializeFromPropertyList((uint64_t)this + 8, a2);
  if (result)
  {
    CFDictionaryRef Value = CFDictionaryGetValue(*a2, @"host");
    if (Value) {
      CFDictionaryRef Value = CFRetain(Value);
    }
    *((void *)this + 4) = Value;
    CFNumberRef v6 = (const __CFNumber *)CFDictionaryGetValue(*a2, @"port");
    if (v6)
    {
      unint64_t valuePtr = 0;
      CFNumberGetValue(v6, kCFNumberCFIndexType, &valuePtr);
      int v7 = (int)valuePtr;
    }
    else
    {
      int v7 = 0;
    }
    *((_DWORD *)this + 10) = v7;
    CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue(*a2, @"type");
    if (v8)
    {
      unint64_t valuePtr = 0;
      CFNumberGetValue(v8, kCFNumberCFIndexType, &valuePtr);
      int v9 = (int)valuePtr;
    }
    else
    {
      int v9 = 0;
    }
    *((_DWORD *)this + 11) = v9;
    CFNumberRef v10 = CFDictionaryGetValue(*a2, @"realm");
    if (v10) {
      CFNumberRef v10 = CFRetain(v10);
    }
    *((void *)this + 6) = v10;
    CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(*a2, @"scheme");
    if (v11)
    {
      unint64_t valuePtr = 0;
      CFNumberGetValue(v11, kCFNumberCFIndexType, &valuePtr);
      int v12 = (int)valuePtr;
    }
    else
    {
      int v12 = 0;
    }
    *((_DWORD *)this + 14) = v12;
    unint64_t valuePtr = 0;
    CFTypeID TypeID = CFArrayGetTypeID();
    DeserializableArchive::decant((DeserializableArchive *)a2, @"distnames", TypeID, &valuePtr);
    *((void *)this + 8) = valuePtr;
    unint64_t valuePtr = 0;
    CFTypeID v14 = SecTrustGetTypeID();
    DeserializableArchive::decant((DeserializableArchive *)a2, @"trust", v14, &valuePtr);
    *((void *)this + 9) = valuePtr;
    URLProtectionSpace::calcHash(this);
    return 1;
  }
  return result;
}

void non-virtual thunk to'URLProtectionSpace::~URLProtectionSpace(URLProtectionSpace *this)
{
}

{
  URLProtectionSpace::~URLProtectionSpace((URLProtectionSpace *)((char *)this - 8));
}

CFStringRef URLProtectionSpace::copyDebugSummary(URLProtectionSpace *this)
{
  CFStringRef v2 = URLProtectionSpace::copyNameForIdentityPreference(this);
  unsigned int v3 = *((_DWORD *)this + 14) - 1;
  if (v3 > 0xB) {
    CFDataRef v4 = "?";
  }
  else {
    CFDataRef v4 = off_1E5255598[v3];
  }
  CFAllocatorRef v5 = CFGetAllocator((char *)this - 16);
  uint64_t v6 = (*(uint64_t (**)(URLProtectionSpace *))(*(void *)this + 8))(this);
  CFStringRef v7 = CFStringCreateWithFormat(v5, 0, @"%@, %s (Hash %lx)", v2, v4, v6);
  if (v2) {
    CFRelease(v2);
  }
  return v7;
}

CFStringRef URLProtectionSpace::copyNameForIdentityPreference(URLProtectionSpace *this)
{
  unsigned int v2 = *((_DWORD *)this + 11) - 1;
  if (v2 > 7)
  {
    LODWORD(v4) = 0;
    unsigned int v3 = @"unknown_scheme";
  }
  else
  {
    unsigned int v3 = off_1E52555F8[v2];
    LODWORD(v4) = dword_18430BFD8[v2];
  }
  if (*((void *)this + 4)) {
    CFAllocatorRef v5 = (__CFString *)*((void *)this + 4);
  }
  else {
    CFAllocatorRef v5 = @"unknown_host";
  }
  if (*((void *)this + 6)) {
    CFStringRef v6 = (const __CFString *)*((void *)this + 6);
  }
  else {
    CFStringRef v6 = @"/";
  }
  int CharacterAtIndex = CFStringGetCharacterAtIndex(v6, 0);
  unsigned int v8 = *((_DWORD *)this + 10);
  if (v8) {
    uint64_t v4 = v8;
  }
  else {
    uint64_t v4 = v4;
  }
  CFAllocatorRef v9 = CFGetAllocator((char *)this - 16);
  uint64_t v10 = 47;
  if (CharacterAtIndex == 47) {
    uint64_t v10 = 0;
  }
  return CFStringCreateWithFormat(v9, 0, @"%@://%@:%d%c%@", v3, v5, v4, v10, v6);
}

CFStringRef URLProtectionSpace::copyDebugDesc(URLProtectionSpace *this)
{
  unsigned int v2 = (char *)this - 16;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, @"<CFURLProtectionSpace %p>{host = %@, port = %d, realm = %@, serverType = %d, authenticationScheme = %d}", v2, *((void *)this + 4), *((unsigned int *)this + 10), *((void *)this + 6), *((unsigned int *)this + 11), *((unsigned int *)this + 14));
}

uint64_t URLProtectionSpace::hash(URLProtectionSpace *this)
{
  return *((void *)this + 3);
}

uint64_t URLProtectionSpace::equals(URLProtectionSpace *this, const CFObject *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (this == a2) {
    return 1;
  }
  CFTypeID v4 = CFGetTypeID((char *)this - 16);
  if (v4 != CFGetTypeID((char *)a2 - 16)
    || *((void *)this + 3) != *((void *)a2 + 3)
    || *((_DWORD *)this + 10) != *((_DWORD *)a2 + 10))
  {
    return 0;
  }
  CFAllocatorRef v5 = (const void *)*((void *)this + 4);
  CFStringRef v6 = (const void *)*((void *)a2 + 4);
  if (v5)
  {
    if (!v6) {
      return 0;
    }
    uint64_t result = CFEqual(v5, v6);
    if (!result) {
      return result;
    }
  }
  else if (v6)
  {
    return 0;
  }
  CFStringRef v8 = (const __CFString *)*((void *)this + 6);
  CFStringRef v9 = (const __CFString *)*((void *)a2 + 6);
  if (v8)
  {
    if (!v9) {
      goto LABEL_19;
    }
    if (CFEqual(v8, v9)) {
      goto LABEL_20;
    }
    if (*((void *)this + 6)) {
      goto LABEL_17;
    }
    CFStringRef v9 = (const __CFString *)*((void *)a2 + 6);
  }
  if (!v9) {
    goto LABEL_20;
  }
  if (CFStringGetLength(v9) > 0) {
    return 0;
  }
LABEL_17:
  if (!*((void *)a2 + 6))
  {
    CFStringRef v8 = (const __CFString *)*((void *)this + 6);
    if (v8)
    {
LABEL_19:
      if (CFStringGetLength(v8) <= 0) {
        goto LABEL_20;
      }
      return 0;
    }
  }
LABEL_20:
  if (*((_DWORD *)this + 11) != *((_DWORD *)a2 + 11)) {
    return 0;
  }
  if (!*((unsigned char *)this + 80) && !*((unsigned char *)a2 + 80))
  {
    int v16 = *((_DWORD *)this + 14);
    if (v16 == 1) {
      return 1;
    }
    int v17 = *((_DWORD *)a2 + 14);
    return v17 == 1 || v16 == v17;
  }
  if (*((_DWORD *)this + 14) == *((_DWORD *)a2 + 14)) {
    return 1;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v10 = CFNLog::logger;
  BOOL v11 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v11)
  {
    uint64_t v12 = *((void *)this + 4);
    int v13 = *((_DWORD *)this + 14);
    uint64_t v14 = *((void *)a2 + 4);
    int v15 = *((_DWORD *)a2 + 14);
    int v18 = 138413058;
    uint64_t v19 = v12;
    __int16 v20 = 1024;
    int v21 = v13;
    __int16 v22 = 2112;
    uint64_t v23 = v14;
    __int16 v24 = 1024;
    int v25 = v15;
    _os_log_impl(&dword_184085000, v10, OS_LOG_TYPE_DEFAULT, "Strict auth scheme mismatch (%@ %d) (%@ %d)", (uint8_t *)&v18, 0x22u);
    return 0;
  }
  return result;
}

uint64_t URLProtectionSpace::getSecAttrProtocol(URLProtectionSpace *this)
{
  switch((int)this)
  {
    case 1:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F3B7E8];
      goto LABEL_11;
    case 2:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F3B7F8];
      goto LABEL_11;
    case 3:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F3B7D0];
      goto LABEL_11;
    case 4:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F3B7E0];
      goto LABEL_11;
    case 5:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F3B7F0];
      goto LABEL_11;
    case 6:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F3B800];
      goto LABEL_11;
    case 7:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F3B7D8];
      goto LABEL_11;
    case 8:
      uint64_t v1 = (uint64_t *)MEMORY[0x1E4F3B818];
LABEL_11:
      uint64_t result = *v1;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t URLProtectionSpace::stringForProtSpaceAuthScheme(int a1)
{
  uint64_t result = 0;
  switch(a1)
  {
    case 2:
      CFAllocatorRef v3 = (uint64_t *)&kCFHTTPAuthenticationSchemeBasic;
      goto LABEL_10;
    case 3:
      CFAllocatorRef v3 = (uint64_t *)&kCFHTTPAuthenticationSchemeDigest;
      goto LABEL_10;
    case 5:
      CFAllocatorRef v3 = (uint64_t *)&kCFHTTPAuthenticationSchemeNTLM;
      goto LABEL_10;
    case 6:
      CFAllocatorRef v3 = (uint64_t *)&kCFHTTPAuthenticationSchemeNegotiate;
      goto LABEL_10;
    case 9:
      CFAllocatorRef v3 = (uint64_t *)&kCFHTTPAuthenticationSchemeXMobileMeAuthToken;
      goto LABEL_10;
    case 10:
      CFAllocatorRef v3 = &_kCFHTTPAuthenticationSchemeOAuth;
      goto LABEL_10;
    case 11:
      CFAllocatorRef v3 = &_kCFHTTPAuthenticationSchemePrivateAccessToken;
      goto LABEL_10;
    case 12:
      CFAllocatorRef v3 = &_kCFHTTPAuthenticationSchemeOAuthBearerToken;
LABEL_10:
      uint64_t result = *v3;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t URLProtectionSpace::authSchemeForAuth(URLProtectionSpace *this, _CFHTTPAuthentication *a2)
{
  CFStringRef v2 = CFHTTPAuthenticationCopyMethod(this);
  if (!v2) {
    return 1;
  }
  CFStringRef v3 = v2;
  int ExactString = _findExactString(v2, 1u);
  CFRelease(v3);
  if (ExactString > 6324247)
  {
    if (ExactString > 8486941)
    {
      if (ExactString != 8486942)
      {
        if (ExactString == 9601061) {
          return 9;
        }
        return 1;
      }
      return 11;
    }
    else
    {
      if (ExactString != 6324248)
      {
        if (ExactString == 7381019) {
          return 10;
        }
        return 1;
      }
      return 5;
    }
  }
  else if (ExactString > 2146310)
  {
    if (ExactString != 2146311)
    {
      if (ExactString == 5316627) {
        return 6;
      }
      return 1;
    }
    return 3;
  }
  else
  {
    if (ExactString != 40960)
    {
      if (ExactString == 1097731) {
        return 12;
      }
      return 1;
    }
    return 2;
  }
}

uint64_t URLProtectionSpace::protSpaceAuthSchemeForCFStringRef(const __CFString *this, const __CFString *a2)
{
  int ExactString = _findExactString(this, 1u);
  if (ExactString > 5316626)
  {
    if (ExactString > 7381018)
    {
      switch(ExactString)
      {
        case 7381019:
          return 10;
        case 8486942:
          return 11;
        case 9601061:
          return 9;
      }
      return 1;
    }
    if (ExactString != 5316627)
    {
      if (ExactString == 6324248) {
        return 5;
      }
      return 1;
    }
    return 6;
  }
  if (ExactString <= 2146310)
  {
    if (ExactString == 40960) {
      return 2;
    }
    if (ExactString == 1097731) {
      return 12;
    }
    return 1;
  }
  if (ExactString == 2146311) {
    return 3;
  }
  if (ExactString == 3211275) {
    return 6;
  }
  return 1;
}

void TransportConnectionObjCPP::~TransportConnectionObjCPP(TransportConnectionObjCPP *this)
{
  TransportConnectionObjCPP::~TransportConnectionObjCPP(this);

  JUMPOUT(0x18531B6D0);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1ECFA3508;
  CFStringRef v2 = (std::__shared_weak_count *)*((void *)this + 4);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
    CFStringRef v3 = (std::__shared_weak_count *)*((void *)this + 4);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
  }
  *(void *)this = &unk_1ECF9B550;
  CFTypeID v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void TransportConnectionObjCPP::TransportConnectionObjCPP(TransportConnectionObjCPP *this, NSObject *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1ECFA3508;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  GlueTubeManager::createTransportConnection((uint64_t)&v2, a2);
}

void sub_184254E38(_Unwind_Exception *exception_object)
{
  CFStringRef v3 = (std::__shared_weak_count *)v1[4];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  *uint64_t v1 = &unk_1ECF9B550;
  CFTypeID v4 = (std::__shared_weak_count *)v1[2];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TransportConnectionObjCPP::read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(unsigned char *)(a1 + 40)) {
    operator new();
  }
  CFTypeID v4 = *(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, void))(a4 + 16);

  return v4(a4, 0, 1, 1, 57, 0);
}

void sub_184255208(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN25TransportConnectionObjCPP4readEjjU13block_pointerFvP11objc_objectb13CFStreamErrorPU32objcproto21OS_nw_content_context8NSObjectE_block_invoke(uint64_t a1, int a2)
{
  if (a2)
  {
    CFStringRef v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
    return v3();
  }
  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFAllocatorRef v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFStringRef v6 = 0;
      _os_log_error_impl(&dword_184085000, v5, OS_LOG_TYPE_ERROR, "NSURLSessionStreamTask: Connection read invalidated by closed connection", v6, 2u);
    }
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void ___ZN25TransportConnectionObjCPP4readEjjU13block_pointerFvP11objc_objectb13CFStreamErrorPU32objcproto21OS_nw_content_context8NSObjectE_block_invoke_2(uint64_t a1, uint64_t a2, dispatch_data_t data2, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = *(void *)(a1 + 32);
  dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(v11 + 48), data2);
  dispatch_release(*(dispatch_object_t *)(v11 + 48));
  *(void *)(v11 + 48) = 0;
  uint64_t v13 = *(void *)(a1 + 40);
  if (v13)
  {
    uint64_t v14 = *(void (**)(void *, uint64_t, NSObject *, uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 8);
    uint64_t v15 = *(void *)(v13 + 16);
    int v16 = (void *)(v13 + (v15 >> 1));
    if (v15) {
      uint64_t v14 = *(void (**)(void *, uint64_t, NSObject *, uint64_t, uint64_t, uint64_t, uint64_t))(*v16 + v14);
    }
    v14(v16, 1, concat, a4, a5, a6, a2);
  }

  dispatch_release(concat);
}

uint64_t ___ZN25TransportConnectionObjCPP4readEjjU13block_pointerFvP11objc_objectb13CFStreamErrorPU32objcproto21OS_nw_content_context8NSObjectE_block_invoke_4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(result + 32);
  if (v6)
  {
    CFStringRef v7 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 8);
    uint64_t v8 = *(void *)(v6 + 16);
    CFStringRef v9 = (void *)(v6 + (v8 >> 1));
    if (v8) {
      CFStringRef v7 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*v9 + v7);
    }
    return v7(v9, 1, a3, a4, a5, a6, a2);
  }
  return result;
}

void __destroy_helper_block_e8_32c124_ZTS18SmartBlockWithArgsIJbPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorPU32objcproto21OS_nw_content_contextS0_EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c124_ZTS18SmartBlockWithArgsIJbPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorPU32objcproto21OS_nw_content_contextS0_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_e8_40c124_ZTS18SmartBlockWithArgsIJbPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorPU32objcproto21OS_nw_content_contextS0_EE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c124_ZTS18SmartBlockWithArgsIJbPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorPU32objcproto21OS_nw_content_contextS0_EE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*> *,SmartBlockWithArgs<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::Deleter,std::allocator<BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_initial
    && v5 != 0)
  {
    CFStringRef v7 = (void *)(v1 + (v2 >> 1));
    if (v2) {
      (*(void (**)(void *, void, void, void, void, void, void))(*v7
    }
                                                                                       + BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_initial))(v7, 0, 0, 0, 0, 0, 0);
    else {
      ((void (*)(void *, void, void, void, void, void, void))BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_initial)(v7, 0, 0, 0, 0, 0, 0);
    }
  }
  _Block_release(*(const void **)v1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*> *,SmartBlockWithArgs<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::Deleter,std::allocator<BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

uint64_t BlockHolderVar<BOOL,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError,NSObject {objcproto21OS_nw_content_context}*>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t TransportConnectionObjCPP::write(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 40)) {
    operator new();
  }
  unint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16);

  return v3(a3, 1, 57);
}

void sub_1842557E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v15);
  _Unwind_Resume(a1);
}

uint64_t ___ZN25TransportConnectionObjCPP5writeEP11objc_objectU13block_pointerFv13CFStreamErrorE_block_invoke(uint64_t a1, int a2)
{
  if (a2)
  {
    unint64_t v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
    return v3();
  }
  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    int v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_error_impl(&dword_184085000, v5, OS_LOG_TYPE_ERROR, "NSURLSessionStreamTask: Connection write invalidated by closed connection", v6, 2u);
    }
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

uint64_t ___ZN25TransportConnectionObjCPP5writeEP11objc_objectU13block_pointerFv13CFStreamErrorE_block_invoke_7(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 32);
  if (v3)
  {
    BOOL v4 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(v3 + 8);
    uint64_t v5 = *(void *)(v3 + 16);
    uint64_t v6 = (void *)(v3 + (v5 >> 1));
    if (v5) {
      BOOL v4 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v6 + v4);
    }
    return v4(v6, 1, a2, a3);
  }
  return result;
}

void __destroy_helper_block_e8_32c44_ZTS18SmartBlockWithArgsIJb13CFStreamErrorEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c44_ZTS18SmartBlockWithArgsIJb13CFStreamErrorEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,CFStreamError> *,SmartBlockWithArgs<BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<BOOL,CFStreamError>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<BOOL,CFStreamError>::invoke_initial && v5 != 0)
  {
    CFStringRef v7 = (void *)(v1 + (v2 >> 1));
    if (v2) {
      (*(void (**)(void *, void, void, void))(*v7
    }
                                                               + BlockHolderVar<BOOL,CFStreamError>::invoke_initial))(v7, 0, 0, 0);
    else {
      ((void (*)(void *, void, void, void))BlockHolderVar<BOOL,CFStreamError>::invoke_initial)(v7, 0, 0, 0);
    }
  }
  _Block_release(*(const void **)v1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,CFStreamError> *,SmartBlockWithArgs<BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<BOOL,CFStreamError>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t BlockHolderVar<BOOL,CFStreamError>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<BOOL,CFStreamError>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

uint64_t BlockHolderVar<BOOL,CFStreamError>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void non-virtual thunk to'Host::~Host(Host *this)
{
}

{
  Host::~Host((Host *)((char *)this - 8));
}

void Host::~Host(Host *this)
{
  *(void *)this = &unk_1ECFA5520;
  *((void *)this + 1) = &unk_1ECFA5590;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  uint64_t v2 = (char **)*((void *)this + 17);
  if (v2)
  {
    unint64_t v3 = v2[2];
    if (v3)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v3, *((const __CFArray **)this + 15));
      _CFTypeInvalidate(v2[2]);
      CFRelease(v2[2]);
      v2[2] = 0;
      (*((void (**)(char **))*v2 + 8))(v2);
      uint64_t v2 = (char **)*((void *)this + 17);
    }
    CFRelease(v2 - 2);
    *((void *)this + 17) = 0;
  }
  HostBase::unlock(this);

  HostBase::~HostBase(this);
}

void sub_184255BB0(_Unwind_Exception *a1)
{
  HostBase::~HostBase(v1);
  _Unwind_Resume(a1);
}

void Host::clientAttached(Host *this, int a2)
{
  if (a2)
  {
    if (!*((void *)this + 13))
    {
      uint64_t v3 = *((void *)this + 17);
      if (v3)
      {
        BOOL v4 = *(void **)(v3 + 16);
        if (v4)
        {
          CFArrayRef v5 = (const __CFArray *)*((void *)this + 15);
          _CFTypeScheduleOnMultipleRunLoops(v4, v5);
        }
      }
    }
  }
  else
  {
    uint64_t v6 = (char **)*((void *)this + 17);
    if (v6)
    {
      CFStringRef v7 = v6[2];
      if (v7)
      {
        _CFTypeUnscheduleFromMultipleRunLoops(v7, *((const __CFArray **)this + 15));
        _CFTypeInvalidate(v6[2]);
        CFRelease(v6[2]);
        void v6[2] = 0;
        (*((void (**)(char **))*v6 + 8))(v6);
        uint64_t v6 = (char **)*((void *)this + 17);
      }
      CFRelease(v6 - 2);
      *((void *)this + 17) = 0;
    }
  }
}

CFIndex Host::unscheduleFromRunLoop(Host *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFIndex result = HostBase::unscheduleFromRunLoop(this, a2, a3);
  if (result)
  {
    if (*((void *)this + 17))
    {
      CFRetain((char *)this - 16);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
      ++*((void *)this + 2);
      uint64_t v7 = *((void *)this + 17);
      if (v7)
      {
        uint64_t v8 = *(void **)(v7 + 16);
        if (v8) {
          _CFTypeUnscheduleFromRunLoop(v8, (uint64_t)a2, (uint64_t)a3);
        }
      }
      HostBase::unlock(this);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t Host::scheduleWithRunLoop(Host *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t result = HostBase::scheduleWithRunLoop(this, a2, a3);
  if (result)
  {
    if (*((void *)this + 17))
    {
      CFRetain((char *)this - 16);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
      ++*((void *)this + 2);
      uint64_t v7 = *((void *)this + 17);
      if (v7)
      {
        uint64_t v8 = *(void **)(v7 + 16);
        if (v8) {
          _CFTypeScheduleOnRunLoop(v8, (uint64_t)a2, (uint64_t)a3);
        }
      }
      HostBase::unlock(this);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void Host::cancelInfoResolution(Host *this, const __CFString *a2)
{
  HostBase::cancelInfoResolution(this, a2);
  if (*((void *)this + 17))
  {
    CFRetain((char *)this - 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    ++*((void *)this + 2);
    uint64_t v3 = (char **)*((void *)this + 17);
    if (v3)
    {
      BOOL v4 = v3[2];
      if (v4)
      {
        _CFTypeUnscheduleFromMultipleRunLoops(v4, *((const __CFArray **)this + 15));
        _CFTypeInvalidate(v3[2]);
        CFRelease(v3[2]);
        uint64_t v3[2] = 0;
        (*((void (**)(char **))*v3 + 8))(v3);
        uint64_t v3 = (char **)*((void *)this + 17);
      }
      CFRelease(v3 - 2);
      *((void *)this + 17) = 0;
    }
    HostBase::unlock(this);
  }
}

CFTypeRef Host::startInfoResolution(Host *this, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4)
{
  uint64_t v7 = (char *)this - 16;
  CFRetain((char *)this - 16);
  CFRetain(v7);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2)) {
    goto LABEL_3;
  }
  if (*((void *)this + 17)) {
    goto LABEL_3;
  }
  CFGetAllocator(v7);
  int ExactString = _findExactString(a2, 0xAu);
  if (!HostBase::calculateWantsLocked((uint64_t)this, ExactString, (CFIndex *)&v36)) {
    goto LABEL_3;
  }
  if (ExactString <= 492009983)
  {
    if (ExactString == 487864780 || ExactString == 489863658 || ExactString == 490912245)
    {
      int v17 = v36;
      if (v36)
      {
        if (HostLookup::Class(void)::sOnce_HostLookup != -1) {
          dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_10396);
        }
        uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
        uint64_t v15 = (HostLookup_Master *)Instance;
        if (Instance)
        {
          Instance[1] = 0u;
          uint64_t v15 = (HostLookup_Master *)(Instance + 1);
          Instance[3] = 0u;
          Instance[4] = 0u;
          Instance[2] = 0u;
        }
        uint64_t v19 = v15;
        CFStringRef v20 = a2;
        int v21 = v17;
        goto LABEL_41;
      }
    }
    goto LABEL_57;
  }
  if (ExactString <= 495032865)
  {
    if (ExactString == 492009984)
    {
      if (HostLookup::Class(void)::sOnce_HostLookup != -1) {
        dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_10396);
      }
      __int16 v24 = (_OWORD *)_CFRuntimeCreateInstance();
      uint64_t v15 = (HostLookup_Master *)v24;
      if (v24)
      {
        v24[1] = 0u;
        uint64_t v15 = (HostLookup_Master *)(v24 + 1);
        unsigned char v24[3] = 0u;
        void v24[4] = 0u;
        v24[2] = 0u;
      }
      int v16 = &_kCFHostMasterAddressLookupString;
      goto LABEL_40;
    }
    if (ExactString == 494017049)
    {
      if (HostLookup::Class(void)::sOnce_HostLookup != -1) {
        dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_10396);
      }
      uint64_t v14 = (_OWORD *)_CFRuntimeCreateInstance();
      uint64_t v15 = (HostLookup_Master *)v14;
      if (v14)
      {
        v14[1] = 0u;
        uint64_t v15 = (HostLookup_Master *)(v14 + 1);
        v14[3] = 0u;
        v14[4] = 0u;
        void v14[2] = 0u;
      }
      int v16 = &kCFHostAddressesString;
LABEL_40:
      CFStringRef v20 = (const __CFString *)*v16;
      int v21 = v36;
      uint64_t v19 = v15;
LABEL_41:
      HostLookup_Master::HostLookup_Master(v19, v20, v21, a3);
      goto LABEL_42;
    }
    goto LABEL_57;
  }
  if (ExactString != 495032866)
  {
    if (ExactString == 496138793)
    {
      CFDataRef v22 = v37;
      if (v37)
      {
        if (HostLookup::Class(void)::sOnce_HostLookup != -1) {
          dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_10396);
        }
        uint64_t v23 = (_OWORD *)_CFRuntimeCreateInstance();
        uint64_t v15 = (HostLookup_Master *)v23;
        if (v23)
        {
          v23[1] = 0u;
          uint64_t v15 = (HostLookup_Master *)(v23 + 1);
          SecTrustRef v23[4] = 0u;
          void v23[5] = 0u;
          v23[2] = 0u;
          v23[3] = 0u;
        }
        HostLookup_ReachabilityFixed::HostLookup_ReachabilityFixed(v15, v22);
        goto LABEL_42;
      }
      uint64_t v28 = v36;
      if (v36)
      {
        BOOL isDottedIP = HostLookup_ReachabilityFixed::isDottedIP(v36, v13);
        if (HostLookup::Class(void)::sOnce_HostLookup != -1) {
          dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_10396);
        }
        if (isDottedIP)
        {
          uint64_t v30 = (_OWORD *)_CFRuntimeCreateInstance();
          uint64_t v15 = (HostLookup_Master *)v30;
          if (v30)
          {
            v30[1] = 0u;
            uint64_t v15 = (HostLookup_Master *)(v30 + 1);
            v30[4] = 0u;
            v30[5] = 0u;
            v30[2] = 0u;
            v30[3] = 0u;
          }
          HostLookup_ReachabilityFixed::HostLookup_ReachabilityFixed(v15, v28);
        }
        else
        {
          CFStringRef v35 = (_OWORD *)_CFRuntimeCreateInstance();
          uint64_t v15 = (HostLookup_Master *)v35;
          if (v35)
          {
            v35[1] = 0u;
            uint64_t v15 = (HostLookup_Master *)(v35 + 1);
            v35[2] = 0u;
            v35[3] = 0u;
          }
          HostLookup_Reachability::HostLookup_Reachability(v15, v28);
        }
LABEL_42:
        *((void *)this + 17) = v15;
        if (!v15) {
          goto LABEL_3;
        }
        goto LABEL_58;
      }
    }
LABEL_57:
    uint64_t v15 = (HostLookup_Master *)*((void *)this + 17);
    if (!v15) {
      goto LABEL_3;
    }
    goto LABEL_58;
  }
  if (HostLookup::Class(void)::sOnce_HostLookup != -1) {
    dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_10396);
  }
  int v25 = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v15 = (HostLookup_Master *)v25;
  if (v25)
  {
    v25[1] = 0u;
    uint64_t v15 = (HostLookup_Master *)(v25 + 1);
    v25[3] = 0u;
    v25[4] = 0u;
    v25[2] = 0u;
  }
  CFDataRef v26 = v37;
  HostLookup::HostLookup(v15, &unk_1EC0A4958);
  *(void *)uint64_t v15 = &unk_1ECF9DDE8;
  *((void *)v15 + 1) = &unk_1ECF9DE40;
  if (v26) {
    CFTypeRef v27 = CFRetain(v26);
  }
  else {
    CFTypeRef v27 = 0;
  }
  *((void *)v15 + 5) = v27;
  *((void *)v15 + 6) = a3;
  *((void *)this + 17) = v15;
LABEL_58:
  uint64_t v31 = (*(uint64_t (**)(HostLookup_Master *, Host *))(*(void *)v15 + 56))(v15, this);
  if (v31)
  {
    uint64_t v32 = (const void *)v31;
    CFRelease((CFTypeRef)(*((void *)this + 17) - 16));
    *((void *)this + 17) = 0;
    HostBase::setInfoLocked(this, a2, v32);
  }
  else if (*((void *)this + 13))
  {
    int64_t v33 = *(void **)(*((void *)this + 17) + 16);
    if (v33) {
      _CFTypeScheduleOnMultipleRunLoops(v33, *((const __CFArray **)this + 15));
    }
  }
  else
  {
    HostBase::unlock(this);
    CFRunLoopRef Current = CFRunLoopGetCurrent();
    (*(void (**)(Host *, CFRunLoopRef, __CFString *))(*(void *)this + 72))(this, Current, @"_kCFHostBlockingMode");
    CFRetain(v7);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    ++*((void *)this + 2);
    for (; *((void *)this + 17); ++*((void *)this + 2))
    {
      HostBase::unlock(this);
      CFRunLoopRunInMode(@"_kCFHostBlockingMode", 1.79769313e308, 1u);
      CFRetain(v7);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    }
    HostBase::unlock(this);
    (*(void (**)(Host *, CFRunLoopRef, __CFString *))(*(void *)this + 80))(this, Current, @"_kCFHostBlockingMode");
    CFRetain(v7);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    ++*((void *)this + 2);
  }
LABEL_3:
  CFDictionaryRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2);
  CFTypeRef v9 = Value;
  if (Value)
  {
    CFTypeID v10 = CFGetTypeID(Value);
    if (v10 == CFErrorGetTypeID()) {
      CFTypeRef v9 = CFRetain(v9);
    }
    else {
      CFTypeRef v9 = 0;
    }
  }
  HostBase::unlock(this);
  CFRelease(v7);
  return v9;
}

void sub_1842564FC(_Unwind_Exception *a1)
{
  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

BOOL HostBase::calculateWantsLocked(uint64_t a1, int a2, CFIndex *a3)
{
  BOOL result = 0;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (a2 <= 492009983)
  {
    if (a2 != 487864780 && a2 != 489863658 && a2 != 490912245) {
      return result;
    }
    goto LABEL_13;
  }
  if (a2 <= 495032865)
  {
    char v6 = 3;
    char v7 = 1;
    if (a2 != 492009984 && a2 != 494017049) {
      return result;
    }
LABEL_14:
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), &unk_1EC0A4958);
    CFArrayRef v10 = (const __CFArray *)*MEMORY[0x1E4F1D260];
    if (Value) {
      BOOL v12 = Value == v10;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
      CFIndex Count = 0;
    }
    else
    {
      CFArrayRef v13 = Value;
      CFIndex Count = CFArrayGetCount(Value);
      if (Count) {
        CFIndex Count = (CFIndex)CFArrayGetValueAtIndex(v13, 0);
      }
    }
    *a3 = Count;
    int v8 = Count != 0;
    char v9 = 1;
    if (v7) {
      return v8 && ((v6 & 2) == 0 || *a3) && ((v9 & 1) != 0 || a3[1]);
    }
    goto LABEL_23;
  }
  if (a2 == 496138793)
  {
LABEL_13:
    char v7 = 0;
    char v6 = 5;
    goto LABEL_14;
  }
  if (a2 != 495032866) {
    return result;
  }
  int v8 = 0;
  char v9 = 0;
  CFArrayRef v10 = (const __CFArray *)*MEMORY[0x1E4F1D260];
  char v6 = 12;
LABEL_23:
  CFArrayRef v15 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), &unk_1EC0A4920);
  if (v15) {
    BOOL v16 = v15 == v10;
  }
  else {
    BOOL v16 = 1;
  }
  if (v16)
  {
    CFIndex ValueAtIndex = 0;
  }
  else
  {
    CFArrayRef v17 = v15;
    CFIndex ValueAtIndex = CFArrayGetCount(v15);
    if (ValueAtIndex) {
      CFIndex ValueAtIndex = (CFIndex)CFArrayGetValueAtIndex(v17, 0);
    }
  }
  a3[1] = ValueAtIndex;
  v8 |= 4 * (ValueAtIndex != 0);
  return v8 && ((v6 & 2) == 0 || *a3) && ((v9 & 1) != 0 || a3[1]);
}

CFStringRef Host::copyDebugDesc(Host *this)
{
  uint64_t v1 = (char *)this - 16;
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<CFHost %p>", v1);
}

void Host::Host(Host *this, const __CFString *a2, const void *a3, ...)
{
  va_start(va, a3);
  HostBase::HostBase(this, 0);
  *char v6 = &unk_1ECFA5520;
  v6[1] = &unk_1ECFA5590;
  CFRetain(v6 - 2);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  HostBase::setInfoLocked(this, a2, a3);
  HostBase::setInfoLocked(this, va);
  HostBase::unlock(this);
}

void sub_184256808(_Unwind_Exception *a1)
{
  HostBase::~HostBase(v1);
  _Unwind_Resume(a1);
}

void Host::performCallback(Host *this, const __CFString *a2)
{
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  BOOL v4 = (char **)*((void *)this + 17);
  if (v4)
  {
    CFArrayRef v5 = v4[2];
    if (v5)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v5, *((const __CFArray **)this + 15));
      _CFTypeInvalidate(v4[2]);
      CFRelease(v4[2]);
      void v4[2] = 0;
      (*((void (**)(char **))*v4 + 8))(v4);
      BOOL v4 = (char **)*((void *)this + 17);
    }
    CFRelease(v4 - 2);
    *((void *)this + 17) = 0;
  }
  HostBase::unlock(this);

  HostBase::invokeCallback(this, a2);
}

void Host::performCallback(Host *this, const __CFString *a2, const void *a3)
{
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  HostBase::setInfoLocked(this, a2, a3);
  HostBase::unlock(this);

  Host::performCallback(this, a2);
}

void non-virtual thunk to'HostLookup::~HostLookup(HostLookup *this)
{
}

{
  HostLookup::~HostLookup((HostLookup *)((char *)this - 8));
}

void HostLookup::~HostLookup(HostLookup *this)
{
  *(void *)this = &unk_1ECF9A868;
  *((void *)this + 1) = &unk_1ECF9A8C0;
  CFAllocatorRef v2 = (char *)*((void *)this + 2);
  if (v2)
  {
    _CFTypeInvalidate(v2);
    uint64_t v3 = (const void *)*((void *)this + 2);
    if (v3) {
      CFRelease(v3);
    }
  }
  *((void *)this + 1) = &unk_1ECF9B550;
}

void sub_184256A04(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void HostLookup::prepareLookup(HostLookup *this, Host *a2)
{
}

CFStringRef HostLookup::copyDebugDesc(HostLookup *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<HostLookup@%p> { %p }", this, *((void *)this + 2));
}

void ___ZN10HostLookup5ClassEv_block_invoke()
{
}

void sub_184256AD8(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void sub_184256BE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NSURLStorageURLCacheDB;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1842579B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t SQLHostForDeleteCallback(void *a1, int a2, const char **a3, char **a4)
{
  char v6 = a1;
  if (v6)
  {
    if (a2 == 1)
    {
      int v8 = [NSString stringWithCString:*a3 encoding:4];
      [v6[17] addObject:v8];
LABEL_8:

      goto LABEL_9;
    }
    if (a2 == 2)
    {
      char v7 = *a3;
      int v8 = [NSString stringWithCString:a3[1] encoding:4];
      [v6[17] addObject:v8];
      if (v7)
      {
        id Property = objc_getProperty(v6, v9, 160, 1);
        uint64_t FS2 = _CFURLCacheCreateFS2((uint64_t)Property);
        uint64_t v12 = FS2;
        if (FS2)
        {
          _CFURLCacheFSPurgeItemFromFileSystemStore(FS2, v7);
          (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
        }
      }
      goto LABEL_8;
    }
  }
LABEL_9:

  return 0;
}

void sub_184257AF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t SQLdeleteSinceDateCallback(void *a1, int a2, const char **a3, char **a4)
{
  char v6 = a1;
  int v8 = v6;
  if (v6)
  {
    if (a2 == 1)
    {
      char v9 = *a3;
      if (v9)
      {
        id Property = objc_getProperty(v6, v7, 160, 1);
        uint64_t FS2 = _CFURLCacheCreateFS2((uint64_t)Property);
        uint64_t v12 = FS2;
        if (FS2)
        {
          _CFURLCacheFSPurgeItemFromFileSystemStore(FS2, v9);
          (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
        }
      }
    }
  }

  return 0;
}

void sub_184257BBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __logAppleATSViolation_block_invoke_27(uint64_t a1)
{
  SecTrustReportNetworkingAnalytics();
  CFAllocatorRef v2 = *(void **)(a1 + 32);

  xpc_release(v2);
}

void copyATSExceptionDomain(const void *a1, const void *a2, __CFDictionary *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    CFTypeID v7 = CFGetTypeID(a2);
    if (v7 == CFDictionaryGetTypeID())
    {
      CFDictionarySetValue(a3, a1, a2);
    }
  }
}

BOOL atsDictionaryClientIDHasPrefix(const __CFDictionary *a1, const __CFString *a2)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, @"_kCFNetworkATSClientID");
  BOOL result = 0;
  if (Value)
  {
    CFStringRef v4 = Value;
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(v4))
    {
      if (CFStringHasPrefix(v4, a2)) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t ___ZL14isMediaProcessv_block_invoke()
{
  uint64_t result = _CFGetProgname();
  if (result)
  {
    uint64_t result = *(void *)result;
    if (result)
    {
      uint64_t result = strcmp((const char *)result, "mediaserverd");
      isMediaProcess(void)::isMediaProcess = result == 0;
    }
  }
  return result;
}

uint64_t ___ZL15isWebkitProcessv_block_invoke()
{
  uint64_t result = _CFGetProgname();
  if (result)
  {
    uint64_t result = *(void *)result;
    if (result)
    {
      uint64_t result = strncmp((const char *)result, "com.apple.WebKit", 0x10uLL);
      isWebkitProcess(void)::isWebkitProcess = result == 0;
    }
  }
  return result;
}

void ___ZL18getDefaultATSStatev_block_invoke()
{
  v9[38] = *MEMORY[0x1E4F143B8];
  v6[0] = @"apple.com";
  v6[1] = @"TLSv1.2";
  uint64_t v0 = (const void *)*MEMORY[0x1E4F1CFD0];
  uint64_t v7 = *MEMORY[0x1E4F1CFC8];
  int v8 = v0;
  v9[0] = v0;
  v9[2] = @"ls.apple.com";
  void v9[3] = @"TLSv1.0";
  v9[4] = v7;
  void v9[5] = v0;
  void v9[6] = v0;
  v9[8] = @"gs.apple.com";
  v9[9] = @"TLSv1.0";
  v9[10] = v7;
  v9[11] = v0;
  v9[12] = v0;
  v9[14] = @"geo.apple.com";
  v9[15] = @"TLSv1.0";
  uint8_t v9[16] = v7;
  v9[17] = v0;
  v9[18] = v0;
  v9[20] = @"is.autonavi.com";
  v9[21] = @"TLSv1.0";
  v9[22] = v7;
  v9[23] = v0;
  v9[24] = v0;
  v9[26] = @"apple-mapkit.com";
  v9[27] = @"TLSv1.0";
  v9[28] = v7;
  v9[29] = v0;
  v9[30] = v0;
  v9[32] = @"setup.icloud.com";
  v9[33] = @"TLSv1.2";
  v9[34] = v7;
  v9[35] = v0;
  v9[36] = v0;
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFTypeRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 7, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  for (uint64_t i = 0; i != 42; i += 6)
  {
    CFStringRef v4 = CFDictionaryCreateMutable(v1, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionarySetValue(v4, @"NSExceptionMinimumTLSVersion", (const void *)v6[i + 1]);
    CFDictionarySetValue(v4, @"NSExceptionAllowsInsecureHTTPLoads", (const void *)v9[i - 1]);
    CFDictionarySetValue(v4, @"NSExceptionRequiresForwardSecrecy", (const void *)v6[i + 2]);
    CFDictionarySetValue(v4, @"NSIncludesSubdomains", (const void *)v9[i]);
    CFDictionarySetValue(v4, @"NSATSBuiltinOverride", v0);
    CFDictionarySetValue(Mutable, (const void *)v6[i], v4);
    CFRelease(v4);
  }
  CFArrayRef v5 = CFDictionaryCreateMutable(v1, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(v5, @"NSExceptionDomains", Mutable);
  CFRelease(Mutable);
  getDefaultATSState(void)::baseATSint State = (uint64_t)CFDictionaryCreateCopy(v1, v5);

  CFRelease(v5);
}

BOOL StrictSecurityPolicy::clientIsWebKit(StrictSecurityPolicy *this)
{
  if ((_BYTE)this) {
    return 1;
  }
  if (isWebkitProcess(void)::onceToken != -1) {
    dispatch_once(&isWebkitProcess(void)::onceToken, &__block_literal_global_118_10780);
  }
  return isWebkitProcess(void)::isWebkitProcess != 0;
}

BOOL StrictSecurityPolicy::clientIsMediaserver(StrictSecurityPolicy *this)
{
  if ((_BYTE)this) {
    return 1;
  }
  if (isMediaProcess(void)::onceToken != -1) {
    dispatch_once(&isMediaProcess(void)::onceToken, &__block_literal_global_121);
  }
  return isMediaProcess(void)::isMediaProcess != 0;
}

uint64_t ___ZN20StrictSecurityPolicy15HardATSFailuresEv_block_invoke()
{
  uint64_t result = os_variant_allows_internal_security_policies();
  if (result)
  {
    Boolean keyExistsAndHasValidFormat = 0;
    uint64_t result = CFPreferencesGetAppBooleanValue(@"com.apple.cfnetwork.ats.hardfailures", (CFStringRef)*MEMORY[0x1E4F1D3D8], &keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat) {
      BOOL v1 = result == 0;
    }
    else {
      BOOL v1 = 0;
    }
    if (v1) {
      StrictSecurityPolicy::HardATSFailures(void)::hardATSFailures = 1;
    }
  }
  return result;
}

CFDataRef ___ZN13ATSTLSCiphers25DefaultNonPFSCipherSuitesEv_block_invoke()
{
  CFDataRef result = CFDataCreateWithBytesNoCopy(0, kATSv1NonPFSCiphers, 50, 0);
  ATSTLSCiphers::DefaultNonPFSCipherSuites(void)::cipherData = (uint64_t)result;
  return result;
}

void StrictSecurityPolicy::_fallbackToATSMode(StrictSecurityPolicy *this, const char *cStr)
{
  if ((*((unsigned char *)this + 32) & 1) == 0) {
    *((unsigned char *)this + 32) |= 1u;
  }
  if (StrictSecurityPolicy::ATSLogLevel(void)::logATSOnce != -1) {
    dispatch_once(&StrictSecurityPolicy::ATSLogLevel(void)::logATSOnce, &__block_literal_global_40_10844);
  }
  if (StrictSecurityPolicy::ATSLogLevel(void)::atslogLevel)
  {
    CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x600u);
    operator new();
  }
}

void sub_184258278(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN20StrictSecurityPolicy19parseCIDRExceptionsEv_block_invoke(uint64_t a1, __CFString *cf)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID() || CFStringFind(cf, @"/", 0).location == -1) {
    return;
  }
  *(void *)bytes = 0;
  uint64_t v32 = 0;
  int v34 = 0;
  uint64_t v33 = 0;
  CFArrayRef v5 = (const char *)[(__CFString *)cf UTF8String];
  if (!v5) {
    goto LABEL_75;
  }
  CFTypeID v6 = v5;
  size_t v7 = strlen(v5);
  if (v7)
  {
    int v8 = 0;
    char v9 = 0;
    int v10 = 0;
    int v11 = 0;
    unint64_t v12 = 0;
    size_t v13 = v7;
    while (1)
    {
      int v14 = v6[v12];
      uint64_t v15 = (v14 - 47);
      if (v15 > 0x37) {
        goto LABEL_21;
      }
      if (((1 << (v14 - 47)) & 0xFC000000FC0000) != 0)
      {
        if (v11 || v13 <= v12) {
          goto LABEL_75;
        }
        int v11 = 0;
        ++v8;
        goto LABEL_11;
      }
      if (v14 != 47) {
        break;
      }
      if (!v12 || v13 <= v12 || v11 && v6[v12 - 1] == 46) {
        goto LABEL_75;
      }
      if (v12 >= 3 && v10 && v6[v12 - 1] == 58)
      {
        size_t v13 = v12;
        if (v6[v12 - 2] != 58) {
          goto LABEL_75;
        }
      }
      else
      {
        size_t v13 = v12;
      }
LABEL_11:
      if (v7 == ++v12) {
        goto LABEL_40;
      }
    }
    if (v15 == 11)
    {
      if (v11 || v13 <= v12) {
        goto LABEL_75;
      }
      ++v10;
      if (v12 && v6[v12 - 1] == 58)
      {
        if (v9) {
          goto LABEL_75;
        }
        int v11 = 0;
        char v9 = 1;
      }
      else
      {
        int v11 = 0;
      }
      goto LABEL_11;
    }
LABEL_21:
    if (v14 == 46)
    {
      if (v8 | v10 || !v12 || v13 <= v12) {
        goto LABEL_75;
      }
      int v10 = 0;
      int v8 = 0;
      ++v11;
    }
    else if ((v14 - 48) > 9)
    {
      goto LABEL_75;
    }
    goto LABEL_11;
  }
  int v11 = 0;
  int v10 = 0;
  char v9 = 0;
  int v8 = 0;
  size_t v13 = 0;
LABEL_40:
  if (v13 >= v7) {
    goto LABEL_75;
  }
  *(void *)bytes = 0;
  uint64_t v32 = 0;
  int v34 = 0;
  uint64_t v33 = 0;
  v29[0] = 0;
  v29[1] = 0;
  *(void *)uint64_t v28 = 0;
  int v30 = 0;
  uint64_t v16 = strtol(&v6[v13 + 1], 0, 0);
  if (v16 < 0) {
    goto LABEL_75;
  }
  uint64_t v17 = v16;
  if (*__error() == 22) {
    goto LABEL_75;
  }
  if (v8 | v10)
  {
    if ((unint64_t)v17 <= 0x80)
    {
      *(_WORD *)uint64_t v28 = 7708;
      *(_WORD *)bytes = 7708;
      if (v13 <= 0x26)
      {
        memcpy(&__dst, v6, v13);
        if (!(v9 & 1 | (v10 > 6)))
        {
          if (v13 - 37 < 0xFFFFFFFFFFFFFFD8) {
            goto LABEL_75;
          }
          *((unsigned char *)&__dst + v13) = 58;
          *((unsigned char *)&__dst + v13 + 1) = 58;
          v13 += 2;
        }
        *((unsigned char *)&__dst + v13) = 0;
        if (inet_pton(30, (const char *)&__dst, &v32) == 1)
        {
          CFStringRef v20 = (UInt8 *)v29;
LABEL_62:
          if (v17 >= 1)
          {
            uint64_t v21 = v17;
            do
            {
              uint64_t v23 = v21 - 8;
              BOOL v22 = (unint64_t)v21 > 8;
              if (v21 >= 8) {
                uint64_t v21 = 8;
              }
              *v20++ = cidrStringToSubnetAndMask(char const*,sockaddr_in_4_6 *,sockaddr_in_4_6 *,unsigned char *)::bb[v21 - 1];
              uint64_t v21 = v23;
            }
            while (v22);
          }
          CFDataRef v24 = CFDataCreate(0, bytes, 28);
          CFDataRef v25 = CFDataCreate(0, v28, 28);
          CFTypeRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDictionaryAddValue(Mutable, @"NSParsedCIDRAddressKey", v24);
          CFDictionaryAddValue(Mutable, @"NSParsedCIDRMaskKey", v25);
          AutoScalar::AutoScalar((AutoScalar *)&__dst, (const __CFAllocator *)v17);
          CFDictionaryAddValue(Mutable, @"NSParsedCIDRPrefixKey", value);
          __dst = &unk_1ECF9A500;
          if (value) {
            CFRelease(value);
          }
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), cf, Mutable);
          if (v24) {
            CFRelease(v24);
          }
          if (v25) {
            CFRelease(v25);
          }
          if (Mutable) {
            CFRelease(Mutable);
          }
          return;
        }
      }
    }
  }
  else if ((unint64_t)v17 <= 0x20)
  {
    *(_WORD *)uint64_t v28 = 528;
    *(_WORD *)bytes = 528;
    if (v13 <= 0xE)
    {
      memcpy(&__dst, v6, v13);
      if (v11 > 2 || v13 == 14)
      {
        size_t v18 = v13;
      }
      else
      {
        do
        {
          size_t v18 = v13 + 2;
          *(_WORD *)((char *)&__dst + v13) = 12334;
          if (v11 > 1) {
            break;
          }
          ++v11;
          BOOL v19 = v13 >= 0xC;
          v13 += 2;
        }
        while (!v19);
      }
      *((unsigned char *)&__dst + v18) = 0;
      if (inet_pton(2, (const char *)&__dst, &bytes[4]) == 1)
      {
        CFStringRef v20 = &v28[4];
        goto LABEL_62;
      }
    }
  }
LABEL_75:
  v27[0] = MEMORY[0x1E4F143A8];
  v27[1] = 3221225472;
  v27[2] = ___ZN20StrictSecurityPolicy19parseCIDRExceptionsEv_block_invoke_2;
  v27[3] = &unk_1E5258228;
  v27[4] = cf;
  if (_ZZZN20StrictSecurityPolicy19parseCIDRExceptionsEvEUb_E9onceToken != -1) {
    dispatch_once(&_ZZZN20StrictSecurityPolicy19parseCIDRExceptionsEvEUb_E9onceToken, v27);
  }
}

void sub_1842587B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN20StrictSecurityPolicy19parseCIDRExceptionsEv_block_invoke_2(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFAllocatorRef v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 138543362;
    uint64_t v5 = v3;
    _os_log_fault_impl(&dword_184085000, v2, OS_LOG_TYPE_FAULT, "App Transport Security exception %{public}@ is not a valid CIDR notation.", (uint8_t *)&v4, 0xCu);
  }
}

uint64_t ___ZNK20StrictSecurityPolicy22logInsecureLoadFailureEPK7__CFURL_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  CFAllocatorRef v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 952;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t isLocalIPAddress(CFStringRef theString)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v17 = 1023;
  ptr = _CFStringGetOrCreateCString(allocator, theString, v19, &v17, 0x8000100u);
  host_with_numeric_port = nw_endpoint_create_host_with_numeric_port();
  if (nw_endpoint_get_type(host_with_numeric_port) != nw_endpoint_type_address) {
    goto LABEL_26;
  }
  address = nw_endpoint_get_address(host_with_numeric_port);
  int sa_family = address->sa_family;
  if (sa_family == 30)
  {
    if (address->sa_len < 0x1Cu) {
      goto LABEL_26;
    }
    if (*(_DWORD *)&address->sa_data[6])
    {
      if (*(_DWORD *)&address->sa_data[6] == 254)
      {
        if ((*(_DWORD *)&address->sa_data[6] & 0xC000) != 0x8000) {
          goto LABEL_26;
        }
      }
      else if ((*(_DWORD *)&address->sa_data[6] & 0xFE) != 0xFC)
      {
        goto LABEL_26;
      }
    }
    else if (*(_DWORD *)&address->sa_data[10] {
           || *(_DWORD *)&address[1].sa_len
    }
           || *(_DWORD *)&address[1].sa_data[2] != 0x1000000)
    {
      goto LABEL_26;
    }
LABEL_42:
    uint64_t is_local = 1;
    if (!host_with_numeric_port) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  if (sa_family == 2 && address->sa_len >= 0x10u)
  {
    unsigned int v4 = bswap32(*(_DWORD *)&address->sa_data[2]);
    unsigned int v5 = v4 & 0xFF000000;
    if ((v4 & 0xFF000000) == 0x7F000000) {
      goto LABEL_42;
    }
    unsigned int v6 = v4 & 0xFFFF0000;
    unsigned int v7 = v4 & 0xFFF00000;
    BOOL v8 = v6 == -1062731776 || v7 == -1408237568;
    BOOL v9 = v8 || v6 == -1442971648;
    if (v9 || v5 == 167772160) {
      goto LABEL_42;
    }
  }
LABEL_26:
  nw_parameters_t v11 = nw_parameters_create();
  evaluator_for_endpoint = (void *)nw_path_create_evaluator_for_endpoint();
  size_t v13 = (void *)nw_path_evaluator_copy_path();
  if (nw_path_is_direct())
  {
    uint64_t is_local = 1;
    if (!v13) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  uint64_t is_local = nw_path_is_local();
  if (v13) {
LABEL_28:
  }
    nw_release(v13);
LABEL_29:
  if (evaluator_for_endpoint) {
    nw_release(evaluator_for_endpoint);
  }
  if (v11) {
    nw_release(v11);
  }
  if (host_with_numeric_port) {
LABEL_34:
  }
    nw_release(host_with_numeric_port);
LABEL_35:
  if (ptr && v19 != ptr) {
    CFAllocatorDeallocate(allocator, ptr);
  }
  return is_local;
}

void sub_184258B40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  if (v12) {
    nw_release(v12);
  }
  if (ptr)
  {
    if (v11 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t exceptionAllowsInsecureLoad(const __CFDictionary *a1)
{
  CFStringRef Value = CFDictionaryGetValue(a1, @"NSExceptionAllowsInsecureHTTPLoads");
  uint64_t v3 = (const void **)MEMORY[0x1E4F1CFD0];
  if (Value)
  {
    unsigned int v4 = Value;
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
    }
    if (*v3 == v4) {
      return 1;
    }
  }
  unsigned int v6 = CFDictionaryGetValue(a1, @"NSThirdPartyExceptionAllowsInsecureHTTPLoads");
  if (v6)
  {
    unsigned int v7 = v6;
    CFTypeID v8 = CFGetTypeID(v6);
    if (v8 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v17, 2u);
    }
    if (*v3 == v7) {
      return 1;
    }
  }
  BOOL v9 = CFDictionaryGetValue(a1, @"NSTemporaryExceptionAllowsInsecureHTTPLoads");
  if (v9)
  {
    int v10 = v9;
    CFTypeID v11 = CFGetTypeID(v9);
    if (v11 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v16, 2u);
    }
    if (*v3 == v10) {
      return 1;
    }
  }
  uint64_t result = (uint64_t)CFDictionaryGetValue(a1, @"NSTemporaryThirdPartyExceptionAllowsInsecureHTTPLoads");
  if (result)
  {
    uint64_t v13 = result;
    CFTypeID v14 = CFGetTypeID((CFTypeRef)result);
    if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      v15[0] = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)v15, 2u);
    }
    return *v3 == (const void *)v13;
  }
  return result;
}

const void *StrictSecurityPolicy::getCIDRException(StrictSecurityPolicy *a1, uint64_t a2, char a3)
{
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000;
  uint64_t v15 = 0;
  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x2020000000;
  char v11 = 0;
  unsigned int v4 = (void *)*((void *)a1 + 3);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = ___ZN20StrictSecurityPolicy16getCIDRExceptionEPK15sockaddr_in_4_6h_block_invoke;
  v8[3] = &unk_1E5255698;
  char v9 = a3;
  void v8[5] = &v12;
  v8[6] = a2;
  v8[4] = v10;
  [v4 enumerateKeysAndObjectsUsingBlock:v8];
  CFStringRef v5 = (const __CFString *)v13[3];
  if (v5) {
    Exception = StrictSecurityPolicy::getException(a1, v5);
  }
  else {
    Exception = 0;
  }
  _Block_object_dispose(v10, 8);
  _Block_object_dispose(&v12, 8);
  return Exception;
}

void sub_184258EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 48), 8);
  _Unwind_Resume(a1);
}

const UInt8 *___ZN20StrictSecurityPolicy16getCIDRExceptionEPK15sockaddr_in_4_6h_block_invoke(uint64_t a1, uint64_t a2, CFDictionaryRef theDict)
{
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, @"NSParsedCIDRAddressKey");
  uint64_t result = CFDataGetBytePtr(Value);
  if (result)
  {
    CFTypeID v8 = result;
    if (result[1] == *(unsigned __int8 *)(a1 + 56))
    {
      CFDataRef v9 = (const __CFData *)CFDictionaryGetValue(theDict, @"NSParsedCIDRMaskKey");
      BytePtr = CFDataGetBytePtr(v9);
      uint64_t v11 = *(void *)(a1 + 48);
      uint64_t v12 = (unsigned __int8 *)(v11 + 8);
      uint64_t v13 = (unsigned __int8 *)(v8 + 8);
      uint64_t v14 = (unsigned __int8 *)(BytePtr + 8);
      uint64_t v15 = (unsigned __int8 *)(v11 + 4);
      if (*(unsigned char *)(a1 + 56) == 2) {
        uint64_t v13 = (unsigned __int8 *)(v8 + 4);
      }
      else {
        uint64_t v15 = v12;
      }
      if (*(unsigned char *)(a1 + 56) == 2)
      {
        uint64_t v14 = (unsigned __int8 *)(BytePtr + 4);
        unint64_t v16 = 4;
      }
      else
      {
        unint64_t v16 = 16;
      }
      if (((*v13 ^ *v15) & *v14) != 0)
      {
        BOOL v17 = 1;
      }
      else
      {
        uint64_t v18 = 1;
        while (v16 != v18)
        {
          int v19 = v14[v18];
          int v20 = v13[v18] ^ v15[v18];
          ++v18;
          if ((v20 & v19) != 0)
          {
            unint64_t v21 = v18 - 1;
            goto LABEL_16;
          }
        }
        unint64_t v21 = v16;
LABEL_16:
        BOOL v17 = v21 < v16;
      }
      unsigned __int8 valuePtr = 0;
      CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSParsedCIDRPrefixKey");
      uint64_t result = (const UInt8 *)CFNumberGetValue(v22, kCFNumberSInt8Type, &valuePtr);
      if (!v17 && result)
      {
        unsigned __int8 v23 = valuePtr;
        if (valuePtr >= *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
        {
          *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v23;
        }
      }
    }
  }
  return result;
}

void non-virtual thunk to'KerberosAccountBroker::~KerberosAccountBroker(KerberosAccountBroker *this)
{
  CFAllocatorRef v2 = (char *)this - 24;
  KerberosAccountBroker::~KerberosAccountBroker((KerberosAccountBroker *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  KerberosAccountBroker::~KerberosAccountBroker((KerberosAccountBroker *)((char *)this - 24));
}

void KerberosAccountBroker::~KerberosAccountBroker(KerberosAccountBroker *this)
{
  *(void *)this = &unk_1ECFA1E20;
  *((void *)this + 3) = &unk_1ECFA1E70;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFAllocatorRef v2 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Destroying global Kerberos Account Broker", v2, 2u);
  }
  *((void *)this + 4) = &unk_1ECFA03F0;
  CFRelease(*((CFTypeRef *)this + 5));
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  KerberosAccountBroker::~KerberosAccountBroker(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void RetainableTypedDict<__CFURL const*,KerberosAccountStore *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA03F0;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<__CFURL const*,KerberosAccountStore *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA03F0;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

BOOL KerberosAccountBroker::initialize(KerberosAccountBroker *this, const __CFString *cf)
{
  if (cf)
  {
    CFAllocatorRef v4 = CFGetAllocator(cf);
    CFStringRef Copy = CFStringCreateCopy(v4, cf);
  }
  else
  {
    CFStringRef Copy = 0;
  }
  *((void *)this + 7) = Copy;
  dispatch_queue_t v6 = dispatch_queue_create("com.apple.kerberosaccountbroker.workqueue", 0);
  *((void *)this + 6) = v6;
  return v6 != 0;
}

CFStringRef KerberosAccountBroker::copyDebugDesc(KerberosAccountBroker *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<KerberosAccountBroker@%p>", this);
}

uint64_t KerberosAccountBroker::getKerberosAccountBroker(KerberosAccountBroker *this, NSURLSessionTask *a2)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN21KerberosAccountBroker24getKerberosAccountBrokerEP16NSURLSessionTask_block_invoke;
  CFHostClientContext block[3] = &unk_1E5258228;
  block[4] = this;
  if (KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sOnce != -1) {
    dispatch_once(&KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sOnce, block);
  }
  return KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sKerberosAccountBroker;
}

void ___ZN21KerberosAccountBroker24getKerberosAccountBrokerEP16NSURLSessionTask_block_invoke(uint64_t a1)
{
  BOOL v1 = *(void **)(a1 + 32);
  if (v1)
  {
    CFDictionaryRef v2 = (const __CFDictionary *)[v1 _copySocketStreamProperties];
    CFDictionaryRef v3 = v2;
    if (v2)
    {
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v2, &unk_1EC0A1158);
      CFStringRef v5 = CFDictionaryGetValue(v3, &unk_1EC0A1190);
      BundleUtilities::effectiveBundleID((BundleUtilities *)&v13, Value, v5);
      char v6 = 0;
      unsigned int v7 = v13;
      goto LABEL_6;
    }
  }
  else
  {
    CFDictionaryRef v3 = 0;
  }
  unsigned int v7 = 0;
  char v6 = 1;
LABEL_6:
  CFTypeID v8 = (KerberosAccountBroker *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 64, 0);
  *((_OWORD *)v8 + 2) = 0u;
  *((_OWORD *)v8 + 3) = 0u;
  *(_OWORD *)CFTypeID v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  KerberosAccountBroker::KerberosAccountBroker(v8);
  KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::suint64_t KerberosAccountBroker = v9;
  if (!(*(unsigned int (**)(uint64_t, const void *))(*(void *)v9 + 56))(v9, v7))
  {
    (*(void (**)(uint64_t))(*(void *)KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sKerberosAccountBroker
                                    + 48))(KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::sKerberosAccountBroker);
    KerberosAccountBroker::getKerberosAccountBroker(NSURLSessionTask *)::suint64_t KerberosAccountBroker = 0;
    if (v6) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  double Helper_x8__HeimCredSetImpersonateBundle = gotLoadHelper_x8__HeimCredSetImpersonateBundle(v10);
  if (*(void *)(v12 + 3672)) {
    HeimCredSetImpersonateBundle_delayInitStub(Helper_x8__HeimCredSetImpersonateBundle);
  }
  if ((v6 & 1) == 0) {
LABEL_12:
  }
    CFRelease(v3);
LABEL_13:
  if (v7)
  {
    CFRelease(v7);
  }
}

void sub_18425954C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void KerberosAccountBroker::KerberosAccountBroker(KerberosAccountBroker *this)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, (const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
  *CFDictionaryRef v2 = &unk_1ECFA1E20;
  v2[3] = &unk_1ECFA1E70;
  CFAllocatorRef v3 = (const __CFAllocator *)v2[1];
  *((void *)this + 4) = &unk_1ECFA03F0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = Mutable;
}

void sub_18425961C(_Unwind_Exception *a1)
{
  *BOOL v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t KerberosAccountBroker::getKerberosAccountBrokerForApplication(KerberosAccountBroker *this, const __CFData *a2, const __CFString *a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN21KerberosAccountBroker38getKerberosAccountBrokerForApplicationEPK8__CFDataPK10__CFString_block_invoke;
  v4[3] = &__block_descriptor_48_e5_v8__0l;
  v4[4] = this;
  void v4[5] = a2;
  if (KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sOnce != -1) {
    dispatch_once(&KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sOnce, v4);
  }
  return KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sKerberosAccountBroker;
}

void ___ZN21KerberosAccountBroker38getKerberosAccountBrokerForApplicationEPK8__CFDataPK10__CFString_block_invoke(uint64_t a1)
{
  BundleUtilities::effectiveBundleID((BundleUtilities *)&v7, *(CFDataRef *)(a1 + 32), *(CFTypeRef *)(a1 + 40));
  BOOL v1 = v7;
  CFDictionaryRef v2 = (KerberosAccountBroker *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 64, 0);
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *(_OWORD *)CFDictionaryRef v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  KerberosAccountBroker::KerberosAccountBroker(v2);
  KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::suint64_t KerberosAccountBroker = v3;
  if (!(*(unsigned int (**)(uint64_t, const void *))(*(void *)v3 + 56))(v3, v1))
  {
    (*(void (**)(uint64_t))(*(void *)KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sKerberosAccountBroker
                                    + 48))(KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::sKerberosAccountBroker);
    KerberosAccountBroker::getKerberosAccountBrokerForApplication(__CFData const*,__CFString const*)::suint64_t KerberosAccountBroker = 0;
    if (!v1) {
      return;
    }
    goto LABEL_5;
  }
  double Helper_x8__HeimCredSetImpersonateBundle = gotLoadHelper_x8__HeimCredSetImpersonateBundle(v4);
  if (*(void *)(v6 + 3672)) {
    HeimCredSetImpersonateBundle_delayInitStub(Helper_x8__HeimCredSetImpersonateBundle);
  }
  if (v1)
  {
LABEL_5:
    CFRelease(v1);
  }
}

void sub_1842597C8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void KerberosAccountBroker::getKerberosCredentialForURL(void *a1, const void *a2, const void *a3, uint64_t a4)
{
  (*(void (**)(void *))(*a1 + 40))(a1);
  if (a3) {
    CFRetain(a3);
  }
  if (a2) {
    CFRetain(a2);
  }
  CFTypeID v8 = a1[6];
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN21KerberosAccountBroker27getKerberosCredentialForURLEPK16_CFURLCredentialPK7__CFURLU13block_pointerFvS2_E_block_invoke;
  void v9[3] = &unk_1E5257920;
  void v9[6] = a3;
  v9[7] = a2;
  v9[4] = a4;
  void v9[5] = a1;
  dispatch_async(v8, v9);
}

uint64_t ___ZN21KerberosAccountBroker27getKerberosCredentialForURLEPK16_CFURLCredentialPK7__CFURLU13block_pointerFvS2_E_block_invoke(uint64_t a1)
{
  CFDictionaryRef v2 = *(KerberosAccountBroker **)(a1 + 40);
  uint64_t v3 = KerberosAccountBroker::copyStoreForURL(v2, *(const __CFURL **)(a1 + 48));
  if (v3)
  {
    double v4 = v3;
    (*(void (**)(KerberosAccountBroker *))(*(void *)v2 + 40))(v2);
    CFStringRef v5 = *(const void **)(a1 + 48);
    if (v5)
    {
      CFRetain(v5);
      uint64_t v6 = *(void *)(a1 + 48);
    }
    else
    {
      uint64_t v6 = 0;
    }
    unsigned int v7 = *(const void **)(a1 + 56);
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = ___ZN21KerberosAccountBroker27getKerberosCredentialForURLEPK16_CFURLCredentialPK7__CFURLU13block_pointerFvS2_E_block_invoke_2;
    v13[3] = &unk_1E5255718;
    v13[4] = *(void *)(a1 + 32);
    void v13[5] = v2;
    void v13[6] = v6;
    (*(void (**)(void *))(*v4 + 40))(v4);
    if (v7) {
      CFRetain(v7);
    }
    CFTypeID v8 = _Block_copy(v13);
    uint64_t v9 = v4[11];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZN20KerberosAccountStore42getKerberosCredentialWithCompletionHandlerEPK16_CFURLCredentialU13block_pointerFvS2_E_block_invoke;
    CFHostClientContext block[3] = &unk_1E5257CF8;
    void block[5] = v4;
    void block[6] = v7;
    block[4] = v8;
    dispatch_async(v9, block);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  double v10 = *(const void **)(a1 + 56);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = *(const void **)(a1 + 48);
  if (v11) {
    CFRelease(v11);
  }
  return (*(uint64_t (**)(KerberosAccountBroker *))(*(void *)v2 + 48))(v2);
}

void *KerberosAccountBroker::copyStoreForURL(KerberosAccountBroker *this, const __CFURL *a2)
{
  CFDataRef Value = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 5), a2);
  if (Value)
  {
    CFStringRef v5 = Value;
    (*(void (**)(void *))(*(void *)Value + 40))(Value);
  }
  else
  {
    CFStringRef v5 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 104, 0);
    *(_OWORD *)CFStringRef v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((void *)v5 + 12) = 0;
    CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)v5, *((const __CFAllocator **)this + 1));
    *(void *)uint64_t v6 = &unk_1ECFA1788;
    *(void *)(v6 + 24) = &unk_1ECFA17E0;
    *(void *)(v6 + 32) = 0;
    *(_OWORD *)(v6 + 48) = 0u;
    *(_OWORD *)(v6 + 64) = 0u;
    *(_OWORD *)(v6 + 80) = 0u;
    *(void *)(v6 + 96) = 0;
    int v7 = CFNAccountStore::initialize((CFNAccountStore *)v6, *((const __CFString **)this + 7), 0.0);
    int v8 = v7;
    if (a2 && v7)
    {
      *((void *)v5 + 8) = CFRetain(a2);
      *((void *)v5 + 7) = CFArrayCreateMutable(*((CFAllocatorRef *)v5 + 1), 0, MEMORY[0x1E4F1D510]);
      *((void *)v5 + 11) = dispatch_queue_create("com.apple.kerberosaccountstore.lookupqueue", 0);
      *((void *)v5 + 12) = dispatch_queue_create("com.apple.kerberosaccountstore.credfetchqueue", 0);
    }
    if (*((void *)v5 + 8) && *((void *)v5 + 7) && *((void *)v5 + 11) && *((void *)v5 + 12) && v8)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 5), a2, v5);
    }
    else
    {
      (*(void (**)(void *))(*(void *)v5 + 48))(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t ___ZN21KerberosAccountBroker27getKerberosCredentialForURLEPK16_CFURLCredentialPK7__CFURLU13block_pointerFvS2_E_block_invoke_2(void *a1)
{
  uint64_t v2 = a1[5];
  (*(void (**)(void))(a1[4] + 16))();
  uint64_t v3 = (const void *)a1[6];
  if (v3) {
    CFRelease(v3);
  }
  double v4 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 48);

  return v4(v2);
}

void KerberosAccountBroker::clearAccountRefreshState(NSObject **this, const __CFURL *a2)
{
  if (a2)
  {
    ((void (*)(NSObject **))(*this)[5].isa)(this);
    CFRetain(a2);
    double v4 = this[6];
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN21KerberosAccountBroker24clearAccountRefreshStateEPK7__CFURL_block_invoke;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = this;
    void v5[5] = a2;
    dispatch_async(v4, v5);
  }
}

uint64_t ___ZN21KerberosAccountBroker24clearAccountRefreshStateEPK7__CFURL_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(KerberosAccountBroker **)(a1 + 32);
  uint64_t v3 = KerberosAccountBroker::copyStoreForURL(v2, *(const __CFURL **)(a1 + 40));
  if (v3)
  {
    double v4 = v3;
    (*(void (**)(void *))(*v3 + 40))(v3);
    CFStringRef v5 = v4[11];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZN20KerberosAccountStore24clearAccountRefreshStateEv_block_invoke;
    CFHostClientContext block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = v4;
    dispatch_async(v5, block);
    (*(void (**)(void *))(*v4 + 48))(v4);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
  uint64_t v6 = *(uint64_t (**)(KerberosAccountBroker *))(*(void *)v2 + 48);

  return v6(v2);
}

void non-virtual thunk to'SHTTPConnectionCache::~SHTTPConnectionCache(SHTTPConnectionCache *this)
{
  uint64_t v2 = (char *)this - 32;
  SHTTPConnectionCache::~SHTTPConnectionCache((SHTTPConnectionCache *)((char *)this - 32));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 3);

  CFAllocatorDeallocate(v3, v2);
}

{
  SHTTPConnectionCache::~SHTTPConnectionCache((SHTTPConnectionCache *)((char *)this - 32));
}

void SHTTPConnectionCache::~SHTTPConnectionCache(SHTTPConnectionCache *this)
{
  *(void *)this = &unk_1ECFA19A8;
  *((void *)this + 4) = &unk_1ECFA1A68;
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  (*(void (**)(void))(**((void **)this + 12) + 48))(*((void *)this + 12));
  *((void *)this + 13) = 0;
  CFRelease(*((CFTypeRef *)this + 6));
  *((void *)this + 4) = &unk_1ECF9B550;
  *(void *)this = &unk_1ECF9FF58;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  SHTTPConnectionCache::~SHTTPConnectionCache(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_184259FB0(_Unwind_Exception *a1)
{
  CFRelease(*(CFTypeRef *)(v1 + 48));
  *(void *)(v1 + 32) = &unk_1ECF9B550;
  *(void *)uint64_t v1 = &unk_1ECF9FF58;

  _Unwind_Resume(a1);
}

uint64_t SHTTPConnectionCache::_meta_release(SHTTPConnectionCache *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

uint64_t SHTTPConnectionCache::_meta_retain(SHTTPConnectionCache *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

void SHTTPConnectionCache::enableCellTimer(SHTTPConnectionCache *this)
{
  if (!*((void *)this + 15))
  {
    uint64_t v2 = (*(uint64_t (**)(void))(**((void **)this + 12) + 80))(*((void *)this + 12));
    double v3 = (double)*((int *)this + 21);
    *((void *)this + 15) = v2;
    dispatch_time_t v4 = dispatch_time(0, (uint64_t)(v3 * 1000000000.0));
    dispatch_source_set_timer(v2, v4, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
    (*(void (**)(SHTTPConnectionCache *))(*(void *)this + 40))(this);
    (*(void (**)(void))(**((void **)this + 13) + 40))(*((void *)this + 13));
    CFStringRef v5 = *((void *)this + 15);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 3221225472;
    handler[2] = ___ZN20SHTTPConnectionCache15enableCellTimerEv_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    void handler[4] = this;
    dispatch_source_set_event_handler(v5, handler);
    uint64_t v6 = *((void *)this + 15);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    void v7[2] = ___ZN20SHTTPConnectionCache15enableCellTimerEv_block_invoke_2;
    v7[3] = &__block_descriptor_40_e5_v8__0l;
    v7[4] = this;
    dispatch_source_set_cancel_handler(v6, v7);
    dispatch_resume(*((dispatch_object_t *)this + 15));
  }
}

uint64_t ___ZN20SHTTPConnectionCache15enableCellTimerEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(HTTPConnectionCache **)(a1 + 32);
  HTTPConnectionCache::disableCellTimer(v1);
  SHTTPConnectionCache::purgeExcessiveConnections((uint64_t)v1);
  uint64_t result = SHTTPConnectionCache::performIdleSweep(v1);
  if (result)
  {
    double v3 = *(uint64_t (**)(HTTPConnectionCache *))(*(void *)v1 + 152);
    return v3(v1);
  }
  return result;
}

uint64_t ___ZN20SHTTPConnectionCache15enableCellTimerEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  (*(void (**)(void *))(*v1[13] + 48))(v1[13]);
  uint64_t v2 = (uint64_t (*)(void **))(*v1)[6];

  return v2(v1);
}

uint64_t SHTTPConnectionCache::purgeExcessiveConnections(uint64_t this)
{
  if (*(void *)(this + 40))
  {
    CFArrayCreateMutable(*(CFAllocatorRef *)(this + 8), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    operator new();
  }
  return this;
}

void sub_18425A494(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t SHTTPConnectionCache::performIdleSweep(SHTTPConnectionCache *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (v1)
  {
    CFArrayCreateMutable(*(CFAllocatorRef *)(v1 + 8), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    CFAbsoluteTimeGetCurrent();
    operator new();
  }
  return 0;
}

void sub_18425A84C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf, char a10)
{
}

uint64_t SHTTPConnectionCache::purgeIdleConnections(SHTTPConnectionCache *this)
{
  uint64_t v1 = *((void *)this + 12);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  uint64_t v3[2] = ___ZN20SHTTPConnectionCache20purgeIdleConnectionsEv_block_invoke;
  v3[3] = &__block_descriptor_40_e5_v8__0l;
  v3[4] = this;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v1 + 96))(v1, v3);
}

void ___ZN20SHTTPConnectionCache20purgeIdleConnectionsEv_block_invoke(uint64_t a1)
{
}

void SHTTPConnectionCache::timeoutIdleConnections(SHTTPConnectionCache *this)
{
  HTTPConnectionCache::disableTimer(this);
  SHTTPConnectionCache::purgeExcessiveConnections((uint64_t)this);
  if (SHTTPConnectionCache::performIdleSweep(this))
  {
    SHTTPConnectionCache::enableTimer(this);
  }
}

void SHTTPConnectionCache::enableTimer(SHTTPConnectionCache *this)
{
  if (!*((void *)this + 14))
  {
    uint64_t v2 = (*(uint64_t (**)(void))(**((void **)this + 12) + 80))(*((void *)this + 12));
    double v3 = (double)*((int *)this + 20);
    *((void *)this + 14) = v2;
    dispatch_time_t v4 = dispatch_time(0, (uint64_t)(v3 * 1000000000.0));
    dispatch_source_set_timer(v2, v4, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    (*(void (**)(SHTTPConnectionCache *))(*(void *)this + 40))(this);
    (*(void (**)(void))(**((void **)this + 13) + 40))(*((void *)this + 13));
    CFStringRef v5 = *((void *)this + 14);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 3221225472;
    handler[2] = ___ZN20SHTTPConnectionCache11enableTimerEv_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    void handler[4] = this;
    dispatch_source_set_event_handler(v5, handler);
    uint64_t v6 = *((void *)this + 14);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    void v7[2] = ___ZN20SHTTPConnectionCache11enableTimerEv_block_invoke_2;
    v7[3] = &__block_descriptor_40_e5_v8__0l;
    v7[4] = this;
    dispatch_source_set_cancel_handler(v6, v7);
    dispatch_resume(*((dispatch_object_t *)this + 14));
  }
}

uint64_t ___ZN20SHTTPConnectionCache11enableTimerEv_block_invoke(uint64_t a1)
{
  return SHTTPConnectionCache::timeoutIdleConnections(*(SHTTPConnectionCache **)(a1 + 32));
}

uint64_t ___ZN20SHTTPConnectionCache11enableTimerEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  (*(void (**)(void *))(*v1[13] + 48))(v1[13]);
  uint64_t v2 = (uint64_t (*)(void **))(*v1)[6];

  return v2(v1);
}

__CFDictionary *SHTTPConnectionCache::invalidateUnpurgeableConnectionsForKey(__CFDictionary *this, const HTTPConnectionCacheKey *a2)
{
  if (a2)
  {
    double v3 = this;
    SHTTPConnectionCache::ensureEntries(this);
    this = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(*((void *)v3 + 5) + 32), a2);
    if (this)
    {
      uint64_t v4 = (uint64_t)this;
      (*(void (**)(__CFDictionary *))(*(void *)this + 40))(this);
      SHTTPConnectionCacheEntry::invalidateUnpurgeableConnections(v4);
      CFStringRef v5 = *(uint64_t (**)(uint64_t))(*(void *)v4 + 48);
      return (__CFDictionary *)v5(v4);
    }
  }
  return this;
}

CFMutableDictionaryRef SHTTPConnectionCache::ensureEntries(CFMutableDictionaryRef this)
{
  if (!*((void *)this + 5))
  {
    CFMutableDictionaryRef v1 = this;
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    double v3 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 40, 0);
    *double v3 = &unk_1ECFA4E60;
    v3[1] = v2;
    uint64_t v3[2] = &unk_1ECFA4E80;
    v3[3] = &unk_1ECFA0370;
    v3[4] = 0;
    this = CFDictionaryCreateMutable(v2, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
    v3[4] = this;
    *((void *)v1 + 5) = v3;
  }
  return this;
}

void sub_18425AD48(_Unwind_Exception *a1)
{
  *CFMutableDictionaryRef v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,SHTTPConnectionCacheEntry *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0370;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,SHTTPConnectionCacheEntry *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0370;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void non-virtual thunk to'SHTTPConnectionCacheDictionary::~SHTTPConnectionCacheDictionary(SHTTPConnectionCacheDictionary *this)
{
  CFAllocatorRef v2 = (char *)this - 16;
  *((void *)this - 2) = &unk_1ECFA4E60;
  *(void *)this = &unk_1ECFA4E80;
  *((void *)this + 1) = &unk_1ECFA0370;
  CFRelease(*((CFTypeRef *)this + 2));
  *(void *)this = &unk_1ECF9B550;
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  *((void *)this - 2) = &unk_1ECFA4E60;
  *(void *)this = &unk_1ECFA4E80;
  *((void *)this + 1) = &unk_1ECFA0370;
  CFRelease(*((CFTypeRef *)this + 2));
  *(void *)this = &unk_1ECF9B550;
}

void SHTTPConnectionCacheDictionary::~SHTTPConnectionCacheDictionary(SHTTPConnectionCacheDictionary *this)
{
  *(void *)this = &unk_1ECFA4E60;
  *((void *)this + 2) = &unk_1ECFA4E80;
  *((void *)this + 3) = &unk_1ECFA0370;
  CFRelease(*((CFTypeRef *)this + 4));
  *((void *)this + 2) = &unk_1ECF9B550;
  CFAllocatorRef v2 = (const __CFAllocator *)*((void *)this + 1);

  CFAllocatorDeallocate(v2, this);
}

{
  *(void *)this = &unk_1ECFA4E60;
  *((void *)this + 2) = &unk_1ECFA4E80;
  *((void *)this + 3) = &unk_1ECFA0370;
  CFRelease(*((CFTypeRef *)this + 4));
  *((void *)this + 2) = &unk_1ECF9B550;
}

void SHTTPConnectionCache::invalidateAllConnections(SHTTPConnectionCache *this)
{
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(*((void *)this + 5) + 32), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,SHTTPConnectionCacheEntry *>::_visit, &__block_literal_global_10987);
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(*((void *)this + 5) + 32));
  CFSetRemoveAllValues(*((CFMutableSetRef *)this + 6));
  HTTPConnectionCache::disableTimer(this);

  HTTPConnectionCache::disableCellTimer(this);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,SHTTPConnectionCacheEntry *>::_visit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFIndex ___ZN30SHTTPConnectionCacheDictionary18forgetCacheEntriesEv_block_invoke(int a1, int a2, SHTTPConnectionCacheEntry *this)
{
  SHTTPConnectionCacheEntry::invalidateUnpurgeableConnections((uint64_t)this);
  uint64_t v4 = *((unsigned int *)this + 52);
  if ((int)v4 >= 1)
  {
    unint64_t v5 = v4 + 1;
    do
    {
      uint64_t v6 = *(CFMutableArrayRef **)(*((void *)this + 11) + 8 * (v5 - 2));
      if (v6 && CFArrayGetCount(*v6) >= 1) {
        CFArrayRemoveAllValues(*v6);
      }
      --v5;
    }
    while (v5 > 1);
  }

  return SHTTPConnectionCacheEntry::setHasBeenForgotten((CFIndex)this);
}

uint64_t SHTTPConnectionCache::getPendingTubeForProtocolWithKey(uint64_t a1, uint64_t a2, void *key)
{
  if (!key) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3) {
    return 0;
  }
  CFDataRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 32), key);
  if (!Value) {
    return 0;
  }
  int v7 = Value;
  (*(void (**)(const void *))(*(void *)Value + 40))(Value);
  uint64_t v8 = (*(uint64_t (**)(const void *, uint64_t, void *))(*(void *)v7 + 80))(v7, a2, key);
  (*(void (**)(const void *))(*(void *)v7 + 48))(v7);
  return v8;
}

uint64_t SHTTPConnectionCache::ingestTube(SHTTPConnectionCache *this, const void **a2)
{
  SHTTPConnectionCache::ensureEntries(this);
  CFDataRef Value = (SHTTPConnectionCacheEntry *)CFDictionaryGetValue(*(CFDictionaryRef *)(*((void *)this + 5) + 32), a2[12]);
  if (!Value) {
    SHTTPConnectionCache::createEmptyCacheEntry((CFMutableSetRef *)this, (const HTTPConnectionCacheKey *)a2[12]);
  }
  unint64_t v5 = Value;
  (*(void (**)(SHTTPConnectionCacheEntry *))(*(void *)Value + 40))(Value);
  SHTTPConnectionCacheEntry::ingestTube(v5, (HTTPConnectionCacheKey **)a2);
  (*(void (**)(SHTTPConnectionCacheEntry *))(*(void *)v5 + 48))(v5);
  SHTTPConnectionCache::enableTimer(this);
  uint64_t v6 = *(uint64_t (**)(SHTTPConnectionCache *))(*(void *)this + 152);

  return v6(this);
}

void SHTTPConnectionCache::createEmptyCacheEntry(CFMutableSetRef *this, const HTTPConnectionCacheKey *a2)
{
  if (CFSetContainsValue(this[6], a2)) {
    CFSetRemoveValue(this[6], a2);
  }
  uint64_t v4 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate(this[1], 256, 0);
  *(_OWORD *)uint64_t v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((_OWORD *)v4 + 7) = 0u;
  *((_OWORD *)v4 + 8) = 0u;
  *((_OWORD *)v4 + 9) = 0u;
  *((_OWORD *)v4 + 10) = 0u;
  *((_OWORD *)v4 + 11) = 0u;
  *((_OWORD *)v4 + 12) = 0u;
  *((_OWORD *)v4 + 13) = 0u;
  *((_OWORD *)v4 + 14) = 0u;
  *((_OWORD *)v4 + 15) = 0u;
  CFAllocatorRef v5 = this[1];
  uint64_t v6 = (char *)(this + 7);
  CFMutableSetRef v7 = this[12];
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v4, v5);
  *uint64_t v8 = &unk_1ECFA32A0;
  v8[3] = &unk_1ECFA3308;
  v8[28] = v6;
  *((void *)v4 + 29) = CFArrayCreateMutable(v5, 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  *((void *)v4 + 4) = (*(uint64_t (**)(CFMutableSetRef))(*(void *)v7 + 88))(v7);
  operator new();
}

void sub_18425B664(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v2, 0x20C4093837F09);
  CFRelease(*(CFTypeRef *)(v1 + 232));
  *uint64_t v3 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t SHTTPConnectionCache::enqueueRequestForProtocol(__CFDictionary *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = *(_DWORD *)a4;
  *(void *)CFDataRef v26 = *(void *)(a4 + 4);
  *(void *)&v26[7] = *(void *)(a4 + 11);
  int v8 = *(unsigned __int8 *)(a4 + 19);
  int v9 = *(_DWORD *)(a4 + 20);
  SHTTPConnectionCache::ensureEntries(a1);
  uint64_t v10 = *((void *)a1 + 5);
  uint64_t v11 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  CFDataRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v10 + 32), v11);
  if (!Value)
  {
    uint64_t v14 = (const HTTPConnectionCacheKey *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
    SHTTPConnectionCache::createEmptyCacheEntry((CFMutableSetRef *)a1, v14);
  }
  uint64_t v13 = Value;
  (*(void (**)(void *))(*(void *)Value + 40))(Value);
  uint64_t v32 = 0;
  unsigned __int8 v31 = 0;
  if (!*((void *)v13 + 27)) {
    *((void *)v13 + 27) = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(a3 - 16));
  }
  if (v8) {
    *((unsigned char *)v13 + 40) |= 8u;
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  if ((*(unsigned int (**)(uint64_t))(*(void *)v15 + 88))(v15) == 2)
  {
    *((unsigned char *)v13 + 40) |= 0x40u;
    BOOL v16 = 0;
  }
  else
  {
    BOOL v16 = v7 < *((_DWORD *)v13 + 52);
  }
  BOOL v17 = !v16 || v7 < 0;
  *(void *)uint64_t v28 = *(void *)v26;
  *(void *)&v28[7] = *(void *)&v26[7];
  if (v17) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = v7;
  }
  int v19 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate(*((CFAllocatorRef *)v13 + 1), 80, 0);
  *(_OWORD *)int v19 = 0u;
  *((_OWORD *)v19 + 1) = 0u;
  *((_OWORD *)v19 + 2) = 0u;
  *((_OWORD *)v19 + 3) = 0u;
  *((_OWORD *)v19 + 4) = 0u;
  CFAllocatorRef v20 = (const __CFAllocator *)*((void *)v13 + 1);
  unsigned int v27 = v18;
  char v29 = v8;
  int v30 = v9;
  SHTTPConnectionCacheEnqueuedRequestInfo::SHTTPConnectionCacheEnqueuedRequestInfo(v19, v20, a2, a3, (long long *)&v27);
  unint64_t v21 = *(CFMutableArrayRef **)(*((void *)v13 + 11) + 8 * v18);
  if (!v21) {
    operator new();
  }
  CFArrayAppendValue(*v21, v19);
  SHTTPConnectionCacheEntry::findOrCreateEmptyNetConnection((SHTTPConnectionCacheEntry *)v13, &v32, v19, &v31);
  CFNumberRef v22 = v32;
  if (v32)
  {
    unsigned int v23 = v31;
    if (!v31) {
      *((void *)v32 + 37) = 0;
    }
    SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection((CFArrayRef **)v13, v22, v23);
    (*(void (**)(HTTPNetConnection *))(*(void *)v22 + 48))(v22);
  }
  (*(void (**)(CFAllocatedReferenceCountedObject *))(*(void *)v19 + 48))(v19);
  SHTTPConnectionCache::purgeExcessiveConnections((uint64_t)a1);
  SHTTPConnectionCache::enableTimer(a1);
  (*(void (**)(__CFDictionary *))(*(void *)a1 + 152))(a1);
  CFDataRef v24 = *(uint64_t (**)(void *))(*(void *)v13 + 48);

  return v24(v13);
}

void sub_18425BA64(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

void SHTTPConnectionCache::useFastPathForCacheEntryWithKey(SHTTPConnectionCache *this, const HTTPConnectionCacheKey *value)
{
  if (value)
  {
    uint64_t v4 = *((void *)this + 5);
    if (v4 && (CFAllocatorRef v5 = CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 32), value)) != 0)
    {
      uint64_t v6 = v5;
      (*(void (**)(const void *))(*(void *)v5 + 40))(v5);
      int v7 = *(void (**)(const void *))(*(void *)v6 + 48);
      v7(v6);
    }
    else
    {
      int v8 = (__CFSet *)*((void *)this + 6);
      CFSetAddValue(v8, value);
    }
  }
}

uint64_t SHTTPConnectionCache::initWithSchedulingSet(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    *(void *)(a1 + 96) = a2;
    (*(void (**)(uint64_t))(*(void *)a2 + 40))(a2);
  }
  else
  {
    *(void *)(a1 + 96) = CoreSchedulingSet::copyLoaderQueueSet((CoreSchedulingSet *)a1);
  }
  *(void *)(a1 + 104) = a3;
  *(void *)(a1 + 40) = 0;
  SHTTPConnectionCache::enableTimer((SHTTPConnectionCache *)a1);
  CFAllocatorRef v5 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 152);

  return v5(a1);
}

BOOL SHTTPConnectionCache::equals(SHTTPConnectionCache *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

void non-virtual thunk to'HostLookup_Master::~HostLookup_Master(HostLookup_Master *this)
{
}

{
  HostLookup_Master::~HostLookup_Master((HostLookup_Master *)((char *)this - 8));
}

void HostLookup_Master::~HostLookup_Master(HostLookup_Master *this)
{
  *(void *)this = &unk_1ECF9EC28;
  *((void *)this + 1) = &unk_1ECF9EC90;
  CFRelease((CFTypeRef)(*((void *)this + 7) - 16));

  HostLookup::~HostLookup(this);
}

void sub_18425BD40(_Unwind_Exception *a1)
{
  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

uint64_t HostLookup_Master::getAddrInfoMachPortCallback(HostLookup_Master *this, CFMachPortRef port, void *a3)
{
  CFMachPortInvalidate(port);
  if (*((CFMachPortRef *)this + 4) == port)
  {
    *((void *)this + 4) = 0;
    if (port) {
      CFRelease(port);
    }
  }

  return getaddrinfo_async_handle_reply();
}

void HostLookup_Master::getAddrInfoCallback(HostLookup_Master *this, int a2, addrinfo *a3)
{
  uint64_t v6 = (Host *)*((void *)this + 7);
  CFRetain((char *)v6 - 16);
  if (a2)
  {
    if (a2 == 11)
    {
      a2 = *__error();
      uint64_t v7 = 1;
    }
    else
    {
      uint64_t v7 = 12;
    }
    uint64_t v16 = v7;
    int v17 = a2;
    CFAllocatorRef v15 = CFGetAllocator((char *)v6 - 16);
    CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v15, (int *)&v16);
    Host::performCallback(v6, *((const __CFString **)this + 3), CFErrorWithStreamError);
    if (!CFErrorWithStreamError) {
      goto LABEL_18;
    }
  }
  else
  {
    CFAllocatorRef v8 = CFGetAllocator((char *)v6 - 16);
    CFErrorWithStreamCFStreamError Error = CFArrayCreateMutable(v8, 0, MEMORY[0x1E4F1D510]);
    if (a3)
    {
      uint64_t v10 = a3;
      do
      {
        ai_addr = v10->ai_addr;
        int sa_family = ai_addr->sa_family;
        if (sa_family == 30 || sa_family == 2)
        {
          CFDataRef v14 = CFDataCreate(v8, &ai_addr->sa_len, ai_addr->sa_len);
          CFArrayAppendValue(CFErrorWithStreamError, v14);
          if (v14) {
            CFRelease(v14);
          }
        }
        uint64_t v10 = v10->ai_next;
      }
      while (v10);
    }
    Host::performCallback(v6, *((const __CFString **)this + 3), CFErrorWithStreamError);
  }
  CFRelease(CFErrorWithStreamError);
LABEL_18:
  if (a3) {
    freeaddrinfo(a3);
  }
  CFRelease((char *)v6 - 16);
}

void sub_18425BF08(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

CFErrorRef HostLookup_Master::prepareLookup(HostLookup_Master *this, Host *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  *((void *)this + 7) = a2;
  CFRetain((char *)a2 - 16);
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  CFAllocatorRef v4 = v3;
  CFStringRef v5 = (const __CFString *)*((void *)this + 5);
  CFAllocatorRef v17 = v3;
  uint64_t v18 = 1023;
  if (v5)
  {
    uint64_t v6 = _CFStringGetOrCreateCString(v3, v5, v20, &v18, 0x8000100u);
    uint64_t v7 = v18;
  }
  else
  {
    uint64_t v7 = 0;
    v20[0] = 0;
    uint64_t v18 = 0;
    uint64_t v6 = v20;
  }
  int v19 = v6;
  if (v7 != strlen((const char *)v6))
  {
    *(_OWORD *)&allocator[0].version = xmmword_1843D1800;
    CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v4, (int *)allocator);
    goto LABEL_23;
  }
  mach_port_t portNum = 0;
  if (!CFEqual(*((CFTypeRef *)this + 3), &unk_1EC0A4840)) {
    CFEqual(*((CFTypeRef *)this + 3), &unk_1EC0A4878);
  }
  CFStringRef v9 = (const __CFString *)*((void *)this + 6);
  if (v9)
  {
    allocator[0].version = (CFIndex)v4;
    allocator[0].info = (void *)1023;
    allocator[0].retain = (const void *(__cdecl *)(const void *))_CFStringGetOrCreateCString(v4, v9, (UInt8 *)&allocator[0].release, (uint64_t *)&allocator[0].info, 0x8000100u);
    mach_port_t v10 = _getaddrinfo_interface_async_call();
    mach_port_t portNum = v10;
    if (allocator[0].retain && &allocator[0].release != (void (__cdecl **)(const void *))allocator[0].retain) {
      CFAllocatorDeallocate((CFAllocatorRef)allocator[0].version, allocator[0].retain);
    }
    CFErrorWithStreamCFStreamError Error = 0;
  }
  else
  {
    int v11 = getaddrinfo_async_start();
    if (!v11) {
      int v11 = -1;
    }
    *(_OWORD *)&allocator[0].version = xmmword_1843D1810;
    LODWORD(allocator[0].info) = v11;
    CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v4, (int *)allocator);
    mach_port_t v10 = 0;
    if (CFErrorWithStreamError) {
      goto LABEL_19;
    }
  }
  if (!v10)
  {
    int v12 = *__error();
    *(_OWORD *)&allocator[0].version = xmmword_1843D16F0;
    LODWORD(allocator[0].info) = v12;
    CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v4, (int *)allocator);
  }
LABEL_19:
  if (!CFErrorWithStreamError)
  {
    allocator[0].version = 0;
    allocator[0].info = this;
    allocator[0].release = 0;
    allocator[0].copyDescription = 0;
    allocator[0].retain = 0;
    uint64_t v13 = CFMachPortCreateWithPort(v4, portNum, (CFMachPortCallBack)HostLookup_Master::_GetAddrInfoMachPortCallBack, allocator, 0);
    *((void *)this + 4) = v13;
    if (v13) {
      uint64_t v13 = CFRetain(v13);
    }
    CFErrorWithStreamCFStreamError Error = 0;
    *((void *)this + 2) = v13;
  }
LABEL_23:
  if (v19 && v20 != v19) {
    CFAllocatorDeallocate(v17, v19);
  }
  return CFErrorWithStreamError;
}

void sub_18425C1FC(_Unwind_Exception *a1)
{
  CFAllocatorRef v3 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    if (v1 != v3) {
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x460], v3);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t HostLookup_Master::_GetAddrInfoMachPortCallBack(HostLookup_Master *this, __CFMachPort *a2, void *a3, uint64_t a4, void *a5)
{
  return (*(uint64_t (**)(uint64_t, HostLookup_Master *, __CFMachPort *))(*(void *)a4 + 80))(a4, this, a2);
}

uint64_t HostLookup_Master::_GetAddrInfoCallBack(HostLookup_Master *this, uint64_t a2, addrinfo *a3, void *a4)
{
  return (*(uint64_t (**)(addrinfo *, HostLookup_Master *, uint64_t))(*(void *)&a3->ai_flags + 72))(a3, this, a2);
}

void HostLookup::HostLookup(HostLookup *this, CFTypeRef cf)
{
  *(void *)this = &unk_1ECF9A868;
  *((void *)this + 1) = &unk_1ECF9A8C0;
  *((void *)this + 2) = 0;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  *((void *)this + 3) = v3;
}

void sub_18425C348(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void HostLookup_Master::HostLookup_Master(HostLookup_Master *this, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  HostLookup::HostLookup(this, a2);
  void *v7 = &unk_1ECF9EC28;
  v7[1] = &unk_1ECF9EC90;
  if (a3) {
    CFTypeRef v8 = CFRetain(a3);
  }
  else {
    CFTypeRef v8 = 0;
  }
  *((void *)this + 5) = v8;
  if (a4) {
    CFTypeRef v9 = CFRetain(a4);
  }
  else {
    CFTypeRef v9 = 0;
  }
  *((void *)this + 6) = v9;
}

void sub_18425C40C(_Unwind_Exception *a1)
{
  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

CFErrorRef HostLookup_Master::enqueueWithHost(HostLookup_Master *this, DispatchHost *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
  CFAllocatorRef v8 = v7;
  CFAllocatorRef v13 = v7;
  uint64_t v14 = 1023;
  if (a3)
  {
    CFTypeRef v9 = _CFStringGetOrCreateCString(v7, a3, v16, &v14, 0x8000100u);
    a3 = (const __CFString *)v14;
  }
  else
  {
    v16[0] = 0;
    uint64_t v14 = 0;
    CFTypeRef v9 = v16;
  }
  CFAllocatorRef v15 = v9;
  if (a3 == (const __CFString *)strlen((const char *)v9))
  {
    if (!CFEqual(a2, &unk_1EC0A4840)) {
      CFEqual(a2, &unk_1EC0A4878);
    }
    operator new();
  }
  *(_OWORD *)&handle[1] = xmmword_1843D1800;
  CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v8, &handle[1]);
  if (v15 && v16 != v15) {
    CFAllocatorDeallocate(v13, v15);
  }
  return CFErrorWithStreamError;
}

void sub_18425C778(_Unwind_Exception *a1)
{
  CFTypeRef v3 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    if (v1 != v3) {
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x460], v3);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t _HostLookup_Master_dispatch_GetAddrInfoCallBack(int a1, addrinfo *a2, void *a3)
{
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)(*((void *)a3 + 1) - 16));
  CFAllocatorRef v7 = v6;
  if (a1)
  {
    if (a1 == 11)
    {
      a1 = *__error();
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v8 = 12;
    }
    uint64_t v18 = v8;
    int v19 = a1;
    CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v7, (int *)&v18);
    DispatchHost::performCallback(*((DispatchHost **)a3 + 1), *((const __CFString **)a3 + 2), CFErrorWithStreamError);
    if (!CFErrorWithStreamError) {
      goto LABEL_19;
    }
    CFErrorRef v15 = CFErrorWithStreamError;
  }
  else
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510]);
    if (a2)
    {
      mach_port_t v10 = a2;
      do
      {
        ai_addr = v10->ai_addr;
        int sa_family = ai_addr->sa_family;
        if (sa_family == 30 || sa_family == 2)
        {
          CFDataRef v14 = CFDataCreate(v7, &ai_addr->sa_len, ai_addr->sa_len);
          CFArrayAppendValue(Mutable, v14);
          if (v14) {
            CFRelease(v14);
          }
        }
        mach_port_t v10 = v10->ai_next;
      }
      while (v10);
    }
    DispatchHost::performCallback(*((DispatchHost **)a3 + 1), *((const __CFString **)a3 + 2), Mutable);
    CFErrorRef v15 = Mutable;
  }
  CFRelease(v15);
LABEL_19:
  if (a2) {
    freeaddrinfo(a2);
  }
  return (*(uint64_t (**)(void *))(*(void *)a3 + 8))(a3);
}

void sub_18425C964(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void DispatchHost::HostAndInfoTypeHelper::~HostAndInfoTypeHelper(DispatchHost::HostAndInfoTypeHelper *this)
{
  DispatchHost::HostAndInfoTypeHelper::~HostAndInfoTypeHelper(this);

  JUMPOUT(0x18531B6D0);
}

{
  const void *v2;

  *(void *)this = &unk_1ECFA5CE8;
  uint64_t v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)this = &unk_1ECFA5CC8;
  CFRelease((CFTypeRef)(*((void *)this + 1) - 16));
}

void sub_18425CA28(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECFA5CC8;
  CFRelease((CFTypeRef)(v1[1] - 16));
  _Unwind_Resume(a1);
}

void DispatchHost::GetAddrAsyncHelper::~GetAddrAsyncHelper(DispatchHost::GetAddrAsyncHelper *this)
{
  *(void *)this = &unk_1ECFA5CC8;
  CFRelease((CFTypeRef)(*((void *)this + 1) - 16));

  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECFA5CC8;
  CFRelease((CFTypeRef)(*((void *)this + 1) - 16));
}

void non-virtual thunk to'HostLookup_Names::~HostLookup_Names(HostLookup_Names *this)
{
}

{
  HostLookup_Names::~HostLookup_Names((HostLookup_Names *)((char *)this - 8));
}

void HostLookup_Names::~HostLookup_Names(HostLookup_Names *this)
{
  *(void *)this = &unk_1ECF9DDE8;
  *((void *)this + 1) = &unk_1ECF9DE40;
  uint64_t v2 = (const void *)*((void *)this + 5);
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = (const void *)*((void *)this + 6);
  if (v3) {
    CFRelease(v3);
  }

  HostLookup::~HostLookup(this);
}

void sub_18425CBA8(_Unwind_Exception *a1)
{
  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

CFErrorRef HostLookup_Names::prepareLookup(HostLookup_Names *this, Host *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *((void *)this + 4) = a2;
  CFRetain((char *)a2 - 16);
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  CFDataGetBytePtr(*((CFDataRef *)this + 5));
  mach_port_t portNum = 0;
  CFStringRef v4 = (const __CFString *)*((void *)this + 6);
  if (v4)
  {
    allocator[0].version = (CFIndex)v3;
    allocator[0].info = (void *)1023;
    allocator[0].retain = (const void *(__cdecl *)(const void *))_CFStringGetOrCreateCString(v3, v4, (UInt8 *)&allocator[0].release, (uint64_t *)&allocator[0].info, 0x8000100u);
    mach_port_t v5 = _getnameinfo_interface_async_call();
    mach_port_t portNum = v5;
    if (allocator[0].retain && &allocator[0].release != (void (__cdecl **)(const void *))allocator[0].retain) {
      CFAllocatorDeallocate((CFAllocatorRef)allocator[0].version, allocator[0].retain);
    }
    CFErrorRef result = 0;
LABEL_9:
    if (!v5)
    {
      int v8 = *__error();
      *(_OWORD *)&allocator[0].version = xmmword_1843D16F0;
      LODWORD(allocator[0].info) = v8;
      CFErrorRef result = __cfnCreateCFErrorWithStreamError(v3, (int *)allocator);
    }
    goto LABEL_11;
  }
  int v7 = getnameinfo_async_start();
  if (!v7) {
    int v7 = -1;
  }
  *(_OWORD *)&allocator[0].version = xmmword_1843D1810;
  LODWORD(allocator[0].info) = v7;
  CFErrorRef result = __cfnCreateCFErrorWithStreamError(v3, (int *)allocator);
  mach_port_t v5 = 0;
  if (!result) {
    goto LABEL_9;
  }
LABEL_11:
  if (!result)
  {
    allocator[0].version = 0;
    allocator[0].info = this;
    allocator[0].release = 0;
    allocator[0].copyDescription = 0;
    allocator[0].retain = 0;
    CFMachPortRef v9 = CFMachPortCreateWithPort(v3, portNum, (CFMachPortCallBack)HostLookup_Names::_GetNameInfoMachPortCallBack, allocator, 0);
    *((void *)this + 7) = v9;
    if (v9) {
      CFTypeRef v10 = CFRetain(v9);
    }
    else {
      CFTypeRef v10 = 0;
    }
    CFErrorRef result = 0;
    *((void *)this + 2) = v10;
  }
  return result;
}

void sub_18425CDB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  if (ptr)
  {
    if (v13 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t HostLookup_Names::_GetNameInfoMachPortCallBack(HostLookup_Names *this, __CFMachPort *a2, void *a3, uint64_t a4, void *a5)
{
  CFMachPortInvalidate(this);
  if (*(HostLookup_Names **)(a4 + 56) == this)
  {
    *(void *)(a4 + 56) = 0;
    if (this) {
      CFRelease(this);
    }
  }

  return MEMORY[0x1F40CC458](a2);
}

void HostLookup_Names::_GetNameInfoCallBack(HostLookup_Names *this, char *cStr, char *a3, char *a4, void *a5)
{
  valuePtr[19] = *MEMORY[0x1E4F143B8];
  if (this == 11)
  {
    unsigned int v8 = *__error();
    uint64_t v13 = 1;
  }
  else
  {
    unsigned int v8 = this;
    if (!this)
    {
      CFMachPortRef v9 = (Host *)*((void *)a4 + 4);
      CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef v11 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x8000100u);
      Array = cfTypeCreateArray(v10, v11, 0, 0, 0, off_1ECF9A530, v11, 0, 0);
      Host::performCallback(v9, @"kCFHostNames", Array);
      if (Array) {
        CFRelease(Array);
      }
      AutoString::~AutoString((AutoString *)valuePtr);
      goto LABEL_10;
    }
    uint64_t v13 = 12;
  }
  CFAllocatorRef v14 = CFGetAllocator(a4 - 16);
  valuePtr[0] = v13;
  valuePtr[1] = v8;
  CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v14, (int *)valuePtr);
  Host::performCallback(*((Host **)a4 + 4), @"kCFHostNames", CFErrorWithStreamError);
  if (CFErrorWithStreamError) {
    CFRelease(CFErrorWithStreamError);
  }
LABEL_10:
  if (cStr) {
    free(cStr);
  }
  if (a3) {
    free(a3);
  }
}

void sub_18425CFC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (v13) {
    CFRelease(v13);
  }
  AutoString::~AutoString((AutoString *)&a13);
  _Unwind_Resume(a1);
}

uint64_t _dispach_HostLookup_Names__GetNameInfoCallBack(unsigned int a1, char *a2, char *a3, void *a4)
{
  valuePtr[19] = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)(*((void *)a4 + 1) - 16));
  CFAllocatorRef v9 = v8;
  if (a1 == 11)
  {
    a1 = *__error();
    uint64_t v13 = 1;
  }
  else
  {
    if (!a1)
    {
      CFAllocatorRef v10 = (DispatchHost *)*((void *)a4 + 1);
      CFStringRef v11 = CFStringCreateWithCString(v8, a2, 0x8000100u);
      Array = cfTypeCreateArray(v9, v11, 0, 0, 0, off_1ECF9A530, v11, 0, 0);
      DispatchHost::performCallback(v10, @"kCFHostNames", Array);
      if (Array) {
        CFRelease(Array);
      }
      AutoString::~AutoString((AutoString *)valuePtr);
      goto LABEL_10;
    }
    uint64_t v13 = 12;
  }
  valuePtr[0] = v13;
  valuePtr[1] = a1;
  CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v9, (int *)valuePtr);
  DispatchHost::performCallback(*((DispatchHost **)a4 + 1), @"kCFHostNames", CFErrorWithStreamError);
  if (CFErrorWithStreamError) {
    CFRelease(CFErrorWithStreamError);
  }
LABEL_10:
  if (a2) {
    free(a2);
  }
  if (a3) {
    free(a3);
  }
  return (*(uint64_t (**)(void *))(*(void *)a4 + 8))(a4);
}

void sub_18425D198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (v13) {
    CFRelease(v13);
  }
  AutoString::~AutoString((AutoString *)&a13);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HostLookup_Reachability::~HostLookup_Reachability(HostLookup_Reachability *this)
{
}

{
  HostLookup_Reachability::~HostLookup_Reachability((HostLookup_Reachability *)((char *)this - 8));
}

void HostLookup_Reachability::~HostLookup_Reachability(HostLookup_Reachability *this)
{
  *(void *)this = &unk_1ECFA2A10;
  *((void *)this + 1) = &unk_1ECFA2A68;
  uint64_t v2 = (const void *)*((void *)this + 5);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    CFRelease((CFTypeRef)(v3 - 16));
  }

  HostLookup::~HostLookup(this);
}

void sub_18425D25C(_Unwind_Exception *a1)
{
  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

CFErrorRef HostLookup_Reachability::prepareLookup(HostLookup_Reachability *this, Host *a2)
{
  *((void *)this + 4) = a2;
  CFRetain((char *)a2 - 16);
  Reachability = HostLookup_Reachability::CreateReachability(*((const __CFString **)this + 5), v3);
  if (Reachability)
  {
    mach_port_t v5 = Reachability;
    context.version = 0;
    context.info = this;
    memset(&context.retain, 0, 24);
    SCNetworkReachabilitySetCallback(Reachability, (SCNetworkReachabilityCallBack)HostLookup_Reachability::_ReachabilityCallback, &context);
    *((void *)this + 2) = CFRetain(v5);
    CFRelease(v5);
    return 0;
  }
  else
  {
    CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
    return __cfnCreateCFError(v7, @"kCFErrorDomainCFNetwork", 1, v8, v9, v10, v11, v12, 0);
  }
}

SCNetworkReachabilityRef HostLookup_Reachability::CreateReachability(const __CFString *this, const __CFString *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v3 = CFGetAllocator(this);
  CFAllocatorRef v4 = v3;
  CFAllocatorRef allocator = v3;
  uint64_t v10 = 1023;
  if (this)
  {
    mach_port_t v5 = _CFStringGetOrCreateCString(v3, this, v12, &v10, 0x8000100u);
    uint64_t v6 = v10;
  }
  else
  {
    uint64_t v6 = 0;
    v12[0] = 0;
    uint64_t v10 = 0;
    mach_port_t v5 = v12;
  }
  ptr = v5;
  if (v6 == strlen((const char *)v5))
  {
    SCNetworkReachabilityRef v7 = SCNetworkReachabilityCreateWithName(v4, (const char *)v5);
    mach_port_t v5 = (UInt8 *)ptr;
    if (!ptr) {
      return v7;
    }
  }
  else
  {
    SCNetworkReachabilityRef v7 = 0;
    if (!v5) {
      return v7;
    }
  }
  if (v12 != v5) {
    CFAllocatorDeallocate(allocator, v5);
  }
  return v7;
}

void sub_18425D420(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  if (ptr)
  {
    if (v11 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  _Unwind_Resume(exception_object);
}

void HostLookup_Reachability::_ReachabilityCallback(HostLookup_Reachability *this, const __SCNetworkReachability *a2, uint64_t a3, void *a4)
{
  *(_DWORD *)bytes = a2;
  CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)(a3 - 16));
  CFDataRef v6 = CFDataCreate(v5, bytes, 4);
  Host::performCallback(*(Host **)(a3 + 32), (const __CFString *)&unk_1EC0A4990, v6);
  if (v6) {
    CFRelease(v6);
  }
}

void HostLookup_Reachability::HostLookup_Reachability(HostLookup_Reachability *this, const __CFString *a2)
{
  HostLookup::HostLookup(this, &unk_1EC0A4990);
  void *v4 = &unk_1ECFA2A10;
  v4[1] = &unk_1ECFA2A68;
  *((void *)this + 5) = CFRetain(a2);
}

void sub_18425D53C(_Unwind_Exception *a1)
{
  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

SCNetworkReachabilityRef HostLookup_Reachability::CreateReachability(HostLookup_Reachability *this, const __CFData *a2)
{
  CFAllocatorRef v3 = CFGetAllocator(this);
  BytePtr = (const sockaddr *)CFDataGetBytePtr(this);

  return SCNetworkReachabilityCreateWithAddress(v3, BytePtr);
}

void _distpatch_HostLookup_Reachability__ReachabilityCallback(const __SCNetworkReachability *a1, int a2, char *cf)
{
  *(_DWORD *)bytes = a2;
  CFAllocatorRef v5 = CFGetAllocator(cf);
  CFDataRef v6 = CFDataCreate(v5, bytes, 4);
  if (cf)
  {
    if (HostBase::Class(void)::sOnce_HostBase != -1) {
      dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
    }
    SCNetworkReachabilityRef v7 = (DispatchHost *)(cf + 16);
  }
  else
  {
    SCNetworkReachabilityRef v7 = 0;
  }
  DispatchHost::performCallback(v7, (const __CFString *)&unk_1EC0A4990, v6);
  if (v6) {
    CFRelease(v6);
  }
  SCNetworkReachabilitySetCallback(a1, 0, 0);
  SCNetworkReachabilitySetDispatchQueue(a1, 0);
  if (a1) {
    CFRelease(a1);
  }
}

CFErrorRef HostLookup_Reachability::enqueueWithHost(dispatch_queue_t *this, const __CFString *a2, const __CFString *a3)
{
  Reachability = HostLookup_Reachability::CreateReachability(a2, a2);
  if (Reachability)
  {
    CFAllocatorRef v5 = Reachability;
    context.version = 0;
    context.info = this - 2;
    context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
    context.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
    context.copyDescription = (CFStringRef (__cdecl *)(const void *))MEMORY[0x1E4F1C220];
    SCNetworkReachabilitySetCallback(Reachability, (SCNetworkReachabilityCallBack)_distpatch_HostLookup_Reachability__ReachabilityCallback, &context);
    SCNetworkReachabilitySetDispatchQueue(v5, this[18]);
    return 0;
  }
  else
  {
    CFAllocatorRef v7 = CFGetAllocator(this - 2);
    return __cfnCreateCFError(v7, @"kCFErrorDomainCFNetwork", 1, v8, v9, v10, v11, v12, 0);
  }
}

void sub_18425E0EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18425E28C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18425E5C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18425F208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__11303(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__11304(uint64_t a1)
{
}

void sub_18425F4B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HostLookup_ReachabilityFixed::~HostLookup_ReachabilityFixed(HostLookup_ReachabilityFixed *this)
{
}

{
  HostLookup_ReachabilityFixed::~HostLookup_ReachabilityFixed((HostLookup_ReachabilityFixed *)((char *)this - 8));
}

void HostLookup_ReachabilityFixed::~HostLookup_ReachabilityFixed(HostLookup_ReachabilityFixed *this)
{
  *(void *)this = &unk_1ECFA45F0;
  *((void *)this + 1) = &unk_1ECFA4658;
  uint64_t v2 = (const void *)*((void *)this + 7);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 8);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *((void *)this + 6);
  if (v4) {
    CFRelease((CFTypeRef)(v4 - 16));
  }

  HostLookup_RunLoopSource::~HostLookup_RunLoopSource(this);
}

void sub_18425F580(_Unwind_Exception *a1)
{
  HostLookup_RunLoopSource::~HostLookup_RunLoopSource(v1);
  _Unwind_Resume(a1);
}

void HostLookup_ReachabilityFixed::perform(HostLookup_ReachabilityFixed *this)
{
  CFDataRef v2 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)this + 72, 4);
  Host::performCallback(*((Host **)this + 6), (const __CFString *)&unk_1EC0A4990, v2);
  if (v2)
  {
    CFRelease(v2);
  }
}

CFErrorRef HostLookup_ReachabilityFixed::prepareLookup(HostLookup_ReachabilityFixed *this, Host *a2)
{
  *((void *)this + 6) = a2;
  CFRetain((char *)a2 - 16);
  CFStringRef v4 = (const __CFString *)*((void *)this + 7);
  if (v4)
  {
    Reachability = HostLookup_Reachability::CreateReachability(v4, v3);
  }
  else
  {
    CFDataRef v6 = (HostLookup_Reachability *)*((void *)this + 8);
    if (!v6) {
      goto LABEL_7;
    }
    Reachability = HostLookup_Reachability::CreateReachability(v6, (const __CFData *)v3);
  }
  CFAllocatorRef v7 = Reachability;
  if (Reachability)
  {
    SCNetworkReachabilityGetFlags(Reachability, (SCNetworkReachabilityFlags *)this + 18);
    SCNetworkReachabilitySetCallback(v7, 0, 0);
    CFRelease(v7);
    (*(void (**)(HostLookup_ReachabilityFixed *))(*(void *)this + 72))(this);
    return 0;
  }
LABEL_7:
  CFAllocatorRef v9 = CFGetAllocator((char *)this - 16);
  return __cfnCreateCFError(v9, @"kCFErrorDomainCFNetwork", 1, v10, v11, v12, v13, v14, 0);
}

BOOL HostLookup_ReachabilityFixed::isDottedIP(const __CFString *this, const __CFString *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef allocator = CFGetAllocator(this);
  uint64_t v8 = 1023;
  ptr = _CFStringGetOrCreateCString(allocator, this, v10, &v8, 0x600u);
  CFAllocatorRef v5 = 0;
  memset(&v6, 0, sizeof(v6));
  v6.ai_flags = 4;
  BOOL v3 = 0;
  if (!getaddrinfo((const char *)ptr, 0, &v6, &v5) && v5)
  {
    BOOL v3 = v5->ai_addr != 0;
    freeaddrinfo(v5);
  }
  if (ptr && v10 != ptr) {
    CFAllocatorDeallocate(allocator, ptr);
  }
  return v3;
}

void sub_18425F7D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFAllocatorRef allocator, uint64_t a18, void *ptr)
{
}

void HostLookup_ReachabilityFixed::HostLookup_ReachabilityFixed(HostLookup_ReachabilityFixed *this, const __CFString *a2)
{
  HostLookup_RunLoopSource::HostLookup_RunLoopSource(this, (const __CFString *)&unk_1EC0A4990);
  void *v4 = &unk_1ECFA45F0;
  v4[1] = &unk_1ECFA4658;
  *((void *)this + 7) = CFRetain(a2);
}

void sub_18425F87C(_Unwind_Exception *a1)
{
  HostLookup_RunLoopSource::~HostLookup_RunLoopSource(v1);
  _Unwind_Resume(a1);
}

void HostLookup_ReachabilityFixed::HostLookup_ReachabilityFixed(HostLookup_ReachabilityFixed *this, const __CFData *a2)
{
  HostLookup_RunLoopSource::HostLookup_RunLoopSource(this, (const __CFString *)&unk_1EC0A4990);
  void *v4 = &unk_1ECFA45F0;
  v4[1] = &unk_1ECFA4658;
  *((void *)this + 8) = CFRetain(a2);
}

void sub_18425F910(_Unwind_Exception *a1)
{
  HostLookup_RunLoopSource::~HostLookup_RunLoopSource(v1);
  _Unwind_Resume(a1);
}

CFErrorRef enqueueWithHost(DispatchHost *a1, SCNetworkReachabilityRef target)
{
  if (target)
  {
    SCNetworkReachabilityFlags flags = 0;
    SCNetworkReachabilityGetFlags(target, &flags);
    CFAllocatorRef v4 = CFGetAllocator((char *)a1 - 16);
    CFDataRef v5 = CFDataCreate(v4, (const UInt8 *)&flags, 4);
    DispatchHost::performCallback(a1, (const __CFString *)&unk_1EC0A4990, v5);
    if (v5) {
      CFRelease(v5);
    }
    CFRelease(target);
    return 0;
  }
  else
  {
    CFAllocatorRef v7 = CFGetAllocator((char *)a1 - 16);
    return __cfnCreateCFError(v7, @"kCFErrorDomainCFNetwork", 1, v8, v9, v10, v11, v12, 0);
  }
}

void HostLookup_RunLoopSource::signal(CFRunLoopSourceRef *this)
{
  CFRunLoopSourceSignal(this[4]);
  CFDataRef v2 = this[5];
  if (v2)
  {
    CFRunLoopWakeUp(v2);
  }
}

void HostLookup_RunLoopSource::lookupInvalidated(HostLookup_RunLoopSource *this)
{
  CFDataRef v2 = (const void *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    CFRelease(v2);
  }
}

void HostLookup_RunLoopSource::HostLookup_RunLoopSource(HostLookup_RunLoopSource *this, const __CFString *a2)
{
  HostLookup::HostLookup(this, a2);
  *BOOL v3 = &unk_1ECFA2E48;
  v3[1] = &unk_1ECFA2EB0;
  v3 -= 2;
  v6.version = 0;
  v6.info = v3;
  v6.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
  v6.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
  v6.equal = 0;
  v6.hash = 0;
  v6.copyDescription = (CFStringRef (__cdecl *)(const void *))MEMORY[0x1E4F1C220];
  v6.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))_logSchedule;
  v6.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))_logCancel;
  v6.perform = (void (__cdecl *)(void *))HostLookup_RunLoopSource::_Perform;
  *((void *)this + 5) = 0;
  CFAllocatorRef v4 = CFGetAllocator(v3);
  CFDataRef v5 = CFRunLoopSourceCreate(v4, 0, &v6);
  *((void *)this + 4) = v5;
  if (v5) {
    CFDataRef v5 = CFRetain(v5);
  }
  *((void *)this + 2) = v5;
}

void sub_18425FB44(_Unwind_Exception *a1)
{
  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

uint64_t HostLookup_RunLoopSource::_Perform(HostLookup_RunLoopSource *this, void *a2)
{
  if (HostLookup::Class(void)::sOnce_HostLookup != -1) {
    dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_10396);
  }
  BOOL v3 = *(uint64_t (**)(char *))(*((void *)this + 2) + 80);

  return v3((char *)this + 16);
}

CFTypeRef _logSchedule(void *a1, CFTypeRef cf, const __CFString *a3)
{
  CFAllocatorRef v4 = a1;
  if (a1)
  {
    if (HostLookup::Class(void)::sOnce_HostLookup != -1) {
      dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_10396);
    }
    v4 += 2;
  }
  CFTypeRef result = (CFTypeRef)v4[5];
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    void v4[5] = result;
  }
  return result;
}

void HostLookup_RunLoopSource::~HostLookup_RunLoopSource(HostLookup_RunLoopSource *this)
{
  *(void *)this = &unk_1ECFA2E48;
  *((void *)this + 1) = &unk_1ECFA2EB0;
  CFDataRef v2 = (const void *)*((void *)this + 4);
  if (v2) {
    CFRelease(v2);
  }
  BOOL v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }

  HostLookup::~HostLookup(this);
}

void sub_18425FCE0(_Unwind_Exception *a1)
{
  HostLookup::~HostLookup(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'URLConnectionInstanceData::~URLConnectionInstanceData(URLConnectionInstanceData *this)
{
  CFDataRef v2 = (char *)this - 16;
  URLConnectionInstanceData::~URLConnectionInstanceData((URLConnectionInstanceData *)((char *)this - 16));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  URLConnectionInstanceData::~URLConnectionInstanceData((URLConnectionInstanceData *)((char *)this - 16));
}

uint64_t non-virtual thunk to'URLConnectionClient::_loaderClientEvent_captureTransportConnection(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 152))(result, 0);
  }
  return result;
}

void non-virtual thunk to'URLConnectionClient::_loaderClientEvent_capturedSocketStreams(URLConnectionClient *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream) {
    CFReadStreamClose(stream);
  }
  if (a3)
  {
    CFWriteStreamClose(a3);
  }
}

void non-virtual thunk to'URLConnectionClient::_loaderClientEvent_asyncError(CFAllocatorRef *this, const __CFString *a2, CFIndex a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void URLConnectionClient::_loaderClientEvent_asyncError(CFAllocatorRef *this, const __CFString *a2, CFIndex a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFCFStreamError Error = __cfnCreateCFError(this[1], a2, a3, a4, a5, a6, a7, a8, 0);
  (*((void (**)(CFAllocatorRef *, CFErrorRef))*this + 31))(this, CFError);
  if (CFError)
  {
    CFRelease(CFError);
  }
}

uint64_t non-virtual thunk to'URLConnectionClient::_loaderClientEvent_ConditionalRequirementsChanged(uint64_t this)
{
  if ((*(_WORD *)(this + 12) & 8) == 0) {
    return (*(uint64_t (**)(void))(*(void *)(this - 16) + 56))();
  }
  return this;
}

uint64_t non-virtual thunk to'URLConnectionClient::_loaderClientEvent_ConnectionWaiting(uint64_t result)
{
  if ((*(_WORD *)(result + 12) & 8) == 0) {
    return (*(uint64_t (**)(void))(*(void *)(result - 16) + 48))();
  }
  return result;
}

void non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidTimeout(URLConnectionClient *this)
{
}

void URLConnectionClient::_loaderClientEvent_DidTimeout(URLConnectionClient *this)
{
  keys[3] = *(void **)MEMORY[0x1E4F143B8];
  if ((*((_WORD *)this + 38) & 8) == 0)
  {
    CFDataRef v2 = (os_unfair_lock_s *)((char *)this + 208);
    os_unfair_lock_lock((os_unfair_lock_t)this + 52);
    CFAllocatorRef v3 = (const void *)*((void *)this + 25);
    if (v3) {
      CFTypeRef v4 = CFRetain(v3);
    }
    else {
      CFTypeRef v4 = 0;
    }
    os_unfair_lock_unlock(v2);
    int valuePtr = -2102;
    keys[0] = @"_kCFStreamErrorDomainKey";
    keys[1] = @"_kCFStreamErrorCodeKey";
    keys[2] = @"NSErrorPeerAddressKey";
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &kCFStreamErrorDomainHTTP);
    values[1] = CFNumberCreate(v5, kCFNumberIntType, &valuePtr);
    values[2] = (void *)v4;
    if (v4) {
      CFIndex v6 = 3;
    }
    else {
      CFIndex v6 = 2;
    }
    CFDictionaryRef v7 = CFDictionaryCreate(v5, (const void **)keys, (const void **)values, v6, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    unint64_t v8 = 0;
    uint64_t v9 = 8 * v6;
    do
    {
      uint64_t v10 = values[v8 / 8];
      if (v10) {
        CFRelease(v10);
      }
      v8 += 8;
    }
    while (v9 != v8);
    CFErrorRef v11 = CFErrorCreate(*((CFAllocatorRef *)this + 1), @"kCFErrorDomainCFNetwork", -1001, v7);
    if (v7) {
      CFRelease(v7);
    }
    (*(void (**)(URLConnectionClient *, CFErrorRef))(*(void *)this + 248))(this, v11);
    if (v11) {
      CFRelease(v11);
    }
  }
}

void non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidFailWithError(URLConnectionClient *this, __CFError *a2)
{
}

void URLConnectionClient::_loaderClientEvent_DidFailWithError(URLConnectionClient *this, __CFError *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if ((*((_WORD *)this + 38) & 8) == 0)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFTypeRef v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 134217984;
      CFIndex Code = CFErrorGetCode(a2);
      _os_log_error_impl(&dword_184085000, v4, OS_LOG_TYPE_ERROR, "NSURLConnection finished with error - code %ld", buf, 0xCu);
    }
    CFDictionaryRef v5 = CFErrorCopyUserInfo(a2);
    if (v5)
    {
      CFDictionaryRef v6 = v5;
      CFDataRef Value = CFDictionaryGetValue(v5, @"NSErrorPeerAddressKey");
      if (Value)
      {
        CFTypeRef v8 = CFRetain(Value);
        if (v8)
        {
          uint64_t v9 = v8;
          os_unfair_lock_lock((os_unfair_lock_t)this + 52);
          uint64_t v10 = (const void *)*((void *)this + 25);
          if (v10 != v9)
          {
            if (v10) {
              CFRelease(v10);
            }
            *((void *)this + 25) = CFRetain(v9);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)this + 52);
          CFRelease(v9);
        }
      }
      CFRelease(v6);
    }
    if ([*((id *)this + 11) currentRequest]) {
      CFURLRef v11 = (const __CFURL *)objc_msgSend((id)objc_msgSend(*((id *)this + 11), "currentRequest"), "URL");
    }
    else {
      CFURLRef v11 = 0;
    }
    CFIndex v12 = CFErrorGetCode(a2);
    uint64_t v13 = v12;
    if (v11)
    {
      CFStringRef v14 = CFURLCopyHostName(v11);
      CFErrorRef v15 = _CFNetworkErrorCopyLocalizedDescriptionWithHostname(v13, v14);
      if (v14) {
        CFRelease(v14);
      }
    }
    else
    {
      LocalizedString = _CFNetworkErrorGetLocalizedString(v12, 0);
      if (LocalizedString) {
        CFErrorRef v15 = CFRetain(LocalizedString);
      }
      else {
        CFErrorRef v15 = 0;
      }
    }
    uint64_t v17 = (2 * (v11 != 0)) | (v15 != 0);
    uint64_t v18 = _CFNetworkErrorGetLocalizedString(v13, 2);
    if (v18) {
      ++v17;
    }
    int v19 = _CFNetworkErrorGetLocalizedString(v13, 3);
    if (v19) {
      uint64_t v20 = v17 + 1;
    }
    else {
      uint64_t v20 = v17;
    }
    if (v20)
    {
      uint64_t v21 = v19;
      CFDictionaryRef v22 = CFErrorCopyUserInfo(a2);
      CFAllocatorRef v23 = (const __CFAllocator *)*((void *)this + 1);
      CFIndex Count = CFDictionaryGetCount(v22);
      MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(v23, Count + v20, v22);
      CFDataRef v26 = MutableCopy;
      if (v11)
      {
        CFDictionaryAddValue(MutableCopy, @"NSErrorFailingURLKey", v11);
        CFStringRef v27 = CFURLGetString(v11);
        CFDictionaryAddValue(v26, @"NSErrorFailingURLStringKey", v27);
      }
      if (v15) {
        CFDictionaryAddValue(v26, (const void *)*MEMORY[0x1E4F1D170], v15);
      }
      if (v18) {
        CFDictionaryAddValue(v26, (const void *)*MEMORY[0x1E4F1D178], v18);
      }
      if (v21) {
        CFDictionaryAddValue(v26, (const void *)*MEMORY[0x1E4F1D180], v21);
      }
      if (v22) {
        CFRelease(v22);
      }
      CFAllocatorRef v28 = (const __CFAllocator *)*((void *)this + 1);
      CFStringRef Domain = CFErrorGetDomain(a2);
      a2 = CFErrorCreate(v28, Domain, v13, v26);
      if (v26) {
        CFRelease(v26);
      }
    }
    else if (a2)
    {
      a2 = (__CFError *)CFRetain(a2);
    }
    uint64_t v30 = [*((id *)this + 11) currentRequest];
    if (v30 && v11 && !*((void *)this + 14)) {
      *((void *)this + 14) = CFURLResponseCreate(v30, v11, 0, -1, 0, 2);
    }
    if (([*((id *)this + 11) _isAVAssetTask] & 1) == 0) {
      -[__CFN_TaskMetrics completeWithError:]([*((id *)this + 11) _metrics], a2);
    }
    v31[0] = MEMORY[0x1E4F143A8];
    v31[1] = 3221225472;
    void v31[2] = ___ZN19URLConnectionClient35_loaderClientEvent_DidFailWithErrorEP9__CFError_block_invoke;
    v31[3] = &__block_descriptor_48_e14_v16__0___v___8l;
    v31[4] = this;
    v31[5] = a2;
    URLConnectionClient::terminalEvent((uint64_t)this, (uint64_t)v31);
    if (v15) {
      CFRelease(v15);
    }
  }
}

void ___ZN19URLConnectionClient35_loaderClientEvent_DidFailWithErrorEP9__CFError_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 48) + 88))();
  CFDataRef v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t URLConnectionClient::terminalEvent(uint64_t result, uint64_t a2)
{
  __int16 v2 = *(_WORD *)(result + 76);
  if ((v2 & 8) == 0)
  {
    *(_WORD *)(result + 76) = v2 | 8;
    uint64_t v4 = *(void *)(result + 216);
    CFRetain((CFTypeRef)(v4 - 16));
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN19URLConnectionClient13terminalEventEPKcU13block_pointerFvU13block_pointerFvvEE_block_invoke;
    v5[3] = &__block_descriptor_40_e5_v8__0l;
    v5[4] = v4;
    return (*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, v5);
  }
  return result;
}

void ___ZN19URLConnectionClient13terminalEventEPKcU13block_pointerFvU13block_pointerFvvEE_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 32) + 192))(*(void *)(a1 + 32));
  __int16 v2 = (const void *)(*(void *)(a1 + 32) - 16);

  CFRelease(v2);
}

URLConnectionClient *non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidFinishLoading(URLConnectionClient *this)
{
  return URLConnectionClient::_loaderClientEvent_DidFinishLoading((URLConnectionClient *)((char *)this - 64));
}

URLConnectionClient *URLConnectionClient::_loaderClientEvent_DidFinishLoading(URLConnectionClient *this)
{
  __int16 v1 = *((_WORD *)this + 38);
  if ((v1 & 8) != 0) {
    return this;
  }
  uint64_t v2 = (uint64_t)this;
  if ((v1 & 0x80) != 0)
  {
    URLConnectionClient::sniffAndSendDidReceiveResponse(this, 0);
    __int16 v3 = *(_WORD *)(v2 + 76);
    if ((v3 & 0x80) != 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "sniffForContentType should be cleared up by now", buf, 2u);
      if ((*(_WORD *)(v2 + 76) & 4) == 0)
      {
LABEL_6:
        os_unfair_lock_lock((os_unfair_lock_t)(v2 + 72));
        __int16 v4 = *(_WORD *)(v2 + 76);
        if ((v4 & 0x200) != 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "If we needed to sniff, we shouldn't have signaled that we had data", buf, 2u);
          __int16 v4 = *(_WORD *)(v2 + 76);
        }
        *(_WORD *)(v2 + 76) = v4 | 0x200;
        os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 72));
      }
    }
    else if ((v3 & 4) == 0)
    {
      goto LABEL_6;
    }
    uint64_t v5 = *(void *)(v2 + 48);
    if (*(void *)(v2 + 104))
    {
      (*(void (**)(void))(v5 + 128))();
      CFDictionaryRef v6 = *(const void **)(v2 + 104);
      *(void *)(v2 + 104) = 0;
      if (v6) {
        CFRelease(v6);
      }
    }
    else
    {
      (*(void (**)(void))(v5 + 120))();
    }
  }
  __int16 v7 = *(_WORD *)(v2 + 76);
  if ((v7 & 4) == 0 && (v7 & 8) == 0)
  {
    CFTypeRef v8 = *(void **)(v2 + 112);
    if (v8)
    {
      if (*(_DWORD *)([v8 _inner] + 72) != 2)
      {
        uint64_t v9 = *(void *)(objc_msgSend((id)objc_msgSend(*(id *)(v2 + 88), "currentRequest"), "_inner") + 56);
        if (v9)
        {
          uint64_t v10 = (__CFHTTPMessage *)CFRetain((CFTypeRef)(v9 - 16));
          if (v10)
          {
            CFURLRef v11 = v10;
            CFStringRef v12 = CFHTTPMessageCopyRequestMethod(v10);
            if (v12)
            {
              CFStringRef v13 = v12;
              if (!CFEqual(v12, @"POST"))
              {
                char v17 = 0;
                BOOL v16 = 1;
                goto LABEL_71;
              }
              CFURLRef v14 = _CFURLRequestCopyProtocolPropertyForKey((void *)[*(id *)(v2 + 88) currentRequest], @"kCFURLRequestAllowAllPOSTCaching");
              CFURLRef v15 = v14;
              if (!v14 || v14 == (CFURLRef)*MEMORY[0x1E4F1CFC8])
              {
                uint64_t v27 = *(void *)([*(id *)(v2 + 112) _inner] + 88);
                if (v27) {
                  uint64_t v28 = v27 - 16;
                }
                else {
                  uint64_t v28 = 0;
                }
                if (v27)
                {
                  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
                    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
                  }
                  char v29 = (HTTPMessage *)(v28 + 16);
                  CFStringRef v30 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)(v28 + 16), 0x1280F30Au);
                  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
                    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
                  }
                  CFStringRef v31 = HTTPMessage::copyHeaderFieldValue(v29, 0x11A1B2B2u);
                  BOOL v16 = ((unint64_t)v30 | (unint64_t)v31) != 0;
                  if (v30) {
                    CFRelease(v30);
                  }
                  if (v31) {
                    CFRelease(v31);
                  }
                }
                else
                {
                  BOOL v16 = 1;
                }
                if (!v15) {
                  goto LABEL_70;
                }
              }
              else
              {
                BOOL v16 = 1;
              }
              CFRelease(v15);
LABEL_70:
              char v17 = 1;
LABEL_71:
              CFRelease(v13);
              CFRelease(v11);
              if (!v16) {
                goto LABEL_72;
              }
LABEL_29:
              if (*(void *)(v2 + 144))
              {
                uint64_t v18 = *(void *)(v2 + 152);
                if (v18)
                {
                  uint64_t v19 = [*(id *)(v2 + 112) _inner];
                  *(void *)(v19 + 32) = v18;
                  uint64_t v20 = *(void *)(v19 + 88);
                  if (v20)
                  {
                    *(_WORD *)(v20 + 297) |= 0x100u;
                    *(_WORD *)(*(void *)(v19 + 88) + 297) |= 0x2000u;
                  }
                  uint64_t v21 = (__CFCachedURLResponse **)CFCachedURLResponseCreateWithDataArray();
                  CFDictionaryRef v22 = *(const void **)(v2 + 144);
                  *(void *)(v2 + 144) = 0;
                  if (v22) {
                    CFRelease(v22);
                  }
                  if (v21)
                  {
                    if (v21[2])
                    {
                      CFAllocatorRef v23 = (_CFURLRequest *)[*(id *)(v2 + 88) currentRequest];
                      if (v23)
                      {
                        CFDataRef v24 = v23;
                        CFDataRef v25 = *(os_unfair_lock_s **)([(_CFURLRequest *)v23 _inner] + 232);
                        if (v25) {
                          CFDataRef v25 = (os_unfair_lock_s *)CFRetain(v25);
                        }
                        v43[0] = MEMORY[0x1E4F143A8];
                        v43[1] = 3221225472;
                        CFStringRef v44 = ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke;
                        uint64_t v45 = &__block_descriptor_40_e5_v8__0l;
                        CFTypeRef v46 = v25;
                        if (v25) {
                          CFDataRef v26 = _CFURLStorageSessionCopyCache((uint64_t)v25, v25);
                        }
                        else {
                          CFDataRef v26 = (void *)CFURLCacheCopySharedURLCache();
                        }
                        uint64_t v32 = v26;
                        if (__CFURLCacheIsVaryHeaderSupportEnabled(v26)
                          && (uint64_t v33 = *(HTTPMessage **)([*(id *)(v2 + 112) _inner] + 88)) != 0)
                        {
                          uint64_t v34 = (__CFString *)HTTPMessage::copyHeaderFieldValue(v33, (const __CFString *)&unk_1EC0A2B60);
                        }
                        else
                        {
                          uint64_t v34 = 0;
                        }
                        CacheKeyForRequest = _createCacheKeyForRequest(v24, 0, v34);
                        if (CacheKeyForRequest)
                        {
                          __CFCachedURLResponse::SetKey(v21[2], CacheKeyForRequest);
                          CFRelease(CacheKeyForRequest);
                        }
                        v44((uint64_t)v43);
                        if (v34) {
                          CFRelease(v34);
                        }
                        if (v32) {
                          CFRelease(v32);
                        }
                      }
                    }
                    *(void *)long long buf = MEMORY[0x1E4F143A8];
                    uint64_t v38 = 3221225472;
                    CFUUIDRef v39 = ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke_2;
                    CFStringRef v40 = &__block_descriptor_41_e76_v16__0___CFCachedURLResponse____CFRuntimeBase_QAQ_____CFCachedURLResponse__8l;
                    uint64_t v41 = v2;
                    char v42 = v17;
                    (*(void (**)(uint64_t, __CFCachedURLResponse **, uint8_t *))(*(void *)(v2 + 48) + 72))(v2 + 48, v21, buf);
                    CFRelease(v21);
                  }
                }
              }
              goto LABEL_72;
            }
            CFRelease(v11);
          }
        }
        char v17 = 0;
        goto LABEL_29;
      }
    }
  }
LABEL_72:
  if (([*(id *)(v2 + 88) _isAVAssetTask] & 1) == 0) {
    -[__CFN_TaskMetrics completeWithError:]([*(id *)(v2 + 88) _metrics], 0);
  }
  v36[0] = MEMORY[0x1E4F143A8];
  v36[1] = 3221225472;
  v36[2] = ___ZN19URLConnectionClient35_loaderClientEvent_DidFinishLoadingEv_block_invoke;
  v36[3] = &__block_descriptor_40_e14_v16__0___v___8l;
  v36[4] = v2;
  return (URLConnectionClient *)URLConnectionClient::terminalEvent(v2, (uint64_t)v36);
}

void sub_184260DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,void (*a24)(char *))
{
  a24(&a22);
  if (v24) {
    CFRelease(v24);
  }
  _Unwind_Resume(a1);
}

uint64_t URLConnectionClient::sniffAndSendDidReceiveResponse(URLConnectionClient *this, CFArrayRef theArray)
{
  if ((*((_WORD *)this + 38) & 0x80) != 0
    && !*((void *)this + 14)
    && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "sniffForContentTypeWithData(): Already sniffed, or no response to work", buf, 2u);
    if (theArray) {
      goto LABEL_5;
    }
LABEL_22:
    CFDataRef v12 = (const __CFData *)*((void *)this + 21);
    *((void *)this + 21) = 0;
    if (!v12)
    {
LABEL_29:
      URLResponse::guessMIMEType((URLResponse *)[*((id *)this + 14) _inner], v12);
      if (!URLResponse::getMIMEType((URLResponse *)[*((id *)this + 14) _inner])
        && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t v18 = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "sniffForContentTypeWithData(): Could not determine a valid content type!", v18, 2u);
      }
      *((_WORD *)this + 38) &= ~0x80u;
      if (v12) {
        CFRelease(v12);
      }
      return (*(uint64_t (**)(char *, void))(*((void *)this + 6) + 112))((char *)this + 48, *((void *)this + 14));
    }
LABEL_23:
    uint64_t v13 = *(void *)([*((id *)this + 14) _inner] + 88);
    if (v13)
    {
      if (((*(unsigned __int16 *)(v13 + 297) | (*(unsigned __int8 *)(v13 + 299) << 16)) & 0x10000) != 0)
      {
        CFURLRef v14 = CFURLDataDecoderCreateWithResponse(*((const __CFAllocator **)this + 1), *((_CFURLResponse **)this + 14));
        if (v14)
        {
          CFURLRef v15 = v14;
          char v19 = 0;
          uint64_t v16 = CFURLDataDecoderDecodeData((uint64_t)v14, (uint64_t)v12, (uint64_t)&v19);
          if (v16)
          {
            CFDataRef v17 = (const __CFData *)v16;
            CFRelease(v12);
            CFDataRef v12 = v17;
          }
          CFRelease(v15);
        }
      }
    }
    goto LABEL_29;
  }
  if (!theArray) {
    goto LABEL_22;
  }
LABEL_5:
  uint64_t result = CFArrayGetCount(theArray);
  if (result >= 1)
  {
    uint64_t v5 = result;
    CFIndex v6 = 0;
    while (1)
    {
      CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(theArray, v6);
      uint64_t Length = CFDataGetLength(ValueAtIndex);
      uint64_t result = *((void *)this + 21);
      if (!result && Length >= 512) {
        break;
      }
      if (!result)
      {
        uint64_t result = (uint64_t)CFDataCreateMutable(*((CFAllocatorRef *)this + 1), 512);
        *((void *)this + 21) = result;
      }
      CFIndex v9 = CFDataGetLength((CFDataRef)result);
      if (v9 + Length > 512) {
        uint64_t Length = 512 - v9;
      }
      uint64_t v10 = (__CFData *)*((void *)this + 21);
      BytePtr = CFDataGetBytePtr(ValueAtIndex);
      CFDataAppendBytes(v10, BytePtr, Length);
      uint64_t result = CFDataGetLength(*((CFDataRef *)this + 21));
      if (result >= 512)
      {
        CFDataRef v12 = (const __CFData *)*((void *)this + 21);
        *((void *)this + 21) = 0;
        goto LABEL_19;
      }
      if (v5 == ++v6) {
        return result;
      }
    }
    if (!ValueAtIndex) {
      return result;
    }
    uint64_t result = (uint64_t)CFRetain(ValueAtIndex);
    CFDataRef v12 = (const __CFData *)result;
LABEL_19:
    if (v12) {
      goto LABEL_23;
    }
  }
  return result;
}

uint64_t ___ZN19URLConnectionClient35_loaderClientEvent_DidFinishLoadingEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 48) + 80))();
}

void ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke(uint64_t a1)
{
  __int16 v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke_2(uint64_t a1, const _CFCachedURLResponse *a2)
{
  v29[6] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return;
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(a1 + 40)) {
    goto LABEL_11;
  }
  __int16 v4 = (void *)[*(id *)(v3 + 88) currentRequest];
  uint64_t v5 = *(HTTPBodyData ***)([v4 _inner] + 56);
  if (!v5) {
    goto LABEL_11;
  }
  CFDataRef v6 = HTTPMessage::copyBody(v5);
  if (!v6) {
    goto LABEL_11;
  }
  CFDataRef v7 = v6;
  uint64_t v8 = [v4 mutableCopy];
  if (!v8)
  {
    CFRelease(v7);
LABEL_11:
    CFDataRef v17 = (NSURLSessionTask *)*(id *)(v3 + 88);
    goto LABEL_12;
  }
  CFIndex v9 = (void *)v8;
  CFHashCode v10 = CFHash(v7);
  uint64_t v13 = MEMORY[0x1F4188790](v10, v11, v12);
  snprintf(v28, 0x11uLL, "%ld", v13);
  size_t v14 = strlen(v28);
  CFDataRef v15 = CFDataCreate(*(CFAllocatorRef *)(v3 + 8), (const UInt8 *)v28, v14);
  if (v15)
  {
    CFDataRef v16 = v15;
    CFURLRequestSetHTTPRequestBody(v9, (uint64_t)v15);
    CFDataRef v17 = -[NSURLSessionTask initWithOriginalRequest:ident:taskGroup:]([NSURLSessionTask alloc], "initWithOriginalRequest:ident:taskGroup:", v9, 0, objc_msgSend((id)objc_msgSend(*(id *)(v3 + 88), "session"), "defaultTaskGroup"));
    CFRelease(v16);
  }
  else
  {
    CFDataRef v17 = 0;
  }
  CFRelease(v9);
  CFRelease(v7);
  if (!v17) {
    goto LABEL_11;
  }
LABEL_12:
  uint64_t v18 = [(NSURLSessionTask *)v17 currentRequest];
  if (v18
    && (char v19 = v18, (v20 = *(const void **)([(NSURLRequest *)v18 _inner] + 232)) != 0)
    && (CFTypeRef v21 = CFRetain(v20)) != 0)
  {
    CFRelease(v21);
    if (*(unsigned char *)(v3 + 232))
    {
      CFDictionaryRef v22 = *(void **)(v3 + 88);
      v29[0] = MEMORY[0x1E4F143A8];
      v29[1] = 3221225472;
      void v29[2] = ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke_3;
      v29[3] = &unk_1E5255A90;
      v29[4] = v19;
      v29[5] = a2;
      [v22 _withXURLCache:v29];
    }
  }
  else
  {
    uint64_t v23 = CFURLCacheCopySharedURLCache();
    if (v23)
    {
      CFDataRef v24 = (__CFURLCache **)v23;
      CFDataRef v25 = [(NSURLSessionTask *)v17 session];
      CFDataRef v26 = [(NSURLSessionTask *)v17 currentRequest];
      _CFURLCacheAddCachedResponseForRequestWithSession(v24, v25, a2, v26, v27);
      CFRelease(v24);
    }
  }
}

uint64_t ___ZN19URLConnectionClient32_internalEvent_WillCacheResponseEv_block_invoke_3(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 24))(a2, *(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t non-virtual thunk to'URLConnectionClient::_loaderClientEvent_HandleCacheResponseIsValid(URLConnectionClient *this, const _CFCachedURLResponse *a2)
{
  return URLConnectionClient::_loaderClientEvent_HandleCacheResponseIsValid((uint64_t)this - 64, a2);
}

uint64_t URLConnectionClient::_loaderClientEvent_HandleCacheResponseIsValid(uint64_t this, const _CFCachedURLResponse *a2)
{
  if ((*(unsigned char *)(this + 76) & 8) != 0) {
    return this;
  }
  uint64_t v3 = this;
  if ((*(unsigned char *)(this + 76) & 4) == 0
    && *(void *)(this + 112)
    && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "assertion failure", buf, 2u);
  }
  __int16 v4 = (void *)CFCachedURLResponseCopyWrappedResponse(a2);
  uint64_t v5 = v4;
  CFDataRef v6 = *(void **)(v3 + 112);
  if (v6 == v4)
  {

    if (!a2) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  *(void *)(v3 + 112) = v5;
  if (a2) {
LABEL_8:
  }
    CFRetain(a2);
LABEL_9:
  if (([*(id *)(v3 + 88) _isAVAssetTask] & 1) == 0) {
    -[__CFN_TaskMetrics completeWithError:]([*(id *)(v3 + 88) _metrics], 0);
  }
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = ___ZN19URLConnectionClient45_loaderClientEvent_HandleCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke;
  v7[3] = &__block_descriptor_48_e14_v16__0___v___8l;
  v7[4] = v3;
  void v7[5] = a2;
  return URLConnectionClient::terminalEvent(v3, (uint64_t)v7);
}

void ___ZN19URLConnectionClient45_loaderClientEvent_HandleCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 48) + 104))();
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidSendBodyData(uint64_t this, UploadProgressInfo *a2, uint64_t a3)
{
  if ((*(_WORD *)(this + 12) & 8) == 0)
  {
    UploadProgressInfo v3 = *a2;
    return (*(uint64_t (**)(uint64_t, UploadProgressInfo *, uint64_t))(*(void *)(this - 16) + 144))(this - 16, &v3, a3);
  }
  return this;
}

uint64_t URLConnectionClient::_loaderClientEvent_DidSendBodyData(uint64_t this, UploadProgressInfo *a2, uint64_t a3)
{
  if ((*(_WORD *)(this + 76) & 8) == 0)
  {
    UploadProgressInfo v3 = *a2;
    return (*(uint64_t (**)(uint64_t, UploadProgressInfo *, uint64_t))(*(void *)(this + 48) + 144))(this + 48, &v3, a3);
  }
  return this;
}

void non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidReceiveData(uint64_t a1, const __CFArray *a2, uint64_t a3)
{
}

void URLConnectionClient::_loaderClientEvent_DidReceiveData(URLConnectionClient *this, CFArrayRef theArray, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (a3) {
    __assert_rtn("_loaderClientEvent_DidReceiveData", "URLConnectionClient.cpp", 867, "dispatchData == nullptr");
  }
  __int16 v4 = *((_WORD *)this + 38);
  if ((v4 & 8) == 0)
  {
    if ((v4 & 0x80) != 0)
    {
      URLConnectionClient::sniffAndSendDidReceiveResponse(this, theArray);
      __int16 v4 = *((_WORD *)this + 38);
    }
    if ((v4 & 4) == 0)
    {
      uint64_t TotalSizeOfDataArrayData = GetTotalSizeOfDataArrayData(theArray);
      os_unfair_lock_lock((os_unfair_lock_t)this + 18);
      CFDataRef v7 = (__CFArray *)*((void *)this + 22);
      if (v7)
      {
        v24.CFStringRef length = CFArrayGetCount(theArray);
        v24.CFIndex location = 0;
        CFArrayAppendArray(v7, theArray, v24);
        *((void *)this + 23) += TotalSizeOfDataArrayData;
        if (!theArray) {
          goto LABEL_25;
        }
      }
      else
      {
        *((void *)this + 22) = CFArrayCreateMutableCopy(*((CFAllocatorRef *)this + 1), 0, theArray);
        *((void *)this + 23) = TotalSizeOfDataArrayData;
        if (!theArray)
        {
LABEL_25:
          __int16 v18 = *((_WORD *)this + 38);
          if ((v18 & 0x80) != 0
            || (*((_WORD *)this + 38) & 0x200) != 0
            || *((void *)this + 23) < *((void *)this + 15))
          {
            os_unfair_lock_unlock((os_unfair_lock_t)this + 18);
          }
          else
          {
            *((_WORD *)this + 38) = v18 | 0x200;
            os_unfair_lock_unlock((os_unfair_lock_t)this + 18);
            char v19 = *(void (**)(char *))(*((void *)this + 6) + 120);
            v19((char *)this + 48);
          }
          return;
        }
      }
      CFDataRef v15 = (CFTypeRef *)((char *)this + 144);
      size_t v14 = (__CFArray *)*((void *)this + 18);
      if (v14)
      {
        v25.CFStringRef length = CFArrayGetCount(theArray);
        v25.CFIndex location = 0;
        CFArrayAppendArray(v14, theArray, v25);
        uint64_t v16 = *((void *)this + 20);
        uint64_t v17 = *((void *)this + 19) + TotalSizeOfDataArrayData;
        *((void *)this + 19) = v17;
        if (v17 > v16)
        {
          CFRelease(*v15);
          *CFDataRef v15 = 0;
          *((void *)this + 19) = 0;
        }
      }
      goto LABEL_25;
    }
    uint64_t v8 = (__CFArray *)*((void *)this + 13);
    if ((v4 & 0x80) != 0)
    {
      if (v8)
      {
        v13.CFStringRef length = CFArrayGetCount(theArray);
        v13.CFIndex location = 0;
        CFArrayAppendArray(v8, theArray, v13);
      }
      else
      {
        *((void *)this + 13) = CFArrayCreateMutableCopy(*((CFAllocatorRef *)this + 1), 0, theArray);
      }
    }
    else
    {
      if (v8)
      {
        uint64_t v8 = (__CFArray *)GetTotalSizeOfDataArrayData(*((const __CFArray **)this + 13));
        (*(void (**)(char *, void))(*((void *)this + 6) + 128))((char *)this + 48, *((void *)this + 13));
        CFIndex v9 = (const void *)*((void *)this + 13);
        *((void *)this + 13) = 0;
        if (v9) {
          CFRelease(v9);
        }
      }
      (*(void (**)(char *, CFArrayRef))(*((void *)this + 6) + 128))((char *)this + 48, theArray);
      uint64_t v10 = GetTotalSizeOfDataArrayData(theArray);
      uint64_t v11 = *((void *)this + 12);
      if ((v11 & 0x8000000000000000) == 0)
      {
        uint64_t v12 = v11 - ((void)v8 + v10);
        *((void *)this + 12) = v12;
        if (v12 < 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          int v20 = 134217984;
          uint64_t v21 = v12;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "delivered more bytes than we thought we should, %ld", (uint8_t *)&v20, 0xCu);
        }
      }
    }
  }
}

uint64_t GetTotalSizeOfDataArrayData(const __CFArray *a1)
{
  if (!a1) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1) {
    return 0;
  }
  CFIndex v3 = Count;
  CFIndex v4 = 0;
  uint64_t v5 = 0;
  do
  {
    CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(a1, v4);
    v5 += CFDataGetLength(ValueAtIndex);
    ++v4;
  }
  while (v3 != v4);
  return v5;
}

void non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidReceiveResponse(URLConnectionClient *this, _CFURLResponse *a2)
{
}

void URLConnectionClient::_loaderClientEvent_DidReceiveResponse(URLConnectionClient *this, _CFURLResponse *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if ((*((_WORD *)this + 38) & 8) == 0)
  {
    uint64_t v2 = a2;
    CFIndex v4 = *(const void **)([(_CFURLResponse *)a2 _inner] + 80);
    if (v4) {
      CFTypeRef v5 = CFRetain(v4);
    }
    else {
      CFTypeRef v5 = 0;
    }
    os_unfair_lock_lock((os_unfair_lock_t)this + 52);
    CFTypeRef v6 = (CFTypeRef)*((void *)this + 25);
    if (v6 != v5)
    {
      if (v6) {
        CFRelease(v6);
      }
      if (v5) {
        CFTypeRef v7 = CFRetain(v5);
      }
      else {
        CFTypeRef v7 = 0;
      }
      *((void *)this + 25) = v7;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 52);
    if (v5) {
      CFRelease(v5);
    }
    __int16 v8 = *((_WORD *)this + 38);
    if ((v8 & 0x80) != 0)
    {
      if ((v8 & 4) == 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        LOWORD(v15) = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "_loaderClientEvent_DidReceiveResponse while sniffing but not multipart/x-mixed-replace", (uint8_t *)&v15, 2u);
      }
      URLConnectionClient::sniffAndSendDidReceiveResponse(this, 0);
      if (*((void *)this + 13))
      {
        (*(void (**)(char *))(*((void *)this + 6) + 128))((char *)this + 48);
        CFIndex v9 = (const void *)*((void *)this + 13);
        *((void *)this + 13) = 0;
        if (v9) {
          CFRelease(v9);
        }
      }
    }
    uint64_t v10 = (_CFURLResponse *)*((void *)this + 14);
    if (!v10)
    {
      uint64_t v11 = *(void *)([(_CFURLResponse *)v2 _inner] + 88);
      if (v11 && (*(_WORD *)(v11 + 297) & 0x8000) != 0)
      {
        *((_WORD *)this + 38) |= 4u;
        *(_DWORD *)([(_CFURLResponse *)v2 _inner] + 72) = 2;
      }
      uint64_t v10 = (_CFURLResponse *)*((void *)this + 14);
      if (!v10) {
        goto LABEL_27;
      }
    }
    if ((*((_WORD *)this + 38) & 4) != 0)
    {
LABEL_27:
      if (v10 != v2)
      {

        uint64_t v2 = v2;
        *((void *)this + 14) = v2;
      }
      if ((*((_WORD *)this + 38) & 4) != 0)
      {
        uint64_t v12 = *((void *)this + 12);
        if (v12 >= 1 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          int v15 = 134217984;
          uint64_t v16 = v12;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "response when we're still expecting bytes: %ld", (uint8_t *)&v15, 0xCu);
          uint64_t v2 = (_CFURLResponse *)*((void *)this + 14);
        }
        *((void *)this + 12) = CFURLResponseGetExpectedContentLength(v2);
      }
      CFRange v13 = (HTTPSniffing *)[*((id *)this + 11) currentRequest];
      if (HTTPSniffing::checkRequestAndUpdateResponseForSniffingPurposes(v13, *((_CFURLRequest **)this + 14), v14)) {
        *((_WORD *)this + 38) |= 0x80u;
      }
      else {
        (*(void (**)(char *, void))(*((void *)this + 6) + 112))((char *)this + 48, *((void *)this + 14));
      }
    }
  }
}

void non-virtual thunk to'URLConnectionClient::_loaderClientEvent_NeedNewBodyStream(URLConnectionClient *this)
{
}

void URLConnectionClient::_loaderClientEvent_NeedNewBodyStream(URLConnectionClient *this)
{
  if ((*((_WORD *)this + 38) & 8) == 0)
  {
    uint64_t v2 = (char *)this + 48;
    if ((*(unsigned int (**)(char *))(*((void *)this + 6) + 16))((char *)this + 48))
    {
      uint64_t v8 = [*((id *)this + 11) currentRequest];
      v10[0] = MEMORY[0x1E4F143A8];
      v10[1] = 3221225472;
      v10[2] = ___ZN19URLConnectionClient36_loaderClientEvent_NeedNewBodyStreamEv_block_invoke;
      void v10[3] = &__block_descriptor_40_e25_v16__0____CFReadStream__8l;
      v10[4] = this;
      (*(void (**)(char *, uint64_t, void *))(*((void *)this + 6) + 64))(v2, v8, v10);
    }
    else
    {
      CFCFStreamError Error = __cfnCreateCFError(*((CFAllocatorRef *)this + 1), @"kCFErrorDomainCFNetwork", -1021, v3, v4, v5, v6, v7, 0);
      (*(void (**)(URLConnectionClient *, CFErrorRef))(*(void *)this + 248))(this, CFError);
      if (CFError)
      {
        CFRelease(CFError);
      }
    }
  }
}

void ___ZN19URLConnectionClient36_loaderClientEvent_NeedNewBodyStreamEv_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (cf)
  {
    CFRetain(cf);
    uint64_t v4 = *(void *)(v2 + 216);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    void v7[2] = ___ZN19URLConnectionClient36_loaderClientEvent_NeedNewBodyStreamEv_block_invoke_2;
    v7[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
    v7[4] = cf;
    CFRetain((CFTypeRef)(v4 - 16));
    uint64_t v5 = *(void *)(v4 + 32);
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    void v8[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11460;
    v8[3] = &unk_1E5255CA0;
    v8[4] = v7;
    void v8[5] = v4;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11461;
    void v9[3] = &unk_1E5257C58;
    v9[4] = v8;
    void v9[5] = v5;
    URLConnectionInstanceData::withWorkQueueAsync(v5, (uint64_t)v9);
  }
  else
  {
    uint64_t v6 = *(void (**)(void))(**(void **)(v2 + 216) + 192);
    v6();
  }
}

void ___ZN19URLConnectionClient36_loaderClientEvent_NeedNewBodyStreamEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 56))(a2, *(void *)(a1 + 32));
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

void ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11460(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11461(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void non-virtual thunk to'URLConnectionClient::_loaderClientEvent_DidReceiveChallenge(URLConnectionClient *this, _CFURLAuthChallenge *a2)
{
}

void URLConnectionClient::_loaderClientEvent_DidReceiveChallenge(URLConnectionClient *this, _CFURLAuthChallenge *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if ((*((_WORD *)this + 38) & 8) != 0) {
    return;
  }
  if (!a2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    int v15 = 136315138;
    uint64_t v16 = "_loaderClientEvent_DidReceiveChallenge";
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s: no challenge found to send!", (uint8_t *)&v15, 0xCu);
  }
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t v4 = (char *)a2 + 16;
  if (!a2) {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *((void *)v4 + 3);
  if (!v5) {
    goto LABEL_22;
  }
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  if ((*(_DWORD *)(v5 + 72) - 7) < 0xFFFFFFFA) {
    goto LABEL_22;
  }
  __int16 v6 = *((_WORD *)this + 38);
  if ((v6 & 0x10) != 0) {
    goto LABEL_22;
  }
  *((_WORD *)this + 38) = v6 | 0x10;
  CFURLRef v7 = (const __CFURL *)objc_msgSend((id)objc_msgSend(*((id *)this + 11), "currentRequest"), "URL");
  CFStringRef v8 = CFURLCopyUserName(v7);
  CFStringRef v9 = CFURLCopyPassword(v7);
  CFStringRef v11 = v9;
  if (v8 && v9)
  {
    uint64_t v12 = CFURLCredentialCreate(*((void *)this + 1), (uint64_t)v8, (uint64_t)v9, v10, 2);
    (*(void (**)(void, const void *, _CFURLAuthChallenge *))(**((void **)this + 27) + 64))(*((void *)this + 27), v12, a2);
    int v13 = 1;
  }
  else
  {
    int v13 = 0;
    int v14 = 0;
    if (!v9) {
      goto LABEL_19;
    }
  }
  CFRelease(v11);
  int v14 = v13;
LABEL_19:
  if (v8) {
    CFRelease(v8);
  }
  if (!v14) {
LABEL_22:
  }
    (*(void (**)(char *, _CFURLAuthChallenge *))(*((void *)this + 6) + 152))((char *)this + 48, a2);
}

uint64_t non-virtual thunk to'URLConnectionClient::_loaderClientEvent_WillSendRequestForEstablishedConnection(uint64_t a1, const void *a2, uint64_t a3)
{
  return URLConnectionClient::_loaderClientEvent_WillSendRequestForEstablishedConnection(a1 - 64, a2, a3);
}

uint64_t URLConnectionClient::_loaderClientEvent_WillSendRequestForEstablishedConnection(uint64_t a1, const void *a2, uint64_t a3)
{
  if ((*(_WORD *)(a1 + 76) & 8) != 0)
  {
    CFStringRef v8 = *(uint64_t (**)(uint64_t, void))(a3 + 16);
    return v8(a3, 0);
  }
  else if ([*(id *)(a1 + 88) currentRequest])
  {
    uint64_t v6 = [*(id *)(a1 + 88) currentRequest];
    if (a2) {
      CFRetain(a2);
    }
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    v10[2] = ___ZN19URLConnectionClient58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke;
    void v10[3] = &unk_1E5255A40;
    v10[4] = a3;
    void v10[5] = a1;
    void v10[6] = a2;
    return (*(uint64_t (**)(uint64_t, uint64_t, const void *, void *))(*(void *)(a1 + 48) + 40))(a1 + 48, v6, a2, v10);
  }
  else
  {
    (*(void (**)(uint64_t, void))(a3 + 16))(a3, 0);
    CFStringRef v9 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(*(void *)a1 + 104);
    return v9(a1, @"kCFErrorDomainCFNetwork", -1002);
  }
}

void ___ZN19URLConnectionClient58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke(void *a1, CFTypeRef cf)
{
  uint64_t v4 = a1[5];
  if (cf) {
    CFRetain(cf);
  }
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = ___ZN19URLConnectionClient58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke_2;
  v7[3] = &unk_1E5255A18;
  uint64_t v5 = a1[4];
  v7[4] = cf;
  void v7[5] = v5;
  uint64_t v6 = a1[6];
  void v7[6] = v4;
  v7[7] = v6;
  URLConnectionInstanceData::withWorkQueueAsync(v4, (uint64_t)v7);
}

void ___ZN19URLConnectionClient58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke_2(void *a1)
{
  [*(id *)(a1[6] + 88) updateCurrentRequest:a1[4]];
  (*(void (**)(void))(a1[5] + 16))();
  uint64_t v2 = (const void *)a1[4];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[7];
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t non-virtual thunk to'URLConnectionClient::_loaderClientEvent_WillSendRequestForRedirection(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  return URLConnectionClient::_loaderClientEvent_WillSendRequestForRedirection(a1 - 64, a2, a3, a4);
}

uint64_t URLConnectionClient::_loaderClientEvent_WillSendRequestForRedirection(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  if ((*(_WORD *)(a1 + 76) & 8) != 0)
  {
    uint64_t v10 = *(uint64_t (**)(uint64_t, void))(a4 + 16);
    return v10(a4, 0);
  }
  else if (a2)
  {
    if (a3)
    {
      CFStringRef v8 = *(const void **)([a3 _inner] + 80);
      if (v8) {
        CFTypeRef v9 = CFRetain(v8);
      }
      else {
        CFTypeRef v9 = 0;
      }
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 208));
      CFTypeRef v13 = *(CFTypeRef *)(a1 + 200);
      if (v13 != v9)
      {
        if (v13) {
          CFRelease(v13);
        }
        if (v9) {
          CFTypeRef v14 = CFRetain(v9);
        }
        else {
          CFTypeRef v14 = 0;
        }
        *(void *)(a1 + 200) = v14;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 208));
      if (v9) {
        CFRelease(v9);
      }
    }
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = ___ZN19URLConnectionClient48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke;
    void v15[3] = &unk_1E5255A68;
    void v15[4] = a4;
    v15[5] = a1;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, void *))(*(void *)(a1 + 48) + 32))(a1 + 48, a2, a3, v15);
  }
  else
  {
    (*(void (**)(uint64_t, void))(a4 + 16))(a4, 0);
    uint64_t v12 = *(uint64_t (**)(uint64_t, __CFString *, uint64_t))(*(void *)a1 + 104);
    return v12(a1, @"kCFErrorDomainCFNetwork", -1002);
  }
}

void ___ZN19URLConnectionClient48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (cf) {
    CFRetain(cf);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN19URLConnectionClient48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke_2;
  v6[3] = &unk_1E5257DA8;
  uint64_t v5 = *(void *)(a1 + 32);
  _OWORD v6[4] = cf;
  void v6[5] = v5;
  void v6[6] = v4;
  URLConnectionInstanceData::withWorkQueueAsync(v4, (uint64_t)v6);
}

void ___ZN19URLConnectionClient48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke_2(void *a1)
{
  uint64_t v2 = a1[6];
  if (a1[4]) {
    objc_msgSend(*(id *)(v2 + 88), "updateCurrentRequest:");
  }
  uint64_t v3 = (os_unfair_lock_s *)(v2 + 128);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 128));
  int v4 = *(unsigned __int8 *)(v2 + 132);
  os_unfair_lock_unlock(v3);
  if (v4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = a1[4];
  }
  (*(void (**)(void, uint64_t))(a1[5] + 16))(a1[5], v5);
  uint64_t v6 = (const void *)a1[4];
  if (v6)
  {
    CFRelease(v6);
  }
}

uint64_t non-virtual thunk to'URLConnectionClient::_loaderClient_SupportsDispatchData(URLConnectionClient *this)
{
  return 0;
}

uint64_t non-virtual thunk to'URLConnectionClient::_connectionClientInterface_cancelConnection(uint64_t a1, NSObject *a2, uint64_t a3)
{
  return URLConnectionClient::_connectionClientInterface_cancelConnection(a1 - 56, a2, a3);
}

uint64_t URLConnectionClient::_connectionClientInterface_cancelConnection(uint64_t a1, dispatch_object_t object, uint64_t a3)
{
  __int16 v3 = *(_WORD *)(a1 + 76);
  if ((v3 & 0x40) != 0) {
    return 0;
  }
  *(_WORD *)(a1 + 76) = v3 | 0x40;
  dispatch_retain(object);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  void v10[3] = &unk_1E5257DA8;
  void v10[5] = a3;
  void v10[6] = a1;
  v10[4] = object;
  if ((*(unsigned char *)(a1 + 76) & 8) != 0)
  {
    ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke((uint64_t)v10);
  }
  else
  {
    if (([*(id *)(a1 + 88) _isAVAssetTask] & 1) == 0)
    {
      uint64_t v7 = [*(id *)(a1 + 88) _metrics];
      -[__CFN_TaskMetrics completeWithError:](v7, (void *)[MEMORY[0x1E4F290A8] errorWithDomain:*MEMORY[0x1E4F289A0] code:-999 userInfo:0]);
    }
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_5;
    void v9[3] = &unk_1E5255938;
    v9[4] = v10;
    void v9[5] = a1;
    URLConnectionClient::terminalEvent(a1, (uint64_t)v9);
  }
  return 1;
}

void ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  uint64_t v2 = *(void *)(v1 + 216);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_2;
  v4[3] = &unk_1E52558E8;
  uint64_t v6 = v1;
  long long v5 = *(_OWORD *)(a1 + 32);
  CFRetain((CFTypeRef)(v2 - 16));
  uint64_t v3 = *(void *)(v2 + 32);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11460;
  v7[3] = &unk_1E5255CA0;
  v7[4] = v4;
  void v7[5] = v2;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11461;
  v8[3] = &unk_1E5257C58;
  v8[4] = v7;
  void v8[5] = v3;
  URLConnectionInstanceData::withWorkQueueAsync(v3, (uint64_t)v8);
}

uint64_t ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_5(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_6;
  v4[3] = &unk_1E5255910;
  void v4[5] = a2;
  void v4[6] = v2;
  void v4[4] = *(void *)(a1 + 32);
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 48) + 96))(v2 + 48, v4);
}

void ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_6(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_7;
  v2[3] = &unk_1E5255F60;
  long long v3 = *(_OWORD *)(a1 + 32);
  URLConnectionInstanceData::withWorkQueueAsync(v1, (uint64_t)v2);
}

uint64_t ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_7(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v2();
}

void ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  (*(void (**)(void))(**(void **)(v4 + 32) + 64))(*(void *)(v4 + 32));
  if (a2)
  {
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    void v11[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_3;
    void v11[3] = &unk_1E5257C58;
    long long v5 = *(NSObject **)(a1 + 32);
    v11[4] = *(void *)(a1 + 40);
    void v11[5] = v4;
    std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject  {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>(&v12, v5, v11);
    uint64_t v6 = v13;
    CFTypeRef v9 = v12;
    uint64_t v10 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, NSObject ***))(*(void *)a2 + 24))(a2, &v9);
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    }
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }
  else
  {
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    void v8[2] = ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_4;
    v8[3] = &unk_1E5257C58;
    uint64_t v7 = *(NSObject **)(a1 + 32);
    v8[4] = *(void *)(a1 + 40);
    void v8[5] = v4;
    dispatch_async(v7, v8);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void sub_184262D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(v1 + 32) + 72);

  return v2();
}

uint64_t ___ZN19URLConnectionClient43_connectionClientInterface_cancelConnectionEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke_4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(v1 + 32) + 72);

  return v2();
}

_WORD *non-virtual thunk to'URLConnectionClient::_connectionClientInterface_startConnection(URLConnectionClient *this, __CFRunLoop *a2, const __CFString *a3)
{
  return URLConnectionClient::_connectionClientInterface_startConnection((_WORD *)this - 28, a2, a3);
}

_WORD *URLConnectionClient::_connectionClientInterface_startConnection(_WORD *this, __CFRunLoop *a2, const __CFString *a3)
{
  if ((this[38] & 1) == 0)
  {
    long long v3 = this;
    (*(void (**)(_WORD *, __CFRunLoop *, const __CFString *))(*(void *)this + 296))(this, a2, a3);
    v3[38] |= 1u;
    uint64_t v4 = *(uint64_t (**)(_WORD *))(*(void *)v3 + 280);
    return (_WORD *)v4(v3);
  }
  return this;
}

uint64_t non-virtual thunk to'URLConnectionClient::_connectionClientInterface_hasBegunLoading(URLConnectionClient *this)
{
  return *((_WORD *)this + 10) & 1;
}

void non-virtual thunk to'URLConnectionClient::_connectionClientInterface_becomeForDownloadIfSafeToDoSo(uint64_t a1, uint64_t a2)
{
}

void URLConnectionClient::_connectionClientInterface_becomeForDownloadIfSafeToDoSo(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    uint64_t v4 = *(const void **)(a1 + 176);
    *(void *)(a1 + 176) = 0;
    *(void *)(a1 + 184) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 72));
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 288))(a1, a2);
    __int16 v5 = *(_WORD *)(a1 + 76);
    if ((v5 & 0x20) == 0)
    {
      *(_WORD *)(a1 + 76) = v5 | 0x20;
      uint64_t v6 = *(void *)(a1 + 216);
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 3221225472;
      v9[2] = ___ZN19URLConnectionClient31forceProtocolToUseLargeDownloadEh_block_invoke;
      void v9[3] = &__block_descriptor_33_e29_v16__0__LoaderInterface_____8l;
      char v10 = 1;
      CFRetain((CFTypeRef)(v6 - 16));
      uint64_t v7 = *(void *)(v6 + 32);
      v11[0] = MEMORY[0x1E4F143A8];
      v11[1] = 3221225472;
      void v11[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11460;
      void v11[3] = &unk_1E5255CA0;
      v11[4] = v9;
      void v11[5] = v6;
      v12[0] = MEMORY[0x1E4F143A8];
      v12[1] = 3221225472;
      v12[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11461;
      v12[3] = &unk_1E5257C58;
      v12[4] = v11;
      void v12[5] = v7;
      URLConnectionInstanceData::withWorkQueueAsync(v7, (uint64_t)v12);
      __int16 v5 = *(_WORD *)(a1 + 76);
    }
    *(_WORD *)(a1 + 76) = v5 & 0xFFF7;
    if (v4)
    {
      (*(void (**)(uint64_t, const void *, void))(*(void *)a1 + 216))(a1, v4, 0);
      CFRelease(v4);
    }
    if ((v5 & 8) != 0)
    {
      CFStringRef v8 = *(void (**)(uint64_t))(*(void *)a1 + 240);
      v8(a1);
    }
  }
}

uint64_t ___ZN19URLConnectionClient31forceProtocolToUseLargeDownloadEh_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 48))(a2, *(unsigned __int8 *)(result + 32));
  }
  return result;
}

BOOL non-virtual thunk to'URLConnectionClient::_connectionClientInterface_canUpdateForCFURLDownload(URLConnectionClient *this)
{
  return !*((void *)this + 17) && *((void *)this + 21) > 0;
}

BOOL URLConnectionClient::isInvalidatingOrInvalid(URLConnectionClient *this)
{
  return (*((_WORD *)this + 38) & 0x40) != 0
      || (*(unsigned int (**)(URLConnectionClient *))(*(void *)this + 64))(this) != 0;
}

void URLConnectionClient::_internalEvent_WillSendRequest(URLConnectionClient *this)
{
  if ((*((_WORD *)this + 38) & 8) != 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "assertion failure", buf, 2u);
  }
  id v2 = -[__NSURLSessionLocal _createCanonicalRequestForTask:]((id)[*((id *)this + 11) session], *((void **)this + 11));
  if (v2)
  {
    long long v3 = v2;
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    void v6[2] = ___ZN19URLConnectionClient30_internalEvent_WillSendRequestEv_block_invoke;
    v6[3] = &__block_descriptor_40_e22_v16__0__NSURLRequest_8l;
    _OWORD v6[4] = this;
    (*(void (**)(char *, id, void, void *))(*((void *)this + 6) + 24))((char *)this + 48, v2, 0, v6);
    CFRelease(v3);
  }
  else
  {
    if (objc_msgSend((id)objc_msgSend(*((id *)this + 11), "currentRequest"), "URL"))
    {
      uint64_t v4 = this;
      uint64_t v5 = -1002;
    }
    else
    {
      uint64_t v4 = this;
      uint64_t v5 = -1000;
    }
    (*(void (**)(URLConnectionClient *, __CFString *, uint64_t))(*(void *)this + 104))(v4, @"kCFErrorDomainCFNetwork", v5);
  }
}

void ___ZN19URLConnectionClient30_internalEvent_WillSendRequestEv_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (cf) {
    CFRetain(cf);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN19URLConnectionClient30_internalEvent_WillSendRequestEv_block_invoke_2;
  v4[3] = &unk_1E5258250;
  void v4[4] = cf;
  void v4[5] = v3;
  URLConnectionInstanceData::withWorkQueueAsync(v3, (uint64_t)v4);
}

void ___ZN19URLConnectionClient30_internalEvent_WillSendRequestEv_block_invoke_2(uint64_t a1)
{
  uint64_t v3 = *(NSURLRequest **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  if ((*(_WORD *)(v2 + 76) & 0x100) != 0)
  {
    if (v3) {
      CFRetain(*(CFTypeRef *)(a1 + 32));
    }
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN19URLConnectionClient41_internal_WillSendRequestPartOnePointFiveEP12NSURLRequest_block_invoke;
    v5[3] = &unk_1E52559F0;
    v5[4] = v3;
    void v5[5] = v2;
    (*(void (**)(uint64_t, void *))(*(void *)(v2 + 48) + 160))(v2 + 48, v5);
  }
  else
  {
    URLConnectionClient::_internalEvent_WillSendRequestPartTwo(*(id **)(a1 + 40), v3, 0);
  }
  uint64_t v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    CFRelease(v4);
  }
}

void URLConnectionClient::_internalEvent_WillSendRequestPartTwo(id *this, NSURLRequest *a2, char a3)
{
  [this[11] updateCurrentRequest:a2];
  if (a2)
  {
    CFRetain(a2);
    uint64_t v6 = this[27];
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZN19URLConnectionClient37_internalEvent_WillSendRequestPartTwoEP12NSURLRequesth_block_invoke;
    void v9[3] = &unk_1E52559A0;
    char v10 = a3;
    void v9[4] = a2;
    void v9[5] = this;
    CFRetain(v6 - 2);
    uint64_t v7 = v6[4];
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    void v11[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11460;
    void v11[3] = &unk_1E5255CA0;
    v11[4] = v9;
    void v11[5] = v6;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11461;
    v12[3] = &unk_1E5257C58;
    v12[4] = v11;
    void v12[5] = v7;
    URLConnectionInstanceData::withWorkQueueAsync(v7, (uint64_t)v12);
  }
  else
  {
    CFStringRef v8 = *(void (**)(void))(*(void *)this[27] + 192);
    v8();
  }
}

void ___ZN19URLConnectionClient41_internal_WillSendRequestPartOnePointFiveEP12NSURLRequest_block_invoke(uint64_t a1, char a2)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  uint64_t v3[2] = ___ZN19URLConnectionClient41_internal_WillSendRequestPartOnePointFiveEP12NSURLRequest_block_invoke_2;
  v3[3] = &unk_1E52559C8;
  uint64_t v2 = *(void *)(a1 + 40);
  v3[4] = *(void *)(a1 + 32);
  void v3[5] = v2;
  char v4 = a2;
  URLConnectionInstanceData::withWorkQueueAsync(v2, (uint64_t)v3);
}

void ___ZN19URLConnectionClient41_internal_WillSendRequestPartOnePointFiveEP12NSURLRequest_block_invoke_2(uint64_t a1)
{
  URLConnectionClient::_internalEvent_WillSendRequestPartTwo(*(id **)(a1 + 40), *(NSURLRequest **)(a1 + 32), *(unsigned char *)(a1 + 48) == 0);
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
  }
}

void ___ZN19URLConnectionClient37_internalEvent_WillSendRequestPartTwoEP12NSURLRequesth_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if (*(unsigned char *)(a1 + 48)) {
      (*(void (**)(uint64_t))(*(void *)a2 + 64))(a2);
    }
    -[__CFN_TaskMetrics nextTransaction:withNewRequest:]([*(id *)(v4 + 88) _metrics], 0, *(void **)(a1 + 32));
    (*(void (**)(uint64_t, void))(*(void *)a2 + 16))(a2, *(void *)(v4 + 88));
  }
  uint64_t v5 = *(const void **)(a1 + 32);
  if (v5)
  {
    CFRelease(v5);
  }
}

uint64_t URLConnectionClient::_loaderClientEvent_captureTransportConnection(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 152))(result, 0);
  }
  return result;
}

void URLConnectionClient::_loaderClientEvent_capturedSocketStreams(URLConnectionClient *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream) {
    CFReadStreamClose(stream);
  }
  if (a3)
  {
    CFWriteStreamClose(a3);
  }
}

uint64_t URLConnectionClient::_loaderClientEvent_ConditionalRequirementsChanged(uint64_t this)
{
  if ((*(_WORD *)(this + 76) & 8) == 0) {
    return (*(uint64_t (**)(void))(*(void *)(this + 48) + 56))();
  }
  return this;
}

uint64_t URLConnectionClient::_loaderClientEvent_ConnectionWaiting(uint64_t result)
{
  if ((*(_WORD *)(result + 76) & 8) == 0) {
    return (*(uint64_t (**)(void))(*(void *)(result + 48) + 48))();
  }
  return result;
}

uint64_t URLConnectionClient::_connectionClientInterface_hasBegunLoading(URLConnectionClient *this)
{
  return *((_WORD *)this + 38) & 1;
}

BOOL URLConnectionClient::_connectionClientInterface_canUpdateForCFURLDownload(URLConnectionClient *this)
{
  return !*((void *)this + 24) && *((void *)this + 28) > 0;
}

uint64_t URLConnectionClient::cancelRequested(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 32;
  os_unfair_lock_lock(this + 32);
  uint64_t os_unfair_lock_opaque_low = LOBYTE(this[33]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2);
  return os_unfair_lock_opaque_low;
}

CFTypeRef URLConnectionClient::copyDebugSummary(URLConnectionClient *this)
{
  uint64_t v1 = (void *)(*(uint64_t (**)(void))(**((void **)this + 27) + 200))(*((void *)this + 27));
  if (v1)
  {
    uint64_t v2 = v1;
    uint64_t v3 = [v1 _inner];
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);

    return (CFTypeRef)v4;
  }
  else
  {
    return CFRetain(@"no original request");
  }
}

uint64_t URLConnectionClient::_markClientAsCanceledAndAskIfItAlreadyWas(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 32;
  os_unfair_lock_lock(this + 32);
  uint64_t os_unfair_lock_opaque_low = LOBYTE(this[33]._os_unfair_lock_opaque);
  LOBYTE(this[33]._os_unfair_lock_opaque) = 1;
  os_unfair_lock_unlock(v2);
  return os_unfair_lock_opaque_low;
}

CFStringRef URLConnectionClient::copyDebugDesc(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat(this[1], 0, @"<URLConnectionClient@%p>", this);
}

uint64_t URLConnectionClient::_loaderClient_SupportsDispatchData(URLConnectionClient *this)
{
  return 0;
}

void URLConnectionClient::invalidateAsync(uint64_t a1, uint64_t *a2)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3321888768;
  void v4[2] = ___ZN19URLConnectionClient15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke;
  v4[3] = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  uint64_t v3 = *a2;
  uint64_t v2 = (std::__shared_weak_count *)a2[1];
  void v4[4] = a1;
  void v4[5] = v3;
  uint64_t v5 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  URLConnectionInstanceData::withWorkQueueAsync(a1, (uint64_t)v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184263B58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN19URLConnectionClient15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if ((*(_WORD *)(v2 + 76) & 8) == 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "ERROR: end state not delivered for this connection client!", buf, 2u);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 72));
  uint64_t v3 = *(const void **)(v2 + 144);
  *(void *)(v2 + 144) = 0;
  if (v3) {
    CFRelease(v3);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 72));
  uint64_t v4 = a1[5];
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  v6[0] = v4;
  v6[1] = (uint64_t)v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  URLConnectionInstanceData::invalidateAsync(v2, v6);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184263C44(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'URLConnectionClient_Classic::~URLConnectionClient_Classic(URLConnectionClient_Classic *this)
{
  uint64_t v2 = (char *)this - 64;
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 64));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 7);

  CFAllocatorDeallocate(v3, v2);
}

{
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 64));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 56;
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 56));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 6);

  CFAllocatorDeallocate(v3, v2);
}

{
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 56));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 48;
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 48));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 5);

  CFAllocatorDeallocate(v3, v2);
}

{
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 48));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 16;
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 16));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  URLConnectionClient_Classic::~URLConnectionClient_Classic((URLConnectionClient_Classic *)((char *)this - 16));
}

void URLConnectionClient_Classic::~URLConnectionClient_Classic(URLConnectionClient_Classic *this)
{
  *(void *)this = &unk_1ECFA3C90;
  *((void *)this + 2) = &unk_1ECFA3E70;
  *((void *)this + 6) = &unk_1ECFA3E90;
  *((void *)this + 7) = &unk_1ECFA3F48;
  *((void *)this + 8) = &unk_1ECFA3FA0;
  if (*((void *)this + 32) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "should've been invalidated", v2, 2u);
  }
  URLConnectionClient::~URLConnectionClient(this);
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  URLConnectionClient_Classic::~URLConnectionClient_Classic(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void URLConnectionClient::~URLConnectionClient(URLConnectionClient *this)
{
  *(void *)this = &unk_1ECFA0730;
  *((void *)this + 2) = &unk_1ECFA0878;
  *((void *)this + 6) = &unk_1ECFA0898;
  *((void *)this + 7) = &unk_1ECFA0950;
  *((void *)this + 8) = &unk_1ECFA09A8;
  *((void *)this + 11) = 0;
  uint64_t v2 = (void *)*((void *)this + 14);
  *((void *)this + 14) = 0;

  CFAllocatorRef v3 = (const void *)*((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 21);
  *((void *)this + 21) = 0;
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)*((void *)this + 25);
  if (v7) {
    CFRelease(v7);
  }

  URLConnectionInstanceData::~URLConnectionInstanceData(this);
}

void sub_184263EEC(_Unwind_Exception *a1)
{
  URLConnectionInstanceData::~URLConnectionInstanceData(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'URLConnectionClient_Classic::_connectionClientInterface_UpdateScheduling(URLConnectionClient_Classic *this, const CoreSchedulingSet *a2)
{
  return URLConnectionClient_Classic::_connectionClientInterface_UpdateScheduling((URLConnectionClient_Classic *)((char *)this - 56), a2);
}

uint64_t URLConnectionClient_Classic::_connectionClientInterface_UpdateScheduling(URLConnectionClient_Classic *this, const CoreSchedulingSet *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (CoreSchedulingSet *)(*(uint64_t (**)(URLConnectionClient_Classic *))(*(void *)this + 80))(this);
  if (v4)
  {
    uint64_t v4 = (CoreSchedulingSet *)os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT);
    if (v4)
    {
      uint64_t v7 = *((void *)this + 27) - 16;
      CFStringRef v8 = (const __CFString *)(*(uint64_t (**)(void))(**((void **)this + 32) + 16))(*((void *)this + 32));
      CFTypeRef v9 = _cfnAutoreleaseInDebug(v8);
      CFStringRef v10 = (const __CFString *)(*(uint64_t (**)(const CoreSchedulingSet *))(*(void *)a2 + 16))(a2);
      int v11 = 134218498;
      uint64_t v12 = v7;
      __int16 v13 = 2080;
      CFTypeRef v14 = v9;
      __int16 v15 = 2080;
      uint64_t v16 = _cfnAutoreleaseInDebug(v10);
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "(1) Attempt to change scheduling of connection %p after its load has started [was %s, wants %s]!", (uint8_t *)&v11, 0x20u);
    }
  }
  uint64_t Empty = *((void *)this + 32);
  if (!Empty)
  {
    uint64_t Empty = CoreSchedulingSet::createEmpty(v4);
    *((void *)this + 32) = Empty;
  }
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1) {
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const CoreSchedulingSet *, uint64_t))(*(void *)Empty + 72))(Empty, a2, CoreSchedulingSet::getEmptySet(void)::sEmptySet);
  *((void *)this + 32) = result;
  return result;
}

void non-virtual thunk to'URLConnectionClient_Classic::_connectionClientInterface_resumeConnection(os_unfair_lock_s *this)
{
}

void URLConnectionClient_Classic::_connectionClientInterface_resumeConnection(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 34;
  os_unfair_lock_lock(this + 34);
  int os_unfair_lock_opaque_low = LOBYTE(this[35]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2);
  if (!os_unfair_lock_opaque_low)
  {
    uint64_t v4 = *(const void **)&this[62]._os_unfair_lock_opaque;
    if (v4)
    {
      *(void *)&this[62]._os_unfair_lock_opaque = 0;
      CFContainerEnumeratorBase::setup((unint64_t)v7, v4, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
      uint64_t v10 = 0;
      while (1)
      {
        uint64_t v5 = v10;
        if (v10 >= v8) {
          break;
        }
        ++v10;
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_connectionClientInterface_resumeConnection", *(void (***)(void, void, void))(v9 + 8 * v5));
      }
      uint64_t v6 = *(void *)&this[66]._os_unfair_lock_opaque - 1;
      *(void *)&this[66]._os_unfair_lock_opaque = v6;
      if (!v6) {
        (*(void (**)(void))(**(void **)&this[8]._os_unfair_lock_opaque + 72))(*(void *)&this[8]._os_unfair_lock_opaque);
      }
      CFRelease(v4);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v7);
    }
  }
}

void sub_1842641E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void URLConnectionClient_Classic::_withDelegateAsync(uint64_t a1, uint64_t a2, void (**a3)(void, void, void))
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 304))(a1)
    || (uint64_t v7 = *(void *)(a1 + 240)) == 0
    || *(_DWORD *)(v7 + 196))
  {
    uint64_t v6 = (void *)MEMORY[0x18531D6D0]();
    a3[2](a3, 0, 0);
    return;
  }
  uint64_t v8 = *(__CFArray **)(a1 + 248);
  if (v8) {
    goto LABEL_8;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 136));
  int v9 = *(unsigned __int8 *)(a1 + 140);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 136));
  if (v9)
  {
    uint64_t v8 = *(__CFArray **)(a1 + 248);
    if (!v8)
    {
      CFAllocatorRef v10 = *(const __CFAllocator **)(a1 + 8);
      CFArrayCallBacks callBacks = *(CFArrayCallBacks *)byte_1ECFACE30;
      uint64_t v8 = CFArrayCreateMutable(v10, 0, &callBacks);
      *(void *)(a1 + 248) = v8;
      uint64_t v11 = *(void *)(a1 + 264);
      *(void *)(a1 + 264) = v11 + 1;
      if (!v11)
      {
        (*(void (**)(void))(**(void **)(a1 + 32) + 64))(*(void *)(a1 + 32));
        uint64_t v8 = *(__CFArray **)(a1 + 248);
      }
    }
LABEL_8:
    CFArrayAppendValue(v8, a3);
    return;
  }
  uint64_t v12 = *(void *)(a1 + 264);
  *(void *)(a1 + 264) = v12 + 1;
  if (!v12) {
    (*(void (**)(void))(**(void **)(a1 + 32) + 64))(*(void *)(a1 + 32));
  }
  uint64_t v13 = *(void *)(a1 + 256);
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  void v14[2] = ___ZN27URLConnectionClient_Classic18_withDelegateAsyncEPKcU13block_pointerFvP16_CFURLConnectionPK33CFURLConnectionClientCurrent_VMaxE_block_invoke;
  v14[3] = &unk_1E5257CF8;
  v14[4] = a3;
  void v14[5] = a1;
  v14[6] = a2;
  (*(void (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, v14);
}

void ___ZN27URLConnectionClient_Classic18_withDelegateAsyncEPKcU13block_pointerFvP16_CFURLConnectionPK33CFURLConnectionClientCurrent_VMaxE_block_invoke(void *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)a1[5];
  CFAllocatorRef v3 = (void *)MEMORY[0x18531D6D0]();
  uint64_t v4 = URLConnectionClient_Classic::copyDelegate(v2);
  if ((*(unsigned int (**)(os_unfair_lock_s *))(*(void *)&v2->_os_unfair_lock_opaque + 304))(v2)
    || *(_DWORD *)(v4 + 196))
  {
    uint64_t v5 = *(void (**)(void))(a1[4] + 16);
  }
  else
  {
    uint64_t v5 = *(void (**)(void))(a1[4] + 16);
  }
  v5();
  if (atomic_fetch_add((atomic_uint *volatile)(v4 + 192), 0xFFFFFFFF) == 1)
  {
    if (*(void *)(v4 + 8))
    {
      uint64_t v6 = *(void (**)(void))(v4 + 24);
      if (v6) {
        v6();
      }
    }
    MEMORY[0x18531B6D0](v4, 0x10C0C4063EE03C6);
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = ___ZN27URLConnectionClient_Classic18_withDelegateAsyncEPKcU13block_pointerFvP16_CFURLConnectionPK33CFURLConnectionClientCurrent_VMaxE_block_invoke_2;
  v8[3] = &__block_descriptor_48_e5_v8__0l;
  uint64_t v7 = a1[6];
  v8[4] = v2;
  void v8[5] = v7;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)v2, (uint64_t)v8);
}

uint64_t URLConnectionClient_Classic::copyDelegate(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 59;
  os_unfair_lock_lock(this + 59);
  uint64_t v3 = *(void *)&this[60]._os_unfair_lock_opaque;
  if (v3) {
    atomic_fetch_add((atomic_uint *volatile)(v3 + 192), 1u);
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t ___ZN27URLConnectionClient_Classic18_withDelegateAsyncEPKcU13block_pointerFvP16_CFURLConnectionPK33CFURLConnectionClientCurrent_VMaxE_block_invoke_2(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  uint64_t v2 = *(void *)(v1 + 264) - 1;
  *(void *)(v1 + 264) = v2;
  if (!v2) {
    return (*(uint64_t (**)(void))(**(void **)(v1 + 32) + 72))();
  }
  return result;
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_shouldUseCredentialStorage(uint64_t a1, void (*a2)(void, void, void))
{
  v2[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
  v2[1] = (void (*)(void, void, void))3221225472;
  v2[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic36_delegate_shouldUseCredentialStorageEU13block_pointerFvhE_block_invoke;
  v2[3] = (void (*)(void, void, void))&unk_1E5255BD0;
  void v2[4] = a2;
  URLConnectionClient_Classic::_withDelegateAsync(a1 - 48, (uint64_t)"_delegate_shouldUseCredentialStorage", v2);
}

uint64_t ___ZN27URLConnectionClient_Classic36_delegate_shouldUseCredentialStorageEU13block_pointerFvhE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v6 = *(void (**)(uint64_t, void))(a3 + 112);
    if (v6)
    {
      v6(a2, *(void *)(a3 + 8));
    }
    else
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "not properly vetted!", v8, 2u);
      (*(void (**)(uint64_t, void))(a3 + 112))(a2, *(void *)(a3 + 8));
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_willSendRequestForAuthenticationChallenge(URLConnectionClient_Classic *this, _CFURLAuthChallenge *a2)
{
}

void URLConnectionClient_Classic::_delegate_willSendRequestForAuthenticationChallenge(URLConnectionClient_Classic *this, _CFURLAuthChallenge *a2)
{
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(void *)this + 304))(this))
  {
    uint64_t v4 = *((void *)this + 30);
    if (v4)
    {
      if (!*(_DWORD *)(v4 + 196))
      {
        if (a2) {
          CFRetain(a2);
        }
        v5[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
        v5[1] = (void (*)(void, void, void))3221225472;
        v5[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic51_delegate_willSendRequestForAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke;
        v5[3] = (void (*)(void, void, void))&__block_descriptor_48_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
        v5[4] = (void (*)(void, void, void))this;
        void v5[5] = (void (*)(void, void, void))a2;
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_willSendRequestForAuthenticationChallenge", v5);
      }
    }
  }
}

void ___ZN27URLConnectionClient_Classic51_delegate_willSendRequestForAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a2 || !a3) {
    goto LABEL_33;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (void (*)(uint64_t, void, void))a3[17];
  if (v7)
  {
    v7(a2, *(void *)(a1 + 40), a3[1]);
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    void v21[2] = ___ZN27URLConnectionClient_Classic51_delegate_willSendRequestForAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke_2;
    v21[3] = &__block_descriptor_48_e5_v8__0l;
    uint64_t v8 = *(void *)(a1 + 40);
    v21[4] = v6;
    void v21[5] = v8;
    __CFNetworkLogForAuthTimeoutIssueSync((uint64_t)v21);
    goto LABEL_33;
  }
  if (!a3[12] && !a3[16])
  {
LABEL_25:
    (*(void (**)(void, void, void))(**(void **)(v6 + 216) + 64))(*(void *)(v6 + 216), 0, *(void *)(a1 + 40));
    goto LABEL_33;
  }
  while (1)
  {
    uint64_t v9 = *(void *)(a1 + 40);
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
    }
    uint64_t v10 = v9 + 16;
    if (!v9) {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(void *)(v10 + 24);
    uint64_t v12 = (unsigned int (*)(uint64_t, uint64_t, void))a3[16];
    if (!v12) {
      break;
    }
    if (v12(a2, v11, a3[1])) {
      goto LABEL_26;
    }
LABEL_19:
    uint64_t v14 = *(void *)(a1 + 40);
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
    }
    if (v14) {
      __int16 v15 = (URLAuthChallenge *)(v14 + 16);
    }
    else {
      __int16 v15 = 0;
    }
    if (!URLAuthChallenge::tryNextProtectionSpace(v15)) {
      goto LABEL_25;
    }
  }
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  uint64_t v13 = v11 + 16;
  if (!v11) {
    uint64_t v13 = 0;
  }
  if ((*(_DWORD *)(v13 + 56) - 7) < 0xFFFFFFFA) {
    goto LABEL_19;
  }
LABEL_26:
  uint64_t v16 = (void (*)(uint64_t, void, void))a3[12];
  if (v16)
  {
    v16(a2, *(void *)(a1 + 40), a3[1]);
  }
  else
  {
    uint64_t v17 = *(void *)(v6 + 216);
    uint64_t v18 = *(void *)(a1 + 40);
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
    }
    uint64_t v19 = v18 + 16;
    if (!v18) {
      uint64_t v19 = 0;
    }
    (*(void (**)(uint64_t, void, void))(*(void *)v17 + 64))(v17, *(void *)(v19 + 32), *(void *)(a1 + 40));
  }
LABEL_33:
  int v20 = *(const void **)(a1 + 40);
  if (v20) {
    CFRelease(v20);
  }
}

void ___ZN27URLConnectionClient_Classic51_delegate_willSendRequestForAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = (const void *)(*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))(*(void *)(a1 + 32));
  CFLog();
  if (v1)
  {
    CFRelease(v1);
  }
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_didSendBodyData(URLConnectionClient_Classic *this, UploadProgressInfo *a2)
{
}

void URLConnectionClient_Classic::_delegate_didSendBodyData(URLConnectionClient_Classic *this, UploadProgressInfo *a2)
{
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(void *)this + 304))(this))
  {
    uint64_t v4 = *((void *)this + 30);
    if (v4)
    {
      if (!*(_DWORD *)(v4 + 196) && *(void *)(v4 + 104))
      {
        if (*(void *)v4)
        {
          v5[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
          v5[1] = (void (*)(void, void, void))3221225472;
          v5[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic25_delegate_didSendBodyDataE18UploadProgressInfo_block_invoke;
          v5[3] = (void (*)(void, void, void))&__block_descriptor_56_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
          long long v6 = *(_OWORD *)&a2->var0;
          int64_t var2 = a2->var2;
          URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_didSendBodyData", v5);
        }
      }
    }
  }
}

void *___ZN27URLConnectionClient_Classic25_delegate_didSendBodyDataE18UploadProgressInfo_block_invoke(void *result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (a3) {
      return (void *)(*(uint64_t (**)(uint64_t, void, void, void, void))(a3 + 104))(a2, result[4], result[5], result[6], *(void *)(a3 + 8));
    }
  }
  return result;
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_didStopBuffering(URLConnectionClient_Classic *this, const __CFArray *a2)
{
}

void URLConnectionClient_Classic::_delegate_didStopBuffering(URLConnectionClient_Classic *this, const __CFArray *a2)
{
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(void *)this + 304))(this))
  {
    uint64_t v4 = *((void *)this + 30);
    if (v4)
    {
      if (!*(_DWORD *)(v4 + 196) && *(void *)(v4 + 64))
      {
        if (a2) {
          CFRetain(a2);
        }
        v5[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
        v5[1] = (void (*)(void, void, void))3221225472;
        v5[2] = ___ZN27URLConnectionClient_Classic26_delegate_didStopBufferingEPK9__CFArray_block_invoke;
        v5[3] = (void (*)(void, void, void))&__block_descriptor_48_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
        v5[4] = (void (*)(void, void, void))this;
        void v5[5] = (void (*)(void, void, void))a2;
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_didStopBuffering", v5);
      }
    }
  }
}

void ___ZN27URLConnectionClient_Classic26_delegate_didStopBufferingEPK9__CFArray_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && a3)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    CFMutableDictionaryRef Mutable = CopyAllDataFromDataArray(*(const __CFArray **)(a1 + 40));
    if (!Mutable) {
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(v6 + 8), 0);
    }
    uint64_t v8 = *(void (**)(uint64_t, __CFData *, CFIndex, void))(a3 + 64);
    CFIndex Length = CFDataGetLength(Mutable);
    v8(a2, Mutable, Length, *(void *)(a3 + 8));
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  uint64_t v10 = *(const void **)(a1 + 40);
  if (v10)
  {
    CFRelease(v10);
  }
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_didReceiveDataArrayWithDataArray(URLConnectionClient_Classic *this, const __CFArray *a2)
{
}

void URLConnectionClient_Classic::_delegate_didReceiveDataArrayWithDataArray(URLConnectionClient_Classic *this, const __CFArray *a2)
{
  char v4 = *((unsigned char *)this + 80);
  if ((v4 & 1) == 0)
  {
    CFLog();
    char v4 = *((unsigned char *)this + 80);
  }
  *((unsigned char *)this + 80) = v4 | 2;
  uint64_t v5 = *((void *)this + 27);
  uint64_t TotalSizeOfDataArrayData = GetTotalSizeOfDataArrayData(a2);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN20ClassicURLConnection29informProtocolOfBytesConsumedEx_block_invoke;
  void v10[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
  v10[4] = TotalSizeOfDataArrayData;
  CFRetain((CFTypeRef)(v5 - 16));
  uint64_t v7 = *(void *)(v5 + 32);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  void v11[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11460;
  void v11[3] = &unk_1E5255CA0;
  v11[4] = v10;
  void v11[5] = v5;
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  v12[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11461;
  v12[3] = &unk_1E5257C58;
  v12[4] = v11;
  void v12[5] = v7;
  URLConnectionInstanceData::withWorkQueueAsync(v7, (uint64_t)v12);
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(void *)this + 304))(this))
  {
    uint64_t v8 = *((void *)this + 30);
    if (v8)
    {
      if (!*(_DWORD *)(v8 + 196))
      {
        if (a2) {
          CFRetain(a2);
        }
        v9[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
        v9[1] = (void (*)(void, void, void))3221225472;
        v9[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic42_delegate_didReceiveDataArrayWithDataArrayEPK9__CFArray_block_invoke;
        void v9[3] = (void (*)(void, void, void))&__block_descriptor_40_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
        void v9[4] = (void (*)(void, void, void))a2;
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_didReceiveDataArrayWithDataArray", v9);
      }
    }
  }
}

uint64_t ___ZN20ClassicURLConnection29informProtocolOfBytesConsumedEx_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 152))(a2, *(void *)(result + 32));
  }
  return result;
}

void ___ZN27URLConnectionClient_Classic42_delegate_didReceiveDataArrayWithDataArrayEPK9__CFArray_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2 && a3 && *(void *)(a1 + 32))
  {
    uint64_t v6 = (void (*)(uint64_t))a3[18];
    if (v6)
    {
      v6(a2);
    }
    else if (a3[7])
    {
      uint64_t v7 = CopyAllDataFromDataArray(*(const __CFArray **)(a1 + 32));
      uint64_t v8 = (void (*)(uint64_t, __CFData *, CFIndex, void))a3[7];
      CFIndex Length = CFDataGetLength(v7);
      v8(a2, v7, Length, a3[1]);
      if (v7) {
        CFRelease(v7);
      }
    }
    uint64_t v10 = *(const void **)(a1 + 32);
    if (v10)
    {
      CFRelease(v10);
    }
  }
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_didReceiveDataArray(URLConnectionClient_Classic *this)
{
}

void URLConnectionClient_Classic::_delegate_didReceiveDataArray(URLConnectionClient_Classic *this)
{
  char v2 = *((unsigned char *)this + 80);
  if ((v2 & 1) == 0)
  {
    CFLog();
    char v2 = *((unsigned char *)this + 80);
  }
  *((unsigned char *)this + 80) = v2 | 2;
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(void *)this + 304))(this))
  {
    uint64_t v3 = *((void *)this + 30);
    if (v3)
    {
      if (!*(_DWORD *)(v3 + 196))
      {
        v4[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
        v4[1] = (void (*)(void, void, void))3221225472;
        void v4[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic29_delegate_didReceiveDataArrayEv_block_invoke;
        v4[3] = (void (*)(void, void, void))&__block_descriptor_40_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
        void v4[4] = (void (*)(void, void, void))this;
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_didReceiveDataArray", v4);
      }
    }
  }
}

void ___ZN27URLConnectionClient_Classic29_delegate_didReceiveDataArrayEv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2)
  {
    if (a3)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 72));
      CFArrayRef v6 = *(const __CFArray **)(v5 + 176);
      uint64_t v7 = *(void *)(v5 + 184);
      *(void *)(v5 + 176) = 0;
      *(void *)(v5 + 184) = 0;
      *(void *)(v5 + 192) += v7;
      *(_WORD *)(v5 + 76) &= ~0x200u;
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 72));
      uint64_t v8 = *(void *)(v5 + 216);
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      void v14[2] = ___ZN20ClassicURLConnection29informProtocolOfBytesConsumedEx_block_invoke;
      v14[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
      v14[4] = v7;
      CFRetain((CFTypeRef)(v8 - 16));
      uint64_t v9 = *(void *)(v8 + 32);
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 3221225472;
      v15[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11460;
      void v15[3] = &unk_1E5255CA0;
      void v15[4] = v14;
      v15[5] = v8;
      v16[0] = MEMORY[0x1E4F143A8];
      v16[1] = 3221225472;
      void v16[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke_11461;
      v16[3] = &unk_1E5257C58;
      v16[4] = v15;
      void v16[5] = v9;
      URLConnectionInstanceData::withWorkQueueAsync(v9, (uint64_t)v16);
      if (v6)
      {
        uint64_t v10 = (void (*)(uint64_t, const __CFArray *, void))a3[18];
        if (v10)
        {
          v10(a2, v6, a3[1]);
        }
        else if (a3[7])
        {
          uint64_t v11 = CopyAllDataFromDataArray(v6);
          uint64_t v12 = (void (*)(uint64_t, __CFData *, CFIndex, void))a3[7];
          CFIndex Length = CFDataGetLength(v11);
          v12(a2, v11, Length, a3[1]);
          if (v11) {
            CFRelease(v11);
          }
        }
        CFRelease(v6);
      }
    }
  }
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_didReceiveResponse(URLConnectionClient_Classic *this, _CFURLResponse *a2)
{
}

void URLConnectionClient_Classic::_delegate_didReceiveResponse(URLConnectionClient_Classic *this, _CFURLResponse *a2)
{
  char v4 = *((unsigned char *)this + 80);
  if ((v4 & 2) != 0 && (*((_WORD *)this + 38) & 4) == 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "NSURLConnection ordering violation: didReceiveResponse to be scheduled after didReceiveData and not multipart/x-mixed-replace", buf, 2u);
    char v4 = *((unsigned char *)this + 80);
  }
  *((unsigned char *)this + 80) = v4 | 1;
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(void *)this + 304))(this))
  {
    uint64_t v5 = *((void *)this + 30);
    if (v5)
    {
      if (!*(_DWORD *)(v5 + 196))
      {
        if (*(void *)(v5 + 48))
        {
          CFArrayRef v6 = a2;
          v7[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
          v7[1] = (void (*)(void, void, void))3221225472;
          void v7[2] = ___ZN27URLConnectionClient_Classic28_delegate_didReceiveResponseEP14_CFURLResponse_block_invoke;
          v7[3] = (void (*)(void, void, void))&__block_descriptor_48_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
          v7[4] = (void (*)(void, void, void))this;
          void v7[5] = (void (*)(void, void, void))a2;
          URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_didReceiveResponse", v7);
        }
      }
    }
  }
}

void ___ZN27URLConnectionClient_Classic28_delegate_didReceiveResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && a3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    ++*(void *)(v5 + 224);
    (*(void (**)(uint64_t, uint64_t, void))(a3 + 48))(a2, v4, *(void *)(a3 + 8));
    --*(void *)(v5 + 224);
  }
  CFArrayRef v6 = *(void **)(a1 + 40);
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_cacheTrifecta(uint64_t a1, const void *a2, void (*a3)(void, void, void))
{
}

void URLConnectionClient_Classic::_delegate_cacheTrifecta(uint64_t a1, CFTypeRef cf, void (*a3)(void, void, void))
{
  if (cf) {
    CFRetain(cf);
  }
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 304))(a1))
  {
    uint64_t v6 = *(void *)(a1 + 240);
    if (v6)
    {
      if (!*(_DWORD *)(v6 + 196))
      {
        v7[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
        v7[1] = (void (*)(void, void, void))3221225472;
        void v7[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic23_delegate_cacheTrifectaEPK20_CFCachedURLResponseU13block_pointerFvvE_block_invoke;
        v7[3] = (void (*)(void, void, void))&unk_1E5255BA8;
        void v7[5] = (void (*)(void, void, void))a1;
        void v7[6] = (void (*)(void, void, void))cf;
        v7[4] = a3;
        URLConnectionClient_Classic::_withDelegateAsync(a1, (uint64_t)"_delegate_cacheTrifecta", v7);
      }
    }
  }
}

uint64_t ___ZN27URLConnectionClient_Classic23_delegate_cacheTrifectaEPK20_CFCachedURLResponseU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v4 = a3;
    if (a3)
    {
      uint64_t v6 = *(void **)(a1 + 40);
      if (!(*(unsigned int (**)(void *))(*v6 + 304))(v6))
      {
        if (*(void *)(v4 + 48))
        {
          uint64_t v10 = (void *)CFCachedURLResponseCopyWrappedResponse(*(const _CFCachedURLResponse **)(a1 + 48));
          ++v6[28];
          (*(void (**)(uint64_t, void *, void))(v4 + 48))(a2, v10, *(void *)(v4 + 8));
          uint64_t v11 = v6[28] - 1;
          v6[28] = v11;
          if (v11)
          {
          }
          else
          {
            uint64_t v4 = v6[30];

            if (!v4) {
              goto LABEL_4;
            }
          }
        }
        if ((*(void *)(v4 + 56) || *(void *)(v4 + 144))
          && !(*(unsigned int (**)(void *))(*v6 + 304))(v6))
        {
          CFArrayRef v12 = (const __CFArray *)CFCachedURLResponseCopyReceiverDataArray(*(void *)(a1 + 48));
          if (v12)
          {
            CFArrayRef v13 = v12;
            uint64_t v14 = *(void (**)(uint64_t, const __CFArray *, void))(v4 + 144);
            if (v14)
            {
              v14(a2, v12, *(void *)(v4 + 8));
            }
            else
            {
              __int16 v15 = CopyAllDataFromDataArray(v12);
              uint64_t v16 = *(void (**)(uint64_t, __CFData *, CFIndex, void))(v4 + 56);
              CFIndex Length = CFDataGetLength(v15);
              v16(a2, v15, Length, *(void *)(v4 + 8));
              if (v15) {
                CFRelease(v15);
              }
            }
            CFRelease(v13);
          }
        }
        if (*(void *)(v4 + 72) && !(*(unsigned int (**)(void *))(*v6 + 304))(v6)) {
          (*(void (**)(uint64_t, void))(v4 + 72))(a2, *(void *)(v4 + 8));
        }
      }
    }
  }
LABEL_4:
  uint64_t v7 = *(const void **)(a1 + 48);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v8();
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_didCancel(uint64_t a1, void (*a2)(void, void, void))
{
  v2[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
  v2[1] = (void (*)(void, void, void))3221225472;
  v2[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic19_delegate_didCancelEU13block_pointerFvvE_block_invoke;
  v2[3] = (void (*)(void, void, void))&unk_1E5255BD0;
  void v2[4] = a2;
  URLConnectionClient_Classic::_withDelegateAsync(a1 - 48, (uint64_t)"_delegate_didCancel", v2);
}

uint64_t ___ZN27URLConnectionClient_Classic19_delegate_didCancelEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_didFail(uint64_t a1, const void *a2, void (*a3)(void, void, void))
{
}

void URLConnectionClient_Classic::_delegate_didFail(void (*a1)(void, void, void), CFTypeRef cf, void (*a3)(void, void, void))
{
  if (cf) {
    CFRetain(cf);
  }
  v6[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
  v6[1] = (void (*)(void, void, void))3221225472;
  uint64_t v6[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic17_delegate_didFailEP9__CFErrorU13block_pointerFvvE_block_invoke;
  v6[3] = (void (*)(void, void, void))&unk_1E5255BA8;
  void v6[5] = a1;
  void v6[6] = (void (*)(void, void, void))cf;
  _OWORD v6[4] = a3;
  URLConnectionClient_Classic::_withDelegateAsync((uint64_t)a1, (uint64_t)"_delegate_didFail", v6);
}

uint64_t ___ZN27URLConnectionClient_Classic17_delegate_didFailEP9__CFErrorU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (a2)
  {
    if (a3)
    {
      uint64_t v5 = (void (*)(uint64_t, void, uint64_t))a3[10];
      if (v5)
      {
        if (*a3 < 1)
        {
          uint64_t v7 = _CFStreamErrorFromCFError(*(__CFError **)(a1 + 48));
          ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))a3[10])(a2, v7, v8, a3[1]);
        }
        else
        {
          v5(a2, *(void *)(a1 + 48), a3[1]);
        }
      }
    }
  }
  uint64_t v9 = *(const void **)(a1 + 48);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v10();
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_didFinishLoading(uint64_t a1, void (*a2)(void, void, void))
{
}

void URLConnectionClient_Classic::_delegate_didFinishLoading(uint64_t a1, void (*a2)(void, void, void))
{
  char v4 = *(unsigned char *)(a1 + 80);
  if ((v4 & 1) == 0)
  {
    CFLog();
    char v4 = *(unsigned char *)(a1 + 80);
  }
  *(unsigned char *)(a1 + 80) = v4 | 4;
  v5[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
  v5[1] = (void (*)(void, void, void))3221225472;
  v5[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic26_delegate_didFinishLoadingEU13block_pointerFvvE_block_invoke;
  v5[3] = (void (*)(void, void, void))&unk_1E5255BD0;
  v5[4] = a2;
  URLConnectionClient_Classic::_withDelegateAsync(a1, (uint64_t)"_delegate_didFinishLoading", v5);
}

uint64_t ___ZN27URLConnectionClient_Classic26_delegate_didFinishLoadingEU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (a3)
    {
      char v4 = *(void (**)(uint64_t, void))(a3 + 72);
      if (v4) {
        v4(a2, *(void *)(a3 + 8));
      }
    }
  }
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v5();
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_willCacheResponse(uint64_t a1, const void *a2, uint64_t a3)
{
}

void URLConnectionClient_Classic::_delegate_willCacheResponse(uint64_t a1, const void *a2, uint64_t a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 304))(a1)
    || (uint64_t v7 = *(void *)(a1 + 240)) == 0
    || *(_DWORD *)(v7 + 196)
    || !*(void *)(v7 + 88))
  {
    uint64_t v6 = *(void (**)(uint64_t, const void *))(a3 + 16);
    v6(a3, a2);
  }
  else
  {
    if (a2) {
      CFRetain(a2);
    }
    v8[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
    v8[1] = (void (*)(void, void, void))3221225472;
    void v8[2] = ___ZN27URLConnectionClient_Classic27_delegate_willCacheResponseEPK20_CFCachedURLResponseU13block_pointerFvS2_E_block_invoke;
    v8[3] = (void (*)(void, void, void))&unk_1E5255BA8;
    void v8[5] = (void (*)(void, void, void))a1;
    void v8[6] = (void (*)(void, void, void))a2;
    v8[4] = (void (*)(void, void, void))a3;
    URLConnectionClient_Classic::_withDelegateAsync(a1, (uint64_t)"_delegate_willCacheResponse", v8);
  }
}

void ___ZN27URLConnectionClient_Classic27_delegate_willCacheResponseEPK20_CFCachedURLResponseU13block_pointerFvS2_E_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v4 = 0;
  if (a2)
  {
    if (a3)
    {
      uint64_t v6 = (const void *)(*(uint64_t (**)(uint64_t, void, void))(a3 + 88))(a2, *(void *)(a1 + 48), *(void *)(a3 + 8));
      char v4 = v6;
      if (!*(void *)a3 && v6 == *(const void **)(a1 + 48) && v6) {
        CFRetain(v6);
      }
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v7 = *(const void **)(a1 + 48);
  if (v7)
  {
    CFRelease(v7);
  }
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_needNewBodyStream(uint64_t a1, const void *a2, uint64_t a3)
{
}

void URLConnectionClient_Classic::_delegate_needNewBodyStream(void *a1, const void *a2, uint64_t a3)
{
  if ((*(unsigned int (**)(void *))(*a1 + 304))(a1)
    || (uint64_t v7 = a1[30]) == 0
    || *(_DWORD *)(v7 + 196)
    || !*(void *)(v7 + 120))
  {
    uint64_t v6 = *(void (**)(uint64_t, void))(a3 + 16);
    v6(a3, 0);
  }
  else
  {
    if (a2) {
      CFRetain(a2);
    }
    v8[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
    v8[1] = (void (*)(void, void, void))3221225472;
    void v8[2] = ___ZN27URLConnectionClient_Classic27_delegate_needNewBodyStreamEP12NSURLRequestU13block_pointerFvP14__CFReadStreamE_block_invoke;
    v8[3] = (void (*)(void, void, void))&unk_1E5255BF8;
    v8[4] = (void (*)(void, void, void))a2;
    void v8[5] = (void (*)(void, void, void))a3;
    URLConnectionClient_Classic::_withDelegateAsync((uint64_t)a1, (uint64_t)"_delegate_needNewBodyStream", v8);
  }
}

void ___ZN27URLConnectionClient_Classic27_delegate_needNewBodyStreamEP12NSURLRequestU13block_pointerFvP14__CFReadStreamE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v4 = 0;
  if (a2 && a3) {
    char v4 = (const void *)(*(uint64_t (**)(uint64_t, void, void))(a3 + 120))(a2, *(void *)(a1 + 32), *(void *)(a3 + 8));
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 32);
  if (v5)
  {
    CFRelease(v5);
  }
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_conditionalRequirementsChanged(URLConnectionClient_Classic *this, char a2)
{
}

void URLConnectionClient_Classic::_delegate_conditionalRequirementsChanged(URLConnectionClient_Classic *this, char a2)
{
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(void *)this + 304))(this))
  {
    uint64_t v4 = *((void *)this + 30);
    if (v4)
    {
      if (!*(_DWORD *)(v4 + 196) && *(void *)(v4 + 176))
      {
        if (*(void *)v4)
        {
          v5[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
          v5[1] = (void (*)(void, void, void))3221225472;
          v5[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic40_delegate_conditionalRequirementsChangedEh_block_invoke;
          v5[3] = (void (*)(void, void, void))&__block_descriptor_33_e114_v24__0___CFURLConnection__8r__CFURLConnectionClientCurrent_VMax_q_v_____________________________________________16l;
          char v6 = a2;
          URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_conditionalRequirementsChanged", v5);
        }
      }
    }
  }
}

uint64_t ___ZN27URLConnectionClient_Classic40_delegate_conditionalRequirementsChangedEh_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (a3) {
      return (*(uint64_t (**)(uint64_t, void, void))(a3 + 176))(a2, *(unsigned __int8 *)(result + 32), *(void *)(a3 + 8));
    }
  }
  return result;
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_connectionWaiting(URLConnectionClient_Classic *this)
{
}

void URLConnectionClient_Classic::_delegate_connectionWaiting(URLConnectionClient_Classic *this)
{
  if (!(*(unsigned int (**)(URLConnectionClient_Classic *))(*(void *)this + 304))(this))
  {
    uint64_t v2 = *((void *)this + 30);
    if (v2)
    {
      if (!*(_DWORD *)(v2 + 196) && *(void *)(v2 + 184) && *(void *)v2)
      {
        URLConnectionClient_Classic::_withDelegateAsync((uint64_t)this, (uint64_t)"_delegate_connectionWaiting", __block_literal_global_11499);
      }
    }
  }
}

uint64_t ___ZN27URLConnectionClient_Classic27_delegate_connectionWaitingEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (a3) {
      return (*(uint64_t (**)(uint64_t, void))(a3 + 184))(a2, *(void *)(a3 + 8));
    }
  }
  return result;
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_willSendRequestForEstablishedConnection(uint64_t a1, const void *a2, const void *a3, uint64_t a4)
{
}

void URLConnectionClient_Classic::_delegate_willSendRequestForEstablishedConnection(void *a1, const void *a2, const void *a3, uint64_t a4)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 304))(a1)
    && (uint64_t v9 = a1[30]) != 0
    && !*(_DWORD *)(v9 + 196)
    && *(void *)(v9 + 168)
    && *(void *)v9)
  {
    if (a3) {
      CFRetain(a3);
    }
    if (a2) {
      CFRetain(a2);
    }
    v10[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
    v10[1] = (void (*)(void, void, void))3221225472;
    v10[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic49_delegate_willSendRequestForEstablishedConnectionEP12NSURLRequestPK14__CFDictionaryU13block_pointerFvS1_E_block_invoke;
    void v10[3] = (void (*)(void, void, void))&unk_1E5255B60;
    void v10[5] = (void (*)(void, void, void))a4;
    void v10[6] = (void (*)(void, void, void))a3;
    v10[4] = (void (*)(void, void, void))a2;
    URLConnectionClient_Classic::_withDelegateAsync((uint64_t)a1, (uint64_t)"_delegate_willSendRequestForEstablishedConnection", v10);
  }
  else
  {
    uint64_t v8 = *(void (**)(uint64_t, const void *))(a4 + 16);
    v8(a4, a2);
  }
}

void ___ZN27URLConnectionClient_Classic49_delegate_willSendRequestForEstablishedConnectionEP12NSURLRequestPK14__CFDictionaryU13block_pointerFvS1_E_block_invoke(void *a1, uint64_t a2, uint64_t a3)
{
  if (a2 && a3)
  {
    uint64_t v4 = *(void (**)(uint64_t, uint64_t, uint64_t, void *, void))(a3 + 168);
    uint64_t v5 = a1[6];
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZN27URLConnectionClient_Classic49_delegate_willSendRequestForEstablishedConnectionEP12NSURLRequestPK14__CFDictionaryU13block_pointerFvS1_E_block_invoke_2;
    void v9[3] = &unk_1E5255B38;
    uint64_t v6 = a1[4];
    void v9[4] = a1[5];
    v4(a2, v6, v5, v9, *(void *)(a3 + 8));
  }
  else
  {
    (*(void (**)(void))(a1[5] + 16))();
  }
  uint64_t v7 = (const void *)a1[4];
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)a1[6];
  if (v8) {
    CFRelease(v8);
  }
}

void ___ZN27URLConnectionClient_Classic49_delegate_willSendRequestForEstablishedConnectionEP12NSURLRequestPK14__CFDictionaryU13block_pointerFvS1_E_block_invoke_2(uint64_t a1, uint64_t a2)
{
  id v3 = [[NSURLRequest alloc] _initWithCFURLRequest:a2];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v3)
  {
    CFRelease(v3);
  }
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_willSendRequestForRedirection(uint64_t a1, const void *a2, void *a3, uint64_t a4)
{
}

void URLConnectionClient_Classic::_delegate_willSendRequestForRedirection(void *a1, const void *a2, void *a3, uint64_t a4)
{
  if ((*(unsigned int (**)(void *))(*a1 + 304))(a1)
    || (uint64_t v9 = a1[30]) == 0
    || *(_DWORD *)(v9 + 196)
    || !*(void *)(v9 + 40))
  {
    uint64_t v8 = *(void (**)(uint64_t, const void *))(a4 + 16);
    v8(a4, a2);
  }
  else
  {
    if (a2) {
      CFRetain(a2);
    }
    id v10 = a3;
    v11[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
    v11[1] = (void (*)(void, void, void))3221225472;
    void v11[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic39_delegate_willSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke;
    void v11[3] = (void (*)(void, void, void))&unk_1E5255B60;
    v11[4] = (void (*)(void, void, void))a2;
    void v11[5] = (void (*)(void, void, void))a4;
    void v11[6] = (void (*)(void, void, void))a3;
    URLConnectionClient_Classic::_withDelegateAsync((uint64_t)a1, (uint64_t)"_delegate_willSendRequestForRedirection", v11);
  }
}

void ___ZN27URLConnectionClient_Classic39_delegate_willSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a2 || !a3) {
    goto LABEL_13;
  }
  uint64_t v5 = (void (*)(uint64_t, uint64_t, uint64_t, void *, void))a3[20];
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    void v14[2] = ___ZN27URLConnectionClient_Classic39_delegate_willSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke_2;
    v14[3] = &unk_1E5255B38;
    uint64_t v7 = *(void *)(a1 + 32);
    v14[4] = *(void *)(a1 + 40);
    v5(a2, v7, v6, v14, a3[1]);
    goto LABEL_14;
  }
  uint64_t v8 = (uint64_t (*)(uint64_t, void, void, void))a3[5];
  if (v8)
  {
    uint64_t v9 = (const void *)v8(a2, *(void *)(a1 + 32), *(void *)(a1 + 48), a3[1]);
    id v10 = v9;
    uint64_t v11 = *(const void **)(a1 + 32);
    if (!*a3 && v9 && v9 == v11)
    {
      CFRetain(v9);
      uint64_t v11 = *(const void **)(a1 + 32);
    }
    if (v10 == v11)
    {
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    else
    {
      id v12 = [[NSURLRequest alloc] _initWithCFURLRequest:v10];
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      if (v12) {
        CFRelease(v12);
      }
    }
    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
LABEL_13:
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
LABEL_14:

  CFArrayRef v13 = *(const void **)(a1 + 32);
  if (v13) {
    CFRelease(v13);
  }
}

void ___ZN27URLConnectionClient_Classic39_delegate_willSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke_2(uint64_t a1, uint64_t a2)
{
  id v3 = [[NSURLRequest alloc] _initWithCFURLRequest:a2];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v3)
  {
    CFRelease(v3);
  }
}

void non-virtual thunk to'URLConnectionClient_Classic::_delegate_willSendRequest(uint64_t a1, const void *a2, void *a3, uint64_t a4)
{
}

void URLConnectionClient_Classic::_delegate_willSendRequest(void *a1, const void *a2, void *a3, uint64_t a4)
{
  if ((*(unsigned int (**)(void *))(*a1 + 304))(a1)
    || (uint64_t v9 = a1[30]) == 0
    || *(_DWORD *)(v9 + 196)
    || !*(void *)(v9 + 40))
  {
    uint64_t v8 = *(void (**)(uint64_t, const void *))(a4 + 16);
    v8(a4, a2);
  }
  else
  {
    if (a2) {
      CFRetain(a2);
    }
    id v10 = a3;
    v11[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
    v11[1] = (void (*)(void, void, void))3221225472;
    void v11[2] = ___ZN27URLConnectionClient_Classic25_delegate_willSendRequestEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke;
    void v11[3] = (void (*)(void, void, void))&unk_1E5255B60;
    void v11[5] = (void (*)(void, void, void))a4;
    void v11[6] = (void (*)(void, void, void))a3;
    v11[4] = (void (*)(void, void, void))a2;
    URLConnectionClient_Classic::_withDelegateAsync((uint64_t)a1, (uint64_t)"_delegate_willSendRequest", v11);
  }
}

void ___ZN27URLConnectionClient_Classic25_delegate_willSendRequestEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v4 = 0;
  if (a2 && a3)
  {
    id v4 = *(id *)(a1 + 32);
    uint64_t v6 = (*(uint64_t (**)(uint64_t, id, void, void))(a3 + 40))(a2, v4, *(void *)(a1 + 48), *(void *)(a3 + 8));
    uint64_t v7 = (const void *)v6;
    if (*(void *)a3) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = v6 == (void)v4;
    }
    if (v8)
    {
      if (!v4) {
        goto LABEL_12;
      }
      CFRetain(v4);
    }
    else if (!v6)
    {
      id v4 = 0;
      goto LABEL_12;
    }
    id v4 = [[NSURLRequest alloc] _initWithCFURLRequest:v7];
    CFRelease(v7);
  }
LABEL_12:
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  if (v4) {
    CFRelease(v4);
  }

  uint64_t v9 = *(const void **)(a1 + 32);
  if (v9)
  {
    CFRelease(v9);
  }
}

BOOL non-virtual thunk to'URLConnectionClient_Classic::_delegate_implements_needNewBodyStream(os_unfair_lock_s *this)
{
  return URLConnectionClient_Classic::_delegate_implements_needNewBodyStream(this - 12);
}

BOOL URLConnectionClient_Classic::_delegate_implements_needNewBodyStream(os_unfair_lock_s *this)
{
  uint64_t v1 = URLConnectionClient_Classic::copyDelegate(this);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  if (*(_DWORD *)(v1 + 196)) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = *(void *)(v1 + 120) != 0;
  }
  if (atomic_fetch_add((atomic_uint *volatile)(v1 + 192), 0xFFFFFFFF) == 1)
  {
    if (*(void *)(v1 + 8))
    {
      id v4 = *(void (**)(void))(v1 + 24);
      if (v4) {
        v4();
      }
    }
    MEMORY[0x18531B6D0](v2, 0x10C0C4063EE03C6);
  }
  return v3;
}

void URLConnectionClient_Classic::_delegate_didCancel(uint64_t a1, void (*a2)(void, void, void))
{
  v2[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
  v2[1] = (void (*)(void, void, void))3221225472;
  v2[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic19_delegate_didCancelEU13block_pointerFvvE_block_invoke;
  v2[3] = (void (*)(void, void, void))&unk_1E5255BD0;
  void v2[4] = a2;
  URLConnectionClient_Classic::_withDelegateAsync(a1, (uint64_t)"_delegate_didCancel", v2);
}

void URLConnectionClient_Classic::_delegate_shouldUseCredentialStorage(uint64_t a1, void (*a2)(void, void, void))
{
  v2[0] = (void (*)(void, void, void))MEMORY[0x1E4F143A8];
  v2[1] = (void (*)(void, void, void))3221225472;
  v2[2] = (void (*)(void, void, void))___ZN27URLConnectionClient_Classic36_delegate_shouldUseCredentialStorageEU13block_pointerFvhE_block_invoke;
  v2[3] = (void (*)(void, void, void))&unk_1E5255BD0;
  void v2[4] = a2;
  URLConnectionClient_Classic::_withDelegateAsync(a1, (uint64_t)"_delegate_shouldUseCredentialStorage", v2);
}

BOOL URLConnectionClient_Classic::isInvalidatingOrInvalid(URLConnectionClient_Classic *this)
{
  return *((unsigned char *)this + 272)
      || (*((_WORD *)this + 38) & 0x40) != 0
      || (*(unsigned int (**)(URLConnectionClient_Classic *))(*(void *)this + 64))(this) != 0;
}

_OWORD *URLConnectionClient_Classic::scheduleIfNotAlreadyScheduled(_OWORD *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  if (!*((void *)this + 32))
  {
    BOOL v3 = this;
    this = CoreSchedulingSet::create(a2, cf1, cf1);
    *((void *)v3 + 32) = this;
  }
  return this;
}

void URLConnectionClient_Classic::setDelegate(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a1 + 236);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 236));
  uint64_t v5 = *(void *)(a1 + 240);
  *(void *)(a1 + 240) = 0;
  if (a2) {
    operator new();
  }
  os_unfair_lock_unlock(v4);
  if (v5)
  {
    atomic_fetch_add((atomic_uint *volatile)(v5 + 196), 1u);
    if (atomic_fetch_add((atomic_uint *volatile)(v5 + 192), 0xFFFFFFFF) == 1)
    {
      if (*(void *)(v5 + 8))
      {
        uint64_t v6 = *(void (**)(void))(v5 + 24);
        if (v6) {
          v6();
        }
      }
      JUMPOUT(0x18531B6D0);
    }
  }
}

void sub_184266E80(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10C0C4063EE03C6);
  _Unwind_Resume(a1);
}

void URLConnectionClient_Classic::_internalEvent_WillSendRequest(URLConnectionClient_Classic *this)
{
  if (*((unsigned char *)this + 273))
  {
    URLConnectionClient::_internalEvent_WillSendRequestPartTwo((id *)this, *((NSURLRequest **)this + 35), *((unsigned char *)this + 274) != 1);
    *((unsigned char *)this + 273) = 0;
    uint64_t v2 = (const void *)*((void *)this + 35);
    if (v2) {
      CFRelease(v2);
    }
    *((void *)this + 35) = 0;
  }
  else
  {
    URLConnectionClient::_internalEvent_WillSendRequest(this);
  }
}

void URLConnectionClient_Classic::_connectionClientInterface_precanonicalizeForSynchronousStart(URLConnectionClient_Classic *this)
{
  if ([*((id *)this + 11) currentRequest])
  {
    uint64_t v2 = (void *)*((void *)this + 11);
    if (v2)
    {
      BOOL v3 = (uint64_t *)*((void *)this + 30);
      if (*v3 >= 1)
      {
        if (v3[5])
        {
          id v4 = -[__NSURLSessionLocal _createCanonicalRequestForTask:]((id)[v2 session], *((void **)this + 11));
          if (v4)
          {
            uint64_t v5 = v4;
            *(_WORD *)((char *)this + 273) = 257;
            *((void *)this + 35) = 0;
            uint64_t v6 = (const void *)(*(uint64_t (**)(uint64_t, id, void, void))(*((void *)this + 30) + 40))(*((void *)this + 27) - 16, v4, 0, *(void *)(*((void *)this + 30) + 8));
            *((void *)this + 35) = [[NSURLRequest alloc] _initWithCFURLRequest:v6];
            if (v6) {
              CFRelease(v6);
            }
            if ((*((_WORD *)this + 38) & 0x100) != 0) {
              *((unsigned char *)this + 274) = (*(uint64_t (**)(uint64_t, void))(*((void *)this + 30) + 112))(*((void *)this + 27) - 16, *(void *)(*((void *)this + 30) + 8));
            }
            CFRelease(v5);
          }
        }
      }
    }
  }
}

CFStringRef URLConnectionClient_Classic::copyDebugDesc(URLConnectionClient_Classic *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*((void *)this + 1);
  uint64_t v3 = *((void *)this + 30);
  if (v3) {
    uint64_t v3 = *(void *)(v3 + 8);
  }
  return CFStringCreateWithFormat(v2, 0, @"<URLConnectionClient@%p>{ info = %p }", this, v3);
}

void URLConnectionClient_Classic::invalidateAsync(uint64_t a1, uint64_t *a2)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3321888768;
  void v4[2] = ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke;
  v4[3] = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  uint64_t v3 = *a2;
  CFAllocatorRef v2 = (std::__shared_weak_count *)a2[1];
  void v4[4] = a1;
  void v4[5] = v3;
  uint64_t v5 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  URLConnectionInstanceData::withWorkQueueAsync(a1, (uint64_t)v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_1842670FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if (*(unsigned char *)(v2 + 272) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "can't invalidate twice", buf, 2u);
  }
  *(unsigned char *)(v2 + 272) = 1;
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 136));
  *(unsigned char *)(v2 + 140) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 136));
  while (*(void *)(v2 + 248))
    (*(void (**)(uint64_t))(*(void *)v2 + 112))(v2);
  (*(void (**)(void))(**(void **)(v2 + 32) + 64))(*(void *)(v2 + 32));
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3321888768;
  uint64_t v7 = ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_23;
  BOOL v8 = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  uint64_t v4 = a1[5];
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  uint64_t v9 = v2;
  uint64_t v10 = v4;
  uint64_t v11 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(void *)(v2 + 264) && (uint64_t v5 = *(_DWORD **)(v2 + 256)) != 0 && v5[10]) {
    (*(void (**)(_DWORD *, void *))(*(void *)v5 + 96))(v5, v6);
  }
  else {
    v7(v6);
  }
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
}

void sub_1842672CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_23(void *a1)
{
  uint64_t v2 = (void **)a1[4];
  ((void (*)(void **, void))(*v2)[36])(v2, 0);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3321888768;
  v5[2] = ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2;
  v5[3] = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
  uint64_t v4 = a1[5];
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  v5[4] = v2;
  void v5[5] = v4;
  uint64_t v6 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)v2, (uint64_t)v5);
  (*(void (**)(void *))(*v2[4] + 72))(v2[4]);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_1842673E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN27URLConnectionClient_Classic15invalidateAsyncENSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_block_invoke_2(void *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)a1[4];
  if (v2[31] && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "assertion failure", buf, 2u);
  }
  uint64_t v3 = v2[33];
  if (v3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 134218240;
    uint64_t v9 = v3;
    __int16 v10 = 2048;
    uint64_t v11 = v2;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "fSendingCallbacks = %ld, which means we're suspended.  Check out *(URLConnectionClient_Classic*) %p", buf, 0x16u);
  }
  if (v2[30] && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "assertion failure", buf, 2u);
  }
  uint64_t v4 = v2[32];
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
    v2[32] = 0;
  }
  uint64_t v5 = a1[5];
  uint64_t v6 = (std::__shared_weak_count *)a1[6];
  v7[0] = v5;
  v7[1] = (uint64_t)v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  URLConnectionClient::invalidateAsync((uint64_t)v2, v7);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_1842675BC(_Unwind_Exception *exception_object)
{
}

uint64_t ___ZN19URLConnectionClientC2EP20ClassicURLConnectionP16NSURLSessionTaskPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
  *(void *)(v2 + 160) = result;
  if (result >= 1)
  {
    uint64_t result = (uint64_t)CFArrayCreateMutable(*(CFAllocatorRef *)(v2 + 8), 0, MEMORY[0x1E4F1D510]);
    *(void *)(v2 + 144) = result;
    *(void *)(v2 + 152) = 0;
    if (*(uint64_t *)(v2 + 160) >= 1) {
      *(unsigned char *)(v2 + 232) = 1;
    }
  }
  return result;
}

void non-virtual thunk to'URLConnectionLoader::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, void *a2, uint64_t a3)
{
}

void URLConnectionLoader::tcpConnectionForUpgradeHeaderAvailable(void *a1, void *a2, uint64_t a3)
{
  v15[19] = *MEMORY[0x1E4F143B8];
  if (a1[18] && !a1[11])
  {
    uint64_t v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_68_11522, 2);
    if (v7)
    {
      uint64_t v8 = v7;
      if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v7 + 16))(v7, "Received tcp connection for upgrade", 0))
      {
        uint64_t v9 = (const void *)(*(uint64_t (**)(void *))(*a1 + 24))(a1);
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        v15[0] = off_1ECF9A530;
        v15[2] = 0;
        void v15[3] = 0;
        v15[1] = CFStringCreateWithCString(v10, "Loader", 0x8000100u);
        (*(void (**)(uint64_t))(*(void *)v8 + 64))(v8);
        AutoString::~AutoString((AutoString *)v15);
        if (v9) {
          CFRelease(v9);
        }
        (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
      }
    }
    uint64_t v11 = a1[4];
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3321888768;
    v13[2] = ___ZN19URLConnectionLoader38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2;
    v13[3] = &unk_1ECFA8F80;
    uint64_t v12 = (std::__shared_weak_count *)a2[1];
    void v13[5] = *a2;
    uint64_t v14 = v12;
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v13[4] = a3;
    (*(void (**)(uint64_t, void *))(*(void *)v11 + 40))(v11, v13);
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v14);
    }
  }
  else if (*a2)
  {
    uint64_t v5 = *(void (**)(void))(*(void *)*a2 + 152);
    v5();
  }
}

void sub_184267948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void ___ZN19URLConnectionLoader38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2(void *a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (std::__shared_weak_count *)a1[6];
    uint64_t v5 = a1[5];
    uint64_t v6 = v2;
    if (v2) {
      atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *, void))(*(void *)a2 + 168))(a2, &v5, a1[4]);
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }
  else
  {
    uint64_t v3 = *(void (**)(uint64_t))(*(void *)a1[5] + 152);
    uint64_t v4 = a1[5];
    v3(v4);
  }
}

void sub_184267A40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN19URLConnectionLoader38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 914;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void non-virtual thunk to'URLConnectionLoader::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(URLConnectionLoader *this, __CFReadStream *a2, __CFWriteStream *a3)
{
}

void URLConnectionLoader::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(URLConnectionLoader *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (this->var21 && a3 && stream && !this->var12)
  {
    uint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_63_11532, 2);
    if (v6)
    {
      uint64_t v7 = v6;
      if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v6 + 16))(v6, "Received socket streams for upgrade", 0))
      {
        uint64_t v8 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))this->var0 + 3))(this);
        CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v16 = off_1ECF9A530;
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        CFStringRef v17 = CFStringCreateWithCString(v9, "Loader", 0x8000100u);
        (*(void (**)(uint64_t))(*(void *)v7 + 64))(v7);
        AutoString::~AutoString((AutoString *)&v16);
        uint64_t v16 = off_1ECF9A530;
        CFStringRef v10 = CFStringCreateWithCString(v9, "ReadStream", 0x8000100u);
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        CFStringRef v17 = v10;
        CFStringRef v11 = CFCopyDescription(stream);
        (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(void *)v7 + 64))(v7, v17, v11);
        if (v11) {
          CFRelease(v11);
        }
        AutoString::~AutoString((AutoString *)&v16);
        uint64_t v16 = off_1ECF9A530;
        CFStringRef v12 = CFStringCreateWithCString(v9, "WriteStream", 0x8000100u);
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        CFStringRef v17 = v12;
        CFStringRef v13 = CFCopyDescription(a3);
        (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(void *)v7 + 64))(v7, v17, v13);
        if (v13) {
          CFRelease(v13);
        }
        AutoString::~AutoString((AutoString *)&v16);
        if (v8) {
          CFRelease(v8);
        }
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      }
    }
    CFRetain(stream);
    CFRetain(a3);
    id var5 = this->var5;
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = ___ZN19URLConnectionLoader54protocolReceivedSocketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke_2;
    void v15[3] = &__block_descriptor_48_e35_v16__0__LoaderClientInterface_____8l;
    void v15[4] = stream;
    v15[5] = a3;
    (*(void (**)(InterfaceRequiredForLoader *, void *))(*(void *)var5 + 40))(var5, v15);
  }
  else
  {
    if (stream) {
      CFReadStreamClose(stream);
    }
    if (a3)
    {
      CFWriteStreamClose(a3);
    }
  }
}

void sub_184267E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void ___ZN19URLConnectionLoader54protocolReceivedSocketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 160))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    CFReadStreamClose(*(CFReadStreamRef *)(a1 + 32));
    CFWriteStreamClose(*(CFWriteStreamRef *)(a1 + 40));
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t ___ZN19URLConnectionLoader54protocolReceivedSocketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 884;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t non-virtual thunk to'URLConnectionLoader::protocolAlternatePathAvailable(uint64_t a1, int a2)
{
  return URLConnectionLoader::protocolAlternatePathAvailable(a1 - 56, a2);
}

uint64_t URLConnectionLoader::protocolAlternatePathAvailable(uint64_t result, int a2)
{
  if (*(void *)(result + 144) && !*(void *)(result + 88) && (*(unsigned char *)(result + 200) & 0x40) != 0)
  {
    uint64_t v2 = *(void *)(result + 32);
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    uint64_t v3[2] = ___ZN19URLConnectionLoader30protocolAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke;
    v3[3] = &__block_descriptor_36_e35_v16__0__LoaderClientInterface_____8l;
    int v4 = a2;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 40))(v2, v3);
  }
  return result;
}

uint64_t ___ZN19URLConnectionLoader30protocolAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 144))(a2, *(unsigned int *)(result + 32));
  }
  return result;
}

URLConnectionLoader *non-virtual thunk to'URLConnectionLoader::protocolConditionalRequirementsChanged(URLConnectionLoader *this, int a2)
{
  return URLConnectionLoader::protocolConditionalRequirementsChanged((URLConnectionLoader *)((char *)this - 56), a2);
}

URLConnectionLoader *URLConnectionLoader::protocolConditionalRequirementsChanged(URLConnectionLoader *this, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (this->var21)
  {
    uint64_t v2 = this;
    if (!this->var12)
    {
      this = (URLConnectionLoader *)DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_55_11539, 2);
      if (this)
      {
        int v4 = this;
        uint64_t v5 = a2 ? "true" : "false";
        this = (URLConnectionLoader *)(*((uint64_t (**)(URLConnectionLoader *, const char *, void))this->var0
                                       + 2))(this, "Condtional Requirements Changed", 0);
        if (this)
        {
          uint64_t v6 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))v2->var0 + 3))(v2);
          CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          uint64_t v16 = off_1ECF9A530;
          uint64_t v18 = 0;
          uint64_t v19 = 0;
          CFStringRef v17 = CFStringCreateWithCString(v7, "Loader", 0x8000100u);
          (*((void (**)(URLConnectionLoader *))v4->var0 + 8))(v4);
          AutoString::~AutoString((AutoString *)&v16);
          uint64_t v16 = off_1ECF9A530;
          CFStringRef v8 = CFStringCreateWithCString(v7, "satisfied", 0x8000100u);
          uint64_t v18 = 0;
          uint64_t v19 = 0;
          CFStringRef v17 = v8;
          CFStringRef v12 = off_1ECF9A530;
          uint64_t v14 = 0;
          uint64_t v15 = 0;
          CFStringRef v13 = CFStringCreateWithCString(v7, v5, 0x8000100u);
          (*((void (**)(URLConnectionLoader *, CFStringRef, CFStringRef))v4->var0 + 8))(v4, v17, v13);
          AutoString::~AutoString((AutoString *)&v12);
          AutoString::~AutoString((AutoString *)&v16);
          if (v6) {
            CFRelease(v6);
          }
          this = (URLConnectionLoader *)(*((uint64_t (**)(URLConnectionLoader *))v4->var0 + 1))(v4);
        }
      }
      if ((*(unsigned char *)&v2->var28 & 0x20) != 0)
      {
        id var5 = v2->var5;
        v10[0] = MEMORY[0x1E4F143A8];
        v10[1] = 3221225472;
        v10[2] = ___ZN19URLConnectionLoader38protocolConditionalRequirementsChangedEh_block_invoke_2;
        void v10[3] = &__block_descriptor_33_e35_v16__0__LoaderClientInterface_____8l;
        char v11 = a2;
        return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, void *))(*(void *)var5 + 40))(var5, v10);
      }
    }
  }
  return this;
}

void sub_18426837C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

uint64_t ___ZN19URLConnectionLoader38protocolConditionalRequirementsChangedEh_block_invoke_2(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 136))(a2, *(unsigned __int8 *)(result + 32));
  }
  return result;
}

uint64_t ___ZN19URLConnectionLoader38protocolConditionalRequirementsChangedEh_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 838;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void *non-virtual thunk to'URLConnectionLoader::protocolConnectionWaiting(uint64_t a1, uint64_t a2)
{
  return URLConnectionLoader::protocolConnectionWaiting((void *)(a1 - 56), a2);
}

void *URLConnectionLoader::protocolConnectionWaiting(void *result, uint64_t a2)
{
  v9[19] = *MEMORY[0x1E4F143B8];
  if (result[18])
  {
    uint64_t v2 = result;
    if (!result[11])
    {
      uint64_t result = (void *)DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_52_11546, 2);
      if (result)
      {
        int v4 = result;
        uint64_t result = (void *)(*(uint64_t (**)(void *, const char *, void))(*result + 16))(result, "Connection Waiting", 0);
        if (result)
        {
          uint64_t v5 = (const void *)(*(uint64_t (**)(void *))(*v2 + 24))(v2);
          CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          v9[0] = off_1ECF9A530;
          v9[2] = 0;
          void v9[3] = 0;
          v9[1] = CFStringCreateWithCString(v6, "Loader", 0x8000100u);
          (*(void (**)(void *))(*v4 + 64))(v4);
          AutoString::~AutoString((AutoString *)v9);
          if (v5) {
            CFRelease(v5);
          }
          uint64_t result = (void *)(*(uint64_t (**)(void *))(*v4 + 8))(v4);
        }
      }
      if ((v2[25] & 0x10) != 0)
      {
        uint64_t v7 = v2[4];
        v8[0] = MEMORY[0x1E4F143A8];
        v8[1] = 3221225472;
        void v8[2] = ___ZN19URLConnectionLoader25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke_2;
        v8[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
        v8[4] = a2;
        return (void *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 40))(v7, v8);
      }
    }
  }
  return result;
}

void sub_184268668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN19URLConnectionLoader25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke_2(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 128))(a2, *(void *)(result + 32));
  }
  return result;
}

uint64_t ___ZN19URLConnectionLoader25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 813;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void non-virtual thunk to'URLConnectionLoader::protocolConnectionEstablished(URLConnectionLoader *this, const __CFDictionary *a2)
{
}

void RedirectionRecorder::playbackMessages(CFArrayRef *a1, uint64_t a2, NSObject *a3)
{
  CFArrayRef v4 = a1[5];
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      for (CFIndex i = 0; i != v8; ++i)
      {
        CFDataRef ValueAtIndex = (void (**)(const void *, void))CFArrayGetValueAtIndex(a1[5], i);
        char v11 = ValueAtIndex;
        if (a3)
        {
          (*((void (**)(CFArrayRef *))*a1 + 5))(a1);
          (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 3221225472;
          block[2] = ___ZN19RedirectionRecorder16playbackMessagesEP17URLProtocolClientPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
          CFHostClientContext block[3] = &unk_1E5257CF8;
          block[4] = v11;
          void block[5] = a1;
          void block[6] = a2;
          dispatch_async(a3, block);
        }
        else
        {
          ValueAtIndex[2](ValueAtIndex, 0);
        }
      }
    }
  }
}

uint64_t ___ZN19RedirectionRecorder16playbackMessagesEP17URLProtocolClientPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  (*(void (**)(void))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48));
  uint64_t v3 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 48);

  return v3(v2);
}

uint64_t ___ZN19URLConnectionLoader15touchConnectionEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1894;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN19URLConnectionLoader29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 768;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

URLConnectionLoader *non-virtual thunk to'URLConnectionLoader::protocolNeedNewBodyStreamFromOffset(URLConnectionLoader *this, uint64_t a2)
{
  return URLConnectionLoader::protocolNeedNewBodyStreamFromOffset((URLConnectionLoader *)((char *)this - 56), a2);
}

URLConnectionLoader *URLConnectionLoader::protocolNeedNewBodyStreamFromOffset(URLConnectionLoader *this, uint64_t a2)
{
  if (this->var21)
  {
    var12 = this->var12;
    if (var12)
    {
      uint64_t v3 = *(uint64_t (**)(RedirectionRecorder *))(*(void *)var12 + 160);
      CFArrayRef v4 = this->var12;
      return (URLConnectionLoader *)v3(v4);
    }
    else if (!this->var23)
    {
      id var5 = this->var5;
      v6[0] = MEMORY[0x1E4F143A8];
      v6[1] = 3221225472;
      void v6[2] = ___ZN19URLConnectionLoader35protocolNeedNewBodyStreamFromOffsetEx_block_invoke;
      v6[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
      _OWORD v6[4] = a2;
      return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, void *))(*(void *)var5 + 40))(var5, v6);
    }
  }
  return this;
}

uint64_t ___ZN19URLConnectionLoader35protocolNeedNewBodyStreamFromOffsetEx_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 56))(a2, *(void *)(result + 32));
  }
  return result;
}

URLConnectionLoader *non-virtual thunk to'URLConnectionLoader::protocolNeedNewBodyStream(URLConnectionLoader *this)
{
  return URLConnectionLoader::protocolNeedNewBodyStream((URLConnectionLoader *)((char *)this - 56));
}

URLConnectionLoader *URLConnectionLoader::protocolNeedNewBodyStream(URLConnectionLoader *this)
{
  if (this->var21)
  {
    var12 = this->var12;
    if (var12)
    {
      return (URLConnectionLoader *)(*(uint64_t (**)(RedirectionRecorder *))(*(void *)var12 + 152))(this->var12);
    }
    else if (!this->var23)
    {
      return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, void *))(*(void *)this->var5 + 40))(this->var5, &__block_literal_global_96);
    }
  }
  return this;
}

uint64_t ___ZN19URLConnectionLoader25protocolNeedNewBodyStreamEv_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
  }
  return result;
}

URLConnectionLoader *non-virtual thunk to'URLConnectionLoader::protocolDidReceiveAuthenticationChallenge(URLConnectionLoader *this, _CFURLAuthChallenge *a2)
{
  return URLConnectionLoader::protocolDidReceiveAuthenticationChallenge((URLConnectionLoader *)((char *)this - 56), a2);
}

void ___ZN19URLConnectionLoader41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = (const void *)(*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
  CFLog();
  if (v1)
  {
    CFRelease(v1);
  }
}

uint64_t ___ZN19URLConnectionLoader41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 537;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

URLConnectionLoader *non-virtual thunk to'URLConnectionLoader::protocolDidFail(URLConnectionLoader *this, __CFError *a2)
{
  return URLConnectionLoader::protocolDidFail((URLConnectionLoader *)((char *)this - 56), a2);
}

uint64_t URLConnectionLoader::logTimings(URLConnectionLoader *this, DiagnosticLogging *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFAbsoluteTimeGetCurrent();
  if (this->var26 == 0.0)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v10 = off_1ECF9A530;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    CFStringRef v11 = CFStringCreateWithCString(v4, "init to origin load", 0x8000100u);
    CFAllocatorRef v6 = off_1ECF9A530;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    CFStringRef v7 = CFStringCreateWithCString(v4, "not done", 0x8000100u);
    (*(void (**)(DiagnosticLogging *, CFStringRef, CFStringRef))(*(void *)a2 + 64))(a2, v11, v7);
    AutoString::~AutoString((AutoString *)&v6);
    AutoString::~AutoString((AutoString *)&v10);
  }
  else
  {
    (*(void (**)(DiagnosticLogging *, const char *, __CFString *))(*(void *)a2 + 72))(a2, "init to origin load", @"%gs");
  }
  (*(void (**)(DiagnosticLogging *, const char *, __CFString *))(*(void *)a2 + 72))(a2, "total time", @"%gs");
  return (*(uint64_t (**)(DiagnosticLogging *, const char *, __CFString *))(*(void *)a2 + 72))(a2, "total bytes", @"%llu");
}

void sub_184268EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t ___ZN19URLConnectionLoader15protocolDidFailEP9__CFError_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1118;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

RedirectionRecorder *non-virtual thunk to'URLConnectionLoader::protocolDidFinishLoading(URLConnectionLoader *this)
{
  return URLConnectionLoader::protocolDidFinishLoading((URLConnectionLoader *)((char *)this - 56));
}

uint64_t ___ZN19URLConnectionLoader24protocolDidFinishLoadingEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1070;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void non-virtual thunk to'URLConnectionLoader::protocolDidSendBodyData(URLConnectionLoader *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

uint64_t ___ZN19URLConnectionLoader23protocolDidSendBodyDataExxx_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 729;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void non-virtual thunk to'URLConnectionLoader::protocolDidLoadData(URLConnectionLoader *this, const __CFData *a2)
{
}

uint64_t ___ZN19URLConnectionLoader19protocolDidLoadDataEPK8__CFDatax_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 633;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t non-virtual thunk to'URLConnectionLoader::protocolDidReceiveResponse(URLConnectionLoader *this, _CFURLResponse *a2)
{
  return URLConnectionLoader::protocolDidReceiveResponse((URLConnectionLoader *)((char *)this - 56), a2);
}

URLConnectionLoader *non-virtual thunk to'URLConnectionLoader::protocolDidReceiveInformationalResponse(URLConnectionLoader *this, _CFURLResponse *a2)
{
  return URLConnectionLoader::protocolDidReceiveInformationalResponse((URLConnectionLoader *)((char *)this - 56), a2);
}

URLConnectionLoader *URLConnectionLoader::protocolDidReceiveInformationalResponse(URLConnectionLoader *this, _CFURLResponse *a2)
{
  if (this->var21)
  {
    uint64_t v3 = this;
    var12 = this->var12;
    if (var12)
    {
      uint64_t v5 = *(uint64_t (**)(void))(*(void *)var12 + 96);
      return (URLConnectionLoader *)v5();
    }
    else
    {
      if (!a2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "connDidReceiveInformationalResponse(): NULL response provided!", buf, 2u);
      }
      URLConnectionLoader::touchConnection(v3);
      CFAllocatorRef v6 = a2;
      id var5 = v3->var5;
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 3221225472;
      void v8[2] = ___ZN19URLConnectionLoader39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke;
      v8[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
      v8[4] = a2;
      return (URLConnectionLoader *)(*(uint64_t (**)(InterfaceRequiredForLoader *, void *))(*(void *)var5 + 40))(var5, v8);
    }
  }
  return this;
}

void ___ZN19URLConnectionLoader39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 64))(a2, *(void *)(a1 + 32));
  }
  uint64_t v3 = *(void **)(a1 + 32);
}

URLConnectionLoader *non-virtual thunk to'URLConnectionLoader::protocolCacheResponseIsValid(URLConnectionLoader *this, const _CFCachedURLResponse *a2)
{
  return URLConnectionLoader::protocolCacheResponseIsValid((URLConnectionLoader *)((char *)this - 56), a2);
}

void non-virtual thunk to'URLConnectionLoader::protocolWasRedirected(URLConnectionLoader *this, NSURLRequest *a2, _CFURLResponse *a3)
{
}

void URLConnectionLoader::protocolWasRedirected(URLConnectionLoader *this, NSURLRequest *a2, _CFURLResponse *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (([this->var9 _appSSOFallback] & 1) != 0
    || [this->var9 _appleIDContextRedirect])
  {
    if ([this->var9 _appSSOFallback])
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFAllocatorRef v6 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      uint64_t v7 = [this->var9 _loggableDescription];
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v7;
      uint64_t v8 = "%{public}@ performing AppSSO fallback";
    }
    else
    {
      if (![this->var9 _appleIDContextRedirect]) {
        goto LABEL_14;
      }
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFAllocatorRef v6 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_14;
      }
      uint64_t v9 = [this->var9 _loggableDescription];
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v9;
      uint64_t v8 = "%{pubic}@ performing AppleIDContext redirect";
    }
    _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&buf, 0xCu);
LABEL_14:
    var10 = this->var10;
    if (var10) {
      var10[13] = 1;
    }
    this->var14 = 1;
    URLConnectionLoader::protocolWasRedirected_final(this, a2);
    return;
  }
  var12 = this->var12;
  if (var12)
  {
    uint64_t v12 = *(void (**)(void))(*(void *)var12 + 80);
    v12();
  }
  else if (!this->var23 && !this->var4)
  {
    uint64_t v13 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_11605, 1);
    if (v13)
    {
      uint64_t v14 = v13;
      if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v13 + 16))(v13, "Redirection", 0))
      {
        uint64_t v15 = (const void *)(*((uint64_t (**)(URLConnectionLoader *))this->var0 + 3))(this);
        CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        *(void *)&long long buf = off_1ECF9A530;
        uint64_t v24 = 0;
        uint64_t v25 = 0;
        *((void *)&buf + 1) = CFStringCreateWithCString(v16, "Loader", 0x8000100u);
        (*(void (**)(uint64_t))(*(void *)v14 + 64))(v14);
        AutoString::~AutoString((AutoString *)&buf);
        if (v15) {
          CFRelease(v15);
        }
        (*(void (**)(uint64_t, const char *, NSURLRequest *))(*(void *)v14 + 48))(v14, "New Request", a2);
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      }
    }
    int64_t var11 = this->var11;
    this->int64_t var11 = var11 + 1;
    if (var11 <= 19)
    {
      uint64_t v18 = (RedirectionRecorder *)CFAllocatorAllocate(this->var1, 48, 0);
      *((_OWORD *)v18 + 1) = 0u;
      *((_OWORD *)v18 + 2) = 0u;
      *(_OWORD *)uint64_t v18 = 0u;
      RedirectionRecorder::RedirectionRecorder(v18, this->var1);
      this->var12 = v19;
      if (a2) {
        CFRetain(a2);
      }
      uint64_t v20 = a3;
      id var5 = this->var5;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_3;
      v22[3] = &unk_1E5255D08;
      v22[4] = a2;
      v22[5] = this;
      v22[6] = a3;
      (*(void (**)(InterfaceRequiredForLoader *, void *))(*(void *)var5 + 40))(var5, v22);
    }
    else
    {
      (*(void (**)(InterfaceRequiredForLoader *, void *))(*(void *)this->var5 + 40))(this->var5, &__block_literal_global_16_11608);
    }
  }
}

void sub_1842696E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void URLConnectionLoader::protocolWasRedirected_final(URLConnectionLoader *this, CFTypeRef cf)
{
  if (!this->var4)
  {
    if (cf) {
      CFRetain(cf);
    }
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    void v4[2] = ___ZN19URLConnectionLoader27protocolWasRedirected_finalEP12NSURLRequest_block_invoke;
    v4[3] = &unk_1E5258250;
    void v4[4] = cf;
    void v4[5] = this;
    URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v4);
  }
}

void RedirectionRecorder::RedirectionRecorder(RedirectionRecorder *this, const __CFAllocator *a2)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)this, a2);
  void *v4 = &unk_1ECFA0008;
  v4[3] = &unk_1ECFA00F0;
  void v4[4] = &unk_1ECFA01B0;
  CFArrayCallBacks v5 = *(CFArrayCallBacks *)byte_1ECFACE30;
  *((void *)this + 5) = CFArrayCreateMutable(a2, 0, &v5);
}

void sub_18426985C(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_3(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (!*(unsigned char *)(v3 + 25))
    {
      (*(void (**)(void))(**(void **)(v3 + 32) + 64))(*(void *)(v3 + 32));
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 48);
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 3221225472;
      void v8[2] = ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_4;
      v8[3] = &__block_descriptor_40_e22_v16__0__NSURLRequest_8l;
      v8[4] = v3;
      (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a2 + 24))(a2, v5, v6, v8);
    }
  }
  uint64_t v7 = *(const void **)(a1 + 32);
  if (v7) {
    CFRelease(v7);
  }
}

uint64_t ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_4(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  URLConnectionLoader::protocolWasRedirected_final((URLConnectionLoader *)v2, a2);
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(v2 + 32) + 72);

  return v3();
}

void non-virtual thunk to'RedirectionRecorder::~RedirectionRecorder(RedirectionRecorder *this)
{
  uint64_t v2 = (char *)this - 32;
  RedirectionRecorder::~RedirectionRecorder((RedirectionRecorder *)((char *)this - 32));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 3);

  CFAllocatorDeallocate(v3, v2);
}

{
  RedirectionRecorder::~RedirectionRecorder((RedirectionRecorder *)((char *)this - 32));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 24;
  RedirectionRecorder::~RedirectionRecorder((RedirectionRecorder *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  RedirectionRecorder::~RedirectionRecorder((RedirectionRecorder *)((char *)this - 24));
}

void RedirectionRecorder::~RedirectionRecorder(RedirectionRecorder *this)
{
  *(void *)this = &unk_1ECFA0008;
  *((void *)this + 3) = &unk_1ECFA00F0;
  *((void *)this + 4) = &unk_1ECFA01B0;
  uint64_t v2 = (const void *)*((void *)this + 5);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 4) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  RedirectionRecorder::~RedirectionRecorder(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_184269AC0(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'RedirectionRecorder::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 152))(result, 0);
  }
  return result;
}

void non-virtual thunk to'RedirectionRecorder::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(RedirectionRecorder *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream) {
    CFReadStreamClose(stream);
  }
  if (a3)
  {
    CFWriteStreamClose(a3);
  }
}

void non-virtual thunk to'RedirectionRecorder::protocolConnectionEstablished(RedirectionRecorder *this, const __CFDictionary *a2)
{
}

void RedirectionRecorder::protocolConnectionEstablished(RedirectionRecorder *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  value[0] = MEMORY[0x1E4F143A8];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = cf;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void ___ZN19RedirectionRecorder29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 128))(a2, *(void *)(a1 + 32));
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

void non-virtual thunk to'RedirectionRecorder::protocolNeedNewBodyStreamFromOffset(RedirectionRecorder *this, uint64_t a2)
{
  value[0] = MEMORY[0x1E4F143A8];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder35protocolNeedNewBodyStreamFromOffsetEx_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), value);
}

uint64_t ___ZN19RedirectionRecorder35protocolNeedNewBodyStreamFromOffsetEx_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 120))(a2, *(void *)(result + 32));
  }
  return result;
}

void non-virtual thunk to'RedirectionRecorder::protocolNeedNewBodyStream(RedirectionRecorder *this)
{
}

uint64_t ___ZN19RedirectionRecorder25protocolNeedNewBodyStreamEv_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 112))(a2);
  }
  return result;
}

void non-virtual thunk to'RedirectionRecorder::protocolDidReceiveAuthenticationChallenge(RedirectionRecorder *this, _CFURLAuthChallenge *a2)
{
}

void RedirectionRecorder::protocolDidReceiveAuthenticationChallenge(RedirectionRecorder *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  value[0] = MEMORY[0x1E4F143A8];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = cf;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void ___ZN19RedirectionRecorder41protocolDidReceiveAuthenticationChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 104))(a2, *(void *)(a1 + 32));
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

void non-virtual thunk to'RedirectionRecorder::protocolDidFail(RedirectionRecorder *this, __CFError *a2)
{
}

void RedirectionRecorder::protocolDidFail(RedirectionRecorder *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  value[0] = MEMORY[0x1E4F143A8];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder15protocolDidFailEP9__CFError_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = cf;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void ___ZN19RedirectionRecorder15protocolDidFailEP9__CFError_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 96))(a2, *(void *)(a1 + 32));
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

void non-virtual thunk to'RedirectionRecorder::protocolDidFinishLoading(RedirectionRecorder *this)
{
}

uint64_t ___ZN19RedirectionRecorder24protocolDidFinishLoadingEv_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 88))(a2);
  }
  return result;
}

void non-virtual thunk to'RedirectionRecorder::protocolDidSendBodyData(RedirectionRecorder *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  value[0] = MEMORY[0x1E4F143A8];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder23protocolDidSendBodyDataExxx_block_invoke;
  value[3] = &__block_descriptor_56_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  void value[5] = a3;
  value[6] = a4;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), value);
}

void *___ZN19RedirectionRecorder23protocolDidSendBodyDataExxx_block_invoke(void *result, uint64_t a2)
{
  if (a2) {
    return (void *)(*(uint64_t (**)(uint64_t, void, void, void))(*(void *)a2 + 80))(a2, result[4], result[5], result[6]);
  }
  return result;
}

void non-virtual thunk to'RedirectionRecorder::protocolDidLoadData(RedirectionRecorder *this, const __CFData *a2, uint64_t a3)
{
}

void RedirectionRecorder::protocolDidLoadData(RedirectionRecorder *this, CFTypeRef cf, uint64_t a3)
{
  if (cf) {
    CFRetain(cf);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN19RedirectionRecorder19protocolDidLoadDataEPK8__CFDatax_block_invoke;
  v6[3] = &__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
  _OWORD v6[4] = cf;
  void v6[5] = a3;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), v6);
}

void ___ZN19RedirectionRecorder19protocolDidLoadDataEPK8__CFDatax_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 72))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

void non-virtual thunk to'RedirectionRecorder::protocolDidReceiveResponse(RedirectionRecorder *this, _CFURLResponse *a2)
{
}

void RedirectionRecorder::protocolDidReceiveResponse(RedirectionRecorder *this, _CFURLResponse *a2)
{
  CFAllocatorRef v4 = a2;
  value[0] = MEMORY[0x1E4F143A8];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder26protocolDidReceiveResponseEP14_CFURLResponse_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void ___ZN19RedirectionRecorder26protocolDidReceiveResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 64))(a2, *(void *)(a1 + 32));
  }
  CFAllocatorRef v3 = *(void **)(a1 + 32);
}

void non-virtual thunk to'RedirectionRecorder::protocolDidReceiveInformationalResponse(RedirectionRecorder *this, _CFURLResponse *a2)
{
}

void RedirectionRecorder::protocolDidReceiveInformationalResponse(RedirectionRecorder *this, _CFURLResponse *a2)
{
  CFAllocatorRef v4 = a2;
  value[0] = MEMORY[0x1E4F143A8];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void ___ZN19RedirectionRecorder39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 56))(a2, *(void *)(a1 + 32));
  }
  CFAllocatorRef v3 = *(void **)(a1 + 32);
}

void non-virtual thunk to'RedirectionRecorder::protocolCacheResponseIsValid(RedirectionRecorder *this, const _CFCachedURLResponse *a2)
{
}

void RedirectionRecorder::protocolCacheResponseIsValid(RedirectionRecorder *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  value[0] = MEMORY[0x1E4F143A8];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder28protocolCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = cf;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void ___ZN19RedirectionRecorder28protocolCacheResponseIsValidEPK20_CFCachedURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 48))(a2, *(void *)(a1 + 32));
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

void non-virtual thunk to'RedirectionRecorder::protocolWasRedirected(RedirectionRecorder *this, NSURLRequest *a2, _CFURLResponse *a3)
{
}

void RedirectionRecorder::protocolWasRedirected(RedirectionRecorder *this, CFTypeRef cf, _CFURLResponse *a3)
{
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v6 = a3;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  uint64_t v7[2] = ___ZN19RedirectionRecorder21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke;
  v7[3] = &unk_1E5255ED8;
  v7[4] = cf;
  void v7[5] = a3;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), v7);
}

void ___ZN19RedirectionRecorder21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 40))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
  }

  CFAllocatorRef v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t non-virtual thunk to'RedirectionRecorder::protocolCopyDescription(RedirectionRecorder *this)
{
  return 0;
}

uint64_t RedirectionRecorder::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 152))(result, 0);
  }
  return result;
}

void RedirectionRecorder::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(RedirectionRecorder *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream) {
    CFReadStreamClose(stream);
  }
  if (a3)
  {
    CFWriteStreamClose(a3);
  }
}

void RedirectionRecorder::protocolNeedNewBodyStreamFromOffset(RedirectionRecorder *this, uint64_t a2)
{
  value[0] = MEMORY[0x1E4F143A8];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder35protocolNeedNewBodyStreamFromOffsetEx_block_invoke;
  value[3] = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

void RedirectionRecorder::protocolNeedNewBodyStream(RedirectionRecorder *this)
{
}

void RedirectionRecorder::protocolDidFinishLoading(RedirectionRecorder *this)
{
}

void RedirectionRecorder::protocolDidSendBodyData(RedirectionRecorder *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  value[0] = MEMORY[0x1E4F143A8];
  value[1] = 3221225472;
  value[2] = ___ZN19RedirectionRecorder23protocolDidSendBodyDataExxx_block_invoke;
  value[3] = &__block_descriptor_56_e31_v16__0__URLProtocolClient_____8l;
  value[4] = a2;
  void value[5] = a3;
  value[6] = a4;
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 5), value);
}

uint64_t RedirectionRecorder::protocolCopyDescription(RedirectionRecorder *this)
{
  return 0;
}

BOOL RedirectionRecorder::equals(RedirectionRecorder *this, RedirectionRecorder *a2)
{
  return this == a2;
}

uint64_t ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, __CFString *, uint64_t))(*(void *)a2 + 152))(a2, @"kCFErrorDomainCFNetwork", -1007);
  }
  return result;
}

uint64_t ___ZN19URLConnectionLoader21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 484;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN19URLConnectionLoader27protocolWasRedirected_finalEP12NSURLRequest_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(URLConnectionLoader **)(a1 + 40);
  v2->var14 = 1;
  if (*(void *)(a1 + 32) && (id var9 = v2->var9) != 0)
  {
    CFAllocatorRef v4 = (void *)[var9 originalRequest];
    if (!v4 || !haveTheSameOrigin((NSURL *)[v4 cfURL], (NSURL *)objc_msgSend(*(id *)(a1 + 32), "cfURL"))) {
      [v2->var9 _releasePreventIdleSleepAssertionIfAppropriate];
    }
    URLConnectionLoader::_private_followRedirection(v2, *(CFTypeRef *)(a1 + 32));
  }
  else if (v2->var15)
  {
    v2->var15 = 0;
    URLConnectionLoader::replayOrConsumeRedirections(v2);
  }
  uint64_t v5 = *(const void **)(a1 + 32);
  if (v5)
  {
    CFRelease(v5);
  }
}

uint64_t non-virtual thunk to'URLConnectionLoader::protocolCopyDescription(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(void))(**(void **)&this[-1].var28 + 24))();
}

uint64_t non-virtual thunk to'URLConnectionLoader::protocolReleaseClient(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(void))(**(void **)&this[-1].var28 + 72))();
}

uint64_t non-virtual thunk to'URLConnectionLoader::protocolRetainClient(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(void))(**(void **)&this[-1].var28 + 64))();
}

void non-virtual thunk to'URLConnectionLoader::~URLConnectionLoader(URLConnectionLoader *this)
{
  p_var24 = &this[-1].var24;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 56));
  double var25 = this[-1].var25;

  CFAllocatorDeallocate(*(CFAllocatorRef *)&var25, p_var24);
}

{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 56));
}

{
  char *p_var25;
  double var26;
  uint64_t vars8;

  p_double var25 = (char *)&this[-1].var25;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 48));
  var26 = this[-1].var26;

  CFAllocatorDeallocate(*(CFAllocatorRef *)&var26, p_var25);
}

{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 48));
}

{
  unint64_t *p_var33;
  CFAllocatorRef v3;
  uint64_t vars8;

  p_var33 = &this[-1].var33;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 16));
  CFAllocatorRef v3 = *(const __CFAllocator **)&this[-1].var34;

  CFAllocatorDeallocate(v3, p_var33);
}

{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 16));
}

uint64_t non-virtual thunk to'URLConnectionLoader::_loaderInterface_expectedProgressTargetChanged(URLConnectionLoader *this)
{
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)&__block_literal_global_84_11619);
}

uint64_t ___ZN19URLConnectionLoader46_loaderInterface_expectedProgressTargetChangedEv_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 176))(a2);
  }
  return result;
}

uint64_t URLConnectionLoader::_loaderInterface_setBytesPerSecondLimit(URLConnectionLoader *this, uint64_t a2)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  uint64_t v3[2] = ___ZN19URLConnectionLoader39_loaderInterface_setBytesPerSecondLimitEx_block_invoke;
  v3[3] = &__block_descriptor_40_e9_v16__0_v8l;
  void v3[4] = a2;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)v3);
}

uint64_t URLConnectionLoader::_loaderInterface_setPriorityHint(URLConnectionLoader *this, float a2, char a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN19URLConnectionLoader32_loaderInterface_setPriorityHintEfb_block_invoke;
  v4[3] = &__block_descriptor_37_e9_v16__0_v8l;
  float v5 = a2;
  char v6 = a3;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)v4);
}

void URLConnectionLoader::_loaderInterface_UpdateScheduling(URLConnectionLoader *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFAllocatorRef v3 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)CFAllocatorRef v4 = 0;
    _os_log_error_impl(&dword_184085000, v3, OS_LOG_TYPE_ERROR, "Rescheduling the CFNetwork loader is no longer supported", v4, 2u);
  }
}

void non-virtual thunk to'URLConnectionLoader::_loaderInterface_rejectChallenge(URLConnectionLoader *this, _CFURLAuthChallenge *a2)
{
}

void URLConnectionLoader::_loaderInterface_rejectChallenge(URLConnectionLoader *this, _CFURLAuthChallenge *a2)
{
  if (!this->var23)
  {
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    void v6[2] = ___ZN19URLConnectionLoader32_loaderInterface_rejectChallengeEP19_CFURLAuthChallenge_block_invoke;
    v6[3] = &__block_descriptor_48_e5_v8__0l;
    _OWORD v6[4] = this;
    void v6[5] = a2;
    __CFNetworkLogForAuthTimeoutIssueSync((uint64_t)v6);
    if (a2)
    {
      if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
        dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
      }
      if (URLAuthChallenge::tryNextProtectionSpace((URLAuthChallenge *)((char *)a2 + 16)))
      {
        CFRetain(a2);
        id var5 = this->var5;
        v5[0] = MEMORY[0x1E4F143A8];
        v5[1] = 3221225472;
        v5[2] = ___ZN19URLConnectionLoader32_loaderInterface_rejectChallengeEP19_CFURLAuthChallenge_block_invoke_2;
        v5[3] = &__block_descriptor_40_e35_v16__0__LoaderClientInterface_____8l;
        v5[4] = a2;
        (*(void (**)(InterfaceRequiredForLoader *, void *))(*(void *)var5 + 40))(var5, v5);
      }
      else
      {
        (*((void (**)(URLConnectionLoader *, void, _CFURLAuthChallenge *))this->var0 + 32))(this, 0, a2);
      }
    }
  }
}

void ___ZN19URLConnectionLoader32_loaderInterface_rejectChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1)
{
  uint64_t v1 = (const void *)(*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
  CFLog();
  if (v1)
  {
    CFRelease(v1);
  }
}

void ___ZN19URLConnectionLoader32_loaderInterface_rejectChallengeEP19_CFURLAuthChallenge_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 40))(a2, *(void *)(a1 + 32));
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

void non-virtual thunk to'URLConnectionLoader::_loaderInterface_useCredential(URLConnectionLoader *this, const _CFURLCredential *a2, _CFURLAuthChallenge *a3)
{
}

void ___ZN19URLConnectionLoader30_loaderInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke(uint64_t a1)
{
  uint64_t v1 = (const void *)(*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
  CFLog();
  if (v1)
  {
    CFRelease(v1);
  }
}

uint64_t ___ZN19URLConnectionLoader30_loaderInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1402;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN19URLConnectionLoader51_loaderInterface_performDefaultHandlingForChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1)
{
  uint64_t v1 = (const void *)(*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
  CFLog();
  if (v1)
  {
    CFRelease(v1);
  }
}

uint64_t non-virtual thunk to'URLConnectionLoader::_loaderEvent_DontUseCredentialStorage(URLConnectionLoader *this)
{
  LOBYTE(this->var22) |= 4u;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)&__block_literal_global_98);
}

void ___ZN19URLConnectionLoader37_loaderEvent_DontUseCredentialStorageEv_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    *(unsigned char *)(a2 + 40) = 0;
  }
}

uint64_t non-virtual thunk to'URLConnectionLoader::_loaderEvent_SetBodyStream(URLConnectionLoader *this, __CFReadStream *a2)
{
  return URLConnectionLoader::_loaderEvent_SetBodyStream((URLConnectionLoader *)((char *)this - 48), a2);
}

uint64_t URLConnectionLoader::_loaderEvent_SetBodyStream(URLConnectionLoader *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN19URLConnectionLoader26_loaderEvent_SetBodyStreamEP14__CFReadStream_block_invoke;
  v5[3] = &__block_descriptor_40_e9_v16__0_v8l;
  v5[4] = cf;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)v5);
}

void ___ZN19URLConnectionLoader26_loaderEvent_SetBodyStreamEP14__CFReadStream_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 80))(a2, *(void *)(a1 + 32));
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t ___ZN19URLConnectionLoader34_loaderEvent_SetProtocolIsDownloadEh_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 128))(a2, *(unsigned __int8 *)(result + 32));
  }
  return result;
}

uint64_t ___ZN19URLConnectionLoader14performTimeOutEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 120))(a2);
  }
  return result;
}

uint64_t ___ZN19URLConnectionLoader14performTimeOutEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1876;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN19URLConnectionLoader16loadWithWhatToDoEP12NSURLRequestPK20_CFCachedURLResponselNS_8WhatToDoE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, __CFString *, void))(*(void *)a2 + 152))(a2, @"kCFErrorDomainCFNetwork", *(void *)(a1 + 32));
}

uint64_t ___ZN19URLConnectionLoader27_private_ScheduleOriginLoadEP12NSURLRequestPK20_CFCachedURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, __CFString *, uint64_t))(*(void *)a2 + 152))(a2, @"kCFErrorDomainCFNetwork", -1002);
  }
  return result;
}

uint64_t ___ZN19URLConnectionLoader16loadWithWhatToDoEP12NSURLRequestPK20_CFCachedURLResponselNS_8WhatToDoE_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1757;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t URLConnectionLoader::_loaderInterface_release(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(void))(*(void *)this->var5 + 72))();
}

void ***URLConnectionLoader::_loaderInterface_retain(URLConnectionLoader *this)
{
  return &this->var7;
}

uint64_t URLConnectionLoader::_loaderInterface_expectedProgressTargetChanged(URLConnectionLoader *this)
{
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)&__block_literal_global_84_11619);
}

uint64_t URLConnectionLoader::protocolCopyDescription(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(void))(*(void *)this->var5 + 24))();
}

uint64_t URLConnectionLoader::protocolReleaseClient(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(void))(*(void *)this->var5 + 72))();
}

uint64_t URLConnectionLoader::protocolRetainClient(URLConnectionLoader *this)
{
  return (*(uint64_t (**)(void))(*(void *)this->var5 + 64))();
}

uint64_t URLConnectionLoader::_loaderEvent_DontUseCredentialStorage(URLConnectionLoader *this)
{
  *(unsigned char *)&this->var28 |= 4u;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)&__block_literal_global_98);
}

uint64_t URLConnectionLoader::_loaderEvent_ResumeProtocolLoad(URLConnectionLoader *this)
{
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)&__block_literal_global_127_11638);
}

uint64_t URLConnectionLoader::_loaderEvent_SuspendProtocolLoad(URLConnectionLoader *this)
{
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)this, (uint64_t)&__block_literal_global_125);
}

CFTypeRef URLConnectionLoader::copyDebugSummary(URLConnectionLoader *this)
{
  uint64_t v1 = (void *)(*(uint64_t (**)(InterfaceRequiredForLoader *))(*(void *)this->var5 + 16))(this->var5);
  if (v1)
  {
    uint64_t v2 = v1;
    uint64_t v3 = [v1 _inner];
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);

    return (CFTypeRef)v4;
  }
  else
  {
    return CFRetain(@"no original request");
  }
}

void non-virtual thunk to'URLConnectionLoader_Classic::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

void URLConnectionLoader_Classic::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3321888768;
  v5[2] = ___ZN27URLConnectionLoader_Classic38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  v5[3] = &unk_1ECFA9CA0;
  uint64_t v4 = *a2;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  void v5[5] = a1;
  void v5[6] = v4;
  char v6 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v5[4] = a3;
  URLConnectionInstanceData::withWorkQueueAsync(a1, (uint64_t)v5);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_18426B61C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN27URLConnectionLoader_Classic38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t *a1)
{
  uint64_t v2 = (void *)a1[5];
  uint64_t v3 = (std::__shared_weak_count *)a1[7];
  v4[0] = a1[6];
  v4[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  URLConnectionLoader::tcpConnectionForUpgradeHeaderAvailable(v2, v4, a1[4]);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void sub_18426B6AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'URLConnectionLoader_Classic::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(URLConnectionLoader_Classic *this, __CFReadStream *a2, __CFWriteStream *a3)
{
}

void URLConnectionLoader_Classic::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(URLConnectionLoader_Classic *this, CFTypeRef cf, CFTypeRef a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN27URLConnectionLoader_Classic54protocolReceivedSocketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke;
  v6[3] = &__block_descriptor_56_e5_v8__0l;
  _OWORD v6[4] = this;
  void v6[5] = cf;
  void v6[6] = a3;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v6);
}

void ___ZN27URLConnectionLoader_Classic54protocolReceivedSocketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke(uint64_t a1)
{
  URLConnectionLoader::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(*(URLConnectionLoader **)(a1 + 32), *(CFReadStreamRef *)(a1 + 40), *(CFWriteStreamRef *)(a1 + 48));
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    CFRelease(v3);
  }
}

void non-virtual thunk to'URLConnectionLoader_Classic::protocolAlternatePathAvailable(uint64_t a1, int a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN27URLConnectionLoader_Classic30protocolAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke;
  v2[3] = &__block_descriptor_44_e5_v8__0l;
  void v2[4] = a1 - 56;
  int v3 = a2;
  URLConnectionInstanceData::withWorkQueueAsync(a1 - 56, (uint64_t)v2);
}

uint64_t ___ZN27URLConnectionLoader_Classic30protocolAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke(uint64_t a1)
{
  return URLConnectionLoader::protocolAlternatePathAvailable(*(void *)(a1 + 32), *(_DWORD *)(a1 + 40));
}

void non-virtual thunk to'URLConnectionLoader_Classic::protocolConditionalRequirementsChanged(URLConnectionLoader_Classic *this, char a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN27URLConnectionLoader_Classic38protocolConditionalRequirementsChangedEh_block_invoke;
  v2[3] = &__block_descriptor_41_e5_v8__0l;
  void v2[4] = (char *)this - 56;
  char v3 = a2;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this - 56, (uint64_t)v2);
}

URLConnectionLoader *___ZN27URLConnectionLoader_Classic38protocolConditionalRequirementsChangedEh_block_invoke(uint64_t a1)
{
  return URLConnectionLoader::protocolConditionalRequirementsChanged(*(URLConnectionLoader **)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void non-virtual thunk to'URLConnectionLoader_Classic::protocolConnectionWaiting(uint64_t a1, uint64_t a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN27URLConnectionLoader_Classic25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke;
  v2[3] = &__block_descriptor_48_e5_v8__0l;
  void v2[4] = a1 - 56;
  void v2[5] = a2;
  URLConnectionInstanceData::withWorkQueueAsync(a1 - 56, (uint64_t)v2);
}

void *___ZN27URLConnectionLoader_Classic25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke(uint64_t a1)
{
  return URLConnectionLoader::protocolConnectionWaiting(*(void **)(a1 + 32), *(void *)(a1 + 40));
}

void non-virtual thunk to'URLConnectionLoader_Classic::protocolNeedNewBodyStreamFromOffset(URLConnectionLoader_Classic *this, uint64_t a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN27URLConnectionLoader_Classic35protocolNeedNewBodyStreamFromOffsetEx_block_invoke;
  v2[3] = &__block_descriptor_48_e5_v8__0l;
  void v2[4] = (char *)this - 56;
  void v2[5] = a2;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this - 56, (uint64_t)v2);
}

URLConnectionLoader *___ZN27URLConnectionLoader_Classic35protocolNeedNewBodyStreamFromOffsetEx_block_invoke(uint64_t a1)
{
  return URLConnectionLoader::protocolNeedNewBodyStreamFromOffset(*(URLConnectionLoader **)(a1 + 32), *(void *)(a1 + 40));
}

void non-virtual thunk to'URLConnectionLoader_Classic::protocolNeedNewBodyStream(URLConnectionLoader_Classic *this)
{
  v1[0] = MEMORY[0x1E4F143A8];
  v1[1] = 3221225472;
  v1[2] = ___ZN27URLConnectionLoader_Classic25protocolNeedNewBodyStreamEv_block_invoke;
  v1[3] = &__block_descriptor_40_e5_v8__0l;
  v1[4] = (char *)this - 56;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this - 56, (uint64_t)v1);
}

URLConnectionLoader *___ZN27URLConnectionLoader_Classic25protocolNeedNewBodyStreamEv_block_invoke(uint64_t a1)
{
  return URLConnectionLoader::protocolNeedNewBodyStream(*(URLConnectionLoader **)(a1 + 32));
}

void non-virtual thunk to'URLConnectionLoader_Classic::protocolDidReceiveInformationalResponse(URLConnectionLoader_Classic *this, _CFURLResponse *a2)
{
}

void URLConnectionLoader_Classic::protocolDidReceiveInformationalResponse(URLConnectionLoader_Classic *this, _CFURLResponse *a2)
{
  uint64_t v4 = a2;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN27URLConnectionLoader_Classic39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke;
  v5[3] = &__block_descriptor_48_e5_v8__0l;
  v5[4] = this;
  void v5[5] = a2;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v5);
}

void ___ZN27URLConnectionLoader_Classic39protocolDidReceiveInformationalResponseEP14_CFURLResponse_block_invoke(uint64_t a1)
{
  URLConnectionLoader::protocolDidReceiveInformationalResponse(*(URLConnectionLoader **)(a1 + 32), *(_CFURLResponse **)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 40);
}

void non-virtual thunk to'URLConnectionLoader_Classic::protocolWasRedirected(URLConnectionLoader_Classic *this, NSURLRequest *a2, _CFURLResponse *a3)
{
}

void URLConnectionLoader_Classic::protocolWasRedirected(URLConnectionLoader_Classic *this, CFTypeRef cf, _CFURLResponse *a3)
{
  if (cf) {
    CFRetain(cf);
  }
  char v6 = a3;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  uint64_t v7[2] = ___ZN27URLConnectionLoader_Classic21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke;
  v7[3] = &unk_1E5255EB0;
  v7[4] = cf;
  void v7[5] = this;
  void v7[6] = a3;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v7);
}

void ___ZN27URLConnectionLoader_Classic21protocolWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke(uint64_t a1)
{
  URLConnectionLoader::protocolWasRedirected(*(URLConnectionLoader **)(a1 + 40), *(NSURLRequest **)(a1 + 32), *(_CFURLResponse **)(a1 + 48));
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  char v3 = *(void **)(a1 + 48);
}

uint64_t non-virtual thunk to'URLConnectionLoader_Classic::protocolCopyDescription(URLConnectionLoader_Classic *this)
{
  return (*(uint64_t (**)(void))(**((void **)this - 3) + 24))();
}

void non-virtual thunk to'URLConnectionLoader_Classic::~URLConnectionLoader_Classic(URLConnectionLoader_Classic *this)
{
  uint64_t v2 = (char *)this - 56;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 56));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 6);

  CFAllocatorDeallocate(v3, v2);
}

{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 56));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 48;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 48));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 5);

  CFAllocatorDeallocate(v3, v2);
}

{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 48));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 16;
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 16));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  URLConnectionLoader::~URLConnectionLoader((URLConnectionLoader *)((char *)this - 16));
}

void URLConnectionLoader_Classic::protocolAlternatePathAvailable(uint64_t a1, int a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN27URLConnectionLoader_Classic30protocolAlternatePathAvailableE36nw_connection_alternate_path_state_t_block_invoke;
  v2[3] = &__block_descriptor_44_e5_v8__0l;
  void v2[4] = a1;
  int v3 = a2;
  URLConnectionInstanceData::withWorkQueueAsync(a1, (uint64_t)v2);
}

void URLConnectionLoader_Classic::protocolConditionalRequirementsChanged(URLConnectionLoader_Classic *this, char a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN27URLConnectionLoader_Classic38protocolConditionalRequirementsChangedEh_block_invoke;
  v2[3] = &__block_descriptor_41_e5_v8__0l;
  void v2[4] = this;
  char v3 = a2;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v2);
}

void URLConnectionLoader_Classic::protocolConnectionWaiting(uint64_t a1, uint64_t a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN27URLConnectionLoader_Classic25protocolConnectionWaitingE40tcp_connection_unmet_conditions_reason_t_block_invoke;
  v2[3] = &__block_descriptor_48_e5_v8__0l;
  void v2[4] = a1;
  void v2[5] = a2;
  URLConnectionInstanceData::withWorkQueueAsync(a1, (uint64_t)v2);
}

void URLConnectionLoader_Classic::protocolConnectionEstablished(URLConnectionLoader_Classic *this, const __CFDictionary *a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN27URLConnectionLoader_Classic29protocolConnectionEstablishedEPK14__CFDictionary_block_invoke;
  v2[3] = &__block_descriptor_48_e5_v8__0l;
  void v2[4] = this;
  void v2[5] = a2;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v2);
}

void URLConnectionLoader_Classic::protocolNeedNewBodyStreamFromOffset(URLConnectionLoader_Classic *this, uint64_t a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN27URLConnectionLoader_Classic35protocolNeedNewBodyStreamFromOffsetEx_block_invoke;
  v2[3] = &__block_descriptor_48_e5_v8__0l;
  void v2[4] = this;
  void v2[5] = a2;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v2);
}

void URLConnectionLoader_Classic::protocolNeedNewBodyStream(URLConnectionLoader_Classic *this)
{
  v1[0] = MEMORY[0x1E4F143A8];
  v1[1] = 3221225472;
  v1[2] = ___ZN27URLConnectionLoader_Classic25protocolNeedNewBodyStreamEv_block_invoke;
  v1[3] = &__block_descriptor_40_e5_v8__0l;
  v1[4] = this;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v1);
}

void URLConnectionLoader_Classic::protocolDidFinishLoading(URLConnectionLoader_Classic *this)
{
  v1[0] = MEMORY[0x1E4F143A8];
  v1[1] = 3221225472;
  v1[2] = ___ZN27URLConnectionLoader_Classic24protocolDidFinishLoadingEv_block_invoke;
  v1[3] = &__block_descriptor_40_e5_v8__0l;
  v1[4] = this;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v1);
}

void URLConnectionLoader_Classic::protocolDidSendBodyData(URLConnectionLoader_Classic *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN27URLConnectionLoader_Classic23protocolDidSendBodyDataExxx_block_invoke;
  v4[3] = &__block_descriptor_64_e5_v8__0l;
  void v4[4] = this;
  void v4[5] = a2;
  void v4[6] = a3;
  void v4[7] = a4;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v4);
}

uint64_t URLConnectionLoader_Classic::protocolCopyDescription(URLConnectionLoader_Classic *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 24))();
}

uint64_t URLConnectionLoader_Classic::protocolReleaseClient(URLConnectionLoader_Classic *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 72))();
}

uint64_t URLConnectionLoader_Classic::protocolRetainClient(URLConnectionLoader_Classic *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 64))();
}

void ___ZN4CFNA20CFNetworkAgentClient23getCFNetworkAgentClientEv_block_invoke()
{
}

void CFNA::CFNetworkAgentClient::CFNetworkAgentClient(void)::$_0::__invoke(dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
}

void CFNA::CFNetworkAgentClient::executeLegacyQuery(CFNA::CFNetworkAgentClient *this, const __CFString *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  xpc_dictionary_create(0, 0, 0);
  operator new();
}

void sub_18426C308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v13);
  std::__shared_weak_count::__release_shared[abi:nn180100](v13);
  _Unwind_Resume(a1);
}

void SmartBlockWithArgs<BOOL,NSObject  {objcproto13OS_xpc_object}*>::SmartBlockWithArgs()
{
}

void sub_18426C418(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void CFNA::CFNetworkAgentClient::sendMessage(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t *a5)
{
  char v6 = *(NSObject **)(a1 + 16);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3321888768;
  void v8[2] = ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke;
  v8[3] = &__block_descriptor_80_e8_48c62_ZTSNSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEE64c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE_e5_v8__0l;
  v8[4] = a1;
  void v8[5] = a4;
  void v8[6] = a2;
  uint64_t v9 = a3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::__shared_weak_count *)a5[1];
  uint64_t v10 = *a5;
  CFStringRef v11 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_async(v6, v8);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
}

void ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = *(_xpc_connection_s **)v2;
  if (*(void *)v2) {
    goto LABEL_2;
  }
  CFStringRef v11 = getenv("CFNETWORKAGENT_SERVICE_NAME");
  if (!v11) {
    CFStringRef v11 = "com.apple.cfnetwork.cfnetworkagent";
  }
  mach_service = xpc_connection_create_mach_service(v11, *(dispatch_queue_t *)(v2 + 16), 0);
  uint64_t v13 = *(_xpc_connection_s **)v2;
  *(void *)uint64_t v2 = mach_service;
  if (v13)
  {
    (*(void (**)(void))(v2 + 8))();
    mach_service = *(_xpc_connection_s **)v2;
  }
  *(void *)(v2 + 8) = _ZZZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EEEUb_EN3__28__invokeES7_;
  if (!mach_service) {
    goto LABEL_20;
  }
  xpc_connection_set_target_queue(mach_service, *(dispatch_queue_t *)(v2 + 16));
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 3221225472;
  void v19[2] = ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke_2;
  v19[3] = &unk_1E5255F88;
  uint64_t v14 = *(void *)(a1 + 40);
  v19[5] = v2;
  v19[6] = v14;
  v19[4] = mach_service;
  xpc_connection_set_event_handler(mach_service, v19);
  xpc_connection_resume(mach_service);
  char v3 = *(_xpc_connection_s **)v2;
  if (*(void *)v2)
  {
LABEL_2:
    uint64_t v4 = *(void *)(a1 + 40);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    float v5 = CFNLog::logger;
    BOOL v6 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
    if (v4 == 3)
    {
      if (v6)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "Sending CFNA PAC query", buf, 2u);
      }
      uint64_t v7 = *(void **)(a1 + 48);
      uint64_t v8 = *(NSObject **)(v2 + 16);
      handler[0] = MEMORY[0x1E4F143A8];
      handler[1] = 3321888768;
      handler[2] = ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke_9;
      handler[3] = &__block_descriptor_56_e8_40c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE_e33_v16__0__NSObject_OS_xpc_object__8l;
      uint64_t v10 = *(void *)(a1 + 64);
      uint64_t v9 = *(std::__shared_weak_count **)(a1 + 72);
      void handler[4] = v2;
      void handler[5] = v10;
      CFStringRef v17 = v9;
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      xpc_connection_send_message_with_reply(v3, v7, v8, handler);
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v17);
      }
    }
    else
    {
      if (v6)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "Sending CFNA legacy query", buf, 2u);
      }
      xpc_connection_send_message(v3, *(xpc_object_t *)(a1 + 48));
    }
  }
  else
  {
LABEL_20:
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v15 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl(&dword_184085000, v15, OS_LOG_TYPE_ERROR, "Failed to create CFNA XPC connection", buf, 2u);
    }
  }
}

void sub_18426C7A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c62_ZTSNSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEE64c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  char v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_e8_48c62_ZTSNSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEE64c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE(void *result, void *a2)
{
  uint64_t v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[9];
  result[8] = a2[8];
  result[9] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t result = MEMORY[0x18531EBC0](a2);
  if (result == MEMORY[0x1E4F145A8])
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    BOOL v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 48);
      if ((unint64_t)(v7 - 1) > 4) {
        uint64_t v8 = "Unknown";
      }
      else {
        uint64_t v8 = off_1E5252900[v7 - 1];
      }
      int v9 = 138412802;
      uint64_t v10 = a2;
      __int16 v11 = 2048;
      uint64_t v12 = v7;
      __int16 v13 = 2080;
      uint64_t v14 = v8;
      _os_log_error_impl(&dword_184085000, v6, OS_LOG_TYPE_ERROR, "Received XPC error %@ for message type %lld %s", (uint8_t *)&v9, 0x20u);
    }
    xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
    uint64_t result = *(void *)v4;
    *(void *)uint64_t v4 = 0;
    if (result) {
      return (*(uint64_t (**)(void))(v4 + 8))();
    }
  }
  return result;
}

void ___ZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EE_block_invoke_9(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  float v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(vCFRelease((char *)this - 16) = 0;
    _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "Received CFNA PAC response", (uint8_t *)&v16, 2u);
  }
  if (a2 == (void *)MEMORY[0x1E4F14550] || a2 == (void *)MEMORY[0x1E4F14528] || a2 == (void *)MEMORY[0x1E4F14520])
  {
    if (*(void *)v4)
    {
      xpc_connection_cancel(*(xpc_connection_t *)v4);
      xpc_connection_t v8 = *(xpc_connection_t *)v4;
      *(void *)uint64_t v4 = 0;
      if (v8) {
        (*(void (**)(void))(v4 + 8))();
      }
    }
  }
  else
  {
    int64_t int64 = xpc_dictionary_get_int64(a2, "type");
    if (int64 == 4)
    {
      uint64_t v10 = *(void *)(a1 + 40);
      if (v10)
      {
        __int16 v11 = *(void (**)(void *, uint64_t, void *))(v10 + 8);
        uint64_t v12 = *(void *)(v10 + 16);
        __int16 v13 = (void *)(v10 + (v12 >> 1));
        if (v12) {
          __int16 v11 = *(void (**)(void *, uint64_t, void *))(*v13 + v11);
        }
        v11(v13, 1, a2);
      }
    }
    else
    {
      int64_t v14 = int64;
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v15 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        int v16 = 134217984;
        int64_t v17 = v14;
        _os_log_error_impl(&dword_184085000, v15, OS_LOG_TYPE_ERROR, "Received unknown CFNA result %lld", (uint8_t *)&v16, 0xCu);
      }
    }
  }
}

void __destroy_helper_block_e8_40c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c66_ZTS18SmartBlockWithArgsIJbPU24objcproto13OS_xpc_object8NSObjectEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void _ZZZN4CFNA20CFNetworkAgentClient11sendMessageENSt3__110shared_ptrIU24objcproto13OS_xpc_object8NSObjectEEx18SmartBlockWithArgsIJbPS4_EEEUb_EN3__28__invokeES7_(xpc_object_t object)
{
  if (object) {
    xpc_release(object);
  }
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*> *,SmartBlockWithArgs<BOOL,NSObject  {objcproto13OS_xpc_object}*>::Deleter,std::allocator<BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_initial
    && v5 != 0)
  {
    uint64_t v7 = (void *)(v1 + (v2 >> 1));
    if (v2) {
      (*(void (**)(void *, void, void))(*v7
    }
                                                       + BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_initial))(v7, 0, 0);
    else {
      ((void (*)(void *, void, void))BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_initial)(v7, 0, 0);
    }
  }
  _Block_release(*(const void **)v1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*> *,SmartBlockWithArgs<BOOL,NSObject  {objcproto13OS_xpc_object}*>::Deleter,std::allocator<BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

uint64_t BlockHolderVar<BOOL,NSObject  {objcproto13OS_xpc_object}*>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_xpc_object}*,CFNA::CFNetworkAgentClient::executeLegacyQuery(__CFString const*,long long)::$_0,std::allocator<NSObject  {objcproto13OS_xpc_object}>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    xpc_release(v1);
  }
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_xpc_object}*,CFNA::CFNetworkAgentClient::executeLegacyQuery(__CFString const*,long long)::$_0,std::allocator<NSObject  {objcproto13OS_xpc_object}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void ___ZN4CFNA20CFNetworkAgentClient10executePACENSt3__110shared_ptrIN3PAC8PACQueryEEE_block_invoke(uint64_t a1, int a2, xpc_object_t xdict)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  if (!a2)
  {
    CFErrorCreate(0, @"kCFErrorDomainCFNetwork", 308, 0);
    operator new();
  }
  size_t length = 0;
  data = (const UInt8 *)xpc_dictionary_get_data(xdict, "list", &length);
  if (data)
  {
    CFDataRef v6 = CFDataCreate(0, data, length);
    CFErrorRef error = 0;
    *(void *)CFTypeRef cf = CFPropertyListCreateWithData(0, v6, 0, 0, &error);
    std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>((uint64_t)&v25, cf);
    if (*(void *)cf) {
      CFRelease(*(CFTypeRef *)cf);
    }
    if (error)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v7 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        CFErrorRef v22 = error;
        CFIndex Code = CFErrorGetCode(error);
        *(_DWORD *)CFTypeRef cf = 138412546;
        *(void *)&cf[4] = v22;
        *(_WORD *)&unsigned char cf[12] = 2048;
        *(void *)&cf[14] = Code;
        _os_log_error_impl(&dword_184085000, v7, OS_LOG_TYPE_ERROR, "PAC failed to unpack proxy list from xpc reply %@ [%ld]", cf, 0x16u);
      }
      CFRelease(error);
    }
    if (v6)
    {
      CFRelease(v6);
      CFDataRef v6 = 0;
    }
  }
  else
  {
    int64_t int64 = xpc_dictionary_get_int64(xdict, "errCode");
    string = xpc_dictionary_get_string(xdict, "errDomain");
    if (string)
    {
      CFStringRef v10 = CFStringCreateWithCString(0, string, 0x8000100u);
      if (v10)
      {
        CFErrorCreate(0, v10, int64, 0);
        operator new();
      }
    }
    CFDataRef v6 = 0;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    __int16 v11 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFTypeRef cf = 0;
      _os_log_error_impl(&dword_184085000, v11, OS_LOG_TYPE_ERROR, "PAC failed to unpack error from xpc message", cf, 2u);
    }
  }
  uint64_t v12 = *(void **)(a1 + 32);
  uint64_t v13 = v12[9];
  int64_t v14 = (std::__shared_weak_count *)v12[10];
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v12 = *(void **)(a1 + 32);
  }
  uint64_t v16 = v12[4];
  uint64_t v15 = v12[5];
  uint64_t v17 = v25;
  uint64_t v18 = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v13)
  {
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v19 = *(void (**)(void *, uint64_t, uint64_t, unsigned char *, size_t *))(v13 + 8);
    uint64_t v20 = *(void *)(v13 + 16);
    uint64_t v21 = (void *)(v13 + (v20 >> 1));
    if (v20) {
      uint64_t v19 = *(void (**)(void *, uint64_t, uint64_t, unsigned char *, size_t *))(*v21 + v19);
    }
    *(void *)CFTypeRef cf = v17;
    *(void *)&cf[8] = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    size_t length = 0;
    uint64_t v28 = (std::__shared_weak_count *)v6;
    v19(v21, v15, v16, cf, &length);
    if (v28) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v28);
    }
    if (*(void *)&cf[8]) {
      std::__shared_weak_count::__release_shared[abi:nn180100](*(std::__shared_weak_count **)&cf[8]);
    }
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v18);
    }
  }
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  if (v26) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v26);
  }
}

void sub_18426D1CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, CFTypeRef cf, uint64_t a16)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_32c41_ZTSNSt3__110shared_ptrIN3PAC8PACQueryEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c41_ZTSNSt3__110shared_ptrIN3PAC8PACQueryEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void CFHTTPCookieStorageFlushCookieStores(void)
{
}

void sub_18426D3F4(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t RetainableTypedDict<__CFDictionary const*,PrivateHTTPCookieStorage *>::_visit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t ___ZL36CFHTTPCookieStorageFlushCookieStoresv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  (*(void (**)(void *))(*a3 + 40))(a3);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZL36CFHTTPCookieStorageFlushCookieStoresv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e5_v8__0l;
  _OWORD v6[4] = a3;
  uint64_t v4 = a3[4];
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  uint64_t result = (*(uint64_t (**)(void *, uint64_t, void *))(*a3 + 160))(a3, 1, v6);
  if (v4) {
    return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  }
  return result;
}

void sub_18426D518(_Unwind_Exception *exception_object)
{
  if (v1) {
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL36CFHTTPCookieStorageFlushCookieStoresv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

void RetainableTypedDict<__CFDictionary const*,PrivateHTTPCookieStorage *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA02F0;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<__CFDictionary const*,PrivateHTTPCookieStorage *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA02F0;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void *_CFHTTPCookieStorageCreateInMemory(__CFAllocator *a1, OpaqueCFHTTPCookieStorage *a2, uint64_t a3)
{
  if (a3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)int v5 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "filter callback no longer supported in this SPI; you should use _CookieStorageCreateInMemory instead anyway.",
      v5,
      2u);
  }
  return _CookieStorageCreateInMemory(a1, a2);
}

char *_CFHTTPCookieStorageCreateWithProperties(const __CFAllocator *a1, const __CFDictionary *a2)
{
  return _CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(a1, a2, 1);
}

void CFHTTPCookieStorageSetCookie(void *a1, OpaqueCFHTTPCookie *a2)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    [a1 setCookie:a2];
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    uint64_t v4 = (PrivateHTTPCookieStorage *)a1[4];
    if (v4) {
      int CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v4);
    }
    else {
      int CookieAcceptPolicy = 2;
    }
    HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v6, 0, 0, 0, CookieAcceptPolicy, 2, 0, 0);
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    HTTPCookieStorage::setCookie((HTTPCookieStorage *)(a1 + 2), a2, (const HTTPCookieStoragePolicy *)v6, 0, 1);
    HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v6);
  }
}

void sub_18426D7C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void CFHTTPCookieStorageSetCookies(void *a1, const __CFArray *a2, const void *a3, const void *a4)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    [a1 setCookies:a2 forURL:a3 mainDocumentURL:a4];
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    xpc_connection_t v8 = (PrivateHTTPCookieStorage *)a1[4];
    if (v8) {
      int CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v8);
    }
    else {
      int CookieAcceptPolicy = 2;
    }
    HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v10, a3, a4, 0, CookieAcceptPolicy, 2, 0, 0);
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    HTTPCookieStorage::setCookiesWithPolicy((HTTPCookieStorage *)(a1 + 2), a2, (const HTTPCookieStoragePolicy *)v10);
    HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v10);
  }
}

void sub_18426D920(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void CFHTTPCookieStorageDeleteAllCookies(char *a1)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    uint64_t v2 = [MEMORY[0x1E4F1C9C8] distantPast];
    [a1 removeCookiesSinceDate:v2];
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    if (a1) {
      unint64_t v3 = a1 + 16;
    }
    else {
      unint64_t v3 = 0;
    }
    uint64_t v4 = (void *)*((void *)v3 + 2);
    uint64_t v5 = v4[4];
    if (v5) {
      pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
    }
    (*(void (**)(void *))(*v4 + 136))(v4);
    if (v5) {
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
    }
    HTTPCookieStorage::notifyObserversOfChanges((HTTPCookieStorage *)v3);
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 30);
    if (*((void *)v3 + 10))
    {
      uint64_t v6 = *((void *)v3 + 14);
      if (v6)
      {
        uint64_t v7 = *((void *)v3 + 12);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = ___ZN17HTTPCookieStorage16deleteAllCookiesEv_block_invoke;
        CFHostClientContext block[3] = &unk_1E5257FD8;
        block[4] = v6;
        dispatch_async(v7, block);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 30);
  }
}

void sub_18426DACC(_Unwind_Exception *exception_object)
{
  if (v1) {
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void _CFHTTPCookieStorageSetCookiesWithResponseHeaderFields(char *cf, __CFURL *a2, __CFDictionary *a3, __CFURL *a4, uint64_t a5)
{
  if (a4 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CoreMedia should be the only caller; they pass NULL here",
      buf,
      2u);
    if (!a5) {
      goto LABEL_6;
    }
  }
  else if (!a5)
  {
    goto LABEL_6;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFStringRef v10 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CoreMedia should be the only caller; they pass kCFHTTPCookieStorageAcceptPolicyAlways here",
      v10,
      2u);
  }
LABEL_6:
  older_spi_CFHTTPCookieStorageSetCookiesWithResponseHeaderFields(cf, a2, a3, a4, a5);
}

void older_spi_CFHTTPCookieStorageSetCookiesWithResponseHeaderFields(char *cf, const __CFURL *a2, const __CFDictionary *a3, const __CFURL *a4, uint64_t a5)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    CFAllocatorRef v10 = CFGetAllocator(cf);
    CFArrayRef v11 = CFHTTPCookieCreateWithResponseHeaderFields(v10, a3, a2);
    if (!v11) {
      return;
    }
    CFArrayRef v12 = v11;
    if (CFArrayGetCount(v11) >= 1)
    {
      uint64_t v16 = @"HTTPCookiePolicyPropertyCookieAcceptPolicy";
      v17[0] = [NSNumber numberWithInt:a5];
      objc_msgSend(cf, "_setCookies:forURL:mainDocumentURL:policyProperties:", v12, a2, a4, objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v17, &v16, 1));
    }
    goto LABEL_14;
  }
  if (cf)
  {
    if (a2)
    {
      CFAllocatorRef v13 = CFGetAllocator(cf);
      CFArrayRef v14 = CFHTTPCookieCreateWithResponseHeaderFields(v13, a3, a2);
      if (v14)
      {
        CFArrayRef v12 = v14;
        if (CFArrayGetCount(v14) >= 1)
        {
          HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v15, a2, a4, 0, a5, 1, 0, 0);
          if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
            dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
          }
          HTTPCookieStorage::setCookiesWithPolicy((HTTPCookieStorage *)(cf + 16), v12, (const HTTPCookieStoragePolicy *)v15);
          HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v15);
        }
LABEL_14:
        CFRelease(v12);
      }
    }
  }
}

void sub_18426DD98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void CFHTTPCookieStorageAddObserver()
{
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_11780(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

uint64_t SourceContext::perform(SourceContext *this, void *a2)
{
  return (*((uint64_t (**)(void, void))this + 1))(*(void *)this, *((void *)this + 2));
}

CFStringRef SourceContext::copyDescription(SourceContext *this, const void *a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"SourceContext{ %@ callback %p(%p) }", *(void *)this, *((void *)this + 1), *((void *)this + 2));
}

void SourceContext::release(CFTypeRef *this, const void *a2)
{
  CFRelease(*this);
  uint64_t v3 = (uint64_t)this[3] - 1;
  this[3] = (CFTypeRef)v3;
  if (!v3)
  {
    CFRelease(*this);
    JUMPOUT(0x18531B6D0);
  }
}

CFTypeRef *SourceContext::retain(CFTypeRef *this, const void *a2)
{
  this[3] = (char *)this[3] + 1;
  return this;
}

void _initObserverLock(void)
{
}

void sub_18426DF98(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void RetainableTypedDict<__CFArray const*,__CFRunLoopSource *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0430;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<__CFArray const*,__CFRunLoopSource *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0430;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void CFHTTPCookieStorageRemoveObserver()
{
}

__CFArray *CFHTTPCookieStorageCopyCookies(char *a1)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    uint64_t v2 = (void *)[a1 cookies];
    return (__CFArray *)v2;
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    if (a1) {
      uint64_t v4 = (HTTPCookieStorage *)(a1 + 16);
    }
    else {
      uint64_t v4 = 0;
    }
    return HTTPCookieStorage::copyCookiesMatching(v4, 0, 32, 0);
  }
}

CFArrayRef _CFHTTPCookieStorageCopyCookiesForURLWithMainDocumentURL(void *a1, const void *a2, const void *a3, const __CFURL *a4)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    uint64_t v13 = 0;
    CFArrayRef v14 = &v13;
    uint64_t v15 = 0x3052000000;
    uint64_t v16 = __Block_byref_object_copy__11786;
    uint64_t v17 = __Block_byref_object_dispose__11787;
    uint64_t v18 = 0;
    xpc_connection_t v8 = dispatch_semaphore_create(0);
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 3221225472;
    void v19[2] = ___CFHTTPCookieStorageCopyCookiesForURLWithMainDocumentURL_block_invoke;
    v19[3] = &unk_1E5255FB0;
    v19[4] = v8;
    v19[5] = &v13;
    [a1 _getCookiesForURL:a2 mainDocumentURL:a3 partition:0 completionHandler:v19];
    dispatch_semaphore_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
    CFArrayRef v9 = (const __CFArray *)v14[5];
    _Block_object_dispose(&v13, 8);
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    CFAllocatorRef v10 = (PrivateHTTPCookieStorage *)a1[4];
    if (v10) {
      int CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v10);
    }
    else {
      int CookieAcceptPolicy = 2;
    }
    HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)&v13, a2, a3, 0, CookieAcceptPolicy, 0, 0, 0);
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    CFArrayRef v9 = HTTPCookieStorage::copyCookiesForURLWithMainDocumentURL((HTTPCookieStorage *)(a1 + 2), (const HTTPCookieStoragePolicy *)&v13, a4);
    HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)&v13);
  }
  return v9;
}

void sub_18426E34C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__11786(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__11787(uint64_t a1)
{
}

CFArrayRef _CFHTTPCookieStorageCopyRequestHeaderFieldsForURL(const __CFAllocator *a1, void *a2, CFURLRef anURL)
{
  CFStringRef v6 = CFURLCopyScheme(anURL);
  if (v6)
  {
    CFStringRef v7 = v6;
    unsigned int v8 = 1;
    if (CFStringCompare(v6, (CFStringRef)&unk_1EC0A5D78, 1uLL)) {
      unsigned int v8 = CFStringCompare(v7, @"wss", 1uLL) == kCFCompareEqualTo;
    }
    CFRelease(v7);
  }
  else
  {
    unsigned int v8 = 0;
  }
  CFArrayRef result = CFHTTPCookieStorageCopyCookiesForURL(a2, anURL, v8);
  if (result)
  {
    CFArrayRef v10 = result;
    CFDictionaryRef v11 = CFHTTPCookieCopyRequestHeaderFields(a1, result);
    CFRelease(v10);
    return v11;
  }
  return result;
}

void CFHTTPCookieStorageDeleteCookie(char *a1, OpaqueCFHTTPCookie *a2)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    [a1 deleteCookie:a2];
  }
  else
  {
    uint64_t v4 = [(OpaqueCFHTTPCookie *)a2 _inner];
    uint64_t v5 = (CompactCookieHeader *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
    EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString(v5, 15, 0);
    if (EnumeratedString)
    {
      CFStringRef v7 = (const UInt8 *)EnumeratedString;
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      size_t v9 = strnlen(EnumeratedString, 0x400uLL);
      CFStringRef v10 = CFStringCreateWithBytes(v8, v7, v9, 0x8000100u, 0);
      HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v13, 0, 0, (uint64_t)v10, 0, 2, 0, 0);
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
      }
      if (a1) {
        CFDictionaryRef v11 = (HTTPCookieStorage *)(a1 + 16);
      }
      else {
        CFDictionaryRef v11 = 0;
      }
      HTTPCookieStorage::deleteCookie(v11, a2, (const HTTPCookieStoragePolicy *)v13);
      CFRelease(v10);
    }
    else
    {
      HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v13, 0, 0, 0, 0, 2, 0, 0);
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
      }
      if (a1) {
        CFArrayRef v12 = (HTTPCookieStorage *)(a1 + 16);
      }
      else {
        CFArrayRef v12 = 0;
      }
      HTTPCookieStorage::deleteCookie(v12, a2, (const HTTPCookieStoragePolicy *)v13);
    }
    HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v13);
  }
}

void sub_18426E680(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void CFHTTPCookieStorageUnscheduleFromRunLoop(uint64_t a1, CFRunLoopRef rl, CFRunLoopMode mode)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFStringRef v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)CFDictionaryRef v11 = 0;
      _os_log_error_impl(&dword_184085000, v6, OS_LOG_TYPE_ERROR, "CFHTTPCookieStorageUnscheduleFromRunLoop should no longer be called", v11, 2u);
    }
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    if (a1) {
      uint64_t v7 = a1 + 16;
    }
    else {
      uint64_t v7 = 0;
    }
    CFAllocatorRef v8 = *(__CFRunLoopTimer **)(v7 + 32);
    if (v8)
    {
      CFRunLoopRemoveTimer(rl, v8, mode);
      uint64_t v9 = *(void *)(v7 + 40) - 1;
      *(void *)(v7 + 40) = v9;
      if (!v9)
      {
        CFRunLoopTimerInvalidate(*(CFRunLoopTimerRef *)(v7 + 32));
        CFStringRef v10 = *(const void **)(v7 + 32);
        *(void *)(v7 + 32) = 0;
        if (v10)
        {
          CFRelease(v10);
        }
      }
    }
  }
}

void non-virtual thunk to'HTTPCookieStorage::~HTTPCookieStorage(HTTPCookieStorage *this)
{
}

{
  HTTPCookieStorage::~HTTPCookieStorage((HTTPCookieStorage *)((char *)this - 8));
}

CFStringRef HTTPCookieStorage::copyDebugDesc(HTTPCookieStorage *this)
{
  uint64_t v2 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 2) + 16))(*((void *)this + 2));
  CFStringRef v3 = CFObject::copyDebugDescHeader(this);
  CFAllocatorRef v4 = CFGetAllocator((char *)this - 16);
  CFStringRef v5 = CFStringCreateWithFormat(v4, 0, @"%@ { %@ }", v3, v2);
  if (v3) {
    CFRelease(v3);
  }
  if (v2) {
    CFRelease(v2);
  }
  return v5;
}

uint64_t HTTPCookieStorage::setCookie(HTTPCookieStorage *this, OpaqueCFHTTPCookie *a2, const HTTPCookieStoragePolicy *a3, const __CFArray *a4, int a5)
{
  uint64_t v10 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_5_11820, 3);
  if (v10)
  {
    CFDictionaryRef v11 = (DiagnosticLogging *)v10;
    if ((*(unsigned int (**)(uint64_t, const char *, HTTPCookieStorage *))(*(void *)v10 + 24))(v10, "HTTPCookieStorage::setCookie", this))
    {
      uint64_t v12 = [(OpaqueCFHTTPCookie *)a2 _inner];
      uint64_t v13 = (CompactCookieHeader *)(*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
      CFArrayRef v14 = v13;
      if (*(_DWORD *)v13 >= 0x14u
        && (uint64_t v15 = *((unsigned int *)v13 + 4), v15)
        && (uint64_t v16 = *(_DWORD *)v13, v16 > v15))
      {
        uint64_t v17 = (char *)v13 + v15;
        uint64_t v18 = (char *)v13 + v16;
        uint64_t v19 = v17;
        while (*v19)
        {
          if (++v19 >= v18) {
            goto LABEL_9;
          }
        }
      }
      else
      {
LABEL_9:
        uint64_t v17 = 0;
      }
      DiagnosticLogging::logPair(v11, "Cookie URL", v17);
      logCookie(v11, 0, v14);
      (*(void (**)(DiagnosticLogging *))(*(void *)v11 + 8))(v11);
    }
  }
  v38[0] = MEMORY[0x1E4F143A8];
  v38[1] = 3221225472;
  CFUUIDRef v39 = ___ZN17HTTPCookieStorage9setCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicyPK9__CFArrayh_block_invoke_2;
  CFStringRef v40 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v41 = 0;
  if (!a4)
  {
    uint64_t v20 = (void *)*((void *)a3 + 2);
    if (v20)
    {
      uint64_t v21 = (void *)[v20 scheme];
      if (!v21 || [v21 caseInsensitiveCompare:0x1EC0A5D40]) {
        goto LABEL_24;
      }
      a4 = HTTPCookieStorage::copyCookiesForURL(this, a3, 1u);
    }
  }
  if (!a4 || (CFIndex Count = CFArrayGetCount(a4), Count < 1))
  {
LABEL_24:
    uint64_t v26 = (void *)*((void *)this + 2);
    uint64_t v27 = [(OpaqueCFHTTPCookie *)a2 _inner];
    uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v27 + 16))(v27);
    uint64_t v29 = v26[4];
    if (v29) {
      pthread_mutex_lock((pthread_mutex_t *)(v29 + 8));
    }
    uint64_t v30 = (*(uint64_t (**)(void *, uint64_t, const HTTPCookieStoragePolicy *))(*v26 + 120))(v26, v28, a3);
    if (v29) {
      pthread_mutex_unlock((pthread_mutex_t *)(v29 + 8));
    }
    HTTPCookieStorage::notifyObserversOfChanges(this);
    os_unfair_lock_lock((os_unfair_lock_t)this + 30);
    if (a5)
    {
      if (*((void *)this + 13))
      {
        if (v30)
        {
          CFStringRef v31 = objc_msgSend(*((id *)this + 10), "objectForKeyedSubscript:", -[OpaqueCFHTTPCookie domain](a2, "domain"));
          if ([v31 count])
          {
            uint64_t v32 = *((void *)this + 13);
            uint64_t v33 = *((void *)this + 11);
            block[0] = MEMORY[0x1E4F143A8];
            block[1] = 3221225472;
            block[2] = ___ZN17HTTPCookieStorage9setCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicyPK9__CFArrayh_block_invoke_11;
            CFHostClientContext block[3] = &unk_1E52581A0;
            void block[5] = a2;
            void block[6] = v32;
            block[4] = v31;
            dispatch_async(v33, block);
          }
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 30);
    goto LABEL_34;
  }
  CFIndex v23 = 0;
  while (1)
  {
    CFDataRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a4, v23);
    if ([ValueAtIndex isSecure])
    {
      if (objc_msgSend((id)-[OpaqueCFHTTPCookie name](a2, "name"), "isEqualToString:", objc_msgSend(ValueAtIndex, "name")))
      {
        uint64_t v25 = [(OpaqueCFHTTPCookie *)a2 _storagePartition];
        if (v25 == [ValueAtIndex _storagePartition]
          || objc_msgSend((id)-[OpaqueCFHTTPCookie _storagePartition](a2, "_storagePartition"), "isEqualToString:", objc_msgSend(ValueAtIndex, "_storagePartition")))
        {
          break;
        }
      }
    }
    if (Count == ++v23) {
      goto LABEL_24;
    }
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFStringRef v35 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl(&dword_184085000, v35, OS_LOG_TYPE_DEBUG, "website http cookie not overwriting existing https cookie", buf, 2u);
  }
  uint64_t v30 = 0;
LABEL_34:
  v39((uint64_t)v38);
  return v30;
}

void sub_18426ECFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, void (*a20)(char *))
{
}

void ___ZN17HTTPCookieStorage9setCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicyPK9__CFArrayh_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void logCookie(DiagnosticLogging *a1, int a2, CompactCookieHeader *a3)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  CFStringRef v6 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
  if (*(_DWORD *)a3 >= 0xCu && (*((_DWORD *)a3 + 2) & 2) != 0)
  {
    CFDateRef v8 = 0;
  }
  else
  {
    double v7 = 0.0;
    if (*(_DWORD *)a3 >= 0x30u)
    {
      *(void *)__CFStringRef str = *((void *)a3 + 5);
      double v7 = floor(*(double *)__str);
    }
    CFDateRef v8 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7);
  }
  if (*(_DWORD *)a3 > 0x37u)
  {
    double v11 = *((double *)a3 + 6);
    *(double *)__CFStringRef str = v11;
    CFAllocatorRef v10 = *v6;
    if (floor(v11) == 0.0)
    {
      CFDateRef v9 = 0;
    }
    else
    {
      double v12 = 0.0;
      if (*(_DWORD *)a3 >= 0x38u)
      {
        *(double *)__CFStringRef str = v11;
        double v12 = floor(v11);
      }
      CFDateRef v9 = CFDateCreate(v10, v12);
    }
  }
  else
  {
    CFDateRef v9 = 0;
    CFAllocatorRef v10 = *v6;
  }
  v54[0] = &unk_1ECFA5A28;
  if (v10) {
    CFTypeRef v13 = CFRetain(v10);
  }
  else {
    CFTypeRef v13 = 0;
  }
  CFArrayRef v14 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  v54[1] = v13;
  if (*(_DWORD *)a3 >= 0x14u)
  {
    uint64_t v15 = *((unsigned int *)a3 + 4);
    if (v15 && (uint64_t v16 = *(_DWORD *)a3, v16 > v15))
    {
      CFArrayRef v14 = (char *)a3 + v15;
      uint64_t v17 = (char *)a3 + v16;
      uint64_t v18 = v14;
      while (*v18)
      {
        if (++v18 >= v17) {
          goto LABEL_23;
        }
      }
    }
    else
    {
LABEL_23:
      CFArrayRef v14 = 0;
    }
  }
  uint64_t v19 = autoString(v14);
  MutableDict = AutoDict::getMutableDict((AutoDict *)v54);
  if (v19) {
    CFDictionarySetValue(MutableDict, @"Domain", v19);
  }
  else {
    CFDictionaryRemoveValue(MutableDict, @"Domain");
  }
  EnumeratedString = (char *)CompactCookieHeader::getEnumeratedString(a3, 15, 0);
  CFErrorRef v22 = autoString(EnumeratedString);
  CFIndex v23 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v22) {
    CFDictionarySetValue(v23, @"Partition", v22);
  }
  else {
    CFDictionaryRemoveValue(v23, @"Partition");
  }
  if (*(_DWORD *)a3 >= 0x18u
    && (uint64_t v24 = *((unsigned int *)a3 + 5), v24)
    && (uint64_t v25 = *(_DWORD *)a3, v25 > v24))
  {
    uint64_t v26 = (char *)a3 + v24;
    uint64_t v27 = (char *)a3 + v25;
    uint64_t v28 = v26;
    while (*v28)
    {
      if (++v28 >= v27) {
        goto LABEL_36;
      }
    }
  }
  else
  {
LABEL_36:
    uint64_t v26 = 0;
  }
  uint64_t v29 = autoString(v26);
  uint64_t v30 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v29) {
    CFDictionarySetValue(v30, @"Name", v29);
  }
  else {
    CFDictionaryRemoveValue(v30, @"Name");
  }
  if (*(_DWORD *)a3 >= 0x1Cu
    && (uint64_t v31 = *((unsigned int *)a3 + 6), v31)
    && (uint64_t v32 = *(_DWORD *)a3, v32 > v31))
  {
    uint64_t v33 = (char *)a3 + v31;
    uint64_t v34 = (char *)a3 + v32;
    CFStringRef v35 = v33;
    while (*v35)
    {
      if (++v35 >= v34) {
        goto LABEL_46;
      }
    }
  }
  else
  {
LABEL_46:
    uint64_t v33 = 0;
  }
  CFRange v36 = autoString(v33);
  uint64_t v37 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v36) {
    CFDictionarySetValue(v37, @"Path", v36);
  }
  else {
    CFDictionaryRemoveValue(v37, @"Path");
  }
  if (__CFNCanLogSensitiveContent::onceToken != -1) {
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_38);
  }
  if (__CFNCanLogSensitiveContent::ok)
  {
    if (*(_DWORD *)a3 >= 0x20u
      && (uint64_t v38 = *((unsigned int *)a3 + 7), v38)
      && (uint64_t v39 = *(_DWORD *)a3, v39 > v38))
    {
      CFStringRef v40 = (char *)a3 + v38;
      uint64_t v41 = (char *)a3 + v39;
      char v42 = v40;
      while (*v42)
      {
        if (++v42 >= v41) {
          goto LABEL_59;
        }
      }
    }
    else
    {
LABEL_59:
      CFStringRef v40 = 0;
    }
    CFStringRef v43 = autoString(v40);
  }
  else
  {
    CFStringRef v43 = @"<redacted>";
  }
  CFStringRef v44 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v43) {
    CFDictionarySetValue(v44, @"Value", v43);
  }
  else {
    CFDictionaryRemoveValue(v44, @"Value");
  }
  if (*(_DWORD *)a3 >= 0xCu && (*((_DWORD *)a3 + 2) & 2) != 0) {
    uint64_t v45 = @"YES";
  }
  else {
    uint64_t v45 = @"NO";
  }
  CFTypeRef v46 = AutoDict::getMutableDict((AutoDict *)v54);
  CFDictionarySetValue(v46, @"Session", v45);
  if (*(_DWORD *)a3 >= 0xCu && (*((_DWORD *)a3 + 2) & 1) != 0) {
    size_t v47 = @"YES";
  }
  else {
    size_t v47 = @"NO";
  }
  CFStringRef v48 = AutoDict::getMutableDict((AutoDict *)v54);
  CFDictionarySetValue(v48, @"Secure", v47);
  if (*(_DWORD *)a3 >= 0xCu && (*((_DWORD *)a3 + 2) & 4) != 0) {
    uint64_t v49 = @"YES";
  }
  else {
    uint64_t v49 = @"NO";
  }
  uint64_t v50 = AutoDict::getMutableDict((AutoDict *)v54);
  CFDictionarySetValue(v50, @"HTTPOnly", v49);
  uint64_t v51 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v8) {
    CFDictionarySetValue(v51, @"Expires", v8);
  }
  else {
    CFDictionaryRemoveValue(v51, @"Expires");
  }
  int v52 = AutoDict::getMutableDict((AutoDict *)v54);
  if (v9) {
    CFDictionarySetValue(v52, @"Created", v9);
  }
  else {
    CFDictionaryRemoveValue(v52, @"Created");
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v53 = (AutoDict *)snprintf(__str, 0x100uLL, "Cookie_%d_%p", a2, a3);
  if (!v56 && !v55) {
    AutoDict::getEmptyDict(v53);
  }
  (*(void (**)(DiagnosticLogging *, char *))(*(void *)a1 + 96))(a1, __str);
  AutoDict::~AutoDict((AutoDict *)v54);
}

void sub_18426F2AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

void HTTPCookieStorage::notifyObserversOfChanges(HTTPCookieStorage *this)
{
  if (*((void *)this + 3))
  {
    CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
    CFSetRef Copy = CFSetCreateCopy(v2, *((CFSetRef *)this + 3));
    CFSetApplyFunction(Copy, (CFSetApplierFunction)_signalObservers, *((void **)this + 3));
    if (Copy) {
      CFRelease(Copy);
    }
  }
  CFAllocatorRef v4 = (__CFRunLoopTimer *)*((void *)this + 4);
  if (v4)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    double v6 = *((double *)this + 6);
    BOOL v7 = v6 + 10.0 < Current || v6 == 0.0;
    double v8 = 2.0;
    if (!v7) {
      double v8 = 10.0;
    }
    CFRunLoopTimerSetNextFireDate(v4, Current + v8);
  }
  else if (*((unsigned char *)this + 64))
  {
    *((unsigned char *)this + 64) = 0;
    CFDateRef v9 = +[NSURLConnection resourceLoaderRunLoop];
    HTTPCookieStorage::scheduleWithRunLoop(this, v9, (const __CFString *)*MEMORY[0x1E4F1D418]);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 30);
  if (*((void *)this + 7))
  {
    if (HTTPCookieStorage::notifyObserversOfChanges(void)::onceToken != -1) {
      dispatch_once(&HTTPCookieStorage::notifyObserversOfChanges(void)::onceToken, &__block_literal_global_29);
    }
    dispatch_async((dispatch_queue_t)HTTPCookieStorage::notifyObserversOfChanges(void)::notificaionQueue, *((dispatch_block_t *)this + 7));
  }

  os_unfair_lock_unlock((os_unfair_lock_t)this + 30);
}

uint64_t ___ZN17HTTPCookieStorage9setCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicyPK9__CFArrayh_block_invoke_11(void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  CFAllocatorRef v2 = (void *)a1[4];
  uint64_t result = [v2 countByEnumeratingWithState:&v9 objects:v14 count:16];
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)v10;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v10 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v9 + 1) + 8 * v6);
        uint64_t v8 = a1[6];
        uint64_t v13 = a1[5];
        (*(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 16))(v8, [MEMORY[0x1E4F1C978] arrayWithObjects:&v13 count:1], v7);
        ++v6;
      }
      while (v4 != v6);
      uint64_t result = [v2 countByEnumeratingWithState:&v9 objects:v14 count:16];
      uint64_t v4 = result;
    }
    while (result);
  }
  return result;
}

dispatch_queue_t ___ZN17HTTPCookieStorage24notifyObserversOfChangesEv_block_invoke()
{
  uint64_t v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v1 = dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_UTILITY, 0);
  dispatch_queue_t result = dispatch_queue_create("com.apple.NSHTTPCookieManagerNotification", v1);
  HTTPCookieStorage::notifyObserversOfChanges(void)::notificaionQueue = (uint64_t)result;
  return result;
}

uint64_t HTTPCookieStorage::_syncTimerFired(HTTPCookieStorage *this, char *cf, void *a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
  }
  if (cf) {
    uint64_t v4 = cf + 16;
  }
  else {
    uint64_t v4 = 0;
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN17HTTPCookieStorage15_syncTimerFiredEP16__CFRunLoopTimerPv_block_invoke;
  v6[3] = &__block_descriptor_40_e5_v8__0l;
  _OWORD v6[4] = cf;
  return HTTPCookieStorage::syncStorageWithCompletion((uint64_t)v4, 0, (uint64_t)v6);
}

void ___ZN17HTTPCookieStorage15_syncTimerFiredEP16__CFRunLoopTimerPv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void _signalObservers(__CFRunLoopSource *a1, __CFSet *a2)
{
  if (CFRunLoopSourceIsValid(a1))
  {
    CFRunLoopSourceSignal(a1);
  }
  else
  {
    CFSetRemoveValue(a2, a1);
  }
}

void domainAndPartitionsForLookup(uint64_t *a1, char *a2, const __CFString *a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  DomainAndPartition::DomainAndPartition(v18, a2, a3, a4, a5);
  unint64_t v12 = a1[1];
  if (v12 >= a1[2])
  {
    uint64_t v13 = std::vector<DomainAndPartition>::__emplace_back_slow_path<DomainAndPartition>(a1, (uint64_t)v18);
  }
  else
  {
    DomainAndPartition::DomainAndPartition(a1[1], (uint64_t)v18);
    uint64_t v13 = v12 + 320;
    a1[1] = v12 + 320;
  }
  a1[1] = v13;
  v18[0] = &unk_1ECF9F1A0;
  if (v20 && v20 != v19) {
    free(v20);
  }
  if (a3 && !a6)
  {
    if (CFStringCompare(a3, @"none", 0))
    {
      DomainAndPartition::DomainAndPartition(v18, a2, @"none", a4, a5);
      unint64_t v14 = a1[1];
      if (v14 >= a1[2])
      {
        uint64_t v15 = std::vector<DomainAndPartition>::__emplace_back_slow_path<DomainAndPartition>(a1, (uint64_t)v18);
      }
      else
      {
        DomainAndPartition::DomainAndPartition(a1[1], (uint64_t)v18);
        uint64_t v15 = v14 + 320;
        a1[1] = v14 + 320;
      }
      a1[1] = v15;
      v18[0] = &unk_1ECF9F1A0;
      if (v20)
      {
        if (v20 != v19) {
          free(v20);
        }
      }
    }
    v18[0] = &unk_1ECF9F1A0;
    DomainAndPartition::init(v18, a4, a5, a2);
    unint64_t v16 = a1[1];
    if (v16 >= a1[2])
    {
      uint64_t v17 = std::vector<DomainAndPartition>::__emplace_back_slow_path<DomainAndPartition>(a1, (uint64_t)v18);
    }
    else
    {
      DomainAndPartition::DomainAndPartition(a1[1], (uint64_t)v18);
      uint64_t v17 = v16 + 320;
      a1[1] = v16 + 320;
    }
    a1[1] = v17;
    v18[0] = &unk_1ECF9F1A0;
    if (v20)
    {
      if (v20 != v19) {
        free(v20);
      }
    }
  }
}

void sub_18426F8C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t *a45)
{
  a10 = &unk_1ECF9F1A0;
  if (a45)
  {
    if (a45 != &a13) {
      free(a45);
    }
  }
  std::vector<DomainAndPartition>::__destroy_vector::operator()[abi:nn180100]((void ***)&a10);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<DomainAndPartition>::__insert_with_size[abi:nn180100]<std::__wrap_iter<DomainAndPartition*>,std::__wrap_iter<DomainAndPartition*>>(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5 < 1) {
    return result;
  }
  uint64_t v6 = a3;
  uint64_t v7 = result;
  uint64_t v8 = *result;
  uint64_t v9 = (a2 - *result) / 320;
  uint64_t v10 = *result + 320 * v9;
  long long v11 = result + 2;
  uint64_t v12 = result[2];
  unint64_t v13 = result[1];
  if ((uint64_t)(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v12 - v13) >> 6)) >= a5)
  {
    uint64_t v39 = (a2 - *result) / 320;
    if ((uint64_t)(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v13 - v10) >> 6)) >= a5)
    {
      uint64_t v19 = a3 + 320 * a5;
      uint64_t v21 = result[1];
    }
    else
    {
      uint64_t v19 = a3 + ((uint64_t)(v13 - v10) >> 6 << 6);
      if (v19 == a4)
      {
        uint64_t v21 = result[1];
      }
      else
      {
        uint64_t v20 = 0;
        do
        {
          dispatch_queue_t result = (uint64_t *)DomainAndPartition::DomainAndPartition(v13 + v20, v19 + v20);
          v20 += 320;
        }
        while (v19 + v20 != a4);
        uint64_t v21 = v13 + v20;
      }
      v7[1] = v21;
      if ((uint64_t)(v13 - v10) < 1) {
        return result;
      }
    }
    uint64_t v32 = 5 * a5;
    unint64_t v33 = v21 - 320 * a5;
    uint64_t v34 = v21;
    if (v33 < v13)
    {
      uint64_t v34 = v21;
      do
      {
        dispatch_queue_t result = (uint64_t *)DomainAndPartition::DomainAndPartition(v34, v33);
        v33 += 320;
        v34 += 320;
      }
      while (v33 < v13);
    }
    uint64_t v35 = v10 + (v32 << 6);
    v7[1] = v34;
    if (v21 != v35)
    {
      CFRange v36 = (char *)(v21 - 312);
      uint64_t v37 = (v21 - v35) >> 6 << 6;
      do
      {
        dispatch_queue_t result = (uint64_t *)memcpy(v36, (const void *)(v8 + 320 * v39 - 312 + v37), 0x138uLL);
        v36 -= 320;
        v37 -= 320;
      }
      while (v37);
    }
    if (v19 != v6)
    {
      uint64_t v38 = (char *)(v8 + 320 * v39 + 8);
      do
      {
        dispatch_queue_t result = (uint64_t *)memcpy(v38, (const void *)(v6 + 8), 0x138uLL);
        v6 += 320;
        v38 += 320;
      }
      while (v6 != v19);
    }
  }
  else
  {
    unint64_t v14 = a5 - 0x3333333333333333 * ((uint64_t)(v13 - v8) >> 6);
    if (v14 > 0xCCCCCCCCCCCCCCLL) {
      abort();
    }
    unint64_t v15 = 0xCCCCCCCCCCCCCCCDLL * ((v12 - v8) >> 6);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x66666666666666) {
      unint64_t v16 = 0xCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v16 = v14;
    }
    CFStringRef v44 = v11;
    if (v16) {
      unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<DomainAndPartition>>(v16);
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v22 = v16 + 320 * v9;
    unint64_t v40 = v16;
    uint64_t v41 = v22;
    uint64_t v42 = v22;
    unint64_t v43 = v16 + 320 * v17;
    uint64_t v23 = 5 * a5;
    uint64_t v24 = v22 + 320 * a5;
    uint64_t v25 = v23 << 6;
    do
    {
      DomainAndPartition::DomainAndPartition(v22, v6);
      v22 += 320;
      v6 += 320;
      v25 -= 320;
    }
    while (v25);
    uint64_t v42 = v24;
    uint64_t v26 = v41;
    uint64_t v27 = *v7;
    if (*v7 != v10)
    {
      uint64_t v28 = v10;
      do
      {
        v28 -= 320;
        uint64_t v26 = DomainAndPartition::DomainAndPartition(v26 - 320, v28);
      }
      while (v28 != v27);
      uint64_t v24 = v42;
    }
    uint64_t v41 = v26;
    uint64_t v29 = v7[1];
    if (v29 != v10)
    {
      do
      {
        DomainAndPartition::DomainAndPartition(v24, v10);
        v10 += 320;
        v24 += 320;
      }
      while (v10 != v29);
      uint64_t v26 = v41;
      uint64_t v10 = v7[1];
    }
    uint64_t v30 = *v7;
    uint64_t *v7 = v26;
    v7[1] = v24;
    unint64_t v31 = v7[2];
    uint64_t v7[2] = v43;
    uint64_t v42 = v10;
    unint64_t v43 = v31;
    unint64_t v40 = v30;
    uint64_t v41 = v30;
    return (uint64_t *)std::__split_buffer<DomainAndPartition>::~__split_buffer((uint64_t)&v40);
  }
  return result;
}

void sub_18426FC78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

void std::vector<DomainAndPartition>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  CFAllocatorRef v2 = (void (***)(void))**a1;
  if (v2)
  {
    uint64_t v4 = (void (***)(void))v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 40;
      uint64_t v7 = v4 - 40;
      do
      {
        (**v7)(v7);
        v6 -= 40;
        BOOL v8 = v7 == v2;
        v7 -= 40;
      }
      while (!v8);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void logCookieArray(uint64_t a1, uint64_t a2)
{
  v17[0] = 0;
  v17[1] = v17;
  void v17[2] = 0x2020000000;
  v17[3] = 0;
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  uint64_t v13 = ___ZL14logCookieArrayP17DiagnosticLoggingPK18CompactCookieArray_block_invoke;
  unint64_t v14 = &unk_1E5256018;
  unint64_t v15 = v17;
  uint64_t v16 = a1;
  CFDataRef v2 = *(const __CFData **)(a2 + 16);
  if (v2)
  {
    BytePtr = CFDataGetBytePtr(v2);
    if (BytePtr)
    {
      unint64_t v5 = *((unsigned int *)BytePtr + 1);
      char v18 = 0;
      if (v5)
      {
        uint64_t v6 = 2;
        do
        {
          CFDataRef v7 = *(const __CFData **)(a2 + 16);
          if (v7 && CFDataGetBytePtr(v7))
          {
            BOOL v8 = CFDataGetBytePtr(*(CFDataRef *)(a2 + 16));
            uint64_t v9 = *(const UInt8 **)(a2 + 16);
            uint64_t v10 = *(unsigned int *)&v8[4 * v6];
            if (v9) {
              uint64_t v9 = CFDataGetBytePtr((CFDataRef)v9);
            }
            long long v11 = &v9[v10];
          }
          else
          {
            long long v11 = 0;
          }
          ((void (*)(void *, const UInt8 *, char *))v13)(v12, v11, &v18);
          if (v6 - 1 >= v5) {
            break;
          }
          ++v6;
        }
        while (!v18);
      }
    }
  }
  _Block_object_dispose(v17, 8);
}

void sub_18426FE98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZL14logCookieArrayP17DiagnosticLoggingPK18CompactCookieArray_block_invoke(uint64_t a1, CompactCookieHeader *a2)
{
}

uint64_t ___ZN17HTTPCookieStorage17copyCookiesForURLERK23HTTPCookieStoragePolicyh_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  CFDataRef v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1168;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t _CookieSortForCopy(void *a1, void *a2, void *a3)
{
  uint64_t v5 = objc_msgSend(a1, "_inner", a3);
  uint64_t v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  if (*v6 >= 0x1C && (v7 = v6[6], v7) && (uint64_t v8 = *v6, v8 > v7))
  {
    uint64_t v9 = (char *)v6 + v7;
    uint64_t v10 = (char *)v6 + v8;
    long long v11 = v9;
    while (*v11)
    {
      if (++v11 >= v10) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    uint64_t v9 = 0;
  }
  uint64_t v12 = [a2 _inner];
  uint64_t v13 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
  if (*v13 >= 0x1C)
  {
    uint64_t v14 = v13[6];
    if (v14)
    {
      uint64_t v15 = *v13;
      if (v15 > v14)
      {
        uint64_t v16 = (char *)v13 + v14;
        uint64_t v17 = (char *)v13 + v15;
        char v18 = v16;
        while (*v18)
        {
          if (++v18 >= v17) {
            goto LABEL_14;
          }
        }
        int v19 = strlen(v16);
        if (!v9) {
          goto LABEL_17;
        }
LABEL_15:
        int v20 = strlen(v9);
        goto LABEL_18;
      }
    }
  }
LABEL_14:
  int v19 = 0;
  if (v9) {
    goto LABEL_15;
  }
LABEL_17:
  int v20 = 0;
LABEL_18:
  if (v19 < v20) {
    return -1;
  }
  if (v19 != v20) {
    return 1;
  }
  uint64_t v22 = [a2 _inner];
  uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
  double v24 = 0.0;
  double v25 = 0.0;
  if (*(_DWORD *)v23 >= 0x38u) {
    double v25 = floor(*(double *)(v23 + 48));
  }
  uint64_t v26 = [a1 _inner];
  uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 16))(v26);
  if (*(_DWORD *)v27 >= 0x38u) {
    double v24 = floor(*(double *)(v27 + 48));
  }
  if (v25 - v24 < 0.0) {
    return -1;
  }
  else {
    return v25 - v24 > 0.0;
  }
}

BOOL std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_3,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_3>,BOOL ()(CompactCookieHeader const*)>::operator()(uint64_t a1, const HTTPCookieStoragePolicy **a2, const CompactCookieHeader *a3)
{
  return HTTPCookieStorage::shouldIncludeCookieForPolicy(*(HTTPCookieStorage **)(a1 + 16), *a2, a3);
}

BOOL HTTPCookieStorage::shouldIncludeCookieForPolicy(HTTPCookieStorage *this, const HTTPCookieStoragePolicy *a2, const CompactCookieHeader *a3)
{
  id v4 = [[NSHTTPCookie alloc] _initWithHeader:a2];
  uint64_t v5 = v4;
  uint64_t v20 = MEMORY[0x1E4F143A8];
  uint64_t v21 = 3221225472;
  uint64_t v22 = ___ZN17HTTPCookieStorage28shouldIncludeCookieForPolicyERK23HTTPCookieStoragePolicyPK19CompactCookieHeader_block_invoke;
  uint64_t v23 = &unk_1E5258228;
  id v24 = v4;
  if (*((unsigned char *)this + 98)
    && (uint64_t v6 = objc_msgSend(v4, "_inner", v20, v21),
        uint64_t v7 = (CompactCookieHeader *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6),
        !CompactCookieHeader::getEnumeratedString(v7, 15, 0)))
  {
    BOOL v14 = 0;
  }
  else
  {
    CFDictionaryRef v8 = (const __CFDictionary *)*((void *)this + 10);
    if (v8 && CFDictionaryGetValue(v8, @"_kCFHTTPCookiePolicyPropertySiteForCookies"))
    {
      uint64_t v9 = [v5 _inner];
      uint64_t v10 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
      if (*v10 >= 0xCu) {
        char v13 = v10[2] & 0x7F;
      }
      else {
        char v13 = 0;
      }
      if ((v13 & 0x10) != 0) {
        int v15 = 3;
      }
      else {
        int v15 = 1;
      }
      if ((v13 & 8) != 0) {
        int v16 = v15;
      }
      else {
        int v16 = ((v13 & 0x10) >> 3) ^ 2;
      }
      BOOL v14 = 1;
      if (v16 != 1)
      {
        if (v16 != 3) {
          goto LABEL_24;
        }
        goto LABEL_23;
      }
      int valuePtr = 1;
      CFDictionaryRef v17 = (const __CFDictionary *)*((void *)this + 10);
      if (v17
        && (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v17, @"_kCFHTTPCookiePolicyPropertyIsSafeRequest")) != 0
        && (CFNumberGetValue(Value, kCFNumberIntType, &valuePtr), !(_BYTE)valuePtr)
        || !HTTPCookieStoragePolicy::isTopLevelNavigation(*((HTTPCookieStoragePolicy **)this + 10)))
      {
LABEL_23:
        BOOL v14 = HTTPCookieStoragePolicy::isURLInSiteForCookie(this, v11, v12) != 0;
      }
    }
    else
    {
      BOOL v14 = 1;
    }
  }
LABEL_24:
  v22((uint64_t)&v20);
  return v14;
}

void sub_184270348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void (*a11)(uint64_t *))
{
}

void ___ZN17HTTPCookieStorage28shouldIncludeCookieForPolicyERK23HTTPCookieStoragePolicyPK19CompactCookieHeader_block_invoke(uint64_t a1)
{
}

__n128 std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_3,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_3>,BOOL ()(CompactCookieHeader const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFAC528;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_3,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_3>,BOOL ()(CompactCookieHeader const*)>::__clone(uint64_t a1)
{
  CFDataRef v2 = (char *)operator new(0x18uLL);
  *(void *)CFDataRef v2 = &unk_1ECFAC528;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_3,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_3>,BOOL ()(CompactCookieHeader const*)>::~__func()
{
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<DomainAndPartition>>(unint64_t a1)
{
  if (a1 >= 0xCCCCCCCCCCCCCDLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(320 * a1);
}

uint64_t std::__split_buffer<DomainAndPartition>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + CFRelease((char *)this - 16) = i - 320;
    (**(void (***)(void))(i - 320))();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::vector<DomainAndPartition>::__emplace_back_slow_path<DomainAndPartition>(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 6);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xCCCCCCCCCCCCCCLL) {
    abort();
  }
  uint64_t v6 = a1 + 2;
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 6) > v3) {
    unint64_t v3 = 0x999999999999999ALL * ((a1[2] - *a1) >> 6);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 6) >= 0x66666666666666) {
    unint64_t v7 = 0xCCCCCCCCCCCCCCLL;
  }
  else {
    unint64_t v7 = v3;
  }
  int v19 = v6;
  if (v7) {
    unint64_t v7 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<DomainAndPartition>>(v7);
  }
  else {
    uint64_t v8 = 0;
  }
  unint64_t v16 = v7;
  v17.i64[0] = v7 + 320 * v2;
  unint64_t v18 = v7 + 320 * v8;
  DomainAndPartition::DomainAndPartition(v17.i64[0], a2);
  uint64_t v9 = v17.i64[0];
  uint64_t v10 = v17.i64[0] + 320;
  v17.i64[1] = v17.i64[0] + 320;
  uint64_t v12 = *a1;
  unint64_t v11 = a1[1];
  if (v11 == *a1)
  {
    int64x2_t v13 = vdupq_n_s64(v11);
  }
  else
  {
    do
    {
      v11 -= 320;
      uint64_t v9 = DomainAndPartition::DomainAndPartition(v9 - 320, v11);
    }
    while (v11 != v12);
    int64x2_t v13 = *(int64x2_t *)a1;
    uint64_t v10 = v17.i64[1];
  }
  *a1 = v9;
  a1[1] = v10;
  int64x2_t v17 = v13;
  unint64_t v14 = a1[2];
  a1[2] = v18;
  unint64_t v18 = v14;
  unint64_t v16 = v13.i64[0];
  std::__split_buffer<DomainAndPartition>::~__split_buffer((uint64_t)&v16);
  return v10;
}

void sub_1842705E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<DomainAndPartition>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_2,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_2>,BOOL ()(CompactCookieHeader const*)>::operator()(uint64_t a1, const HTTPCookieStoragePolicy **a2, const CompactCookieHeader *a3)
{
  return HTTPCookieStorage::shouldIncludeCookieForPolicy(*(HTTPCookieStorage **)(a1 + 16), *a2, a3);
}

__n128 std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_2,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_2>,BOOL ()(CompactCookieHeader const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFAC4E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_2,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_2>,BOOL ()(CompactCookieHeader const*)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1ECFAC4E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_2,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_2>,BOOL ()(CompactCookieHeader const*)>::~__func()
{
}

BOOL std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_1,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_1>,BOOL ()(CompactCookieHeader const*)>::operator()(uint64_t a1, const HTTPCookieStoragePolicy **a2, const CompactCookieHeader *a3)
{
  return HTTPCookieStorage::shouldIncludeCookieForPolicy(*(HTTPCookieStorage **)(a1 + 16), *a2, a3);
}

__n128 std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_1,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_1>,BOOL ()(CompactCookieHeader const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFAC498;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_1,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_1>,BOOL ()(CompactCookieHeader const*)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1ECFAC498;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_1,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_1>,BOOL ()(CompactCookieHeader const*)>::~__func()
{
}

BOOL std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_0,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_0>,BOOL ()(CompactCookieHeader const*)>::operator()(uint64_t a1, const HTTPCookieStoragePolicy **a2, const CompactCookieHeader *a3)
{
  return HTTPCookieStorage::shouldIncludeCookieForPolicy(*(HTTPCookieStorage **)(a1 + 16), *a2, a3);
}

__n128 std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_0,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_0>,BOOL ()(CompactCookieHeader const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFAC450;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_0,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_0>,BOOL ()(CompactCookieHeader const*)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1ECFAC450;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_0,std::allocator<HTTPCookieStorage::copyCookiesForURL(HTTPCookieStoragePolicy const&,unsigned char)::$_0>,BOOL ()(CompactCookieHeader const*)>::~__func()
{
}

__CFString *autoString(char *cStr)
{
  if (!cStr) {
    return @"NULL";
  }
  CFStringRef v1 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x8000100u);

  return (__CFString *)CFAutorelease(v1);
}

uint64_t ___ZN17HTTPCookieStorage9setCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicyPK9__CFArrayh_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  unint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 250;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void HTTPCookieStorage::setCookiesWithPolicy(HTTPCookieStorage *this, const __CFArray *a2, const HTTPCookieStoragePolicy *a3)
{
  uint64_t v186 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_13_11900, 3);
  if (v5)
  {
    uint64_t v7 = v5;
    if ((*(unsigned int (**)(uint64_t, const char *, HTTPCookieStorage *))(*(void *)v5 + 24))(v5, "HTTPCookieStorage::setCookiesWithPolicies", this))
    {
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      int v9 = *((_DWORD *)a3 + 10);
      if (v9 == -1)
      {
        int v9 = 3;
        *((_DWORD *)a3 + 10) = 3;
      }
      CFDictionaryRef v175 = off_1ECF9A530;
      v178[0] = 0;
      CFStringRef v176 = CFStringCreateWithCString(v8, "AcceptPolicy", 0x8000100u);
      unint64_t v177 = 0;
      CFStringRef v10 = CFStringCreateWithFormat(v8, 0, @"%ld", v9);
      (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(void *)v7 + 64))(v7, v176, v10);
      if (v10) {
        CFRelease(v10);
      }
      AutoString::~AutoString((AutoString *)&v175);
      (*(void (**)(uint64_t, const char *, void))(*(void *)v7 + 40))(v7, "URL", *((void *)a3 + 2));
      (*(void (**)(uint64_t, const char *, void))(*(void *)v7 + 40))(v7, "MainDocumentURL", *((void *)a3 + 3));
      if (!a2) {
        goto LABEL_14;
      }
      if (CFArrayGetCount(a2))
      {
        CompactCookieArray = CompactCookieArray::makeCompactCookieArray((CompactCookieArray *)v8, a2, v11);
        if (CompactCookieArray)
        {
          logCookieArray(v7, (uint64_t)CompactCookieArray);
          CFRelease((char *)CompactCookieArray - 16);
LABEL_14:
          (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
          goto LABEL_15;
        }
        CFDictionaryRef v175 = off_1ECF9A530;
        CFStringRef v14 = CFStringCreateWithCString(v8, "Cookies", 0x8000100u);
        v178[0] = 0;
        CFStringRef v176 = v14;
        unint64_t v177 = 0;
        unint64_t v169 = off_1ECF9A530;
        uint64_t v172 = 0;
        CFStringRef v170 = CFStringCreateWithCString(v8, "corrupt?", 0x8000100u);
        uint64_t v171 = 0;
        (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(void *)v7 + 64))(v7, v176, v170);
      }
      else
      {
        CFDictionaryRef v175 = off_1ECF9A530;
        CFStringRef v13 = CFStringCreateWithCString(v8, "Cookies", 0x8000100u);
        v178[0] = 0;
        CFStringRef v176 = v13;
        unint64_t v177 = 0;
        unint64_t v169 = off_1ECF9A530;
        uint64_t v172 = 0;
        CFStringRef v170 = CFStringCreateWithCString(v8, "empty cookie array", 0x8000100u);
        uint64_t v171 = 0;
        (*(void (**)(uint64_t, CFStringRef, CFStringRef))(*(void *)v7 + 64))(v7, v176, v170);
      }
      AutoString::~AutoString((AutoString *)&v169);
      AutoString::~AutoString((AutoString *)&v175);
      goto LABEL_14;
    }
  }
LABEL_15:
  BOOL v15 = 0;
  switch(*((_DWORD *)a3 + 10))
  {
    case 0xFFFFFFFF:
      *((_DWORD *)a3 + 10) = 3;
      goto LABEL_67;
    case 1:
      BOOL v15 = 1;
      goto LABEL_71;
    case 2:
      CFStringRef v16 = CFURLCopyHostName(*((CFURLRef *)a3 + 2));
      if (!v16) {
        goto LABEL_67;
      }
      CFTypeRef cf = (char *)this - 16;
      CFAllocatorRef v17 = CFGetAllocator((char *)this - 16);
      CFStringRef theString = CFStringCreateMutableCopy(v17, 0, v16);
      CFRelease(v16);
      if (!theString) {
        goto LABEL_67;
      }
      CFStringLowercase(theString, 0);
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
      UInt8 buffer = (char *)CStringPtr;
      if (!CStringPtr)
      {
        CFIndex Length = CFStringGetLength(theString);
        CFAllocatorRef v19 = CFGetAllocator(cf);
        UInt8 buffer = (char *)CFAllocatorAllocate(v19, ++Length, 0);
        CFStringGetCString(theString, buffer, Length, 0x600u);
        if (!buffer)
        {
          CFRelease(theString);
          int v35 = 0;
          UInt8 buffer = 0;
          goto LABEL_65;
        }
      }
      double Current = CFAbsoluteTimeGetCurrent();
      uint64_t v21 = buffer;
      break;
    case 3:
      goto LABEL_67;
    default:
      goto LABEL_71;
  }
  do
  {
    CFDictionaryRef v175 = (void (**)(AutoString *__hidden))&unk_1ECF9F1A0;
    DomainAndPartition::init(&v175, 1, *(uint64_t *)&Current, v21);
    uint64_t v22 = (void *)*((void *)this + 2);
    DomainAndPartition::DomainAndPartition((uint64_t)&v169, (uint64_t)&v175);
    uint64_t v23 = PrivateHTTPCookieStorage::copyDomainCookieArray(v22, (uint64_t)&v169, 1);
    unint64_t v169 = (void (**)(AutoString *__hidden))&unk_1ECF9F1A0;
    if (v174 && v174 != &v172) {
      free(v174);
    }
    if (v23)
    {
      unint64_t v24 = 0;
      while (1)
      {
        CFDataRef v25 = *(const __CFData **)(v23 + 16);
        if (v25 && (BytePtr = CFDataGetBytePtr(v25)) != 0) {
          unint64_t v27 = *((unsigned int *)BytePtr + 1);
        }
        else {
          unint64_t v27 = 0;
        }
        BOOL v28 = v24 >= v27;
        if (v24 >= v27) {
          break;
        }
        CFDataRef v29 = *(const __CFData **)(v23 + 16);
        if (v29 && CFDataGetBytePtr(v29))
        {
          uint64_t v30 = CFDataGetBytePtr(*(CFDataRef *)(v23 + 16));
          unint64_t v31 = *(const UInt8 **)(v23 + 16);
          uint64_t v32 = *(unsigned int *)&v30[4 * v24 + 8];
          if (v31) {
            unint64_t v31 = CFDataGetBytePtr((CFDataRef)v31);
          }
          unint64_t v33 = &v31[v32];
        }
        else
        {
          unint64_t v33 = 0;
        }
        if (*(_DWORD *)v33 < 0xCu || (*((_DWORD *)v33 + 2) & 2) == 0)
        {
          double v34 = 0.0;
          if (*(_DWORD *)v33 >= 0x30u)
          {
            v163[0] = *((double *)v33 + 5);
            double v34 = floor(v163[0]);
          }
          ++v24;
          if (Current >= v34) {
            continue;
          }
        }
        int v35 = 1;
        goto LABEL_53;
      }
      if (*v21 == 46) {
        uint64_t v37 = v21 + 1;
      }
      else {
        uint64_t v37 = v21;
      }
      uint64_t v21 = strchr(v37, 46);
      int v35 = 0;
LABEL_53:
      CFRelease((CFTypeRef)(v23 - 16));
    }
    else
    {
      if (*v21 == 46) {
        CFRange v36 = v21 + 1;
      }
      else {
        CFRange v36 = v21;
      }
      uint64_t v21 = strchr(v36, 46);
      int v35 = 0;
      BOOL v28 = 1;
    }
    CFDictionaryRef v175 = (void (**)(AutoString *__hidden))&unk_1ECF9F1A0;
    if (v179 && v179 != v178) {
      free(v179);
    }
    if (v21) {
      BOOL v38 = v28;
    }
    else {
      BOOL v38 = 0;
    }
  }
  while (v38 && *v21);
  CFRelease(theString);
  if (CStringPtr) {
    goto LABEL_66;
  }
LABEL_65:
  CFAllocatorRef v39 = CFGetAllocator(cf);
  CFAllocatorDeallocate(v39, buffer);
LABEL_66:
  if (v35) {
    goto LABEL_69;
  }
LABEL_67:
  CFURLRef v40 = (const __CFURL *)*((void *)a3 + 3);
  if (!v40 || HTTPCookieStorage::isURLInMainDocumentDomain(*((HTTPCookieStorage **)a3 + 2), v40, v6))
  {
LABEL_69:
    BOOL v15 = 0;
    goto LABEL_71;
  }
  BOOL v15 = *((void *)a3 + 4) == 0;
LABEL_71:
  obuint64_t j = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  if (!v15)
  {
    uint64_t v41 = (void *)*((void *)a3 + 2);
    if (v41
      && (uint64_t v42 = (void *)[v41 scheme]) != 0
      && ![v42 caseInsensitiveCompare:0x1EC0A5D40])
    {
      CFArrayRef v132 = HTTPCookieStorage::copyCookiesForURL(this, a3, 1u);
      CFArrayRef v133 = v132;
      if (v132) {
        CFIndex Count = CFArrayGetCount(v132);
      }
      else {
        CFIndex Count = 0;
      }
      v159[0] = MEMORY[0x1E4F143A8];
      v159[1] = 3221225472;
      CFStringRef v160 = ___ZN17HTTPCookieStorage20setCookiesWithPolicyEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke_2;
      CFArrayRef v161 = &__block_descriptor_40_e5_v8__0l;
      CFArrayRef v162 = v133;
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFDataRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v133, i);
          if ([ValueAtIndex isSecure]) {
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
        }
      }
      v160((uint64_t)v159);
    }
    else
    {
      CFMutableDictionaryRef Mutable = 0;
    }
    CFGetAllocator((char *)this - 16);
    CookieHostName::CookieHostName((CookieHostName *)&v175, *((CFURLRef *)a3 + 2), v44);
    if (v177 >= 2)
    {
      CFStringRef v45 = v176;
      CFContainerEnumeratorBase::setup((unint64_t)&v169, a2, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
      uint64_t v173 = 0;
      if ((uint64_t)v170 >= 1)
      {
        uint64_t v46 = 0;
        theStringa = (CookieUtils *)((char *)&v45->isa + 1);
        do
        {
          uint64_t v173 = v46 + 1;
          size_t v47 = *(OpaqueCFHTTPCookie **)(v171 + 8 * v46);
          uint64_t v48 = [(OpaqueCFHTTPCookie *)v47 _inner];
          uint64_t v49 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v48 + 16))(v48);
          if (*v49 >= 0x18
            && (uint64_t v50 = v49[5], v50)
            && (uint64_t v51 = (char *)v49 + v50, v52 = *v49, v53 = (char *)v49 + v50, v52 > v50))
          {
            while (*v53)
            {
              if (++v53 >= (unsigned char *)v49 + v52) {
                goto LABEL_84;
              }
            }
          }
          else
          {
LABEL_84:
            uint64_t v51 = 0;
          }
          unsigned int v54 = *v51;
          if (*v51)
          {
            uint64_t v55 = v51 + 1;
            do
            {
              BOOL v56 = v54 >= 0x20 || v54 == 9;
              BOOL v57 = !v56;
              if (v54 == 127 || v57) {
                goto LABEL_162;
              }
              unsigned int v58 = *v55++;
              unsigned int v54 = v58;
            }
            while (v58);
          }
          CFURLRef v59 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v48 + 16))(v48);
          if (*v59 >= 0x20
            && (uint64_t v60 = v59[7], v60)
            && (v61 = (char *)v59 + v60, uint64_t v62 = *v59, v63 = (char *)v59 + v60, v62 > v60))
          {
            while (*v63)
            {
              if (++v63 >= (unsigned char *)v59 + v62) {
                goto LABEL_101;
              }
            }
          }
          else
          {
LABEL_101:
            CFAllocatorRef v61 = 0;
          }
          unsigned int v64 = *v61;
          if (*v61)
          {
            CFStringRef v65 = v61 + 1;
            do
            {
              BOOL v66 = v64 >= 0x20 || v64 == 9;
              BOOL v67 = !v66;
              if (v64 == 127 || v67) {
                goto LABEL_162;
              }
              unsigned int v68 = *v65++;
              unsigned int v64 = v68;
            }
            while (v68);
          }
          if (!CFHTTPCookie_domainMatches(v47, *((const __CFURL **)a3 + 2))) {
            goto LABEL_162;
          }
          v155[0] = &unk_1ECFA2990;
          CFDictionaryRef theDict = 0;
          uint64_t v157 = 0;
          __int16 v158 = 0;
          HTTPCookieStoragePolicy::init((uint64_t)v155, *((CFTypeRef *)a3 + 2), *((const void **)a3 + 3), *((void *)a3 + 4), *((_DWORD *)a3 + 10), *((_DWORD *)a3 + 18), *((void *)a3 + 7), *((void *)a3 + 8), *((const __CFDictionary **)a3 + 10), *((unsigned char *)a3 + 98));
          uint64_t v69 = [(OpaqueCFHTTPCookie *)v47 _inner];
          CFStringRef v70 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v69 + 16))(v69);
          if (*v70 > 0xBu)
          {
            int v71 = v70[2];
            if (theDict
              && CFDictionaryGetValue(theDict, @"_kCFHTTPCookiePolicyPropertySiteForCookies")
              && (v71 & 8) != 0
              && !HTTPCookieStoragePolicy::isTopLevelNavigation(theDict))
            {
              int isURLInSiteForCookie = HTTPCookieStoragePolicy::isURLInSiteForCookie((HTTPCookieStoragePolicy *)v155, v72, v73);
              HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v155);
              if (!isURLInSiteForCookie) {
                goto LABEL_162;
              }
              goto LABEL_122;
            }
          }
          else if (theDict)
          {
            CFDictionaryGetValue(theDict, @"_kCFHTTPCookiePolicyPropertySiteForCookies");
          }
          HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v155);
LABEL_122:
          id v74 = [NSString alloc];
          uint64_t v75 = [(OpaqueCFHTTPCookie *)v47 _inner];
          uint64_t v76 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v75 + 16))(v75);
          if (*v76 >= 0x18)
          {
            uint64_t v77 = v76[5];
            if (v77)
            {
              uint64_t v78 = *v76;
              CFStringRef v79 = (char *)v76 + v77;
              if (v78 > v77)
              {
                do
                {
                  if (!*v79) {
                    break;
                  }
                  ++v79;
                }
                while (v79 < (unsigned char *)v76 + v78);
              }
            }
          }
          id v80 = (id)objc_msgSend(v74, "initWithCString:encoding:");
          char v81 = [v80 hasPrefix:@"__Secure-"];
          if ((v81 & 1) == 0 && ![v80 hasPrefix:@"__Host-"]) {
            goto LABEL_155;
          }
          uint64_t v82 = [(OpaqueCFHTTPCookie *)v47 _inner];
          CFStringRef v83 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v82 + 16))(v82);
          if (*v83 >= 0xCu && (v83[2] & 1) != 0)
          {
            CFURLRef v84 = (const __CFURL *)*((void *)a3 + 2);
            if (!v84) {
              goto LABEL_155;
            }
            CFStringRef v85 = CFURLCopyScheme(v84);
            *(void *)&v163[0] = MEMORY[0x1E4F143A8];
            *(void *)&v163[1] = 3221225472;
            CFStringRef v164 = ___ZL36shouldAllowCookieBasedOnCookiePrefixPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicy_block_invoke;
            CFAllocatorRef v165 = &__block_descriptor_40_e5_v8__0l;
            CFStringRef v166 = v85;
            if (_findCanonicalString(v85, 0xFu) == 591445440
              || _findCanonicalString(v85, 0xFu) == 596671952)
            {
              if (v81) {
                goto LABEL_154;
              }
              uint64_t v86 = [(OpaqueCFHTTPCookie *)v47 _inner];
              CFTypeRef v87 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v86 + 16))(v86);
              if (*v87 >= 0xCu) {
                unsigned int v88 = v87[2] & 0x20;
              }
              else {
                unsigned int v88 = 0;
              }
              uint64_t v90 = (*(uint64_t (**)(uint64_t))(*(void *)v86 + 16))(v86);
              unsigned int v91 = v88 >> 5;
              uint64_t v92 = *(unsigned int *)(v90 + 16);
              uint64_t v93 = v90 + v92;
              do
                ++v93;
              while (*(unsigned char *)(v93 - 1));
              if (v91 != (*(unsigned char *)(v90 + v92) != 46))
              {
                if (CFNLog::onceToken != -1) {
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
                }
                CFAllocatorRef v94 = CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
                {
                  BOOL v108 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v86 + 16))(v86);
                  if (*v108 >= 0x18
                    && (uint64_t v109 = v108[5], v109)
                    && (uint64_t v110 = *v108, v111 = (char *)v108 + v109, v110 > v109))
                  {
                    while (*v111)
                    {
                      if (++v111 >= (unsigned char *)v108 + v110) {
                        goto LABEL_173;
                      }
                    }
                    uint64_t v140 = (char *)v108 + v109;
                  }
                  else
                  {
LABEL_173:
                    uint64_t v140 = 0;
                  }
                  uint64_t v112 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v86 + 16))(v86);
                  if (*v112 >= 0x20
                    && (uint64_t v113 = v112[7], v113)
                    && (uint64_t v114 = *v112, v115 = (char *)v112 + v113, v114 > v113))
                  {
                    while (*v115)
                    {
                      if (++v115 >= (unsigned char *)v112 + v114) {
                        goto LABEL_179;
                      }
                    }
                    CFTypeRef cfa = (char *)v112 + v113;
                  }
                  else
                  {
LABEL_179:
                    CFTypeRef cfa = 0;
                  }
                  int v116 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v86 + 16))(v86);
                  if (*v116 >= 0x14
                    && (uint64_t v117 = v116[4], v117)
                    && (uint64_t v118 = (char *)v116 + v117,
                        uint64_t v119 = *v116,
                        uint64_t v120 = (char *)v116 + v117,
                        v119 > v117))
                  {
                    while (*v120)
                    {
                      if (++v120 >= (unsigned char *)v116 + v119) {
                        goto LABEL_185;
                      }
                    }
                  }
                  else
                  {
LABEL_185:
                    uint64_t v118 = 0;
                  }
                  *(_DWORD *)long long buf = 136315650;
                  v181 = v140;
                  __int16 v182 = 2080;
                  CFTypeRef v183 = cfa;
                  __int16 v184 = 2080;
                  uint64_t v185 = v118;
                  _os_log_fault_impl(&dword_184085000, v94, OS_LOG_TYPE_FAULT, "Cookie hostOnly flag and domain pattern is inconsistent. @{%s:%s; domain=%s}",
                    buf,
                    0x20u);
                }
                unsigned int v91 = v88 == 0;
              }
              if (v91)
              {
                id v95 = [NSString alloc];
                uint64_t v96 = [(OpaqueCFHTTPCookie *)v47 _inner];
                uint64_t v97 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v96 + 16))(v96);
                if (*v97 >= 0x1C)
                {
                  uint64_t v98 = v97[6];
                  if (v98)
                  {
                    uint64_t v99 = *v97;
                    uint64_t v100 = (char *)v97 + v98;
                    if (v99 > v98)
                    {
                      do
                      {
                        if (!*v100) {
                          break;
                        }
                        ++v100;
                      }
                      while (v100 < (unsigned char *)v97 + v99);
                    }
                  }
                }
                if (objc_msgSend((id)objc_msgSend(v95, "initWithCString:encoding:"), "isEqualToString:", @"/"))
                {
LABEL_154:
                  v164((uint64_t)v163);
LABEL_155:
                  uint64_t v101 = [(OpaqueCFHTTPCookie *)v47 _inner];
                  char v102 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v101 + 16))(v101);
                  if (*v102 >= 0x14)
                  {
                    uint64_t v104 = v102[4];
                    if (v104)
                    {
                      unint64_t v105 = (char *)v102 + v104;
                      uint64_t v106 = *v102;
                      int v107 = (char *)v102 + v104;
                      if (v106 > v104)
                      {
                        while (*v107)
                        {
                          if (++v107 >= (unsigned char *)v102 + v106) {
                            goto LABEL_162;
                          }
                        }
                        if ((theStringa == (CookieUtils *)v105
                           || CookieUtils::web_domainMatches_LCC_LCC(theStringa, v105, v103))
                          && HTTPCookieStorage::setCookie(this, v47, a3, Mutable, 0) == 1)
                        {
                          [obj addObject:v47];
                        }
                      }
                    }
                  }
                  goto LABEL_162;
                }
              }
            }
            v164((uint64_t)v163);
          }
LABEL_162:
          uint64_t v46 = v173;
        }
        while (v173 < (uint64_t)v170);
      }
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v169);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    CFDictionaryRef v175 = (void (**)(AutoString *__hidden))&unk_1ECF9C868;
    if (v179 != v178) {
      free(v179);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 30);
  if (*((void *)this + 13))
  {
    CFAllocatorRef v121 = (NSMutableDictionary *)[MEMORY[0x1E4F1CA60] dictionary];
    long long v153 = 0u;
    long long v154 = 0u;
    long long v151 = 0u;
    long long v152 = 0u;
    uint64_t v122 = [obj countByEnumeratingWithState:&v151 objects:v168 count:16];
    if (v122)
    {
      uint64_t v123 = *(void *)v152;
      do
      {
        for (uint64_t j = 0; j != v122; ++j)
        {
          if (*(void *)v152 != v123) {
            objc_enumerationMutation(obj);
          }
          CFRange v125 = *(NSHTTPCookie **)(*((void *)&v151 + 1) + 8 * j);
          uint64_t v126 = objc_msgSend(*((id *)this + 10), "objectForKeyedSubscript:", -[NSHTTPCookie domain](v125, "domain"));
          long long v149 = 0u;
          long long v150 = 0u;
          long long v147 = 0u;
          long long v148 = 0u;
          uint64_t v127 = [v126 countByEnumeratingWithState:&v147 objects:v167 count:16];
          if (v127)
          {
            uint64_t v128 = *(void *)v148;
            do
            {
              for (uint64_t k = 0; k != v127; ++k)
              {
                if (*(void *)v148 != v128) {
                  objc_enumerationMutation(v126);
                }
                addCookieToSubscriberDictionaryForDomain(v125, v121, *(NSString **)(*((void *)&v147 + 1) + 8 * k));
              }
              uint64_t v127 = [v126 countByEnumeratingWithState:&v147 objects:v167 count:16];
            }
            while (v127);
          }
        }
        uint64_t v122 = [obj countByEnumeratingWithState:&v151 objects:v168 count:16];
      }
      while (v122);
    }
    if ([(NSMutableDictionary *)v121 count])
    {
      uint64_t v130 = *((void *)this + 13);
      uint64_t v131 = *((void *)this + 11);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZN17HTTPCookieStorage20setCookiesWithPolicyEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke_3;
      CFHostClientContext block[3] = &unk_1E5258028;
      block[4] = v121;
      void block[5] = v130;
      dispatch_async(v131, block);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 30);
}

void sub_184271B44(_Unwind_Exception *a1)
{
}

BOOL HTTPCookieStorage::isURLInMainDocumentDomain(HTTPCookieStorage *this, const __CFURL *a2, const __CFURL *a3)
{
  CFStringRef v4 = CFURLCopyHostName(this);
  CFStringRef v5 = CFURLCopyHostName(a2);
  if (!((unint64_t)v4 | (unint64_t)v5))
  {
    CFStringRef v4 = (const __CFString *)CFRetain(@".^filecookies^");
    CFStringRef v5 = (const __CFString *)CFRetain(@".^filecookies^");
  }
  CFStringRef v6 = v5;
  if (v4 && v5)
  {
    uint64_t v7 = copyStringAndLowerCase(v4);
    CFAllocatorRef v8 = copyStringAndLowerCase(v6);
    if (CFEqual(v7, v8))
    {
      BOOL v19 = 1;
      if (!v7) {
        goto LABEL_31;
      }
      goto LABEL_30;
    }
    CFURLRef v21 = a2;
    CFAllocatorRef alloc = CFGetAllocator(v7);
    CFStringFind(v7, @".", 8uLL);
    CFStringFind(v8, @".", 8uLL);
    CFIndex location = CFStringFind(v7, @".", 4uLL).location;
    if (location == -1 || (CFIndex Length = location, location != CFStringGetLength(v7) - 1)) {
      CFIndex Length = CFStringGetLength(v7);
    }
    CFStringRef v22 = v6;
    CFStringRef v23 = v4;
    CFRange v11 = CFStringFind(v8, @".", 4uLL);
    CFRange result = v11;
    if (v11.location == -1 || (CFIndex v12 = v11.location, v11.location != CFStringGetLength(v8) - 1)) {
      CFIndex v12 = CFStringGetLength(v8);
    }
    if (Length < 1)
    {
LABEL_23:
      CFStringRef v6 = v22;
      CFStringRef v4 = v23;
    }
    else
    {
      CFIndex v13 = 0;
      CFIndex v14 = Length;
      while (1)
      {
        CFIndex v15 = v12 >= v14 ? v14 : v12;
        v26.CFIndex location = v13;
        v26.size_t length = v14;
        CFStringRef v16 = CFStringCreateWithSubstring(alloc, v7, v26);
        v27.CFIndex location = (v12 - v14) & ~((v12 - v14) >> 63);
        v27.size_t length = v15;
        if (CFStringCompareWithOptions(v8, v16, v27, 1uLL) == kCFCompareEqualTo) {
          break;
        }
        v28.CFIndex location = v13;
        v28.size_t length = v14;
        int v17 = CFStringFindWithOptions(v7, @".", v28, 0, &result);
        CFIndex v18 = result.location;
        CFRelease(v16);
        if (v17) {
          CFIndex v13 = v18 + 1;
        }
        else {
          CFIndex v13 = -1;
        }
        if (v17)
        {
          CFIndex v14 = Length + ~v18;
          if (v14 > 0) {
            continue;
          }
        }
        goto LABEL_23;
      }
      CFStringRef v6 = v22;
      CFStringRef v4 = v23;
      if (v16)
      {
        BOOL v19 = !isTopLevelDomain(v16, 1);
        CFRelease(v16);
        if (!v7)
        {
LABEL_31:
          if (v8) {
            CFRelease(v8);
          }
          goto LABEL_33;
        }
LABEL_30:
        CFRelease(v7);
        goto LABEL_31;
      }
    }
    BOOL v19 = v21 == 0;
    if (!v7) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  BOOL v19 = 0;
  if (!v5)
  {
    BOOL v19 = 0;
    if (!v4) {
      return v19;
    }
    goto LABEL_34;
  }
LABEL_33:
  CFRelease(v6);
  if (v4) {
LABEL_34:
  }
    CFRelease(v4);
  return v19;
}

void ___ZN17HTTPCookieStorage20setCookiesWithPolicyEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke_2(uint64_t a1)
{
  CFStringRef v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZL36shouldAllowCookieBasedOnCookiePrefixPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicy_block_invoke(uint64_t a1)
{
  CFStringRef v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t addCookieToSubscriberDictionaryForDomain(NSHTTPCookie *a1, NSMutableDictionary *a2, NSString *a3)
{
  CFStringRef v6 = (void *)-[NSMutableDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:");
  if (v6)
  {
    return [v6 addObject:a1];
  }
  else
  {
    CFAllocatorRef v8 = (void *)[MEMORY[0x1E4F1CA48] array];
    [v8 addObject:a1];
    return [(NSMutableDictionary *)a2 setObject:v8 forKeyedSubscript:a3];
  }
}

uint64_t ___ZN17HTTPCookieStorage20setCookiesWithPolicyEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke_3(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  unint64_t v2 = *(void **)(a1 + 32);
  uint64_t result = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)v8;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        [*(id *)(a1 + 32) objectForKeyedSubscript:*(void *)(*((void *)&v7 + 1) + 8 * v6)];
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
        ++v6;
      }
      while (v4 != v6);
      uint64_t result = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
      uint64_t v4 = result;
    }
    while (result);
  }
  return result;
}

__CFString *copyStringAndLowerCase(const __CFString *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  MutableCFSetRef Copy = CFStringCreateMutableCopy(v2, 0, a1);
  CFLocaleRef System = CFLocaleGetSystem();
  CFStringLowercase(MutableCopy, System);
  return MutableCopy;
}

uint64_t ___ZN17HTTPCookieStorage20setCookiesWithPolicyEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  CFAllocatorRef v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 317;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN17HTTPCookieStorage16deleteAllCookiesEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void ___ZN17HTTPCookieStorage22deleteCookiesSinceDateEPK8__CFDate_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = (os_unfair_lock_s *)(v3 + 120);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 120));
  if (*(void *)(v3 + 112))
  {
    uint64_t v5 = (NSMutableDictionary *)[MEMORY[0x1E4F1CA60] dictionary];
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    uint64_t v6 = [a2 countByEnumeratingWithState:&v24 objects:v29 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)v25;
      obuint64_t j = a2;
      do
      {
        for (uint64_t i = 0; i != v7; ++i)
        {
          if (*(void *)v25 != v8) {
            objc_enumerationMutation(obj);
          }
          long long v10 = *(NSHTTPCookie **)(*((void *)&v24 + 1) + 8 * i);
          CFRange v11 = objc_msgSend(*(id *)(v3 + 80), "objectForKeyedSubscript:", -[NSHTTPCookie domain](v10, "domain"));
          long long v20 = 0u;
          long long v21 = 0u;
          long long v22 = 0u;
          long long v23 = 0u;
          uint64_t v12 = [v11 countByEnumeratingWithState:&v20 objects:v28 count:16];
          if (v12)
          {
            uint64_t v13 = v12;
            uint64_t v14 = *(void *)v21;
            do
            {
              for (uint64_t j = 0; j != v13; ++j)
              {
                if (*(void *)v21 != v14) {
                  objc_enumerationMutation(v11);
                }
                addCookieToSubscriberDictionaryForDomain(v10, v5, *(NSString **)(*((void *)&v20 + 1) + 8 * j));
              }
              uint64_t v13 = [v11 countByEnumeratingWithState:&v20 objects:v28 count:16];
            }
            while (v13);
          }
        }
        uint64_t v7 = [obj countByEnumeratingWithState:&v24 objects:v29 count:16];
      }
      while (v7);
    }
    uint64_t v4 = (os_unfair_lock_s *)(v3 + 120);
    if ([(NSMutableDictionary *)v5 count])
    {
      uint64_t v16 = *(void *)(v3 + 112);
      int v17 = *(NSObject **)(v3 + 96);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZN17HTTPCookieStorage22deleteCookiesSinceDateEPK8__CFDate_block_invoke_2;
      CFHostClientContext block[3] = &unk_1E5258028;
      block[4] = v5;
      void block[5] = v16;
      dispatch_async(v17, block);
    }
  }
  os_unfair_lock_unlock(v4);
}

uint64_t ___ZN17HTTPCookieStorage22deleteCookiesSinceDateEPK8__CFDate_block_invoke_2(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  CFAllocatorRef v2 = *(void **)(a1 + 32);
  uint64_t result = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)v8;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        [*(id *)(a1 + 32) objectForKeyedSubscript:*(void *)(*((void *)&v7 + 1) + 8 * v6)];
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
        ++v6;
      }
      while (v4 != v6);
      uint64_t result = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
      uint64_t v4 = result;
    }
    while (result);
  }
  return result;
}

__CFArray *HTTPCookieStorage::copyCookiesMatching(HTTPCookieStorage *this, const __CFDictionary *a2, uint64_t a3, const __CFArray *a4)
{
  long long v7 = (char *)this - 16;
  CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
  long long v9 = (char *)CFAllocatorAllocate(v8, 1040, 0);
  bzero(v9, 0x410uLL);
  CFAllocatorRef v10 = CFGetAllocator(v7);
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)v9, v10);
  *CFRange v11 = &unk_1ECF9B4C8;
  bzero(v11 + 5, 0x320uLL);
  if (a2)
  {
    *((void *)v9 + 3) = CFRetain(a2);
    uint64_t v12 = (CFTypeID *)(v9 + 48);
    uint64_t v13 = 1u;
    do
    {
      CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)v9 + 3), &gConstantCFStringValueTable[7 * ((CookieData::sCookieFieldInfo[v13] >> 20) & 0x3FF)]);
      *(v12 - 1) = (CFTypeID)Value;
      if (Value) {
        CFTypeID *v12 = CFGetTypeID(Value);
      }
      v13 += 5;
      v12 += 5;
    }
    while (v13 != 101);
  }
  else
  {
    *((void *)v9 + 3) = 0;
  }
  *((void *)v9 + 105) = a3;
  if (a4) {
    CFTypeRef v15 = CFRetain(a4);
  }
  else {
    CFTypeRef v15 = 0;
  }
  *((void *)v9 + 4) = v15;
  *((void *)v9 + 106) = 0;
  CFContainerEnumeratorBase::setup((unint64_t)&v55, a4, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
  uint64_t v61 = 0;
  CFTypeID TypeID = CFStringGetTypeID();
  CFTypeID v17 = CFArrayGetTypeID();
  uint64_t v18 = v61;
  if (v61 < v56)
  {
    CFTypeID v19 = v17;
    uint64_t v53 = (const void *)*MEMORY[0x1E4F1CFD0];
    long long v20 = MEMORY[0x1E4F14500];
    do
    {
      uint64_t v61 = v18 + 1;
      CFStringRef v21 = (const __CFString *)*((void *)v57 + v18);
      if (CFGetTypeID(v21) == TypeID)
      {
        BOOL v22 = 1;
        if (!v21) {
          goto LABEL_68;
        }
      }
      else
      {
        if (CFGetTypeID(v21) != v19) {
          goto LABEL_68;
        }
        CFIndex Count = CFArrayGetCount((CFArrayRef)v21);
        if (Count < 1) {
          goto LABEL_68;
        }
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v21, 0);
        BOOL v22 = (unint64_t)Count < 2 || CFArrayGetValueAtIndex((CFArrayRef)v21, 1) == v53;
        CFStringRef v21 = ValueAtIndex;
        if (!ValueAtIndex) {
          goto LABEL_68;
        }
      }
      int CanonicalString = _findCanonicalString(v21, 3u);
      if (CanonicalString > 269521452)
      {
        if (CanonicalString <= 274797120)
        {
          if (CanonicalString > 272667194)
          {
            if (CanonicalString == 272667195)
            {
              long long v26 = (int *)&unk_18430C184;
LABEL_64:
              if (v26[1] != CanonicalString && os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_fault_impl(&dword_184085000, v20, OS_LOG_TYPE_FAULT, "string constant mismatch", buf, 2u);
              }
              uint64_t v27 = *((void *)v9 + 106);
              *(void *)&v9[8 * v27 + 856] = v26;
              *((void *)v9 + 106) = v27 + 1;
              v9[v27 + 1016] = v22;
              goto LABEL_68;
            }
            if (CanonicalString == 273715774)
            {
              long long v26 = (int *)&unk_18430C198;
              goto LABEL_64;
            }
          }
          else
          {
            if (CanonicalString == 269521453)
            {
              long long v26 = (int *)&unk_18430C15C;
              goto LABEL_64;
            }
            if (CanonicalString == 270610992)
            {
              long long v26 = (int *)&unk_18430C170;
              goto LABEL_64;
            }
          }
        }
        else if (CanonicalString <= 278008401)
        {
          if (CanonicalString == 274797121)
          {
            long long v26 = (int *)&unk_18430C1FC;
            goto LABEL_64;
          }
          if (CanonicalString == 275829318)
          {
            long long v26 = (int *)&unk_18430C1AC;
            goto LABEL_64;
          }
        }
        else
        {
          switch(CanonicalString)
          {
            case 278008402:
              long long v26 = (int *)&unk_18430C1E8;
              goto LABEL_64;
            case 278966875:
              long long v26 = (int *)&unk_18430C1C0;
              goto LABEL_64;
            case 280031838:
              long long v26 = (int *)&unk_18430C1D4;
              goto LABEL_64;
          }
        }
      }
      else if (CanonicalString <= 264294934)
      {
        if (CanonicalString > 262205966)
        {
          if (CanonicalString == 262205967)
          {
            long long v26 = (int *)&unk_18430C0E4;
            goto LABEL_64;
          }
          if (CanonicalString == 263254547)
          {
            long long v26 = (int *)&unk_18430C0F8;
            goto LABEL_64;
          }
        }
        else
        {
          long long v26 = CookieData::sCookieFieldInfo;
          if (CanonicalString == 260108805) {
            goto LABEL_64;
          }
          if (CanonicalString == 261181961)
          {
            long long v26 = (int *)&unk_18430C0D0;
            goto LABEL_64;
          }
        }
      }
      else if (CanonicalString <= 266416670)
      {
        if (CanonicalString == 264294935)
        {
          long long v26 = (int *)&unk_18430C10C;
          goto LABEL_64;
        }
        if (CanonicalString == 265351707)
        {
          long long v26 = (int *)&unk_18430C120;
          goto LABEL_64;
        }
      }
      else
      {
        switch(CanonicalString)
        {
          case 266416671:
            long long v26 = (int *)&unk_18430C210;
            goto LABEL_64;
          case 267457060:
            long long v26 = (int *)&unk_18430C134;
            goto LABEL_64;
          case 268497449:
            long long v26 = (int *)&unk_18430C148;
            goto LABEL_64;
        }
      }
LABEL_68:
      uint64_t v18 = v61;
    }
    while (v61 < v56);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v55);
  CFAllocatorRef v28 = CFGetAllocator(v7);
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v28, 0, MEMORY[0x1E4F1D510]);
  uint64_t v30 = (void *)*((void *)this + 2);
  *(void *)long long buf = 0;
  CFDictionaryRef v63 = buf;
  uint64_t v64 = 0x2020000000;
  uint64_t v65 = 0;
  unint64_t v31 = dispatch_semaphore_create(0);
  uint64_t v55 = MEMORY[0x1E4F143A8];
  uint64_t v56 = 3221225472;
  BOOL v57 = ___ZN24PrivateHTTPCookieStorage24newCookieArrayEnumeratorEP12CookieSifter_block_invoke;
  unsigned int v58 = &unk_1E5256040;
  CFURLRef v59 = v31;
  uint64_t v60 = buf;
  uint64_t v32 = v30[4];
  if (v32) {
    pthread_mutex_lock((pthread_mutex_t *)(v32 + 8));
  }
  (*(void (**)(void *, char *, uint64_t *))(*v30 + 104))(v30, v9, &v55);
  if (v32) {
    pthread_mutex_unlock((pthread_mutex_t *)(v32 + 8));
  }
  dispatch_semaphore_wait(v31, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v31);
  unint64_t v33 = (CFContainerEnumeratorBase *)*((void *)v63 + 3);
  _Block_object_dispose(buf, 8);
  if (v33)
  {
    uint64_t v34 = *((void *)v33 + 1);
    if (v34 < 1)
    {
      unsigned int v35 = 0;
    }
    else
    {
      unsigned int v35 = 0;
      for (uint64_t i = 0; i != v34; ++i)
      {
        uint64_t v37 = *(void *)(*((void *)v33 + 2) + 8 * i);
        if (v37)
        {
          if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
            dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
          }
          v37 += 16;
        }
        CFDataRef v38 = *(const __CFData **)(v37 + 16);
        if (v38 && (BytePtr = CFDataGetBytePtr(v38)) != 0) {
          int v40 = *((_DWORD *)BytePtr + 1);
        }
        else {
          int v40 = 0;
        }
        CFArrayAppendValue(Mutable, (const void *)(v37 - 16));
        v35 += v40;
      }
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v33);
    MEMORY[0x18531B6D0]();
  }
  else
  {
    unsigned int v35 = 0;
  }
  CFAllocatorRef v41 = CFGetAllocator(v7);
  CFIndex v42 = v35;
  unint64_t v43 = CFArrayCreateMutable(v41, v35, MEMORY[0x1E4F1D510]);
  CFContainerEnumeratorBase::setup((unint64_t)&v55, Mutable, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
  uint64_t v61 = 0;
  if (v56 >= 1)
  {
    uint64_t v44 = 0;
    do
    {
      uint64_t v61 = v44 + 1;
      uint64_t v45 = *((void *)v57 + v44);
      if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
        dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
      }
      CFDataRef v46 = *(const __CFData **)(v45 + 32);
      if (v46)
      {
        size_t v47 = CFDataGetBytePtr(v46);
        if (v47)
        {
          uint64_t v48 = *((unsigned int *)v47 + 1);
          if (v48)
          {
            uint64_t v49 = 0;
            uint64_t v50 = v45 + 16;
            do
            {
              id v51 = [[NSHTTPCookie alloc] _initWithReference:v50 index:v49];
              CFArrayAppendValue(v43, v51);

              ++v49;
            }
            while (v48 != v49);
          }
        }
      }
      uint64_t v44 = v61;
    }
    while (v61 < v56);
  }
  if (*((uint64_t *)v9 + 106) >= 1)
  {
    v66.CFIndex location = 0;
    v66.size_t length = v42;
    CFArraySortValues(v43, v66, (CFComparatorFunction)_cmp_cookie, v9);
  }
  (*(void (**)(char *))(*(void *)v9 + 48))(v9);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v55);
  CFRelease(Mutable);
  return v43;
}

void sub_184272D44(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v2 - 128), 8);
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t _cmp_cookie(void *a1, void *a2, void *a3)
{
  uint64_t v5 = [a1 _inner];
  uint64_t v6 = [a2 _inner];
  long long v7 = (CompactCookieHeader *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
  if (v7 == (CompactCookieHeader *)v8 || (uint64_t v9 = a3[106], v9 < 1))
  {
    int v49 = 0;
  }
  else
  {
    CFAllocatorRef v10 = (CompactCookieHeader *)v8;
    CFRange v11 = (int **)(a3 + 107);
    uint64_t v12 = (int **)&a3[v9 + 107];
    uint64_t v13 = (unsigned __int8 *)(a3 + 127);
    do
    {
      int v14 = 0;
      uint64_t v16 = *v11++;
      CFTypeRef v15 = v16;
      LODWORD(vCFRelease((char *)this - 16) = *v13++;
      int v17 = (int)v16;
      int v18 = v15[3];
      switch(v18)
      {
        case 1:
          EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString(v7, *v15, 0);
          uint64_t v30 = (const char *)CompactCookieHeader::getEnumeratedString(v10, *v15, 0);
          if (!((unint64_t)EnumeratedString | (unint64_t)v30)) {
            goto LABEL_23;
          }
          if (EnumeratedString) {
            BOOL v32 = 1;
          }
          else {
            BOOL v32 = v30 == 0;
          }
          if (v32)
          {
            if (EnumeratedString) {
              BOOL v33 = v30 == 0;
            }
            else {
              BOOL v33 = 0;
            }
            if (v33) {
              goto LABEL_7;
            }
            int v34 = strcasecmp(EnumeratedString, v30);
            if (v34 < 0) {
              int v14 = -1;
            }
            else {
              int v14 = v34 != 0;
            }
          }
          else
          {
            int v14 = 1;
          }
          break;
        case 2:
        case 4:
          unsigned __int8 EnumeratedTime = CompactCookieHeader::getEnumeratedTime((uint64_t)v7, *v15);
          double v21 = v20;
          int v22 = EnumeratedTime;
          if (EnumeratedTime == CompactCookieHeader::getEnumeratedTime((uint64_t)v10, *v15))
          {
            if (v21 >= v23) {
              int v14 = v21 > v23;
            }
            else {
LABEL_7:
            }
              int v14 = -1;
          }
          else if (v22)
          {
            int v14 = -1;
          }
          else
          {
            int v14 = 1;
          }
          break;
        case 3:
        case 5:
        case 6:
        case 7:
          break;
        case 8:
          if (*(_DWORD *)v7 >= 0x10u) {
            unsigned int v31 = *((_DWORD *)v7 + 3);
          }
          else {
            unsigned int v31 = 0;
          }
          if (*(_DWORD *)v10 >= 0x10u) {
            unsigned int v35 = *((_DWORD *)v10 + 3);
          }
          else {
            unsigned int v35 = 0;
          }
          if (v31 >= v35) {
            unint64_t v36 = v35;
          }
          else {
            unint64_t v36 = v31;
          }
          if (!v36) {
            goto LABEL_66;
          }
          unsigned int v37 = 56;
          unint64_t v38 = 1;
          do
          {
            CFAllocatorRef v39 = (unsigned __int16 *)((char *)v7 + v37);
            uint64_t v40 = *(_DWORD *)v7;
            if (v40 <= v37 || v39 + 1 > (unsigned __int16 *)((char *)v7 + v40)) {
              int v42 = 0;
            }
            else {
              int v42 = *v39;
            }
            unint64_t v43 = (unsigned __int16 *)((char *)v10 + v37);
            uint64_t v44 = *(_DWORD *)v10;
            if (v44 <= v37 || v43 + 1 > (unsigned __int16 *)((char *)v10 + v44)) {
              int v46 = 0;
            }
            else {
              int v46 = *v43;
            }
            int v14 = v42 - v46;
            if (v38 >= v36) {
              break;
            }
            ++v38;
            v37 += 2;
          }
          while (!v14);
          if (!v14)
          {
LABEL_66:
            BOOL v47 = v31 >= v35;
            BOOL v48 = v31 != v35;
            if (v47) {
              int v14 = v48;
            }
            else {
              int v14 = -1;
            }
          }
          break;
        default:
          if (v18 == 16)
          {
            int EnumeratedBoolean = CompactCookieHeader::getEnumeratedBoolean(v7, *v15);
            int v25 = CompactCookieHeader::getEnumeratedBoolean(v10, *v15);
            if (EnumeratedBoolean == v25)
            {
LABEL_23:
              int v14 = 0;
            }
            else
            {
              if (EnumeratedBoolean) {
                BOOL v26 = 1;
              }
              else {
                BOOL v26 = v25 == 0;
              }
              int v27 = !v26;
              if (EnumeratedBoolean) {
                BOOL v28 = v25 == 0;
              }
              else {
                BOOL v28 = 0;
              }
              if (v28) {
                int v14 = -1;
              }
              else {
                int v14 = v27;
              }
            }
          }
          break;
      }
      if (v17) {
        int v49 = v14;
      }
      else {
        int v49 = -v14;
      }
    }
    while (v11 < v12 && !v49);
  }
  if ((a3[105] & 0x20) != 0) {
    int v50 = -v49;
  }
  else {
    int v50 = v49;
  }
  if (v49) {
    uint64_t v51 = -1;
  }
  else {
    uint64_t v51 = 0;
  }
  if (v50 < 0) {
    return 1;
  }
  else {
    return v51;
  }
}

void ___ZN24PrivateHTTPCookieStorage24newCookieArrayEnumeratorEP12CookieSifter_block_invoke()
{
}

void sub_1842731B0(_Unwind_Exception *a1)
{
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v1);
  MEMORY[0x18531B6D0]();
  _Unwind_Resume(a1);
}

void ___ZN17HTTPCookieStorage20copyCookiesForDomainEPK10__CFString_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    CFRelease((CFTypeRef)(v1 - 16));
  }
}

unsigned int *appendCompactCookieArray(const CompactCookieArray *a1, __CFArray *a2)
{
  for (unint64_t i = 0; ; ++i)
  {
    uint64_t result = (unsigned int *)*((void *)a1 + 2);
    if (result && (uint64_t result = (unsigned int *)CFDataGetBytePtr((CFDataRef)result)) != 0) {
      unint64_t v6 = result[1];
    }
    else {
      unint64_t v6 = 0;
    }
    if (i >= v6) {
      break;
    }
    CFArrayAppendValue(a2, [[NSHTTPCookie alloc] _initWithReference:a1 index:i]);
  }
  return result;
}

void ___ZN17HTTPCookieStorage20copyCookiesForDomainEPK10__CFString_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    CFRelease((CFTypeRef)(v1 - 16));
  }
}

void ___ZN17HTTPCookieStorage20copyCookiesForDomainEPK10__CFString_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    CFRelease((CFTypeRef)(v1 - 16));
  }
}

void HTTPCookieStorage::deleteCookie(HTTPCookieStorage *this, OpaqueCFHTTPCookie *a2, const HTTPCookieStoragePolicy *a3)
{
  unint64_t v6 = (void *)*((void *)this + 2);
  uint64_t v7 = [(OpaqueCFHTTPCookie *)a2 _inner];
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
  uint64_t v9 = v6[4];
  if (v9) {
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  }
  (*(void (**)(void *, uint64_t, const HTTPCookieStoragePolicy *))(*v6 + 128))(v6, v8, a3);
  if (v9) {
    pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
  }
  HTTPCookieStorage::notifyObserversOfChanges(this);
  os_unfair_lock_lock((os_unfair_lock_t)this + 30);
  if (*((void *)this + 14))
  {
    CFAllocatorRef v10 = objc_msgSend(*((id *)this + 10), "objectForKeyedSubscript:", -[OpaqueCFHTTPCookie domain](a2, "domain"));
    if ([v10 count])
    {
      uint64_t v11 = *((void *)this + 14);
      uint64_t v12 = *((void *)this + 12);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZN17HTTPCookieStorage12deleteCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicy_block_invoke;
      CFHostClientContext block[3] = &unk_1E52581A0;
      void block[5] = a2;
      void block[6] = v11;
      block[4] = v10;
      dispatch_async(v12, block);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 30);
}

void sub_1842733FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN17HTTPCookieStorage12deleteCookieEPK18OpaqueCFHTTPCookieRK23HTTPCookieStoragePolicy_block_invoke(void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  uint64_t v2 = (void *)a1[4];
  uint64_t result = [v2 countByEnumeratingWithState:&v9 objects:v14 count:16];
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)v10;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v10 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v9 + 1) + 8 * v6);
        uint64_t v8 = a1[6];
        uint64_t v13 = a1[5];
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(v8 + 16))(v8, [MEMORY[0x1E4F1C978] arrayWithObjects:&v13 count:1], v7, 0);
        ++v6;
      }
      while (v4 != v6);
      uint64_t result = [v2 countByEnumeratingWithState:&v9 objects:v14 count:16];
      uint64_t v4 = result;
    }
    while (result);
  }
  return result;
}

uint64_t PrivateHTTPCookieStorage::invalidateLocked(uint64_t this)
{
  *(unsigned char *)(this + 40) = 0;
  return this;
}

BOOL PrivateHTTPCookieStorage::equals(PrivateHTTPCookieStorage *this, const CFAllocatedReferenceCountedObject *a2)
{
  return a2 == this;
}

uint64_t PrivateHTTPCookieStorage::copyDebugDesc(PrivateHTTPCookieStorage *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  uint64_t v3 = (*(uint64_t (**)(PrivateHTTPCookieStorage *))(*(void *)this + 88))(this);
  if (v2) {
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 8));
  }
  return v3;
}

void sub_1842735CC(_Unwind_Exception *exception_object)
{
  if (v1) {
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void PrivateHTTPCookieStorage::setCookiesWithPoliciesAppliedCommonImpl(CFAllocatorRef *a1, const void *a2, HTTPCookieStoragePolicy *this, uint64_t a4)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  switch(*((_DWORD *)this + 10))
  {
    case 0xFFFFFFFF:
      *((_DWORD *)this + 10) = 3;
      goto LABEL_52;
    case 1:
      return;
    case 2:
      CFStringRef v8 = CFURLCopyHostName(*((CFURLRef *)this + 2));
      if (!v8) {
        goto LABEL_52;
      }
      CFStringRef v9 = v8;
      MutableCFSetRef Copy = CFStringCreateMutableCopy(a1[1], 0, v8);
      CFRelease(v9);
      if (!MutableCopy) {
        goto LABEL_52;
      }
      CFStringLowercase(MutableCopy, 0);
      CStringPtr = CFStringGetCStringPtr(MutableCopy, 0x600u);
      long long v12 = (char *)CStringPtr;
      if (CStringPtr
        || (CFIndex v13 = CFStringGetLength(MutableCopy) + 1,
            long long v12 = (char *)CFAllocatorAllocate(a1[1], v13, 0),
            CFStringGetCString(MutableCopy, v12, v13, 0x600u),
            v12))
      {
        unsigned int v54 = CStringPtr;
        CFMutableStringRef cf = MutableCopy;
        CFStringRef theString = (const __CFString *)*((void *)this + 4);
        double Current = CFAbsoluteTimeGetCurrent();
        ptr = v12;
        do
        {
          DomainAndPartition::DomainAndPartition(v63, v12, theString, 1, *(uint64_t *)&Current);
          DomainAndPartition::DomainAndPartition((uint64_t)&v57, (uint64_t)v63);
          uint64_t v15 = (*(uint64_t (**)(uint64_t, void **, uint64_t))(a4 + 16))(a4, &v57, 1);
          BOOL v57 = &unk_1ECF9F1A0;
          if (v62 && v62 != &v60) {
            free(v62);
          }
          if (v15)
          {
            unint64_t v16 = 0;
            while (1)
            {
              CFDataRef v17 = *(const __CFData **)(v15 + 16);
              if (v17 && (BytePtr = CFDataGetBytePtr(v17)) != 0) {
                unint64_t v19 = *((unsigned int *)BytePtr + 1);
              }
              else {
                unint64_t v19 = 0;
              }
              BOOL v20 = v16 >= v19;
              if (v16 >= v19) {
                break;
              }
              CFDataRef v21 = *(const __CFData **)(v15 + 16);
              if (v21 && CFDataGetBytePtr(v21))
              {
                int v22 = CFDataGetBytePtr(*(CFDataRef *)(v15 + 16));
                double v23 = *(const UInt8 **)(v15 + 16);
                uint64_t v24 = *(unsigned int *)&v22[4 * v16 + 8];
                if (v23) {
                  double v23 = CFDataGetBytePtr((CFDataRef)v23);
                }
                int v25 = &v23[v24];
              }
              else
              {
                int v25 = 0;
              }
              if (*(_DWORD *)v25 < 0xCu || (*((_DWORD *)v25 + 2) & 2) == 0)
              {
                double v26 = 0.0;
                if (*(_DWORD *)v25 >= 0x30u) {
                  double v26 = floor(*((double *)v25 + 5));
                }
                ++v16;
                if (Current >= v26) {
                  continue;
                }
              }
              int v27 = 1;
              goto LABEL_38;
            }
            if (*v12 == 46) {
              CFDataRef v29 = v12 + 1;
            }
            else {
              CFDataRef v29 = v12;
            }
            long long v12 = strchr(v29, 46);
            int v27 = 0;
LABEL_38:
            CFRelease((CFTypeRef)(v15 - 16));
          }
          else
          {
            if (*v12 == 46) {
              BOOL v28 = v12 + 1;
            }
            else {
              BOOL v28 = v12;
            }
            long long v12 = strchr(v28, 46);
            int v27 = 0;
            BOOL v20 = 1;
          }
          v63[0] = &unk_1ECF9F1A0;
          if (v65 && v65 != v64) {
            free(v65);
          }
          if (v12) {
            BOOL v30 = v20;
          }
          else {
            BOOL v30 = 0;
          }
        }
        while (v30 && *v12);
        CFRelease(cf);
        if (v54)
        {
          if (v27) {
            goto LABEL_54;
          }
          goto LABEL_52;
        }
      }
      else
      {
        CFRelease(MutableCopy);
        int v27 = 0;
        ptr = 0;
      }
      CFAllocatorDeallocate(a1[1], ptr);
      if (v27) {
        goto LABEL_54;
      }
LABEL_52:
      CFURLRef v31 = (const __CFURL *)*((void *)this + 3);
      if (v31 && !HTTPCookieStorage::isURLInMainDocumentDomain(*((HTTPCookieStorage **)this + 2), v31, this)) {
        return;
      }
LABEL_54:
      uint64_t Name = HTTPCookieStoragePolicy::getName(this);
      if (Name && *(void *)(Name + 16) >= 2uLL)
      {
        uint64_t v33 = HTTPCookieStoragePolicy::getName(this);
        if (v33 && *(void *)(v33 + 16)) {
          int v34 = (CookieUtils *)(*(void *)(v33 + 8) + 1);
        }
        else {
          int v34 = 0;
        }
        CFContainerEnumeratorBase::setup((unint64_t)&v57, a2, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
        uint64_t v61 = 0;
        if (v58 < 1)
        {
LABEL_86:
          CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v57);
          return;
        }
        uint64_t v35 = 0;
        while (1)
        {
          uint64_t v61 = v35 + 1;
          unint64_t v36 = *(OpaqueCFHTTPCookie **)(v59 + 8 * v35);
          if (CFHTTPCookie_domainMatches(v36, *((const __CFURL **)this + 2))) {
            break;
          }
LABEL_85:
          uint64_t v35 = v61;
          if (v61 >= v58) {
            goto LABEL_86;
          }
        }
        uint64_t v37 = [(OpaqueCFHTTPCookie *)v36 _inner];
        unint64_t v38 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v37 + 16))(v37);
        if (*v38 >= 0x14
          && (uint64_t v39 = v38[4], v39)
          && (uint64_t v40 = (char *)v38 + v39, v41 = *v38, v42 = (char *)v38 + v39, v41 > v39))
        {
          while (*v42)
          {
            if (++v42 >= (unsigned char *)v38 + v41) {
              goto LABEL_68;
            }
          }
        }
        else
        {
LABEL_68:
          uint64_t v40 = 0;
        }
        uint64_t v43 = [(OpaqueCFHTTPCookie *)v36 _inner];
        uint64_t v44 = (CompactCookieHeader *)(*(uint64_t (**)(uint64_t))(*(void *)v43 + 16))(v43);
        EnumeratedString = (void *)CompactCookieHeader::getEnumeratedString(v44, 15, 0);
        if (!EnumeratedString)
        {
          CFStringRef v46 = (const __CFString *)*((void *)this + 4);
          if (!v46)
          {
LABEL_73:
            EnumeratedString = 0;
            goto LABEL_74;
          }
          CFIndex v47 = CFStringGetLength(v46) + 1;
          EnumeratedString = malloc_type_malloc(v47, 0xC69A39CDuLL);
          if (!CFStringGetCString(*((CFStringRef *)this + 4), (char *)EnumeratedString, v47, 0x8000100u))
          {
            free(EnumeratedString);
            goto LABEL_73;
          }
        }
LABEL_74:
        if (*((unsigned char *)this + 56))
        {
          uint64_t v48 = *((void *)this + 8);
        }
        else
        {
          *((unsigned char *)this + 56) = 1;
          CFAbsoluteTime v49 = CFAbsoluteTimeGetCurrent();
          *((CFAbsoluteTime *)this + 8) = v49;
          uint64_t v48 = *(void *)&v49;
        }
        DomainAndPartition::DomainAndPartition(v63, v40, (char *)EnumeratedString, *((void *)this + 7), v48);
        if (v34 == (CookieUtils *)v40 || v34 && v40 && CookieUtils::web_domainMatches_LCC_LCC(v34, v40, v50))
        {
          uint64_t v51 = [(OpaqueCFHTTPCookie *)v36 _inner];
          uint64_t v52 = (*(uint64_t (**)(uint64_t))(*(void *)v51 + 16))(v51);
          (*((void (**)(CFAllocatorRef *, uint64_t, HTTPCookieStoragePolicy *))*a1 + 15))(a1, v52, this);
        }
        v63[0] = &unk_1ECF9F1A0;
        if (v65)
        {
          if (v65 != v64) {
            free(v65);
          }
        }
        goto LABEL_85;
      }
      return;
    case 3:
      goto LABEL_52;
    default:
      goto LABEL_54;
  }
}

void sub_184273C28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

uint64_t HTTPCookieStoragePolicy::getName(HTTPCookieStoragePolicy *this)
{
  if (!*((void *)this + 1)) {
    operator new();
  }
  return *((void *)this + 1);
}

void sub_184273D8C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D1C40B840AE13);
  _Unwind_Resume(a1);
}

uint64_t PrivateHTTPCookieStorage::allowCookieToBeWrittenConsideringHTTPOnly(PrivateHTTPCookieStorage *this, const CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3, const MemoryCookies *a4)
{
  uint64_t v29 = 0;
  BOOL v30 = &v29;
  uint64_t v31 = 0x2020000000;
  uint64_t v4 = 1;
  char v32 = 1;
  if (a2 == 2 && (*(_DWORD *)this < 0xCu || (*((_DWORD *)this + 2) & 4) == 0))
  {
    if (*(_DWORD *)this >= 0x14u
      && (uint64_t v7 = *((unsigned int *)this + 4), v7)
      && (uint64_t v8 = *(unsigned int *)this, v8 > v7))
    {
      CFStringRef v9 = (char *)this + v7;
      long long v10 = (char *)this + v8;
      long long v11 = v9;
      while (*v11)
      {
        if (++v11 >= v10) {
          goto LABEL_10;
        }
      }
      size_t v12 = strlen(v9);
    }
    else
    {
LABEL_10:
      CFStringRef v9 = 0;
      size_t v12 = 0;
    }
    if (*(_DWORD *)this >= 0x18u
      && (uint64_t v13 = *((unsigned int *)this + 5), v13)
      && (uint64_t v14 = *(unsigned int *)this, v14 > v13))
    {
      uint64_t v15 = (char *)this + v13;
      unint64_t v16 = (char *)this + v14;
      CFDataRef v17 = v15;
      while (*v17)
      {
        if (++v17 >= v16) {
          goto LABEL_17;
        }
      }
      size_t v18 = strlen(v15);
    }
    else
    {
LABEL_17:
      uint64_t v15 = 0;
      size_t v18 = 0;
    }
    if (*(_DWORD *)this >= 0x1Cu
      && (uint64_t v19 = *((unsigned int *)this + 6), v19)
      && (uint64_t v20 = *(unsigned int *)this, v20 > v19))
    {
      CFDataRef v21 = (char *)this + v19;
      int v22 = (char *)this + v20;
      double v23 = v21;
      while (*v23)
      {
        if (++v23 >= v22) {
          goto LABEL_24;
        }
      }
      size_t v24 = strlen(v21);
    }
    else
    {
LABEL_24:
      CFDataRef v21 = 0;
      size_t v24 = 0;
    }
    if (*(_DWORD *)this >= 0xCu)
    {
      char v25 = *((_DWORD *)this + 2) & 1;
      if (!v12)
      {
LABEL_32:
        uint64_t v4 = 0;
        char v32 = 0;
        goto LABEL_33;
      }
    }
    else
    {
      char v25 = 0;
      if (!v12) {
        goto LABEL_32;
      }
    }
    if (!v18 || !v24) {
      goto LABEL_32;
    }
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 3321888768;
    v27[2] = ___ZN24PrivateHTTPCookieStorage41allowCookieToBeWrittenConsideringHTTPOnlyEPK19CompactCookieHeaderRK23HTTPCookieStoragePolicyPK13MemoryCookies_block_invoke;
    v27[3] = &unk_1ECFAA678;
    v27[6] = v12;
    v27[7] = v15;
    v27[8] = v18;
    v27[9] = v21;
    v27[10] = v24;
    char v28 = v25;
    v27[4] = &v29;
    void v27[5] = v9;
    MemoryCookies::visitCookies((uint64_t)a3, (uint64_t)v27);
    uint64_t v4 = *((unsigned __int8 *)v30 + 24);
  }
LABEL_33:
  _Block_object_dispose(&v29, 8);
  return v4;
}

void sub_184273FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

size_t ___ZN24PrivateHTTPCookieStorage41allowCookieToBeWrittenConsideringHTTPOnlyEPK19CompactCookieHeaderRK23HTTPCookieStoragePolicyPK13MemoryCookies_block_invoke(size_t result, unsigned int *a2, unsigned char *a3)
{
  if (*a2 >= 0xC && (a2[2] & 4) != 0)
  {
    size_t v5 = result;
    if (*a2 >= 0x14 && (uint64_t v6 = a2[4], v6) && (v7 = *a2, v7 > v6))
    {
      uint64_t v8 = (char *)a2 + v6;
      CFStringRef v9 = (char *)a2 + v7;
      long long v10 = v8;
      while (*v10)
      {
        if (++v10 >= v9) {
          goto LABEL_9;
        }
      }
      uint64_t result = strlen(v8);
      size_t v11 = result;
    }
    else
    {
LABEL_9:
      uint64_t v8 = 0;
      size_t v11 = 0;
    }
    if (*a2 >= 0x18 && (uint64_t v12 = a2[5], v12) && (v13 = *a2, v13 > v12))
    {
      uint64_t v14 = (char *)a2 + v12;
      uint64_t v15 = (char *)a2 + v13;
      unint64_t v16 = v14;
      while (*v16)
      {
        if (++v16 >= v15) {
          goto LABEL_16;
        }
      }
      uint64_t result = strlen(v14);
      size_t v17 = result;
    }
    else
    {
LABEL_16:
      uint64_t v14 = 0;
      size_t v17 = 0;
    }
    if (*a2 >= 0x1C && (uint64_t v18 = a2[6], v18) && (v19 = *a2, v19 > v18))
    {
      uint64_t v20 = (char *)a2 + v18;
      CFDataRef v21 = (char *)a2 + v19;
      int v22 = v20;
      while (*v22)
      {
        if (++v22 >= v21) {
          goto LABEL_23;
        }
      }
      uint64_t result = strlen(v20);
      size_t v23 = result;
    }
    else
    {
LABEL_23:
      uint64_t v20 = 0;
      size_t v23 = 0;
    }
    if (*a2 >= 0xC) {
      int v24 = a2[2] & 1;
    }
    else {
      int v24 = 0;
    }
    if (v24 == *(unsigned __int8 *)(v5 + 88) && v11 == *(void *)(v5 + 48))
    {
      uint64_t result = strncasecmp(v8, *(const char **)(v5 + 40), v11);
      if (!result && v17 == *(void *)(v5 + 64))
      {
        uint64_t result = strncasecmp(v14, *(const char **)(v5 + 56), v17);
        if (!result && v23 == *(void *)(v5 + 80))
        {
          uint64_t result = strncasecmp(v20, *(const char **)(v5 + 72), v23);
          if (!result)
          {
            *(unsigned char *)(*(void *)(*(void *)(v5 + 32) + 8) + 24) = 0;
            *a3 = 1;
          }
        }
      }
    }
  }
  return result;
}

void non-virtual thunk to'MemoryCookies::~MemoryCookies(MemoryCookies *this)
{
  uint64_t v2 = (char *)this - 16;
  MemoryCookies::~MemoryCookies((MemoryCookies *)((char *)this - 16));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  MemoryCookies::~MemoryCookies((MemoryCookies *)((char *)this - 16));
}

void MemoryCookies::setCookiesForDomain(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void MemoryCookies::withImmutableDomains(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 24);
  if (v3)
  {
    CFDictionaryRef Copy = CFDictionaryCreateCopy(*(CFAllocatorRef *)(a1 + 8), v3);
    (*(void (**)(uint64_t, CFDictionaryRef))(a2 + 16))(a2, Copy);
    CFRelease(Copy);
  }
}

void ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke(uint64_t a1, CFDictionaryRef theDict)
{
  int Count = CFDictionaryGetCount(theDict);
  CFContainerEnumeratorBase::setup((unint64_t)v12, theDict, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
  uint64_t v15 = 0;
  if (v13 < 1)
  {
    int v6 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    int v6 = 0;
    do
    {
      uint64_t v15 = v5 + 1;
      uint64_t v7 = *(void *)(v14 + 8 * v5);
      if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
        dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
      }
      uint64_t v8 = v7 + 16;
      if (!v7) {
        uint64_t v8 = 0;
      }
      CFDataRef v9 = *(const __CFData **)(v8 + 16);
      if (v9 && (BytePtr = CFDataGetBytePtr(v9)) != 0) {
        int v11 = *((_DWORD *)BytePtr + 1);
      }
      else {
        int v11 = 0;
      }
      v6 += v11;
      uint64_t v5 = v15;
    }
    while (v15 < v13);
  }
  snprintf(*(char **)(a1 + 32), *(int *)(a1 + 40), "<%d cookies in %d domains>", v6, Count);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v12);
}

void sub_184274408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

uint64_t MemoryCookies::setCookie(CompactCookieArray **this, CompactCookieHeader *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  unint64_t v16 = a2;
  if (*(_DWORD *)a2 < 0x14u) {
    return 0;
  }
  uint64_t v3 = *((unsigned int *)a2 + 4);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(_DWORD *)a2;
  if (v4 <= v3) {
    return 0;
  }
  int v6 = (char *)a2 + v3;
  uint64_t v7 = (char *)a2 + v4;
  uint64_t v8 = v6;
  while (*v8)
  {
    if (++v8 >= v7) {
      return 0;
    }
  }
  CompactCookieArray = CompactCookieArray::makeCompactCookieArray(this[1], &v16, (const CompactCookieHeader **)1);
  if (!CompactCookieArray)
  {
    CompactCookieArray::newEmptyArray(0);
    CompactCookieArray = v12;
  }
  EnumeratedString = (char *)CompactCookieHeader::getEnumeratedString(a2, 15, 0);
  uint64_t v14 = 0;
  if (*(_DWORD *)a2 >= 0x38u)
  {
    v22[0] = *((double *)a2 + 6);
    uint64_t v14 = floor(v22[0]);
  }
  DomainAndPartition::DomainAndPartition(v22, v6, EnumeratedString, 1, v14);
  DomainAndPartition::DomainAndPartition((uint64_t)&v17, (uint64_t)v22);
  if (v20) {
    BOOL v15 = *v20 != 0;
  }
  else {
    BOOL v15 = 0;
  }
  uint64_t v9 = MemoryCookies::setCookiesWithPartitionedDomains((CFDictionaryRef *)this, v21, CompactCookieArray, v15);
  size_t v17 = &unk_1ECF9F1A0;
  if (v19 && v19 != &v18) {
    free(v19);
  }
  CFRelease((char *)CompactCookieArray - 16);
  *(void *)&v22[0] = &unk_1ECF9F1A0;
  if (v24 && v24 != &v23) {
    free(v24);
  }
  return v9;
}

void sub_1842745F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  if (a45 && a45 != &a13) {
    free(a45);
  }
  a50 = (uint64_t)&unk_1ECF9F1A0;
  unsigned int v54 = (uint64_t *)STACK[0x260];
  if (STACK[0x260])
  {
    if (v54 != &a53) {
      free(v54);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t MemoryCookies::setCookiesWithPartitionedDomains(CFDictionaryRef *this, const unsigned __int8 *a2, CompactCookieArray *a3, int a4)
{
  CFNumberRef Value = (char *)CFDictionaryGetValue(this[3], a2);
  if (!Value)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    CFDataRef v14 = (const __CFData *)*((void *)a3 + 2);
    if (v14)
    {
      double v15 = Current;
      BytePtr = CFDataGetBytePtr(v14);
      if (BytePtr)
      {
        uint64_t v17 = *((unsigned int *)BytePtr + 1);
        if (v17)
        {
          uint64_t v18 = malloc_type_malloc(8 * v17, 0x2004093837F09uLL);
          uint64_t v19 = 0;
          uint64_t v20 = 0;
          do
          {
            CFDataRef v21 = (const __CFData *)*((void *)a3 + 2);
            if (v21)
            {
              if (CFDataGetBytePtr(v21))
              {
                int v22 = CFDataGetBytePtr(*((CFDataRef *)a3 + 2));
                CFDataRef v23 = (const __CFData *)*((void *)a3 + 2);
                if (v23)
                {
                  uint64_t v24 = *(unsigned int *)&v22[v19 + 8];
                  uint64_t v25 = CFDataGetBytePtr(v23);
                  if (v25)
                  {
                    double v26 = &v25[v24];
                    if (*(_DWORD *)&v25[v24] >= 0xCu && (*((_DWORD *)v26 + 2) & 2) != 0) {
                      goto LABEL_20;
                    }
                    double v27 = 0.0;
                    if (*(_DWORD *)v26 >= 0x30u) {
                      double v27 = floor(*((double *)v26 + 5));
                    }
                    if (v27 > v15)
                    {
LABEL_20:
                      v18[v20] = v26;
                      uint64_t v20 = (const CompactCookieHeader **)(v20 + 1);
                    }
                  }
                }
              }
            }
            v19 += 4;
          }
          while (4 * v17 != v19);
          if (v17 == v20)
          {
            free(v18);
          }
          else
          {
            char v28 = (CompactCookieArray *)CFGetAllocator((char *)a3 - 16);
            CompactCookieArray = CompactCookieArray::makeCompactCookieArray(v28, (const CompactCookieHeader **)v18, v20);
            free(v18);
            if (CompactCookieArray)
            {
LABEL_27:
              CFDataRef v29 = (const __CFData *)*((void *)CompactCookieArray + 2);
              if (!v29 || (BOOL v30 = CFDataGetBytePtr(v29)) == 0 || !*((_DWORD *)v30 + 1))
              {
                uint64_t v12 = 0;
                uint64_t v9 = (char *)CompactCookieArray - 16;
                goto LABEL_32;
              }
              goto LABEL_30;
            }
          }
        }
      }
    }
    CFRetain((char *)a3 - 16);
    CompactCookieArray = a3;
    goto LABEL_27;
  }
  uint64_t v9 = Value;
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
  }
  uint64_t v10 = CompactCookieArray::_mungeCookies((CompactCookieArray *)(v9 + 16), a3, (const CompactCookieArray *)1, a4);
  if ((char *)v10 == v9 + 16)
  {
    uint64_t v12 = 0;
LABEL_32:
    CFRelease(v9);
    return v12;
  }
  CompactCookieArray = (CompactCookieArray *)v10;
  if (v10)
  {
LABEL_30:
    uint64_t v9 = (char *)CompactCookieArray - 16;
    CFDictionarySetValue(this[3], a2, (char *)CompactCookieArray - 16);
    uint64_t v12 = 1;
    goto LABEL_32;
  }
  return 0;
}

uint64_t MemoryCookies::deleteCookie(MemoryCookies *this, CompactCookieHeader *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a2;
  if (*(_DWORD *)a2 < 0x14u) {
    return 0;
  }
  uint64_t v3 = *((unsigned int *)a2 + 4);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(_DWORD *)a2;
  if (v4 <= v3) {
    return 0;
  }
  int v6 = (char *)a2 + v3;
  uint64_t v7 = (char *)a2 + v4;
  uint64_t v8 = v6;
  while (*v8)
  {
    if (++v8 >= v7) {
      return 0;
    }
  }
  CompactCookieArray = CompactCookieArray::makeCompactCookieArray(*((CompactCookieArray **)this + 1), &v20, (const CompactCookieHeader **)1);
  if (!CompactCookieArray)
  {
    CompactCookieArray::newEmptyArray(0);
    CompactCookieArray = v12;
  }
  EnumeratedString = (char *)CompactCookieHeader::getEnumeratedString(a2, 15, 0);
  uint64_t v14 = 0;
  if (*(_DWORD *)a2 >= 0x38u)
  {
    v25[0] = *((double *)a2 + 6);
    uint64_t v14 = floor(v25[0]);
  }
  DomainAndPartition::DomainAndPartition(v25, v6, EnumeratedString, 1, v14);
  DomainAndPartition::DomainAndPartition((uint64_t)&v21, (uint64_t)v25);
  CFNumberRef Value = (char *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 3), key);
  if (!Value) {
    goto LABEL_22;
  }
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
  }
  uint64_t v16 = CompactCookieArray::_mungeCookies((CompactCookieArray *)(Value + 16), CompactCookieArray, 0, 0);
  uint64_t v17 = v16;
  if ((char *)v16 != Value + 16)
  {
    if (v16)
    {
      CFDataRef v18 = *(const __CFData **)(v16 + 16);
      if (v18 && (BytePtr = CFDataGetBytePtr(v18)) != 0 && *((_DWORD *)BytePtr + 1)) {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 3), key, (const void *)(v17 - 16));
      }
      else {
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 3), key);
      }
      CFNumberRef Value = (char *)(v17 - 16);
      uint64_t v9 = 1;
      goto LABEL_26;
    }
LABEL_22:
    uint64_t v9 = 0;
    goto LABEL_27;
  }
  uint64_t v9 = 0;
LABEL_26:
  CFRelease(Value);
LABEL_27:
  CFDataRef v21 = &unk_1ECF9F1A0;
  if (v23 && v23 != &v22) {
    free(v23);
  }
  CFRelease((char *)CompactCookieArray - 16);
  *(void *)&v25[0] = &unk_1ECF9F1A0;
  if (v27 && v27 != &v26) {
    free(v27);
  }
  return v9;
}

void sub_184274B08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  unsigned int v54 = (uint64_t *)STACK[0x260];
  if (STACK[0x260])
  {
    if (v54 != &a53) {
      free(v54);
    }
  }
  _Unwind_Resume(a1);
}

void MemoryCookies::newCookieArrayEnumerator(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    CFDictionaryRef v4 = *(const __CFDictionary **)(a2 + 24);
    if (v4 && CFDictionaryGetCount(v4)) {
      LOBYTE(v5) = 0;
    }
    else {
      int v5 = (*(unsigned __int8 *)(a2 + 840) >> 5) & 1;
    }
  }
  else
  {
    LOBYTE(v5) = 1;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  uint64_t v7[2] = ___ZNK13MemoryCookies24newCookieArrayEnumeratorEP12CookieSifter_block_invoke;
  v7[3] = &__block_descriptor_49_e25_v16__0____CFDictionary__8l;
  char v8 = v5;
  v7[4] = Mutable;
  void v7[5] = a2;
  MemoryCookies::withImmutableDomains(a1, (uint64_t)v7);
  operator new();
}

void sub_184274CC0(_Unwind_Exception *a1)
{
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v1);
  MEMORY[0x18531B6D0]();
  _Unwind_Resume(a1);
}

void ___ZNK13MemoryCookies24newCookieArrayEnumeratorEP12CookieSifter_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  CFContainerEnumeratorBase::setup((unint64_t)v83, a2, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
  uint64_t v74 = v84;
  if (v84 >= 1)
  {
    uint64_t v3 = 0;
    CFTypeRef cf2 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
    uint64_t v80 = *MEMORY[0x1E4F1D260];
    uint64_t v76 = a1;
    do
    {
      uint64_t v4 = *(void *)(v85 + 8 * v3);
      if (*(unsigned char *)(a1 + 48))
      {
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), *(const void **)(v85 + 8 * v3));
      }
      else
      {
        if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
          dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
        }
        if (v4) {
          uint64_t v5 = v4 + 16;
        }
        else {
          uint64_t v5 = 0;
        }
        CFDataRef v6 = *(const __CFData **)(v5 + 16);
        if (!v6 || (uint64_t v7 = *(void *)(v76 + 40), (BytePtr = CFDataGetBytePtr(v6)) == 0))
        {
          unsigned int v10 = 0;
          long long v116 = 0u;
          long long v117 = 0u;
          long long v114 = 0u;
          long long v115 = 0u;
          long long v112 = 0u;
          long long v113 = 0u;
          long long v110 = 0u;
          long long v111 = 0u;
          long long v108 = 0u;
          long long v109 = 0u;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v104 = 0u;
          long long v105 = 0u;
          long long v102 = 0u;
          long long v103 = 0u;
          long long v100 = 0u;
          long long v101 = 0u;
          long long v98 = 0u;
          long long v99 = 0u;
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          long long v92 = 0u;
          long long v93 = 0u;
          long long v90 = 0u;
          long long v91 = 0u;
          long long v88 = 0u;
          long long v89 = 0u;
          long long v86 = 0u;
          long long v87 = 0u;
          goto LABEL_106;
        }
        uint64_t v9 = *((unsigned int *)BytePtr + 1);
        long long v116 = 0u;
        long long v117 = 0u;
        long long v114 = 0u;
        long long v115 = 0u;
        long long v112 = 0u;
        long long v113 = 0u;
        long long v110 = 0u;
        long long v111 = 0u;
        long long v108 = 0u;
        long long v109 = 0u;
        long long v106 = 0u;
        long long v107 = 0u;
        long long v104 = 0u;
        long long v105 = 0u;
        long long v102 = 0u;
        long long v103 = 0u;
        long long v100 = 0u;
        long long v101 = 0u;
        long long v98 = 0u;
        long long v99 = 0u;
        long long v96 = 0u;
        long long v97 = 0u;
        long long v94 = 0u;
        long long v95 = 0u;
        long long v92 = 0u;
        long long v93 = 0u;
        long long v90 = 0u;
        long long v91 = 0u;
        long long v88 = 0u;
        long long v89 = 0u;
        long long v86 = 0u;
        long long v87 = 0u;
        if (v9 >= 0x41) {
          operator new[]();
        }
        if (v9)
        {
          uint64_t v11 = 0;
          unsigned int v81 = 0;
          uint64_t v78 = v5;
          uint64_t v79 = v3;
          uint64_t v77 = v9;
          while (1)
          {
            CFDataRef v12 = *(const __CFData **)(v5 + 16);
            uint64_t v82 = v11;
            if (v12 && CFDataGetBytePtr(v12))
            {
              uint64_t v13 = CFDataGetBytePtr(*(CFDataRef *)(v5 + 16));
              uint64_t v14 = *(const UInt8 **)(v5 + 16);
              uint64_t v15 = *(unsigned int *)&v13[4 * v11 + 8];
              if (v14) {
                uint64_t v14 = CFDataGetBytePtr((CFDataRef)v14);
              }
              uint64_t v16 = (CompactCookieHeader *)&v14[v15];
            }
            else
            {
              uint64_t v16 = 0;
            }
            uint64_t v17 = *(void *)(v7 + 840);
            if (!*(void *)(v7 + 24))
            {
              if ((v17 & 0x20) == 0) {
                goto LABEL_101;
              }
              goto LABEL_102;
            }
            BOOL v18 = 0;
            for (unint64_t i = 0; i != 20; ++i)
            {
              uint64_t v20 = v7 + 40 * i;
              uint64_t v22 = *(void *)(v20 + 40);
              CFDataRef v21 = (CookieSifter::Term *)(v20 + 40);
              if (v22)
              {
                int v23 = CookieData::sCookieFieldInfo[5 * i + 3];
                switch(v23)
                {
                  case 0:
                    goto LABEL_91;
                  case 1:
                    EnumeratedString = (char *)CompactCookieHeader::getEnumeratedString(v16, i, 0);
                    uint64_t v37 = v7 + 40 * i;
                    int v39 = *(_DWORD *)(v37 + 72);
                    unint64_t v38 = (_DWORD *)(v37 + 72);
                    if (v39 != 2)
                    {
                      CookieSifter::Term::cleanCache(v21);
                      *unint64_t v38 = 2;
                      CFAllocatorRef v40 = CFGetAllocator(*(CFTypeRef *)v21);
                      CFStringRef v41 = *(const __CFString **)v21;
                      CFAllocatorRef valuePtr = v40;
                      v119[0] = 1023;
                      if (v41)
                      {
                        CString = _CFStringGetOrCreateCString(v40, v41, v120, v119, 0x8000100u);
                      }
                      else
                      {
                        v120[0] = 0;
                        v119[0] = 0;
                        CString = v120;
                      }
                      v119[1] = (uint64_t)CString;
                      *(void *)(v7 + 40 * i + 56) = strdup((const char *)CString);
                      if (CString && v120 != CString) {
                        CFAllocatorDeallocate(valuePtr, CString);
                      }
                    }
                    CFDictionaryRef v63 = *(const char **)(v7 + 40 * i + 56);
                    if (EnumeratedString == v63) {
                      goto LABEL_91;
                    }
                    if (!EnumeratedString)
                    {
                      BOOL v51 = *v63 == 0;
LABEL_87:
                      BOOL v50 = v51;
                      goto LABEL_90;
                    }
                    uint64_t v64 = *(void *)(v7 + 840);
                    if ((v64 & 2) != 0)
                    {
                      if (v64) {
                        int v66 = strcmp(EnumeratedString, v63);
                      }
                      else {
                        int v66 = strcasecmp(EnumeratedString, v63);
                      }
                      BOOL v51 = v66 == 0;
                      goto LABEL_87;
                    }
                    if (v64) {
                      uint64_t v65 = strstr(EnumeratedString, v63);
                    }
                    else {
                      uint64_t v65 = strcasestr(EnumeratedString, v63);
                    }
                    BOOL v50 = v65 != 0;
LABEL_90:
                    if (!v50) {
                      goto LABEL_93;
                    }
LABEL_91:
                    char v67 = 1;
                    char v68 = 1;
                    char v69 = 1;
                    if ((v17 & 0x10) == 0) {
                      goto LABEL_95;
                    }
                    goto LABEL_94;
                  case 2:
                  case 4:
                    unsigned __int8 EnumeratedTime = CompactCookieHeader::getEnumeratedTime((uint64_t)v16, i);
                    double v26 = v25;
                    uint64_t v27 = v7 + 40 * i;
                    int v29 = *(_DWORD *)(v27 + 72);
                    uint64_t v28 = (_DWORD *)(v27 + 72);
                    if (v29 != 1)
                    {
                      CookieSifter::Term::cleanCache(v21);
                      *uint64_t v28 = 1;
                      BOOL v30 = (unsigned char *)(v7 + 40 * i + 56);
                      if (*(void *)v21 == v80)
                      {
                        *BOOL v30 = 0;
                      }
                      else
                      {
                        *BOOL v30 = 1;
                        *(double *)(v7 + 40 * i + 64) = MEMORY[0x185319AB0]();
                      }
                    }
                    uint64_t v47 = v7 + 40 * i;
                    double v48 = *(double *)(v47 + 64);
                    BOOL v49 = *(unsigned __int8 *)(v47 + 56) == EnumeratedTime;
                    if (v48 > v26) {
                      BOOL v49 = 0;
                    }
                    BOOL v50 = v48 >= v26 && v49;
                    goto LABEL_90;
                  case 3:
                  case 5:
                  case 6:
                  case 7:
                    goto LABEL_93;
                  case 8:
                    uint64_t v43 = v7 + 40 * i;
                    int v45 = *(_DWORD *)(v43 + 72);
                    uint64_t v44 = (_DWORD *)(v43 + 72);
                    if (v45 != 3)
                    {
                      CookieSifter::Term::cleanCache(v21);
                      *uint64_t v44 = 3;
                      operator new();
                    }
                    CFStringRef v46 = *(unsigned __int16 **)(v7 + 40 * i + 56);
                    if (*(_DWORD *)v16 < 0x10u) {
                      goto LABEL_93;
                    }
                    uint64_t v52 = *((unsigned int *)v16 + 3);
                    if (!v52) {
                      goto LABEL_93;
                    }
                    uint64_t v53 = 0;
                    uint64_t v54 = *(void *)(v7 + 840);
                    unint64_t v55 = *v46;
                    break;
                  default:
                    if (v23 != 16) {
                      goto LABEL_93;
                    }
                    int EnumeratedBoolean = CompactCookieHeader::getEnumeratedBoolean(v16, i);
                    uint64_t v32 = v7 + 40 * i;
                    int v34 = *(_DWORD *)(v32 + 72);
                    uint64_t v33 = (_DWORD *)(v32 + 72);
                    if (v34 == 4)
                    {
                      int v35 = *(unsigned __int8 *)(v7 + 40 * i + 56);
                    }
                    else
                    {
                      CookieSifter::Term::cleanCache(v21);
                      *uint64_t v33 = 4;
                      int v35 = CFEqual(*(CFTypeRef *)v21, cf2);
                      *(unsigned char *)(v7 + 40 * i + 56) = v35;
                    }
                    BOOL v51 = EnumeratedBoolean == v35;
                    goto LABEL_87;
                }
                while (2)
                {
                  uint64_t v56 = (2 * v53 + 56);
                  uint64_t v57 = *(_DWORD *)v16;
                  if (v57 > v56 && (char *)v16 + v56 + 2 <= (char *)v16 + v57)
                  {
                    int v59 = *(unsigned __int16 *)((char *)v16 + v56);
                    if (*v46) {
                      goto LABEL_58;
                    }
                    goto LABEL_65;
                  }
                  int v59 = 0;
                  if (!*v46) {
                    goto LABEL_65;
                  }
LABEL_58:
                  if (v46[1] == v59) {
                    goto LABEL_59;
                  }
                  unint64_t v60 = 0;
                  do
                  {
                    if (v55 - 1 == v60) {
                      goto LABEL_65;
                    }
                    int v61 = v46[v60++ + 2];
                  }
                  while (v61 != v59);
                  if (v60 < v55)
                  {
LABEL_59:
                    if ((v54 & 8) == 0) {
                      goto LABEL_91;
                    }
                    BOOL v50 = 1;
                  }
                  else
                  {
LABEL_65:
                    if ((v54 & 8) != 0) {
                      break;
                    }
                    BOOL v50 = 0;
                  }
                  if (++v53 == v52) {
                    goto LABEL_90;
                  }
                  continue;
                }
              }
LABEL_93:
              char v67 = 0;
              char v68 = 0;
              char v69 = 0;
              if ((v17 & 0x10) != 0) {
                break;
              }
LABEL_94:
              BOOL v18 = i > 0x12;
              char v69 = v67;
            }
LABEL_95:
            if ((v17 & 0x10) != 0) {
              char v70 = v69;
            }
            else {
              char v70 = 0;
            }
            if (!v18) {
              char v70 = v68;
            }
            uint64_t v5 = v78;
            uint64_t v3 = v79;
            uint64_t v9 = v77;
            if ((v70 != 0) == ((*(unsigned char *)(v7 + 840) & 0x20) == 0)) {
LABEL_101:
            }
              *((void *)&v86 + v81++) = v16;
LABEL_102:
            uint64_t v11 = v82 + 1;
            if (v82 + 1 == v9)
            {
              unsigned int v10 = v81;
              goto LABEL_106;
            }
          }
        }
        unsigned int v10 = 0;
LABEL_106:
        CFGetAllocator((CFTypeRef)(v5 - 16));
        if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
          dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
        }
        uint64_t Instance = (void *)_CFRuntimeCreateInstance();
        uint64_t v72 = (CompactCookieArray *)Instance;
        if (Instance)
        {
          Instance[2] = 0;
          Instance[3] = 0;
          uint64_t v72 = (CompactCookieArray *)(Instance + 2);
          Instance[4] = 0;
        }
        CompactCookieArray::CompactCookieArray(v72, (const CompactCookieHeader **)&v86, v10);
        if (v72)
        {
          CFURLRef v73 = (char *)v72 - 16;
          CFArrayAppendValue(*(CFMutableArrayRef *)(v76 + 32), v73);
          CFRelease(v73);
        }
      }
      ++v3;
      a1 = v76;
    }
    while (v3 != v74);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v83);
}

void sub_1842754F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

_OWORD *MemoryCookies::clone(CFAllocatorRef *this)
{
  uint64_t v2 = CFAllocatorAllocate(this[1], 32, 0);
  *uint64_t v2 = 0u;
  v2[1] = 0u;
  CFAllocatorRef v3 = this[1];
  CFDictionaryRef v4 = this[3];
  *(void *)uint64_t v2 = &unk_1ECF9C338;
  *((void *)v2 + 1) = v3;
  *((void *)v2 + 2) = &unk_1ECF9C360;
  *((void *)v2 + 3) = CFDictionaryCreateMutableCopy(v3, 0, v4);
  return v2;
}

void sub_184275600(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void MemoryCookies::visitCookies(uint64_t a1, uint64_t a2)
{
  v3[0] = 0;
  v3[1] = v3;
  uint64_t v3[2] = 0x2020000000;
  char v4 = 0;
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZNK13MemoryCookies12visitCookiesEU13block_pointerFvPK19CompactCookieHeaderPbE_block_invoke;
  v2[3] = &unk_1E52560F8;
  void v2[4] = a2;
  void v2[5] = v3;
  MemoryCookies::withImmutableDomains(a1, (uint64_t)v2);
  _Block_object_dispose(v3, 8);
}

void sub_1842756B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZNK13MemoryCookies12visitCookiesEU13block_pointerFvPK19CompactCookieHeaderPbE_block_invoke(uint64_t a1, const void *a2)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    CFContainerEnumeratorBase::setup((unint64_t)v17, a2, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
    uint64_t v20 = 0;
    if (v18 >= 1)
    {
      uint64_t v3 = 0;
      do
      {
        if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
          break;
        }
        uint64_t v20 = v3 + 1;
        uint64_t v4 = *(void *)(v19 + 8 * v3);
        if (v4)
        {
          if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
            dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
          }
          uint64_t v5 = v4 + 16;
        }
        else
        {
          uint64_t v5 = 0;
        }
        CFDataRef v6 = *(const __CFData **)(v5 + 16);
        if (v6)
        {
          BytePtr = CFDataGetBytePtr(v6);
          if (BytePtr)
          {
            uint64_t v8 = *((unsigned int *)BytePtr + 1);
            if (v8)
            {
              uint64_t v9 = 0;
              uint64_t v10 = 4 * v8;
              do
              {
                uint64_t v11 = *(void *)(a1 + 32);
                CFDataRef v12 = *(const __CFData **)(v5 + 16);
                if (v12 && CFDataGetBytePtr(v12))
                {
                  uint64_t v13 = CFDataGetBytePtr(*(CFDataRef *)(v5 + 16));
                  uint64_t v14 = *(const UInt8 **)(v5 + 16);
                  uint64_t v15 = *(unsigned int *)&v13[v9 + 8];
                  if (v14) {
                    uint64_t v14 = CFDataGetBytePtr((CFDataRef)v14);
                  }
                  uint64_t v16 = &v14[v15];
                }
                else
                {
                  uint64_t v16 = 0;
                }
                (*(void (**)(uint64_t, const UInt8 *, uint64_t))(v11 + 16))(v11, v16, *(void *)(*(void *)(a1 + 40) + 8) + 24);
                v9 += 4;
              }
              while (v10 != v9);
            }
          }
        }
        uint64_t v3 = v20;
      }
      while (v20 < v18);
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v17);
  }
}

void sub_184275868(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

uint64_t MemoryCookies::_mergeCookiesFrom(MemoryCookies *this, char *a2, CFDictionaryRef *a3, void *a4)
{
  if (a2)
  {
    if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
      dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
    }
    uint64_t v7 = (CompactCookieArray *)(a2 + 16);
  }
  else
  {
    uint64_t v7 = 0;
  }

  return MemoryCookies::setCookiesWithPartitionedDomains(a3, (const unsigned __int8 *)this, v7, 0);
}

void MemoryCookies::updateDomainCookieArrayAccessTimeLocked(uint64_t a1, uint64_t a2, const __CFArray *a3)
{
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), *(const void **)(a2 + 312));
  if (Value)
  {
    uint64_t v5 = Value;
    if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
      dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
    }
    unint64_t Count = CFArrayGetCount(a3);
    if (Count)
    {
      if (Count >> 61) {
        abort();
      }
      uint64_t v7 = std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(Count);
    }
    else
    {
      uint64_t v7 = 0;
    }
    CFDataRef v8 = (const __CFData *)v5[4];
    if (v8)
    {
      BytePtr = CFDataGetBytePtr(v8);
      if (BytePtr)
      {
        if (*((_DWORD *)BytePtr + 1)) {
          operator new[]();
        }
      }
    }
    CFRetain(v5);
    if (v7) {
      operator delete(v7);
    }
    CFRelease(v5);
  }
}

void sub_184275E68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, CompactHTTPCookieWithData a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZNK13MemoryCookies7isEmptyEv_block_invoke(uint64_t a1, const void *a2)
{
  CFContainerEnumeratorBase::setup((unint64_t)v7, a2, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
  uint64_t v10 = 0;
  if (v8 >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
        break;
      }
      uint64_t v10 = v3 + 1;
      uint64_t v4 = *(void *)(v9 + 8 * v3);
      if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
        dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
      }
      CFDataRef v5 = *(const __CFData **)(v4 + 32);
      if (v5)
      {
        BytePtr = CFDataGetBytePtr(v5);
        if (BytePtr)
        {
          if (*((_DWORD *)BytePtr + 1)) {
            *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
          }
        }
      }
      uint64_t v3 = v10;
    }
    while (v10 < v8);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v7);
}

void sub_184275FD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'MemoryCookieStorage::~MemoryCookieStorage(MemoryCookieStorage *this)
{
  uint64_t v2 = (char *)this - 24;
  MemoryCookieStorage::~MemoryCookieStorage((MemoryCookieStorage *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  MemoryCookieStorage::~MemoryCookieStorage((MemoryCookieStorage *)((char *)this - 24));
}

void MemoryCookieStorage::setCookiesWithPoliciesAppliedLocked(CFAllocatorRef *this, const __CFArray *a2, const HTTPCookieStoragePolicy *a3)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  uint64_t v3[2] = ___ZN19MemoryCookieStorage35setCookiesWithPoliciesAppliedLockedEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke;
  void v3[3] = &__block_descriptor_40_e116_r__CompactCookieArray___________CFData__332__0_DomainAndPartition_____CFAbsoluteTimeAsSpecified_Cd__256C__Q____8C328l;
  void v3[4] = this;
  PrivateHTTPCookieStorage::setCookiesWithPoliciesAppliedCommonImpl(this, a2, a3, (uint64_t)v3);
}

uint64_t ___ZN19MemoryCookieStorage35setCookiesWithPoliciesAppliedLockedEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 72);
  DomainAndPartition::DomainAndPartition((uint64_t)&v9, a2);
  MemoryCookies::copyCookiesInDomain(*(const __CFDictionary **)(v4 + 24), v12, a3);
  uint64_t v6 = v5;
  uint64_t v9 = &unk_1ECF9F1A0;
  if (v11) {
    BOOL v7 = v11 == &v10;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    free(v11);
  }
  return v6;
}

void sub_184276164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t *a45)
{
  if (a45) {
    BOOL v46 = a45 == &a13;
  }
  else {
    BOOL v46 = 1;
  }
  if (!v46) {
    free(a45);
  }
  _Unwind_Resume(exception_object);
}

void MemoryCookieStorage::visitCookiesLocked(uint64_t a1, uint64_t a2)
{
}

uint64_t MemoryCookieStorage::getCookieAcceptPolicyLocked(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(a2 + 16))(a2, *(unsigned int *)(a1 + 80));
}

uint64_t MemoryCookieStorage::setCookieAcceptPolicyLocked(uint64_t this, int a2)
{
  *(_DWORD *)(this + 80) = a2;
  return this;
}

void MemoryCookieStorage::addToArchiveInternalLocked(MemoryCookieStorage *this, CFMutableArrayRef theArray)
{
}

void sub_184276338(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MemoryCookieStorage::syncStorageWithCompletionLocked(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  }
  return result;
}

void MemoryCookieStorage::updateDomainCookieArrayAccessTimeLocked(uint64_t a1, uint64_t a2, const __CFArray *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 72);
  DomainAndPartition::DomainAndPartition((uint64_t)v6, a2);
  MemoryCookies::updateDomainCookieArrayAccessTimeLocked(v4, (uint64_t)v6, a3);
  v6[0] = &unk_1ECF9F1A0;
  if (v8) {
    BOOL v5 = v8 == &v7;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    free(v8);
  }
}

void sub_184276434(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45)
{
  if (a45) {
    BOOL v47 = a45 == (void *)(v45 + 24);
  }
  else {
    BOOL v47 = 1;
  }
  if (!v47) {
    free(a45);
  }
  _Unwind_Resume(exception_object);
}

void MemoryCookieStorage::deleteAllCookiesSinceDateLocked(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x3052000000;
  uint64_t v11 = __Block_byref_object_copy__12013;
  CFDataRef v12 = __Block_byref_object_dispose__12014;
  uint64_t v13 = 0;
  if (a1[9])
  {
    double v5 = MEMORY[0x185319AB0](a2);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    uint64_t v7[2] = ___ZN19MemoryCookieStorage31deleteAllCookiesSinceDateLockedEPK8__CFDateU13block_pointerFvP7NSArrayE_block_invoke;
    v7[3] = &unk_1E5256148;
    *(double *)&void v7[6] = v5;
    v7[4] = &v8;
    void v7[5] = a1;
    (*(void (**)(void *, void *))(*a1 + 192))(a1, v7);
    uint64_t v6 = (void *)v9[5];
    if (v6) {
      (*(void (**)(uint64_t, void *))(a3 + 16))(a3, v6);
    }
  }
  _Block_object_dispose(&v8, 8);
}

void sub_1842765A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__12013(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__12014(uint64_t a1)
{
}

uint64_t ___ZN19MemoryCookieStorage31deleteAllCookiesSinceDateLockedEPK8__CFDateU13block_pointerFvP7NSArrayE_block_invoke(uint64_t result, CompactCookieHeader *a2)
{
  uint64_t v3 = result;
  double v4 = 0.0;
  if (*(_DWORD *)a2 >= 0x38u) {
    double v4 = floor(*((double *)a2 + 6));
  }
  if (v4 >= *(double *)(result + 48))
  {
    MemoryCookies::deleteCookie(*(MemoryCookies **)(*(void *)(result + 40) + 72), a2);
    if (!*(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 40)) {
      *(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    }
    id v5 = [[NSHTTPCookie alloc] _initWithHeader:a2];
    uint64_t v6 = *(void **)(*(void *)(*(void *)(v3 + 32) + 8) + 40);
    return [v6 addObject:v5];
  }
  return result;
}

void MemoryCookieStorage::deleteAllCookiesLocked(MemoryCookieStorage *this)
{
  uint64_t v2 = *((void *)this + 9);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (MemoryCookies *)CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 32, 0);
  *(_OWORD *)uint64_t v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  MemoryCookies::MemoryCookies(v3, *((CFAllocatorRef *)this + 1));
  *((void *)this + 9) = v4;
}

uint64_t MemoryCookieStorage::deleteCookieInternalLocked(const HTTPCookieStoragePolicy **this, CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3, const MemoryCookies *a4)
{
  uint64_t result = PrivateHTTPCookieStorage::allowCookieToBeWrittenConsideringHTTPOnly((PrivateHTTPCookieStorage *)a2, (const CompactCookieHeader *)*((unsigned int *)a3 + 18), this[9], a4);
  if (result)
  {
    uint64_t v7 = this[9];
    return MemoryCookies::deleteCookie(v7, a2);
  }
  return result;
}

uint64_t MemoryCookieStorage::setCookieInternalLocked(const HTTPCookieStoragePolicy **this, CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3, const MemoryCookies *a4)
{
  uint64_t result = PrivateHTTPCookieStorage::allowCookieToBeWrittenConsideringHTTPOnly((PrivateHTTPCookieStorage *)a2, (const CompactCookieHeader *)*((unsigned int *)a3 + 18), this[9], a4);
  if (result)
  {
    uint64_t v7 = (CompactCookieArray **)this[9];
    return MemoryCookies::setCookie(v7, a2);
  }
  return result;
}

void MemoryCookieStorage::newCookieArrayEnumeratorLocked(uint64_t a1, uint64_t a2)
{
}

uint64_t MemoryCookieStorage::copyPersistentCookiesLocked(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = MemoryCookies::clone(*(CFAllocatorRef **)(a1 + 72));
  uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 16))(a2, v3);
  if (v3)
  {
    id v5 = *(uint64_t (**)(_OWORD *))(*(void *)v3 + 8);
    return v5(v3);
  }
  return result;
}

CFStringRef MemoryCookieStorage::copyDebugDescLocked(MemoryCookieStorage *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v1 = (const __CFAllocator *)*((void *)this + 1);
  uint64_t v2 = *((void *)this + 9);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
  v4[3] = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
  void v4[4] = v6;
  int v5 = 1024;
  MemoryCookies::withImmutableDomains(v2, (uint64_t)v4);
  return CFStringCreateWithFormat(v1, 0, @"Memory Cookies: { %p, %s }", v2, v6);
}

uint64_t MemoryCookieStorage::wantsSyncTimer(MemoryCookieStorage *this)
{
  return 0;
}

void sub_184277340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1842774DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184277A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_184277BC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184277D00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184277E28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842781D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842783A0(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_184278898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184278A30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void DiskCookieStorage::Journal::~Journal(DiskCookieStorage::Journal *this)
{
  *(void *)this = &unk_1ECFA5D38;
  uint64_t v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);

  CFAllocatorDeallocate(v3, this);
}

{
  const void *v1;

  *(void *)this = &unk_1ECFA5D38;
  CFAllocatorRef v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

void DiskCookieStorage::setCookiesWithPoliciesAppliedLocked(CFAllocatorRef *this, const __CFArray *a2, const HTTPCookieStoragePolicy *a3)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  uint64_t v3[2] = ___ZN17DiskCookieStorage35setCookiesWithPoliciesAppliedLockedEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke;
  void v3[3] = &__block_descriptor_40_e116_r__CompactCookieArray___________CFData__332__0_DomainAndPartition_____CFAbsoluteTimeAsSpecified_Cd__256C__Q____8C328l;
  void v3[4] = this;
  PrivateHTTPCookieStorage::setCookiesWithPoliciesAppliedCommonImpl(this, a2, a3, (uint64_t)v3);
}

uint64_t ___ZN17DiskCookieStorage35setCookiesWithPoliciesAppliedLockedEPK9__CFArrayRK23HTTPCookieStoragePolicy_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 296);
  if (!v3) {
    return 0;
  }
  DomainAndPartition::DomainAndPartition((uint64_t)&v8, a2);
  MemoryCookies::copyCookiesInDomain(*(const __CFDictionary **)(v3 + 24), v11, a3);
  uint64_t v6 = v5;
  uint64_t v8 = &unk_1ECF9F1A0;
  if (v10 && v10 != &v9) {
    free(v10);
  }
  return v6;
}

void sub_184278C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t *a45)
{
  if (a45)
  {
    if (a45 != &a13) {
      free(a45);
    }
  }
  _Unwind_Resume(exception_object);
}

void DiskCookieStorage::visitCookiesLocked(uint64_t a1, uint64_t a2)
{
}

void DiskCookieStorage::_asyncWriteFileCompletely(DiskCookieStorage *this, void *a2)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v32 = "_asyncWriteFileCompletely";
  int v33 = 0;
  uint64_t v37 = 0;
  CFTypeRef cf = 0;
  uint64_t v35 = 0;
  int v36 = 0;
  uint64_t v3 = *((void *)this + 131);
  if (v3)
  {
    uint64_t v52 = 0;
    uint64_t v53 = &v52;
    uint64_t v54 = 0x2020000000;
    char v55 = 1;
    *(void *)&long long v41 = MEMORY[0x1E4F143A8];
    *((void *)&v41 + 1) = 3221225472;
    *(void *)&long long v42 = ___ZNK13MemoryCookies7isEmptyEv_block_invoke;
    *((void *)&v42 + 1) = &unk_1E5256120;
    *(void *)&long long v43 = &v52;
    MemoryCookies::withImmutableDomains(v3, (uint64_t)&v41);
    int v4 = *((unsigned __int8 *)v53 + 24);
    _Block_object_dispose(&v52, 8);
    if (v4)
    {
      uint64_t v5 = *((void *)this + 130);
      if (*(_DWORD *)(v5 + 320) == 2)
      {
        if (unlink((const char *)(*(void *)(v5 + 72) + 1))) {
          __error();
        }
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v41 = 0u;
        DiskCookieStorage::writeCompleted(*((void *)this + 130), &v41, *((void *)this + 131));
        goto LABEL_42;
      }
    }
  }
  int v6 = 3;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  while (1)
  {
    uint64_t v7 = *((void *)this + 130);
    uint64_t v8 = *((void *)this + 131);
    uint64_t v9 = *((void *)this + 132);
    CFAllocatorRef v10 = *(const __CFAllocator **)(v7 + 8);
    uint64_t v11 = getpid();
    AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)&v52, v10, @"_tmp_%d.dat", v11);
    FilePath::FilePath((uint64_t)&v41, *(void *)(v7 + 72), (uint64_t)v53);
    int v12 = open_dprotected_np((const char *)&v41 + 1, 1537, 3, 0, 438);
    if (v12 < 0)
    {
      int v18 = *__error();
      int v39 = v18;
      if (v12 != -1 || v18 != 2) {
        goto LABEL_21;
      }
      size_t v19 = strlen((const char *)&v41 + 1);
      CFURLRef v20 = CFURLCreateFromFileSystemRepresentation(allocator, (const UInt8 *)&v41 + 1, v19, 0);
      FilePathStorage<unsigned char>::mkParentDirs(v20, v50, v51, &v39);
      if (v20) {
        CFRelease(v20);
      }
      int v18 = v39;
      if (v39) {
        goto LABEL_21;
      }
      int v12 = open_dprotected_np((const char *)&v41 + 1, 1537, 3, 0, 438);
      if (v12 < 0)
      {
        int v18 = *__error();
LABEL_21:
        TracerData::set((TracerData *)&v32, v18, 0, "CantOpen", 637, (const char *)&v41 + 1);
        goto LABEL_39;
      }
    }
    uint64_t v13 = (__CFWriteStream *)_CFWriteStreamCreateFromFileDescriptor();
    if (!v13)
    {
      if (close(v12)) {
        __error();
      }
      TracerData::set((TracerData *)&v32, 2, 0, "CantCreateWriteStream", 644, (const char *)&v41 + 1);
      goto LABEL_39;
    }
    uint64_t v14 = *(void *)(v7 + 72);
    if (*(_DWORD *)(v14 + 1028) == 1)
    {
      uint64_t v15 = (const UInt8 *)(v14 + 1);
      size_t v16 = strlen((const char *)(v14 + 1));
      if (CFURLCreateFromFileSystemRepresentation(*(CFAllocatorRef *)(v7 + 8), v15, v16, 0)) {
        operator new();
      }
    }
    if (!CFWriteStreamOpen(v13))
    {
      CFErrorRef v21 = CFWriteStreamCopyError(v13);
      if (v21)
      {
        TracerData::set((TracerData *)&v32, 0, v21, "CantOpenWriteStream", 671, (const char *)&v41 + 1);
        CFRelease(v21);
      }
      else
      {
        TracerData::set((TracerData *)&v32, 2, 0, "CantOpenWriteStream", 669, (const char *)&v41 + 1);
      }
      CFRelease(v13);
      goto LABEL_39;
    }
    uint64_t v17 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t, __CFWriteStream *, uint64_t))(*(void *)v7 + 208))(v7, v8, v13, v9);
    if (!v17) {
      break;
    }
    TracerData::set((TracerData *)&v32, 0, v17, "WriteCookiesToStream", 684, (const char *)&v41 + 1);
    CFRelease(v17);
    CFWriteStreamClose(v13);
    CFRelease(v13);
LABEL_39:
    AutoString::~AutoString((AutoString *)&v52);
    if (!--v6)
    {
      if (v35) {
        DiskCookieStorage::traceError(*((DiskCookieStorage **)this + 130), (const TracerData *)&v32);
      }
      goto LABEL_42;
    }
  }
  fstat(v12, &v38);
  CFWriteStreamClose(v13);
  CFRelease(v13);
  rename((const std::__fs::filesystem::path *)((char *)&v41 + 1), (const std::__fs::filesystem::path *)(*(void *)(v7 + 72) + 1), v22);
  if (v23 < 0) {
    int v24 = *__error();
  }
  else {
    int v24 = 0;
  }
  *(unsigned char *)(v7 + 325) = 1;
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  if (DarwinNotifyCenter) {
    CFNotificationCenterPostNotification(DarwinNotifyCenter, *(CFNotificationName *)(v7 + 328), 0, 0, 1u);
  }
  if (v24)
  {
    AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)v40, allocator, @"Error renaming the temporary file to %s", *(void *)(v7 + 72) + 1);
    AutoString::getCString((AutoString *)v40);
    TracerData::set((TracerData *)&v32, v24, 0, "CantRename", 764, (const char *)&v41 + 1);
    AutoString::~AutoString((AutoString *)v40);
    if (unlink((const char *)&v41 + 1)) {
      __error();
    }
    goto LABEL_39;
  }
  stat v31 = v38;
  AutoString::~AutoString((AutoString *)&v52);
  int v33 = 0;
  CFTypeRef v29 = cf;
  CFTypeRef cf = 0;
  if (v29) {
    CFRelease(v29);
  }
  uint64_t v35 = 0;
  int v36 = 0;
  free(v37);
  uint64_t v37 = 0;
  DiskCookieStorage::writeCompleted(*((void *)this + 130), &v31, *((void *)this + 131));
LABEL_42:
  uint64_t v26 = *((void *)this + 133);
  if (v26)
  {
    (*(void (**)(void))(v26 + 16))();
    _Block_release(*((const void **)this + 133));
  }
  (*(void (**)(void))(**((void **)this + 130) + 48))(*((void *)this + 130));
  uint64_t v27 = (const void *)*((void *)this + 132);
  if (v27) {
    CFRelease(v27);
  }
  uint64_t v28 = *((void *)this + 131);
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
  }
  MEMORY[0x18531B6D0](this, 0x10E0C408C693DC2);
  if (cf) {
    CFRelease(cf);
  }
  free(v37);
}

void sub_184279340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void DiskCookieStorage::writeCompleted(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_72, 1);
  if (v6)
  {
    uint64_t v7 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)v6 + 32))(v6, "DiskCookieStorage Updated", a1))
    {
      if (a3)
      {
        uint64_t v26 = (void (**)(AutoString *__hidden))MEMORY[0x1E4F143A8];
        uint64_t v27 = 3221225472;
        uint64_t v28 = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
        CFTypeRef v29 = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
        BOOL v30 = cStr;
        int v31 = 256;
        MemoryCookies::withImmutableDomains(a3, (uint64_t)&v26);
        uint64_t v8 = cStr;
      }
      else
      {
        uint64_t v8 = "null";
      }
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v26 = off_1ECF9A530;
      CFStringRef v10 = CFStringCreateWithCString(v9, "Persistent Cookies", 0x8000100u);
      uint64_t v28 = 0;
      CFTypeRef v29 = 0;
      uint64_t v27 = (uint64_t)v10;
      uint64_t v22 = off_1ECF9A530;
      CFStringRef v11 = CFStringCreateWithCString(v9, v8, 0x8000100u);
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      CFStringRef v23 = v11;
      (*(void (**)(uint64_t, uint64_t, CFStringRef))(*(void *)v7 + 64))(v7, v27, v11);
      AutoString::~AutoString((AutoString *)&v22);
      AutoString::~AutoString((AutoString *)&v26);
      uint64_t v12 = *(void *)(a1 + 280);
      uint64_t v26 = (void (**)(AutoString *__hidden))MEMORY[0x1E4F143A8];
      uint64_t v27 = 3221225472;
      uint64_t v28 = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
      CFTypeRef v29 = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
      BOOL v30 = cStr;
      int v31 = 256;
      MemoryCookies::withImmutableDomains(v12, (uint64_t)&v26);
      uint64_t v26 = off_1ECF9A530;
      CFStringRef v13 = CFStringCreateWithCString(v9, "Session Cookies", 0x8000100u);
      uint64_t v28 = 0;
      CFTypeRef v29 = 0;
      uint64_t v27 = (uint64_t)v13;
      uint64_t v22 = off_1ECF9A530;
      CFStringRef v14 = CFStringCreateWithCString(v9, cStr, 0x8000100u);
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      CFStringRef v23 = v14;
      (*(void (**)(uint64_t, uint64_t, CFStringRef))(*(void *)v7 + 64))(v7, v27, v14);
      AutoString::~AutoString((AutoString *)&v22);
      AutoString::~AutoString((AutoString *)&v26);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
      CFAbsoluteTimeGetCurrent();
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72))(v7, "Time from first dirty", @"%g");
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72))(v7, "Time from last  dirty", @"%g");
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72))(v7, "Total time to write", @"%g");
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(_OWORD *)(a1 + CFRelease((char *)this - 128) = *a2;
  long long v15 = a2[1];
  long long v16 = a2[2];
  long long v17 = a2[4];
  *(_OWORD *)(a1 + 176) = a2[3];
  *(_OWORD *)(a1 + 192) = v17;
  *(_OWORD *)(a1 + 144) = v15;
  *(_OWORD *)(a1 + 16MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v16;
  long long v18 = a2[5];
  long long v19 = a2[6];
  long long v20 = a2[8];
  *(_OWORD *)(a1 + 24MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = a2[7];
  *(_OWORD *)(a1 + 256) = v20;
  *(_OWORD *)(a1 + 208) = v18;
  *(_OWORD *)(a1 + 224) = v19;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

void sub_184279848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  AutoString::~AutoString((AutoString *)&a42);
  AutoString::~AutoString((AutoString *)(v42 - 256));
  _Unwind_Resume(a1);
}

void DiskCookieStorage::traceError(DiskCookieStorage *this, const TracerData *a2)
{
  uint64_t v3 = DiskCookieStorage::traceError(TracerData const*)::sLastError;
  if (!DiskCookieStorage::traceError(TracerData const*)::sLastError) {
LABEL_14:
  }
    operator new();
  if (*(void *)a2 != *(void *)DiskCookieStorage::traceError(TracerData const*)::sLastError) {
    goto LABEL_12;
  }
  if (*((_DWORD *)a2 + 2) != *(_DWORD *)(DiskCookieStorage::traceError(TracerData const*)::sLastError + 8)) {
    goto LABEL_12;
  }
  int v4 = (__CFError *)*((void *)a2 + 2);
  uint64_t v5 = *(__CFError **)(DiskCookieStorage::traceError(TracerData const*)::sLastError + 16);
  if (v4 != v5)
  {
    if (!v4) {
      goto LABEL_12;
    }
    if (!v5) {
      goto LABEL_12;
    }
    CFIndex Code = CFErrorGetCode(*((CFErrorRef *)a2 + 2));
    if (Code != CFErrorGetCode(v5)) {
      goto LABEL_12;
    }
    CFErrorDomain Domain = CFErrorGetDomain(v4);
    CFErrorDomain v8 = CFErrorGetDomain(v5);
    if (!CFEqual(Domain, v8)) {
      goto LABEL_12;
    }
  }
  uint64_t v9 = *((void *)a2 + 3);
  if (v9 != *(void *)(v3 + 24)
    || (uint64_t v10 = *((unsigned int *)a2 + 8), v10 != *(_DWORD *)(v3 + 32))
    || (CFStringRef v11 = (const char *)*((void *)a2 + 5), strcmp(v11, *(const char **)(v3 + 40))))
  {
LABEL_12:
    uint64_t v12 = DiskCookieStorage::traceError(TracerData const*)::sLastError;
    if (DiskCookieStorage::traceError(TracerData const*)::sLastError)
    {
      TracerData::clearError((TracerData *)DiskCookieStorage::traceError(TracerData const*)::sLastError);
      MEMORY[0x18531B6D0](v12, 0x1070C40A8115D6ALL);
    }
    goto LABEL_14;
  }
  CFStringRef v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s errno %d cferror %@ ep %s line %d path %s", *(void *)a2, *((unsigned int *)a2 + 2), *((void *)a2 + 2), v9, v10, v11);
  if (v13)
  {
    CFRelease(v13);
  }
}

void sub_18427A000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,CFAllocatorRef allocator,uint64_t a62,void *ptr)
{
  AutoString::~AutoString((AutoString *)&a42);
  if (ptr)
  {
    if (v63 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  _Unwind_Resume(a1);
}

void TracerData::clearError(TracerData *this)
{
  *((_DWORD *)this + 2) = 0;
  uint64_t v2 = (const void *)*((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  free(*((void **)this + 5));
  *((void *)this + 5) = 0;
}

os_log_t ___ZN17DiskCookieStorage10traceErrorEPK10TracerData_block_invoke()
{
  os_log_t result = os_log_create("com.apple.CFNetwork", "DiskCookies");
  DiskCookieStorage::traceError(TracerData const*)::l = (uint64_t)result;
  return result;
}

uint64_t FilePath::FilePath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a1 + 1028) = 0;
  *(_DWORD *)(a1 + 1028) = *(_DWORD *)(a2 + 1028);
  *(_DWORD *)(a1 + 1032) = *(_DWORD *)(a2 + 1032);
  *(unsigned char *)a1 = 0;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v6 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)(a2 + 1));
  CFStringRef v7 = CFStringCreateWithFormat(v5, 0, @"%@%@", v6, a3);
  if (v6) {
    CFRelease(v6);
  }
  if (v7)
  {
    CFURLRef v8 = CFURLCreateWithFileSystemPath(v5, v7, kCFURLPOSIXPathStyle, 0);
    CFRelease(v7);
    if (v8)
    {
      *(unsigned char *)a1 = CFURLGetFileSystemRepresentation(v8, 1u, (UInt8 *)(a1 + 1), 1024);
      CFRelease(v8);
    }
  }
  return a1;
}

char *TracerData::set(TracerData *this, int a2, CFTypeRef cf, const char *a4, int a5, const char *a6)
{
  *((_DWORD *)this + 2) = a2;
  CFStringRef v11 = (const void *)*((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v11) {
    CFRelease(v11);
  }
  if (cf) {
    CFTypeRef v12 = CFRetain(cf);
  }
  else {
    CFTypeRef v12 = 0;
  }
  *((void *)this + 2) = v12;
  *((void *)this + 3) = a4;
  *((_DWORD *)this + 8) = a5;
  free(*((void **)this + 5));
  if (a6) {
    os_log_t result = strdup(a6);
  }
  else {
    os_log_t result = 0;
  }
  *((void *)this + 5) = result;
  return result;
}

void FilePathStorage<unsigned char>::mkParentDirs(const void *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v8 = CFGetAllocator(a1);
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(v8, (CFURLRef)a1);
  FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v15, PathComponent, a2, a3, 0);
  if (v17) {
    mode_t v10 = 448;
  }
  else {
    mode_t v10 = 493;
  }
  int v11 = mkdir(v16, v10);
  int v12 = 0;
  if ((v11 & 0x80000000) == 0)
  {
LABEL_5:
    *a4 = v12;
    goto LABEL_6;
  }
  int v13 = *__error();
  *a4 = v13;
  if (v13 == 2)
  {
    FilePathStorage<unsigned char>::mkParentDirs(PathComponent, a2, a3, a4);
    if (v17) {
      mode_t v14 = 448;
    }
    else {
      mode_t v14 = 493;
    }
    if (mkdir(v16, v14) < 0) {
      int v12 = *__error();
    }
    else {
      int v12 = 0;
    }
    goto LABEL_5;
  }
LABEL_6:
  if (PathComponent) {
    CFRelease(PathComponent);
  }
}

uint64_t ___ZN17DiskCookieStorage14writeCompletedERK12FilePathStatPK13MemoryCookies_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 859;
  *(void *)(a1 + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN17DiskCookieStorage31syncStorageWithCompletionLockedEhU13block_pointerFvvE_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 994;
  *(void *)(a1 + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN17DiskCookieStorage31syncStorageWithCompletionLockedEhU13block_pointerFvvE_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 961;
  *(void *)(a1 + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void DiskCookieStorage::updateDomainCookieArrayAccessTimeLocked(void *a1, uint64_t a2, const __CFArray *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  ++a1[39];
  uint64_t v6 = a1[37];
  if (v6)
  {
    DomainAndPartition::DomainAndPartition((uint64_t)v15, a2);
    MemoryCookies::updateDomainCookieArrayAccessTimeLocked(v6, (uint64_t)v15, a3);
    v15[0] = &unk_1ECF9F1A0;
    if (v17)
    {
      if (v17 != &v16) {
        free(v17);
      }
    }
  }
  uint64_t v7 = a1[36];
  if (v7)
  {
    DomainAndPartition::DomainAndPartition((uint64_t)v12, a2);
    MemoryCookies::updateDomainCookieArrayAccessTimeLocked(v7, (uint64_t)v12, a3);
    v12[0] = &unk_1ECF9F1A0;
    if (v14)
    {
      if (v14 != &v13) {
        free(v14);
      }
    }
  }
  uint64_t v8 = a1[35];
  if (v8)
  {
    DomainAndPartition::DomainAndPartition((uint64_t)v9, a2);
    MemoryCookies::updateDomainCookieArrayAccessTimeLocked(v8, (uint64_t)v9, a3);
    v9[0] = &unk_1ECF9F1A0;
    if (v11)
    {
      if (v11 != &v10) {
        free(v11);
      }
    }
  }
}

void sub_18427A67C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45)
{
  if (a45)
  {
    if (a45 != v45) {
      free(a45);
    }
  }
  _Unwind_Resume(a1);
}

void DiskCookieStorage::deleteAllCookiesSinceDateLocked(void *a1, uint64_t a2, uint64_t a3)
{
  ++a1[39];
  double v5 = MEMORY[0x185319AB0](a2);
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x3052000000;
  int v11 = __Block_byref_object_copy__12290;
  int v12 = __Block_byref_object_dispose__12291;
  uint64_t v13 = 0;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  uint64_t v7[2] = ___ZN17DiskCookieStorage31deleteAllCookiesSinceDateLockedEPK8__CFDateU13block_pointerFvP7NSArrayE_block_invoke;
  v7[3] = &unk_1E5256148;
  *(double *)&void v7[6] = v5;
  v7[4] = &v8;
  void v7[5] = a1;
  (*(void (**)(void *, void *))(*a1 + 192))(a1, v7);
  uint64_t v6 = (void *)v9[5];
  if (v6) {
    (*(void (**)(uint64_t, void *))(a3 + 16))(a3, v6);
  }
  _Block_object_dispose(&v8, 8);
}

void sub_18427A800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__12290(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__12291(uint64_t a1)
{
}

uint64_t ___ZN17DiskCookieStorage31deleteAllCookiesSinceDateLockedEPK8__CFDateU13block_pointerFvP7NSArrayE_block_invoke(uint64_t result, CompactCookieHeader *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    int v4 = *(void **)(result + 40);
    double v5 = 0.0;
    if (*(_DWORD *)a2 >= 0x38u) {
      double v5 = floor(*((double *)a2 + 6));
    }
    if (v5 >= *(double *)(result + 48))
    {
      uint64_t v6 = v4[38];
      if (v6) {
        DiskCookieStorage::Journal::record(v6, 1, (const UInt8 *)a2);
      }
      uint64_t v7 = (MemoryCookies *)v4[37];
      if (v7) {
        MemoryCookies::deleteCookie(v7, a2);
      }
      uint64_t v8 = (MemoryCookies *)v4[36];
      if (v8) {
        MemoryCookies::deleteCookie(v8, a2);
      }
      uint64_t v9 = (MemoryCookies *)v4[35];
      if (v9) {
        MemoryCookies::deleteCookie(v9, a2);
      }
      if (!*(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 40)) {
        *(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      }
      id v10 = [[NSHTTPCookie alloc] _initWithHeader:a2];
      int v11 = *(void **)(*(void *)(*(void *)(v3 + 32) + 8) + 40);
      return [v11 addObject:v10];
    }
  }
  return result;
}

void DiskCookieStorage::Journal::record(uint64_t a1, int a2, const UInt8 *a3)
{
  *(_DWORD *)bytes = a2;
  CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 16), bytes, 4);
  if (a3)
  {
    if (*(_DWORD *)a3 >= 4u) {
      CFIndex v5 = *(unsigned int *)a3;
    }
    else {
      CFIndex v5 = 0;
    }
    CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 16), a3, v5);
  }
}

void DiskCookieStorage::deleteAllCookiesLocked(DiskCookieStorage *this)
{
  uint64_t v2 = *((void *)this + 38);
  ++*((void *)this + 39);
  if (v2)
  {
    *(_DWORD *)bytes = 2;
    CFDataAppendBytes(*(CFMutableDataRef *)(v2 + 16), bytes, 4);
  }
  uint64_t v3 = (MemoryCookies *)*((void *)this + 37);
  if (v3) {
    MemoryCookies::deleteAllCookies(v3);
  }
  int v4 = (MemoryCookies *)*((void *)this + 36);
  if (v4) {
    MemoryCookies::deleteAllCookies(v4);
  }
  CFIndex v5 = (MemoryCookies *)*((void *)this + 35);
  if (v5) {
    MemoryCookies::deleteAllCookies(v5);
  }
  DiskCookieStorage::setDirtyAndNotifyInstantOff((os_unfair_lock_s *)this);
}

void DiskCookieStorage::setDirtyAndNotifyInstantOff(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 22;
  os_unfair_lock_lock(this + 22);
  double Current = CFAbsoluteTimeGetCurrent();
  *(double *)&this[26]._os_unfair_lock_opaque = Current;
  if (*(double *)&this[24]._os_unfair_lock_opaque == 0.0) {
    *(double *)&this[24]._os_unfair_lock_opaque = Current;
  }

  os_unfair_lock_unlock(v2);
}

void DiskCookieStorage::deleteCookieInternalLocked(DiskCookieStorage *this, CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3, const MemoryCookies *a4)
{
  if (PrivateHTTPCookieStorage::allowCookieToBeWrittenConsideringHTTPOnly((PrivateHTTPCookieStorage *)a2, (const CompactCookieHeader *)*((unsigned int *)a3 + 18), *((const HTTPCookieStoragePolicy **)this + 37), a4))
  {
    uint64_t v6 = *((void *)this + 38);
    ++*((void *)this + 39);
    if (v6) {
      DiskCookieStorage::Journal::record(v6, 1, (const UInt8 *)a2);
    }
    uint64_t v7 = (MemoryCookies *)*((void *)this + 35);
    if (v7) {
      MemoryCookies::deleteCookie(v7, a2);
    }
    uint64_t v8 = (MemoryCookies *)*((void *)this + 36);
    if (v8) {
      MemoryCookies::deleteCookie(v8, a2);
    }
    if (MemoryCookies::deleteCookie(*((MemoryCookies **)this + 37), a2))
    {
      DiskCookieStorage::setDirtyAndNotifyInstantOff((os_unfair_lock_s *)this);
    }
  }
}

uint64_t DiskCookieStorage::setCookieInternalLocked(DiskCookieStorage *this, CompactCookieHeader *a2, const HTTPCookieStoragePolicy *a3, const MemoryCookies *a4)
{
  if (!PrivateHTTPCookieStorage::allowCookieToBeWrittenConsideringHTTPOnly((PrivateHTTPCookieStorage *)a2, (const CompactCookieHeader *)*((unsigned int *)a3 + 18), *((const HTTPCookieStoragePolicy **)this + 37), a4))return 0; {
  ++*((void *)this + 39);
  }
  if (*(_DWORD *)a2 >= 0xCu && (*((_DWORD *)a2 + 2) & 2) != 0)
  {
    MemoryCookies::deleteCookie(*((MemoryCookies **)this + 36), a2);
    uint64_t v6 = MemoryCookies::setCookie(*((CompactCookieArray ***)this + 35), a2);
  }
  else
  {
    MemoryCookies::deleteCookie(*((MemoryCookies **)this + 35), a2);
    uint64_t v6 = MemoryCookies::setCookie(*((CompactCookieArray ***)this + 36), a2);
    uint64_t v7 = *((void *)this + 38);
    if (v7) {
      DiskCookieStorage::Journal::record(v7, 0, (const UInt8 *)a2);
    }
  }
  if (MemoryCookies::setCookie(*((CompactCookieArray ***)this + 37), a2)) {
    DiskCookieStorage::setDirtyAndNotifyInstantOff((os_unfair_lock_s *)this);
  }
  return v6;
}

intptr_t ___ZN17DiskCookieStorage31rereadFromDiskIfNecessaryLockedEv_block_invoke(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t DiskCookieStorage::newCookieArrayEnumeratorLocked(DiskCookieStorage *a1, uint64_t a2, uint64_t a3)
{
  DiskCookieStorage::rereadFromDiskIfNecessaryLocked(a1);
  uint64_t v6 = *((void *)a1 + 37);
  if (v6) {
    MemoryCookies::newCookieArrayEnumerator(v6, a2);
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t, void))(a3 + 16);

  return v7(a3, 0);
}

uint64_t DiskCookieStorage::copyPersistentCookiesLocked(CFAllocatorRef **a1, uint64_t a2)
{
  DiskCookieStorage::rereadFromDiskIfNecessaryLocked((DiskCookieStorage *)a1);
  int v4 = MemoryCookies::clone(a1[36]);
  uint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *))(a2 + 16))(a2, v4);
  if (v4)
  {
    uint64_t v6 = *(uint64_t (**)(_OWORD *))(*(void *)v4 + 8);
    return v6(v4);
  }
  return result;
}

CFStringRef DiskCookieStorage::copyDebugDescLocked(DiskCookieStorage *this)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = (const __CFAllocator *)*((void *)this + 1);
  uint64_t v3 = (const char *)(*((void *)this + 9) + 1);
  size_t v4 = strlen(v3);
  CFURLRef v5 = CFURLCreateFromFileSystemRepresentation(v2, (const UInt8 *)v3, v4, 0);
  CFStringRef v6 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v7 = *((void *)this + 37);
  if (v7)
  {
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
    void v15[3] = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
    void v15[4] = v17;
    int v16 = 1024;
    MemoryCookies::withImmutableDomains(v7, (uint64_t)v15);
  }
  else
  {
    strcpy(v17, "<cookies not yet read>");
  }
  CFAllocatorRef v8 = (const __CFAllocator *)*((void *)this + 1);
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  double v9 = *((double *)this + 12);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 22);
  if (v9 == 0.0) {
    id v10 = "clean";
  }
  else {
    id v10 = "dirty";
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  double v11 = *((double *)this + 14);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 22);
  int v12 = "writing";
  if (v11 == 0.0) {
    int v12 = "not writing";
  }
  CFStringRef v13 = CFStringCreateWithFormat(v8, 0, @"Disk Cookies: { %@, %s %s %s }", v6, v17, v10, v12);
  if (v6) {
    CFRelease(v6);
  }
  return v13;
}

uint64_t DiskCookieStorage::invalidateLocked(uint64_t this)
{
  *(unsigned char *)(this + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0;
  return this;
}

uint64_t DiskCookieStorage::wantsSyncTimer(DiskCookieStorage *this)
{
  return 1;
}

void DiskCookieStorage::_handleCookiesChangedNotification(DiskCookieStorage *this, __CFNotificationCenter *a2, void *a3, const __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  if (*((unsigned char *)a2 + 325)) {
    *((unsigned char *)a2 + 325) = 0;
  }
  else {
    *((unsigned char *)a2 + 324) = 1;
  }
}

uint64_t ___ZN17DiskCookieStorage10initializeEPK13MemoryCookies_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  CFAllocatorRef v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 255;
  *(void *)(a1 + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void DiskCookieStorage::~DiskCookieStorage(DiskCookieStorage *this)
{
  *(void *)this = &unk_1ECF9E2B8;
  *((void *)this + 3) = &unk_1ECF9E3A8;
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  if (DarwinNotifyCenter) {
    CFNotificationCenterRemoveEveryObserver(DarwinNotifyCenter, this);
  }
  uint64_t v3 = *((void *)this + 35);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 36);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 37);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 9);
  if (v6) {
    MEMORY[0x18531B6D0](v6, 0x1000C4048165BC6);
  }
  *((void *)this + 9) = 0;
  uint64_t v7 = *((void *)this + 38);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  CFAllocatorRef v8 = *((void *)this + 10);
  if (v8) {
    dispatch_release(v8);
  }
  double v9 = (const void *)*((void *)this + 41);
  if (v9) {
    CFRelease(v9);
  }

  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(this);
}

void sub_18427B11C(_Unwind_Exception *a1)
{
  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN17DiskCookieStorage18requiresJournalingEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  CFAllocatorRef v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1147;
  *(void *)(a1 + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t CFNetworkTrust::strictEvaluate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = 0;
  if (MEMORY[0x18531B160](*(void *)(a1 + 8), &v7)) {
    return 4294957494;
  }
  else {
    return CFNetworkTrust::processStrictEvaluateResult(a1, a2, a3, v7);
  }
}

uint64_t CFNetworkTrust::errorForEvaluationFalure(CFNetworkTrust *this)
{
  if ((*((unsigned char *)this + 32) & 0x20) != 0) {
    return *((unsigned int *)this + 10);
  }
  if ((*((unsigned char *)this + 32) & 0x10) != 0) {
    return *((unsigned int *)this + 9);
  }
  if (*((char *)this + 32) < 0) {
    int v1 = -9815;
  }
  else {
    int v1 = -9807;
  }
  if ((*((unsigned char *)this + 32) & 0x40) != 0) {
    int v2 = -9812;
  }
  else {
    int v2 = v1;
  }
  if ((*((unsigned char *)this + 32) & 4) != 0) {
    int v3 = -9814;
  }
  else {
    int v3 = v2;
  }
  if ((*((unsigned char *)this + 32) & 2) != 0) {
    unsigned int v4 = -9843;
  }
  else {
    unsigned int v4 = v3;
  }
  if (*((unsigned char *)this + 32)) {
    return 4294957483;
  }
  else {
    return v4;
  }
}

void *BundleUtilities::effectiveBundleID(BundleUtilities *this, CFDataRef theData, CFTypeRef cf)
{
  *(void *)this = 0;
  if (theData && (unint64_t)CFDataGetLength(theData) >= 0x20)
  {
    CFDataGetBytePtr(theData);
    uint64_t v22 = 0;
    gotLoadHelper_x8__CPCopyBundleIdentifierAndTeamFromAuditToken(v6);
    if (*(void *)(v8 + 3416))
    {
      long long v9 = v7[1];
      long long v20 = *v7;
      long long v21 = v9;
      CPCopyBundleIdentifierAndTeamFromAuditToken_delayInitStub(*(double *)&v20);
      uint64_t v10 = v22;
    }
    else
    {
      uint64_t v10 = 0;
    }
    uint64_t v15 = MEMORY[0x1E4F143A8];
    uint64_t v16 = 3221225472;
    int v17 = ___ZN15BundleUtilities17effectiveBundleIDEPK8__CFDataPK10__CFStringb_block_invoke;
    uint64_t v18 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v19 = v10;
  }
  if (cf)
  {
    uint64_t result = (void *)CFRetain(cf);
    *(void *)this = result;
    if (result) {
      return result;
    }
  }
  else
  {
    *(void *)this = 0;
  }
  MainBundle = CFBundleGetMainBundle();
  uint64_t result = (void *)CFBundleGetIdentifier(MainBundle);
  if (result)
  {
    CFStringRef v13 = CFBundleGetMainBundle();
    CFStringRef Identifier = CFBundleGetIdentifier(v13);
    uint64_t result = (void *)CFRetain(Identifier);
  }
  *(void *)this = result;
  return result;
}

void sub_18427B3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  void *v12 = 0;
  _Unwind_Resume(a1);
}

void ___ZN15BundleUtilities17effectiveBundleIDEPK8__CFDataPK10__CFStringb_block_invoke(uint64_t a1)
{
  int v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t _CFNetworkHTTPConnectionCacheGetLimit(int a1)
{
  if (mutableGlobalLimits(void)::sOnce != -1) {
    dispatch_once(&mutableGlobalLimits(void)::sOnce, &__block_literal_global_11_12382);
  }
  int v2 = (unsigned int *)mutableGlobalLimits(void)::gLimits;
  switch(a1)
  {
    case 0:
      goto LABEL_14;
    case 1:
      int v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 4);
      goto LABEL_14;
    case 2:
      int v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 8);
      goto LABEL_14;
    case 3:
      int v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 12);
      goto LABEL_14;
    case 4:
      int v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 16);
      goto LABEL_14;
    case 5:
      int v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 20);
      goto LABEL_14;
    case 6:
      int v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 24);
      goto LABEL_14;
    case 7:
      int v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 28);
      goto LABEL_14;
    case 8:
      int v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 32);
      goto LABEL_14;
    case 9:
      int v2 = (unsigned int *)(mutableGlobalLimits(void)::gLimits + 36);
LABEL_14:
      uint64_t result = *v2;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

void non-virtual thunk to'URLCredentialClientCertificate::~URLCredentialClientCertificate(URLCredentialClientCertificate *this)
{
}

{
  URLCredentialClientCertificate::~URLCredentialClientCertificate((URLCredentialClientCertificate *)((char *)this - 24));
}

{
  URLCredentialClientCertificate::~URLCredentialClientCertificate((URLCredentialClientCertificate *)((char *)this - 8));
}

{
  URLCredentialClientCertificate::~URLCredentialClientCertificate((URLCredentialClientCertificate *)((char *)this - 8));
}

void URLCredentialClientCertificate::~URLCredentialClientCertificate(URLCredentialClientCertificate *this)
{
  *(void *)this = &unk_1ECFA4EA0;
  *((void *)this + 1) = &unk_1ECFA4F30;
  *((void *)this + 3) = &unk_1ECFA4F60;
  int v2 = (const void *)*((void *)this + 9);
  if (v2) {
    CFRelease(v2);
  }
  int v3 = (const void *)*((void *)this + 8);
  if (v3) {
    CFRelease(v3);
  }

  URLCredential::~URLCredential(this);
}

void sub_18427B5FC(_Unwind_Exception *a1)
{
  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'URLCredentialClientCertificate::serializeToPropertyList(const __CFArray **this, SerializableArchive **a2)
{
  return 1;
}

uint64_t URLCredentialClientCertificate::serializeToPropertyList(const __CFArray **this, SerializableArchive **a2)
{
  return 1;
}

BOOL non-virtual thunk to'URLCredentialClientCertificate::initializeFromPropertyList(URLCredentialClientCertificate *this, CFDictionaryRef *a2)
{
  return URLCredentialClientCertificate::initializeFromPropertyList((URLCredentialClientCertificate *)((char *)this - 8), a2);
}

BOOL URLCredentialClientCertificate::initializeFromPropertyList(URLCredentialClientCertificate *this, CFDictionaryRef *a2)
{
  BOOL result = URLCredential::initializeFromPropertyList(this, a2);
  if (result)
  {
    double v6 = 0;
    CFTypeID TypeID = CFArrayGetTypeID();
    DeserializableArchive::decant(a2, @"certs", TypeID, (CFErrorRef *)&v6);
    *((void *)this + 8) = v6;
    return 1;
  }
  return result;
}

uint64_t URLCredentialClientCertificate::getCertificateIdentity(URLCredentialClientCertificate *this)
{
  return *((void *)this + 9);
}

uint64_t URLCredentialClientCertificate::getCertificateArray(URLCredentialClientCertificate *this)
{
  return *((void *)this + 8);
}

CFStringRef URLCredentialClientCertificate::copyStorageNameForCredentialType(URLCredentialClientCertificate *this)
{
  SecCertificateRef certificateRef = 0;
  int v2 = (__SecIdentity *)*((void *)this + 9);
  if (!v2 || SecIdentityCopyCertificate(v2, &certificateRef))
  {
    CFArrayRef v3 = (const __CFArray *)*((void *)this + 8);
    if (!v3) {
      return 0;
    }
    CFStringRef ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v3, 0);
    SecCertificateRef certificateRef = ValueAtIndex;
    if (!ValueAtIndex) {
      return 0;
    }
    CFRetain(ValueAtIndex);
  }
  if (!certificateRef) {
    return 0;
  }
  CFStringRef v5 = SecCertificateCopySubjectSummary(certificateRef);
  if (certificateRef) {
    CFRelease(certificateRef);
  }
  return v5;
}

uint64_t URLCredentialClientCertificate::calcHash(URLCredentialClientCertificate *this, uint64_t a2)
{
  return a2;
}

uint64_t URLCredentialClientCertificate::copy(URLCredentialClientCertificate *this)
{
  CFGetAllocator((char *)this - 16);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 8MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0u;
  *(_OWORD *)(Instance + CFRelease((char *)this - 16) = 0u;
  *(void *)(Instance + 32) = &gConstantCFStringValueTable[3773];
  *(_DWORD *)(Instance + 48) = 3;
  *(unsigned char *)(Instance + 64) = 0;
  *(void *)(Instance + 72) = 0;
  *(void *)(Instance + 56) = 0;
  *(void *)(Instance + CFRelease((char *)this - 16) = &unk_1ECFA4EA0;
  *(void *)(Instance + 24) = &unk_1ECFA4F30;
  *(void *)(Instance + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = &unk_1ECFA4F60;
  URLCredentialClientCertificate::initialize(Instance + 16, *((CFTypeRef *)this + 9), *((const __CFArray **)this + 8), *((_DWORD *)this + 9));
  return Instance;
}

uint64_t URLCredentialClientCertificate::initialize(uint64_t a1, CFTypeRef cf, const __CFArray *MutableCopy, int a4)
{
  *(_DWORD *)(a1 + 36) = a4;
  if (!cf) {
    return 0;
  }
  *(void *)(a1 + 72) = CFRetain(cf);
  if (MutableCopy)
  {
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, 0);
    if (CFEqual(ValueAtIndex, cf))
    {
      CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)(a1 - 16));
      MutableCFDictionaryRef Copy = CFArrayCreateMutableCopy(v8, 0, MutableCopy);
      CFArrayRemoveValueAtIndex(MutableCopy, 0);
    }
    else
    {
      MutableCFDictionaryRef Copy = (const __CFArray *)CFRetain(MutableCopy);
    }
  }
  *(void *)(a1 + 64) = MutableCopy;
  return 1;
}

CFStringRef URLCredentialClientCertificate::copyDebugDesc(URLCredentialClientCertificate *this)
{
  int v2 = (char *)this - 16;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, @"<CFURLCredential %p>{ identity = %@, certificate array = %@, persistence = %d}", v2, *((void *)this + 9), *((void *)this + 8), *((unsigned int *)this + 9));
}

BOOL URLCredentialClientCertificate::equals(URLCredentialClientCertificate *this, const CFObject *a2)
{
  BOOL result = URLCredential::equals(this, a2);
  if (result)
  {
    unint64_t v5 = *((void *)this + 9);
    unint64_t v6 = *((void *)a2 + 9);
    if (v5 | v6) {
      return (v5 == 0) == (v6 == 0) && CFEqual((CFTypeRef)v5, (CFTypeRef)v6) != 0;
    }
    else {
      return 1;
    }
  }
  return result;
}

void URLCredentialClientCertificate::URLCredentialClientCertificate(URLCredentialClientCertificate *this)
{
  *((void *)this + 2) = (char *)&gConstantCFStringValueTable + 30184;
  *((_DWORD *)this + 8) = 3;
  *((unsigned char *)this + 48) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_1ECFA4EA0;
  *((void *)this + 1) = &unk_1ECFA4F30;
  *((void *)this + 3) = &unk_1ECFA4F60;
}

void non-virtual thunk to'URLCredentialInternetPassword::~URLCredentialInternetPassword(URLCredentialInternetPassword *this)
{
}

{
  URLCredentialInternetPassword::~URLCredentialInternetPassword((URLCredentialInternetPassword *)((char *)this - 24));
}

{
  URLCredentialInternetPassword::~URLCredentialInternetPassword((URLCredentialInternetPassword *)((char *)this - 8));
}

{
  URLCredentialInternetPassword::~URLCredentialInternetPassword((URLCredentialInternetPassword *)((char *)this - 8));
}

void URLCredentialInternetPassword::~URLCredentialInternetPassword(URLCredentialInternetPassword *this)
{
  *(void *)this = &unk_1ECFA4AB0;
  *((void *)this + 1) = &unk_1ECFA4B58;
  *((void *)this + 3) = &unk_1ECFA4B88;
  int v2 = (const void *)*((void *)this + 8);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 9);
  if (v3) {
    CFRelease(v3);
  }
  unsigned int v4 = (const void *)*((void *)this + 10);
  if (v4) {
    CFRelease(v4);
  }
  unint64_t v5 = (const void *)*((void *)this + 12);
  if (v5) {
    CFRelease(v5);
  }

  URLCredential::~URLCredential(this);
}

void sub_18427BB84(_Unwind_Exception *a1)
{
  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'URLCredentialInternetPassword::serializeToPropertyList(CFDictionaryRef *this, SerializableArchive **a2)
{
  return 1;
}

uint64_t URLCredentialInternetPassword::serializeToPropertyList(CFDictionaryRef *this, SerializableArchive **a2)
{
  URLCredential::serializeToPropertyList((URLCredential *)this, a2);
  CFDictionaryRef v4 = this[8];
  SerializableArchive::assertEmpty(*a2, @"username");
  if (v4) {
    CFDictionarySetValue(*a2, @"username", v4);
  }
  CFDictionaryRef v5 = this[9];
  SerializableArchive::assertEmpty(*a2, @"password");
  if (v5) {
    CFDictionarySetValue(*a2, @"password", v5);
  }
  SerializableArchive::add((SerializableArchive *)a2, @"attributes", this[10]);
  CFDictionaryRef v6 = this[12];
  SerializableArchive::assertEmpty(*a2, @"identifier");
  if (v6) {
    CFDictionarySetValue(*a2, @"identifier", v6);
  }
  return 1;
}

BOOL non-virtual thunk to'URLCredentialInternetPassword::initializeFromPropertyList(URLCredentialInternetPassword *this, CFDictionaryRef *a2)
{
  return URLCredentialInternetPassword::initializeFromPropertyList((URLCredentialInternetPassword *)((char *)this - 8), a2);
}

BOOL URLCredentialInternetPassword::initializeFromPropertyList(URLCredentialInternetPassword *this, CFDictionaryRef *a2)
{
  BOOL result = URLCredential::initializeFromPropertyList(this, a2);
  if (result)
  {
    CFNumberRef Value = CFDictionaryGetValue(*a2, @"username");
    if (Value) {
      CFNumberRef Value = CFRetain(Value);
    }
    *((void *)this + 8) = Value;
    CFDictionaryRef v6 = CFDictionaryGetValue(*a2, @"password");
    if (v6) {
      CFDictionaryRef v6 = CFRetain(v6);
    }
    *((void *)this + 9) = v6;
    long long v9 = 0;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    DeserializableArchive::decant(a2, @"attributes", TypeID, (CFErrorRef *)&v9);
    *((void *)this + 1MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v9;
    CFAllocatorRef v8 = CFDictionaryGetValue(*a2, @"identifier");
    if (v8) {
      CFAllocatorRef v8 = CFRetain(v8);
    }
    *((void *)this + 12) = v8;
    return 1;
  }
  return result;
}

uint64_t URLCredentialInternetPassword::initialize(uint64_t a1, const __CFString *a2, const __CFString *a3, int a4, const __CFDictionary *a5)
{
  if (a2)
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(a2)) {
      return 0;
    }
  }
  if (a3)
  {
    CFTypeID v11 = CFStringGetTypeID();
    if (v11 != CFGetTypeID(a3)) {
      return 0;
    }
  }
  *(_DWORD *)(a1 + 36) = a4;
  if (a2)
  {
    CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)(a1 - 16));
    CFStringRef Copy = CFStringCreateCopy(v12, a2);
  }
  else
  {
    CFStringRef Copy = 0;
  }
  *(void *)(a1 + 64) = Copy;
  if (a3)
  {
    CFAllocatorRef v15 = CFGetAllocator((CFTypeRef)(a1 - 16));
    CFStringRef v16 = CFStringCreateCopy(v15, a3);
  }
  else
  {
    CFStringRef v16 = 0;
  }
  *(void *)(a1 + 72) = v16;
  if (a5)
  {
    CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)(a1 - 16));
    CFDictionaryRef v18 = CFDictionaryCreateCopy(v17, a5);
  }
  else
  {
    CFDictionaryRef v18 = 0;
  }
  *(void *)(a1 + 8MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v18;
  *(void *)(a1 + 96) = 0;
  return 1;
}

BOOL URLCredentialInternetPassword::containsPassword(URLCredentialInternetPassword *this)
{
  return *((void *)this + 10) || *((void *)this + 9) != 0;
}

CFStringRef URLCredentialInternetPassword::copyPassword(URLCredentialInternetPassword *this)
{
  if (!*((void *)this + 9))
  {
    if (*((void *)this + 10))
    {
      CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
      MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(v2, 0, *((CFDictionaryRef *)this + 10));
      if (MutableCopy)
      {
        CFDictionaryRef v4 = MutableCopy;
        CFDictionaryRef v5 = (const void *)*MEMORY[0x1E4F1CFD0];
        CFDictionarySetValue(MutableCopy, (const void *)*MEMORY[0x1E4F3BC70], (const void *)*MEMORY[0x1E4F1CFD0]);
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F3B978], (const void *)*MEMORY[0x1E4F3B998]);
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F3BB80], (const void *)*MEMORY[0x1E4F3BB90]);
        if (*((unsigned char *)this + 88)) {
          CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F3BD20], v5);
        }
        if (*((void *)this + 12))
        {
          CFDictionaryRef v6 = (const void *)*MEMORY[0x1E4F3B848];
          CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 10), (const void *)*MEMORY[0x1E4F3B848]);
          if (Value)
          {
            CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ (%@)", Value, *((void *)this + 12));
            CFDictionarySetValue(v4, v6, v8);
            CFRelease(v8);
          }
        }
        CFDataRef theData = 0;
        if (!(*((unsigned int (**)(__CFDictionary *, CFDataRef *))&_gFwStubs + 1))(v4, &theData) && theData)
        {
          CFAllocatorRef v9 = CFGetAllocator((char *)this - 16);
          BytePtr = CFDataGetBytePtr(theData);
          CFIndex Length = CFDataGetLength(theData);
          *((void *)this + 9) = CFStringCreateWithBytes(v9, BytePtr, Length, 0x8000100u, 0);
          if (theData) {
            CFRelease(theData);
          }
        }
        CFRelease(v4);
      }
    }
    if (!*((void *)this + 9)) {
      return 0;
    }
  }
  CFAllocatorRef v12 = CFGetAllocator((char *)this - 16);
  return CFStringCreateCopy(v12, *((CFStringRef *)this + 9));
}

uint64_t URLCredentialInternetPassword::getPassword(URLCredentialInternetPassword *this)
{
  if (*((void *)this + 9) && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 9)))) {
    return *((void *)this + 9);
  }
  else {
    return 0;
  }
}

uint64_t URLCredentialInternetPassword::getUserName(URLCredentialInternetPassword *this)
{
  if (*((void *)this + 8) && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 8)))) {
    return *((void *)this + 8);
  }
  else {
    return 0;
  }
}

CFTypeRef URLCredentialInternetPassword::copyStorageNameForCredentialType(URLCredentialInternetPassword *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 8);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

CFHashCode URLCredentialInternetPassword::calcHash(URLCredentialInternetPassword *this, CFHashCode a2)
{
  CFHashCode v2 = a2;
  CFDictionaryRef v4 = (const void *)*((void *)this + 8);
  if (v4) {
    CFHashCode v2 = CFHash(v4) ^ a2;
  }
  CFDictionaryRef v5 = (const void *)*((void *)this + 9);
  if (v5) {
    v2 ^= CFHash(v5);
  }
  return v2;
}

CFTypeRef URLCredentialInternetPassword::setIdentifier(URLCredentialInternetPassword *this, CFTypeRef cf)
{
  if (cf) {
    CFTypeRef result = CFRetain(cf);
  }
  else {
    CFTypeRef result = 0;
  }
  *((void *)this + 12) = result;
  return result;
}

uint64_t URLCredentialInternetPassword::setUseSystemKeychain(uint64_t this, char a2)
{
  *(unsigned char *)(this + 88) = a2;
  return this;
}

uint64_t URLCredentialInternetPassword::copy(URLCredentialInternetPassword *this)
{
  CFGetAllocator((char *)this - 16);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 8MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(void *)(Instance + 112) = 0;
  *(_OWORD *)(Instance + CFRelease((char *)this - 16) = 0u;
  *(void *)(Instance + 32) = &gConstantCFStringValueTable[3773];
  *(_DWORD *)(Instance + 48) = 0;
  *(unsigned char *)(Instance + 64) = 0;
  *(void *)(Instance + 72) = 0;
  *(void *)(Instance + 56) = 0;
  *(void *)(Instance + CFRelease((char *)this - 16) = &unk_1ECFA4AB0;
  *(void *)(Instance + 24) = &unk_1ECFA4B58;
  *(void *)(Instance + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = &unk_1ECFA4B88;
  *(unsigned char *)(Instance + 104) = 0;
  URLCredentialInternetPassword::initialize(Instance + 16, *((const __CFString **)this + 8), *((const __CFString **)this + 9), *((_DWORD *)this + 9), *((const __CFDictionary **)this + 10));
  (*(void (**)(uint64_t, void))(*(void *)(Instance + 16) + 88))(Instance + 16, *((void *)this + 12));
  return Instance;
}

CFStringRef URLCredentialInternetPassword::copyDebugDesc(URLCredentialInternetPassword *this)
{
  CFHashCode v2 = (char *)this - 16;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, @"<CFURLCredential %p>{username = %@, password = %@, persistence = %d, attributes = %@, identifier = %@}", v2, *((void *)this + 8), *((void *)this + 9), *((unsigned int *)this + 9), *((void *)this + 10), *((void *)this + 12));
}

unint64_t URLCredentialInternetPassword::equals(const __CFDictionary **this, const __CFDictionary **a2)
{
  unint64_t result = URLCredential::equals((URLCredential *)this, (const CFObject *)a2);
  if (result)
  {
    unint64_t v5 = (unint64_t)this[8];
    unint64_t v6 = (unint64_t)a2[8];
    if (!(v5 | v6)) {
      goto LABEL_6;
    }
    if ((v5 == 0) != (v6 == 0)) {
      return 0;
    }
    unint64_t result = CFEqual((CFTypeRef)v5, (CFTypeRef)v6);
    if (result)
    {
LABEL_6:
      CFDictionaryRef v7 = this[10];
      if (v7)
      {
LABEL_12:
        if (!URLCredentialInternetPassword::containsSWCACreator(v7)
          || (unint64_t result = (unint64_t)URLCredentialInternetPassword::containsSWCACreator(a2[10]), result))
        {
          if (!URLCredentialInternetPassword::containsSWCACreator(a2[10])) {
            return 1;
          }
          unint64_t result = (unint64_t)URLCredentialInternetPassword::containsSWCACreator(this[10]);
          if (result) {
            return 1;
          }
        }
        return result;
      }
      unint64_t v8 = (unint64_t)this[9];
      unint64_t v9 = (unint64_t)a2[9];
      if (!(v8 | v9))
      {
        CFDictionaryRef v7 = 0;
        goto LABEL_12;
      }
      if ((v8 == 0) != (v9 == 0)) {
        return 0;
      }
      unint64_t result = CFEqual((CFTypeRef)v8, (CFTypeRef)v9);
      if (result)
      {
        CFDictionaryRef v7 = this[10];
        goto LABEL_12;
      }
    }
  }
  return result;
}

const __CFDictionary *URLCredentialInternetPassword::containsSWCACreator(const __CFDictionary *this)
{
  if (this)
  {
    this = (const __CFDictionary *)CFDictionaryGetValue(this, (const void *)*MEMORY[0x1E4F3B670]);
    if (this)
    {
      int valuePtr = 0;
      return (const __CFDictionary *)(CFNumberGetValue(this, kCFNumberSInt32Type, &valuePtr) && valuePtr == 1937204065);
    }
  }
  return this;
}

void URLCredentialInternetPassword::URLCredentialInternetPassword(URLCredentialInternetPassword *this)
{
  *((void *)this + 2) = (char *)&gConstantCFStringValueTable + 30184;
  *((_DWORD *)this + 8) = 0;
  *((unsigned char *)this + 48) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_1ECFA4AB0;
  *((void *)this + 1) = &unk_1ECFA4B58;
  *((void *)this + 3) = &unk_1ECFA4B88;
  *((unsigned char *)this + 88) = 0;
}

void ConditionalConnectionSIMScheduler::ConditionalConnectionSIMScheduler(__CFDate const*,__CFNumber const*,__CFNumber const*,NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(void),void({block_pointer})(void))::$_0::__invoke(dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
}

void ConditionalConnectionSIMScheduler::ConditionalConnectionSIMScheduler(uint64_t a1, uint64_t a2, const __CFNumber *a3, CFNumberRef number)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = _ZN33ConditionalConnectionSIMScheduler6_queueMUlPU28objcproto17OS_dispatch_queue8NSObjectE_8__invokeES2_;
  *(_OWORD *)(a1 + 32) = 0u;
  CFDictionaryRef v7 = (void *)(a1 + 32);
  unint64_t v8 = (uint64_t *)(a1 + 40);
  *(_OWORD *)(a1 + CFRelease((char *)this - 16) = 0u;
  *(_WORD *)(a1 + 48) = 0;
  if (!number || (CFNumberGetValue(number, kCFNumberSInt64Type, v8), *v8 <= 3599)) {
    *unint64_t v8 = 3600;
  }
  if (a3) {
    CFNumberGetValue(a3, kCFNumberSInt64Type, v7);
  }
  if (a2) {
    *(double *)(a1 + 24) = MEMORY[0x185319AB0](a2);
  }
  SmartBlockWithArgs<>::SmartBlockWithArgs();
}

void sub_18427C6FC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 88);
  *(void *)(v1 + 88) = 0;
  if (v3) {
    (*(void (**)(void))(v1 + 96))();
  }
  CFDictionaryRef v4 = *(std::__shared_weak_count **)(v1 + 80);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  unint64_t v5 = *(std::__shared_weak_count **)(v1 + 64);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  unint64_t v6 = *(std::__shared_weak_count **)(v1 + 8);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  _Unwind_Resume(exception_object);
}

void ConditionalConnectionSIMScheduler::cancel(ConditionalConnectionSIMScheduler *this)
{
  *((unsigned char *)this + 49) = 1;
  CFHashCode v2 = *((void *)this + 2);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 2));
    *((void *)this + 2) = 0;
  }
}

void ConditionalConnectionSIMScheduler::start(ConditionalConnectionSIMScheduler *this)
{
  if (*((unsigned char *)this + 48)) {
    return;
  }
  *((unsigned char *)this + 48) = 1;
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    dispatch_time_t v3 = dispatch_time(0, 1000000000 * v2);
LABEL_11:
    dispatch_time_t v9 = v3;
    goto LABEL_12;
  }
  double v4 = *((double *)this + 3);
  if (v4 != 0.0)
  {
    double v5 = v4 - CFAbsoluteTimeGetCurrent();
    double v6 = *((double *)this + 3);
    if (v5 < 0.0)
    {
      double v6 = v6 - v5;
      *((double *)this + 3) = v6;
      *((void *)this + 5) += (int)v5;
    }
    __y.tv_seCC_MD5_CTX c = 0;
    double v7 = modf(v6, (long double *)&__y.tv_sec);
    double v8 = *(double *)&__y.tv_sec;
    if (v7 < 0.0)
    {
      double v8 = *(double *)&__y.tv_sec + -1.0;
      double v7 = v7 + 1.0;
    }
    __y.tv_seCC_MD5_CTX c = (uint64_t)(*MEMORY[0x1E4F1CF78] + v8);
    __y.tv_nseCC_MD5_CTX c = (uint64_t)(v7 * 1000000000.0 + 0.5);
    dispatch_time_t v3 = dispatch_walltime(&__y, 0);
    goto LABEL_11;
  }
  dispatch_time_t v9 = 0;
LABEL_12:
  if (*((uint64_t *)this + 5) >= 1)
  {
    uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 1);
    if (v10 && (uint64_t v11 = *(void *)this, (v12 = std::__shared_weak_count::lock(v10)) != 0))
    {
      CFStringRef v13 = v12;
      p_shared_weak_owners = &v12->__shared_weak_owners_;
      atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
      CFAllocatorRef v15 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *((dispatch_queue_t *)this + 11));
      *((void *)this + 2) = v15;
      v17[0] = MEMORY[0x1E4F143A8];
      v17[1] = 3321888768;
      void v17[2] = ___ZN33ConditionalConnectionSIMScheduler5startEv_block_invoke;
      v17[3] = &__block_descriptor_48_e8_32c58_ZTSNSt3__18weak_ptrI33ConditionalConnectionSIMSchedulerEE_e5_v8__0l;
      void v17[4] = v11;
      CFDictionaryRef v18 = v13;
      atomic_fetch_add_explicit(p_shared_weak_owners, 1uLL, memory_order_relaxed);
      dispatch_source_set_event_handler(v15, v17);
      dispatch_source_set_timer(*((dispatch_source_t *)this + 2), v9, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      dispatch_activate(*((dispatch_object_t *)this + 2));
      if (v18) {
        std::__shared_weak_count::__release_weak(v18);
      }
      std::__shared_weak_count::__release_weak(v13);
    }
    else
    {
      uint64_t v16 = std::__throw_bad_weak_ptr[abi:nn180100]();
      ___ZN33ConditionalConnectionSIMScheduler5startEv_block_invoke(v16);
    }
  }
}

void ___ZN33ConditionalConnectionSIMScheduler5startEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    dispatch_time_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      double v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        double v6 = *(NSObject **)(v5 + 16);
        if (v6)
        {
          v14[0] = MEMORY[0x1E4F143A8];
          v14[1] = 3321888768;
          void v14[2] = ___ZN33ConditionalConnectionSIMScheduler5startEv_block_invoke_2;
          v14[3] = &__block_descriptor_48_e8_32c58_ZTSNSt3__18weak_ptrI33ConditionalConnectionSIMSchedulerEE_e5_v8__0l;
          double v7 = *(std::__shared_weak_count **)(a1 + 40);
          v14[4] = v5;
          CFAllocatorRef v15 = v7;
          if (v7) {
            atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          dispatch_source_set_event_handler(v6, v14);
          double v8 = *(NSObject **)(v5 + 16);
          dispatch_time_t v9 = dispatch_time(0x8000000000000000, 1000000000 * *(void *)(v5 + 40));
          dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
          if (!*(unsigned char *)(v5 + 49))
          {
            uint64_t v10 = *(void *)(v5 + 56);
            if (v10)
            {
              uint64_t v11 = *(void (**)(void *))(v10 + 8);
              uint64_t v12 = *(void *)(v10 + 16);
              CFStringRef v13 = (void *)(v10 + (v12 >> 1));
              if (v12) {
                uint64_t v11 = *(void (**)(void *))(*v13 + v11);
              }
              v11(v13);
            }
          }
          if (v15) {
            std::__shared_weak_count::__release_weak(v15);
          }
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_18427CABC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c58_ZTSNSt3__18weak_ptrI33ConditionalConnectionSIMSchedulerEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_e8_32c58_ZTSNSt3__18weak_ptrI33ConditionalConnectionSIMSchedulerEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN33ConditionalConnectionSIMScheduler5startEv_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    dispatch_time_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      double v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        if (!*(unsigned char *)(v5 + 49))
        {
          uint64_t v6 = *(void *)(v5 + 72);
          if (v6)
          {
            double v7 = *(void (**)(void *))(v6 + 8);
            uint64_t v8 = *(void *)(v6 + 16);
            dispatch_time_t v9 = (void *)(v6 + (v8 >> 1));
            if (v8) {
              double v7 = *(void (**)(void *))(*v9 + v7);
            }
            v7(v9);
          }
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_18427CB98(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'URLCredentialKerberosTicket::~URLCredentialKerberosTicket(URLCredentialKerberosTicket *this)
{
}

{
  URLCredentialKerberosTicket::~URLCredentialKerberosTicket((URLCredentialKerberosTicket *)((char *)this - 24));
}

{
  URLCredentialKerberosTicket::~URLCredentialKerberosTicket((URLCredentialKerberosTicket *)((char *)this - 8));
}

{
  URLCredentialKerberosTicket::~URLCredentialKerberosTicket((URLCredentialKerberosTicket *)((char *)this - 8));
}

void URLCredentialKerberosTicket::~URLCredentialKerberosTicket(URLCredentialKerberosTicket *this)
{
  *(void *)this = &unk_1ECFA4350;
  *((void *)this + 1) = &unk_1ECFA43F8;
  *((void *)this + 3) = &unk_1ECFA4428;
  uint64_t v2 = (const void *)*((void *)this + 10);
  if (v2) {
    CFRelease(v2);
  }
  dispatch_time_t v3 = (const void *)*((void *)this + 9);
  if (v3) {
    CFRelease(v3);
  }
  double v4 = (const void *)*((void *)this + 8);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 11);
  if (v5) {
    CFRelease(v5);
  }

  URLCredential::~URLCredential(this);
}

void sub_18427CC74(_Unwind_Exception *a1)
{
  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'URLCredentialKerberosTicket::serializeToPropertyList(CFDictionaryRef *this, SerializableArchive **a2)
{
  return 1;
}

uint64_t URLCredentialKerberosTicket::serializeToPropertyList(CFDictionaryRef *this, SerializableArchive **a2)
{
  URLCredential::serializeToPropertyList((URLCredential *)this, a2);
  SerializableArchive::add((SerializableArchive *)a2, @"flags", this[8]);
  CFDictionaryRef v4 = this[9];
  SerializableArchive::assertEmpty(*a2, @"service");
  if (v4) {
    CFDictionarySetValue(*a2, @"service", v4);
  }
  CFDictionaryRef v5 = this[10];
  SerializableArchive::assertEmpty(*a2, @"principle");
  if (v5) {
    CFDictionarySetValue(*a2, @"principle", v5);
  }
  if (this[11])
  {
    CFAllocatorRef v6 = CFGetAllocator(this - 2);
    CFStringRef v7 = CFUUIDCreateString(v6, this[11]);
    SerializableArchive::assertEmpty(*a2, @"uuid");
    if (v7)
    {
      CFDictionarySetValue(*a2, @"uuid", v7);
      CFRelease(v7);
    }
  }
  else
  {
    SerializableArchive::assertEmpty(*a2, @"uuid");
  }
  return 1;
}

BOOL non-virtual thunk to'URLCredentialKerberosTicket::initializeFromPropertyList(URLCredentialKerberosTicket *this, CFDictionaryRef *a2)
{
  return URLCredentialKerberosTicket::initializeFromPropertyList((URLCredentialKerberosTicket *)((char *)this - 8), a2);
}

BOOL URLCredentialKerberosTicket::initializeFromPropertyList(URLCredentialKerberosTicket *this, CFDictionaryRef *a2)
{
  BOOL result = URLCredential::initializeFromPropertyList(this, a2);
  if (result)
  {
    uint64_t v12 = 0;
    CFTypeID TypeID = CFDictionaryGetTypeID();
    DeserializableArchive::decant(a2, @"flags", TypeID, (CFErrorRef *)&v12);
    *((void *)this + 8) = v12;
    CFNumberRef Value = CFDictionaryGetValue(*a2, @"service");
    if (Value) {
      CFNumberRef Value = CFRetain(Value);
    }
    *((void *)this + 9) = Value;
    CFStringRef v7 = CFDictionaryGetValue(*a2, @"principle");
    if (v7) {
      CFStringRef v7 = CFRetain(v7);
    }
    *((void *)this + 1MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v7;
    uint64_t v8 = CFDictionaryGetValue(*a2, @"uuid");
    if (v8 && (CFStringRef v9 = (const __CFString *)CFRetain(v8)) != 0)
    {
      CFStringRef v10 = v9;
      CFAllocatorRef v11 = CFGetAllocator((char *)this - 16);
      *((void *)this + 11) = CFUUIDCreateFromString(v11, v10);
      CFRelease(v10);
    }
    else
    {
      *((void *)this + 11) = 0;
    }
    return 1;
  }
  return result;
}

uint64_t URLCredentialKerberosTicket::getUUID(URLCredentialKerberosTicket *this)
{
  if (*((void *)this + 11) && (CFTypeID v2 = CFUUIDGetTypeID(), v2 == CFGetTypeID(*((CFTypeRef *)this + 11)))) {
    return *((void *)this + 11);
  }
  else {
    return 0;
  }
}

uint64_t URLCredentialKerberosTicket::getServicePrincipal(URLCredentialKerberosTicket *this)
{
  if (*((void *)this + 9) && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 9)))) {
    return *((void *)this + 9);
  }
  else {
    return 0;
  }
}

uint64_t URLCredentialKerberosTicket::getUserPrincipal(URLCredentialKerberosTicket *this)
{
  if (*((void *)this + 10) && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 10)))) {
    return *((void *)this + 10);
  }
  else {
    return 0;
  }
}

const __CFDictionary *URLCredentialKerberosTicket::getFlags(URLCredentialKerberosTicket *this)
{
  CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 8);
  if (result)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(result, @"kCFURLCredentialKerberosNoUIFlag");
    if (Value) {
      CFStringCompare(Value, @"TRUE", 1uLL);
    }
    CFDictionaryRef result = (const __CFDictionary *)*((void *)this + 8);
    if (result)
    {
      CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, @"kCFURLCredentialKerberosTicketAllowDelegation");
      if (result) {
        return (const __CFDictionary *)((CFStringCompare((CFStringRef)result, @"TRUE", 1uLL) == kCFCompareEqualTo) << 15);
      }
    }
  }
  return result;
}

uint64_t URLCredentialKerberosTicket::getUserName(URLCredentialKerberosTicket *this)
{
  if (*((void *)this + 10) && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 10)))) {
    return *((void *)this + 10);
  }
  else {
    return 0;
  }
}

CFStringRef URLCredentialKerberosTicket::copyStorageNameForCredentialType(URLCredentialKerberosTicket *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@/%@%@", *((void *)this + 10), *((void *)this + 9), *((void *)this + 11));
}

CFHashCode URLCredentialKerberosTicket::calcHash(URLCredentialKerberosTicket *this, uint64_t a2)
{
  uint64_t v2 = a2;
  CFDictionaryRef v4 = (const void *)*((void *)this + 9);
  if (v4) {
    return CFHash(v4) ^ a2;
  }
  CFDictionaryRef v4 = (const void *)*((void *)this + 11);
  if (v4) {
    return CFHash(v4) ^ a2;
  }
  return v2;
}

uint64_t URLCredentialKerberosTicket::copy(URLCredentialKerberosTicket *this)
{
  CFGetAllocator((char *)this - 16);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 8MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + CFRelease((char *)this - 16) = 0u;
  *(void *)(Instance + 32) = &gConstantCFStringValueTable[3773];
  *(_DWORD *)(Instance + 48) = 2;
  *(unsigned char *)(Instance + 64) = 0;
  *(void *)(Instance + 72) = 0;
  *(void *)(Instance + 56) = 0;
  *(void *)(Instance + CFRelease((char *)this - 16) = &unk_1ECFA4350;
  *(void *)(Instance + 24) = &unk_1ECFA43F8;
  *(void *)(Instance + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = &unk_1ECFA4428;
  *(void *)(Instance + 104) = 0;
  URLCredentialKerberosTicket::initialize((URLCredentialKerberosTicket *)(Instance + 16), *((const __CFString **)this + 10), *((const __CFString **)this + 9), *((const __CFDictionary **)this + 8), *((const __CFUUID **)this + 11));
  return Instance;
}

uint64_t URLCredentialKerberosTicket::initialize(URLCredentialKerberosTicket *this, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4, const __CFUUID *a5)
{
  uint64_t v8 = 0;
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 9) = 2;
  if (a2 && a3)
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(a3) || (CFTypeID v12 = CFStringGetTypeID(), v12 != CFGetTypeID(a2)))
    {
      uint64_t v8 = 0;
      if (a4) {
        goto LABEL_7;
      }
LABEL_9:
      keys[0] = @"kCFURLCredentialKerberosTicketAllowDelegation";
      keys[1] = @"kCFURLCredentialKerberosNoUIFlag";
      values[0] = @"TRUE";
      values[1] = @"TRUE";
      CFAllocatorRef v15 = CFGetAllocator((char *)this - 16);
      MutableCFStringRef Copy = CFDictionaryCreate(v15, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      goto LABEL_10;
    }
    *((void *)this + 9) = CFRetain(a3);
    *((void *)this + 1MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = CFRetain(a2);
    uint64_t v8 = 1;
  }
  if (!a4) {
    goto LABEL_9;
  }
LABEL_7:
  CFAllocatorRef v13 = CFGetAllocator((char *)this - 16);
  MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(v13, 0, a4);
  CFDictionaryAddValue(MutableCopy, @"kCFURLCredentialKerberosTicketAllowDelegation", @"TRUE");
  CFDictionaryAddValue(MutableCopy, @"kCFURLCredentialKerberosNoUIFlag", @"TRUE");
LABEL_10:
  *((void *)this + 8) = MutableCopy;
  if (a5)
  {
    CFTypeID v16 = CFUUIDGetTypeID();
    if (v16 == CFGetTypeID(a5))
    {
      *((void *)this + 11) = CFRetain(a5);
      return 1;
    }
  }
  return v8;
}

CFStringRef URLCredentialKerberosTicket::copyDebugDesc(URLCredentialKerberosTicket *this)
{
  uint64_t v2 = (char *)this - 16;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, @"<CFURLCredential %p>{userPrincipal = %@, hostPrincipal = %@, uuid = %@, kerberosFlags = %@, persistence = %d}", v2, *((void *)this + 10), *((void *)this + 9), *((void *)this + 11), *((void *)this + 8), *((unsigned int *)this + 9));
}

uint64_t URLCredentialKerberosTicket::equals(URLCredentialKerberosTicket *this, const CFObject *a2)
{
  uint64_t result = URLCredential::equals(this, a2);
  if (result)
  {
    CFDictionaryRef v5 = (const void *)*((void *)this + 9);
    if (!v5
      || (CFAllocatorRef v6 = (const void *)*((void *)a2 + 9)) == 0
      || CFEqual(v5, v6)
      || (CFAllocatorRef v11 = (const void *)*((void *)this + 10)) == 0
      || (CFTypeID v12 = (const void *)*((void *)a2 + 10)) == 0
      || (uint64_t result = CFEqual(v11, v12), result))
    {
      CFStringRef v7 = (const void *)*((void *)this + 8);
      if (!v7 || (uint64_t v8 = (const void *)*((void *)a2 + 8)) == 0 || (result = CFEqual(v7, v8), result))
      {
        CFStringRef v9 = (const void *)*((void *)this + 11);
        CFStringRef v10 = (const void *)*((void *)a2 + 11);
        if (v9)
        {
          if (v10)
          {
            uint64_t result = CFEqual(v9, v10);
            if (!result) {
              return result;
            }
            return 1;
          }
        }
        else if (!v10)
        {
          return 1;
        }
        return 0;
      }
    }
  }
  return result;
}

void URLCredentialKerberosTicket::URLCredentialKerberosTicket(URLCredentialKerberosTicket *this)
{
  *((void *)this + 2) = (char *)&gConstantCFStringValueTable + 30184;
  *((_DWORD *)this + 8) = 2;
  *((unsigned char *)this + 48) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_1ECFA4350;
  *((void *)this + 1) = &unk_1ECFA43F8;
  *((void *)this + 3) = &unk_1ECFA4428;
  *((void *)this + 11) = 0;
}

void ___ZN14ObserverHolder5ClassEv_block_invoke()
{
}

void sub_18427D584(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'URLCredentialServerTrust::~URLCredentialServerTrust(URLCredentialServerTrust *this)
{
}

{
  URLCredentialServerTrust::~URLCredentialServerTrust((URLCredentialServerTrust *)((char *)this - 24));
}

{
  URLCredentialServerTrust::~URLCredentialServerTrust((URLCredentialServerTrust *)((char *)this - 8));
}

{
  URLCredentialServerTrust::~URLCredentialServerTrust((URLCredentialServerTrust *)((char *)this - 8));
}

void URLCredentialServerTrust::~URLCredentialServerTrust(URLCredentialServerTrust *this)
{
  *(void *)this = &unk_1ECFA2FF0;
  *((void *)this + 1) = &unk_1ECFA3070;
  *((void *)this + 3) = &unk_1ECFA30A0;
  uint64_t v2 = (const void *)*((void *)this + 8);
  if (v2) {
    CFRelease(v2);
  }

  URLCredential::~URLCredential(this);
}

void sub_18427D64C(_Unwind_Exception *a1)
{
  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'URLCredentialServerTrust::serializeToPropertyList(__SecTrust **this, SerializableArchive **a2)
{
  return 1;
}

uint64_t URLCredentialServerTrust::serializeToPropertyList(__SecTrust **this, SerializableArchive **a2)
{
  return 1;
}

BOOL non-virtual thunk to'URLCredentialServerTrust::initializeFromPropertyList(URLCredentialServerTrust *this, CFDictionaryRef *a2)
{
  return URLCredentialServerTrust::initializeFromPropertyList((URLCredentialServerTrust *)((char *)this - 8), a2);
}

BOOL URLCredentialServerTrust::initializeFromPropertyList(URLCredentialServerTrust *this, CFDictionaryRef *a2)
{
  BOOL result = URLCredential::initializeFromPropertyList(this, a2);
  if (result)
  {
    CFStringRef v7 = 0;
    CFTypeID TypeID = SecTrustGetTypeID();
    DeserializableArchive::decant(a2, @"trust", TypeID, (CFErrorRef *)&v7);
    CFAllocatorRef v6 = v7;
    *((void *)this + 8) = v7;
    return v6 != 0;
  }
  return result;
}

CFStringRef URLCredentialServerTrust::copyStorageNameForCredentialType(SecTrustRef *this)
{
  if (SecTrustGetCertificateCount(this[8]) < 1) {
    return 0;
  }
  CFArrayRef v2 = SecTrustCopyCertificateChain(this[8]);
  if (!v2) {
    return 0;
  }
  CFArrayRef v3 = v2;
  if (CFArrayGetCount(v2) >= 1 && (CFStringRef ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v3, 0)) != 0) {
    CFStringRef v5 = SecCertificateCopySubjectSummary(ValueAtIndex);
  }
  else {
    CFStringRef v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

void sub_18427D7E8(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

CFHashCode URLCredentialServerTrust::calcHash(URLCredentialServerTrust *this, uint64_t a2)
{
  uint64_t v2 = a2;
  CFArrayRef v3 = (const void *)*((void *)this + 8);
  if (v3) {
    return CFHash(v3) ^ a2;
  }
  return v2;
}

uint64_t URLCredentialServerTrust::copy(URLCredentialServerTrust *this)
{
  CFGetAllocator((char *)this - 16);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + CFRelease((char *)this - 16) = 0u;
  *(void *)(Instance + 32) = &gConstantCFStringValueTable[3773];
  *(unsigned char *)(Instance + 64) = 0;
  *(void *)(Instance + 72) = 0;
  *(void *)(Instance + 8MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0;
  *(void *)(Instance + 56) = 0;
  *(void *)(Instance + CFRelease((char *)this - 16) = &unk_1ECFA2FF0;
  *(void *)(Instance + 24) = &unk_1ECFA3070;
  *(void *)(Instance + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = &unk_1ECFA30A0;
  CFTypeRef v3 = (CFTypeRef)*((void *)this + 8);
  *(void *)(Instance + 48) = 0x200000001;
  if (v3) {
    CFTypeRef v3 = CFRetain(v3);
  }
  *(void *)(Instance + 8MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v3;
  return Instance;
}

CFStringRef URLCredentialServerTrust::copyDebugDesc(URLCredentialServerTrust *this)
{
  uint64_t v1 = (char *)this - 16;
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<CFURLCredential %p>{ accepted server trust }", v1);
}

BOOL URLCredentialServerTrust::equals(CFTypeRef *this, const CFObject *a2)
{
  BOOL result = URLCredential::equals((URLCredential *)this, a2);
  if (result)
  {
    unint64_t v5 = (unint64_t)this[8];
    unint64_t v6 = *((void *)a2 + 8);
    BOOL result = (v5 | v6) == 0;
    if (v5) {
      BOOL v7 = v6 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7) {
      return CFEqual(this[8], (CFTypeRef)v6) != 0;
    }
  }
  return result;
}

void URLCredentialServerTrust::URLCredentialServerTrust(URLCredentialServerTrust *this)
{
  *((void *)this + 2) = (char *)&gConstantCFStringValueTable + 30184;
  *((_DWORD *)this + 8) = 1;
  *((unsigned char *)this + 48) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_1ECFA2FF0;
  *((void *)this + 1) = &unk_1ECFA3070;
  *((void *)this + 3) = &unk_1ECFA30A0;
}

void HetergeneousCFDict::~HetergeneousCFDict(HetergeneousCFDict *this)
{
  AutoDict::~AutoDict(this);

  JUMPOUT(0x18531B6D0);
}

BOOL HTTPCookie::equals(HTTPCookie *this, const HTTPCookie *a2)
{
  CFTypeRef v3 = (CompactCookieHeader *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  uint64_t v4 = (*((uint64_t (**)(const HTTPCookie *))a2->var0 + 2))(a2);
  if (v3 == (CompactCookieHeader *)v4) {
    return 1;
  }
  unint64_t v5 = (CompactCookieHeader *)v4;
  CFPropertyListRef v6 = CompactCookieHeader::copyExtraInfo(v3, 0);
  CFPropertyListRef v7 = CompactCookieHeader::copyExtraInfo(v5, 0);
  uint64_t v8 = v7;
  if (*(_DWORD *)v3 >= 8u) {
    unsigned int v9 = *((_DWORD *)v3 + 1);
  }
  else {
    unsigned int v9 = 0;
  }
  if (*(_DWORD *)v5 >= 8u) {
    unsigned int v11 = *((_DWORD *)v5 + 1);
  }
  else {
    unsigned int v11 = 0;
  }
  if (v9 == v11)
  {
    int v12 = *(_DWORD *)v3 >= 0xCu ? *((_DWORD *)v3 + 2) & 0x7F : 0;
    int v13 = *(_DWORD *)v5 >= 0xCu ? *((_DWORD *)v5 + 2) & 0x7F : 0;
    if (v12 == v13)
    {
      BOOL v14 = 0;
      unint64_t v15 = 0;
      while (((0xE02C4uLL >> v15) & 1) != 0)
      {
LABEL_52:
        BOOL v14 = v15++ > 0x12;
        if (v15 == 20) {
          goto LABEL_53;
        }
      }
      switch(CookieData::sCookieFieldInfo[5 * v15 + 3])
      {
        case 1:
          EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString(v3, v15, 0);
          CFAllocatorRef v17 = (const char *)CompactCookieHeader::getEnumeratedString(v5, v15, 0);
          if (!((unint64_t)EnumeratedString | (unint64_t)v17)) {
            goto LABEL_52;
          }
          BOOL v18 = EnumeratedString != 0;
          if (v17)
          {
            BOOL v18 = 0;
            BOOL v19 = EnumeratedString == 0;
          }
          else
          {
            BOOL v19 = 0;
          }
          if (!v19 && !v18 && !strcmp(EnumeratedString, v17)) {
            goto LABEL_52;
          }
          goto LABEL_53;
        case 2:
        case 4:
          CompactCookieHeader::getEnumeratedTime((uint64_t)v3, v15);
          CompactCookieHeader::getEnumeratedTime((uint64_t)v5, v15);
          goto LABEL_52;
        case 8:
          if (*(_DWORD *)v3 >= 0x10u) {
            uint64_t v20 = *((unsigned int *)v3 + 3);
          }
          else {
            uint64_t v20 = 0;
          }
          if (*(_DWORD *)v5 >= 0x10u) {
            uint64_t v21 = *((unsigned int *)v5 + 3);
          }
          else {
            uint64_t v21 = 0;
          }
          if (v20 != v21) {
            goto LABEL_53;
          }
          if (!v20) {
            goto LABEL_52;
          }
          uint64_t v22 = 0;
          uint64_t v23 = 2 * v20;
          break;
        default:
          goto LABEL_52;
      }
      while (1)
      {
        uint64_t v24 = (unsigned __int16 *)((char *)v3 + (v22 + 56));
        uint64_t v25 = *(_DWORD *)v3;
        BOOL v26 = v25 <= (int)v22 + 56 || v24 + 1 > (unsigned __int16 *)((char *)v3 + v25);
        int v27 = v26 ? 0 : *v24;
        uint64_t v28 = (unsigned __int16 *)((char *)v5 + (v22 + 56));
        uint64_t v29 = *(_DWORD *)v5;
        BOOL v30 = v29 <= (int)v22 + 56 || v28 + 1 > (unsigned __int16 *)((char *)v5 + v29);
        int v31 = v30 ? 0 : *v28;
        if (v27 != v31) {
          break;
        }
        v22 += 2;
        if (v23 == v22) {
          goto LABEL_52;
        }
      }
LABEL_53:
      int v32 = v14;
      if (!v8) {
        goto LABEL_57;
      }
      goto LABEL_56;
    }
  }
  int v32 = 0;
  if (v7) {
LABEL_56:
  }
    CFRelease(v8);
LABEL_57:
  if (v6) {
    CFRelease(v6);
  }
  return v32 != 0;
}

CFStringRef HTTPCookie::copyDebugDesc(HTTPCookie *this)
{
  uint64_t v2 = (*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  CFTypeRef v3 = (double *)v2;
  if (*(_DWORD *)v2 >= 0xCu && (*(_DWORD *)(v2 + 8) & 2) != 0)
  {
    CFDateRef v6 = 0;
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  }
  else
  {
    double v4 = 0.0;
    if (*(_DWORD *)v2 >= 0x30u) {
      double v4 = floor(*(double *)(v2 + 40));
    }
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDateRef v6 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4);
  }
  CompactCookieHeader::getEnumeratedTime((uint64_t)v3, 19);
  CFDateRef v8 = CFDateCreate(v5, v7);
  if (*(_DWORD *)v3 < 0x38u || floor(v3[6]) == 0.0)
  {
    CFDateRef v9 = 0;
  }
  else
  {
    double v37 = 0.0;
    if (*(_DWORD *)v3 >= 0x38u) {
      double v37 = floor(v3[6]);
    }
    CFDateRef v9 = CFDateCreate(v5, v37);
  }
  if (*(_DWORD *)v3 >= 0x14u
    && (uint64_t v10 = *((unsigned int *)v3 + 4), v10)
    && (uint64_t v11 = *(unsigned int *)v3, v11 > v10))
  {
    int v12 = (char *)v3 + v10;
    int v13 = (char *)v3 + v11;
    BOOL v14 = v12;
    while (*v14)
    {
      if (++v14 >= v13) {
        goto LABEL_16;
      }
    }
  }
  else
  {
LABEL_16:
    int v12 = 0;
  }
  EnumeratedString = CompactCookieHeader::getEnumeratedString((CompactCookieHeader *)v3, 15, 0);
  CFTypeID v16 = 0;
  if (*(_DWORD *)v3 >= 0x18u)
  {
    uint64_t v17 = *((unsigned int *)v3 + 5);
    if (v17 && (uint64_t v18 = *(unsigned int *)v3, v18 > v17))
    {
      CFTypeID v16 = (char *)v3 + v17;
      BOOL v19 = (char *)v3 + v18;
      uint64_t v20 = v16;
      while (*v20)
      {
        if (++v20 >= v19) {
          goto LABEL_23;
        }
      }
    }
    else
    {
LABEL_23:
      CFTypeID v16 = 0;
    }
  }
  if (*(_DWORD *)v3 >= 0x1Cu
    && (uint64_t v21 = *((unsigned int *)v3 + 6), v21)
    && (uint64_t v22 = *(unsigned int *)v3, v22 > v21))
  {
    uint64_t v23 = (char *)v3 + v21;
    uint64_t v24 = (char *)v3 + v22;
    uint64_t v25 = v23;
    while (*v25)
    {
      if (++v25 >= v24) {
        goto LABEL_30;
      }
    }
  }
  else
  {
LABEL_30:
    uint64_t v23 = 0;
  }
  if (*(_DWORD *)v3 >= 0x20u
    && (uint64_t v26 = *((unsigned int *)v3 + 7), v26)
    && (uint64_t v27 = *(unsigned int *)v3, v27 > v26))
  {
    uint64_t v28 = (char *)v3 + v26;
    uint64_t v29 = (char *)v3 + v27;
    BOOL v30 = v28;
    while (*v30)
    {
      if (++v30 >= v29) {
        goto LABEL_37;
      }
    }
  }
  else
  {
LABEL_37:
    uint64_t v28 = 0;
  }
  if (*(_DWORD *)v3 >= 0xCu && (v3[1] & 2) != 0) {
    uint64_t v31 = 89;
  }
  else {
    uint64_t v31 = 110;
  }
  if (*(_DWORD *)v3 >= 0xCu && (v3[1] & 1) != 0) {
    uint64_t v32 = 89;
  }
  else {
    uint64_t v32 = 110;
  }
  if (*(_DWORD *)v3 >= 0xCu && (v3[1] & 4) != 0) {
    uint64_t v33 = 89;
  }
  else {
    uint64_t v33 = 110;
  }
  CFStringRef v34 = CFStringCreateWithFormat(v5, 0, @"<CompactCookieHeader@%p> { domain: %s, partition: %s, name: %s, path: %s, value: %s, session: %c, secure: %c, httponly? %c, expires: %@, created: %@, accessed: %@ }", v3, v12, EnumeratedString, v16, v23, v28, v31, v32, v33, v6, v9, v8);
  if (v6) {
    CFRelease(v6);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v9) {
    CFRelease(v9);
  }
  CFStringRef v35 = CFStringCreateWithFormat(v5, 0, @"<HTTPCookie@%p> { %@ }", this, v34);
  if (v34) {
    CFRelease(v34);
  }
  return v35;
}

void non-virtual thunk to'Throttler::~Throttler(Throttler *this)
{
  uint64_t v2 = (char *)this - 24;
  Throttler::~Throttler((Throttler *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  Throttler::~Throttler((Throttler *)((char *)this - 24));
}

uint64_t ___ZN9Throttler10invalidateEU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v2(v1);
}

uint64_t ___ZN9Throttler19_onqueue_setupTimerEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(void *)(v1 + 48) = 0;
  uint64_t result = *(void *)(v1 + 80);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t ___ZN9Throttler19_onqueue_setupTimerEv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

void Throttler::setMaximumBPSTarget(Throttler *this, uint64_t a2)
{
  *((void *)this + 12) = a2;
  *((CFAbsoluteTime *)this + 5) = CFAbsoluteTimeGetCurrent();
  *((void *)this + 7) = 0;
  CFAllocatorRef v3 = *((void *)this + 4);
  if (v3) {
    goto LABEL_3;
  }
  *((CFAbsoluteTime *)this + 5) = CFAbsoluteTimeGetCurrent();
  *((void *)this + 7) = 0;
  *((void *)this + 4) = (*(uint64_t (**)(void))(**((void **)this + 9) + 80))(*((void *)this + 9));
  (*(void (**)(Throttler *))(*(void *)this + 40))(this);
  double v4 = *((void *)this + 4);
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 3221225472;
  handler[2] = ___ZN9Throttler19_onqueue_setupTimerEv_block_invoke;
  handler[3] = &__block_descriptor_40_e5_v8__0l;
  void handler[4] = this;
  dispatch_source_set_event_handler(v4, handler);
  CFAllocatorRef v5 = *((void *)this + 4);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN9Throttler19_onqueue_setupTimerEv_block_invoke_2;
  void v6[3] = &__block_descriptor_40_e5_v8__0l;
  _OWORD v6[4] = this;
  dispatch_source_set_cancel_handler(v5, v6);
  dispatch_source_set_timer(*((dispatch_source_t *)this + 4), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(*((dispatch_object_t *)this + 4));
  CFAllocatorRef v3 = *((void *)this + 4);
  if (v3)
  {
LABEL_3:
    dispatch_source_set_timer(v3, 0, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
}

void std::__shared_ptr_pointer<Throttler *,Deleter_release<Throttler>,std::allocator<Throttler>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void sub_18427E7D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18427EE18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18427F210(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_18427FE9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_18427FF64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__12949(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = *(void *)(a2 + 40);
  *(void *)(a2 + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0;
  return result;
}

void __Block_byref_object_dispose__12950(uint64_t a1)
{
}

const char *CStringKeyCallbacks::_caseInsensitiveHash(const char *this, const void *a2)
{
  if (this)
  {
    uint64_t v2 = this;
    int64_t v3 = strlen(this);
    unint64_t v4 = v3;
    if (v3 >= 97)
    {
      unint64_t v12 = 0;
      uint64_t v7 = v3;
      do
      {
        uint64_t v13 = 16974593 * __tolower(v2[v12]) + 67503105 * v7;
        uint64_t v14 = 66049 * __tolower(v2[v12 + 1]);
        unsigned __int8 v15 = __tolower(v2[v12 + 2]);
        uint64_t v7 = v13 + v14 + (v15 | (v15 << 8)) + __tolower(v2[v12 + 3]);
        BOOL v16 = v12 >= 0x1C;
        v12 += 4;
      }
      while (!v16);
      uint64_t v17 = 0;
      uint64_t v18 = (uint64_t)&v2[(v4 >> 1) - 16];
      do
      {
        uint64_t v19 = 16974593 * __tolower(*(unsigned __int8 *)(v18 + v17)) + 67503105 * v7;
        uint64_t v20 = 66049 * __tolower(*(unsigned __int8 *)(v18 + v17 + 1));
        unsigned __int8 v21 = __tolower(*(unsigned __int8 *)(v18 + v17 + 2));
        uint64_t v7 = v19 + v20 + (v21 | (v21 << 8)) + __tolower(*(unsigned __int8 *)(v18 + v17 + 3));
        uint64_t v22 = v17 - 16;
        v17 += 4;
      }
      while (v22 < 12);
      uint64_t v23 = &v2[v4];
      uint64_t v24 = (unsigned __int8 *)(v23 - 32);
      do
      {
        uint64_t v25 = 16974593 * __tolower(*v24) + 67503105 * v7;
        uint64_t v26 = 66049 * __tolower(v24[1]);
        unsigned __int8 v27 = __tolower(v24[2]);
        uint64_t v7 = v25 + v26 + (v27 | (v27 << 8)) + __tolower(v24[3]);
        v24 += 4;
      }
      while (v24 < (unsigned __int8 *)v23);
    }
    else
    {
      CFAllocatorRef v5 = &v2[v3];
      if ((uint64_t)(v3 & 0xFFFFFFFFFFFFFFFCLL) < 1)
      {
        CFDateRef v8 = (unsigned __int8 *)v2;
        uint64_t v7 = v3;
      }
      else
      {
        CFDateRef v6 = &v2[v3 & 0xFFFFFFFFFFFFFFFCLL];
        uint64_t v7 = v3;
        CFDateRef v8 = (unsigned __int8 *)v2;
        do
        {
          uint64_t v9 = 16974593 * __tolower(*v8) + 67503105 * v7;
          uint64_t v10 = 66049 * __tolower(v8[1]);
          unsigned __int8 v11 = __tolower(v8[2]);
          uint64_t v7 = v9 + v10 + (v11 | (v11 << 8)) + __tolower(v8[3]);
          v8 += 4;
        }
        while (v8 < (unsigned __int8 *)v6);
      }
      if (v8 < (unsigned __int8 *)v5)
      {
        int64_t v28 = &v2[v4] - (const char *)v8;
        do
        {
          __darwin_ct_rune_t v29 = *v8++;
          uint64_t v7 = 257 * v7 + __tolower(v29);
          --v28;
        }
        while (v28);
      }
    }
    return (const char *)((v7 << (v4 & 0x1F)) + v7);
  }
  return this;
}

BOOL CStringKeyCallbacks::_caseInsensitiveEqual(CStringKeyCallbacks *this, const char *a2, const void *a3)
{
  return this == (CStringKeyCallbacks *)a2 || strcasecmp((const char *)this, a2) == 0;
}

CFStringRef CStringKeyCallbacks::_copyDescription(CStringKeyCallbacks *this, const void *a2)
{
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const char *)this, 0x8000100u);
}

void *CStringKeyCallbacks::_retain(CStringKeyCallbacks *this, const __CFAllocator *__s, const void *a3)
{
  if (!__s) {
    return 0;
  }
  size_t v5 = strlen((const char *)__s) + 1;
  CFDateRef v6 = CFAllocatorAllocate(this, v5, 0);
  uint64_t v7 = v6;
  if (v6) {
    memcpy(v6, __s, v5);
  }
  return v7;
}

uint64_t _netServiceDispatchCallbackForResolving(__CFNetService *a1, CFStreamError *a2, id *a3)
{
  if (a3) {
    Weauint64_t k = objc_loadWeak(a3 + 1);
  }
  else {
    Weauint64_t k = 0;
  }
  uint64_t error = a2->error;
  CFIndex domain = a2->domain;

  return [(NSNetService *)(uint64_t)Weak _dispatchCallBackWithError:error];
}

uint64_t _netServiceDispatchCallbackForPublishing(__CFNetService *a1, CFStreamError *a2, id *a3)
{
  if (a3) {
    Weauint64_t k = objc_loadWeak(a3 + 1);
  }
  else {
    Weauint64_t k = 0;
  }
  uint64_t error = a2->error;
  if (error)
  {
    CFIndex domain = a2->domain;
    return [(NSNetService *)(uint64_t)Weak _dispatchCallBackWithError:error];
  }
  else
  {
    [Weak delegate];
    uint64_t result = objc_opt_respondsToSelector();
    if (result)
    {
      CFDateRef v8 = (void *)[Weak delegate];
      return [v8 netServiceDidPublish:Weak];
    }
  }
  return result;
}

void sub_184281558(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void _netServiceMonitorCallBack(__CFNetServiceMonitor *a1, __CFNetService *a2, CFNetServiceMonitorType a3, const __CFData *a4, CFStreamError *a5, id *a6)
{
  if (a6) {
    Weauint64_t k = objc_loadWeak(a6 + 1);
  }
  else {
    Weauint64_t k = 0;
  }
  if (a5->domain != 10 || a5->error != -72005)
  {
    uint64_t v9 = [Weak delegate];
    if (v9)
    {
      uint64_t v10 = (void *)v9;
      if (objc_opt_respondsToSelector())
      {
        [v10 netService:Weak didUpdateTXTRecordData:a4];
      }
    }
  }
}

uint64_t _netServiceBrowserDispatchCallBack(__CFNetServiceBrowser *a1, uint64_t a2, const void *a3, CFStreamError *a4, id *a5)
{
  if (a5) {
    Weauint64_t k = objc_loadWeak(a5 + 1);
  }
  else {
    Weauint64_t k = 0;
  }
  uint64_t error = a4->error;
  CFIndex domain = a4->domain;

  return objc_msgSend(Weak, "_dispatchCallBack:flags:error:", a3, a2, domain, error);
}

void _CoreLockable::~_CoreLockable(_CoreLockable *this)
{
  *(void *)this = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));

  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

void CoreLockable::~CoreLockable(CoreLockable *this)
{
  *(void *)this = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));

  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

void CoreCondLock::~CoreCondLock(CoreCondLock *this)
{
  CoreCondLock::~CoreCondLock(this);

  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9B510;
  pthread_cond_destroy((pthread_cond_t *)((char *)this + 72));
  *(void *)this = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

void sub_184282CC4(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 8));
  _Unwind_Resume(a1);
}

void APSRelayTransaction::~APSRelayTransaction(APSRelayTransaction *this)
{
  APSRelayTransaction::~APSRelayTransaction(this);

  JUMPOUT(0x18531B6D0);
}

{
  uint64_t v2;
  const void *v3;
  const void *v4;
  NSObject *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  std::__shared_weak_count *v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  std::__shared_weak_count *v14;
  std::__shared_weak_count *v15;

  *(void *)this = &unk_1ECF9F7C0;
  uint64_t v2 = *((void *)this + 24);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 24) = 0;
  }
  int64_t v3 = (const void *)*((void *)this + 29);
  if (v3)
  {
    _Block_release(v3);
    *((void *)this + 29) = 0;
  }
  unint64_t v4 = (const void *)*((void *)this + 27);
  if (v4)
  {
    _Block_release(v4);
    *((void *)this + 27) = 0;
  }
  size_t v5 = *((void *)this + 28);
  if (v5)
  {
    dispatch_release(v5);
    *((void *)this + 28) = 0;
  }
  CFDateRef v6 = (std::__shared_weak_count *)*((void *)this + 34);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  CFDateRef v8 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 19);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  unsigned __int8 v11 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  unint64_t v12 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v13);
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  *(void *)this = &unk_1ECF9B550;
  unsigned __int8 v15 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
}

void sub_184282E64(_Unwind_Exception *exception_object)
{
  int64_t v3 = (std::__shared_weak_count *)v1[34];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  unint64_t v4 = (std::__shared_weak_count *)v1[26];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  size_t v5 = (std::__shared_weak_count *)v1[23];
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  CFDateRef v6 = (std::__shared_weak_count *)v1[21];
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)v1[19];
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  CFDateRef v8 = (std::__shared_weak_count *)v1[17];
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)v1[9];
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)v1[7];
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  unsigned __int8 v11 = (std::__shared_weak_count *)v1[5];
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  *uint64_t v1 = &unk_1ECF9B550;
  unint64_t v12 = (std::__shared_weak_count *)v1[2];
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_emplace<APSRelayEngine>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<APSRelayEngine>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA66E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<APSRelayEngine>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA66E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void APSRelayTransaction::setBodyStreamBeforeOpening(APSRelayTransaction *this, __CFReadStream *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    CFReadStreamOpen(a2);
    while (CFReadStreamGetStatus(a2) <= kCFStreamStatusWriting)
    {
      uint64_t v4 = CFReadStreamRead(a2, buffer, 1024);
      if (v4 < 1) {
        break;
      }
      CFDataAppendBytes(Mutable, buffer, v4);
    }
    CFReadStreamClose(a2);
    if (Mutable) {
      CFRetain(Mutable);
    }
    operator new();
  }
  CFDataRef v5 = CFHTTPMessageCopyBody((CFHTTPMessageRef)(*((void *)this + 18) - 16));
  if (v5)
  {
    CFDataRef v6 = v5;
    if (CFDataGetLength(v5) >= 1)
    {
      CFRetain(v6);
      operator new();
    }
    CFRelease(v6);
  }
}

void sub_184283194(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void APSRelayTransaction::scheduleAndOpenWithHandler(APSRelayTransaction *this, const CoreSchedulingSet *a2, void *aBlock, void *a4)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 27)) {
    __assert_rtn("scheduleAndOpenWithHandler", "APSRelayTransaction.cpp", 169, "!_callbackHandler");
  }
  int v5 = *((_DWORD *)this + 20);
  if ((v5 == 0) != (v5 != 5)) {
    __assert_rtn("scheduleAndOpenWithHandler", "APSRelayTransaction.cpp", 179, "(_state == State::New) || (_state == State::Canceled)");
  }
  if (!v5)
  {
    *((void *)this + 27) = _Block_copy(aBlock);
    *((void *)this + 29) = _Block_copy(a4);
    *((unsigned char *)this + 24) |= 1u;
    APSRelayTransaction::_updateScheduling(this, a2);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v8 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *((void *)this + 33);
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v9;
      _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@ now using Connection APSR", (uint8_t *)&buf, 0xCu);
    }
    int v10 = *((_DWORD *)this + 20);
    if (v10 != 6)
    {
      if (v10 >= 2) {
        __assert_rtn("_changeState", "APSRelayTransaction.cpp", 712, "newState >= _state");
      }
      *((_DWORD *)this + 2MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 1;
    }
    CFDataRef v11 = (const __CFData *)*((void *)this + 20);
    if (v11) {
      CFIndex Length = CFDataGetLength(v11);
    }
    else {
      CFIndex Length = 0;
    }
    cleanUpRequest((__CFHTTPMessage *)(*((void *)this + 18) - 16), Length, 1, 0, *((id **)this + 24));
    uint64_t v13 = *((void *)this + 24);
    if (v13)
    {
      int v14 = [*(id *)(v13 - 96) _cachePolicy];
      [*(id *)(v13 - 96) _timeoutInterval];
    }
    else
    {
      int v14 = 0;
      double v15 = 0.0;
    }
    BOOL v16 = (void *)_constructRequestFromParts((const __CFAllocator *)(*((void *)this + 18) - 16), 0, (const __CFArray *)v14, NSURLRequestUseProtocolCachePolicy, v15, 0);
    -[__CFN_TransactionMetrics setTransferredRequest:](*((void *)this + 35), v16);
    if (v16) {
      CFRelease(v16);
    }
    uint64_t v17 = *((void *)this + 24);
    if (v17) {
      uint64_t v18 = v17 - 176;
    }
    else {
      uint64_t v18 = 0;
    }
    [*(id *)(v18 + 80) _timeoutInterval];
    uint64_t v20 = *((void *)this + 6);
    if (!v20) {
      __assert_rtn("_startRequest", "APSRelayTransaction.cpp", 403, "_engine");
    }
    double v21 = v19;
    uint64_t v22 = *((void *)this + 4);
    uint64_t v23 = (std::__shared_weak_count *)*((void *)this + 5);
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      uint64_t v20 = *((void *)this + 6);
    }
    uint64_t v24 = *((void *)this + 18);
    uint64_t v25 = (std::__shared_weak_count *)*((void *)this + 19);
    if (v25) {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v59 = v25;
    uint64_t v27 = *((void *)this + 20);
    uint64_t v26 = (std::__shared_weak_count *)*((void *)this + 21);
    if (v26) {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v28 = *((void *)this + 25);
    __darwin_ct_rune_t v29 = (std::__shared_weak_count *)*((void *)this + 26);
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v30 = *((void *)this + 33);
    uint64_t v31 = (std::__shared_weak_count *)*((void *)this + 34);
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v60[0] = MEMORY[0x1E4F143A8];
    v60[1] = 3321888768;
    v60[2] = ___ZN19APSRelayTransaction13_startRequestEv_block_invoke;
    v60[3] = &__block_descriptor_56_e8_40c44_ZTSNSt3__18weak_ptrI19APSRelayTransactionEE_e102_v64__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8_24___qi_32q48q56l;
    v60[4] = this;
    v60[5] = v22;
    int v61 = v23;
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v58 = v23;
    if (*(void *)(v20 + 96))
    {
      uint64_t v54 = "!_httpRequest";
      int v55 = 105;
    }
    else if (*(void *)(v20 + 64))
    {
      uint64_t v54 = "!_schedulingSet";
      int v55 = 106;
    }
    else
    {
      if (!*(void *)(v20 + 168))
      {
        uint64_t v57 = v30;
        if (v59) {
          atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v32 = *(std::__shared_weak_count **)(v20 + 104);
        *(void *)(v20 + 96) = v24;
        *(void *)(v20 + 104) = v59;
        if (v32) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v32);
        }
        if (v26) {
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v33 = *(std::__shared_weak_count **)(v20 + 120);
        *(void *)(v20 + 112) = v27;
        *(void *)(v20 + 12MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v26;
        if (v33) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v33);
        }
        if (v29) {
          atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v56 = a4;
        CFStringRef v34 = *(std::__shared_weak_count **)(v20 + 72);
        *(void *)(v20 + 64) = v28;
        *(void *)(v20 + 72) = v29;
        if (v34) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v34);
        }
        uint64_t v35 = HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(void *)(v20 + 96) + 128));
        uint64_t v36 = *(void *)(v20 + 96);
        CFStringRef v37 = *(const __CFString **)(v36 + 152);
        BOOL v38 = (v37
            || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
            && (LOWORD(buf) = 0,
                _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", (uint8_t *)&buf, 2u), (CFStringRef v37 = *(const __CFString **)(v36 + 152)) != 0))&& CFEqual(v37, (CFStringRef)&gConstantCFStringValueTable[2625]);
        CFMutableDictionaryRef v39 = HTTPMessage::copyAllHeaderFields(*(HTTPMessage **)(v20 + 96));
        uint64_t v40 = *(void *)(v20 + 112);
        gotLoadHelper_x8__OBJC_CLASS___FTURLRequestMessage(v41);
        long long v43 = (void *)[objc_alloc(*(Class *)(v42 + 1904)) initWithURL:v35 type:v38 headers:v39 stringParams:0 body:v40];
        *(void *)(v20 + 152) = v43;
        [v43 setUnderlyingService:*(void *)(v20 + 48)];
        [*(id *)(v20 + 152) setTopic:*(void *)(v20 + 48)];
        [*(id *)(v20 + 152) setHttpDoNotDecodeData:1];
        if (v39) {
          CFRelease(v39);
        }
        uint64_t v44 = *(void *)(v20 + 32);
        long long v45 = *(std::__shared_weak_count **)(v20 + 40);
        if (v45) {
          atomic_fetch_add_explicit(&v45->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        long long v46 = *(void **)(v20 + 152);
        *(void *)&long long buf = MEMORY[0x1E4F143A8];
        *((void *)&buf + 1) = 3321888768;
        CFDictionaryRef v63 = ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke;
        uint64_t v64 = &unk_1ECFAA370;
        uint64_t v66 = v20;
        uint64_t v67 = v44;
        char v68 = v45;
        if (v45) {
          atomic_fetch_add_explicit(&v45->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v69 = v57;
        char v70 = v31;
        if (v31) {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v65 = v60;
        [v46 setCompletionBlock:&buf];
        [*(id *)(v20 + 152) setTimeout:v21];
        gotLoadHelper_x8__OBJC_CLASS___FTMessageDelivery_DualMode(v47);
        *(void *)(v20 + 168) = [objc_alloc(*(Class *)(v48 + 1872)) initWithPreferedType:2];
        long long v49 = HTTPMessage::copyHeaderFieldValue(*(HTTPMessage **)(v20 + 96), 0x14E15421u);
        if (!v49)
        {
          pthread_once(&initControl, initializeUserAgentString);
          if (sUserAgentString) {
            long long v49 = CFRetain((CFTypeRef)sUserAgentString);
          }
          else {
            long long v49 = 0;
          }
        }
        [*(id *)(v20 + 168) setUserAgent:v49];
        double Current = CFAbsoluteTimeGetCurrent();
        uint64_t v51 = *(void *)(v20 + 176);
        if (v51) {
          *(double *)(v51 + 176) = Current;
        }
        objc_msgSend(*(id *)(v20 + 168), "sendMessage:", *(void *)(v20 + 152), Current);
        if (v49) {
          CFRelease(v49);
        }
        if (v70) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v70);
        }
        a4 = v56;
        if (v68) {
          std::__shared_weak_count::__release_weak(v68);
        }
        if (v45) {
          std::__shared_weak_count::__release_weak(v45);
        }
        if (v31) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v31);
        }
        if (v29) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v29);
        }
        if (v26) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v26);
        }
        if (v59) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v59);
        }
        if (v61) {
          std::__shared_weak_count::__release_weak(v61);
        }
        if (v58) {
          std::__shared_weak_count::__release_weak(v58);
        }
        int v52 = *((_DWORD *)this + 20);
        if (v52 != 6)
        {
          if (v52 >= 3) {
            __assert_rtn("_changeState", "APSRelayTransaction.cpp", 712, "newState >= _state");
          }
          *((_DWORD *)this + 2MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 2;
        }
        goto LABEL_91;
      }
      uint64_t v54 = "!_apsDelivery";
      int v55 = 107;
    }
    __assert_rtn("processTransaction", "APSRelayEngine.mm", v55, v54);
  }
LABEL_91:
  if (*((unsigned char *)this + 24))
  {
    *((unsigned char *)this + 24MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v5 == 0;
    APSRelayTransaction::_invokeHandler(this);
  }
  else
  {
    uint64_t v53 = (void (*)(void *, void))a4[2];
    v53(a4, 0);
  }
}

void sub_184283964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,std::__shared_weak_count *a30)
{
  if (a30) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a30);
  }
  if (a28) {
    std::__shared_weak_count::__release_weak(a28);
  }
  if (v33) {
    std::__shared_weak_count::__release_weak(v33);
  }
  if (a20) {
    std::__shared_weak_count::__release_weak(a20);
  }
  if (v32)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v32);
    if (!v31)
    {
LABEL_11:
      if (!v30) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else if (!v31)
  {
    goto LABEL_11;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v31);
  if (!v30)
  {
LABEL_13:
    if (a13) {
      std::__shared_weak_count::__release_shared[abi:nn180100](a13);
    }
    if (a12) {
      std::__shared_weak_count::__release_weak(a12);
    }
    _Unwind_Resume(exception_object);
  }
LABEL_12:
  std::__shared_weak_count::__release_shared[abi:nn180100](v30);
  goto LABEL_13;
}

uint64_t APSRelayTransaction::_updateScheduling(APSRelayTransaction *this, const CoreSchedulingSet *a2)
{
  uint64_t result = *((void *)this + 25);
  if ((unint64_t)a2 | result)
  {
    if (!a2 || !result || (uint64_t result = CoreSchedulingSet::isEqualTo((CoreSchedulingSet *)result, a2), !result))
    {
      int v5 = (std::__shared_weak_count *)*((void *)this + 26);
      *((void *)this + 25) = 0;
      *((void *)this + 26) = 0;
      if (v5) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v5);
      }
      if (a2) {
        (*(void (**)(const CoreSchedulingSet *))(*(void *)a2 + 40))(a2);
      }
      operator new();
    }
  }
  return result;
}

void APSRelayTransaction::_invokeHandler(APSRelayTransaction *this)
{
  uint64_t v2 = (void (**)(void, void))*((void *)this + 29);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 25);
    if (v3 && *(_DWORD *)(v3 + 40))
    {
      *((void *)this + 29) = 0;
      v2[2](v2, *((unsigned __int8 *)this + 240));
      _Block_release(v2);
    }
    else
    {
      *((unsigned char *)this + 24) |= 4u;
    }
  }
  char v4 = *((unsigned char *)this + 24);
  if ((v4 & 3) == 1)
  {
    uint64_t v5 = *((void *)this + 25);
    if (!v5 || !*(_DWORD *)(v5 + 40))
    {
      char v8 = v4 | 8;
LABEL_13:
      *((unsigned char *)this + 24) = v8;
      return;
    }
    uint64_t v6 = *((void *)this + 22);
    if (*((int *)this + 20) < 3)
    {
      if (!v6) {
        return;
      }
    }
    else if (!v6)
    {
      uint64_t v7 = *(void (**)(void))(*((void *)this + 27) + 16);
LABEL_21:
      v7();
      char v8 = *((unsigned char *)this + 24) | 2;
      goto LABEL_13;
    }
    uint64_t v9 = *((void *)this + 28);
    if (v9)
    {
      *((void *)this + 28) = 0;
      (*(void (**)(void))(*((void *)this + 27) + 16))();
      dispatch_release(v9);
      char v4 = *((unsigned char *)this + 24);
    }
    if ((v4 & 1) != 0 && *((int *)this + 20) >= 3)
    {
      uint64_t v7 = *(void (**)(void))(*((void *)this + 27) + 16);
      goto LABEL_21;
    }
  }
}

void ___ZN19APSRelayTransaction13_startRequestEv_block_invoke(void *a1, uint64_t *a2, NSObject *a3, CFIndex a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  char v8 = (std::__shared_weak_count *)a1[6];
  if (!v8) {
    return;
  }
  uint64_t v15 = a1[4];
  BOOL v16 = std::__shared_weak_count::lock(v8);
  if (!v16) {
    return;
  }
  uint64_t v17 = v16;
  uint64_t v18 = a1[5];
  if (v18)
  {
    uint64_t v19 = *(void *)(v15 + 256) + a7;
    *(void *)(v15 + 248) += a6;
    *(void *)(v15 + 256) = v19;
    uint64_t v20 = *a2;
    double v21 = (std::__shared_weak_count *)a2[1];
    if (v21) {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(int *)(v18 + 80) > 3) {
      goto LABEL_30;
    }
    *(_DWORD *)(v18 + 8MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 3;
    if (a5)
    {
      v41.CFIndex domain = a4;
      *(void *)&v41.uint64_t error = a5;
      APSRelayTransaction::_handleError((APSRelayTransaction *)v18, v41);
LABEL_30:
      if (v21) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v21);
      }
      goto LABEL_32;
    }
    if (v20)
    {
      if (*(void *)(v18 + 176))
      {
        uint64_t v31 = "!_response";
        int v32 = 468;
      }
      else
      {
        if (v21) {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v22 = *(std::__shared_weak_count **)(v18 + 184);
        *(void *)(v18 + 176) = v20;
        *(void *)(v18 + 184) = v21;
        if (v22) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v22);
        }
        uint64_t v23 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(void *)(v18 + 144)
                                                                                          + 128));
        HTTPResponseMessage::setResponseURL(*(HTTPResponseMessage **)(v18 + 176), v23, 0);
        uint64_t v24 = *(void *)(v18 + 176);
        if (v24) {
          uint64_t v25 = (__CFHTTPMessage *)(v24 - 16);
        }
        else {
          uint64_t v25 = 0;
        }
        CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v25);
        int hasHeaderField = HTTPMessage::hasHeaderField(*(os_unfair_lock_s **)(v18 + 176), 0x11F1D2DBu);
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        uint64_t v28 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v29 = *(void *)(v18 + 264);
          if (hasHeaderField) {
            int v30 = 75;
          }
          else {
            int v30 = 85;
          }
          int v33 = 138543874;
          uint64_t v34 = v29;
          __int16 v35 = 2048;
          CFIndex v36 = ResponseStatusCode;
          __int16 v37 = 1024;
          int v38 = v30;
          _os_log_impl(&dword_184085000, v28, OS_LOG_TYPE_DEFAULT, "%{public}@ received response, status %ld content %c", (uint8_t *)&v33, 0x1Cu);
        }
        if (!*(void *)(v18 + 224))
        {
          if (a3)
          {
            *(void *)(v18 + 224) = a3;
            dispatch_retain(a3);
          }
          APSRelayTransaction::_invokeHandler((APSRelayTransaction *)v18);
          goto LABEL_30;
        }
        uint64_t v31 = "!_callbackBuffer";
        int v32 = 488;
      }
    }
    else
    {
      uint64_t v31 = "response";
      int v32 = 467;
    }
    __assert_rtn("_processResponse", "APSRelayTransaction.cpp", v32, v31);
  }
LABEL_32:

  std::__shared_weak_count::__release_shared[abi:nn180100](v17);
}

void sub_184283FA8(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_40c44_ZTSNSt3__18weak_ptrI19APSRelayTransactionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_e8_40c44_ZTSNSt3__18weak_ptrI19APSRelayTransactionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void APSRelayTransaction::_handleError(APSRelayTransaction *this, CFStreamError a2)
{
  int v2 = *((_DWORD *)this + 20);
  if (v2 == 6) {
    return;
  }
  *(CFStreamError *)((char *)this + 88) = a2;
  if (a2.domain != 1 || a2.error != 89)
  {
    if (v2 < 7)
    {
      int v4 = 6;
      goto LABEL_8;
    }
LABEL_14:
    __assert_rtn("_changeState", "APSRelayTransaction.cpp", 712, "newState >= _state");
  }
  if (v2 >= 6) {
    goto LABEL_14;
  }
  int v4 = 5;
LABEL_8:
  *((_DWORD *)this + 2MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v4;
  APSRelayTransaction::_invokeHandler(this);
  if ((*((unsigned char *)this + 24) & 1) == 0 && (*((_DWORD *)this + 20) & 0xFFFFFFFE) == 2)
  {
    uint64_t v5 = *((void *)this + 6);
    APSRelayEngine::cancel(v5);
  }
}

void APSRelayTransaction::closeAndClearHandler(APSRelayTransaction *this)
{
  if (*((unsigned char *)this + 24))
  {
    *((unsigned char *)this + 24) &= ~1u;
    int v2 = (const void *)*((void *)this + 27);
    if (v2)
    {
      _Block_release(v2);
      *((void *)this + 27) = 0;
    }
    uint64_t v3 = (const void *)*((void *)this + 29);
    if (v3)
    {
      _Block_release(v3);
      *((void *)this + 29) = 0;
    }
    APSRelayTransaction::_updateScheduling(this, 0);
  }
  int v4 = *((_DWORD *)this + 20);
  if (v4 <= 1) {
    goto LABEL_10;
  }
  if ((v4 - 5) < 2) {
    return;
  }
  if (v4 == 2)
  {
LABEL_10:
    v7.CFIndex domain = 1;
    *(void *)&v7.uint64_t error = 89;
    APSRelayTransaction::_handleError(this, v7);
    if ((*((_DWORD *)this + 20) & 0xFFFFFFFE) == 2)
    {
      uint64_t v5 = *((void *)this + 6);
      APSRelayEngine::cancel(v5);
    }
  }
  else
  {
    if (v4 >= 5) {
      __assert_rtn("_changeState", "APSRelayTransaction.cpp", 712, "newState >= _state");
    }
    *((_DWORD *)this + 2MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 4;
  }
}

BOOL APSRelayTransaction::setProperty(uint64_t a1, int a2, const void *a3)
{
  CFStringRef v5 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  int ExactString = _findExactString(v5, 0);
  if (ExactString == 11870276) {
    HTTPMessage::setHeaderFieldStringValue(*(HTTPMessage **)(a1 + 144), 0x1191B2ABu, a3);
  }
  return ExactString == 11870276;
}

void CoreLogger::~CoreLogger(CoreLogger *this)
{
}

void non-virtual thunk to'CompactCookieArray::~CompactCookieArray(CompactCookieArray *this)
{
}

{
  CompactCookieArray::~CompactCookieArray((CompactCookieArray *)((char *)this - 8));
}

CFStringRef CompactCookieArray::copyDebugDesc(CompactCookieArray *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v3 = (const __CFData *)*((void *)this + 2);
  if (v3 && (BytePtr = CFDataGetBytePtr(v3)) != 0) {
    uint64_t v5 = *((unsigned int *)BytePtr + 1);
  }
  else {
    uint64_t v5 = 0;
  }
  return CFStringCreateWithFormat(v2, 0, @"<CompactCookieArray@%p> { %d cookies }", this, v5);
}

uint64_t _cookie_header_qsort(CompactCookieHeader **a1, CompactCookieHeader **a2)
{
  return cookieHeaderSort(*a1, *a2);
}

uint64_t cookieHeaderSort(CompactCookieHeader *a1, CompactCookieHeader *a2)
{
  if (*(_DWORD *)a1 >= 0x14u
    && (uint64_t v4 = *((unsigned int *)a1 + 4), v4)
    && (uint64_t v5 = *(_DWORD *)a1, v5 > v4))
  {
    unint64_t v6 = (unint64_t)a1 + v4;
    CFStreamError v7 = (char *)a1 + v5;
    char v8 = (unsigned char *)v6;
    while (*v8)
    {
      if (++v8 >= v7) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    unint64_t v6 = 0;
  }
  if (*(_DWORD *)a2 >= 0x14u
    && (uint64_t v9 = *((unsigned int *)a2 + 4), v9)
    && (uint64_t v10 = *(_DWORD *)a2, v10 > v9))
  {
    unint64_t v11 = (unint64_t)a2 + v9;
    unint64_t v12 = (char *)a2 + v10;
    uint64_t v13 = (unsigned char *)v11;
    while (*v13)
    {
      if (++v13 >= v12) {
        goto LABEL_14;
      }
    }
  }
  else
  {
LABEL_14:
    unint64_t v11 = 0;
  }
  if (v6 | v11)
  {
    if (!v6 && v11) {
      return 1;
    }
    if (v6 && !v11) {
      return 0xFFFFFFFFLL;
    }
    int v37 = strcasecmp((const char *)v6, (const char *)v11);
    if (v37 < 0) {
      return 0xFFFFFFFFLL;
    }
    if (v37) {
      return 1;
    }
  }
  if (*(_DWORD *)a1 >= 0x1Cu
    && (uint64_t v14 = *((unsigned int *)a1 + 6), v14)
    && (uint64_t v15 = *(_DWORD *)a1, v15 > v14))
  {
    unint64_t v16 = (unint64_t)a1 + v14;
    uint64_t v17 = (char *)a1 + v15;
    uint64_t v18 = (unsigned char *)v16;
    while (*v18)
    {
      if (++v18 >= v17) {
        goto LABEL_22;
      }
    }
  }
  else
  {
LABEL_22:
    unint64_t v16 = 0;
  }
  if (*(_DWORD *)a2 >= 0x1Cu
    && (uint64_t v19 = *((unsigned int *)a2 + 6), v19)
    && (uint64_t v20 = *(_DWORD *)a2, v20 > v19))
  {
    unint64_t v21 = (unint64_t)a2 + v19;
    uint64_t v22 = (char *)a2 + v20;
    uint64_t v23 = (unsigned char *)v21;
    while (*v23)
    {
      if (++v23 >= v22) {
        goto LABEL_29;
      }
    }
  }
  else
  {
LABEL_29:
    unint64_t v21 = 0;
  }
  if (v16 | v21)
  {
    if (!v16 && v21) {
      return 1;
    }
    if (v16 && !v21) {
      return 0xFFFFFFFFLL;
    }
    int v38 = strcasecmp((const char *)v16, (const char *)v21);
    if (v38 < 0) {
      return 0xFFFFFFFFLL;
    }
    if (v38) {
      return 1;
    }
  }
  EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString(a1, 15, 0);
  uint64_t v25 = (const char *)CompactCookieHeader::getEnumeratedString(a2, 15, 0);
  if ((unint64_t)EnumeratedString | (unint64_t)v25)
  {
    if (!EnumeratedString && v25) {
      return 1;
    }
    if (EnumeratedString && !v25) {
      return 0xFFFFFFFFLL;
    }
    int v41 = strcasecmp(EnumeratedString, v25);
    if (v41 < 0) {
      return 0xFFFFFFFFLL;
    }
    if (v41) {
      return 1;
    }
  }
  if (*(_DWORD *)a1 >= 0x18u
    && (uint64_t v26 = *((unsigned int *)a1 + 5), v26)
    && (uint64_t v27 = *(_DWORD *)a1, v27 > v26))
  {
    unint64_t v28 = (unint64_t)a1 + v26;
    uint64_t v29 = (char *)a1 + v27;
    int v30 = (unsigned char *)v28;
    while (*v30)
    {
      if (++v30 >= v29) {
        goto LABEL_38;
      }
    }
  }
  else
  {
LABEL_38:
    unint64_t v28 = 0;
  }
  if (*(_DWORD *)a2 >= 0x18u
    && (uint64_t v31 = *((unsigned int *)a2 + 5), v31)
    && (uint64_t v32 = *(_DWORD *)a2, v32 > v31))
  {
    unint64_t v33 = (unint64_t)a2 + v31;
    uint64_t v34 = (char *)a2 + v32;
    __int16 v35 = (unsigned char *)v33;
    while (*v35)
    {
      if (++v35 >= v34) {
        goto LABEL_45;
      }
    }
  }
  else
  {
LABEL_45:
    unint64_t v33 = 0;
  }
  if (!(v28 | v33)) {
    return 0;
  }
  if (v33) {
    BOOL v39 = 0;
  }
  else {
    BOOL v39 = v28 != 0;
  }
  if (v33) {
    BOOL v40 = v28 == 0;
  }
  else {
    BOOL v40 = 0;
  }
  uint64_t v36 = 0xFFFFFFFFLL;
  if (!v40 && !v39)
  {
    if (!strcmp((const char *)v28, (const char *)v33)) {
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  return v36;
}

const UInt8 *CompactCookieArray::peekData(CompactCookieArray *this, uint64_t *a2)
{
  uint64_t result = (const UInt8 *)*((void *)this + 2);
  if (result)
  {
    *a2 = CFDataGetLength((CFDataRef)result);
    CFDataRef v4 = (const __CFData *)*((void *)this + 2);
    return CFDataGetBytePtr(v4);
  }
  return result;
}

BOOL CompactCookieArray::assertCookiesValid(CompactCookieArray *this)
{
  uint64_t v24 = 0;
  uint64_t v1 = CompactCookieArray::peekData(this, &v24);
  uint64_t v2 = 0;
  if (v1)
  {
    uint64_t v3 = v24;
    if (v24 >= 12)
    {
      CFDataRef v4 = v1;
      if ((v1 & 7) != 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t v23 = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "this must always be 16 byte aligned", v23, 2u);
      }
      if (*v4 == 0x10000)
      {
        unint64_t v5 = v4[1];
        uint64_t v2 = 1;
        if (v5)
        {
          unint64_t v6 = 0;
LABEL_9:
          if (v6 == v5)
          {
            unint64_t v7 = v5;
          }
          else
          {
            unint64_t v7 = v6++;
            unsigned int v8 = v3;
            if (v6 < v5) {
              unsigned int v8 = v4[v6 + 2];
            }
            uint64_t v9 = v4[v7 + 2];
            if (v3 >= v9 && v3 >= v8)
            {
              unsigned int v11 = v8 - v9;
              if (v11 >= 5)
              {
                unint64_t v12 = (char *)v4 + v9;
                unsigned int v13 = *(_DWORD *)((char *)v4 + v9);
                if (v13 <= 0x8000 && v13 <= v11)
                {
                  if (*(_DWORD *)v12 != v13 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "end calculation wrong", buf, 2u);
                  }
                  unsigned __int8 v26 = 0;
                  uint64_t v15 = &unk_18430C0D0;
                  while (2)
                  {
                    int v16 = *(v15 - 5);
                    switch(v16)
                    {
                      case 0:
                      case 1:
                      case 13:
                      case 15:
                        EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString((CompactCookieHeader *)v12, v16, &v26);
                        if (!EnumeratedString || !(strlen(EnumeratedString) >> 15)) {
                          goto LABEL_31;
                        }
                        break;
                      case 3:
                        if (*(_DWORD *)v12 < 0xCu
                          || (*((_DWORD *)v12 + 2) & 2) == 0
                          || *(_DWORD *)v12 >= 0xCu && (*((_DWORD *)v12 + 2) & 2) != 0)
                        {
                          goto LABEL_31;
                        }
                        break;
                      case 4:
                      case 8:
                      case 10:
                        uint64_t v18 = (const char *)CompactCookieHeader::getEnumeratedString((CompactCookieHeader *)v12, v16, &v26);
                        if (v18 && strlen(v18) < 0x8000) {
                          goto LABEL_31;
                        }
                        break;
                      case 6:
                        if (*(_DWORD *)v12 < 0xCu
                          || (*((_DWORD *)v12 + 2) & 4) == 0
                          || *(_DWORD *)v12 >= 0xCu && (*((_DWORD *)v12 + 2) & 4) != 0)
                        {
                          goto LABEL_31;
                        }
                        break;
                      case 11:
                        if (*(_DWORD *)v12 <= 0xFu)
                        {
                          unsigned __int8 v26 = 1;
                          goto LABEL_31;
                        }
                        unsigned int v21 = *((_DWORD *)v12 + 3);
                        if (v21 <= 0x3FF && (!v21 || 2 * v21 + 56 <= *(_DWORD *)v12)) {
                          goto LABEL_31;
                        }
                        break;
                      case 12:
                        if (*(_DWORD *)v12 < 0xCu
                          || (*((_DWORD *)v12 + 2) & 1) == 0
                          || *(_DWORD *)v12 >= 0xCu && (*((_DWORD *)v12 + 2) & 1) != 0)
                        {
                          goto LABEL_31;
                        }
                        break;
                      case 17:
                        if (*(_DWORD *)v12 < 0xCu
                          || (*((_DWORD *)v12 + 2) & 0x20) == 0
                          || *(_DWORD *)v12 >= 0xCu && (*((_DWORD *)v12 + 2) & 0x20) != 0)
                        {
                          goto LABEL_31;
                        }
                        break;
                      case 18:
                        if (*(_DWORD *)v12 < 0xCu
                          || (*((_DWORD *)v12 + 2) & 0x40) == 0
                          || *(_DWORD *)v12 >= 0xCu && (*((_DWORD *)v12 + 2) & 0x40) != 0)
                        {
                          goto LABEL_31;
                        }
                        break;
                      default:
LABEL_31:
                        BOOL v19 = v15 >= &dword_18430C24C;
                        v15 += 5;
                        if (!v19 && v26 == 0) {
                          continue;
                        }
                        if (!v26) {
                          goto LABEL_9;
                        }
                        break;
                    }
                    break;
                  }
                }
              }
            }
          }
          return v7 >= v5;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v2;
}

uint64_t CompactCookieArray::_mungeCookies(CompactCookieArray *this, const CompactCookieArray *a2, const CompactCookieArray *a3, int a4)
{
  int __p = (int)a3;
  unint64_t v5 = this;
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  long long v117 = 0;
  memset(v120, 0, sizeof(v120));
  CFDataRef v6 = (const __CFData *)*((void *)this + 2);
  if (v6 && (BytePtr = CFDataGetBytePtr(v6)) != 0) {
    unsigned int v8 = *((_DWORD *)BytePtr + 1);
  }
  else {
    unsigned int v8 = 0;
  }
  CFDataRef v9 = (const __CFData *)*((void *)a2 + 2);
  if (v9 && (uint64_t v10 = CFDataGetBytePtr(v9)) != 0) {
    unsigned int v11 = *((_DWORD *)v10 + 1);
  }
  else {
    unsigned int v11 = 0;
  }
  if (__p) {
    unsigned int v12 = v11;
  }
  else {
    unsigned int v12 = 0;
  }
  if (v12 + v8 >= 0x41) {
    operator new[]();
  }
  unsigned int v13 = 0;
  long long v117 = (CompactCookieHeader **)v120;
  uint64_t v114 = (uint64_t)v5;
  unsigned int v14 = 0;
  int v15 = 0;
  int v16 = 0;
  if (v8 && v11)
  {
    int v16 = 0;
    int v15 = 0;
    unsigned int v14 = 0;
    unsigned int v13 = 0;
    do
    {
      CFDataRef v17 = (const __CFData *)*((void *)v5 + 2);
      if (v17 && CFDataGetBytePtr(v17))
      {
        uint64_t v18 = CFDataGetBytePtr(*(CFDataRef *)(v114 + 16));
        BOOL v19 = *(const UInt8 **)(v114 + 16);
        uint64_t v20 = *(unsigned int *)&v18[4 * v14 + 8];
        if (v19) {
          BOOL v19 = CFDataGetBytePtr((CFDataRef)v19);
        }
        unsigned int v21 = (CompactCookieHeader *)&v19[v20];
      }
      else
      {
        unsigned int v21 = 0;
      }
      CFDataRef v22 = (const __CFData *)*((void *)a2 + 2);
      if (v22 && CFDataGetBytePtr(v22))
      {
        uint64_t v23 = CFDataGetBytePtr(*((CFDataRef *)a2 + 2));
        uint64_t v24 = (const UInt8 *)*((void *)a2 + 2);
        uint64_t v25 = *(unsigned int *)&v23[4 * v13 + 8];
        if (v24) {
          uint64_t v24 = CFDataGetBytePtr((CFDataRef)v24);
        }
        unsigned __int8 v26 = (CompactCookieHeader *)&v24[v25];
      }
      else
      {
        unsigned __int8 v26 = 0;
      }
      int v27 = cookieHeaderSort(v21, v26);
      if (v27 == -1)
      {
        v117[v15++] = v21;
        ++v14;
        unint64_t v5 = (CompactCookieArray *)v114;
      }
      else if (v27 == 1)
      {
        if (__p)
        {
          v117[v15++] = v26;
          int v16 = 1;
        }
        unint64_t v5 = (CompactCookieArray *)v114;
        ++v13;
      }
      else
      {
        unint64_t v5 = (CompactCookieArray *)v114;
        if (!v27)
        {
          if (__p) {
            v117[v15++] = v26;
          }
          ++v14;
          ++v13;
          int v16 = 1;
        }
      }
    }
    while (v14 < v8 && v13 < v11);
  }
  if (v8 != v14 && v11 != v13 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "How did I get here then?", buf, 2u);
  }
  unsigned int v28 = v8 - v14;
  if (v8 <= v14)
  {
    int v35 = v15;
  }
  else
  {
    uint64_t v29 = 4 * v14 + 8;
    do
    {
      CFDataRef v30 = *(const __CFData **)(v114 + 16);
      if (v30 && CFDataGetBytePtr(v30))
      {
        uint64_t v31 = CFDataGetBytePtr(*(CFDataRef *)(v114 + 16));
        uint64_t v32 = *(const UInt8 **)(v114 + 16);
        uint64_t v33 = *(unsigned int *)&v31[v29];
        if (v32) {
          uint64_t v32 = CFDataGetBytePtr((CFDataRef)v32);
        }
        uint64_t v34 = (CompactCookieHeader *)&v32[v33];
      }
      else
      {
        uint64_t v34 = 0;
      }
      int v35 = v15 + 1;
      v117[v15] = v34;
      v29 += 4;
      ++v15;
      --v28;
    }
    while (v28);
  }
  if (__p && (unsigned int v36 = v11 - v13, v11 > v13))
  {
    uint64_t v37 = 4 * v13 + 8;
    int v38 = v35;
    do
    {
      CFDataRef v39 = (const __CFData *)*((void *)a2 + 2);
      if (v39 && CFDataGetBytePtr(v39))
      {
        BOOL v40 = CFDataGetBytePtr(*((CFDataRef *)a2 + 2));
        int v41 = (const UInt8 *)*((void *)a2 + 2);
        uint64_t v42 = *(unsigned int *)&v40[v37];
        if (v41) {
          int v41 = CFDataGetBytePtr((CFDataRef)v41);
        }
        long long v43 = (CompactCookieHeader *)&v41[v42];
      }
      else
      {
        long long v43 = 0;
      }
      int v35 = v38 + 1;
      v117[v38] = v43;
      v37 += 4;
      ++v38;
      --v36;
    }
    while (v36);
  }
  else if (!v16)
  {
    CFRetain((CFTypeRef)(v114 - 16));
    goto LABEL_144;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  if (v35)
  {
    uint64_t v45 = 0;
    unsigned int v46 = 0;
    do
    {
      double v47 = v117[v45];
      if (v47)
      {
        if (*(_DWORD *)v47 >= 0xCu && (*((_DWORD *)v47 + 2) & 2) != 0) {
          goto LABEL_76;
        }
        double v48 = 0.0;
        if (*(_DWORD *)v47 >= 0x30u)
        {
          *(void *)long long buf = *((void *)v47 + 5);
          double v48 = floor(*(double *)buf);
        }
        if (Current < v48) {
LABEL_76:
        }
          v117[v46++] = v47;
      }
      ++v45;
    }
    while (v35 != v45);
    uint64_t v49 = v114;
    if (__p && a4 && v46 >= 0xB5)
    {
      size_t v50 = 4 * v46;
      uint64_t v51 = operator new(v50);
      uint64_t v52 = v46 - 150;
      bzero(v51, v50);
      uint64_t v53 = 0;
      size_t v54 = v50;
      do
      {
        v51[v53] = v53;
        ++v53;
        v54 -= 4;
      }
      while (v54);
      uint64_t v118 = &v117;
      unint64_t v55 = (unint64_t)(v52 - 2) >> 1;
      unint64_t v56 = v55 + 1;
      __pa = (char *)v51;
      uint64_t v57 = &v51[v55];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,CompactCookieArray::_mungeCookies(CompactCookieArray const*,CompactCookieArray const*,unsigned char,BOOL)::$_0 &,std::__wrap_iter<unsigned int *>>((uint64_t)v51, (uint64_t **)&v118, v46 - 150, v57--);
        --v56;
      }
      while (v56);
      if (&v51[v52] != &v51[v50 / 4])
      {
        uint64_t v58 = 4 * v52;
        do
        {
          int v59 = v117[v51[(unint64_t)v58 / 4]];
          unint64_t v60 = v117[*v51];
          CompactCookieHeader::getEnumeratedTime((uint64_t)v59, 19);
          double v62 = v61;
          CompactCookieHeader::getEnumeratedTime((uint64_t)v60, 19);
          if (v62 < v63) {
            goto LABEL_94;
          }
          if (v62 <= v63)
          {
            double v64 = 0.0;
            double v65 = 0.0;
            if (*(_DWORD *)v59 >= 0x38u)
            {
              *(void *)long long buf = *((void *)v59 + 6);
              double v65 = floor(*(double *)buf);
            }
            if (*(_DWORD *)v60 >= 0x38u)
            {
              *(void *)long long buf = *((void *)v60 + 6);
              double v64 = floor(*(double *)buf);
            }
            if (v65 < v64)
            {
LABEL_94:
              int v66 = v51[(unint64_t)v58 / 4];
              v51[(unint64_t)v58 / 4] = *v51;
              *uint64_t v51 = v66;
              std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,CompactCookieArray::_mungeCookies(CompactCookieArray const*,CompactCookieArray const*,unsigned char,BOOL)::$_0 &,std::__wrap_iter<unsigned int *>>((uint64_t)v51, (uint64_t **)&v118, v46 - 150, v51);
            }
          }
          v58 += 4;
        }
        while (v50 != v58);
      }
      unint64_t v109 = v46 - 150;
      unsigned int v110 = v46;
      uint64_t v67 = v109;
      long long v113 = &v51[v52];
      do
      {
        uint64_t v68 = 0;
        uint64_t v69 = (unsigned int *)__pa;
        unsigned int v111 = *(_DWORD *)__pa;
        do
        {
          char v70 = v69;
          v69 += v68 + 1;
          uint64_t v71 = 2 * v68;
          uint64_t v68 = (2 * v68) | 1;
          uint64_t v72 = v71 + 2;
          if (v71 + 2 < v67)
          {
            CFURLRef v73 = v117[*v69];
            uint64_t v74 = v117[v69[1]];
            CompactCookieHeader::getEnumeratedTime((uint64_t)v73, 19);
            double v76 = v75;
            CompactCookieHeader::getEnumeratedTime((uint64_t)v74, 19);
            if (v76 < v77) {
              goto LABEL_100;
            }
            if (v76 <= v77)
            {
              double v78 = 0.0;
              double v79 = 0.0;
              if (*(_DWORD *)v73 >= 0x38u)
              {
                *(void *)long long buf = *((void *)v73 + 6);
                double v79 = floor(*(double *)buf);
              }
              if (*(_DWORD *)v74 >= 0x38u)
              {
                *(void *)long long buf = *((void *)v74 + 6);
                double v78 = floor(*(double *)buf);
              }
              if (v79 < v78)
              {
LABEL_100:
                ++v69;
                uint64_t v68 = v72;
              }
            }
          }
          *char v70 = *v69;
        }
        while (v68 <= (uint64_t)((unint64_t)(v67 - 2) >> 1));
        uint64_t v80 = v113 - 1;
        if (v69 == --v113)
        {
          *uint64_t v69 = v111;
        }
        else
        {
          *uint64_t v69 = *v80;
          *uint64_t v80 = v111;
          uint64_t v82 = (char *)v69 - __pa + 4;
          if (v82 >= 5)
          {
            unint64_t v83 = ((unint64_t)v82 >> 2) - 2;
            unint64_t v84 = v83 >> 1;
            uint64_t v85 = &__pa[4 * (v83 >> 1)];
            long long v86 = v117[*(unsigned int *)v85];
            long long v87 = v117[*v69];
            CompactCookieHeader::getEnumeratedTime((uint64_t)v86, 19);
            double v89 = v88;
            CompactCookieHeader::getEnumeratedTime((uint64_t)v87, 19);
            if (v89 < v90) {
              goto LABEL_117;
            }
            if (v89 <= v90)
            {
              double v91 = 0.0;
              double v92 = 0.0;
              if (*(_DWORD *)v86 >= 0x38u)
              {
                *(void *)long long buf = *((void *)v86 + 6);
                double v92 = floor(*(double *)buf);
              }
              if (*(_DWORD *)v87 >= 0x38u)
              {
                *(void *)long long buf = *((void *)v87 + 6);
                double v91 = floor(*(double *)buf);
              }
              if (v92 < v91)
              {
LABEL_117:
                uint64_t v93 = *v69;
                *uint64_t v69 = *(_DWORD *)v85;
                if (v83 >= 2)
                {
                  while (1)
                  {
                    unint64_t v95 = v84 - 1;
                    unint64_t v84 = (v84 - 1) >> 1;
                    long long v94 = &__pa[4 * v84];
                    long long v96 = v117[*(unsigned int *)v94];
                    long long v97 = v117[v93];
                    CompactCookieHeader::getEnumeratedTime((uint64_t)v96, 19);
                    double v99 = v98;
                    CompactCookieHeader::getEnumeratedTime((uint64_t)v97, 19);
                    if (v99 >= v100)
                    {
                      if (v99 > v100) {
                        break;
                      }
                      double v101 = 0.0;
                      double v102 = 0.0;
                      if (*(_DWORD *)v96 >= 0x38u)
                      {
                        *(void *)long long buf = *((void *)v96 + 6);
                        double v102 = floor(*(double *)buf);
                      }
                      if (*(_DWORD *)v97 >= 0x38u)
                      {
                        *(void *)long long buf = *((void *)v97 + 6);
                        double v101 = floor(*(double *)buf);
                      }
                      if (v102 >= v101) {
                        break;
                      }
                    }
                    *(_DWORD *)uint64_t v85 = *(_DWORD *)v94;
                    uint64_t v85 = &__pa[4 * v84];
                    if (v95 <= 1) {
                      goto LABEL_127;
                    }
                  }
                }
                long long v94 = v85;
LABEL_127:
                *(_DWORD *)long long v94 = v93;
              }
            }
          }
        }
      }
      while (v67-- > 2);
      std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
      uint64_t v104 = 0;
      int v105 = 0;
      int v106 = 0;
      uint64_t v49 = v114;
      do
      {
        if (v109 > v105 && v104 == *(_DWORD *)&__pa[4 * v105]) {
          ++v105;
        }
        else {
          v117[v106++] = v117[v104];
        }
        ++v104;
      }
      while (v110 != v104);
      operator delete(__pa);
      unsigned int v46 = 150;
    }
  }
  else
  {
    unsigned int v46 = 0;
    uint64_t v49 = v114;
  }
  CFGetAllocator((CFTypeRef)(v49 - 16));
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(void *)(Instance + CFRelease((char *)this - 16) = 0;
    *(void *)(Instance + 24) = 0;
    Instance += 16;
    *(void *)(Instance + CFRelease((char *)this - 16) = 0;
  }
  uint64_t v114 = Instance;
  CompactCookieArray::CompactCookieArray((CompactCookieArray *)Instance, (const CompactCookieHeader **)v117, v46);
LABEL_144:
  if (v117 != (CompactCookieHeader **)v120 && v117) {
    MEMORY[0x18531B6B0]();
  }
  return v114;
}

void sub_1842852C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p)
{
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,CompactCookieArray::_mungeCookies(CompactCookieArray const*,CompactCookieArray const*,unsigned char,BOOL)::$_0 &,std::__wrap_iter<unsigned int *>>(uint64_t result, uint64_t **a2, uint64_t a3, _DWORD *a4)
{
  int64_t v48 = (unint64_t)(a3 - 2) >> 1;
  if (v48 >= ((uint64_t)a4 - result) >> 2)
  {
    uint64_t v7 = result;
    uint64_t v8 = ((uint64_t)a4 - result) >> 1;
    uint64_t v9 = v8 | 1;
    uint64_t v10 = (unsigned int *)(result + 4 * (v8 | 1));
    uint64_t v11 = v8 + 2;
    if (v8 + 2 < a3)
    {
      uint64_t v12 = **a2;
      uint64_t v13 = *(void *)(v12 + 8 * *v10);
      uint64_t v14 = *(void *)(v12 + 8 * v10[1]);
      CompactCookieHeader::getEnumeratedTime(v13, 19);
      double v16 = v15;
      CompactCookieHeader::getEnumeratedTime(v14, 19);
      if (v16 < v17) {
        goto LABEL_10;
      }
      if (v16 <= v17)
      {
        double v18 = 0.0;
        double v19 = 0.0;
        if (*(_DWORD *)v13 >= 0x38u) {
          double v19 = floor(*(double *)(v13 + 48));
        }
        if (*(_DWORD *)v14 >= 0x38u) {
          double v18 = floor(*(double *)(v14 + 48));
        }
        if (v19 < v18)
        {
LABEL_10:
          ++v10;
          uint64_t v9 = v11;
        }
      }
    }
    uint64_t v20 = **a2;
    uint64_t v21 = *(void *)(v20 + 8 * *v10);
    uint64_t v22 = *(void *)(v20 + 8 * *a4);
    CompactCookieHeader::getEnumeratedTime(v21, 19);
    double v24 = v23;
    uint64_t result = CompactCookieHeader::getEnumeratedTime(v22, 19);
    if (v24 >= v25)
    {
      if (v24 > v25) {
        goto LABEL_18;
      }
      double v26 = 0.0;
      double v27 = 0.0;
      if (*(_DWORD *)v21 >= 0x38u) {
        double v27 = floor(*(double *)(v21 + 48));
      }
      if (*(_DWORD *)v22 >= 0x38u) {
        double v26 = floor(*(double *)(v22 + 48));
      }
      if (v27 >= v26)
      {
LABEL_18:
        uint64_t v47 = *a4;
        *a4 = *v10;
        if (v48 >= v9)
        {
          while (1)
          {
            uint64_t v29 = 2 * v9;
            uint64_t v9 = (2 * v9) | 1;
            unsigned int v28 = (unsigned int *)(v7 + 4 * v9);
            uint64_t v30 = v29 + 2;
            if (v29 + 2 < a3)
            {
              uint64_t v31 = **a2;
              uint64_t v32 = *(void *)(v31 + 8 * *v28);
              uint64_t v33 = *(void *)(v31 + 8 * v28[1]);
              CompactCookieHeader::getEnumeratedTime(v32, 19);
              double v35 = v34;
              CompactCookieHeader::getEnumeratedTime(v33, 19);
              if (v35 < v36) {
                goto LABEL_28;
              }
              if (v35 <= v36)
              {
                double v37 = 0.0;
                double v38 = 0.0;
                if (*(_DWORD *)v32 >= 0x38u) {
                  double v38 = floor(*(double *)(v32 + 48));
                }
                if (*(_DWORD *)v33 >= 0x38u) {
                  double v37 = floor(*(double *)(v33 + 48));
                }
                if (v38 < v37)
                {
LABEL_28:
                  ++v28;
                  uint64_t v9 = v30;
                }
              }
            }
            uint64_t v39 = **a2;
            uint64_t v40 = *(void *)(v39 + 8 * *v28);
            uint64_t v41 = *(void *)(v39 + 8 * v47);
            CompactCookieHeader::getEnumeratedTime(v40, 19);
            double v43 = v42;
            uint64_t result = CompactCookieHeader::getEnumeratedTime(v41, 19);
            if (v43 < v44) {
              break;
            }
            if (v43 <= v44)
            {
              double v45 = 0.0;
              double v46 = 0.0;
              if (*(_DWORD *)v40 >= 0x38u) {
                double v46 = floor(*(double *)(v40 + 48));
              }
              if (*(_DWORD *)v41 >= 0x38u) {
                double v45 = floor(*(double *)(v41 + 48));
              }
              if (v46 < v45) {
                break;
              }
            }
            *uint64_t v10 = *v28;
            uint64_t v10 = v28;
            if (v48 < v9) {
              goto LABEL_37;
            }
          }
        }
        unsigned int v28 = v10;
LABEL_37:
        *unsigned int v28 = v47;
      }
    }
  }
  return result;
}

CompactCookieArray *CompactCookieArray::makeCompactCookieArray(CompactCookieArray *this, const CompactCookieHeader **a2, const CompactCookieHeader **a3)
{
  unsigned int v3 = a3;
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  CFDataRef v6 = (CompactCookieArray *)Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    CFDataRef v6 = (CompactCookieArray *)(Instance + 2);
    Instance[4] = 0;
  }
  CompactCookieArray::CompactCookieArray(v6, a2, v3);
  if (!CompactCookieArray::assertCookiesValid(v7))
  {
    CFRelease((char *)v6 - 16);
    return 0;
  }
  return v6;
}

CompactCookieArray *CompactCookieArray::makeCompactCookieArray(CompactCookieArray *this, const __CFAllocator *a2, const __CFData *a3)
{
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  unint64_t v5 = (CompactCookieArray *)Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    unint64_t v5 = (CompactCookieArray *)(Instance + 2);
    Instance[4] = 0;
  }
  *(void *)unint64_t v5 = &unk_1ECF9EFC0;
  *((void *)v5 + 1) = &unk_1ECF9F008;
  if (a2) {
    CFTypeRef v6 = CFRetain(a2);
  }
  else {
    CFTypeRef v6 = 0;
  }
  *((void *)v5 + 2) = v6;
  if (!CompactCookieArray::assertCookiesValid(v5))
  {
    CFRelease((char *)v5 - 16);
    return 0;
  }
  return v5;
}

void sub_1842857CC(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

CompactCookieArray *CompactCookieArray::makeCompactCookieArray(CompactCookieArray *this, const __CFAllocator *a2, const __CFArray *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (CompactCookieArray::Class(void)::sOnce_CompactCookieArray != -1) {
    dispatch_once(&CompactCookieArray::Class(void)::sOnce_CompactCookieArray, &__block_literal_global_13810);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  unint64_t v5 = (CompactCookieArray *)Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    unint64_t v5 = (CompactCookieArray *)(Instance + 2);
    Instance[4] = 0;
  }
  *(void *)unint64_t v5 = &unk_1ECF9EFC0;
  *((void *)v5 + 1) = &unk_1ECF9F008;
  CFAllocatorRef v6 = CFGetAllocator((char *)v5 - 16);
  CFMutableArrayRef Mutable = CFDataCreateMutable(v6, 0);
  CFMutableDataRef v15 = Mutable;
  unsigned int Count = CFArrayGetCount(a2);
  unsigned int v9 = Count;
  size_t v10 = Count;
  if (Count >= 0x21uLL) {
    operator new[]();
  }
  memset(v16, 0, sizeof(v16));
  v18.CFIndex location = 0;
  v18.size_t length = Count;
  CFArrayGetValues(a2, v18, (const void **)v16);
  if (v9)
  {
    uint64_t v11 = (id *)v16;
    size_t v12 = v10;
    do
    {
      uint64_t v13 = [*v11 _inner];
      *v11++ = (id)(*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
      --v12;
    }
    while (v12);
  }
  qsort(v16, v10, 8uLL, (int (__cdecl *)(const void *, const void *))_cookie_header_qsort);
  *((void *)v5 + 2) = CookieArrayViewConstructionKit::createArrayView(&v15, (const CompactCookieHeader **)v16, v9);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (!CompactCookieArray::assertCookiesValid(v5))
  {
    CFRelease((char *)v5 - 16);
    return 0;
  }
  return v5;
}

void sub_184285A50(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(exception_object);
}

CompactCookieHeader *CompactHTTPCookieReference::cookieHeader(CompactHTTPCookieReference *this)
{
  return this->var2;
}

void CompactHTTPCookieReference::~CompactHTTPCookieReference(CompactHTTPCookieReference *this)
{
  CompactHTTPCookieReference::~CompactHTTPCookieReference(this);

  JUMPOUT(0x18531B6D0);
}

{
  this->id var0 = (void **)&unk_1ECFA3718;
  CFRelease((char *)this->var1 - 16);
  this->id var0 = (void **)&unk_1ECF9B550;
}

void sub_184285BF0(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::shouldFreeEnumeratedString()
{
  return 0;
}

double CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::getCreateTime(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 344);
  if (*(_DWORD *)v1 >= 0x38u) {
    return floor(*(double *)(v1 + 48));
  }
  else {
    return 0.0;
  }
}

BOOL CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::getExpireTime(uint64_t a1)
{
  uint64_t v1 = *(_DWORD **)(a1 + 344);
  return *v1 < 0xCu || (v1[2] & 2) == 0;
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::getPort(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int **)(a1 + 344);
  uint64_t v3 = (2 * a2 + 56);
  CFDataRef v4 = (unsigned __int16 *)((char *)v2 + v3);
  uint64_t v5 = *v2;
  CFAllocatorRef v6 = (unsigned __int16 *)((char *)v2 + v5);
  uint64_t v7 = v4 + 1;
  if (v5 > v3)
  {
    BOOL v8 = v7 >= v6;
    BOOL v9 = v7 == v6;
  }
  else
  {
    BOOL v8 = 1;
    BOOL v9 = 0;
  }
  if (!v9 && v8) {
    return 0;
  }
  else {
    return *v4;
  }
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::getFlags(uint64_t a1)
{
  uint64_t v1 = *(_DWORD **)(a1 + 344);
  if (*v1 >= 0xCu) {
    return v1[2] & 0x7FLL;
  }
  else {
    return 0;
  }
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::getVersion(uint64_t a1)
{
  uint64_t v1 = *(_DWORD **)(a1 + 344);
  if (*v1 >= 8u) {
    return v1[1];
  }
  else {
    return 0;
  }
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::getPortCount(uint64_t a1)
{
  uint64_t v1 = *(_DWORD **)(a1 + 344);
  if (*v1 >= 0x10u) {
    return v1[3];
  }
  else {
    return 0;
  }
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::getEnumeratedTime(uint64_t a1, int a2)
{
  if (a2 == 19)
  {
    if (*(unsigned char *)(a1 + 368)) {
      return 1;
    }
    a2 = 19;
  }
  return CompactCookieHeader::getEnumeratedTime(*(void *)(a1 + 344), a2);
}

const UInt8 *CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::getEnumeratedString(uint64_t a1, int a2)
{
  if (a2 == 15) {
    return *(const UInt8 **)(a1 + 352);
  }
  else {
    return CompactCookieHeader::getEnumeratedString(*(CompactCookieHeader **)(a1 + 344), a2, 0);
  }
}

void CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::~SrcDecanter(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFAC6D0;
  free(*(void **)(a1 + 352));

  JUMPOUT(0x18531B6D0);
}

uint64_t CompactHTTPCookieWithData::initFromSource(HTTPCookie const*,__CFString const*,std::optional<double>)::SrcDecanter::~SrcDecanter(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFAC6D0;
  free(*(void **)(a1 + 352));
  return a1;
}

void *CompactHTTPCookieWithData::CompactHTTPCookieWithData(void *a1, uint64_t a2, const __CFString *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  *a1 = &unk_1ECFA3128;
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  long long v32 = 0u;
  memset(v33, 0, sizeof(v33));
  long long v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  long long v28 = 0u;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v36 = a4;
  uint64_t v37 = a5;
  uint64_t v13 = &unk_1ECFAC6D0;
  uint64_t v34 = v9;
  if (a3)
  {
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFAllocatorRef allocator = v10;
    v39[0] = 1023;
    CString = _CFStringGetOrCreateCString(v10, a3, v40, v39, 0x8000100u);
    v39[1] = (uint64_t)CString;
    double v35 = strdup((const char *)CString);
    if (CString && v40 != CString) {
      CFAllocatorDeallocate(allocator, CString);
    }
  }
  else
  {
    double v35 = 0;
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  }
  a1[1] = Decanter::decant((Decanter *)&v13, v10);
  uint64_t v13 = &unk_1ECFAC6D0;
  free(v35);
  return a1;
}

void sub_184286018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54)
{
  free(a54);
  *size_t v54 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::shouldFreeEnumeratedString()
{
  return 1;
}

uint64_t CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::getPort(uint64_t a1, CFIndex idx)
{
  unsigned int v2 = idx;
  CFArrayRef v4 = *(const __CFArray **)(a1 + 352);
  if (!v4)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "You need a port array to get a port", buf, 2u);
      CFArrayRef v4 = *(const __CFArray **)(a1 + 352);
    }
    else
    {
      CFArrayRef v4 = 0;
    }
  }
  uint64_t v7 = 0;
  CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, v2);
  CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::valueToCFIndex(ValueAtIndex, &v7);
  return (unsigned __int16)v7;
}

CFStringRef CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureDomainToOriginURL(uint64_t a1, CFTypeRef cf)
{
  CFAllocatorRef v4 = CFGetAllocator(cf);
  char v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
  CFAllocatorRef v6 = "https";
  if ((v5 & 1) == 0) {
    CFAllocatorRef v6 = "http";
  }
  return CFStringCreateWithFormat(v4, 0, @"%s://%@/", v6, cf);
}

CFStringRef CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::ensureOriginURLToDomain(int a1, const __CFString *cf)
{
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 == CFURLGetTypeID())
  {
    return CFURLCopyHostName((CFURLRef)cf);
  }
  else
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFStringGetTypeID())
    {
      CFAllocatorRef v6 = CFGetAllocator(cf);
      CFURLRef v7 = CFURLCreateWithString(v6, cf, 0);
      CFStringRef v8 = CFURLCopyHostName(v7);
      CFRelease(v7);
      return v8;
    }
    else
    {
      return 0;
    }
  }
}

void CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::~PropDecanter(void *a1)
{
  CompactHTTPCookieWithData::CompactHTTPCookieWithData(__CFDictionary const*)::PropDecanter::~PropDecanter(a1);

  JUMPOUT(0x18531B6D0);
}

void CoreLoggable::~CoreLoggable(CoreLoggable *this)
{
  this->id var0 = (void **)&unk_1ECF9B550;
  JUMPOUT(0x18531B6D0);
}

{
  this->id var0 = (void **)&unk_1ECF9B550;
}

void non-virtual thunk to'HTTPConnection::~HTTPConnection(HTTPConnection *this)
{
  HTTPConnection::~HTTPConnection((HTTPConnection *)((char *)this - 24));

  JUMPOUT(0x18531B6D0);
}

{
  HTTPConnection::~HTTPConnection((HTTPConnection *)((char *)this - 24));
}

uint64_t HTTPConnection::alternatePathAvailable(HTTPConnection *this, uint64_t a2)
{
  CFStreamError v17 = (CFStreamError)xmmword_1843D1780;
  uint64_t v4 = *((void *)this + 20);
  if (v4)
  {
    TransactionItr = HTTPConnection::_onqueue_getTransactionItr(*((void **)this + 15), *((void **)this + 16), v4);
    uint64_t v6 = *((void *)this + 18);
    if (v6) {
      CFURLRef v7 = HTTPConnection::_onqueue_getTransactionItr(*((void **)this + 15), *((void **)this + 16), v6) + 2;
    }
    else {
      CFURLRef v7 = (uint64_t *)*((void *)this + 16);
    }
    while (1)
    {
      BOOL v8 = TransactionItr != v7;
      if (TransactionItr == v7)
      {
LABEL_16:
        v9.CFIndex domain = v17.domain;
        goto LABEL_17;
      }
      uint64_t v10 = *TransactionItr;
      uint64_t v11 = (std::__shared_weak_count *)TransactionItr[1];
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v12 = *(void *)(v10 + 208);
      if (!v12) {
        break;
      }
      BOOL v13 = (*(unsigned int (**)(uint64_t, CFStreamError *, void))(*(void *)v12 + 280))(v12, &v17, 0)
          - 5 < 6;
      if (v11) {
        goto LABEL_11;
      }
LABEL_12:
      TransactionItr += 2;
      if (!v13) {
        goto LABEL_16;
      }
    }
    BOOL v13 = 0;
    if (!v11) {
      goto LABEL_12;
    }
LABEL_11:
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    goto LABEL_12;
  }
  BOOL v8 = 0;
  v9.CFIndex domain = 4;
LABEL_17:
  *(void *)&v9.uint64_t error = *(void *)&v17.error;
  if ((a2 & 0xFFFFFFFD) != 1 || v8)
  {
    HTTPConnection::_onqueue_doNotAllowMoreRequests(this, v9, 0);
    uint64_t v14 = *((void *)this + 20);
    if (v14)
    {
      uint64_t v15 = *(void *)(v14 + 208);
      if (v15) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 248))(v15, a2);
      }
    }
  }
  else
  {
    HTTPConnection::_onqueue_errorOccurred(this, v9, 0);
  }
  return 1;
}

void sub_1842864AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void HTTPConnection::_onqueue_errorOccurred(HTTPConnection *this, CFStreamError a2, unsigned int a3)
{
  uint64_t v20 = *(void *)&a2.error;
  int v3 = *((unsigned __int16 *)this + 16);
  if ((v3 & 0x20) == 0)
  {
    unsigned int v5 = v3 & 0xFFFFFFFE | (*((unsigned __int8 *)this + 34) << 16);
    *((unsigned char *)this + 34) = BYTE2(v5);
    *((_WORD *)this + CFRelease((char *)this - 16) = v5 | 0x20;
    *(void *)&a2.uint64_t error = *((void *)this + 20);
    if (*(void *)&a2.error)
    {
      CFIndex domain = a2.domain;
      for (unint64_t i = &HTTPConnection::_onqueue_getTransactionItr(*((void **)this + 15), *((void **)this + 16), *(uint64_t *)&a2.error)[2 * a3]; i != *((uint64_t **)this + 16); i += 2)
      {
        uint64_t v8 = *i;
        CFStreamError v9 = (std::__shared_weak_count *)i[1];
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v8 == *((void *)this + 18)) {
          *((_WORD *)this + 16) |= 0x800u;
        }
        v27[0] = 0;
        v27[1] = v27;
        v27[2] = 0x4012000000;
        v27[3] = __Block_byref_object_copy__14;
        v27[4] = __Block_byref_object_dispose__15;
        void v27[5] = &unk_18441BEED;
        uint64_t v28 = 0;
        long long v29 = 0;
        uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 6);
        if (v10)
        {
          long long v29 = std::__shared_weak_count::lock(v10);
          if (v29) {
            uint64_t v28 = *((void *)this + 5);
          }
        }
        uint64_t v11 = *((void *)this + 7);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3321888768;
        block[2] = ___ZN14HTTPConnection22_onqueue_errorOccurredE13CFStreamErrorb_block_invoke;
        CFHostClientContext block[3] = &unk_1ECFAA0F0;
        void block[5] = v8;
        long long v24 = v9;
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        CFIndex v25 = domain;
        uint64_t v26 = v20;
        block[4] = v27;
        dispatch_async(v11, block);
        if (v24) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v24);
        }
        _Block_object_dispose(v27, 8);
        if (v29) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v29);
        }
        if (v9) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v9);
        }
      }
    }
    if (a3)
    {
      HTTPConnection::_onqueue_cleanupEngineWhenPossible(this, 0);
    }
    else
    {
      uint64_t v12 = (HTTPEngine *)*((void *)this + 8);
      if (v12)
      {
        int v13 = *((unsigned __int16 *)this + 16);
        int v14 = v13 | (*((unsigned __int8 *)this + 34) << 16);
        if ((v13 & 0x100) == 0)
        {
          *((unsigned char *)this + 34) = BYTE2(v14);
          *((_WORD *)this + CFRelease((char *)this - 16) = v14 | 0x100;
          HTTPEngine::_cleanupConnection(v12, 0);
        }
      }
    }
    uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 11);
    if (v15)
    {
      long long v16 = std::__shared_weak_count::lock(v15);
      if (v16)
      {
        CFStreamError v17 = v16;
        uint64_t v18 = *((void *)this + 10);
        if (v18)
        {
          std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v21, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
          (*(void (**)(uint64_t, uint64_t *))(*(void *)v18 + 40))(v18, &v21);
          if (v22) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v22);
          }
        }
        std::__shared_weak_count::__release_shared[abi:nn180100](v17);
      }
    }
  }
}

void sub_18428676C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__14(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void ___ZN14HTTPConnection31_onqueue_doNotAllowMoreRequestsE13CFStreamErrorb_block_invoke(uint64_t a1)
{
  HTTPTransaction::errorOccurred(*(HTTPTransaction **)(a1 + 40), *(CFStreamError *)(a1 + 56));
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  int v3 = *(std::__shared_weak_count **)(v2 + 56);
  *(void *)(v2 + 48) = 0;
  *(void *)(v2 + 56) = 0;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void __destroy_helper_block_e8_40c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN14HTTPConnection22_onqueue_errorOccurredE13CFStreamErrorb_block_invoke(uint64_t a1)
{
  HTTPTransaction::errorOccurred(*(HTTPTransaction **)(a1 + 40), *(CFStreamError *)(a1 + 56));
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  int v3 = *(std::__shared_weak_count **)(v2 + 56);
  *(void *)(v2 + 48) = 0;
  *(void *)(v2 + 56) = 0;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void HTTPConnection::errorOccurred(HTTPConnection *this, CFStreamError a2)
{
}

void non-virtual thunk to'HTTPConnectionAuthenticator::~HTTPConnectionAuthenticator(HTTPConnectionAuthenticator *this)
{
  HTTPConnectionAuthenticator::~HTTPConnectionAuthenticator((HTTPConnectionAuthenticator *)((char *)this - 88));

  JUMPOUT(0x18531B6D0);
}

{
  HTTPConnectionAuthenticator::~HTTPConnectionAuthenticator((HTTPConnectionAuthenticator *)((char *)this - 88));
}

BOOL HTTPConnectionAuthenticator::applyToRequest(HTTPConnectionAuthenticator *this, HTTPRequestMessage *a2, void *a3, BOOL a4)
{
  BOOL v4 = a4;
  v12[4] = *MEMORY[0x1E4F143B8];
  if (this)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
    if (!v4)
    {
LABEL_12:
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
      return v4;
    }
LABEL_5:
    if (*((void *)this + 13)) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = *((void *)this + 16) == 0;
    }
    BOOL v4 = 0;
    if (a2 && !v8)
    {
      char v11 = 1;
      CFStreamError v9 = operator new(0x20uLL);
      *CFStreamError v9 = &unk_1ECFA6450;
      v9[1] = a2;
      v9[2] = a3;
      void v9[3] = &v11;
      void v12[3] = v9;
      AuthenticationState::_foreachAuthenticationInfo((uint64_t)this, (uint64_t)v12);
      std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](v12);
      BOOL v4 = v11 != 0;
    }
    goto LABEL_12;
  }
  if (a4) {
    goto LABEL_5;
  }
  return 0;
}

void sub_184286A34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100]((uint64_t *)va);
  pthread_mutex_unlock((pthread_mutex_t *)(v2 + 8));
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, AuthenticationInfo **a3)
{
  if (AuthenticationInfo::canApplyHeadersToRequest(*a3, *(HTTPRequestMessage **)(a1 + 8))
    && HTTPAuthentication::isKerberosThePreferredAuthScheme(*(const __CFDictionary **)(*((void *)*a3 + 1) + 136)))
  {
    int v5 = AuthenticationInfo::applyToRequest(*a3, *(HTTPRequestMessage **)(a1 + 8), *(void **)(a1 + 16));
    uint64_t v6 = *(BOOL **)(a1 + 24);
    if (v5) {
      BOOL v7 = *v6;
    }
    else {
      BOOL v7 = 0;
    }
    *uint64_t v6 = v7;
  }
  return 1;
}

__n128 std::__function::__func<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA6450;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1ECFA6450;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0,std::allocator<HTTPConnectionAuthenticator::applyToRequest(HTTPRequestMessage *,void *,BOOL)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

void HTTPConnection::_onqueue_cleanupEngine(HTTPConnection *this)
{
  uint64_t v2 = (HTTPEngine *)*((void *)this + 8);
  if (v2)
  {
    int v3 = *((unsigned __int16 *)this + 16);
    int v4 = v3 | (*((unsigned __int8 *)this + 34) << 16);
    if ((v3 & 0x100) == 0)
    {
      *((unsigned char *)this + 34) = BYTE2(v4);
      *((_WORD *)this + CFRelease((char *)this - 16) = v4 | 0x100;
      HTTPEngine::_cleanupConnection(v2, 0);
    }
  }
}

__n128 __Block_byref_object_copy__13926(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__13927(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void std::__shared_ptr_emplace<HTTPConnectionAuthenticator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6C60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTPConnectionAuthenticator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6C60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t ___ZN14HTTPConnection19willEnqueueRequestsEb_block_invoke(uint64_t a1)
{
  uint64_t result = HTTPConnection::_onqueue_willEnqueueRequests(*(HTTPConnection **)(a1 + 40), 0, *(unsigned __int8 *)(a1 + 48));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void ___ZN14HTTPConnection17getLastAccessTimeEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 120) == *(void *)(v2 + 128)) {
    double Current = *(double *)(v2 + 208);
  }
  else {
    double Current = CFAbsoluteTimeGetCurrent();
  }
  *(double *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = Current;
}

uint64_t ___ZN14HTTPConnection13getQueueDepthEv_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = (*(void *)(*(void *)(result + 40) + 128)
                                                                   - *(void *)(*(void *)(result + 40) + 120)) >> 4;
  return result;
}

void *___ZN14HTTPConnection22getPendingRequestCountEv_block_invoke(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v2 + 144);
  if (v3)
  {
    uint64_t result = HTTPConnection::_onqueue_getTransactionItr(*(void **)(v2 + 120), *(void **)(v2 + 128), v3);
    uint64_t v4 = (*(void *)(v2 + 128) - (void)result) >> 4;
  }
  else
  {
    LODWORD(v4) = 0;
  }
  *(_DWORD *)(*(void *)(v1[4] + 8) + 24) = v4;
  return result;
}

uint64_t HTTPConnection::getPendingResponseCount(HTTPConnection *this)
{
  uint64_t v7 = 0;
  BOOL v8 = &v7;
  uint64_t v9 = 0x2020000000;
  int v10 = 0;
  uint64_t v1 = *((void *)this + 20);
  if (v1)
  {
    uint64_t v2 = (*((void *)this + 16)
        - (void)HTTPConnection::_onqueue_getTransactionItr(*((void **)this + 15), *((void **)this + 16), v1)) >> 4;
    uint64_t v3 = (unsigned int *)(v8 + 3);
    uint64_t v4 = (int *)(v8 + 3);
  }
  else
  {
    LODWORD(v2) = 0;
    uint64_t v3 = (unsigned int *)&v10;
    uint64_t v4 = &v10;
  }
  int *v4 = v2;
  uint64_t v5 = *v3;
  _Block_object_dispose(&v7, 8);
  return v5;
}

void sub_184286E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *___ZN14HTTPConnection23getPendingResponseCountEv_block_invoke(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[5];
  uint64_t v3 = *(void *)(v2 + 160);
  if (v3)
  {
    uint64_t result = HTTPConnection::_onqueue_getTransactionItr(*(void **)(v2 + 120), *(void **)(v2 + 128), v3);
    uint64_t v4 = (*(void *)(v2 + 128) - (void)result) >> 4;
  }
  else
  {
    LODWORD(v4) = 0;
  }
  *(_DWORD *)(*(void *)(v1[4] + 8) + 24) = v4;
  return result;
}

uint64_t ___ZN14HTTPConnection19hasPendingResponsesEv_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(*(void *)(result + 40) + 160) != 0;
  return result;
}

void ___ZN14HTTPConnection31doNotAllowMoreRequests_offqueueEv_block_invoke(uint64_t a1)
{
  v1.CFIndex domain = 4;
  *(void *)&v1.uint64_t error = 4294967292;
  HTTPConnection::_onqueue_doNotAllowMoreRequests(*(HTTPConnection **)(a1 + 32), v1, 0);
}

uint64_t ___ZN14HTTPConnection25getNumSuccessfulResponsesEv_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(*(void *)(result + 40) + 232);
  return result;
}

void ___ZN14HTTPConnection22isIneligibleToBePurgedEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFAbsoluteTimeGetCurrent() < *(double *)(v1 + 216);
}

void HTTPConnection::suspendTransaction(void *a1, void *a2, int a3)
{
  if (*a2)
  {
    uint64_t v4 = (HTTPEngine *)a1[8];
    if (v4)
    {
      uint64_t v7 = a1[18];
      if (v7) {
        BOOL v8 = *a2 == v7;
      }
      else {
        BOOL v8 = 0;
      }
      if (v8) {
        HTTPEngine::suspendWrites(v4, a3);
      }
      uint64_t v9 = a1[20];
      if (v9 && *a2 == v9)
      {
        int v10 = (HTTPEngine *)a1[8];
        HTTPEngine::suspendReads(v10, a3);
      }
    }
  }
}

void ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke_39(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v4 = *(HTTPResponseMessage **)a2;
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 88);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = *(void *)(v2 + 80);
      if (v7)
      {
        std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v14, *(void *)(v2 + 8), *(std::__shared_weak_count **)(v2 + 16));
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v7 + 32))(v7, &v14);
        if (v15) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v15);
        }
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(v2 + 160);
  if (!v8)
  {
    uint64_t v12 = "_currentResponse";
    int v13 = 1548;
    goto LABEL_29;
  }
  if (!v4)
  {
    uint64_t v12 = "response";
    int v13 = 1551;
LABEL_29:
    __assert_rtn("_onqueue_informationalResponseArrived", "HTTPConnection.cpp", v13, v12);
  }
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(void *)(v8 + 208);
  if (v9) {
    int v10 = (void *)(v9 - 176);
  }
  else {
    int v10 = 0;
  }
  char v11 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(void *)(v8 + 160) + 128));
  HTTPResponseMessage::setResponseURL(v4, v11, 0);
  v16[0] = v4;
  v16[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HTTPProtocol::handleInformationalResponse(v10, (uint64_t)v16);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void sub_184287174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  _Unwind_Resume(a1);
}

BOOL std::__function::__func<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0,std::allocator<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(HTTPAuthentication **)(*(void *)a3 + 8);
  if (!v4 || !HTTPAuthentication::isConnectionBasedAuth(v4)) {
    return **(unsigned char **)(a1 + 8) != 0;
  }
  uint64_t v6 = *(void *)(*(void *)a3 + 16);
  if (v6)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    BOOL result = *(_DWORD *)(v6 + 52) != 1;
  }
  else
  {
    BOOL result = 0;
  }
  **(unsigned char **)(a1 + 8) = result;
  return result;
}

uint64_t std::__function::__func<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0,std::allocator<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1ECFA6498;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0,std::allocator<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1ECFA6498;
  result[1] = v3;
  return result;
}

void std::__function::__func<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0,std::allocator<HTTPConnectionAuthenticator::canReuseCredentials(void)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

uint64_t ___ZN14HTTPConnection21_onqueue_requestStartEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1149;
  *(void *)(a1 + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN14HTTPConnection37_onqueue_negotiateAuthenticationStartEv_block_invoke(void *a1, uint64_t a2, NSObject *a3, unsigned int a4, CFStreamError a5)
{
  uint64_t v5 = *(void *)&a5.error;
  CFIndex domain = a5.domain;
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    uint64_t v9 = a1[5];
    int v10 = *(unsigned __int16 *)(v9 + 32);
    v9 += 32;
    int v11 = *(unsigned __int8 *)(v9 + 2);
    *(_WORD *)uint64_t v9 = v10 & 0xFBFF;
    *(unsigned char *)(v9 + 2) = (v10 & 0xFFFFFBFF | (v11 << 16)) >> 16;
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 0;
  }
  uint64_t v12 = (HTTPConnection *)a1[6];
  uint64_t v14 = *(HTTPMessage **)a2;
  int v13 = *(atomic_ullong **)(a2 + 8);
  if (v13) {
    atomic_fetch_add_explicit(v13 + 1, 1uLL, memory_order_relaxed);
  }
  if (a5.error != -1002 && a5.error)
  {
    HTTPConnection::_onqueue_errorOccurred(v12, a5, 0);
  }
  else if (a3 || v14 || a4)
  {
    if (v14)
    {
      HTTPConnection::_onqueue_requestFinish(v12, a5);
      v15[0] = v14;
      v15[1] = (HTTPMessage *)v13;
      if (v13) {
        atomic_fetch_add_explicit(v13 + 1, 1uLL, memory_order_relaxed);
      }
      HTTPConnection::_onqueue_responseHeadersArrived((uint64_t)v12, v15, domain, v5);
      if (v13) {
        std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v13);
      }
    }
    if (a3 || a4) {
      HTTPConnection::_onqueue_responseDataArrived((uint64_t)v12, a3, domain, v5, a4);
    }
  }
  else
  {
    HTTPConnection::_onqueue_attemptNextRequest(v12);
  }
  if (v13)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v13);
  }
}

void sub_1842874D8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::SmartBlockWithArgs()
{
}

void sub_1842875CC(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

uint64_t HTTPConnectionAuthenticator::getConnectionIdentifier(HTTPConnectionAuthenticator *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 20);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 19);
  std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  return v4;
}

void HTTPConnectionAuthenticator::errorOccurred(HTTPConnectionAuthenticator *this, CFStreamError a2)
{
  uint64_t v2 = *((void *)this + 29);
  if (v2)
  {
    uint64_t v3 = *(void (**)(void *, long long *, void, void, CFIndex, void))(v2 + 8);
    uint64_t v4 = *(void *)(v2 + 16);
    uint64_t v5 = (void *)(v2 + (v4 >> 1));
    if (v4) {
      uint64_t v3 = *(void (**)(void *, long long *, void, void, CFIndex, void))(*v5 + v3);
    }
    long long v6 = 0uLL;
    v3(v5, &v6, 0, 0, a2.domain, *(void *)&a2.error);
    if (*((void *)&v6 + 1)) {
      std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v6 + 1));
    }
  }
  SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::SmartBlockWithArgs();
}

void sub_1842876DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN27HTTPConnectionAuthenticator12writeRequestEv_block_invoke(uint64_t a1, CFStreamError a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2.error)
  {
    uint64_t v3 = *(HTTPConnectionAuthenticator **)(a1 + 32);
    HTTPConnectionAuthenticator::errorOccurred(v3, a2);
  }
  v14[0] = 0;
  v14[1] = v14;
  void v14[2] = 0x2020000000;
  char v15 = 0;
  uint64_t v4 = *(void *)(v2 + 168);
  uint64_t v5 = *(void *)(v2 + 200);
  long long v6 = *(std::__shared_weak_count **)(v2 + 208);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  v13[2] = ___ZN27HTTPConnectionAuthenticator12readResponseEv_block_invoke;
  v13[3] = &__block_descriptor_40_e93_v40__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8___qi_24l;
  v13[4] = v2;
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  void v12[2] = ___ZN27HTTPConnectionAuthenticator12readResponseEv_block_invoke_2;
  void v12[3] = &unk_1E5256620;
  v12[4] = v14;
  void v12[5] = v2;
  HTTPEngine::readResponse(v4, v5, (uint64_t)v6, 0, v13, v12, &__block_literal_global_55_13986);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v2 + 160);
  if (v7)
  {
    uint64_t v8 = std::__shared_weak_count::lock(v7);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v2 + 152);
      if (v10)
      {
        uint64_t v11 = *(void *)(v10 + 160);
        if (v11)
        {
          if (!HTTPTransaction::requestExpectsResponseBody(*(HTTPTransaction **)(v11 + 160))) {
            HTTPEngine::setProperty(*(HTTPEngine **)(v2 + 168), (CFStringRef)&unk_1EC0A3768, (const void *)*MEMORY[0x1E4F1CFD0]);
          }
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
    }
  }
  if (*(unsigned char *)(v2 + 250)) {
    *(_DWORD *)(*(void *)(v2 + 168) + 32) |= 0x400u;
  }
  _Block_object_dispose(v14, 8);
}

void sub_1842878A0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Block_object_dispose((const void *)(v2 - 48), 8);
  _Unwind_Resume(a1);
}

void ___ZN27HTTPConnectionAuthenticator12readResponseEv_block_invoke(uint64_t a1, uint64_t a2, CFStreamError a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a3.error)
  {
    uint64_t v4 = *(HTTPConnectionAuthenticator **)(a1 + 32);
    HTTPConnectionAuthenticator::errorOccurred(v4, a3);
  }
  uint64_t v7 = *(HTTPResponseMessage **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(v3 + 224);
  *(void *)(v3 + 2CFRelease((char *)this - 16) = v7;
  *(void *)(v3 + 224) = v6;
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    uint64_t v7 = *(HTTPResponseMessage **)(v3 + 216);
  }
  int v9 = *((_DWORD *)v7 + 32);
  if (!*(unsigned char *)(v3 + 249) && v9 == 407)
  {
    *(unsigned char *)(v3 + 249) = 1;
LABEL_14:
    ConnectionCFStringRef Identifier = (void *)HTTPConnectionAuthenticator::getConnectionIdentifier((HTTPConnectionAuthenticator *)v3);
    AuthenticationState::updateWithResponse(v3, v7, ConnectionIdentifier);
    if (*(unsigned char *)(v3 + 249)) {
      int v11 = 2;
    }
    else {
      int v11 = 1;
    }
    if (AuthenticationState::isValid(v3, v11))
    {
      uint64_t v12 = *(HTTPRequestMessage **)(v3 + 184);
      int v13 = (void *)HTTPConnectionAuthenticator::getConnectionIdentifier((HTTPConnectionAuthenticator *)v3);
      AuthenticationState::applyToRequest((AuthenticationState *)v3, v12, v13, 1);
      return;
    }
    uint64_t Auth = AuthenticationState::getAuth((AuthenticationState *)v3, *(unsigned __int8 *)(v3 + 249));
    if (Auth)
    {
      CFIndex v15 = *(void *)(Auth + 88);
      uint64_t v16 = *(void *)(Auth + 96);
      if (v16) {
        goto LABEL_30;
      }
    }
    else
    {
      CFIndex v15 = 0;
      uint64_t v16 = 0;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v22) = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Auth is not valid but we don't have an error", (uint8_t *)&v22, 2u);
    }
LABEL_30:
    v25.CFIndex domain = v15;
    *(void *)&v25.uint64_t error = v16;
    HTTPConnectionAuthenticator::errorOccurred((HTTPConnectionAuthenticator *)v3, v25);
  }
  if (v9 == 407 || v9 == 401) {
    goto LABEL_14;
  }
  *(unsigned char *)(v3 + 248) = 1;
  CFStreamError v17 = *(std::__shared_weak_count **)(v3 + 224);
  if (v17)
  {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v18 = *(void *)(v3 + 232);
    if (!v18)
    {
LABEL_41:
      std::__shared_weak_count::__release_shared[abi:nn180100](v17);
      return;
    }
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v18 = *(void *)(v3 + 232);
    if (!v18) {
      return;
    }
  }
  long long v19 = *(void (**)(void *, HTTPResponseMessage **, void, void, void, void))(v18 + 8);
  uint64_t v20 = *(void *)(v18 + 16);
  uint64_t v21 = (void *)(v18 + (v20 >> 1));
  if (v20) {
    long long v19 = *(void (**)(void *, HTTPResponseMessage **, void, void, void, void))(*v21
  }
                                                                                                  + v19);
  long long v22 = v7;
  long long v23 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v19(v21, &v22, 0, 0, 0, 0);
  if (v23) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v23);
  }
  if (v17)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
    goto LABEL_41;
  }
}

void sub_184287B1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN27HTTPConnectionAuthenticator12readResponseEv_block_invoke_2(uint64_t a1, uint64_t a2, CFStreamError a3, char a4)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (a3.error) {
    HTTPConnectionAuthenticator::errorOccurred(*(HTTPConnectionAuthenticator **)(a1 + 40), a3);
  }
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    HTTPEngine::resetResponse(*(HTTPEngine **)(v4 + 168));
  }
  if (a4)
  {
    uint64_t v5 = *(void *)(v4 + 232);
    if (*(unsigned char *)(v4 + 248))
    {
      if (!v5) {
        return;
      }
      uint64_t v6 = *(void (**)(void *, uint64_t *, uint64_t, uint64_t, void, void))(v5 + 8);
      uint64_t v7 = *(void *)(v5 + 16);
      uint64_t v8 = (void *)(v5 + (v7 >> 1));
      if (v7) {
        uint64_t v6 = *(void (**)(void *, uint64_t *, uint64_t, uint64_t, void, void))(*v8 + v6);
      }
      uint64_t v16 = 0;
      CFStreamError v17 = 0;
      v6(v8, &v16, a2, 1, 0, 0);
    }
    else
    {
      if (!v5) {
        return;
      }
      int v13 = *(void (**)(void *, uint64_t *, void, void, void, void))(v5 + 8);
      uint64_t v14 = *(void *)(v5 + 16);
      CFIndex v15 = (void *)(v5 + (v14 >> 1));
      if (v14) {
        int v13 = *(void (**)(void *, uint64_t *, void, void, void, void))(*v15 + v13);
      }
      uint64_t v16 = 0;
      CFStreamError v17 = 0;
      v13(v15, &v16, 0, 0, 0, 0);
    }
    goto LABEL_23;
  }
  if (*(unsigned char *)(v4 + 248))
  {
    uint64_t v9 = *(void *)(v4 + 232);
    if (v9)
    {
      uint64_t v10 = *(void (**)(void *, uint64_t *, uint64_t, void, void, void))(v9 + 8);
      uint64_t v11 = *(void *)(v9 + 16);
      uint64_t v12 = (void *)(v9 + (v11 >> 1));
      if (v11) {
        uint64_t v10 = *(void (**)(void *, uint64_t *, uint64_t, void, void, void))(*v12 + v10);
      }
      uint64_t v16 = 0;
      CFStreamError v17 = 0;
      v10(v12, &v16, a2, 0, 0, 0);
LABEL_23:
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v17);
      }
    }
  }
}

void sub_184287CAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v3 = *(void (**)(uint64_t *, uint64_t *))(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | (unint64_t)v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if (v3 == BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_initial
    && v5 != 0)
  {
    uint64_t v7 = (void *)(v1 + (v2 >> 1));
    if (v2) {
      uint64_t v8 = *(void (**)(uint64_t *, uint64_t *))(*v7
    }
                                                       + BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_initial);
    else {
      uint64_t v8 = BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_initial;
    }
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    ((void (*)(void *, uint64_t *, void, void, void, void))v8)(v7, &v10, 0, 0, 0, 0);
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
  }
  _Block_release(*(const void **)v1);
  return MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
}

void sub_184287DBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_initial(uint64_t *a1, uint64_t *a2)
{
  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_normal;
  a1[2] = 0;
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  int v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184287E80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void BlockHolderVar<std::shared_ptr<HTTPResponseMessage>,NSObject  {objcproto16OS_dispatch_data}*,BOOL,CFStreamError>::invoke_normal(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  int v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184287EF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN14HTTPConnection38_onqueue_cleanAbortRequestTransmissionEv_block_invoke(uint64_t a1)
{
  return HTTPConnection::_onqueue_attemptNextRequest(*(HTTPConnection **)(a1 + 32));
}

uint64_t HTTPConnection::getShouldPipeline(HTTPConnection *this)
{
  v4[0] = 0;
  v4[1] = v4;
  void v4[2] = 0x2020000000;
  unsigned int v1 = *((unsigned __int8 *)this + 34);
  uint64_t v2 = (v1 >> 1) & 1;
  BOOL v5 = (v1 & 2) != 0;
  _Block_object_dispose(v4, 8);
  return v2;
}

uint64_t ___ZN14HTTPConnection17getShouldPipelineEv_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = (*(unsigned char *)(*(void *)(result + 40) + 34) & 2) != 0;
  return result;
}

BOOL std::__function::__func<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0,std::allocator<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(HTTPAuthentication **)(*(void *)a3 + 8);
  if (v4 && HTTPAuthentication::isConnectionBasedAuth(v4) && *(_DWORD *)(*(void *)a3 + 24) != 2) {
    **(unsigned char **)(a1 + CFRelease((char *)this - 16) = 1;
  }
  return **(unsigned char **)(a1 + 16) == 0;
}

__n128 std::__function::__func<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0,std::allocator<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1ECFA64E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0,std::allocator<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1ECFA64E0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0,std::allocator<HTTPConnectionAuthenticator::requiresConnectionNegotiation(AuthenticationState *)::$_0>,BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__func()
{
}

id AppSSO::AppSSOLog(AppSSO *this)
{
  if (AppSSO::AppSSOLog(void)::onceToken != -1) {
    dispatch_once(&AppSSO::AppSSOLog(void)::onceToken, &__block_literal_global_14007);
  }
  unsigned int v1 = (void *)AppSSO::AppSSOLog(void)::ssoLog;

  return v1;
}

void ___ZN6AppSSO9AppSSOLogEv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.CFNetwork", "AppSSO");
  unsigned int v1 = (void *)AppSSO::AppSSOLog(void)::ssoLog;
  AppSSO::AppSSOLog(void)::ssoLog = (uint64_t)v0;
}

uint64_t AppSSO::isPerformDefaultHandlingError(AppSSO *this, __CFError *a2)
{
  uint64_t v2 = this;
  if ([(AppSSO *)v2 code] == -5)
  {
    uint64_t v3 = [(AppSSO *)v2 domain];
    double Helper_x8__SOErrorDomain = gotLoadHelper_x8__SOErrorDomain(v4);
    uint64_t v8 = objc_msgSend(v7, "isEqualToString:", **(void **)(v6 + 2112), Helper_x8__SOErrorDomain);
  }
  else
  {
    uint64_t v8 = 0;
  }

  return v8;
}

void sub_1842881F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN6AppSSO11getResponseENSt3__110shared_ptrIK10__CFStringEEPK7__CFURLPK14__CFDictionaryPK8__CFDataSD_18SmartBlockWithArgsIJU8__strongP13NSURLResponseSD_P9__CFErrorEE_block_invoke_5(AppSSO *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = AppSSO::AppSSOLog(a1);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *((void *)a1 + 4);
    int v17 = 138544130;
    uint64_t v18 = v9;
    __int16 v19 = 2112;
    uint64_t v20 = a2;
    __int16 v21 = 2112;
    uint64_t v22 = a3;
    __int16 v23 = 2112;
    uint64_t v24 = a4;
    _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "getResponse %{public}@ response=%@ body=%@ error=%@", (uint8_t *)&v17, 0x2Au);
  }

  id v10 = a2;
  uint64_t v11 = v10;
  uint64_t v12 = *((void *)a1 + 6);
  if (v12)
  {
    id v13 = v10;
    uint64_t v14 = *(void (**)(void *, id, uint64_t, uint64_t))(v12 + 8);
    uint64_t v15 = *(void *)(v12 + 16);
    uint64_t v16 = (void *)(v12 + (v15 >> 1));
    if (v15) {
      uint64_t v14 = *(void (**)(void *, id, uint64_t, uint64_t))(*v16 + v14);
    }
    v14(v16, v13, a3, a4);
  }
}

void sub_184288340(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrIK10__CFStringEE48c76_ZTS18SmartBlockWithArgsIJU8__strongP13NSURLResponsePK8__CFDataP9__CFErrorEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrIK10__CFStringEE48c76_ZTS18SmartBlockWithArgsIJU8__strongP13NSURLResponsePK8__CFDataP9__CFErrorEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void AppSSO::getAuthHeaders(AppSSO *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (AppSSO::ssoOptionFlag(void)::onceToken != -1) {
    dispatch_once(&AppSSO::ssoOptionFlag(void)::onceToken, &__block_literal_global_13_14020);
  }
  if (AppSSO::ssoOptionFlag(void)::flag) {
    uint64_t v14 = 2;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = AppSSO::AppSSOLog(a1);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = *(void *)a1;
    *(_DWORD *)long long buf = 138545154;
    uint64_t v22 = v16;
    __int16 v23 = 2048;
    uint64_t v24 = v14;
    __int16 v25 = 2112;
    uint64_t v26 = a2;
    __int16 v27 = 2112;
    uint64_t v28 = a3;
    __int16 v29 = 2048;
    uint64_t v30 = 401;
    __int16 v31 = 2048;
    uint64_t v32 = a4;
    __int16 v33 = 2112;
    uint64_t v34 = a5;
    __int16 v35 = 2112;
    uint64_t v36 = a6;
    _os_log_impl(&dword_184085000, v15, OS_LOG_TYPE_DEFAULT, "getAuthHeaders %{public}@ flag %lu url %@ headers %@ code %ld failureCount %ld token %@ bundle %@", buf, 0x52u);
  }

  int v17 = (std::__shared_weak_count *)*((void *)a1 + 1);
  __int16 v19 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = *(std::__shared_weak_count **)(a7 + 8);
  uint64_t v20 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  appSSO_handleResponseImpersonationCredential_delayInitStub(COERCE_DOUBLE(3321888768));
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  }
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v19);
  }
}

void sub_1842885F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN6AppSSO14getAuthHeadersENSt3__110shared_ptrIK10__CFStringEEPK7__CFURLPK14__CFDictionaryllPK8__CFDataPS3_18SmartBlockWithArgsIJSA_P9__CFErrorEE_block_invoke_9(AppSSO *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = AppSSO::AppSSOLog(a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)a1 + 4);
    int v12 = 138543874;
    uint64_t v13 = v7;
    __int16 v14 = 2112;
    uint64_t v15 = a2;
    __int16 v16 = 2112;
    uint64_t v17 = a3;
    _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "getAuthHeaders %{public}@ headers=%@ error=%@", (uint8_t *)&v12, 0x20u);
  }

  uint64_t v8 = *((void *)a1 + 6);
  if (v8)
  {
    uint64_t v9 = *(void (**)(void *, uint64_t, uint64_t))(v8 + 8);
    uint64_t v10 = *(void *)(v8 + 16);
    uint64_t v11 = (void *)(v8 + (v10 >> 1));
    if (v10) {
      uint64_t v9 = *(void (**)(void *, uint64_t, uint64_t))(*v11 + v9);
    }
    v9(v11, a2, a3);
  }
}

void __destroy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrIK10__CFStringEE48c57_ZTS18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrIK10__CFStringEE48c57_ZTS18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void TLSCallbackClientCertificate::~TLSCallbackClientCertificate(TLSCallbackClientCertificate *this)
{
  TLSCallbackClientCertificate::~TLSCallbackClientCertificate(this);

  JUMPOUT(0x18531B6D0);
}

{
  const void *v2;
  const void *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;

  *(void *)this = &unk_1ECFA4838;
  uint64_t v2 = (const void *)*((void *)this + 7);
  if (v2)
  {
    _Block_release(v2);
    *((void *)this + 7) = 0;
  }
  uint64_t v3 = (const void *)*((void *)this + 8);
  if (v3)
  {
    _Block_release(v3);
    *((void *)this + 8) = 0;
  }
  double v4 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  BOOL v5 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  *(void *)this = &unk_1ECF9B550;
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_1842888C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (std::__shared_weak_count *)v1[12];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  double v4 = (std::__shared_weak_count *)v1[10];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  BOOL v5 = (std::__shared_weak_count *)v1[6];
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)v1[4];
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  *unsigned int v1 = &unk_1ECF9B550;
  uint64_t v7 = (std::__shared_weak_count *)v1[2];
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  _Unwind_Resume(exception_object);
}

void TLSCallbackClientCertificate::invokeCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  double v4 = *(std::__shared_weak_count **)(a1 + 32);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3321888768;
  void v6[2] = ___ZN28TLSCallbackClientCertificate14invokeCallbackEU13block_pointerFvbE_block_invoke;
  void v6[3] = &unk_1ECFA8DD8;
  void v6[5] = v3;
  uint64_t v7 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  _OWORD v6[4] = a2;
  (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);
  _Block_release(*(const void **)(a1 + 56));
  *(void *)(a1 + 56) = 0;
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_184288A38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN28TLSCallbackClientCertificate14invokeCallbackEU13block_pointerFvbE_block_invoke(void *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = (std::__shared_weak_count *)a1[6];
  if (v8)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v8);
    if (v11)
    {
      uint64_t v12 = a1[5];
      if (v12)
      {
        uint64_t v14 = *a2;
        uint64_t v13 = a2[1];
        if (v13) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v15 = *(std::__shared_weak_count **)(v12 + 80);
        *(void *)(v12 + 72) = v14;
        *(void *)(v12 + 8MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v13;
        if (v15) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v15);
        }
        uint64_t v17 = *a3;
        uint64_t v16 = a3[1];
        if (v16) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v18 = *(std::__shared_weak_count **)(v12 + 96);
        *(void *)(v12 + 88) = v17;
        *(void *)(v12 + 96) = v16;
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v18);
        }
        uint64_t v19 = *(void *)(v12 + 64);
        uint64_t v20 = (std::__shared_weak_count *)a2[1];
        uint64_t v21 = *a2;
        uint64_t v22 = v20;
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(v19 + 16))(v19, &v21, a4, a5);
        if (v22) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v22);
        }
        _Block_release(*(const void **)(v12 + 64));
        *(void *)(v12 + 64) = 0;
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  (*(void (**)(void))(a1[4] + 16))(a1[4]);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
}

void sub_184288B94(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_40c53_ZTSNSt3__18weak_ptrI28TLSCallbackClientCertificateEE(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_e8_40c53_ZTSNSt3__18weak_ptrI28TLSCallbackClientCertificateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  return a1;
}

void ___ZN16TLSCallbackQueue20_doClientCertificateENSt3__110shared_ptrI28TLSCallbackClientCertificateEE_block_invoke(void *a1, int a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        if (a2)
        {
          *(unsigned char *)(v7 + 41) = 0;
          std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*(void *)(v7 + 48));
        }
        else
        {
          uint64_t v8 = *(uint64_t **)(v7 + 64);
          uint64_t v9 = operator new(0x20uLL);
          uint64_t v10 = a1[7];
          v9[2] = a1[6];
          void v9[3] = v10;
          if (v10) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v11 = *v8;
          *uint64_t v9 = *v8;
          v9[1] = v8;
          *(void *)(v11 + 8) = v9;
          *uint64_t v8 = (uint64_t)v9;
          ++v8[2];
          *(unsigned char *)(v7 + 41) = 0;
          std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*(void *)(v7 + 48));
          TLSCallbackQueue::_invokeNextCallback((TLSCallbackQueue *)v7);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }
}

void sub_184288D04(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c41_ZTSNSt3__18weak_ptrI16TLSCallbackQueueEE48c56_ZTSNSt3__110shared_ptrI28TLSCallbackClientCertificateEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *__copy_helper_block_e8_32c41_ZTSNSt3__18weak_ptrI16TLSCallbackQueueEE48c56_ZTSNSt3__110shared_ptrI28TLSCallbackClientCertificateEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void TLSCallbackQueue::copyCachedPeerCertificates(void *a1, uint64_t a2, sec_protocol_metadata_t metadataB)
{
  uint64_t v6 = *(void **)(*(void *)(a2 + 56) + 8);
  while (v6 != *(void **)(a2 + 56))
  {
    uint64_t v8 = (void *)v6[2];
    uint64_t v7 = (std::__shared_weak_count *)v6[3];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v8[5];
    if (v9 && sec_protocol_metadata_peers_are_equal(v9, metadataB))
    {
      uint64_t v10 = v8[13];
      *a1 = v8[12];
      a1[1] = v10;
      if (v10)
      {
        char v11 = 1;
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
        if (!v7) {
          goto LABEL_12;
        }
      }
      else
      {
        char v11 = 1;
        if (!v7) {
          goto LABEL_12;
        }
      }
LABEL_11:
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
      goto LABEL_12;
    }
    char v11 = 0;
    uint64_t v6 = (void *)v6[1];
    if (v7) {
      goto LABEL_11;
    }
LABEL_12:
    if (v11) {
      return;
    }
  }
  *a1 = 0;
  a1[1] = 0;
}

void sub_184288E64(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'CFNACOAuthSigner::~CFNACOAuthSigner(CFNACOAuthSigner *this)
{
}

{
  CFNACOAuthSigner::~CFNACOAuthSigner((CFNACOAuthSigner *)((char *)this - 8));
}

void CFNACOAuthSigner::~CFNACOAuthSigner(CFNACOAuthSigner *this)
{
  *(void *)this = &unk_1ECF9DB50;
  *((void *)this + 1) = &unk_1ECF9DBA0;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 1) = &unk_1ECF9B550;
}

void sub_184288F0C(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t CFNACOAuthSigner::initialize(uint64_t a1, void *a2, double a3)
{
  gotLoadHelper_x21__OBJC_CLASS___ACOAuthSigner(a3);
  uint64_t result = objc_opt_class();
  if (result)
  {
    id v7 = objc_alloc(*(Class *)(v3 + 2552));
    uint64_t v8 = v7;
    if (a2)
    {
      if (TCFObject<CFNAccount>::Class(void)::sOnce != -1) {
        dispatch_once(&TCFObject<CFNAccount>::Class(void)::sOnce, &__block_literal_global_14082);
      }
      *(void *)(a1 + CFRelease((char *)this - 16) = [v8 initWithAccount:a2[4]];
      *(void *)(a1 + 24) = CFRetain(a2);
      return 1;
    }
    else
    {
      uint64_t v9 = [v7 initWithAccount:MEMORY[0x10]];
      uint64_t result = 0;
      *(void *)(a1 + CFRelease((char *)this - 16) = v9;
    }
  }
  return result;
}

void ___ZN9TCFObjectI10CFNAccountE5ClassEv_block_invoke()
{
}

void sub_18428904C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

CFStringRef CFNACOAuthSigner::copyDebugDesc(CFNACOAuthSigner *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFNACOAuthSigner@%p>", this);
}

void ___ZN9TCFObjectI15CFNNSURLRequestE5ClassEv_block_invoke_14095()
{
}

void sub_18428911C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t CompactCookieHeader::getEnumeratedTime(uint64_t a1, int a2)
{
  if (a2 == 2)
  {
    if (*(_DWORD *)a1 >= 0x38u)
    {
      uint64_t v2 = *(void *)(a1 + 48);
      goto LABEL_11;
    }
  }
  else
  {
    if (a2 == 19)
    {
      unsigned __int8 v7 = 0;
      CFDictionaryRef v4 = (const __CFDictionary *)CompactCookieHeader::copyExtraInfo((CompactCookieHeader *)a1, &v7);
      if (v4)
      {
        CFDictionaryRef v5 = v4;
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v4, &gConstantCFStringValueTable[1729]);
        if (Value)
        {
          uint64_t valuePtr = 0;
          CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
        }
        CFRelease(v5);
      }
      return 1;
    }
    if (a2 != 5 || *(_DWORD *)a1 >= 0xCu && (*(_DWORD *)(a1 + 8) & 2) != 0) {
      return 0;
    }
    if (*(_DWORD *)a1 >= 0x30u)
    {
      uint64_t v2 = *(void *)(a1 + 40);
LABEL_11:
      uint64_t valuePtr = v2;
    }
  }
  return 1;
}

uint64_t CompactCookieHeader::getEnumeratedBoolean(_DWORD *a1, int a2)
{
  uint64_t result = 0;
  if (a2 <= 11)
  {
    if (a2 != 3)
    {
      if (a2 == 6)
      {
        if (*a1 >= 0xCu) {
          return (a1[2] >> 2) & 1;
        }
        return 0;
      }
      return result;
    }
    if (*a1 >= 0xCu) {
      return (a1[2] >> 1) & 1;
    }
    return 0;
  }
  switch(a2)
  {
    case 18:
      if (*a1 >= 0xCu) {
        return (a1[2] >> 6) & 1;
      }
      return 0;
    case 17:
      if (*a1 >= 0xCu) {
        return (a1[2] >> 5) & 1;
      }
      return 0;
    case 12:
      if (*a1 >= 0xCu) {
        return a1[2] & 1;
      }
      return 0;
  }
  return result;
}

void sub_184289524(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842896A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184289830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
  _Unwind_Resume(a1);
}

id destinationURLFragment(void *a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  CFDictionaryRef v4 = NSString;
  CFDictionaryRef v5 = [a1 URL];
  id v6 = [v4 stringWithFormat:@"%@%@", v3, v5];
  unsigned __int8 v7 = (const void *)[v6 UTF8String];
  id v8 = v6;
  CC_LONG v9 = strlen((const char *)[v8 UTF8String]);
  CC_SHA1(v7, v9, md);
  uint64_t v10 = [MEMORY[0x1E4F28E78] stringWithCapacity:40];
  for (uint64_t i = 0; i != 8; ++i)
    objc_msgSend(v10, "appendFormat:", @"%02X", md[i]);

  return v10;
}

void sub_1842899AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CFNetworkWriteStream::_writeStreamClientCallBack(CFNetworkWriteStream *this, __CFWriteStream *a2)
{
}

uint64_t CFNetworkWriteStream::_streamImpl_SetProperty(CFNetworkWriteStream *this, __CFWriteStream *a2, const __CFString *a3, const void *a4)
{
  return 0;
}

uint64_t CFNetworkWriteStream::_streamImpl_CopyProperty(CFNetworkWriteStream *this, __CFWriteStream *a2, const __CFString *a3)
{
  return 0;
}

uint64_t CFNetworkWriteStream::_streamImpl_CanWrite(CFNetworkWriteStream *this, __CFWriteStream *a2)
{
  return 0;
}

uint64_t CFNetworkWriteStream::_streamImpl_Write(CFNetworkWriteStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5)
{
  return -1;
}

uint64_t CFNetworkWriteStream::_streamImpl_OpenCompleted(CFNetworkWriteStream *this, __CFWriteStream *a2, CFStreamError *a3)
{
  return 0;
}

uint64_t CFNetworkWriteStream::_streamImpl_Open(CFNetworkWriteStream *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a4 = 0;
  return 0;
}

CFStringRef CFNetworkWriteStream::copyDescription(CFNetworkWriteStream *this, CFTypeRef cf)
{
  CFAllocatorRef v3 = CFGetAllocator(cf);
  return CFStringCreateWithFormat(v3, 0, @"<CFNetworkWriteStream@%p>", this);
}

void CFNetworkWriteStream::~CFNetworkWriteStream(CFNetworkWriteStream *this)
{
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + 1) = 0;
  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + 1) = 0;
}

uint64_t CFNetworkWriteStream::httpStreamUnschedule(CFNetworkWriteStream *this, __CFWriteStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkWriteStream *, __CFWriteStream *, __CFRunLoop *))a4->isa
          + 11))(a4, this, a2, a3);
}

uint64_t CFNetworkWriteStream::httpStreamSchedule(CFNetworkWriteStream *this, __CFWriteStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkWriteStream *, __CFWriteStream *, __CFRunLoop *))a4->isa
          + 10))(a4, this, a2, a3);
}

uint64_t CFNetworkWriteStream::httpStreamSetProperty(CFNetworkWriteStream *this, __CFWriteStream *a2, const __CFString *a3, const void *a4, void *a5)
{
  return (*(uint64_t (**)(const void *, CFNetworkWriteStream *, __CFWriteStream *, const __CFString *))(*(void *)a4 + 72))(a4, this, a2, a3);
}

uint64_t CFNetworkWriteStream::httpStreamCopyProperty(CFNetworkWriteStream *this, __CFWriteStream *a2, const __CFString *a3, void *a4)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkWriteStream *, __CFWriteStream *))a3->isa + 8))(a3, this, a2);
}

uint64_t CFNetworkWriteStream::httpStreamClose(CFNetworkWriteStream *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFWriteStream *, CFNetworkWriteStream *))(*(void *)a2 + 56))(a2, this);
}

uint64_t CFNetworkWriteStream::httpStreamCanWrite(CFNetworkWriteStream *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFWriteStream *, CFNetworkWriteStream *))(*(void *)a2 + 48))(a2, this);
}

uint64_t CFNetworkWriteStream::httpStreamWrite(CFNetworkWriteStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, void *a6)
{
  return (*(uint64_t (**)(CFStreamError *, CFNetworkWriteStream *, __CFWriteStream *, const unsigned __int8 *, uint64_t))(a5->domain + 40))(a5, this, a2, a3, a4);
}

uint64_t CFNetworkWriteStream::httpStreamOpenCompleted(CFNetworkWriteStream *this, __CFWriteStream *a2, CFStreamError *a3, void *a4)
{
  return (*(uint64_t (**)(CFStreamError *, CFNetworkWriteStream *, __CFWriteStream *))(a3->domain + 32))(a3, this, a2);
}

uint64_t CFNetworkWriteStream::httpStreamOpen(CFNetworkWriteStream *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(unsigned __int8 *, CFNetworkWriteStream *, __CFWriteStream *, CFStreamError *))(*(void *)a4 + 24))(a4, this, a2, a3);
}

uint64_t CFNetworkWriteStream::httpStreamCopyDescription(CFNetworkWriteStream *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFWriteStream *, CFNetworkWriteStream *))(*(void *)a2 + 16))(a2, this);
}

void CFNetworkWriteStream::httpStreamFinalize(CFNetworkWriteStream *this, __CFWriteStream *a2, void *a3)
{
  if (this) {
    CFAllocatorRef v4 = CFGetAllocator(this);
  }
  else {
    CFAllocatorRef v4 = 0;
  }
  (**(void (***)(__CFWriteStream *))a2)(a2);

  CFAllocatorDeallocate(v4, a2);
}

uint64_t CFNetworkWriteStream::_createStream(CFNetworkWriteStream *this, uint64_t (**a2)(__CFWriteStream *, CFNetworkWriteStream *), void *a3)
{
  return a2[2]((__CFWriteStream *)a2, this);
}

void __Block_byref_object_copy__14730(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__14731(uint64_t a1)
{
}

void ConnectionReadAggregator::_timerStart(ConnectionReadAggregator *this)
{
  if (*((_DWORD *)this + 18)) {
    __assert_rtn("_timerStart", "ConnectionReadAggregator.mm", 303, "_timerState == TimerState::NotSet");
  }
  if (*((double *)this + 11) <= 0.0) {
    __assert_rtn("_timerStart", "ConnectionReadAggregator.mm", 304, "_timeout > 0.0");
  }
  if (!*((void *)this + 8))
  {
    dispatch_source_t v2 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *((dispatch_queue_t *)this + 5));
    CFAllocatorRef v3 = *((void *)this + 8);
    *((void *)this + 8) = v2;
    if (v3) {
      dispatch_release(v3);
    }
    uint64_t v4 = *((void *)this + 3);
    CFDictionaryRef v5 = (std::__shared_weak_count *)*((void *)this + 4);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    id v6 = *((void *)this + 8);
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3321888768;
    v9[2] = ___ZN24ConnectionReadAggregator11_timerStartEv_block_invoke;
    void v9[3] = &__block_descriptor_48_e8_32c49_ZTSNSt3__18weak_ptrI24ConnectionReadAggregatorEE_e5_v8__0l;
    void v9[4] = v4;
    uint64_t v10 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    dispatch_source_set_event_handler(v6, v9);
    dispatch_source_set_timer(*((dispatch_source_t *)this + 8), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_resume(*((dispatch_object_t *)this + 8));
    if (v10) {
      std::__shared_weak_count::__release_weak(v10);
    }
    if (v5) {
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  unsigned __int8 v7 = *((void *)this + 8);
  dispatch_time_t v8 = dispatch_time(0, (uint64_t)(*((double *)this + 11) * 1000000000.0));
  dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0);
  *((_DWORD *)this + 18) = 1;
}

void ___ZN24ConnectionReadAggregator11_timerStartEv_block_invoke(uint64_t a1)
{
  dispatch_source_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    CFAllocatorRef v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      CFDictionaryRef v5 = *(ConnectionReadAggregator **)(a1 + 32);
      if (v5 && *((_DWORD *)v5 + 18) == 1)
      {
        *((void *)v5 + 9) = 0x100000002;
        ConnectionReadAggregator::_evaluate(v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_18428B634(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c49_ZTSNSt3__18weak_ptrI24ConnectionReadAggregatorEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_e8_32c49_ZTSNSt3__18weak_ptrI24ConnectionReadAggregatorEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 4MemoryCookies::newCookieArrayEnumerator(*((void *)this + 9), 0) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}