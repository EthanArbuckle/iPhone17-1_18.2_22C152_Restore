void sub_18413DFC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const void *TubeManager::_onqueue_getValidAwaitingTubeForKey(CFArrayRef *this, const HTTPConnectionCacheKey *a2)
{
  CFIndex Count = CFArrayGetCount(this[17]);
  if (Count < 1) {
    return 0;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(this[17], v6);
    uint64_t v8 = (*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 72))(ValueAtIndex);
    if ((*(unsigned int (**)(uint64_t, const HTTPConnectionCacheKey *))(*(void *)v8 + 24))(v8, a2))
    {
      if ((*(unsigned int (**)(const void *))(*(void *)ValueAtIndex + 112))(ValueAtIndex)
        && !(*(unsigned int (**)(const void *))(*(void *)ValueAtIndex + 128))(ValueAtIndex))
      {
        break;
      }
    }
    if (v5 == ++v6) {
      return 0;
    }
  }
  return ValueAtIndex;
}

void ___ZN14HTTPConnection10isCellularEv_block_invoke(uint64_t a1)
{
  v2 = *(HTTPEngine **)(*(void *)(a1 + 40) + 64);
  if (v2)
  {
    CFTypeRef v3 = HTTPEngine::copyProperty(v2, @"kCFStreamPropertyConnectionIsCellular");
    if (v3)
    {
      v4 = v3;
      CFTypeID v5 = CFGetTypeID(v3);
      if (v5 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)CFIndex v6 = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v6, 2u);
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *MEMORY[0x1E4F1CFD0] == (void)v4;
      CFRelease(v4);
    }
    else
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
  }
}

void HTTPConnectionCacheEntry::setHasBeenForgotten(HTTPConnectionCacheEntry *this, unsigned int a2)
{
  *((unsigned char *)this + 32) |= 4u;
  if ((HTTPConnectionCacheEntry::hasRequestsEnqueued(this) & 1) == 0)
  {
    HTTPConnectionCacheEntry::_removeAllConnections(this, a2);
    CFArrayRef v4 = (const __CFArray *)*((void *)this + 10);
    v7.length = CFArrayGetCount(v4);
    v7.location = 0;
    CFArrayApplyFunction(v4, v7, (CFArrayApplierFunction)RetainableTypedArray<Tube *>::_invoke, &__block_literal_global_9020);
    CFTypeID v5 = (__CFArray *)*((void *)this + 10);
    CFArrayRemoveAllValues(v5);
  }
}

uint64_t HTTPConnectionCacheEntry::hasRequestsEnqueued(HTTPConnectionCacheEntry *this)
{
  char v2 = 0;
  uint64_t v3 = *((int *)this + 30);
  do
  {
    if (v3-- < 1) {
      break;
    }
    if ((v3 & 0x80000000) != 0
      || (uint64_t v5 = *(void *)(*((void *)this + 13) + 8),
          v3 > (unint64_t)((*(void *)(*((void *)this + 13) + 16) - v5) >> 4)))
    {
      CFIndex v6 = 0;
    }
    else
    {
      uint64_t v8 = (uint64_t *)(v5 + 16 * v3);
      uint64_t v9 = *v8;
      CFIndex v6 = (std::__shared_weak_count *)v8[1];
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v9 && (uint64_t)(*(void *)(v9 + 24) - *(void *)(v9 + 16)) > 0)
      {
        char v7 = 0;
        char v2 = 1;
        if (!v6) {
          continue;
        }
LABEL_7:
        std::__shared_weak_count::__release_shared[abi:nn180100](v6);
        continue;
      }
    }
    char v7 = 1;
    if (v6) {
      goto LABEL_7;
    }
  }
  while ((v7 & 1) != 0);
  return v2 & 1;
}

void HTTPConnectionCacheEntry::_removeAllConnections(HTTPConnectionCacheEntry *this, unsigned int a2)
{
  uint64_t v2 = *(void *)(*((void *)this + 12) + 16) - *(void *)(*((void *)this + 12) + 8);
  if (v2 >= 1)
  {
    unint64_t v5 = ((unint64_t)v2 >> 4) + 1;
    do
    {
      HTTPConnectionCacheEntry::ConnectionArray::stopAndRemove(*((HTTPConnectionCacheEntry::ConnectionArray **)this + 12), v5 - 2, a2);
      --v5;
    }
    while (v5 > 1);
  }
}

void XTubeManager::~XTubeManager(XTubeManager *this)
{
  XTubeManager::~XTubeManager(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  std::__shared_weak_count *v2;

  *(void *)this = &unk_1ECF9C2D0;
  XTubeManager::invalidateAllConnections((CFDictionaryRef *)this, 0);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 40));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 19);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  *((void *)this + 3) = &unk_1ECFA0310;
  CFRelease(*((CFTypeRef *)this + 4));
}

void sub_18413E598(_Unwind_Exception *a1)
{
  CFAllocatorRef v3 = *(std::__shared_weak_count **)(v1 + 152);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  *(void *)(v1 + 24) = &unk_1ECFA0310;
  CFRelease(*(CFTypeRef *)(v1 + 32));
  _Unwind_Resume(a1);
}

uint64_t XTubeManager::invalidateAllConnections(CFDictionaryRef *this, char a2)
{
  CFArrayRef v4 = (pthread_mutex_t *)(this + 5);
  pthread_mutex_lock((pthread_mutex_t *)(this + 5));
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = ___ZN12XTubeManager24invalidateAllConnectionsEb_block_invoke;
  context[3] = &__block_descriptor_33_e136_v24__0r__CoreSchedulingSet________CFAllocator_i______opaque_pthread_t_i____CFSet___os_unfair_lock_s_I_____CFRunLoop_____CFString_i_8_v16l;
  char v7 = a2;
  CFDictionaryApplyFunction(this[4], (CFDictionaryApplierFunction)RetainableTypedDict<CoreSchedulingSet const*,GlueTubeManager *>::_visit, context);
  return pthread_mutex_unlock(v4);
}

void sub_18413ED54(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN6AppSSOL13ssoOptionFlagEv_block_invoke()
{
  uint64_t result = _CFGetProgname();
  if (result)
  {
    uint64_t result = *(void *)result;
    if (result)
    {
      uint64_t result = strcmp((const char *)result, "nsurlsessiond");
      if (!result) {
        AppSSO::ssoOptionFlag(void)::flag = 1;
      }
    }
  }
  return result;
}

void sub_18413EEC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_18413F0B0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18413F214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_69(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    CFAllocatorRef v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      CFArrayRef v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        CFIndex v6 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = *(void *)(v5 + 288);
          int v10 = 134217984;
          uint64_t v11 = v7;
          _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "Connection %llu: read-side closed", (uint8_t *)&v10, 0xCu);
        }
        uint64_t v8 = *(void *)(v5 + 160);
        uint64_t v9 = *(std::__shared_weak_count **)(v5 + 168);
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v8) {
          (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
        }
        else {
          NWIOConnection::_handleEvent_Disconnected(v5, 0);
        }
        if (v9) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v9);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_18413F3FC(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void __summaryLog_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.CFNetwork", "Summary");
  uint64_t v1 = (void *)summaryLog::handle;
  summaryLog::handle = (uint64_t)v0;
}

void sub_18413F6D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18413F870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_48c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t cf_nghttp2_on_begin_headers_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(unsigned __int8 *)(a2 + 12);
  if (v4 == 5)
  {
    uint64_t stream_user_data = nghttp2_session_get_stream_user_data();
    if (stream_user_data && *(void *)stream_user_data)
    {
      uint64_t v11 = *(void *)(*(void *)stream_user_data + 16);
      if (v11) {
        uint64_t v12 = v11 - 176;
      }
      else {
        uint64_t v12 = 0;
      }
      NSURLRequestCachePolicy v13 = [*(id *)(v12 + 80) _cachePolicy];
    }
    else
    {
      NSURLRequestCachePolicy v13 = NSURLRequestUseProtocolCachePolicy;
    }
    HTTP2ServerPush::createNewForStreamId((HTTP2ServerPush *)(a3 + 288), *(_DWORD *)(a2 + 40), v13, 0);
  }
  else if (v4 == 1)
  {
    int v5 = *(_DWORD *)(a2 + 8);
    if (v5) {
      BOOL v6 = (v5 & 1) == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (!v6)
    {
      uint64_t v7 = (HTTP2Stream **)nghttp2_session_get_stream_user_data();
      if (v7)
      {
        uint64_t v8 = *v7;
        if (v8) {
          HTTP2Stream::beginHeaders(v8);
        }
      }
    }
  }
  return 0;
}

void HTTP2Stream::beginHeaders(HTTP2Stream *this)
{
  if (*((unsigned char *)this + 128))
  {
    if (*((unsigned char *)this + 129))
    {
      if (*((unsigned char *)this + 152)) {
        __assert_rtn("_onqueue_beginTrailers", "HTTP2Stream.cpp", 852, "!fTrailersBegan");
      }
      *((unsigned char *)this + 152) = 1;
      *((void *)this + 18) = CFHTTPMessageCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1) {
        dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_17041);
      }
      Instance = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
      if (Instance)
      {
        *((void *)Instance + 2) = 0;
        *((void *)Instance + 3) = 0;
        Instance = (HTTPHeaderDict *)((char *)Instance + 16);
      }
      HTTPHeaderDict::HTTPHeaderDict(Instance);
      uint64_t v3 = *((void *)this + 20);
      *((void *)this + 20) = v4;
      if (v3)
      {
        CFRelease((CFTypeRef)(v3 - 16));
      }
    }
  }
  else
  {
    *((unsigned char *)this + 128) = 1;
    *((void *)this + 15) = CFHTTPMessageCreateEmpty((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1) {
      dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_17041);
    }
    int v5 = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
    if (v5)
    {
      *((void *)v5 + 2) = 0;
      *((void *)v5 + 3) = 0;
      int v5 = (HTTPHeaderDict *)((char *)v5 + 16);
    }
    HTTPHeaderDict::HTTPHeaderDict(v5);
    *((void *)this + 17) = v6;
  }
}

CFHTTPMessageRef CFHTTPMessageCreateEmpty(CFAllocatorRef alloc, Boolean isRequest)
{
  int v2 = isRequest;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (v2)
  {
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v4 = (_OWORD *)Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 16) = 0u;
      uint64_t v4 = (_OWORD *)(Instance + 16);
      *(void *)(Instance + 192) = 0;
      *(_OWORD *)(Instance + 160) = 0u;
      *(_OWORD *)(Instance + 176) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 144) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
    }
    HTTPMessage::HTTPMessage((HTTPMessage *)v4, "httprequest");
    *(void *)uint64_t v4 = &unk_1ECF9F3F0;
    *((void *)v4 + 1) = &unk_1ECF9F470;
    *((void *)v4 + 2) = &unk_1ECF9F490;
    *((void *)v4 + 16) = &unk_1ECF9F4C0;
    CFAllocatorRef v5 = CFGetAllocator(v4 - 1);
    HTTPRequestParserClient::HTTPRequestParserClient((HTTPRequestParserClient *)(v4 + 8), v5);
    *(void *)uint64_t v4 = &unk_1ECF9F3F0;
    *((void *)v4 + 1) = &unk_1ECF9F470;
    *((void *)v4 + 2) = &unk_1ECF9F490;
    *((void *)v4 + 16) = &unk_1ECF9F4C0;
  }
  else
  {
    uint64_t v6 = (_OWORD *)_CFRuntimeCreateInstance();
    uint64_t v4 = v6;
    if (v6)
    {
      v6[1] = 0u;
      uint64_t v4 = v6 + 1;
      v6[18] = 0u;
      v6[19] = 0u;
      uint8_t v6[16] = 0u;
      v6[17] = 0u;
      v6[14] = 0u;
      v6[15] = 0u;
      v6[12] = 0u;
      v6[13] = 0u;
      v6[10] = 0u;
      v6[11] = 0u;
      v6[8] = 0u;
      v6[9] = 0u;
      v6[6] = 0u;
      v6[7] = 0u;
      v6[4] = 0u;
      v6[5] = 0u;
      v6[2] = 0u;
      v6[3] = 0u;
    }
    HTTPMessage::HTTPMessage((HTTPMessage *)v4, "httpresponse");
    *(void *)uint64_t v4 = &unk_1ECF9FD98;
    *((void *)v4 + 1) = &unk_1ECF9FE08;
    *((void *)v4 + 2) = &unk_1ECF9FE28;
    *((_DWORD *)v4 + 32) = -1;
    *((void *)v4 + 17) = 0;
    v4[10] = 0u;
    v4[11] = 0u;
    v4[12] = 0u;
    v4[13] = 0u;
    v4[14] = 0u;
    v4[15] = 0u;
    v4[16] = 0u;
    v4[17] = 0u;
    *((unsigned char *)v4 + 296) = 0;
  }
  return (CFHTTPMessageRef)(v4 - 1);
}

void sub_18413FCE8(_Unwind_Exception *a1)
{
  HTTPMessage::~HTTPMessage(v1);
  _Unwind_Resume(a1);
}

_DWORD *__copy_helper_block_ea8_48c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE64c17_ZTS11HTTP3Fields(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  uint64_t v6 = *(unsigned char **)(a2 + 64);
  CFAllocatorRef v5 = *(unsigned char **)(a2 + 72);
  size_t v7 = v5 - v6;
  if (v5 != v6)
  {
    std::vector<char>::__vallocate[abi:nn180100]((void *)(a1 + 64), v5 - v6);
    uint64_t v8 = *(char **)(a1 + 72);
    memmove(v8, v6, v7);
    *(void *)(a1 + 72) = &v8[v7];
  }
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  return std::vector<std::pair<unsigned short,unsigned short>>::__init_with_size[abi:nn180100]<std::pair<unsigned short,unsigned short>*,std::pair<unsigned short,unsigned short>*>((_DWORD *)(a1 + 88), *(int **)(a2 + 88), *(int **)(a2 + 96), (uint64_t)(*(void *)(a2 + 96) - *(void *)(a2 + 88)) >> 2);
}

void sub_18413FDB0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 56);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<char>::__vallocate[abi:nn180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    abort();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void HTTP3Connection::_tryCreateBidirectionalStreams(HTTP3Connection *this)
{
  if (*((void *)this + 139))
  {
    int v2 = (uint64_t *)((char *)this + 1120);
    do
    {
      uint64_t v3 = *v2;
      if (!*v2)
      {
        if (HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::onceToken != -1) {
          dispatch_once(&HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::onceToken, &__block_literal_global_52);
        }
        connection_metadata = nw_quic_create_connection_metadata();
        nw_quic_connection_metadata_set_stream_options();
        CFAllocatorRef v5 = nw_content_context_create("request");
        nw_content_context_set_metadata_for_protocol(v5, connection_metadata);

        uint64_t v6 = operator new(0xB8uLL);
        size_t v7 = v6;
        v6[1] = 0;
        v6[2] = 0;
        *uint64_t v6 = &unk_1ECFA6598;
        uint64_t v8 = *((void *)this + 126);
        if (v8) {
          uint64_t v9 = v8 + 112;
        }
        else {
          uint64_t v9 = 0;
        }
        int v10 = (std::__shared_weak_count *)*((void *)this + 127);
        v22[0] = v9;
        v22[1] = (uint64_t)v10;
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        HTTP3Framer::HTTP3Framer((uint64_t)(v6 + 3), v22, v5, 0, 0);
        if (v10) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v10);
        }
        *(void *)&long long v21 = v7 + 3;
        *((void *)&v21 + 1) = v7;
        std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&v21, v7 + 3, (uint64_t)(v7 + 3));
        uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 141);
        *((_OWORD *)this + 70) = v21;
        if (v11) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v11);
        }

        uint64_t v3 = *v2;
      }
      uint64_t StreamID = HTTP3Framer::getStreamID(*(NSObject **)(v3 + 48));
      if (StreamID == -1) {
        break;
      }
      uint64_t v13 = StreamID;
      v14 = (void (**)(void *, uint64_t *, uint64_t, void))_Block_copy(*(const void **)(*(void *)(*((void *)this + 135) + ((*((void *)this + 138) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                                                                 + 8
                                                                                                 * (*((void *)this + 138) & 0x1FFLL)));
      objc_release(*(id *)(*(void *)(*((void *)this + 135) + ((*((void *)this + 138) >> 6) & 0x3FFFFFFFFFFFFF8))
                         + 8 * (*((void *)this + 138) & 0x1FFLL)));
      int64x2_t v15 = vaddq_s64(*((int64x2_t *)this + 69), (int64x2_t)xmmword_1843D1750);
      *((int64x2_t *)this + 69) = v15;
      if (v15.i64[0] >= 0x400uLL)
      {
        operator delete(**((void ***)this + 135));
        *((void *)this + 135) += 8;
        *((void *)this + 138) -= 512;
      }
      uint64_t v16 = *((void *)this + 140);
      v17 = (std::__shared_weak_count *)*((void *)this + 141);
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        v18 = (std::__shared_weak_count *)*((void *)this + 141);
        uint64_t *v2 = 0;
        v2[1] = 0;
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v18);
        }
        uint64_t v19 = v16;
        v20 = v17;
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        uint64_t *v2 = 0;
        v2[1] = 0;
        uint64_t v19 = v16;
        v20 = 0;
      }
      v14[2](v14, &v19, v13, 0);
      if (v20) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v20);
      }
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v17);
      }
    }
    while (*((void *)this + 139));
  }
}

void sub_1841400A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  std::__shared_weak_count::~__shared_weak_count(v13);
  operator delete(v16);

  _Unwind_Resume(a1);
}

uint64_t HTTP3Framer::HTTP3Framer(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, char a5)
{
  id v10 = a3;
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v11 = (void **)(a1 + 48);
  *(void *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 128) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_DWORD *)(a1 + 108) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  uint64_t v12 = *a2;
  uint64_t v13 = a2[1];
  if (v13)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    v14 = *(std::__shared_weak_count **)(a1 + 24);
    *(void *)(a1 + 16) = v12;
    *(void *)(a1 + 24) = v13;
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v14);
    }
  }
  else
  {
    *(void *)(a1 + 16) = v12;
    *(void *)(a1 + 24) = 0;
  }
  *(void *)(a1 + 32) = a4;
  *(unsigned char *)(a1 + 40) = a5;
  objc_storeStrong((id *)(a1 + 56), a3);
  if (a5) {
    id v15 = 0;
  }
  else {
    id v15 = v10;
  }
  uint64_t v16 = *v11;
  *uint64_t v11 = v15;

  if (v10) {
    (*(void (**)(void, id))(**(void **)(a1 + 16) + 40))(*(void *)(a1 + 16), v10);
  }

  return a1;
}

void sub_184140238(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 24);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  CFAllocatorRef v5 = *(std::__shared_weak_count **)(v2 + 8);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'NWIOConnection::registerContext(uint64_t a1)
{
  return MEMORY[0x1F40F2C18](*(void *)(a1 + 160));
}

void ___ZN11HTTP3Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke(uint64_t a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v11 = *a2;
  uint64_t v10 = a2[1];
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(v8 + 32);
  *(void *)(v8 + 24) = v11;
  *(void *)(v8 + 32) = v10;
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  uint64_t v13 = *a2;
  uint64_t v14 = *(void *)(*(void *)(a1 + 48) + 296);
  if (v14) {
    uint64_t v15 = v14 - 176;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *(Throttler **)(v15 + 64);
  if (v16)
  {
    v17 = Throttler::getByteHeadroomInfoBlock(v16);
  }
  else
  {
    v17 = 0;
  }
  v18 = _Block_copy(v17);

  uint64_t v19 = _Block_copy(v18);
  v20 = *(void **)(v13 + 64);
  *(void *)(v13 + 64) = v19;

  uint64_t v21 = *(void *)(a1 + 48);
  *(void *)(v21 + 336) = a3;
  *(unsigned char *)(v21 + 126) = a4;
  uint64_t v22 = *(void *)(v21 + 344);
  if (v22)
  {
    *(unsigned char *)(v22 + 10) = a4;
    if (a4)
    {
      *(CFAbsoluteTime *)(v22 + 184) = CFAbsoluteTimeGetCurrent();
      uint64_t v21 = *(void *)(a1 + 48);
LABEL_14:
      *(_DWORD *)(v21 + 112) = 4;
LABEL_37:
      HTTP3Stream::_read(*(HTTP3Stream **)(a1 + 48), 0);
      return;
    }
  }
  else if (a4)
  {
    goto LABEL_14;
  }
  if (a3 != -1)
  {
    uint64_t v40 = MEMORY[0x1E4F143A8];
    uint64_t v41 = 3321888768;
    v42 = ___ZN11HTTP3Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke_1;
    v43 = &__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e16_v32__0Q8___qi_16l;
    v23 = *(std::__shared_weak_count **)(a1 + 56);
    uint64_t v44 = v21;
    v45 = v23;
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    HTTP3Stream::_sendHEADERS((void *)v21, (void *)(a1 + 64), 0, &v40);
    uint64_t v24 = *(void *)(a1 + 48);
    if (*(void *)(v24 + 96))
    {
      v25 = (__CFString *)HTTPMessage::copyHeaderFieldValue(*(HTTPMessage **)(v24 + 64), (const __CFString *)&unk_1EC0A22A0);
      v26 = v25;
      if (v25
        && (-[__CFString rangeOfString:options:](v25, "rangeOfString:options:", 0x1EC0A2D20, 1, v40, v41, v42, v43, v44), v27))
      {
        uint64_t v28 = *(void *)(a1 + 48);
        *(_DWORD *)(v28 + 112) = 1;
        dispatch_source_t v29 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(v28 + 40));
        v30 = *(void **)(v28 + 136);
        *(void *)(v28 + 136) = v29;

        uint64_t v31 = *(void *)(v28 + 8);
        v32 = *(std::__shared_weak_count **)(v28 + 16);
        if (v32) {
          atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        v33 = *(NSObject **)(v28 + 136);
        *(void *)handler = MEMORY[0x1E4F143A8];
        *(void *)&handler[8] = 3321888768;
        *(void *)&handler[16] = ___ZN11HTTP3Stream22_start100ContinueTimerEv_block_invoke;
        v47 = &__block_descriptor_48_ea8_32c36_ZTSNSt3__18weak_ptrI11HTTP3StreamEE_e5_v8__0l;
        uint64_t v48 = v31;
        v49 = v32;
        if (v32) {
          atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        dispatch_source_set_event_handler(v33, handler);
        v34 = *(NSObject **)(v28 + 136);
        dispatch_time_t v35 = dispatch_time(0, 5000000000);
        dispatch_source_set_timer(v34, v35, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        dispatch_resume(*(dispatch_object_t *)(v28 + 136));
        if (v49) {
          std::__shared_weak_count::__release_weak(v49);
        }
        if (v32) {
          std::__shared_weak_count::__release_weak(v32);
        }
      }
      else
      {
        v37 = *(HTTP3Stream **)(a1 + 48);
        *((_DWORD *)v37 + 28) = 2;
        HTTP3Stream::_resumeRequestBody(v37);
        (*(void (**)(void, void, void))(**(void **)(*(void *)(a1 + 48) + 96) + 40))(*(void *)(*(void *)(a1 + 48) + 96), *(void *)(a1 + 112), 0);
      }
    }
    if (v45) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v45);
    }
    goto LABEL_37;
  }
  v36 = CFN_LOG_h3stream();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    uint64_t v38 = *(void *)(v9 + 352);
    v39 = *(void **)(v9 + 336);
    *(_DWORD *)handler = 138543874;
    *(void *)&handler[4] = v38;
    *(_WORD *)&handler[12] = 2048;
    *(void *)&handler[14] = v9;
    *(_WORD *)&handler[22] = 2048;
    v47 = v39;
    _os_log_error_impl(&dword_184085000, v36, OS_LOG_TYPE_ERROR, "%{public}@ %p ID=%llu failed to create quic stream", handler, 0x20u);
  }

  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
}

void sub_184140650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::scheduleAndOpenWithHandler(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (!*(unsigned char *)(a1 + 369))
  {
    if (a2) {
      (*(void (**)(uint64_t))(*(void *)a2 + 40))(a2);
    }
    operator new();
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 56);
  if (v9)
  {
    uint64_t v10 = std::__shared_weak_count::lock(v9);
    if (v10)
    {
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)(a1 + 48);
      if (v12)
      {
        uint64_t v13 = *(void *)(v12 + 1008);
        uint64_t v14 = *(std::__shared_weak_count **)(v12 + 1016);
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v13)
        {
          uint64_t v15 = *(void *)(a1 + 296);
          if (v15) {
            uint64_t v16 = v15 - 176;
          }
          else {
            uint64_t v16 = 0;
          }
          id v17 = *(id *)(v16 + 80);
          (*(void (**)(uint64_t, id, uint64_t, void))(*(void *)v13 + 280))(v13, v17, 5, 0);
          *(unsigned char *)(a1 + 368) = 1;
        }
        if (v14) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v14);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 376) + 16))();

  return 1;
}

void sub_184141224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, HTTP3Fields *a10, HTTP3Fields *a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,void *__p,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,std::__shared_weak_count *a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,uint64_t a60,std::__shared_weak_count *a61)
{
  v65 = *(std::__shared_weak_count **)(v63 - 152);
  if (v65) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v65);
  }
  _Block_object_dispose(&a42, 8);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(a12);
  if (a61) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a61);
  }

  v66 = *(std::__shared_weak_count **)(v63 - 224);
  if (v66) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v66);
  }

  HTTP3Fields::~HTTP3Fields(a10);
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  if (a31) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a31);
  }
  _Block_object_dispose(&a32, 8);
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)a11);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v62);
  HTTP3Fields::~HTTP3Fields((HTTP3Fields *)&a36);

  _Unwind_Resume(a1);
}

void HTTPConnection::_onqueue_requestStart(HTTPConnection *this)
{
  v31[4] = *MEMORY[0x1E4F143B8];
  *((_WORD *)this + 16) |= 0x400u;
  uint64_t v2 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_13973, 2);
  if (v2)
  {
    uint64_t v3 = v2;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v2 + 16))(v2, "Prepare Transmission", 0))
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  int v4 = HTTPConnection::_onqueue_willEnqueueRequests(this, 0, 0);
  int v5 = 0;
  if (v4 != 2)
  {
    if (!HTTPTransaction::requestPermitsConnectionReuse(*((HTTPTransaction **)this + 18))) {
      goto LABEL_13;
    }
    if ((*((_WORD *)this + 16) & 8) == 0) {
      goto LABEL_12;
    }
    uint64_t v6 = *((void *)this + 22);
    if (v6) {
      pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
    }
    unsigned __int8 v30 = 1;
    v31[0] = &unk_1ECFA6498;
    v31[1] = &v30;
    v31[3] = v31;
    AuthenticationState::_foreachAuthenticationInfo(v6, (uint64_t)v31);
    std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](v31);
    int v7 = v30;
    if (v6) {
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
    }
    if (v7)
    {
LABEL_12:
      int v5 = 1;
    }
    else
    {
LABEL_13:
      v32.domain = 4;
      *(void *)&v32.error = 4294967292;
      HTTPConnection::_onqueue_doNotAllowMoreRequests(this, v32, 0);
      int v5 = 0;
    }
  }
  uint64_t v8 = *((void *)this + 18);
  if (*(void *)(v8 + 192))
  {
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 19);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v10 = *((void *)this + 18);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = *((void *)this + 18);
    uint64_t v8 = 0;
  }
  if (*(int *)(v10 + 80) > 3)
  {
    uint64_t v22 = "_state <= State::Negotiating";
    int v23 = 304;
    uint64_t v24 = "getPreparedRequest";
    goto LABEL_62;
  }
  HTTPTransaction::_onqueue_prepareRequest((HTTPTransaction *)v10, v5, (*((unsigned __int16 *)this + 16) >> 9) & 1);
  int v11 = *(_DWORD *)(v10 + 80);
  if (v11 == 11) {
    goto LABEL_24;
  }
  if (v11 >= 5)
  {
    uint64_t v22 = "newState >= _state";
    int v23 = 1664;
    uint64_t v24 = "_onqueue_changeState";
LABEL_62:
    __assert_rtn(v24, "HTTPTransaction.cpp", v23, v22);
  }
  *(_DWORD *)(v10 + 80) = 4;
LABEL_24:
  uint64_t v13 = *(HTTPRequestMessage **)(v10 + 160);
  uint64_t v12 = *(std::__shared_weak_count **)(v10 + 168);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if ((*((_WORD *)this + 16) & 8) == 0
    && AuthenticationState::canApplyHeadersToRequest(*((AuthenticationState **)this + 22), v13))
  {
    (*(void (**)(void, HTTPRequestMessage *, HTTPConnection *, uint64_t))(**((void **)this + 22) + 24))(*((void *)this + 22), v13, this, 1);
  }
  uint64_t v14 = *((void *)this + 18);
  uint64_t v15 = *(void *)(v14 + 152);
  if (v15)
  {
    (*(void (**)(uint64_t, void))(v15 + 16))(v15, 0);
    _Block_release(*(const void **)(v14 + 152));
    *(void *)(v14 + 152) = 0;
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v16)
  {
    id v17 = std::__shared_weak_count::lock(v16);
    if (v17) {
      uint64_t v18 = *((void *)this + 5);
    }
    else {
      uint64_t v18 = 0;
    }
  }
  else
  {
    uint64_t v18 = 0;
    id v17 = 0;
  }
  uint64_t v19 = *((void *)this + 8);
  v29[0] = (uint64_t)v13;
  v29[1] = (uint64_t)v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v28[0] = v8;
  v28[1] = (uint64_t)v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3321888768;
  aBlock[2] = ___ZN14HTTPConnection21_onqueue_requestStartEv_block_invoke_2;
  aBlock[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e13_v24__0___qi_8l;
  aBlock[4] = v18;
  uint64_t v27 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HTTPEngine::writeRequest(v19, v29, v28, aBlock);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  uint64_t v20 = *(void *)(*((void *)this + 18) + 216);
  if (!v20 || !*(_DWORD *)(v20 + 40))
  {
    uint64_t v21 = (std::__shared_weak_count *)*((void *)this + 19);
    v25[0] = *((void *)this + 18);
    v25[1] = v21;
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      HTTPConnection::suspendTransaction(this, v25, 1);
      std::__shared_weak_count::__release_shared[abi:nn180100](v21);
    }
    else
    {
      HTTPConnection::suspendTransaction(this, v25, 1);
    }
  }
  HTTPConnection::_onqueue_attemptNextResponse(this);
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v27);
  }
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  }
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
}

void sub_1841418AC(_Unwind_Exception *a1)
{
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100]((void *)(v2 - 88));
  if (v1) {
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  }
  _Unwind_Resume(a1);
}

void sub_18414192C()
{
  if (v0) {
    JUMPOUT(0x184141934);
  }
  JUMPOUT(0x184141908);
}

void sub_184141944()
{
  if (!v0) {
    JUMPOUT(0x184141914);
  }
  JUMPOUT(0x18414190CLL);
}

void HTTPConnection::_onqueue_attemptNextResponse(HTTPConnection *this)
{
  if (*((void *)this + 8))
  {
    int v2 = *((unsigned __int16 *)this + 16);
    int v3 = v2 | (*((unsigned __int8 *)this + 34) << 16);
    if ((v2 & 0x100) == 0
      && *((void *)this + 15) != *((void *)this + 16)
      && (v2 & 0x6000) == 0
      && *((void *)this + 20) != 0)
    {
      *((unsigned char *)this + 34) = BYTE2(v3);
      *((_WORD *)this + 16) = v3 | 0x2000;
      int v5 = (std::__shared_weak_count *)*((void *)this + 6);
      if (v5)
      {
        uint64_t v6 = std::__shared_weak_count::lock(v5);
        if (v6) {
          uint64_t v7 = *((void *)this + 5);
        }
        else {
          uint64_t v7 = 0;
        }
      }
      else
      {
        uint64_t v7 = 0;
        uint64_t v6 = 0;
      }
      uint64_t v8 = *((void *)this + 8);
      uint64_t v9 = (void *)*((void *)this + 20);
      uint64_t v11 = v9[20];
      uint64_t v10 = (std::__shared_weak_count *)v9[21];
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v9 = (void *)*((void *)this + 20);
      }
      uint64_t v12 = v9[26];
      if (v12 && (uint64_t v13 = *(Throttler **)(v12 - 112)) != 0) {
        ByteHeadroomInfoBlock = (void *)Throttler::getByteHeadroomInfoBlock(v13);
      }
      else {
        ByteHeadroomInfoBlock = 0;
      }
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3321888768;
      uint64_t v22[2] = ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke;
      v22[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e93_v40__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8___qi_24l;
      v22[4] = v7;
      int v23 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 3321888768;
      v20[2] = ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke_34;
      v20[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
      v20[4] = v7;
      uint64_t v21 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v18[0] = MEMORY[0x1E4F143A8];
      v18[1] = 3321888768;
      v18[2] = ___ZN14HTTPConnection22_onqueue_responseStartEv_block_invoke_39;
      v18[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e85_v24__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8l;
      v18[4] = v7;
      uint64_t v19 = v6;
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      HTTPEngine::readResponse(v8, v11, (uint64_t)v10, ByteHeadroomInfoBlock, v22, v20, v18);
      if (v10) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v10);
      }
      if (!HTTPTransaction::requestExpectsResponseBody(*(HTTPTransaction **)(*((void *)this + 20) + 160))) {
        HTTPEngine::setProperty(*((HTTPEngine **)this + 8), (CFStringRef)&unk_1EC0A3768, (const void *)*MEMORY[0x1E4F1CFD0]);
      }
      HTTPConnection::_onqueue_checkAndUpdateLargeDownload((uint64_t)this);
      uint64_t v15 = *(void *)(*((void *)this + 20) + 216);
      if (!v15 || !*(_DWORD *)(v15 + 40))
      {
        uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 21);
        v17[0] = *((void *)this + 20);
        v17[1] = v16;
        if (v16)
        {
          atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
          HTTPConnection::suspendTransaction(this, v17, 1);
          std::__shared_weak_count::__release_shared[abi:nn180100](v16);
        }
        else
        {
          HTTPConnection::suspendTransaction(this, v17, 1);
        }
      }
      if (v19) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v19);
      }
      if (v21) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v21);
      }
      if (v23) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v23);
      }
      if (v6) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v6);
      }
    }
  }
}

void sub_184141C1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (v23)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v23);
    if (!v22) {
LABEL_4:
    }
      _Unwind_Resume(exception_object);
  }
  else if (!v22)
  {
    goto LABEL_4;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  goto LABEL_4;
}

uint64_t HTTPConnection::_onqueue_checkAndUpdateLargeDownload(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 160);
  if (v1 && *(void *)(this + 64) && (*(_WORD *)(v1 + 32) & 0x200) != 0)
  {
    *(_WORD *)(v1 + 32) &= ~0x200u;
    if ((*(_WORD *)(*(void *)(this + 160) + 32) & 0x400) != 0) {
      int v2 = (const void **)MEMORY[0x1E4F1CFD0];
    }
    else {
      int v2 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    return HTTPEngine::setProperty(*(HTTPEngine **)(this + 64), (CFStringRef)&unk_1EC09F7C0, *v2);
  }
  return this;
}

uint64_t Throttler::getByteHeadroomInfoBlock(Throttler *this)
{
  uint64_t result = *((void *)this + 14);
  if (!result)
  {
    if (*((uint64_t *)this + 13) >= 1)
    {
      (*(void (**)(Throttler *))(*(void *)this + 40))(this);
      operator new();
    }
    return 0;
  }
  return result;
}

void sub_184141E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  _Unwind_Resume(a1);
}

BOOL HTTPTransaction::requestPermitsConnectionReuse(HTTPTransaction *this)
{
  int v2 = (HTTPMessage *)*((void *)this + 20);
  if (!v2) {
    return 1;
  }
  if ((*((_WORD *)this + 16) & 1) == 0) {
    return 1;
  }
  CFStringRef v3 = HTTPMessage::copyHeaderFieldValue(v2, 0x11B152B9u);
  if (!v3) {
    return 1;
  }
  CFStringRef v4 = v3;
  BOOL v5 = CFStringCompare(v3, (CFStringRef)&unk_1EC0A2E70, 1uLL) != kCFCompareEqualTo;
  CFRelease(v4);
  return v5;
}

void sub_184141EBC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

BOOL HTTPTransaction::requestExpectsResponseBody(HTTPTransaction *this)
{
  if (!this) {
    return 1;
  }
  uint64_t v1 = (const void *)*((void *)this + 19);
  if (!v1) {
    return 1;
  }
  CFTypeRef v2 = CFRetain(v1);
  if (!v2) {
    return 1;
  }
  CFStringRef v3 = v2;
  BOOL v4 = CFEqual(v2, &unk_1EC0A33B0) == 0;
  CFRelease(v3);
  return v4;
}

void sub_184141F30(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTPTransaction::_onqueue_prepareRequest(HTTPTransaction *this, int a2, int a3)
{
  uint64_t v6 = *((void *)this + 24);
  if (v6) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 56))(v6);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *((void *)this + 26);
  if (v8) {
    uint64_t v9 = (id *)(v8 - 176);
  }
  else {
    uint64_t v9 = 0;
  }
  cleanUpRequest((__CFHTTPMessage *)(*((void *)this + 20) - 16), v7, a2, a3, v9);
  uint64_t v10 = *((void *)this + 26);
  if (v10)
  {
    int v11 = [*(id *)(v10 - 96) _cachePolicy];
    [*(id *)(v10 - 96) _timeoutInterval];
    CFArrayRef v13 = (const __CFArray *)v11;
  }
  else
  {
    CFArrayRef v13 = 0;
    double v12 = 0.0;
  }
  uint64_t v14 = (void *)_constructRequestFromParts((const __CFAllocator *)(*((void *)this + 20) - 16), 0, v13, NSURLRequestUseProtocolCachePolicy, v12, 0);
  -[__CFN_TransactionMetrics setTransferredRequest:](*((void *)this + 34), v14);
  if (v14)
  {
    CFRelease(v14);
  }
}

void cleanUpRequest(__CFHTTPMessage *this, uint64_t a2, int a3, int a4, id *a5)
{
  uint64_t v9 = this;
  if (this)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*((unsigned char *)v9 + 40)) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = (__CFHTTPMessage *)((char *)v9 + 16);
    }
  }
  if (!HTTPMessage::hasHeaderField((os_unfair_lock_s *)v9, 0x14E15421u)
    && (!a5
     || (uint64_t v10 = (void *)[a5[10] _effectiveConfiguration]) == 0
     || (int v11 = (void *)[v10 _suppressedAutoAddedHTTPHeaders]) == 0
     || ([v11 containsObject:0x1EC0A2B28] & 1) == 0))
  {
    pthread_once(&initControl, initializeUserAgentString);
    HTTPMessage::setHeaderFieldStringValue(v9, 0x14E15421u, (const void *)sUserAgentString);
  }
  if ((a2 & 0x8000000000000000) == 0)
  {
    CFStringRef v12 = (const __CFString *)*((void *)v9 + 19);
    if (!v12)
    {
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)) {
        goto LABEL_39;
      }
      *(_WORD *)uint64_t v20 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", v20, 2u);
      CFStringRef v12 = (const __CFString *)*((void *)v9 + 19);
      if (!v12) {
        goto LABEL_39;
      }
    }
    if (CFEqual(v12, (CFStringRef)&gConstantCFStringValueTable[2604])) {
      goto LABEL_22;
    }
    CFStringRef v13 = (const __CFString *)*((void *)v9 + 19);
    if (!v13)
    {
LABEL_39:
      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)) {
        goto LABEL_21;
      }
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u);
      CFStringRef v13 = (const __CFString *)*((void *)v9 + 19);
      if (!v13) {
        goto LABEL_21;
      }
    }
    if (CFStringCompare(v13, (CFStringRef)&gConstantCFStringValueTable[2611], 0)) {
LABEL_21:
    }
      HTTPMessage::setHeaderFieldScalarValue(v9, a2);
  }
LABEL_22:
  if (a3)
  {
    if (HTTPMessage::hasHeaderField((os_unfair_lock_s *)v9, 0x11B152B9u)) {
      goto LABEL_28;
    }
    unsigned int v14 = 372331669;
    uint64_t v15 = v9;
    unsigned int v16 = 372331669;
  }
  else
  {
    unsigned int v14 = 365999224;
    uint64_t v15 = v9;
    unsigned int v16 = 365999224;
  }
  HTTPMessage::setHeaderFieldStringValue(v15, 0x11B152B9u, v16);
  if (a4) {
    HTTPMessage::setHeaderFieldStringValue(v9, 0x13921375u, v14);
  }
LABEL_28:
  if (!HTTPMessage::hasHeaderField((os_unfair_lock_s *)v9, 0x1290930Eu))
  {
    CFURLRef v17 = (const __CFURL *)HTTPRequestParserClient::requestURL((__CFHTTPMessage *)((char *)v9 + 128));
    if (v17)
    {
      HTTPUtilities::createAuthorityStringFromURL((HTTPUtilities *)&v19, v17);
      uint64_t v18 = v19;
      if (v19)
      {
        HTTPMessage::setHeaderFieldStringValue(v9, 0x1290930Eu, v19);
        CFRelease(v18);
      }
    }
  }
}

void sub_1841422FC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void HTTPUtilities::createAuthorityStringFromURL(HTTPUtilities *this, CFURLRef url)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  *(void *)this = 0;
  CFRange v4 = CFURLGetByteRangeForComponent(url, kCFURLComponentHost, 0);
  if (v4.location == -1 || v4.length < 1) {
    goto LABEL_18;
  }
  int64_t v6 = CFURLGetBytes(url, 0, 0);
  CFIndex v7 = v6;
  if (v6 < 1) {
    goto LABEL_18;
  }
  if ((unint64_t)v6 >= 0x201)
  {
    uint64_t v8 = (UInt8 *)malloc_type_malloc(v6, 0x32BC5F4FuLL);
    if (!v8) {
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v8 = buffer;
  }
  if (CFURLGetBytes(url, v8, v7) < 1)
  {
    CFStringRef v11 = 0;
  }
  else
  {
    CFRange v9 = CFURLGetByteRangeForComponent(url, kCFURLComponentPort, 0);
    if (v9.location == -1) {
      CFIndex length = v4.length;
    }
    else {
      CFIndex length = v9.length - v4.location + v9.location;
    }
    CFStringRef v11 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &v8[v4.location], length, 0x201u, 0);
  }
  if (v8 != buffer) {
    free(v8);
  }
  if (v11) {
    goto LABEL_32;
  }
LABEL_18:
  CFStringRef v12 = CFURLCopyHostName(url);
  if (v12)
  {
    uint64_t v13 = CFURLGetPortNumber(url);
    CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v15 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v12, 0, 0, 0x8000100u);
    if (v15 || (CFStringRef v15 = CFURLCreateStringByAddingPercentEscapes(v14, v12, 0, 0, 0x201u)) != 0)
    {
      if (_isIPAddress(v12, 0)) {
        CFStringRef v16 = v13 == -1
      }
            ? CFStringCreateWithFormat(v14, 0, @"[%@]", v15)
            : CFStringCreateWithFormat(v14, 0, @"[%@]:%d", v15, v13);
      else {
        CFStringRef v16 = v13 == -1
      }
            ? (CFStringRef)CFRetain(v15)
            : CFStringCreateWithFormat(v14, 0, @"%@:%d", v15, v13);
      CFStringRef v11 = v16;
      CFRelease(v15);
    }
    else
    {
      CFStringRef v11 = 0;
    }
    CFRelease(v12);
    if (v11)
    {
LABEL_32:
      if (CFStringGetLength(v11) < 1
        || CFStringGetCharacterAtIndex(v11, 0) != 91
        || (v18 = CFStringFind(v11, @"%25", 0), CFStringRef v17 = (const __CFString *)v18.length, v18.location == -1)
        || (CFRange v19 = CFStringFind(v11, @"]", 0), v17 = (const __CFString *)v19.length, v19.location == -1)
        || v19.location <= v18.location
        || (CFAllocatorRef v20 = CFGetAllocator(v11), MutableCopy = CFStringCreateMutableCopy(v20, 0, v11),
                                       (CFStringRef v22 = MutableCopy) == 0))
      {
        CFStringRef v22 = v11;
      }
      else
      {
        v26.location = v18.location;
        v26.CFIndex length = v19.location - v18.location;
        CFStringDelete(MutableCopy, v26);
        CFRelease(v11);
      }
      if (HTTPHeaderValue::isValid(v22, v17))
      {
        int v23 = *(const void **)this;
        *(void *)this = v22;
        if (v23) {
          CFRelease(v23);
        }
      }
      else
      {
        CFRelease(v22);
      }
    }
  }
}

void sub_184142624(_Unwind_Exception *exception_object)
{
  CFStringRef v3 = *v1;
  *uint64_t v1 = 0;
  if (v3) {
    CFRelease(v3);
  }
  _Unwind_Resume(exception_object);
}

void HTTPMessage::setHeaderFieldStringValue(HTTPMessage *a1, unsigned int a2, unsigned int a3)
{
  BOOL v5 = HTTPMessage::mutableHeaders(a1);
  HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(&v8, a2);
  int64_t v6 = &unk_1ECFA3240;
  CFTypeRef cf = CFRetain(&gConstantCFStringValueTable[7 * ((a3 >> 20) & 0x3FF)]);
  HTTPHeaderDict::setValue((uint64_t)v5, (uint64_t)&v8, (uint64_t)&v6);
  int64_t v6 = &unk_1ECF9F718;
  if (cf) {
    CFRelease(cf);
  }
  uint64_t v8 = &unk_1ECF9F718;
  if (v9) {
    CFRelease(v9);
  }
}

void sub_184142750(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf, uint64_t a11, CFTypeRef a12)
{
  if (cf) {
    CFRelease(cf);
  }
  if (a12) {
    CFRelease(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _constructRequestFromParts(const __CFAllocator *a1, __CFHTTPMessage *a2, const __CFArray *a3, NSURLRequestCachePolicy a4, double a5, const __CFURL *a6)
{
  int v6 = (int)a6;
  id v7 = [[NSURLRequestInternal alloc] _initWithMessage:a1 bodyParts:a2 cachePolicy:a3 timeout:a4 mainDocumentURL:a6 mutable:a5];
  uint64_t v8 = off_1E5250D10;
  if (v6) {
    uint64_t v8 = off_1E5250C28;
  }
  uint64_t v9 = [objc_alloc(*v8) _initWithInternal:v7];

  return v9;
}

void sub_184142B64(_Unwind_Exception *a1)
{
  HTTPRequestMessage::~HTTPRequestMessage(v1);
  _Unwind_Resume(a1);
}

void HTTPEngine::writeRequest(uint64_t a1, uint64_t *a2, uint64_t *a3, void *aBlock)
{
  if (!*a2) {
    __assert_rtn("writeRequest", "HTTPEngine.cpp", 507, "request");
  }
  if (*(void *)(a1 + 312)) {
    __assert_rtn("writeRequest", "HTTPEngine.cpp", 510, "!_outCB");
  }
  *(void *)(a1 + 312) = _Block_copy(aBlock);
  if (*(void *)(a1 + 56) && (int v7 = *(_DWORD *)(a1 + 32), (v7 & 3) == 0))
  {
    if (!*(void *)(a1 + 240) || (v7 & 0x1000010) == 0x1000010)
    {
      uint64_t v16 = *a2;
      uint64_t v15 = a2[1];
      if (v15) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
      }
      CFStringRef v17 = *(std::__shared_weak_count **)(a1 + 248);
      *(void *)(a1 + 240) = v16;
      *(void *)(a1 + 248) = v15;
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v17);
      }
      CFRange v18 = (std::__shared_weak_count *)a3[1];
      if (v18)
      {
        CFRange v18 = std::__shared_weak_count::lock(v18);
        if (v18) {
          uint64_t v19 = *a3;
        }
        else {
          uint64_t v19 = 0;
        }
      }
      else
      {
        uint64_t v19 = 0;
      }
      CFAllocatorRef v20 = *(std::__shared_weak_count **)(a1 + 264);
      *(void *)(a1 + 256) = v19;
      *(void *)(a1 + 264) = v18;
      if (v20)
      {
        std::__shared_weak_count::__release_shared[abi:nn180100](v20);
        uint64_t v19 = *(void *)(a1 + 256);
      }
      if (!v19)
      {
        uint64_t v21 = *(std::__shared_weak_count **)(a1 + 264);
        *(void *)(a1 + 256) = 0;
        *(void *)(a1 + 264) = 0;
        if (v21) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v21);
        }
      }
      *(void *)(a1 + 288) = 0;
      *(void *)(a1 + 296) = 0;
      CFStringRef v22 = *(NSObject **)(a1 + 304);
      if (v22)
      {
        dispatch_release(v22);
        *(void *)(a1 + 304) = 0;
      }
      *(_DWORD *)(a1 + 32) &= 0xF07FFFFF;
      int v23 = *(std::__shared_weak_count **)(a1 + 48);
      if (v23)
      {
        uint64_t v9 = std::__shared_weak_count::lock(v23);
        if (v9) {
          uint64_t v24 = *(void *)(a1 + 40);
        }
        else {
          uint64_t v24 = 0;
        }
      }
      else
      {
        uint64_t v24 = 0;
        uint64_t v9 = 0;
      }
      CFRange v26 = *(NSObject **)(a1 + 72);
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 3321888768;
      v27[2] = ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke_3;
      v27[3] = &__block_descriptor_48_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
      v27[4] = v24;
      uint64_t v28 = v9;
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      dispatch_async(v26, v27);
      CFAllocatorRef v14 = v28;
      if (v28) {
        goto LABEL_18;
      }
    }
    else
    {
      CFStringRef v11 = *(std::__shared_weak_count **)(a1 + 48);
      if (v11)
      {
        uint64_t v9 = std::__shared_weak_count::lock(v11);
        if (v9) {
          uint64_t v12 = *(void *)(a1 + 40);
        }
        else {
          uint64_t v12 = 0;
        }
      }
      else
      {
        uint64_t v12 = 0;
        uint64_t v9 = 0;
      }
      uint64_t v25 = *(NSObject **)(a1 + 72);
      v29[0] = MEMORY[0x1E4F143A8];
      v29[1] = 3321888768;
      uint64_t v29[2] = ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke_2;
      v29[3] = &__block_descriptor_64_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
      v29[4] = v12;
      unsigned __int8 v30 = v9;
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v31 = 4;
      uint64_t v32 = 4294965201;
      dispatch_async(v25, v29);
      CFAllocatorRef v14 = v30;
      if (v30) {
        goto LABEL_18;
      }
    }
  }
  else
  {
    uint64_t v8 = *(std::__shared_weak_count **)(a1 + 48);
    if (v8)
    {
      uint64_t v9 = std::__shared_weak_count::lock(v8);
      if (v9) {
        uint64_t v10 = *(void *)(a1 + 40);
      }
      else {
        uint64_t v10 = 0;
      }
    }
    else
    {
      uint64_t v10 = 0;
      uint64_t v9 = 0;
    }
    uint64_t v13 = *(NSObject **)(a1 + 72);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke;
    block[3] = &__block_descriptor_64_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
    block[4] = v10;
    v34 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v35 = 4;
    uint64_t v36 = 4294967292;
    dispatch_async(v13, block);
    CFAllocatorRef v14 = v34;
    if (v34) {
LABEL_18:
    }
      std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
}

void HTTPEngine::readResponse(uint64_t a1, uint64_t a2, uint64_t a3, void *aBlock, void *a5, const void *a6, const void *a7)
{
  if (*(void *)(a1 + 144)) {
    __assert_rtn("readResponse", "HTTPEngine.cpp", 407, "!_inResponseAssociatedRequest");
  }
  if (*(void *)(a1 + 160)) {
    __assert_rtn("readResponse", "HTTPEngine.cpp", 408, "!_inHeadroomInfo");
  }
  if (*(void *)(a1 + 200)) {
    __assert_rtn("readResponse", "HTTPEngine.cpp", 409, "!_inCBHeaders");
  }
  if (*(void *)(a1 + 208)) {
    __assert_rtn("readResponse", "HTTPEngine.cpp", 410, "!_inCBData");
  }
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 152);
  *(void *)(a1 + 144) = a2;
  *(void *)(a1 + 152) = a3;
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  if (aBlock) {
    *(void *)(a1 + 160) = _Block_copy(aBlock);
  }
  *(void *)(a1 + 200) = _Block_copy(a5);
  *(void *)(a1 + 208) = _Block_copy(a6);
  *(void *)(a1 + 216) = _Block_copy(a7);
  if (*(void *)(a1 + 56))
  {
    int v13 = *(_DWORD *)(a1 + 32);
    if ((v13 & 1) == 0)
    {
      if ((~v13 & 0x50) == 0)
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
        uint64_t v15 = (HTTPMessage *)Instance;
        if (Instance)
        {
          Instance[1] = 0u;
          uint64_t v15 = (HTTPMessage *)(Instance + 1);
          Instance[18] = 0u;
          Instance[19] = 0u;
          Instance[16] = 0u;
          Instance[17] = 0u;
          Instance[14] = 0u;
          Instance[15] = 0u;
          Instance[12] = 0u;
          Instance[13] = 0u;
          Instance[10] = 0u;
          Instance[11] = 0u;
          Instance[8] = 0u;
          Instance[9] = 0u;
          Instance[6] = 0u;
          Instance[7] = 0u;
          Instance[4] = 0u;
          Instance[5] = 0u;
          Instance[2] = 0u;
          Instance[3] = 0u;
        }
        HTTPMessage::HTTPMessage(v15, "httpresponse");
        *(void *)uint64_t v15 = &unk_1ECF9FD98;
        *((void *)v15 + 1) = &unk_1ECF9FE08;
        *((void *)v15 + 2) = &unk_1ECF9FE28;
        *((_DWORD *)v15 + 32) = -1;
        *((void *)v15 + 17) = 0;
        *((_OWORD *)v15 + 10) = 0u;
        *((_OWORD *)v15 + 11) = 0u;
        *((_OWORD *)v15 + 12) = 0u;
        *((_OWORD *)v15 + 13) = 0u;
        *((_OWORD *)v15 + 14) = 0u;
        *((_OWORD *)v15 + 15) = 0u;
        *((_OWORD *)v15 + 16) = 0u;
        *((_OWORD *)v15 + 17) = 0u;
        *((unsigned char *)v15 + 296) = 0;
        operator new();
      }
      uint64_t v16 = *(std::__shared_weak_count **)(a1 + 48);
      if (v16)
      {
        CFStringRef v17 = std::__shared_weak_count::lock(v16);
        if (v17) {
          uint64_t v18 = *(void *)(a1 + 40);
        }
        else {
          uint64_t v18 = 0;
        }
      }
      else
      {
        uint64_t v18 = 0;
        CFStringRef v17 = 0;
      }
      int v23 = *(NSObject **)(a1 + 72);
      v24[0] = MEMORY[0x1E4F143A8];
      v24[1] = 3321888768;
      v24[2] = ___ZN10HTTPEngine12readResponseENSt3__110shared_ptrI18HTTPRequestMessageEEU13block_pointerFxvEU13block_pointerFvNS1_I19HTTPResponseMessageEE13CFStreamErrorEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectS8_bEU13block_pointerFvS7_E_block_invoke_11;
      v24[3] = &__block_descriptor_56_e8_40c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
      v24[4] = a1;
      v24[5] = v18;
      uint64_t v25 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      dispatch_async(v23, v24);
      CFStringRef v22 = v25;
      if (!v25) {
        goto LABEL_31;
      }
LABEL_30:
      std::__shared_weak_count::__release_shared[abi:nn180100](v22);
      goto LABEL_31;
    }
  }
  uint64_t v19 = *(std::__shared_weak_count **)(a1 + 48);
  if (v19)
  {
    CFStringRef v17 = std::__shared_weak_count::lock(v19);
    if (v17) {
      uint64_t v20 = *(void *)(a1 + 40);
    }
    else {
      uint64_t v20 = 0;
    }
  }
  else
  {
    uint64_t v20 = 0;
    CFStringRef v17 = 0;
  }
  uint64_t v21 = *(NSObject **)(a1 + 72);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN10HTTPEngine12readResponseENSt3__110shared_ptrI18HTTPRequestMessageEEU13block_pointerFxvEU13block_pointerFvNS1_I19HTTPResponseMessageEE13CFStreamErrorEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectS8_bEU13block_pointerFvS7_E_block_invoke;
  block[3] = &__block_descriptor_64_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
  block[4] = v20;
  uint64_t v27 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v28 = 4;
  uint64_t v29 = 4294967292;
  dispatch_async(v21, block);
  CFStringRef v22 = v27;
  if (v27) {
    goto LABEL_30;
  }
LABEL_31:
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  }
}

_DWORD *std::vector<std::pair<unsigned short,unsigned short>>::__init_with_size[abi:nn180100]<std::pair<unsigned short,unsigned short>*,std::pair<unsigned short,unsigned short>*>(_DWORD *result, int *a2, int *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 62) {
      abort();
    }
    int v6 = result;
    uint64_t result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned short,unsigned short>>>(a4);
    *int v6 = result;
    v6[1] = result;
    v6[2] = &result[v7];
    while (a2 != a3)
    {
      int v8 = *a2++;
      *result++ = v8;
    }
    v6[1] = result;
  }
  return result;
}

void HTTP3Fields::HTTP3Fields(HTTP3Fields *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  CFTypeRef v2 = (char *)operator new(0x4000uLL);
  *(void *)this = v2;
  *((void *)this + 1) = v2;
  *((void *)this + 2) = v2 + 0x4000;
}

void ___ZN15HTTP3Connection21createFramerForStreamERK11HTTP3FieldsU13block_pointerFvNSt3__110shared_ptrI11HTTP3FramerEEybE_block_invoke(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *a2;
  if (*a2)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    int v8 = (std::__shared_weak_count *)a2[1];
    uint64_t v138 = *a2;
    v139 = v8;
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v6 = *a2;
    }
    uint64_t StreamID = HTTP3Framer::getStreamID(*(NSObject **)(v6 + 48));
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(v7 + 16))(v7, &v138, StreamID, 1);
    if (v139) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v139);
    }
    goto LABEL_49;
  }
  uint64_t v10 = *(void **)(a1 + 48);
  CFStringRef v11 = (char *)v10[136];
  uint64_t v12 = (char *)v10[135];
  uint64_t v13 = v11 - v12;
  if (v11 == v12) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = ((v11 - v12) << 6) - 1;
  }
  unint64_t v15 = v10[138];
  if (v14 == v10[139] + v15)
  {
    BOOL v16 = v15 >= 0x200;
    unint64_t v17 = v15 - 512;
    if (v16)
    {
      v10[138] = v17;
      uint64_t v20 = *(void *)v12;
      uint64_t v18 = v12 + 8;
      uint64_t v19 = v20;
      v10[135] = v18;
      if (v11 == (char *)v10[137])
      {
        unint64_t v21 = v10[134];
        uint64_t v22 = (uint64_t)&v18[-v21];
        if ((unint64_t)v18 <= v21)
        {
          uint64_t v50 = (uint64_t)&v11[-v21];
          BOOL v49 = v50 == 0;
          uint64_t v51 = v50 >> 2;
          if (v49) {
            unint64_t v52 = 1;
          }
          else {
            unint64_t v52 = v51;
          }
          v53 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v52);
          v55 = &v53[8 * (v52 >> 2)];
          v56 = (uint64_t *)v10[135];
          CFStringRef v11 = v55;
          uint64_t v57 = v10[136] - (void)v56;
          if (v57)
          {
            CFStringRef v11 = &v55[v57 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v58 = 8 * (v57 >> 3);
            v59 = &v53[8 * (v52 >> 2)];
            do
            {
              uint64_t v60 = *v56++;
              *(void *)v59 = v60;
              v59 += 8;
              v58 -= 8;
            }
            while (v58);
          }
          v61 = (void *)v10[134];
          v10[134] = v53;
          v10[135] = v55;
          v10[136] = v11;
          v10[137] = &v53[8 * v54];
          if (v61)
          {
            operator delete(v61);
            CFStringRef v11 = (char *)v10[136];
          }
        }
        else
        {
          uint64_t v23 = v22 >> 3;
          BOOL v24 = v22 >> 3 < -1;
          uint64_t v25 = (v22 >> 3) + 2;
          if (v24) {
            uint64_t v26 = v25;
          }
          else {
            uint64_t v26 = v23 + 1;
          }
          uint64_t v27 = -(v26 >> 1);
          uint64_t v28 = v26 >> 1;
          uint64_t v29 = &v18[-8 * v28];
          int64_t v30 = v11 - v18;
          if (v11 != v18)
          {
            memmove(&v18[-8 * v28], v18, v11 - v18);
            CFStringRef v11 = (char *)v10[135];
          }
          uint64_t v31 = &v11[8 * v27];
          CFStringRef v11 = &v29[v30];
          v10[136] = &v29[v30];
          v10[135] = v31;
        }
      }
      *(void *)CFStringRef v11 = v19;
    }
    else
    {
      uint64_t v32 = v13 >> 3;
      v33 = (char *)v10[137];
      v34 = (char *)v10[134];
      if (v13 >> 3 >= (unint64_t)((v33 - v34) >> 3))
      {
        uint64_t v130 = *(void *)(a1 + 40);
        if (v33 == v34) {
          unint64_t v37 = 1;
        }
        else {
          unint64_t v37 = (v33 - v34) >> 2;
        }
        uint64_t v38 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v37);
        uint64_t v40 = v39;
        uint64_t v41 = &v38[8 * v32];
        *(void *)&long long v42 = v38;
        *((void *)&v42 + 1) = v41;
        long long v134 = v42;
        v43 = operator new(0x1000uLL);
        *(void *)&long long v44 = v41;
        *((void *)&v44 + 1) = &v38[8 * v40];
        if (v32 == v40)
        {
          uint64_t v45 = 8 * v32;
          *(void *)&long long v46 = v134;
          if (v13 < 1)
          {
            v94 = v43;
            uint64_t v95 = v45 >> 2;
            if (v11 == v12) {
              unint64_t v96 = 1;
            }
            else {
              unint64_t v96 = v95;
            }
            v97 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v96);
            uint64_t v41 = &v97[8 * (v96 >> 2)];
            *(void *)&long long v46 = v97;
            *((void *)&v46 + 1) = v41;
            *(void *)&long long v44 = v41;
            *((void *)&v44 + 1) = &v97[8 * v98];
            if (v38)
            {
              long long v131 = v44;
              long long v135 = v46;
              operator delete(v38);
              long long v44 = v131;
              long long v46 = v135;
            }
            v43 = v94;
          }
          else
          {
            uint64_t v47 = v45 >> 3;
            if (v47 >= -1) {
              unint64_t v48 = v47 + 1;
            }
            else {
              unint64_t v48 = v47 + 2;
            }
            v41 -= 8 * (v48 >> 1);
            *(void *)&long long v44 = v41;
            *((void *)&v46 + 1) = v41;
          }
        }
        else
        {
          long long v46 = v134;
        }
        *(void *)uint64_t v41 = v43;
        *(void *)&long long v44 = v44 + 8;
        uint64_t v99 = v10[136];
        uint64_t v5 = v130;
        while (v99 != v10[135])
        {
          v100 = (void *)*((void *)&v46 + 1);
          if (*((void *)&v46 + 1) == (void)v46)
          {
            v102 = (unsigned char *)v44;
            if ((unint64_t)v44 >= *((void *)&v44 + 1))
            {
              if (*((void *)&v44 + 1) == *((void *)&v46 + 1)) {
                unint64_t v107 = 1;
              }
              else {
                unint64_t v107 = (uint64_t)(*((void *)&v44 + 1) - *((void *)&v46 + 1)) >> 2;
              }
              v108 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v107);
              v101 = &v108[(2 * v107 + 6) & 0xFFFFFFFFFFFFFFF8];
              v110 = v101;
              uint64_t v111 = v102 - (unsigned char *)v100;
              if (v102 != (unsigned char *)v100)
              {
                v110 = &v101[v111 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v112 = 8 * (v111 >> 3);
                v113 = v101;
                v114 = v100;
                do
                {
                  uint64_t v115 = *v114++;
                  *(void *)v113 = v115;
                  v113 += 8;
                  v112 -= 8;
                }
                while (v112);
              }
              *(void *)&long long v46 = v108;
              *((void *)&v46 + 1) = v101;
              *(void *)&long long v44 = v110;
              *((void *)&v44 + 1) = &v108[8 * v109];
              if (v100)
              {
                long long v132 = v44;
                long long v137 = v46;
                operator delete(v100);
                long long v44 = v132;
                long long v46 = v137;
              }
            }
            else
            {
              uint64_t v103 = (uint64_t)(*((void *)&v44 + 1) - v44) >> 3;
              if (v103 >= -1) {
                uint64_t v104 = v103 + 1;
              }
              else {
                uint64_t v104 = v103 + 2;
              }
              uint64_t v105 = v104 >> 1;
              uint64_t v106 = v44 + 8 * (v104 >> 1);
              v101 = (char *)(v106 - (v44 - *((void *)&v46 + 1)));
              if ((void)v44 == *((void *)&v46 + 1))
              {
                v102 = (unsigned char *)*((void *)&v46 + 1);
              }
              else
              {
                uint64_t v133 = *((void *)&v44 + 1);
                uint64_t v136 = v46;
                memmove((void *)(v106 - (v44 - *((void *)&v46 + 1))), *((const void **)&v46 + 1), v44 - *((void *)&v46 + 1));
                *((void *)&v44 + 1) = v133;
                *(void *)&long long v46 = v136;
              }
              *((void *)&v46 + 1) = v101;
              *(void *)&long long v44 = &v102[8 * v105];
            }
          }
          else
          {
            v101 = (char *)*((void *)&v46 + 1);
          }
          uint64_t v116 = *(void *)(v99 - 8);
          v99 -= 8;
          *((void *)v101 - 1) = v116;
          *((void *)&v46 + 1) -= 8;
        }
        v117 = (void *)v10[134];
        *((_OWORD *)v10 + 67) = v46;
        *((_OWORD *)v10 + 68) = v44;
        if (v117)
        {
          operator delete(v117);
          CFStringRef v11 = (char *)v10[136];
        }
        else
        {
          CFStringRef v11 = (char *)v44;
        }
        goto LABEL_43;
      }
      uint64_t v35 = operator new(0x1000uLL);
      uint64_t v36 = v35;
      if (v33 == v11)
      {
        if (v12 == v34)
        {
          if (v11 == v12) {
            unint64_t v71 = 1;
          }
          else {
            unint64_t v71 = (v33 - v12) >> 2;
          }
          uint64_t v72 = 2 * v71;
          v73 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v71);
          uint64_t v12 = &v73[(v72 + 6) & 0xFFFFFFFFFFFFFFF8];
          v75 = (uint64_t *)v10[135];
          v76 = v12;
          uint64_t v77 = v10[136] - (void)v75;
          if (v77)
          {
            v76 = &v12[v77 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v78 = 8 * (v77 >> 3);
            v79 = v12;
            do
            {
              uint64_t v80 = *v75++;
              *(void *)v79 = v80;
              v79 += 8;
              v78 -= 8;
            }
            while (v78);
          }
          v81 = (void *)v10[134];
          v10[134] = v73;
          v10[135] = v12;
          v10[136] = v76;
          v10[137] = &v73[8 * v74];
          if (v81)
          {
            operator delete(v81);
            uint64_t v12 = (char *)v10[135];
          }
        }
        *((void *)v12 - 1) = v36;
        v82 = (char *)v10[135];
        v10[135] = v82 - 8;
        uint64_t v83 = *((void *)v82 - 1);
        v10[135] = v82;
        v84 = (char *)v10[136];
        if (v84 == (char *)v10[137])
        {
          unint64_t v85 = v10[134];
          uint64_t v86 = (uint64_t)&v82[-v85];
          if ((unint64_t)v82 <= v85)
          {
            uint64_t v118 = (uint64_t)&v84[-v85];
            BOOL v49 = v118 == 0;
            uint64_t v119 = v118 >> 2;
            if (v49) {
              unint64_t v120 = 1;
            }
            else {
              unint64_t v120 = v119;
            }
            v121 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v120);
            v123 = &v121[8 * (v120 >> 2)];
            v124 = (uint64_t *)v10[135];
            v84 = v123;
            uint64_t v125 = v10[136] - (void)v124;
            if (v125)
            {
              v84 = &v123[v125 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v126 = 8 * (v125 >> 3);
              v127 = &v121[8 * (v120 >> 2)];
              do
              {
                uint64_t v128 = *v124++;
                *(void *)v127 = v128;
                v127 += 8;
                v126 -= 8;
              }
              while (v126);
            }
            v129 = (void *)v10[134];
            v10[134] = v121;
            v10[135] = v123;
            v10[136] = v84;
            v10[137] = &v121[8 * v122];
            if (v129)
            {
              operator delete(v129);
              v84 = (char *)v10[136];
            }
          }
          else
          {
            uint64_t v87 = v86 >> 3;
            BOOL v24 = v86 >> 3 < -1;
            uint64_t v88 = (v86 >> 3) + 2;
            if (v24) {
              uint64_t v89 = v88;
            }
            else {
              uint64_t v89 = v87 + 1;
            }
            uint64_t v90 = -(v89 >> 1);
            uint64_t v91 = v89 >> 1;
            v92 = &v82[-8 * v91];
            int64_t v93 = v84 - v82;
            if (v84 != v82)
            {
              memmove(&v82[-8 * v91], v82, v84 - v82);
              v82 = (char *)v10[135];
            }
            v84 = &v92[v93];
            v10[136] = &v92[v93];
            v10[135] = &v82[8 * v90];
          }
        }
        *(void *)v84 = v83;
      }
      else
      {
        *(void *)CFStringRef v11 = v35;
      }
    }
    CFStringRef v11 = (char *)(v10[136] + 8);
    v10[136] = v11;
LABEL_43:
    uint64_t v12 = (char *)v10[135];
  }
  if (v11 == v12)
  {
    uint64_t v63 = 0;
  }
  else
  {
    unint64_t v62 = v10[139] + v10[138];
    uint64_t v63 = (void **)(*(void *)&v12[(v62 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v62 & 0x1FF));
  }
  *uint64_t v63 = _Block_copy(*(const void **)(a1 + 32));
  ++v10[139];
  v64 = *(HTTP3Connection **)(a1 + 48);
  if (*((void *)v64 + 139) == 1) {
    HTTP3Connection::_tryCreateBidirectionalStreams(v64);
  }
LABEL_49:
  if (a3)
  {
    uint64_t v65 = *(void *)(*(void *)(a1 + 48) + 1008);
    if (v65)
    {
      if ((*(unsigned char *)(v5 + 920) & 4) == 0)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v65 + 96))(v65, *(int *)(v5 + 792) + 3);
        uint64_t v66 = *(void *)(a1 + 48);
        unint64_t __src = 0;
        size_t v68 = QUICUtilities::quic_vle_encode(*(int *)(v66 + 792) - 1, &__src, v67);
        memcpy(__dst, &__src, v68);
        uint64_t v69 = *(void *)(v66 + 1024);
        dispatch_data_t v70 = dispatch_data_create(__dst, v68, 0, 0);
        HTTP3Framer::writeFrame(v69, 0xDuLL, v70, 0, &__block_literal_global_37);
      }
    }
  }
}

void sub_184143B2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, long long a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  operator delete(v16);
  if ((void)a13) {
    operator delete((void *)a13);
  }
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a1);
}

uint64_t HTTP3Framer::getStreamID(NSObject *this)
{
  CFTypeRef v2 = nw_protocol_copy_quic_connection_definition();
  nw_protocol_metadata_t v3 = nw_content_context_copy_protocol_metadata(this, v2);

  CFRange v4 = (void *)nw_quic_connection_copy_stream_metadata();
  if (v4) {
    uint64_t id = nw_quic_stream_get_id();
  }
  else {
    uint64_t id = -1;
  }

  return id;
}

void sub_184143C30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void FileURLProtocol::~FileURLProtocol(FileURLProtocol *this)
{
  *(void *)this = &unk_1ECF9D2E0;
  *((void *)this + 1) = &unk_1ECF9D3E0;
  *((void *)this + 2) = &unk_1ECF9D400;
  CFTypeRef v2 = (const void *)*((void *)this + 15);
  if (v2) {
    CFRelease(v2);
  }
  nw_protocol_metadata_t v3 = (const void *)*((void *)this + 18);
  if (v3) {
    CFRelease(v3);
  }
  FileURLProtocol::destroyReadStream(this);

  URLProtocol::~URLProtocol((URLProtocol *)this);
}

void sub_184143D08(_Unwind_Exception *a1)
{
  URLProtocol::~URLProtocol(v1);
  _Unwind_Resume(a1);
}

void FileURLProtocol::destroyReadStream(FileURLProtocol *this)
{
  uint64_t v1 = (__CFReadStream *)*((void *)this + 16);
  if (v1)
  {
    *((void *)this + 16) = 0;
    CFTypeRef v2 = MEMORY[0x185319E30](v1);
    MEMORY[0x185319F20](v1, 0);
    CFReadStreamSetClient(v1, 0, 0, 0);
    CFReadStreamClose(v1);
    if (v2)
    {
      dispatch_async_f(v2, v1, (dispatch_function_t)_release_ReadStream);
      dispatch_release(v2);
    }
    else
    {
      CFRelease(v1);
    }
  }
}

void ___ZN20HTTP2ConnectionCache15initCacheTimersEv_block_invoke_3(uint64_t a1)
{
}

void HTTP3ConnectionCacheWrapper::ingestTube(HTTP3ConnectionCacheWrapper *this, Tube **a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  nw_protocol_metadata_t v3 = (const HTTPConnectionCacheKey *)*((void *)this + 4);
  CFRange v4 = (const void *)Tube::copyKey((Tube *)a2);
  v40[2] = MEMORY[0x1E4F143A8];
  v40[3] = 3221225472;
  v40[4] = ___ZN20HTTP3ConnectionCache10ingestTubeEP4Tubeb_block_invoke;
  v40[5] = &__block_descriptor_40_e5_v8__0l;
  v40[6] = v4;
  HTTP3ConnectionCache::_entryFindOrCreate((HTTP3ConnectionCache *)v40, v3, v4);
  uint64_t v5 = v40[0];
  uint64_t v6 = *(void *)(v40[0] + 104);
  uint64_t v7 = *(void *)(v40[0] + 112);
  if (v6 == v7) {
    goto LABEL_13;
  }
  LOBYTE(v8) = 0;
  while (1)
  {
    uint64_t v9 = *(HTTP3Connection **)v6;
    uint64_t v10 = *(std::__shared_weak_count **)(v6 + 8);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v8) {
      break;
    }
    BOOL v8 = 1;
    if (v10) {
      goto LABEL_7;
    }
LABEL_8:
    v6 += 16;
    if (v6 == v7)
    {
      if (v8) {
        __assert_rtn("ingestTube", "HTTP3ConnectionCacheEntry.mm", 155, "!_willEnqueueRequests()");
      }
LABEL_13:
      long long v11 = *(_OWORD *)(v5 + 8);
      *(_OWORD *)uint64_t v39 = v11;
      uint64_t v12 = *(std::__shared_weak_count **)(v5 + 16);
      if (*((void *)&v11 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v11 + 1) + 16), 1uLL, memory_order_relaxed);
      }
      uint64_t v13 = (char *)operator new(0x4F0uLL);
      uint64_t v14 = v13;
      *(_OWORD *)(v13 + 8) = 0u;
      *(void *)uint64_t v13 = &unk_1ECFA6870;
      unint64_t v15 = v13 + 24;
      *((_OWORD *)v13 + 2) = 0u;
      *((void *)v13 + 3) = &unk_1ECF9D5F0;
      *((void *)v13 + 6) = &unk_1ECF9D640;
      BOOL v16 = v13 + 952;
      *((void *)v13 + 81) = 0x200000;
      *((void *)v13 + 82) = 0;
      *((_DWORD *)v13 + 166) = 0;
      *((_OWORD *)v13 + 42) = 0u;
      *((_OWORD *)v13 + 43) = 0u;
      *((_OWORD *)v13 + 44) = 0u;
      *((void *)v13 + 90) = 0;
      *((_DWORD *)v13 + 182) = 1065353216;
      *((_OWORD *)v13 + 46) = 0u;
      *((_OWORD *)v13 + 47) = 0u;
      *((_DWORD *)v13 + 192) = 1065353216;
      *(_OWORD *)(v13 + 776) = 0u;
      *(_OWORD *)(v13 + 792) = 0u;
      *((_DWORD *)v13 + 202) = 1065353216;
      *((_DWORD *)v13 + 204) = 100;
      *(_OWORD *)(v13 + 820) = 0u;
      *(_OWORD *)(v13 + 836) = 0u;
      *(void *)(v13 + 852) = 0x3F80000000000000;
      *((_OWORD *)v13 + 54) = 0u;
      *((_OWORD *)v13 + 55) = 0u;
      *((_DWORD *)v13 + 224) = 1065353216;
      *(_OWORD *)(v13 + 904) = 0u;
      *(_OWORD *)(v13 + 920) = 0u;
      *((_DWORD *)v13 + 234) = 1065353216;
      *(_OWORD *)(v13 + 952) = xmmword_1843D17B0;
      v13[944] = 0;
      *(_OWORD *)(v13 + 968) = 0u;
      *(_OWORD *)(v13 + 984) = 0u;
      *(_OWORD *)(v13 + 1000) = 0u;
      *(_OWORD *)(v13 + 1016) = 0u;
      *(_OWORD *)(v13 + 1032) = 0u;
      *(_OWORD *)(v13 + 1048) = 0u;
      *(_OWORD *)(v13 + 1064) = 0u;
      *(_OWORD *)(v13 + 1080) = 0u;
      *(_OWORD *)(v13 + 1096) = 0u;
      *(_OWORD *)(v13 + 1112) = 0u;
      *(_OWORD *)(v13 + 1128) = 0u;
      *(_OWORD *)(v13 + 1144) = 0u;
      *(_OWORD *)(v13 + 1160) = 0u;
      *((void *)v13 + 147) = 0;
      *((_OWORD *)v13 + 78) = 0u;
      *((_OWORD *)v13 + 77) = 0u;
      *((_OWORD *)v13 + 76) = 0u;
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        unint64_t v17 = (std::__shared_weak_count *)*((void *)v13 + 124);
        *((_OWORD *)v16 + 2) = *(_OWORD *)v39;
        if (v17) {
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      else
      {
        *(_OWORD *)(v13 + 984) = (unint64_t)v39[0];
      }
      uint64_t v18 = a2[17];
      if (v18) {
        *((unsigned char *)a2 + 240) = 0;
      }
      uint64_t v19 = a2[18];
      *(void *)&long long v20 = v18;
      *((void *)&v20 + 1) = v19;
      if (v19) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v19 + 1, 1uLL, memory_order_relaxed);
      }
      unint64_t v21 = (std::__shared_weak_count *)*((void *)v14 + 130);
      *((_OWORD *)v16 + 5) = v20;
      if (v21) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v21);
      }
      if (Tube::reportsDataStalls(a2[14])) {
        v14[944] |= 8u;
      }
      *((void *)v14 + 155) = (*(uint64_t (**)(void))(**((void **)v16 + 10) + 256))(*((void *)v16 + 10));
      uint64_t v22 = *((void *)v14 + 129);
      uint64_t v23 = *(void *)(v22 + 120);
      if (v23) {
        dispatch_retain(*(dispatch_object_t *)(v22 + 120));
      }
      BOOL v24 = (void *)*((void *)v14 + 128);
      *((void *)v14 + 128) = v23;

      *((void *)v14 + 150) = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
      uint64_t v25 = (*(uint64_t (**)(void))(**((void **)v14 + 129) + 104))(*((void *)v14 + 129));
      uint64_t v26 = 0;
      long long v27 = 0uLL;
      *(_OWORD *)(v14 + 168) = 0u;
      *((void *)v14 + 151) = 1000000 * v25;
      *(_OWORD *)(v14 + 104) = 0u;
      *(_OWORD *)(v14 + 120) = 0u;
      *(_OWORD *)(v14 + 264) = 0u;
      *(_OWORD *)(v14 + 280) = 0u;
      *(_OWORD *)(v14 + 152) = 0u;
      *(_OWORD *)(v14 + 136) = 0u;
      *((void *)v14 + 15) = v14 + 112;
      *((void *)v14 + 148) = 0;
      *((_DWORD *)v14 + 298) = 0;
      *(_OWORD *)(v14 + 56) = 0u;
      *(_OWORD *)(v14 + 72) = 0u;
      *(_OWORD *)(v14 + 88) = 0u;
      *(_OWORD *)(v14 + 184) = 0u;
      *(_OWORD *)(v14 + 200) = 0u;
      *(_OWORD *)(v14 + 216) = 0u;
      *(_OWORD *)(v14 + 232) = 0u;
      *(_OWORD *)(v14 + 248) = 0u;
      *((void *)v14 + 18) = v14 + 136;
      *((void *)v14 + 20) = v14 + 152;
      *((void *)v14 + 22) = v14 + 168;
      unsigned int v28 = *((_DWORD *)v14 + 238);
      uint64_t v29 = *((void *)v14 + 120);
      *(_OWORD *)(v14 + 616) = 0u;
      *(_OWORD *)(v14 + 632) = 0u;
      *(_OWORD *)(v14 + 584) = 0u;
      *(_OWORD *)(v14 + 600) = 0u;
      *(_OWORD *)(v14 + 552) = 0u;
      *(_OWORD *)(v14 + 568) = 0u;
      *(_OWORD *)(v14 + 520) = 0u;
      *(_OWORD *)(v14 + 536) = 0u;
      *(_OWORD *)(v14 + 488) = 0u;
      *(_OWORD *)(v14 + 504) = 0u;
      *(_OWORD *)(v14 + 456) = 0u;
      *(_OWORD *)(v14 + 472) = 0u;
      *(_OWORD *)(v14 + 424) = 0u;
      *(_OWORD *)(v14 + 440) = 0u;
      *(_OWORD *)(v14 + 392) = 0u;
      *(_OWORD *)(v14 + 408) = 0u;
      *(_OWORD *)(v14 + 360) = 0u;
      *(_OWORD *)(v14 + 376) = 0u;
      *(_OWORD *)(v14 + 328) = 0u;
      *(_OWORD *)(v14 + 344) = 0u;
      *(_OWORD *)(v14 + 296) = 0u;
      *(_OWORD *)(v14 + 312) = 0u;
      *((_DWORD *)v14 + 75) = v28;
      *((_DWORD *)v14 + 76) = v28;
      unsigned int v30 = v28 >> 5;
      int v31 = 2 * (v28 >> 5) - 1;
      *((_DWORD *)v14 + 82) = v31;
      *((_DWORD *)v14 + 83) = v31;
      *((_DWORD *)v14 + 78) = v29;
      *((_DWORD *)v14 + 79) = v30;
      *((void *)v14 + 42) = &HTTP3Connection::HTTP3Connection(Tube *,std::weak_ptr<HTTP3ConnectionCacheEntry>)::callbacks;
      *((void *)v14 + 48) = v14 + 376;
      do
      {
        uint64_t v32 = (double *)&v14[v26 + 392];
        uint64_t v33 = (uint64_t)&v14[v26 + 408];
        vst2q_f64(v32, *(float64x2x2_t *)&v27);
        v26 += 32;
      }
      while (v26 != 128);
      if (v12) {
        std::__shared_weak_count::__release_weak(v12);
      }
      v34 = (std::__shared_weak_count *)*((void *)v14 + 5);
      if (v34)
      {
        if (v34->__shared_owners_ == -1)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 1, 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 2, 1uLL, memory_order_relaxed);
          *((void *)v14 + 4) = v15;
          *((void *)v14 + 5) = v14;
          std::__shared_weak_count::__release_weak(v34);
          goto LABEL_37;
        }
      }
      else
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 1, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit((atomic_ullong *volatile)v14 + 2, 1uLL, memory_order_relaxed);
        *((void *)v14 + 4) = v15;
        *((void *)v14 + 5) = v14;
LABEL_37:
        std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v14);
      }
      std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&buffer, *((void *)v14 + 4), *((std::__shared_weak_count **)v14 + 5));
      uint64_t v35 = *((void *)v16 + 10);
      uint64_t v42 = buffer;
      v43 = v45;
      if (v45) {
        atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v35 + 184))(v35, &v42);
      if (v43) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v43);
      }
      uint64_t v36 = *((void *)v14 + 4);
      uint64_t v37 = *((void *)v14 + 5);
      if (v37) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v37 + 16), 1uLL, memory_order_relaxed);
      }
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 3321888768;
      aBlock[2] = ___ZN15HTTP3Connection10initializeEv_block_invoke;
      aBlock[3] = &__block_descriptor_48_ea8_32c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE_e5_v8__0l;
      aBlock[4] = v36;
      void aBlock[5] = v37;
      if (v37) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v37 + 16), 1uLL, memory_order_relaxed);
      }
      _Block_copy(aBlock);
      uint64_t v38 = operator new(0x58uLL);
      v38[1] = 0;
      v38[2] = 0;
      *uint64_t v38 = &unk_1ECFA6790;
      SmartBlockWithArgs<>::SmartBlockWithArgs();
    }
  }
  BOOL v8 = HTTP3Connection::willEnqueueRequests(v9);
  if (!v10) {
    goto LABEL_8;
  }
LABEL_7:
  std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  goto LABEL_8;
}

void sub_184144B54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, long long a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, char a17, uint64_t a18, void (*a19)(char *), uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,std::__shared_weak_count *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,std::__shared_weak_count *a41)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v41);
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  a19(&a17);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke(void *a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = *(void *)(v2 + 56);
  if (*(_DWORD *)v4 != 1) {
    goto LABEL_19;
  }
  uint64_t v5 = *(void *)(v3 + 136);
  if (v5) {
    *(unsigned char *)(v3 + 240) = 0;
  }
  uint64_t v6 = *(std::__shared_weak_count **)(v3 + 144);
  if (!v6)
  {
LABEL_7:
    uint64_t v7 = *(std::__shared_weak_count **)(v4 + 16);
    *(void *)(v4 + 8) = v5;
    *(void *)(v4 + 16) = v6;
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
    if (!v6) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  if (*(_DWORD *)v4 == 1)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_7;
  }
LABEL_10:
  std::__shared_weak_count::__release_shared[abi:nn180100](v6);
LABEL_11:
  uint64_t v8 = *(void *)(v2 + 56);
  if (*(_DWORD *)v8 == 1)
  {
    uint64_t v9 = *(void *)(v8 + 8);
    uint64_t v10 = *(std::__shared_weak_count **)(v8 + 16);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  *(void *)(v2 + 72) = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 256))(v9);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  if (!*(void *)(v2 + 56)) {
    goto LABEL_30;
  }
  uint64_t v3 = a1[6];
LABEL_19:
  *(void *)&long long v50 = 0;
  int v11 = nghttp2_option_new();
  if (v11)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v12 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v11;
      uint64_t v13 = "Failed to create http2 option %d";
LABEL_56:
      _os_log_fault_impl(&dword_184085000, v12, OS_LOG_TYPE_FAULT, v13, buf, 8u);
      goto LABEL_30;
    }
    goto LABEL_30;
  }
  nghttp2_option_set_no_auto_window_update();
  nghttp2_option_set_no_rfc9113_leading_and_trailing_ws_validation();
  *(_DWORD *)(v2 + 180) = 4096;
  *(unsigned char *)(v2 + 184) = 1;
  *(_OWORD *)(v2 + 188) = xmmword_1843D1770;
  if (sessionCallbacks(void)::onceToken != -1) {
    dispatch_once(&sessionCallbacks(void)::onceToken, &__block_literal_global_78);
  }
  int v14 = nghttp2_session_client_new2();
  MEMORY[0x18531C270](v50);
  if (!v14)
  {
    uint64_t v15 = Tube::copyWaiter((Tube *)v3);
    if (v15)
    {
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 3221225472;
      uint64_t v47 = ___ZN15HTTP2Connection15initializeHTTP2EP4Tube_block_invoke;
      unint64_t v48 = &__block_descriptor_40_e5_v8__0l;
      uint64_t v49 = v15;
      uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 80))(v15);
      if (v16) {
        *(_DWORD *)(v2 + 216) = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 168))(v16);
      }
      v47((uint64_t)aBlock);
    }
    unint64_t v17 = getenv("CFN_USE_HTTP2_SERVER_PUSH");
    if (!v17) {
      goto LABEL_70;
    }
    uint64_t v18 = buf;
    std::string::basic_string[abi:nn180100]<0>(buf, v17);
    char v19 = HIBYTE(v52);
    if (v52 >= 0) {
      long long v20 = &buf[HIBYTE(v52)];
    }
    else {
      long long v20 = (unsigned char *)(*(void *)buf + *(void *)&buf[8]);
    }
    if (v52 < 0) {
      uint64_t v18 = *(unsigned char **)buf;
    }
    if (v18 != v20)
    {
      do
      {
        unsigned char *v18 = __tolower((char)*v18);
        ++v18;
      }
      while (v18 != v20);
      char v19 = HIBYTE(v52);
    }
    if ((v19 & 0x80) == 0)
    {
      if (v19 != 1)
      {
        if (v19 == 3)
        {
          if (*(unsigned __int16 *)buf == 25977 && buf[2] == 115) {
            goto LABEL_73;
          }
        }
        else if (v19 == 4 && *(_DWORD *)buf == 1702195828)
        {
          goto LABEL_73;
        }
LABEL_70:
        *(void *)buf = 2;
        int v24 = *(_DWORD *)(v2 + 212);
        int v23 = *(_DWORD *)(v2 + 216);
        *(_DWORD *)&buf[8] = 4;
        *(_DWORD *)&buf[12] = v23;
        *(_DWORD *)&uint8_t buf[16] = 3;
        int v52 = v24;
        int v25 = nghttp2_submit_settings();
        goto LABEL_74;
      }
      if (buf[0] != 49) {
        goto LABEL_70;
      }
LABEL_73:
      int v27 = *(_DWORD *)(v2 + 212);
      int v26 = *(_DWORD *)(v2 + 216);
      *(_DWORD *)buf = 4;
      *(_DWORD *)&buf[4] = v26;
      *(_DWORD *)&buf[8] = 3;
      *(_DWORD *)&buf[12] = v27;
      int v25 = nghttp2_submit_settings();
LABEL_74:
      *(unsigned char *)(v2 + 596) = v25 == 0;
      int v28 = nghttp2_submit_window_update();
      if (v28 < 0)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        uint64_t v32 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v33 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2);
          v34 = _cfnAutoreleaseInDebug(v33);
          *(_DWORD *)buf = 136315394;
          *(void *)&buf[4] = v34;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v28;
          _os_log_error_impl(&dword_184085000, v32, OS_LOG_TYPE_ERROR, "Could not submit window update on [%s], error code: %d", buf, 0x12u);
        }
        goto LABEL_30;
      }
      *(_DWORD *)(v2 + 176) = 0;
      uint64_t v29 = *(int **)(v2 + 56);
      if (!v29)
      {
        BOOL v35 = 0;
        *(unsigned char *)(v2 + 597) = 0;
        goto LABEL_112;
      }
      int v30 = *v29;
      if (*v29 == 1)
      {
        uint64_t v36 = *((void *)v29 + 1);
        uint64_t v37 = (std::__shared_weak_count *)*((void *)v29 + 2);
        if (v37) {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v38 = (const void *)(*(uint64_t (**)(uint64_t, __CFString *))(*(void *)v36 + 216))(v36, @"kCFStreamPropertyConnectionIsCellular");
        if (v37) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v37);
        }
        if (v38)
        {
          CFTypeID v39 = CFGetTypeID(v38);
          if (v39 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            LOWORD(aBlock[0]) = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)aBlock, 2u);
          }
          BOOL v40 = *MEMORY[0x1E4F1CFD0] == (void)v38;
          CFRelease(v38);
          goto LABEL_95;
        }
      }
      else
      {
        if (v30 != 2)
        {
          *(unsigned char *)(v2 + 597) = 0;
          goto LABEL_98;
        }
        int v31 = (std::__shared_weak_count *)*((void *)v29 + 2);
        if (v31)
        {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          std::__shared_weak_count::__release_shared[abi:nn180100](v31);
        }
      }
      BOOL v40 = 0;
LABEL_95:
      uint64_t v29 = *(int **)(v2 + 56);
      *(unsigned char *)(v2 + 597) = v40;
      if (!v29) {
        goto LABEL_111;
      }
      int v30 = *v29;
LABEL_98:
      if (v30 == 2)
      {
        uint64_t v45 = (std::__shared_weak_count *)*((void *)v29 + 2);
        if (v45)
        {
          atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
          std::__shared_weak_count::__release_shared[abi:nn180100](v45);
        }
      }
      else if (v30 == 1)
      {
        uint64_t v41 = *((void *)v29 + 1);
        uint64_t v42 = (std::__shared_weak_count *)*((void *)v29 + 2);
        if (v42) {
          atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v43 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v41 + 216))(v41, 0x1EC09E838);
        if (v42) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v42);
        }
        if (v43)
        {
          CFTypeID v44 = CFGetTypeID(v43);
          if (v44 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            LOWORD(aBlock[0]) = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)aBlock, 2u);
          }
          BOOL v35 = *MEMORY[0x1E4F1CFD0] == (void)v43;
          CFRelease(v43);
LABEL_112:
          *(unsigned char *)(v2 + 598) = v35;
          CFRetain((CFTypeRef)(v2 - 16));
          CFRetain((CFTypeRef)(v2 - 16));
          operator new();
        }
      }
LABEL_111:
      BOOL v35 = 0;
      goto LABEL_112;
    }
    if (*(void *)&buf[8] == 1)
    {
      if (**(unsigned char **)buf == 49)
      {
LABEL_72:
        operator delete(*(void **)buf);
        goto LABEL_73;
      }
    }
    else if (*(void *)&buf[8] == 3)
    {
      if (**(_WORD **)buf == 25977 && *(unsigned char *)(*(void *)buf + 2) == 115) {
        goto LABEL_72;
      }
    }
    else if (*(void *)&buf[8] == 4 && **(_DWORD **)buf == 1702195828)
    {
      goto LABEL_72;
    }
    operator delete(*(void **)buf);
    goto LABEL_70;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v12 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v14;
    uint64_t v13 = "Failed to create http2 session %d";
    goto LABEL_56;
  }
LABEL_30:
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 0;
}

void sub_184145AE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v30);
  }
  _Unwind_Resume(exception_object);
}

void *CFURLCacheSetMemoryCapacity(void *result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t TypeID = CFURLCacheGetTypeID();
    uint64_t result = (void *)CFGetTypeID(v3);
    if ((void *)TypeID == result)
    {
      uint64_t v5 = v3[2];
      *(void *)(v5 + 168) = a2;
      v6.i64[0] = a2;
      v6.i64[1] = *(void *)(v5 + 176);
      *(int64x2_t *)(v5 + 184) = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(v6), *(double *)(v5 + 200)));
    }
    else
    {
      uint64_t v7 = (const char *)CFURLCacheSetMemoryCapacity::s;
      if (!CFURLCacheSetMemoryCapacity::s)
      {
        uint64_t v7 = sel_registerName("_nscfBridgeURLCacheSetMemoryCapacity:");
        CFURLCacheSetMemoryCapacity::s = (uint64_t)v7;
      }
      return objc_msgSend(v3, v7, a2);
    }
  }
  return result;
}

void CFURLCacheSetDiskCapacity(void *a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      if (a2 >= 5242880 || !a2)
      {
        uint64_t v6 = a1[2];
        *(void *)(v6 + 176) = a2;
        v7.i64[0] = *(void *)(v6 + 168);
        v7.i64[1] = a2;
        *(int64x2_t *)(v6 + 184) = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(v7), *(double *)(v6 + 200)));
        os_unfair_lock_lock((os_unfair_lock_t)(v6 + 124));
        uint64_t v8 = *(void *)(v6 + 128);
        if (v8) {
          *(void *)(v8 + 176) = a2;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 124));
      }
    }
    else
    {
      uint64_t v5 = (const char *)CFURLCacheSetDiskCapacity::s;
      if (!CFURLCacheSetDiskCapacity::s)
      {
        uint64_t v5 = sel_registerName("_nscfBridgeURLCacheSetDiskCapacity:");
        CFURLCacheSetDiskCapacity::s = (uint64_t)v5;
      }
      objc_msgSend(a1, v5, a2);
    }
  }
}

uint64_t __CFURLCacheCreateInternal(const __CFAllocator *a1, uint64_t a2, uint64_t a3, const __CFString *a4, int a5, int a6, char a7)
{
  block = (std::__shared_weak_count *)MEMORY[0x1E4F143A8];
  uint64_t v20 = 3221225472;
  unint64_t v21 = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2699;
  uint64_t v22 = &__block_descriptor_40_e5_v8__0l;
  int v23 = _URLCacheRegisterClass;
  if (_CFURLCacheClassRegistration != -1) {
    dispatch_once(&_CFURLCacheClassRegistration, &block);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 16) = 0;
  *(void *)(Instance + 24) = 0;
  if (a4)
  {
    if (a6) {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a4);
    }
    else {
      CFStringRef Copy = __CreatePathToCacheDirectory(a4, a5 != 0);
    }
    CFStringRef v15 = Copy;
  }
  else
  {
    CFStringRef v15 = 0;
  }
  uint64_t v16 = (std::__shared_weak_count *)operator new(0x298uLL);
  v16->__shared_owners_ = 0;
  v16->__shared_weak_owners_ = 0;
  v16->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6678;
  __CFURLCache::__CFURLCache((__CFURLCache *)&v16[1], (const _CFURLCache *)Instance, a2, a3, v15, a7);
  block = v16 + 1;
  uint64_t v20 = (uint64_t)v16;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&block, &v16[1].__shared_owners_, (uint64_t)&v16[1]);
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v17 = *(std::__shared_weak_count **)(Instance + 24);
  *(void *)(Instance + 16) = v16 + 1;
  *(void *)(Instance + 24) = v16;
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  }
  if (v15) {
    CFRelease(v15);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  return Instance;
}

void sub_184146080(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>(uint64_t a1, void *a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        uint64_t v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v5)
      {
        std::__shared_weak_count::__release_shared[abi:nn180100](v5);
      }
    }
  }
}

void __CFURLCache::__CFURLCache(__CFURLCache *this, const _CFURLCache *a2, uint64_t a3, uint64_t a4, const __CFString *a5, char a6)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1ECF9C318;
  *((void *)this + 6) = &unk_1ECF9C6A8;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 56), 0);
  *((_OWORD *)this + 14) = 0u;
  *((void *)this + 6) = &unk_1ECF9B530;
  *((_OWORD *)this + 15) = 0u;
  *((_DWORD *)this + 64) = 1065353216;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((unsigned char *)this + 632) = a6;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 18) = 0;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((void *)this + 55) = a2;
  *((unsigned char *)this + 40) = 0;
  *((void *)this + 25) = 0x3FA999999999999ALL;
  *((void *)this + 27) = 0;
  *((unsigned char *)this + 528) = 0;
  *((void *)this + 65) = 0;
  *((_WORD *)this + 60) = 0;
  *((_DWORD *)this + 31) = 0;
  *((void *)this + 16) = 0;
  *(_OWORD *)((char *)this + 536) = 0u;
  uint64_t v12 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *((void *)this + 17) = dispatch_queue_create("com.apple.CFNetwork.CacheDB-write", v12);
  if (pthread_mutex_init((pthread_mutex_t *)((char *)this + 456), 0)
    || pthread_mutex_init((pthread_mutex_t *)((char *)this + 312), 0)
    || pthread_mutex_init((pthread_mutex_t *)((char *)this + 376), 0)
    || pthread_mutex_init((pthread_mutex_t *)((char *)this + 552), 0))
  {
    return;
  }
  CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *((void *)this + 56) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  *((void *)this + 65) = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((void *)this + 67) = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (a5) {
    *((void *)this + 27) = CFStringCreateCopy(v13, a5);
  }
  if (a4) {
    BOOL v14 = a4 < 15001;
  }
  else {
    BOOL v14 = 0;
  }
  int v15 = v14;
  if (a3 && a3 < 1025)
  {
    *((void *)this + 21) = 0x400000;
    if (v15)
    {
      *((void *)this + 22) = 20971520;
      int64x2_t v16 = (int64x2_t)xmmword_1843D1760;
LABEL_25:
      *(int64x2_t *)((char *)this + 184) = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(v16), *((double *)this + 25)));
      goto LABEL_26;
    }
    *((void *)this + 22) = a4;
    a3 = 0x400000;
LABEL_23:
    if (a4)
    {
      v16.i64[0] = a3;
      v16.i64[1] = a4;
      goto LABEL_25;
    }
    goto LABEL_26;
  }
  *((void *)this + 21) = a3;
  if ((v15 & 1) == 0)
  {
    *((void *)this + 22) = a4;
    if (!a3) {
      goto LABEL_26;
    }
    goto LABEL_23;
  }
  *((void *)this + 22) = 20971520;
  if (a3)
  {
    int64x2_t v16 = vdupq_n_s64(0x1400000uLL);
    v16.i64[0] = a3;
    goto LABEL_25;
  }
LABEL_26:
  uint64_t v17 = MEMORY[0x1E4F143A8];
  *(_OWORD *)((char *)this + 616) = 0u;
  block[0] = v17;
  block[1] = 3221225472;
  block[2] = ___ZN12__CFURLCacheC2EPK11_CFURLCachellPK10__CFStringb_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  if (__CFURLCache::__CFURLCache(_CFURLCache const*,long,long,__CFString const*,BOOL)::onceToken != -1) {
    dispatch_once(&__CFURLCache::__CFURLCache(_CFURLCache const*,long,long,__CFString const*,BOOL)::onceToken, block);
  }
  if (*((unsigned char *)this + 632))
  {
    PathToCacheDirectory = (__CFString *)*((void *)this + 27);
    if (!PathToCacheDirectory)
    {
      PathToCacheDirectory = __CreatePathToCacheDirectory(0, 0);
      *((void *)this + 27) = PathToCacheDirectory;
    }
    if (CFStringGetFileSystemRepresentation(PathToCacheDirectory, buffer, 1024)) {
      __BuildPath(buffer);
    }
    id v19 = (id)[NSString stringWithFormat:@"%@/VaryState.db", *((void *)this + 27)];
    *((void *)this + 77) = v19;
    if (sqlite3_open((const char *)[v19 UTF8String], (sqlite3 **)this + 78))
    {
      *((void *)this + 78) = 0;
    }
    else
    {
      __retainStorageAssertion(*((void **)this + 17));
      __CFURLCache::_createVaryStateTable((sqlite3 **)this);
      __releaseStorageAssertion(v20);
    }
  }
}

void sub_184146508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  std::deque<__CFURLCacheNode *>::~deque[abi:nn180100](v14);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table(v13);
  *int v15 = a11;
  pthread_mutex_destroy(v12);
  uint64_t v17 = *(std::__shared_weak_count **)(v11 + 16);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  _Unwind_Resume(a1);
}

uint64_t Tube::reportsDataStalls(Tube *this)
{
  if (!this) {
    return 1;
  }
  uint64_t v1 = (*(uint64_t (**)(Tube *))(*(void *)this + 80))(this);
  if (!v1) {
    return 1;
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(v1 - 176) + 424);

  return v2();
}

uint64_t NotificationStation::registerForPropertyUpdates(uint64_t a1, const __CFString *value, void *a3, uint64_t a4)
{
  if (!*(unsigned char *)(a1 + 88))
  {
    uint64_t result = *(void *)(a1 + 72);
    if (!result) {
      return result;
    }
    uint64_t result = CFSetContainsValue((CFSetRef)result, value);
    if (!result) {
      return result;
    }
  }
  CFStringRef v33 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  uint64_t v8 = *(void *)a1;
  if (!*(void *)a1) {
    operator new();
  }
  if (value) {
    CFRetain(value);
  }
  v34[0] = value;
  v34[1] = (CFStringRef)CFTypeRefRelease<__CFString const*>;
  uint64_t v10 = std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::find<std::unique_ptr<__CFString const,void (*)(__CFString const*)>>(v8, v34);
  uint64_t v11 = v10;
  if (value)
  {
    CFTypeRefRelease<__CFString const*>(value);
    uint64_t v12 = v11;
    if (*(void *)a1 + 8 == v11)
    {
      CFRetain(value);
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v12 = v10;
    if (*(void *)a1 + 8 == v10) {
LABEL_14:
    }
      operator new();
  }
  uint64_t v13 = *(char ***)(v12 + 48);
  long long v14 = *(_OWORD *)a3;
  uint64_t v15 = a3[1];
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = v13[1];
  unint64_t v16 = (unint64_t)v13[2];
  if ((unint64_t)v17 >= v16)
  {
    uint64_t v19 = (v17 - *v13) >> 4;
    if ((unint64_t)(v19 + 1) >> 60) {
      abort();
    }
    long long v32 = v14;
    uint64_t v20 = v16 - (void)*v13;
    uint64_t v21 = v20 >> 3;
    if (v20 >> 3 <= (unint64_t)(v19 + 1)) {
      uint64_t v21 = v19 + 1;
    }
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v22 = v21;
    }
    if (v22 >> 60) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v23 = (char *)operator new(16 * v22);
    int v24 = &v23[16 * v19];
    *(_OWORD *)int v24 = v32;
    int v25 = *v13;
    int v26 = v13[1];
    if (v26 == *v13)
    {
      uint64_t v18 = v24 + 16;
      *uint64_t v13 = v24;
      v13[1] = v24 + 16;
      v13[2] = &v23[16 * v22];
    }
    else
    {
      int v27 = &v23[16 * v19];
      do
      {
        long long v28 = *((_OWORD *)v26 - 1);
        v26 -= 16;
        *((_OWORD *)v27 - 1) = v28;
        v27 -= 16;
        *(void *)int v26 = 0;
        *((void *)v26 + 1) = 0;
      }
      while (v26 != v25);
      int v26 = *v13;
      uint64_t v29 = v13[1];
      uint64_t v18 = v24 + 16;
      *uint64_t v13 = v27;
      v13[1] = v24 + 16;
      v13[2] = &v23[16 * v22];
      while (v29 != v26)
      {
        int v30 = (std::__shared_weak_count *)*((void *)v29 - 1);
        if (v30) {
          std::__shared_weak_count::__release_weak(v30);
        }
        v29 -= 16;
      }
    }
    if (v26) {
      operator delete(v26);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v17 = v14;
    uint64_t v18 = v17 + 16;
  }
  v13[1] = v18;
  if (a4)
  {
    int v31 = (const void *)(*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
    (*(void (**)(void, const __CFString *, const void *))(*(void *)*a3 + 16))(*a3, value, v31);
    if (v31) {
      CFRelease(v31);
    }
  }
  std::mutex::unlock(v33);
  return 1;
}

void sub_1841469B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, char a12, uint64_t a13, uint64_t a14)
{
}

uint64_t *std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::destroy(*(void ****)(v2 + 8));
    JUMPOUT(0x18531B6D0);
  }
  return result;
}

void ***std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>::reset[abi:nn180100](void ***result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1)
  {
    uint64_t v2 = (char *)*v1;
    if (*v1)
    {
      uint64_t v3 = (char *)v1[1];
      uint64_t v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          uint64_t v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
          if (v5) {
            std::__shared_weak_count::__release_weak(v5);
          }
          v3 -= 16;
        }
        while (v3 != v2);
        uint64_t v4 = *v1;
      }
      v1[1] = v2;
      operator delete(v4);
    }
    JUMPOUT(0x18531B6D0);
  }
  return result;
}

void CFTypeRefRelease<__CFString const*>(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::find<std::unique_ptr<__CFString const,void (*)(__CFString const*)>>(uint64_t a1, CFStringRef *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    CFComparisonResult v6 = CFStringCompare(*(CFStringRef *)(v3 + 32), *a2, 0);
    int64x2_t v7 = (uint64_t *)(v3 + 8);
    if (v6 != kCFCompareLessThan)
    {
      int64x2_t v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v5 == v2 || CFStringCompare(*a2, *(CFStringRef *)(v5 + 32), 0) == kCFCompareLessThan) {
    return v2;
  }
  return v5;
}

uint64_t PropertyObserver::propertyChanged(PropertyObserver *this, const __CFString *a2, const void *a3)
{
  uint64_t result = *((void *)this + 1);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const __CFString *, const void *))(result + 16))(result, a2, a3);
  }
  return result;
}

void SmartBlockWithArgs<>::SmartBlockWithArgs()
{
}

void sub_184146CBC(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void HTTPStallTimer::HTTPStallTimer(uint64_t a1, dispatch_object_t object, uint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1ECF9CD80;
  *(_OWORD *)(a1 + 24) = 0u;
  CFComparisonResult v6 = (NSObject **)(a1 + 24);
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 56) = 0;
  dispatch_retain(object);
  int64x2_t v7 = *v6;
  *CFComparisonResult v6 = object;
  if (v7) {
    dispatch_release(v7);
  }
  uint64_t v8 = *a3;
  uint64_t v9 = a3[1];
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 56);
  *(void *)(a1 + 48) = v8;
  *(void *)(a1 + 56) = v9;
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    uint64_t v8 = *(void *)(a1 + 48);
  }
  if (v8)
  {
    *(void *)(v8 + 8) = BlockHolderVar<>::invoke_normal;
    *(void *)(v8 + 16) = 0;
  }
  operator new();
}

void sub_184146DF8(_Unwind_Exception *a1)
{
  uint64_t v5 = (std::__shared_weak_count *)v1[7];
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100](v2, 0);
  CFComparisonResult v6 = v1[4];
  v1[4] = 0;
  if (v6) {
    dispatch_release(v6);
  }
  int64x2_t v7 = *v3;
  *uint64_t v3 = 0;
  if (v7) {
    dispatch_release(v7);
  }
  *uint64_t v1 = &unk_1ECF9B550;
  uint64_t v8 = (std::__shared_weak_count *)v1[2];
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    std::__tree<std::shared_ptr<void>>::destroy(*(void **)(v2 + 8));
    JUMPOUT(0x18531B6D0);
  }
  return result;
}

void HTTPStallTimer::setup(HTTPStallTimer *this)
{
  uint64_t v3 = *((void *)this + 1);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *((dispatch_queue_t *)this + 3));
  uint64_t v5 = *((void *)this + 4);
  *((void *)this + 4) = v4;
  if (v5)
  {
    dispatch_release(v5);
    uint64_t v4 = *((void *)this + 4);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3321888768;
  v6[2] = ___ZN14HTTPStallTimer5setupEv_block_invoke;
  v6[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14HTTPStallTimerEE_e5_v8__0l;
  v6[4] = v3;
  int64x2_t v7 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_source_set_event_handler(v4, v6);
  dispatch_source_set_timer(v4, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(v4);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t HTTPProtocol::reportsDataStalls(HTTPProtocol *this)
{
  uint64_t v1 = (void *)[*((id *)this + 10) _effectiveConfiguration];
  if (!v1) {
    return 1;
  }

  return [v1 _reportsDataStalls];
}

uint64_t IOConnWrapper::copyProperty(IOConnWrapper *this, const __CFString *a2)
{
  if (*(_DWORD *)this == 2) {
    return 0;
  }
  if (*(_DWORD *)this != 1) {
    __assert_rtn("copyProperty", "TCPIOConnectionTest.hpp", 217, "false");
  }
  uint64_t v2 = *(uint64_t (**)(void))(**((void **)this + 1) + 216);

  return v2();
}

uint64_t ___ZN15HTTP2Connection20initializeConnectionEv_block_invoke_45(uint64_t a1)
{
  return IOConnWrapper::copyProperty(*(IOConnWrapper **)(*(void *)(a1 + 32) + 56), @"__kCFStreamPropertyDoNotReuse");
}

void ___ZN15HTTP2Connection20initializeConnectionEv_block_invoke(uint64_t a1, int a2, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v5 = *(HTTP2Connection **)(a1 + 32);
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v10, 2u);
    }
    if ((CFTypeRef)*MEMORY[0x1E4F1CFD0] == cf)
    {
      uint64_t v7 = *(void *)(a1 + 40);
      uint64_t v8 = *(std::__shared_weak_count **)(v7 + 280);
      *(void *)(v7 + 272) = 0;
      *(void *)(v7 + 280) = 0;
      if (v8) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v8);
      }
      uint64_t v9 = *(void *)(a1 + 40);
      if (!*(unsigned char *)(v9 + 264))
      {
        *(unsigned char *)(v9 + 264) = 1;
        HTTP2Connection::stopIfNoOutstandingRequests(v5);
      }
    }
  }
}

uint64_t ___ZN15HTTP2Connection15initializeHTTP2EP4Tube_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

void HTTP3Framer::writeFrame(uint64_t a1, unint64_t a2, void *a3, int a4, void *a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a3;
  id v10 = a5;
  if (!v9) {
    __assert_rtn("writeFrame", "HTTP3Frame.mm", 254, "data");
  }
  CFStringRef v33 = v10;
  unint64_t __src = 0;
  unsigned int v12 = QUICUtilities::quic_vle_encode(a2, &__src, v11);
  memcpy(__dst, &__src, v12);
  size_t size = dispatch_data_get_size(v9);
  size_t v15 = QUICUtilities::quic_vle_encode(size, &__src, v14);
  memcpy(&__dst[v12], &__src, v15);
  size_t v16 = v15 + v12;
  uint64_t v18 = dispatch_data_create(__dst, v16, 0, 0);
  char v19 = *(unsigned char *)(a1 + 40);
  if (v19)
  {
    unint64_t v20 = *(void *)(a1 + 32);
    unint64_t buffer = 0;
    unsigned int v21 = QUICUtilities::quic_vle_encode(v20, &buffer, v17);
    unint64_t v22 = dispatch_data_create(&buffer, v21, 0, 0);
    dispatch_data_t concat = dispatch_data_create_concat(v22, v18);

    *(unsigned char *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 40) = 0;

    uint64_t v18 = concat;
  }
  data2 = v9;
  uint64_t v24 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16));
  id v25 = *(id *)(a1 + 56);
  uint64_t v26 = *(void *)(a1 + 16);
  uint64_t v27 = *(void *)(a1 + 56);
  uint64_t v28 = a4 ^ 1u;
  dispatch_data_t v29 = dispatch_data_create_concat(v18, data2);
  v35[0] = MEMORY[0x1E4F143A8];
  v35[1] = 3221225472;
  v35[2] = ___ZN11HTTP3Framer10writeFrameEN2H39FrameTypeEPU27objcproto16OS_dispatch_data8NSObjectbU13block_pointerFvm13CFStreamErrorE_block_invoke;
  v35[3] = &unk_1E5252ED8;
  id v30 = v33;
  char v40 = v19;
  id v36 = v25;
  id v37 = v30;
  size_t v38 = v16;
  uint64_t v39 = v24;
  int v31 = *(void (**)(uint64_t, uint64_t, uint64_t, dispatch_data_t, void *))(*(void *)v26 + 32);
  id v32 = v25;
  v31(v26, v27, v28, v29, v35);
}

void sub_184147448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

uint64_t QUICUtilities::quic_vle_encode(unint64_t this, unint64_t *a2, unint64_t *a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (this > 0x3F)
  {
    if (this >> 14)
    {
      if (this >> 30)
      {
        if (this >> 62)
        {
          uint64_t result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT);
          if (result)
          {
            int v5 = 134217984;
            unint64_t v6 = this;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "unable to encode quic vle value: %llu", (uint8_t *)&v5, 0xCu);
            return 0;
          }
        }
        else
        {
          *a2 = bswap64(this | 0xC000000000000000);
          return 8;
        }
      }
      else
      {
        *a2 = bswap32(this | 0x80000000);
        return 4;
      }
    }
    else
    {
      *a2 = bswap32(this | 0x4000) >> 16;
      return 2;
    }
  }
  else
  {
    *a2 = this;
    return 1;
  }
  return result;
}

uint64_t non-virtual thunk to'NWIOConnection::getConnectionID(NWIOConnection *this)
{
  return *((void *)this + 22);
}

void non-virtual thunk to'NWIOConnection::writeWithContext(uint64_t a1, NSObject *a2, int a3, NSObject *a4, uint64_t a5)
{
}

void std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::destroy(void ***a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::destroy(a1[1]);
    std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>::reset[abi:nn180100](a1 + 6);
    uint64_t v2 = a1[4];
    a1[4] = 0;
    if (v2) {
      ((void (*)(void))a1[5])();
    }
    operator delete(a1);
  }
}

void ___ZN15HTTP3Connection29_requestNewServerStreamHandleEv_block_invoke(uint64_t a1, void *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  id v12 = a2;
  id v13 = a3;
  if (v12 && !a6)
  {
    uint64_t v14 = *(void *)(a1 + 32);
    size_t v15 = v12;
    size_t v16 = v13;
    uint64_t v17 = v16;
    if (v16 && (size_t size = dispatch_data_get_size(v16)) != 0)
    {
      size_t v19 = size;
      if (*(void *)(v14 + 992)) {
        HTTP3Connection::_stopStallRecovery((HTTP3Connection *)v14);
      }
      uint64_t v40 = 0;
      uint64_t v41 = &v40;
      uint64_t v42 = 0x2020000000;
      char v43 = 0;
      applier[0] = MEMORY[0x1E4F143A8];
      applier[1] = 3221225472;
      applier[2] = ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke;
      applier[3] = &unk_1E5257648;
      applier[4] = &v40;
      dispatch_data_apply(v17, applier);
      dispatch_data_t subrange = dispatch_data_create_subrange(v17, 1uLL, v19);
      switch(*((unsigned char *)v41 + 24))
      {
        case 0:
          if (!HTTP3Framer::setReadHandleBeforeReading(*(void *)(v14 + 1024), v15, subrange, 0))
          {
            *(void *)(v14 + 1160) = 4;
            *(_DWORD *)(v14 + 1168) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v14, 259, 0);
            int v30 = 1;
            goto LABEL_34;
          }
          HTTP3Connection::_readControlStream((HTTP3Connection *)v14);
          break;
        case 1:
          std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v37, *(void *)(v14 + 8), *(std::__shared_weak_count **)(v14 + 16));
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 3321888768;
          *(void *)&uint8_t buf[16] = ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke_2;
          uint64_t v45 = &unk_1ECFA9EC8;
          uint64_t v47 = v14;
          uint64_t v48 = v37;
          uint64_t v49 = v38;
          if (v38) {
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v46 = v15;
          HTTP3Connection::_readPushID(v14, v46, subrange, a4, buf);

          if (v49) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v49);
          }
          if (v38) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v38);
          }
          break;
        case 2:
          if (*(void *)(v14 + 1048))
          {
            *(void *)(v14 + 1160) = 4;
            *(_DWORD *)(v14 + 1168) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v14, 259, 0);
            int v30 = 17;
            goto LABEL_34;
          }
          objc_storeStrong((id *)(v14 + 1048), a2);
          HTTP3Connection::_readEncoderStream(v14, subrange);
          break;
        case 3:
          if (*(void *)(v14 + 1064))
          {
            *(void *)(v14 + 1160) = 4;
            *(_DWORD *)(v14 + 1168) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v14, 259, 0);
            int v30 = 33;
LABEL_34:
            HTTP3Connection::reportServerProtocolViolation(v14, v30, -1);
          }
          else
          {
            objc_storeStrong((id *)(v14 + 1064), a2);
            HTTP3Connection::_readDecoderStream(v14, subrange);
          }
          break;
        default:
          int v31 = CFN_LOG_h3connection();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
          {
            uint64_t v32 = *(void *)(v14 + 1216);
            int v33 = *((unsigned __int8 *)v41 + 24);
            *(_DWORD *)buf = 134218496;
            *(void *)&buf[4] = v14;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v32;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v45) = v33;
            _os_log_impl(&dword_184085000, v31, OS_LOG_TYPE_INFO, "%p %llu unknown incoming stream type (0x%02x)", buf, 0x1Cu);
          }

          v34 = nw_protocol_copy_quic_connection_definition();
          nw_protocol_metadata_t v35 = nw_content_context_copy_protocol_metadata(v15, v34);

          id v36 = (void *)nw_quic_connection_copy_stream_metadata();
          nw_quic_stream_set_application_error();
          (*(void (**)(void, NSObject *))(**(void **)(v14 + 1008) + 80))(*(void *)(v14 + 1008), v15);

          break;
      }

      _Block_object_dispose(&v40, 8);
    }
    else
    {
      id v25 = CFN_LOG_h3connection();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        uint64_t v26 = *(void *)(v14 + 1216);
        *(_DWORD *)buf = 134218240;
        *(void *)&buf[4] = v14;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v26;
        _os_log_impl(&dword_184085000, v25, OS_LOG_TYPE_INFO, "%p %llu ignore empty incoming stream", buf, 0x16u);
      }

      uint64_t v27 = nw_protocol_copy_quic_connection_definition();
      nw_protocol_metadata_t v28 = nw_content_context_copy_protocol_metadata(v15, v27);

      dispatch_data_t v29 = (void *)nw_quic_connection_copy_stream_metadata();
      nw_quic_stream_set_application_error();
      (*(void (**)(void, NSObject *))(**(void **)(v14 + 1008) + 80))(*(void *)(v14 + 1008), v15);
    }
    unsigned int v21 = *(HTTP3Connection **)(a1 + 32);
    goto LABEL_37;
  }
  unsigned int v21 = *(HTTP3Connection **)(a1 + 32);
  if (a5 == 1 && a6 == 54)
  {
LABEL_37:
    HTTP3Connection::_requestNewServerStreamHandle(v21);
    goto LABEL_38;
  }
  v51.domain = a5;
  *(void *)&v51.error = a6;
  if (HTTP3Connection::checkAndPerformFallback(v21, v51))
  {
    unint64_t v22 = CFN_LOG_h3connection();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = *(void *)(a1 + 32);
      uint64_t v24 = *(void *)(v23 + 1216);
      *(_DWORD *)buf = 134218240;
      *(void *)&buf[4] = v23;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v24;
      _os_log_impl(&dword_184085000, v22, OS_LOG_TYPE_DEFAULT, "%p %llu New stream fallback triggered", buf, 0x16u);
    }
  }
  else
  {
    HTTP3Connection::_cleanupConnection(*(HTTP3Connection **)(a1 + 32), -1, 0);
  }
LABEL_38:
}

void sub_184147BB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void HTTP3Connection::_requestNewServerStreamHandle(HTTP3Connection *this)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v6, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
  uint64_t v2 = *((void *)this + 126);
  if (v2 && (*((unsigned char *)this + 920) & 4) == 0)
  {
    uint64_t v3 = *MEMORY[0x1E4F38C70];
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3321888768;
    v4[2] = ___ZN15HTTP3Connection29_requestNewServerStreamHandleEv_block_invoke;
    v4[3] = &__block_descriptor_48_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e83_v44__0__NSObject_OS_nw_content_context__8__NSObject_OS_dispatch_data__16B24___qi_28l;
    v4[4] = v6;
    int v5 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v2 + 56))(v2, v3, 1, 132000, v4);
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    }
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
}

void sub_184147D68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  size_t v16 = *(std::__shared_weak_count **)(v14 - 24);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a4;
  return 0;
}

NSObject *HTTP3Connection::_newClientUnidirectionalStreamHandle(HTTP3Connection *this, const char *a2)
{
  if (HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::onceToken != -1) {
    dispatch_once(&HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::onceToken, &__block_literal_global_50);
  }
  connection_metadata = nw_quic_create_connection_metadata();
  nw_quic_connection_metadata_set_stream_options();
  uint64_t v4 = nw_content_context_create((const char *)this);
  nw_content_context_set_metadata_for_protocol(v4, connection_metadata);

  return v4;
}

void sub_184147E34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTP3Connection10initializeEv_block_invoke_8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5 && (uint64_t v6 = *(void *)(v5 + 1008)) != 0) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 216))(v6, 0x1EC09E8A8);
  }
  else {
    uint64_t v7 = 0;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  return v7;
}

void sub_184147EE8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP3Connection10initializeEv_block_invoke_3(uint64_t a1, int a2, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)id v10 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v10, 2u);
    }
    if ((CFTypeRef)*MEMORY[0x1E4F1CFD0] == cf)
    {
      uint64_t v6 = *(std::__shared_weak_count **)(a1 + 40);
      if (v6)
      {
        uint64_t v7 = std::__shared_weak_count::lock(v6);
        if (v7)
        {
          uint64_t v8 = v7;
          uint64_t v9 = *(void *)(a1 + 32);
          if (v9)
          {
            *(unsigned char *)(v9 + 920) |= 2u;
            if (*(void *)(v9 + 1136) == *(void *)(v9 + 1144)) {
              HTTP3Connection::_cleanupConnection((HTTP3Connection *)v9, 256, 0);
            }
          }
          std::__shared_weak_count::__release_shared[abi:nn180100](v8);
        }
      }
    }
  }
}

void sub_184147FF4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::getQUICPeerIdleTimeout(nw_connection_t *this)
{
  uint64_t v2 = nw_protocol_copy_quic_connection_definition();
  nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(this[34], v2);
  if (!v3)
  {
    uint64_t peer_idle_timeout = 0;
    if (!v2) {
      return peer_idle_timeout;
    }
    goto LABEL_3;
  }
  uint64_t peer_idle_timeout = nw_quic_connection_get_peer_idle_timeout();
  nw_release(v3);
  if (v2) {
LABEL_3:
  }
    nw_release(v2);
  return peer_idle_timeout;
}

void sub_18414807C(_Unwind_Exception *a1)
{
  nw_release(v2);
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

BOOL HTTP3Framer::setReadHandleBeforeReading(uint64_t a1, void *a2, void *a3, int a4)
{
  id v8 = a2;
  id v9 = a3;
  uint64_t v10 = *(void *)(a1 + 48);
  if (!v10)
  {
    objc_storeStrong((id *)(a1 + 48), a2);
    objc_storeStrong((id *)(a1 + 136), a3);
    if (a4)
    {
      *(void *)(a1 + 144) = 4;
      *(_DWORD *)(a1 + 152) = -2300;
    }
  }

  return v10 == 0;
}

uint64_t ___ZN25HTTP3ConnectionCacheEntry10ingestTubeEP4Tubeb_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    (*(void (**)(uint64_t, void))(*(void *)result + 56))(result, 0);
    nw_protocol_metadata_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 32) + 48);
    return v3();
  }
  return result;
}

uint64_t ___ZN20HTTP3ConnectionCache10ingestTubeEP4Tubeb_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

void HTTP3Connection::_readDecoderStream(uint64_t a1, void *a2)
{
  nw_protocol_metadata_t v3 = a2;
  applier[0] = MEMORY[0x1E4F143A8];
  applier[1] = 3221225472;
  applier[2] = ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  applier[3] = &__block_descriptor_40_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
  applier[4] = a1;
  dispatch_data_apply(v3, applier);
  if (*(void *)(a1 + 1008) && (*(unsigned char *)(a1 + 920) & 4) == 0)
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v8, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
    uint64_t v4 = *(void *)(a1 + 1008);
    uint64_t v5 = *(void *)(a1 + 1064);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3321888768;
    v6[2] = ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2;
    v6[3] = &__block_descriptor_56_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e83_v44__0__NSObject_OS_nw_content_context__8__NSObject_OS_dispatch_data__16B24___qi_28l;
    v6[4] = a1;
    void v6[5] = v8;
    uint64_t v7 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v4 + 56))(v4, v5, 1, 132000, v6);
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
    }
  }
}

void sub_184148350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a17);
  }

  _Unwind_Resume(a1);
}

void sub_184148458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

uint64_t CFURLDataDecoderIsFinishedDecoding(uint64_t a1)
{
  if (URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder != -1) {
    dispatch_once(&URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder, &__block_literal_global_2913);
  }
  if (a1) {
    uint64_t v2 = a1 + 16;
  }
  else {
    uint64_t v2 = 0;
  }
  nw_protocol_metadata_t v3 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 56))(v2) + 32);

  return v3();
}

uint64_t ___ZN12HTTPProtocol14bytesAvailableEPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, const UInt8 *a4, uint64_t a5)
{
  if (!a5) {
    return 1;
  }
  uint64_t v7 = *(void *)(a1 + 32);
  int v8 = *(_DWORD *)(v7 + 200);
  *(void *)(v7 + 520) += a5;
  if (v8 - 5 < 2 || v8 == 3)
  {
    if (*(void *)(v7 + 216)
      || (CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)(v7 - 16)),
          uint64_t v11 = CFURLDataDecoderCreateWithContentEncoding(v10, v8),
          (*(void *)(v7 + 216) = v11) != 0))
    {
      id v12 = *(const void **)(v7 + 224);
      if (v12)
      {
        CFIndex v13 = CFDataGetLength(*(CFDataRef *)(v7 + 224)) + a5;
        CFAllocatorRef v14 = CFGetAllocator(v12);
        MutableCFStringRef Copy = CFDataCreateMutableCopy(v14, v13, (CFDataRef)v12);
        CFDataRef v16 = MutableCopy;
        if (MutableCopy)
        {
          CFDataAppendBytes(MutableCopy, a4, a5);
          CFIndex Length = CFDataGetLength(v16);
          if (Length != CFDataGetLength((CFDataRef)v12) + a5
            && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "unable to append to this buffer", buf, 2u);
          }
        }
        uint64_t v18 = *(const void **)(v7 + 224);
        *(void *)(v7 + 224) = 0;
        if (v18) {
          CFRelease(v18);
        }
        if (!v16) {
          goto LABEL_38;
        }
      }
      else
      {
        CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)(v7 - 16));
        CFDataRef v16 = CFDataCreateWithBytesNoCopy(v23, a4, a5, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
        if (!v16)
        {
LABEL_38:
          uint64_t v22 = -998;
          goto LABEL_39;
        }
      }
      buf[0] = 0;
      uint64_t v24 = CFURLDataDecoderDecodeData(*(void *)(v7 + 216), (uint64_t)v16, (uint64_t)buf);
      if (v24) {
        BOOL v25 = 1;
      }
      else {
        BOOL v25 = buf[0] == 0;
      }
      if (!v25)
      {
        CFAllocatorRef v36 = CFGetAllocator((CFTypeRef)(v7 - 16));
        *(void *)(v7 + 224) = CFDataCreateCopy(v36, v16);
        CFDataRef v37 = v16;
        goto LABEL_94;
      }
      CFDataRef v21 = (const __CFData *)v24;
      CFRelease(v16);
      if (!v21)
      {
        uint64_t v22 = -1015;
        goto LABEL_39;
      }
      goto LABEL_30;
    }
LABEL_22:
    uint64_t v22 = -1016;
LABEL_39:
    HTTPProtocol::sendError((HTTPProtocol *)v7, (const __CFString *)v22);
    HTTPProtocol::cleanupStreams((HTTPProtocol *)v7);
    return 0;
  }
  if (v8 != 2) {
    goto LABEL_22;
  }
  CFAllocatorRef v20 = CFGetAllocator((CFTypeRef)(v7 - 16));
  CFDataRef v21 = CFDataCreate(v20, a4, a5);
  if (!v21) {
    goto LABEL_38;
  }
LABEL_30:
  if (!*(void *)(v7 + 232))
  {
    if (v8 <= 6u && ((1 << v8) & 0x68) != 0)
    {
      *(void *)(v7 + 528) += CFDataGetLength(v21);
      [*(id *)(v7 + 80) _appendCountOfPendingBytesReceivedEncoded:a5];
    }
    HTTPProtocol::sendDidLoadData((HTTPProtocol *)v7, (char *)v21, a5);
    goto LABEL_93;
  }
  BytePtr = (UInt8 *)CFDataGetBytePtr(v21);
  CFIndex v27 = CFDataGetLength(v21);
  nw_protocol_metadata_t v28 = CFDataGetBytePtr(*(CFDataRef *)(v7 + 240));
  CFIndex v29 = CFDataGetLength(*(CFDataRef *)(v7 + 240));
  int v30 = CFDataGetBytePtr(*(CFDataRef *)(v7 + 232));
  size_t v31 = CFDataGetLength(*(CFDataRef *)(v7 + 232));
  CFDataRef v32 = *(const __CFData **)(v7 + 256);
  CFDataRef v63 = v21;
  size_t v64 = v29;
  uint64_t v65 = v28;
  if (v32)
  {
    CFIndex v33 = CFDataGetLength(v32);
    CFDataAppendBytes(*(CFMutableDataRef *)(v7 + 256), BytePtr, v27);
    v34 = (UInt8 *)CFDataGetBytePtr(*(CFDataRef *)(v7 + 256));
    CFIndex v27 = CFDataGetLength(*(CFDataRef *)(v7 + 256));
    if (*v34 == *v28) {
      int64_t v35 = v29;
    }
    else {
      int64_t v35 = v31;
    }
    if (v33 <= v35) {
      BytePtr = v34;
    }
    else {
      BytePtr = &v34[v33 - v35];
    }
  }
  else
  {
    v34 = BytePtr;
  }
  v67 = 0;
  *(void *)buf = 0;
  uint64_t v39 = &v34[v27];
  CFTypeRef cf = (CFTypeRef)(v7 - 16);
  LOBYTE(v40) = 1;
  while (1)
  {
    *(_WORD *)uint64_t v66 = 0;
    if (v40)
    {
      DelimiterInBytes = _findDelimiterInBytes(BytePtr, v39 - BytePtr, v65, v64, (const unsigned __int8 **)&v67, v66);
      BOOL v40 = DelimiterInBytes != &BytePtr[v27];
    }
    else
    {
      BOOL v40 = 0;
      DelimiterInBytes = 0;
    }
    uint64_t v42 = *(const void **)(v7 + 232);
    if (v42 == *(const void **)(v7 + 240))
    {
      char v43 = 0;
      uint64_t v45 = v67;
LABEL_67:
      uint64_t v44 = v42;
      goto LABEL_68;
    }
    char v43 = _findDelimiterInBytes(BytePtr, v39 - BytePtr, v30, v31, (const unsigned __int8 **)buf, &v66[1]);
    uint64_t v42 = *(const void **)(v7 + 232);
    uint64_t v44 = *(const void **)(v7 + 240);
    uint64_t v45 = v67;
    if (v42 == v44) {
      goto LABEL_67;
    }
    if (v67) {
      BOOL v46 = v40;
    }
    else {
      BOOL v46 = 0;
    }
    if (!v46 || *(void *)buf == 0 || DelimiterInBytes >= v43)
    {
      uint64_t v45 = *(unsigned __int8 **)buf;
      DelimiterInBytes = v43;
      goto LABEL_76;
    }
LABEL_68:
    *(void *)buf = v45;
    v66[1] = v66[0];
    if (v42 != v44 && v43 - DelimiterInBytes == 2)
    {
      if (v42)
      {
        CFRelease(v42);
        uint64_t v44 = *(const void **)(v7 + 240);
      }
      size_t v31 = v64;
      if (v44) {
        CFTypeRef v49 = CFRetain(v44);
      }
      else {
        CFTypeRef v49 = 0;
      }
      *(void *)(v7 + 232) = v49;
      int v30 = v65;
    }
LABEL_76:
    if (DelimiterInBytes != v34)
    {
      uint64_t v50 = *(unsigned int *)(v7 + 192);
      unint64_t v51 = v50 | ((unint64_t)*(unsigned __int16 *)(v7 + 196) << 32);
      if ((v50 & 0x400) != 0)
      {
        HTTPProtocol::fixupAndSendMultiPartData((HTTPProtocol *)v7, v34, DelimiterInBytes - v34, (v50 >> 12) & 1);
        unint64_t v51 = *(unsigned int *)(v7 + 192) | ((unint64_t)*(unsigned __int16 *)(v7 + 196) << 32);
      }
      *(_WORD *)(v7 + 196) = WORD2(v51);
      *(_DWORD *)(v7 + 192) = v51 & 0xFFFFEFFF;
    }
    if (!v45) {
      break;
    }
    *(_DWORD *)(v7 + 192) |= 0x1400u;
    if (v66[1])
    {
      HTTPProtocol::fixupAndSendMultiPartData((HTTPProtocol *)v7, 0, 0, 1);
      v56 = *(void **)(v7 + 832);
      if (v56)
      {
        Property = (CFAbsoluteTime *)objc_getProperty(v56, v55, 96, 1);
        if (Property)
        {
          uint64_t v58 = Property;
          Property[25] = CFAbsoluteTimeGetCurrent();
          *((_OWORD *)v58 + 2) = *((_OWORD *)v58 + 8);
        }
      }
      URLProtocol::sendDidFinishLoading((URLProtocol *)v7);
LABEL_92:
      CFDataRef v21 = v63;
      goto LABEL_93;
    }
    CFIndex v27 = v39 - v45;
    BytePtr = v45;
    v34 = v45;
  }
  if (DelimiterInBytes == v39)
  {
    v59 = *(const void **)(v7 + 256);
    *(void *)(v7 + 256) = 0;
    CFDataRef v21 = v63;
    if (v59) {
      CFRelease(v59);
    }
  }
  else
  {
    if (DelimiterInBytes != BytePtr)
    {
      CFAllocatorRef v52 = CFGetAllocator(cf);
      Mutable = CFDataCreateMutable(v52, 0);
      CFDataAppendBytes(Mutable, DelimiterInBytes, v39 - DelimiterInBytes);
      uint64_t v54 = *(const void **)(v7 + 256);
      if (v54) {
        CFRelease(v54);
      }
      *(void *)(v7 + 256) = Mutable;
      goto LABEL_92;
    }
    CFDataRef v21 = v63;
    if (!*(void *)(v7 + 256))
    {
      CFAllocatorRef v60 = CFGetAllocator(cf);
      v61 = CFDataCreateMutable(v60, 0);
      *(void *)(v7 + 256) = v61;
      CFDataAppendBytes(v61, v34, v27);
    }
  }
LABEL_93:
  CFDataRef v37 = v21;
LABEL_94:
  CFRelease(v37);
  return 1;
}

dispatch_data_t GZipDataDecoder::decodeData(GZipDataDecoder *this, const __CFAllocator *a2, CFDataRef theData, unsigned __int8 *a4)
{
  CFDataRef v7 = 0;
  LODWORD(v10) = 0;
  if (!*((unsigned char *)this + 121))
  {
    int v8 = gzipDecodeHeader(theData, (uInt *)&v10, 0, 0, 0, a4);
    *((unsigned char *)this + 121) = v8;
    if (!v8) {
      return 0;
    }
    CFDataRef v7 = (const __CFData *)v10;
  }
  *a4 = 0;
  return createGzipDecodedData((z_stream_s *)((char *)this + 8), (unsigned __int8 *)this + 122, theData, v7);
}

dispatch_data_t createGzipDecodedData(z_stream_s *a1, unsigned __int8 *a2, CFDataRef theData, const __CFData *a4)
{
  if (*a2)
  {
    dispatch_data_t subrange = (dispatch_data_t)MEMORY[0x1E4F14410];
    dispatch_retain(MEMORY[0x1E4F14410]);
  }
  else
  {
    int v5 = (int)a4;
    a1->next_in = (Bytef *)&CFDataGetBytePtr(theData)[(int)a4];
    a1->avail_in = CFDataGetLength(theData) - v5;
    a1->uInt avail_out = 0x4000;
    uint64_t alloc = dispatch_data_create_alloc();
    if (alloc)
    {
      CFAllocatorRef v10 = alloc;
      uInt v11 = 0x4000;
      while (1)
      {
        int v12 = inflate(a1, 0);
        if (v12 != -5)
        {
          if (v12) {
            break;
          }
        }
        uInt avail_out = a1->avail_out;
        if (avail_out) {
          goto LABEL_12;
        }
        v11 <<= v11 >> 26 == 0;
        a1->uInt avail_out = v11;
        CFAllocatorRef v14 = dispatch_data_create_alloc();
        if (!v14) {
          goto LABEL_13;
        }
        size_t v15 = v14;
        dispatch_data_t concat = dispatch_data_create_concat(v10, v14);
        dispatch_release(v15);
        dispatch_release(v10);
        CFAllocatorRef v10 = concat;
      }
      if (v12 == 1)
      {
        *a2 = 1;
        uInt avail_out = a1->avail_out;
LABEL_12:
        size_t size = dispatch_data_get_size(v10);
        dispatch_data_t subrange = dispatch_data_create_subrange(v10, 0, size - avail_out);
        dispatch_release(v10);
        return subrange;
      }
LABEL_13:
      dispatch_release(v10);
    }
    return 0;
  }
  return subrange;
}

uint64_t CFURLDataDecoderDecodeData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder != -1) {
    dispatch_once(&URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder, &__block_literal_global_2913);
  }
  if (a1) {
    uint64_t v6 = a1 + 16;
  }
  else {
    uint64_t v6 = 0;
  }
  CFDataRef v7 = (const void *)(v6 - 16);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 56))(v6);
  CFAllocatorRef v9 = CFGetAllocator(v7);
  CFAllocatorRef v10 = *(uint64_t (**)(uint64_t, CFAllocatorRef, uint64_t, uint64_t))(*(void *)v8 + 24);

  return v10(v8, v9, a2, a3);
}

uint64_t GZIPDataDecoderHolder::decoder(GZIPDataDecoderHolder *this)
{
  return (uint64_t)this + 8;
}

uint64_t gzipDecodeHeader(const __CFData *a1, uInt *a2, const __CFAllocator *a3, const __CFString **a4, unint64_t *a5, unsigned __int8 *a6)
{
  int Length = CFDataGetLength(a1);
  BytePtr = CFDataGetBytePtr(a1);
  if (Length <= 9) {
    goto LABEL_2;
  }
  size_t v15 = BytePtr;
  uint64_t result = 0;
  *a6 = 0;
  if (*v15 == 31)
  {
    if (v15[1] != 139) {
      return 0;
    }
    if (v15[2] != 8) {
      return 0;
    }
    unsigned int v16 = v15[3];
    if (v16 > 0x1F) {
      return 0;
    }
    if ((v16 & 4) != 0)
    {
      if (Length <= 0xB) {
        goto LABEL_2;
      }
      uInt v17 = *((unsigned __int16 *)v15 + 5) + 12;
      if (v17 > Length) {
        goto LABEL_2;
      }
    }
    else
    {
      uInt v17 = 10;
    }
    if ((v16 & 8) != 0)
    {
      uint64_t v19 = v17;
      uint64_t v18 = (const char *)&v15[v17];
      if ((int)v17 <= Length) {
        uint64_t v20 = Length;
      }
      else {
        uint64_t v20 = v17;
      }
      while (v20 != v19)
      {
        uInt v17 = v19 + 1;
        if (!v15[v19++]) {
          goto LABEL_18;
        }
      }
      goto LABEL_2;
    }
    uint64_t v18 = 0;
LABEL_18:
    if ((v16 & 0x10) != 0)
    {
      uint64_t v22 = (int)v17;
      if ((int)v17 <= Length) {
        uint64_t v23 = Length;
      }
      else {
        uint64_t v23 = v17;
      }
      while (v23 != v22)
      {
        uInt v17 = v22 + 1;
        if (!v15[v22++]) {
          goto LABEL_24;
        }
      }
      goto LABEL_2;
    }
LABEL_24:
    if ((v16 & 2) == 0) {
      goto LABEL_25;
    }
    if ((int)(v17 + 2) <= Length)
    {
      unsigned __int16 v25 = crc32(0, v15, v17);
      int v26 = *(unsigned __int16 *)&v15[v17];
      v17 += 2;
      if (v26 == v25)
      {
LABEL_25:
        if (a2) {
          *a2 = v17;
        }
        if (a5) {
          *a5 = *((int *)v15 + 1);
        }
        if (a4)
        {
          if (v18) {
            *a4 = CFStringCreateWithCString(a3, v18, 0x500u);
          }
          else {
            *a4 = 0;
          }
        }
        return 1;
      }
      return 0;
    }
LABEL_2:
    uint64_t result = 0;
    *a6 = 1;
  }
  return result;
}

_OWORD *CFURLDataDecoderCreateWithContentEncoding(const __CFAllocator *a1, int a2)
{
  switch(a2)
  {
    case 6:
      if (URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder != -1) {
        dispatch_once(&URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder, &__block_literal_global_2913);
      }
      uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
      nw_protocol_metadata_t v3 = Instance;
      if (Instance)
      {
        Instance[1] = 0u;
        nw_protocol_metadata_t v3 = Instance + 1;
        Instance[3] = 0u;
        Instance[4] = 0u;
        Instance[2] = 0u;
      }
      v3[2] = 0u;
      v3[3] = 0u;
      v3[1] = 0u;
      *(void *)nw_protocol_metadata_t v3 = &unk_1ECFA1B80;
      uint64_t v4 = (void *)v3 + 1;
      *((void *)v3 + 1) = &unk_1ECF9E100;
      *((unsigned char *)v3 + 56) = compression_stream_init((compression_stream *)(v3 + 1), COMPRESSION_STREAM_DECODE, COMPRESSION_BROTLI) == COMPRESSION_STATUS_OK;
      int v5 = (uint64_t (**)(void))&unk_1ECFA2850;
      *(void *)nw_protocol_metadata_t v3 = &unk_1ECFA2850;
      uint64_t v6 = &unk_1ECFA28A0;
      break;
    case 5:
      if (URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder != -1) {
        dispatch_once(&URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder, &__block_literal_global_2913);
      }
      uint64_t v8 = _CFRuntimeCreateInstance();
      *(_OWORD *)(v8 + 16) = 0u;
      nw_protocol_metadata_t v3 = (_OWORD *)(v8 + 16);
      *(void *)(v8 + 144) = 0;
      *(void *)(v8 + 16) = &unk_1ECFA1B80;
      uint64_t v4 = (void *)(v8 + 24);
      *(void *)(v8 + 24) = &unk_1ECF9F168;
      *(_OWORD *)(v8 + 48) = 0u;
      *(_OWORD *)(v8 + 64) = 0u;
      *(_OWORD *)(v8 + 80) = 0u;
      *(_OWORD *)(v8 + 96) = 0u;
      *(_OWORD *)(v8 + 112) = 0u;
      *(_OWORD *)(v8 + 128) = 0u;
      *(_OWORD *)(v8 + 32) = 0u;
      *(unsigned char *)(v8 + 144) = inflateInit_((z_streamp)(v8 + 32), "1.2.12", 112) == 0;
      int v5 = (uint64_t (**)(void))&unk_1ECFA2C00;
      *(void *)(v8 + 16) = &unk_1ECFA2C00;
      uint64_t v6 = &unk_1ECFA2C50;
      break;
    case 3:
      if (URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder != -1) {
        dispatch_once(&URLDataDecoderHolder::Class(void)::sOnce_URLDataDecoderHolder, &__block_literal_global_2913);
      }
      uint64_t v2 = _CFRuntimeCreateInstance();
      *(_OWORD *)(v2 + 16) = 0u;
      nw_protocol_metadata_t v3 = (_OWORD *)(v2 + 16);
      *(void *)(v2 + 144) = 0;
      *(void *)(v2 + 16) = &unk_1ECFA1B80;
      uint64_t v4 = (void *)(v2 + 24);
      *(void *)(v2 + 24) = &unk_1ECF9D440;
      *(_OWORD *)(v2 + 48) = 0u;
      *(_OWORD *)(v2 + 64) = 0u;
      *(_OWORD *)(v2 + 80) = 0u;
      *(_OWORD *)(v2 + 96) = 0u;
      *(_OWORD *)(v2 + 112) = 0u;
      *(_OWORD *)(v2 + 128) = 0u;
      *(_OWORD *)(v2 + 32) = 0u;
      *(unsigned char *)(v2 + 144) = inflateInit2_((z_streamp)(v2 + 32), -15, "1.2.12", 112) == 0;
      *(_WORD *)(v2 + 145) = 0;
      int v5 = (uint64_t (**)(void))&unk_1ECFA1C20;
      *(void *)(v2 + 16) = &unk_1ECFA1C20;
      uint64_t v6 = &unk_1ECFA1C70;
      break;
    default:
      return 0;
  }
  void *v4 = v6;
  uint64_t v9 = ((uint64_t (**)(_OWORD *))v5)[7](v3);
  int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
  uint64_t result = v3 - 1;
  if (v10) {
    return result;
  }
  CFRelease(result);
  return 0;
}

void sub_184149674(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9AAB8;
  _Unwind_Resume(a1);
}

uint64_t GZipDataDecoder::isInitialized(GZipDataDecoder *this)
{
  return *((unsigned __int8 *)this + 120);
}

void ___ZN11HTTP2Stream24closeStreamWithErrorCodeEi_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 40);
  int v3 = *(_DWORD *)(v1 + 56);
  if (v3 != 2)
  {
    int v3 = 3;
    *(_DWORD *)(v1 + 56) = 3;
  }
  if (*(unsigned char *)(v1 + 129))
  {
    HTTP2Stream::_onqueue_notifyDataAvailable((HTTP2Stream *)v1);
    int v3 = *(_DWORD *)(v1 + 56);
  }
  if (v3 == 3) {
    HTTP2Stream::_onqueue_notifyStreamClosed((HTTP2Stream *)v1);
  }
  if (*(unsigned char *)(v2 + 232))
  {
    uint64_t v4 = *(void *)(v2 + 64);
    if (v4)
    {
      uint64_t v5 = *(void *)(v4 + 56);
      if (v5)
      {
        if (*(_DWORD *)v5 == 1)
        {
          uint64_t v6 = *(void *)(v5 + 8);
          CFDataRef v7 = *(std::__shared_weak_count **)(v5 + 16);
          if (v7) {
            atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v8 = *(void *)(v2 + 16);
          if (v8 && v6)
          {
            if (*(unsigned char *)(v2 + 320)) {
              uint64_t v9 = 6;
            }
            else {
              uint64_t v9 = 8;
            }
            (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v6 + 280))(v6, *(void *)(v8 - 96), v9, *(void *)(v2 + 304));
            *(unsigned char *)(v2 + 232) = 0;
          }
          if (v7)
          {
            std::__shared_weak_count::__release_shared[abi:nn180100](v7);
          }
        }
      }
    }
  }
}

void sub_1841497A8(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void HTTP2Stream::_onqueue_notifyStreamClosed(HTTP2Stream *this)
{
  uint64_t v2 = *((void *)this + 4);
  if ((!v2 || !*(_DWORD *)(v2 + 40)) && !*((unsigned char *)this + 176))
  {
    *((_DWORD *)this + 50) |= 1u;
    return;
  }
  if (!*((unsigned char *)this + 130) && *((void *)this + 3))
  {
    int v3 = (std::__shared_weak_count *)*((void *)this + 36);
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4) {
        uint64_t v5 = *((void *)this + 35);
      }
      else {
        uint64_t v5 = 0;
      }
    }
    else
    {
      uint64_t v5 = 0;
      uint64_t v4 = 0;
    }
    if (*((unsigned char *)this + 129))
    {
      uint64_t v6 = *((void *)this + 4);
    }
    else
    {
      uint64_t v6 = *((void *)this + 4);
      if (*((_DWORD *)this + 14) == 3)
      {
        v10[0] = MEMORY[0x1E4F143A8];
        v10[1] = 3321888768;
        v10[2] = ___ZN11HTTP2Stream27_onqueue_notifyStreamClosedEv_block_invoke;
        v10[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
        v10[4] = this;
        v10[5] = v5;
        uInt v11 = v4;
        if (v4) {
          atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        (*(void (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v10);
        *((unsigned char *)this + 130) = 1;
        CFDataRef v7 = v11;
        if (!v11) {
          goto LABEL_23;
        }
LABEL_22:
        std::__shared_weak_count::__release_shared[abi:nn180100](v7);
LABEL_23:
        if (v4) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v4);
        }
        return;
      }
    }
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3321888768;
    v8[2] = ___ZN11HTTP2Stream27_onqueue_notifyStreamClosedEv_block_invoke_2;
    v8[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
    v8[4] = this;
    v8[5] = v5;
    uint64_t v9 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v8);
    CFDataRef v7 = v9;
    if (!v9) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
}

void sub_1841499A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  }
  _Unwind_Resume(exception_object);
}

void CFURLRequestSetURL(void *a1, const void *a2)
{
  uint64_t v3 = [a1 _inner];
  uint64_t v4 = *(const void **)(v3 + 8);
  if (v4 != a2)
  {
    if (v4) {
      CFRelease(v4);
    }
    if (a2) {
      CFTypeRef v5 = CFRetain(a2);
    }
    else {
      CFTypeRef v5 = 0;
    }
    *(void *)(v3 + 8) = v5;
  }
  if (*(void *)(v3 + 56))
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
    CFDataRef v7 = (HTTPRequestMessage *)Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      CFDataRef v7 = (HTTPRequestMessage *)(Instance + 1);
      Instance[13] = 0u;
      Instance[14] = 0u;
      Instance[11] = 0u;
      Instance[12] = 0u;
      Instance[9] = 0u;
      Instance[10] = 0u;
      Instance[7] = 0u;
      Instance[8] = 0u;
      Instance[5] = 0u;
      Instance[6] = 0u;
      Instance[3] = 0u;
      Instance[4] = 0u;
      Instance[2] = 0u;
    }
    uint64_t v8 = *(const HTTPRequestMessage **)(v3 + 56);
    HTTPRequestMessage::HTTPRequestMessage(v7, v8, (const __CFURL *)a2);
    *(void *)CFDataRef v7 = &unk_1ECF9AE88;
    *((void *)v7 + 1) = &unk_1ECF9AF08;
    *((void *)v7 + 2) = &unk_1ECF9AF28;
    *((void *)v7 + 16) = &unk_1ECF9AF58;
    HTTPRequest::commonInitialization(v9, (const HTTPRequest *)v8);
    CFRelease((CFTypeRef)(*(void *)(v3 + 56) - 16));
    *(void *)(v3 + 56) = v7;
  }
}

void sub_184149B5C(_Unwind_Exception *a1)
{
  HTTPRequestMessage::~HTTPRequestMessage(v1);
  _Unwind_Resume(a1);
}

void HTTPRequestMessage::HTTPRequestMessage(HTTPRequestMessage *this, const HTTPRequestMessage *a2, const __CFURL *a3)
{
  HTTPMessage::HTTPMessage(this, a2);
  *CFTypeRef v5 = &unk_1ECF9F3F0;
  v5[1] = &unk_1ECF9F470;
  v5[2] = &unk_1ECF9F490;
  uint64_t v6 = v5 + 16;
  v5[16] = &unk_1ECF9F4C0;
  CFAllocatorRef v7 = CFGetAllocator(v5 - 2);
  uint64_t v8 = (const void *)*((void *)a2 + 19);
  if (v8) {
    CFTypeRef v9 = CFRetain(v8);
  }
  else {
    CFTypeRef v9 = 0;
  }
  CFTypeRef cf = v9;
  HTTPRequestParserClient::HTTPRequestParserClient(v6, v7, v9, 0, a3);
  if (cf) {
    CFRelease(cf);
  }
  *(void *)this = &unk_1ECF9F3F0;
  *((void *)this + 1) = &unk_1ECF9F470;
  *((void *)this + 2) = &unk_1ECF9F490;
  *((void *)this + 16) = &unk_1ECF9F4C0;
}

void sub_184149CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  HTTPMessage::~HTTPMessage(v12);
  _Unwind_Resume(a1);
}

uint64_t ___ZN17CoreSchedulingSet23copyRunloopEmulationSetEv_block_invoke()
{
  uint64_t v0 = (__CFRunLoop *)_coreSchedulingSet_RLM();
  CFStringRef v2 = v1;
  uint64_t v3 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 120, 0);
  *uint64_t v3 = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  v3[4] = 0u;
  v3[5] = 0u;
  v3[6] = 0u;
  *((void *)v3 + 14) = 0;
  RunLoopSchedulingSet::RunLoopSchedulingSet((RunLoopSchedulingSet *)v3, v0, v2, "com.apple.CFNetwork.LoaderRL");
  CoreSchedulingSet::copyRunloopEmulationSet(void)::sEmulationSet = v4;
  CFTypeRef v5 = *(uint64_t (**)(void))(*(void *)v4 + 112);

  return v5();
}

uint64_t formSchedule(__CFReadStream *a1, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode, void *a4)
{
  CFAllocatorRef v7 = (__CFReadStream *)a4[2];
  if (v7) {
    CFReadStreamScheduleWithRunLoop(v7, runLoop, runLoopMode);
  }
  uint64_t result = (*(uint64_t (**)(void, CFRunLoopRef, CFRunLoopMode))(*(void *)*a4 + 56))(*a4, runLoop, runLoopMode);
  *a4 = result;
  return result;
}

_OWORD *EmptyCoreSchedulingSet::copyWithAdditionReleaseSelf(EmptyCoreSchedulingSet *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  return CoreSchedulingSet::create(a2, cf1, cf1);
}

_OWORD *CoreSchedulingSet::create(CoreSchedulingSet *this, const __CFString *cf1, const __CFString *a3)
{
  CFTypeRef v5 = (const void *)*MEMORY[0x1E4F1D418];
  if (!cf1
    || (int v6 = CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E4F1D418]), !this)
    || !v6
    || (CFAllocatorRef v7 = (const void *)_coreSchedulingSet_RLM(), v9 = v8, !CFEqual(this, v7))
    || (int v10 = (CoreSchedulingSet *)CFEqual(cf1, v9), !v10))
  {
    if (CFEqual(cf1, v5))
    {
      os_unfair_lock_lock((os_unfair_lock_t)&sLoaderSetLock);
      if (sDict)
      {
        Value = CFDictionaryGetValue(*(CFDictionaryRef *)(sDict + 8), this);
        if (Value)
        {
          CFIndex v13 = Value;
          (*(void (**)(_OWORD *))(*(void *)Value + 40))(Value);
          os_unfair_lock_unlock((os_unfair_lock_t)&sLoaderSetLock);
          return v13;
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&sLoaderSetLock);
    }
    CFIndex v13 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 120, 0);
    *CFIndex v13 = 0u;
    v13[1] = 0u;
    v13[2] = 0u;
    v13[3] = 0u;
    v13[4] = 0u;
    v13[5] = 0u;
    v13[6] = 0u;
    *((void *)v13 + 14) = 0;
    RunLoopSchedulingSet::RunLoopSchedulingSet((RunLoopSchedulingSet *)v13, (__CFRunLoop *)this, cf1, "other");
    return v13;
  }

  return (_OWORD *)CoreSchedulingSet::copyRunloopEmulationSet(v10);
}

uint64_t _coreSchedulingSet_RLM(void)
{
  if (_coreSchedulingSet_RLM(void)::sOnce != -1) {
    dispatch_once(&_coreSchedulingSet_RLM(void)::sOnce, &__block_literal_global_127_20395);
  }
  return _coreSchedulingSet_RLM(void)::sLoaderRunLoop;
}

void RunLoopSchedulingSet::RunLoopSchedulingSet(RunLoopSchedulingSet *this, __CFRunLoop *a2, const __CFString *a3, const char *a4)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, (const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
  *(_DWORD *)(v8 + 40) = 1;
  *(void *)uint64_t v8 = &unk_1ECFA1900;
  *(void *)(v8 + 24) = &unk_1ECFA1988;
  *(void *)(v8 + 96) = a4;
  if (a2) {
    CFTypeRef v9 = CFRetain(a2);
  }
  else {
    CFTypeRef v9 = 0;
  }
  *((void *)this + 9) = v9;
  if (a3) {
    CFTypeRef v10 = CFRetain(a3);
  }
  else {
    CFTypeRef v10 = 0;
  }
  *((void *)this + 10) = v10;
  *((unsigned char *)this + 116) = 0;
}

void sub_18414A0C0(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1ECF9E210;
  *(_DWORD *)(v1 + 40) = 0;
  *(void *)(v1 + 24) = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_8237()
{
}

void sub_18414A168(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN20URLDataDecoderHolder5ClassEv_block_invoke()
{
}

void sub_18414A1D8(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN25HTTP2ConnectionCacheEntry5ClassEv_block_invoke()
{
}

void sub_18414A248(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP2Connection5ClassEv_block_invoke()
{
}

void sub_18414A2B8(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN17HTTP2StreamBridge5ClassEv_block_invoke()
{
}

void sub_18414A328(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN18CompactCookieArray5ClassEv_block_invoke()
{
}

void sub_18414A398(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN8HostBase5ClassEv_block_invoke()
{
}

void sub_18414A408(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN16URLAuthChallenge5ClassEv_block_invoke()
{
}

void sub_18414A478(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN18URLProtectionSpace5ClassEv_block_invoke()
{
}

void sub_18414A4E8(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN17HTTPCookieStorage5ClassEv_block_invoke()
{
}

void sub_18414A558(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_8724()
{
}

void sub_18414A5E4(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN20URLCredentialStorage5ClassEv_block_invoke()
{
}

void sub_18414A654(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN11HTTPMessage5ClassEv_block_invoke()
{
}

void sub_18414A6C4(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN14HTTPHeaderDict5ClassEv_block_invoke()
{
}

void sub_18414A734(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN9HSTSCache5ClassEv_block_invoke()
{
}

void sub_18414A7A4(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN10HSTSPolicy5ClassEv_block_invoke()
{
}

void sub_18414A814(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void ___ZN14StorageSession5ClassEv_block_invoke()
{
}

void sub_18414A884(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void CFClass::CFClass(CFClass *this, const char *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = CFClass::FinalizeObj;
  *((void *)this + 5) = CFClass::EqualObj;
  *((void *)this + 6) = CFClass::HashObj;
  *((void *)this + 7) = CFClass::CopyFormattingDescObj;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = CFClass::CopyDebugDescObj;
  uint64_t v3 = _CFRuntimeRegisterClass();
  *((void *)this + 12) = v3;
  if (!v3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Couldn't allocate a type ID", v4, 2u);
  }
}

CFStringRef ___ZL13isAppleBundlev_block_invoke()
{
  MainBundle = CFBundleGetMainBundle();
  CFStringRef result = CFBundleGetIdentifier(MainBundle);
  uint64_t v2 = (uint64_t)result;
  if (!result)
  {
    isAppleBundle(void)::_isAppleBundle = 1;
    goto LABEL_5;
  }
  CFStringRef result = (const __CFString *)CFStringHasPrefix(result, @"com.apple.");
  isAppleBundle(void)::_isAppleBundle = result != 0;
  if (result) {
LABEL_5:
  }
    appleBundleID = v2;
  return result;
}

void ___ZN17RequestBodyStream20_onqueue_setupStreamEv_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if (CFReadStreamGetStatus(*(CFReadStreamRef *)(v2 + 120))) {
    __assert_rtn("_onqueue_setupStream_block_invoke", "HTTPRequestBody.cpp", 878, "CFReadStreamGetStatus(_stream.get()) == kCFStreamStatusNotOpen");
  }
  CFReadStreamOpen(*(CFReadStreamRef *)(v2 + 120));
  if (CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)(v2 + 120))) {
    int v3 = (*(unsigned __int8 *)(v2 + 192) >> 2) & 1;
  }
  else {
    LOBYTE(v3) = 0;
  }
  uint64_t v4 = a1[5];
  CFTypeRef v5 = *(NSObject **)(v4 + 48);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3321888768;
  v7[2] = ___ZN17RequestBodyStream20_onqueue_setupStreamEv_block_invoke_2;
  v7[3] = &__block_descriptor_57_e8_40c45_ZTSNSt3__110shared_ptrI17RequestBodyStreamEE_e5_v8__0l;
  char v9 = v3;
  v7[4] = v2;
  v7[5] = v4;
  int v6 = (std::__shared_weak_count *)a1[6];
  uint64_t v8 = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_async(v5, v7);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
}

void ___ZN11HTTP2Stream14didSendHeadersEv_block_invoke(void *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v3 = (void *)a1[4];
  uint64_t v2 = a1[5];
  if (*(_DWORD *)(v2 + 56) != 1) {
    *(_DWORD *)(v2 + 56) = 1;
  }
  if (!v3[33])
  {
    uint64_t v4 = v3[38];
    if (v4) {
      *(CFAbsoluteTime *)(v4 + 184) = CFAbsoluteTimeGetCurrent();
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFTypeRef v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = v3[27];
      int v10 = 138543362;
      uint64_t v11 = v6;
      _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@ sent request, body N 0", (uint8_t *)&v10, 0xCu);
    }
    uint64_t v7 = v3[8];
    uint64_t v8 = a1[5];
    char v9 = (std::__shared_weak_count *)a1[6];
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      HTTP2Connection::streamEnteredStallableState(v7, v8, v9);
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
    }
    else
    {
      HTTP2Connection::streamEnteredStallableState(v7, v8, 0);
    }
  }
}

void HTTP3Connection::_decoderUnblocked(HTTP3Connection *this, void *a2)
{
  if (*((_DWORD *)this + 29) != 9)
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v7, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
    int v3 = *((_DWORD *)this + 29);
    switch(v3)
    {
      case 2:
        int v4 = 1;
        break;
      case 8:
        int v4 = 7;
        break;
      case 5:
        int v4 = 4;
        break;
      default:
        __assert_rtn("responseUnblocked", "HTTP3Stream.mm", 440, "false");
    }
    *((_DWORD *)this + 29) = v4;
    id v5 = *((id *)this + 19);
    uint64_t v6 = (void *)*((void *)this + 19);
    *((void *)this + 19) = 0;

    if (!HTTP3Stream::_handleHeaders((uint64_t)this, 0, v5, *((unsigned __int8 *)this + 131))) {
      HTTP3Stream::_read(this, 0);
    }

    if (v8) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
  }
}

void sub_18414AD08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN11HTTP3Framer5_readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke(uint64_t a1, void *a2, void *a3, int a4, uint64_t a5, uint64_t a6)
{
  id v11 = a2;
  uint64_t v12 = a3;
  CFIndex v13 = v12;
  uint64_t v14 = *(void *)(a1 + 40);
  if (a6)
  {
    *(void *)(v14 + 144) = a5;
    *(void *)(v14 + 152) = a6;
  }
  else if (a4)
  {
    *(void *)(v14 + 144) = 4;
    *(_DWORD *)(v14 + 152) = -2300;
  }
  if (v12)
  {
    size_t size = dispatch_data_get_size(v12);
    size_t v16 = *(void *)(v14 + 104);
    if (v16 <= size)
    {
      if (v16 == size)
      {
        dispatch_data_t subrange = v13;
      }
      else
      {
        size_t v17 = size;
        dispatch_data_t subrange = dispatch_data_create_subrange(v13, 0, v16);
        dispatch_data_t v19 = dispatch_data_create_subrange(v13, *(void *)(v14 + 104), v17 - *(void *)(v14 + 104));
        uint64_t v20 = *(void **)(v14 + 136);
        *(void *)(v14 + 136) = v19;
      }
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      *(void *)(v14 + 104) = 0;
      *(_DWORD *)(v14 + 76) = 0;
      uint64_t v23 = *(void *)(a1 + 32);
      long long v24 = *(_OWORD *)(v14 + 80);
      uint64_t v25 = *(void *)(v14 + 96);
      if (!*(void *)(v14 + 136))
      {
        uint64_t v22 = *(void *)(v14 + 144);
        uint64_t v21 = *(void *)(v14 + 152);
      }
      (*(void (**)(uint64_t, long long *, dispatch_data_t, uint64_t, uint64_t, uint64_t))(v23 + 16))(v23, &v24, subrange, 1, v22, v21);
    }
    else
    {
      *(void *)(v14 + 104) = v16 - size;
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    }
  }
  else
  {
    if (!*(_DWORD *)(v14 + 152))
    {
      *(void *)(v14 + 144) = 4;
      *(_DWORD *)(v14 + 152) = -1;
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_18414AEE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HTTP3Connection::_readControlStream(HTTP3Connection *this)
{
  if (!*((void *)this + 126) || (*((unsigned char *)this + 920) & 4) != 0) {
    return;
  }
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v9, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
  uint64_t v2 = *((void *)this + 128);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3321888768;
  v7[2] = ___ZN15HTTP3Connection18_readControlStreamEv_block_invoke;
  v7[3] = &__block_descriptor_56_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e65_v56__0_FrameMetadata_QQQ_8__NSObject_OS_dispatch_data__32___qi_40l;
  v7[4] = this;
  v7[5] = v9;
  uint64_t v8 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v3 = v7;
  if (*(_DWORD *)(v2 + 76))
  {
    id v5 = "_state == State::ReadingHeader";
    int v6 = 241;
    goto LABEL_20;
  }
  if (*(unsigned char *)(v2 + 72))
  {
    id v5 = "!_processingReadCall";
    int v6 = 242;
LABEL_20:
    __assert_rtn("readFrame", "HTTP3Frame.mm", v6, v5);
  }
  *(unsigned char *)(v2 + 72) = 1;
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v15, *(void *)v2, *(std::__shared_weak_count **)(v2 + 8));
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3321888768;
  v11[2] = ___ZN11HTTP3Framer9readFrameEmU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke;
  v11[3] = &unk_1ECFA9658;
  uint64_t v13 = v15;
  uint64_t v14 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v4 = v3;
  id v12 = v4;
  HTTP3Framer::_readFrame(v2, 1024, MEMORY[0x1E4F14410], v11);

  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }

  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
}

void sub_18414B0D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a24);
  }
  CFIndex v27 = *(std::__shared_weak_count **)(v25 - 56);
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v27);
  }

  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a17);
  }
  _Unwind_Resume(a1);
}

void HTTP3Framer::_readFrame(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = ___ZN11HTTP3Framer10_readFrameEmPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_13CFStreamErrorE_block_invoke;
  v11[3] = &unk_1E5252EB0;
  id v12 = v7;
  id v13 = v8;
  uint64_t v14 = a1;
  uint64_t v15 = a2;
  id v9 = v7;
  id v10 = v8;
  HTTP3Framer::_read(a1, v11);
}

void sub_18414B1F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::_handleSendError(HTTP3Stream *this, CFStreamError a2, int a3)
{
  uint64_t v4 = *(void *)&a2.error;
  CFIndex domain = a2.domain;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  switch(HTTP3Stream::_translateError(this, a2, 1))
  {
    case 1u:
      goto LABEL_3;
    case 2u:
      *((void *)this + 33) = domain;
      *((void *)this + 34) = v4;
      goto LABEL_30;
    case 3u:
      *((void *)this + 33) = 4;
      int v14 = -4;
      goto LABEL_29;
    case 4u:
      goto LABEL_21;
    case 5u:
      *((void *)this + 33) = 4;
      int v14 = -2205;
      goto LABEL_29;
    case 6u:
      if (!*((_DWORD *)this + 29)) {
        goto LABEL_28;
      }
      uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 7);
      if (v15)
      {
        size_t v16 = std::__shared_weak_count::lock(v15);
        if (v16)
        {
          size_t v17 = v16;
          uint64_t v18 = *((void *)this + 6);
          if (v18)
          {
            *(void *)(v18 + 1160) = 4;
            *(_DWORD *)(v18 + 1168) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v18, 257, 0);
            HTTP3Connection::reportServerProtocolViolation(v18, 50, *((void *)this + 42));
          }
          std::__shared_weak_count::__release_shared[abi:nn180100](v17);
        }
      }
LABEL_21:
      *((void *)this + 33) = 4;
      int v14 = -1;
      goto LABEL_29;
    case 7u:
      uint64_t v19 = *((void *)this + 37);
      if (v19) {
        uint64_t v20 = v19 - 176;
      }
      else {
        uint64_t v20 = 0;
      }
      id v21 = *(id *)(v20 + 80);
      uint64_t v22 = [v21 session];
      uint64_t v23 = [(id)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*((void *)this + 8) + 128)) host];
      if (v22) {
        -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:]((uint64_t)v22, v23, 80);
      }

LABEL_28:
      *((void *)this + 33) = 4;
      int v14 = -2200;
LABEL_29:
      *((_DWORD *)this + 68) = v14;
      goto LABEL_30;
    default:
      if (!a3) {
        return 0;
      }
LABEL_3:
      uint64_t v7 = *((void *)this + 43);
      if (v7) {
        *(CFAbsoluteTime *)(v7 + 184) = CFAbsoluteTimeGetCurrent();
      }
      *((_DWORD *)this + 28) = 4;
      id v8 = CFN_LOG_h3stream();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *((void *)this + 42);
        uint64_t v10 = *((void *)this + 44);
        uint64_t v11 = *((void *)this + 12);
        if (v11)
        {
          if ((*(uint64_t (**)(uint64_t))(*(void *)v11 + 56))(v11) < 0) {
            int v12 = 83;
          }
          else {
            int v12 = 68;
          }
          uint64_t v13 = *((void *)this + 12);
          if (v13) {
            uint64_t v13 = *(void *)(v13 + 96);
          }
        }
        else
        {
          uint64_t v13 = 0;
          int v12 = 78;
        }
        *(_DWORD *)buf = 134219010;
        *(void *)&buf[4] = this;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v9;
        __int16 v34 = 2114;
        uint64_t v35 = v10;
        __int16 v36 = 1024;
        int v37 = v12;
        __int16 v38 = 2048;
        uint64_t v39 = v13;
        _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "%p ID=%llu %{public}@ sent request, body %c %lld", buf, 0x30u);
      }

      if (*((int *)this + 29) <= 2)
      {
        uint64_t v25 = (std::__shared_weak_count *)*((void *)this + 7);
        if (v25)
        {
          int v26 = std::__shared_weak_count::lock(v25);
          if (v26)
          {
            CFIndex v27 = v26;
            uint64_t v28 = *((void *)this + 6);
            if (v28)
            {
              std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v31, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
              if (v31)
              {
                CFIndex v29 = *(void **)(v28 + 976);
                if (v29)
                {
                  int v30 = v32;
                  *(void *)buf = v31;
                  *(void *)&uint8_t buf[8] = v32;
                  if (v32)
                  {
                    atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
                    HTTPStallTimer::add(v29, (uint64_t *)buf);
                    std::__shared_weak_count::__release_shared[abi:nn180100](v30);
                  }
                  else
                  {
                    HTTPStallTimer::add(v29, (uint64_t *)buf);
                  }
                }
              }
              if (v32) {
                std::__shared_weak_count::__release_shared[abi:nn180100](v32);
              }
            }
            std::__shared_weak_count::__release_shared[abi:nn180100](v27);
          }
        }
      }
LABEL_30:
      HTTP3Stream::_protocolCallback(this);
      return 1;
  }
}

void sub_18414B544(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void HTTP3Stream::_protocolCallback(HTTP3Stream *this)
{
  uint64_t v2 = (void (**)(void, void, void, void))*((void *)this + 41);
  if (!v2) {
    return;
  }
  uint64_t v3 = *((void *)this + 39);
  if (!v3 || !*(_DWORD *)(v3 + 40))
  {
    *((unsigned char *)this + 128) = 1;
    return;
  }
  int v4 = *((_DWORD *)this + 68);
  if (v4) {
    id v5 = (char *)this + 264;
  }
  else {
    id v5 = 0;
  }
  uint64_t v6 = *((void *)this + 10);
  if (!v6)
  {
    if (!v4) {
      return;
    }
    id v11 = _Block_copy(v2);
    uint64_t v10 = (void *)*((void *)this + 41);
    *((void *)this + 41) = 0;

    (*((void (**)(id, void, void, char *))v11 + 2))(v11, 0, 0, (char *)this + 264);
    goto LABEL_18;
  }
  uint64_t v7 = *((void *)this + 20);
  if (!v7
    || (v2[2](v2, v6 - 16, v7, 0),
        id v8 = (void *)*((void *)this + 20),
        *((void *)this + 20) = 0,
        v8,
        (uint64_t v2 = (void (**)(void, void, void, void))*((void *)this + 41)) != 0))
  {
    if (*((_DWORD *)this + 28) == 4 && *((_DWORD *)this + 29) == 9 || *((_DWORD *)this + 68))
    {
      id v11 = _Block_copy(v2);
      uint64_t v9 = (void *)*((void *)this + 41);
      *((void *)this + 41) = 0;

      (*((void (**)(id, uint64_t, void, char *))v11 + 2))(v11, *((void *)this + 10) - 16, 0, v5);
LABEL_18:
    }
  }
}

void sub_18414B6D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id CFN_LOG_h3stream(void)
{
  if (CFN_LOG_h3stream(void)::once != -1) {
    dispatch_once(&CFN_LOG_h3stream(void)::once, &__block_literal_global_6420);
  }
  uint64_t v0 = (void *)CFN_LOG_h3stream(void)::log;

  return v0;
}

void ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke_2(uint64_t a1, void *a2, void *a3, int a4, uint64_t a5, uint64_t a6)
{
  id v11 = a2;
  int v12 = a3;
  uint64_t v13 = v12;
  uint64_t v14 = *(void *)(a1 + 40);
  if (a6)
  {
    *(void *)(v14 + 144) = a5;
    *(void *)(v14 + 152) = a6;
  }
  else if (a4)
  {
    *(void *)(v14 + 144) = 4;
    *(_DWORD *)(v14 + 152) = -2300;
  }
  if (v12)
  {
    uint64_t v15 = *(NSObject **)(v14 + 136);
    if (v15) {
      dispatch_data_t concat = dispatch_data_create_concat(v15, v13);
    }
    else {
      dispatch_data_t concat = v13;
    }
    uint64_t v18 = *(void **)(v14 + 136);
    *(void *)(v14 + 136) = concat;

    HTTP3Framer::_readHeader(v14, v13, *(void *)(a1 + 32));
  }
  else
  {
    if (*(_DWORD *)(v14 + 152))
    {
      uint64_t v17 = *(void *)(v14 + 144);
    }
    else
    {
      uint64_t v17 = 4;
      *(void *)(v14 + 144) = 4;
      *(_DWORD *)(v14 + 152) = -1;
    }
    uint64_t v19 = *(void *)(a1 + 32);
    memset(v20, 0, sizeof(v20));
    (*(void (**)(uint64_t, void *, void, BOOL, uint64_t, void))(v19 + 16))(v19, v20, 0, *(unsigned char *)(v14 + 128) == 0, v17, *(void *)(v14 + 152));
  }
}

void sub_18414B85C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HTTP3Stream::_read(HTTP3Stream *this, char a2)
{
  uint64_t v3 = *((void *)this + 39);
  if (v3 && *(_DWORD *)(v3 + 40))
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v24, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
    uint64_t v20 = 0;
    id v21 = &v20;
    uint64_t v22 = 0x2020000000;
    char v23 = a2;
    uint64_t v5 = MEMORY[0x1E4F143A8];
    do
    {
      uint64_t v16 = 0;
      uint64_t v17 = &v16;
      uint64_t v18 = 0x2020000000;
      char v19 = 1;
      uint64_t v12 = 0;
      uint64_t v13 = &v12;
      uint64_t v14 = 0x2020000000;
      char v15 = 1;
      uint64_t v6 = *((void *)this + 3);
      v10[0] = v5;
      v10[1] = 3321888768;
      v10[2] = ___ZN11HTTP3Stream5_readEb_block_invoke;
      v10[3] = &unk_1ECFAA220;
      v10[7] = v24;
      id v11 = v25;
      if (v25) {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v10[4] = &v16;
      v10[5] = &v20;
      void v10[6] = &v12;
      uint64_t v7 = v10;
      if (*(unsigned char *)(v6 + 72)) {
        __assert_rtn("read", "HTTP3Frame.mm", 210, "!_processingReadCall");
      }
      *(unsigned char *)(v6 + 72) = 1;
      std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v30, *(void *)v6, *(std::__shared_weak_count **)(v6 + 8));
      v26[0] = MEMORY[0x1E4F143A8];
      v26[1] = 3321888768;
      v26[2] = ___ZN11HTTP3Framer4readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke;
      v26[3] = &unk_1ECFA9690;
      uint64_t v28 = v30;
      CFIndex v29 = v31;
      if (v31) {
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      id v8 = v7;
      id v27 = v8;
      HTTP3Framer::_read(v6, v26);

      if (v29) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v29);
      }
      if (v31) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v31);
      }

      *((unsigned char *)v17 + 24) = 0;
      int v9 = *((unsigned __int8 *)v13 + 24);
      if (v11) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v11);
      }
      _Block_object_dispose(&v12, 8);
      _Block_object_dispose(&v16, 8);
    }
    while (!v9);
    if (*((unsigned char *)v21 + 24)) {
      HTTP3Stream::_protocolCallback(this);
    }
    _Block_object_dispose(&v20, 8);
    if (v25) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v25);
    }
  }
  else
  {
    *((unsigned char *)this + 127) = 1;
  }
}

void sub_18414BAD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (a32) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a32);
  }
  _Unwind_Resume(a1);
}

void HTTP3Framer::_read(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  int v5 = *(_DWORD *)(a1 + 76);
  if (v5 == 1)
  {
    if (!*(void *)(a1 + 104))
    {
      uint64_t v12 = "_waitingBodySize > 0";
      int v13 = 167;
      goto LABEL_19;
    }
    if (*(void *)(a1 + 136))
    {
      uint64_t v12 = "_pendingData == nullptr";
      int v13 = 168;
      goto LABEL_19;
    }
    if (*(_DWORD *)(a1 + 152))
    {
      memset(v17, 0, sizeof(v17));
      (*((void (**)(id, void *, void, void, void, void))v3 + 2))(v3, v17, 0, 0, *(void *)(a1 + 144), *(void *)(a1 + 152));
    }
    else
    {
      uint64_t v6 = *(void *)(a1 + 16);
      uint64_t v7 = *(void *)(a1 + 48);
      uint64_t v8 = *(void *)(a1 + 64);
      if (v8)
      {
        uint64_t v9 = (*(uint64_t (**)(void))(v8 + 16))();
        int v10 = 132001;
        if (v9 > 132001) {
          int v10 = v9;
        }
        uint64_t v11 = (v10 - 1);
      }
      else
      {
        uint64_t v11 = 132000;
      }
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      v14[2] = ___ZN11HTTP3Framer5_readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke;
      v14[3] = &unk_1E5252E88;
      uint64_t v16 = a1;
      id v15 = v4;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v6 + 24))(v6, v7, 1, v11, v14);
    }
  }
  else if (!v5)
  {
    if (!*(void *)(a1 + 104))
    {
      HTTP3Framer::_readHeader(a1, *(void **)(a1 + 136), v3);
      goto LABEL_15;
    }
    uint64_t v12 = "_waitingBodySize == 0";
    int v13 = 162;
LABEL_19:
    __assert_rtn("_read", "HTTP3Frame.mm", v13, v12);
  }
LABEL_15:
}

void sub_18414BD18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void HTTP3Framer::_readHeader(uint64_t a1, void *a2, void *a3)
{
  int v5 = a2;
  uint64_t v6 = a3;
  uint64_t v35 = 0;
  __int16 v36 = &v35;
  uint64_t v37 = 0x2020000000;
  char v38 = 0;
  if (v5)
  {
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 3221225472;
    applier[2] = ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke;
    applier[3] = &unk_1E5254888;
    applier[4] = &v35;
    void applier[5] = a1;
    dispatch_data_apply(v5, applier);
    if (*((unsigned char *)v36 + 24))
    {
      uint64_t v7 = *(NSObject **)(a1 + 136);
      if (!v7) {
        __assert_rtn("_readHeader", "HTTP3Frame.mm", 114, "_pendingData");
      }
      size_t v8 = *(void *)(a1 + 96);
      size_t size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 136));
      size_t v10 = size - v8;
      if (size < v8) {
        __assert_rtn("_readHeader", "HTTP3Frame.mm", 117, "pendingSize >= headerSize");
      }
      uint64_t v11 = (long long *)(a1 + 80);
      size_t v12 = *(void *)(a1 + 88);
      if (v10 >= v12)
      {
        dispatch_data_t subrange = dispatch_data_create_subrange(v7, v8, v12);
        uint64_t v21 = *(void *)(a1 + 88);
        uint64_t v22 = *(NSObject **)(a1 + 136);
        if (v10 == v21)
        {
          dispatch_data_t v23 = 0;
        }
        else
        {
          dispatch_data_t v23 = dispatch_data_create_subrange(v22, v21 + v8, v10 - v21);
          uint64_t v22 = *(NSObject **)(a1 + 136);
        }
        *(void *)(a1 + 136) = v23;

        long long v32 = *v11;
        uint64_t v33 = *(void *)(a1 + 96);
        if (*(void *)(a1 + 136))
        {
          uint64_t v24 = 0;
          uint64_t v25 = 0;
        }
        else
        {
          uint64_t v25 = *(void *)(a1 + 144);
          uint64_t v24 = *(void *)(a1 + 152);
        }
        v6[2](v6, &v32, subrange, 1, v25, v24);
      }
      else
      {
        dispatch_data_t subrange = dispatch_data_create_subrange(v7, v8, v10);
        *(_DWORD *)(a1 + 76) = 1;
        *(void *)(a1 + 104) = *(void *)(a1 + 88) - v10;
        uint64_t v14 = *(void **)(a1 + 136);
        *(void *)(a1 + 136) = 0;

        uint64_t v31 = *(void *)(a1 + 96);
        long long v30 = *v11;
        v6[2](v6, &v30, subrange, 0, *(void *)(a1 + 144), *(void *)(a1 + 152));
      }
LABEL_22:

      goto LABEL_23;
    }
  }
  if (!*(_DWORD *)(a1 + 152))
  {
    uint64_t v15 = *(void *)(a1 + 16);
    uint64_t v16 = *(void *)(a1 + 48);
    uint64_t v17 = *(void *)(a1 + 64);
    if (v17)
    {
      uint64_t v18 = (*(uint64_t (**)(void))(v17 + 16))();
      int v19 = 132001;
      if (v18 > 132001) {
        int v19 = v18;
      }
      uint64_t v20 = (v19 - 1);
    }
    else
    {
      uint64_t v20 = 132000;
    }
    v26[0] = MEMORY[0x1E4F143A8];
    v26[1] = 3221225472;
    v26[2] = ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke_2;
    v26[3] = &unk_1E5252E88;
    uint64_t v28 = a1;
    id v27 = v6;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v15 + 24))(v15, v16, 1, v20, v26);
    dispatch_data_t subrange = v27;
    goto LABEL_22;
  }
  memset(v29, 0, sizeof(v29));
  v6[2](v6, (long long *)v29, 0, *(unsigned char *)(a1 + 128) == 0, *(void *)(a1 + 144), *(void *)(a1 + 152));
LABEL_23:
  _Block_object_dispose(&v35, 8);
}

void sub_18414C084(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v4 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11HTTP3Framer4readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke(uint64_t a1, long long *a2, uint64_t a3)
{
  *(unsigned char *)(*(void *)(a1 + 40) + 72) = 0;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v6 = *((void *)a2 + 2);
  long long v5 = *a2;
  return (*(uint64_t (**)(uint64_t, long long *, uint64_t))(v3 + 16))(v3, &v5, a3);
}

void ___ZN11HTTP3Stream5_readEb_block_invoke(void *a1, uint64_t *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  id v11 = a3;
  uint64_t v12 = a1[7];
  uint64_t v14 = *a2;
  uint64_t v13 = a2[1];
  uint64_t v15 = a2[2];
  data2 = v11;
  if (a6)
  {
    uint64_t v16 = *(std::__shared_weak_count **)(v12 + 56);
    if (v16)
    {
      uint64_t v17 = std::__shared_weak_count::lock(v16);
      if (v17)
      {
        uint64_t v18 = v17;
        int v19 = *(HTTP3Connection **)(v12 + 48);
        if (v19)
        {
          v106.CFIndex domain = a5;
          *(void *)&v106.error = a6;
          if (HTTP3Connection::checkAndPerformFallback(v19, v106))
          {
            uint64_t v20 = CFN_LOG_h3stream();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v21 = *(void *)(v12 + 336);
              uint64_t v22 = *(void *)(v12 + 352);
              *(_DWORD *)buf = 134218498;
              *(void *)&buf[4] = v12;
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v21;
              *(_WORD *)&unsigned char buf[22] = 2114;
              *(void *)&unsigned char buf[24] = v22;
              _os_log_impl(&dword_184085000, v20, OS_LOG_TYPE_DEFAULT, "%p ID=%llu %{public}@ fallback triggered", buf, 0x20u);
            }

            dispatch_data_t v23 = v18;
LABEL_31:
            std::__shared_weak_count::__release_shared[abi:nn180100](v23);
LABEL_32:
            dispatch_data_t subrange = data2;
            goto LABEL_109;
          }
        }
        std::__shared_weak_count::__release_shared[abi:nn180100](v18);
      }
    }
  }
  dispatch_data_t subrange = data2;
  if (*(_DWORD *)(v12 + 116) != 9)
  {
    if (data2)
    {
      uint64_t v25 = *(std::__shared_weak_count **)(v12 + 56);
      if (v25)
      {
        int v26 = std::__shared_weak_count::lock(v25);
        if (v26)
        {
          id v27 = v26;
          uint64_t v28 = *(HTTP3Connection **)(v12 + 48);
          if (v28 && *((void *)v28 + 124)) {
            HTTP3Connection::_stopStallRecovery(v28);
          }
          std::__shared_weak_count::__release_shared[abi:nn180100](v27);
        }
      }
      switch(v14)
      {
        case 0:
          unsigned int v29 = *(_DWORD *)(v12 + 116);
          dispatch_data_t subrange = data2;
          if (v29 > 9) {
            goto LABEL_76;
          }
          if (!v29)
          {
            uint64_t v48 = *(std::__shared_weak_count **)(v12 + 56);
            dispatch_data_t subrange = data2;
            if (!v48) {
              goto LABEL_109;
            }
            CFTypeRef v49 = std::__shared_weak_count::lock(v48);
            dispatch_data_t subrange = data2;
            if (!v49) {
              goto LABEL_109;
            }
            __int16 v34 = v49;
            uint64_t v35 = *(void *)(v12 + 48);
            if (!v35) {
              goto LABEL_30;
            }
            goto LABEL_29;
          }
          if (v29 != 3)
          {
            void applier[6] = 0;
            long long v102 = 0u;
            long long v103 = 0u;
            long long v101 = 0u;
            memset(buf, 0, sizeof(buf));
            os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR);
            int v90 = 67110144;
            unsigned int v91 = v29;
            __int16 v92 = 2048;
            uint64_t v93 = 0;
            __int16 v94 = 2048;
            uint64_t v95 = v13;
            __int16 v96 = 2048;
            size_t size = dispatch_data_get_size(data2);
            __int16 v98 = 1024;
            int v99 = a4;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
LABEL_146:
            __assert_rtn("_received", "HTTP3Stream.mm", v40, "false");
          }
          long long v30 = *(NSObject **)(v12 + 160);
          if (v30) {
            dispatch_data_t concat = dispatch_data_create_concat(v30, data2);
          }
          else {
            dispatch_data_t concat = data2;
          }
          uint64_t v54 = *(void **)(v12 + 160);
          *(void *)(v12 + 160) = concat;

          uint64_t v55 = *(void *)(v12 + 344);
          dispatch_data_t subrange = data2;
          if (v55)
          {
            size_t v56 = dispatch_data_get_size(data2);
            if (a4) {
              uint64_t v57 = v15;
            }
            else {
              uint64_t v57 = 0;
            }
            *(void *)(v55 + 136) += v56 + v57;
            goto LABEL_75;
          }
          goto LABEL_76;
        case 1:
          dispatch_data_t subrange = data2;
          int v40 = 1046;
          switch(*(_DWORD *)(v12 + 116))
          {
            case 0:
              uint64_t v41 = *(void *)(v12 + 344);
              if (v41) {
                *(void *)(v41 + 200) = 0x7FF8000000000000;
              }
              *(_DWORD *)(v12 + 116) = 1;
              *(_DWORD *)(v12 + 248) = -1;
              if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1) {
                dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_17041);
              }
              uint64_t Instance = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
              if (Instance)
              {
                *((void *)Instance + 2) = 0;
                *((void *)Instance + 3) = 0;
                uint64_t Instance = (HTTPHeaderDict *)((char *)Instance + 16);
              }
              HTTPHeaderDict::HTTPHeaderDict(Instance);
              uint64_t v43 = *(void *)(v12 + 256);
              *(void *)(v12 + 256) = v44;
              if (v43) {
                CFRelease((CFTypeRef)(v43 - 16));
              }
              goto LABEL_50;
            case 1:
LABEL_50:
              if (a4)
              {
                uint64_t v45 = *(void *)(v12 + 344);
                if (v45) {
                  *(void *)(v45 + 120) += v13 + v15;
                }
              }
              goto LABEL_66;
            case 2:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
              goto LABEL_146;
            case 3:
              *(_DWORD *)(v12 + 116) = 4;
              if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1) {
                dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_17041);
              }
              uint64_t v50 = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
              if (v50)
              {
                *((void *)v50 + 2) = 0;
                *((void *)v50 + 3) = 0;
                uint64_t v50 = (HTTPHeaderDict *)((char *)v50 + 16);
              }
              HTTPHeaderDict::HTTPHeaderDict(v50);
              uint64_t v51 = *(void *)(v12 + 256);
              *(void *)(v12 + 256) = v52;
              if (v51) {
                CFRelease((CFTypeRef)(v51 - 16));
              }
              goto LABEL_66;
            case 4:
LABEL_66:
              int v53 = HTTP3Stream::_handleHeaders(v12, v13, data2, a4);
              dispatch_data_t subrange = data2;
              if (v53) {
                goto LABEL_67;
              }
              goto LABEL_76;
            default:
              goto LABEL_76;
          }
        case 2:
        case 6:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          goto LABEL_33;
        case 3:
        case 4:
        case 7:
        case 13:
          goto LABEL_26;
        case 5:
          if (*(unsigned char *)(v12 + 126))
          {
            char v38 = *(std::__shared_weak_count **)(v12 + 56);
            dispatch_data_t subrange = data2;
            if (v38)
            {
              uint64_t v39 = std::__shared_weak_count::lock(v38);
              dispatch_data_t subrange = data2;
              if (v39)
              {
                __int16 v34 = v39;
                uint64_t v35 = *(void *)(v12 + 48);
                if (v35)
                {
LABEL_29:
                  *(void *)(v35 + 1160) = 4;
                  *(_DWORD *)(v35 + 1168) = -1;
                  HTTP3Connection::_cleanupConnection((HTTP3Connection *)v35, 261, 0);
                  HTTP3Connection::reportServerProtocolViolation(v35, 48, *(void *)(v12 + 336));
                }
LABEL_30:
                dispatch_data_t v23 = v34;
                goto LABEL_31;
              }
            }
            goto LABEL_109;
          }
          break;
        default:
          if ((unint64_t)(v14 - 984832) >= 2)
          {
LABEL_33:
            __int16 v36 = CFN_LOG_h3stream();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
            {
              uint64_t v37 = *(void *)(v12 + 336);
              *(_DWORD *)buf = 134218496;
              *(void *)&buf[4] = v12;
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v37;
              *(_WORD *)&unsigned char buf[22] = 2048;
              *(void *)&unsigned char buf[24] = v14;
              _os_log_impl(&dword_184085000, v36, OS_LOG_TYPE_INFO, "%p ID=%llu unsupported frame type %llu", buf, 0x20u);
            }

            goto LABEL_75;
          }
LABEL_26:
          long long v32 = *(std::__shared_weak_count **)(v12 + 56);
          dispatch_data_t subrange = data2;
          if (!v32) {
            goto LABEL_109;
          }
          uint64_t v33 = std::__shared_weak_count::lock(v32);
          dispatch_data_t subrange = data2;
          if (!v33) {
            goto LABEL_109;
          }
          __int16 v34 = v33;
          uint64_t v35 = *(void *)(v12 + 48);
          if (!v35) {
            goto LABEL_30;
          }
          goto LABEL_29;
      }
      int v46 = *(_DWORD *)(v12 + 116);
      int v40 = 1144;
      dispatch_data_t subrange = data2;
      switch(v46)
      {
        case 0:
        case 3:
          unsigned int v47 = 0;
          *(_DWORD *)(v12 + 116) = 6;
          *(_DWORD *)(v12 + 120) = v46;
          *(unsigned char *)(v12 + 176) = 0;
          goto LABEL_122;
        case 1:
        case 2:
        case 4:
        case 5:
        case 8:
        case 9:
          goto LABEL_146;
        case 6:
          unsigned int v47 = *(unsigned __int8 *)(v12 + 176);
LABEL_122:
          *(void *)buf = 0;
          *(void *)&uint8_t buf[8] = buf;
          *(void *)&uint8_t buf[16] = 0x2020000000;
          unsigned char buf[24] = 0;
          applier[0] = MEMORY[0x1E4F143A8];
          applier[1] = 3221225472;
          applier[2] = ___ZN11HTTP3Stream9_receivedEN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamError_block_invoke;
          applier[3] = &unk_1E5254888;
          applier[4] = buf;
          void applier[5] = v12;
          dispatch_data_apply(data2, applier);
          if (*(unsigned char *)(*(void *)&buf[8] + 24))
          {
            *(_DWORD *)(v12 + 116) = 7;
            v76 = *(std::__shared_weak_count **)(v12 + 56);
            if (v76)
            {
              uint64_t v77 = std::__shared_weak_count::lock(v76);
              if (v77)
              {
                uint64_t v78 = v77;
                uint64_t v79 = *(void *)(v12 + 48);
                if (v79)
                {
                  if (*(void *)(v12 + 168) > (unint64_t)(*(int *)(v79 + 792) - 1))
                  {
                    *(void *)(v79 + 1160) = 4;
                    *(_DWORD *)(v79 + 1168) = -1;
                    HTTP3Connection::_cleanupConnection((HTTP3Connection *)v79, 264, 0);
                    HTTP3Connection::reportServerProtocolViolation(v79, 55, *(void *)(v12 + 336));
                    goto LABEL_133;
                  }
                  *(void *)uint64_t v86 = *(void *)(v12 + 168);
                  uint64_t v83 = *(void *)(v12 + 296);
                  if (v83) {
                    uint64_t v84 = v83 - 176;
                  }
                  else {
                    uint64_t v84 = 0;
                  }
                  id v87 = *(id *)(v84 + 80);
                  char NewForStreamId = HTTP2ServerPush::createNewForStreamId((HTTP2ServerPush *)(v79 + 624), v86[0], (NSURLRequestCachePolicy)[v87 _cachePolicy], 1);

                  if ((NewForStreamId & 1) == 0) {
                    *(unsigned char *)(v12 + 177) = 1;
                  }
                }
                std::__shared_weak_count::__release_shared[abi:nn180100](v78);
              }
            }
            dispatch_data_t subrange = dispatch_data_create_subrange(data2, *(unsigned __int8 *)(v12 + 176) - (unint64_t)v47, 0xFFFFFFFFFFFFFFFFLL);

            _Block_object_dispose(buf, 8);
LABEL_143:
            int v53 = HTTP3Stream::_handleHeaders(v12, v13 - *(unsigned __int8 *)(v12 + 176), subrange, a4);
            if (v53)
            {
LABEL_67:

              if (v53 == 2) {
                goto LABEL_110;
              }
              goto LABEL_112;
            }
          }
          else
          {
            if (a4)
            {
              uint64_t v80 = *(std::__shared_weak_count **)(v12 + 56);
              if (!v80) {
                goto LABEL_134;
              }
              v81 = std::__shared_weak_count::lock(v80);
              if (!v81) {
                goto LABEL_134;
              }
              uint64_t v78 = v81;
              uint64_t v82 = *(void *)(v12 + 48);
              if (v82)
              {
                *(void *)(v82 + 1160) = 4;
                *(_DWORD *)(v82 + 1168) = -1;
                HTTP3Connection::_cleanupConnection((HTTP3Connection *)v82, 262, 0);
                HTTP3Connection::reportServerProtocolViolation(v82, 54, *(void *)(v12 + 336));
              }
LABEL_133:
              std::__shared_weak_count::__release_shared[abi:nn180100](v78);
LABEL_134:
              _Block_object_dispose(buf, 8);
              goto LABEL_32;
            }
            _Block_object_dispose(buf, 8);
LABEL_75:
            dispatch_data_t subrange = data2;
          }
          break;
        case 7:
          goto LABEL_143;
        default:
          break;
      }
    }
    else
    {
      dispatch_data_t subrange = 0;
    }
LABEL_76:
    v107.CFIndex domain = a5;
    *(void *)&v107.error = a6;
    switch(HTTP3Stream::_translateError((HTTP3Stream *)v12, v107, 0))
    {
      case 1u:
        if (!a4)
        {
          uint64_t v72 = *(std::__shared_weak_count **)(v12 + 56);
          if (v72)
          {
            v73 = std::__shared_weak_count::lock(v72);
            if (v73)
            {
              uint64_t v74 = v73;
              uint64_t v75 = *(void *)(v12 + 48);
              if (v75)
              {
                *(void *)(v75 + 1160) = 4;
                *(_DWORD *)(v75 + 1168) = -1;
                HTTP3Connection::_cleanupConnection((HTTP3Connection *)v75, 262, 0);
                HTTP3Connection::reportServerProtocolViolation(v75, 49, *(void *)(v12 + 336));
              }
              std::__shared_weak_count::__release_shared[abi:nn180100](v74);
            }
          }
          goto LABEL_89;
        }
        int v60 = *(_DWORD *)(v12 + 116);
        if (v60 == 9 || v60 == 3)
        {
          *(_DWORD *)(v12 + 116) = 9;
          HTTP3Stream::_reportResult((HTTP3Stream *)v12, 1);
          *(unsigned char *)(v12 + 132) = 1;
          goto LABEL_109;
        }
        goto LABEL_87;
      case 2u:
        *(void *)(v12 + 264) = a5;
        *(void *)(v12 + 272) = a6;
        if (a5 == 1 && a6 == 57) {
          goto LABEL_109;
        }
        goto LABEL_89;
      case 3u:
LABEL_87:
        *(void *)(v12 + 264) = 4;
        int v59 = -4;
        goto LABEL_88;
      case 4u:
        *(void *)(v12 + 264) = 4;
        int v59 = -1;
LABEL_88:
        *(_DWORD *)(v12 + 272) = v59;
LABEL_89:
        HTTP3Stream::_reportResult((HTTP3Stream *)v12, 0);
        goto LABEL_109;
      case 5u:
        *(void *)(v12 + 264) = 4;
        int v67 = -2205;
        goto LABEL_108;
      case 6u:
        if (!*(_DWORD *)(v12 + 116)) {
          goto LABEL_107;
        }
        size_t v68 = *(std::__shared_weak_count **)(v12 + 56);
        if (v68)
        {
          uint64_t v69 = std::__shared_weak_count::lock(v68);
          if (v69)
          {
            dispatch_data_t v70 = v69;
            uint64_t v71 = *(void *)(v12 + 48);
            if (v71)
            {
              *(void *)(v71 + 1160) = 4;
              *(_DWORD *)(v71 + 1168) = -1;
              HTTP3Connection::_cleanupConnection((HTTP3Connection *)v71, 257, 0);
              HTTP3Connection::reportServerProtocolViolation(v71, 50, *(void *)(v12 + 336));
            }
            std::__shared_weak_count::__release_shared[abi:nn180100](v70);
          }
        }
        *(void *)(v12 + 264) = 4;
        int v67 = -1;
        goto LABEL_108;
      case 7u:
        uint64_t v62 = *(void *)(v12 + 296);
        if (v62) {
          uint64_t v63 = v62 - 176;
        }
        else {
          uint64_t v63 = 0;
        }
        id v64 = *(id *)(v63 + 80);
        uint64_t v65 = [v64 session];
        uint64_t v66 = [(id)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(void *)(v12 + 64) + 128)) host];
        if (v65) {
          -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:]((uint64_t)v65, v66, 80);
        }

LABEL_107:
        *(void *)(v12 + 264) = 4;
        int v67 = -2200;
LABEL_108:
        *(_DWORD *)(v12 + 272) = v67;
        goto LABEL_109;
      default:

        if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
        {
          *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
          uint64_t v58 = a1 + 6;
          goto LABEL_111;
        }
        HTTP3Stream::_read((HTTP3Stream *)a1[7], 1);
        break;
    }
    goto LABEL_112;
  }
LABEL_109:

LABEL_110:
  HTTP3Stream::_protocolCallback((HTTP3Stream *)a1[7]);
  uint64_t v58 = a1 + 5;
LABEL_111:
  *(unsigned char *)(*(void *)(*v58 + 8) + 24) = 0;
LABEL_112:
}

void sub_18414CC50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v27);
  _Block_object_dispose(&a27, 8);

  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::_translateError(HTTP3Stream *this, CFStreamError a2, int a3)
{
  uint64_t v3 = *(void *)&a2.error;
  if (a2.error)
  {
    uint64_t v6 = *(NSObject **)(*((void *)this + 3) + 48);
    uint64_t v7 = nw_protocol_copy_quic_connection_definition();
    nw_protocol_metadata_t v8 = nw_content_context_copy_protocol_metadata(v6, v7);

    uint64_t v9 = (void *)nw_quic_connection_copy_stream_metadata();
    uint64_t application_error = nw_quic_stream_get_application_error();

    uint64_t v3 = 5;
    switch(application_error)
    {
      case 257:
      case 259:
      case 260:
      case 261:
      case 262:
      case 264:
      case 265:
      case 266:
      case 270:
      case 271:
        return 4;
      case 258:
      case 268:
      case 269:
        return 3;
      case 263:
        return v3;
      case 267:
        return 6;
      case 272:
        return 7;
      default:
        if ((unint64_t)(application_error - 512) < 3) {
          return 4;
        }
        if (application_error == -1)
        {
          uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 7);
          if (v12)
          {
            uint64_t v13 = std::__shared_weak_count::lock(v12);
            if (v13)
            {
              uint64_t v14 = v13;
              uint64_t v15 = *((void *)this + 6);
              if (v15)
              {
                uint64_t v16 = *(void *)(v15 + 1008);
                if (!v16
                  || (*(unsigned char *)(v15 + 920) & 4) != 0
                  || (uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 120))(v16), v17 == -1))
                {
                  uint64_t v3 = 2;
                  goto LABEL_23;
                }
                if (v17 == 272)
                {
                  uint64_t v3 = 7;
LABEL_23:
                  std::__shared_weak_count::__release_shared[abi:nn180100](v14);
                  return v3;
                }
              }
              std::__shared_weak_count::__release_shared[abi:nn180100](v14);
            }
          }
          return 3;
        }
        if (a3) {
          uint64_t v3 = 1;
        }
        else {
          uint64_t v3 = 3;
        }
        break;
    }
  }
  return v3;
}

void sub_18414CEC0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke(void *a1)
{
  uint64_t v2 = a1[8];
  size_t size = *(void *)(*(void *)(a1[5] + 8) + 40);
  if (size) {
    size_t size = dispatch_data_get_size((dispatch_data_t)size);
  }
  *(void *)(v2 + 184) += size;
  if ((*(unsigned char *)(v2 + 33) & 0x20) != 0
    || ((int v4 = *(_DWORD *)(*(void *)(a1[6] + 8) + 56), v4 == 57) || v4 == 54)
    && (*(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1, (*(unsigned char *)(v2 + 33) & 0x20) != 0))
  {
    uint64_t v5 = *(void *)(a1[7] + 8);
    if (*(unsigned char *)(v5 + 24))
    {
      if (!*(_DWORD *)(*(void *)(a1[6] + 8) + 56))
      {
        *(unsigned char *)(v5 + 24) = 0;
        *(void *)(*(void *)(a1[6] + 8) + 48) = 4;
        *(_DWORD *)(*(void *)(a1[6] + 8) + 56) = -4;
      }
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  uint64_t v6 = *(NSObject **)(*(void *)(a1[5] + 8) + 40);
  if (v6)
  {
    dispatch_release(v6);
  }
}

void HTTPEngine::_readBodyStartNextRead(HTTPEngine *this)
{
  int v1 = *((_DWORD *)this + 8);
  if ((v1 & 0x400) != 0)
  {
    *((_DWORD *)this + 8) = v1 | 0x1000;
  }
  else
  {
    if ((v1 & 0x2000) == 0)
    {
      uint64_t v5 = MEMORY[0x1E4F143A8];
      uint64_t v6 = 3221225472;
      uint64_t v2 = ___ZN10HTTPEngine14_readBodyPlainEv_block_invoke;
LABEL_4:
      uint64_t v7 = v2;
      nw_protocol_metadata_t v8 = &__block_descriptor_40_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
      uint64_t v9 = this;
      HTTPEngine::_getBodyIntelligently((uint64_t)this, (uint64_t)&v5);
      return;
    }
    if ((v1 & 0x8000) != 0)
    {
      HTTPEngine::_chunkedReadTrailer(this);
    }
    uint64_t v3 = *((void *)this + 22);
    if (v3 != -3 && v3 != *((void *)this + 23))
    {
      uint64_t v5 = MEMORY[0x1E4F143A8];
      uint64_t v6 = 3221225472;
      uint64_t v2 = ___ZN10HTTPEngine16_chunkedReadBodyEv_block_invoke;
      goto LABEL_4;
    }
    v4.CFIndex domain = 0;
    *(void *)&v4.error = 0;
    HTTPEngine::_chunkedParseHeader(this, v4);
  }
}

void HTTPEngine::_getBodyIntelligently(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = 132000;
  uint64_t v55 = 0;
  size_t v56 = &v55;
  uint64_t v57 = 0x3052000000;
  uint64_t v58 = __Block_byref_object_copy__32;
  int v59 = __Block_byref_object_dispose__33;
  uint64_t v60 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = &v47;
  uint64_t v49 = 0x4012000000;
  uint64_t v50 = __Block_byref_object_copy__18998;
  uint64_t v51 = __Block_byref_object_dispose__18999;
  uint64_t v52 = &unk_18441BEED;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = &v43;
  uint64_t v45 = 0x2020000000;
  char v46 = 0;
  v42[0] = MEMORY[0x1E4F143A8];
  v42[1] = 3221225472;
  v42[2] = ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke;
  v42[3] = &unk_1E52575D0;
  v42[7] = &v43;
  v42[8] = a1;
  v42[5] = &v55;
  v42[6] = &v47;
  v42[4] = a2;
  uint64_t v5 = *(void *)(a1 + 160);
  if (v5)
  {
    uint64_t v6 = (*(uint64_t (**)(void))(v5 + 16))();
    if (v6 <= 132001) {
      unsigned int v4 = 132000;
    }
    else {
      unsigned int v4 = v6 - 1;
    }
  }
  int v7 = *(_DWORD *)(a1 + 32);
  int v8 = v7 & 0x700000;
  if ((v7 & 0x700000) != 0)
  {
    unsigned int v9 = *(_DWORD *)(a1 + 224);
    double v10 = *(double *)(a1 + 232);
    if ((v7 & 0x600000) != 0)
    {
      if ((v7 & 0x400000) != 0) {
        unsigned int v4 = 0x10000;
      }
      else {
        unsigned int v4 = *(_DWORD *)(a1 + 224);
      }
      if ((v7 & 0x400000) != 0) {
        double v10 = 0.2;
      }
      unsigned int v9 = v4;
    }
  }
  else
  {
    unsigned int v9 = 1;
    double v10 = 0.0;
  }
  uint64_t v11 = *(void *)(a1 + 176);
  if (v11 != -1)
  {
    unint64_t v12 = v11 - *(void *)(a1 + 184);
    if (v12 < v4) {
      unsigned int v4 = v12;
    }
  }
  if (v9 >= v4) {
    size_t v13 = v4;
  }
  else {
    size_t v13 = v9;
  }
  if (!v4)
  {
    *((unsigned char *)v44 + 24) = 1;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 16))(a2, v56[5], v48[6], v48[7], 1);
    goto LABEL_60;
  }
  uint64_t v14 = *(NSObject **)(a1 + 192);
  if (v14)
  {
    size_t size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 192));
    if (size)
    {
      if (!v8 || size >= v13)
      {
        if (size <= v4)
        {
          v56[5] = (uint64_t)v14;
          *(void *)(a1 + 192) = 0;
        }
        else
        {
          dispatch_data_t subrange = dispatch_data_create_subrange(v14, 0, v4);
          v56[5] = (uint64_t)subrange;
          HTTPEngine::_readBufferConsume((HTTPEngine *)a1, v4);
        }
        uint64_t v22 = *(std::__shared_weak_count **)(a1 + 48);
        if (v22)
        {
          uint64_t v17 = std::__shared_weak_count::lock(v22);
          if (v17) {
            uint64_t v23 = *(void *)(a1 + 40);
          }
          else {
            uint64_t v23 = 0;
          }
        }
        else
        {
          uint64_t v23 = 0;
          uint64_t v17 = 0;
        }
        id v27 = *(NSObject **)(a1 + 72);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3321888768;
        block[2] = ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_2;
        block[3] = &unk_1ECFA9FA0;
        block[6] = v23;
        uint64_t v39 = v17;
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v40 = v13;
        unsigned int v41 = v4;
        block[4] = v42;
        void block[5] = &v55;
        dispatch_async(v27, block);
        int v26 = v39;
        if (!v39) {
          goto LABEL_58;
        }
LABEL_57:
        std::__shared_weak_count::__release_shared[abi:nn180100](v26);
LABEL_58:
        if (v17) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v17);
        }
        goto LABEL_60;
      }
      LODWORD(v13) = v13 - size;
      v4 -= size;
    }
  }
  if ((v7 & 1) == 0)
  {
    uint64_t v16 = *(std::__shared_weak_count **)(a1 + 48);
    if (v16)
    {
      uint64_t v17 = std::__shared_weak_count::lock(v16);
      if (v17) {
        uint64_t v18 = *(void *)(a1 + 40);
      }
      else {
        uint64_t v18 = 0;
      }
    }
    else
    {
      uint64_t v18 = 0;
      uint64_t v17 = 0;
    }
    v36[0] = MEMORY[0x1E4F143A8];
    v36[1] = 3321888768;
    v36[2] = ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_36;
    v36[3] = &unk_1ECFAA570;
    v36[5] = &v47;
    v36[6] = &v43;
    v36[8] = a1;
    v36[9] = v18;
    uint64_t v37 = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v36[7] = &v55;
    v36[4] = v42;
    if (*(unsigned char *)(a1 + 34))
    {
      ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_36(v36, 0, 0, 0, 0);
      goto LABEL_56;
    }
    uint64_t v24 = *(void *)(a1 + 112);
    if (v8)
    {
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 3321888768;
      void aBlock[2] = ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_40;
      aBlock[3] = &unk_1ECFA9918;
      void aBlock[5] = v18;
      unsigned int v29 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v30 = v13;
      unsigned int v31 = v4;
      aBlock[4] = v36;
      ConnectionReadAggregator::read(v24, v13, v4, aBlock, v10);
      uint64_t v25 = v29;
      if (!v29) {
        goto LABEL_56;
      }
    }
    else
    {
      v32[0] = MEMORY[0x1E4F143A8];
      v32[1] = 3321888768;
      v32[2] = ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_37;
      v32[3] = &unk_1ECFA9918;
      v32[5] = v18;
      uint64_t v33 = v17;
      if (v17) {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v34 = v13;
      unsigned int v35 = v4;
      v32[4] = v36;
      ConnectionReadAggregator::read(v24, v13, v4, v32, 0.0);
      uint64_t v25 = v33;
      if (!v33)
      {
LABEL_56:
        int v26 = v37;
        if (!v37) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }
    }
    std::__shared_weak_count::__release_shared[abi:nn180100](v25);
    goto LABEL_56;
  }
  int v19 = v48;
  *((_OWORD *)v48 + 3) = *(_OWORD *)(a1 + 96);
  if (*((_DWORD *)v19 + 14))
  {
    uint64_t v20 = v19[6];
  }
  else
  {
    uint64_t v20 = 4;
    v19[6] = 4;
    *((_DWORD *)v19 + 14) = -4;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(a2 + 16))(a2, v56[5], v20, v19[7], *((unsigned __int8 *)v44 + 24));
LABEL_60:
  _Block_object_dispose(&v43, 8);
  _Block_object_dispose(&v47, 8);
  _Block_object_dispose(&v55, 8);
}

void sub_18414D6B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,std::__shared_weak_count *a36)
{
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a24);
  }
  if (a36) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a36);
  }
  if (v36) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v36);
  }
  _Block_object_dispose((const void *)(v37 - 224), 8);
  _Block_object_dispose((const void *)(v37 - 192), 8);
  _Block_object_dispose((const void *)(v37 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN9Throttler24getByteHeadroomInfoBlockEv_block_invoke(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 32) + 104) - *(void *)(*(void *)(a1 + 32) + 88);
}

void ___ZN10HTTPEngine14_readBodyPlainEv_block_invoke(uint64_t a1, dispatch_data_t data, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v9 = *(HTTPEngine **)(a1 + 32);
  uint64_t v10 = *((void *)v9 + 41);
  if (data)
  {
    size_t size = dispatch_data_get_size(data);
    if (!v10) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  size_t size = 0;
  if (v10) {
LABEL_3:
  }
    *(void *)(v10 + 136) += size;
LABEL_4:

  HTTPEngine::_deliverBodyBytes(v9, (uint64_t)data, a3, a4, a5);
}

void HTTPEngine::_deliverBodyBytes(HTTPEngine *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v5 = a4;
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = a4 & 0xFFFFFFFF00000000;
  if (a4)
  {
    if ((*((unsigned char *)this + 34) & 6) == 0)
    {
LABEL_14:
      HTTPEngine::_readBodyFinish((uint64_t)this, a2, a3, v5 | v9, a5);
      return;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v10 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      if ((*((_DWORD *)this + 8) & 0x20000) != 0) {
        int v11 = 300;
      }
      else {
        int v11 = 401;
      }
      v13[0] = 67109376;
      v13[1] = v5;
      __int16 v14 = 1024;
      int v15 = v11;
      _os_log_impl(&dword_184085000, v10, OS_LOG_TYPE_DEFAULT, "Received readError %d but saw a %d status so sending EOF", (uint8_t *)v13, 0xEu);
    }
    unsigned int v5 = 0;
    a3 = 0;
LABEL_13:
    a5 = 1;
    goto LABEL_14;
  }
  if (a5)
  {
    unsigned int v5 = 0;
    goto LABEL_13;
  }
  HTTPEngine::_updateBytesTransferred(this);
  uint64_t v12 = *((void *)this + 26);
  if (v12) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, unint64_t, void))(v12 + 16))(v12, a2, a3, v9, 0);
  }

  HTTPEngine::_readBodyStartNextRead(this);
}

void non-virtual thunk to'NWIOConnection::readWithContext(uint64_t a1, uint64_t a2, uint32_t a3, uint32_t a4, uint64_t a5)
{
}

uint64_t HTTP3Connection::checkAndPerformFallback(HTTP3Connection *this, CFStreamError a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  char v2 = *((unsigned char *)this + 920);
  if ((v2 & 0x10) != 0) {
    return 1;
  }
  uint64_t result = 0;
  if ((v2 & 0x20) != 0 && a2.domain == 1 && a2.error == 60)
  {
    unsigned int v5 = CFN_LOG_h3connection();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = *((void *)this + 152);
      *(_DWORD *)buf = 134218240;
      *(void *)&buf[4] = this;
      __int16 v26 = 2048;
      uint64_t v27 = v20;
      _os_log_error_impl(&dword_184085000, v5, OS_LOG_TYPE_ERROR, "%p %llu stalled, attempting fallback", buf, 0x16u);
    }

    *((unsigned char *)this + 920) |= 0x10u;
    HTTP3Connection::_stopStallRecovery(this);
    uint64_t v6 = *((void *)this + 126);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 128))(v6, 1);
    }
    long long v24 = xmmword_1843D1780;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(&v21, *((void **)this + 142), *((void **)this + 143), (uint64_t)(*((void *)this + 143) - *((void *)this + 142)) >> 4);
    int v7 = v21;
    for (i = v22; v7 != i; v7 += 2)
    {
      uint64_t v10 = *v7;
      unint64_t v9 = (std::__shared_weak_count *)v7[1];
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if ((*(unsigned int (**)(void, long long *, void))(**(void **)(v10 + 296) + 280))(*(void *)(v10 + 296), &v24, 0)- 5 <= 5)
      {
        int v11 = CFN_LOG_h3stream();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          uint64_t v18 = *(void *)(v10 + 352);
          uint64_t v19 = *(void *)(v10 + 336);
          *(_DWORD *)buf = 138543874;
          *(void *)&buf[4] = v18;
          __int16 v26 = 2048;
          uint64_t v27 = v10;
          __int16 v28 = 2048;
          uint64_t v29 = v19;
          _os_log_error_impl(&dword_184085000, v11, OS_LOG_TYPE_ERROR, "%{public}@ %p ID=%llu handling fallback", buf, 0x20u);
        }

        uint64_t v12 = *(void *)(v10 + 296);
        if (v12) {
          uint64_t v13 = v12 - 176;
        }
        else {
          uint64_t v13 = 0;
        }
        id v14 = *(id *)(v13 + 80);
        int v15 = [v14 session];
        uint64_t v16 = [(id)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(void *)(v10 + 64) + 128)) host];
        -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:]((uint64_t)v15, v16, 64);

        long long v17 = v24;
        HTTP3Stream::_cleanupStream(v10, 256, 0);
        *(_OWORD *)(v10 + 264) = v17;
        HTTP3Stream::_protocolCallback((HTTP3Stream *)v10);
      }
      if (v9) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v9);
      }
    }
    HTTP3Connection::_cleanupConnection(this, 256, 0);
    *(void *)buf = &v21;
    std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
    return 1;
  }
  return result;
}

void sub_18414DC94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  a17 = (void **)&a12;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a17);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::getQUICApplicationError(nw_connection_t *this)
{
  char v2 = nw_protocol_copy_quic_connection_definition();
  nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(this[34], v2);
  if (!v3)
  {
    uint64_t application_error = -1;
    if (!v2) {
      return application_error;
    }
    goto LABEL_3;
  }
  uint64_t application_error = nw_quic_connection_get_application_error();
  nw_release(v3);
  if (v2) {
LABEL_3:
  }
    nw_release(v2);
  return application_error;
}

void sub_18414DD8C(_Unwind_Exception *a1)
{
  nw_release(v2);
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

void HTTP3Stream::_reportResult(HTTP3Stream *this, int a2)
{
  nw_protocol_metadata_t v3 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v3)
  {
    unsigned int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *((void *)this + 6);
      if (v7)
      {
        uint64_t v8 = *(void *)(v7 + 1008);
        unint64_t v9 = *(std::__shared_weak_count **)(v7 + 1016);
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v8) {
          (*(void (**)(uint64_t, void))(*(void *)v8 + 128))(v8, a2 ^ 1u);
        }
        if (v9) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v9);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }
}

void sub_18414DE70(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void NWIOConnection::reportQUICApplicationResult(uint64_t a1)
{
  if (*(void *)(a1 + 272))
  {
    char v2 = nw_protocol_copy_quic_connection_definition();
    nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(*(nw_connection_t *)(a1 + 272), v2);
    if (v3)
    {
      nw_quic_connection_report_application_result();
      nw_release(v3);
    }
    if (v2)
    {
      nw_release(v2);
    }
  }
}

void sub_18414DF20(_Unwind_Exception *a1)
{
  nw_release(v2);
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t cf_nghttp2_data_source_read_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t stream_user_data = (void *)nghttp2_session_get_stream_user_data();
  if (!stream_user_data) {
    return -521;
  }
  uint64_t v10 = (void *)*stream_user_data;
  unint64_t v9 = (std::__shared_weak_count *)stream_user_data[1];
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = v10[4];
  if (v11 && *(_DWORD *)(v11 + 40))
  {
    uint64_t v12 = v10[33];
    if (!v12 || ((*(uint64_t (**)(uint64_t))(*(void *)v12 + 72))(v12) & 1) != 0)
    {
      int64_t size = -521;
      goto LABEL_18;
    }
    uint64_t v14 = v10[33];
    if (v14 && (*(unsigned int (**)(uint64_t))(*(void *)v14 + 80))(v14))
    {
      uint64_t v15 = v10[33];
      if (v15)
      {
        char v30 = 0;
        uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)v15 + 88))(v15, a4, &v30);
        long long v17 = v16;
        if (v16)
        {
          int64_t size = dispatch_data_get_size(v16);
          if (size >= 1)
          {
            v29[0] = MEMORY[0x1E4F143A8];
            v29[1] = 3221225472;
            uint64_t v29[2] = ___ZN11HTTP2Stream15provideBodyDataEPhmPj_block_invoke;
            void v29[3] = &__block_descriptor_40_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
            v29[4] = a3;
            dispatch_data_apply(v17, v29);
            -[__CFN_TransactionMetrics requestBody:](v10[38], v17);
          }
          dispatch_release(v17);
        }
        else
        {
          int64_t size = 0;
        }
        if (v30)
        {
          *a5 |= 1u;
          uint64_t v19 = (*(uint64_t (**)(void))(*(void *)v10[33] + 56))(v10[33]);
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          uint64_t v20 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v21 = v10[27];
            if (v19 < 0) {
              int v22 = 83;
            }
            else {
              int v22 = 68;
            }
            uint64_t v23 = v10[33];
            if (v23) {
              uint64_t v23 = *(void *)(v23 + 96);
            }
            *(_DWORD *)buf = 138543874;
            uint64_t v32 = v21;
            __int16 v33 = 1024;
            int v34 = v22;
            __int16 v35 = 2048;
            uint64_t v36 = v23;
            _os_log_impl(&dword_184085000, v20, OS_LOG_TYPE_DEFAULT, "%{public}@ sent request, body %c %lld", buf, 0x1Cu);
          }
          uint64_t v24 = v10[8];
          uint64_t v25 = (std::__shared_weak_count *)v10[36];
          if (v25 && (__int16 v26 = std::__shared_weak_count::lock(v25)) != 0)
          {
            uint64_t v27 = v26;
            HTTP2Connection::streamEnteredStallableState(v24, v10[35], v26);
            std::__shared_weak_count::__release_shared[abi:nn180100](v27);
          }
          else
          {
            HTTP2Connection::streamEnteredStallableState(v24, 0, 0);
          }
          uint64_t v28 = v10[38];
          if (v28) {
            *(CFAbsoluteTime *)(v28 + 184) = CFAbsoluteTimeGetCurrent();
          }
        }
      }
      else
      {
        int64_t size = 0;
      }
      goto LABEL_18;
    }
  }
  int64_t size = -508;
LABEL_18:
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  return size;
}

void sub_18414E274(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL RequestBodyStream::errorEncountered(RequestBodyStream *this)
{
  int v1 = *((_DWORD *)this + 44);
  if (v1) {
    RequestBody::_onqueue_updateUploadStatus((RequestBody *)this, 0, 1);
  }
  return v1 != 0;
}

BOOL RequestBodyStream::canProvideData(RequestBodyStream *this)
{
  return *((void *)this + 20) || *((unsigned char *)this + 184) != 0;
}

void HTTP2Connection::streamEnteredStallableState(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a2)
  {
    nw_protocol_metadata_t v3 = *(void **)(a1 + 648);
    if (v3)
    {
      v5[0] = a2;
      v5[1] = (uint64_t)a3;
      if (a3)
      {
        atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
        HTTPStallTimer::add(v3, v5);
        std::__shared_weak_count::__release_shared[abi:nn180100](a3);
      }
      else
      {
        HTTPStallTimer::add(v3, v5);
      }
    }
  }
}

void HTTPStallTimer::add(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1];
  nw_protocol_metadata_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v4 = a1[3];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3321888768;
  v6[2] = ___ZN14HTTPStallTimer3addENSt3__110shared_ptrIvEE_block_invoke;
  v6[3] = &__block_descriptor_64_e8_32c39_ZTSNSt3__18weak_ptrI14HTTPStallTimerEE48c27_ZTSNSt3__110shared_ptrIvEE_e5_v8__0l;
  v6[4] = v2;
  uint64_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  unsigned int v5 = (std::__shared_weak_count *)a2[1];
  uint64_t v8 = *a2;
  unint64_t v9 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_async(v4, v6);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

NSObject *RequestBodyStream::provideData(RequestBodyStream *this, size_t a2, BOOL *a3)
{
  unsigned int v5 = *((void *)this + 20);
  if (v5)
  {
    size_t size = dispatch_data_get_size(*((dispatch_data_t *)this + 20));
    size_t v8 = size - a2;
    if (size <= a2)
    {
      *((void *)this + 20) = 0;
      a2 = size;
    }
    else
    {
      dispatch_data_t subrange = dispatch_data_create_subrange(v5, 0, a2);
      *((void *)this + 20) = dispatch_data_create_subrange(v5, a2, v8);
      dispatch_release(v5);
      unsigned int v5 = subrange;
    }
  }
  else
  {
    a2 = 0;
  }
  if (*((unsigned char *)this + 184)) {
    BOOL v10 = *((void *)this + 20) == 0;
  }
  else {
    BOOL v10 = 0;
  }
  *a3 = v10;
  RequestBody::_onqueue_updateUploadStatus((RequestBody *)this, a2, v10);
  if (!*((unsigned char *)this + 184)) {
    RequestBodyStream::_onqueue_resume(this);
  }
  return v5;
}

void RequestBody::_onqueue_updateUploadStatus(RequestBody *this, uint64_t a2, int a3)
{
  *((void *)this + 12) += a2;
  *((void *)this + 4) += a2;
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v11, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3321888768;
  uint64_t v7 = ___ZN11RequestBody27_onqueue_updateUploadStatusElb_block_invoke;
  size_t v8 = &__block_descriptor_48_e8_32c39_ZTSNSt3__110shared_ptrI11RequestBodyEE_e5_v8__0l;
  uint64_t v9 = v11;
  BOOL v10 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a3)
  {
    v7((uint64_t)v6);
  }
  else if (!*((unsigned char *)this + 40) {
         && *((void *)this + 7)
  }
         && (*(unsigned int (**)(RequestBody *))(*(void *)this + 48))(this))
  {
    *((unsigned char *)this + 40) = 1;
    dispatch_time_t v5 = dispatch_time(0, 100000000);
    dispatch_after(v5, *((dispatch_queue_t *)this + 6), v6);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
}

void sub_18414E650(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(v14 - 24);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN11RequestBody27_onqueue_updateUploadStatusElb_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  *(unsigned char *)(result + 40) = 0;
  if (*(uint64_t *)(result + 32) >= 1)
  {
    if (*(void *)(result + 56))
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result);
      if (result)
      {
        uint64_t v3 = *(void *)(a1 + 32);
        uint64_t v4 = *(void *)(v3 + 32);
        *(void *)(v3 + 32) = 0;
        uint64_t v5 = *(void *)(v3 + 56);
        if (v5) {
          uint64_t v6 = v5 - 176;
        }
        else {
          uint64_t v6 = 0;
        }
        CFRetain((CFTypeRef)(v6 - 16));
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = *(void *)(v7 + 96);
        uint64_t v9 = *(void *)(v7 + 64);
        v10[0] = MEMORY[0x1E4F143A8];
        v10[1] = 3221225472;
        v10[2] = ___ZN11RequestBody27_onqueue_updateUploadStatusElb_block_invoke_2;
        v10[3] = &__block_descriptor_56_e5_v8__0l;
        v10[4] = v6;
        v10[5] = v4;
        void v10[6] = v8;
        return (*(uint64_t (**)(uint64_t, void *))(*(void *)v9 + 96))(v9, v10);
      }
    }
  }
  return result;
}

uint64_t ___ZN11HTTP2Stream15provideBodyDataEPhmPj_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  return 1;
}

CFDataRef ___ZN13ATSTLSCiphers22DefaultPFSCipherSuitesEv_block_invoke()
{
  CFDataRef result = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)kATSv1PFSCiphers, 38, 0);
  ATSTLSCiphers::DefaultPFSCipherSuites(void)::cipherData = (uint64_t)result;
  return result;
}

BOOL ___ZN11HTTP3Stream14_handleHeadersEmPU27objcproto16OS_dispatch_data8NSObjectb_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1[6];
  uint64_t v8 = *(std::__shared_weak_count **)(v7 + 56);
  if (v8)
  {
    unint64_t v10 = a1[7];
    uint64_t v11 = std::__shared_weak_count::lock(v8);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = *(void *)(v7 + 48);
      if (v13)
      {
        uint64_t v25 = a4;
        size_t size = 10;
        if (*(unsigned char *)(v7 + 130))
        {
          uint64_t v14 = *(void *)(v7 + 336);
          if (v10 > 1)
          {
            long long v39 = 0u;
            long long v40 = 0u;
            long long v37 = 0u;
            long long v38 = 0u;
            uint64_t v35 = 0;
            long long v36 = 0u;
            long long v32 = 0u;
            long long v33 = 0u;
            memset(v27, 0, sizeof(v27));
            uint64_t v28 = v7;
            uint64_t v29 = v14;
            unint64_t v30 = v10;
            unint64_t v31 = v10;
            int v34 = parse_header_prefix;
            uint64_t v19 = *(FILE **)(v13 + 320);
            if (v19)
            {
              fwrite("qdec: debug: ", 0xDuLL, 1uLL, v19);
              fprintf(*(FILE **)(v13 + 320), "begin reading header block for stream %llu", v14);
              fputc(10, *(FILE **)(v13 + 320));
            }
            int v16 = qdec_header_process(v13 + 272, v27, &v25, a5, buffer, &size);
          }
          else
          {
            uint64_t v15 = *(FILE **)(v13 + 320);
            if (v15)
            {
              fwrite("qdec: debug: ", 0xDuLL, 1uLL, v15);
              fprintf(*(FILE **)(v13 + 320), "header block for stream %llu is too short (%zd byte%.*s)", v14, v10, v10 != 1, "s");
              fputc(10, *(FILE **)(v13 + 320));
            }
            *(void *)(v13 + 600) = 0x10AF00000000;
            *(void *)(v13 + 608) = 0;
            *(void *)(v13 + 616) = v14;
            int v16 = 3;
          }
          *(unsigned char *)(v7 + 130) = 0;
LABEL_20:
          a5 = v25 - a4;
          if (!v16)
          {
            *(void *)(v7 + 192) = *(void *)(v7 + 184);
            uint64_t v20 = *(void *)(v7 + 344);
            uint64_t v21 = *(void *)(v13 + 1208);
            *(void *)(v13 + 1208) = 0;
            if (v20) {
              *(void *)(v20 + 120) += v21;
            }
            if (size)
            {
              dispatch_data_t v22 = dispatch_data_create(buffer, size, 0, 0);
              HTTP3Connection::writeDecoderStream(v13, v22);
            }
            int v16 = 0;
            *(unsigned char *)(v7 + 130) = 1;
          }
          goto LABEL_30;
        }
        long long v17 = (void *)(v13 + 352);
        while (1)
        {
          long long v17 = (void *)*v17;
          if (!v17) {
            break;
          }
          if (v17[4] == v7)
          {
            uint64_t v18 = *(FILE **)(v13 + 320);
            if (v18)
            {
              fwrite("qdec: debug: ", 0xDuLL, 1uLL, v18);
              fprintf(*(FILE **)(v13 + 320), "continue reading header block for stream %llu", v17[5]);
              fputc(10, *(FILE **)(v13 + 320));
            }
            int v16 = qdec_header_process(v13 + 272, v17, &v25, a5, buffer, &size);
            goto LABEL_20;
          }
        }
        uint64_t v23 = *(FILE **)(v13 + 320);
        if (v23)
        {
          fwrite("qdec: info: ", 0xCuLL, 1uLL, v23);
          fwrite("could not find header block to continue reading", 0x2FuLL, 1uLL, *(FILE **)(v13 + 320));
          fputc(10, *(FILE **)(v13 + 320));
        }
        a5 = 0;
      }
      int v16 = 3;
LABEL_30:
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
      goto LABEL_31;
    }
  }
  int v16 = 3;
LABEL_31:
  *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = v16;
  *(void *)(*(void *)(a1[5] + 8) + 24) += a5;
  return *(_DWORD *)(*(void *)(a1[4] + 8) + 24) == 2;
}

void sub_18414EC34(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t qdec_header_process(uint64_t a1, void *a2, void *a3, uint64_t a4, unsigned char *a5, void *a6)
{
  uint64_t v9 = a2;
  a2[14] = *a3;
  a2[15] = a4;
  a2[16] = 0;
  unint64_t v11 = a2[7];
  while (2)
  {
    if (!v11)
    {
LABEL_30:
      float v37 = *(float *)(a1 + 228);
      float v38 = (float)*((unsigned int *)v9 + 18);
      if (v37 != 0.0) {
        float v38 = v37 + (float)(v38 - v37) * 0.4;
      }
      *(float *)(a1 + 228) = v38;
      if (a6 && a5 && (*((_DWORD *)v9 + 26) & 2) != 0)
      {
        if (!*a6) {
          goto LABEL_40;
        }
        unint64_t v39 = *((void *)v9 + 5);
        *a5 = 0x80;
        long long v40 = lsqpack_enc_int(a5, (unint64_t)&a5[*a6], v39, 7);
        uint64_t v41 = v40 - a5;
        if (v40 <= a5) {
          goto LABEL_40;
        }
        *a6 = v41;
        unsigned int v42 = *(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 24) += v41;
        if (v42)
        {
          int v43 = *((_DWORD *)v9 + 16);
          unsigned int v44 = v43 + 2 * v42 - *(_DWORD *)(a1 + 36);
          if (~(v44 / (2 * v42) * 2 * v42) + v44 < v42) {
            *(_DWORD *)(a1 + 36) = v43;
          }
        }
      }
      else if (a6)
      {
        *a6 = 0;
      }
      *a3 += *((void *)v9 + 16);
      unsigned int v46 = *(_DWORD *)(a1 + 28);
      unsigned int v47 = *(_DWORD *)(a1 + 24) + *((_DWORD *)v9 + 12);
      *(_DWORD *)(a1 + 24) = v47;
      if (v46 >= 0x80000001)
      {
        *(_DWORD *)(a1 + 24) = (float)((float)((float)v47 / (float)v46) * 1000.0);
        *(_DWORD *)(a1 + 28) = 1000;
        uint64_t v48 = *(FILE **)(a1 + 48);
        if (v48)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v48);
          uint64_t v49 = *(FILE **)(a1 + 48);
          float v50 = lsqpack_dec_ratio(a1);
          fprintf(v49, "reset bytes in/out counters, ratio: %.3f", v50);
          fputc(10, *(FILE **)(a1 + 48));
        }
      }
      uint64_t v18 = (FILE **)(a1 + 48);
      uint64_t v51 = *(FILE **)(a1 + 48);
      if (v51)
      {
        fwrite("qdec: debug: ", 0xDuLL, 1uLL, v51);
        fprintf(*v18, "header block for stream %llu is done", *((void *)v9 + 5));
        uint64_t v34 = 0;
        goto LABEL_28;
      }
      uint64_t v34 = 0;
LABEL_41:
      if ((*((unsigned char *)v9 + 104) & 0x10) != 0) {
        destroy_header_block_read_ctx(a1, (uint64_t *)v9);
      }
      return v34;
    }
    int v12 = *((_DWORD *)v9 + 26);
    if (v12) {
      unint64_t v13 = v11;
    }
    else {
      unint64_t v13 = 1;
    }
    uint64_t v14 = *((void *)v9 + 16);
    uint64_t v15 = *((void *)v9 + 14);
    if (*((void *)v9 + 15) - v14 >= v13) {
      unint64_t v16 = v13;
    }
    else {
      unint64_t v16 = *((void *)v9 + 15) - v14;
    }
    *((void *)v9 + 16) = v16 + v14;
    if (v16)
    {
      *((void *)v9 + 7) = v11 - v16;
      switch((*((unsigned int (**)(uint64_t, _OWORD *, uint64_t, unint64_t))v9 + 12))(a1, v9, v15 + v14, v16))
      {
        case 0u:
          goto LABEL_30;
        case 1u:
          int v12 = *((_DWORD *)v9 + 26);
          goto LABEL_15;
        case 2u:
          unint64_t v11 = *((void *)v9 + 7);
          if (!v11) {
            goto LABEL_12;
          }
          continue;
        case 3u:
LABEL_12:
          uint64_t v18 = (FILE **)(a1 + 48);
          long long v17 = *(FILE **)(a1 + 48);
          if (!v17) {
            goto LABEL_40;
          }
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v17);
          fprintf(*v18, "header block for stream %llu has had an error");
          break;
        default:
          __assert_rtn("qdec_header_process", "lsqpack.c", 4223, "st == LQRHS_ERROR");
      }
      goto LABEL_27;
    }
    break;
  }
LABEL_15:
  if ((v12 & 0x10) == 0)
  {
    uint64_t v19 = malloc_type_malloc(0xC0uLL, 0x10F0040D151BEFFuLL);
    if (v19)
    {
      long long v20 = v9[3];
      long long v22 = *v9;
      long long v21 = v9[1];
      v19[2] = v9[2];
      v19[3] = v20;
      *uint64_t v19 = v22;
      v19[1] = v21;
      long long v23 = v9[4];
      long long v24 = v9[5];
      long long v25 = v9[7];
      v19[6] = v9[6];
      v19[7] = v25;
      v19[4] = v23;
      v19[5] = v24;
      long long v26 = v9[8];
      long long v27 = v9[9];
      long long v28 = v9[11];
      v19[10] = v9[10];
      v19[11] = v28;
      v19[8] = v26;
      v19[9] = v27;
      uint64_t v29 = *(void **)(a1 + 88);
      *(void *)uint64_t v19 = 0;
      *((void *)v19 + 1) = v29;
      *uint64_t v29 = v19;
      *(void *)(a1 + 88) = v19;
      int v12 = *((_DWORD *)v19 + 26) | 0x10;
      *((_DWORD *)v19 + 26) = v12;
      uint64_t v9 = v19;
      goto LABEL_18;
    }
LABEL_40:
    uint64_t v34 = 3;
    goto LABEL_41;
  }
LABEL_18:
  if (v16)
  {
    unsigned int v30 = *(_DWORD *)(a1 + 224);
    if (v30 < *(_DWORD *)(a1 + 16))
    {
      uint64_t v31 = v9[4] & 7;
      *((void *)v9 + 2) = 0;
      uint64_t v32 = a1 + 16 * v31;
      *((void *)v9 + 3) = *(void *)(v32 + 104);
      **(void **)(v32 + 104) = v9;
      *(void *)(v32 + 104) = v9 + 1;
      *(_DWORD *)(a1 + 224) = v30 + 1;
      *((_DWORD *)v9 + 26) = v12 | 4;
      *a3 += *((void *)v9 + 16);
      long long v33 = *(FILE **)(a1 + 48);
      uint64_t v34 = 1;
      if (v33)
      {
        fwrite("qdec: debug: ", 0xDuLL, 1uLL, v33);
        fprintf(*(FILE **)(a1 + 48), "header block for stream %llu is blocked", *((void *)v9 + 5));
        fputc(10, *(FILE **)(a1 + 48));
      }
      return v34;
    }
    uint64_t v18 = (FILE **)(a1 + 48);
    long long v36 = *(FILE **)(a1 + 48);
    if (v36)
    {
      fwrite("qdec: info: ", 0xCuLL, 1uLL, v36);
      fprintf(*(FILE **)(a1 + 48), "cannot block another header: reached maximum of %u");
LABEL_27:
      uint64_t v34 = 3;
LABEL_28:
      fputc(10, *v18);
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  *a3 += *((void *)v9 + 16);
  uint64_t v35 = *(FILE **)(a1 + 48);
  if (v35)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v35);
    fprintf(*(FILE **)(a1 + 48), "header block for stream %llu needs more bytes", *((void *)v9 + 5));
    fputc(10, *(FILE **)(a1 + 48));
  }
  return 2;
}

uint64_t parse_header_prefix(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  long long v28 = a3;
  if (a4 < 1)
  {
LABEL_19:
    if (*(void *)(a2 + 56)) {
      return 2;
    }
    else {
      return 3;
    }
  }
  uint64_t v6 = &a3[a4];
  uint64_t v7 = (unint64_t *)(a2 + 168);
  int v8 = *(_DWORD *)(a2 + 136);
  char v9 = -1;
  while (2)
  {
    switch(v8)
    {
      case 0:
        *(_DWORD *)(a2 + 144) = 0;
        *(_DWORD *)(a2 + 136) = 1;
        char v9 = 8;
        goto LABEL_5;
      case 1:
LABEL_5:
        int v10 = lsqpack_dec_int(&v28, (unint64_t)v6, v9, (uint64_t *)(a2 + 168), (int *)(a2 + 144));
        if (!v10)
        {
          unint64_t v11 = *v7;
          if (*v7)
          {
            int v12 = *(_DWORD *)(a1 + 20);
            unint64_t v13 = (2 * v12);
            if (v11 > v13) {
              return 3;
            }
            if (v12) {
              unint64_t v14 = (v11 + v13 - 2) % v13;
            }
            else {
              LODWORD(v14) = 0;
            }
            *(_DWORD *)(a2 + 64) = v14;
            *(_DWORD *)(a2 + 104) |= 3u;
            *(_DWORD *)(a2 + 136) = 2;
            unsigned int v15 = *(_DWORD *)(a1 + 32);
            unsigned int v16 = *(_DWORD *)(a1 + 20);
            if (v15 >= v16)
            {
              uint64_t result = 1;
              if (v15 < v14 || v15 - v16 + 1 > v14) {
                return result;
              }
            }
            else if (v15 < v14 && v16 + v15 >= v14)
            {
              return 1;
            }
          }
          else
          {
            *(_DWORD *)(a2 + 104) |= 1u;
            *(_DWORD *)(a2 + 136) = 2;
          }
          a3 = v28;
          int v8 = 2;
          if (v28 >= v6) {
            goto LABEL_19;
          }
          continue;
        }
        if (v10 != -1) {
          return 3;
        }
        unint64_t v17 = (2 * *(_DWORD *)(a1 + 20));
        uint64_t v18 = 1;
        if (v17 >= 0xFF) {
          uint64_t v18 = 2;
        }
        uint64x2_t v19 = (uint64x2_t)vdupq_n_s64(v17);
        *(int8x8_t *)v19.i8 = vcnt_s8((int8x8_t)vaddvq_s16((int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v19, (uint64x2_t)xmmword_1843D18F0), (int32x4_t)vcgtq_u64(v19, (uint64x2_t)xmmword_1843D18E0)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64(v19, (uint64x2_t)xmmword_1843D18D0), (int32x4_t)vcgtq_u64(v19, (uint64x2_t)xmmword_1843D18C0))), (int8x16_t)xmmword_1843D18B0)));
        v19.i16[0] = vaddlv_u8(*(uint8x8_t *)v19.i8);
        if (*(void *)(a2 + 48) - *(void *)(a2 + 56) <= v18 + (unint64_t)v19.u32[0]) {
          return 2;
        }
        else {
          return 3;
        }
      case 2:
        *(_DWORD *)(a2 + 176) = *a3 >> 7;
        *(_DWORD *)(a2 + 144) = 0;
        *(_DWORD *)(a2 + 136) = 3;
        char v9 = 7;
        goto LABEL_29;
      case 3:
LABEL_29:
        int v20 = lsqpack_dec_int(&v28, (unint64_t)v6, v9, (uint64_t *)(a2 + 168), (int *)(a2 + 144));
        if (v20 == -1) {
          return 2;
        }
        if (v20) {
          return 3;
        }
        if ((*(unsigned char *)(a2 + 104) & 2) == 0) {
          goto LABEL_32;
        }
        int v23 = *(_DWORD *)(a1 + 20);
        if (*(_DWORD *)(a2 + 176))
        {
          if (v23)
          {
            unsigned int v24 = 2 * v23;
            unint64_t v25 = (*(_DWORD *)(a2 + 64) + 2 * v23) + ~*(void *)(a2 + 168);
            goto LABEL_40;
          }
        }
        else if (v23)
        {
          unint64_t v25 = *(void *)(a2 + 168) + *(unsigned int *)(a2 + 64);
          unsigned int v24 = 2 * v23;
LABEL_40:
          int v21 = v25 % v24;
LABEL_41:
          *(_DWORD *)(a2 + 68) = v21;
          *(void *)(a2 + 96) = parse_header_data;
          *(_DWORD *)(a2 + 136) = 0;
          long long v26 = v28;
          uint64_t v27 = v6 - v28;
          if (v6 == v28) {
            return 2;
          }
          return parse_header_data(a1, a2, v26, v27);
        }
LABEL_32:
        int v21 = 0;
        goto LABEL_41;
      default:
        __assert_rtn("parse_header_prefix", "lsqpack.c", 3987, "0");
    }
  }
}

void HTTP3Stream::_sendHEADERS(void *a1, void *a2, int a3, void *a4)
{
  v99[0] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a4;
  int v8 = (std::__shared_weak_count *)a1[7];
  if (!v8)
  {
    char v9 = 0;
    goto LABEL_12;
  }
  char v9 = std::__shared_weak_count::lock(v8);
  if (!v9 || (uint64_t v10 = a1[6]) == 0)
  {
LABEL_12:
    v7[2](v7, 0, 4, 4294967292);
    if (!v9) {
      goto LABEL_82;
    }
    goto LABEL_81;
  }
  uint64_t v96 = 0;
  uint64_t v97 = 0;
  v95[0] = 0;
  v95[1] = v95;
  v95[2] = 0x2020000000;
  v95[3] = 0;
  v94[0] = 0;
  v94[1] = v94;
  v94[2] = 0x2020000000;
  v94[3] = 0;
  uint64_t v90 = 0;
  unsigned int v91 = &v90;
  uint64_t v92 = 0x2020000000;
  uint64_t v93 = 22;
  uint64_t v86 = 0;
  id v87 = &v86;
  uint64_t v88 = 0x2020000000;
  uint64_t v89 = 0;
  v85[0] = 0;
  v85[1] = v85;
  v85[2] = 0x2020000000;
  v85[3] = 512;
  v84[0] = 0;
  v84[1] = v84;
  v84[2] = 0x2020000000;
  v84[3] = 512;
  uint64_t v78 = 0;
  uint64_t v79 = &v78;
  uint64_t v80 = 0x3032000000;
  v81 = __Block_byref_object_copy__18;
  uint64_t v82 = __Block_byref_object_dispose__19;
  id alloc = (id)dispatch_data_create_alloc();
  uint64_t v72 = 0;
  v73 = &v72;
  uint64_t v74 = 0x3032000000;
  uint64_t v75 = __Block_byref_object_copy__18;
  v76 = __Block_byref_object_dispose__19;
  id v77 = (id)dispatch_data_create_alloc();
  if (*(unsigned char *)(v10 + 44)) {
    __assert_rtn("_sendHEADERS", "HTTP3Stream.mm", 694, "status == 0");
  }
  uint64_t v11 = v97;
  uint64_t v12 = a1[42];
  unint64_t v13 = *(FILE **)(v10 + 232);
  if (v13)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v13);
    fprintf(*(FILE **)(v10 + 232), "Start header for stream %llu", v12);
    fputc(10, *(FILE **)(v10 + 232));
  }
  unint64_t v14 = (void *)(v10 + 112);
  while (1)
  {
    unint64_t v14 = (void *)*v14;
    if (!v14) {
      break;
    }
    uint64_t v15 = v14[1];
    if (v15 != -1) {
      goto LABEL_18;
    }
  }
  if ((*(unsigned char *)(v10 + 44) & 4) != 0
    || 4112 * (unint64_t)*(unsigned int *)(v10 + 76) < *(unsigned int *)(v10 + 52))
  {
    unint64_t v14 = malloc_type_malloc(0x1010uLL, 0x10A0040497EC00CuLL);
    if (v14)
    {
      uint64_t v15 = 0;
      void *v14 = 0;
      v14[1] = 0;
      **(void **)(v10 + 120) = v14;
      *(void *)(v10 + 120) = v14;
      ++*(_DWORD *)(v10 + 76);
LABEL_18:
      unint64_t v16 = __clz(__rbit64(~v15));
      v14[1] = (1 << v16) | v15;
      unint64_t v17 = &v14[8 * v16];
      void v17[2] = 0;
      v17 += 2;
      *(_OWORD *)(v17 + 3) = 0u;
      *(_OWORD *)(v17 + 5) = 0u;
      v17[7] = 0;
      *(_OWORD *)(v17 + 1) = 0u;
      v17[4] = v17;
      uint64_t v18 = *(void **)(v10 + 136);
      v17[1] = v18;
      void *v18 = v17;
      *(void *)(v10 + 136) = v17;
      *(void *)(v10 + 160) = v17;
      uint64x2_t v19 = (void *)(v10 + 160);
      v17[5] = v12;
      *((_DWORD *)v17 + 12) = a3;
      goto LABEL_19;
    }
  }
  *(void *)(v10 + 160) = 0;
  uint64x2_t v19 = (void *)(v10 + 160);
  long long v22 = *(FILE **)(v10 + 232);
  if (v22)
  {
    fwrite("qenc: info: ", 0xCuLL, 1uLL, v22);
    fprintf(*(FILE **)(v10 + 232), "could not allocate hinfo for stream %llu", v12);
    fputc(10, *(FILE **)(v10 + 232));
  }
LABEL_19:
  *(void *)(v10 + 168) = 0;
  *(_DWORD *)(v10 + 176) = 0;
  int v20 = *(_DWORD *)(v10 + 32);
  *(_DWORD *)(v10 + 184) = 0;
  *(_DWORD *)(v10 + 188) = v20;
  if (a3)
  {
    if (*v19)
    {
      uint64_t v21 = *(void *)(v10 + 144);
      if (v21)
      {
        while (*(void *)(v21 + 40) != v12)
        {
          uint64_t v21 = *(void *)(v21 + 16);
          if (!v21) {
            goto LABEL_28;
          }
        }
        *(void *)(v10 + 168) = v21;
      }
    }
  }
LABEL_28:
  *(_DWORD *)(v10 + 44) |= 1u;
  v68[0] = MEMORY[0x1E4F143A8];
  v68[1] = 3321888768;
  v68[2] = ___ZN11HTTP3Stream12_sendHEADERSERK11HTTP3FieldsbU13block_pointerFvm13CFStreamErrorE_block_invoke;
  v68[3] = &unk_1ECFA80D8;
  v68[4] = v95;
  v68[5] = v85;
  v68[6] = &v90;
  v68[7] = v94;
  v68[8] = v84;
  v68[9] = &v86;
  v68[12] = v10;
  uint64_t v69 = v9;
  atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v70 = v96;
  uint64_t v71 = v97;
  v68[10] = &v72;
  v68[11] = &v78;
  HTTP3Fields::enumerateFields(a2, v68);
  if ((*(unsigned char *)(v10 + 44) & 1) == 0) {
    goto LABEL_84;
  }
  if (*(void *)(v10 + 248))
  {
    float v23 = *(float *)(v10 + 244);
    float v24 = (float)*(unsigned int *)(v10 + 176);
    if (v23 != 0.0) {
      float v24 = v23 + (float)(v24 - v23) * 0.4;
    }
    *(float *)(v10 + 244) = v24;
    unint64_t v25 = *(FILE **)(v10 + 232);
    if (v25)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v25);
      fprintf(*(FILE **)(v10 + 232), "header count actual: %u; exponential moving average: %.3f",
        *(_DWORD *)(v10 + 176),
        *(float *)(v10 + 244));
      fputc(10, *(FILE **)(v10 + 232));
    }
    float v26 = *(float *)(v10 + 240);
    if (v26 != 0.0 && v26 > *(float *)(v10 + 244))
    {
      float v27 = vabds_f32((float)*(unsigned int *)(v10 + 260), v26);
      if (v27 >= 1.5 || (float)(v27 / v26) >= 0.1) {
        qenc_hist_update_size(v10 + 32, vcvtas_u32_f32(v26));
      }
    }
  }
  unint64_t v28 = *(void *)(v10 + 160);
  if (v28)
  {
    unsigned int v29 = *(_DWORD *)(v28 + 60);
    if (v29)
    {
      uint64_t v63 = v11;
      LOBYTE(__src[0]) = 0;
      uint64_t v30 = v29 % (2 * *(_DWORD *)(v10 + 60));
      int v31 = v30 + 1;
      uint64_t v32 = *(FILE **)(v10 + 232);
      if (v32)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v32);
        fprintf(*(FILE **)(v10 + 232), "LargestRef for stream %llu is encoded as %u", *(void *)(v28 + 40), v30 + 1);
        fputc(10, *(FILE **)(v10 + 232));
      }
      if (v30 > 0xFD)
      {
        LOBYTE(__src[0]) = -1;
        unint64_t v37 = v30 - 254;
        if ((unint64_t)(v30 - 254) < 0x80)
        {
          HIBYTE(__src[0]) = v30 + 2;
          uint64_t v33 = 2;
        }
        else
        {
          uint64_t v38 = 1;
          do
          {
            if (v38 == 22) {
              goto LABEL_66;
            }
            unint64_t v39 = v38;
            *((unsigned char *)__src + v38) = v37 | 0x80;
            unint64_t v40 = v37 >> 7;
            ++v38;
            unint64_t v41 = v37 >> 14;
            v37 >>= 7;
          }
          while (v41);
          if (v39 > 0x14 || (*((unsigned char *)__src + v38) = v40, v39 == 20))
          {
LABEL_66:
            int64_t v36 = 0;
            uint64_t v11 = v63;
            goto LABEL_73;
          }
          uint64_t v33 = v39 + 2;
        }
      }
      else
      {
        LOBYTE(__src[0]) |= v31;
        uint64_t v33 = 1;
      }
      unsigned int v42 = (char *)__src + v33;
      unsigned int v43 = *(_DWORD *)(v10 + 188);
      unsigned int v44 = *(_DWORD *)(v28 + 60);
      BOOL v45 = v43 >= v44;
      unsigned int v46 = v43 - v44;
      char v47 = v43 < v44;
      unsigned int v48 = v44 + ~v43;
      if (v45) {
        unint64_t v49 = v46;
      }
      else {
        unint64_t v49 = v48;
      }
      *unsigned int v42 = v47 << 7;
      float v50 = lsqpack_enc_int(v42, (unint64_t)v99, v49, 7);
      if (v50 > v42)
      {
        uint64_t v51 = v50;
        if (*(_DWORD *)(v28 + 60) > *(_DWORD *)(v10 + 36))
        {
          *(void *)(v28 + 16) = 0;
          uint64_t v52 = *(unint64_t **)(v10 + 152);
          *(void *)(v28 + 24) = v52;
          *uint64_t v52 = v28;
          *(void *)(v10 + 152) = v28 + 16;
          uint64_t v53 = *(void *)(v10 + 168);
          if (v53)
          {
            *(void *)(v28 + 32) = *(void *)(v53 + 32);
            *(void *)(v53 + 32) = v28;
          }
          else
          {
            unsigned int v54 = *(_DWORD *)(v10 + 72) + 1;
            *(_DWORD *)(v10 + 72) = v54;
            uint64_t v55 = *(FILE **)(v10 + 232);
            if (v55)
            {
              fwrite("qenc: debug: ", 0xDuLL, 1uLL, v55);
              fprintf(*(FILE **)(v10 + 232), "streams at risk: %u", *(_DWORD *)(v10 + 72));
              fputc(10, *(FILE **)(v10 + 232));
              unsigned int v54 = *(_DWORD *)(v10 + 72);
            }
            if (v54 > *(_DWORD *)(v10 + 68)) {
              __assert_rtn("qenc_add_to_risked_list", "lsqpack.c", 1156, "enc->qpe_cur_streams_at_risk <= enc->qpe_max_risked_streams");
            }
          }
        }
        size_t v56 = *(FILE **)(v10 + 232);
        if (v56)
        {
          fwrite("qenc: debug: ", 0xDuLL, 1uLL, v56);
          fprintf(*(FILE **)(v10 + 232), "ended header for stream %llu; max ref: %u encoded as %u; risked: %d",
            *(void *)(v28 + 40),
            *(_DWORD *)(v28 + 60),
            v31,
            *(_DWORD *)(v28 + 60) > *(_DWORD *)(v10 + 36));
          fputc(10, *(FILE **)(v10 + 232));
        }
        *(void *)(v10 + 160) = 0;
        *(_DWORD *)(v10 + 44) &= ~1u;
        int64_t v36 = v51 - (char *)v99 + 22;
        *(_DWORD *)(v10 + 228) += v36;
        uint64_t v11 = v63;
        if (v36 >= 0) {
          goto LABEL_73;
        }
LABEL_84:
        __assert_rtn("_sendHEADERS", "HTTP3Stream.mm", 738, "prefixBufferSize >= 0");
      }
      goto LABEL_66;
    }
    __src[0] = 0;
    uint64_t v35 = *(FILE **)(v10 + 232);
    if (v35)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v35);
      fprintf(*(FILE **)(v10 + 232), "ended header for stream %llu; dynamic table not referenced",
        *(void *)(*(void *)(v10 + 160) + 40));
      fputc(10, *(FILE **)(v10 + 232));
      unint64_t v28 = *(void *)(v10 + 160);
    }
    enc_free_hinfo(v10 + 32, v28);
    *(void *)(v10 + 160) = 0;
  }
  else
  {
    __src[0] = 0;
    uint64_t v34 = *(FILE **)(v10 + 232);
    if (v34)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v34);
      fwrite("ended header; hinfo absent", 0x1AuLL, 1uLL, *(FILE **)(v10 + 232));
      fputc(10, *(FILE **)(v10 + 232));
    }
  }
  *(_DWORD *)(v10 + 44) &= ~1u;
  *(_DWORD *)(v10 + 228) += 2;
  int64_t v36 = 2;
LABEL_73:
  memcpy((void *)(v11 - v36 + 22), __src, v36);
  dispatch_data_t subrange = dispatch_data_create_subrange((dispatch_data_t)v79[5], 22 - v36, v36 + v91[3] - 22);
  size_t v58 = v87[3];
  if (v58)
  {
    dispatch_data_t v59 = dispatch_data_create_subrange((dispatch_data_t)v73[5], 0, v58);
    HTTP3Connection::writeEncoderStream(v10, v59);
  }
  uint64_t v60 = a1[3];
  int v61 = (a3 & 1) != 0 || a1[12] == 0;
  v64[0] = MEMORY[0x1E4F143A8];
  v64[1] = 3221225472;
  v64[2] = ___ZN11HTTP3Stream12_sendHEADERSERK11HTTP3FieldsbU13block_pointerFvm13CFStreamErrorE_block_invoke_23;
  v64[3] = &unk_1E5254810;
  uint64_t v66 = v7;
  uint64_t v62 = subrange;
  uint64_t v65 = v62;
  int v67 = &v86;
  HTTP3Framer::writeFrame(v60, 1uLL, v62, v61, v64);

  if (v69) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v69);
  }
  _Block_object_dispose(&v72, 8);

  _Block_object_dispose(&v78, 8);
  _Block_object_dispose(v84, 8);
  _Block_object_dispose(v85, 8);
  _Block_object_dispose(&v86, 8);
  _Block_object_dispose(&v90, 8);
  _Block_object_dispose(v94, 8);
  _Block_object_dispose(v95, 8);
LABEL_81:
  std::__shared_weak_count::__release_shared[abi:nn180100](v9);
LABEL_82:
}

void sub_18414FE98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,std::__shared_weak_count *a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,id a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,id a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
  if (a35) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a35);
  }
  _Block_object_dispose(&a38, 8);

  _Block_object_dispose(&a44, 8);
  _Block_object_dispose(&a50, 8);
  _Block_object_dispose(&a54, 8);
  _Block_object_dispose(&a58, 8);
  _Block_object_dispose((const void *)(v62 - 248), 8);
  _Block_object_dispose((const void *)(v62 - 216), 8);
  _Block_object_dispose((const void *)(v62 - 184), 8);
  std::__shared_weak_count::__release_shared[abi:nn180100](v59);

  _Unwind_Resume(a1);
}

void HTTP3Fields::enumerateFields(void *a1, void *a2)
{
  id v6 = a2;
  uint64_t v3 = (unsigned __int16 *)a1[3];
  uint64_t v4 = (unsigned __int16 *)a1[4];
  if (v3 != v4)
  {
    int v5 = 0;
    do
    {
      (*((void (**)(id, void, void, void, void, void))v6 + 2))(v6, *a1 + (unsigned __int16)v5, 0, *v3, *v3, v3[1]);
      v5 += *v3 + v3[1];
      v3 += 2;
    }
    while (v3 != v4);
  }
}

void sub_18415001C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN11HTTP3Stream12_sendHEADERSERK11HTTP3FieldsbU13block_pointerFvm13CFStreamErrorE_block_invoke(void *a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  id v6 = a1;
  uint64_t v250 = *MEMORY[0x1E4F143B8];
  v222 = a1 + 4;
  v223 = a1 + 6;
  v217 = a1 + 7;
  v218 = a1 + 9;
  unsigned int v216 = a4 + 414139866;
  size_t v238 = a4;
  unint64_t v213 = a4 & 0xF;
  size_t __n = a6;
  v241 = (char *)(a2 + a5);
  v235 = &v241[a6];
  unsigned int v215 = a6 + a4;
  unint64_t v214 = a6 + a4 + 32;
  unint64_t v212 = a4 + 32;
  if (a4) {
    uint64_t v7 = (char *)(a2 + a3);
  }
  else {
    uint64_t v7 = 0;
  }
  v246 = v7;
  v244 = &v7[a4];
  while (2)
  {
    uint64_t v8 = *(void *)(*(void *)(v6[4] + 8) + 24);
    uint64_t v9 = *(void *)(*(void *)(v6[5] + 8) + 24);
    uint64_t v10 = *(void *)(*(void *)(v6[6] + 8) + 24);
    uint64_t v11 = *(void *)(*(void *)(v6[7] + 8) + 24);
    uint64_t v12 = *(void *)(*(void *)(v6[8] + 8) + 24);
    uint64_t v13 = *(void *)(*(void *)(v6[9] + 8) + 24);
    uint64_t v14 = v6[12];
    uint64_t v16 = v6[14];
    uint64_t v15 = v6[15];
    v248 = 0;
    v249 = 0;
    unint64_t v17 = *(FILE **)(v14 + 232);
    if (v17)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v17);
      fputc(10, *(FILE **)(v14 + 232));
    }
    uint64_t v242 = v14;
    if (v9 + v8 == v10)
    {
LABEL_8:
      size_t v18 = *(void *)(*(void *)(v6[6] + 8) + 24);
      uint64_t v19 = *(void *)(v6[5] + 8);
      uint64_t v20 = *(void *)(v19 + 24);
      if (v18 < v20 + *(void *)(*(void *)(v6[4] + 8) + 24))
      {
        dispatch_data_t subrange = dispatch_data_create_subrange(*(dispatch_data_t *)(*(void *)(v6[11] + 8) + 40), 0, v18);
        uint64_t v22 = *(void *)(v6[11] + 8);
        float v23 = *(void **)(v22 + 40);
        *(void *)(v22 + 40) = subrange;

        uint64_t v19 = *(void *)(v6[5] + 8);
        uint64_t v20 = *(void *)(v19 + 24);
      }
      *(void *)(v19 + 24) = v20 + 512;
      id alloc = dispatch_data_create_alloc();
      dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(void *)(v6[11] + 8) + 40), alloc);
      uint64_t v26 = *(void *)(v6[11] + 8);
      float v27 = *(void **)(v26 + 40);
      *(void *)(v26 + 40) = concat;
      unint64_t v28 = v222;
      unsigned int v29 = v223;
      goto LABEL_192;
    }
    unsigned int v30 = 414139866;
    if (v246)
    {
      unint64_t v31 = v238;
      unsigned int v30 = v216;
      uint64_t v32 = v246;
      if (a4 >= 0x10)
      {
        int v33 = 1679910008;
        int v34 = 39378473;
        int v35 = -2008766304;
        int v36 = 645669457;
        uint64_t v32 = v246;
        do
        {
          HIDWORD(v37) = v36 - 2048144777 * *(_DWORD *)v32;
          LODWORD(v37) = HIDWORD(v37);
          int v36 = -1640531535 * (v37 >> 19);
          HIDWORD(v37) = v35 - 2048144777 * *((_DWORD *)v32 + 1);
          LODWORD(v37) = HIDWORD(v37);
          int v35 = -1640531535 * (v37 >> 19);
          HIDWORD(v37) = v34 - 2048144777 * *((_DWORD *)v32 + 2);
          LODWORD(v37) = HIDWORD(v37);
          int v34 = -1640531535 * (v37 >> 19);
          HIDWORD(v37) = v33 - 2048144777 * *((_DWORD *)v32 + 3);
          LODWORD(v37) = HIDWORD(v37);
          int v33 = -1640531535 * (v37 >> 19);
          v32 += 16;
        }
        while (v32 < v244 - 15);
        HIDWORD(v39) = v36;
        LODWORD(v39) = v36;
        int v38 = v39 >> 31;
        HIDWORD(v39) = v35;
        LODWORD(v39) = v35;
        int v40 = v39 >> 25;
        HIDWORD(v39) = v34;
        LODWORD(v39) = v34;
        int v41 = v39 >> 20;
        HIDWORD(v39) = v33;
        LODWORD(v39) = v33;
        unsigned int v30 = v38 + a4 + v40 + v41 + (v39 >> 14);
        unint64_t v31 = v213;
      }
      if (v31 >= 4)
      {
        do
        {
          int v42 = *(_DWORD *)v32;
          v32 += 4;
          HIDWORD(v43) = v30 - 1028477379 * v42;
          LODWORD(v43) = HIDWORD(v43);
          unsigned int v30 = 668265263 * (v43 >> 15);
          v31 -= 4;
        }
        while (v31 > 3);
      }
      for (; v31; --v31)
      {
        int v44 = *v32++;
        HIDWORD(v45) = v30 + 374761393 * v44;
        LODWORD(v45) = HIDWORD(v45);
        unsigned int v30 = -1640531535 * (v45 >> 21);
      }
    }
    uint64_t v46 = v11;
    unsigned int v47 = -1028477379 * ((-2048144777 * (v30 ^ (v30 >> 15))) ^ ((-2048144777 * (v30 ^ (v30 >> 15))) >> 13));
    uint64_t v48 = v47 ^ HIWORD(v47);
    uint64_t v49 = XXH_INLINE_XXH32((int *)v241, __n, v47 ^ HIWORD(v47));
    float v50 = *(FILE **)(v242 + 232);
    if (v50)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v50);
      fprintf(*(FILE **)(v242 + 232), "name hash: 0x%X; nameval hash: 0x%X", v48, v49);
      fputc(10, *(FILE **)(v242 + 232));
    }
    uint64_t v230 = v48;
    v234 = (_DWORD *)(v242 + 32);
    v228 = (unsigned char *)(v16 + v13 - v46);
    int64_t v232 = v12 + v46 - v13;
    unint64_t v226 = (unint64_t)&v228[v232];
    unint64_t v221 = v9 + v8 - v10;
    v224 = (unsigned char *)(v15 + v10 - v8);
    unint64_t v225 = v15 + v9;
    unsigned int v51 = a4;
    if (nameval2id_plus_one[v49 & 0x1FF])
    {
      uint64_t v52 = nameval2id_plus_one[v49 & 0x1FF] - 1;
      uint64_t v53 = &(&static_table)[3 * v52];
      if (*((_DWORD *)v53 + 4) == a4
        && *((_DWORD *)&static_table + 6 * v52 + 5) == a6
        && !memcmp(*v53, v246, v238)
        && !memcmp((&static_table)[3 * v52 + 1], v241, __n))
      {
        uint64_t v236 = 0;
        BOOL v219 = 0;
        int v237 = 0;
        unsigned int v239 = 0;
        int v65 = 0;
        uint64_t v66 = 0;
        uint64_t v67 = 0;
        uint64_t v63 = 0;
        uint64_t v233 = v52;
        uint64_t v240 = 1;
        unint64_t v57 = (unint64_t)v235;
        unint64_t v58 = (unint64_t)v244;
        uint64_t v54 = v242;
        uint64_t v55 = v230;
        BOOL v59 = 0;
        id v6 = a1;
        goto LABEL_151;
      }
    }
    uint64_t v54 = v242;
    uint64_t v55 = v230;
    id v6 = a1;
    if (*(_DWORD *)(v242 + 60))
    {
      uint64_t v56 = *(void *)(v242 + 160);
      unint64_t v57 = (unint64_t)v235;
      unint64_t v58 = (unint64_t)v244;
      if (v56 && *(_DWORD *)(v56 + 52) < *(_DWORD *)(v242 + 52) >> 1)
      {
        BOOL v59 = *v234 != -1;
        int v237 = 1;
      }
      else
      {
        int v237 = 0;
        BOOL v59 = 0;
      }
    }
    else
    {
      int v237 = 0;
      BOOL v59 = 0;
      unint64_t v57 = (unint64_t)v235;
      unint64_t v58 = (unint64_t)v244;
    }
    if (*(void *)(v242 + 168) || *(_DWORD *)(v242 + 72) < *(_DWORD *)(v242 + 68))
    {
      BOOL v60 = 1;
LABEL_36:
      unsigned int v239 = v60;
      goto LABEL_37;
    }
    uint64_t v64 = *(void *)(v242 + 160);
    if (v64)
    {
      BOOL v60 = *(_DWORD *)(v64 + 60) > *(_DWORD *)(v242 + 36);
      goto LABEL_36;
    }
    unsigned int v239 = 0;
LABEL_37:
    uint64_t v61 = 0;
    uint64_t v62 = 0;
    uint64_t v63 = 0;
    BOOL v219 = *(void *)(v242 + 248) != 0;
LABEL_42:
    while (2)
    {
      uint64_t v229 = v49;
      if (!v237)
      {
        uint64_t v236 = v61;
        goto LABEL_77;
      }
      uint64_t v63 = *(unsigned int **)(*(void *)(v54 + 104) + 32 * (v49 & ~(-1 << *(_DWORD *)(v54 + 84))) + 16);
      if (!v63)
      {
        uint64_t v236 = 0;
        uint64_t v63 = 0;
        goto LABEL_77;
      }
      uint64_t v68 = 0;
      while (1)
      {
        if (v49 != v63[10] || v63[12] != v51 || v63[13] != a6) {
          goto LABEL_51;
        }
        if (!memcmp(v246, v63 + 14, v238) && !memcmp(v241, (char *)v63 + v238 + 56, __n)) {
          break;
        }
        unint64_t v58 = (unint64_t)v244;
LABEL_51:
        uint64_t v63 = *(unsigned int **)v63;
        if (!v63)
        {
          uint64_t v236 = v68;
          unint64_t v57 = (unint64_t)v235;
          if (v68 != 1) {
            goto LABEL_77;
          }
          uint64_t v63 = v248;
          uint64_t v62 = v248[6];
          if (v239)
          {
            if (!v59) {
              goto LABEL_76;
            }
          }
          else
          {
            unsigned int v69 = *(_DWORD *)(v54 + 36);
            BOOL v70 = v62 > v69 || !v59;
            unsigned int v71 = v248[6];
            if (v70) {
              goto LABEL_74;
            }
          }
          if ((*(unsigned char *)(v54 + 44) & 2) != 0)
          {
            unint64_t v72 = v248[12] + v248[13] + 32;
            float v73 = (float)*(unsigned int *)(v54 + 52);
            if ((float)((float)(v72 + *(_DWORD *)(v54 + 48)) / v73) >= 0.8
              && (float)((float)(v248[7] - *(_DWORD *)(v54 + 64) + v248[8]) / v73) < 0.2)
            {
              int can_evict_at_least = qenc_has_or_can_evict_at_least((uint64_t)v234, v72);
              unint64_t v58 = (unint64_t)v244;
              if (can_evict_at_least)
              {
                uint64_t v240 = 0;
                int v65 = 6;
                uint64_t v236 = 1;
                if (v239)
                {
                  uint64_t v233 = v62;
                  int v237 = 1;
                  unsigned int v239 = 1;
                  goto LABEL_71;
                }
                int v172 = *(_DWORD *)(v54 + 48);
                unsigned int v171 = *(_DWORD *)(v54 + 52);
                if (v63[7] - *(_DWORD *)(v54 + 64) + v63[8] + v171 - v172 >= v171 >> 2)
                {
                  unsigned int v239 = 0;
                  unsigned int v173 = v172 + v63[12] + v63[13] + 32;
                  int v65 = 2;
                  uint64_t v240 = 2;
                  uint64_t v236 = 1;
                  int v237 = 1;
                  if (v173 <= v171)
                  {
                    uint64_t v233 = v62;
                  }
                  else
                  {
                    uint64_t v174 = *(void *)(v54 + 88);
                    int v65 = 2;
                    uint64_t v240 = 2;
                    if ((unsigned int *)v174 == v63)
                    {
                      uint64_t v66 = 0;
                      uint64_t v236 = 1;
                      int v237 = 1;
                      unsigned int v239 = 0;
                      uint64_t v233 = v62;
                      goto LABEL_146;
                    }
                    while (1)
                    {
                      unsigned int v173 = v173 - (*(_DWORD *)(v174 + 48) + *(_DWORD *)(v174 + 52)) - 32;
                      if (v173 <= v171) {
                        break;
                      }
                      uint64_t v174 = *(void *)(v174 + 16);
                      int v65 = 2;
                      if ((unsigned int *)v174 == v63)
                      {
                        uint64_t v236 = 1;
                        unsigned int v239 = 0;
                        uint64_t v66 = 0;
                        uint64_t v67 = 0;
                        uint64_t v233 = v62;
                        int v237 = 1;
                        uint64_t v240 = 2;
                        goto LABEL_151;
                      }
                    }
                    unsigned int v239 = 0;
                    int v65 = 2;
                    uint64_t v236 = 1;
                    uint64_t v233 = v62;
                    int v237 = 1;
                    uint64_t v240 = 2;
                  }
LABEL_71:
                  uint64_t v66 = 1;
                  uint64_t v67 = 1;
                  goto LABEL_151;
                }
LABEL_75:
                uint64_t v236 = 1;
                goto LABEL_77;
              }
            }
          }
          if (v239)
          {
LABEL_76:
            int v65 = 2;
            uint64_t v240 = 2;
            uint64_t v236 = 1;
            if (v63[7] - *(_DWORD *)(v54 + 64) + v63[8] + *(_DWORD *)(v54 + 52) - *(_DWORD *)(v54 + 48) < *(_DWORD *)(v54 + 52) >> 2) {
              goto LABEL_77;
            }
            uint64_t v66 = 0;
            uint64_t v233 = v62;
            int v237 = 1;
            goto LABEL_146;
          }
          unsigned int v71 = v63[6];
          unsigned int v69 = *(_DWORD *)(v54 + 36);
LABEL_74:
          if (v71 > v69) {
            goto LABEL_75;
          }
          goto LABEL_76;
        }
      }
      (&v248)[v68] = v63;
      unint64_t v58 = (unint64_t)v244;
      if (!v68)
      {
        uint64_t v68 = 1;
        goto LABEL_51;
      }
      uint64_t v168 = v62;
      unsigned int v169 = v249[6];
      unsigned int v170 = v248[6];
      if (v169 <= v170) {
        __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1767, "candidates[1]->ete_id > candidates[0]->ete_id");
      }
      int v65 = 2;
      if (v239)
      {
        uint64_t v66 = 0;
        uint64_t v233 = v249[6];
        uint64_t v236 = 2;
        int v237 = 1;
        unsigned int v239 = 1;
        uint64_t v240 = 2;
        uint64_t v67 = 0;
        uint64_t v63 = v249;
        goto LABEL_110;
      }
      unsigned int v175 = *(_DWORD *)(v54 + 36);
      unint64_t v57 = (unint64_t)v235;
      if (v169 <= v175)
      {
        uint64_t v66 = 0;
        int v65 = 2;
        uint64_t v233 = v249[6];
        uint64_t v236 = 2;
        unsigned int v239 = 0;
        int v237 = 1;
        uint64_t v240 = 2;
        uint64_t v67 = 0;
        uint64_t v63 = v249;
        goto LABEL_151;
      }
      if (v170 <= v175)
      {
        uint64_t v236 = 2;
        uint64_t v62 = v168;
        if (v248[7] - *(_DWORD *)(v54 + 64) + v248[8] + *(_DWORD *)(v54 + 52) - *(_DWORD *)(v54 + 48) >= *(_DWORD *)(v54 + 52) >> 2)
        {
          uint64_t v66 = 0;
          int v65 = 2;
          unsigned int v239 = 0;
          uint64_t v233 = v248[6];
          int v237 = 1;
          uint64_t v240 = 2;
          uint64_t v67 = 0;
          uint64_t v63 = v248;
          goto LABEL_151;
        }
      }
      else
      {
        uint64_t v236 = 2;
        uint64_t v62 = v168;
      }
LABEL_77:
      uint64_t v75 = v6;
      uint64_t v76 = v55;
      BOOL v77 = v59;
      uint64_t v78 = v62;
      uint64_t v79 = v76;
      int v80 = name2id_plus_one[v76 & 0x1FF];
      if (v80)
      {
        uint64_t v81 = (v80 - 1);
        if (LODWORD((&static_table)[3 * v81 + 2]) == v51)
        {
          int v82 = memcmp((&static_table)[3 * v81], v246, v238);
          unint64_t v58 = (unint64_t)v244;
          if (!v82)
          {
            uint64_t v233 = v81;
            if (v77)
            {
              BOOL v59 = 1;
              if (qenc_has_or_can_evict_at_least((uint64_t)v234, v214))
              {
                uint64_t v95 = *(void *)(v54 + 248);
                BOOL v96 = 1;
                unint64_t v58 = (unint64_t)v244;
                uint64_t v55 = v79;
                id v6 = v75;
                uint64_t v49 = v229;
                if (v95)
                {
                  uint64_t v97 = 260;
                  if (!*(_DWORD *)(v54 + 264)) {
                    uint64_t v97 = 256;
                  }
                  unint64_t v98 = v95 + 8 * *(unsigned int *)(v54 + v97);
                  *(_DWORD *)(v98 + 4) = v229;
                  unint64_t v99 = v95 - 8;
                  do
                  {
                    int v100 = *(_DWORD *)(v99 + 12);
                    v99 += 8;
                  }
                  while (v100 != v229);
                  BOOL v96 = v99 < v98;
                }
                if (v237) {
                  BOOL v101 = v236 == 0;
                }
                else {
                  BOOL v101 = 1;
                }
                unsigned int v102 = !v101;
                long long v103 = (unsigned int *)((char *)&lsqpack_enc_encode_programs + 64 * v96 + 32 * v239 + 16 * v102);
                uint64_t v67 = *v103;
                uint64_t v240 = v103[1];
                uint64_t v66 = v103[2];
                int v65 = v103[3];
                BOOL v59 = 1;
                goto LABEL_151;
              }
              uint64_t v66 = 0;
              int v65 = 0;
              uint64_t v67 = 0;
              unint64_t v58 = (unint64_t)v244;
            }
            else
            {
              uint64_t v66 = 0;
              int v65 = 0;
              BOOL v59 = 0;
              uint64_t v67 = 0;
            }
            uint64_t v55 = v79;
            id v6 = v75;
            uint64_t v240 = 3;
            uint64_t v49 = v229;
            goto LABEL_151;
          }
        }
      }
      int v83 = -1;
      uint64_t v84 = v78;
      BOOL v59 = v77;
      uint64_t v55 = v79;
      id v6 = v75;
      uint64_t v49 = v229;
      if (!v237
        || (uint64_t v63 = 0,
            uint64_t v85 = *(void *)(v54 + 104),
            !*(void *)(v85 + 32 * (v55 & ~(-1 << *(_DWORD *)(v54 + 84))))))
      {
LABEL_99:
        if (!v59)
        {
          uint64_t v66 = 0;
          int v65 = 0;
          uint64_t v233 = v84;
          BOOL v59 = 0;
          uint64_t v240 = 6;
          uint64_t v67 = 0;
          goto LABEL_110;
        }
        uint64_t v86 = *(void *)(v54 + 248);
        if (!v86) {
          goto LABEL_106;
        }
        uint64_t v87 = 260;
        if (!*(_DWORD *)(v54 + 264)) {
          uint64_t v87 = 256;
        }
        unint64_t v88 = v86 + 8 * *(unsigned int *)(v54 + v87);
        *(_DWORD *)(v88 + 4) = v229;
        unint64_t v89 = v86 - 8;
        do
        {
          int v90 = *(_DWORD *)(v89 + 12);
          v89 += 8;
        }
        while (v90 != v229);
        if (v89 < v88)
        {
LABEL_106:
          if ((v83 & 0x80000000) == 0)
          {
            if (!v83) {
              goto LABEL_136;
            }
LABEL_112:
            if (v237) {
              BOOL v92 = v236 == 0;
            }
            else {
              BOOL v92 = 1;
            }
            unsigned int v93 = !v92;
            __int16 v94 = (unsigned int *)((char *)&lsqpack_enc_encode_programs_20 + 32 * v239 + 16 * v93);
            uint64_t v67 = *v94;
            uint64_t v66 = v94[2];
            unint64_t v57 = (unint64_t)v235;
LABEL_144:
            uint64_t v240 = v94[1];
            int v65 = v94[3];
            BOOL v59 = 1;
            uint64_t v233 = v84;
            goto LABEL_151;
          }
          int v91 = qenc_has_or_can_evict_at_least((uint64_t)v234, v214);
          unint64_t v58 = (unint64_t)v244;
          if (v91) {
            goto LABEL_112;
          }
          uint64_t v86 = *(void *)(v54 + 248);
        }
LABEL_136:
        unint64_t v57 = (unint64_t)v235;
        if (!v86) {
          goto LABEL_142;
        }
        uint64_t v104 = 260;
        if (!*(_DWORD *)(v54 + 264)) {
          uint64_t v104 = 256;
        }
        uint64_t v105 = (_DWORD *)(v86 + 8 * *(unsigned int *)(v54 + v104));
        *uint64_t v105 = v55;
        unint64_t v106 = v86 - 8;
        do
        {
          int v107 = *(_DWORD *)(v106 + 8);
          v106 += 8;
        }
        while (v107 != v55);
        BOOL v59 = 1;
        if (v106 < (unint64_t)v105)
        {
LABEL_142:
          BOOL v59 = 1;
          if (!qenc_has_or_can_evict_at_least((uint64_t)v234, v212))
          {
            uint64_t v66 = 0;
            int v65 = 0;
            uint64_t v233 = v84;
            uint64_t v240 = 6;
            uint64_t v67 = 0;
            unint64_t v58 = (unint64_t)v244;
            goto LABEL_151;
          }
          __int16 v94 = (unsigned int *)((char *)&lsqpack_enc_encode_programs_21 + 16 * v239);
          uint64_t v66 = 2;
          uint64_t v67 = 5;
          unint64_t v58 = (unint64_t)v244;
          goto LABEL_144;
        }
        uint64_t v66 = 0;
        int v65 = 0;
        uint64_t v233 = v84;
        uint64_t v240 = 6;
LABEL_146:
        uint64_t v67 = 0;
        goto LABEL_151;
      }
      uint64_t v63 = *(unsigned int **)(v85 + 32 * (v55 & ~(-1 << *(_DWORD *)(v54 + 84))));
      while (2)
      {
        if (v55 != v63[11]
          || v63[7] - *(_DWORD *)(v54 + 64) + v63[8] + *(_DWORD *)(v54 + 52) - *(_DWORD *)(v54 + 48) < *(_DWORD *)(v54 + 52) >> 2
          || v63[12] != v51
          || !v239 && v63[6] > *(_DWORD *)(v54 + 36))
        {
LABEL_96:
          uint64_t v63 = (unsigned int *)*((void *)v63 + 1);
          if (!v63) {
            goto LABEL_99;
          }
          continue;
        }
        break;
      }
      if (v59)
      {
        if (v83 < 0)
        {
          if (!qenc_has_or_can_evict_at_least((uint64_t)v234, v214))
          {
            int v83 = 0;
            goto LABEL_95;
          }
        }
        else if (!v83)
        {
LABEL_95:
          unint64_t v58 = (unint64_t)v244;
          goto LABEL_96;
        }
        int v83 = 1;
      }
      if (memcmp(v246, v63 + 14, v238)) {
        goto LABEL_95;
      }
      uint64_t v233 = v63[6];
      unint64_t v58 = (unint64_t)v244;
      if (!v239 || !v59 || !v83) {
        goto LABEL_229;
      }
      uint64_t v240 = 0;
      uint64_t v161 = *(void *)(v54 + 248);
      int v65 = 6;
      uint64_t v66 = 1;
      if (!v161) {
        goto LABEL_219;
      }
      uint64_t v162 = 260;
      if (!*(_DWORD *)(v54 + 264)) {
        uint64_t v162 = 256;
      }
      unint64_t v163 = v161 + 8 * *(unsigned int *)(v54 + v162);
      *(_DWORD *)(v163 + 4) = v229;
      unint64_t v164 = v161 - 8;
      do
      {
        int v165 = *(_DWORD *)(v164 + 12);
        v164 += 8;
      }
      while (v165 != v229);
      uint64_t v240 = 0;
      int v65 = 6;
      uint64_t v66 = 1;
      if (v164 < v163)
      {
LABEL_219:
        int v237 = 1;
        unsigned int v239 = 1;
        BOOL v59 = 1;
        uint64_t v67 = 3;
      }
      else
      {
LABEL_229:
        uint64_t v66 = 0;
        uint64_t v67 = 0;
        int v65 = 2;
        int v237 = 1;
        uint64_t v240 = 4;
      }
LABEL_110:
      unint64_t v57 = (unint64_t)v235;
LABEL_151:
      if (((1 << v67) & 0x3C) != 0 && ((1 << v240) & 0x78) != 0)
      {
        unsigned int v108 = 0;
        if (a4)
        {
          unsigned int v108 = 0;
          uint64_t v109 = v246;
          do
          {
            int v110 = *v109++;
            v108 += encode_table[2 * v110 + 1];
          }
          while ((unint64_t)v109 < v58);
        }
        unsigned int v111 = 0;
        unsigned int v112 = v108 >> 3;
        BOOL v113 = (v108 & 7) != 0;
        if (a6)
        {
          unsigned int v111 = 0;
          v114 = v241;
          do
          {
            int v115 = *v114++;
            v111 += encode_table[2 * v115 + 1];
          }
          while ((unint64_t)v114 < v57);
        }
        unsigned int v116 = v112 + *(_DWORD *)(v54 + 228) + v113 + (v111 >> 3);
        if ((v111 & 7) != 0) {
          ++v116;
        }
        if ((float)((float)v116 / (float)(v215 + *(_DWORD *)(v54 + 224))) > 0.95)
        {
          if (!v59) {
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1917, "index");
          }
          v117 = *(FILE **)(v54 + 232);
          if (v117)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v117);
            fwrite("double lit would result in ratio > 0.95, reset", 0x2EuLL, 1uLL, *(FILE **)(v54 + 232));
            fputc(10, *(FILE **)(v54 + 232));
          }
          BOOL v59 = 0;
          uint64_t v62 = v233;
          unsigned int v51 = a4;
          unint64_t v58 = (unint64_t)v244;
          uint64_t v61 = v236;
          continue;
        }
      }
      break;
    }
    uint64_t v118 = v66;
    int v231 = v65;
    uint64_t v119 = *(FILE **)(v54 + 232);
    if (v119)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v119);
      fprintf(*(FILE **)(v54 + 232), "program: %s; %s; %s; flags: 0x%X",
        eea2str[v67],
        eha2str[v240],
        eta2str[v118],
        v231);
      fputc(10, *(FILE **)(v54 + 232));
    }
    int64_t v120 = v232;
    switch(v67)
    {
      case 0:
        goto LABEL_187;
      case 1:
        if (v232 < 1) {
          goto LABEL_189;
        }
        unsigned char *v228 = 0;
        uint64_t v126 = lsqpack_enc_int(v228, v226, (*v234 - v233), 5);
        uint64_t v67 = v126 - v228;
        if (v126 <= v228) {
          goto LABEL_189;
        }
        goto LABEL_187;
      case 2:
        if (v232 < 1) {
          goto LABEL_189;
        }
        v127 = v228;
        unsigned char *v228 = -64;
        unint64_t v128 = v233;
        goto LABEL_183;
      case 3:
        if (v232 < 1) {
          goto LABEL_189;
        }
        v127 = v228;
        unsigned char *v228 = 0x80;
        unint64_t v128 = (*v234 - v233);
LABEL_183:
        v129 = lsqpack_enc_int(v127, v226, v128, 6);
        if (v129 <= v127
          || (uint64_t v130 = v129,
              int v131 = lsqpack_enc_enc_str(7, v129, v226 - (void)v129, (unsigned __int16 *)v241, a6),
              v131 < 0))
        {
LABEL_189:
          size_t v134 = *(void *)(*(void *)(v6[9] + 8) + 24);
          uint64_t v135 = *(void *)(v6[8] + 8);
          uint64_t v136 = *(void *)(v135 + 24);
          if (v134 < v136 + *(void *)(*(void *)(v6[7] + 8) + 24))
          {
            dispatch_data_t v137 = dispatch_data_create_subrange(*(dispatch_data_t *)(*(void *)(v6[10] + 8) + 40), 0, v134);
            uint64_t v138 = *(void *)(v6[10] + 8);
            v139 = *(void **)(v138 + 40);
            *(void *)(v138 + 40) = v137;

            uint64_t v135 = *(void *)(v6[8] + 8);
            uint64_t v136 = *(void *)(v135 + 24);
          }
          *(void *)(v135 + 24) = v136 + 512;
          id alloc = dispatch_data_create_alloc();
          dispatch_data_t v140 = dispatch_data_create_concat(*(dispatch_data_t *)(*(void *)(v6[10] + 8) + 40), alloc);
          uint64_t v141 = *(void *)(v6[10] + 8);
          float v27 = *(void **)(v141 + 40);
          *(void *)(v141 + 40) = v140;
          unint64_t v28 = v217;
          unsigned int v29 = v218;
LABEL_192:

          *(void *)(*(void *)(*v28 + 8) + 24) = *(void *)(*(void *)(*v29 + 8) + 24);
          continue;
        }
        uint64_t v125 = &v130[v131];
LABEL_186:
        uint64_t v67 = v125 - v228;
LABEL_187:
        switch(v240)
        {
          case 0:
            uint64_t v132 = (*v234 + 1);
            uint64_t v133 = v224;
            goto LABEL_195;
          case 1:
            uint64_t v133 = v224;
            unsigned char *v224 = -64;
            unint64_t v142 = v233;
            goto LABEL_221;
          case 2:
            uint64_t v132 = v233;
            uint64_t v133 = v224;
            if (v233 <= *(_DWORD *)(v54 + 188))
            {
              unsigned char *v224 = 0x80;
              unint64_t v142 = (*(_DWORD *)(v54 + 188) - v233);
LABEL_221:
              v144 = v133;
              unint64_t v145 = v225;
              char v146 = 6;
            }
            else
            {
LABEL_195:
              *uint64_t v133 = 16;
              unsigned int v143 = *(_DWORD *)(v54 + 188);
              if (v132 <= v143) {
                __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2008, "id > enc->qpe_cur_header.base_idx");
              }
              uint64_t v233 = v132;
              unint64_t v142 = v132 + ~v143;
              v144 = v133;
              unint64_t v145 = v225;
              char v146 = 4;
            }
            v157 = lsqpack_enc_int(v144, v145, v142, v146);
            if (v157 > v133) {
              break;
            }
            goto LABEL_8;
          case 3:
            v148 = v224;
            unsigned char *v224 = 80;
            unint64_t v149 = v233;
            goto LABEL_206;
          case 4:
            uint64_t v147 = v233;
            v148 = v224;
            if (v233 > *(_DWORD *)(v54 + 188)) {
              goto LABEL_200;
            }
            unsigned char *v224 = 64;
            unint64_t v149 = (*(_DWORD *)(v54 + 188) - v233);
LABEL_206:
            v151 = v148;
            unint64_t v152 = v225;
            char v153 = 4;
            goto LABEL_207;
          case 5:
            uint64_t v147 = (*v234 + 1);
            v148 = v224;
LABEL_200:
            unsigned char *v148 = 0;
            unsigned int v150 = *(_DWORD *)(v54 + 188);
            if (v147 <= v150) {
              __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2045, "id > enc->qpe_cur_header.base_idx");
            }
            uint64_t v233 = v147;
            unint64_t v149 = v147 + ~v150;
            v151 = v148;
            unint64_t v152 = v225;
            char v153 = 3;
LABEL_207:
            v158 = lsqpack_enc_int(v151, v152, v149, v153);
            if (v158 <= v148) {
              goto LABEL_8;
            }
            v159 = v158;
            int v160 = lsqpack_enc_enc_str(7, v158, v225 - (void)v158, (unsigned __int16 *)v241, a6);
            if (v160 < 0) {
              goto LABEL_8;
            }
            v157 = &v159[v160];
            break;
          case 6:
            unsigned char *v224 = 32;
            int v154 = lsqpack_enc_enc_str(3, v224, v221, (unsigned __int16 *)v246, a4);
            if (v154 < 0) {
              goto LABEL_8;
            }
            v155 = &v224[v154];
            int v156 = lsqpack_enc_enc_str(7, v155, v225 - (void)v155, (unsigned __int16 *)v241, a6);
            if (v156 < 0) {
              goto LABEL_8;
            }
            v157 = &v155[v156];
            break;
          default:
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2075, "prog.ep_hea_action == EHA_LIT_WITH_NAME_STAT");
        }
        if ((unint64_t)(v118 - 1) <= 1)
        {
          if (v118 == 1) {
            unsigned int v166 = a6;
          }
          else {
            unsigned int v166 = 0;
          }
          v167 = lsqpack_enc_push_entry((uint64_t)v234, v55, v49, v246, a4, v241, v166);
          if (v167)
          {
            uint64_t v176 = v157 - v224;
            uint64_t v177 = v242;
            v178 = *(_DWORD **)(v242 + 160);
            v178[13] += v167[12] + v167[13] + 32;
            if ((v231 & 4) != 0)
            {
              ++v167[9];
              *(_DWORD *)(v242 + 184) |= 2u;
              unsigned int v179 = v178[15];
              unsigned int v180 = v167[6];
              if (!v179)
              {
                v178[14] = v180;
                v178[15] = v180;
                if ((v231 & 2) == 0) {
                  goto LABEL_262;
                }
                goto LABEL_256;
              }
              if (v180 <= v179) {
                __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2111, "new_entry->ete_id > enc->qpe_cur_header.hinfo->qhi_max_id");
              }
              v178[15] = v180;
            }
            if ((v231 & 2) == 0) {
              goto LABEL_262;
            }
            goto LABEL_256;
          }
          BOOL v59 = 0;
          uint64_t v62 = v233;
          unsigned int v51 = a4;
          unint64_t v58 = (unint64_t)v244;
          unint64_t v57 = (unint64_t)v235;
          uint64_t v61 = v236;
          uint64_t v54 = v242;
          goto LABEL_42;
        }
        if (v118) {
          __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2117, "prog.ep_tab_action == ETA_NOOP");
        }
        uint64_t v176 = v157 - v224;
        uint64_t v177 = v242;
        if ((v231 & 2) == 0) {
          goto LABEL_262;
        }
LABEL_256:
        ++v63[9];
        uint64_t v181 = *(void *)(v177 + 160);
        unsigned int v182 = v63[6];
        unsigned int v183 = *(_DWORD *)(v181 + 60);
        if (!v183)
        {
          *(_DWORD *)(v181 + 60) = v182;
LABEL_261:
          *(_DWORD *)(v181 + 56) = v182;
          goto LABEL_262;
        }
        if (v183 < v182)
        {
          *(_DWORD *)(v181 + 60) = v182;
          goto LABEL_262;
        }
        if (*(_DWORD *)(v181 + 56) > v182) {
          goto LABEL_261;
        }
LABEL_262:
        qenc_remove_overflow_entries((uint64_t)v234);
        if (v219)
        {
          uint64_t v184 = *(void *)(v177 + 248);
          if (!v184) {
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2132, "enc->qpe_hist_els");
          }
          unsigned int v185 = *(_DWORD *)(v177 + 260);
          if (*(_DWORD *)(v177 + 176) < v185)
          {
LABEL_267:
            *(_DWORD *)(v184 + 8 * *(unsigned int *)(v177 + 256)) = v55;
            *(_DWORD *)(v184 + 8 * *(unsigned int *)(v177 + 256) + 4) = v49;
            unsigned int v186 = (*(_DWORD *)(v177 + 256) + 1) % *(_DWORD *)(v177 + 260);
            *(_DWORD *)(v177 + 256) = v186;
            *(_DWORD *)(v177 + 264) |= v186 == 0;
          }
          else
          {
            qenc_hist_update_size((uint64_t)v234, v185 + 4);
            if (*(_DWORD *)(v177 + 260))
            {
              uint64_t v184 = *(void *)(v177 + 248);
              goto LABEL_267;
            }
          }
          ++*(_DWORD *)(v177 + 176);
        }
        if (v232 != v67)
        {
          uint64_t v247 = v176;
          v187 = (_DWORD *)(v242 + 32);
          while ((*(unsigned char *)(v177 + 44) & 2) != 0 && *v187 != -1)
          {
            float v188 = *(float *)(v177 + 240);
            if ((v188 != 0.0
               || *(void *)(v177 + 168)
               || *(_DWORD *)(v177 + 72) < *(_DWORD *)(v177 + 68)
               || (uint64_t v189 = *(void *)(v177 + 160)) != 0 && *(_DWORD *)(v189 + 60) > *(_DWORD *)(v177 + 36))
              && v188 < *(float *)(v177 + 244))
            {
              break;
            }
            v190 = *(uint64_t **)(v177 + 88);
            if (!v190) {
              break;
            }
            v191 = 0;
            v192 = &v228[v67];
            do
            {
              if ((*((_DWORD *)v190 + 7)
                                - *(_DWORD *)(v177 + 64)
                                + *((_DWORD *)v190 + 8)
                                + *(_DWORD *)(v177 + 52)
                                - *(_DWORD *)(v177 + 48)) >= *(_DWORD *)(v177 + 52) >> 2)
                break;
              if (!v191
                || *((_DWORD *)v190 + 12) + *((_DWORD *)v190 + 13) + 32 >= (v191[12] + v191[13] + 32))
              {
                v193 = (uint64_t *)*v190;
                int v194 = *((_DWORD *)v190 + 10);
                if (*v190)
                {
                  while (1)
                  {
                    if (*((_DWORD *)v193 + 10) == v194)
                    {
                      uint64_t v195 = *((unsigned int *)v193 + 12);
                      if (v195 == *((_DWORD *)v190 + 12))
                      {
                        size_t v196 = *((unsigned int *)v193 + 13);
                        if (v196 == *((_DWORD *)v190 + 13)
                          && !memcmp(v193 + 7, v190 + 7, *((unsigned int *)v193 + 12))
                          && !memcmp((char *)v193 + v195 + 56, (char *)v190 + v195 + 56, v196))
                        {
                          break;
                        }
                      }
                    }
                    v193 = (uint64_t *)*v193;
                    if (!v193) {
                      goto LABEL_291;
                    }
                  }
                  v187 = (_DWORD *)(v242 + 32);
                  uint64_t v177 = v242;
                }
                else
                {
LABEL_291:
                  uint64_t v177 = v242;
                  uint64_t v197 = *(void *)(v242 + 248);
                  if (!v197) {
                    goto LABEL_297;
                  }
                  uint64_t v198 = 260;
                  if (!*(_DWORD *)(v242 + 264)) {
                    uint64_t v198 = 256;
                  }
                  unint64_t v199 = v197 + 8 * *(unsigned int *)(v242 + v198);
                  *(_DWORD *)(v199 + 4) = v194;
                  unint64_t v200 = v197 - 8;
                  do
                  {
                    int v201 = *(_DWORD *)(v200 + 12);
                    v200 += 8;
                  }
                  while (v201 != v194);
                  if (v200 >= v199)
                  {
                    v187 = (_DWORD *)(v242 + 32);
                  }
                  else
                  {
LABEL_297:
                    v187 = (_DWORD *)(v242 + 32);
                    if (qenc_has_or_can_evict_at_least((uint64_t)v234, (*((_DWORD *)v190 + 12) + *((_DWORD *)v190 + 13) + 32)))v191 = v190; {
                  }
                    }
                }
              }
              v190 = (uint64_t *)v190[2];
            }
            while (v190);
            if (!v191) {
              break;
            }
            v202 = *(FILE **)(v177 + 232);
            if (v202)
            {
              fwrite("qenc: debug: ", 0xDuLL, 1uLL, v202);
              fwrite("dup draining", 0xCuLL, 1uLL, *(FILE **)(v177 + 232));
              fputc(10, *(FILE **)(v177 + 232));
            }
            unsigned char *v192 = 0;
            v203 = lsqpack_enc_int(v192, v226, (*v187 - v191[6]), 5);
            if (v203 <= v192
              || (int v204 = (int)v203,
                  !lsqpack_enc_push_entry((uint64_t)v187, v191[11], v191[10], v191 + 14, v191[12], (char *)v191 + v191[12] + 56, v191[13]))|| v204 == v192)
            {
              int64_t v120 = v67;
              uint64_t v176 = v247;
              uint64_t v177 = v242;
              goto LABEL_315;
            }
            v67 += (v204 - v192);
            qenc_remove_overflow_entries((uint64_t)v187);
            uint64_t v177 = v242;
            if (v232 == v67)
            {
              int64_t v120 = v232;
LABEL_313:
              uint64_t v176 = v247;
              goto LABEL_315;
            }
          }
          int64_t v120 = v67;
          goto LABEL_313;
        }
LABEL_315:
        unsigned int v205 = v215 + *(_DWORD *)(v177 + 224);
        unsigned int v206 = *(_DWORD *)(v177 + 228) + v120 + v176;
        *(_DWORD *)(v177 + 224) = v205;
        *(_DWORD *)(v177 + 228) = v206;
        if (v206 >= 0x80000001)
        {
          *(_DWORD *)(v177 + 224) = (int)(float)((float)((float)v205 / (float)v206) * 1000.0);
          *(_DWORD *)(v177 + 228) = 1000;
          v207 = *(FILE **)(v177 + 232);
          if (v207)
          {
            uint64_t v208 = v176;
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v207);
            v209 = *(FILE **)(v177 + 232);
            unsigned int v210 = *(_DWORD *)(v177 + 224);
            if (v210)
            {
              float v211 = (float)*(unsigned int *)(v177 + 228) / (float)v210;
              if (v209)
              {
                fwrite("qenc: debug: ", 0xDuLL, 1uLL, *(FILE **)(v177 + 232));
                fprintf(*(FILE **)(v177 + 232), "bytes out: %u; bytes in: %u, ratio: %.3f",
                  *(_DWORD *)(v177 + 228),
                  *(_DWORD *)(v177 + 224),
                  v211);
                fputc(10, *(FILE **)(v177 + 232));
              }
            }
            else
            {
              float v211 = 0.0;
            }
            fprintf(v209, "reset bytes in/out counters, ratio: %.3f", v211);
            fputc(10, *(FILE **)(v177 + 232));
            uint64_t v176 = v208;
          }
        }
        *(void *)(*(void *)(*v223 + 8) + 24) += v176;
        *(void *)(*(void *)(*v218 + 8) + 24) += v120;
        return;
      case 4:
      case 5:
        if (v232 < 1) {
          goto LABEL_189;
        }
        unsigned char *v228 = 64;
        int v121 = lsqpack_enc_enc_str(5, v228, v232, (unsigned __int16 *)v246, a4);
        if (v121 < 0) {
          goto LABEL_189;
        }
        uint64_t v122 = &v228[v121];
        unsigned int v123 = v67 == 4 ? a6 : 0;
        int v124 = lsqpack_enc_enc_str(7, v122, v226 - (void)v122, (unsigned __int16 *)v241, v123);
        if (v124 < 0) {
          goto LABEL_189;
        }
        uint64_t v125 = &v122[v124];
        goto LABEL_186;
      default:
        __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1989, "EEA_NONE == prog.ep_enc_action");
    }
  }
}

uint64_t XXH_INLINE_XXH32(int *a1, unint64_t a2, int a3)
{
  if (a1)
  {
    if (a2 < 0x10)
    {
      unsigned int v12 = a3 + 374761393 + a2;
    }
    else
    {
      unint64_t v3 = (unint64_t)a1 + a2 - 15;
      int v4 = a3 + 606290984;
      int v5 = a3 - 2048144777;
      int v6 = a3 + 1640531535;
      do
      {
        HIDWORD(v7) = v4 - 2048144777 * *a1;
        LODWORD(v7) = HIDWORD(v7);
        int v4 = -1640531535 * (v7 >> 19);
        HIDWORD(v7) = v5 - 2048144777 * a1[1];
        LODWORD(v7) = HIDWORD(v7);
        int v5 = -1640531535 * (v7 >> 19);
        HIDWORD(v7) = a3 - 2048144777 * a1[2];
        LODWORD(v7) = HIDWORD(v7);
        a3 = -1640531535 * (v7 >> 19);
        HIDWORD(v7) = v6 - 2048144777 * a1[3];
        LODWORD(v7) = HIDWORD(v7);
        int v6 = -1640531535 * (v7 >> 19);
        a1 += 4;
      }
      while ((unint64_t)a1 < v3);
      HIDWORD(v9) = v4;
      LODWORD(v9) = v4;
      int v8 = v9 >> 31;
      HIDWORD(v9) = v5;
      LODWORD(v9) = v5;
      int v10 = v9 >> 25;
      HIDWORD(v9) = a3;
      LODWORD(v9) = a3;
      int v11 = v9 >> 20;
      HIDWORD(v9) = v6;
      LODWORD(v9) = v6;
      unsigned int v12 = v8 + a2 + v10 + v11 + (v9 >> 14);
      a2 &= 0xFu;
    }
    if (a2 >= 4)
    {
      do
      {
        int v13 = *a1++;
        HIDWORD(v14) = v12 - 1028477379 * v13;
        LODWORD(v14) = HIDWORD(v14);
        unsigned int v12 = 668265263 * (v14 >> 15);
        a2 -= 4;
      }
      while (a2 > 3);
    }
    for (; a2; --a2)
    {
      int v15 = *(unsigned __int8 *)a1;
      a1 = (int *)((char *)a1 + 1);
      HIDWORD(v16) = v12 + 374761393 * v15;
      LODWORD(v16) = HIDWORD(v16);
      unsigned int v12 = -1640531535 * (v16 >> 21);
    }
  }
  else
  {
    unsigned int v12 = a3 + 374761393;
  }
  unsigned int v17 = -1028477379 * ((-2048144777 * (v12 ^ (v12 >> 15))) ^ ((-2048144777 * (v12 ^ (v12 >> 15))) >> 13));
  return v17 ^ HIWORD(v17);
}

void qenc_remove_overflow_entries(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  unsigned int v3 = *(_DWORD *)(a1 + 20);
  unsigned int v4 = v3;
  if (v2 > v3)
  {
    int v5 = (void **)(a1 + 56);
    do
    {
      int v6 = (char *)*v5;
      if (!*v5) {
        __assert_rtn("qenc_drop_oldest_entry", "lsqpack.c", 852, "entry");
      }
      unint64_t v7 = *(FILE **)(a1 + 200);
      int v8 = *v5;
      if (v7)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
          *((_DWORD *)v6 + 6),
          *((_DWORD *)v6 + 12),
          v6 + 56,
          *((_DWORD *)v6 + 13),
          &v6[*((unsigned int *)v6 + 12) + 56],
          *(_DWORD *)(a1 + 48) - 1,
          *(_DWORD *)(a1 + 16) - (*((_DWORD *)v6 + 12) + *((_DWORD *)v6 + 13)) - 32);
        fputc(10, *(FILE **)(a1 + 200));
        int v8 = *(void **)(a1 + 56);
      }
      unint64_t v9 = (void *)v8[2];
      *int v5 = v9;
      if (!v9) {
        *(void *)(a1 + 64) = v5;
      }
      int v10 = -1 << *(_DWORD *)(a1 + 52);
      uint64_t v11 = *((_DWORD *)v6 + 10) & ~v10;
      uint64_t v12 = *(void *)(a1 + 72);
      uint64_t v13 = v12 + 32 * v11;
      int v15 = *(char **)(v13 + 16);
      unint64_t v14 = (void *)(v13 + 16);
      if (v6 != v15) {
        __assert_rtn("qenc_drop_oldest_entry", "lsqpack.c", 859, "entry == STAILQ_FIRST(&enc->qpe_buckets[buckno].by_nameval)");
      }
      uint64_t v16 = *(void *)v6;
      void *v14 = *(void *)v6;
      if (!v16) {
        *(void *)(v12 + 32 * v11 + 24) = v14;
      }
      unsigned int v17 = (void **)(v12 + 32 * (*((_DWORD *)v6 + 11) & ~v10));
      if (v6 != *v17) {
        __assert_rtn("qenc_drop_oldest_entry", "lsqpack.c", 862, "entry == STAILQ_FIRST(&enc->qpe_buckets[buckno].by_name)");
      }
      size_t v18 = (void *)*((void *)v6 + 1);
      FILE *v17 = v18;
      if (!v18) {
        v17[1] = v17;
      }
      int v19 = *((_DWORD *)v6 + 12) + *((_DWORD *)v6 + 13) + 32;
      *(_DWORD *)(a1 + 32) += v19;
      *(_DWORD *)(a1 + 16) -= v19;
      --*(_DWORD *)(a1 + 48);
      free(v6);
      unsigned int v4 = *(_DWORD *)(a1 + 20);
    }
    while (*(_DWORD *)(a1 + 16) > v4);
  }
  uint64_t v20 = *(FILE **)(a1 + 200);
  if (v4) {
    BOOL v21 = v20 == 0;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21)
  {
    int v22 = *(_DWORD *)(a1 + 12);
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v20);
    unsigned int v24 = *(_DWORD *)(a1 + 16);
    unsigned int v23 = *(_DWORD *)(a1 + 20);
    float v25 = (float)v23;
    float v26 = (float)v24 / (float)v23;
    double v27 = v26;
    if ((v22 & 2) != 0)
    {
      if (!v23) {
        __assert_rtn("qenc_effective_fill", "lsqpack.c", 878, "enc->qpe_cur_max_capacity");
      }
      uint64_t v28 = *(void *)(a1 + 56);
      unsigned int v40 = v2;
      unint64_t v39 = *(FILE **)(a1 + 200);
      if (v28 && (uint64_t v29 = *(void *)(v28 + 16)) != 0)
      {
        int v30 = 0;
        do
        {
          unint64_t v31 = (_DWORD *)v28;
          uint64_t v28 = v29;
          int v32 = v31[12];
          uint64_t v33 = v29;
          while (1)
          {
            if (*(_DWORD *)(v33 + 48) == v32)
            {
              int v34 = *(_DWORD *)(v33 + 52);
              if (v34 == v31[13] && !memcmp((const void *)(v33 + 56), v31 + 14, (v34 + v32))) {
                break;
              }
            }
            uint64_t v33 = *(void *)(v33 + 16);
            if (!v33) {
              goto LABEL_32;
            }
          }
          v30 += v32 + v34 + 32;
LABEL_32:
          uint64_t v29 = *(void *)(v28 + 16);
        }
        while (v29);
      }
      else
      {
        int v30 = 0;
      }
      fprintf(v39, "fill: %.2f; effective fill: %.2f", v27, (float)((float)(v24 - v30) / v25));
      unsigned int v2 = v40;
    }
    else
    {
      fprintf(*(FILE **)(a1 + 200), "fill: %.2f", v26);
    }
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (v2 > v3 && *(void *)(a1 + 216))
  {
    float v35 = *(float *)(a1 + 208);
    float v36 = (float)*(unsigned int *)(a1 + 48);
    if (v35 != 0.0) {
      float v36 = v35 + (float)(v36 - v35) * 0.4;
    }
    *(float *)(a1 + 208) = v36;
    unint64_t v37 = *(FILE **)(a1 + 200);
    if (v37)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v37);
      fprintf(*(FILE **)(a1 + 200), "table size actual: %u; exponential moving average: %.3f",
        *(_DWORD *)(a1 + 48),
        *(float *)(a1 + 208));
      int v38 = *(FILE **)(a1 + 200);
      fputc(10, v38);
    }
  }
}

uint64_t lsqpack_enc_enc_str(char a1, unsigned char *a2, unint64_t a3, unsigned __int16 *a4, unsigned int a5)
{
  int v6 = a4;
  unint64_t v8 = (unint64_t)a4 + a5;
  unsigned int v9 = 0;
  if (a5)
  {
    int v10 = a4;
    do
    {
      int v11 = *(unsigned __int8 *)v10;
      int v10 = (unsigned __int16 *)((char *)v10 + 1);
      v9 += encode_table[2 * v11 + 1];
    }
    while ((unint64_t)v10 < v8);
  }
  unsigned int v12 = v9 >> 3;
  if ((v9 & 7) != 0) {
    unint64_t v13 = v12 + 1;
  }
  else {
    unint64_t v13 = v12;
  }
  if (v13 >= a5)
  {
    size_t v34 = a5;
    if (~(-1 << a1) > (unint64_t)a5) {
      int v35 = 1;
    }
    else {
      int v35 = 2;
    }
    int64x2_t v36 = vdupq_n_s64(-1 << a1);
    uint64x2_t v37 = (uint64x2_t)vdupq_n_s64(a5);
    int16x8_t v38 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v37, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1843D1870, v36)), (int32x4_t)vcgeq_u64(v37, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1843D1880, v36))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v37, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1843D1890, v36)), (int32x4_t)vcgeq_u64(v37, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1843D18A0, v36)))), (int8x16_t)xmmword_1843D18B0);
    v38.i32[0] = vaddvq_s16(v38);
    *(int8x8_t *)v38.i8 = vcnt_s8(*(int8x8_t *)v38.i8);
    v38.i16[0] = vaddlv_u8(*(uint8x8_t *)v38.i8);
    __int32 v39 = v35 + v38.i32[0];
    unint64_t v40 = v35 + v38.i32[0] + a5;
    if (v40 <= a3)
    {
      *a2 &= -2 << a1;
      lsqpack_enc_int_nocheck(a2, a5, a1);
      memcpy(&a2[v39], v6, v34);
      return v40;
    }
    return 0xFFFFFFFFLL;
  }
  if (~(-1 << a1) > (unint64_t)v13) {
    int v14 = 1;
  }
  else {
    int v14 = 2;
  }
  int64x2_t v15 = vdupq_n_s64(-1 << a1);
  uint64x2_t v16 = (uint64x2_t)vdupq_n_s64(v13);
  int16x8_t v17 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v16, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1843D1870, v15)), (int32x4_t)vcgeq_u64(v16, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1843D1880, v15))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v16, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1843D1890, v15)), (int32x4_t)vcgeq_u64(v16, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_1843D18A0, v15)))), (int8x16_t)xmmword_1843D18B0);
  v17.i32[0] = vaddvq_s16(v17);
  *(int8x8_t *)v17.i8 = vcnt_s8(*(int8x8_t *)v17.i8);
  v17.i16[0] = vaddlv_u8(*(uint8x8_t *)v17.i8);
  __int32 v18 = v14 + v17.i32[0];
  unint64_t v19 = (v14 + v17.i32[0] + v13);
  if (v19 > a3) {
    return 0xFFFFFFFFLL;
  }
  *a2 = *a2 & (-2 << a1) | (1 << a1);
  lsqpack_enc_int_nocheck(a2, v13, a1);
  uint64_t v20 = &a2[v18];
  if (a5 < 0xF)
  {
    uint64_t v22 = 0;
    unsigned int v21 = 0;
  }
  else
  {
    unsigned int v21 = 0;
    uint64_t v22 = 0;
    unsigned int v23 = &a2[v18];
    while (1)
    {
      float v25 = v6 + 1;
      uint64_t v24 = *v6;
      unsigned int v26 = hencs[2 * v24];
      unsigned int v27 = v26 + v21;
      if (v26 + v21 > 0x3F)
      {
        unint64_t v31 = v6;
      }
      else
      {
        do
        {
          unsigned int v21 = v27;
          uint64_t v28 = v22 << v26;
          uint64_t v29 = hencs[2 * v24 + 1];
          unsigned int v30 = *v25++;
          uint64_t v24 = v30;
          uint64_t v22 = v28 | v29;
          unsigned int v26 = hencs[2 * v30];
          v27 += v26;
        }
        while (v27 < 0x40);
        unint64_t v31 = v25 - 1;
      }
      int v6 = v25;
      if (v26 > 0x3F) {
        break;
      }
      uint64_t v32 = v22 << -(char)v21;
      uint64_t v22 = hencs[2 * v24 + 1];
      unsigned int v21 = v26 - (64 - v21);
      unsigned char *v23 = HIBYTE(v32);
      v23[1] = BYTE6(v32);
      v23[2] = BYTE5(v32);
      v23[3] = BYTE4(v32);
      int v33 = v32 | (v22 >> v21);
      v23[4] = HIBYTE(v33);
      v23[5] = BYTE2(v33);
      v23[6] = BYTE1(v33);
      uint64_t v20 = v23 + 8;
      v23[7] = v33;
      v23 += 8;
      if ((unint64_t)(v6 + 7) >= v8) {
        goto LABEL_29;
      }
    }
    uint64_t v20 = v23;
    int v6 = v31;
  }
LABEL_29:
  if (v6 != (unsigned __int16 *)v8)
  {
    do
    {
      uint64_t v41 = v22;
      while (1)
      {
        int v42 = *(unsigned __int8 *)v6;
        int v6 = (unsigned __int16 *)((char *)v6 + 1);
        unint64_t v43 = &encode_table[2 * v42];
        uint64_t v22 = *v43;
        unsigned int v44 = v43[1];
        unsigned int v45 = v44 + v21;
        if (v44 + v21 > 0x3F) {
          break;
        }
        uint64_t v41 = (v41 << v44) | v22;
        v21 += v44;
        if (v6 == (unsigned __int16 *)v8)
        {
          unsigned int v47 = v20;
          uint64_t v22 = v41;
          unsigned int v21 = v45;
          goto LABEL_35;
        }
      }
      uint64_t v46 = v41 << -(char)v21;
      unsigned int v21 = v44 - (64 - v21);
      unsigned char *v20 = HIBYTE(v46);
      v20[1] = BYTE6(v46);
      v20[2] = BYTE5(v46);
      void v20[3] = BYTE4(v46);
      LODWORD(v46) = v46 | (v22 >> v21);
      v20[4] = BYTE3(v46);
      void v20[5] = BYTE2(v46);
      v20[6] = BYTE1(v46);
      unsigned int v47 = v20 + 8;
      v20[7] = v46;
      v20 += 8;
    }
    while (v6 != (unsigned __int16 *)v8);
LABEL_35:
    if (!v21) {
      goto LABEL_47;
    }
    goto LABEL_38;
  }
  unsigned int v47 = v20;
  if (v21)
  {
LABEL_38:
    unsigned int v48 = v21 + 7;
    char v49 = ((v21 + 7) & 0xF8) - v21;
    uint64_t v50 = v22 << v49;
    int v51 = (v22 << v49) | ~(-1 << v49);
    switch(v48 >> 3)
    {
      case 2u:
        goto LABEL_45;
      case 3u:
        goto LABEL_44;
      case 4u:
        goto LABEL_43;
      case 5u:
        goto LABEL_42;
      case 6u:
        goto LABEL_41;
      case 7u:
        goto LABEL_40;
      case 8u:
        *v47++ = HIBYTE(v50);
LABEL_40:
        *v47++ = BYTE6(v50);
LABEL_41:
        *v47++ = BYTE5(v50);
LABEL_42:
        *v47++ = BYTE4(v50);
LABEL_43:
        *v47++ = HIBYTE(v51);
LABEL_44:
        *v47++ = BYTE2(v51);
LABEL_45:
        *v47++ = BYTE1(v51);
        break;
      default:
        break;
    }
    unsigned char *v47 = v51;
    LODWORD(v47) = v47 + 1;
  }
LABEL_47:
  if (v19 != v47 - a2) {
    __assert_rtn("lsqpack_enc_enc_str", "lsqpack.c", 823, "(unsigned) (p - dst) == len_size + enc_size_bytes");
  }
  return v19;
}

unsigned char *lsqpack_enc_int_nocheck(unsigned char *result, unint64_t a2, char a3)
{
  if (~(-1 << a3) <= a2)
  {
    *result++ |= ~(-1 << a3);
    unint64_t v3 = a2 - ~(-1 << a3);
    if (v3 < 0x80)
    {
      LODWORD(v4) = a2 + (-1 << a3) + 1;
    }
    else
    {
      do
      {
        *result++ = v3 | 0x80;
        unint64_t v4 = v3 >> 7;
        unint64_t v5 = v3 >> 14;
        v3 >>= 7;
      }
      while (v5);
    }
    *uint64_t result = v4;
  }
  else
  {
    *result |= a2;
  }
  return result;
}

unsigned char *lsqpack_enc_int(unsigned char *result, unint64_t a2, unint64_t a3, char a4)
{
  if ((unint64_t)result >= a2) {
    __assert_rtn("lsqpack_enc_int", "lsqpack.c", 759, "dst < end");
  }
  if (~(-1 << a4) <= a3)
  {
    *result |= ~(-1 << a4);
    unint64_t v4 = result + 1;
    unint64_t v5 = a3 - ~(-1 << a4);
    if (v5 < 0x80)
    {
      unint64_t v8 = result;
      LODWORD(v6) = a3 + (-1 << a4) + 1;
LABEL_9:
      if ((unint64_t)v4 < a2)
      {
        uint64_t result = v8 + 2;
        unsigned char *v4 = v6;
      }
    }
    else
    {
      while ((unint64_t)v4 < a2)
      {
        *v4++ = v5 | 0x80;
        unint64_t v6 = v5 >> 7;
        unint64_t v7 = v5 >> 14;
        v5 >>= 7;
        if (!v7)
        {
          unint64_t v8 = v4 - 1;
          goto LABEL_9;
        }
      }
    }
  }
  else
  {
    *result++ |= a3;
  }
  return result;
}

uint64_t qenc_has_or_can_evict_at_least(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (*(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16));
  if (v2 >= a2) {
    return 1;
  }
  int v3 = *(_DWORD *)(a1 + 152);
  if ((v3 & 4) != 0)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 148);
  }
  else
  {
    unint64_t v4 = *(uint64_t **)(a1 + 96);
    if (v4)
    {
      unsigned int v5 = 0;
      do
      {
        unsigned int v6 = *((_DWORD *)v4 + 14);
        if (!v5 || (v6 ? (BOOL v7 = v6 >= v5) : (BOOL v7 = 1), !v7)) {
          unsigned int v5 = *((_DWORD *)v4 + 14);
        }
        unint64_t v4 = (uint64_t *)*v4;
      }
      while (v4);
    }
    else
    {
      unsigned int v5 = 0;
    }
    *(_DWORD *)(a1 + 148) = v5;
    *(_DWORD *)(a1 + 152) = v3 | 4;
  }
  uint64_t v8 = *(void *)(a1 + 128);
  if (v8)
  {
    unsigned int v9 = *(_DWORD *)(v8 + 56);
    if (!v5 || (v9 ? (BOOL v10 = v9 >= v5) : (BOOL v10 = 1), !v10)) {
      unsigned int v5 = v9;
    }
  }
  uint64_t v11 = *(void *)(a1 + 56);
  if (v11)
  {
    unsigned int v12 = v5 - 1;
    do
    {
      unsigned int v13 = *(_DWORD *)(v11 + 24);
      if (v12 < v13 || v13 > *(_DWORD *)(a1 + 4)) {
        break;
      }
      v2 += (*(_DWORD *)(v11 + 48) + *(_DWORD *)(v11 + 52) + 32);
      if (v2 >= a2) {
        return 1;
      }
      uint64_t v11 = *(void *)(v11 + 16);
    }
    while (v11);
  }
  return 0;
}

void HTTP3Connection::writeDecoderStream(uint64_t a1, void *a2)
{
  int v3 = a2;
  uint64_t v4 = *(void *)(a1 + 1008);
  if (v4 && (*(unsigned char *)(a1 + 920) & 4) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 1056);
    if (!v5)
    {
      uint64_t v6 = HTTP3Connection::_newClientUnidirectionalStreamHandle((HTTP3Connection *)"outbound decoder", 0);
      BOOL v7 = *(void **)(a1 + 1056);
      *(void *)(a1 + 1056) = v6;

      char buffer = 3;
      uint64_t v8 = dispatch_data_create(&buffer, 1uLL, 0, 0);
      dispatch_data_t concat = dispatch_data_create_concat(v8, v3);

      uint64_t v4 = *(void *)(a1 + 1008);
      uint64_t v5 = *(void *)(a1 + 1056);
      int v3 = concat;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, NSObject *, void *))(*(void *)v4 + 64))(v4, v5, 1, v3, &__block_literal_global_22_6083);
  }
}

void sub_1841528E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t enc_free_hinfo(uint64_t result, unint64_t a2)
{
  unint64_t v2 = (void *)(result + 80);
  do
  {
    unint64_t v2 = (void *)*v2;
    if (!v2) {
      __assert_rtn("enc_free_hinfo", "lsqpack.c", 347, "0");
    }
    int v3 = v2 + 2;
  }
  while ((unint64_t)(v2 + 2) > a2 || (unint64_t)(v2 + 514) <= a2);
  v2[1] &= ~(1 << ((a2 - (unint64_t)v3) >> 6));
  uint64_t v5 = &v2[8 * (unint64_t)((a2 - (unint64_t)v3) >> 6)];
  uint64_t v6 = v5[2];
  BOOL v7 = (void *)v5[3];
  uint64_t v8 = v5 + 2;
  if (v6)
  {
    *(void *)(v6 + 8) = v7;
    BOOL v7 = (void *)v8[1];
  }
  else
  {
    *(void *)(result + 104) = v7;
  }
  *BOOL v7 = v6;
  return result;
}

void destroy_header_block_read_ctx(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  int v3 = (void *)a2[1];
  if (*a2)
  {
    *(void *)(v2 + 8) = v3;
    int v3 = (void *)a2[1];
  }
  else
  {
    *(void *)(a1 + 88) = v3;
  }
  *int v3 = v2;
  if ((a2[13] & 4) != 0)
  {
    uint64_t v4 = a2[2];
    if (v4) {
      *(void *)(v4 + 24) = a2[3];
    }
    else {
      *(void *)(a1 + 16 * (a2[8] & 7) + 104) = a2[3];
    }
    *(void *)a2[3] = v4;
    --*(_DWORD *)(a1 + 224);
  }
  free(a2);
}

char *CFHTTPCookieStorageCreateFromIdentifyingData(CFAllocatorRef allocator, CFDataRef data)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    uint64_t v4 = [NSHTTPCookieStorageToCookie2Storage alloc];
    return (char *)-[NSHTTPCookieStorageToCookie2Storage initWithIdentifyingData:](v4, data);
  }
  else
  {
    CFArrayRef v6 = (const __CFArray *)CFPropertyListCreateWithData(allocator, data, 0, 0, 0);
    if (!v6) {
      return 0;
    }
    CFArrayRef v7 = v6;
    CFTypeID v8 = CFGetTypeID(v6);
    if (v8 == CFArrayGetTypeID()) {
      BOOL v10 = _CFHTTPCookieStorageCreateFromArchive(allocator, v7, v9);
    }
    else {
      BOOL v10 = 0;
    }
    CFRelease(v7);
    return v10;
  }
}

char *HTTPCookieStorage::createFromArchive(HTTPCookieStorage *this, const __CFAllocator *a2, const __CFArray *a3, audit_token_t *a4)
{
  CFIndex Count = CFArrayGetCount(a2);
  if (Count <= 1 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)valuePtr = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "not a valid archive", valuePtr, 2u);
  }
  CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a2, 0);
  *(_DWORD *)valuePtr = 0;
  if (!CFNumberGetValue(ValueAtIndex, kCFNumberIntType, valuePtr) || (CFTypeID v8 = 0, !*(_DWORD *)valuePtr))
  {
    CFNumberRef v9 = (const __CFNumber *)CFArrayGetValueAtIndex(a2, 1);
    CFAllocatorRef v10 = (const __CFAllocator *)CFArrayGetValueAtIndex(a2, 2);
    if (CFArrayGetCount(v10) < 1) {
      unsigned int v13 = 0;
    }
    else {
      unsigned int v13 = (const void *)HTTPCookieStorage::createFromArchive(this, v10, v11, v12);
    }
    CFStringRef v14 = (const __CFString *)CFArrayGetValueAtIndex(a2, 3);
    int ExactString = _findExactString(v14, 4u);
    if (ExactString != 281080418)
    {
      if (ExactString == 282112614)
      {
        CFNumberRef v50 = v9;
        int v51 = v13;
        uint64x2_t v16 = CFAllocatorAllocate(this, 88, 0);
        *uint64x2_t v16 = 0u;
        v16[1] = 0u;
        v16[2] = 0u;
        v16[3] = 0u;
        v16[4] = 0u;
        *((void *)v16 + 10) = 0;
        MemoryCookieStorage::MemoryCookieStorage((MemoryCookieStorage *)v16, 1);
        HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)valuePtr, 0, 0, 0, 0, 0, 0, 1);
        CFNumberRef v17 = (const __CFNumber *)CFArrayGetValueAtIndex(a2, 4);
        *(_DWORD *)buf = 0;
        if (CFNumberGetValue(v17, kCFNumberIntType, buf) && *(int *)buf >= 1)
        {
          uint64_t v18 = *(int *)buf + 4;
          CFIndex v19 = 5;
          do
          {
            if (v19 >= Count && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "oob", buf, 2u);
            }
            CFAllocatorRef v20 = (const __CFAllocator *)CFArrayGetValueAtIndex(a2, v19);
            CompactCookieArray = CompactCookieArray::makeCompactCookieArray((CompactCookieArray *)this, v20, v21);
            unsigned int v23 = CompactCookieArray;
            if (CompactCookieArray)
            {
              CFDataRef v24 = (const __CFData *)*((void *)CompactCookieArray + 2);
              if (v24)
              {
                BytePtr = CFDataGetBytePtr(v24);
                if (BytePtr)
                {
                  uint64_t v26 = *((unsigned int *)BytePtr + 1);
                  if (v26)
                  {
                    uint64_t v27 = 0;
                    uint64_t v28 = 4 * v26;
                    do
                    {
                      CFDataRef v29 = (const __CFData *)*((void *)v23 + 2);
                      if (v29 && CFDataGetBytePtr(v29))
                      {
                        unsigned int v30 = CFDataGetBytePtr(*((CFDataRef *)v23 + 2));
                        unint64_t v31 = (const UInt8 *)*((void *)v23 + 2);
                        uint64_t v32 = *(unsigned int *)&v30[v27 + 8];
                        if (v31) {
                          unint64_t v31 = CFDataGetBytePtr((CFDataRef)v31);
                        }
                        int v33 = &v31[v32];
                      }
                      else
                      {
                        int v33 = 0;
                      }
                      (*(void (**)(_OWORD *, const UInt8 *, uint8_t *))(*(void *)v16 + 120))(v16, v33, valuePtr);
                      v27 += 4;
                    }
                    while (v28 != v27);
                  }
                }
              }
              CFRelease((char *)v23 - 16);
            }
          }
          while (v19++ != v18);
        }
        HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)valuePtr);
        if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
          dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
        }
        uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
        uint64_t v46 = Instance;
        unsigned int v13 = v51;
        if (Instance)
        {
          Instance[1] = 0u;
          uint64_t v46 = Instance + 1;
          Instance[7] = 0u;
          Instance[8] = 0u;
          Instance[5] = 0u;
          Instance[6] = 0u;
          Instance[3] = 0u;
          Instance[4] = 0u;
          Instance[2] = 0u;
        }
        *(void *)uint64_t v46 = &unk_1ECF9E5A0;
        *((void *)v46 + 1) = &unk_1ECF9E5E8;
        *((_DWORD *)v46 + 30) = 0;
        *(_DWORD *)valuePtr = 0;
        CFNumberGetValue(v50, kCFNumberIntType, valuePtr);
        HTTPCookieStorage::initialize((HTTPCookieStorage *)v46, (PrivateHTTPCookieStorage *)v16);
        CFTypeID v8 = (char *)(v46 - 1);
        if (v16) {
          (*(void (**)(_OWORD *))(*(void *)v16 + 48))(v16);
        }
      }
      else
      {
        CFTypeID v8 = 0;
      }
LABEL_56:
      if (v13) {
        CFRelease(v13);
      }
      return v8;
    }
    CFDictionaryRef v35 = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, 4);
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(this, 0, v35);
    CFDictionarySetValue(MutableCopy, @"policy", v9);
    if (v13) {
      CFDictionarySetValue(MutableCopy, @"base", v13);
    }
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v35, @"urlstring");
    if (!Value)
    {
      CFStringRef v47 = (const __CFString *)CFDictionaryGetValue(v35, @"url");
      if (!v47) {
        goto LABEL_53;
      }
      CFStringRef Value = v47;
      CFTypeID TypeID = CFStringGetTypeID();
      if (TypeID != CFGetTypeID(Value) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)valuePtr = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "archived thingy not a string as expected", valuePtr, 2u);
      }
    }
    CFURLRef v38 = CFURLCreateWithFileSystemPath(this, Value, kCFURLPOSIXPathStyle, 0);
    CFDictionarySetValue(MutableCopy, @"url", v38);
    CFRelease(v38);
    CFDataRef v39 = (const __CFData *)CFDictionaryGetValue(v35, @"sandbox_ext");
    if (v39)
    {
      CFDataRef v40 = v39;
      int64_t Length = CFDataGetLength(v39);
      if (Length > 0)
      {
        CFIndex v42 = Length;
        unint64_t v43 = (UInt8 *)malloc_type_malloc(Length, 0xCB89618AuLL);
        v54.location = 0;
        v54.CFIndex length = v42;
        CFDataGetBytes(v40, v54, v43);
        v43[v42 - 1] = 0;
        uint64_t v44 = sandbox_extension_consume();
        free(v43);
        CFTypeID v8 = _CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(this, MutableCopy, 1);
        if (v44 != -1)
        {
          if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
            dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
          }
          *((void *)v8 + 11) = v44;
        }
        goto LABEL_54;
      }
    }
LABEL_53:
    CFTypeID v8 = _CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(this, MutableCopy, 1);
LABEL_54:
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    goto LABEL_56;
  }
  return v8;
}

void sub_184153118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

char *_CFHTTPCookieStorageCreateFromArchive(const __CFAllocator *a1, CFArrayRef theArray, audit_token_t *a3)
{
  if (CFArrayGetCount(theArray) >= 3)
  {
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
    CFTypeID v6 = CFGetTypeID(ValueAtIndex);
    if (v6 == CFNumberGetTypeID())
    {
      return HTTPCookieStorage::createFromArchive(a1, theArray, v7, v8);
    }
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    CFIndex v11 = Count;
    CFIndex v12 = 0;
    unsigned int v13 = 0;
    while (1)
    {
      CFStringRef v14 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v12);
      CFTypeID v15 = CFGetTypeID(v14);
      if (v15 == CFStringGetTypeID())
      {
        if (v14 && (uint64x2_t v16 = (char *)CFEqual(v14, @"%ext%"), v16))
        {
          CFNumberRef v17 = (os_unfair_lock_s *)_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault;
          if (!_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault)
          {
            uint64x2_t v16 = StorageSession::copyProcessDefault((StorageSession *)v16);
            CFNumberRef v17 = (os_unfair_lock_s *)(v16 - 16);
            _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault = (uint64_t)(v16 - 16);
          }
          uint64_t v18 = _CFURLStorageSessionCopyCookieStorage((uint64_t)v16, v17);
          if (v18) {
            goto LABEL_25;
          }
        }
        else
        {
          CFURLRef v24 = CFURLCreateWithFileSystemPath(a1, v14, kCFURLPOSIXPathStyle, 0);
          if (v24)
          {
            CFURLRef v25 = v24;
            uint64_t v18 = CFHTTPCookieStorageCreateFromFile((char *)a1, v24, (uint64_t)v13);
            CFRelease(v25);
            if (v18) {
              goto LABEL_25;
            }
          }
        }
      }
      else
      {
        CFTypeID v19 = CFGetTypeID(v14);
        if (v19 == CFArrayGetTypeID())
        {
          CFDataRef v21 = _CookieStorageCreateInMemory(a1, v20);
          if (v21)
          {
            uint64_t v18 = v21;
            CFContainerEnumeratorBase::setup((unint64_t)&v26, v14, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
            uint64_t v29 = 0;
            if (v27 >= 1)
            {
              uint64_t v22 = 0;
              do
              {
                uint64_t v29 = v22 + 1;
                unsigned int v23 = [[NSHTTPCookie alloc] _initWithProperties:*(void *)(v28 + 8 * v22) fromString:0];
                if (v23)
                {
                  CFHTTPCookieStorageSetCookie(v18, v23);
                  CFRelease(v23);
                }
                uint64_t v22 = v29;
              }
              while (v29 < v27);
            }
            CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v26);
LABEL_25:
            if (v13) {
              CFRelease(v13);
            }
            goto LABEL_28;
          }
        }
      }
      uint64_t v18 = v13;
LABEL_28:
      ++v12;
      unsigned int v13 = v18;
      if (v12 == v11) {
        return (char *)v18;
      }
    }
  }
  return 0;
}

void sub_1841533AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__CFArray *CFHTTPCookieStorageCreateIdentifyingData(CFAllocatorRef allocator, char *self)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    if (self) {
      id Property = objc_getProperty(self, self, 40, 1);
    }
    else {
      id Property = 0;
    }
    uint64_t v5 = (void *)[Property identifyingData];
    return (__CFArray *)v5;
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    if (self) {
      CFArrayRef v7 = (HTTPCookieStorage *)(self + 16);
    }
    else {
      CFArrayRef v7 = 0;
    }
    uint64_t result = HTTPCookieStorage::createArchive(v7, allocator);
    if (result)
    {
      CFTypeID v8 = result;
      CFDataRef Data = CFPropertyListCreateData(allocator, result, kCFPropertyListBinaryFormat_v1_0, 0, 0);
      CFRelease(v8);
      return Data;
    }
  }
  return result;
}

CFTypeRef StorageSession::copyCookieStorage(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 12;
  os_unfair_lock_lock(this + 12);
  if (BYTE1(this[13]._os_unfair_lock_opaque)) {
    goto LABEL_30;
  }
  BYTE1(this[13]._os_unfair_lock_opaque) = 1;
  if (*(void *)&this[6]._os_unfair_lock_opaque || LOBYTE(this[14]._os_unfair_lock_opaque)) {
    goto LABEL_30;
  }
  CFDictionaryRef v3 = *(const __CFDictionary **)&this[20]._os_unfair_lock_opaque;
  if (!v3)
  {
    CFTypeRef v5 = 0;
LABEL_11:
    CFArrayRef v7 = *(const void **)&this[18]._os_unfair_lock_opaque;
    if (v7) {
      CFTypeID v8 = CFRetain(v7);
    }
    else {
      CFTypeID v8 = 0;
    }
    CFNumberRef v9 = (uint64_t *)MEMORY[0x1E4F1CFD0];
    goto LABEL_15;
  }
  CFStringRef Value = CFDictionaryGetValue(v3, @"kCFURLStorageSessionAppIdentifier");
  if (Value) {
    CFTypeRef v5 = CFRetain(Value);
  }
  else {
    CFTypeRef v5 = 0;
  }
  CFDictionaryRef v6 = *(const __CFDictionary **)&this[20]._os_unfair_lock_opaque;
  if (!v6 || CFDictionaryGetValue(v6, @"kCFURLStorageSessionIsPrivate") != (const void *)*MEMORY[0x1E4F1CFD0]) {
    goto LABEL_11;
  }
  CFAllocatorRef v17 = CFGetAllocator(&this[-4]);
  CFTypeID v8 = CFStringCreateWithFormat(v17, 0, @"%@-%ld", *(void *)&this[18]._os_unfair_lock_opaque, *(void *)&this[16]._os_unfair_lock_opaque);
  CFNumberRef v9 = (uint64_t *)MEMORY[0x1E4F1CFC8];
LABEL_15:
  uint64_t v10 = *v9;
  CFAllocatorRef v11 = CFGetAllocator(&this[-4]);
  MutableDictionary = cfTypeCreateMutableDictionary(v11, @"ident", v8, @"persistent", v10, @"url", v5, 0, 0);
  if (v5) {
    CFRelease(v5);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    unsigned int v13 = +[NSHTTPCookieStorage sharedHTTPCookieStorage];
  }
  else
  {
    CFAllocatorRef v14 = CFGetAllocator(&this[-4]);
    CFDictionaryRef v15 = *(const __CFDictionary **)&this[20]._os_unfair_lock_opaque;
    int v16 = v15
       && CFDictionaryGetValue(v15, @"kCFURLStorageSessionProcessSharing") == (const void *)*MEMORY[0x1E4F1CFD0]
       || LOBYTE(this[14]._os_unfair_lock_opaque) != 0;
    unsigned int v13 = (NSHTTPCookieStorage *)_CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(v14, MutableDictionary, v16);
  }
  *(void *)&this[6]._os_unfair_lock_opaque = v13;
  CFRelease(MutableDictionary);
LABEL_30:
  os_unfair_lock_unlock(v2);
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled || !LOBYTE(this[14]._os_unfair_lock_opaque))
  {
    uint64_t v18 = *(const void **)&this[6]._os_unfair_lock_opaque;
    if (v18)
    {
      return CFRetain(v18);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return (CFTypeRef)CFHTTPCookieStorageCopySharedHTTPCookieStorage();
  }
}

__CFArray *HTTPCookieStorage::createArchive(HTTPCookieStorage *this, CFAllocatorRef allocator)
{
  Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
  AutoScalar::AutoScalar((AutoScalar *)&v19, 0);
  CFArrayAppendValue(Mutable, value);
  CFTypeID v19 = &unk_1ECF9A500;
  if (value) {
    CFRelease(value);
  }
  uint64_t v4 = (PrivateHTTPCookieStorage *)*((void *)this + 2);
  if (v4) {
    uint64_t CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v4);
  }
  else {
    uint64_t CookieAcceptPolicy = 2;
  }
  AutoScalar::AutoScalar((AutoScalar *)&v19, (const __CFAllocator *)CookieAcceptPolicy);
  CFArrayAppendValue(Mutable, value);
  CFTypeID v19 = &unk_1ECF9A500;
  CFDictionaryRef v6 = (AutoArray *)value;
  if (value) {
    CFRelease(value);
  }
  EmptyArray = (const void *)AutoArray::getEmptyArray(v6);
  CFArrayAppendValue(Mutable, EmptyArray);
  uint64_t v8 = *((void *)this + 2);
  uint64_t v9 = *(void *)(v8 + 32);
  if (v9) {
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  }
  uint64_t v10 = *(void *)(v8 + 56);
  if (v10)
  {
    uint64_t v11 = *(void *)(v8 + 48);
    int v12 = *(unsigned __int8 *)(v8 + 64);
    CFArrayAppendValue(Mutable, &unk_1EC0A1CB8);
    CFAllocatorRef v13 = CFGetAllocator(Mutable);
    CFAllocatorRef v14 = (uint64_t *)MEMORY[0x1E4F1CFD0];
    if (!v12) {
      CFAllocatorRef v14 = (uint64_t *)MEMORY[0x1E4F1CFC8];
    }
    uint64_t v15 = *v14;
    int v16 = @"kCFURLStorageSessionAppIdentifier";
    if (!v11) {
      int v16 = 0;
    }
    MutableDictionary = cfTypeCreateMutableDictionary(v13, @"ident", v10, @"persistent", v15, v16, v11, 0, 0, v19);
    CFArrayAppendValue(Mutable, MutableDictionary);
    if (MutableDictionary) {
      CFRelease(MutableDictionary);
    }
  }
  else
  {
    (*(void (**)(uint64_t, __CFArray *))(*(void *)v8 + 168))(v8, Mutable);
  }
  if (v9) {
    pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
  }
  return Mutable;
}

void sub_184153964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL33_CFHTTPCookieStorageCreateDefaultPK13__CFAllocator_block_invoke(uint64_t a1)
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_184085000, v2, OS_LOG_TYPE_DEFAULT, "Initializing CFHTTPCookieStorage singleton", buf, 2u);
  }
  if (_xpc_runtime_is_app_sandboxed()) {
    goto LABEL_21;
  }
  CFDictionaryRef v3 = (const char **)_CFGetProgname();
  if (v3 && (uint64_t v4 = *v3) != 0) {
    BOOL v5 = !strncmp(*v3, "com.apple.WebKit", 0x10uLL) || !strcmp(v4, "MobileSafari") || strcmp(v4, "DashboardClient") == 0;
  }
  else {
    BOOL v5 = 0;
  }
  MainBundle = CFBundleGetMainBundle();
  CFStringRef Identifier = CFBundleGetIdentifier(MainBundle);
  if (!v5)
  {
    CFStringRef v8 = Identifier;
    if (Identifier) {
      BOOL v5 = CFEqual(Identifier, @"com.apple.webapp")
    }
        || CFEqual(v8, @"com.apple.webapp1")
        || CFEqual(v8, @"com.apple.WebSheet")
        || CFEqual(v8, @"com.apple.NanoWebSheet");
  }
  if (v5)
  {
LABEL_21:
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v9 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFTypeID v19 = 0;
      _os_log_impl(&dword_184085000, v9, OS_LOG_TYPE_DEFAULT, "Creating default cookie storage with default identifier", v19, 2u);
    }
    uint64_t v10 = (void *)CFRetain(@"com.apple.CFNetwork.defaultStorageSession");
    goto LABEL_26;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFAllocatorRef v13 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v18 = 0;
    _os_log_impl(&dword_184085000, v13, OS_LOG_TYPE_DEFAULT, "Creating default cookie storage with process/bundle identifier", v18, 2u);
  }
  CFAllocatorRef v14 = CFBundleGetMainBundle();
  CFStringRef v15 = CFBundleGetIdentifier(v14);
  if (!v15 || (CFTypeRef v11 = CFRetain(v15)) == 0)
  {
    CFAllocatorRef v16 = *(const __CFAllocator **)(a1 + 32);
    CFAllocatorRef v17 = (const char **)_CFGetProgname();
    uint64_t v10 = (void *)CFStringCreateWithCString(v16, *v17, 0x8000100u);
LABEL_26:
    CFTypeRef v11 = v10;
  }
  MutableDictionary = cfTypeCreateMutableDictionary((const __CFAllocator *)*MEMORY[0x1E4F1CF80], @"ident", v11, @"persistent", *MEMORY[0x1E4F1CFD0], 0, 0);
  _CFHTTPCookieStorageCreateDefault(__CFAllocator const*)::cookieStorage = (uint64_t)_CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(*(const __CFAllocator **)(a1 + 32), MutableDictionary, 1);
  if (MutableDictionary) {
    CFRelease(MutableDictionary);
  }
  if (v11) {
    CFRelease(v11);
  }
}

char *_CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(const __CFAllocator *a1, CFDictionaryRef theDict, int a3)
{
  if (theDict)
  {
    CFDictionaryGetValue(theDict, @"base");
    CFURLRef Value = (const __CFURL *)CFDictionaryGetValue(theDict, @"url");
    if (Value)
    {
      CFURLRef v7 = Value;
      CFStringRef v8 = (__CFString *)CFDictionaryGetValue(theDict, @"type");
      uint64_t v9 = CFDictionaryGetValue(theDict, @"policy");
      CFURLRef v10 = CFURLCopyAbsoluteURL(v7);
      if (v8) {
        CFTypeRef v11 = v8;
      }
      else {
        CFTypeRef v11 = @"binary";
      }
      CFTypeRef v12 = v9;
      if (!v9)
      {
        AutoScalar::AutoScalar((AutoScalar *)&valuePtr, (const __CFAllocator *)2);
        CFTypeRef v12 = cf;
      }
      CFAllocatorRef v13 = CFDictionaryGetValue(theDict, @"base");
      MutableDictionary = cfTypeCreateMutableDictionary((const __CFAllocator *)*MEMORY[0x1E4F1CF80], @"url", v10, @"type", v11, @"policy", v12, @"base", v13, 0, 0);
      if (!v9)
      {
        valuePtr = &unk_1ECF9A500;
        if (cf) {
          CFRelease(cf);
        }
      }
      CFStringRef v15 = (char *)cacheOrCreate(MutableDictionary, (PrivateHTTPCookieStorage *(*)(const __CFDictionary *))_createByFile, a3);
      CFRelease(MutableDictionary);
      if (v10) {
        CFRelease(v10);
      }
    }
    else
    {
      CFAllocatorRef v17 = CFDictionaryGetValue(theDict, @"ident");
      if (v17)
      {
        CFTypeID v19 = v17;
        CFTypeRef v20 = (CFTypeRef)*MEMORY[0x1E4F1CF80];
        valuePtr = &unk_1ECFA5A28;
        if (v20) {
          CFTypeRef v20 = CFRetain(v20);
        }
        uint64_t v41 = 0;
        uint64_t v42 = 0;
        CFTypeRef cf = v20;
        MutableDict = AutoDict::getMutableDict((AutoDict *)&valuePtr);
        CFDictionarySetValue(MutableDict, @"ident", v19);
        uint64_t v22 = CFDictionaryGetValue(theDict, @"persistent");
        if (v22) {
          unsigned int v23 = v22;
        }
        else {
          unsigned int v23 = (const void *)*MEMORY[0x1E4F1CFD0];
        }
        CFURLRef v24 = AutoDict::getMutableDict((AutoDict *)&valuePtr);
        if (v23) {
          CFDictionarySetValue(v24, @"persistent", v23);
        }
        else {
          CFDictionaryRemoveValue(v24, @"persistent");
        }
        uint64_t v27 = CFDictionaryGetValue(theDict, @"policy");
        CFTypeRef v28 = v27;
        if (!v27)
        {
          AutoScalar::AutoScalar((AutoScalar *)&v37, (const __CFAllocator *)2);
          CFTypeRef v28 = v38;
        }
        uint64_t v29 = AutoDict::getMutableDict((AutoDict *)&valuePtr);
        if (v28) {
          CFDictionarySetValue(v29, @"policy", v28);
        }
        else {
          CFDictionaryRemoveValue(v29, @"policy");
        }
        if (!v27)
        {
          uint64x2_t v37 = &unk_1ECF9A500;
          if (v38) {
            CFRelease(v38);
          }
        }
        unsigned int v30 = CFDictionaryGetValue(theDict, @"kCFURLStorageSessionAppIdentifier");
        if (v30)
        {
          unint64_t v31 = AutoDict::getMutableDict((AutoDict *)&valuePtr);
          CFDictionarySetValue(v31, @"kCFURLStorageSessionAppIdentifier", v30);
        }
        uint64_t v32 = CFDictionaryGetValue(theDict, @"kCFHTTPCookieStorageGroupContainerURL");
        if (v32)
        {
          int v33 = AutoDict::getMutableDict((AutoDict *)&valuePtr);
          CFDictionarySetValue(v33, @"kCFHTTPCookieStorageGroupContainerURL", v32);
        }
        size_t v34 = CFDictionaryGetValue(theDict, @"base");
        if (v34)
        {
          CFDictionaryRef v35 = AutoDict::getMutableDict((AutoDict *)&valuePtr);
          CFDictionarySetValue(v35, @"base", v34);
        }
        CFDictionaryRef v36 = AutoDict::copyDictAndSetEmpty((AutoDict *)&valuePtr);
        CFStringRef v15 = (char *)cacheOrCreate(v36, (PrivateHTTPCookieStorage *(*)(const __CFDictionary *))_createByIdentifier, a3);
        CFRelease(v36);
        AutoDict::~AutoDict((AutoDict *)&valuePtr);
      }
      else
      {
        CFStringRef v15 = (char *)_CookieStorageCreateInMemory(a1, v18);
        if (v15)
        {
          CFNumberRef v25 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"policy");
          if (v25)
          {
            LODWORD(valuePtr) = 0;
            if (CFNumberGetValue(v25, kCFNumberIntType, &valuePtr)) {
              uint64_t v26 = valuePtr;
            }
            else {
              uint64_t v26 = 0;
            }
            CFHTTPCookieStorageSetCookieAcceptPolicy(v15, v26);
          }
        }
      }
    }
    return v15;
  }
  else
  {
    return (char *)_CookieStorageCreateInMemory(a1, 0);
  }
}

void sub_1841540D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf,uint64_t a21,CFTypeRef a22)
{
}

CFDictionaryRef HTTPCookie::copyProperties_CF(HTTPCookie *this)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (const void *)*MEMORY[0x1E4F1CF80];
  uint64_t v97 = &unk_1ECFA5A28;
  if (v2) {
    CFAllocatorRef v3 = (const __CFAllocator *)CFRetain(v2);
  }
  else {
    CFAllocatorRef v3 = 0;
  }
  uint64_t v99 = 0;
  uint64_t v100 = 0;
  uint64_t v97 = &unk_1ECF9F610;
  CFAllocatorRef alloc = v3;
  uint64_t v4 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v4 >= 0x18)
  {
    uint64_t v5 = v4[5];
    if (v5)
    {
      uint64_t v6 = *v4;
      if (v6 > v5)
      {
        CFURLRef v7 = (char *)v4 + v5;
        CFStringRef v8 = (char *)v4 + v6;
        uint64_t v9 = v7;
        while (*v9)
        {
          if (++v9 >= v8) {
            goto LABEL_15;
          }
        }
        long long v103 = off_1ECF9A530;
        CFStringRef v10 = CFStringCreateWithCString(alloc, v7, 0x8000100u);
        uint64_t v105 = 0;
        uint64_t v106 = 0;
        CFTypeRef cf = v10;
        MutableDict = AutoDict::getMutableDict((AutoDict *)&v97);
        if (v10) {
          CFDictionarySetValue(MutableDict, &unk_1EC0A1A50, v10);
        }
        else {
          CFDictionaryRemoveValue(MutableDict, &unk_1EC0A1A50);
        }
        AutoString::~AutoString((AutoString *)&v103);
      }
    }
  }
LABEL_15:
  CFTypeRef v12 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v12 >= 0x20)
  {
    uint64_t v13 = v12[7];
    if (v13)
    {
      uint64_t v14 = *v12;
      if (v14 > v13)
      {
        CFStringRef v15 = (char *)v12 + v13;
        CFAllocatorRef v16 = (char *)v12 + v14;
        CFAllocatorRef v17 = v15;
        while (*v17)
        {
          if (++v17 >= v16) {
            goto LABEL_26;
          }
        }
        long long v103 = off_1ECF9A530;
        CFStringRef v18 = CFStringCreateWithCString(alloc, v15, 0x8000100u);
        uint64_t v105 = 0;
        uint64_t v106 = 0;
        CFTypeRef cf = v18;
        CFTypeID v19 = AutoDict::getMutableDict((AutoDict *)&v97);
        if (v18) {
          CFDictionarySetValue(v19, &unk_1EC0A1C48, v18);
        }
        else {
          CFDictionaryRemoveValue(v19, &unk_1EC0A1C48);
        }
        AutoString::~AutoString((AutoString *)&v103);
      }
    }
  }
LABEL_26:
  CFTypeRef v20 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v20 >= 8u && v20[1])
  {
    CFDataRef v21 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
    if (*v21 >= 8u) {
      uint64_t v22 = v21[1];
    }
    else {
      uint64_t v22 = 0;
    }
    snprintf(__str, 0x19uLL, "%lu", v22);
    long long v103 = off_1ECF9A530;
    CFStringRef v23 = CFStringCreateWithCString(alloc, __str, 0x8000100u);
    uint64_t v105 = 0;
    uint64_t v106 = 0;
    CFTypeRef cf = v23;
    CFURLRef v24 = AutoDict::getMutableDict((AutoDict *)&v97);
    if (v23) {
      CFDictionarySetValue(v24, &unk_1EC0A1C80, v23);
    }
    else {
      CFDictionaryRemoveValue(v24, &unk_1EC0A1C80);
    }
    AutoString::~AutoString((AutoString *)&v103);
  }
  CFNumberRef v25 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v25 >= 0x14)
  {
    uint64_t v26 = v25[4];
    if (v26)
    {
      uint64_t v27 = *v25;
      if (v27 > v26)
      {
        CFTypeRef v28 = (char *)v25 + v26;
        uint64_t v29 = (char *)v25 + v27;
        unsigned int v30 = v28;
        while (*v30)
        {
          if (++v30 >= v29) {
            goto LABEL_46;
          }
        }
        long long v103 = off_1ECF9A530;
        CFStringRef v31 = CFStringCreateWithCString(alloc, v28, 0x8000100u);
        uint64_t v105 = 0;
        uint64_t v106 = 0;
        CFTypeRef cf = v31;
        uint64_t v32 = AutoDict::getMutableDict((AutoDict *)&v97);
        if (v31) {
          CFDictionarySetValue(v32, &unk_1EC0A1938, v31);
        }
        else {
          CFDictionaryRemoveValue(v32, &unk_1EC0A1938);
        }
        AutoString::~AutoString((AutoString *)&v103);
      }
    }
  }
LABEL_46:
  int v33 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v33 >= 0x1C)
  {
    uint64_t v34 = v33[6];
    if (v34)
    {
      uint64_t v35 = *v33;
      if (v35 > v34)
      {
        CFDictionaryRef v36 = (char *)v33 + v34;
        uint64x2_t v37 = (char *)v33 + v35;
        CFTypeRef v38 = v36;
        while (*v38)
        {
          if (++v38 >= v37) {
            goto LABEL_57;
          }
        }
        long long v103 = off_1ECF9A530;
        CFStringRef v39 = CFStringCreateWithCString(alloc, v36, 0x8000100u);
        uint64_t v105 = 0;
        uint64_t v106 = 0;
        CFTypeRef cf = v39;
        CFDataRef v40 = AutoDict::getMutableDict((AutoDict *)&v97);
        if (v39) {
          CFDictionarySetValue(v40, &unk_1EC0A1AF8, v39);
        }
        else {
          CFDictionaryRemoveValue(v40, &unk_1EC0A1AF8);
        }
        AutoString::~AutoString((AutoString *)&v103);
      }
    }
  }
LABEL_57:
  uint64_t v41 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v41 >= 0x24)
  {
    uint64_t v42 = v41[8];
    if (v42)
    {
      uint64_t v43 = *v41;
      if (v43 > v42)
      {
        uint64_t v44 = (char *)v41 + v42;
        unsigned int v45 = (char *)v41 + v43;
        uint64_t v46 = v44;
        while (*v46)
        {
          if (++v46 >= v45) {
            goto LABEL_68;
          }
        }
        long long v103 = off_1ECF9A530;
        CFStringRef v47 = CFStringCreateWithCString(alloc, v44, 0x8000100u);
        uint64_t v105 = 0;
        uint64_t v106 = 0;
        CFTypeRef cf = v47;
        unsigned int v48 = AutoDict::getMutableDict((AutoDict *)&v97);
        if (v47) {
          CFDictionarySetValue(v48, &unk_1EC0A1858, v47);
        }
        else {
          CFDictionaryRemoveValue(v48, &unk_1EC0A1858);
        }
        AutoString::~AutoString((AutoString *)&v103);
      }
    }
  }
LABEL_68:
  char v49 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v49 >= 0x28)
  {
    uint64_t v50 = v49[9];
    if (v50)
    {
      uint64_t v51 = *v49;
      if (v51 > v50)
      {
        uint64_t v52 = (char *)v49 + v50;
        uint64_t v53 = (char *)v49 + v51;
        CFRange v54 = v52;
        while (*v54)
        {
          if (++v54 >= v53) {
            goto LABEL_79;
          }
        }
        long long v103 = off_1ECF9A530;
        CFStringRef v55 = CFStringCreateWithCString(alloc, v52, 0x8000100u);
        uint64_t v105 = 0;
        uint64_t v106 = 0;
        CFTypeRef cf = v55;
        uint64_t v56 = AutoDict::getMutableDict((AutoDict *)&v97);
        if (v55) {
          CFDictionarySetValue(v56, &unk_1EC0A1890, v55);
        }
        else {
          CFDictionaryRemoveValue(v56, &unk_1EC0A1890);
        }
        AutoString::~AutoString((AutoString *)&v103);
      }
    }
  }
LABEL_79:
  unint64_t v57 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v57 >= 0xCu) {
    char v58 = v57[2] & 0x7F;
  }
  else {
    char v58 = 0;
  }
  if ((v58 & 0x10) != 0) {
    int v59 = 3;
  }
  else {
    int v59 = 1;
  }
  if ((v58 & 8) != 0) {
    int v60 = v59;
  }
  else {
    int v60 = ((v58 & 0x10) >> 3) ^ 2;
  }
  if (v60 == 1)
  {
    uint64_t v61 = AutoDict::getMutableDict((AutoDict *)&v97);
    uint64_t v62 = &_kCFHTTPCookieSameSiteLax;
  }
  else
  {
    if (v60 != 3) {
      goto LABEL_95;
    }
    uint64_t v61 = AutoDict::getMutableDict((AutoDict *)&v97);
    uint64_t v62 = &_kCFHTTPCookieSameSiteStrict;
  }
  if (*v62) {
    CFDictionarySetValue(v61, &unk_1EC0A1B68, (const void *)*v62);
  }
  else {
    CFDictionaryRemoveValue(v61, &unk_1EC0A1B68);
  }
LABEL_95:
  uint64_t v63 = (*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*(_DWORD *)v63 < 0xCu || (*(_DWORD *)(v63 + 8) & 2) == 0)
  {
    double v64 = 0.0;
    if (*(_DWORD *)v63 >= 0x30u)
    {
      long long v103 = *(void (***)(AutoString *__hidden))(v63 + 40);
      double v64 = floor(*(double *)&v103);
    }
    CFDateRef v65 = CFDateCreate(alloc, v64);
    uint64_t v66 = AutoDict::getMutableDict((AutoDict *)&v97);
    if (v65)
    {
      CFDictionarySetValue(v66, &unk_1EC0A1970, v65);
      CFRelease(v65);
    }
    else
    {
      CFDictionaryRemoveValue(v66, &unk_1EC0A1970);
    }
  }
  uint64_t v67 = (CompactCookieHeader *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  EnumeratedString = (const char *)CompactCookieHeader::getEnumeratedString(v67, 15, 0);
  if (EnumeratedString)
  {
    long long v103 = off_1ECF9A530;
    CFStringRef v69 = CFStringCreateWithCString(alloc, EnumeratedString, 0x8000100u);
    uint64_t v105 = 0;
    uint64_t v106 = 0;
    CFTypeRef cf = v69;
    BOOL v70 = AutoDict::getMutableDict((AutoDict *)&v97);
    if (v69) {
      CFDictionarySetValue(v70, &unk_1EC0A1C10, v69);
    }
    else {
      CFDictionaryRemoveValue(v70, &unk_1EC0A1C10);
    }
    AutoString::~AutoString((AutoString *)&v103);
  }
  uint64_t v71 = (*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*(_DWORD *)v71 >= 0x38u)
  {
    long long v103 = *(void (***)(AutoString *__hidden))(v71 + 48);
    double v72 = floor(*(double *)&v103);
    if (v72 != 0.0)
    {
      *(double *)__str = v72;
      long long v103 = (void (**)(AutoString *__hidden))&unk_1ECF9A500;
      CFNumberRef v73 = CFNumberCreate((CFAllocatorRef)v2, kCFNumberFloat64Type, __str);
      CFTypeRef cf = v73;
      uint64_t v74 = AutoDict::getMutableDict((AutoDict *)&v97);
      if (v73) {
        CFDictionarySetValue(v74, &unk_1EC0A18C8, v73);
      }
      else {
        CFDictionaryRemoveValue(v74, &unk_1EC0A18C8);
      }
      long long v103 = (void (**)(AutoString *__hidden))&unk_1ECF9A500;
      if (cf) {
        CFRelease(cf);
      }
    }
  }
  uint64_t v75 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v75 >= 0xCu && (v75[2] & 1) != 0)
  {
    uint64_t v76 = AutoDict::getMutableDict((AutoDict *)&v97);
    CFDictionarySetValue(v76, &unk_1EC0A1BA0, @"TRUE");
  }
  BOOL v77 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v77 >= 0xCu && (v77[2] & 4) != 0)
  {
    uint64_t v78 = AutoDict::getMutableDict((AutoDict *)&v97);
    CFDictionarySetValue(v78, &unk_1EC0A19E0, @"TRUE");
  }
  uint64_t v79 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v79 >= 0xCu && (v79[2] & 2) != 0)
  {
    int v80 = AutoDict::getMutableDict((AutoDict *)&v97);
    CFDictionarySetValue(v80, &unk_1EC0A1900, @"TRUE");
  }
  uint64_t v81 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v81 >= 0xCu && (v81[2] & 0x40) != 0)
  {
    int v82 = AutoDict::getMutableDict((AutoDict *)&v97);
    CFDictionarySetValue(v82, &unk_1EC0A1BD8, @"TRUE");
  }
  int v83 = (_DWORD *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
  if (*v83 >= 0x10u)
  {
    uint64_t v84 = v83[3];
    if (v84)
    {
      long long v103 = (void (**)(AutoString *__hidden))&unk_1ECFA5BB8;
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)v2, 0, MEMORY[0x1E4F1D510]);
      uint64_t v86 = 0;
      CFTypeRef cf = Mutable;
      uint64_t v87 = 2 * v84;
      do
      {
        unint64_t v88 = (unsigned int *)(*((uint64_t (**)(HTTPCookie *))this->var0 + 2))(this);
        uint64_t v89 = (v86 + 56);
        uint64_t v90 = *v88;
        if (v90 <= v89 || (char *)v88 + v89 + 2 > (char *)v88 + v90) {
          CFAllocatorRef v92 = 0;
        }
        else {
          CFAllocatorRef v92 = (const __CFAllocator *)*(unsigned __int16 *)((char *)v88 + v89);
        }
        AutoScalar::AutoScalar((AutoScalar *)__str, v92);
        if (value)
        {
          CFArrayAppendValue((CFMutableArrayRef)cf, value);
          *(void *)__str = &unk_1ECF9A500;
          if (value) {
            CFRelease(value);
          }
        }
        else
        {
          *(void *)__str = &unk_1ECF9A500;
        }
        v86 += 2;
      }
      while (v87 != v86);
      CFTypeRef v93 = cf;
      __int16 v94 = AutoDict::getMutableDict((AutoDict *)&v97);
      if (v93) {
        CFDictionarySetValue(v94, &unk_1EC0A1B30, v93);
      }
      else {
        CFDictionaryRemoveValue(v94, &unk_1EC0A1B30);
      }
      long long v103 = (void (**)(AutoString *__hidden))&unk_1ECFA5BB8;
      if (cf) {
        CFRelease(cf);
      }
    }
  }
  CFDictionaryRef v95 = AutoDict::copyDictAndSetEmpty((AutoDict *)&v97);
  AutoDict::~AutoDict((AutoDict *)&v97);
  return v95;
}

void sub_184154E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf)
{
}

CFMutableDictionaryRef AutoDict::getMutableDict(AutoDict *this)
{
  CFMutableDictionaryRef result = (CFMutableDictionaryRef)*((void *)this + 3);
  if (!result)
  {
    CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);
    CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 2);
    if (v4)
    {
      CFMutableDictionaryRef result = CFDictionaryCreateMutableCopy(v3, 0, v4);
      uint64_t v5 = (const void *)*((void *)this + 2);
      *((void *)this + 2) = 0;
      *((void *)this + 3) = result;
      if (v5)
      {
        CFRelease(v5);
        return (CFMutableDictionaryRef)*((void *)this + 3);
      }
    }
    else
    {
      CFMutableDictionaryRef result = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      *((void *)this + 3) = result;
    }
  }
  return result;
}

void AutoString::~AutoString(AutoString *this)
{
  *(void *)this = off_1ECF9A530;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (void *)*((void *)this + 2);
  if (v3)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*((void *)this + 3);
    if (v4)
    {
      CFAllocatorDeallocate(v4, v3);
      uint64_t v5 = (const void *)*((void *)this + 3);
      *((void *)this + 2) = 0;
      *((void *)this + 3) = 0;
      if (v5) {
        CFRelease(v5);
      }
    }
  }
}

{
  uint64_t vars8;

  AutoString::~AutoString(this);

  JUMPOUT(0x18531B6D0);
}

void AutoDict::~AutoDict(AutoDict *this)
{
  *(void *)this = &unk_1ECFA5A28;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  CFAllocatorRef v4 = (const void *)*((void *)this + 3);
  if (v4) {
    CFRelease(v4);
  }
}

{
  uint64_t vars8;

  AutoDict::~AutoDict(this);

  JUMPOUT(0x18531B6D0);
}

CFDictionaryRef AutoDict::copyDictAndSetEmpty(AutoDict *this)
{
  CFDictionaryRef Copy = (CFDictionaryRef)*((void *)this + 3);
  if (Copy) {
    goto LABEL_2;
  }
  CFDictionaryRef v5 = (const __CFDictionary *)*((void *)this + 2);
  if (v5)
  {
    CFAllocatorRef v6 = CFGetAllocator(*((CFTypeRef *)this + 2));
    CFDictionaryRef Copy = CFDictionaryCreateCopy(v6, v5);
    CFURLRef v7 = (const void *)*((void *)this + 2);
    *((void *)this + 2) = 0;
    if (v7) {
      CFRelease(v7);
    }
    if (Copy)
    {
LABEL_2:
      CFAllocatorRef v3 = CFGetAllocator(Copy);
      *((void *)this + 3) = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      return Copy;
    }
  }
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((void *)this + 3) = Mutable;
  EmptyDict = (const void *)AutoDict::getEmptyDict(Mutable);
  if (!EmptyDict) {
    return 0;
  }

  return (CFDictionaryRef)CFRetain(EmptyDict);
}

const UInt8 *CompactCookieHeader::getEnumeratedString(CompactCookieHeader *a1, int a2, unsigned __int8 *a3)
{
  BytePtr = 0;
  switch(a2)
  {
    case 0:
      if (*(_DWORD *)a1 < 0x24u) {
        return 0;
      }
      uint64_t v10 = *((unsigned int *)a1 + 8);
      if (!v10) {
        return 0;
      }
      uint64_t v11 = *(_DWORD *)a1;
      if (v11 <= v10) {
        goto LABEL_47;
      }
      BytePtr = (const UInt8 *)a1 + v10;
      CFTypeRef v12 = (const UInt8 *)a1 + v11;
      uint64_t v13 = BytePtr;
      while (*v13)
      {
        if (++v13 >= v12) {
          goto LABEL_47;
        }
      }
      return BytePtr;
    case 1:
      if (*(_DWORD *)a1 < 0x28u) {
        return 0;
      }
      uint64_t v14 = *((unsigned int *)a1 + 9);
      if (!v14) {
        return 0;
      }
      uint64_t v15 = *(_DWORD *)a1;
      if (v15 <= v14) {
        goto LABEL_47;
      }
      BytePtr = (const UInt8 *)a1 + v14;
      CFAllocatorRef v16 = (const UInt8 *)a1 + v15;
      CFAllocatorRef v17 = BytePtr;
      while (*v17)
      {
        if (++v17 >= v16) {
          goto LABEL_47;
        }
      }
      return BytePtr;
    case 4:
      if (*(_DWORD *)a1 < 0x14u) {
        return 0;
      }
      uint64_t v18 = *((unsigned int *)a1 + 4);
      if (!v18) {
        return 0;
      }
      uint64_t v19 = *(_DWORD *)a1;
      if (v19 <= v18) {
        goto LABEL_47;
      }
      BytePtr = (const UInt8 *)a1 + v18;
      CFTypeRef v20 = (const UInt8 *)a1 + v19;
      CFDataRef v21 = BytePtr;
      while (*v21)
      {
        if (++v21 >= v20) {
          goto LABEL_47;
        }
      }
      return BytePtr;
    case 8:
      if (*(_DWORD *)a1 < 0x18u) {
        return 0;
      }
      uint64_t v22 = *((unsigned int *)a1 + 5);
      if (!v22) {
        return 0;
      }
      uint64_t v23 = *(_DWORD *)a1;
      if (v23 <= v22) {
        goto LABEL_47;
      }
      BytePtr = (const UInt8 *)a1 + v22;
      CFURLRef v24 = (const UInt8 *)a1 + v23;
      CFNumberRef v25 = BytePtr;
      while (*v25)
      {
        if (++v25 >= v24) {
          goto LABEL_47;
        }
      }
      return BytePtr;
    case 10:
      if (*(_DWORD *)a1 < 0x1Cu) {
        return 0;
      }
      uint64_t v26 = *((unsigned int *)a1 + 6);
      if (!v26) {
        return 0;
      }
      uint64_t v27 = *(_DWORD *)a1;
      if (v27 <= v26) {
        goto LABEL_47;
      }
      BytePtr = (const UInt8 *)a1 + v26;
      CFTypeRef v28 = (const UInt8 *)a1 + v27;
      uint64_t v29 = BytePtr;
      while (*v29)
      {
        if (++v29 >= v28) {
          goto LABEL_47;
        }
      }
      return BytePtr;
    case 13:
      if (*(_DWORD *)a1 < 0x20u) {
        return 0;
      }
      uint64_t v30 = *((unsigned int *)a1 + 7);
      if (!v30) {
        return 0;
      }
      uint64_t v31 = *(_DWORD *)a1;
      if (v31 <= v30)
      {
LABEL_47:
        if (!a3) {
          return 0;
        }
        BytePtr = 0;
        *a3 = 1;
      }
      else
      {
        BytePtr = (const UInt8 *)a1 + v30;
        uint64_t v32 = (const UInt8 *)a1 + v31;
        int v33 = BytePtr;
        while (*v33)
        {
          if (++v33 >= v32) {
            goto LABEL_47;
          }
        }
      }
      return BytePtr;
    case 15:
    case 19:
      CFDictionaryRef v5 = (const __CFDictionary *)CompactCookieHeader::copyExtraInfo(a1, a3);
      if (!v5) {
        return 0;
      }
      CFDictionaryRef v6 = v5;
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v5, &gConstantCFStringValueTable[7* ((CookieData::sCookieFieldInfo[5 * a2 + 1] >> 20) & 0x3FF)]);
      if (!Value) {
        goto LABEL_53;
      }
      CFStringRef v8 = Value;
      CStringPtr = CFStringGetCStringPtr(Value, 0x8000100u);
      if (CStringPtr)
      {
        BytePtr = (const UInt8 *)CStringPtr;
        CFRetain(v8);
        CFAutorelease(v8);
      }
      else
      {
        uint64_t Length = CFStringGetLength(v8);
        if (Length < 1)
        {
LABEL_53:
          BytePtr = 0;
        }
        else
        {
          CFIndex v36 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
          CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v36);
          MutableBytePtr = (char *)CFDataGetMutableBytePtr(Mutable);
          CFStringGetCString(v8, MutableBytePtr, v36, 0x8000100u);
          CFAutorelease(Mutable);
          BytePtr = CFDataGetBytePtr(Mutable);
        }
      }
      CFRelease(v6);
      return BytePtr;
    default:
      return BytePtr;
  }
}

CFPropertyListRef CompactCookieHeader::copyExtraInfo(CompactCookieHeader *this, unsigned __int8 *a2)
{
  if (*(_DWORD *)this < 0xCu) {
    return 0;
  }
  unint64_t v2 = *((unsigned int *)this + 2);
  if (v2 < 0x100) {
    return 0;
  }
  CFAllocatorRef v3 = (const UInt8 *)this + *(_DWORD *)this - (v2 >> 8);
  if (v3 < (const UInt8 *)this || __CFADD__(v2 >> 8, v3))
  {
    if (a2)
    {
      CFPropertyListRef v4 = 0;
      *a2 = 1;
      return v4;
    }
    return 0;
  }
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDataRef v7 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3, v2 >> 8, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  CFPropertyListRef v4 = CFPropertyListCreateWithData(v6, v7, 0, 0, 0);
  if (v7) {
    CFRelease(v7);
  }
  return v4;
}

void AutoScalar::AutoScalar(AutoScalar *this, const __CFAllocator *a2)
{
  int valuePtr = (int)a2;
  *(void *)this = &unk_1ECF9A500;
  if ((a2 - 16) > 0xFFFFFFEC)
  {
    int v7 = (int)a2;
    uint64_t v4 = (a2 + 3);
    CFNumberRef v5 = (CFNumberRef)copyInternedInt(int)::sInterned[v4];
    if (!v5)
    {
      CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v7);
      copyInternedInt(int)::sInterned[v4] = v5;
    }
    CFAllocatorRef v3 = (void *)CFRetain(v5);
  }
  else
  {
    CFAllocatorRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  }
  *((void *)this + 1) = v3;
}

_OWORD *cacheOrCreate(CFDictionaryRef theDict, PrivateHTTPCookieStorage *(*a2)(const __CFDictionary *), int a3)
{
  MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theDict);
  CFDictionaryRemoveValue(MutableCopy, @"policy");
  pthread_mutex_lock(&sLock);
  if (!sStorageDict) {
    operator new();
  }
  CFStringRef Value = (unsigned __int8 *)CFDictionaryGetValue(*(CFDictionaryRef *)(sStorageDict + 8), MutableCopy);
  if (Value)
  {
    CFStringRef v8 = Value;
    uint64_t v9 = *((void *)Value + 4);
    if (v9)
    {
      uint64_t v10 = (pthread_mutex_t *)(v9 + 8);
      pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
      int v11 = v8[40];
      pthread_mutex_unlock(v10);
      if (v11)
      {
LABEL_5:
        (*(void (**)(unsigned __int8 *))(*(void *)v8 + 40))(v8);
        goto LABEL_12;
      }
    }
    else if (Value[40])
    {
      goto LABEL_5;
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(sStorageDict + 8), MutableCopy);
  }
  CFTypeRef v12 = a2(theDict);
  CFStringRef v8 = (unsigned __int8 *)v12;
  if (a3 && v12) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(sStorageDict + 8), MutableCopy, v12);
  }
LABEL_12:
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  pthread_mutex_unlock(&sLock);
  if (!v8) {
    return 0;
  }
  CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"policy");
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v15 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v15 = Instance + 1;
    Instance[7] = 0u;
    Instance[8] = 0u;
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
  }
  *(void *)uint64_t v15 = &unk_1ECF9E5A0;
  *((void *)v15 + 1) = &unk_1ECF9E5E8;
  *((_DWORD *)v15 + 30) = 0;
  if (v13)
  {
    int valuePtr = 0;
    CFNumberGetValue(v13, kCFNumberIntType, &valuePtr);
  }
  HTTPCookieStorage::initialize((HTTPCookieStorage *)v15, (PrivateHTTPCookieStorage *)v8);
  (*(void (**)(unsigned __int8 *))(*(void *)v8 + 48))(v8);
  return v15 - 1;
}

void sub_1841558A4(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

_OWORD *_createByIdentifier(const __CFDictionary *a1)
{
  CFStringRef Value = (__CFString *)CFDictionaryGetValue(a1, @"ident");
  CFAllocatorRef v3 = CFDictionaryGetValue(a1, @"persistent");
  uint64_t v4 = (const void *)*MEMORY[0x1E4F1CFC8];
  CFDictionaryGetValue(a1, @"kCFURLStorageSessionAppIdentifier");
  CFStringRef v5 = (const __CFString *)CFDictionaryGetValue(a1, @"kCFHTTPCookieStorageGroupContainerURL");
  if (v3 != v4)
  {
    CFURLRef v8 = copyParameterizedCookieStorageLocation(v5, Value, v6, v7);
    uint64_t v9 = CFDictionaryGetValue(a1, @"policy");
    CFTypeRef v10 = v9;
    if (!v9)
    {
      AutoScalar::AutoScalar((AutoScalar *)&v15, (const __CFAllocator *)2);
      CFTypeRef v10 = v16;
    }
    int v11 = CFDictionaryGetValue(a1, @"base");
    MutableDictionary = cfTypeCreateMutableDictionary((const __CFAllocator *)*MEMORY[0x1E4F1CF80], @"url", v8, @"safeparent", *MEMORY[0x1E4F1CFD0], @"type", @"binary", @"policy", v10, @"base", v11, 0, 0);
    if (!v9)
    {
      uint64_t v15 = &unk_1ECF9A500;
      if (v16) {
        CFRelease(v16);
      }
    }
    _createByFile(MutableDictionary);
  }
  CFNumberRef v13 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 88, 0);
  *CFNumberRef v13 = 0u;
  v13[1] = 0u;
  _DWORD v13[2] = 0u;
  v13[3] = 0u;
  v13[4] = 0u;
  *((void *)v13 + 10) = 0;
  MemoryCookieStorage::MemoryCookieStorage((MemoryCookieStorage *)v13, 1);
  return v13;
}

void sub_184155A90(_Unwind_Exception *exception_object)
{
  if (!v1)
  {
    *(void *)(v2 - 64) = &unk_1ECF9A500;
    uint64_t v4 = *(const void **)(v2 - 56);
    if (v4) {
      CFRelease(v4);
    }
  }
  _Unwind_Resume(exception_object);
}

__CFDictionary *cfTypeCreateMutableDictionary(const __CFAllocator *a1, ...)
{
  va_start(va, a1);
  va_copy(v10, va);
  va_copy((va_list)v11, va);
  unint64_t v1 = -1;
  do
  {
    uint64_t v2 = va_arg(v10, void);
    ++v1;
  }
  while (v2);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v1 >= 2)
  {
    unint64_t v4 = v1 >> 1;
    while (1)
    {
      CFStringRef v5 = v11;
      CFStringRef v6 = *v11;
      v11 += 2;
      CFStringRef v7 = v5[1];
      if (!v6 || v7 == 0) {
        break;
      }
      CFDictionarySetValue(Mutable, v6, v7);
      if (!--v4) {
        return Mutable;
      }
    }
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

CFURLRef copyParameterizedCookieStorageLocation(const __CFString *a1, __CFString *theString1, const __CFString *a3, const __CFString *a4)
{
  CFStringRef v5 = @"Cookies";
  if (theString1 && CFStringCompare(theString1, @"com.apple.CFNetwork.defaultStorageSession", 0)) {
    CFStringRef v5 = theString1;
  }
  if (a1)
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFURLRef v8 = (const void *)MEMORY[0x18531A7C0](*MEMORY[0x1E4F1CF80], @"Library/Cookies/", 0, 1, a1);
    CFStringRef v5 = @"Cookies";
  }
  else
  {
    uint64_t v9 = (const void *)CFCopyHomeDirectoryURLForUser();
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFURLRef v8 = (const void *)MEMORY[0x18531A7C0](*MEMORY[0x1E4F1CF80], @"Library/Cookies/", 0, 1, v9);
    if (v9) {
      CFRelease(v9);
    }
  }
  CFStringRef v10 = CFStringCreateWithFormat(v7, 0, @"%@.%@", v5, @"binarycookies");
  CFStringRef v11 = CFURLCreateStringByAddingPercentEscapes(0, v10, 0, @"/", 0x8000100u);
  CFURLRef v12 = (const __CFURL *)MEMORY[0x18531A7C0](v7, v11, 0, 0, v8);
  if (v8) {
    CFRelease(v8);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v11) {
    CFRelease(v11);
  }
  CFURLRef v13 = CFURLCopyAbsoluteURL(v12);
  if (v12) {
    CFRelease(v12);
  }
  return v13;
}

void DiskCookieStorage::addToArchiveInternalLocked(DiskCookieStorage *this, CFMutableArrayRef theArray)
{
  CFArrayAppendValue(theArray, &unk_1EC0A1CB8);
  unint64_t v4 = (const UInt8 *)*((void *)this + 9);
  CFAllocatorRef v5 = CFGetAllocator(theArray);
  size_t v6 = strlen((const char *)++v4);
  CFURLRef v7 = CFURLCreateFromFileSystemRepresentation(v5, v4, v6, 0);
  CFStringRef v8 = CFURLCopyFileSystemPath(v7, kCFURLPOSIXPathStyle);
  CFRelease(v7);
  CFAllocatorRef v9 = CFGetAllocator(theArray);
  MutableDictionary = cfTypeCreateMutableDictionary(v9, @"urlstring", v8, 0, 0);
  CFRelease(v8);
  CFArrayAppendValue(theArray, MutableDictionary);
  if (MutableDictionary)
  {
    CFRelease(MutableDictionary);
  }
}

void ActualCredentialStorage::~ActualCredentialStorage(ActualCredentialStorage *this)
{
  *(void *)this = &unk_1ECFA2708;
  *((void *)this + 1) = &unk_1ECFA27A8;
  *((void *)this + 2) = &unk_1ECFA2810;
  *((void *)this + 3) = &unk_1ECFA2830;
  uint64_t v2 = *((void *)this + 13);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 14);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *(void *)this = &unk_1ECFA1A88;
  *((void *)this + 1) = &unk_1ECFA1AD8;
  *((void *)this + 2) = &unk_1ECFA1B40;
  *((void *)this + 3) = &unk_1ECFA1B60;
  unint64_t v4 = (const void *)*((void *)this + 12);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 3) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  *((void *)this + 2) = &unk_1ECF9B550;
}

void sub_184155FB8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 24) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 32));
  *(void *)(v1 + 16) = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void MemoryCredentialStorage::~MemoryCredentialStorage(MemoryCredentialStorage *this)
{
  MemoryCredentialStorage::~MemoryCredentialStorage(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  *(void *)this = &unk_1ECFA2A88;
  *((void *)this + 2) = &unk_1ECFA2AE0;
  *((void *)this + 3) = &unk_1ECFA2B48;
  *((void *)this + 6) = &unk_1ECFA0270;
  CFRelease(*((CFTypeRef *)this + 7));
  *((void *)this + 4) = &unk_1ECFA0250;
  CFRelease(*((CFTypeRef *)this + 5));
  *((void *)this + 3) = &unk_1ECF9B550;
}

void __destroy_helper_block_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t ___ZL35isIMRemoteURLConnectionAgentProcessv_block_invoke()
{
  uint64_t v0 = (const char **)_CFGetProgname();
  uint64_t result = strcmp(*v0, "IMRemoteURLConnectionAgent");
  isIMRemoteURLConnectionAgentProcess(void)::isIMRemoteURLConnectionAgent = result == 0;
  return result;
}

void ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_3(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 76))
  {
    uint64_t v3 = *(void *)(a1 + 56);
    if ((*(_WORD *)(v3 + 248) & 0x60) != 0 || (*(_DWORD *)(v3 + 136) - 5) <= 2)
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
      *(void *)(v4 + 48) = 1;
      *(_DWORD *)(v4 + 56) = 89;
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      (*(void (**)(void, void, uint64_t *, uint64_t *, void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), 0, &v30, &v28, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48), *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 56));
      if (v29) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v29);
      }
      uint64_t v2 = v31;
      if (v31) {
        goto LABEL_5;
      }
      return;
    }
    uint64_t v5 = *(void *)(a1 + 48);
    v19[0] = MEMORY[0x1E4F143A8];
    v19[1] = 3321888768;
    CFTypeRef v20 = ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_4;
    CFDataRef v21 = &unk_1ECFAA2C8;
    uint64_t v24 = v5;
    uint64_t v25 = v3;
    size_t v6 = *(std::__shared_weak_count **)(a1 + 64);
    uint64_t v26 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v22 = *(void *)(a1 + 32);
    uint64_t v23 = v7;
    int v8 = *(_DWORD *)(a1 + 72);
    int v27 = v8;
    switch(v8)
    {
      case 0:
        NWIOConnection::_tlsProcessTrust_PolicyDefault(*(void *)(a1 + 56), (uint64_t)v19);
        goto LABEL_30;
      case 2:
        uint64_t v10 = *(void *)(a1 + 56);
        CFStringRef v11 = *(std::__shared_weak_count **)(v5 + 472);
        v18[0] = *(void *)(v5 + 464);
        v18[1] = (uint64_t)v11;
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        NWIOConnection::_tlsProcessTrust_PolicyStrict(v10, v18, (uint64_t)v19);
        break;
      case 1:
        uint64_t v9 = *(void *)(a1 + 56);
        if (TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce != -1)
        {
          uint64_t v13 = *(void *)(a1 + 56);
          dispatch_once(&TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce, &__block_literal_global_1892);
          uint64_t v9 = v13;
        }
        TrustExceptionManager::storeTrustExceptions((TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton, *(const __CFData **)(v9 + 432), *(SecTrustRef *)(v9 + 448));
        v20(v19, 0);
        goto LABEL_30;
      default:
        uint64_t v12 = *(void *)(v7 + 8);
        *(void *)(v12 + 48) = 1;
        *(_DWORD *)(v12 + 56) = 22;
        uint64_t v16 = 0;
        CFAllocatorRef v17 = 0;
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        (*(void (**)(void, void, uint64_t *, uint64_t *, void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), 0, &v16, &v14, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48), *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 56));
        if (v15) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v15);
        }
        CFStringRef v11 = v17;
        break;
    }
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
LABEL_30:
    uint64_t v2 = v26;
    if (!v26) {
      return;
    }
    goto LABEL_5;
  }
  uint64_t v1 = *(void *)(*(void *)(a1 + 40) + 8);
  *(void *)(v1 + 48) = 1;
  *(_DWORD *)(v1 + 56) = 89;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v32 = 0;
  int v33 = 0;
  (*(void (**)(void, void, uint64_t *, uint64_t *, void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), 0, &v34, &v32, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48), *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 56));
  if (v33) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v33);
  }
  uint64_t v2 = v35;
  if (v35) {
LABEL_5:
  }
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
}

void sub_184156410(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  if (a25) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a25);
  }
  _Unwind_Resume(exception_object);
}

void NWIOConnection::_tlsProcessTrust_PolicyDefault(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC0A1270);
  if (os_variant_allows_internal_security_policies())
  {
    if (Value && &unk_1EC0A1778 != 0)
    {
      size_t v6 = CFDictionaryGetValue(Value, &unk_1EC0A1778);
      if (v6)
      {
        uint64_t v7 = v6;
        CFTypeID v8 = CFGetTypeID(v6);
        if (v8 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
        }
        if ((const void *)*MEMORY[0x1E4F1CFC8] == v7) {
          goto LABEL_14;
        }
      }
    }
  }
  BOOL v46 = 0;
  if (TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce != -1) {
    dispatch_once(&TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce, &__block_literal_global_1892);
  }
  TrustExceptionManager::applyTrustExceptions((TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton, *(const __CFData **)(a1 + 432), *(__SecTrust **)(a1 + 448), &v46);
  if (v46)
  {
LABEL_14:
    (*(void (**)(uint64_t, void))(a2 + 16))(a2, 0);
  }
  else
  {
    *(void *)buf = 0;
    CFStringRef v39 = buf;
    uint64_t v40 = 0x4012000000;
    uint64_t v41 = __Block_byref_object_copy__226;
    uint64_t v42 = __Block_byref_object_dispose__227;
    uint64_t v43 = &unk_18441BEED;
    std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>(&v44, *(const void **)(a1 + 448));
    if (Value)
    {
      if (os_variant_allows_internal_security_policies())
      {
        if (&unk_1EC0A1548)
        {
          uint64_t v9 = CFDictionaryGetValue(Value, &unk_1EC0A1548);
          uint64_t v10 = v9;
          if (v9)
          {
            CFTypeID v11 = CFGetTypeID(v9);
            if (v11 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)uint64_t v30 = 0;
              _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v30, 2u);
            }
            if ((const void *)*MEMORY[0x1E4F1CFD0] == v10) {
              *(unsigned char *)(*((void *)v39 + 6) + 33) |= 1u;
            }
          }
        }
        if (&unk_1EC0A1580)
        {
          uint64_t v12 = CFDictionaryGetValue(Value, &unk_1EC0A1580);
          uint64_t v13 = v12;
          if (v12)
          {
            CFTypeID v14 = CFGetTypeID(v12);
            if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)uint64_t v30 = 0;
              _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v30, 2u);
            }
            if ((const void *)*MEMORY[0x1E4F1CFD0] == v13) {
              *(unsigned char *)(*((void *)v39 + 6) + 33) |= 2u;
            }
          }
        }
        if (&unk_1EC0A1510)
        {
          uint64_t v15 = CFDictionaryGetValue(Value, &unk_1EC0A1510);
          uint64_t v16 = v15;
          if (v15)
          {
            CFTypeID v17 = CFGetTypeID(v15);
            if (v17 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)uint64_t v30 = 0;
              _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", v30, 2u);
            }
            if ((const void *)*MEMORY[0x1E4F1CFD0] == v16) {
              *(unsigned char *)(*((void *)v39 + 6) + 33) |= 4u;
            }
          }
        }
      }
      uint64_t v18 = CFDictionaryGetValue(Value, &unk_1EC0A04E0);
      if (v18)
      {
        uint64_t v19 = *((void *)v39 + 6);
        *(void *)(v19 + 24) = CFRetain(v18);
      }
    }
    *(void *)uint64_t v30 = 0;
    uint64_t v31 = v30;
    uint64_t v32 = 0x4012000000;
    int v33 = __Block_byref_object_copy__223;
    uint64_t v34 = __Block_byref_object_dispose__224;
    uint64_t v35 = &unk_18441BEED;
    uint64_t v36 = 0;
    uint64x2_t v37 = 0;
    CFTypeRef v20 = *(std::__shared_weak_count **)(a1 + 264);
    if (v20)
    {
      uint64x2_t v37 = std::__shared_weak_count::lock(v20);
      if (v37) {
        uint64_t v36 = *(void *)(a1 + 256);
      }
    }
    uint64_t v21 = *((void *)v39 + 6);
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 3221225472;
    uint64_t v24 = ___ZN14NWIOConnection30_tlsProcessTrust_PolicyDefaultEU13block_pointerFviE_block_invoke;
    uint64_t v25 = &unk_1E5253B28;
    uint64_t v26 = a2;
    int v27 = buf;
    uint64_t v28 = v30;
    uint64_t v29 = a1;
    uint64_t v47 = MEMORY[0x1E4F143A8];
    uint64_t v48 = 3221225472;
    char v49 = ___ZN14CFNetworkTrust13evaluateAsyncEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvNS_14QuantizedErrorEE_block_invoke;
    uint64_t v50 = &unk_1E5256190;
    uint64_t v51 = v23;
    uint64_t v52 = v21;
    int v22 = SecTrustEvaluateFastAsync();
    if (v22)
    {
      *(_DWORD *)(v21 + 40) = v22;
      *(unsigned char *)(v21 + 32) |= 0x20u;
      v24(v23, 2);
    }
    _Block_object_dispose(v30, 8);
    if (v37) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v37);
    }
    _Block_object_dispose(buf, 8);
    if (v45) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v45);
    }
  }
}

void sub_1841569C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (a32) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a32);
  }
  _Unwind_Resume(a1);
}

void std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>(void *a1, const void *a2)
{
  uint64_t v4 = operator new(0x48uLL);
  v4[1] = 0;
  v4[2] = 0;
  void *v4 = &unk_1ECFA6720;
  CFNetworkTrust::CFNetworkTrust((CFNetworkTrust *)(v4 + 3), a2);
  *a1 = v5;
  a1[1] = v4;
}

void sub_184156A74(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void CFNetworkTrust::CFNetworkTrust(CFNetworkTrust *this, CFTypeRef cf)
{
  *(void *)this = &unk_1ECF9C848;
  *((_WORD *)this + 16) = 0;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 1) = v3;
}

void sub_184156AEC(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void TrustExceptionManager::applyTrustExceptions(TrustExceptionManager *this, const __CFData *a2, __SecTrust *a3, BOOL *a4)
{
  *a4 = 0;
  if (a2)
  {
    uint64_t v7 = (os_unfair_lock_s *)((char *)this + 8);
    os_unfair_lock_lock((os_unfair_lock_t)this + 2);
    CFDictionaryRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 3), a2);
    if (Value)
    {
      CFDataRef v9 = (const __CFData *)CFRetain(Value);
      os_unfair_lock_unlock(v7);
      if (v9)
      {
        if (a3) {
          SecTrustSetExceptions(a3, v9);
        }
        CFRelease(v9);
      }
    }
    else
    {
      os_unfair_lock_unlock(v7);
    }
  }
}

void NWIOConnection::_tlsProcessTrust_PolicyStrict(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC0A1270);
  CFDictionaryRef ATSVersion = StrictSecurity::getATSVersion(Value, v7);
  if (Value)
  {
    uint64_t v10 = CFDictionaryGetValue(Value, &unk_1EC0A0160);
    uint64_t v9 = (uint64_t)v10;
    if (v10)
    {
      CFTypeID v11 = CFGetTypeID(v10);
      if (v11 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      uint64_t v9 = *MEMORY[0x1E4F1CFD0] == v9;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  v31[0] = 0;
  v31[1] = v31;
  v31[2] = 0x4012000000;
  v31[3] = __Block_byref_object_copy__223;
  v31[4] = __Block_byref_object_dispose__224;
  void v31[5] = &unk_18441BEED;
  uint64_t v32 = 0;
  int v33 = 0;
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 264);
  if (v12)
  {
    int v33 = std::__shared_weak_count::lock(v12);
    if (v33) {
      uint64_t v32 = *(void *)(a1 + 256);
    }
  }
  uint64_t v13 = *a2;
  uint64_t v14 = *(void *)(a1 + 120);
  v23[0] = MEMORY[0x1E4F143A8];
  v23[1] = 3221225472;
  uint64_t v24 = ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke;
  uint64_t v25 = &unk_1E5253B00;
  uint64_t v28 = a1;
  CFDictionaryRef v29 = ATSVersion;
  int v30 = v9;
  uint64_t v26 = a3;
  int v27 = v31;
  if (!v13 || !ATSVersion || !dyld_program_sdk_at_least()) {
    goto LABEL_35;
  }
  CFTypeRef cf = 0;
  uint64_t v15 = (const void *)SecTrustDeserialize();
  uint64_t v16 = v15;
  BOOL v17 = cf || v15 == 0;
  BOOL v18 = v17;
  if (v17)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v19 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      CFTypeRef v20 = cf;
      if (cf) {
        CFIndex Code = CFErrorGetCode((CFErrorRef)cf);
      }
      else {
        CFIndex Code = 0;
      }
      *(_DWORD *)buf = 138412546;
      *(void *)&uint8_t buf[4] = v20;
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = Code;
      _os_log_error_impl(&dword_184085000, v19, OS_LOG_TYPE_ERROR, "Failed to deserialize cloned ATS trust %@ [%ld]", buf, 0x16u);
    }
  }
  else
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x4012000000;
    uint64x2_t v37 = __Block_byref_object_copy__129;
    CFTypeRef v38 = __Block_byref_object_dispose__130;
    CFStringRef v39 = &unk_18441BEED;
    std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>(&v40, v15);
    uint64_t v22 = *(void *)(*(void *)&buf[8] + 48);
    v34[0] = MEMORY[0x1E4F143A8];
    v34[1] = 3221225472;
    CFStringRef v34[2] = ___ZN14StrictSecurity33performSystemTrustEvaluationAsyncEPK8__CFDataNS_21SessionStrengthPolicyEN14CFNetworkTrust26SignatureAlgorithmStrengthEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFviE_block_invoke;
    v34[3] = &unk_1E5256A30;
    v34[4] = v23;
    v34[5] = buf;
    CFNetworkTrust::strictEvaluateAsync(v22, 1, v9, v14, (uint64_t)v34);
    _Block_object_dispose(buf, 8);
    if (v41) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v41);
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v18) {
LABEL_35:
  }
    v24((uint64_t)v23, 0);
  _Block_object_dispose(v31, 8);
  if (v33) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v33);
  }
}

void sub_184156FB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::__shared_weak_count *a25)
{
  if (v25) {
    CFRelease(v25);
  }
  _Block_object_dispose(&a18, 8);
  if (a25) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a25);
  }
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke_229(void *a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v4 = a1[7];
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(v4 + 288);
      int v11 = 134218240;
      uint64_t v12 = v10;
      __int16 v13 = 1024;
      int v14 = a2;
      _os_log_error_impl(&dword_184085000, v5, OS_LOG_TYPE_ERROR, "Connection %llu: strict TLS Trust evaluation failed(%d)", (uint8_t *)&v11, 0x12u);
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  uint64_t v6 = *(void *)(a1[5] + 8);
  CFDictionaryRef v7 = *(std::__shared_weak_count **)(v6 + 56);
  *(void *)(v6 + 48) = 0;
  *(void *)(v6 + 56) = 0;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  uint64_t v8 = *(void *)(a1[6] + 8);
  uint64_t v9 = *(std::__shared_weak_count **)(v8 + 56);
  *(void *)(v8 + 48) = 0;
  *(void *)(v8 + 56) = 0;
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
}

void TLSCallbackQueue::~TLSCallbackQueue(uint64_t **this)
{
  *this = (uint64_t *)&unk_1ECF9E038;
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackClientCertificate>>>::reset[abi:nn180100](this + 8, 0);
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackServerTrust>>>::reset[abi:nn180100](this + 7, 0);
  std::unique_ptr<std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>>::reset[abi:nn180100](this + 6, 0);
  uint64_t v2 = (std::__shared_weak_count *)this[4];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  *this = (uint64_t *)&unk_1ECF9B550;
  CFTypeRef v3 = (std::__shared_weak_count *)this[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

{
  uint64_t vars8;

  TLSCallbackQueue::~TLSCallbackQueue(this);

  JUMPOUT(0x18531B6D0);
}

void ___ZN14NWIOConnection30_tlsProcessTrust_PolicyDefaultEU13block_pointerFviE_block_invoke(void *a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if ((a2 - 1) < 2)
  {
    uint64_t v3 = a1[7];
    int v4 = CFNetworkTrust::errorForEvaluationFalure(*(CFNetworkTrust **)(*(void *)(a1[5] + 8) + 48));
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(v3 + 288);
      int v11 = 134218240;
      uint64_t v12 = v6;
      __int16 v13 = 1024;
      int v14 = v4;
      _os_log_error_impl(&dword_184085000, v5, OS_LOG_TYPE_ERROR, "Connection %llu: default TLS Trust evaluation failed(%d)", (uint8_t *)&v11, 0x12u);
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  uint64_t v7 = *(void *)(a1[5] + 8);
  uint64_t v8 = *(std::__shared_weak_count **)(v7 + 56);
  *(void *)(v7 + 48) = 0;
  *(void *)(v7 + 56) = 0;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  uint64_t v9 = *(void *)(a1[6] + 8);
  uint64_t v10 = *(std::__shared_weak_count **)(v9 + 56);
  *(void *)(v9 + 48) = 0;
  *(void *)(v9 + 56) = 0;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
}

void ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_4(void *a1, unsigned int a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1[7];
  if ((*(_WORD *)(v3 + 248) & 0x60) != 0 || (*(_DWORD *)(v3 + 136) - 5) <= 2)
  {
    uint64_t v4 = *(void *)(a1[5] + 8);
    *(void *)(v4 + 48) = 1;
    *(_DWORD *)(v4 + 56) = 89;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    (*(void (**)(void))(a1[4] + 16))();
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v7 = (void *)a1[6];
    if (a2) {
      int v8 = *MEMORY[0x1E4F1D430];
    }
    else {
      int v8 = 0;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v9 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = v7[36];
      *(_DWORD *)buf = 134218240;
      uint64_t v27 = v10;
      __int16 v28 = 1024;
      unsigned int v29 = a2;
      _os_log_impl(&dword_184085000, v9, OS_LOG_TYPE_DEFAULT, "Connection %llu: TLS Trust result %d", buf, 0x12u);
    }
    uint64_t v11 = v7[56];
    uint64_t v5 = (std::__shared_weak_count *)v7[57];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v13 = v7[60];
    uint64_t v12 = (std::__shared_weak_count *)v7[61];
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!a2)
    {
      int v14 = (std::__shared_weak_count *)v7[57];
      v7[56] = 0;
      v7[57] = 0;
      if (v14) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v14);
      }
      uint64_t v15 = (std::__shared_weak_count *)v7[59];
      v7[58] = 0;
      v7[59] = 0;
      if (v15) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v15);
      }
      uint64_t v16 = (std::__shared_weak_count *)v7[61];
      v7[60] = 0;
      v7[61] = 0;
      if (v16) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v16);
      }
    }
    uint64_t v17 = a1[4];
    uint64_t v20 = v11;
    uint64_t v21 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v18 = v13;
    uint64_t v19 = v12;
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, BOOL, uint64_t *, uint64_t *, void, void))(v17 + 16))(v17, a2 == 0, &v20, &v18, v8, a2);
    if (v19) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v19);
    }
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v21);
    }
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
    }
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184157598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (a12)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
    if (!v13)
    {
LABEL_5:
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }
  else if (!v13)
  {
    goto LABEL_5;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v13);
  if (!v12) {
LABEL_7:
  }
    _Unwind_Resume(exception_object);
LABEL_6:
  std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  goto LABEL_7;
}

void sub_1841575E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  if (!a16) {
    JUMPOUT(0x1841575C0);
  }
  JUMPOUT(0x1841575B8);
}

void ___ZN22TLSCallbackServerTrust14invokeCallbackEU13block_pointerFvbE_block_invoke(void *a1, char a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v5);
    if (v9)
    {
      uint64_t v10 = a1[5];
      if (v10)
      {
        *(unsigned char *)(v10 + 72) = a2;
        uint64_t v12 = *a3;
        uint64_t v11 = a3[1];
        if (v11) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v13 = *(std::__shared_weak_count **)(v10 + 88);
        *(void *)(v10 + 80) = v12;
        *(void *)(v10 + 88) = v11;
        if (v13) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v13);
        }
        uint64_t v15 = *a4;
        uint64_t v14 = a4[1];
        if (v14) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v16 = *(std::__shared_weak_count **)(v10 + 104);
        *(void *)(v10 + 96) = v15;
        *(void *)(v10 + 104) = v14;
        if (v16) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v16);
        }
        (*(void (**)(void))(*(void *)(v10 + 64) + 16))();
        _Block_release(*(const void **)(v10 + 64));
        *(void *)(v10 + 64) = 0;
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  (*(void (**)(void))(a1[4] + 16))();
  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
}

void sub_184157730(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke_208(void *a1, uint64_t a2, CFIndex a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (!v5)
  {
    uint64_t v9 = 0;
    goto LABEL_16;
  }
  uint64_t v9 = std::__shared_weak_count::lock(v5);
  if (!v9 || (uint64_t v10 = a1[5]) == 0)
  {
LABEL_16:
    (*(void (**)(void))(a1[4] + 16))();
    if (!v9) {
      return;
    }
    goto LABEL_17;
  }
  uint64_t v11 = a1[4];
  if ((*(_WORD *)(v10 + 248) & 0x60) == 0 && (*(_DWORD *)(v10 + 136) - 5) >= 3)
  {
    if (!a3 && !a4) {
      goto LABEL_14;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v12 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = *(void *)(v10 + 288);
      int v14 = 134218496;
      uint64_t v15 = v13;
      __int16 v16 = 2048;
      CFIndex v17 = a3;
      __int16 v18 = 1024;
      int v19 = a4;
      _os_log_error_impl(&dword_184085000, v12, OS_LOG_TYPE_ERROR, "Connection %llu: TLS Trust encountered error %ld:%d", (uint8_t *)&v14, 0x1Cu);
    }
    v22.CFIndex domain = a3;
    *(void *)&v22.error = a4;
    NWIOConnection::_handleError((NWIOConnection *)v10, v22);
  }
  a2 = 0;
LABEL_14:
  (*(void (**)(uint64_t, uint64_t))(v11 + 16))(v11, a2);
LABEL_17:

  std::__shared_weak_count::__release_shared[abi:nn180100](v9);
}

void sub_184157924(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN16TLSCallbackQueue14_doServerTrustENSt3__110shared_ptrI22TLSCallbackServerTrustEE_block_invoke(void *a1, int a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        if (a2)
        {
          *(unsigned char *)(v7 + 41) = 0;
          std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*(void *)(v7 + 48));
        }
        else
        {
          int v8 = *(uint64_t **)(v7 + 56);
          uint64_t v9 = operator new(0x20uLL);
          uint64_t v10 = a1[7];
          v9[2] = a1[6];
          v9[3] = v10;
          if (v10) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v11 = *v8;
          *uint64_t v9 = *v8;
          v9[1] = v8;
          *(void *)(v11 + 8) = v9;
          *int v8 = (uint64_t)v9;
          ++v8[2];
          *(unsigned char *)(v7 + 41) = 0;
          std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*(void *)(v7 + 48));
          TLSCallbackQueue::_invokeNextCallback((TLSCallbackQueue *)v7);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }
}

void sub_184157A18(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v6)
  {
    int v8 = 0;
    goto LABEL_8;
  }
  int v8 = std::__shared_weak_count::lock(v6);
  if (!v8 || (uint64_t v9 = *(void *)(a1 + 40)) == 0)
  {
LABEL_8:
    (*(void (**)(uint64_t, void))(a4 + 16))(a4, 0);
    if (!v8) {
      return;
    }
    goto LABEL_9;
  }
  if ((*(_WORD *)(v9 + 248) & 0x60) == 0 && (*(_DWORD *)(v9 + 136) - 5) > 2)
  {
    sec_retain(a2);
    operator new();
  }
  (*(void (**)(uint64_t, void))(a4 + 16))(a4, 0);
LABEL_9:
  std::__shared_weak_count::__release_shared[abi:nn180100](v8);
}

void sub_1841581E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30,uint64_t a31,std::__shared_weak_count *a32,uint64_t a33,std::__shared_weak_count *a34)
{
  if (a24) {
    std::__shared_weak_count::__release_weak(a24);
  }
  if (a34) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a34);
  }
  if (a32) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a32);
  }
  if (a30) {
    std::__shared_weak_count::__release_weak(a30);
  }
  if (v36) {
    std::__shared_weak_count::__release_weak(v36);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](a11);
  std::__shared_weak_count::__release_shared[abi:nn180100](v35);
  std::__shared_weak_count::__release_shared[abi:nn180100](a11);
  std::__shared_weak_count::__release_shared[abi:nn180100](v35);
  std::__shared_weak_count::__release_shared[abi:nn180100](v34);
  _Unwind_Resume(a1);
}

void TLSCallbackQueue::_invokeNextCallback(TLSCallbackQueue *this)
{
  if (!*((unsigned char *)this + 41) && !*((unsigned char *)this + 40))
  {
    uint64_t v2 = *((void *)this + 6);
    if (*(void *)(v2 + 16))
    {
      *((unsigned char *)this + 41) = 1;
      uint64_t v3 = *(void **)(v2 + 8);
      uint64_t v5 = v3[2];
      uint64_t v4 = (std::__shared_weak_count *)v3[3];
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v7 = v3[4];
      uint64_t v6 = (std::__shared_weak_count *)v3[5];
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v5)
      {
        if (v4) {
          atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v8 = *(void **)(*((void *)this + 7) + 8);
        while (1)
        {
          if (v8 == *((void **)this + 7))
          {
            uint64_t v26 = *((void *)this + 3);
            uint64_t v25 = (std::__shared_weak_count *)*((void *)this + 4);
            if (v25) {
              atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
            }
            uint64_t v27 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)buf = 0;
              _os_log_debug_impl(&dword_184085000, v27, OS_LOG_TYPE_DEBUG, "[TLSCBQ] Need to invoke to satisfy trust callback", buf, 2u);
            }
            *(void *)buf = MEMORY[0x1E4F143A8];
            uint64_t v34 = 3321888768;
            uint64_t v35 = ___ZN16TLSCallbackQueue14_doServerTrustENSt3__110shared_ptrI22TLSCallbackServerTrustEE_block_invoke;
            uint64_t v36 = &__block_descriptor_64_e8_32c41_ZTSNSt3__18weak_ptrI16TLSCallbackQueueEE48c50_ZTSNSt3__110shared_ptrI22TLSCallbackServerTrustEE_e8_v12__0B8l;
            uint64_t v37 = v26;
            CFTypeRef v38 = v25;
            if (v25) {
              atomic_fetch_add_explicit(&v25->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v39 = v5;
            uint64_t v40 = v4;
            if (v4) {
              atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v28 = *(void *)(v5 + 24);
            unsigned int v29 = *(std::__shared_weak_count **)(v5 + 32);
            if (v29) {
              atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v30 = *(void *)(v5 + 56);
            v41[0] = MEMORY[0x1E4F143A8];
            v41[1] = 3321888768;
            v41[2] = ___ZN22TLSCallbackServerTrust14invokeCallbackEU13block_pointerFvbE_block_invoke;
            v41[3] = &unk_1ECFA8DA0;
            v41[5] = v28;
            uint64_t v42 = v29;
            if (v29) {
              atomic_fetch_add_explicit(&v29->__shared_weak_owners_, 1uLL, memory_order_relaxed);
            }
            v41[4] = buf;
            (*(void (**)(uint64_t, void *))(v30 + 16))(v30, v41);
            _Block_release(*(const void **)(v5 + 56));
            *(void *)(v5 + 56) = 0;
            if (v42) {
              std::__shared_weak_count::__release_weak(v42);
            }
            if (v29) {
              std::__shared_weak_count::__release_weak(v29);
            }
            if (v40) {
              std::__shared_weak_count::__release_shared[abi:nn180100](v40);
            }
            if (v38) {
              std::__shared_weak_count::__release_weak(v38);
            }
            if (v25) {
              std::__shared_weak_count::__release_weak(v25);
            }
LABEL_97:
            if (v4) {
              std::__shared_weak_count::__release_shared[abi:nn180100](v4);
            }
LABEL_99:
            if (!v6)
            {
LABEL_116:
              if (v4) {
                std::__shared_weak_count::__release_shared[abi:nn180100](v4);
              }
              return;
            }
LABEL_115:
            std::__shared_weak_count::__release_shared[abi:nn180100](v6);
            goto LABEL_116;
          }
          uint64_t v10 = v8[2];
          uint64_t v9 = (std::__shared_weak_count *)v8[3];
          if (v9) {
            atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v4) {
            atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v11 = *(NSObject **)(v5 + 40);
          uint64_t v12 = *(std::__shared_weak_count **)(v5 + 48);
          if (v12) {
            atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          int v13 = 0;
          if (!v11) {
            goto LABEL_24;
          }
          int v14 = *(NSObject **)(v10 + 40);
          if (!v14) {
            goto LABEL_24;
          }
          if (sec_protocol_metadata_peers_are_equal(v14, v11)) {
            break;
          }
          int v13 = 0;
          if (v12) {
            goto LABEL_25;
          }
LABEL_26:
          if (v4) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v4);
          }
          if (v13)
          {
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
            }
            uint64_t v15 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)buf = 0;
              _os_log_debug_impl(&dword_184085000, v15, OS_LOG_TYPE_DEBUG, "[TLSCBQ] Used cache to satisfy trust callback", buf, 2u);
            }
            *((unsigned char *)this + 41) = 0;
            std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*((void *)this + 6));
            TLSCallbackQueue::_invokeNextCallback(this);
            if (!v9) {
              goto LABEL_35;
            }
          }
          else
          {
            int v8 = (void *)v8[1];
            if (!v9) {
              goto LABEL_35;
            }
          }
          std::__shared_weak_count::__release_shared[abi:nn180100](v9);
LABEL_35:
          if (v13) {
            goto LABEL_97;
          }
        }
        (*(void (**)(void, void, void, void))(*(void *)(v5 + 64) + 16))(*(void *)(v5 + 64), *(unsigned __int8 *)(v10 + 72), 0, 0);
        _Block_release(*(const void **)(v5 + 64));
        *(void *)(v5 + 64) = 0;
        int v13 = 1;
LABEL_24:
        if (!v12) {
          goto LABEL_26;
        }
LABEL_25:
        std::__shared_weak_count::__release_shared[abi:nn180100](v12);
        goto LABEL_26;
      }
      if (!v7) {
        goto LABEL_99;
      }
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      __int16 v16 = *(void **)(*((void *)this + 8) + 8);
      while (1)
      {
        if (v16 == *((void **)this + 8))
        {
          uint64_t v31 = *((void *)this + 3);
          uint64_t v32 = (std::__shared_weak_count *)*((void *)this + 4);
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          *(void *)buf = MEMORY[0x1E4F143A8];
          uint64_t v34 = 3321888768;
          uint64_t v35 = ___ZN16TLSCallbackQueue20_doClientCertificateENSt3__110shared_ptrI28TLSCallbackClientCertificateEE_block_invoke;
          uint64_t v36 = &__block_descriptor_64_e8_32c41_ZTSNSt3__18weak_ptrI16TLSCallbackQueueEE48c56_ZTSNSt3__110shared_ptrI28TLSCallbackClientCertificateEE_e8_v12__0B8l;
          uint64_t v37 = v31;
          CFTypeRef v38 = v32;
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v39 = v7;
          uint64_t v40 = v6;
          if (v6) {
            atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          TLSCallbackClientCertificate::invokeCallback(v7, (uint64_t)buf);
          if (v40) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v40);
          }
          if (v38) {
            std::__shared_weak_count::__release_weak(v38);
          }
          if (v32) {
            std::__shared_weak_count::__release_weak(v32);
          }
LABEL_113:
          if (!v6) {
            goto LABEL_116;
          }
          std::__shared_weak_count::__release_shared[abi:nn180100](v6);
          goto LABEL_115;
        }
        __int16 v18 = (void *)v16[2];
        CFIndex v17 = (std::__shared_weak_count *)v16[3];
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v6) {
          atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v19 = *(NSObject **)(v7 + 40);
        uint64_t v20 = *(std::__shared_weak_count **)(v7 + 48);
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v21 = 0;
        if (!v19) {
          goto LABEL_60;
        }
        CFStreamError v22 = v18[5];
        if (!v22) {
          goto LABEL_60;
        }
        if (sec_protocol_metadata_challenge_parameters_are_equal(v22, v19)) {
          break;
        }
        int v21 = 0;
        if (v20) {
          goto LABEL_61;
        }
LABEL_62:
        if (v6) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v6);
        }
        if (!v21)
        {
          __int16 v16 = (void *)v16[1];
          if (!v17) {
            goto LABEL_67;
          }
LABEL_66:
          std::__shared_weak_count::__release_shared[abi:nn180100](v17);
          goto LABEL_67;
        }
        *((unsigned char *)this + 41) = 0;
        std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(*((void *)this + 6));
        TLSCallbackQueue::_invokeNextCallback(this);
        if (v17) {
          goto LABEL_66;
        }
LABEL_67:
        if (v21) {
          goto LABEL_113;
        }
      }
      uint64_t v23 = *(void *)(v7 + 64);
      uint64_t v24 = (std::__shared_weak_count *)v18[10];
      *(void *)buf = v18[9];
      uint64_t v34 = (uint64_t)v24;
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, uint8_t *, void, void))(v23 + 16))(v23, buf, 0, 0);
      if (v34) {
        std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v34);
      }
      _Block_release(*(const void **)(v7 + 64));
      *(void *)(v7 + 64) = 0;
      int v21 = 1;
LABEL_60:
      if (!v20) {
        goto LABEL_62;
      }
LABEL_61:
      std::__shared_weak_count::__release_shared[abi:nn180100](v20);
      goto LABEL_62;
    }
  }
}

void sub_1841588E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  if (a18) {
    std::__shared_weak_count::__release_weak(a18);
  }
  if (v28) {
    std::__shared_weak_count::__release_weak(v28);
  }
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v27);
  }
  std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>::~pair((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void NWIOConnection::withHostname(uint64_t a1, uint64_t a2)
{
  nw_endpoint_type_t type = nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 304));
  uint64_t v5 = *(NSObject **)(a1 + 304);
  if (v5) {
    BOOL v6 = type - 1 > 1;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    CFStringRef v9 = 0;
  }
  else
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    hostname = nw_endpoint_get_hostname(v5);
    CFStringRef v9 = CFStringCreateWithCString(v7, hostname, 0x8000100u);
  }
  (*(void (**)(uint64_t, CFStringRef, BOOL))(a2 + 16))(a2, v9, type == nw_endpoint_type_address);
  if (v9)
  {
    CFRelease(v9);
  }
}

void sub_184158AD8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = a1[4];
      if (v6)
      {
        CFAllocatorRef v7 = (std::__shared_weak_count *)a1[7];
        v15[0] = a1[6];
        v15[1] = v7;
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v8 = a1[8];
        CFStringRef v9 = (std::__shared_weak_count *)a1[9];
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v14[0] = 0;
        v14[1] = 0;
        NWIOConnection::_tlsProcessValidateServerTrust_Invoke(v6, (uint64_t)v15, v8, (uint64_t)v9, (uint64_t)v14, a2);
        if (v9) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v9);
        }
        if (v7) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v7);
        }
LABEL_18:
        std::__shared_weak_count::__release_shared[abi:nn180100](v5);
        return;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v12 = 0;
  int v13 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  (*(void (**)(uint64_t, void, uint64_t *, uint64_t *, uint64_t, uint64_t))(a2 + 16))(a2, 0, &v12, &v10, 1, 89);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v13);
  }
  if (v5) {
    goto LABEL_18;
  }
}

void sub_184158BF4(_Unwind_Exception *a1)
{
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_2()
{
  if ((SecPolicySetSSLHostname() & 1) == 0)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v0 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v1 = 0;
      _os_log_fault_impl(&dword_184085000, v0, OS_LOG_TYPE_FAULT, "SecPolicySetSSLHostname failed", v1, 2u);
    }
  }
}

void _ZNSt3__115allocate_sharedB8nn180100I16TLSCallbackQueueNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_()
{
  uint64_t v0 = operator new(0x60uLL);
  *(_OWORD *)((char *)v0 + 8) = 0u;
  *(void *)uint64_t v0 = &unk_1ECFA6988;
  v0[2] = 0u;
  v0[3] = 0u;
  *((void *)v0 + 3) = &unk_1ECF9E038;
  *((void *)v0 + 9) = 0;
  v0[5] = 0u;
  *((_WORD *)v0 + 32) = 0;
  operator new();
}

void sub_184158E78(_Unwind_Exception *a1)
{
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackClientCertificate>>>::reset[abi:nn180100](v4, 0);
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackServerTrust>>>::reset[abi:nn180100](v3, 0);
  std::unique_ptr<std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>>::reset[abi:nn180100](v2, 0);
  shared_owners = (std::__shared_weak_count *)v1[2].__shared_owners_;
  if (shared_owners) {
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  v1[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECF9B550;
  shared_weak_owners = (std::__shared_weak_count *)v1[1].__shared_weak_owners_;
  if (shared_weak_owners) {
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v8);
  _Unwind_Resume(a1);
}

uint64_t **std::unique_ptr<std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>>::reset[abi:nn180100](uint64_t **result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    if (v2[2])
    {
      uint64_t v3 = *v2;
      uint64_t v4 = (uint64_t *)v2[1];
      uint64_t v5 = *v4;
      *(void *)(v5 + 8) = *(void *)(*v2 + 8);
      **(void **)(v3 + 8) = v5;
      v2[2] = 0;
      if (v4 != v2)
      {
        do
        {
          uint64_t v6 = (uint64_t *)v4[1];
          std::__destroy_at[abi:nn180100]<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>,0>((uint64_t)(v4 + 2));
          operator delete(v4);
          uint64_t v4 = v6;
        }
        while (v6 != v2);
      }
    }
    JUMPOUT(0x18531B6D0);
  }
  return result;
}

uint64_t **std::unique_ptr<std::list<std::shared_ptr<TLSCallbackClientCertificate>>>::reset[abi:nn180100](uint64_t **result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    std::__list_imp<std::shared_ptr<AuthenticationState>>::clear(v2);
    JUMPOUT(0x18531B6D0);
  }
  return result;
}

uint64_t **std::unique_ptr<std::list<std::shared_ptr<TLSCallbackServerTrust>>>::reset[abi:nn180100](uint64_t **result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    if (v2[2])
    {
      uint64_t v3 = *v2;
      uint64_t v4 = (uint64_t *)v2[1];
      uint64_t v5 = *v4;
      *(void *)(v5 + 8) = *(void *)(*v2 + 8);
      **(void **)(v3 + 8) = v5;
      v2[2] = 0;
      if (v4 != v2)
      {
        do
        {
          uint64_t v6 = (uint64_t *)v4[1];
          CFAllocatorRef v7 = (std::__shared_weak_count *)v4[3];
          if (v7) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v7);
          }
          operator delete(v4);
          uint64_t v4 = v6;
        }
        while (v6 != v2);
      }
    }
    JUMPOUT(0x18531B6D0);
  }
  return result;
}

void TLSCallbackQueue::initialize(TLSCallbackQueue *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2 && (uint64_t v3 = *((void *)this + 1), (v4 = std::__shared_weak_count::lock(v2)) != 0))
  {
    uint64_t v5 = v4;
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 4);
    *((void *)this + 3) = v3;
    *((void *)this + 4) = v5;
    if (v6) {
      std::__shared_weak_count::__release_weak(v6);
    }
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  else
  {
    uint64_t v7 = std::__throw_bad_weak_ptr[abi:nn180100]();
    NWIOConnection::_tlsProcessValidateServerTrust_Invoke(v7, v8, v9, v10, v11, v12);
  }
}

void NWIOConnection::_tlsProcessValidateServerTrust_Invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x4012000000;
  uint64_t v28 = __Block_byref_object_copy__212;
  unsigned int v29 = __Block_byref_object_dispose__213;
  uint64_t v30 = &unk_18441BEED;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  if ((*(_WORD *)(a1 + 248) & 0x60) != 0 || (*(_DWORD *)(a1 + 136) - 5) <= 2)
  {
    uint64_t v31 = 1;
    LODWORD(v32) = 89;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v21 = 0;
    CFStreamError v22 = 0;
    (*(void (**)(uint64_t, void, uint64_t *, uint64_t *, uint64_t, uint64_t))(a6 + 16))(a6, 0, &v23, &v21, 1, v32);
    if (v22) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v22);
    }
    uint64_t v8 = v24;
  }
  else if ((*(_WORD *)(a1 + 248) & 0x1000) != 0 && !*(void *)(a1 + 144))
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v17 = 0;
    __int16 v18 = 0;
    (*(void (**)(uint64_t, void, uint64_t *, uint64_t *, void, void))(a6 + 16))(a6, 0, &v19, &v17, 0, 0);
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v18);
    }
    uint64_t v8 = v20;
  }
  else
  {
    if (a4) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a4 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 456);
    *(void *)(a1 + 448) = a3;
    *(void *)(a1 + 456) = a4;
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
    }
    if (!CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC09FE50)
      || (int v10 = SecTrustSetPinningPolicyName()) == 0)
    {
      NWIOConnection::_tlsTrustDataForTrust((NWIOConnection *)&v12, a1);
    }
    uint64_t v11 = v26;
    v26[6] = (int)*MEMORY[0x1E4F1D430];
    *((_DWORD *)v11 + 14) = v10;
    uint64_t v15 = 0;
    __int16 v16 = 0;
    uint64_t v13 = 0;
    int v14 = 0;
    (*(void (**)(uint64_t, void, uint64_t *, uint64_t *))(a6 + 16))(a6, 0, &v15, &v13);
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v14);
    }
    uint64_t v8 = v16;
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  _Block_object_dispose(&v25, 8);
}

void sub_184159674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,std::__shared_weak_count *a34)
{
  if (a19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a19);
  }
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a21);
  }
  _Block_object_dispose(&a27, 8);
  if (a34) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a34);
  }
  _Block_object_dispose((const void *)(v34 - 128), 8);
  _Unwind_Resume(a1);
}

void NWIOConnection::_tlsTrustDataForTrust(NWIOConnection *this, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 368), &unk_1EC0A1270);
  CFDictionaryRef ATSVersion = StrictSecurity::getATSVersion(Value, v5);
  StrictSecurity::cloneSecTrust((uint64_t *)buf, (uint64_t)ATSVersion, *(void *)(a2 + 448));
  *(void *)this = *(void *)buf;
  operator new();
}

void sub_184159958(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

const __CFDictionary *StrictSecurity::getATSVersion(const __CFDictionary *this, const __CFDictionary *a2)
{
  if (this)
  {
    this = (const __CFDictionary *)CFDictionaryGetValue(this, &unk_1EC0A0208);
    if (this)
    {
      uint64_t valuePtr = -1;
      return (const __CFDictionary *)(CFNumberGetValue(this, kCFNumberCFIndexType, &valuePtr) && valuePtr == 1);
    }
  }
  return this;
}

void StrictSecurity::cloneSecTrust(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  if (a2 >= 1)
  {
    if (a3)
    {
      if (dyld_program_sdk_at_least())
      {
        uint64_t v4 = SecTrustSerialize();
        *a1 = v4;
        if (!v4)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          CFDictionaryRef v5 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412546;
            uint64_t v7 = 0;
            __int16 v8 = 2048;
            uint64_t v9 = 0;
            _os_log_error_impl(&dword_184085000, v5, OS_LOG_TYPE_ERROR, "Failed to clone ATS trust %@ [%ld]", buf, 0x16u);
          }
        }
      }
    }
  }
}

void sub_184159B30(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = 0;
  if (v2) {
    CFRelease(v2);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'Tube::needServerTrust(uint64_t a1, const void *a2, void *a3)
{
}

{
  Tube::needServerTrust(a1 - 32, a2, a3);
}

void Tube::needServerTrust(uint64_t a1, CFTypeRef cf, void *aBlock)
{
  if (*(void *)(a1 + 256)) {
    __assert_rtn("needServerTrust", "Tube.cpp", 1888, "!fSSLTrust");
  }
  *(void *)(a1 + 256) = cf;
  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 312) = _Block_copy(aBlock);
  if (*(int *)(a1 + 220) < 10)
  {
    *(_DWORD *)(a1 + 220) = 7;
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 80))(*(void *)(a1 + 112));
    if (v5) {
      uint64_t v6 = v5 - 176;
    }
    else {
      uint64_t v6 = 0;
    }
    CFRetain((CFTypeRef)(v6 - 16));
    aBlocka[0] = MEMORY[0x1E4F143A8];
    aBlocka[1] = 3221225472;
    aBlocka[2] = ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke;
    aBlocka[3] = &__block_descriptor_40_e5_v8__0l;
    aBlocka[4] = v6;
    _Block_copy(aBlocka);
    operator new();
  }

  Tube::_onqueue_complete_needServerTrust((Tube *)a1, 0, 1);
}

void sub_184159DF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v15);
  _Unwind_Resume(a1);
}

void std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>::pop_front(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v3 = *v2;
  *(void *)(v3 + 8) = v2[1];
  *(void *)v2[1] = v3;
  *(void *)(a1 + 16) = v1 - 1;
  std::__destroy_at[abi:nn180100]<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>,0>((uint64_t)(v2 + 2));

  operator delete(v2);
}

void std::__destroy_at[abi:nn180100]<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>,0>(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke(uint64_t a1, int a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 48);
  if (!a2)
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x4012000000;
    __int16 v16 = __Block_byref_object_copy__226;
    uint64_t v17 = __Block_byref_object_dispose__227;
    __int16 v18 = &unk_18441BEED;
    std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>(&v19, *(const void **)(v3 + 448));
    uint64_t v8 = *(void *)(*(void *)&buf[8] + 48);
    uint64_t v9 = *(void *)(a1 + 56);
    uint64_t v10 = *(unsigned int *)(a1 + 64);
    uint64_t v11 = *(void *)(v3 + 120);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    void v14[2] = ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke_229;
    v14[3] = &unk_1E5253B28;
    uint64_t v12 = *(void *)(a1 + 40);
    void v14[4] = *(void *)(a1 + 32);
    v14[5] = buf;
    v14[6] = v12;
    v14[7] = v3;
    CFNetworkTrust::strictEvaluateAsync(v8, v9, v10, v11, (uint64_t)v14);
    _Block_object_dispose(buf, 8);
    uint64_t v7 = v20;
    if (!v20) {
      return;
    }
    goto LABEL_7;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v5 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v13 = *(void *)(v3 + 288);
    *(_DWORD *)buf = 134218240;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_error_impl(&dword_184085000, v5, OS_LOG_TYPE_ERROR, "Connection %llu: system TLS Trust evaluation failed(%d)", buf, 0x12u);
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v7 = *(std::__shared_weak_count **)(v6 + 56);
  *(void *)(v6 + 48) = 0;
  *(void *)(v6 + 56) = 0;
  if (v7) {
LABEL_7:
  }
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
}

void sub_18415A0B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a24);
  }
  _Unwind_Resume(a1);
}

uint64_t CFNetworkTrust::strictEvaluateAsync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = SecTrustEvaluateFastAsync();
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, 4294957494);
  }
  return result;
}

void ___ZL25ConnectionProtocolConnectP11nw_protocolS0__block_invoke_2(uint64_t a1, void *a2, char a3)
{
  if (a2 && (a3 & 1) == 0)
  {
    uint64_t v5 = (void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 32) + 216))(*(void *)(a1 + 32), 0x1EC09E5D0);
    uint64_t v6 = *(void **)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 56);
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3321888768;
    v9[2] = ___ZL25ConnectionProtocolConnectP11nw_protocolS0__block_invoke_3;
    v9[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE_e66_v40__0____CFString__8____CFArray__16____CFData__24____CFString__32l;
    uint64_t v8 = *(std::__shared_weak_count **)(a1 + 40);
    v9[4] = *(void *)(a1 + 32);
    uint64_t v10 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = ___ZN18H2CoalescingEngine29findCoalescingConnectionEntryEP14__CFDictionaryPKS0_PK10__CFStringPK9__CFArrayU13block_pointerFvS6_S9_PK8__CFDataS6_E_block_invoke;
    v11[3] = &unk_1E52578A0;
    void v11[4] = v9;
    __NSURLSession_CoalescingGetCoalescingCCEntryHostWithDNSRecord(v6, v7, a2, v5, 1, (uint64_t)v11);
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
}

void sub_18415A2CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  if (v15) {
    CFRelease(v15);
  }
  _Unwind_Resume(exception_object);
}

void __NSURLSession_CoalescingGetCoalescingCCEntryHostWithDNSRecord(void *a1, uint64_t a2, void *a3, void *a4, int a5, uint64_t a6)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = [a1 objectForKeyedSubscript:a2];
  if (a5)
  {
    [(__CFN_CoalescingDomainHolder *)&v38 coalescingCoalescingConnectionHost:a3 ipAddrs:a4];
    uint64_t v12 = v38;
    if (!v38) {
      goto LABEL_51;
    }
    if (H2CoalescingLog(void)::onceToken != -1) {
      dispatch_once(&H2CoalescingLog(void)::onceToken, &__block_literal_global_7331);
    }
    uint64_t v13 = H2CoalescingLog(void)::onceLog;
    if (!os_log_type_enabled((os_log_t)H2CoalescingLog(void)::onceLog, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_47;
    }
    int v14 = v12;
    if (v12[23] < 0) {
      int v14 = *(const char **)v12;
    }
    *(_DWORD *)buf = 138412802;
    uint64_t v50 = a3;
    __int16 v51 = 2080;
    uint64_t v52 = v14;
    __int16 v53 = 2048;
    CFRange v54 = a1;
    uint64_t v15 = "possible mapping %@ -> %s config %p";
    goto LABEL_57;
  }
  uint64_t v37 = v11;
  if (!v11)
  {
    CFTypeRef v38 = 0;
    uint64_t v39 = 0;
    goto LABEL_51;
  }
  int64x2_t v46 = 0uLL;
  uint64_t v47 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  uint64_t v16 = [a4 countByEnumeratingWithState:&v42 objects:buf count:16];
  if (v16)
  {
    uint64_t v17 = *(void *)v43;
    do
    {
      for (uint64_t i = 0; i != v16; ++i)
      {
        if (*(void *)v43 != v17) {
          objc_enumerationMutation(a4);
        }
        std::string::basic_string[abi:nn180100]<0>(__p, (char *)[*(id *)(*((void *)&v42 + 1) + 8 * i) UTF8String]);
        uint64_t v19 = (_OWORD *)v46.i64[1];
        if (v46.i64[1] >= (unint64_t)v47)
        {
          unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((v46.i64[1] - v46.i64[0]) >> 3);
          unint64_t v22 = v21 + 1;
          if (v21 + 1 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          if (0x5555555555555556 * (((uint64_t)v47 - v46.i64[0]) >> 3) > v22) {
            unint64_t v22 = 0x5555555555555556 * (((uint64_t)v47 - v46.i64[0]) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * (((uint64_t)v47 - v46.i64[0]) >> 3) >= 0x555555555555555) {
            unint64_t v23 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v23 = v22;
          }
          v48.__end_cap_.__value_ = (std::allocator<std::string> *)&v47;
          if (v23) {
            unint64_t v23 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v23);
          }
          else {
            uint64_t v24 = 0;
          }
          unint64_t v25 = v23 + 24 * v21;
          long long v26 = *(_OWORD *)__p;
          *(void *)(v25 + 16) = v41;
          *(_OWORD *)unint64_t v25 = v26;
          __p[1] = 0;
          uint64_t v41 = 0;
          __p[0] = 0;
          uint64_t v27 = v46.i64[1];
          uint64_t v28 = v46.i64[0];
          if (v46.i64[1] == v46.i64[0])
          {
            int64x2_t v31 = vdupq_n_s64(v46.u64[1]);
            unint64_t v29 = v23 + 24 * v21;
          }
          else
          {
            unint64_t v29 = v23 + 24 * v21;
            do
            {
              long long v30 = *(_OWORD *)(v27 - 24);
              *(void *)(v29 - 8) = *(void *)(v27 - 8);
              *(_OWORD *)(v29 - 24) = v30;
              v29 -= 24;
              *(void *)(v27 - 16) = 0;
              *(void *)(v27 - 8) = 0;
              *(void *)(v27 - 24) = 0;
              v27 -= 24;
            }
            while (v27 != v28);
            int64x2_t v31 = v46;
          }
          unint64_t v32 = v25 + 24;
          v46.i64[0] = v29;
          v46.i64[1] = v25 + 24;
          *(int64x2_t *)&v48.__begin_ = v31;
          int v33 = v47;
          uint64_t v47 = (std::string *)(v23 + 24 * v24);
          v48.__end_cap_.__value_ = v33;
          v48.__first_ = (std::__split_buffer<std::string>::pointer)v31.i64[0];
          std::__split_buffer<std::string>::~__split_buffer(&v48);
          v46.i64[1] = v32;
          if (SHIBYTE(v41) < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          long long v20 = *(_OWORD *)__p;
          *(void *)(v46.i64[1] + 16) = v41;
          *uint64_t v19 = v20;
          v46.i64[1] = (uint64_t)v19 + 24;
        }
      }
      uint64_t v16 = [a4 countByEnumeratingWithState:&v42 objects:buf count:16];
    }
    while (v16);
  }
  std::string::basic_string[abi:nn180100]<0>(&v48, (char *)[a3 UTF8String]);
  if (v46.i64[0] == v46.i64[1]) {
    __assert_rtn("updateCoalescingConnectionKeyWithHostWithDNSRecord", "HTTP2CoalescingSupport.mm", 151, "!DNSRecordIPAddresses.empty()");
  }
  CoalescingDomain::_find_coalescing_connection_key(&v38, v37 + 8, (uint64_t)&v48, v46.i64[0], (void *)v46.i64[1]);
  uint64_t v12 = v38;
  if (v38)
  {
    uint64_t v34 = v39;
    __p[0] = (void *)v38;
    __p[1] = v39;
    if (v39) {
      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CoalescingDomain::_update_internal_mappings((uint64_t **)(v37 + 8), (uint64_t *)__p, (uint64_t)&v48, (long long **)&v46);
    if (v34) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v34);
    }
  }
  if (SHIBYTE(v48.__end_) < 0) {
    operator delete(v48.__first_);
  }
  v48.__first_ = (std::__split_buffer<std::string>::pointer)&v46;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v48);
  if (v12)
  {
    if (H2CoalescingLog(void)::onceToken != -1) {
      dispatch_once(&H2CoalescingLog(void)::onceToken, &__block_literal_global_7331);
    }
    uint64_t v13 = H2CoalescingLog(void)::onceLog;
    if (!os_log_type_enabled((os_log_t)H2CoalescingLog(void)::onceLog, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_47;
    }
    uint64_t v36 = v12;
    if (v12[23] < 0) {
      uint64_t v36 = *(const char **)v12;
    }
    *(_DWORD *)buf = 138412802;
    uint64_t v50 = a3;
    __int16 v51 = 2080;
    uint64_t v52 = v36;
    __int16 v53 = 2048;
    CFRange v54 = a1;
    uint64_t v15 = "updated mapping %@ -> %s config %p";
LABEL_57:
    _os_log_debug_impl(&dword_184085000, v13, OS_LOG_TYPE_DEBUG, v15, buf, 0x20u);
LABEL_47:
    if (v12[23] < 0) {
      uint64_t v12 = *(const char **)v12;
    }
    CFStringRef v35 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v12, 0);
    (*(void (**)(uint64_t, CFStringRef, void, void, void))(a6 + 16))(a6, v35, *((void *)v38 + 3), *((void *)v38 + 4), *((void *)v38 + 5));
    if (v35) {
      CFRelease(v35);
    }
  }
LABEL_51:
  if (v39) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v39);
  }
}

void sub_18415A7F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,char *a42)
{
  if (v42)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v42);
    std::__shared_weak_count::__release_shared[abi:nn180100](v42);
  }
  if (a39 < 0) {
    operator delete(__p);
  }
  a42 = &a30;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&a42);
  _Unwind_Resume(a1);
}

char *CFHTTPCookieStorageCreateFromFile(char *a1, CFURLRef relativeURL, uint64_t a3)
{
  CFAllocatorRef v5 = (const __CFAllocator *)a1;
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    uint64_t v6 = [NSHTTPCookieStorageToCookie2Storage alloc];
    return (char *)-[NSHTTPCookieStorageToCookie2Storage initWithPath:](v6, relativeURL);
  }
  else if (relativeURL)
  {
    CFURLRef v8 = CFURLCopyAbsoluteURL(relativeURL);
    AutoScalar::AutoScalar((AutoScalar *)&v12, (const __CFAllocator *)2);
    MutableDictionary = cfTypeCreateMutableDictionary(v5, @"url", v8, @"type", @"binary", @"policy", v13, @"base", a3, 0, 0);
    uint64_t v12 = &unk_1ECF9A500;
    if (v13) {
      CFRelease(v13);
    }
    uint64_t v10 = _CFHTTPCookieStorageCreateWithProperties_possiblyFromCache(v5, MutableDictionary, 1);
    if (MutableDictionary) {
      CFRelease(MutableDictionary);
    }
    if (v8) {
      CFRelease(v8);
    }
    return v10;
  }
  else
  {
    uint64_t v11 = (os_unfair_lock_s *)_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault;
    if (!_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault)
    {
      a1 = StorageSession::copyProcessDefault((StorageSession *)a1);
      uint64_t v11 = (os_unfair_lock_s *)(a1 - 16);
      _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault = (uint64_t)(a1 - 16);
    }
    return (char *)_CFURLStorageSessionCopyCookieStorage((uint64_t)a1, v11);
  }
}

void sub_18415AA98(_Unwind_Exception *exception_object)
{
  *(void *)(v2 - 48) = &unk_1ECF9A500;
  uint64_t v4 = *(const void **)(v2 - 40);
  if (v4) {
    CFRelease(v4);
  }
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void FileURLProtocol::fileStreamEvent(FileURLProtocol *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](this, a2, a3);
  uint64_t v5 = v4;
  uint64_t v6 = v3;
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if ((v4 > 0x10 || ((1 << v4) & 0x10106) == 0) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(buffer[0].st_dev) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "fileReadStreamCB(): unrecognized event", (uint8_t *)buffer, 2u);
  }
  char v7 = *(unsigned char *)(v6 + 112);
  if (v7)
  {
    *(void *)(v6 + 136) = v5;
  }
  else if (v5 > 7)
  {
    if (v5 == 8)
    {
      CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*(void *)(v6 + 128));
      *(void *)&buffer[0].st_dev = Error.domain;
      buffer[0].st_ino = *(void *)&Error.error;
      CFAllocatorRef v35 = CFGetAllocator((CFTypeRef)(v6 - 16));
      CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v35, &buffer[0].st_dev);
      URLProtocol::sendDidFail((URLProtocol *)v6, CFErrorWithStreamError);
      if (CFErrorWithStreamError) {
        CFRelease(CFErrorWithStreamError);
      }
    }
    else if (v5 == 16)
    {
      if ((*(unsigned char *)(v6 + 112) & 2) == 0)
      {
        *(unsigned char *)(v6 + 112) = v7 | 2;
        __darwin_time_t v21 = *(void *)(v6 + 120);
        *(void *)&buffer[0].st_dev = MEMORY[0x1E4F143A8];
        buffer[0].st_ino = 3221225472;
        *(void *)&buffer[0].st_uuint64_t id = ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8227;
        *(void *)&buffer[0].st_rdev = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
        buffer[0].st_atimespec.tv_sec = v21;
        uint64_t v22 = *(void *)(v6 + 96);
        if (v22)
        {
          uint64_t v23 = (*(uint64_t (**)(void))(*(void *)v22 + 16))(*(void *)(v6 + 96));
          uint64_t v24 = (void *)MEMORY[0x18531D6D0](v23);
          (*(void (**)(stat *, void))&buffer[0].st_uid)(buffer, *(void *)(v6 + 96));
          (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
        }
      }
      URLProtocol::sendDidFinishLoading((URLProtocol *)v6);
    }
  }
  else if (v5 == 1)
  {
    if (*(void *)(v6 + 144))
    {
      CFDataRef v25 = (const __CFData *)CFReadStreamCopyProperty(*(CFReadStreamRef *)(v6 + 128), (CFStreamPropertyKey)*MEMORY[0x1E4F1CCC0]);
      CFDataRef v26 = v25;
      if (v25)
      {
        BytePtr = (int *)CFDataGetBytePtr(v25);
        if (!fstat(*BytePtr, buffer)
          && (LODWORD(valuePtr[0]) = 0, (CFNumberRef v41 = *(const __CFNumber **)(v6 + 144)) != 0)
          && CFNumberGetValue(v41, kCFNumberIntType, valuePtr))
        {
          BOOL v42 = LODWORD(valuePtr[0]) == buffer[0].st_dev;
          CFRelease(v26);
          if (v42)
          {
            FileURLProtocol::checkAndSendDidReceiveResponse(v6);
            return;
          }
        }
        else
        {
          CFRelease(v26);
        }
      }
      FileURLProtocol::destroyReadStream((FileURLProtocol *)v6);
      CFAllocatorRef v28 = CFGetAllocator((CFTypeRef)(v6 - 16));
      CFCFStreamError Error = __cfnCreateCFError(v28, @"kCFErrorDomainCFNetwork", -1104, v29, v30, v31, v32, v33, 0);
      URLProtocol::sendDidFail((URLProtocol *)v6, CFError);
      if (CFError) {
LABEL_17:
      }
        CFRelease(CFError);
    }
    else if ((*(unsigned char *)(v6 + 112) & 2) == 0)
    {
      *(unsigned char *)(v6 + 112) = v7 | 2;
      __darwin_time_t v37 = *(void *)(v6 + 120);
      *(void *)&buffer[0].st_dev = MEMORY[0x1E4F143A8];
      buffer[0].st_ino = 3221225472;
      *(void *)&buffer[0].st_uuint64_t id = ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8227;
      *(void *)&buffer[0].st_rdev = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
      buffer[0].st_atimespec.tv_sec = v37;
      uint64_t v38 = *(void *)(v6 + 96);
      if (v38)
      {
        uint64_t v39 = (*(uint64_t (**)(void))(*(void *)v38 + 16))(*(void *)(v6 + 96));
        uint64_t v40 = (void *)MEMORY[0x18531D6D0](v39);
        (*(void (**)(stat *, void))&buffer[0].st_uid)(buffer, *(void *)(v6 + 96));
        (*(void (**)(uint64_t))(*(void *)v38 + 24))(v38);
      }
    }
  }
  else if (v5 == 2)
  {
    if ((*(unsigned char *)(v6 + 112) & 2) == 0)
    {
      *(unsigned char *)(v6 + 112) = v7 | 2;
      __darwin_time_t v8 = *(void *)(v6 + 120);
      *(void *)&buffer[0].st_dev = MEMORY[0x1E4F143A8];
      buffer[0].st_ino = 3221225472;
      *(void *)&buffer[0].st_uuint64_t id = ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8227;
      *(void *)&buffer[0].st_rdev = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
      buffer[0].st_atimespec.tv_sec = v8;
      uint64_t v9 = *(void *)(v6 + 96);
      if (v9)
      {
        uint64_t v10 = (*(uint64_t (**)(void))(*(void *)v9 + 16))(*(void *)(v6 + 96));
        uint64_t v11 = (void *)MEMORY[0x18531D6D0](v10);
        (*(void (**)(stat *, void))&buffer[0].st_uid)(buffer, *(void *)(v6 + 96));
        (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
      }
    }
    uint64_t v12 = CFReadStreamRead(*(CFReadStreamRef *)(v6 + 128), (UInt8 *)buffer, 0x10000);
    if (v12 >= 1)
    {
      CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)(v6 - 16));
      CFDataRef v14 = CFDataCreate(v13, (const UInt8 *)buffer, v12);
      CFCFStreamError Error = v14;
      if (v14)
      {
        uint64_t v16 = *(Throttler **)(v6 + 64);
        if (v16)
        {
          CFIndex Length = CFDataGetLength(v14);
          Throttler::noteOutstandingBytes(v16, Length);
        }
      }
      valuePtr[0] = MEMORY[0x1E4F143A8];
      valuePtr[1] = 3221225472;
      long long v44 = ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke_8228;
      long long v45 = &__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
      int64x2_t v46 = CFError;
      uint64_t v47 = v12;
      uint64_t v18 = *(void *)(v6 + 96);
      if (v18)
      {
        uint64_t v19 = (*(uint64_t (**)(void))(*(void *)v18 + 16))(*(void *)(v6 + 96));
        long long v20 = (void *)MEMORY[0x18531D6D0](v19);
        v44((uint64_t)valuePtr, *(void *)(v6 + 96));
        (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
      }
      if (CFError) {
        goto LABEL_17;
      }
    }
  }
}

CFTypeRef StorageSession::copyCredStorage(StorageSession *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 48);
  os_unfair_lock_lock((os_unfair_lock_t)this + 12);
  if (!*((unsigned char *)this + 54))
  {
    *((unsigned char *)this + 54) = 1;
    if (!*((void *)this + 4))
    {
      CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
      *((void *)this + 4) = _CFURLCredentialStorageCreateWithProperties(v3, 0, *((CFDictionaryRef *)this + 10));
    }
  }
  os_unfair_lock_unlock(v2);
  CFTypeRef result = (CFTypeRef)*((void *)this + 4);
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

CFTypeRef _CFURLStorageSessionCopyCredentialStorage(uint64_t a1, uint64_t a2)
{
  if (StorageSession::Class(void)::sOnce_StorageSession != -1) {
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_19595);
  }
  if (a2) {
    CFAllocatorRef v3 = (StorageSession *)(a2 + 16);
  }
  else {
    CFAllocatorRef v3 = 0;
  }

  return StorageSession::copyCredStorage(v3);
}

CFTypeRef CFURLCredentialStorageCreate(char *a1)
{
  uint64_t v1 = _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault;
  if (!_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault)
  {
    a1 = StorageSession::copyProcessDefault((StorageSession *)a1);
    uint64_t v1 = (uint64_t)(a1 - 16);
    _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault = (uint64_t)(a1 - 16);
  }

  return _CFURLStorageSessionCopyCredentialStorage((uint64_t)a1, v1);
}

char *StorageSession::copyProcessDefault(StorageSession *this)
{
  if (StorageSession::copyProcessDefault(void)::sOnce != -1) {
    dispatch_once(&StorageSession::copyProcessDefault(void)::sOnce, &__block_literal_global_4_19602);
  }
  uint64_t v1 = (char *)StorageSession::copyProcessDefault(void)::sProcessDefault;
  if (!StorageSession::copyProcessDefault(void)::sProcessDefault) {
    return 0;
  }
  if (StorageSession::Class(void)::sOnce_StorageSession != -1) {
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_19595);
  }
  uint64_t v2 = v1 + 16;
  CFRetain(v1);
  return v2;
}

void *_CFURLCredentialStorageCreateWithProperties(const __CFAllocator *a1, const __CFString *a2, CFDictionaryRef theDict)
{
  if (theDict) {
    BOOL v4 = CFDictionaryGetValue(theDict, @"kCFURLStorageSessionIsPrivate") == (const void *)*MEMORY[0x1E4F1CFC8];
  }
  else {
    BOOL v4 = 1;
  }
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v6 = (void *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v6 = (void *)(Instance + 16);
    *(void *)(Instance + 128) = 0;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  *uint64_t v6 = &unk_1ECFA1A88;
  v6[1] = &unk_1ECFA1AD8;
  v6[3] = &unk_1ECFA1B60;
  void v6[2] = &unk_1ECF9B550;
  _CoreLockable::_CoreLockable((_CoreLockable *)(v6 + 3), 1);
  *uint64_t v6 = &unk_1ECFA2708;
  v6[1] = &unk_1ECFA27A8;
  void v6[2] = &unk_1ECFA2810;
  v6[3] = &unk_1ECFA2830;
  int v7 = ActualCredentialStorage::initialize((ActualCredentialStorage *)v6, a2, v4);
  CFTypeRef result = v6 - 2;
  if (!v7)
  {
    CFRelease(result);
    return 0;
  }
  return result;
}

void sub_18415B71C(_Unwind_Exception *a1)
{
  void *v2 = v1;
  _Unwind_Resume(a1);
}

void _CoreLockable::_CoreLockable(_CoreLockable *this, int a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ECF9C6A8;
  if (a2)
  {
    pthread_mutexattr_init(&v3);
    pthread_mutexattr_settype(&v3, 2);
    pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), &v3);
    pthread_mutexattr_destroy(&v3);
  }
  else
  {
    pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), 0);
  }
}

uint64_t ActualCredentialStorage::initialize(ActualCredentialStorage *this, const __CFString *a2, int a3)
{
  uint64_t v6 = (char *)this - 16;
  CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
  __darwin_time_t v8 = CFAllocatorAllocate(v7, 64, 0);
  *__darwin_time_t v8 = 0u;
  v8[3] = 0u;
  v8[2] = 0u;
  v8[1] = 0u;
  CFAllocatorRef v9 = CFGetAllocator(v6);
  *(void *)__darwin_time_t v8 = &unk_1ECFA2A88;
  *((void *)v8 + 1) = v9;
  *((void *)v8 + 2) = &unk_1ECFA2AE0;
  *((void *)v8 + 3) = &unk_1ECFA2B48;
  *((void *)v8 + 4) = &unk_1ECFA0250;
  *((void *)v8 + 5) = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((void *)v8 + 6) = &unk_1ECFA0270;
  *((void *)v8 + 7) = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((void *)this + 13) = v8;
  if (!a3)
  {
LABEL_4:
    if (a2) {
      CFTypeRef v15 = CFRetain(a2);
    }
    else {
      CFTypeRef v15 = 0;
    }
    *((void *)this + 12) = v15;
    return 1;
  }
  CFAllocatorRef v10 = CFGetAllocator(v6);
  uint64_t v11 = CFAllocatorAllocate(v10, 48, 0);
  *uint64_t v11 = 0u;
  v11[2] = 0u;
  v11[1] = 0u;
  CFAllocatorRef v12 = CFGetAllocator(v6);
  *(void *)uint64_t v11 = &unk_1ECFA3B98;
  *((void *)v11 + 1) = v12;
  *((void *)v11 + 2) = &unk_1ECFA3C08;
  *((void *)v11 + 3) = &unk_1ECFA3C70;
  *((unsigned char *)v11 + 40) = 0;
  *((void *)this + 14) = v11;
  int v13 = PersistentCredentialStorage::initialize((PersistentCredentialStorage *)v11, a2);
  uint64_t result = *((void *)this + 14);
  if (v13)
  {
    if (!result) {
      return result;
    }
    goto LABEL_4;
  }
  if (result) {
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
  }
  uint64_t result = 0;
  *((void *)this + 14) = 0;
  return result;
}

void sub_18415BA38(_Unwind_Exception *a1)
{
  *(void *)(v1 + 32) = v2;
  CFRelease(*(CFTypeRef *)(v1 + 40));
  *pthread_mutexattr_t v3 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t PersistentCredentialStorage::initialize(PersistentCredentialStorage *this, CFTypeRef cf)
{
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  *((void *)this + 4) = v3;
  return 1;
}

void _createByFile(const __CFDictionary *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  CFDictionaryGetValue(a1, @"url");
  CFDictionaryRef Value = CFDictionaryGetValue(a1, @"safeparent");
  CFTypeRef v3 = (PrivateHTTPCookieStorage *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 336, 0);
  *(_OWORD *)CFTypeRef v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((_OWORD *)v3 + 14) = 0u;
  *((_OWORD *)v3 + 15) = 0u;
  *((_OWORD *)v3 + 16) = 0u;
  *((_OWORD *)v3 + 17) = 0u;
  *((_OWORD *)v3 + 18) = 0u;
  *((_OWORD *)v3 + 19) = 0u;
  *((_OWORD *)v3 + 20) = 0u;
  if (Value)
  {
    CFTypeID v4 = CFGetTypeID(Value);
    if (v4 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)char buffer = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buffer, 2u);
    }
  }
  PrivateHTTPCookieStorage::PrivateHTTPCookieStorage(v3, 1);
  *(void *)CFTypeRef v3 = &unk_1ECF9E2B8;
  *((void *)v3 + 3) = &unk_1ECF9E3A8;
  operator new();
}

void sub_18415C6C0(_Unwind_Exception *a1)
{
  AutoString::~AutoString((AutoString *)&STACK[0x498]);
  AutoString::~AutoString((AutoString *)(v2 - 256));
  DiskCookieStorage::~DiskCookieStorage(v1);
  _Unwind_Resume(a1);
}

void *_CookieStorageCreateInMemory(const __CFAllocator *a1, OpaqueCFHTTPCookieStorage *a2)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    uint64_t v2 = [NSHTTPCookieStorageToCookie2Storage alloc];
    return -[NSHTTPCookieStorageToCookie2Storage initMemoryCookieStore](v2);
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
    uint64_t v5 = Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      uint64_t v5 = Instance + 1;
      Instance[7] = 0u;
      Instance[8] = 0u;
      Instance[5] = 0u;
      Instance[6] = 0u;
      Instance[3] = 0u;
      Instance[4] = 0u;
      Instance[2] = 0u;
    }
    *(void *)uint64_t v5 = &unk_1ECF9E5A0;
    *((void *)v5 + 1) = &unk_1ECF9E5E8;
    *((_DWORD *)v5 + 30) = 0;
    HTTPCookieStorage::initialize((HTTPCookieStorage *)v5, 0);
    return v5 - 1;
  }
}

uint64_t HTTPCookieStorage::initialize(HTTPCookieStorage *this, PrivateHTTPCookieStorage *a2)
{
  if (a2)
  {
    *((void *)this + 2) = a2;
    (*(void (**)(PrivateHTTPCookieStorage *))(*(void *)a2 + 40))(a2);
    CFTypeRef v3 = (_OWORD *)*((void *)this + 2);
  }
  else
  {
    CFAllocatorRef v4 = CFGetAllocator((char *)this - 16);
    CFTypeRef v3 = CFAllocatorAllocate(v4, 88, 0);
    *CFTypeRef v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    v3[4] = 0u;
    *((void *)v3 + 10) = 0;
    MemoryCookieStorage::MemoryCookieStorage((MemoryCookieStorage *)v3, 0);
    *((void *)this + 2) = v5;
  }
  uint64_t v6 = *((void *)v3 + 4);
  if (v6) {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  uint64_t result = (*(uint64_t (**)(_OWORD *))(*(void *)v3 + 72))(v3);
  if (v6) {
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  }
  *((void *)this + 7) = 0;
  *((unsigned char *)this + 64) = 0;
  *((void *)this + 9) = -1;
  return result;
}

void sub_18415C964(_Unwind_Exception *exception_object)
{
  if (v1) {
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void MemoryCookieStorage::MemoryCookieStorage(MemoryCookieStorage *this, int a2)
{
  PrivateHTTPCookieStorage::PrivateHTTPCookieStorage(this, a2);
  *(void *)uint64_t v3 = &unk_1ECF9FE58;
  *(void *)(v3 + 24) = &unk_1ECF9FF38;
  CFAllocatorRef v4 = (MemoryCookies *)CFAllocatorAllocate(*(CFAllocatorRef *)(v3 + 8), 32, 0);
  *(_OWORD *)CFAllocatorRef v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  MemoryCookies::MemoryCookies(v4, *((CFAllocatorRef *)this + 1));
  *((void *)this + 9) = v5;
  *((_DWORD *)this + 20) = 2;
}

void sub_18415CA10(_Unwind_Exception *a1)
{
  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(v1);
  _Unwind_Resume(a1);
}

void MemoryCookies::MemoryCookies(MemoryCookies *this, CFAllocatorRef allocator)
{
  *(void *)this = &unk_1ECF9C338;
  *((void *)this + 1) = allocator;
  *((void *)this + 2) = &unk_1ECF9C360;
  *((void *)this + 3) = CFDictionaryCreateMutable(allocator, 0, &CStringKeyCallbacks::caseInsensitiveCallbacks(void)::sCallbacks, MEMORY[0x1E4F1D540]);
}

void sub_18415CAA8(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void PrivateHTTPCookieStorage::PrivateHTTPCookieStorage(PrivateHTTPCookieStorage *this, int a2)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, (const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
  void *v4 = &unk_1ECFA2ED0;
  v4[3] = &unk_1ECFA2FB0;
  if (a2) {
    operator new();
  }
  *((unsigned char *)this + 40) = 1;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
}

void sub_18415CB9C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x1081C4076DFA842);
  void *v2 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void FileURLProtocol::_protocolInterface_startLoad(FileURLProtocol *this, const _CFCachedURLResponse *a2, uint64_t a3)
{
  __darwin_ino64_t v3 = MEMORY[0x1F4188790](this, a2, a3);
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  CFURLRef v4 = (const __CFURL *)[*(id *)(v3 + 88) cfURL];
  FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v68, v4, 0, 0, 0);
  *(void *)(v3 + 144) = _CFURLRequestCopyProtocolPropertyForKey(*(void **)(v3 + 88), @"NSURLRequestFileProtocolExpectedDevice");
  if (!v68
    || stat(v69, &propertyValueTypeRefPtr)
    || (st_size_t size = propertyValueTypeRefPtr.st_size, propertyValueTypeRefPtr.st_size == -1))
  {
    CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)(v3 - 16));
    CFCFStreamError Error = __cfnCreateCFError(v10, @"kCFErrorDomainCFNetwork", -1100, v11, v12, v13, v14, v15, 0);
    URLProtocol::sendDidFail((URLProtocol *)v3, CFError);
    if (!CFError) {
      return;
    }
    goto LABEL_10;
  }
  CFURLRef v6 = (const __CFURL *)[(__CFURL *)v4 URLByResolvingSymlinksInPath];
  *(void *)&propertyValueTypeRefPtr.st_dev = 0;
  if (!CFURLCopyResourcePropertyForKey(v6, (CFStringRef)*MEMORY[0x1E4F1D778], &propertyValueTypeRefPtr, 0)
    || !*(void *)&propertyValueTypeRefPtr.st_dev
    || (CFStringRef v7 = UTTypeCopyPreferredTagWithClass(*(CFStringRef *)&propertyValueTypeRefPtr.st_dev, (CFStringRef)*MEMORY[0x1E4F22500]), CFRelease(*(CFTypeRef *)&propertyValueTypeRefPtr.st_dev), !v7))
  {
    CFStringRef v8 = _CFURLCopyPathExtension_WorksWithMoreSchemes(v6);
    CFStringRef v9 = v8;
    if (v8)
    {
      CFStringRef v7 = copyMIMETypeForExtension(v8);
      CFRelease(v9);
    }
    else
    {
      CFStringRef v7 = 0;
    }
  }
  CFAllocatorRef v17 = CFGetAllocator((CFTypeRef)(v3 - 16));
  if (st_size) {
    uint64_t v18 = st_size;
  }
  else {
    uint64_t v18 = -1;
  }
  *(void *)(v3 + 120) = CFURLResponseCreate((uint64_t)v17, v4, v7, v18, 0, 2);
  if (v7) {
    CFRelease(v7);
  }
  if (st_size < 0x4000 && st_size)
  {
    if (!v68) {
      goto LABEL_58;
    }
    int v19 = open(v69, 0);
    if ((v19 & 0x80000000) == 0 || (long long v20 = __error(), v19 != -1))
    {
      if (!*(void *)(v3 + 144)
        || !fstat(v19, &propertyValueTypeRefPtr)
        && (LODWORD(valuePtr[0]) = 0, (CFNumberRef v35 = *(const __CFNumber **)(v3 + 144)) != 0)
        && CFNumberGetValue(v35, kCFNumberIntType, valuePtr)
        && LODWORD(valuePtr[0]) == propertyValueTypeRefPtr.st_dev)
      {
        if ((*(unsigned char *)(v3 + 112) & 2) == 0)
        {
          *(unsigned char *)(v3 + 112) |= 2u;
          __darwin_time_t v36 = *(void *)(v3 + 120);
          *(void *)&propertyValueTypeRefPtr.st_dev = MEMORY[0x1E4F143A8];
          propertyValueTypeRefPtr.st_ino = 3221225472;
          *(void *)&propertyValueTypeRefPtr.st_uuint64_t id = ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8227;
          *(void *)&propertyValueTypeRefPtr.st_rdev = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
          propertyValueTypeRefPtr.st_atimespec.tv_sec = v36;
          uint64_t v37 = *(void *)(v3 + 96);
          if (v37)
          {
            uint64_t v38 = (*(uint64_t (**)(void))(*(void *)v37 + 16))(*(void *)(v3 + 96));
            uint64_t v39 = (void *)MEMORY[0x18531D6D0](v38);
            (*(void (**)(stat *, void))&propertyValueTypeRefPtr.st_uid)(&propertyValueTypeRefPtr, *(void *)(v3 + 96));
            (*(void (**)(uint64_t))(*(void *)v37 + 24))(v37);
          }
        }
        ssize_t v40 = read(v19, &propertyValueTypeRefPtr, 0x4000uLL);
        if (v40 == -1)
        {
          int v56 = *__error();
          switch(v56)
          {
            case 2:
              CFIndex v21 = -1100;
              break;
            case 13:
              CFIndex v21 = -1102;
              break;
            case 21:
              CFIndex v21 = -1101;
              break;
            default:
              CFIndex v21 = v56;
              break;
          }
        }
        else
        {
          CFAllocatorRef v41 = CFGetAllocator((CFTypeRef)(v3 - 16));
          CFDataRef v42 = CFDataCreate(v41, (const UInt8 *)&propertyValueTypeRefPtr, v40);
          CFDataRef v43 = v42;
          if (v42)
          {
            long long v44 = *(Throttler **)(v3 + 64);
            if (v44)
            {
              CFIndex Length = CFDataGetLength(v42);
              Throttler::noteOutstandingBytes(v44, Length);
            }
          }
          valuePtr[0] = MEMORY[0x1E4F143A8];
          valuePtr[1] = 3221225472;
          double v64 = ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke_8228;
          CFDateRef v65 = &__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
          CFDataRef v66 = v43;
          ssize_t v67 = v40;
          uint64_t v46 = *(void *)(v3 + 96);
          if (v46)
          {
            uint64_t v47 = (*(uint64_t (**)(void))(*(void *)v46 + 16))(*(void *)(v3 + 96));
            std::__split_buffer<std::string> v48 = (void *)MEMORY[0x18531D6D0](v47);
            v64((uint64_t)valuePtr, *(void *)(v3 + 96));
            (*(void (**)(uint64_t))(*(void *)v46 + 24))(v46);
          }
          if (v43) {
            CFRelease(v43);
          }
          URLProtocol::sendDidFinishLoading((URLProtocol *)v3);
          CFIndex v21 = 0;
        }
      }
      else
      {
        CFIndex v21 = -1104;
      }
      close(v19);
LABEL_52:
      if (!v21) {
        return;
      }
      goto LABEL_59;
    }
    CFIndex v21 = *v20;
    switch(v21)
    {
      case 2:
LABEL_58:
        CFIndex v21 = -1100;
        break;
      case 0xD:
        CFIndex v21 = -1102;
        break;
      case 0x15:
        CFIndex v21 = -1101;
        break;
      default:
        goto LABEL_52;
    }
LABEL_59:
    CFAllocatorRef v49 = CFGetAllocator((CFTypeRef)(v3 - 16));
    uint64_t v55 = __cfnCreateCFError(v49, @"kCFErrorDomainCFNetwork", v21, v50, v51, v52, v53, v54, 0);
    URLProtocol::sendDidFail((URLProtocol *)v3, v55);
    if (v55) {
      CFRelease(v55);
    }
    return;
  }
  *(void *)(v3 + 136) = 0;
  CFAllocatorRef v22 = CFGetAllocator((CFTypeRef)(v3 - 16));
  uint64_t v23 = CFReadStreamCreateWithFile(v22, v4);
  *(void *)(v3 + 128) = v23;
  if (!v23)
  {
    CFAllocatorRef v29 = CFGetAllocator((CFTypeRef)(v3 - 16));
    CFCFStreamError Error = __cfnCreateCFError(v29, @"kCFErrorDomainCFNetwork", -998, v30, v31, v32, v33, v34, 0);
    URLProtocol::sendDidFail((URLProtocol *)v3, CFError);
    if (!CFError) {
      return;
    }
LABEL_10:
    CFRelease(CFError);
    return;
  }
  *(void *)&propertyValueTypeRefPtr.st_dev = 0;
  propertyValueTypeRefPtr.st_ino = v3;
  memset(&propertyValueTypeRefPtr.st_uid, 0, 24);
  CFReadStreamSetClient(v23, 0x1BuLL, (CFReadStreamClientCallBack)FileURLProtocol::_fileReadStreamCB, (CFStreamClientContext *)&propertyValueTypeRefPtr);
  CoreSchedulingSet::_scheduleStream(*(void *)(v3 + 24), *(void *)(v3 + 128), MEMORY[0x1E4F1C268], MEMORY[0x1E4F1C260]);
  if (!CFReadStreamOpen(*(CFReadStreamRef *)(v3 + 128)))
  {
    uint64_t v24 = CFReadStreamCopyError(*(CFReadStreamRef *)(v3 + 128));
    CFDataRef v25 = v24;
    if (!v24)
    {
      URLProtocol::sendDidFail((URLProtocol *)v3, 0);
      return;
    }
    CFStringRef Domain = CFErrorGetDomain(v24);
    if (CFStringCompare((CFStringRef)*MEMORY[0x1E4F1D160], Domain, 0)
      || ((CFIndex Code = CFErrorGetCode(v25), Code == 2)
        ? (CFIndex v28 = -1100)
        : Code == 13
        ? (CFIndex v28 = -1102)
        : Code != 21
        ? (CFIndex v28 = (int)Code)
        : (CFIndex v28 = -1101),
          Code == v28))
    {
      URLProtocol::sendDidFail((URLProtocol *)v3, v25);
    }
    else
    {
      CFRelease(v25);
      CFAllocatorRef v57 = CFGetAllocator((CFTypeRef)(v3 - 16));
      CFDataRef v25 = __cfnCreateCFError(v57, @"kCFErrorDomainCFNetwork", v28, v58, v59, v60, v61, v62, 0);
      URLProtocol::sendDidFail((URLProtocol *)v3, v25);
      if (!v25) {
        return;
      }
    }
    CFRelease(v25);
  }
}

uint64_t FilePathStorage<unsigned char>::FilePathStorage(uint64_t a1, CFURLRef url, int a3, int a4, Boolean a5)
{
  *(unsigned char *)a1 = CFURLGetFileSystemRepresentation(url, a5, (UInt8 *)(a1 + 1), 1024);
  *(_DWORD *)(a1 + 1028) = a3;
  CFURLRef v9 = (const __CFURL *)CFCopyHomeDirectoryURLForUser();
  if (!v9)
  {
    *(_DWORD *)(a1 + 1032) = a4;
    return a1;
  }
  CFURLRef v10 = v9;
  CFURLRef v11 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9, @"Library/Cookies", 1u);
  CFAllocatorRef v12 = CFGetAllocator(url);
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(v12, url);
  if (PathComponent && v11)
  {
    CFStringRef v14 = CFURLGetString(v11);
    CFStringRef v15 = CFURLGetString(PathComponent);
    if (CFStringCompare(v14, v15, 1uLL)) {
      int v16 = a4;
    }
    else {
      int v16 = 1;
    }
    *(_DWORD *)(a1 + 1032) = v16;
    goto LABEL_10;
  }
  *(_DWORD *)(a1 + 1032) = a4;
  if (v11) {
LABEL_10:
  }
    CFRelease(v11);
  if (PathComponent) {
    CFRelease(PathComponent);
  }
  CFRelease(v10);
  return a1;
}

id CFURLResponseCreate(uint64_t a1, const void *a2, const __CFString *a3, uint64_t a4, const __CFString *a5, int a6)
{
  CFURLRef v11 = objc_alloc_init(NSURLResponseInternal);
  URLResponse::initialize((uint64_t)[(NSURLResponseInternal *)v11 _inner], a2, a3, a4, a5, a6);
  id v12 = [[NSURLResponse alloc] _initWithInternal:v11];

  return v12;
}

void *URLResponse::initialize(uint64_t a1, CFTypeRef cf, const __CFString *a3, uint64_t a4, const __CFString *a5, int a6)
{
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (cf) {
    uint64_t result = (void *)CFRetain(cf);
  }
  else {
    uint64_t result = 0;
  }
  *(void *)(a1 + 8) = result;
  if (a3)
  {
    uint64_t result = (void *)CFStringCreateCopy(v11, a3);
    *(void *)(a1 + 16) = result;
  }
  if (a5)
  {
    uint64_t result = (void *)CFStringCreateCopy(v11, a5);
    *(void *)(a1 + 24) = result;
  }
  *(void *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 72) = a6;
  return result;
}

uint64_t ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke_8227(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 64))(a2, *(void *)(a1 + 32));
}

uint64_t ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke_8228(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 72))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
}

void MemoryCookies::mergeCookiesFrom(CFAllocatorRef *this, const MemoryCookies *a2)
{
  if (CFDictionaryGetCount(this[3]))
  {
    CFDictionaryRef v4 = (const __CFDictionary *)*((void *)a2 + 3);
    CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)MemoryCookies::_mergeCookiesFrom, this);
  }
  else
  {
    CFAllocatorRef v5 = this[3];
    this[3] = CFDictionaryCreateMutableCopy(this[1], 0, *((CFDictionaryRef *)a2 + 3));
    if (v5)
    {
      CFRelease(v5);
    }
  }
}

void DiskCookieStorage::readFileToCookies(DiskCookieStorage *this, MemoryCookies *a2)
{
  v28[19] = *MEMORY[0x1E4F143B8];
  *((unsigned char *)this + 324) = 0;
  CFAllocatorRef v4 = (const __CFAllocator *)*((void *)this + 1);
  CFAllocatorRef v5 = (const char *)(*((void *)this + 9) + 1);
  size_t v6 = strlen(v5);
  CFURLRef v7 = CFURLCreateFromFileSystemRepresentation(v4, (const UInt8 *)v5, v6, 0);
  CFStringRef v8 = CFReadStreamCreateWithFile(*((CFAllocatorRef *)this + 1), v7);
  CFRelease(v7);
  if (v8)
  {
    if (CFReadStreamOpen(v8))
    {
      CFDataRef data = 0;
      CFURLRef v9 = (const void *)(*(uint64_t (**)(DiskCookieStorage *, __CFReadStream *, MemoryCookies *, CFDataRef *))(*(void *)this + 216))(this, v8, a2, &data);
      CFReadStreamClose(v8);
      if (data)
      {
        CFDictionaryRef v10 = (const __CFDictionary *)CFPropertyListCreateWithData(*((CFAllocatorRef *)this + 1), data, 0, 0, 0);
        CFDictionaryRef v11 = v10;
        if (v10)
        {
          CFTypeID v12 = CFGetTypeID(v10);
          if (v12 == CFDictionaryGetTypeID())
          {
            CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v11, @"NSHTTPCookieAcceptPolicy");
            CFNumberRef v14 = Value;
            if (Value)
            {
              CFTypeID v15 = CFGetTypeID(Value);
              if (v15 == CFNumberGetTypeID())
              {
                valuePtr[0].st_dev = 0;
                CFNumberGetValue(v14, kCFNumberIntType, valuePtr);
                *((_DWORD *)this + 80) = valuePtr[0].st_dev;
              }
            }
          }
          CFRelease(v11);
        }
        if (data) {
          CFRelease(data);
        }
        if (!v9) {
          goto LABEL_22;
        }
        goto LABEL_15;
      }
      *((_DWORD *)this + 80) = 2;
      if (v9)
      {
LABEL_15:
        if (!lstat((const char *)(*((void *)this + 9) + 1), valuePtr))
        {
          long long v20 = "readFileToCookies";
          int v21 = 0;
          CFDataRef v25 = 0;
          CFTypeRef cf = 0;
          uint64_t v23 = 0;
          int v24 = 0;
          TracerData::set((TracerData *)&v20, 0, v9, "CantParseData", 352, (const char *)(*((void *)this + 9) + 1));
          DiskCookieStorage::traceError(this, (const TracerData *)&v20);
          CFAllocatorRef v16 = (const __CFAllocator *)*((void *)this + 1);
          v28[0] = off_1ECF9A530;
          CFStringRef v17 = CFStringCreateWithCString(v16, " - corrupt", 0x8000100u);
          uint64_t v28[2] = 0;
          v28[3] = 0;
          v28[1] = v17;
          FilePath::FilePath((uint64_t)valuePtr, *((void *)this + 9), (uint64_t)v17);
          rename((const std::__fs::filesystem::path *)(*((void *)this + 9) + 1), (const std::__fs::filesystem::path *)((char *)&valuePtr[0].st_dev + 1), v18);
          if (v19 < 0) {
            __error();
          }
          AutoString::~AutoString((AutoString *)v28);
          if (cf) {
            CFRelease(cf);
          }
          free(v25);
        }
        CFRelease(v9);
      }
    }
LABEL_22:
    CFRelease(v8);
  }
}

void sub_18415D894(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  AutoString::~AutoString((AutoString *)(v2 - 224));
  TracerData::clearError((TracerData *)va);
  _Unwind_Resume(a1);
}

os_log_t ___ZL15H2CoalescingLogv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.CFNetwork", "Coalescing");
  H2CoalescingLog(void)::onceLog = (uint64_t)result;
  return result;
}

CFIndex ___ZN20StrictSecurityPolicy11ATSLogLevelEv_block_invoke()
{
  Boolean keyExistsAndHasValidFormat = 0;
  CFIndex result = CFPreferencesGetAppIntegerValue(@"com.apple.cfnetwork.ats.loglevel", (CFStringRef)*MEMORY[0x1E4F1D3B8], &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
  {
    if (result == 1)
    {
      int v1 = 1;
    }
    else
    {
      if (result != 2) {
        return result;
      }
      int v1 = 2;
    }
    StrictSecurityPolicy::ATSLogLevel(void)::atslogLevel = v1;
  }
  return result;
}

uint64_t ___ZN13HTTPUtilities15isHeaderAllowedEPK10__CFString_block_invoke()
{
  uint64_t result = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CAD0]), "initWithObjects:", 0x1EC0A2000, 0x1EC0A23F0, 0x1EC0A2690, 0x1EC0A29D8, 0x1EC0A2310, 0);
  HTTPUtilities::isHeaderAllowed(__CFString const*)::disallowed = result;
  return result;
}

void ___ZN11WeakTrackerI19TransportConnectionE15_trackedObjectsEv_block_invoke()
{
}

void HSTSCache::~HSTSCache(HSTSCache *this)
{
  *(void *)this = &unk_1ECFA5BD8;
  *((void *)this + 1) = &unk_1ECFA5C20;
  dispatch_release(*((dispatch_object_t *)this + 2));
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    dispatch_release(v2);
  }
  __darwin_ino64_t v3 = *((void *)this + 4);
  if (v3) {
    dispatch_source_cancel(v3);
  }
  uint64_t v4 = *((void *)this + 5);
  if (v4 >= 1)
  {
    do
    {
      *((void *)this + 5) = --v4;
      if (!v4)
      {
        CFAllocatorRef v5 = *((void *)this + 4);
        if (!v5) {
          goto LABEL_12;
        }
        dispatch_resume(v5);
        uint64_t v4 = *((void *)this + 5);
      }
    }
    while (v4 > 0);
  }
  size_t v6 = *((void *)this + 4);
  if (v6) {
    dispatch_release(v6);
  }
LABEL_12:
  CFURLRef v7 = (const void *)*((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v7) {
    CFRelease(v7);
  }
  CFStringRef v8 = (const void *)*((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v8) {
    CFRelease(v8);
  }
  CFURLRef v9 = (const void *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v9) {
    CFRelease(v9);
  }
  *((void *)this + 1) = &unk_1ECF9B550;
}

void HSTSPolicy::~HSTSPolicy(HSTSPolicy *this)
{
  *(void *)this = &unk_1ECF9A620;
  *((void *)this + 1) = &unk_1ECF9A668;
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    if (!*(unsigned char *)(v2 + 73)
      || !os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
      || (*(_WORD *)__darwin_ino64_t v3 = 0,
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Non-private, global HSTS policy is being destroyed.", v3, 2u), (uint64_t v2 = *((void *)this + 2)) != 0))
    {
      CFRelease((CFTypeRef)(v2 - 16));
    }
  }
  *((void *)this + 1) = &unk_1ECF9B550;
}

void sub_18415E390(_Unwind_Exception *a1)
{
  *int v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void URLResponse::guessMIMEType(URLResponse *this, const __CFData *a2)
{
  fMIMEType = this->fMIMEType;
  if (!fMIMEType || !CFStringGetLength(fMIMEType)) {
    goto LABEL_36;
  }
  int CanonicalString = _findCanonicalString(this->fMIMEType, 0xBu);
  if (CanonicalString <= 531708793)
  {
    if (CanonicalString <= 527514468)
    {
      if (CanonicalString != 497056307 && CanonicalString != 510818999)
      {
        int v6 = 521272127;
        goto LABEL_22;
      }
LABEL_36:
      CFStringRef v15 = (const __CFString *)copyMIMETypeForUnknown(a2);
LABEL_134:
      CFStringRef v9 = v15;
      goto LABEL_135;
    }
    if (CanonicalString != 527514469 && CanonicalString != 528563050 && CanonicalString != 529619823)
    {
LABEL_120:
      MIMETypeForRuleArray = this->fMIMEType;
      if (MIMETypeForRuleArray) {
        goto LABEL_133;
      }
      goto LABEL_18;
    }
LABEL_15:
    CFURLRef v7 = this->fMIMEType;
    MIMETypeForRuleArray = getMIMETypeForRuleArray(a2, sImageTypeRules, 0);
    if (!MIMETypeForRuleArray) {
      MIMETypeForRuleArray = v7;
    }
    if (MIMETypeForRuleArray) {
      goto LABEL_133;
    }
LABEL_18:
    CFStringRef v9 = 0;
    goto LABEL_135;
  }
  if (CanonicalString > 544299977)
  {
    if (CanonicalString != 544299978)
    {
      if (CanonicalString == 549583855) {
        goto LABEL_36;
      }
      int v6 = 548477930;
      goto LABEL_22;
    }
    if (!a2)
    {
      MIMETypeForRuleArray = &unk_1EC0A53A0;
      goto LABEL_133;
    }
    CFIndex Length = CFDataGetLength(a2);
    if (Length >= 512) {
      uint64_t v37 = 512;
    }
    else {
      uint64_t v37 = Length;
    }
    BytePtr = CFDataGetBytePtr(a2);
    if (v37 > 2)
    {
      if (*(__int16 *)BytePtr == -2 || *(__int16 *)BytePtr == -257)
      {
        CFDataRef MIMETypeForComplexNonScriptableTypeRules = (const __CFData *)&unk_1EC0A53A0;
      }
      else
      {
        CFDataRef MIMETypeForComplexNonScriptableTypeRules = (const __CFData *)&unk_1EC0A53A0;
        if (*(unsigned __int16 *)BytePtr ^ 0xBBEF | BytePtr[2] ^ 0xBF) {
          goto LABEL_126;
        }
      }
LABEL_130:
      if (MIMETypeForComplexNonScriptableTypeRules) {
        MIMETypeForRuleArray = MIMETypeForComplexNonScriptableTypeRules;
      }
      else {
        MIMETypeForRuleArray = &unk_1EC0A4B50;
      }
      goto LABEL_133;
    }
    CFDataRef MIMETypeForComplexNonScriptableTypeRules = (const __CFData *)&unk_1EC0A53A0;
LABEL_126:
    if (!isAllText(a2))
    {
      CFDataRef MIMETypeForComplexNonScriptableTypeRules = getMIMETypeForRuleArray(a2, sNonScriptableTypeRules, 0);
      if (!MIMETypeForComplexNonScriptableTypeRules)
      {
        CFDataRef MIMETypeForComplexNonScriptableTypeRules = getMIMETypeForRuleArray(a2, sImageTypeRules, 0);
        if (!MIMETypeForComplexNonScriptableTypeRules) {
          CFDataRef MIMETypeForComplexNonScriptableTypeRules = (const __CFData *)getMIMETypeForComplexNonScriptableTypeRules(a2);
        }
      }
    }
    goto LABEL_130;
  }
  if (CanonicalString == 531708794 || CanonicalString == 536026001) {
    goto LABEL_15;
  }
  int v6 = 542194621;
LABEL_22:
  if (CanonicalString != v6) {
    goto LABEL_120;
  }
  if (this->fMIMEType) {
    CFStringRef v9 = this->fMIMEType;
  }
  else {
    CFStringRef v9 = (const __CFString *)&unk_1EC0A5330;
  }
  if (!a2) {
    goto LABEL_109;
  }
  CFIndex v10 = CFDataGetLength(a2);
  if (v10 >= 512) {
    uint64_t v11 = 512;
  }
  else {
    uint64_t v11 = v10;
  }
  CFTypeID v12 = CFDataGetBytePtr(a2);
  uint64_t v13 = v12;
  if (v11 >= 3 && *v12 == 239 && v12[1] == 187)
  {
    if (v12[2] == 191) {
      uint64_t v14 = 3;
    }
    else {
      uint64_t v14 = 0;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  if (v14 >= v11) {
    goto LABEL_106;
  }
  CFAllocatorRef v16 = v12 + 2;
  while (1)
  {
    while (1)
    {
      if ((char)v12[v14] <= 0x20 && ((1 << v12[v14]) & 0x100002600) != 0)
      {
        uint64_t v18 = v14 + 1;
        goto LABEL_45;
      }
      if (v12[v14] != 60 || v14 + 3 >= v11) {
        goto LABEL_106;
      }
      uint64_t v18 = v14 + 1;
      int v19 = &v12[v14 + 1];
      if (*(_WORD *)v19 != 11553 || v19[2] != 45) {
        break;
      }
      if (v14 + 6 >= v11) {
        goto LABEL_106;
      }
      v14 += 4;
      while (*(_WORD *)&v12[v14] != 11565 || v12[v14 + 2] != 62)
      {
        uint64_t v25 = v14 + 3;
        ++v14;
        if (v25 >= v11) {
          goto LABEL_106;
        }
      }
LABEL_57:
      v14 += 3;
LABEL_61:
      if (v14 >= v11) {
        goto LABEL_106;
      }
    }
    int v21 = *v19;
    if (v21 == 33)
    {
      do
      {
        if (v14 + 2 >= v11) {
          goto LABEL_106;
        }
        int v23 = v16[v14++];
      }
      while (v23 != 62);
      v14 += 2;
      goto LABEL_61;
    }
    if (v21 == 63)
    {
      while (v14 + 3 < v11)
      {
        int v22 = *(unsigned __int16 *)&v16[v14++];
        if (v22 == 15935) {
          goto LABEL_57;
        }
      }
LABEL_106:
      CFStringRef v34 = 0;
      goto LABEL_107;
    }
    if (*(_WORD *)v19 == 29554 && v19[2] == 115) {
      break;
    }
    if (v14 + 4 >= v11) {
      goto LABEL_106;
    }
    if (*(_DWORD *)v19 == 1684366694)
    {
      CFNumberRef v35 = &kCFMIMETypeApplicationAtomXML;
      goto LABEL_169;
    }
    if (v14 + 7 >= v11) {
      goto LABEL_106;
    }
    int v27 = *(_DWORD *)v19;
    int v28 = *(_DWORD *)(v19 + 3);
    if (v27 == 979788914 && v28 == 1178882618)
    {
      int v30 = 0;
      int v31 = 0;
      while (1)
      {
        if (v31)
        {
          int v31 = 1;
        }
        else
        {
          if (v18 + 23 >= v11) {
            goto LABEL_106;
          }
          if (*(void *)&v13[v18] == 0x702F2F3A70747468
            && *(void *)&v13[v18 + 8] == 0x2F67726F2E6C7275
            && *(void *)&v13[v18 + 16] == 0x2F302E312F737372)
          {
            int v31 = 1;
            v18 += 23;
          }
          else
          {
            int v31 = 0;
          }
        }
        if (v30)
        {
          if (v31) {
            goto LABEL_105;
          }
        }
        else
        {
          if (v18 + 42 >= v11) {
            goto LABEL_106;
          }
          if (memcmp(&v13[v18], "http://www.w3.org/1999/02/22-rdf-syntax-ns#", 0x2BuLL))
          {
            int v30 = 0;
            goto LABEL_102;
          }
          v18 += 42;
          if (v31) {
            goto LABEL_105;
          }
        }
        int v30 = 1;
LABEL_102:
        CFStringRef v34 = 0;
        if (++v18 >= v11) {
          goto LABEL_107;
        }
      }
    }
LABEL_45:
    uint64_t v14 = v18;
    if (v18 >= v11) {
      goto LABEL_106;
    }
  }
LABEL_105:
  CFNumberRef v35 = &kCFMIMETypeApplicationRSSXML;
LABEL_169:
  CFStringRef v34 = (const __CFString *)*v35;
LABEL_107:
  if (v34) {
    CFStringRef v9 = v34;
  }
LABEL_109:
  if (v9)
  {
    MIMETypeForRuleArray = v9;
LABEL_133:
    CFStringRef v15 = (const __CFString *)CFRetain(MIMETypeForRuleArray);
    goto LABEL_134;
  }
LABEL_135:
  fURL = this->fURL;
  if (fURL)
  {
    CFStringRef v41 = CFURLCopyScheme(fURL);
    if (v41)
    {
      CFStringRef v42 = v41;
      if (_findCanonicalString(v41, 0xFu) != 588283320) {
        goto LABEL_151;
      }
      int v43 = _findCanonicalString(v9, 0xBu);
      if (v43 != 544299978 && v43 != 504568436) {
        goto LABEL_151;
      }
      CFStringRef v44 = URLResponse::copySuggestedFilename(this);
      if (v44)
      {
        CFStringRef v45 = v44;
        CFStringRef v46 = copyExtensionFromName(v44);
        CFRelease(v45);
        if (!v46)
        {
LABEL_151:
          CFRelease(v42);
          goto LABEL_152;
        }
      }
      else
      {
        uint64_t v47 = this->fURL;
        if (!v47) {
          goto LABEL_151;
        }
        CFStringRef v46 = _CFURLCopyPathExtension_WorksWithMoreSchemes(v47);
        if (!v46) {
          goto LABEL_151;
        }
      }
      if (CFStringGetLength(v46) >= 1 && (CFStringRef v48 = copyMIMETypeForExtension(v46)) != 0)
      {
        CFStringRef v49 = v48;
        if (v9) {
          CFRelease(v9);
        }
      }
      else
      {
        CFStringRef v49 = v9;
      }
      CFRelease(v46);
      CFStringRef v9 = v49;
      goto LABEL_151;
    }
  }
LABEL_152:
  if (!v9)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v53 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Sniffing on a resource resulted in a NULL MIME type, which means the sniffing algorithm was coded incorrectly", v53, 2u);
    }
    uint64_t v50 = this->fMIMEType;
    if (!v50) {
      uint64_t v50 = (__CFString *)&unk_1EC0A4B50;
    }
    CFStringRef v9 = (const __CFString *)CFRetain(v50);
  }
  uint64_t v51 = this->fMIMEType;
  if (v51 != v9)
  {
    if (v51) {
      CFRelease(v51);
    }
    if (v9) {
      uint64_t v52 = (__CFString *)CFRetain(v9);
    }
    else {
      uint64_t v52 = 0;
    }
    this->fMIMEType = v52;
  }
  if (v9) {
    CFRelease(v9);
  }
}

CFTypeRef copyMIMETypeForUnknown(const __CFData *a1)
{
  if (a1)
  {
    CFDataRef MIMETypeForRuleArray = getMIMETypeForRuleArray(a1, sScriptableTypeRules, 1);
    if (!MIMETypeForRuleArray)
    {
      CFDataRef MIMETypeForRuleArray = getMIMETypeForRuleArray(a1, sNonScriptableTypeRules, 1);
      if (!MIMETypeForRuleArray)
      {
        CFDataRef MIMETypeForRuleArray = getMIMETypeForRuleArray(a1, sImageTypeRules, 1);
        if (!MIMETypeForRuleArray)
        {
          CFDataRef MIMETypeForRuleArray = (const __CFData *)getMIMETypeForComplexNonScriptableTypeRules(a1);
          if (!MIMETypeForRuleArray)
          {
            if (isAllText(a1)) {
              CFDataRef MIMETypeForRuleArray = (const __CFData *)&unk_1EC0A53A0;
            }
            else {
              CFDataRef MIMETypeForRuleArray = 0;
            }
          }
        }
      }
    }
    if (!MIMETypeForRuleArray) {
      CFDataRef MIMETypeForRuleArray = (const __CFData *)&unk_1EC0A4B50;
    }
  }
  else
  {
    CFDataRef MIMETypeForRuleArray = (const __CFData *)&unk_1EC0A53A0;
  }

  return CFRetain(MIMETypeForRuleArray);
}

CFDataRef getMIMETypeForRuleArray(const __CFData *result, void *a2, int a3)
{
  if (result)
  {
    CFDataRef v5 = result;
    CFIndex Length = CFDataGetLength(result);
    uint64_t v25 = Length;
    if (Length >= 512) {
      uint64_t v7 = 512;
    }
    else {
      uint64_t v7 = Length;
    }
    CFStringRef v8 = a2 + 1;
    if (!a2[1]) {
      return 0;
    }
    uint64_t v9 = 0;
    uint64_t v24 = 0;
    CFIndex v10 = 0;
    int v26 = 0;
    if (v7 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = v7;
    }
    CFTypeID v12 = a2;
    while (1)
    {
      uint64_t v13 = &a2[4 * v9];
      uint64_t v15 = v13[2];
      uint64_t v14 = v13 + 2;
      if (v7 >= v15)
      {
        BytePtr = CFDataGetBytePtr(v5);
        int v17 = *(unsigned __int8 *)*v8;
        if (v17 == 60)
        {
          if (v26)
          {
            if (!v10) {
              goto LABEL_35;
            }
          }
          else
          {
            if (v25 < 1) {
              goto LABEL_34;
            }
            uint64_t v22 = 0;
            while (1)
            {
              CFIndex v10 = &BytePtr[v22];
              if ((char)BytePtr[v22] > 0x20 || ((1 << BytePtr[v22]) & 0x100003600) == 0) {
                break;
              }
              if (v11 == ++v22) {
                goto LABEL_34;
              }
            }
            if (BytePtr[v22] != 60)
            {
LABEL_34:
              CFIndex v10 = 0;
LABEL_35:
              int v26 = 1;
              goto LABEL_41;
            }
            uint64_t v24 = v7 - v22;
          }
          uint64_t v18 = *v14;
          int v26 = 1;
          BytePtr = v10;
          if (v24 < *v14) {
            goto LABEL_41;
          }
        }
        else
        {
          uint64_t v18 = *v14;
        }
        uint64_t v19 = 0;
        if (v18 >= 1)
        {
          while (1)
          {
            if (a3)
            {
              int v20 = BytePtr[v19];
              if (*v12) {
                int v20 = (*(unsigned char *)(*v12 + v19) & v20);
              }
            }
            else
            {
              int v20 = BytePtr[v19];
            }
            int v21 = *(unsigned __int8 *)(*v8 + v19);
            if (v17 == 60 && v20 != v21) {
              break;
            }
            if (v20 != v21) {
              goto LABEL_40;
            }
            if (v18 == ++v19) {
              return (const __CFData *)&gConstantCFStringValueTable[7 * ((LODWORD(a2[4 * v9 + 3]) >> 20) & 0x3FF)];
            }
          }
          if (v18 - 1 == v19 && v21 == 32 && (v20 == 32 || v20 == 62)) {
            return (const __CFData *)&gConstantCFStringValueTable[7 * ((LODWORD(a2[4 * v9 + 3]) >> 20) & 0x3FF)];
          }
        }
LABEL_40:
        if (v19 == v18) {
          return (const __CFData *)&gConstantCFStringValueTable[7 * ((LODWORD(a2[4 * v9 + 3]) >> 20) & 0x3FF)];
        }
      }
LABEL_41:
      ++v9;
      CFTypeID v12 = &a2[4 * v9];
      CFStringRef v8 = v12 + 1;
      if (!v12[1]) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t isAllText(const __CFData *a1)
{
  CFIndex Length = CFDataGetLength(a1);
  if (Length < 1) {
    return 1;
  }
  if (Length >= 512) {
    uint64_t v3 = 512;
  }
  else {
    uint64_t v3 = Length;
  }
  BytePtr = CFDataGetBytePtr(a1);
  unint64_t v5 = (unint64_t)&BytePtr[v3 - 1];
  while (1)
  {
    unsigned int v6 = *BytePtr;
    BOOL v7 = (v6 & 0xFC) != 0x1C && v6 >= 9;
    BOOL v8 = !v7 || v6 == 11;
    if (v8 || v6 - 14 <= 0xC) {
      break;
    }
    if ((unint64_t)++BytePtr > v5) {
      return 1;
    }
  }
  return 0;
}

uint64_t getMIMETypeForComplexNonScriptableTypeRules(const __CFData *a1)
{
  CFIndex Length = CFDataGetLength(a1);
  if (Length >= 512) {
    uint64_t v3 = 512;
  }
  else {
    uint64_t v3 = Length;
  }
  BytePtr = CFDataGetBytePtr(a1);
  if (v3 < 4) {
    goto LABEL_56;
  }
  if (*(_WORD *)BytePtr == 17481 && BytePtr[2] == 51)
  {
    if (*((char *)BytePtr + 3) >= 32) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = 0x1EC0A4FB0;
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  BOOL v7 = (unint64_t)v3 > 7;
  if (!v6 && (unint64_t)v3 >= 8)
  {
    if (*((_DWORD *)BytePtr + 1) == 1987014509
      || *((_DWORD *)BytePtr + 1) == 1952539757
      || *((_DWORD *)BytePtr + 1) == 1701079415)
    {
      uint64_t v6 = 0x1EC0A5608;
    }
    else
    {
      uint64_t v6 = 0;
    }
  }
  BOOL v8 = (unint64_t)v3 > 0xB;
  if (!v6 && (unint64_t)v3 >= 0xC)
  {
    if (*BytePtr || BytePtr[1] || *((_DWORD *)BytePtr + 1) != 1887007846) {
      goto LABEL_25;
    }
    if (*((_WORD *)BytePtr + 4) == 28781 && BytePtr[10] == 52)
    {
      if (BytePtr[11] - 49 >= 2) {
        uint64_t v6 = 0;
      }
      else {
        uint64_t v6 = 0x1EC0A55D0;
      }
      goto LABEL_26;
    }
    if (*((_WORD *)BytePtr + 4) == 29545 && BytePtr[10] == 111)
    {
      int v16 = BytePtr[11];
      if (v16 == 109 || v16 == 50)
      {
        uint64_t v15 = &kCFMIMETypeVideoMP4;
        goto LABEL_118;
      }
LABEL_25:
      uint64_t v6 = 0;
LABEL_26:
      BOOL v8 = 1;
LABEL_27:
      BOOL v7 = 1;
      goto LABEL_28;
    }
    if (*((_WORD *)BytePtr + 4) != 13389 || BytePtr[10] != 86)
    {
      if (*((_DWORD *)BytePtr + 2) == 541144141)
      {
        uint64_t v15 = &kCFMIMETypeAudioMP4;
        goto LABEL_118;
      }
      if (*((_WORD *)BytePtr + 4) == 26419)
      {
        if (*((_WORD *)BytePtr + 5) == 24882)
        {
          uint64_t v15 = &kCFMIMETypeVideo3GPP2;
          goto LABEL_118;
        }
        if (BytePtr[10] - 101 <= 0xE
          && (BytePtr[11] & 0xFC) == 0x34
          && (*((_WORD *)BytePtr + 5) == 13925
           || *((_WORD *)BytePtr + 5) == 14181
           || *((_WORD *)BytePtr + 5) == 13927
           || *((_WORD *)BytePtr + 5) == 13424
           || *((_WORD *)BytePtr + 5) == 13680
           || *((_WORD *)BytePtr + 5) == 13936
           || *((_WORD *)BytePtr + 5) == 13938
           || *((_WORD *)BytePtr + 5) == 13939
           || *((_WORD *)BytePtr + 5) == 14195))
        {
          uint64_t v15 = &kCFMIMETypeVideo3GPP;
LABEL_118:
          uint64_t v6 = *v15;
          goto LABEL_26;
        }
      }
      goto LABEL_25;
    }
    uint64_t v6 = 0;
    BOOL v8 = 1;
    unsigned int v17 = BytePtr[11] - 32;
    if (v17 > 0x30) {
      goto LABEL_27;
    }
    uint64_t v18 = 1 << v17;
    BOOL v7 = 1;
    if ((v18 & 0x1010000000001) != 0) {
      uint64_t v6 = 0x1EC0A5598;
    }
  }
LABEL_28:
  if (!v6 && v8)
  {
    if (*(_DWORD *)BytePtr == 1179011410)
    {
      if (*((_DWORD *)BytePtr + 2) == 1163280727)
      {
        uint64_t v6 = 0x1EC0A4FE8;
      }
      else if (*((_DWORD *)BytePtr + 2) == 541677121)
      {
        uint64_t v6 = 0x1EC0A5560;
      }
      else
      {
        uint64_t v6 = 0;
      }
    }
    else
    {
      uint64_t v6 = 0;
    }
  }
  if (v6) {
    BOOL v8 = 0;
  }
  if (v8)
  {
    if (*(_DWORD *)BytePtr == 1297239878 && *((_WORD *)BytePtr + 4) == 18753 && BytePtr[10] == 70)
    {
      int v11 = BytePtr[11];
      if (v11 == 70 || v11 == 67)
      {
        uint64_t v6 = 0x1EC0A4F40;
        goto LABEL_51;
      }
    }
    uint64_t v6 = 0;
  }
  if (v6 || (unint64_t)v3 < 5) {
    goto LABEL_51;
  }
  if (!BytePtr[3] && !BytePtr[4])
  {
    if (BytePtr[1])
    {
      if (BytePtr[1] != 1 || (BytePtr[2] & 0xF7) != 1) {
        goto LABEL_50;
      }
    }
    else if ((BytePtr[2] & 0xF6) != 2)
    {
      goto LABEL_50;
    }
    uint64_t v6 = 0x1EC0A51A8;
    goto LABEL_51;
  }
LABEL_50:
  uint64_t v6 = 0;
LABEL_51:
  if (v6) {
    BOOL v7 = 0;
  }
  if (!v7) {
    goto LABEL_57;
  }
  if (*((_DWORD *)BytePtr + 1) == 1668506729 || *((_DWORD *)BytePtr + 1) == 1952539753)
  {
    uint64_t v6 = 0x1EC0A5250;
    goto LABEL_62;
  }
LABEL_56:
  uint64_t v6 = 0;
LABEL_57:
  if (!v6 && v3 >= 2)
  {
    if (*(_WORD *)BytePtr == 759) {
      uint64_t v6 = 0x1EC0A4D48;
    }
    else {
      uint64_t v6 = 0;
    }
  }
LABEL_62:
  if (v3 >= 4 && !v6)
  {
    if (*(unsigned __int16 *)BytePtr == 55809 && BytePtr[2] <= 1u)
    {
      if (BytePtr[3] - 1 >= 0xF) {
        return 0;
      }
      else {
        return 0x1EC0A5138;
      }
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

uint64_t __copy_helper_block_e8_48c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t HTTPConnectionCacheEntry::_notifyNextProtocolOfOpenConnection(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*(void *)(*(void *)a2 + 64) + 56);
  (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 88))(v4, 1);
  int v5 = *(_DWORD *)(a1 + 120);
  uint64_t v6 = (v5 - 1);
  if (v5 >= 1)
  {
    do
    {
      if (v6 <= *(int *)(*(void *)a2 + 240))
      {
        if ((v6 & 0x80000000) == 0) {
          goto LABEL_7;
        }
      }
      else
      {
        BOOL hasPendingResponses = HTTPConnection::hasPendingResponses(*(HTTPConnection **)a2);
        if ((v6 & 0x80000000) == 0 && !hasPendingResponses)
        {
LABEL_7:
          uint64_t v8 = *(void *)(*(void *)(a1 + 104) + 8);
          if (v6 <= (unint64_t)((*(void *)(*(void *)(a1 + 104) + 16) - v8) >> 4))
          {
            uint64_t v9 = v8 + 16 * v6;
            int v11 = *(HTTPConnectionCacheEntry::RequestQueue **)v9;
            CFIndex v10 = *(std::__shared_weak_count **)(v9 + 8);
            if (v10) {
              atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            CFAllocatorRef v29 = v10;
            if (v11)
            {
              uint64_t v12 = *((void *)v11 + 2);
              if (*((void *)v11 + 3) - v12 >= 16)
              {
                uint64_t v14 = 0;
                do
                {
                  if (v14 < 0)
                  {
                    unsigned int v17 = 0;
                    int v16 = 0;
                  }
                  else
                  {
                    uint64_t v15 = v12 + 16 * v14;
                    unsigned int v17 = *(HTTPConnectionCacheEntry::EnqueuedRequest **)v15;
                    int v16 = *(atomic_ullong **)(v15 + 8);
                    if (v16) {
                      atomic_fetch_add_explicit(v16 + 1, 1uLL, memory_order_relaxed);
                    }
                  }
                  uint64_t v18 = (*(uint64_t (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(void *)v17 + 80))(v17);
                  if ((*(unsigned int (**)(uint64_t))(*(void *)v18 + 176))(v18))
                  {
                    HTTPConnectionCacheEntry::RequestQueue::removeRequest(v11, v14);
                  }
                  else
                  {
                    uint64_t v19 = *(HTTPConnection **)a2;
                    int v20 = *(std::__shared_weak_count **)(a2 + 8);
                    if (v20) {
                      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    v32[0] = v17;
                    v32[1] = (HTTPConnectionCacheEntry::EnqueuedRequest *)v16;
                    if (v16) {
                      atomic_fetch_add_explicit(v16 + 1, 1uLL, memory_order_relaxed);
                    }
                    BOOL doesConnAuthApply = HTTPConnectionCacheEntry::_doesConnAuthApply(*((void *)v19 + 22), *((std::__shared_weak_count **)v19 + 23), v32);
                    if (v16) {
                      std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v16);
                    }
                    if (v20) {
                      std::__shared_weak_count::__release_shared[abi:nn180100](v20);
                    }
                    if (doesConnAuthApply)
                    {
                      uint64_t v22 = *(void **)(a1 + 112);
                      uint64_t v23 = (*(uint64_t (**)(HTTPConnectionCacheEntry::EnqueuedRequest *))(*(void *)v17 + 80))(v17);
                      uint64_t v24 = HTTPConnectionCacheEntry::EnqueuedRequest::mutableRequest(v17);
                      if (v24)
                      {
                        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
                          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
                        }
                        if (*(unsigned char *)(v24 + 40)) {
                          uint64_t v25 = 0;
                        }
                        else {
                          uint64_t v25 = (HTTPRequestMessage *)(v24 + 16);
                        }
                      }
                      else
                      {
                        uint64_t v25 = 0;
                      }
                      AuthenticationCache::processRequest(v22, v23, v25);
                      HTTPConnectionCacheEntry::RequestQueue::removeRequest(v11, v14);
                      uint64_t v26 = *(void *)(a2 + 8);
                      v31[0] = *(void *)a2;
                      v31[1] = v26;
                      if (v26) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
                      }
                      v30[0] = v17;
                      v30[1] = (HTTPConnectionCacheEntry::EnqueuedRequest *)v16;
                      if (v16) {
                        atomic_fetch_add_explicit(v16 + 1, 1uLL, memory_order_relaxed);
                      }
                      HTTPConnectionCacheEntry::_dispatchConnectionToProtocol(a1, v31, v30);
                    }
                    ++v14;
                  }
                  if (v16) {
                    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v16);
                  }
                  uint64_t v12 = *((void *)v11 + 2);
                }
                while (v14 < (*((void *)v11 + 3) - v12) >> 4);
              }
            }
            if (v29) {
              std::__shared_weak_count::__release_shared[abi:nn180100](v29);
            }
          }
        }
      }
    }
    while (v6-- >= 1);
  }
  if ((*(unsigned char *)(a1 + 32) & 4) != 0
    && (HTTPConnectionCacheEntry::hasRequestsEnqueued((HTTPConnectionCacheEntry *)a1) & 1) == 0)
  {
    HTTPConnectionCacheEntry::_removeAllConnections((HTTPConnectionCacheEntry *)a1, 0);
  }
  int v27 = *(uint64_t (**)(void))(**(void **)(*(void *)(*(void *)a2 + 64) + 56) + 88);

  return v27();
}

void sub_18415F8FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::__shared_weak_count *a9)
{
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  if (a9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a9);
  }
  _Unwind_Resume(exception_object);
}

void HTTPConnectionCacheEntry::RequestQueue::removeRequest(HTTPConnectionCacheEntry::RequestQueue *this, uint64_t a2)
{
  uint64_t v3 = *((void *)this + 3);
  uint64_t v4 = *((void *)this + 2) + 16 * a2;
  uint64_t v5 = v4 + 16;
  if (v4 + 16 != v3)
  {
    do
    {
      uint64_t v4 = v5;
      long long v6 = *(_OWORD *)v5;
      *(void *)uint64_t v5 = 0;
      *(void *)(v5 + 8) = 0;
      BOOL v7 = *(std::__shared_weak_count **)(v5 - 8);
      *(_OWORD *)(v5 - 16) = v6;
      if (v7) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v7);
      }
      v5 += 16;
    }
    while (v4 + 16 != v3);
    uint64_t v5 = *((void *)this + 3);
  }
  while (v5 != v4)
  {
    uint64_t v8 = *(std::__shared_weak_count **)(v5 - 8);
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
    v5 -= 16;
  }
  *((void *)this + 3) = v4;
}

BOOL HTTPConnection::hasPendingResponses(HTTPConnection *this)
{
  v3[0] = 0;
  v3[1] = v3;
  v3[2] = 0x2020000000;
  BOOL v4 = *((void *)this + 20) != 0;
  BOOL v1 = v4;
  _Block_object_dispose(v3, 8);
  return v1;
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_3_57(void *a1, uint64_t a2)
{
  if (!a1[7]) {
    __assert_rtn("_onqueue_newTubeReady_block_invoke_3", "TubeManager.cpp", 919, "connCache != NULL");
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 104))(a2, *(void *)(a1[4] + 8) + 24, *(void *)(a1[5] + 8) + 24, *(void *)(a1[6] + 8) + 48);
  (*(void (**)(uint64_t, void))(*(void *)a2 + 56))(a2, 0);
  uint64_t v4 = a1[8];
  uint64_t v6 = *(void *)(v4 + 264);
  uint64_t v5 = *(std::__shared_weak_count **)(v4 + 272);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!v6) {
      goto LABEL_13;
    }
    uint64_t v7 = *(void *)(*(void *)(a1[4] + 8) + 24);
    uint64_t v17 = v6;
    uint64_t v18 = v5;
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    if (!v6) {
      goto LABEL_13;
    }
    uint64_t v7 = *(void *)(*(void *)(a1[4] + 8) + 24);
    uint64_t v17 = *(void *)(v4 + 264);
    uint64_t v18 = 0;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v7 + 40))(v7, &v17);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  uint64_t v8 = a1[9];
  uint64_t v15 = v6;
  int v16 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v8 + 56))(v8, &v15);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
LABEL_13:
  uint64_t v9 = *(void *)(*(void *)(a1[4] + 8) + 24);
  uint64_t v10 = *(void *)(*(void *)(a1[5] + 8) + 24);
  uint64_t v11 = a1[7];
  uint64_t v12 = *(void *)(a1[6] + 8);
  long long v13 = *(_OWORD *)(v12 + 48);
  uint64_t v14 = *(void *)(v12 + 64);
  (*(void (**)(uint64_t, uint64_t, uint64_t, long long *))(*(void *)v11 + 80))(v11, v9, v10, &v13);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_18415FC6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTP2ConnectionCache::ingestTube(CFDictionaryRef *this, dispatch_object_t *a2, int a3)
{
  uint64_t v6 = (const HTTPConnectionCacheKey *)Tube::copyKey((Tube *)a2);
  HTTP2ConnectionCacheEntry = HTTP2ConnectionCache::_onqueue_findOrCreateHTTP2ConnectionCacheEntry(this, v6);
  if (!a2) {
    __assert_rtn("ingestTube", "HTTP2ConnectionCacheEntry.cpp", 218, "newTube");
  }
  uint64_t v8 = (uint64_t)HTTP2ConnectionCacheEntry;
  callBacks.version = 0;
  callBacks.retain = (CFArrayRetainCallBack)&callBacks;
  callBacks.release = (CFArrayReleaseCallBack)0x2020000000;
  LOBYTE(callBacks.copyDescription) = 0;
  *(void *)&long long context = MEMORY[0x1E4F143A8];
  *((void *)&context + 1) = 3221225472;
  uint64_t v25 = (void (__cdecl *)(CFAllocatorRef, const void *))___ZN25HTTP2ConnectionCacheEntry23shouldOpenNewConnectionEv_block_invoke;
  uint64_t v26 = &unk_1E5256E50;
  p_CFArrayCallBacks callBacks = &callBacks;
  CFArrayRef v9 = (const __CFArray *)*((void *)HTTP2ConnectionCacheEntry + 11);
  v37.CFIndex length = CFArrayGetCount(v9);
  v37.location = 0;
  CFArrayApplyFunction(v9, v37, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, &context);
  int v10 = *((unsigned __int8 *)callBacks.retain + 24);
  _Block_object_dispose(&callBacks, 8);
  if (v10) {
    __assert_rtn("ingestTube", "HTTP2ConnectionCacheEntry.cpp", 235, "shouldOpenNewConnection()");
  }
  int v23 = a3;
  CFGetAllocator((CFTypeRef)(v8 - 16));
  if (HTTP2Connection::Class(void)::sOnce_HTTP2Connection != -1) {
    dispatch_once(&HTTP2Connection::Class(void)::sOnce_HTTP2Connection, &__block_literal_global_2);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v12 = (char *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2F0uLL);
  }
  else
  {
    uint64_t v12 = 0;
  }
  CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)(v8 - 16));
  *(void *)uint64_t v12 = &unk_1ECF9D4E0;
  *((void *)v12 + 1) = &unk_1ECF9D558;
  *((void *)v12 + 2) = &unk_1ECF9D578;
  *((void *)v12 + 3) = &unk_1ECF9D5C8;
  *((void *)v12 + 4) = &unk_1ECFA02B0;
  *((void *)v12 + 5) = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((_DWORD *)v12 + 27) = 0;
  v12[136] = 0;
  *((void *)v12 + 32) = 0;
  *((void *)v12 + 34) = 0;
  *((void *)v12 + 35) = 0;
  *((void *)v12 + 8) = 0;
  *((void *)v12 + 9) = 0;
  *((void *)v12 + 7) = 0;
  *((_WORD *)v12 + 40) = 0;
  *((void *)v12 + 11) = 0;
  *((void *)v12 + 12) = 0;
  v12[104] = 0;
  *((_OWORD *)v12 + 18) = xmmword_1843D1850;
  *((_DWORD *)v12 + 76) = 0;
  *((void *)v12 + 45) = 0;
  *(_OWORD *)(v12 + 312) = 0u;
  *(_OWORD *)(v12 + 328) = 0u;
  *(_OWORD *)(v12 + 344) = 0u;
  *((_DWORD *)v12 + 92) = 1065353216;
  *(_OWORD *)(v12 + 376) = 0u;
  *(_OWORD *)(v12 + 392) = 0u;
  *((_DWORD *)v12 + 102) = 1065353216;
  *((_OWORD *)v12 + 26) = 0u;
  *((_OWORD *)v12 + 27) = 0u;
  *((_DWORD *)v12 + 112) = 1065353216;
  *((_DWORD *)v12 + 114) = 100;
  *(_OWORD *)(v12 + 460) = 0u;
  *(_OWORD *)(v12 + 476) = 0u;
  *(void *)(v12 + 492) = 0x3F80000000000000;
  *(_OWORD *)(v12 + 504) = 0u;
  *(_OWORD *)(v12 + 520) = 0u;
  *((_DWORD *)v12 + 134) = 1065353216;
  *((_OWORD *)v12 + 34) = 0u;
  *((_OWORD *)v12 + 35) = 0u;
  *((_DWORD *)v12 + 144) = 1065353216;
  *((_DWORD *)v12 + 150) = 0;
  *((void *)v12 + 77) = 0;
  *((void *)v12 + 78) = 0;
  *(void *)(v12 + 591) = 0;
  *((void *)v12 + 73) = 0;
  *((void *)v12 + 79) = HTTP2Connection::HTTP2Connection(__CFAllocator const*)::$_0::__invoke;
  *((void *)v12 + 76) = v12 + 616;
  *((_WORD *)v12 + 320) = 0;
  v12[642] = 1;
  *((void *)v12 + 87) = 0;
  *(_OWORD *)(v12 + 664) = 0u;
  *(_OWORD *)(v12 + 680) = 0u;
  *(_OWORD *)(v12 + 648) = 0u;
  *((_DWORD *)v12 + 176) = 1065353216;
  *((void *)v12 + 29) = 0;
  v12[228] = 0;
  v12[264] = 0;
  v12[744] = 0;
  *(_OWORD *)(v12 + 712) = 0u;
  *(_OWORD *)(v12 + 728) = 0u;
  uint64_t v14 = (char *)operator new(0x30uLL);
  *(_OWORD *)(v14 + 8) = 0u;
  *(void *)uint64_t v14 = &unk_1ECFA66B0;
  *((_DWORD *)v14 + 6) = 1;
  *((_OWORD *)v14 + 2) = 0u;
  *(void *)&long long v15 = v14 + 24;
  *((void *)&v15 + 1) = v14;
  int v16 = (std::__shared_weak_count *)*((void *)v12 + 8);
  *(_OWORD *)(v12 + 56) = v15;
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  uint64_t v31 = 0;
  uint64_t v32 = &v31;
  uint64_t v33 = 0x2020000000;
  char v34 = 1;
  uint64_t v17 = Tube::copyKey((Tube *)a2);
  *((_DWORD *)v12 + 148) = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 88))(v17);
  CFArrayCallBacks callBacks = *(CFArrayCallBacks *)byte_1ECFAB720;
  *((void *)v12 + 29) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callBacks);
  *((CFAbsoluteTime *)v12 + 31) = CFAbsoluteTimeGetCurrent();
  *((void *)v12 + 30) = v8;
  CFRetain((CFTypeRef)(v8 - 16));
  *(_OWORD *)(v12 + 204) = defaultLocalSettings;
  *(void *)(v12 + 220) = 0x7FFFFFFF00FFFFFFLL;
  dispatch_object_t v18 = a2[20];
  if (v18)
  {
    dispatch_retain(a2[20]);
    *((void *)v12 + 21) = v18;
    *(void *)&long long context = MEMORY[0x1E4F143A8];
    *((void *)&context + 1) = 3221225472;
    uint64_t v25 = (void (__cdecl *)(CFAllocatorRef, const void *))___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke;
    uint64_t v26 = &unk_1E5257A50;
    int v28 = v12;
    CFAllocatorRef v29 = a2;
    p_CFArrayCallBacks callBacks = (CFArrayCallBacks *)&v31;
    ___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke(&context);
    BOOL v19 = *((unsigned char *)v32 + 24) != 0;
  }
  else
  {
    *((void *)v12 + 21) = 0;
    BOOL v19 = *((unsigned char *)v32 + 24) == 0;
  }
  (*(void (**)(uint64_t))(*(void *)v17 + 48))(v17);
  _Block_object_dispose(&v31, 8);
  if (!v19)
  {
    CFRelease(v12 - 16);
    if (!v23) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(v8 + 88), v12);
  CFRelease(v12 - 16);
  *(unsigned char *)(v8 + 104) = 1;
  if (v23)
  {
LABEL_17:
    uint64_t v31 = 0;
    uint64_t v35 = 0;
    long long context = 0x3F000000FFFFFFFFuLL;
    LODWORD(v25) = 0;
    uint64_t v20 = Tube::copyWaiter((Tube *)a2);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *, long long *))(*(void *)v20 + 104))(v20, &v31, &v35, &context);
    (*(void (**)(uint64_t, void))(*(void *)v20 + 56))(v20, 0);
    *(_OWORD *)&callBacks.version = context;
    callBacks.release = v25;
    HTTP2ConnectionCacheEntry::enqueueRequestForProtocol(v8, v31, v35, (int *)&callBacks);
    (*(void (**)(uint64_t))(*(void *)v20 + 48))(v20);
  }
LABEL_18:
  int v21 = *(uint64_t (**)(const HTTPConnectionCacheKey *))(*(void *)v6 + 48);

  return v21(v6);
}

void sub_184160340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  (*(void (**)(uint64_t))(*(void *)v17 + 48))(v17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void AwaitingTube::getRequestToEnqueue(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  *a3 = *(void *)(a1 + 40);
  *a2 = *(void *)(a1 + 48);
  long long v4 = *(_OWORD *)(a1 + 56);
  *(void *)(a4 + 16) = *(void *)(a1 + 72);
  *(_OWORD *)a4 = v4;
  *(CFAbsoluteTime *)(a1 + 96) = CFAbsoluteTimeGetCurrent();
}

uint64_t HTTP2ConnectionCache::enqueueRequestForProtocol(CFDictionaryRef *a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v8 = (const HTTPConnectionCacheKey *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  HTTP2ConnectionCacheEntry = HTTP2ConnectionCache::_onqueue_findOrCreateHTTP2ConnectionCacheEntry(a1, v8);
  long long v11 = *a4;
  uint64_t v12 = *((void *)a4 + 2);
  return HTTP2ConnectionCacheEntry::enqueueRequestForProtocol((uint64_t)HTTP2ConnectionCacheEntry, a2, a3, (int *)&v11);
}

const void *HTTP2ConnectionCache::_onqueue_findOrCreateHTTP2ConnectionCacheEntry(CFDictionaryRef *this, const HTTPConnectionCacheKey *a2)
{
  CFNumberRef Value = CFDictionaryGetValue(this[12], a2);
  if (!Value)
  {
    if (HTTP2ConnectionCacheEntry::Class(void)::sOnce_HTTP2ConnectionCacheEntry != -1) {
      dispatch_once(&HTTP2ConnectionCacheEntry::Class(void)::sOnce_HTTP2ConnectionCacheEntry, &__block_literal_global_7492);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    CFDictionaryRef v5 = this[10];
    CFDictionaryRef v6 = this[13];
    *(void *)(Instance + 16) = &unk_1ECFA31B8;
    *(void *)(Instance + 24) = &unk_1ECFA3200;
    *(_OWORD *)(Instance + 48) = xmmword_1843D16C0;
    *(_OWORD *)(Instance + 64) = xmmword_1843D16D0;
    *(void *)(Instance + 80) = 0x7800000078;
    CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)Instance);
    *(void *)(Instance + 104) = CFArrayCreateMutable(v7, 0, &CFObject::skCFTypeArrayCallBacks);
    *(void *)(Instance + 112) = 0;
    *(void *)(Instance + 32) = this;
    (*((void (**)(CFDictionaryRef *))*this + 5))(this);
    *(void *)(Instance + 88) = v5;
    *(void *)(Instance + 96) = v6;
    (*(void (**)(CFDictionaryRef))(*(void *)v5 + 40))(v5);
    *(_WORD *)(Instance + 120) = 0;
    operator new();
  }
  return Value;
}

void sub_184160800(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void *)(v1 + 112);
  *(void *)(v1 + 112) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  CFRelease(*(CFTypeRef *)(v1 + 104));
  void *v2 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void HTTP3ConnectionCacheWrapper::enqueueRequestForProtocol(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  CFDictionaryRef v6 = *(const HTTPConnectionCacheKey **)(a1 + 32);
  long long v9 = *a4;
  uint64_t v10 = *((void *)a4 + 2);
  CFAllocatorRef v7 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  HTTP3ConnectionCache::_entryFindOrCreate((HTTP3ConnectionCache *)&v11, v6, v7);
  HTTP3ConnectionCacheEntry::enqueueRequestForProtocol(v11, a2, a3, (uint64_t)&v9);
  HTTP3ConnectionCache::_timersStart(v6);
  uint64_t v8 = v12;
  if (v12)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
}

void sub_184160934(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void HTTP3ConnectionCacheEntry::enqueueRequestForProtocol(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (__CFHTTPMessage *)(a3 - 16);
  CFURLRef v9 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(a3 - 16));
  if (a2) {
    uint64_t v10 = a2 - 176;
  }
  else {
    uint64_t v10 = 0;
  }
  if ((HTTPProtocol::canUseH2WithCurrentAuthScheme((HTTPProtocol *)v10, v9) & 1) == 0) {
    goto LABEL_65;
  }
  CFURLRef v42 = v9;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFHTTPMessageRef Copy = CFHTTPMessageCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8);
  v43[0] = MEMORY[0x1E4F143A8];
  v43[1] = 3221225472;
  CFStringRef v44 = ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke;
  CFStringRef v45 = &__block_descriptor_40_e5_v8__0l;
  CFHTTPMessageRef v46 = Copy;
  uint64_t v12 = (void *)a1[16];
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (*((unsigned char *)Copy + 40)) {
    CFAllocatorRef v13 = 0;
  }
  else {
    CFAllocatorRef v13 = (CFHTTPMessageRef)((char *)Copy + 16);
  }
  AuthenticationCache::processRequest(v12, a2, v13);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (*((unsigned char *)Copy + 40)) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = (CFHTTPMessageRef)((char *)Copy + 16);
  }
  AuthenticationCache::applyAuthenticationToRequest(a2, v14);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (*((unsigned char *)Copy + 40)) {
    long long v15 = 0;
  }
  else {
    long long v15 = (char *)Copy + 16;
  }
  uint64_t v17 = (uint64_t *)a1[13];
  int v16 = (uint64_t *)a1[14];
  if (v17 == v16)
  {
    dispatch_object_t v18 = 0;
    CFURLRef v9 = v42;
  }
  else
  {
    int v39 = *((unsigned __int8 *)Copy + 40);
    ssize_t v40 = v15;
    while (1)
    {
      uint64_t v19 = *v17;
      dispatch_object_t v18 = (std::__shared_weak_count *)v17[1];
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (HTTP3Connection::willEnqueueRequests((HTTP3Connection *)v19)) {
        break;
      }
      if (v18) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v18);
      }
      v17 += 2;
      if (v17 == v16)
      {
        dispatch_object_t v18 = 0;
        CFURLRef v9 = v42;
        goto LABEL_42;
      }
    }
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:nn180100](v18);
    }
    CFURLRef v9 = v42;
    if (v19)
    {
      if (![*(id *)(v10 + 80) _preconnect])
      {
        if (*(void *)(v19 + 1136) == *(void *)(v19 + 1144))
        {
          (*(void (**)(void, void))(**(void **)(v19 + 1008) + 88))(*(void *)(v19 + 1008), 0);
          (*(void (**)(void, void, void))(**(void **)(v19 + 1008) + 136))(*(void *)(v19 + 1008), 0, 0);
          int v30 = (*(void (**)(void))(**(void **)(v19 + 1008) + 248))(*(void *)(v19 + 1008));
          CFAbsoluteTimeGetCurrent();
          (*(void (**)(void))(**(void **)(v19 + 1008) + 248))(*(void *)(v19 + 1008));
        }
        uint64_t v31 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate(allocator, 48, 0);
        *((_OWORD *)v31 + 1) = 0u;
        *((_OWORD *)v31 + 2) = 0u;
        *(_OWORD *)uint64_t v31 = 0u;
        uint64_t v32 = *(void **)(v19 + 1000);
        uint64_t v33 = *(void *)(v19 + 8);
        uint64_t v34 = *(void *)(v19 + 16);
        if (v34) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 16), 1uLL, memory_order_relaxed);
        }
        id v38 = v32;
        CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v31, allocator);
        *(void *)uint64_t v31 = &unk_1ECF9F1C0;
        *((void *)v31 + 3) = &unk_1ECF9F298;
        *((void *)v31 + 4) = 0;
        *((void *)v31 + 5) = 0;
        uint64_t v35 = operator new(0x1A0uLL);
        v35[1] = 0;
        v35[2] = 0;
        *uint64_t v35 = &unk_1ECFA65D0;
        if (v34) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 16), 1uLL, memory_order_relaxed);
        }
        id v36 = v38;
        void v35[4] = 0;
        v35[5] = 0;
        v35[3] = &unk_1ECF9AD28;
        v35[6] = 0;
        v35[7] = 0;
        v35[8] = v36;
        v35[9] = v33;
        v35[10] = v34;
        if (v34) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 16), 1uLL, memory_order_relaxed);
        }
        if (!v39) {
          CFRetain(v40 - 16);
        }
        v35[11] = v40;
        operator new();
      }
      uint64_t v20 = *(void *)(v19 + 1008);
      int v21 = *(std::__shared_weak_count **)(v19 + 1016);
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v20)
      {
        (*(void (**)(uint64_t))(*(void *)v10 + 744))(v10);
        uint64_t v22 = (unsigned char *)objc_claimAutoreleasedReturnValue();
        int v23 = (*(void (**)(uint64_t))(*(void *)v20 + 248))(v20);
        -[__CFN_TransactionMetrics linkWithConnection:](v22, v23);

        (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 88))(v20, 1);
      }
      if (v21) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v21);
      }
      uint64_t v24 = *(void *)(v19 + 1008);
      if (v24) {
        uint64_t v25 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v24 + 216))(v24, 0x1EC09FF30);
      }
      else {
        uint64_t v25 = 0;
      }
      CFRange v37 = *(void **)(v10 + 80);
      if (v37) {
        objc_msgSend(v37, "set_TCPConnectionMetadata:", v25);
      }
      if (v25) {
        CFRelease(v25);
      }
      URLProtocol::sendDidFinishLoading((URLProtocol *)v10);
      goto LABEL_62;
    }
  }
LABEL_42:
  uint64_t v26 = a1[12];
  int v27 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  TubeManager::invalidateKey(v26, v27, 1, 2u);
  uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  if (CFStringCompare(*(CFStringRef *)(v28 + 32), *(CFStringRef *)(v28 + 136), 0))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(a2 - 176) + 280))(a2 - 176, 4, 4294965096, 0);
  }
  else
  {
    CFAllocatorRef v29 = (CFArrayRef *)a1[12];
    long long v47 = *(_OWORD *)a4;
    uint64_t v48 = *(void *)(a4 + 16);
    TubeManager::_onqueue_enqueueRequestForProtocol(v29, a2, a3, &v47, 0);
  }
LABEL_62:
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  v44((uint64_t)v43);
LABEL_65:
  if (v9) {
    CFRelease(v9);
  }
}

void sub_1841613F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,CFTypeRef cf,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,void (*a30)(char *))
{
  if (v31) {
    CFRelease(v31);
  }
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v30);
  }
  a30(&a28);
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(a1);
}

void ___ZN15HTTP2Connection22createStreamAndEnqueueEPK18HTTPRequestMessageP25MetaConnectionCacheClientif_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (HTTP2StreamBridge::Class(void)::sOnce_HTTP2StreamBridge != -1) {
    dispatch_once(&HTTP2StreamBridge::Class(void)::sOnce_HTTP2StreamBridge, &__block_literal_global_49);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v3 = (void *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v3 = (void *)(Instance + 16);
    *(void *)(Instance + 48) = 0;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  uint64_t v4 = *(void *)(v1 + 64);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  *uint64_t v3 = &unk_1ECF9E3C8;
  v3[1] = &unk_1ECF9E4B0;
  v3[2] = &unk_1ECF9E580;
  operator new();
}

void sub_184161A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  *a11 = &unk_1ECF9B550;
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'HTTPProtocol::getSuspensionThreshold(HTTPProtocol *this)
{
  return [*((id *)this - 12) _suspensionThreshhold];
}

void HTTPConnectionCacheEntry::_dispatchConnectionToProtocol(uint64_t a1, void *a2, HTTPConnectionCacheEntry::EnqueuedRequest **a3)
{
  CFDictionaryRef v6 = *a3;
  if (!*((unsigned char *)*a3 + 65))
  {
    *(unsigned char *)(a1 + 32) &= ~0x10u;
    CFDictionaryRef v6 = *a3;
  }
  uint64_t v7 = *a2;
  BOOL v8 = *((unsigned char *)v6 + 66) != 0;
  CFURLRef v9 = *(std::__shared_weak_count **)(*a2 + 48);
  if (v9)
  {
    uint64_t v10 = std::__shared_weak_count::lock(v9);
    if (v10) {
      uint64_t v11 = *(void *)(v7 + 40);
    }
    else {
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v10 = 0;
  }
  uint64_t v12 = *(NSObject **)(v7 + 56);
  uint64_t block = MEMORY[0x1E4F143A8];
  uint64_t block_8 = 3321888768;
  CFRange v37 = ___ZN14HTTPConnection26setShouldSkipPipelineProbeEb_block_invoke;
  id v38 = &__block_descriptor_49_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e5_v8__0l;
  uint64_t v39 = v11;
  ssize_t v40 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v41 = v8;
  dispatch_async(v12, &block);
  if (v40) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v40);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  CFAllocatorRef v13 = (void *)*a2;
  if ((*(unsigned char *)(a1 + 32) & 8) == 0
    || (*(unsigned char *)(a1 + 32) & 0x10) != 0 && (*(unsigned char *)(a1 + 32) & 0x60) != 0x20
    || (uint64_t v14 = *a3, !*((unsigned char *)*a3 + 67)))
  {
    BOOL v17 = 0;
    goto LABEL_24;
  }
  uint64_t v15 = *((void *)v14 + 5);
  if (v15)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (!*(unsigned char *)(v15 + 40))
    {
      int v16 = (os_unfair_lock_s *)(v15 + 16);
LABEL_54:
      BOOL v32 = HTTPMessage::hasHeaderField(v16, 0x1490F3F6u) != 0;
LABEL_56:
      BOOL v17 = !v32;
LABEL_24:
      dispatch_object_t v18 = (std::__shared_weak_count *)v13[6];
      if (v18)
      {
        uint64_t v19 = std::__shared_weak_count::lock(v18);
        if (v19) {
          uint64_t v20 = v13[5];
        }
        else {
          uint64_t v20 = 0;
        }
      }
      else
      {
        uint64_t v20 = 0;
        uint64_t v19 = 0;
      }
      int v21 = v13[7];
      uint64_t block = MEMORY[0x1E4F143A8];
      uint64_t block_8 = 3321888768;
      CFRange v37 = ___ZN14HTTPConnection17setShouldPipelineEb_block_invoke;
      id v38 = &__block_descriptor_49_e8_32c42_ZTSNSt3__110shared_ptrI14HTTPConnectionEE_e5_v8__0l;
      uint64_t v39 = v20;
      ssize_t v40 = v19;
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      BOOL v41 = v17;
      dispatch_async(v21, &block);
      if (v40) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v40);
      }
      if (v19) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v19);
      }
      uint64_t v22 = (*(uint64_t (**)(void))(*(void *)*a3 + 80))();
      uint64_t v23 = HTTPConnectionCacheEntry::EnqueuedRequest::mutableRequest(*a3);
      if (v23)
      {
        uint64_t v24 = v23;
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        if (*(unsigned char *)(v24 + 40)) {
          uint64_t v25 = 0;
        }
        else {
          uint64_t v25 = (HTTPRequestMessage *)(v24 + 16);
        }
      }
      else
      {
        uint64_t v25 = 0;
      }
      AuthenticationCache::applyAuthenticationToRequest(v22, v25);
      CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      int v27 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 48, 0);
      *(_OWORD *)int v27 = 0u;
      *((_OWORD *)v27 + 1) = 0u;
      *((_OWORD *)v27 + 2) = 0u;
      uint64_t v28 = a2[1];
      if (v28) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v29 = HTTPConnectionCacheEntry::EnqueuedRequest::mutableRequest(*a3);
      if (v29)
      {
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        if (*(unsigned char *)(v29 + 40)) {
          uint64_t v30 = 0;
        }
        else {
          uint64_t v30 = v29 + 16;
        }
      }
      else
      {
        uint64_t v30 = 0;
      }
      (*(void (**)(void))(*(void *)*a3 + 80))();
      (*(void (**)(long long *__return_ptr))(*(void *)*a3 + 96))(&v33);
      CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v27, v26);
      *(void *)int v27 = &unk_1ECFA2338;
      *((void *)v27 + 3) = &unk_1ECFA2420;
      *((void *)v27 + 4) = 0;
      *((void *)v27 + 5) = 0;
      uint64_t v31 = (char *)operator new(0x148uLL);
      *(_OWORD *)(v31 + 8) = 0u;
      *(void *)uint64_t v31 = &unk_1ECFA68A8;
      *(_OWORD *)(v31 + 136) = v33;
      *((void *)v31 + 19) = v34;
      *((_OWORD *)v31 + 2) = 0u;
      *((void *)v31 + 3) = &unk_1ECF9D660;
      *((void *)v31 + 6) = &unk_1ECF9D748;
      *((_OWORD *)v31 + 19) = 0u;
      *((_WORD *)v31 + 28) = 0;
      *((void *)v31 + 14) = 0;
      *((_DWORD *)v31 + 30) = 0;
      *((void *)v31 + 16) = 0;
      *((void *)v31 + 28) = 0;
      *((_OWORD *)v31 + 12) = 0u;
      *((_OWORD *)v31 + 13) = 0u;
      *((_OWORD *)v31 + 10) = 0u;
      *((_OWORD *)v31 + 11) = 0u;
      *(_OWORD *)(v31 + 92) = 0u;
      *((_OWORD *)v31 + 4) = 0u;
      *((_OWORD *)v31 + 5) = 0u;
      if (v30)
      {
        CFRetain((CFTypeRef)(v30 - 16));
        operator new();
      }
      __assert_rtn("HTTPTransaction", "HTTPTransaction.cpp", 62, "request");
    }
  }
  else
  {
    int v16 = (os_unfair_lock_s *)*((void *)v14 + 4);
    if (v16) {
      goto LABEL_54;
    }
  }
  BOOL v32 = 0;
  goto LABEL_56;
}

void sub_184162624(_Unwind_Exception *a1)
{
  if (v3) {
    CFRelease(v3);
  }
  CFRelease(v2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(a1);
}

HTTPProtocol *non-virtual thunk to'HTTPProtocol::copyTaskLoggableDescription@<X0>(HTTPProtocol *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *((void *)this + 78);
  *a2 = *((void *)this + 77);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

BOOL non-virtual thunk to'HTTPProtocol::useNetStreamInfoForRequest(HTTPProtocol *this, MetaNetStreamInfo *a2, const HTTPRequestMessage *a3, int a4)
{
  return HTTPProtocol::useNetStreamInfoForRequest((HTTPProtocol *)((char *)this - 176), a2, a3, a4);
}

__n128 HTTPConnectionCacheEntry::EnqueuedRequest::getOptions@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = this[3];
  *a2 = result;
  a2[1].n128_u64[0] = this[4].n128_u64[0];
  return result;
}

BOOL HTTP3Connection::willEnqueueRequests(HTTP3Connection *this)
{
  if (*((_DWORD *)this + 292) || (*((unsigned char *)this + 920) & 6) != 0) {
    return 0;
  }
  if (*((void *)this + 142) != *((void *)this + 143)) {
    return 1;
  }
  uint64_t v2 = *((void *)this + 148);
  if (!v2) {
    return 1;
  }
  __uint64_t v3 = v2 + *((void *)this + 147) - 1000000000;
  return v3 > clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
}

uint64_t ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

void ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void *HTTP3ConnectionCache::_entryFindOrCreate(HTTP3ConnectionCache *this, const HTTPConnectionCacheKey *a2, const void *a3)
{
  __n128 result = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), a3);
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  if (!result)
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v10 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 48, 0);
    uint64_t v11 = v10;
    *uint64_t v10 = 0u;
    v10[1] = 0u;
    v10[2] = 0u;
    uint64_t v13 = *((void *)a2 + 1);
    uint64_t v12 = *((void *)a2 + 2);
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 16), 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = *((void *)a2 + 8);
    uint64_t v15 = *((void *)a2 + 9);
    CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)v10, v9);
    *uint64_t v11 = &unk_1ECFA52E8;
    v11[3] = 0;
    void v11[4] = 0;
    int v16 = operator new(0xA8uLL);
    BOOL v17 = v16;
    v16[1] = 0;
    v16[2] = 0;
    *int v16 = &unk_1ECFA6BB8;
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 16), 1uLL, memory_order_relaxed);
    }
    *((_OWORD *)v16 + 8) = 0u;
    v16[4] = 0;
    v16[5] = 0;
    v16[3] = &unk_1ECFA3220;
    v16[6] = 0;
    v16[7] = 0;
    long long v18 = *(_OWORD *)((char *)a2 + 40);
    *((_OWORD *)v16 + 4) = *(_OWORD *)((char *)a2 + 24);
    *((_OWORD *)v16 + 5) = v18;
    uint64_t v19 = *((void *)a2 + 7);
    *((_OWORD *)v16 + 7) = 0u;
    *((_OWORD *)v16 + 9) = 0u;
    *((unsigned char *)v16 + 160) = 0;
    v16[12] = v19;
    v16[13] = a3;
    (*(void (**)(const void *))(*(void *)a3 + 40))(a3);
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 16), 1uLL, memory_order_relaxed);
    }
    uint64_t v20 = (std::__shared_weak_count *)v17[7];
    v17[6] = v13;
    v17[7] = v12;
    if (v20) {
      std::__shared_weak_count::__release_weak(v20);
    }
    v17[14] = v14;
    (*(void (**)(uint64_t))(*(void *)v14 + 40))(v14);
    v17[15] = v15;
    operator new();
  }
  uint64_t v8 = result[3];
  uint64_t v7 = result[4];
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)this = v8;
  *((void *)this + 1) = v7;
  return result;
}

void sub_184162C0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  int v21 = *(std::__shared_weak_count **)(v18 + 32);
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  }
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  _Unwind_Resume(exception_object);
}

void HTTP3ConnectionCache::_timersStart(HTTP3ConnectionCache *this)
{
  if (!*((unsigned char *)this + 96))
  {
    *((unsigned char *)this + 96) = 1;
    uint64_t v2 = *((void *)this + 13);
    dispatch_time_t v3 = dispatch_time(0, 1000000000 * *((int *)this + 14));
    dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    uint64_t v4 = *((void *)this + 14);
    dispatch_time_t v5 = dispatch_time(0, 1000000000 * *((int *)this + 15));
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  }
}

void NWIOConnection::setQUICKeepalive(uint64_t a1)
{
  if (*(void *)(a1 + 272))
  {
    uint64_t v2 = nw_protocol_copy_quic_connection_definition();
    nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(*(nw_connection_t *)(a1 + 272), v2);
    if (v3)
    {
      nw_quic_connection_set_keepalive();
      nw_release(v3);
    }
    if (v2)
    {
      nw_release(v2);
    }
  }
}

void sub_184162E2C(_Unwind_Exception *a1)
{
  nw_release(v2);
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

BOOL HTTPConnectionCacheEntry::_doesConnAuthApply(uint64_t a1, std::__shared_weak_count *a2, HTTPConnectionCacheEntry::EnqueuedRequest **a3)
{
  v16[4] = *MEMORY[0x1E4F143B8];
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)*a3 + 80))();
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v6 + 88))(&v13);
  if (!AuthenticationState::isEmpty((AuthenticationState *)a1) && !AuthenticationState::isValid(a1, 0)) {
    goto LABEL_19;
  }
  if (!AuthenticationState::isEmpty((AuthenticationState *)a1))
  {
    uint64_t v7 = HTTPConnectionCacheEntry::EnqueuedRequest::mutableRequest(*a3);
    if (v7)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      uint64_t v8 = *(unsigned char *)(v7 + 40) ? 0 : (HTTPRequestMessage *)(v7 + 16);
    }
    else
    {
      uint64_t v8 = 0;
    }
    if (!AuthenticationState::canApplyHeadersToRequest((AuthenticationState *)a1, v8))
    {
LABEL_19:
      BOOL v11 = 0;
      goto LABEL_22;
    }
  }
  uint64_t v9 = v13;
  if (a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  }
  if (!v9)
  {
    BOOL v11 = 1;
    if (!a1) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
  uint64_t v10 = (pthread_mutex_t *)(v9 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  char v15 = 1;
  v16[0] = &unk_1ECFA60F0;
  v16[1] = a1;
  v16[2] = &v15;
  v16[3] = v16;
  AuthenticationState::_foreachAuthenticationInfo(v9, (uint64_t)v16);
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](v16);
  BOOL v11 = v15 != 0;
  pthread_mutex_unlock(v10);
  if (a1) {
LABEL_21:
  }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
LABEL_22:
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  if (a2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a2);
  }
  return v11;
}

void sub_184163050(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100]((uint64_t *)va);
  pthread_mutex_unlock(v6);
  if (v5) {
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  if (a3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a3);
  }
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  _Unwind_Resume(a1);
}

BOOL AuthenticationState::isEmpty(AuthenticationState *this)
{
  if (this) {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  }
  if (*((void *)this + 13)) {
    BOOL v2 = 0;
  }
  else {
    BOOL v2 = *((void *)this + 16) == 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 8));
  return v2;
}

uint64_t ___ZN20HTTP3ConnectionCache18_entryFindOrCreateEPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

void sub_1841634DC(_Unwind_Exception *a1)
{
  uint64_t v7 = v6;

  _Unwind_Resume(a1);
}

uint64_t ___ZN14CFNetworkTrust13evaluateAsyncEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvNS_14QuantizedErrorEE_block_invoke(uint64_t a1, int a2, SecTrustResultType a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = CFNetworkTrust::processEvaluateResult(*(SecTrustRef **)(a1 + 40), a3);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 16);

  return v5(v3, v4);
}

uint64_t CFNetworkTrust::processEvaluateResult(SecTrustRef *this, SecTrustResultType a2)
{
  switch(a2)
  {
    case kSecTrustResultProceed:
      return 0;
    case kSecTrustResultDeny:
      return 2;
    case kSecTrustResultUnspecified:
      return 0;
  }
  CFArrayRef v4 = SecTrustCopyProperties(this[1]);
  if (v4)
  {
    CFArrayRef v5 = v4;
    CFContainerEnumeratorBase::setup((unint64_t)&v29, v4, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
    uint64_t v32 = 0;
    if (v30 >= 1)
    {
      uint64_t v6 = 0;
      do
      {
        uint64_t v32 = v6 + 1;
        CFDictionaryRef v7 = *(const __CFDictionary **)(v31 + 8 * v6);
        CFNumberRef Value = CFDictionaryGetValue(v7, @"value");
        uint64_t v9 = CFDictionaryGetValue(v7, @"type");
        if (CFEqual(v9, @"error"))
        {
          if (CFEqual(Value, @"Root certificate is not trusted."))
          {
            char v10 = *((unsigned char *)this + 32) | 1;
          }
          else if (CFEqual(Value, @"Hostname mismatch."))
          {
            char v10 = *((unsigned char *)this + 32) | 2;
          }
          else
          {
            int v11 = CFEqual(Value, @"One or more certificates have expired or are not valid yet.");
            char v12 = *((unsigned char *)this + 32);
            if (!v11)
            {
              *((unsigned char *)this + 32) = v12 | 0x10;
              *((_DWORD *)this + 9) = -9807;
              goto LABEL_17;
            }
            char v10 = v12 | 4;
          }
          *((unsigned char *)this + 32) = v10;
        }
LABEL_17:
        uint64_t v6 = v32;
      }
      while (v32 < v30);
    }
    CFRelease(v5);
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v29);
  }
  else
  {
    *((unsigned char *)this + 32) |= 0x10u;
    *((_DWORD *)this + 9) = -9807;
  }
  CFArrayRef v13 = this[2];
  if ((v13 || (CFArrayRef v13 = SecTrustCopyCertificateChain(this[1]), (this[2] = v13) != 0))
    && (CFArrayRef v14 = (const __CFArray *)CFRetain(v13)) != 0)
  {
    CFArrayRef v15 = v14;
    if (CFArrayGetCount(v14) < 1)
    {
      LODWORD(v17) = 0;
    }
    else
    {
      CFNumberRef ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v15, 0);
      LODWORD(v17) = 0;
      if (ValueAtIndex)
      {
        SecTrustRef v18 = this[3];
        if (v18)
        {
          CFDataRef v17 = SecCertificateCopyData(ValueAtIndex);
          if (v17)
          {
            CFContainerEnumeratorBase::setup((unint64_t)&v29, v18, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
            CFIndex v19 = v30;
            if (v30 < 1)
            {
              uint64_t v22 = 0;
            }
            else
            {
              CFIndex v20 = 0;
              do
              {
                CFDataRef v21 = SecCertificateCopyData(*(SecCertificateRef *)(v31 + 8 * v20));
                if (v21)
                {
                  if (CFEqual(v17, v21)) {
                    uint64_t v22 = CFArrayGetValueAtIndex(v18, v20);
                  }
                  else {
                    uint64_t v22 = 0;
                  }
                  CFRelease(v21);
                }
                else
                {
                  uint64_t v22 = 0;
                }
                ++v20;
              }
              while (v20 < v19 && !v22);
            }
            CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v29);
            CFRelease(v17);
            LODWORD(v17) = v22 != 0;
          }
        }
      }
    }
    CFRelease(v15);
  }
  else
  {
    LODWORD(v17) = 0;
  }
  unsigned int v23 = *((unsigned __int8 *)this + 32);
  BOOL v24 = v17 != 0;
  int v25 = v24 & (v23 >> 4);
  if (v25) {
    unsigned int v26 = v23 & 0xFFFFFFEF;
  }
  else {
    unsigned int v26 = *((unsigned __int8 *)this + 32);
  }
  int v27 = v24 & (v26 >> 3);
  if (v27) {
    char v28 = v26 & 0xF7;
  }
  else {
    char v28 = v26;
  }
  if ((v25 & 1) == 0 && (v27 & 1) == 0)
  {
    if ((v28 & 1) == 0) {
      goto LABEL_54;
    }
LABEL_57:
    if ((*((unsigned char *)this + 33) & 4) == 0 && !v17) {
      goto LABEL_62;
    }
    LOBYTE(v23) = v28 & 0xFE;
    *((unsigned char *)this + 32) = v28 & 0xFE;
    v28 &= ~1u;
    if ((v28 & 2) == 0) {
      goto LABEL_62;
    }
LABEL_60:
    if (v17)
    {
      LOBYTE(v23) = v28 & 0xFD;
      *((unsigned char *)this + 32) = v28 & 0xFD;
      v28 &= ~2u;
    }
    goto LABEL_62;
  }
  *((unsigned char *)this + 32) = v28;
  LOBYTE(v23) = v28;
  if (v28) {
    goto LABEL_57;
  }
LABEL_54:
  if ((v28 & 2) != 0) {
    goto LABEL_60;
  }
LABEL_62:
  if ((v28 & 4) != 0 && ((*((unsigned char *)this + 33) & 1) != 0 || v17))
  {
    LOBYTE(v23) = v28 & 0xFB;
    *((unsigned char *)this + 32) = v28 & 0xFB;
    v28 &= ~4u;
  }
  if ((v28 & 0x40) != 0 && ((*((unsigned char *)this + 33) & 4) != 0 || v17))
  {
    LOBYTE(v23) = v28 & 0xBF;
    *((unsigned char *)this + 32) = v28 & 0xBF;
    v28 &= ~0x40u;
  }
  if (v28 < 0 && ((*((unsigned char *)this + 33) & 1) != 0 || v17))
  {
    LOBYTE(v23) = v28 & 0x7F;
    *((unsigned char *)this + 32) = v28 & 0x7F;
  }
  return (v23 & 0xDF) != 0;
}

void sub_184163950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL CFURLProtectionSpaceIsProxy(uint64_t a1)
{
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return (*(_DWORD *)(v2 + 44) - 5) < 4;
}

void ___ZL19mutableGlobalLimitsv_block_invoke()
{
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke(void *a1, NSObject *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    uint64_t v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      CFDictionaryRef v7 = v6;
      uint64_t v8 = a1[5];
      if (v8)
      {
        if ((*(_WORD *)(v8 + 248) & 0x60) != 0 || (*(_DWORD *)(v8 + 136) - 5) <= 2)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          uint64_t v9 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v10 = *(void *)(v5 + 288);
            int v11 = 134217984;
            uint64_t v12 = v10;
            _os_log_impl(&dword_184085000, v9, OS_LOG_TYPE_DEFAULT, "Connection %llu: Ignoring sec configuration block - connection canceled", (uint8_t *)&v11, 0xCu);
          }
        }
        else
        {
          NWIOConnection::_tlsConfigure(v8, a2);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
  }
}

void sub_184163E70(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void NWIOConnection::_tlsConfigure(uint64_t a1, sec_protocol_options_t options)
{
  v119[128] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 256);
  CFArrayRef v4 = *(std::__shared_weak_count **)(a1 + 264);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  verify_block[0] = MEMORY[0x1E4F143A8];
  verify_block[1] = 3321888768;
  verify_block[2] = ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke;
  verify_block[3] = &__block_descriptor_56_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e81_v32__0__NSObject_OS_sec_protocol_metadata__8__NSObject_OS_sec_trust__16___v__B_24l;
  verify_block[4] = a1;
  verify_void block[5] = v5;
  v114 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sec_protocol_options_set_verify_block(options, verify_block, *(dispatch_queue_t *)(a1 + 120));
  challenge_block[0] = MEMORY[0x1E4F143A8];
  challenge_block[1] = 3321888768;
  challenge_block[2] = ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_181;
  challenge_block[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e81_v24__0__NSObject_OS_sec_protocol_metadata__8___v____NSObject_OS_sec_identity___16l;
  challenge_block[4] = v5;
  unsigned int v112 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  sec_protocol_options_set_challenge_block(options, challenge_block, *(dispatch_queue_t *)(a1 + 120));
  NWIOConnection::_tlsCreatePeerName(a1);
  if (*(void *)(a1 + 432)) {
    goto LABEL_41;
  }
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC0A1270);
  if (Value)
  {
    CFDictionaryRef v7 = CFDictionaryGetValue(Value, &unk_1EC0A04A8);
    uint64_t v8 = v7;
    if (v7)
    {
      CFTypeID v9 = CFGetTypeID(v7);
      if (v9 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t valuePtr = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
      }
      if ((const void *)*MEMORY[0x1E4F1CFC8] == v8) {
        goto LABEL_41;
      }
    }
  }
  uint64_t v10 = *(NSObject **)(a1 + 304);
  if (!v10)
  {
    hostname = 0;
LABEL_23:
    CFNumberRef v13 = 0;
    goto LABEL_24;
  }
  if (nw_endpoint_get_type(v10) == nw_endpoint_type_host) {
    hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 304));
  }
  else {
    hostname = 0;
  }
  uint64_t v12 = *(NSObject **)(a1 + 304);
  if (!v12
    || nw_endpoint_get_type(v12) != nw_endpoint_type_host
    && nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 304)) != nw_endpoint_type_address)
  {
    goto LABEL_23;
  }
  *(_WORD *)uint64_t valuePtr = 0;
  *(_WORD *)uint64_t valuePtr = nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 304));
  CFNumberRef v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt16Type, valuePtr);
LABEL_24:
  NWIOConnection::_tlsCreatePeerName(a1);
  uint64_t v15 = *(void *)(a1 + 416);
  CFArrayRef v14 = *(std::__shared_weak_count **)(a1 + 424);
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v15)
  {
    CFRetain(@"nulldomain");
    operator new();
  }
  int v16 = v14;
  CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"{%s:%@}%@", hostname, v13, v15);
  CFStringRef v19 = v18;
  if (*(void *)(a1 + 176))
  {
    uint64_t identifier = nw_context_get_identifier();
    CFStringRef v21 = CFStringCreateWithFormat(v17, 0, @"%s{%@}", identifier, v19);
    if (v19) {
      CFRelease(v19);
    }
  }
  else
  {
    CFStringRef v21 = v18;
  }
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(v17, v21, 0x8000100u, 0x2Eu);
  unsigned int v23 = *(const void **)(a1 + 432);
  *(void *)(a1 + 432) = ExternalRepresentation;
  if (v23) {
    CFRelease(v23);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  if (v13) {
    CFRelease(v13);
  }
LABEL_41:
  CFDictionaryRef v24 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC0A1270);
  CFDictionaryRef v25 = v24;
  if (v24)
  {
    unsigned int v26 = CFDictionaryGetValue(v24, &unk_1EC0A1740);
    int v27 = CFDictionaryGetValue(v25, &unk_1EC0A0438);
    char v28 = CFDictionaryGetValue(v25, &unk_1EC0A00F0);
    if (v26 || v27 || v28) {
      operator new();
    }
    uint64_t v29 = (const void **)MEMORY[0x1E4F1CFD0];
    uint64_t v30 = CFDictionaryGetValue(v25, &unk_1EC0A0470);
    uint64_t v31 = v30;
    if (!v30) {
      goto LABEL_52;
    }
    CFTypeID v32 = CFGetTypeID(v30);
    if (v32 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t valuePtr = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
    }
    if (*v29 == v31) {
      BOOL v33 = 1;
    }
    else {
LABEL_52:
    }
      BOOL v33 = 0;
    sec_protocol_options_set_tls_is_fallback_attempt(options, v33);
    uint64_t v34 = CFDictionaryGetValue(v25, &unk_1EC0A0518);
    uint64_t v35 = v34;
    if (!v34) {
      goto LABEL_58;
    }
    CFTypeID v36 = CFGetTypeID(v34);
    if (v36 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t valuePtr = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
    }
    if (*v29 == v35)
    {
      *(_WORD *)(a1 + 248) |= 0x2000u;
    }
    else
    {
LABEL_58:
      int v37 = *(_WORD *)(a1 + 248) & 0xDFFF | (*(unsigned __int8 *)(a1 + 250) << 16);
      *(_WORD *)(a1 + 248) &= ~0x2000u;
      *(unsigned char *)(a1 + 250) = BYTE2(v37);
    }
    id v38 = CFDictionaryGetValue(v25, &unk_1EC0A0550);
    uint64_t v39 = v38;
    if (!v38) {
      goto LABEL_64;
    }
    CFTypeID v40 = CFGetTypeID(v38);
    if (v40 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t valuePtr = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
    }
    if (*v29 == v39)
    {
      unsigned int v41 = *(unsigned __int16 *)(a1 + 248) | (*(unsigned __int8 *)(a1 + 250) << 16) | 0x6000;
      *(_WORD *)(a1 + 248) |= 0x6000u;
    }
    else
    {
LABEL_64:
      unsigned int v41 = *(_WORD *)(a1 + 248) & 0xBFFF | (*(unsigned __int8 *)(a1 + 250) << 16);
      *(_WORD *)(a1 + 248) &= ~0x4000u;
      *(unsigned char *)(a1 + 250) = BYTE2(v41);
    }
    if ((v41 & 0x6000) == 0x2000)
    {
      NWIOConnection::_copyNetworkSignature((uint64_t)valuePtr, a1);
      CFStringRef v43 = *(const __CFString **)valuePtr;
      if (*(void *)valuePtr)
      {
        CFStringRef v44 = CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore(*(CFNA **)valuePtr, (const __CFString *)"TLSFalseStart", v42);
        CFStringRef v45 = v44;
        if (!v44)
        {
          if (CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once != -1) {
            dispatch_once(&CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once, &__block_literal_global_11694);
          }
          CFNA::CFNetworkAgentClient::executeLegacyQuery((CFNA::CFNetworkAgentClient *)CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client, v43);
        }
        CFComparisonResult v46 = CFStringCompare(v44, @"TRUE", 0);
        CFRelease(v45);
        CFRelease(v43);
        unsigned int v41 = *(unsigned __int16 *)(a1 + 248) | (*(unsigned __int8 *)(a1 + 250) << 16);
        if (v46 == kCFCompareEqualTo)
        {
          unsigned int v47 = HIWORD(v41);
          v41 |= 0x4000u;
          *(unsigned char *)(a1 + 250) = v47;
          *(_WORD *)(a1 + 248) = v41;
        }
      }
      else
      {
        unsigned int v41 = *(unsigned __int16 *)(a1 + 248) | (*(unsigned __int8 *)(a1 + 250) << 16);
      }
    }
    sec_protocol_options_set_tls_false_start_enabled(options, (~v41 & 0x6000) == 0);
    NWIOConnection::_tlsCreatePeerName(a1);
    uint64_t v48 = *(const void **)(a1 + 416);
    if (v48)
    {
      if (CFEqual(v48, (CFTypeRef)*MEMORY[0x1E4F1D260]))
      {
        sec_protocol_options_set_tls_sni_disabled();
      }
      else
      {
        CFAllocatorRef v49 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFStringRef v50 = *(const __CFString **)(a1 + 416);
        *(void *)uint64_t valuePtr = *MEMORY[0x1E4F1CF80];
        *(void *)&valuePtr[8] = 1023;
        if (v50)
        {
          CString = _CFStringGetOrCreateCString(v49, v50, (UInt8 *)v119, (uint64_t *)&valuePtr[8], 0x8000100u);
        }
        else
        {
          LOBYTE(v119[0]) = 0;
          *(void *)&valuePtr[8] = 0;
          CString = (UInt8 *)v119;
        }
        *(void *)&valuePtr[16] = CString;
        sec_protocol_options_set_tls_server_name(options, (const char *)CString);
        if (*(void *)&valuePtr[16] && v119 != *(void **)&valuePtr[16]) {
          CFAllocatorDeallocate(*(CFAllocatorRef *)valuePtr, *(void **)&valuePtr[16]);
        }
      }
    }
    uint64_t v52 = CFDictionaryGetValue(v25, &unk_1EC0A04A8);
    uint64_t v53 = v52;
    if (v52)
    {
      CFTypeID v54 = CFGetTypeID(v52);
      if (v54 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t valuePtr = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
      }
      if ((const void *)*MEMORY[0x1E4F1CFC8] == v53) {
        goto LABEL_97;
      }
    }
    uint64_t v55 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC09F0C0);
    int v56 = v55;
    if (!v55) {
      goto LABEL_96;
    }
    CFTypeID v57 = CFGetTypeID(v55);
    if (v57 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t valuePtr = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
    }
    if ((const void *)*MEMORY[0x1E4F1CFC8] == v56) {
LABEL_97:
    }
      BOOL v58 = 0;
    else {
LABEL_96:
    }
      BOOL v58 = 1;
    sec_protocol_options_set_tls_resumption_enabled(options, v58);
    uint64_t v59 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC09F0F8);
    uint64_t v60 = v59;
    if (v59)
    {
      CFTypeID v61 = CFGetTypeID(v59);
      if (v61 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t valuePtr = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
      }
      uint64_t v62 = *v29;
      if (*v29 == v60) {
        goto LABEL_107;
      }
      CFTypeID v63 = CFGetTypeID(v60);
      if (v63 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t valuePtr = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
      }
      if ((const void *)*MEMORY[0x1E4F1CFC8] == v60) {
LABEL_107:
      }
        sec_protocol_options_set_tls_tickets_enabled(options, v62 == v60);
    }
    double v64 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC09F168);
    CFDateRef v65 = v64;
    if (v64)
    {
      CFTypeID v66 = CFGetTypeID(v64);
      if (v66 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t valuePtr = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
      }
      ssize_t v67 = *v29;
      if (*v29 == v65) {
        goto LABEL_117;
      }
      CFTypeID v68 = CFGetTypeID(v65);
      if (v68 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t valuePtr = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", valuePtr, 2u);
      }
      if ((const void *)*MEMORY[0x1E4F1CFC8] == v65) {
LABEL_117:
      }
        sec_protocol_options_set_enable_encrypted_client_hello(options, v67 == v65);
    }
    CFStringRef v69 = CFDictionaryGetValue(v25, &unk_1EC0A15B8);
    if (v69)
    {
      *(void *)uint64_t valuePtr = CFRetain(v69);
      std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>(a1 + 512, valuePtr);
      if (*(void *)valuePtr) {
        CFRelease(*(CFTypeRef *)valuePtr);
      }
    }
    if (*(void *)(a1 + 512))
    {
      BOOL v70 = *(atomic_ullong **)(a1 + 520);
      v117[0] = *(CFArrayRef *)(a1 + 512);
      v117[1] = (CFArrayRef)v70;
      if (v70) {
        atomic_fetch_add_explicit(v70 + 1, 1uLL, memory_order_relaxed);
      }
      NWIOConnection::_tlsCreateIdentityFromClientCertificates(destructor, v117);
      if (v70) {
        std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v70);
      }
      uint64_t v71 = destructor[0];
      if (destructor[0])
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        double v72 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v73 = *(void *)(a1 + 288);
          CFArrayRef Count = *(const __CFArray **)(a1 + 512);
          if (Count) {
            CFArrayRef Count = (const __CFArray *)CFArrayGetCount(Count);
          }
          *(_DWORD *)uint64_t valuePtr = 134218240;
          *(void *)&valuePtr[4] = v73;
          *(_WORD *)&valuePtr[12] = 2048;
          *(void *)&valuePtr[14] = Count;
          _os_log_impl(&dword_184085000, v72, OS_LOG_TYPE_DEFAULT, "Connection %llu: providing TLS Client Identity (%ld elements)", valuePtr, 0x16u);
        }
        sec_protocol_options_set_local_identity(options, v71);
        if (*(int *)(a1 + 528) <= 1) {
          *(_DWORD *)(a1 + 528) = 2;
        }
        sec_release(v71);
      }
    }
    uint64_t v75 = CFDictionaryGetValue(v25, &unk_1EC0A1708);
    uint64_t v76 = CFDictionaryGetValue(v25, &unk_1EC0A16D0);
    if (v75)
    {
      BOOL v77 = v76;
      if (v76)
      {
        CFRetain(v75);
        BytePtr = CFDataGetBytePtr((CFDataRef)v75);
        size_t Length = CFDataGetLength((CFDataRef)v75);
        int v80 = *(NSObject **)(a1 + 120);
        *(void *)uint64_t valuePtr = MEMORY[0x1E4F143A8];
        *(void *)&valuePtr[8] = 3221225472;
        *(void *)&valuePtr[16] = ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke;
        v119[0] = &__block_descriptor_40_e5_v8__0l;
        v119[1] = v75;
        uint64_t v81 = dispatch_data_create(BytePtr, Length, v80, valuePtr);
        CFRetain(v77);
        int v82 = CFDataGetBytePtr((CFDataRef)v77);
        size_t v83 = CFDataGetLength((CFDataRef)v77);
        uint64_t v84 = *(NSObject **)(a1 + 120);
        destructor[0] = (sec_identity_t)MEMORY[0x1E4F143A8];
        destructor[1] = (sec_identity_t)3221225472;
        destructor[2] = (sec_identity_t)___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_2;
        destructor[3] = (sec_identity_t)&__block_descriptor_40_e5_v8__0l;
        destructor[4] = v77;
        uint64_t v85 = dispatch_data_create(v82, v83, v84, destructor);
        sec_protocol_options_add_pre_shared_key(options, v81, v85);
        *(_WORD *)(a1 + 248) |= 0x400u;
        if (v85) {
          dispatch_release(v85);
        }
        if (v81) {
          dispatch_release(v81);
        }
      }
    }
    CFDataRef v86 = (const __CFData *)CFDictionaryGetValue(v25, &unk_1EC0A15F0);
    CFDataRef v87 = v86;
    if (v86)
    {
      unint64_t v88 = CFDataGetBytePtr(v86);
      unint64_t v89 = CFDataGetLength(v87);
      if (v89 >= 2)
      {
        unint64_t v90 = v89 >> 1;
        do
        {
          unsigned int v91 = *(unsigned __int16 *)v88;
          v88 += 2;
          MEMORY[0x18531DF00](options, v91);
          --v90;
        }
        while (v90);
      }
    }
    CFDataRef v92 = (const __CFData *)CFDictionaryGetValue(v25, &unk_1EC0A12A8);
    CFDataRef v93 = v92;
    if (v92)
    {
      CFRetain(v92);
      __int16 v94 = CFDataGetBytePtr(v93);
      size_t v95 = CFDataGetLength(v93);
      BOOL v96 = *(NSObject **)(a1 + 120);
      v115[0] = MEMORY[0x1E4F143A8];
      v115[1] = 3221225472;
      v115[2] = ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_3;
      v115[3] = &__block_descriptor_40_e5_v8__0l;
      v115[4] = v93;
      uint64_t v97 = dispatch_data_create(v94, v95, v96, v115);
      sec_protocol_options_set_tls_diffie_hellman_parameters(options, v97);
      if (v97) {
        dispatch_release(v97);
      }
    }
    CFArrayRef v98 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC09F8D8);
    if (v98) {
      addTransportSpecificALPN((int)options, v98);
    }
    CFArrayRef v99 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC09EF70);
    if (v99) {
      addTransportSpecificALPN((int)options, v99);
    }
  }
  CFDictionaryRef v100 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_1EC0A1270);
  CFDictionaryRef v101 = v100;
  if (v100)
  {
    unsigned int v102 = CFDictionaryGetValue(v100, &unk_1EC0A1740);
    unint64_t v103 = (unint64_t)v102;
    if (v102
      && (CFEqual(v102, (CFTypeRef)*MEMORY[0x1E4F3B528])
       || CFEqual((CFTypeRef)v103, (CFTypeRef)*MEMORY[0x1E4F3B518])
       || CFEqual((CFTypeRef)v103, (CFTypeRef)*MEMORY[0x1E4F3B520])))
    {
      sec_protocol_options_set_tls_max_version(options, kTLSProtocol1);
    }
    CFNumberRef v104 = (const __CFNumber *)CFDictionaryGetValue(v101, &unk_1EC0A05C0);
    CFNumberRef v105 = (const __CFNumber *)CFDictionaryGetValue(v101, &unk_1EC0A0588);
    if ((unint64_t)v104 | (unint64_t)v105)
    {
      if (v104)
      {
        *(void *)uint64_t valuePtr = 0;
        CFNumberGetValue(v104, kCFNumberCFIndexType, valuePtr);
        if (*(int *)valuePtr < 5)
        {
          SSLProtocol v106 = kTLSProtocol1;
        }
        else
        {
          *(void *)uint64_t valuePtr = 0;
          CFNumberGetValue(v104, kCFNumberCFIndexType, valuePtr);
          SSLProtocol v106 = *(_DWORD *)valuePtr;
        }
        sec_protocol_options_set_tls_min_version(options, v106);
      }
      if (!v105) {
        goto LABEL_188;
      }
      *(void *)uint64_t valuePtr = 0;
      CFNumberGetValue(v105, kCFNumberCFIndexType, valuePtr);
      SSLProtocol v110 = *(_DWORD *)valuePtr;
      if (!*(_DWORD *)valuePtr) {
        goto LABEL_188;
      }
LABEL_187:
      sec_protocol_options_set_tls_max_version(options, v110);
      goto LABEL_188;
    }
    CFStringRef v107 = (const __CFString *)CFDictionaryGetValue(v101, &unk_1EC0A1660);
    if (!(v103 | (unint64_t)v107)) {
      CFStringRef v107 = (const __CFString *)&unk_1EC0A13C0;
    }
    if (v107)
    {
      int ExactString = _findExactString(v107, 2u);
      SSLProtocol v109 = kTLSProtocol1;
      SSLProtocol v110 = kTLSProtocol12;
      if (ExactString <= 240455928)
      {
        if (ExactString <= 237252804)
        {
          if (ExactString != 236204212)
          {
            if (ExactString == 235147427) {
              abort();
            }
            goto LABEL_186;
          }
        }
        else if (ExactString != 237252805 && ExactString != 239366375)
        {
          goto LABEL_186;
        }
        goto LABEL_185;
      }
      switch(ExactString)
      {
        case 240455929:
          SSLProtocol v110 = kTLSProtocol1;
          break;
        case 241463566:
          SSLProtocol v109 = kTLSProtocol11;
          goto LABEL_185;
        case 242512160:
          SSLProtocol v109 = kTLSProtocol12;
LABEL_185:
          SSLProtocol v110 = v109;
          break;
      }
LABEL_186:
      sec_protocol_options_set_tls_min_version(options, v109);
      goto LABEL_187;
    }
  }
LABEL_188:
  if (v112) {
    std::__shared_weak_count::__release_weak(v112);
  }
  if (v114) {
    std::__shared_weak_count::__release_weak(v114);
  }
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void sub_184165504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,CFAllocatorRef allocator,uint64_t a40,void *ptr)
{
  std::default_delete<std::forward_list<SSLCiphersuiteGroup>>::operator()[abi:nn180100](v42);
  if (a19) {
    std::__shared_weak_count::__release_weak(a19);
  }
  if (a26) {
    std::__shared_weak_count::__release_weak(a26);
  }
  if (v41) {
    std::__shared_weak_count::__release_weak(v41);
  }
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::_tlsCreatePeerName(uint64_t this)
{
  if (!*(void *)(this + 416))
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(this + 368), &unk_1EC0A1270);
    uint64_t v2 = CFDictionaryGetValue(Value, &unk_1EC0A1698);
    if (v2) {
      CFRetain(v2);
    }
    operator new();
  }
  return this;
}

CFIndex addTransportSpecificALPN(int a1, CFArrayRef theArray)
{
  for (CFIndex i = 0; ; ++i)
  {
    CFIndex result = CFArrayGetCount(theArray);
    if (i >= result) {
      break;
    }
    objc_msgSend((id)CFArrayGetValueAtIndex(theArray, i), "UTF8String");
    sec_protocol_options_add_transport_specific_application_protocol();
  }
  return result;
}

void **std::default_delete<std::forward_list<SSLCiphersuiteGroup>>::operator()[abi:nn180100](void **result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    *uint64_t v1 = 0;
    JUMPOUT(0x18531B6D0);
  }
  return result;
}

void sub_184165A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c45_ZTSNSt3__18weak_ptrI20HTTP3ConnectionCacheEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void __destroy_helper_block_ea8_32c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void ___ZN17CoreSchedulingSet11getEmptySetEv_block_invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v1 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 96, 0);
  *(_OWORD *)uint64_t v1 = 0u;
  *((_OWORD *)v1 + 1) = 0u;
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  *((_OWORD *)v1 + 4) = 0u;
  *((_OWORD *)v1 + 5) = 0u;
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v1, v0);
  *(_DWORD *)(v2 + 40) = 0;
  *(void *)uint64_t v2 = &unk_1ECFA2200;
  *(void *)(v2 + 24) = &unk_1ECFA2288;
  CoreSchedulingSet::getEmptySet(void)::sEmptySet = v2;
}

void ___ZN12HTTPProtocol15needServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicybE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1[53]) {
    (*(void (**)(void, void))(*v1 + 120))(*(void *)(a1 + 32), 0);
  }

  CFRelease(v1 - 2);
}

void ___ZN19URLConnectionLoader30_loaderInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke_3(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 120))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  CFArrayRef v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    CFRelease(v4);
  }
}

void HTTPProtocol::_protocolInterface_useCredential(HTTPProtocol *this, _CFURLCredential *a2, _CFURLAuthChallenge *a3)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 41))
  {
    uint64_t v6 = *((void *)this + 97);
    if (v6) {
      AuthenticationState::setOption(v6, 0, *((unsigned char *)this + 40) != 0);
    }
  }
  if (isLikeChallenge(a3, *((_CFURLAuthChallenge **)this + 53)))
  {
    CFDictionaryRef v7 = (void *)*((void *)this + 11);
    CFURLRef v8 = (const __CFURL *)[v7 cfURL];
    if (v8
      && (CFTypeID v9 = (StrictSecurityPolicy *)*((void *)this + 92)) != 0
      && StrictSecurityPolicy::strictSecurityPolicyInEffectForURL(v9, v8, *(const __CFDictionary **)([v7 _inner] + 200)))
    {
      uint64_t v10 = 2;
    }
    else
    {
      uint64_t v10 = a2 != 0;
    }
    int v11 = (const void *)*((void *)this + 53);
    uint64_t v12 = (void (**)(void, void, void))*((void *)this + 54);
    *((void *)this + 53) = 0;
    *((void *)this + 54) = 0;
    if (v11) {
      CFRelease(v11);
    }
    if (v12)
    {
      v12[2](v12, v10, 0);
      _Block_release(v12);
    }
    CFNumberRef v13 = (NSURLRequest *)*((void *)this + 11);
    CFURLRef v14 = [(NSURLRequest *)v13 cfURL];
    HTTPProtocol::applyPreAuthenticationToCurrentRequest(this, 0, v13, v14);
    return;
  }
  if (isLikeChallenge(a3, *((_CFURLAuthChallenge **)this + 51)))
  {
    uint64_t v15 = (void (**)(void, void, void))*((void *)this + 52);
    *((void *)this + 52) = 0;
    if (a2)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      if (*((_DWORD *)a2 + 12) == 3)
      {
        int v16 = (char *)a2 + 16;
        CFAllocatorRef v17 = (const void *)(*(uint64_t (**)(char *))(*((void *)a2 + 2) + 120))((char *)a2 + 16);
        if (v17)
        {
          CFAllocatorRef v18 = CFGetAllocator((char *)this - 16);
          CFMutableArrayRef Mutable = CFArrayCreateMutable(v18, 0, MEMORY[0x1E4F1D510]);
          CFArrayAppendValue(Mutable, v17);
          CFArrayRef v20 = (const __CFArray *)(*(uint64_t (**)(char *))(*(void *)v16 + 112))(v16);
          CFArrayRef v21 = v20;
          if (v20 && CFArrayGetCount(v20) >= 1)
          {
            CFContainerEnumeratorBase::setup((unint64_t)&v88, v21, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
            uint64_t v93 = 0;
            while (1)
            {
              uint64_t v22 = v93;
              if (v93 >= *(uint64_t *)&v89[4]) {
                break;
              }
              ++v93;
              CFArrayAppendValue(Mutable, *(const void **)(*(void *)&v89[12] + 8 * v22));
            }
            CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v88);
          }
          goto LABEL_122;
        }
      }
    }
    else
    {
      int v37 = (void *)*((void *)this + 11);
      if (v37 && ([*((id *)this + 10) _shouldSkipPreferredClientCertificateLookup] & 1) == 0)
      {
        CFURLRef v38 = CFURLCopyAbsoluteURL(*(CFURLRef *)([v37 _inner] + 8));
        CFStringRef v39 = CFURLGetString(v38);
        CFIndex Length = CFStringGetLength(v39);
        CFIndex v41 = Length - 1;
        if (Length < 1) {
          goto LABEL_72;
        }
        uint64_t v42 = Length;
        while (CFStringGetCharacterAtIndex(v39, --v42) == 47)
        {
          if (v42 <= 0)
          {
            uint64_t v42 = -1;
            break;
          }
        }
        if (v42 == v41)
        {
LABEL_72:
          CFRetain(v39);
        }
        else
        {
          CFAllocatorRef v67 = CFGetAllocator(v37);
          v96.CFIndex length = v42 + 1;
          v96.location = 0;
          CFStringRef v39 = CFStringCreateWithSubstring(v67, v39, v96);
        }
        if (v38) {
          CFRelease(v38);
        }
        if (v39) {
          CFRelease(v39);
        }
      }
    }
    CFMutableArrayRef Mutable = 0;
LABEL_122:
    CFTypeID v68 = (const void *)*((void *)this + 51);
    *((void *)this + 51) = 0;
    if (v68) {
      CFRelease(v68);
    }
    if (v15)
    {
      ((void (**)(void, __CFArray *, void))v15)[2](v15, Mutable, 0);
      _Block_release(v15);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    return;
  }
  if (!a3) {
    goto LABEL_92;
  }
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t v23 = *((void *)a3 + 5);
  if (v23)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
    }
    if (*(_DWORD *)(v23 + 72) == 8) {
      return;
    }
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
    }
  }
  uint64_t v24 = *((void *)a3 + 5);
  if (v24)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
    }
    if (*(_DWORD *)(v24 + 72) == 7) {
      return;
    }
  }
  CFDictionaryRef v25 = (void *)*((void *)this + 10);
  if (!v25 || ([v25 _requiresSecureHTTPSProxyConnection] & 1) == 0)
  {
    if (__CFNUseNWHTTPSProxies::useProxyOnce != -1) {
      dispatch_once(&__CFNUseNWHTTPSProxies::useProxyOnce, &__block_literal_global_16_5533);
    }
    if (!__CFNUseNWHTTPSProxies::useNWHTTPSProxy) {
      goto LABEL_73;
    }
  }
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t v26 = *((void *)a3 + 5);
  if (!v26)
  {
LABEL_75:
    uint64_t v43 = *((void *)a3 + 5);
    if (v43)
    {
      if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
        dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
      }
      if (*(_DWORD *)(v43 + 72) == 11)
      {
        if (HTTPConnectionCacheKey::isFirstPartyResource(*((HTTPConnectionCacheKey **)this + 35))
          || ([*((id *)this + 11) _allowPrivateAccessTokensForThirdParty] & 1) != 0
          || (double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(v44),
              unsigned int v47 = *(void **)(v46 + 312),
              CFStringRef v48 = CFURLCopyHostName(*(CFURLRef *)(objc_msgSend(*((id *)this + 11), "_inner", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher)+ 8)), objc_msgSend(v47, "checkOriginAllowedAsThirdParty:", (id)CFMakeCollectable(v48))))
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          CFAllocatorRef v49 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v84 = *((void *)this + 99);
            int v88 = 138543362;
            *(void *)unint64_t v89 = v84;
            _os_log_debug_impl(&dword_184085000, v49, OS_LOG_TYPE_DEBUG, "%{public}@ handling PAT Challenge after use cred", (uint8_t *)&v88, 0xCu);
          }
          if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
            dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
          }
          CFStringRef v50 = (void *)*((void *)a3 + 8);
          uint64_t Auth = AuthenticationState::getAuth(*((AuthenticationState **)this + 97), 0);
          if (v50)
          {
            uint64_t v52 = Auth;
            uint64_t v53 = [v50 _inner];
            if (v52)
            {
              uint64_t v54 = *(void *)(v53 + 88);
              if (v54)
              {
                uint64_t v55 = (void *)*((void *)this + 11);
                int v56 = *(__CFArray **)(v52 + 232);
                BOOL isFirstPartyResource = HTTPConnectionCacheKey::isFirstPartyResource(*((HTTPConnectionCacheKey **)this
                                                                                    + 35));
                HTTPProtocol::askPATForCreds(this, (__CFHTTPMessage *)(v54 - 16), v56, !isFirstPartyResource, [v55 _allowPrivateAccessTokensForThirdParty], *(const __CFURL **)(objc_msgSend(v55, "_inner") + 32));
              }
            }
          }
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          BOOL v77 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v78 = *((void *)this + 99);
            int v88 = 138543362;
            *(void *)unint64_t v89 = v78;
            _os_log_impl(&dword_184085000, v77, OS_LOG_TYPE_DEFAULT, "%{public}@ unable to handle PAT challenge", (uint8_t *)&v88, 0xCu);
          }
LABEL_157:
          HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC0BLL);
          return;
        }
      }
    }
LABEL_92:
    if (a2)
    {
      if (*((void *)this + 47))
      {
        setTypeProperty<_CFURLAuthChallenge *>((CFTypeRef *)this + 47, a3);
        BOOL v58 = (_CFURLAuthChallenge *)*((void *)this + 47);
      }
      else
      {
        BOOL v58 = 0;
      }
      if (isLikeChallenge(a3, v58))
      {
        setTypeProperty<_CFURLCredential const*>((CFTypeRef *)this + 44, a2);
        *((_DWORD *)this + 48) |= 0x10000u;
        uint64_t v59 = (AuthenticationState *)*((void *)this + 97);
        if (!v59
          || !AuthenticationState::updateState(v59, 0, *((void *)this + 47), *((const _CFURLCredential **)this + 44), *((__SecTrust **)this + 57)))
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          uint64_t v60 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
          {
            uint64_t v82 = *((void *)this + 99);
            int v88 = 138543362;
            *(void *)unint64_t v89 = v82;
            _os_log_fault_impl(&dword_184085000, v60, OS_LOG_TYPE_FAULT, "%{public}@ invalid authentication state", (uint8_t *)&v88, 0xCu);
          }
          goto LABEL_157;
        }
      }
      else
      {
        CFTypeID v61 = (_CFURLAuthChallenge *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648))(this);
        if (isLikeChallenge(a3, v61))
        {
          if ((*((_DWORD *)this + 48) & 0x400000) == 0)
          {
            uint64_t ProtectionSpace = CFURLAuthChallengeGetProtectionSpace((uint64_t)a3);
            (*(void (**)(void, _CFURLCredential *, uint64_t, void))(**((void **)this + 87) + 64))(*((void *)this + 87), a2, ProtectionSpace, *((void *)this + 10));
          }
          (*(void (**)(HTTPProtocol *, _CFURLCredential *))(*(void *)this + 624))(this, a2);
          CFTypeID v63 = (AuthenticationState *)*((void *)this + 97);
          if (!v63
            || (unint64_t v64 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648))(this),
                CFDateRef v65 = (const _CFURLCredential *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616))(this),
                !AuthenticationState::updateState(v63, 0, v64, v65, 0)))
          {
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
            }
            CFTypeID v66 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
            {
              uint64_t v85 = *((void *)this + 99);
              int v88 = 138543362;
              *(void *)unint64_t v89 = v85;
              _os_log_fault_impl(&dword_184085000, v66, OS_LOG_TYPE_FAULT, "%{public}@ invalid proxy authentication state", (uint8_t *)&v88, 0xCu);
            }
            goto LABEL_157;
          }
        }
        else if (isLikeChallenge(a3, *((_CFURLAuthChallenge **)this + 48)))
        {
          setTypeProperty<_CFURLCredential const*>((CFTypeRef *)this + 45, a2);
          CFStringRef v69 = (void *)*((void *)this + 49);
          HTTPProtocol::executePACQuery(this, v69, 0);
          return;
        }
      }
    }
    else
    {
      *((_DWORD *)this + 48) |= 0x8000u;
    }
    uint64_t v70 = *((unsigned int *)this + 48);
    unint64_t v71 = v70 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    if ((v71 & 0x8000000000) != 0)
    {
      uint64_t v74 = *((void *)this + 97);
      uint64_t v75 = (std::__shared_weak_count *)*((void *)this + 98);
      if (v75) {
        atomic_fetch_add_explicit(&v75->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(*((void *)this + 78), v74, v75);
      if (v75) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v75);
      }
      SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs();
    }
    *((_DWORD *)this + 48) = v70 & 0xFFFFFFFD;
    *((_WORD *)this + 98) = (v71 & 0xFFFFFFFFFFFFFFFDLL) >> 32;
    if (v71)
    {
      if (!a3) {
        goto LABEL_147;
      }
      if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
        dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
      }
      uint64_t v72 = *((void *)a3 + 5);
      if (v72)
      {
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
        }
        int v73 = *(_DWORD *)(v72 + 72);
      }
      else
      {
LABEL_147:
        int v73 = 0;
      }
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v76 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
      {
        uint64_t v83 = *((void *)this + 99);
        int v88 = 138544386;
        *(void *)unint64_t v89 = v83;
        *(_WORD *)&v89[8] = 2048;
        *(void *)&v89[10] = a2;
        *(_WORD *)&v89[18] = 2048;
        unint64_t v90 = a3;
        __int16 v91 = 1024;
        LODWORD(v92[0]) = v73;
        WORD2(v92[0]) = 2112;
        *(void *)((char *)v92 + 6) = a3;
        _os_log_fault_impl(&dword_184085000, v76, OS_LOG_TYPE_FAULT, "%{public}@ in invalid state when supplying credential %p for challenge %p %d: %@", (uint8_t *)&v88, 0x30u);
      }
    }
    -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((void *)this + 104), 3, 0);
    HTTPProtocol::createAndOpenStream(this, 0);
    return;
  }
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  if (*(_DWORD *)(v26 + 60) != 6)
  {
LABEL_73:
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
    }
    goto LABEL_75;
  }
  uint64_t v27 = *((void *)this + 85);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  char v28 = CFNLog::logger;
  BOOL v29 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG);
  if (v27)
  {
    if (v29)
    {
      uint64_t v86 = *((void *)this + 99);
      uint64_t v87 = *((void *)this + 85);
      int v88 = 138544130;
      *(void *)unint64_t v89 = v86;
      *(_WORD *)&v89[8] = 2048;
      *(void *)&v89[10] = v87;
      *(_WORD *)&v89[18] = 2112;
      unint64_t v90 = (_CFURLAuthChallenge *)a2;
      __int16 v91 = 2112;
      v92[0] = a3;
      _os_log_debug_impl(&dword_184085000, v28, OS_LOG_TYPE_DEBUG, "%{public}@ useCredential for proxy (%lu) creds %@ challenge %@", (uint8_t *)&v88, 0x2Au);
    }
    uint64_t v30 = (uint64_t *)(*(void *)(*((void *)this + 81) + ((*((void *)this + 84) >> 5) & 0x7FFFFFFFFFFFFF8))
                    + 16 * *((void *)this + 84));
    uint64_t v32 = *v30;
    uint64_t v31 = (std::__shared_weak_count *)v30[1];
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (a2)
    {
      (*(void (**)(HTTPProtocol *, _CFURLCredential *))(*(void *)this + 624))(this, a2);
    }
    else
    {
      int v80 = (void *)*((void *)this + 10);
      if (v80)
      {
        if ([v80 _requiresSecureHTTPSProxyConnection])
        {
          uint64_t v81 = (void *)*((void *)this + 10);
          if (v81)
          {
            uint64_t v33 = [v81 _preventsSystemHTTPProxyAuthentication];
            if (v32) {
              goto LABEL_62;
            }
            goto LABEL_167;
          }
        }
      }
    }
    uint64_t v33 = 0;
    if (v32)
    {
LABEL_62:
      uint64_t v34 = *(void (**)(void *, _CFURLCredential *, uint64_t))(v32 + 8);
      uint64_t v35 = *(void *)(v32 + 16);
      CFTypeID v36 = (void *)(v32 + (v35 >> 1));
      if (v35) {
        uint64_t v34 = *(void (**)(void *, _CFURLCredential *, uint64_t))(*v36 + v34);
      }
      v34(v36, a2, v33);
    }
LABEL_167:
    std::deque<SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::pop_front((uint64_t)this + 640);
    if (v31) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v31);
    }
    return;
  }
  if (v29)
  {
    uint64_t v79 = *((void *)this + 99);
    int v88 = 138543618;
    *(void *)unint64_t v89 = v79;
    *(_WORD *)&v89[8] = 2112;
    *(void *)&v89[10] = a3;
    _os_log_debug_impl(&dword_184085000, v28, OS_LOG_TYPE_DEBUG, "%{public}@ ignoring stale proxy challenge %@", (uint8_t *)&v88, 0x16u);
  }
}

void sub_184166A90(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke_3(uint64_t a1, int a2, char a3)
{
  uint64_t v3 = *(void **)(a1 + 32);
  Tube::_complete_needServerTrust(v3, a2, a3);
  CFArrayRef v4 = *(uint64_t (**)(void *))(*v3 + 48);

  return v4(v3);
}

void Tube::_complete_needServerTrust(void *a1, int a2, char a3)
{
  (*(void (**)(void *))(*a1 + 40))(a1);
  uint64_t v6 = a1[20];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = ___ZN4Tube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicyb_block_invoke;
  v7[3] = &__block_descriptor_45_e5_v8__0l;
  v7[4] = a1;
  int v8 = a2;
  char v9 = a3;
  dispatch_async(v6, v7);
}

uint64_t AuthenticationState::setOption(uint64_t a1, int a2, int a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  }
  uint64_t v6 = *(void *)(a1 + 144);
  if (a2 != 1 || a3)
  {
    AuthenticationConfiguration::setOption(v6, a2, a3);
    if (!a2)
    {
      int v8 = &v11;
      int v11 = &unk_1ECFA63C0;
      char v12 = a3;
      CFNumberRef v13 = &v11;
      AuthenticationState::_foreachAuthenticationInfo(a1, (uint64_t)&v11);
      goto LABEL_9;
    }
  }
  else
  {
    char v7 = *(unsigned char *)(v6 + 8);
    *(unsigned char *)(v6 + 8) = v7 & 0xFD;
    if ((v7 & 2) != 0)
    {
      int v8 = (void **)v10;
      v10[0] = &unk_1ECFA6408;
      v10[3] = v10;
      AuthenticationState::_foreachAuthenticationInfo(a1, (uint64_t)v10);
LABEL_9:
      std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100](v8);
    }
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
}

void sub_184166D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::__function::__value_func<BOOL ()(AuthenticationState::AuthInfoType,std::shared_ptr<AuthenticationInfo> const&)>::~__value_func[abi:nn180100]((uint64_t *)va);
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  _Unwind_Resume(a1);
}

uint64_t AuthenticationConfiguration::setOption(uint64_t result, int a2, int a3)
{
  if (a2 == 2)
  {
    char v5 = *(unsigned char *)(result + 8);
    if (a3) {
      char v4 = v5 | 4;
    }
    else {
      char v4 = v5 & 0xFB;
    }
  }
  else if (a2 == 1)
  {
    char v6 = *(unsigned char *)(result + 8);
    if (a3) {
      char v4 = v6 | 2;
    }
    else {
      char v4 = v6 & 0xFD;
    }
  }
  else
  {
    if (a2) {
      return result;
    }
    char v3 = *(unsigned char *)(result + 8);
    if (a3) {
      char v4 = v3 | 1;
    }
    else {
      char v4 = v3 & 0xFE;
    }
  }
  *(unsigned char *)(result + 8) = v4;
  return result;
}

uint64_t isLikeChallenge(_CFURLAuthChallenge *a1, _CFURLAuthChallenge *a2)
{
  if (!a1 || !a2) {
    return 0;
  }
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  char v4 = (const void *)*((void *)a1 + 5);
  char v5 = (const void *)*((void *)a2 + 5);

  return CFEqual(v4, v5);
}

uint64_t ___ZN17CoreSchedulingSet18copyLoaderQueueSetEv_block_invoke()
{
  CFAllocatorRef v0 = dispatch_queue_create("com.apple.CFNetwork.LoaderQ", 0);
  uint64_t v1 = nw_context_copy_implicit_context();
  if (v1)
  {
    uint64_t v2 = (void *)v1;
    nw_queue_context_target_dispatch_queue();
    nw_release(v2);
  }
  char v3 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 96, 0);
  *(_OWORD *)char v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  CoreSchedulingSet::copyLoaderQueueSet(void)::sLoaderQueueSet = (uint64_t)QCoreSchedulingSet::QCoreSchedulingSet(v3, v0);
  char v4 = *(uint64_t (**)(void))(*(void *)CoreSchedulingSet::copyLoaderQueueSet(void)::sLoaderQueueSet + 112);

  return v4();
}

CFAllocatedReferenceCountedObject *QCoreSchedulingSet::QCoreSchedulingSet(CFAllocatedReferenceCountedObject *a1, NSObject *a2)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(a1, (const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
  *(_DWORD *)(v4 + 40) = 3;
  *(void *)uint64_t v4 = &unk_1ECF9F650;
  *(void *)(v4 + 24) = &unk_1ECF9F6D8;
  *(_DWORD *)(v4 + 64) = 0;
  *(void *)(v4 + 56) = a2;
  dispatch_retain(a2);
  return a1;
}

uint64_t CFURLCacheSetSharedURLCache(const void *a1)
{
  pthread_mutex_lock(&gSharedInstanceLock);
  if ((const void *)gSharedInstance != a1)
  {
    if (gSharedInstance) {
      CFRelease((CFTypeRef)gSharedInstance);
    }
    if (a1) {
      CFRetain(a1);
    }
    gShareduint64_t Instance = (uint64_t)a1;
  }

  return pthread_mutex_unlock(&gSharedInstanceLock);
}

void ___ZN10HTTPEngine22_readBufferCaptureBodyERNSt3__110shared_ptrI19HTTPResponseMessageEE_block_invoke(uint64_t a1)
{
}

void ___ZL17HARLoggingEnabledi_block_invoke()
{
  CFAllocatorRef v0 = (void *)MEMORY[0x18531D6D0]();
  int out_token = -1;
  if (notify_register_dispatch("com.apple.CFNetwork.har-capture-update", &out_token, MEMORY[0x1E4F14428], &__block_literal_global_176))
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v1 = (id)CFNLog::logger;
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v2 = 0;
      _os_log_error_impl(&dword_184085000, v1, OS_LOG_TYPE_ERROR, "Failed to dispatch registered notification", v2, 2u);
    }
  }
  readHARPreference();
}

void readHARPreference(void)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  double v0 = secondsToStopForHARLogging(@"har-capture-global");
  double v1 = 0.0;
  if (v0 > 0.0)
  {
    double v2 = v0;
    if (__CFNIsInDevelopmentEnvironment::onceToken != -1) {
      dispatch_once(&__CFNIsInDevelopmentEnvironment::onceToken, &__block_literal_global_30);
    }
    if (__CFNIsInDevelopmentEnvironment::ok
      || checkEntitlementForHARLogging(@"com.apple.private.cfnetwork.har-capture-delegation"))
    {
      HARPIDSpecific = 0;
      double v1 = v2;
    }
  }
  double v3 = secondsToStopForHARLogging(@"har-capture-pid-date");
  uint64_t v4 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
  char v5 = (CFStringRef *)MEMORY[0x1E4F1D3C8];
  if (v3 > v1)
  {
    double v6 = v3;
    if (__CFNIsInDevelopmentEnvironment::onceToken != -1) {
      dispatch_once(&__CFNIsInDevelopmentEnvironment::onceToken, &__block_literal_global_30);
    }
    if (__CFNIsInDevelopmentEnvironment::ok
      || checkEntitlementForHARLogging(@"com.apple.private.cfnetwork.har-capture-delegation"))
    {
      char v7 = (void *)CFPreferencesCopyValue(@"har-capture-pid-specific", @"com.apple.CFNetwork", *v4, *v5);
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        HARPIDSpecific = [v7 intValue];
        double v1 = v6;
      }
    }
  }
  double v8 = secondsToStopForHARLogging(@"har-capture-amp");
  if (v8 > v1)
  {
    double v9 = v8;
    if (checkEntitlementForHARLogging(@"com.apple.private.cfnetwork.har-capture-amp"))
    {
      HARPIDSpecific = 0;
      double v1 = v9;
    }
  }
  if (os_variant_has_internal_diagnostics() && getenv("CFNETWORK_HAR_LOGGING"))
  {
    double v1 = INFINITY;
LABEL_22:
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v10 = (id)CFNLog::logger;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = 134217984;
      double v23 = v1;
      _os_log_impl(&dword_184085000, v10, OS_LOG_TYPE_DEFAULT, "Starting HAR logging for %f seconds", (uint8_t *)&v22, 0xCu);
    }

    if (initializeHAR(void)::onceToken != -1) {
      dispatch_once(&initializeHAR(void)::onceToken, &__block_literal_global_214);
    }
    CFStringRef v11 = *v4;
    CFStringRef v12 = *v5;
    CFNumberRef v13 = (void *)CFPreferencesCopyValue(@"har-body-size-limit", @"com.apple.CFNetwork", v11, v12);
    uint64_t v14 = v13;
    if (v13) {
      HARBodySizeLimit = [v13 unsignedIntegerValue];
    }
    uint64_t v15 = getenv("CFNETWORK_HAR_BODYSIZELIMIT");
    if (v15) {
      HARBodySizeLimit = strtoul(v15, 0, 0);
    }
    CFPropertyListRef v16 = CFPreferencesCopyValue(@"har-path-denial-list", @"com.apple.CFNetwork", v11, v12);
    CFAllocatorRef v17 = (void *)HARPathDenialList;
    HARPathDenialList = (uint64_t)v16;

    CFPropertyListRef v18 = CFPreferencesCopyValue(@"har-host-denial-list", @"com.apple.CFNetwork", v11, v12);
    CFStringRef v19 = (void *)HARHostDenialList;
    HARHostDenialList = (uint64_t)v18;

    HAREnabled = 1;
    if (fabs(v1) != INFINITY)
    {
      dispatch_time_t v20 = dispatch_walltime(0, (uint64_t)(v1 * 1000000000.0));
      dispatch_after(v20, (dispatch_queue_t)HARQueue, &__block_literal_global_210);
    }

    return;
  }
  if (v1 > 1.0) {
    goto LABEL_22;
  }
  if (HAREnabled == 1)
  {
    CFArrayRef v21 = HARQueue;
    dispatch_async(v21, &__block_literal_global_212);
  }
}

void sub_184167620(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double secondsToStopForHARLogging(const __CFString *a1)
{
  double v1 = (void *)CFPreferencesCopyValue(a1, @"com.apple.CFNetwork", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  objc_opt_class();
  double v2 = 0.0;
  if (objc_opt_isKindOfClass())
  {
    [v1 timeIntervalSinceNow];
    double v2 = v3;
  }

  return v2;
}

void sub_1841676C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN11HTTP3Framer10_readFrameEmPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_13CFStreamErrorE_block_invoke(void *a1, long long *a2, void *a3, int a4, uint64_t a5, uint64_t a6)
{
  CFStringRef v11 = a3;
  if (v11)
  {
    uint64_t v12 = a1[6];
    CFNumberRef v13 = a1[4];
    if (dispatch_data_get_size(v13) >= a1[7]) {
      dispatch_data_t concat = v13;
    }
    else {
      dispatch_data_t concat = dispatch_data_create_concat(v13, v11);
    }
    dispatch_data_t v18 = concat;
    if (a4)
    {
      uint64_t v19 = a1[5];
      uint64_t v21 = *((void *)a2 + 2);
      long long v20 = *a2;
      (*(void (**)(uint64_t, long long *, dispatch_data_t))(v19 + 16))(v19, &v20, v18);
    }
    else
    {
      HTTP3Framer::_readFrame(v12, a1[7], concat, a1[5]);
    }
  }
  else
  {
    uint64_t v15 = a6;
    if (a6) {
      uint64_t v16 = a5;
    }
    else {
      uint64_t v16 = 4;
    }
    uint64_t v17 = a1[5];
    uint64_t v23 = *((void *)a2 + 2);
    long long v22 = *a2;
    if (!a6) {
      uint64_t v15 = 0xFFFFFFFFLL;
    }
    (*(void (**)(uint64_t, long long *, void, uint64_t, unint64_t))(v17 + 16))(v17, &v22, 0, v16, v15 | a6 & 0xFFFFFFFF00000000);
  }
}

void sub_184167900(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN11HTTP3Framer9readFrameEmU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke(uint64_t a1, long long *a2, uint64_t a3)
{
  *(unsigned char *)(*(void *)(a1 + 40) + 72) = 0;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v6 = *((void *)a2 + 2);
  long long v5 = *a2;
  return (*(uint64_t (**)(uint64_t, long long *, uint64_t))(v3 + 16))(v3, &v5, a3);
}

void ___ZN15HTTP3Connection18_readControlStreamEv_block_invoke(uint64_t a1, void **a2, void *a3, CFIndex a4, uint64_t a5)
{
  buffer_ptr[3] = *(void **)MEMORY[0x1E4F143B8];
  double v9 = a3;
  if (!v9 || a5)
  {
    if (a4 != 4) {
      goto LABEL_20;
    }
    if (a5 != -2300) {
      goto LABEL_20;
    }
    uint64_t v18 = *(void *)(a1 + 40);
    if ((*(unsigned char *)(v18 + 920) & 4) != 0) {
      goto LABEL_20;
    }
    uint64_t v19 = *(void *)(v18 + 1008);
    if (v19)
    {
      if ((*(uint64_t (**)(void))(*(void *)v19 + 120))(*(void *)(v18 + 1008)) != -1)
      {
LABEL_20:
        v59.CFIndex domain = a4;
        *(void *)&v59.error = a5;
        if (!HTTP3Connection::checkAndPerformFallback(*(HTTP3Connection **)(a1 + 40), v59))
        {
          uint64_t v23 = *(void *)(a1 + 40);
          *(unsigned char *)(v23 + 920) |= 2u;
          if (*(void *)(v23 + 1136) == *(void *)(v23 + 1144)) {
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v23, 256, 0);
          }
          goto LABEL_30;
        }
        long long v20 = CFN_LOG_h3connection();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v21 = *(void **)(a1 + 40);
          long long v22 = (void *)v21[152];
          LODWORD(buffer_ptr[0]) = 134218240;
          *(void **)((char *)buffer_ptr + 4) = v21;
          WORD2(buffer_ptr[1]) = 2048;
          *(void **)((char *)&buffer_ptr[1] + 6) = v22;
          _os_log_impl(&dword_184085000, v20, OS_LOG_TYPE_DEFAULT, "%p %llu Control stream fallback triggered", (uint8_t *)buffer_ptr, 0x16u);
        }
LABEL_23:

        goto LABEL_30;
      }
      uint64_t v18 = *(void *)(a1 + 40);
    }
    *(void *)(v18 + 1160) = 4;
    *(_DWORD *)(v18 + 1168) = -1;
    HTTP3Connection::_cleanupConnection((HTTP3Connection *)v18, 260, 0);
    HTTP3Connection::reportServerProtocolViolation(*(void *)(a1 + 40), 2, -1);
    long long v20 = CFN_LOG_h3connection();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
    {
      CFAllocatorRef v49 = *(void **)(a1 + 40);
      CFStringRef v50 = (void *)v49[152];
      LODWORD(buffer_ptr[0]) = 134218240;
      *(void **)((char *)buffer_ptr + 4) = v49;
      WORD2(buffer_ptr[1]) = 2048;
      *(void **)((char *)&buffer_ptr[1] + 6) = v50;
      _os_log_fault_impl(&dword_184085000, v20, OS_LOG_TYPE_FAULT, "%p %llu Control stream closed but connection is alive", (uint8_t *)buffer_ptr, 0x16u);
    }
    goto LABEL_23;
  }
  uint64_t v10 = *(void *)(a1 + 40);
  if ((*(unsigned char *)(v10 + 920) & 1) != 0 || *a2 == (void *)4)
  {
    if (*(void *)(v10 + 992)) {
      HTTP3Connection::_stopStallRecovery((HTTP3Connection *)v10);
    }
    switch((unint64_t)*a2)
    {
      case 0uLL:
      case 1uLL:
      case 5uLL:
        goto LABEL_28;
      case 2uLL:
      case 6uLL:
        goto LABEL_31;
      case 3uLL:
        size_t size_ptr = 0;
        buffer_ptr[0] = 0;
        dispatch_data_t v11 = dispatch_data_create_map(v9, (const void **)buffer_ptr, &size_ptr);
        size_t v55 = 0;
        int v56 = buffer_ptr[0];
        char v13 = QUICUtilities::quic_vle_decode((QUICUtilities *)&v56, (const unsigned __int8 **)&size_ptr, &v55, 0, v12);
        if (size_ptr) {
          char v14 = 0;
        }
        else {
          char v14 = v13;
        }
        uint64_t v15 = *(void *)(a1 + 40);
        if (v14)
        {
          int v16 = v55;
          if (*(_DWORD *)(v15 + 792) > (int)v55)
          {
            int v17 = *(_DWORD *)(v15 + 796);
            if (v17 <= (int)v55)
            {
              if (v17 < (int)v55)
              {
                do
                {
                  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(v15 + 800, v17, v17);
                  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(v15 + 840, v17, v17);
                  ++v17;
                }
                while (v16 != v17);
              }
              *(_DWORD *)(v15 + 796) = v16 + 1;
            }
            else
            {
              std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>((uint64_t *)(v15 + 800), v55);
              std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>((uint64_t *)(v15 + 840), v16);
            }
            CFStringRef v45 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((void *)(v15 + 672), v16);
            if (v45)
            {
              uint64_t v46 = v45[3];
              if (v46)
              {
                HTTP2ServerPushStream::_invokeCompletionHadlers(v46, 0);
                HTTP2ServerPush::_removeStream((HTTP2ServerPush *)(v15 + 624), v16, 1);
              }
            }
            unsigned int v47 = (void *)(v15 + 880);
            CFStringRef v48 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>(v47, v16);
            if (v48)
            {
              HTTP3Framer::cancelStream(v48[3], 268);
              std::__hash_table<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>>>::__erase_unique<int>(v47, v16);
            }

LABEL_34:
            HTTP3Connection::_readControlStream(*(HTTP3Connection **)(a1 + 40));
            goto LABEL_30;
          }
          *(void *)(v15 + 1160) = 4;
          *(_DWORD *)(v15 + 1168) = -1;
          HTTP3Connection::_cleanupConnection((HTTP3Connection *)v15, 264, 0);
          int v37 = 177;
        }
        else
        {
          *(void *)(v15 + 1160) = 4;
          *(_DWORD *)(v15 + 1168) = -1;
          HTTP3Connection::_cleanupConnection((HTTP3Connection *)v15, 262, 0);
          int v37 = 176;
        }
        HTTP3Connection::reportServerProtocolViolation(*(void *)(a1 + 40), v37, -1);

        goto LABEL_30;
      case 4uLL:
        uint64_t v26 = *(void *)(a1 + 40);
        if (*(unsigned char *)(v26 + 920))
        {
          *(void *)(v26 + 1160) = 4;
          *(_DWORD *)(v26 + 1168) = -1;
          HTTP3Connection::_cleanupConnection((HTTP3Connection *)v26, 261, 0);
          int v24 = 145;
          goto LABEL_29;
        }
        *(unsigned char *)(v26 + 920) |= 1u;
        size_t v53 = 0;
        uint64_t v54 = 0;
        dispatch_data_t v28 = dispatch_data_create_map(v9, (const void **)&v54, &v53);
        BOOL v29 = *(HTTP3Connection **)(a1 + 40);
        size_t size_ptr = (size_t)v54;
        buffer_ptr[0] = (void *)v53;
        if (!v53)
        {
LABEL_47:
          HTTP3Connection::_settingsReceived(v29);

          goto LABEL_34;
        }
        while (1)
        {
          size_t v55 = 0;
          int v56 = 0;
          if (!QUICUtilities::quic_vle_decode((QUICUtilities *)&size_ptr, (const unsigned __int8 **)buffer_ptr, (unint64_t *)&v56, 0, v27)|| !QUICUtilities::quic_vle_decode((QUICUtilities *)&size_ptr, (const unsigned __int8 **)buffer_ptr, &v55, 0, v30))
          {
            break;
          }
          if ((unsigned __int16)v56 == 1)
          {
            *((void *)v29 + 118) = v55;
          }
          else if ((unsigned __int16)v56 == 7)
          {
            *((void *)v29 + 119) = v55;
          }
          else if ((unsigned __int16)v56 - 2 < 4)
          {
            break;
          }
          if (!buffer_ptr[0])
          {
            BOOL v29 = *(HTTP3Connection **)(a1 + 40);
            goto LABEL_47;
          }
        }
        uint64_t v39 = *(void *)(a1 + 40);
        *(void *)(v39 + 1160) = 4;
        *(_DWORD *)(v39 + 1168) = -1;
        HTTP3Connection::_cleanupConnection((HTTP3Connection *)v39, 265, 0);
        HTTP3Connection::reportServerProtocolViolation(*(void *)(a1 + 40), 144, -1);

        goto LABEL_30;
      case 7uLL:
        size_t v55 = 0;
        int v56 = 0;
        dispatch_data_t v31 = dispatch_data_create_map(v9, (const void **)&v56, &v55);
        size_t v53 = 0;
        uint64_t v54 = v56;
        char v33 = QUICUtilities::quic_vle_decode((QUICUtilities *)&v54, (const unsigned __int8 **)&v55, &v53, 0, v32);
        if (v55) {
          char v34 = 0;
        }
        else {
          char v34 = v33;
        }
        if (v34)
        {
          if ((v53 & 3) == 0)
          {
            uint64_t v40 = *(void *)(a1 + 40);
            memset(buffer_ptr, 0, 24);
            std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(buffer_ptr, *(void **)(v40 + 1136), *(void **)(v40 + 1144), (uint64_t)(*(void *)(v40 + 1144) - *(void *)(v40 + 1136)) >> 4);
            CFIndex v41 = (char *)buffer_ptr[0];
            for (CFIndex i = (char *)buffer_ptr[1]; v41 != i; v41 += 16)
            {
              double v44 = *(HTTP3Stream **)v41;
              uint64_t v43 = (std::__shared_weak_count *)*((void *)v41 + 1);
              if (v43) {
                atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              if (*((void *)v44 + 42) >= v53)
              {
                HTTP3Stream::_cleanupStream((uint64_t)v44, 256, 0);
                *((void *)v44 + 33) = 4;
                *((void *)v44 + 34) = 4294965096;
                HTTP3Stream::_protocolCallback(v44);
              }
              if (v43) {
                std::__shared_weak_count::__release_shared[abi:nn180100](v43);
              }
            }
            HTTP3Connection::_cleanupIfNoStreams(*(void *)(a1 + 40));
            size_t size_ptr = (size_t)buffer_ptr;
            std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)&size_ptr);

            goto LABEL_34;
          }
          uint64_t v35 = *(void *)(a1 + 40);
          *(void *)(v35 + 1160) = 4;
          *(_DWORD *)(v35 + 1168) = -1;
          HTTP3Connection::_cleanupConnection((HTTP3Connection *)v35, 264, 0);
          int v36 = 161;
        }
        else
        {
          uint64_t v38 = *(void *)(a1 + 40);
          *(void *)(v38 + 1160) = 4;
          *(_DWORD *)(v38 + 1168) = -1;
          HTTP3Connection::_cleanupConnection((HTTP3Connection *)v38, 262, 0);
          int v36 = 160;
        }
        HTTP3Connection::reportServerProtocolViolation(*(void *)(a1 + 40), v36, -1);

        goto LABEL_30;
      default:
        if ((char *)*a2 - 984832 < (char *)2)
        {
LABEL_28:
          HTTP3Connection::_cleanupConnection(*(HTTP3Connection **)(a1 + 40), 261, 0);
          int v24 = 0;
          goto LABEL_29;
        }
LABEL_31:
        CFDictionaryRef v25 = CFN_LOG_h3connection();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v51 = *(void **)(*(void *)(a1 + 40) + 1216);
          uint64_t v52 = *a2;
          LODWORD(buffer_ptr[0]) = 134218240;
          *(void **)((char *)buffer_ptr + 4) = v51;
          WORD2(buffer_ptr[1]) = 2048;
          *(void **)((char *)&buffer_ptr[1] + 6) = v52;
          _os_log_debug_impl(&dword_184085000, v25, OS_LOG_TYPE_DEBUG, "%llu unsupported frame type %llu", (uint8_t *)buffer_ptr, 0x16u);
        }

        goto LABEL_34;
    }
  }
  *(void *)(v10 + 1160) = 4;
  *(_DWORD *)(v10 + 1168) = -1;
  HTTP3Connection::_cleanupConnection((HTTP3Connection *)v10, 266, 0);
  int v24 = 146;
LABEL_29:
  HTTP3Connection::reportServerProtocolViolation(*(void *)(a1 + 40), v24, -1);
LABEL_30:
}

void sub_1841680B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14, char a15)
{
  a14 = (void **)&a15;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a14);

  _Unwind_Resume(a1);
}

BOOL ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke(uint64_t a1, int a2, int a3, void *__src, unint64_t a5)
{
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(unsigned __int8 *)(v6 + 128);
  if (16 - v7 >= a5) {
    size_t v8 = a5;
  }
  else {
    size_t v8 = 16 - v7;
  }
  memcpy((void *)(v6 + 112 + v7), __src, v8);
  unsigned __int8 v9 = *(unsigned char *)(v6 + 128) + v8;
  *(unsigned char *)(v6 + 128) = v9;
  *(void *)(v6 + 96) = 0;
  *(void *)&v16[1] = v9;
  uint64_t v17 = v6 + 112;
  v16[0] = 0;
  unint64_t v15 = 0;
  int v11 = QUICUtilities::quic_vle_decode((QUICUtilities *)&v17, (const unsigned __int8 **)&v16[1], &v15, (unint64_t *)v16, v10);
  char v13 = 0;
  if (v11)
  {
    *(void *)(v6 + 80) = v15;
    *(void *)(v6 + 96) += v16[0];
    if (QUICUtilities::quic_vle_decode((QUICUtilities *)&v17, (const unsigned __int8 **)&v16[1], (unint64_t *)(v6 + 88), (unint64_t *)v16, v12))
    {
      *(void *)(v6 + 96) += v16[0];
      *(unsigned char *)(v6 + 128) = 0;
      char v13 = 1;
    }
    else
    {
      char v13 = 0;
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v13;
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t QUICUtilities::quic_vle_decode(QUICUtilities *this, const unsigned __int8 **a2, unint64_t *a3, unint64_t *a4, unsigned __int8 *a5)
{
  if (!this) {
    __assert_rtn("quic_vle_decode", "QUICUtilities.cpp", 48, "buffer");
  }
  long long v5 = *(_DWORD **)this;
  if (!*(void *)this) {
    __assert_rtn("quic_vle_decode", "QUICUtilities.cpp", 49, "*buffer");
  }
  if (!a2) {
    __assert_rtn("quic_vle_decode", "QUICUtilities.cpp", 50, "remaining_p");
  }
  if (!a3) {
    __assert_rtn("quic_vle_decode", "QUICUtilities.cpp", 51, "decoded_val");
  }
  unint64_t v6 = (unint64_t)*a2;
  if (!*a2) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int8 *)v5;
  if (v7 > 0x3F)
  {
    unsigned int v10 = v7 >> 6;
    if (v10 == 2)
    {
      if (v6 >= 4)
      {
        unint64_t v7 = bswap32(*v5 & 0xFFFFFF7F);
        unsigned int v8 = 4;
        goto LABEL_8;
      }
    }
    else if (v10 == 1)
    {
      if (v6 >= 2)
      {
        unint64_t v7 = bswap32(*(_WORD *)v5 & 0xFFBF) >> 16;
        unsigned int v8 = 2;
        goto LABEL_8;
      }
    }
    else if (v6 >= 8)
    {
      unint64_t v7 = bswap64(*(void *)v5 & 0xFFFFFFFFFFFFFF3FLL);
      unsigned int v8 = 8;
      goto LABEL_8;
    }
    return 0;
  }
  unsigned int v8 = 1;
LABEL_8:
  *a3 = v7;
  *(void *)this = (char *)v5 + v8;
  *a2 = (const unsigned __int8 *)(v6 - v8);
  if (a4) {
    *(unsigned char *)a4 = v8;
  }
  return 1;
}

void HTTP3Stream::_cleanupStream(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 129))
  {
    uint64_t v5 = *(void *)(a1 + 24);
    if (v5 && (a3 & 1) == 0) {
      HTTP3Framer::cancelStream(v5, a2);
    }
    *(unsigned char *)(a1 + 129) = 1;
    unint64_t v6 = *(std::__shared_weak_count **)(a1 + 56);
    if (v6)
    {
      unint64_t v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        unsigned int v8 = v7;
        uint64_t v9 = *(void *)(a1 + 48);
        if (v9)
        {
          if ((a3 & 1) == 0)
          {
            unsigned int v10 = (uint64_t *)(v9 + 352);
            while (1)
            {
              unsigned int v10 = (uint64_t *)*v10;
              if (!v10) {
                break;
              }
              if (v10[4] == a1)
              {
                unint64_t v11 = v10[5];
                if (v11 <= 0x3E)
                {
                  uint64_t v12 = v47;
                  char buffer = v11 | 0x40;
                  char v13 = *(FILE **)(v9 + 320);
                  if (v13)
                  {
                    char v14 = (FILE **)(v9 + 320);
                    goto LABEL_26;
                  }
LABEL_27:
                  size_t v22 = v12 - &buffer;
                  goto LABEL_28;
                }
                char buffer = 127;
                unint64_t v16 = v11 - 63;
                uint64_t v17 = 1;
                if (v11 - 63 >= 0x80)
                {
                  while (v17 != 6)
                  {
                    unint64_t v18 = v17;
                    v47[v17 - 1] = v16 | 0x80;
                    unint64_t v19 = v16 >> 7;
                    ++v17;
                    unint64_t v20 = v16 >> 14;
                    v16 >>= 7;
                    if (!v20)
                    {
                      if (v18 < 5)
                      {
                        p_char buffer = &v47[v18 - 1];
                        LOBYTE(v16) = v19;
                        goto LABEL_24;
                      }
                      break;
                    }
                  }
                  char v13 = *(FILE **)(v9 + 320);
                  if (v13)
                  {
                    char v14 = (FILE **)(v9 + 320);
                    goto LABEL_33;
                  }
                  goto LABEL_34;
                }
                p_char buffer = &buffer;
LABEL_24:
                uint64_t v12 = p_buffer + 2;
                v47[v17 - 1] = v16;
                char v14 = (FILE **)(v9 + 320);
                char v13 = *(FILE **)(v9 + 320);
                if (p_buffer + 2 <= &buffer)
                {
                  if (v13)
                  {
LABEL_33:
                    fwrite("qdec: warn: ", 0xCuLL, 1uLL, v13);
                    fprintf(*v14, "cannot generate Cancel Stream instruction for stream %llu; buf size=%zu",
                      v10[5],
                      6uLL);
                    fputc(10, *v14);
                  }
LABEL_34:
                  size_t v22 = -1;
                }
                else
                {
                  if (!v13) {
                    goto LABEL_27;
                  }
LABEL_26:
                  fwrite("qdec: debug: ", 0xDuLL, 1uLL, v13);
                  size_t v22 = v12 - &buffer;
                  fprintf(*v14, "cancelled stream %llu; generate instruction of %u bytes", v10[5], v22);
                  fputc(10, *v14);
LABEL_28:
                  destroy_header_block_read_ctx(v9 + 272, v10);
                  *(_DWORD *)(v9 + 296) += v22;
                  if (!v22) {
                    goto LABEL_36;
                  }
                }
                dispatch_data_t v23 = dispatch_data_create(&buffer, v22, 0, 0);
                HTTP3Connection::writeDecoderStream(v9, v23);

                goto LABEL_36;
              }
            }
            unint64_t v15 = *(FILE **)(v9 + 320);
            if (v15)
            {
              fwrite("qdec: info: ", 0xCuLL, 1uLL, v15);
              fwrite("could not find stream to cancel", 0x1FuLL, 1uLL, *(FILE **)(v9 + 320));
              fputc(10, *(FILE **)(v9 + 320));
            }
LABEL_36:
            std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v44, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
            int v24 = *(void **)(v9 + 1136);
            CFDictionaryRef v25 = *(void **)(v9 + 1144);
            if (v24 != v25)
            {
              while (*v24 != v44)
              {
                v24 += 2;
                if (v24 == v25)
                {
                  int v24 = *(void **)(v9 + 1144);
                  break;
                }
              }
            }
            if (v24 != v25)
            {
              int v26 = *(unsigned __int8 *)(a1 + 132);
              uint64_t v27 = v24 + 2;
              if (v24 + 2 != v25)
              {
                do
                {
                  int v24 = v27;
                  long long v28 = *(_OWORD *)v27;
                  *uint64_t v27 = 0;
                  v27[1] = 0;
                  BOOL v29 = (std::__shared_weak_count *)*(v27 - 1);
                  *((_OWORD *)v27 - 1) = v28;
                  if (v29) {
                    std::__shared_weak_count::__release_shared[abi:nn180100](v29);
                  }
                  uint64_t v27 = v24 + 2;
                }
                while (v24 + 2 != v25);
                CFDictionaryRef v25 = *(void **)(v9 + 1144);
              }
              while (v25 != v24)
              {
                uint64_t v30 = (std::__shared_weak_count *)*(v25 - 1);
                if (v30) {
                  std::__shared_weak_count::__release_shared[abi:nn180100](v30);
                }
                v25 -= 2;
              }
              *(void *)(v9 + 1144) = v24;
              if (*(void **)(v9 + 1136) == v24)
              {
                *(void *)(v9 + 1176) = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
                if (*(void *)(v9 + 992)) {
                  HTTP3Connection::_stopStallRecovery((HTTP3Connection *)v9);
                }
                if ((*(unsigned char *)(v9 + 920) & 2) != 0)
                {
                  HTTP3Connection::_cleanupConnection((HTTP3Connection *)v9);
                }
                else
                {
                  (*(void (**)(void, uint64_t))(**(void **)(v9 + 1008) + 88))(*(void *)(v9 + 1008), 1);
                  (*(void (**)(void, uint64_t, void))(**(void **)(v9 + 1008) + 136))(*(void *)(v9 + 1008), 1, 0);
                }
              }
              dispatch_data_t v31 = CFN_LOG_h3connection();
              if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
              {
                unint64_t v40 = *(void *)(v44 + 336);
                uint64_t v41 = *(void *)(v9 + 1216);
                *(_DWORD *)buf = 134218752;
                uint64_t v49 = v9;
                __int16 v50 = 2048;
                uint64_t v51 = v41;
                __int16 v52 = 2048;
                unint64_t v53 = v40;
                __int16 v54 = 1024;
                LODWORD(v55) = v26;
                _os_log_debug_impl(&dword_184085000, v31, OS_LOG_TYPE_DEBUG, "%p %llu Stream %llu ended successfully %{BOOL}d", buf, 0x26u);
              }

              if ((*(unsigned char *)(v9 + 920) & 6) == 0)
              {
                if (v26)
                {
                  *(void *)(v9 + 1224) = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
                  *(void *)(v9 + 1232) = 0;
                }
                else
                {
                  unint64_t v32 = *(void *)(v9 + 1232) + 1;
                  *(void *)(v9 + 1232) = v32;
                  if (v32 >= 0xB)
                  {
                    __uint64_t v33 = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX) - *(void *)(v9 + 1224);
                    if (v33 >= 0xDF8475801)
                    {
                      char v34 = CFN_LOG_h3connection();
                      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v42 = *(void *)(v9 + 1216);
                        uint64_t v43 = *(void *)(v9 + 1232);
                        *(_DWORD *)buf = 134218752;
                        uint64_t v49 = v9;
                        __int16 v50 = 2048;
                        uint64_t v51 = v42;
                        __int16 v52 = 2048;
                        unint64_t v53 = v33 / 0x3B9ACA00;
                        __int16 v54 = 2048;
                        uint64_t v55 = v43;
                        _os_log_error_impl(&dword_184085000, v34, OS_LOG_TYPE_ERROR, "%p %llu Terminating broken connection, last success %llus ago, consecutive failures %llu", buf, 0x2Au);
                      }

                      HTTP3Connection::_cleanupIfNoStreams(v9);
                    }
                  }
                }
              }
            }
            if (v45) {
              std::__shared_weak_count::__release_shared[abi:nn180100](v45);
            }
          }
          if (*(unsigned char *)(a1 + 368))
          {
            uint64_t v35 = *(void *)(v9 + 1008);
            int v36 = *(std::__shared_weak_count **)(v9 + 1016);
            if (v36) {
              atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v35)
            {
              uint64_t v37 = *(void *)(a1 + 296);
              if (v37) {
                uint64_t v38 = v37 - 176;
              }
              else {
                uint64_t v38 = 0;
              }
              if (*(unsigned char *)(a1 + 369)) {
                uint64_t v39 = 6;
              }
              else {
                uint64_t v39 = 8;
              }
              (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v35 + 280))(v35, *(void *)(v38 + 80), v39, *(void *)(a1 + 344));
              *(unsigned char *)(a1 + 368) = 0;
            }
            if (v36) {
              std::__shared_weak_count::__release_shared[abi:nn180100](v36);
            }
          }
        }
        std::__shared_weak_count::__release_shared[abi:nn180100](v8);
      }
    }
  }
}

void sub_184168980(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

id CFN_LOG_h3connection(void)
{
  if (CFN_LOG_h3connection(void)::once != -1) {
    dispatch_once(&CFN_LOG_h3connection(void)::once, &__block_literal_global_63);
  }
  double v0 = (void *)CFN_LOG_h3connection(void)::log;

  return v0;
}

uint64_t non-virtual thunk to'NWIOConnection::unregisterContext(uint64_t a1)
{
  return MEMORY[0x1F40F2CC0](*(void *)(a1 + 160));
}

uint64_t HTTP3Framer::cancelStream(uint64_t a1, uint64_t a2)
{
  if (a2 != -1)
  {
    uint64_t v3 = *(NSObject **)(a1 + 48);
    uint64_t v4 = nw_protocol_copy_quic_connection_definition();
    nw_protocol_metadata_t v5 = nw_content_context_copy_protocol_metadata(v3, v4);

    unint64_t v6 = (void *)nw_quic_connection_copy_stream_metadata();
    nw_quic_stream_set_application_error();
  }
  unint64_t v7 = *(uint64_t (**)(void))(**(void **)(a1 + 16) + 48);

  return v7();
}

void sub_184168AD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HTTP3Connection::_settingsReceived(HTTP3Connection *this)
{
  unsigned int v2 = *((_DWORD *)this + 236);
  if (v2 >= 0x10000) {
    unint64_t v3 = 0x10000;
  }
  else {
    unint64_t v3 = v2;
  }
  *((void *)this + 118) = v3;
  if (*((void *)this + 119) >= 0x64uLL) {
    uint64_t v4 = 100;
  }
  else {
    uint64_t v4 = *((void *)this + 119);
  }
  *((void *)this + 119) = v4;
  if (v3)
  {
    buffer[0] = 32;
    nw_protocol_metadata_t v5 = lsqpack_enc_int(buffer, (unint64_t)&v22, v3, 5);
    if (v5 <= buffer)
    {
      *__error() = 55;
      size_t v8 = 6;
      goto LABEL_25;
    }
    unint64_t v6 = v5;
    unint64_t v7 = (FILE *)*((void *)this + 29);
    if (v7)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
      size_t v8 = v6 - buffer;
      fprintf(*((FILE **)this + 29), "generated TSU=%u instruction %zd byte%.*s in size", v3, v8, v8 != 1, "s");
      fputc(10, *((FILE **)this + 29));
    }
    else
    {
      size_t v8 = v5 - buffer;
    }
  }
  else
  {
    size_t v8 = 0;
  }
  unsigned int v9 = v3 / 0x60;
  if (v3 <= 0x4DF) {
    unsigned int v9 = 12;
  }
  *((_DWORD *)this + 65) = v9;
  unsigned int v10 = malloc_type_malloc(8 * v9 + 8, 0x100004000313F17uLL);
  *((void *)this + 31) = v10;
  if (!v10)
  {
LABEL_24:
    if (!v8) {
      return;
    }
    goto LABEL_25;
  }
  if (v2 < 0x20)
  {
    unint64_t v11 = 0;
    int v12 = 0;
LABEL_23:
    *((_DWORD *)this + 14) = v2;
    *((_DWORD *)this + 15) = v2 >> 5;
    *((_DWORD *)this + 13) = v3;
    *((_DWORD *)this + 17) = v4;
    *((void *)this + 13) = v11;
    *((_DWORD *)this + 21) = v12;
    *((void *)this + 29) = 0;
    *((_DWORD *)this + 11) |= 2u;
    goto LABEL_24;
  }
  unint64_t v11 = (char *)malloc_type_malloc(0x80uLL, 0xA004088793A40uLL);
  if (v11)
  {
    uint64_t v13 = 0;
    long long v14 = 0uLL;
    do
    {
      unint64_t v15 = (double *)&v11[v13];
      uint64_t v16 = (uint64_t)&v11[v13 + 32];
      uint64_t v17 = (uint64_t)&v11[v13 + 16];
      uint64_t v18 = (uint64_t)&v11[v13 + 48];
      long long v19 = 0uLL;
      vst4q_f64(v15, *(float64x2x4_t *)&v14);
      v13 += 64;
    }
    while (v13 != 128);
    int v12 = 2;
    goto LABEL_23;
  }
  free(*((void **)this + 31));
  if (!v8) {
    return;
  }
LABEL_25:
  dispatch_data_t v20 = dispatch_data_create(buffer, v8, 0, 0);
  HTTP3Connection::writeEncoderStream((uint64_t)this, v20);
}

void sub_184168D20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HTTP3Connection::writeEncoderStream(uint64_t a1, void *a2)
{
  unint64_t v3 = a2;
  uint64_t v4 = *(void *)(a1 + 1008);
  if (v4 && (*(unsigned char *)(a1 + 920) & 4) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 1040);
    if (!v5)
    {
      uint64_t v6 = HTTP3Connection::_newClientUnidirectionalStreamHandle((HTTP3Connection *)"outbound encoder", 0);
      unint64_t v7 = *(void **)(a1 + 1040);
      *(void *)(a1 + 1040) = v6;

      char buffer = 2;
      size_t v8 = dispatch_data_create(&buffer, 1uLL, 0, 0);
      dispatch_data_t concat = dispatch_data_create_concat(v8, v3);

      uint64_t v4 = *(void *)(a1 + 1008);
      uint64_t v5 = *(void *)(a1 + 1040);
      unint64_t v3 = concat;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, NSObject *, void *))(*(void *)v4 + 64))(v4, v5, 1, v3, &__block_literal_global_6093);
  }
}

void sub_184168E14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184169020(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(a1);
}

CFSetRef ___ZN19TransportConnection20observablePropertiesEv_block_invoke()
{
  if ((_ZGVZZN19TransportConnection20observablePropertiesEvEUb_E23observablePropertyNames & 1) == 0)
  {
    _ZZZN19TransportConnection20observablePropertiesEvEUb_E23observablePropertyNames = 0x1EC09E8A8;
    _ZGVZZN19TransportConnection20observablePropertiesEvEUb_E23observablePropertyNames = 1;
  }
  CFSetRef result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&_ZZZN19TransportConnection20observablePropertiesEvEUb_E23observablePropertyNames, 1, MEMORY[0x1E4F1D548]);
  TransportConnection::observableProperties(void)::observableProps = (uint64_t)result;
  return result;
}

CFTypeRef ___ZL22_coreSchedulingSet_RLMv_block_invoke()
{
  double v0 = +[NSURLConnection resourceLoaderRunLoop];
  if (v0)
  {
    CFTypeRef result = CFRetain(v0);
    _coreSchedulingSet_RLM(void)::sLoaderRunLoop = (uint64_t)result;
    if (result) {
      return result;
    }
  }
  else
  {
    _coreSchedulingSet_RLM(void)::sLoaderRunLoop = 0;
  }
  CFTypeRef result = CoreSchedulingSet::createNewPrivateRunLoopThread((uint64_t)"com.apple.CFNetwork.LoaderRL", 0, 0);
  _coreSchedulingSet_RLM(void)::sLoaderRunLoop = (uint64_t)result;
  return result;
}

uint64_t CookieParser_parse(CFAllocatorRef alloc, char **a2, CFTypeRef *a3, const __CFURL *a4, const void *a5)
{
  CFAllocatorRef v5 = alloc;
  int v55 = 0;
  uint64_t v6 = 0;
  signed int v7 = 0u;
  unint64_t __src = v65;
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  CFStringRef v61 = 0;
  unint64_t v8 = 200;
  unsigned int v9 = (__int16 *)v66;
  unsigned int v10 = v66;
  unint64_t v11 = (CFTypeRef *)v65;
  int v12 = -2;
  while (1)
  {
    *(_WORD *)unsigned int v10 = v7;
    if (&v9[v8 - 1] <= (__int16 *)v10)
    {
      if (v8 >> 4 > 0x270
        || (2 * v8 >= 0x2710 ? (uint64_t v13 = 10000) : (uint64_t v13 = 2 * v8),
            (long long v14 = (__int16 *)malloc_type_malloc(10 * v13 + 7, 0x2EE69A94uLL)) == 0))
      {
        LODWORD(v26) = 0;
        uint64_t v48 = 2;
        goto LABEL_89;
      }
      unint64_t v15 = v14;
      int v58 = v12;
      uint64_t v16 = v6;
      uint64_t v17 = (v10 - (char *)v9) >> 1;
      uint64_t v18 = v17 + 1;
      memcpy(v14, v9, 2 * (v17 + 1));
      int64_t v19 = v13;
      dispatch_data_t v20 = (char *)v15 + ((2 * v13 + 7) & 0xFFFFFFFFFFFFFFF8);
      memcpy(v20, __src, 8 * (v17 + 1));
      if (v9 != (__int16 *)v66) {
        free(v9);
      }
      unsigned int v10 = (char *)&v15[v17];
      unint64_t v11 = (CFTypeRef *)&v20[8 * v18 - 8];
      if (v19 <= v18)
      {
        LODWORD(v26) = 0;
        uint64_t v48 = 1;
        unsigned int v9 = v15;
        LODWORD(v6) = v16;
        int v12 = v58;
        goto LABEL_89;
      }
      unint64_t v8 = v19;
      unsigned int v9 = v15;
      unint64_t __src = v20;
      uint64_t v6 = v16;
      int v12 = v58;
    }
    unint64_t v59 = v8;
    if ((0x5CB2FF9BCD0FFCuLL >> v7)) {
      break;
    }
    int v21 = yypact_23480[v7];
    if (v12 == -2) {
      int v12 = CookieParser_lex(&v61, v5, a2);
    }
    if (v12 < 1)
    {
      uint64_t v6 = 0;
      int v12 = 0u;
    }
    else
    {
      uint64_t v6 = v12 > 0x10D ? 2 : yytranslate_23481[v12];
    }
    uint64_t v22 = (v6 + v21);
    if (v22 > 0x57 || v6 != yycheck_23482[v22]) {
      break;
    }
    signed int v23 = yytable_23483[v22];
    if (!yytable_23483[v22]) {
      goto LABEL_34;
    }
    if (v22 == 6)
    {
      LODWORD(v26) = 0;
      uint64_t v48 = 0;
      goto LABEL_89;
    }
    int v24 = v55 - 1;
    if (!v55) {
      int v24 = 0;
    }
    int v55 = v24;
    if (v12) {
      int v12 = -2;
    }
    else {
      int v12 = 0;
    }
    v11[1] = v61;
    ++v11;
    signed int v7 = v23;
LABEL_84:
    v10 += 2;
    unint64_t v8 = v59;
    CFAllocatorRef v5 = alloc;
  }
  if (((0x20010000129003uLL >> v7) & 1) == 0)
  {
    uint64_t v25 = yydefact_23484[v7];
    uint64_t v26 = yyr2_23485[v25];
    switch(v7)
    {
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 22:
      case 24:
      case 28:
      case 29:
      case 31:
      case 32:
      case 41:
      case 49:
      case 51:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124:
      case 125:
      case 126:
      case 127:
      case 128:
      case 129:
      case 130:
      case 131:
      case 132:
      case 133:
      case 134:
      case 135:
      case 136:
      case 137:
      case 138:
      case 139:
      case 140:
      case 141:
      case 142:
        goto LABEL_33;
      case 13:
      case 60:
      case 61:
      case 64:
      case 67:
      case 68:
      case 71:
      case 73:
        uint64_t v49 = v11;
        goto LABEL_103;
      case 14:
      case 63:
        CFMutableArrayRef Mutable = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
        uint64_t v27 = (__CFString *)Mutable;
        if (!*v11) {
          break;
        }
        CFArrayAppendValue(Mutable, *v11);
        goto LABEL_78;
      case 16:
        CFMutableArrayRef v31 = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
        goto LABEL_55;
      case 19:
      case 56:
      case 57:
      case 62:
      case 66:
      case 69:
      case 72:
      case 96:
        uint64_t v49 = v11 - 1;
LABEL_103:
        uint64_t v48 = 0;
        *a3 = *v49;
        goto LABEL_89;
      case 21:
      case 26:
      case 30:
      case 42:
        CFMutableArrayRef v31 = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
LABEL_55:
        uint64_t v27 = (__CFString *)v31;
        break;
      case 23:
        uint64_t v30 = *(v11 - 2);
        if (v30)
        {
          CFArrayInsertValueAtIndex((CFMutableArrayRef)*v11, 0, v30);
          CFRelease(*(v11 - 2));
        }
LABEL_33:
        uint64_t v27 = (__CFString *)*v11;
        break;
      case 25:
        uint64_t v27 = @"=";
        break;
      case 27:
        Cookie = (__CFString *)_makeCookie(alloc, *(v11 - 2), &stru_1ECFAD558, (const __CFDictionary *)*v11, a4, a5);
        goto LABEL_66;
      case 33:
        CFRelease(*v11);
        uint64_t v27 = (__CFString *)&unk_1EC0A1858;
        break;
      case 34:
        CFRelease(*v11);
        uint64_t v27 = (__CFString *)&unk_1EC0A1938;
        break;
      case 35:
        CFRelease(*v11);
        uint64_t v27 = (__CFString *)&unk_1EC0A1A18;
        break;
      case 36:
        CFRelease(*v11);
        uint64_t v27 = (__CFString *)&unk_1EC0A1AF8;
        break;
      case 37:
        CFRelease(*v11);
        uint64_t v27 = (__CFString *)&unk_1EC0A1BA0;
        break;
      case 38:
        CFRelease(*v11);
        uint64_t v27 = (__CFString *)&unk_1EC0A19E0;
        break;
      case 39:
        CFRelease(*v11);
        uint64_t v27 = (__CFString *)&unk_1EC0A1C80;
        break;
      case 43:
        *(void *)&values.year = 0;
        values.second = 0.0;
        *(void *)&values.year = *v11;
        *(void *)&values.second = &stru_1ECFAD558;
        uint64_t v27 = (__CFString *)CFArrayCreate(alloc, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
        goto LABEL_78;
      case 44:
        uint64_t v27 = (__CFString *)CFStringCreateWithFormat(alloc, 0, @"%@%@", *(v11 - 1), *v11);
        goto LABEL_76;
      case 45:
        uint64_t v27 = (__CFString *)_makeCookie(alloc, *(v11 - 3), *(v11 - 1), (const __CFDictionary *)*v11, a4, a5);
        CFRelease(*(v11 - 3));
LABEL_76:
        unint64_t v40 = *(v11 - 1);
        goto LABEL_77;
      case 46:
      case 48:
        *(void *)&values.year = 0;
        values.second = 0.0;
        *(void *)&values.year = *(v11 - 1);
        *(void *)&values.second = &stru_1ECFAD558;
        uint64_t v27 = (__CFString *)CFArrayCreate(alloc, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
        goto LABEL_57;
      case 47:
        __uint64_t v33 = (__CFDictionary *)*v11;
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)*(v11 - 1), 0);
        uint64_t v35 = CFArrayGetValueAtIndex((CFArrayRef)*(v11 - 1), 1);
        CFDictionaryAddValue(v33, ValueAtIndex, v35);
        uint64_t v27 = (__CFString *)*v11;
LABEL_57:
        int v36 = *(v11 - 1);
        goto LABEL_79;
      case 50:
        *(void *)&values.year = 0;
        values.second = 0.0;
        CFTimeZoneRef tz = 0;
        uint64_t v62 = &unk_1EC0A1970;
        CFTypeID v63 = &stru_1ECFAD558;
        _CFGregorianDateCreateWithString(alloc, (CFStringRef)*v11, (uint64_t)&values, (CFTypeRef *)&tz);
        if (!values.year) {
          goto LABEL_85;
        }
        CFAbsoluteTime AbsoluteTime = CFGregorianDateGetAbsoluteTime(values, tz);
        CFDateRef v38 = CFDateCreate(alloc, AbsoluteTime);
        if (tz) {
          CFRelease(tz);
        }
        if (v38)
        {
          char v39 = 0;
          CFDateRef v50 = v38;
          CFTypeID v63 = (__CFString *)v38;
        }
        else
        {
LABEL_85:
          CFDateRef v50 = 0;
          char v39 = 1;
        }
        uint64_t v27 = (__CFString *)CFArrayCreate(alloc, (const void **)&v62, 2, MEMORY[0x1E4F1D510]);
        CFRelease(*(v11 - 2));
        CFRelease(*v11);
        if (v39) {
          break;
        }
        int v36 = v50;
        goto LABEL_79;
      case 52:
        *(void *)&values.year = 0;
        values.second = 0.0;
        *(void *)&values.year = *(v11 - 2);
        *(void *)&values.second = *v11;
        Cookie = (__CFString *)CFArrayCreate(alloc, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
        goto LABEL_66;
      case 54:
      case 100:
        Cookie = (__CFString *)CFStringCreateWithFormat(alloc, 0, @"%@, %@", *(v11 - 2), *v11);
LABEL_66:
        uint64_t v27 = Cookie;
        unint64_t v40 = *(v11 - 2);
LABEL_77:
        CFRelease(v40);
LABEL_78:
        int v36 = *v11;
LABEL_79:
        CFRelease(v36);
        break;
      default:
        uint64_t v27 = (__CFString *)v11[1 - v26];
        break;
    }
    uint64_t v41 = &v11[-v26];
    v10 -= 2 * v26;
    v41[1] = v27;
    unint64_t v11 = v41 + 1;
    uint64_t v42 = yyr1_23497[v25] - 18;
    uint64_t v43 = (*(__int16 *)v10 + yypgoto_23498[v42]);
    if (v43 <= 0x57 && *(unsigned __int16 *)v10 == (unsigned __int16)yycheck_23482[v43]) {
      signed int v7 = yytable_23483[v43];
    }
    else {
      signed int v7 = yydefgoto_23499[v42];
    }
    goto LABEL_84;
  }
LABEL_34:
  if (v55 == 3)
  {
    if (v12 > 0)
    {
      yydestruct_23502(v6, (CFTypeRef *)&v61);
      int v12 = -2;
      goto LABEL_39;
    }
    if (!v12)
    {
      LODWORD(v26) = 0;
      uint64_t v48 = 1;
      goto LABEL_92;
    }
  }
  while (1)
  {
LABEL_39:
    if (((0x5CB2FF9BCD0FFCuLL >> v7) & 1) == 0 && ((0x234D006432D003uLL >> v7) & 1) != 0 && yypact_23480[v7] == 2)
    {
      v11[1] = v61;
      ++v11;
      signed int v7 = 1u;
      int v55 = 3;
      goto LABEL_84;
    }
    if (v10 == (char *)v9) {
      break;
    }
    yydestruct_23502(yystos_23503[v7], v11--);
    signed int v28 = *((__int16 *)v10 - 1);
    v10 -= 2;
    signed int v7 = v28;
  }
  LODWORD(v26) = 0;
  uint64_t v48 = 1;
  unsigned int v10 = (char *)v9;
LABEL_89:
  if (v12 != -2 && v12) {
    yydestruct_23502(v6, (CFTypeRef *)&v61);
  }
LABEL_92:
  uint64_t v44 = (__int16 *)&v10[-2 * v26];
  if (v44 != v9)
  {
    CFStringRef v45 = &v11[-v26];
    do
    {
      uint64_t v46 = *v44--;
      yydestruct_23502(yystos_23503[v46], v45--);
    }
    while (v44 != v9);
  }
  if (v9 != (__int16 *)v66) {
    free(v9);
  }
  return v48;
}

uint64_t CookieParser_lex(CFStringRef *a1, CFAllocatorRef alloc, char **a3)
{
  uint64_t v6 = (const UInt8 *)*a3;
  *a1 = 0;
  while (2)
  {
    switch(*v6)
    {
      case 0u:
        goto LABEL_112;
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 0xBu:
      case 0xCu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x2Cu:
      case 0x3Bu:
      case 0x3Du:
      case 0x7Fu:
        signed int v7 = (char *)(v6 + 1);
        uint64_t result = *(char *)v6;
        goto LABEL_229;
      case 9u:
      case 0x20u:
        ++v6;
        continue;
      case 0xAu:
        signed int v7 = (char *)(v6 + 1);
        if (*((char *)v6 + 1) < 1) {
          goto LABEL_111;
        }
        uint64_t result = 10;
        goto LABEL_229;
      case 0xDu:
        signed int v7 = (char *)(v6 + 1);
        if (v6[1])
        {
          if (v6[1] != 10 || (int v21 = *((char *)v6 + 2), v6 += 2, v21 >= 1))
          {
            uint64_t result = 13;
            goto LABEL_229;
          }
        }
        else
        {
LABEL_111:
          uint64_t v6 = (const UInt8 *)v7;
        }
LABEL_112:
        signed int v7 = (char *)(v6 + 1);
        uint64_t result = 261;
        goto LABEL_229;
      case 0x22u:
        unsigned int v9 = (char *)v6;
LABEL_93:
        while (2)
        {
          while (2)
          {
            signed int v7 = v9 + 1;
            int v22 = v9[1];
            signed int v23 = v9;
            unsigned int v9 = v7;
            int v24 = v7;
            switch(v22)
            {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 10:
              case 11:
              case 12:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
              case 22:
              case 23:
              case 24:
              case 25:
              case 26:
              case 27:
              case 28:
              case 29:
              case 30:
              case 31:
                goto LABEL_225;
              case 9:
              case 32:
                unsigned int v9 = v23 + 2;
                while (2)
                {
                  int v22 = *v9;
                  switch(*v9)
                  {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 10:
                    case 11:
                    case 12:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                      goto LABEL_225;
                    case 9:
                    case 32:
                      ++v9;
                      continue;
                    case 13:
                      goto LABEL_141;
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 58:
                    case 60:
                      goto LABEL_93;
                    case 34:
                      goto LABEL_161;
                    case 44:
                      int v24 = v9;
                      goto LABEL_101;
                    case 59:
                    case 61:
                      goto LABEL_144;
                    default:
                      goto LABEL_98;
                  }
                }
              case 13:
                unsigned int v9 = v7;
                goto LABEL_141;
              case 33:
              case 35:
              case 36:
              case 37:
              case 38:
              case 39:
              case 40:
              case 41:
              case 42:
              case 43:
              case 45:
              case 46:
              case 47:
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 58:
              case 60:
                continue;
              case 34:
                goto LABEL_161;
              case 44:
                goto LABEL_101;
              case 59:
              case 61:
                goto LABEL_144;
              default:
                unsigned int v9 = v7;
LABEL_98:
                if (v22 == 127) {
                  goto LABEL_225;
                }
                continue;
            }
          }
LABEL_101:
          unsigned int v9 = v24 + 1;
          switch(v24[1])
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 10:
            case 11:
            case 12:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              goto LABEL_103;
            case 9:
            case 32:
            case 59:
              goto LABEL_144;
            case 13:
              __uint64_t v33 = (char *)v24[2];
              unsigned int v9 = v24 + 2;
              if (v24[2] > 0x3D) {
                goto LABEL_172;
              }
              if (((1 << v24[2]) & 0x28000000FFFFF9FFLL) != 0) {
                goto LABEL_157;
              }
              if (v33 == (char *)10)
              {
                signed int v7 = v24 + 2;
LABEL_142:
                int v37 = *++v9;
                int v36 = v37;
                if (v37 != 9 && v36 != 32) {
                  goto LABEL_225;
                }
                while (1)
                {
LABEL_144:
                  unsigned int v39 = *++v9;
                  uint64_t v38 = v39;
                  if (v39 <= 0x22)
                  {
                    if (((1 << v38) & 0xFFFFDDFFLL) != 0) {
                      goto LABEL_225;
                    }
                    if (v38 == 13)
                    {
LABEL_141:
                      int v35 = *++v9;
                      if (v35 != 10) {
                        goto LABEL_225;
                      }
                      goto LABEL_142;
                    }
                    if (v38 == 34) {
                      goto LABEL_154;
                    }
                  }
                  if (v38 == 127) {
                    goto LABEL_225;
                  }
                }
              }
LABEL_172:
              if (v33 == 127) {
                goto LABEL_157;
              }
              int v13 = 2;
              uint64_t result = 34;
              break;
            case 33:
            case 35:
            case 36:
            case 37:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
              continue;
            case 34:
              goto LABEL_161;
            default:
              if (v24[1] != 127) {
                continue;
              }
LABEL_103:
              uint64_t result = 34;
              goto LABEL_250;
          }
          goto LABEL_169;
        }
      case 0x27u:
        signed int v7 = (char *)v6;
        break;
      case 0x28u:
      case 0x29u:
      case 0x2Fu:
      case 0x3Au:
      case 0x3Cu:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x5Bu:
      case 0x5Cu:
      case 0x5Du:
      case 0x7Bu:
      case 0x7Du:
        uint64_t result = *(char *)v6;
        unsigned int v9 = (char *)v6;
        goto LABEL_250;
      case 0x43u:
      case 0x63u:
        signed int v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x6F) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x6D) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x6D) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x65) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6E) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 6);
        int v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x74) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 7);
        unsigned int v11 = *((char *)v6 + 7);
        if ((v11 > 0x3D || ((1 << v11) & 0x28000000FFFFFDFFLL) == 0) && v11 != 127)
        {
          LOBYTE(v12) = v6[7];
          int v13 = 7;
          goto LABEL_84;
        }
LABEL_188:
        CFStringRef v49 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_206:
        *a1 = v49;
        uint64_t result = 262;
        goto LABEL_229;
      case 0x44u:
      case 0x64u:
        signed int v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x6F) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x6D) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x61) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x69) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6E) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 6);
        unsigned int v14 = *((char *)v6 + 6);
        if ((v14 > 0x3D || ((1 << v14) & 0x28000000FFFFFDFFLL) == 0) && v14 != 127)
        {
          LOBYTE(v12) = v6[6];
          int v13 = 5;
          goto LABEL_84;
        }
LABEL_184:
        CFStringRef v47 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_202:
        *a1 = v47;
        uint64_t result = 263;
        goto LABEL_229;
      case 0x45u:
      case 0x65u:
        signed int v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x78) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x70) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x69) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x72) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x65) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 6);
        int v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x73) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 7);
        unsigned int v15 = *((char *)v6 + 7);
        if ((v15 > 0x3D || ((1 << v15) & 0x28000000FFFFFDFFLL) == 0) && v15 != 127)
        {
          LOBYTE(v12) = v6[7];
          int v13 = 8;
          goto LABEL_84;
        }
LABEL_190:
        CFStringRef v50 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_208:
        *a1 = v50;
        uint64_t result = 269;
        goto LABEL_229;
      case 0x48u:
      case 0x68u:
        signed int v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x74) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x74) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x70) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x6F) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6E) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 6);
        int v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x6C) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 7);
        int v10 = *((char *)v6 + 7);
        if ((v10 | 0x20) != 0x79) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 8);
        unsigned int v16 = *((char *)v6 + 8);
        if ((v16 > 0x3D || ((1 << v16) & 0x28000000FFFFFDFFLL) == 0) && v16 != 127)
        {
          LOBYTE(v12) = v6[8];
          int v13 = 11;
          goto LABEL_84;
        }
LABEL_180:
        CFStringRef v45 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_198:
        *a1 = v45;
        uint64_t result = 267;
        goto LABEL_229;
      case 0x4Du:
      case 0x6Du:
        signed int v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x61) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x78) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 3);
        int v12 = v6[3];
        if (v12 != 45) {
          goto LABEL_83;
        }
        signed int v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x61
          || (signed int v7 = (char *)(v6 + 5), v10 = *((char *)v6 + 5), (v10 | 0x20) != 0x67)
          || (signed int v7 = (char *)(v6 + 6), v10 = *((char *)v6 + 6), (v10 | 0x20) != 0x65))
        {
LABEL_82:
          LOBYTE(v12) = v10;
LABEL_83:
          int v13 = 1;
          goto LABEL_84;
        }
        signed int v7 = (char *)(v6 + 7);
        unsigned int v17 = *((char *)v6 + 7);
        if ((v17 > 0x3D || ((1 << v17) & 0x28000000FFFFFDFFLL) == 0) && v17 != 127)
        {
          LOBYTE(v12) = v6[7];
          int v13 = 9;
          goto LABEL_84;
        }
LABEL_192:
        CFStringRef v51 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_210:
        *a1 = v51;
        uint64_t result = 264;
        goto LABEL_229;
      case 0x50u:
      case 0x70u:
        signed int v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x61) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x74) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x68) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 4);
        unsigned int v18 = *((char *)v6 + 4);
        if ((v18 > 0x3D || ((1 << v18) & 0x28000000FFFFFDFFLL) == 0) && v18 != 127)
        {
          LOBYTE(v12) = v6[4];
          int v13 = 4;
          goto LABEL_84;
        }
LABEL_182:
        CFStringRef v46 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_200:
        *a1 = v46;
        uint64_t result = 265;
        goto LABEL_229;
      case 0x53u:
      case 0x73u:
        signed int v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x65) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x63) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x75) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x72) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x65) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 6);
        unsigned int v19 = *((char *)v6 + 6);
        if ((v19 > 0x3D || ((1 << v19) & 0x28000000FFFFFDFFLL) == 0) && v19 != 127)
        {
          LOBYTE(v12) = v6[6];
          int v13 = 6;
          goto LABEL_84;
        }
LABEL_186:
        CFStringRef v48 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_204:
        *a1 = v48;
        uint64_t result = 266;
        goto LABEL_229;
      case 0x56u:
      case 0x76u:
        signed int v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x65) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x72) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x73) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x69) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6F) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 6);
        int v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x6E) {
          goto LABEL_82;
        }
        signed int v7 = (char *)(v6 + 7);
        unsigned int v20 = *((char *)v6 + 7);
        if (v20 <= 0x3D && ((1 << v20) & 0x28000000FFFFFDFFLL) != 0 || v20 == 127)
        {
LABEL_194:
          CFStringRef v52 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_212:
          *a1 = v52;
          uint64_t result = 268;
        }
        else
        {
          LOBYTE(v12) = v6[7];
          int v13 = 10;
LABEL_84:
          uint64_t result = *(char *)v6;
          while (1)
          {
            int v54 = (char)v12;
            if ((char)v12 <= 122)
            {
              uint64_t v43 = v7;
              unsigned int v9 = v7;
              switch(v54)
              {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 59:
                case 61:
                  goto LABEL_216;
                case 9:
                case 32:
                  goto LABEL_238;
                case 34:
                case 40:
                case 41:
                case 47:
                case 58:
                case 60:
                case 62:
                case 63:
                case 64:
                case 91:
                case 92:
                case 93:
                  goto LABEL_250;
                case 44:
                  goto LABEL_244;
                default:
                  goto LABEL_213;
              }
            }
            if ((char)v12 == 123 || (char)v12 == 125)
            {
              unsigned int v9 = v7;
              goto LABEL_250;
            }
            if ((char)v12 == 127) {
              break;
            }
LABEL_213:
            char v53 = *++v7;
            LOBYTE(v12) = v53;
            int v13 = 1;
          }
LABEL_216:
          if (v6 >= (const UInt8 *)v7) {
            CFStringRef v55 = &stru_1ECFAD558;
          }
          else {
            CFStringRef v55 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
          }
          *a1 = v55;
          uint64_t result = 258;
        }
        goto LABEL_229;
      default:
        uint64_t result = *(char *)v6;
        signed int v7 = (char *)v6;
        goto LABEL_213;
    }
    break;
  }
  while (2)
  {
    unsigned int v25 = *++v7;
    uint64_t result = v25;
    switch(v25)
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x7Fu:
        goto LABEL_216;
      case 9u:
      case 0x20u:
        int v13 = 1;
LABEL_114:
        unsigned int v9 = v7 + 1;
        while (2)
        {
          switch(*v9)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 10:
            case 11:
            case 12:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              goto LABEL_117;
            case 9:
            case 32:
              ++v9;
              continue;
            case 13:
              goto LABEL_122;
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 40:
            case 41:
            case 42:
            case 43:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 60:
              goto LABEL_107;
            case 39:
LABEL_161:
              unsigned int v40 = *++v9;
              LODWORD(v33) = v40;
              uint64_t v41 = (1 << v40) & 0x28000000FFFFFDFFLL;
              BOOL v42 = v40 > 0x3D || v41 == 0;
              if (v42 && v33 != 127)
              {
                int v13 = 3;
                uint64_t result = *(char *)v6;
                goto LABEL_169;
              }
              signed int v7 = v9;
LABEL_177:
              if (v6 >= (const UInt8 *)v7) {
                CFStringRef v44 = &stru_1ECFAD558;
              }
              else {
                CFStringRef v44 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
              }
              *a1 = v44;
              uint64_t result = 259;
              break;
            case 44:
              __uint64_t v33 = v9;
              goto LABEL_133;
            case 59:
            case 61:
              goto LABEL_125;
            default:
              if (*v9 == 127) {
                goto LABEL_117;
              }
              goto LABEL_107;
          }
          break;
        }
        break;
      case 0xDu:
        int v13 = 1;
LABEL_121:
        unsigned int v9 = v7;
        goto LABEL_122;
      case 0x22u:
      case 0x28u:
      case 0x29u:
      case 0x2Fu:
      case 0x3Au:
      case 0x3Cu:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x5Bu:
      case 0x5Cu:
      case 0x5Du:
      case 0x7Bu:
      case 0x7Du:
        unsigned int v9 = v7;
LABEL_107:
        signed int v7 = v9;
        while (2)
        {
          int v27 = *++v7;
          int v26 = v27;
          switch(v27)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 10:
            case 11:
            case 12:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              goto LABEL_225;
            case 9:
            case 32:
              int v13 = 2;
              goto LABEL_114;
            case 13:
              int v13 = 2;
              goto LABEL_121;
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 40:
            case 41:
            case 42:
            case 43:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 60:
              continue;
            case 39:
              unsigned int v9 = v7;
              goto LABEL_161;
            case 44:
              int v13 = 2;
              goto LABEL_132;
            case 59:
            case 61:
              int v13 = 2;
              goto LABEL_119;
            default:
              if (v26 == 127) {
                goto LABEL_225;
              }
              continue;
          }
        }
      case 0x27u:
        goto LABEL_213;
      case 0x2Cu:
        int v13 = 1;
LABEL_132:
        __uint64_t v33 = v7;
LABEL_133:
        unsigned int v9 = v33 + 1;
        uint64_t result = 39;
        switch(v33[1])
        {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 10:
          case 11:
          case 12:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
            goto LABEL_250;
          case 9:
          case 32:
          case 59:
            goto LABEL_125;
          case 13:
            uint64_t v34 = v33[2];
            unsigned int v9 = v33 + 2;
            int v13 = 2;
            if (v33[2] > 0x3D) {
              goto LABEL_174;
            }
            if (((1 << v33[2]) & 0x28000000FFFFF9FFLL) != 0) {
              goto LABEL_157;
            }
            if (v34 == 10)
            {
              signed int v7 = v33 + 2;
LABEL_123:
              int v30 = *++v9;
              int v29 = v30;
              if (v30 != 9 && v29 != 32)
              {
LABEL_117:
                uint64_t result = 39;
                goto LABEL_176;
              }
              while (1)
              {
LABEL_125:
                unsigned int v32 = *++v9;
                uint64_t v31 = v32;
                if (v32 <= 0x27)
                {
                  if (((1 << v31) & 0xFFFFDDFFLL) != 0) {
                    goto LABEL_117;
                  }
                  if (v31 == 13)
                  {
LABEL_122:
                    int v28 = *++v9;
                    if (v28 != 10) {
                      goto LABEL_117;
                    }
                    goto LABEL_123;
                  }
                  if (v31 == 39)
                  {
LABEL_154:
                    signed int v7 = v9 + 1;
                    goto LABEL_177;
                  }
                }
                if (v31 == 127) {
                  goto LABEL_117;
                }
              }
            }
LABEL_174:
            if (v34 != 127)
            {
              uint64_t result = 39;
              LODWORD(v33) = v33[2];
LABEL_169:
              uint64_t v43 = v9;
              while (1)
              {
                if (v33 > 0x3D) {
                  goto LABEL_249;
                }
                if (((1 << (char)v33) & 0x100000200) == 0) {
                  break;
                }
                signed int v7 = v9;
LABEL_238:
                LODWORD(v33) = v7[1];
                unsigned int v9 = v7 + 1;
              }
              if (((1 << (char)v33) & 0x28000000FFFFFDFFLL) != 0)
              {
                signed int v7 = v43;
              }
              else if (v33 == 44)
              {
                signed int v7 = v9;
LABEL_244:
                while (1)
                {
                  char v59 = v7[1];
                  unsigned int v9 = v7 + 1;
                  if (v59 <= 0x3B)
                  {
                    signed int v7 = v43;
                    if (((1 << v59) & 0x800000100000200) != 0) {
                      break;
                    }
                  }
LABEL_250:
                  signed int v7 = v9;
                  while (1)
                  {
                    unsigned int v58 = *++v7;
                    uint64_t v57 = v58;
                    if (v58 <= 0x3D)
                    {
                      if (((1 << v57) & 0x28000000FFFFFDFFLL) != 0) {
                        goto LABEL_225;
                      }
                      if (((1 << v57) & 0x100000200) != 0)
                      {
                        int v13 = 2;
                        uint64_t v43 = v7;
                        goto LABEL_238;
                      }
                      if (v57 == 44) {
                        break;
                      }
                    }
                    if (v57 == 127) {
                      goto LABEL_225;
                    }
                  }
                  int v13 = 2;
                  uint64_t v43 = v7;
                }
              }
              else
              {
LABEL_249:
                signed int v7 = v43;
                if (v33 != 127) {
                  goto LABEL_250;
                }
              }
LABEL_176:
              switch(v13)
              {
                case 0:
                  goto LABEL_229;
                case 1:
                  goto LABEL_216;
                case 2:
                  goto LABEL_225;
                case 3:
                  goto LABEL_177;
                case 4:
                  if (v6 < (const UInt8 *)v7) {
                    goto LABEL_182;
                  }
                  CFStringRef v46 = &stru_1ECFAD558;
                  goto LABEL_200;
                case 5:
                  if (v6 < (const UInt8 *)v7) {
                    goto LABEL_184;
                  }
                  CFStringRef v47 = &stru_1ECFAD558;
                  goto LABEL_202;
                case 6:
                  if (v6 < (const UInt8 *)v7) {
                    goto LABEL_186;
                  }
                  CFStringRef v48 = &stru_1ECFAD558;
                  goto LABEL_204;
                case 7:
                  if (v6 < (const UInt8 *)v7) {
                    goto LABEL_188;
                  }
                  CFStringRef v49 = &stru_1ECFAD558;
                  goto LABEL_206;
                case 8:
                  if (v6 < (const UInt8 *)v7) {
                    goto LABEL_190;
                  }
                  CFStringRef v50 = &stru_1ECFAD558;
                  goto LABEL_208;
                case 9:
                  if (v6 < (const UInt8 *)v7) {
                    goto LABEL_192;
                  }
                  CFStringRef v51 = &stru_1ECFAD558;
                  goto LABEL_210;
                case 10:
                  if (v6 < (const UInt8 *)v7) {
                    goto LABEL_194;
                  }
                  CFStringRef v52 = &stru_1ECFAD558;
                  goto LABEL_212;
                default:
                  if (v6 < (const UInt8 *)v7) {
                    goto LABEL_180;
                  }
                  CFStringRef v45 = &stru_1ECFAD558;
                  goto LABEL_198;
              }
            }
LABEL_157:
            signed int v7 = v9;
LABEL_225:
            if (v6 >= (const UInt8 *)v7) {
              CFStringRef v56 = &stru_1ECFAD558;
            }
            else {
              CFStringRef v56 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
            }
            *a1 = v56;
            uint64_t result = 260;
            break;
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
            goto LABEL_107;
          case 39:
            goto LABEL_161;
          default:
            if (v33[1] == 127) {
              goto LABEL_250;
            }
            goto LABEL_107;
        }
        break;
      case 0x3Bu:
      case 0x3Du:
        int v13 = 1;
LABEL_119:
        unsigned int v9 = v7;
        goto LABEL_125;
      default:
        continue;
    }
    break;
  }
LABEL_229:
  *a3 = v7;
  return result;
}

id _makeCookie(const __CFAllocator *a1, const void *a2, const void *a3, const __CFDictionary *a4, const __CFURL *a5, const void *a6)
{
  CFStringRef theString = 0;
  value = 0;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  v40[0] = MEMORY[0x1E4F143A8];
  v40[1] = 3221225472;
  uint64_t v41 = ___makeCookie_block_invoke;
  BOOL v42 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v43 = Mutable;
  CFDictionarySetValue(Mutable, &unk_1EC0A1A50, a2);
  CFDictionarySetValue(Mutable, &unk_1EC0A1C48, a3);
  if (a4)
  {
    CFIndex Count = CFDictionaryGetCount(a4);
    int v13 = (const void **)CFAllocatorAllocate(a1, 8 * Count, 0);
    unsigned int v14 = (const void **)CFAllocatorAllocate(a1, 8 * Count, 0);
    CFDictionaryGetKeysAndValues(a4, v13, v14);
    if (Count >= 1)
    {
      unsigned int v15 = (CFStringRef *)v13;
      unsigned int v16 = v14;
      do
      {
        unsigned int CanonicalString = _findCanonicalString(*v15, 3u);
        if (CanonicalString == 571) {
          CFDictionaryAddValue(Mutable, *v15, *v16);
        }
        else {
          CFDictionaryAddValue(Mutable, &gConstantCFStringValueTable[7 * ((CanonicalString >> 20) & 0x3FF)], *v16);
        }
        ++v16;
        ++v15;
        --Count;
      }
      while (Count);
    }
    CFAllocatorDeallocate(a1, v13);
    CFAllocatorDeallocate(a1, v14);
  }
  if (a5) {
    CFStringRef v18 = CFURLCopyHostName(a5);
  }
  else {
    CFStringRef v18 = 0;
  }
  if (!CFDictionaryGetValueIfPresent(Mutable, &unk_1EC0A1938, (const void **)&value)
    || !CFStringGetLength((CFStringRef)value))
  {
    if (!v18)
    {
LABEL_22:
      CFDictionarySetValue(Mutable, &unk_1EC0A1938, @".^filecookies^");
      goto LABEL_23;
    }
LABEL_20:
    if (CFStringGetLength(v18) >= 1)
    {
      CFDictionarySetValue(Mutable, &unk_1EC0A1938, v18);
LABEL_24:
      CFRelease(v18);
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  if (v18 && isTopLevelDomain(v18, 1)) {
    goto LABEL_20;
  }
  if (!CFStringHasPrefix((CFStringRef)value, @".")
    && !CookieUtils::looksLikeIPAddress((const __CFString *)value, v19))
  {
    CFStringRef v20 = CFStringCreateWithFormat(a1, 0, @".%@", value);
    CFDictionarySetValue(Mutable, &unk_1EC0A1938, v20);
    CFRelease(v20);
  }
LABEL_23:
  if (v18) {
    goto LABEL_24;
  }
LABEL_25:
  if (!CFDictionaryGetValueIfPresent(Mutable, &unk_1EC0A1AF8, (const void **)&theString)
    || !CFStringGetLength(theString)
    || CFEqual(theString, @"\"\"")
    || CFEqual(theString, @"''"))
  {
    if (a5)
    {
      CFStringRef v21 = CFURLCopyPath(a5);
      if (v21)
      {
        if (CFEqual(@"/", v21))
        {
          int v22 = (__CFString *)v21;
LABEL_44:
          CFDictionarySetValue(Mutable, &unk_1EC0A1AF8, v22);
          CFRelease(v22);
          goto LABEL_45;
        }
        v23.CFIndex length = CFStringFind(v21, @"/", 4uLL).location;
        if (v23.length < 1)
        {
          int v22 = @"/";
        }
        else
        {
          v23.location = 0;
          int v22 = (__CFString *)CFStringCreateWithSubstring(a1, v21, v23);
        }
        CFRelease(v21);
        if (v22) {
          goto LABEL_44;
        }
      }
    }
    int v22 = (__CFString *)CFRetain(@"/");
    goto LABEL_44;
  }
  CFIndex Length = CFStringGetLength(theString);
  CFStringRef v25 = theString;
  if (Length >= 3)
  {
    if (CFStringGetCharacterAtIndex(theString, 0) == 34)
    {
      CFStringRef v26 = theString;
      CFIndex v27 = CFStringGetLength(theString);
      if (CFStringGetCharacterAtIndex(v26, v27 - 1) == 34) {
        goto LABEL_40;
      }
    }
    int CharacterAtIndex = CFStringGetCharacterAtIndex(theString, 0);
    CFStringRef v25 = theString;
    if (CharacterAtIndex != 39) {
      goto LABEL_59;
    }
    CFIndex v29 = CFStringGetLength(theString);
    if (CFStringGetCharacterAtIndex(v25, v29 - 1) == 39)
    {
LABEL_40:
      CFStringRef v30 = theString;
      v46.CFIndex length = CFStringGetLength(theString) - 2;
      v46.location = 1;
      CFStringRef v31 = CFStringCreateWithSubstring(a1, v30, v46);
      CFStringRef v25 = (const __CFString *)CFAutorelease(v31);
      CFStringRef theString = v25;
    }
    else
    {
      CFStringRef v25 = theString;
    }
  }
LABEL_59:
  CFStringRef v38 = CFURLCreateStringByAddingPercentEscapes(a1, v25, @"%", 0, 0x8000100u);
  if (v38)
  {
    CFDictionarySetValue(Mutable, &unk_1EC0A1AF8, v38);
    CFRelease(v38);
  }
LABEL_45:
  CFStringRef v32 = (const __CFString *)CFDictionaryGetValue(Mutable, &unk_1EC0A1AF8);
  CFStringRef theString = v32;
  if (v32)
  {
    if (CFStringGetLength(v32) >= 2)
    {
      if (CFStringHasPrefix(theString, @"\""))
      {
        if (CFStringHasSuffix(theString, @"\""))
        {
          v47.CFIndex length = CFStringGetLength(theString) - 2;
          v47.location = 1;
          CFStringRef v33 = CFStringCreateWithSubstring(a1, theString, v47);
          if (v33)
          {
            CFDictionarySetValue(Mutable, &unk_1EC0A1AF8, v33);
            CFRelease(v33);
          }
        }
      }
    }
  }
  uint64_t v34 = CFDictionaryGetValue(Mutable, &unk_1EC0A1AC0);
  int v35 = CFDictionaryGetValue(Mutable, &unk_1EC0A1BA0);
  if (a6 && v34)
  {
    if (!v35)
    {
      id v36 = 0;
      goto LABEL_56;
    }
    CFDictionarySetValue(Mutable, &unk_1EC0A1C10, a6);
  }
  id v36 = [[NSHTTPCookie alloc] _initWithProperties:Mutable fromString:1];
LABEL_56:
  v41((uint64_t)v40);
  return v36;
}

void sub_18416ADF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *))
{
}

void ___makeCookie_block_invoke(uint64_t a1)
{
}

uint64_t CookieUtils::looksLikeIPAddress(const __CFString *this, const __CFString *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(this);
  uint64_t result = 0;
  if (Length && Length <= 23)
  {
    if (CFStringGetCharacterAtIndex(this, 0) == 46
      && Length == 1
      && (*(_DWORD *)(MEMORY[0x1E4F14390] + 244) & 0x10000) == 0)
    {
      return 0;
    }
    else
    {
      uint64_t result = CFStringGetCString(this, buffer, 24, 0x600u);
      if (result)
      {
        uint64_t result = inet_pton(2, buffer, v6);
        if (result != 1) {
          return inet_pton(30, buffer, v6) == 1;
        }
      }
    }
  }
  return result;
}

void HTTPStallTimer::~HTTPStallTimer(HTTPStallTimer *this)
{
  *(void *)this = &unk_1ECF9CD80;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100]((uint64_t *)this + 5, 0);
  unint64_t v3 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v4) {
    dispatch_release(v4);
  }
  *(void *)this = &unk_1ECF9B550;
  CFAllocatorRef v5 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

{
  std::__shared_weak_count *v2;
  NSObject *v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  uint64_t vars8;

  *(void *)this = &unk_1ECF9CD80;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100]((uint64_t *)this + 5, 0);
  unint64_t v3 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v4) {
    dispatch_release(v4);
  }
  *(void *)this = &unk_1ECF9B550;
  CFAllocatorRef v5 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  JUMPOUT(0x18531B6D0);
}

void HTTP2ConnectionCache::_onqueue_removeIdleConnections(HTTP2ConnectionCache *this)
{
  unsigned int v2 = *((void *)this + 14);
  dispatch_time_t v3 = dispatch_time(0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  uint64_t v4 = *((void *)this + 15);
  dispatch_time_t v5 = dispatch_time(0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  HTTP2ConnectionCache::_onqueue_base_remove_connections(this, 0, 0);
  if (CFDictionaryGetCount(*((CFDictionaryRef *)this + 12)))
  {
    uint64_t v6 = *((void *)this + 14);
    dispatch_time_t v7 = dispatch_time(0x8000000000000000, (uint64_t)((double)*((int *)this + 18) * 1000000000.0));
    dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    unint64_t v8 = *((void *)this + 15);
    dispatch_time_t v9 = dispatch_time(0, (uint64_t)((double)*((int *)this + 19) * 1000000000.0));
    dispatch_source_set_timer(v8, v9, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  }
}

uint64_t ___ZN20HTTP2ConnectionCache24invalidateAllConnectionsEb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v1 + 128))
  {
    char v2 = *(unsigned char *)(a1 + 40);
    *(unsigned char *)(v1 + 128) = 1;
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 112));
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 120));
    HTTP2ConnectionCache::_onqueue_base_remove_connections((HTTP2ConnectionCache *)v1, 1, v2);
  }
  (*(void (**)(void))(**(void **)(v1 + 104) + 48))(*(void *)(v1 + 104));
  dispatch_time_t v3 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v3(v1);
}

void HTTP2ConnectionCache::_onqueue_base_remove_connections(HTTP2ConnectionCache *this, int a2, char a3)
{
  if (CFDictionaryGetCount(*((CFDictionaryRef *)this + 12)))
  {
    double Current = CFAbsoluteTimeGetCurrent();
    int v7 = *((_DWORD *)this + 18);
    double v8 = CFAbsoluteTimeGetCurrent();
    if (a2)
    {
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 3221225472;
      context[2] = ___ZN20HTTP2ConnectionCache32_onqueue_base_remove_connectionsEbb_block_invoke;
      context[3] = &__block_descriptor_41_e14_v24__0r_v8_v16l;
      void context[4] = this;
      char v15 = a3;
      CFDictionaryApplyFunction(*((CFDictionaryRef *)this + 12), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::_visit, context);
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 12));
    }
    else
    {
      double v9 = v8 - (double)*((int *)this + 19);
      CFArrayRef Mutable = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, 0);
      v13[0] = MEMORY[0x1E4F143A8];
      v13[1] = 3221225472;
      _DWORD v13[2] = ___ZN20HTTP2ConnectionCache32_onqueue_base_remove_connectionsEbb_block_invoke_2;
      v13[3] = &__block_descriptor_64_e14_v24__0r_v8_v16l;
      v13[4] = this;
      *(double *)&v13[5] = Current - (double)v7;
      *(double *)&v13[6] = v9;
      v13[7] = Mutable;
      CFDictionaryApplyFunction(*((CFDictionaryRef *)this + 12), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::_visit, v13);
      for (CFIndex i = 0; i < CFArrayGetCount(Mutable); ++i)
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, i);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 12), ValueAtIndex);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
  }
}

CFTypeRef CoreSchedulingSet::createNewPrivateRunLoopThread(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v6 = [__CFN_CoreSchedulingSetRunnable alloc];
  if (v6)
  {
    v12.receiver = v6;
    v12.super_class = (Class)__CFN_CoreSchedulingSetRunnable;
    id v7 = objc_msgSendSuper2(&v12, sel_init);
    if (v7)
    {
      *((void *)v7 + 1) = dispatch_semaphore_create(0);
      if (a3) {
        *((void *)v7 + 2) = _Block_copy(a3);
      }
      *((void *)v7 + 4) = 0;
    }
  }
  else
  {
    id v7 = 0;
  }
  double v8 = (void *)[objc_alloc(MEMORY[0x1E4F29060]) initWithTarget:self selector:sel__run_ object:v7];
  if (a1) {
    objc_msgSend(v8, "setName:", objc_msgSend(NSString, "stringWithUTF8String:", a1));
  }
  if (a2) {
    (*(void (**)(uint64_t, void *))(a2 + 16))(a2, v8);
  }
  [v8 start];
  if (v7
    && (dispatch_semaphore_wait(*((dispatch_semaphore_t *)v7 + 1), 0xFFFFFFFFFFFFFFFFLL),
        dispatch_release(*((dispatch_object_t *)v7 + 1)),
        *((void *)v7 + 1) = 0,
        (double v9 = (const void *)*((void *)v7 + 4)) != 0))
  {
    CFTypeRef v10 = CFRetain(v9);
  }
  else
  {
    CFTypeRef v10 = 0;
  }

  return v10;
}

void _CFNetworkErrorInitLocalizedStringsDictionary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const __CFString *a9)
{
  if (!_CFNetworkErrorLocalizedDescriptionsDict)
  {
    _CFNetworkErrorLocalizedDescriptionsDict = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    _CFNetworkErrorMapErrorCode(306, @"Err306", @"There was a problem communicating with the web proxy server (HTTP).", 0, 0, @"Please check your proxy settings. For help with this problem, contact your system administrator.", @"Please check your proxy settings. For help with this problem, contact your system administrator.", v9, v59);
    _CFNetworkErrorMapErrorCode(310, @"Err310", @"There was a problem communicating with the secure web proxy server (HTTPS).", 0, 0, @"Please check your proxy settings. For help with this problem, contact your system administrator.", @"Please check your proxy settings. For help with this problem, contact your system administrator.", v10, v60);
    _CFNetworkErrorMapErrorCode(311, @"Err311", @"There was a problem establishing a secure tunnel through the web proxy server.", 0, 0, @"Please check your proxy settings. For help with this problem, contact your system administrator.", @"Please check your proxy settings. For help with this problem, contact your system administrator.", v11, v61);
    _CFNetworkErrorMapErrorCode(-996, @"Err-996", @"Could not communicate with background transfer service", 0, 0, 0, 0, v12, v62);
    _CFNetworkErrorMapErrorCode(-997, @"Err-997", @"Lost connection to background transfer service", 0, 0, 0, 0, v13, v63);
    _CFNetworkErrorMapErrorCode(-1, @"Err-998", @"unknown error", 0, 0, 0, 0, v14, v64);
    _CFNetworkErrorMapErrorCode(-998, @"Err-998", @"unknown error", 0, 0, 0, 0, v15, v65);
    _CFNetworkErrorMapErrorCode(-999, @"Err-999", @"cancelled", 0, 0, 0, 0, v16, v66);
    _CFNetworkErrorMapErrorCode(-1000, @"Err-1000", @"bad URL", 0, 0, 0, 0, v17, v67);
    _CFNetworkErrorMapErrorCode(-1001, @"Err-1001", @"The request timed out.", 0, 0, 0, 0, v18, v68);
    _CFNetworkErrorMapErrorCode(-1002, @"Err-1002", @"unsupported URL", 0, 0, 0, 0, v19, v69);
    _CFNetworkErrorMapErrorCode(-1003, @"Err-1003", @"A server with the specified hostname could not be found.", 0, 0, 0, 0, v20, v70);
    _CFNetworkErrorMapErrorCode(-1004, @"Err-1004", @"Could not connect to the server.", 0, 0, 0, 0, v21, v71);
    _CFNetworkErrorMapErrorCode(-1005, @"Err-1005", @"The network connection was lost.", 0, 0, 0, 0, v22, v72);
    _CFNetworkErrorMapErrorCode(-1006, @"Err-1006", @"DNS lookup error", 0, 0, 0, 0, v23, v73);
    _CFNetworkErrorMapErrorCode(-1007, @"Err-1007", @"too many HTTP redirects", 0, 0, 0, 0, v24, v74);
    _CFNetworkErrorMapErrorCode(-1008, @"Err-1008", @"resource unavailable", 0, 0, 0, 0, v25, v75);
    _CFNetworkErrorMapErrorCode(-1009, @"Err-1009", @"The Internet connection appears to be offline.", 0, 0, 0, 0, v26, v76);
    _CFNetworkErrorMapErrorCode(-1010, @"Err-1010", @"redirected to nowhere", 0, 0, 0, 0, v27, v77);
    _CFNetworkErrorMapErrorCode(-1011, @"Err-1011", @"There was a bad response from the server.", 0, 0, 0, 0, v28, v78);
    _CFNetworkErrorMapErrorCode(-1014, @"Err-1014", @"zero byte resource", 0, 0, 0, 0, v29, v79);
    _CFNetworkErrorMapErrorCode(-1015, @"Err-1015", @"cannot decode raw data", 0, 0, 0, 0, v30, v80);
    _CFNetworkErrorMapErrorCode(-1016, @"Err-1016", @"cannot decode content data", 0, 0, 0, 0, v31, v81);
    _CFNetworkErrorMapErrorCode(-1017, @"Err-1017", @"cannot parse response", 0, 0, 0, 0, v32, v82);
    _CFNetworkErrorMapErrorCode(-1018, @"Err-1018", @"International roaming is currently off.", 0, 0, 0, 0, v33, v83);
    _CFNetworkErrorMapErrorCode(-1019, @"Err-1019", @"A data connection cannot be established since a call is currently active.", 0, 0, 0, 0, v34, v84);
    _CFNetworkErrorMapErrorCode(-1020, @"Err-1020", @"A data connection is not currently allowed.", 0, 0, 0, 0, v35, v85);
    _CFNetworkErrorMapErrorCode(-1021, @"Err-1021", @"request body stream exhausted", 0, 0, 0, 0, v36, v86);
    _CFNetworkErrorMapErrorCode(-1022, @"Err-1022", @"The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.", 0, 0, 0, 0, v37, v87);
    _CFNetworkErrorMapErrorCode(-1100, @"Err-1100", @"The requested URL was not found on this server.", 0, 0, 0, 0, v38, v88);
    _CFNetworkErrorMapErrorCode(-1101, @"Err-1101", @"file is directory", 0, 0, 0, 0, v39, v89);
    _CFNetworkErrorMapErrorCode(-1102, @"Err-1102", @"You do not have permission to access the requested resource.", 0, 0, 0, 0, v40, v90);
    _CFNetworkErrorMapErrorCode(-1103, @"Err-1103", @"resource exceeds maximum size", 0, 0, 0, 0, v41, v91);
    _CFNetworkErrorMapErrorCode(-1104, @"Err-1104", @"file is outside of the safe area", 0, 0, 0, 0, v42, v92);
    _CFNetworkErrorMapErrorCode(-1200, @"Err-1200", @"An SSL error has occurred and a secure connection to the server cannot be made.", 0, 0, @"Would you like to connect to the server anyway?", @"Would you like to connect to the server anyway?", v43, v93);
    _CFNetworkErrorMapErrorCode(-1201, @"Err-1201", @"The certificate for this server has expired.", @"Err-1201.w", @"The certificate for this server has expired. You might be connecting to a server that is pretending to be \"%@\" which could put your confidential information at risk.", @"Would you like to connect to the server anyway?", @"Would you like to connect to the server anyway?", v44, v94);
    _CFNetworkErrorMapErrorCode(-1202, @"Err-1202", @"The certificate for this server is invalid.", @"Err-1202.w", @"The certificate for this server is invalid. You might be connecting to a server that is pretending to be \"%@\" which could put your confidential information at risk.", @"Would you like to connect to the server anyway?", @"Would you like to connect to the server anyway?", v45, v95);
    _CFNetworkErrorMapErrorCode(-1203, @"Err-1203", @"The certificate for this server was signed by an unknown certifying authority.", @"Err-1203.w", @"The certificate for this server was signed by an unknown certifying authority. You might be connecting to a server that is pretending to be \"%@\" which could put your confidential information at risk.", @"Would you like to connect to the server anyway?", @"Would you like to connect to the server anyway?", v46, v96);
    _CFNetworkErrorMapErrorCode(-1204, @"Err-1204", @"The certificate for this server is not yet valid.", @"Err-1204.w", @"The certificate for this server is not yet valid. You might be connecting to a server that is pretending to be \"%@\" which could put your confidential information at risk.", @"Would you like to connect to the server anyway?", @"Would you like to connect to the server anyway?", v47, v97);
    _CFNetworkErrorMapErrorCode(-1205, @"Err-1205", @"The server did not accept the certificate.", @"Err-1205.w", @"The server \"%@\" did not accept the certificate.", 0, 0, v48, v98);
    _CFNetworkErrorMapErrorCode(-1206, @"Err-1206", @"The server requires a client certificate.", @"Err-1206.w", @"The server \"%@\" requires a client certificate.", 0, 0, v49, v99);
    _CFNetworkErrorMapErrorCode(-2000, @"Err-2000", @"can't load from network", 0, 0, 0, 0, v50, v100);
    _CFNetworkErrorMapErrorCode(-3000, @"Err-3000", @"Cannot create file", 0, 0, 0, 0, v51, v101);
    _CFNetworkErrorMapErrorCode(-3001, @"Err-3001", @"Cannot open file", 0, 0, 0, 0, v52, v102);
    _CFNetworkErrorMapErrorCode(-3002, @"Err-3002", @"Failure occurred while closing file", 0, 0, 0, 0, v53, v103);
    _CFNetworkErrorMapErrorCode(-3003, @"Err-3003", @"Cannot write file", 0, 0, 0, 0, v54, v104);
    _CFNetworkErrorMapErrorCode(-3004, @"Err-3004", @"Cannot remove file", 0, 0, 0, 0, v55, v105);
    _CFNetworkErrorMapErrorCode(-3005, @"Err-3005", @"Cannot move file", 0, 0, 0, 0, v56, v106);
    _CFNetworkErrorMapErrorCode(-3006, @"Err-3006", @"Download decoding failed", 0, 0, 0, 0, v57, v107);
    _CFNetworkErrorMapErrorCode(-3007, @"Err-3007", @"Download decoding failed", 0, 0, 0, 0, v58, a9);
  }
}

void _CFNetworkErrorMapErrorCode(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, const __CFString *a8, const __CFString *a9)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a1;
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberCFIndexType, &v26);
  CFStringRef v16 = (const void **)MEMORY[0x1E4F1D260];
  if (a2)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_5505);
    }
    CFStringRef v17 = (__CFString *)CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, a2, a3, @"Localizable");
  }
  else
  {
    CFStringRef v17 = (__CFString *)*MEMORY[0x1E4F1D260];
  }
  CFGregorianDate values = v17;
  if (a4)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_5505);
    }
    CFStringRef v18 = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, a4, a5, @"Localizable");
    CFStringRef v19 = (const __CFString *)*v16;
  }
  else
  {
    CFStringRef v19 = (const __CFString *)*v16;
    CFStringRef v18 = (CFStringRef)*v16;
  }
  CFTypeRef cf = v18;
  CFTypeRef v29 = v19;
  CFStringRef v20 = v19;
  if (a6)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_5505);
    }
    CFStringRef v20 = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, a6, a7, @"Localizable");
  }
  CFTypeRef v30 = v20;
  CFArrayRef v21 = CFArrayCreate(0, (const void **)&values, 4, MEMORY[0x1E4F1D510]);
  if (values != v19 && values != 0) {
    CFRelease(values);
  }
  if (cf != v19 && cf != 0) {
    CFRelease(cf);
  }
  if (v29 != v19 && v29 != 0) {
    CFRelease(v29);
  }
  if (v30 != v19 && v30 != 0) {
    CFRelease(v30);
  }
  CFDictionaryAddValue((CFMutableDictionaryRef)_CFNetworkErrorLocalizedDescriptionsDict, v15, v21);
  if (v15) {
    CFRelease(v15);
  }
  if (v21) {
    CFRelease(v21);
  }
}

uint64_t ___ZL11isSafariAppv_block_invoke()
{
  uint64_t result = _CFGetProgname();
  if (result)
  {
    uint64_t v1 = *(const char **)result;
    if (*(void *)result)
    {
      uint64_t result = strcmp(*(const char **)result, "MobileSafari");
      if (result && (uint64_t result = strncmp(v1, "com.apple.Safari", 0x10uLL), result))
      {
        uint64_t result = strncmp(v1, "com.apple.WebKit.Networking", 0x1BuLL);
        BOOL v2 = result == 0;
      }
      else
      {
        BOOL v2 = 1;
      }
      isSafariApp(void)::isSafariProcess = v2;
    }
  }
  return result;
}

void NSXURLCache::addCachedResponseForTask(id *this, const _CFCachedURLResponse *a2, NSURLSessionTask *a3)
{
  id v5 = [[NSCachedURLResponse alloc] _initWithCFCachedURLResponse:a2];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    objc_msgSend(this[1], "storeCachedResponse:forRequest:", v5, -[NSURLSessionTask currentRequest](a3, "currentRequest"));
  }
  else {
    [this[1] storeCachedResponse:v5 forDataTask:a3];
  }
}

void ___ZL20CFN_LOG_h3connectionv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.cfnetwork", "h3connection");
  uint64_t v1 = (void *)CFN_LOG_h3connection(void)::log;
  CFN_LOG_h3connection(void)::log = (uint64_t)v0;
}

void ___ZN12__CFURLCacheC2EPK11_CFURLCachellPK10__CFStringb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  BOOL v2 = getenv("CFN_VARY_HEADER_SUPPORT");
  if (v2)
  {
    p_p = (char *)&__p;
    std::string::basic_string[abi:nn180100]<0>(&__p, v2);
    unsigned __int8 v4 = v10;
    if ((v10 & 0x80u) == 0) {
      id v5 = (char *)&__p + v10;
    }
    else {
      id v5 = (char *)__p + v9;
    }
    if ((v10 & 0x80u) != 0) {
      p_p = (char *)__p;
    }
    if (p_p != v5)
    {
      do
      {
        char *p_p = __tolower(*p_p);
        ++p_p;
      }
      while (p_p != v5);
      unsigned __int8 v4 = v10;
    }
    if ((v4 & 0x80) != 0)
    {
      uint64_t v6 = __p;
      switch(v9)
      {
        case 1:
          if (*(unsigned char *)__p != 48) {
            break;
          }
          goto LABEL_31;
        case 2:
          if (*(_WORD *)__p == 28526) {
            goto LABEL_31;
          }
          break;
        case 5:
          goto LABEL_18;
      }
LABEL_33:
      operator delete(v6);
      return;
    }
    if (v4 != 1)
    {
      if (v4 == 2)
      {
        if ((unsigned __int16)__p != 28526) {
          return;
        }
        goto LABEL_31;
      }
      if (v4 != 5) {
        return;
      }
      uint64_t v6 = &__p;
LABEL_18:
      if (*(_DWORD *)v6 != 1936482662 || v6[4] != 101)
      {
        if ((v4 & 0x80) == 0) {
          return;
        }
LABEL_32:
        uint64_t v6 = __p;
        goto LABEL_33;
      }
LABEL_31:
      *(unsigned char *)(v1 + 632) = 0;
      if ((v4 & 0x80) == 0) {
        return;
      }
      goto LABEL_32;
    }
    if (__p == 48) {
      goto LABEL_31;
    }
  }
}

void sub_18416C710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL15_HSTSIsDisabledv_block_invoke()
{
  CFPropertyListRef v0 = CFPreferencesCopyValue(@"com.apple.CFNetwork.HSTS.DisableHSTS", (CFStringRef)*MEMORY[0x1E4F1D3B8], (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  if (v0)
  {
    uint64_t v1 = v0;
    CFTypeID v2 = CFGetTypeID(v0);
    BOOL v4 = v2 == CFBooleanGetTypeID() && v1 == (const void *)*MEMORY[0x1E4F1CFD0];
    _HSTSIsDisabled(void)::sHSTSIsDisabled = v4;
    CFRelease(v1);
  }
}

void *_CFNetServiceRegisterClass(void)
{
  uint64_t result = malloc_type_calloc(1uLL, 0x60uLL, 0x10D00408820D60FuLL);
  _kCFNetServiceClass = (uint64_t)result;
  if (result)
  {
    *uint64_t result = 0;
    result[1] = "CFNetService";
    result[4] = _ServiceDestroy;
    result[5] = _ServiceEqual;
    result[6] = _ServiceHash;
    result[8] = _ServiceCopyDebugDesc;
    uint64_t result = (void *)_CFRuntimeRegisterClass();
    _kCFNetServiceCFTypeID TypeID = (uint64_t)result;
  }
  return result;
}

void ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke_2(uint64_t a1)
{
}

void sub_18416CA58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  _Unwind_Resume(a1);
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_9(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(int *)(a1 + 48);
  CFIndex v3 = -1004;
  CFStringRef v4 = @"kCFErrorDomainCFNetwork";
  if (v2 > 31)
  {
    switch(*(_DWORD *)(a1 + 48))
    {
      case '1':
      case '3':
      case ';':
      case '=':
      case '@':
      case 'A':
        goto LABEL_21;
      case '2':
LABEL_3:
        CFIndex v3 = -1009;
        goto LABEL_21;
      case '4':
      case '7':
      case '8':
      case ':':
      case '>':
      case '?':
        goto LABEL_20;
      case '5':
      case '6':
      case '9':
        goto LABEL_10;
      case '<':
LABEL_12:
        CFIndex v3 = -1001;
        goto LABEL_21;
      default:
        if (v2 == 89)
        {
LABEL_18:
          CFIndex v3 = -999;
          goto LABEL_21;
        }
        if (v2 != 32) {
          goto LABEL_20;
        }
LABEL_10:
        if ((*(_DWORD *)(v1 + 192) & 2) == 0)
        {
          switch(*(_DWORD *)(a1 + 48))
          {
            case '1':
            case '3':
            case ';':
            case '=':
            case '@':
            case 'A':
              goto LABEL_21;
            case '2':
              goto LABEL_3;
            case '4':
            case '7':
            case '8':
            case ':':
            case '>':
            case '?':
              goto LABEL_20;
            case '5':
            case '6':
            case '9':
              goto LABEL_19;
            case '<':
              goto LABEL_12;
            default:
              if (v2 == 32) {
                goto LABEL_19;
              }
              if (v2 == 89) {
                goto LABEL_18;
              }
              goto LABEL_20;
          }
        }
        break;
    }
    goto LABEL_19;
  }
  if (v2 > 12)
  {
    if (v2 != 13)
    {
      if (v2 != 22) {
        goto LABEL_20;
      }
      CFIndex v3 = -1000;
    }
  }
  else if (v2 != -1)
  {
    if (v2 == 9)
    {
LABEL_19:
      CFIndex v3 = -1005;
      goto LABEL_21;
    }
LABEL_20:
    CFStringRef v4 = (const __CFString *)*MEMORY[0x1E4F1D160];
    CFIndex v3 = *(int *)(a1 + 48);
  }
LABEL_21:
  CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)(v1 - 16));
  return __cfnCreateCFError(v5, v4, v3, v6, v7, v8, v9, v10, 0);
}

CFErrorRef __cfnCreateCFError(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFStringRef v22 = &a9;
  unint64_t v12 = -1;
  do
  {
    CFStringRef v13 = v22++;
    ++v12;
  }
  while (*v13);
  if (v12 <= 3) {
    return CFErrorCreate(allocator, domain, code, 0);
  }
  unint64_t v14 = v12 >> 1;
  CFArrayRef Mutable = CFDictionaryCreateMutable(allocator, v12 >> 1, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  CFStringRef v23 = (const void **)&a9;
  if (v14 <= 1) {
    unint64_t v14 = 1;
  }
  while (1)
  {
    CFStringRef v16 = v23;
    CFStringRef v17 = *v23;
    v23 += 2;
    CFStringRef v18 = v16[1];
    if (!v17 || v18 == 0) {
      break;
    }
    CFDictionarySetValue(Mutable, v17, v18);
    if (!--v14) {
      goto LABEL_14;
    }
  }
  CFRelease(Mutable);
  CFArrayRef Mutable = 0;
LABEL_14:
  CFErrorRef v20 = CFErrorCreate(allocator, domain, code, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v20;
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_11(uint64_t a1)
{
  CFAllocatorRef v1 = CFGetAllocator((CFTypeRef)(*(void *)(a1 + 32) - 16));
  return __cfnCreateCFError(v1, @"kCFErrorDomainCFNetwork", -1003, v2, v3, v4, v5, v6, 0);
}

CFStringRef ___ZN14StorageSession18copyProcessDefaultEv_block_invoke()
{
  if (StorageSession::Class(void)::sOnce_StorageSession != -1) {
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_19595);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v1 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v1 = Instance + 16;
    *(void *)(Instance + 96) = 0;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  *(void *)uint64_t v1 = &unk_1ECF9CFC8;
  *(void *)(v1 + 8) = &unk_1ECF9D010;
  *(unsigned char *)(v1 + 56) = 1;
  uint64_t v2 = StorageSession::StorageSession(unsigned char)::gGenerations++;
  *(void *)(v1 + 64) = v2;
  *(_DWORD *)(v1 + 48) = 0;
  CFAllocatorRef v3 = CFGetAllocator((CFTypeRef)(v1 - 16));
  CFStringRef result = CFStringCreateCopy(v3, @"com.apple.CFNetwork.defaultStorageSession");
  *(void *)(v1 + 72) = result;
  *(void *)(v1 + 80) = 0;
  StorageSession::copyProcessDefault(void)::sProcessDefault = v1 - 16;
  return result;
}

void ___ZN9HSTSCache15defaultStoreURLEv_block_invoke()
{
  os_unfair_lock_lock((os_unfair_lock_t)&HSTSPathOverrideLock);
  if (HSTSPathOverride)
  {
    CFRetain((CFTypeRef)HSTSPathOverride);
    operator new();
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&HSTSPathOverrideLock);
  PathToCacheDirectory = __CreatePathToCacheDirectory(0, 0);
  uint64_t v1 = PathToCacheDirectory;
  if (PathToCacheDirectory)
  {
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@/%@", PathToCacheDirectory, @"HSTS.plist");
    if (v3)
    {
      HSTSCache::defaultStoreURL(void)::cacheFileURL = (uint64_t)CFURLCreateWithFileSystemPath(v2, v3, kCFURLPOSIXPathStyle, 0);
      CFRelease(v3);
    }
    CFRelease(v1);
  }
}

void sub_18416CFF4(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  CFRelease(v4);
  CFRelease(v2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(a1);
}

__CFString *__CreatePathToCacheDirectory(const __CFString *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFArrayRef v4 = (const __CFArray *)CFCopySearchPathForDirectoriesInDomains();
  if (!v4) {
    return 0;
  }
  CFArrayRef v5 = v4;
  if (CFArrayGetCount(v4) < 1
    || (CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v5, 0)) == 0
    || !CFURLGetFileSystemRepresentation(ValueAtIndex, 1u, buffer, 1024))
  {
    unint64_t v14 = v5;
LABEL_13:
    CFRelease(v14);
    return 0;
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  size_t v8 = strlen((const char *)buffer);
  CFStringRef v9 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], buffer, v8, 0x8000100u, 0);
  MutableCFHTTPMessageRef Copy = CFStringCreateMutableCopy(v7, 0, v9);
  if (v9) {
    CFRelease(v9);
  }
  CFRelease(v5);
  if (MutableCopy)
  {
    if (a2) {
      goto LABEL_19;
    }
    MainBundle = CFBundleGetMainBundle();
    if (MainBundle)
    {
      CFStringRef Identifier = CFBundleGetIdentifier(MainBundle);
      if (Identifier)
      {
        CFStringRef v13 = Identifier;
        CFStringAppend(MutableCopy, @"/");
        CFStringAppend(MutableCopy, v13);
        goto LABEL_19;
      }
    }
    CFStringRef v16 = *(const char **)_CFGetProgname();
    if (v16)
    {
      CFStringRef v17 = CFStringCreateWithCString(v7, v16, 0x8000100u);
      if (v17)
      {
        CFStringRef v18 = v17;
        CFStringAppend(MutableCopy, @"/");
        CFStringAppend(MutableCopy, v18);
        CFRelease(v18);
LABEL_19:
        if (a1)
        {
          CFStringAppend(MutableCopy, @"/");
          CFStringAppend(MutableCopy, a1);
        }
        return MutableCopy;
      }
    }
    unint64_t v14 = MutableCopy;
    goto LABEL_13;
  }
  return MutableCopy;
}

CFDataRef StrictSecurityPolicy::CreateDefaultSerializedATSState(StrictSecurityPolicy *this, int a2)
{
  int v3 = (int)this;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v6 = (const void **)MEMORY[0x1E4F1CFD0];
  if ((v3 & 1) != 0 || !dyld_program_sdk_at_least())
  {
    CFDictionaryAddValue(Mutable, @"NSAllowsArbitraryLoads", *v6);
  }
  else
  {
    if (getDefaultATSState(void)::defaultStateToken != -1) {
      dispatch_once(&getDefaultATSState(void)::defaultStateToken, &__block_literal_global_132);
    }
    CFDictionaryRef v7 = (const __CFDictionary *)getDefaultATSState(void)::baseATSState;
    if (getDefaultATSState(void)::baseATSState)
    {
      CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)getDefaultATSState(void)::baseATSState);
      MutableCFHTTPMessageRef Copy = CFDictionaryCreateMutableCopy(v4, Count, v7);
      if (Mutable) {
        CFRelease(Mutable);
      }
      CFArrayRef Mutable = MutableCopy;
    }
  }
  if (a2) {
    CFDictionaryAddValue(Mutable, @"_ATSHasAppleBundleException", *v6);
  }
  if (ATSLog(void)::onceToken != -1) {
    dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_115);
  }
  uint64_t v10 = ATSLog(void)::atsLog;
  if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
  {
    v14[0] = 67109634;
    v14[1] = v3;
    __int16 v15 = 1024;
    int v16 = a2;
    __int16 v17 = 2112;
    CFStringRef v18 = Mutable;
    _os_log_debug_impl(&dword_184085000, v10, OS_LOG_TYPE_DEBUG, "Created default configuration %d,%d %@", (uint8_t *)v14, 0x18u);
  }
  CFDataRef BinaryDataFromPropertyList = StrictSecurityPolicy::CreateBinaryDataFromPropertyList(Mutable, v11);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return BinaryDataFromPropertyList;
}

void sub_18416D404(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

CFDataRef StrictSecurityPolicy::CreateBinaryDataFromPropertyList(CFPropertyListRef propertyList, const void *a2)
{
  CFErrorRef error = 0;
  CFDataRef v2 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], propertyList, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  if (error) {
    CFRelease(error);
  }
  return v2;
}

void ___ZN17RequestBodyStream21bodyStopProvidingDataEv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = 0;
}

void ___ZL16CFN_LOG_h3streamv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.cfnetwork", "h3stream");
  uint64_t v1 = (void *)CFN_LOG_h3stream(void)::log;
  CFN_LOG_h3stream(void)::log = (uint64_t)v0;
}

void HTTPProtocol::streamError(HTTPProtocol *this, const CFStreamError *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = (void *)*((void *)this + 10);
  if (v4) {
    [v4 _releasePreventIdleSleepAssertionIfAppropriate];
  }
  int v5 = (*(uint64_t (**)(HTTPProtocol *, const CFStreamError *, uint64_t))(*(void *)this + 272))(this, a2, 1);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)this + 99);
    CFIndex domain = a2->domain;
    if ((v5 - 5) >= 6) {
      int v9 = 78;
    }
    else {
      int v9 = 89;
    }
    SInt32 error = a2->error;
    *(_DWORD *)buf = 138544386;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v9;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&unsigned char buf[20] = v5;
    LOWORD(v16) = 2048;
    *(void *)((char *)&v16 + 2) = domain;
    WORD5(v16) = 1024;
    HIDWORD(v16) = error;
    _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "%{public}@ can retry(%c) with reason(%d) for error [%ld:%d]", buf, 0x28u);
  }
  switch(v5)
  {
    case 4:
      uint64_t v11 = *((void *)this + 93);
      if (v11) {
        -[__NSURLSessionLocal _withConnectionCache_setCurrentSSLMethod:forKey:scheduling:](v11, 0, *((void *)this + 35), *((const void **)this + 3));
      }
      HTTPProtocol::cleanupStreams(this);
      goto LABEL_15;
    case 5:
      uint64_t TLSFallbackMethod = HTTPProtocol::nextTLSFallbackMethod(this);
      uint64_t v13 = *((void *)this + 93);
      if (v13) {
        -[__NSURLSessionLocal _withConnectionCache_setCurrentSSLMethod:forKey:scheduling:](v13, TLSFallbackMethod, *((void *)this + 35), *((const void **)this + 3));
      }
      HTTPProtocol::cleanupStreams(this);
      if (*((void *)this + 11)) {
        (*(void (**)(HTTPProtocol *, void))(*(void *)this + 88))(this, 0);
      }
      break;
    case 6:
    case 7:
    case 9:
      HTTPProtocol::destroyReadStream(this);
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((void *)this + 104), 1025, 0);
      HTTPProtocol::createAndOpenStream(this, 0);
      break;
    case 8:
      CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 37), 0);
      HTTPProtocol::destroyReadStream(this);
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((void *)this + 104), 1026, 0);
      HTTPProtocol::createAndOpenStream(this, 0);
      break;
    case 10:
      HTTPProtocol::destroyReadStream(this);
      *((void *)this + 6) = 0;
      *((void *)this + 7) = 0;
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((void *)this + 104), 1025, 0);
      HTTPProtocol::createAndOpenStream(this, 0);
      break;
    default:
LABEL_15:
      if (*((_DWORD *)this + 206) != 1)
      {
        long long v14 = (__int128)*a2;
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&uint8_t buf[16] = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke;
        *(void *)&long long v16 = &__block_descriptor_56_e90_v32__0____CFError__8_shared_ptr___CFDictionary______CFDictionary_____shared_weak_count__16l;
        *((void *)&v16 + 1) = this;
        long long v17 = v14;
        CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        operator new();
      }
      return;
  }
}

void sub_18416E024(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

CFTypeRef Tube::copyConnectionProperty(Tube *this, const __CFString *a2)
{
  uint64_t v3 = *((void *)this + 17);
  if (v3)
  {
    CFAllocatorRef v4 = *(uint64_t (**)(void))(*(void *)v3 + 216);
    return (CFTypeRef)v4();
  }
  else
  {
    CFDictionaryRef v6 = (const __CFDictionary *)*((void *)this + 28);
    if (v6 && (CFDictionaryRef Value = CFDictionaryGetValue(v6, a2)) != 0)
    {
      return CFRetain(Value);
    }
    else
    {
      return 0;
    }
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_8(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_7(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_6(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_4(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_2_213(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t HTTPProtocol::canRetryRequestAfterError(HTTPProtocol *this, const CFStreamError *a2, int a3)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v6 = (void *)*((void *)this + 11);
  if (!v6)
  {
    uint64_t v16 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_102_8629, 1);
    uint64_t v11 = v16;
    if (!v16) {
      goto LABEL_59;
    }
    if ((*(unsigned int (**)(uint64_t, const char *, HTTPProtocol *))(*(void *)v16 + 24))(v16, "Stream Error", this))
    {
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v11 + 72))(v11, "HTTPProtocol", @"Task and request are both nullptr; Error: %p [%ld:%d]");
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
    goto LABEL_56;
  }
  if ((*((_DWORD *)this + 48) & 2) == 0)
  {
    if (objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_allowsTLSFallback"))
    {
      uint64_t v7 = (void *)*((void *)this + 11);
      if ((!v7
         || (size_t v8 = (StrictSecurityPolicy *)*((void *)this + 92)) == 0
         || StrictSecurityPolicy::strictSecurityPolicyInEffectForURL(v8, (CFURLRef)[*((id *)this + 11) cfURL], *(const __CFDictionary **)(objc_msgSend(v7, "_inner") + 200)) != 2)&& a2->domain == *MEMORY[0x1E4F1D430])
      {
        unsigned int v9 = a2->error + 9850;
        if (v9 > 0x2B || ((1 << v9) & 0xC7803E80081) == 0)
        {
          if (HTTPProtocol::nextTLSFallbackMethod(this)) {
            uint64_t v11 = 5;
          }
          else {
            uint64_t v11 = 4;
          }
          if (a3) {
            goto LABEL_69;
          }
LABEL_60:
          uint64_t v25 = CFNLog::onceToken;
          goto LABEL_61;
        }
      }
    }
  }
  uint64_t v10 = *((void *)this + 111);
  if (v10
    && (*(unsigned int (**)(uint64_t))(*(void *)v10 + 96))(v10)
    && a2->domain == 4
    && a2->error == -2200)
  {
    uint64_t v11 = 9;
    if (a3) {
      goto LABEL_69;
    }
    goto LABEL_60;
  }
  LOWORD(v12) = *((_DWORD *)this + 48);
  if ((*((_DWORD *)this + 48) & 2) != 0)
  {
LABEL_44:
    if ((v12 & 2) != 0)
    {
      uint64_t v11 = 1;
      if (a3) {
        goto LABEL_69;
      }
      goto LABEL_60;
    }
    if (a2->domain == 1)
    {
      SInt32 error = a2->error;
      if (((error - 53) > 0x2B || ((1 << (error - 53)) & 0x80000000003) == 0)
        && error != 32)
      {
        goto LABEL_58;
      }
    }
    else if (a2->domain != 4 {
           || ((SInt32 v23 = a2->error, (v23 + 5) > 4) || ((1 << (v23 + 5)) & 0x13) == 0) && v23 != -2200)
    }
    {
LABEL_58:
      uint64_t v11 = 2;
LABEL_59:
      if (a3) {
        goto LABEL_69;
      }
      goto LABEL_60;
    }
LABEL_56:
    uint64_t v11 = 0;
    if (a3) {
      goto LABEL_69;
    }
    goto LABEL_60;
  }
  CFIndex domain = a2->domain;
  if (a2->domain == 1)
  {
    uint64_t v11 = 0;
    SInt32 v17 = a2->error;
    if ((v17 - 53) <= 0x2B && ((1 << (v17 - 53)) & 0x80000000003) != 0)
    {
      BOOL v15 = 0;
      goto LABEL_30;
    }
    BOOL v15 = 0;
    if (v17 == 32) {
      goto LABEL_30;
    }
    goto LABEL_37;
  }
  if (domain != 4 || ((SInt32 v14 = a2->error, (v14 + 5) > 4) || ((1 << (v14 + 5)) & 0x13) == 0) && v14 != -2200)
  {
LABEL_37:
    if (domain != *MEMORY[0x1E4F1D430] && a2->error != -2098)
    {
      CFArrayRef v22 = (const __CFArray *)*((void *)this + 37);
      if (v22)
      {
        if (CFArrayGetCount(v22) > 1)
        {
          uint64_t v11 = 8;
          if (a3) {
            goto LABEL_69;
          }
          goto LABEL_60;
        }
        int v12 = *((_DWORD *)this + 48);
      }
    }
    goto LABEL_44;
  }
  uint64_t v11 = v14 == -2200;
  BOOL v15 = v14 == -4;
LABEL_30:
  if ((*((_DWORD *)this + 48) & 0x200) == 0)
  {
    uint64_t v18 = *(void *)([v6 _inner] + 56);
    if (!v18
      || (CFStringRef v19 = *(const __CFString **)(v18 + 152)) != 0
      && (CFEqual(v19, (CFStringRef)&gConstantCFStringValueTable[2604])
       || ((CFStringRef v20 = *(const __CFString **)(v18 + 152)) != 0
        || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
        && (*(_WORD *)buf = 0,
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (CFStringRef v20 = *(const __CFString **)(v18 + 152)) != 0))&& CFEqual(v20, (CFStringRef)&gConstantCFStringValueTable[2611])))
    {
      uint64_t v11 = 6;
      int v21 = 1;
      goto LABEL_103;
    }
  }
  uint64_t v43 = *(void *)([v6 _inner] + 56);
  if (!v43) {
    goto LABEL_102;
  }
  CFStringRef v44 = *(const __CFString **)(v43 + 152);
  if (v44)
  {
    if (CFEqual(v44, (CFStringRef)&gConstantCFStringValueTable[2604]))
    {
LABEL_102:
      int v21 = 0;
      uint64_t v11 = 7;
      goto LABEL_103;
    }
    CFStringRef v45 = *(const __CFString **)(v43 + 152);
    if (v45
      || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
      && (*(_WORD *)buf = 0,
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (CFStringRef v45 = *(const __CFString **)(v43 + 152)) != 0))
    {
      if (CFStringCompare(v45, (CFStringRef)&gConstantCFStringValueTable[2611], 0)) {
        char v46 = v11;
      }
      else {
        char v46 = 1;
      }
      if ((v46 & 1) == 0)
      {
        int v21 = 0;
        uint64_t v11 = 0;
        goto LABEL_103;
      }
      goto LABEL_102;
    }
  }
  if (v11) {
    goto LABEL_102;
  }
  int v21 = 0;
LABEL_103:
  int v47 = *((_DWORD *)this + 120);
  if (v47 >= 2)
  {
    if ((v15 & v21) == 1 && (int v48 = *((_DWORD *)this + 121), v48 == v47) && v48 <= 7)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFStringRef v49 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v50 = *((void *)this + 99);
        int v51 = *((_DWORD *)this + 121);
        int v52 = *((_DWORD *)this + 120);
        *(_DWORD *)buf = 138543874;
        uint64_t v68 = v50;
        __int16 v69 = 1024;
        int v70 = v51;
        __int16 v71 = 1024;
        int v72 = v52;
        _os_log_impl(&dword_184085000, v49, OS_LOG_TYPE_DEFAULT, "%{public}@ RetryReason::Permit_ConnectionLost fNumConnectionLossRetries=%d, fNumRetries=%d", buf, 0x18u);
      }
      uint64_t v11 = 6;
    }
    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFStringRef v53 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v54 = *((void *)this + 99);
        int v55 = *((_DWORD *)this + 121);
        int v56 = *((_DWORD *)this + 120);
        *(_DWORD *)buf = 138543874;
        uint64_t v68 = v54;
        __int16 v69 = 1024;
        int v70 = v55;
        __int16 v71 = 1024;
        int v72 = v56;
        _os_log_impl(&dword_184085000, v53, OS_LOG_TYPE_DEFAULT, "%{public}@ RetryReason::Deny_MaxRetriesReached fNumConnectionLossRetries=%d, fNumRetries=%d", buf, 0x18u);
      }
      uint64_t v11 = 3;
    }
  }
  CFStringRef v57 = (void *)*((void *)this + 10);
  if (objc_msgSend((id)objc_msgSend(v57, "resumableUploadState"), "isResumable"))
  {
    uint64_t v58 = [v57 resumableUploadState];
    if (v58) {
      *(_DWORD *)(v58 + 12) = 2;
    }
    uint64_t v59 = [v57 resumableUploadState];
    if (v59) {
      ++*(unsigned char *)(v59 + 8);
    }
    uint64_t v11 = 10;
    goto LABEL_130;
  }
  char v60 = !v15;
  if (v11 != 6) {
    char v60 = 1;
  }
  if (v60)
  {
LABEL_130:
    uint64_t v25 = CFNLog::onceToken;
    if (a3) {
      goto LABEL_131;
    }
LABEL_61:
    if (v25 != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v26 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = *((void *)this + 99);
      CFIndex v28 = a2->domain;
      if ((v11 - 5) >= 6) {
        int v29 = 78;
      }
      else {
        int v29 = 89;
      }
      SInt32 v30 = a2->error;
      *(_DWORD *)buf = 138544386;
      uint64_t v68 = v27;
      __int16 v69 = 1024;
      int v70 = v29;
      __int16 v71 = 1024;
      int v72 = v11;
      __int16 v73 = 2048;
      CFIndex v74 = v28;
      __int16 v75 = 1024;
      SInt32 v76 = v30;
      uint64_t v31 = "%{public}@ could retry(%c) with reason(%d) if issued error [%ld:%d]";
      CFStringRef v32 = v26;
      uint32_t v33 = 40;
      goto LABEL_68;
    }
    goto LABEL_69;
  }
  ++*((_DWORD *)this + 121);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v25 = CFNLog::onceToken;
  CFStringRef v61 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v62 = *((void *)this + 99);
    int v63 = *((_DWORD *)this + 121);
    *(_DWORD *)buf = 138543618;
    uint64_t v68 = v62;
    __int16 v69 = 1024;
    int v70 = v63;
    _os_log_impl(&dword_184085000, v61, OS_LOG_TYPE_DEFAULT, "%{public}@ fNumConnectionLossRetries=%d", buf, 0x12u);
    uint64_t v11 = 6;
    goto LABEL_130;
  }
  uint64_t v11 = 6;
  if (!a3) {
    goto LABEL_61;
  }
LABEL_131:
  ++*((_DWORD *)this + 120);
  if (v25 != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v64 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v65 = *((void *)this + 99);
    int v66 = *((_DWORD *)this + 120);
    *(_DWORD *)buf = 138543618;
    uint64_t v68 = v65;
    __int16 v69 = 1024;
    int v70 = v66;
    uint64_t v31 = "%{public}@ incrementRetryCount fNumRetries=%d";
    CFStringRef v32 = v64;
    uint32_t v33 = 18;
LABEL_68:
    _os_log_impl(&dword_184085000, v32, OS_LOG_TYPE_DEFAULT, v31, buf, v33);
  }
LABEL_69:
  if (v6 && !v11)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFStringRef v34 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v35 = *((void *)this + 99);
      uint64_t v36 = *(void *)([v6 _inner] + 56);
      if (v36)
      {
        CFStringRef v37 = *(const __CFString **)(v36 + 152);
        if (!v37)
        {
LABEL_83:
          int v39 = 78;
          goto LABEL_84;
        }
        if (CFStringCompare(v37, (CFStringRef)&gConstantCFStringValueTable[2604], 0))
        {
          CFStringRef v38 = *(const __CFString **)(v36 + 152);
          if (v38
            || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
            && (*(_WORD *)buf = 0,
                _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", buf, 2u), (CFStringRef v38 = *(const __CFString **)(v36 + 152)) != 0))
          {
            if (CFStringCompare(v38, (CFStringRef)&gConstantCFStringValueTable[2611], 0)) {
              int v39 = 78;
            }
            else {
              int v39 = 89;
            }
            goto LABEL_84;
          }
          goto LABEL_83;
        }
      }
      int v39 = 89;
LABEL_84:
      uint64_t v40 = *((void *)this + 34);
      int v41 = 89;
      if (v40)
      {
        if ((*(uint64_t (**)(uint64_t))(*(void *)v40 + 96))(v40)) {
          int v41 = 89;
        }
        else {
          int v41 = 78;
        }
      }
      *(_DWORD *)buf = 138544130;
      uint64_t v68 = v35;
      __int16 v69 = 1024;
      int v70 = v39;
      __int16 v71 = 1024;
      int v72 = 0;
      __int16 v73 = 1024;
      LODWORD(v74) = v41;
      _os_log_impl(&dword_184085000, v34, OS_LOG_TYPE_DEFAULT, "%{public}@ idempotent(%c) retry reason(%d) bytes written(%c)", buf, 0x1Eu);
    }
  }
  return v11;
}

void HTTPProtocol::asyncTransformError(uint64_t a1)
{
  if (HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::onceToken == -1)
  {
    if (!a1) {
      goto LABEL_4;
    }
  }
  else
  {
    dispatch_once(&HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::onceToken, &__block_literal_global_218);
    if (!a1) {
LABEL_4:
    }
      operator new();
  }
  CFRetain((CFTypeRef)(a1 - 16));
  goto LABEL_4;
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_5(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t ___ZN15HTTP3Connection36_newClientUnidirectionalStreamHandleEPKc_block_invoke()
{
  uint64_t stream_options = nw_quic_create_stream_options();
  uint64_t v1 = (void *)HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::options;
  HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::options = stream_options;

  uint64_t v2 = HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::options;

  return MEMORY[0x1F40F3DD0](v2, 1);
}

uint64_t ___ZN15HTTP3Connection35_newClientBidirectionalStreamHandleEPKc_block_invoke()
{
  uint64_t stream_options = nw_quic_create_stream_options();
  uint64_t v1 = (void *)HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::options;
  HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::options = stream_options;

  uint64_t v2 = HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::options;

  return MEMORY[0x1F40F3DD0](v2, 0);
}

void ___ZN20HTTP2ConnectionCache32_onqueue_base_remove_connectionsEbb_block_invoke(uint64_t a1, void *a2, HTTP2ConnectionCacheEntry *this)
{
  uint64_t v4 = *(void *)(a1 + 32);
  HTTP2ConnectionCacheEntry::stopConnections(this, *(unsigned char *)(a1 + 40));
  uint64_t v5 = *(void *)(v4 + 104);

  TubeManager::invalidateKey(v5, a2, 1, 1u);
}

void HTTP2ConnectionCacheEntry::stopConnections(HTTP2ConnectionCacheEntry *this, char a2)
{
  if (!*((unsigned char *)this + 105))
  {
    *((unsigned char *)this + 105) = 1;
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = ___ZN25HTTP2ConnectionCacheEntry15stopConnectionsEb_block_invoke;
    context[3] = &__block_descriptor_33_e9_v16__0_v8l;
    char v5 = a2;
    CFArrayRef v3 = (const __CFArray *)*((void *)this + 11);
    v6.CFIndex length = CFArrayGetCount(v3);
    v6.location = 0;
    CFArrayApplyFunction(v3, v6, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, context);
    *((unsigned char *)this + 105) = 0;
  }
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

__n128 ___ZN11HTTP2Stream8setErrorE13CFStreamErrorh_block_invoke(uint64_t a1)
{
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(*(void *)(a1 + 40) + 184) = result;
  return result;
}

void ___ZN10HSTSPolicy16getDefaultPolicyEv_block_invoke()
{
  uint64_t v0 = *MEMORY[0x1E4F1CF80];
  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1) {
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  uint64_t v2 = Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    uint64_t v2 = Instance + 2;
    Instance[4] = 0;
  }
  if (HSTSCache::defaultStoreURL(void)::once != -1) {
    dispatch_once(&HSTSCache::defaultStoreURL(void)::once, &__block_literal_global_9_17672);
  }
  CFTypeRef v3 = (CFTypeRef)HSTSCache::defaultStoreURL(void)::cacheFileURL;
  if (HSTSCache::defaultStoreURL(void)::cacheFileURL) {
    CFTypeRef v3 = CFRetain((CFTypeRef)HSTSCache::defaultStoreURL(void)::cacheFileURL);
  }
  CFTypeRef cf = v3;
  HSTSPolicy::HSTSPolicy(v2, v0, 1, (uint64_t *)&cf);
  HSTSPolicy::getDefaultPolicy(void)::sHSTSPolicy = (uint64_t)v2;
  CFTypeRef v4 = cf;
  if (cf)
  {
    CFRelease(v4);
  }
}

void sub_18416F310(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void *_CFHSTSPolicyCreateWithStorageLocation(CFURLRef url)
{
  uint64_t v2 = *MEMORY[0x1E4F1CF80];
  if (url) {
    CFURLRef v3 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], url, @"HSTS.plist", 0);
  }
  else {
    CFURLRef v3 = 0;
  }
  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1) {
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  char v5 = Instance;
  if (Instance)
  {
    Instance[2] = 0;
    Instance[3] = 0;
    char v5 = Instance + 2;
    Instance[4] = 0;
  }
  CFTypeRef cf = v3;
  HSTSPolicy::HSTSPolicy(v5, v2, url != 0, (uint64_t *)&cf);
  if (cf) {
    CFRelease(cf);
  }
  return v5 - 2;
}

void sub_18416F464(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void *HSTSPolicy::HSTSPolicy(void *a1, uint64_t a2, int a3, uint64_t *a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  *a1 = &unk_1ECF9A620;
  a1[1] = &unk_1ECF9A668;
  if (HSTSCache::Class(void)::sOnce_HSTSCache != -1) {
    dispatch_once(&HSTSCache::Class(void)::sOnce_HSTSCache, &__block_literal_global_2_17662);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  size_t v8 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    size_t v8 = Instance + 1;
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
  }
  unsigned int v9 = 0;
  uint64_t v10 = *a4;
  *a4 = 0;
  *(void *)size_t v8 = &unk_1ECFA5BD8;
  *((void *)v8 + 1) = &unk_1ECFA5C20;
  v8[1] = 0u;
  v8[2] = 0u;
  v8[3] = 0u;
  *((void *)v8 + 8) = v10;
  *((unsigned char *)v8 + 72) = 0;
  *((unsigned char *)v8 + 73) = a3;
  *((void *)v8 + 10) = 0;
  char v11 = 1;
  *((unsigned char *)v8 + 88) = 0;
  if (!a3 || !v10)
  {
LABEL_54:
    CFAllocatorRef v27 = CFGetAllocator(v8 - 1);
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(v27, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v11) {
      goto LABEL_56;
    }
    goto LABEL_55;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  int v12 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v23 = *((void *)v8 + 8);
    *(_DWORD *)stat propertyValueTypeRefPtr = 134218242;
    *(void *)&propertyValueTypeRefPtr[4] = v8;
    __int16 v45 = 2112;
    uint64_t v46 = v23;
    _os_log_debug_impl(&dword_184085000, v12, OS_LOG_TYPE_DEBUG, "Using HSTS %p path %@", propertyValueTypeRefPtr, 0x16u);
  }
  CFErrorRef v41 = 0;
  CFErrorRef error = 0;
  CFURLRef v13 = (const __CFURL *)*((void *)v8 + 8);
  *(void *)stat propertyValueTypeRefPtr = 0;
  if (!CFURLCopyResourcePropertyForKey(v13, (CFStringRef)*MEMORY[0x1E4F1D640], propertyValueTypeRefPtr, &error)) {
    goto LABEL_25;
  }
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (!*(void *)propertyValueTypeRefPtr)
  {
    CFErrorRef error = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x1E4F1D158], 1, 0);
LABEL_25:
    CFDataRef v20 = 0;
LABEL_26:
    unsigned int v9 = 0;
    goto LABEL_44;
  }
  CFIndex valuePtr = 0;
  if (!CFNumberGetValue(*(CFNumberRef *)propertyValueTypeRefPtr, kCFNumberCFIndexType, &valuePtr))
  {
    CFArrayRef v22 = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x1E4F1D160], 27, 0);
LABEL_30:
    CFDataRef v20 = 0;
    CFErrorRef error = v22;
    goto LABEL_37;
  }
  if (!valuePtr)
  {
    CFDataRef v20 = CFDataCreate(v14, 0, 0);
    goto LABEL_37;
  }
  if (v14) {
    CFAllocatorRef v15 = v14;
  }
  else {
    CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CFB0];
  }
  uint64_t v16 = CFReadStreamCreateWithFile(v14, v13);
  SInt32 v17 = v16;
  if (!v16)
  {
    CFArrayRef v22 = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x1E4F1D158], 1, 0);
    goto LABEL_30;
  }
  if (CFReadStreamOpen(v16))
  {
    uint64_t v18 = (UInt8 *)CFAllocatorAllocate(v15, valuePtr, 0);
    if (v18)
    {
      CFIndex v19 = CFReadStreamRead(v17, v18, valuePtr);
      if (v19 < 0)
      {
        int v21 = CFReadStreamCopyError(v17);
        goto LABEL_34;
      }
      CFDataRef v20 = CFDataCreateWithBytesNoCopy(v15, v18, v19, v15);
      if (!v20)
      {
        int v21 = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x1E4F1D160], 12, 0);
LABEL_34:
        CFErrorRef error = v21;
        CFAllocatorDeallocate(v15, v18);
        CFDataRef v20 = 0;
      }
    }
    else
    {
      CFDataRef v20 = 0;
      CFErrorRef error = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x1E4F1D160], 12, 0);
    }
    CFReadStreamClose(v17);
    goto LABEL_36;
  }
  CFDataRef v20 = 0;
  CFErrorRef error = CFReadStreamCopyError(v17);
LABEL_36:
  CFRelease(v17);
LABEL_37:
  CFRelease(*(CFTypeRef *)propertyValueTypeRefPtr);
  if (v20)
  {
    CFPropertyListRef v24 = CFPropertyListCreateWithData(v14, v20, 1uLL, 0, &v41);
    unsigned int v9 = v24;
    if (!v41)
    {
      CFTypeID v25 = CFGetTypeID(v24);
      if (v25 != CFDictionaryGetTypeID())
      {
        if (v9)
        {
          CFRelease(v9);
          char v11 = 0;
          goto LABEL_26;
        }
      }
    }
    char v11 = 0;
  }
  else
  {
    unsigned int v9 = 0;
    char v11 = 1;
  }
LABEL_44:
  if (error) {
    CFRelease(error);
  }
  if (v41) {
    CFRelease(v41);
  }
  if ((v11 & 1) == 0) {
    CFRelease(v20);
  }
  if (!v9)
  {
    char v11 = 1;
    goto LABEL_54;
  }
  CFDictionaryRef Mutable = (const __CFDictionary *)CFRetain(v9);
  if (!Mutable)
  {
    char v11 = 0;
    goto LABEL_54;
  }
LABEL_55:
  CFRelease(v9);
LABEL_56:
  CFIndex v28 = (const void *)*((void *)v8 + 6);
  *((void *)v8 + 6) = Mutable;
  if (v28)
  {
    CFRelease(v28);
    CFDictionaryRef Mutable = (const __CFDictionary *)*((void *)v8 + 6);
  }
  if (Mutable)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(Mutable, @"com.apple.CFNetwork.defaultStorageSession");
    SInt32 v30 = v8 - 1;
    if (Value)
    {
      CFAllocatorRef v31 = CFGetAllocator(v30);
      CFIndex Count = CFDictionaryGetCount(Value);
      MutableCFHTTPMessageRef Copy = CFDictionaryCreateMutableCopy(v31, Count, Value);
    }
    else
    {
      CFAllocatorRef v34 = CFGetAllocator(v30);
      MutableCFHTTPMessageRef Copy = CFDictionaryCreateMutable(v34, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    CFMutableDictionaryRef v35 = MutableCopy;
    uint64_t v36 = (const void *)*((void *)v8 + 7);
    *((void *)v8 + 7) = v35;
    if (v36)
    {
      CFRelease(v36);
      CFMutableDictionaryRef v35 = (CFMutableDictionaryRef)*((void *)v8 + 7);
    }
    CFDictionarySetValue(*((CFMutableDictionaryRef *)v8 + 6), @"com.apple.CFNetwork.defaultStorageSession", v35);
  }
  CFStringRef v37 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *((void *)v8 + 2) = dispatch_queue_create("com.apple.hstscache.workqueue", v37);
  if (*((unsigned char *)v8 + 73))
  {
    CFStringRef v38 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    dispatch_queue_t v39 = dispatch_queue_create("com.apple.hstscache.persistqueue", v38);
  }
  else
  {
    dispatch_queue_t v39 = 0;
  }
  *((void *)v8 + 3) = v39;
  *((unsigned char *)v8 + 88) = 0;
  a1[2] = v8;
  return a1;
}

void sub_18416FA68(_Unwind_Exception *a1)
{
  CFRelease(v3);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v7 = (const void *)v1[8];
  v1[8] = 0;
  if (v7) {
    CFRelease(v7);
  }
  size_t v8 = (const void *)v1[7];
  v1[7] = 0;
  if (v8) {
    CFRelease(v8);
  }
  unsigned int v9 = (const void *)v1[6];
  v1[6] = 0;
  if (v9) {
    CFRelease(v9);
  }
  *char v5 = &unk_1ECF9B550;
  void *v4 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(__CFError **)(a1 + 48);
  if (v2)
  {
    HTTPProtocol::logLoadFailure(*(HTTPProtocol **)(a1 + 40), v2, (const CFStreamError *)(a1 + 64));
    uint64_t v2 = *(__CFError **)(a1 + 48);
  }
  uint64_t v3 = *(void *)(a1 + 32);
  CFTypeRef v4 = *(std::__shared_weak_count **)(a1 + 88);
  uint64_t v5 = *(void *)(a1 + 80);
  CFRange v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, __CFError *, uint64_t *))(v3 + 16))(v3, v2, &v5);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_18416FBF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke(uint64_t result, void *cf)
{
  if (cf)
  {
    uint64_t v3 = *(void *)(result + 32);
    CFRetain(cf);
    CFDictionaryRef v4 = CFErrorCopyUserInfo((CFErrorRef)cf);
    if (v4)
    {
      CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)(v3 - 16));
      CFDictionaryCreateMutableCopy(v5, 0, v4);
      operator new();
    }
    CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)(v3 - 16));
    CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    operator new();
  }
  return result;
}

void sub_18416FE9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
    if (!v18)
    {
LABEL_3:
      if (!v16)
      {
LABEL_5:
        std::__shared_weak_count::__release_shared[abi:nn180100](v15);
        if (v14) {
          CFRelease(v14);
        }
        if (v17) {
          CFRelease(v17);
        }
        _Unwind_Resume(a1);
      }
LABEL_4:
      CFRelease(v16);
      goto LABEL_5;
    }
  }
  else if (!v18)
  {
    goto LABEL_3;
  }
  CFRelease(v18);
  if (!v16) {
    goto LABEL_5;
  }
  goto LABEL_4;
}

void HTTPProtocol::logLoadFailure(HTTPProtocol *this, CFErrorRef err, const CFStreamError *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *((void *)this + 71);
  uint64_t v7 = *((void *)this + 72);
  uint64_t v8 = *((void *)this + 34);
  if (v8)
  {
    v6 += (*(uint64_t (**)(uint64_t))(*(void *)v8 + 96))(v8);
    v7 += (*(uint64_t (**)(void))(**((void **)this + 34) + 104))(*((void *)this + 34));
  }
  CFIndex Code = CFErrorGetCode(err);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v10 = CFNLog::logger;
  if (Code == -999)
  {
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *((void *)this + 99);
      CFIndex v12 = CFErrorGetCode(err);
      CFIndex domain = a3->domain;
      SInt32 error = a3->error;
      int v19 = 138544642;
      uint64_t v20 = v11;
      __int16 v21 = 2048;
      uint64_t v22 = v6;
      __int16 v23 = 2048;
      uint64_t v24 = v7;
      __int16 v25 = 2048;
      CFIndex v26 = v12;
      __int16 v27 = 2048;
      CFIndex v28 = domain;
      __int16 v29 = 1024;
      SInt32 v30 = error;
      _os_log_impl(&dword_184085000, v10, OS_LOG_TYPE_DEFAULT, "%{public}@ HTTP load canceled, %lld/%lld bytes (error code: %ld [%ld:%d])", (uint8_t *)&v19, 0x3Au);
    }
  }
  else if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = *((void *)this + 99);
    CFIndex v16 = CFErrorGetCode(err);
    CFIndex v17 = a3->domain;
    SInt32 v18 = a3->error;
    int v19 = 138544642;
    uint64_t v20 = v15;
    __int16 v21 = 2048;
    uint64_t v22 = v6;
    __int16 v23 = 2048;
    uint64_t v24 = v7;
    __int16 v25 = 2048;
    CFIndex v26 = v16;
    __int16 v27 = 2048;
    CFIndex v28 = v17;
    __int16 v29 = 1024;
    SInt32 v30 = v18;
    _os_log_error_impl(&dword_184085000, v10, OS_LOG_TYPE_ERROR, "%{public}@ HTTP load failed, %lld/%lld bytes (error code: %ld [%ld:%d])", (uint8_t *)&v19, 0x3Au);
  }
}

void URLProtocol::sendDidFail(URLProtocol *this, __CFError *a2)
{
  uint64_t v4 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_27, 1);
  if (v4)
  {
    uint64_t v5 = v4;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v4 + 16))(v4, "Response Error", 0))
    {
      id v6 = *((id *)this + 11);
      (*(void (**)(uint64_t, const char *, id))(*(void *)v5 + 48))(v5, "Request", v6);

      (*(void (**)(uint64_t, const char *, __CFError *))(*(void *)v5 + 56))(v5, "Error", a2);
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
  }
  if (!a2)
  {
    id v12 = *((id *)this + 11);
    CFLog();

    abort();
  }
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  CFAllocatorRef v14 = ___ZN11URLProtocol11sendDidFailEP9__CFError_block_invoke_2;
  uint64_t v15 = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
  CFIndex v16 = a2;
  uint64_t v7 = v13;
  uint64_t v8 = *((void *)this + 12);
  if (v8)
  {
    uint64_t v9 = (*(uint64_t (**)(void))(*(void *)v8 + 16))(*((void *)this + 12));
    uint64_t v10 = (void *)MEMORY[0x18531D6D0](v9);
    v14((uint64_t)v7, *((void *)this + 12));
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }

  uint64_t v11 = (void *)*((void *)this + 8);
  if (v11)
  {
    *((void *)this + 8) = 0;
    CFRetain((char *)this - 16);
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 3221225472;
    void v17[2] = ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke_2495;
    void v17[3] = &__block_descriptor_40_e5_v8__0l;
    v17[4] = this;
    Throttler::invalidate(v11, (uint64_t)v17);
    (*(void (**)(void *))(*v11 + 48))(v11);
  }
}

void sub_184170418(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN11URLProtocol11sendDidFailEP9__CFError_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 96))(a2, *(void *)(a1 + 32));
}

void non-virtual thunk to'URLConnectionLoader_Classic::protocolDidFail(URLConnectionLoader_Classic *this, __CFError *a2)
{
}

void URLConnectionLoader_Classic::protocolDidFail(URLConnectionLoader_Classic *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZN27URLConnectionLoader_Classic15protocolDidFailEP9__CFError_block_invoke;
  v4[3] = &__block_descriptor_48_e5_v8__0l;
  v4[4] = this;
  void v4[5] = cf;
  URLConnectionInstanceData::withWorkQueueAsync((uint64_t)this, (uint64_t)v4);
}

void HTTP2Connection::stop(HTTP2Connection *this, char a2)
{
  CFRetain((char *)this - 16);
  uint64_t v4 = *((void *)this + 21);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  uint64_t v5[2] = ___ZN15HTTP2Connection4stopEb_block_invoke;
  v5[3] = &__block_descriptor_41_e5_v8__0l;
  v5[4] = this;
  char v6 = a2;
  dispatch_async(v4, v5);
}

void _CFNetworkHTTPConnectionCacheSetLimit(int a1, int a2)
{
  if (mutableGlobalLimits(void)::sOnce != -1) {
    dispatch_once(&mutableGlobalLimits(void)::sOnce, &__block_literal_global_11_12382);
  }
  uint64_t v4 = (int *)mutableGlobalLimits(void)::gLimits;
  switch(a1)
  {
    case 0:
      goto LABEL_16;
    case 1:
      uint64_t v4 = (int *)(mutableGlobalLimits(void)::gLimits + 4);
      goto LABEL_16;
    case 2:
      uint64_t v4 = (int *)(mutableGlobalLimits(void)::gLimits + 8);
      goto LABEL_16;
    case 3:
      if (a2 < 1) {
        return;
      }
      uint64_t v4 = (int *)(mutableGlobalLimits(void)::gLimits + 12);
      goto LABEL_16;
    case 4:
      if (a2 < 0 || *(_DWORD *)mutableGlobalLimits(void)::gLimits <= a2) {
        return;
      }
      uint64_t v4 = (int *)(mutableGlobalLimits(void)::gLimits + 16);
      goto LABEL_16;
    case 5:
      uint64_t v4 = (int *)(mutableGlobalLimits(void)::gLimits + 20);
      goto LABEL_16;
    case 6:
      *(_DWORD *)(mutableGlobalLimits(void)::gLimits + 24) = a2;
      if (a2 != 30) {
        goto LABEL_13;
      }
      return;
    case 7:
LABEL_13:
      v4 += 7;
      goto LABEL_16;
    case 8:
      *(_DWORD *)(mutableGlobalLimits(void)::gLimits + 32) = a2;
      if (a2 != 120) {
        goto LABEL_15;
      }
      return;
    case 9:
LABEL_15:
      v4 += 9;
LABEL_16:
      int *v4 = a2;
      break;
    default:
      return;
  }
}

void ____retainStorageAssertion_block_invoke()
{
  os_unfair_lock_lock((os_unfair_lock_t)&lock);
  shouldHold = 0;
  if (!assertionCount)
  {
    [(id)assertion invalidate];
    uint64_t v0 = (void *)assertion;
    assertion = 0;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&lock);
}

uint64_t HTTPCookieStorage::syncStorageWithCompletion(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFRetain((CFTypeRef)(a1 - 16));
  char v6 = *(void **)(a1 + 16);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN17HTTPCookieStorage25syncStorageWithCompletionEhU13block_pointerFvvE_block_invoke;
  v9[3] = &unk_1E5257C58;
  v9[4] = a3;
  void v9[5] = a1;
  uint64_t v7 = v6[4];
  if (v7) {
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 8));
  }
  uint64_t result = (*(uint64_t (**)(void *, uint64_t, void *))(*v6 + 160))(v6, a2, v9);
  if (v7) {
    return pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  }
  return result;
}

void sub_18417084C(_Unwind_Exception *exception_object)
{
  if (v1) {
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

uint64_t DiskCookieStorage::syncStorageWithCompletionLocked(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_84_12198, 1);
  char v6 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
  if (v5)
  {
    uint64_t v7 = v5;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v5 + 16))(v5, "DiskCookieStorage Sync Request", 0))
    {
      CFAllocatorRef v8 = *v6;
      if (a2) {
        uint64_t v9 = "yes";
      }
      else {
        uint64_t v9 = "no";
      }
      *(void *)&cStr.st_dev = off_1ECF9A530;
      *(void *)&cStr.st_uuint64_t id = 0;
      *(void *)&cStr.st_rdev = 0;
      cStr.__darwin_ino64_t st_ino = (__darwin_ino64_t)CFStringCreateWithCString(v8, "Forced", 0x8000100u);
      *(void *)buf = off_1ECF9A530;
      CFStringRef v88 = 0;
      *(void *)&uint8_t buf[8] = CFStringCreateWithCString(v8, v9, 0x8000100u);
      *(void *)&uint8_t buf[16] = 0;
      (*(void (**)(uint64_t, __darwin_ino64_t, void))(*(void *)v7 + 64))(v7, cStr.st_ino, *(void *)&buf[8]);
      AutoString::~AutoString((AutoString *)buf);
      AutoString::~AutoString((AutoString *)&cStr);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
      double v10 = *(double *)(a1 + 96);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      if (v10 == 0.0) {
        uint64_t v11 = "no";
      }
      else {
        uint64_t v11 = "yes";
      }
      *(void *)&cStr.st_dev = off_1ECF9A530;
      CFStringRef v12 = CFStringCreateWithCString(v8, "isDirty", 0x8000100u);
      *(void *)&cStr.st_uuint64_t id = 0;
      *(void *)&cStr.st_rdev = 0;
      cStr.__darwin_ino64_t st_ino = (__darwin_ino64_t)v12;
      *(void *)buf = off_1ECF9A530;
      CFStringRef v13 = CFStringCreateWithCString(v8, v11, 0x8000100u);
      CFStringRef v88 = 0;
      *(void *)&uint8_t buf[8] = v13;
      *(void *)&uint8_t buf[16] = 0;
      (*(void (**)(uint64_t, __darwin_ino64_t, CFStringRef))(*(void *)v7 + 64))(v7, cStr.st_ino, v13);
      AutoString::~AutoString((AutoString *)buf);
      AutoString::~AutoString((AutoString *)&cStr);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
      double v14 = *(double *)(a1 + 112);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      if (v14 == 0.0) {
        uint64_t v15 = "no";
      }
      else {
        uint64_t v15 = "yes";
      }
      *(void *)&cStr.st_dev = off_1ECF9A530;
      CFStringRef v16 = CFStringCreateWithCString(v8, "isWriting", 0x8000100u);
      *(void *)&cStr.st_uuint64_t id = 0;
      *(void *)&cStr.st_rdev = 0;
      cStr.__darwin_ino64_t st_ino = (__darwin_ino64_t)v16;
      *(void *)buf = off_1ECF9A530;
      CFStringRef v17 = CFStringCreateWithCString(v8, v15, 0x8000100u);
      CFStringRef v88 = 0;
      *(void *)&uint8_t buf[8] = v17;
      *(void *)&uint8_t buf[16] = 0;
      (*(void (**)(uint64_t, __darwin_ino64_t, CFStringRef))(*(void *)v7 + 64))(v7, cStr.st_ino, v17);
      AutoString::~AutoString((AutoString *)buf);
      AutoString::~AutoString((AutoString *)&cStr);
      size_t v18 = strlen((const char *)(*(void *)(a1 + 72) + 1));
      CFURLRef v19 = CFURLCreateFromFileSystemRepresentation(*(CFAllocatorRef *)(a1 + 8), (const UInt8 *)(*(void *)(a1 + 72) + 1), v18, 0);
      (*(void (**)(uint64_t, const char *, CFURLRef))(*(void *)v7 + 40))(v7, "File", v19);
      CFRelease(v19);
      if (*(void *)(a1 + 304)) {
        uint64_t v20 = "yes";
      }
      else {
        uint64_t v20 = "no";
      }
      *(void *)&cStr.st_dev = off_1ECF9A530;
      CFStringRef v21 = CFStringCreateWithCString(v8, "Journal", 0x8000100u);
      *(void *)&cStr.st_uuint64_t id = 0;
      *(void *)&cStr.st_rdev = 0;
      cStr.__darwin_ino64_t st_ino = (__darwin_ino64_t)v21;
      *(void *)buf = off_1ECF9A530;
      CFStringRef v22 = CFStringCreateWithCString(v8, v20, 0x8000100u);
      CFStringRef v88 = 0;
      *(void *)&uint8_t buf[8] = v22;
      *(void *)&uint8_t buf[16] = 0;
      (*(void (**)(uint64_t, __darwin_ino64_t, CFStringRef))(*(void *)v7 + 64))(v7, cStr.st_ino, v22);
      AutoString::~AutoString((AutoString *)buf);
      AutoString::~AutoString((AutoString *)&cStr);
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72))(v7, "Mutations", @"%ld");
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  if (a2)
  {
    double v23 = *(double *)(a1 + 112);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
    if (v23 != 0.0) {
      dispatch_sync_f(*(dispatch_queue_t *)(a1 + 80), (void *)a1, (dispatch_function_t)DiskCookieStorage::_waitUntilDone);
    }
  }
  else
  {
    double v24 = *(double *)(a1 + 96);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
    if (v24 == 0.0) {
      goto LABEL_99;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
    double v25 = *(double *)(a1 + 112);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
    if (v25 != 0.0) {
      goto LABEL_99;
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  uint64_t v26 = *(void *)(a1 + 176);
  uint64_t v27 = *(void *)(a1 + 184);
  uint64_t v79 = *(void *)(a1 + 224);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
  uint64_t v28 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_98_12209, 2);
  uint64_t v29 = v28;
  if (v28
    && (*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)v28 + 32))(v28, "DiskCookieStorage Checking", a1))
  {
    size_t v30 = strlen((const char *)(*(void *)(a1 + 72) + 1));
    CFURLRef v31 = CFURLCreateFromFileSystemRepresentation(*(CFAllocatorRef *)(a1 + 8), (const UInt8 *)(*(void *)(a1 + 72) + 1), v30, 0);
    (*(void (**)(uint64_t, const char *, CFURLRef))(*(void *)v29 + 40))(v29, "File", v31);
    CFRelease(v31);
    int v32 = stat((const char *)(*(void *)(a1 + 72) + 1), &v81);
    double v33 = *MEMORY[0x1E4F1CF78];
    if (v32)
    {
      uint64_t tv_nsec = 0;
      __darwin_time_t tv_sec = 0;
      memset(&v81, 0, sizeof(v81));
    }
    else
    {
      __darwin_time_t tv_sec = v81.st_mtimespec.tv_sec;
      uint64_t tv_nsec = v81.st_mtimespec.tv_nsec;
    }
    CFDateRef v36 = CFDateCreate(*(CFAllocatorRef *)(a1 + 8), (double)tv_sec - v33 + (double)tv_nsec / 1000000000.0);
    CFAllocatorRef v37 = *v6;
    *(void *)&cStr.st_dev = off_1ECF9A530;
    __darwin_ino64_t st_ino = (__darwin_ino64_t)CFStringCreateWithCString(v37, "Disk Mod", 0x8000100u);
    *(void *)&cStr.st_uuint64_t id = 0;
    *(void *)&cStr.st_rdev = 0;
    cStr.__darwin_ino64_t st_ino = st_ino;
    if (v36)
    {
      CFStringRef v39 = CFCopyDescription(v36);
      __darwin_ino64_t st_ino = cStr.st_ino;
    }
    else
    {
      CFStringRef v39 = @"null";
    }
    (*(void (**)(uint64_t, __darwin_ino64_t, CFStringRef))(*(void *)v29 + 64))(v29, st_ino, v39);
    if (v36) {
      BOOL v40 = v39 == 0;
    }
    else {
      BOOL v40 = 1;
    }
    if (!v40) {
      CFRelease(v39);
    }
    AutoString::~AutoString((AutoString *)&cStr);
    CFRelease(v36);
    CFDateRef v41 = CFDateCreate(*(CFAllocatorRef *)(a1 + 8), (double)v27 / 1000000000.0 + (double)v26 - v33);
    *(void *)&cStr.st_dev = off_1ECF9A530;
    __darwin_ino64_t v42 = (__darwin_ino64_t)CFStringCreateWithCString(v37, "Last Sync", 0x8000100u);
    *(void *)&cStr.st_uuint64_t id = 0;
    *(void *)&cStr.st_rdev = 0;
    cStr.__darwin_ino64_t st_ino = v42;
    if (v41)
    {
      CFStringRef v43 = CFCopyDescription(v41);
      __darwin_ino64_t v42 = cStr.st_ino;
    }
    else
    {
      CFStringRef v43 = @"null";
    }
    (*(void (**)(uint64_t, __darwin_ino64_t, CFStringRef))(*(void *)v29 + 64))(v29, v42, v43);
    if (v41) {
      BOOL v44 = v43 == 0;
    }
    else {
      BOOL v44 = 1;
    }
    if (!v44) {
      CFRelease(v43);
    }
    AutoString::~AutoString((AutoString *)&cStr);
    CFRelease(v41);
    uint64_t v45 = *(void *)(a1 + 288);
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
    CFStringRef v88 = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
    p_stat cStr = &cStr;
    int v90 = 256;
    MemoryCookies::withImmutableDomains(v45, (uint64_t)buf);
    *(void *)buf = off_1ECF9A530;
    CFStringRef v46 = CFStringCreateWithCString(v37, "Persistent Cookies", 0x8000100u);
    CFStringRef v88 = 0;
    *(void *)&uint8_t buf[8] = v46;
    *(void *)&uint8_t buf[16] = 0;
    CFStringRef v83 = off_1ECF9A530;
    CFStringRef v47 = CFStringCreateWithCString(v37, (const char *)&cStr, 0x8000100u);
    uint64_t v85 = 0;
    uint64_t v86 = 0;
    CFStringRef v84 = v47;
    (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v29 + 64))(v29, *(void *)&buf[8], v47);
    AutoString::~AutoString((AutoString *)&v83);
    AutoString::~AutoString((AutoString *)buf);
    uint64_t v48 = *(void *)(a1 + 280);
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = ___ZNK13MemoryCookies14getDescriptionEPci_block_invoke;
    CFStringRef v88 = &__block_descriptor_44_e25_v16__0____CFDictionary__8l;
    p_stat cStr = &cStr;
    int v90 = 256;
    MemoryCookies::withImmutableDomains(v48, (uint64_t)buf);
    *(void *)buf = off_1ECF9A530;
    CFStringRef v49 = CFStringCreateWithCString(v37, "Session Cookies", 0x8000100u);
    CFStringRef v88 = 0;
    *(void *)&uint8_t buf[8] = v49;
    *(void *)&uint8_t buf[16] = 0;
    CFStringRef v83 = off_1ECF9A530;
    CFStringRef v50 = CFStringCreateWithCString(v37, (const char *)&cStr, 0x8000100u);
    uint64_t v85 = 0;
    uint64_t v86 = 0;
    CFStringRef v84 = v50;
    (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v29 + 64))(v29, *(void *)&buf[8], v50);
    AutoString::~AutoString((AutoString *)&v83);
    AutoString::~AutoString((AutoString *)buf);
    if (*(void *)(a1 + 304))
    {
      *(void *)buf = off_1ECF9A530;
      if ((double)v81.st_mtimespec.tv_sec - v33 + (double)v81.st_mtimespec.tv_nsec / 1000000000.0 == (double)v27 / 1000000000.0 + (double)v26 - v33)
      {
        CFStringRef v55 = CFStringCreateWithCString(v37, "Journal", 0x8000100u);
        CFStringRef v88 = 0;
        *(void *)&uint8_t buf[8] = v55;
        *(void *)&uint8_t buf[16] = 0;
        CFStringRef v83 = off_1ECF9A530;
        CFStringRef v52 = CFStringCreateWithCString(v37, "not required", 0x8000100u);
      }
      else
      {
        CFStringRef v51 = CFStringCreateWithCString(v37, "Journal", 0x8000100u);
        CFStringRef v88 = 0;
        *(void *)&uint8_t buf[8] = v51;
        *(void *)&uint8_t buf[16] = 0;
        CFStringRef v83 = off_1ECF9A530;
        CFStringRef v52 = CFStringCreateWithCString(v37, "must replay", 0x8000100u);
      }
      uint64_t v85 = 0;
      uint64_t v86 = 0;
      CFStringRef v84 = v52;
      (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v29 + 64))(v29, *(void *)&buf[8], v52);
    }
    else
    {
      *(void *)buf = off_1ECF9A530;
      CFStringRef v53 = CFStringCreateWithCString(v37, "Journal", 0x8000100u);
      CFStringRef v88 = 0;
      *(void *)&uint8_t buf[8] = v53;
      *(void *)&uint8_t buf[16] = 0;
      CFStringRef v83 = off_1ECF9A530;
      CFStringRef v54 = CFStringCreateWithCString(v37, "none", 0x8000100u);
      uint64_t v85 = 0;
      uint64_t v86 = 0;
      CFStringRef v84 = v54;
      (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v29 + 64))(v29, *(void *)&buf[8], v54);
    }
    AutoString::~AutoString((AutoString *)&v83);
    AutoString::~AutoString((AutoString *)buf);
    (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
  }
  if (a2)
  {
    BOOL v56 = *(void *)(a1 + 312) == 0;
    if (!*(void *)(a1 + 312)) {
      goto LABEL_60;
    }
  }
  else
  {
    BOOL v56 = 0;
  }
  if (*(void *)(a1 + 304))
  {
    if (*(unsigned char *)(a1 + 324)) {
      goto LABEL_61;
    }
    if (!stat((const char *)(*(void *)(a1 + 72) + 1), &cStr))
    {
      if ((double)cStr.st_mtimespec.tv_sec - *MEMORY[0x1E4F1CF78] + (double)cStr.st_mtimespec.tv_nsec / 1000000000.0 != (double)v27 / 1000000000.0 + (double)v26 - *MEMORY[0x1E4F1CF78]
        || cStr.st_size != v79)
      {
        goto LABEL_61;
      }
LABEL_56:
      uint64_t v57 = *(void *)(a1 + 304);
      if (v57) {
        CFDataSetLength(*(CFMutableDataRef *)(v57 + 16), 0);
      }
      goto LABEL_92;
    }
    BOOL v56 = 0;
  }
LABEL_60:
  if (!v56) {
    goto LABEL_56;
  }
LABEL_61:
  CFAllocatorRef v58 = *(const __CFAllocator **)(a1 + 8);
  uint64_t v59 = (MemoryCookies *)CFAllocatorAllocate(v58, 32, 0);
  *(_OWORD *)uint64_t v59 = 0u;
  *((_OWORD *)v59 + 1) = 0u;
  MemoryCookies::MemoryCookies(v59, v58);
  DiskCookieStorage::readFileToCookies((DiskCookieStorage *)a1, v59);
  if (!stat((const char *)(*(void *)(a1 + 72) + 1), &cStr))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
    long long v60 = *(_OWORD *)&cStr.st_blksize;
    *(_OWORD *)(a1 + 224) = *(_OWORD *)&cStr.st_size;
    *(_OWORD *)(a1 + 240) = v60;
    *(_OWORD *)(a1 + 256) = *(_OWORD *)cStr.st_qspare;
    timespec st_mtimespec = cStr.st_mtimespec;
    *(timespec *)(a1 + 160) = cStr.st_atimespec;
    *(timespec *)(a1 + 176) = st_mtimespec;
    timespec st_birthtimespec = cStr.st_birthtimespec;
    *(timespec *)(a1 + 192) = cStr.st_ctimespec;
    *(timespec *)(a1 + 208) = st_birthtimespec;
    long long v63 = *(_OWORD *)&cStr.st_uid;
    *(_OWORD *)(a1 + 128) = *(_OWORD *)&cStr.st_dev;
    *(_OWORD *)(a1 + 144) = v63;
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
  }
  uint64_t v64 = *(void *)(a1 + 304);
  if (v64)
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v64 + 16));
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(v64 + 16));
    if (Length >= 1)
    {
      unint64_t v67 = (unint64_t)&BytePtr[Length];
      uint64_t v68 = MEMORY[0x1E4F14500];
      __int16 v69 = (CompactCookieHeader *)BytePtr;
      do
      {
        int v71 = *(_DWORD *)v69;
        __int16 v69 = (CompactCookieHeader *)((char *)v69 + 4);
        int v70 = v71;
        if ((unint64_t)v69 > v67 && os_log_type_enabled(v68, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 134218240;
          *(void *)&uint8_t buf[4] = v69;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v67;
          _os_log_fault_impl(&dword_184085000, v68, OS_LOG_TYPE_FAULT, "overflow %p < %p", buf, 0x16u);
        }
        if (v70 == 2)
        {
          MemoryCookies::deleteAllCookies(v59);
        }
        else if (v70 == 3)
        {
          int v72 = *((_DWORD *)BytePtr + 1);
          __int16 v69 = (CompactCookieHeader *)(BytePtr + 8);
          if ((unint64_t)(BytePtr + 8) > v67 && os_log_type_enabled(v68, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 134218240;
            *(void *)&uint8_t buf[4] = BytePtr + 8;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v67;
            _os_log_fault_impl(&dword_184085000, v68, OS_LOG_TYPE_FAULT, "overflow %p < %p - policy", buf, 0x16u);
          }
          *(_DWORD *)(a1 + 320) = v72;
        }
        else
        {
          if (*(_DWORD *)v69 >= 4u) {
            uint64_t v73 = *(_DWORD *)v69;
          }
          else {
            uint64_t v73 = 0;
          }
          CFIndex v74 = (CompactCookieHeader *)((char *)v69 + v73);
          if ((unint64_t)v69 + v73 > v67 && os_log_type_enabled(v68, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_184085000, v68, OS_LOG_TYPE_FAULT, "overflow", buf, 2u);
          }
          if (v70 == 1)
          {
            MemoryCookies::deleteCookie(v59, v69);
          }
          else if (!v70)
          {
            MemoryCookies::setCookie((CompactCookieArray **)v59, v69);
          }
          __int16 v69 = v74;
        }
        BytePtr = (const UInt8 *)v69;
      }
      while ((unint64_t)v69 < v67);
    }
    CFDataSetLength(*(CFMutableDataRef *)(*(void *)(a1 + 304) + 16), 0);
  }
  uint64_t v75 = *(void *)(a1 + 288);
  if (v75)
  {
    (*(void (**)(uint64_t))(*(void *)v75 + 8))(v75);
    *(void *)(a1 + 288) = 0;
  }
  *(void *)(a1 + 288) = v59;
  MemoryCookies::deleteAllCookies(*(MemoryCookies **)(a1 + 296));
  MemoryCookies::mergeCookiesFrom(*(CFAllocatorRef **)(a1 + 296), *(const MemoryCookies **)(a1 + 288));
  MemoryCookies::mergeCookiesFrom(*(CFAllocatorRef **)(a1 + 296), *(const MemoryCookies **)(a1 + 280));
LABEL_92:
  if (!a2 || *(void *)(a1 + 312))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
    CFAllocatorRef v76 = *(const __CFAllocator **)(a1 + 8);
    AutoScalar::AutoScalar((AutoScalar *)&cStr, (const __CFAllocator *)*(unsigned int *)(a1 + 320));
    MutableDictionary = cfTypeCreateMutableDictionary(v76, @"NSHTTPCookieAcceptPolicy", cStr.st_ino, 0, 0);
    *(void *)&cStr.st_dev = &unk_1ECF9A500;
    if (cStr.st_ino) {
      CFRelease((CFTypeRef)cStr.st_ino);
    }
    CFPropertyListCreateData(*(CFAllocatorRef *)(a1 + 8), MutableDictionary, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (MutableDictionary) {
      CFRelease(MutableDictionary);
    }
    *(CFAbsoluteTime *)(a1 + 112) = CFAbsoluteTimeGetCurrent();
    operator new();
  }
LABEL_99:
  uint64_t result = a3;
  if (a3) {
    return (*(uint64_t (**)(void))(a3 + 16))();
  }
  return result;
}

void sub_184171A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,CFTypeRef cf,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  AutoString::~AutoString((AutoString *)&a68);
  AutoString::~AutoString((AutoString *)&STACK[0x270]);
  _Unwind_Resume(a1);
}

void HTTPCookieStorage::~HTTPCookieStorage(HTTPCookieStorage *this)
{
  *(void *)this = &unk_1ECF9E5A0;
  *((void *)this + 1) = &unk_1ECF9E5E8;
  uint64_t v2 = (void *)*((void *)this + 2);
  uint64_t v3 = v2[4];
  if (v3) {
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 8));
  }
  (*(void (**)(void *))(*v2 + 80))(v2);
  if (v3) {
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  }
  (*(void (**)(void))(**((void **)this + 2) + 48))(*((void *)this + 2));
  uint64_t v4 = (const void *)*((void *)this + 3);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 7);
  if (v5)
  {
    _Block_release(v5);
    *((void *)this + 7) = 0;
  }
  if (*((void *)this + 9) != -1)
  {
    sandbox_extension_release();
    *((void *)this + 9) = -1;
  }
  char v6 = (const void *)*((void *)this + 10);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)*((void *)this + 13);
  if (v7) {
    _Block_release(v7);
  }
  CFAllocatorRef v8 = (const void *)*((void *)this + 14);
  if (v8) {
    _Block_release(v8);
  }
  uint64_t v9 = *((void *)this + 11);
  if (v9) {
    dispatch_release(v9);
  }
  double v10 = *((void *)this + 12);
  if (v10) {
    dispatch_release(v10);
  }
  *((void *)this + 1) = &unk_1ECF9B550;
}

void sub_184171C80(_Unwind_Exception *exception_object)
{
  if (v2) {
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 8));
  }
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(exception_object);
}

void MemoryCookieStorage::~MemoryCookieStorage(MemoryCookieStorage *this)
{
  MemoryCookieStorage::~MemoryCookieStorage(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1ECF9FE58;
  *((void *)this + 3) = &unk_1ECF9FF38;
  uint64_t v2 = *((void *)this + 9);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(this);
}

void PrivateHTTPCookieStorage::~PrivateHTTPCookieStorage(PrivateHTTPCookieStorage *this)
{
  *(void *)this = &unk_1ECFA2ED0;
  *((void *)this + 3) = &unk_1ECFA2FB0;
  uint64_t v2 = (const void *)*((void *)this + 7);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 6);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *((void *)this + 4);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  *((void *)this + 3) = &unk_1ECF9B550;
}

void sub_184171DBC(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void MemoryCookies::~MemoryCookies(MemoryCookies *this)
{
  MemoryCookies::~MemoryCookies(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  const void *v2;

  *(void *)this = &unk_1ECF9C338;
  *((void *)this + 2) = &unk_1ECF9C360;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 2) = &unk_1ECF9B550;
}

void sub_184171F3C(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void ___ZN17HTTPCookieStorage25syncStorageWithCompletionEhU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  *(CFAbsoluteTime *)(v2 + 48) = CFAbsoluteTimeGetCurrent();
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    (*(void (**)(void))(v3 + 16))();
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

void MemoryCookies::deleteAllCookies(MemoryCookies *this)
{
  uint64_t v1 = (const void *)*((void *)this + 3);
  *((void *)this + 3) = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CStringKeyCallbacks::caseInsensitiveCallbacks(void)::sCallbacks, MEMORY[0x1E4F1D540]);
  if (v1)
  {
    CFRelease(v1);
  }
}

void sub_184172160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void initializeUserAgentString(void)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (sUserAgentString) {
    return;
  }
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (!Mutable)
  {
    uint64_t v8 = 0;
    atomic_compare_exchange_strong(&sUserAgentString, (unint64_t *)&v8, 0x1EC0A2DC8uLL);
    return;
  }
  uint64_t v2 = Mutable;
  MainBundle = CFBundleGetMainBundle();
  uint64_t v4 = (const void **)MEMORY[0x1E4F1D020];
  if (!MainBundle) {
    goto LABEL_20;
  }
  uint64_t v5 = MainBundle;
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
  if (!dyld_program_sdk_at_least())
  {
    CFStringRef ValueForInfoDictionaryKey = (const __CFString *)CFBundleGetValueForInfoDictionaryKey(v5, (CFStringRef)*MEMORY[0x1E4F1D008]);
LABEL_9:
    if (ValueForInfoDictionaryKey)
    {
      appendEscaped(v2, ValueForInfoDictionaryKey);
      if (!InfoDictionary) {
        goto LABEL_17;
      }
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (InfoDictionary)
  {
    CFStringRef ValueForInfoDictionaryKey = (const __CFString *)CFDictionaryGetValue(InfoDictionary, (const void *)*MEMORY[0x1E4F1D008]);
    goto LABEL_9;
  }
LABEL_12:
  CFURLRef v9 = CFBundleCopyExecutableURL(v5);
  if (v9)
  {
    CFURLRef v10 = v9;
    CFStringRef PathComponent = CFURLCopyLastPathComponent(v9);
    if (!PathComponent)
    {
      CFStringRef v15 = (CFStringRef)v10;
      goto LABEL_19;
    }
    CFStringRef v12 = PathComponent;
    appendEscaped(v2, PathComponent);
    CFRelease(v12);
    CFRelease(v10);
    if (!InfoDictionary)
    {
LABEL_17:
      CFStringAppendFormat(v2, 0, @" %@", @"(unknown version)");
      goto LABEL_20;
    }
LABEL_15:
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, *v4);
    if (Value)
    {
      CFStringRef v14 = CFURLCreateStringByAddingPercentEscapes(v0, Value, 0, @"()<>@,;:\\\"/[]?={} \t", 0x8000100u);
      CFStringAppendFormat(v2, 0, @"/%@", v14);
      CFStringRef v15 = v14;
LABEL_19:
      CFRelease(v15);
      goto LABEL_20;
    }
    goto LABEL_17;
  }
LABEL_20:
  if (CFStringGetLength(v2)) {
    CFStringAppendFormat(v2, 0, @" %@", @"CFNetwork");
  }
  else {
    CFStringAppend(v2, @"CFNetwork");
  }
  if (__CFNGetCFNetworkBundle::onceToken != -1) {
    dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_5505);
  }
  CFTypeRef v16 = CFBundleGetValueForInfoDictionaryKey((CFBundleRef)__CFNGetCFNetworkBundle::bundle, (CFStringRef)*v4);
  if (v16) {
    CFStringAppendFormat(v2, 0, @"/%@", v16);
  }
  else {
    CFStringAppendFormat(v2, 0, @" %@", @"(unknown version)");
  }
  *(void *)double v25 = 0x100000001;
  CFStringRef v17 = copySysctl(v25);
  if (v17)
  {
    CFStringRef v18 = v17;
    CFStringRef v19 = CFURLCreateStringByAddingPercentEscapes(v0, v17, 0, @"()<>@,;:\\\"/[]?={} \t", 0x8000100u);
    CFStringAppendFormat(v2, 0, @" %@", v19);
    CFRelease(v19);
    CFRelease(v18);
    *(void *)double v25 = 0x200000001;
    CFStringRef v20 = copySysctl(v25);
    if (v20)
    {
      CFStringRef v21 = v20;
      CFStringRef v22 = CFURLCreateStringByAddingPercentEscapes(v0, v20, 0, @"()<>@,;:\\\"/[]?={} \t", 0x8000100u);
      CFStringAppendFormat(v2, 0, @"/%@", v22);
      CFRelease(v22);
      CFRelease(v21);
    }
    else
    {
      CFStringAppendFormat(v2, 0, @" %@", @"(unknown version)");
    }
  }
  CFStringRef Copy = CFStringCreateCopy(v0, v2);
  uint64_t v24 = 0;
  atomic_compare_exchange_strong(&sUserAgentString, (unint64_t *)&v24, (unint64_t)Copy);
  if (v24)
  {
    if (Copy) {
      CFRelease(Copy);
    }
  }
  CFRelease(v2);
}

CFStringRef copySysctl(int *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  size_t v2 = 128;
  if (sysctl(a1, 2u, cStr, &v2, 0, 0) < 0) {
    return 0;
  }
  else {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x8000100u);
  }
}

void appendEscaped(__CFString *a1, const __CFString *a2)
{
  CFStringRef v3 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0, @"()<>@,;:\\\"/[]?={} \t",
         0x8000100u);
  CFStringAppend(a1, v3);

  CFRelease(v3);
}

CFStringRef ___ZL11getBundleIdv_block_invoke()
{
  getBundleId(void)::bundle = (uint64_t)CFBundleGetMainBundle();
  CFStringRef result = CFBundleGetIdentifier((CFBundleRef)getBundleId(void)::bundle);
  getBundleId(void)::bundleID = (uint64_t)result;
  return result;
}

uint64_t ___ZN19TransportConnectionC2EPU28objcproto17OS_dispatch_queue8NSObject_block_invoke()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v0 = getrlimit(8, &v6);
  *(void *)uint64_t v7 = 0x1D00000001;
  int rlim_max = 0;
  size_t v4 = 4;
  uint64_t result = sysctl(v7, 2u, &rlim_max, &v4, 0, 0);
  if (result | v0)
  {
    if (v0) {
      return result;
    }
    LODWORD(v2) = rlim_max;
  }
  else
  {
    LODWORD(v2) = rlim_max;
    if (v6.rlim_max < rlim_max)
    {
      int rlim_max = v6.rlim_max;
      LODWORD(v2) = v6.rlim_max;
    }
  }
  if (v6.rlim_cur < (int)v2)
  {
    rlim_t v2 = (int)v2;
    rlimit v3 = v6;
    if (v6.rlim_cur + 2304 < (int)v2) {
      rlim_t v2 = v6.rlim_cur + 2304;
    }
    v3.rlim_cur = v2;
    return setrlimit(8, &v3);
  }
  return result;
}

void ___ZN21TrustExceptionManager27sharedTrustExceptionManagerEv_block_invoke()
{
}

void sub_1841728F0(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  MEMORY[0x18531B6D0](v1, 0x10A1C40914F2AA0);
  _Unwind_Resume(a1);
}

CFArrayRef CFHTTPCookieCopyPortArray(OpaqueCFHTTPCookie *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFStringRef v18 = &unk_1ECFA5BB8;
  CFMutableArrayRef theArray = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = [(OpaqueCFHTTPCookie *)a1 _inner];
  size_t v4 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
  if (*v4 >= 0x10u)
  {
    uint64_t v5 = v4[3];
    if (v5)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 2 * v5;
      do
      {
        uint64_t v8 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
        uint64_t v9 = (v6 + 56);
        uint64_t v10 = *v8;
        if (v10 <= v9 || (char *)v8 + v9 + 2 > (char *)v8 + v10) {
          CFAllocatorRef v12 = 0;
        }
        else {
          CFAllocatorRef v12 = (const __CFAllocator *)*(unsigned __int16 *)((char *)v8 + v9);
        }
        AutoScalar::AutoScalar((AutoScalar *)&v16, v12);
        if (value)
        {
          CFArrayAppendValue(theArray, value);
          CFTypeRef v16 = &unk_1ECF9A500;
          if (value) {
            CFRelease(value);
          }
        }
        else
        {
          CFTypeRef v16 = &unk_1ECF9A500;
        }
        v6 += 2;
      }
      while (v7 != v6);
    }
  }
  CFAllocatorRef v13 = CFGetAllocator(theArray);
  CFArrayRef Copy = CFArrayCreateCopy(v13, theArray);
  CFStringRef v18 = &unk_1ECFA5BB8;
  if (theArray) {
    CFRelease(theArray);
  }
  return Copy;
}

void sub_184172B04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef a10, uint64_t a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void CFURLCacheRemoveAllCachedResponses(void *a1)
{
  if (a1)
  {
    uint64_t TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      uint64_t v3 = (__CFURLCache *)a1[2];
      __CFURLCache::PurgeMemoryCache(v3);
      __CFURLCache::PurgePersistentCache(v3);
    }
    else
    {
      size_t v4 = (const char *)CFURLCacheRemoveAllCachedResponses::s;
      if (!CFURLCacheRemoveAllCachedResponses::s)
      {
        size_t v4 = sel_registerName("_nscfBridgeURLCacheRemoveAllCachedResponses");
        CFURLCacheRemoveAllCachedResponses::s = (uint64_t)v4;
      }
      [a1 v4];
    }
  }
}

void __CFURLCache::~__CFURLCache(__CFURLCache *this)
{
  *(void *)this = &unk_1ECF9C318;
  __CFURLCache::PurgeMemoryCache(this);
  CFAllocatorRef v2 = (const void *)*((void *)this + 27);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 27) = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  CFSetRemoveAllValues(*((CFMutableSetRef *)this + 56));
  uint64_t v3 = (const void *)*((void *)this + 56);
  if (v3) {
    CFRelease(v3);
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 376));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 376));
  size_t v4 = (const void *)*((void *)this + 4);
  if (v4)
  {
    _Block_release(v4);
    *((void *)this + 4) = 0;
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5)
  {
    dispatch_release(v5);
    *((void *)this + 3) = 0;
  }
  if (*((void *)this + 65))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 65));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
    uint64_t v6 = (const void *)*((void *)this + 65);
    if (v6) {
      CFRelease(v6);
    }
    *((void *)this + 65) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456));
  if (*((void *)this + 67))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 552));
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 67));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 552));
    uint64_t v7 = (const void *)*((void *)this + 67);
    if (v7) {
      CFRelease(v7);
    }
    *((void *)this + 67) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 552));
  uint64_t v8 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v8)
  {
    uint64_t v9 = *((void *)this + 17);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZN12__CFURLCacheD2Ev_block_invoke;
    block[3] = &unk_1E5258228;
    block[4] = v8;
    dispatch_async(v9, block);
  }
  dispatch_release(*((dispatch_object_t *)this + 17));

  uint64_t v10 = (sqlite3 *)*((void *)this + 78);
  if (v10) {
    sqlite3_close(v10);
  }
  std::deque<__CFURLCacheNode *>::~deque[abi:nn180100]((uint64_t)this + 264);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)this + 224);
  *((void *)this + 6) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 56));
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
}

{
  uint64_t vars8;

  __CFURLCache::~__CFURLCache(this);

  JUMPOUT(0x18531B6D0);
}

void sub_184172DEC(_Unwind_Exception *a1)
{
  std::deque<__CFURLCacheNode *>::~deque[abi:nn180100](v1 + 264);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table(v1 + 224);
  *(void *)(v1 + 48) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 56));
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(a1);
}

uint64_t __CFURLCache::PurgeMemoryCache(__CFURLCache *this)
{
  CFAllocatorRef v2 = (pthread_mutex_t *)((char *)this + 312);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 312));
  for (CFIndex i = (void *)*((void *)this + 30); i; CFIndex i = (void *)*i)
  {
    NodeFromHashMap = __CFURLCache::GetNodeFromHashMap(this, i[2]);
    if (NodeFromHashMap) {
      (*(void (**)(void *))(*NodeFromHashMap + 8))(NodeFromHashMap);
    }
  }
  if (*((void *)this + 31))
  {
    uint64_t v5 = (void *)*((void *)this + 30);
    if (v5)
    {
      do
      {
        uint64_t v6 = (void *)*v5;
        operator delete(v5);
        uint64_t v5 = v6;
      }
      while (v6);
    }
    *((void *)this + 30) = 0;
    uint64_t v7 = *((void *)this + 29);
    if (v7)
    {
      for (uint64_t j = 0; j != v7; ++j)
        *(void *)(*((void *)this + 28) + 8 * j) = 0;
    }
    *((void *)this + 31) = 0;
  }
  uint64_t v9 = (void **)*((void *)this + 34);
  uint64_t v10 = *((void *)this + 35);
  *((void *)this + 38) = 0;
  unint64_t v11 = v10 - (void)v9;
  if (v11 >= 0x11)
  {
    do
    {
      operator delete(*v9);
      uint64_t v12 = *((void *)this + 35);
      uint64_t v9 = (void **)(*((void *)this + 34) + 8);
      *((void *)this + 34) = v9;
      unint64_t v11 = v12 - (void)v9;
    }
    while (v11 > 0x10);
  }
  if (v11 >> 3 == 1)
  {
    uint64_t v13 = 256;
  }
  else
  {
    if (v11 >> 3 != 2) {
      goto LABEL_19;
    }
    uint64_t v13 = 512;
  }
  *((void *)this + 37) = v13;
LABEL_19:
  *((void *)this + 18) = 0;

  return pthread_mutex_unlock(v2);
}

uint64_t std::deque<__CFURLCacheNode *>::~deque[abi:nn180100](uint64_t a1)
{
  CFAllocatorRef v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      CFAllocatorRef v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 512;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void HTTP2Connection::~HTTP2Connection(HTTP2Connection *this)
{
  CFAllocatorRef v2 = (void *)((char *)this + 648);
  *(void *)this = &unk_1ECF9D4E0;
  *((void *)this + 1) = &unk_1ECF9D558;
  *((void *)this + 2) = &unk_1ECF9D578;
  *((void *)this + 3) = &unk_1ECF9D5C8;
  uint64_t v3 = (HTTPStallTimer *)*((void *)this + 81);
  if (v3)
  {
    HTTPStallTimer::invalidate(v3);
    unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 82);
    void *v2 = 0;
    v2[1] = 0;
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
  HTTP2Connection::flushAllBatchedData(this);
  unint64_t v5 = (const void *)*((void *)this + 29);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 29) = 0;
  }
  uint64_t v6 = *((void *)this + 21);
  if (v6)
  {
    dispatch_release(v6);
    *((void *)this + 21) = 0;
  }
  if (*((void *)this + 20))
  {
    nghttp2_session_del();
    *((void *)this + 20) = 0;
  }
  uint64_t v7 = *((void *)this + 30);
  if (v7)
  {
    CFRelease((CFTypeRef)(v7 - 16));
    *((void *)this + 30) = 0;
  }
  uint64_t v8 = (void *)*((void *)this + 86);
  if (v8)
  {
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v10 = (const __CFString *)*MEMORY[0x1E4F1D160];
    do
    {
      unint64_t v11 = (void (**)(void, void, double))v8[4];
      CFErrorRef v12 = CFErrorCreate(v9, v10, 57, 0);
      ((void (**)(void, CFErrorRef, double))v11)[2](v11, v12, 0.0);
      v19[0] = MEMORY[0x1E4F143A8];
      v19[1] = 3221225472;
      CFStringRef v20 = ___ZN15HTTP2ConnectionD2Ev_block_invoke;
      CFStringRef v21 = &__block_descriptor_40_e5_v8__0l;
      CFErrorRef v22 = v12;
      _Block_release(v11);
      v20((uint64_t)v19);
      uint64_t v8 = (void *)*v8;
    }
    while (v8);
  }
  uint64_t v13 = (void *)v2[8];
  if (v13) {
    v13[1] = 0;
  }

  CFStringRef v14 = *((void *)this + 90);
  v2[8] = 0;
  v2[9] = 0;
  if (v14) {
    dispatch_release(v14);
  }
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)this + 672);
  CFStringRef v15 = (std::__shared_weak_count *)*((void *)this + 82);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v15);
  }
  std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::destroy(*((void **)this + 77));
  CFTypeRef v16 = (const void *)*((void *)this + 73);
  *((void *)this + 73) = 0;
  if (v16) {
    CFRelease(v16);
  }
  HTTP2ServerPush::~HTTP2ServerPush((HTTP2Connection *)((char *)this + 288));
  CFStringRef v17 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  }
  CFStringRef v18 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  *((void *)this + 4) = &unk_1ECFA02B0;
  CFRelease(*((CFTypeRef *)this + 5));
  *((void *)this + 1) = &unk_1ECF9B550;
}

void sub_1841732E8(_Unwind_Exception *a1)
{
  uint64_t v3 = *(NSObject **)(v1 + 720);
  *(void *)(v1 + 720) = 0;
  if (v3) {
    dispatch_release(v3);
  }
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table(v1 + 672);
  unint64_t v4 = *(std::__shared_weak_count **)(v1 + 656);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  std::__tree<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,std::__map_value_compare<HTTP2Stream *,std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>,BOOL (*)(HTTP2Stream const*,HTTP2Stream const*),false>,std::allocator<std::__value_type<HTTP2Stream *,NSObject  {objcproto16OS_dispatch_data}*>>>::destroy(*(void **)(v1 + 616));
  unint64_t v5 = *(const void **)(v1 + 584);
  *(void *)(v1 + 584) = 0;
  if (v5) {
    CFRelease(v5);
  }
  HTTP2ServerPush::~HTTP2ServerPush((HTTP2ServerPush *)(v1 + 288));
  uint64_t v6 = *(std::__shared_weak_count **)(v1 + 280);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 64);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  *(void *)(v1 + 32) = &unk_1ECFA02B0;
  CFRelease(*(CFTypeRef *)(v1 + 40));
  *(void *)(v1 + 8) = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void HTTP2ServerPush::~HTTP2ServerPush(HTTP2ServerPush *this)
{
  CFAllocatorRef v2 = (void *)*((void *)this + 34);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      unint64_t v4 = (std::__shared_weak_count *)v2[4];
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v4);
      }
      operator delete(v2);
      CFAllocatorRef v2 = v3;
    }
    while (v3);
  }
  unint64_t v5 = (void *)*((void *)this + 32);
  *((void *)this + 32) = 0;
  if (v5) {
    operator delete(v5);
  }
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)this + 216);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)this + 176);
  uint64_t v6 = (void *)*((void *)this + 18);
  if (v6)
  {
    do
    {
      uint64_t v7 = (void *)*v6;
      operator delete(v6);
      uint64_t v6 = v7;
    }
    while (v7);
  }
  uint64_t v8 = (void *)*((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v8) {
    operator delete(v8);
  }
  CFAllocatorRef v9 = (void *)*((void *)this + 13);
  if (v9)
  {
    do
    {
      CFStringRef v10 = (void *)*v9;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,0>((uint64_t)(v9 + 2));
      operator delete(v9);
      CFAllocatorRef v9 = v10;
    }
    while (v10);
  }
  unint64_t v11 = (void *)*((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v11) {
    operator delete(v11);
  }
  CFErrorRef v12 = (void *)*((void *)this + 8);
  if (v12)
  {
    do
    {
      uint64_t v13 = (void *)*v12;
      operator delete(v12);
      CFErrorRef v12 = v13;
    }
    while (v13);
  }
  CFStringRef v14 = (void *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v14) {
    operator delete(v14);
  }
  CFStringRef v15 = (HTTP2ServerPushStream **)*((void *)this + 3);
  if (v15)
  {
    CFTypeRef v16 = (HTTP2ServerPushStream **)*((void *)this + 4);
    CFStringRef v17 = (void *)*((void *)this + 3);
    if (v16 != v15)
    {
      do
        std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](--v16, 0);
      while (v16 != v15);
      CFStringRef v17 = (void *)*((void *)this + 3);
    }
    *((void *)this + 4) = v15;
    operator delete(v17);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table(uint64_t a1)
{
  CFAllocatorRef v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      CFAllocatorRef v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void ___ZN14HTTPHeaderDict9emptyDictEv_block_invoke()
{
  if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1) {
    dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_17041);
  }
  uint64_t Instance = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    *((void *)Instance + 2) = 0;
    *((void *)Instance + 3) = 0;
    uint64_t Instance = (HTTPHeaderDict *)((char *)Instance + 16);
  }
  HTTPHeaderDict::HTTPHeaderDict(Instance);
  HTTPHeaderDict::emptyDict(void)::gEmpty = v1;
}

void ___ZN19RunloopBlockContextC2EPK17CoreSchedulingSet_block_invoke()
{
}

void sub_184173678(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10F1C408D345D2BLL);
  _Unwind_Resume(a1);
}

void RunLoopMultiplexer::RunLoopMultiplexer(RunLoopMultiplexer *this, CFAllocatorRef allocator, const char *a3)
{
  *((_DWORD *)this + 2) = 0;
  *(void *)this = &unk_1ECF9F6F8;
  *((void *)this + 2) = "RunloopBlockContext";
  *((void *)this + 4) = allocator;
  *((void *)this + 3) = CFDictionaryCreateMutable(allocator, 0, &kCoreSchedulingSetCallbacks, 0);
}

void sub_18417370C(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

CFHTTPMessageRef CFHTTPMessageCreateResponse(CFAllocatorRef alloc, CFIndex statusCode, CFStringRef statusDescription, CFStringRef httpVersion)
{
  __int16 v6 = statusCode;
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v8 = (uint64_t)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v8 = (uint64_t)(Instance + 1);
    Instance[18] = 0u;
    Instance[19] = 0u;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v10, httpVersion);
  HTTPResponseMessage::HTTPResponseMessage(v8, v6 & 0x3FF, statusDescription, cf);
  CFStringRef v10 = &unk_1ECF9F718;
  if (cf) {
    CFRelease(cf);
  }
  return (CFHTTPMessageRef)(v8 - 16);
}

void sub_18417383C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'URLConnectionLoader::_loaderInterface_setBytesPerSecondLimit(URLConnectionLoader *this, uint64_t a2)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN19URLConnectionLoader39_loaderInterface_setBytesPerSecondLimitEx_block_invoke;
  void v3[3] = &__block_descriptor_40_e9_v16__0_v8l;
  v3[4] = a2;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)v3);
}

uint64_t ___ZN19URLConnectionLoader39_loaderInterface_setBytesPerSecondLimitEx_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 160))(a2, *(void *)(result + 32));
  }
  return result;
}

dispatch_queue_t ___ZL15getMetricsQueuev_block_invoke()
{
  int v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t result = dispatch_queue_create("com.apple.cfnetwork.ats.metrics", v0);
  getMetricsQueue(void)::metricsQueue = (uint64_t)result;
  return result;
}

uint64_t __copy_helper_block_e8_32c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN11HTTP2Stream16didSendRSTStreamEv_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(_DWORD *)(v1 + 56) != 2) {
    *(_DWORD *)(v1 + 56) = 3;
  }
  return result;
}

uint64_t non-virtual thunk to'URLConnectionLoader::_loaderInterface_setPriorityHint(URLConnectionLoader *this, float a2, char a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZN19URLConnectionLoader32_loaderInterface_setPriorityHintEfb_block_invoke;
  v4[3] = &__block_descriptor_37_e9_v16__0_v8l;
  float v5 = a2;
  char v6 = a3;
  return URLConnectionLoader::withExistingProtocolAsync((uint64_t)&this[-1].var25, (uint64_t)v4);
}

uint64_t ___ZN19URLConnectionLoader32_loaderInterface_setPriorityHintEfb_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, void, float))(*(void *)a2 + 152))(a2, *(unsigned __int8 *)(result + 36), *(float *)(result + 32));
  }
  return result;
}

CFStringRef _CFURLCacheCopyCacheDirectory(os_unfair_lock_s **a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t TypeID = CFURLCacheGetTypeID();
  if (TypeID != CFGetTypeID(a1) || !__CFURLCache::GetDirectoryOfPersistentStore(a1[2])) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef DirectoryOfPersistentStore = (const __CFString *)__CFURLCache::GetDirectoryOfPersistentStore(a1[2]);

  return CFStringCreateCopy(v3, DirectoryOfPersistentStore);
}

uint64_t __CFURLCache::GetDirectoryOfPersistentStore(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 31;
  os_unfair_lock_lock(this + 31);
  if (!*(void *)&this[54]._os_unfair_lock_opaque) {
    *(void *)&this[54]._os_unfair_lock_opaque = __CreatePathToCacheDirectory(0, 0);
  }
  os_unfair_lock_unlock(v2);
  return *(void *)&this[54]._os_unfair_lock_opaque;
}

CFMutableDictionaryRef __logAppleATSViolation_block_invoke()
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  logAppleATSViolation::reportedDomains = (uint64_t)result;
  return result;
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_45()
{
  int v0 = getenv("CFN_USE_HTTP2_CONNECTION_COALESCING");
  if (v0)
  {
    p_p = (char *)&__p;
    std::string::basic_string[abi:nn180100]<0>(&__p, v0);
    unsigned __int8 v2 = v8;
    if ((v8 & 0x80u) == 0) {
      CFAllocatorRef v3 = (char *)&__p + v8;
    }
    else {
      CFAllocatorRef v3 = (char *)__p + v7;
    }
    if ((v8 & 0x80u) != 0) {
      p_p = (char *)__p;
    }
    if (p_p != v3)
    {
      do
      {
        char *p_p = __tolower(*p_p);
        ++p_p;
      }
      while (p_p != v3);
      unsigned __int8 v2 = v8;
    }
    if ((v2 & 0x80) != 0)
    {
      unint64_t v4 = __p;
      switch(v7)
      {
        case 1:
          if (*(unsigned char *)__p != 48) {
            break;
          }
          goto LABEL_31;
        case 2:
          if (*(_WORD *)__p == 28526) {
            goto LABEL_31;
          }
          break;
        case 5:
          goto LABEL_18;
      }
LABEL_33:
      operator delete(v4);
      return;
    }
    if (v2 != 1)
    {
      if (v2 == 2)
      {
        if ((unsigned __int16)__p != 28526) {
          return;
        }
        goto LABEL_31;
      }
      if (v2 != 5) {
        return;
      }
      unint64_t v4 = &__p;
LABEL_18:
      if (*(_DWORD *)v4 != 1936482662 || v4[4] != 101)
      {
        if ((v2 & 0x80) == 0) {
          return;
        }
LABEL_32:
        unint64_t v4 = __p;
        goto LABEL_33;
      }
LABEL_31:
      TubeManager::_onqueue_newTubeReady(Tube *,CFStreamError)::disableH2ConnectionCoalescing = 1;
      if ((v2 & 0x80) == 0) {
        return;
      }
      goto LABEL_32;
    }
    if (__p == 48) {
      goto LABEL_31;
    }
  }
}

void sub_184175074(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFTypeRef _CFURLStorageSessionCopyCache(uint64_t a1, os_unfair_lock_s *a2)
{
  if (StorageSession::Class(void)::sOnce_StorageSession != -1) {
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_19595);
  }
  if (a2) {
    CFAllocatorRef v3 = a2 + 4;
  }
  else {
    CFAllocatorRef v3 = 0;
  }

  return StorageSession::copyCacheStorage(v3);
}

uint64_t ___ZL16sessionCallbacksv_block_invoke()
{
  nghttp2_session_callbacks_new();
  nghttp2_session_callbacks_set_on_frame_recv_callback();
  nghttp2_session_callbacks_set_on_frame_recv_callback();
  nghttp2_session_callbacks_set_on_invalid_frame_recv_callback();
  nghttp2_session_callbacks_set_on_data_chunk_recv_callback();
  nghttp2_session_callbacks_set_before_frame_send_callback();
  nghttp2_session_callbacks_set_on_frame_send_callback();
  nghttp2_session_callbacks_set_on_frame_not_send_callback();
  nghttp2_session_callbacks_set_on_stream_close_callback();
  nghttp2_session_callbacks_set_on_begin_headers_callback();
  nghttp2_session_callbacks_set_on_header_callback();
  nghttp2_session_callbacks_set_on_invalid_header_callback();
  uint64_t v0 = sessionCallbacks(void)::sessionCallbacks;

  return MEMORY[0x1F417DE80](v0, cf_nghttp2_error_callback2);
}

void HTTPConnectionCacheEntryWrapper::~HTTPConnectionCacheEntryWrapper(HTTPConnectionCacheEntryWrapper *this)
{
  *(void *)this = &unk_1ECFA5038;
  unsigned __int8 v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);

  CFAllocatorDeallocate(v3, this);
}

{
  std::__shared_weak_count *v1;

  *(void *)this = &unk_1ECFA5038;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

CFTypeRef _CFURLStorageSessionCopyCookieStorage(uint64_t a1, os_unfair_lock_s *a2)
{
  if (StorageSession::Class(void)::sOnce_StorageSession != -1) {
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_19595);
  }
  if (a2) {
    CFAllocatorRef v3 = a2 + 4;
  }
  else {
    CFAllocatorRef v3 = 0;
  }

  return StorageSession::copyCookieStorage(v3);
}

dispatch_queue_t ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke()
{
  uint64_t v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t result = dispatch_queue_create("com.apple.CFNetwork.Async.SCNetworkReachability", v0);
  HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::q = (uint64_t)result;
  return result;
}

void ___ZN15GlueTubeManager22_getIOPathFromDefaultsEv_block_invoke()
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFStringRef v0 = (const __CFString *)CFPreferencesCopyValue(@"com.apple.CFNetwork.ForceIOPath", (CFStringRef)*MEMORY[0x1E4F1D3B8], (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  if (!v0)
  {
    GlueTubeManager::_getIOPathFromDefaults(void)::ioPath = 0;
    return;
  }
  CFStringRef v1 = v0;
  CFTypeID v2 = CFGetTypeID(v0);
  if (v2 != CFStringGetTypeID())
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    unint64_t v4 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    int v10 = 138543362;
    CFStringRef v11 = v1;
    char v6 = "CFNetwork I/O Path Preference(%{public}@) Invalid";
    goto LABEL_14;
  }
  if (CFStringCompare(v1, @"stream", 1uLL) == kCFCompareEqualTo)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      _os_log_impl(&dword_184085000, v7, OS_LOG_TYPE_DEFAULT, "CFNetwork I/O Path Preference Forcing Stream I/O", (uint8_t *)&v10, 2u);
    }
    p_vtable = (void **)(AVAssetDownloadURLSession + 24);
    int v9 = 1;
    goto LABEL_23;
  }
  CFComparisonResult v3 = CFStringCompare(v1, @"nw", 1uLL);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  unint64_t v4 = CFNLog::logger;
  BOOL v5 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
  if (v3 == kCFCompareEqualTo)
  {
    if (v5)
    {
      LOWORD(v10) = 0;
      _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "CFNetwork I/O Path Preference Forcing NW", (uint8_t *)&v10, 2u);
    }
    p_vtable = AVAssetDownloadURLSession.vtable;
    int v9 = 2;
LABEL_23:
    *((_DWORD *)p_vtable + 474) = v9;
    goto LABEL_24;
  }
  if (v5)
  {
    int v10 = 138543362;
    CFStringRef v11 = v1;
    char v6 = "CFNetwork I/O Path Preference Unrecognized(%{public}@)";
LABEL_14:
    _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v10, 0xCu);
  }
LABEL_24:
  CFRelease(v1);
}

void sub_184176034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *))
{
}

void ___Z24_CFURLCacheCreateWithURLPK13__CFAllocatorllPK7__CFURL_block_invoke(uint64_t a1)
{
  CFStringRef v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void RunLoopSchedulingSet::markAsUniquable(RunLoopSchedulingSet *this)
{
  if (!*((unsigned char *)this + 116))
  {
    *((unsigned char *)this + 116) = 1;
    CFTypeID v2 = (os_unfair_lock_s *)((char *)this + 112);
    os_unfair_lock_lock((os_unfair_lock_t)this + 28);
    uint64_t v3 = *((void *)this + 13);
    if (v3) {
      *(unsigned char *)(v3 + 64) = 1;
    }
    os_unfair_lock_unlock(v2);
    unint64_t v4 = (const void *)*((void *)this + 9);
    os_unfair_lock_lock((os_unfair_lock_t)&sLoaderSetLock);
    if (!sDict) {
      operator new();
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(sDict + 8), v4, this);
    os_unfair_lock_unlock((os_unfair_lock_t)&sLoaderSetLock);
  }
}

void sub_184176170(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14CFNetworkTrust19strictEvaluateAsyncEN14StrictSecurity21SessionStrengthPolicyENS_26SignatureAlgorithmStrengthEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFviE_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = CFNetworkTrust::processStrictEvaluateResult(*(void *)(a1 + 40), *(void *)(a1 + 48), *(unsigned int *)(a1 + 56), a3);
  BOOL v5 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 16);

  return v5(v3, v4);
}

uint64_t CFNetworkTrust::processStrictEvaluateResult(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 != 4 && a4 != 1) {
    return 4294957494;
  }
  if (a2 < 1) {
    return 0;
  }
  BOOL v5 = SecTrustCopyKey(*(SecTrustRef *)(a1 + 8));
  if (!v5) {
    return 4294957494;
  }
  char v6 = v5;
  size_t BlockSize = SecKeyGetBlockSize(v5);
  switch(SecKeyGetAlgorithmId())
  {
    case 0:
    case 2:
      goto LABEL_6;
    case 1:
      if (BlockSize >= 0x100) {
        goto LABEL_11;
      }
      goto LABEL_6;
    case 3:
      if (BlockSize > 0x1F) {
        goto LABEL_11;
      }
LABEL_6:
      CFRelease(v6);
      return 4294957494;
    default:
LABEL_11:
      CFRelease(v6);
      CFArrayRef v9 = SecTrustCopyCertificateChain(*(SecTrustRef *)(a1 + 8));
      if (!v9) {
        return 0;
      }
      CFArrayRef v10 = v9;
      if (CFArrayGetCount(v9) >= 1 && CFArrayGetValueAtIndex(v10, 0))
      {
        if (SecCertificateGetSignatureHashAlgorithm() >= 6) {
          uint64_t v8 = 0;
        }
        else {
          uint64_t v8 = 4294957494;
        }
      }
      else
      {
        uint64_t v8 = 0;
      }
      CFRelease(v10);
      break;
  }
  return v8;
}

void sub_1841762F8(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void ___ZN17DiagnosticLogging19userDiagnosticLevelEv_block_invoke()
{
  v42[19] = *MEMORY[0x1E4F143B8];
  p_p = (std::string *)getenv("CFNETWORK_DIAGNOSTICS");
  memset(&__p, 0, sizeof(__p));
  if (p_p)
  {
    int v1 = 0;
    goto LABEL_3;
  }
  memset(&__str, 0, sizeof(__str));
  uint64_t v4 = MEMORY[0x1E4FBA460] + 64;
  v42[0] = MEMORY[0x1E4FBA460] + 64;
  BOOL v5 = (void *)MEMORY[0x1E4FBA3F8];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA3F8] + 16);
  *(void *)Boolean keyExistsAndHasValidFormat = *(void *)(MEMORY[0x1E4FBA3F8] + 8);
  *(void *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)] = v6;
  uint64_t v40 = 0;
  uint64_t v7 = (std::ios_base *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)];
  std::ios_base::init(v7, v41);
  uint64_t v8 = MEMORY[0x1E4FBA460] + 24;
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  *(void *)Boolean keyExistsAndHasValidFormat = v8;
  v42[0] = v4;
  MEMORY[0x18531B510](v41);
  memset(&v37, 0, sizeof(v37));
  v35[0] = 0;
  v35[1] = 0;
  unint64_t v36 = 0;
  std::ifstream::open();
  CFArrayRef v9 = (const std::ios_base *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)];
  if (v9->__rdstate_)
  {
    LOBYTE(v10) = 0;
    goto LABEL_63;
  }
  locale = 0;
  CFArrayRef v10 = 0;
  uint64_t v12 = (std::locale::id *)MEMORY[0x1E4FBA258];
  do
  {
    std::ios_base::getloc(v9);
    uint64_t v13 = std::locale::use_facet(__dst, v12);
    unsigned __int8 v14 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
    std::locale::~locale(__dst);
    MEMORY[0x18531B530](__dst, keyExistsAndHasValidFormat, 1);
    if (!LOBYTE(__dst[0].__locale_)) {
      goto LABEL_30;
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      *__str.__r_.__value_.__l.__data_ = 0;
      __str.__r_.__value_.__l.__size_ = 0;
    }
    else
    {
      __str.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__str.__r_.__value_.__s + 23) = 0;
    }
    uint64_t v15 = 0;
    while (1)
    {
      CFTypeRef v16 = *(void **)&v41[*(void *)(*(void *)keyExistsAndHasValidFormat - 24) + 24];
      CFStringRef v17 = (unsigned char *)v16[3];
      if (v17 != (unsigned char *)v16[4])
      {
        v16[3] = v17 + 1;
        LOBYTE(v16) = *v17;
        goto LABEL_21;
      }
      LODWORD(v16) = (*(uint64_t (**)(void *))(*v16 + 80))(v16);
      if (v16 == -1) {
        break;
      }
LABEL_21:
      if (v14 == v16)
      {
        int v18 = 0;
        goto LABEL_29;
      }
      std::string::push_back(&__str, (std::string::value_type)v16);
      ++v15;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0 && __str.__r_.__value_.__l.__size_ == 0x7FFFFFFFFFFFFFF7)
      {
        int v18 = 4;
        goto LABEL_29;
      }
    }
    if (v15) {
      int v18 = 2;
    }
    else {
      int v18 = 6;
    }
LABEL_29:
    std::ios_base::clear((std::ios_base *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)], *(_DWORD *)&v41[*(void *)(*(void *)keyExistsAndHasValidFormat - 24) + 16] | v18);
LABEL_30:
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    if (!size) {
      goto LABEL_62;
    }
    std::string::size_type v20 = HIBYTE(v37.__r_.__value_.__r.__words[2]);
    if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v20 = v37.__r_.__value_.__l.__size_;
    }
    if (!v20)
    {
      double v25 = (const char **)_CFGetProgname();
      if (v25)
      {
        uint64_t v26 = (char *)*v25;
        if (*v25)
        {
          size_t v27 = strlen(*v25);
          std::string::basic_string[abi:nn180100](__dst, v26, v27);
          if ((v10 & 0x80) != 0) {
            operator delete(v35[0]);
          }
          *(_OWORD *)CFMutableDictionaryRef v35 = *(_OWORD *)&__dst[0].__locale_;
          unint64_t v36 = v34;
          CFArrayRef v10 = (std::locale::__imp *)HIBYTE(v34);
          locale = __dst[1].__locale_;
          if ((v34 & 0x8000000000000000) == 0 ? (std::locale::__imp *)HIBYTE(v34) : __dst[1].__locale_)
          {
            std::string::operator=(&v37, &__str);
            goto LABEL_61;
          }
        }
      }
      break;
    }
    if ((char)v10 >= 0) {
      CFStringRef v21 = v10;
    }
    else {
      CFStringRef v21 = locale;
    }
    if ((char)v10 >= 0) {
      CFErrorRef v22 = v35;
    }
    else {
      CFErrorRef v22 = (void **)v35[0];
    }
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_str = &__str;
    }
    else {
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if (size >= (unint64_t)v21) {
      size_t v24 = (size_t)v21;
    }
    else {
      size_t v24 = size;
    }
    if (!memcmp(v22, p_str, v24) && (std::locale::__imp *)size == v21)
    {
      int v30 = 1;
      goto LABEL_64;
    }
LABEL_61:
    std::string::erase(&__str, 0, 0xFFFFFFFFFFFFFFFFLL);
LABEL_62:
    CFArrayRef v9 = (const std::ios_base *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)];
  }
  while (!v9->__rdstate_);
LABEL_63:
  int v30 = 0;
LABEL_64:
  if (!std::filebuf::close()) {
    std::ios_base::clear((std::ios_base *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)], *(_DWORD *)&v41[*(void *)(*(void *)keyExistsAndHasValidFormat - 24) + 16] | 4);
  }
  if (v30)
  {
    std::string v31 = v37;
    uint64_t v29 = &v37;
  }
  else
  {
    uint64_t v29 = &v31;
  }
  v29->__r_.__value_.__r.__words[0] = 0;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  if ((v10 & 0x80) != 0) {
    operator delete(v35[0]);
  }
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v37.__r_.__value_.__l.__data_);
  }
  *(void *)Boolean keyExistsAndHasValidFormat = *v5;
  *(void *)&keyExistsAndHasValidFormat[*(void *)(*(void *)keyExistsAndHasValidFormat - 24)] = v5[3];
  MEMORY[0x18531B520](v41);
  std::istream::~istream();
  MEMORY[0x18531B660](v42);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  std::string __p = v31;
  int v1 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__p.__r_.__value_.__l.__size_) {
      goto LABEL_80;
    }
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!__p.__r_.__value_.__r.__words[0]) {
      goto LABEL_80;
    }
LABEL_3:
    AppIntegerCFStringRef Value = atoi((const char *)p_p);
  }
  else
  {
    if (*((unsigned char *)&v31.__r_.__value_.__s + 23))
    {
      p_p = &__p;
      goto LABEL_3;
    }
LABEL_80:
    keyExistsAndHasValidFormat[0] = 0;
    AppIntegerCFStringRef Value = CFPreferencesGetAppIntegerValue(@"AppleCFNetworkDiagnosticLogging", @"Apple Global Domain", keyExistsAndHasValidFormat);
  }
  if ((unint64_t)(AppIntegerValue - 1) >= 3) {
    int v3 = 0;
  }
  else {
    int v3 = AppIntegerValue;
  }
  DiagnosticLogging::userDiagnosticLevel(void)::sChecked = v3;
  if (v1 < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_18417694C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, std::locale a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  if (v37 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HTTPEngine::_writeBodyResume(HTTPEngine *this)
{
  if (*((void *)this + 32))
  {
    int v2 = *((_DWORD *)this + 8);
    if ((v2 & 0x10000000) == 0)
    {
      *((_DWORD *)this + 8) = v2 | 0x10000000;
      int v3 = (std::__shared_weak_count *)*((void *)this + 6);
      if (v3)
      {
        uint64_t v4 = std::__shared_weak_count::lock(v3);
        if (v4) {
          uint64_t v5 = *((void *)this + 5);
        }
        else {
          uint64_t v5 = 0;
        }
      }
      else
      {
        uint64_t v5 = 0;
        uint64_t v4 = 0;
      }
      uint64_t v6 = *((void *)this + 32);
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3321888768;
      int v7[2] = ___ZN10HTTPEngine16_writeBodyResumeEv_block_invoke;
      v7[3] = &__block_descriptor_56_e8_40c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
      v7[4] = this;
      void v7[5] = v5;
      uint64_t v8 = v4;
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      (*(void (**)(uint64_t, void *))(*(void *)v6 + 16))(v6, v7);
      if (v8) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v8);
      }
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v4);
      }
    }
  }
}

void sub_184176B30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  _Unwind_Resume(exception_object);
}

void HTTPTransaction::bodyStartProvidingData(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 192)) {
    return;
  }
  if (*(int *)(a1 + 80) <= 4) {
    *(_DWORD *)(a1 + 80) = 5;
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (!v4)
  {
    uint64_t v5 = 0;
    goto LABEL_8;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v4);
  if (!v5)
  {
LABEL_8:
    uint64_t v6 = 0;
    goto LABEL_9;
  }
  uint64_t v6 = *(void *)(a1 + 40);
LABEL_9:
  uint64_t v7 = *(void *)(a1 + 192);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 200);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3321888768;
  v9[2] = ___ZN15HTTPTransaction22bodyStartProvidingDataEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke;
  v9[3] = &unk_1ECFA9950;
  void v9[5] = a1;
  void v9[6] = v6;
  CFArrayRef v10 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v9[4] = a2;
  (*(void (**)(uint64_t, void *))(*(void *)v7 + 16))(v7, v9);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184176C88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
    if (!v17)
    {
LABEL_3:
      if (!v16) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if (!v17)
  {
    goto LABEL_3;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  if (!v16) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_4:
  std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  goto LABEL_5;
}

void RequestBodyStream::bodyStartProvidingData(uint64_t a1, void *aBlock)
{
  if (*(void *)(a1 + 80)) {
    __assert_rtn("bodyStartProvidingData", "HTTPRequestBody.cpp", 445, "!_cb");
  }
  *(void *)(a1 + 80) = _Block_copy(aBlock);
  if ((*(unsigned char *)(a1 + 192) & 1) == 0)
  {
    RequestBodyStream::_onqueue_setupStream((RequestBodyStream *)a1);
  }
  if ((*(unsigned char *)(a1 + 192) & 8) != 0)
  {
    RequestBodyStream::_onqueue_resume((RequestBodyStream *)a1);
  }
}

uint64_t __CFNIsMachServiceReachable(char *service_name)
{
  kern_return_t v1;
  uint64_t result;
  BOOL v3;
  mach_port_t sp;

  sp = 0;
  int v1 = bootstrap_look_up(*MEMORY[0x1E4F14638], service_name, &sp);
  dispatch_queue_t result = 0;
  if (v1) {
    int v3 = 1;
  }
  else {
    int v3 = sp == 0;
  }
  if (!v3)
  {
    mach_port_deallocate(*MEMORY[0x1E4F14960], sp);
    return 1;
  }
  return result;
}

void sub_18417735C(_Unwind_Exception *a1)
{
}

void sub_1841774A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

__n128 _CFURLConnectionSetFrameworkStubs(uint64_t a1)
{
  if (*(void *)a1) {
    __assert_rtn("_CFURLConnectionSetFrameworkStubs", "SecItem-shim.cpp", 13, "stubs->version == 0");
  }
  __n128 result = *(__n128 *)a1;
  long long v2 = *(_OWORD *)(a1 + 16);
  off_1EC09E210 = *(_UNKNOWN **)(a1 + 32);
  _gFwStubs = (__int128)result;
  *(_OWORD *)&off_1EC09E200 = v2;
  return result;
}

void ___ZL35__CFURLCacheCreateForStorageSessionPK13__CFAllocatorllPK10__CFStringhS4_hh_block_invoke()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t started = sysdir_start_search_path_enumeration_private();
  if (started)
  {
    uint64_t v1 = started;
    bzero(__s, 0x400uLL);
    MEMORY[0x18531E480](v1, __s);
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    size_t v3 = strlen(__s);
    CFURLRef v4 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)__s, v3, 1u);
    if (v4)
    {
      CFURLRef v5 = v4;
      CFURLRef v6 = CFURLCreateCopyAppendingPathComponent(v2, v4, @"Caches", 1u);
      CFRelease(v5);
      if (v6)
      {
        __CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::sharedCachesDirectory = (uint64_t)CFURLCreateCopyAppendingPathComponent(v2, v6, @"sharedCaches", 1u);
        CFRelease(v6);
      }
    }
  }
}

void HTTPConnectionCacheEntry::RequestQueue::~RequestQueue(HTTPConnectionCacheEntry::RequestQueue *this)
{
  *(void *)this = &unk_1ECFA5ED8;
  CFAllocatorRef v2 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<HTTPConnectionCacheEntry::EnqueuedRequest>>::__destroy_vector::operator()[abi:nn180100](&v2);
  *(void *)this = &unk_1ECF9B550;
}

{
  void **v2;
  uint64_t vars8;

  *(void *)this = &unk_1ECFA5ED8;
  CFAllocatorRef v2 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<HTTPConnectionCacheEntry::EnqueuedRequest>>::__destroy_vector::operator()[abi:nn180100](&v2);
  *(void *)this = &unk_1ECF9B550;

  JUMPOUT(0x18531B6D0);
}

void std::vector<std::shared_ptr<HTTPConnectionCacheEntry::EnqueuedRequest>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  CFAllocatorRef v2 = *a1;
  if (*v2)
  {
    std::vector<std::shared_ptr<HTTPConnectionCacheEntry::EnqueuedRequest>>::__clear[abi:nn180100]((uint64_t *)v2);
    size_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::shared_ptr<HTTPConnectionCacheEntry::EnqueuedRequest>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    CFURLRef v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
  a1[1] = v2;
}

char *___ZL17getBundleIdStringv_block_invoke()
{
  if (getBundleId(void)::onceToken != -1) {
    dispatch_once(&getBundleId(void)::onceToken, &__block_literal_global_110);
  }
  __n128 result = (char *)getBundleId(void)::bundleID;
  getBundleIdString(void)::bundleID = getBundleId(void)::bundleID;
  if (getBundleId(void)::bundleID)
  {
    CFIndex Length = CFStringGetLength((CFStringRef)getBundleId(void)::bundleID);
    CFIndex v2 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    __n128 result = (char *)malloc_type_malloc(v2, 0x1F19698EuLL);
    getBundleIdString(void)::bundleIdString = (uint64_t)result;
    if (result)
    {
      size_t v3 = result;
      CFStringRef v4 = (const __CFString *)getBundleIdString(void)::bundleID;
      return (char *)CFStringGetCString(v4, v3, v2, 0x8000100u);
    }
  }
  return result;
}

void ___ZN20StrictSecurityPolicy20isATSCompliantCipherEt_block_invoke()
{
}

void sub_184177C68(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t IOLogger::_initLogger(IOLogger *this)
{
  if (getenv("CFNETWORK_IO_LOG_FILE") && !issetugid()) {
    operator new();
  }
  if (getenv("CFNETWORK_IO_LOG_STDOUT")) {
    operator new();
  }
  if (getenv("CFNETWORK_IO_LOG_STDERR") || getenv("CFNETWORK_IO_LOG")) {
    operator new();
  }
  uint64_t result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_20781, 2);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void))(*(void *)result + 16))(result, "SocketStream IO Logging", 0);
    if (result) {
      operator new();
    }
  }
  return result;
}

void sub_184178128()
{
  *CFStringRef v0 = v1;
  abort();
}

uint64_t _CFURLStorageSessionCreate(uint64_t a1, const __CFString *a2, const __CFDictionary *a3)
{
  if (StorageSession::Class(void)::sOnce_StorageSession != -1) {
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_19595);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v6 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v6 = Instance + 16;
    *(void *)(Instance + 96) = 0;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  *(void *)uint64_t v6 = &unk_1ECF9CFC8;
  *(void *)(v6 + 8) = &unk_1ECF9D010;
  *(unsigned char *)(v6 + 56) = 0;
  uint64_t v7 = StorageSession::StorageSession(unsigned char)::gGenerations++;
  *(void *)(v6 + 64) = v7;
  *(_DWORD *)(v6 + 48) = 0;
  if (a2) {
    goto LABEL_6;
  }
  if (a3)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a3, @"kCFURLStorageSessionIdentifier");
    if (Value)
    {
      a2 = Value;
LABEL_6:
      CFStringRef v8 = 0;
LABEL_7:
      CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)(v6 - 16));
      CFArrayRef Copy = (const char **)CFStringCreateCopy(v9, a2);
      goto LABEL_8;
    }
  }
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    CFStringRef Identifier = CFBundleGetIdentifier(MainBundle);
    if (Identifier)
    {
      CFStringRef v17 = (const __CFString *)CFRetain(Identifier);
      goto LABEL_23;
    }
  }
  CFArrayRef Copy = (const char **)_CFGetProgname();
  if (!Copy)
  {
    CFStringRef v8 = 0;
    goto LABEL_8;
  }
  int v18 = *Copy;
  if (*Copy)
  {
    size_t v19 = strlen(*Copy);
    CFStringRef v17 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v18, v19, 0x201u, 0);
LABEL_23:
    CFStringRef v8 = v17;
    a2 = v17;
    if (v17) {
      goto LABEL_7;
    }
    goto LABEL_27;
  }
  CFStringRef v8 = 0;
LABEL_27:
  CFArrayRef Copy = 0;
LABEL_8:
  *(void *)(v6 + 72) = Copy;
  if (a3)
  {
    CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)(v6 - 16));
    CFDictionaryRef v12 = CFDictionaryCreateCopy(v11, a3);
  }
  else
  {
    CFDictionaryRef v12 = 0;
  }
  *(void *)(v6 + 80) = v12;
  if (v8) {
    CFRelease(v8);
  }
  return v6 - 16;
}

void sub_1841783D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void _CFURLStorageSessionDisableCache(uint64_t a1)
{
  if (StorageSession::Class(void)::sOnce_StorageSession != -1) {
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_19595);
  }
  if (a1) {
    uint64_t v2 = a1 + 16;
  }
  else {
    uint64_t v2 = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 48));
  if (!*(unsigned char *)(v2 + 52))
  {
    *(unsigned char *)(v2 + 52) = 1;
    size_t v3 = *(const void **)(v2 + 16);
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(v2 + 16) = 0;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 48));
}

uint64_t withHostsSPILocked(uint64_t a1)
{
  if (withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::sOnce != -1) {
    dispatch_once(&withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::sOnce, &__block_literal_global_533);
  }
  uint64_t v2 = (void *)withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::gSyncObject;
  objc_sync_enter((id)withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::gSyncObject);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::allowAnyHTTPCertificateHostSet, withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::allowSpecificHTTPCertificateHostDict);

  return objc_sync_exit(v2);
}

void sub_184178694(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP2Connection13sendRSTStreamENSt3__110shared_ptrI11HTTP2StreamEE18nghttp2_error_code_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(void *)(v1 + 160))
  {
    if ((nghttp2_submit_rst_stream() & 0x80000000) != 0) {
      HTTP2Connection::closeConnection((HTTP2Connection *)v1, 0);
    }
    size_t v3 = *(void **)(v1 + 128);
    if (v3) {
      dispatch_async(*(dispatch_queue_t *)(v1 + 168), v3);
    }
  }
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

void sub_1841787A4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_184178AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_184178C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_184178D0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL _CFNetworkSetATSContext(const void *a1)
{
  pthread_mutex_lock(&StrictSecurityPolicy::_Mutex);
  uint64_t v2 = StrictSecurityPolicy::_ATSData;
  if (!StrictSecurityPolicy::_ATSData) {
    StrictSecurityPolicy::_ATSCFDataRef Data = (uint64_t)CFRetain(a1);
  }
  pthread_mutex_unlock(&StrictSecurityPolicy::_Mutex);
  if (ATSLog(void)::onceToken != -1) {
    dispatch_once(&ATSLog(void)::onceToken, &__block_literal_global_115);
  }
  size_t v3 = ATSLog(void)::atsLog;
  if (os_log_type_enabled((os_log_t)ATSLog(void)::atsLog, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)CFURLRef v5 = 0;
    _os_log_debug_impl(&dword_184085000, v3, OS_LOG_TYPE_DEBUG, "Set custom context", v5, 2u);
  }
  return v2 == 0;
}

void HTTPCookieStorage::scheduleWithRunLoop(HTTPCookieStorage *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6 = *((void *)this + 5);
  *((void *)this + 5) = v6 + 1;
  if (v6)
  {
    uint64_t v7 = (__CFRunLoopTimer *)*((void *)this + 4);
    if (!v7) {
      return;
    }
    goto LABEL_10;
  }
  context.version = 0;
  context.info = (char *)this - 16;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
  context.copyDescription = (CFStringRef (__cdecl *)(const void *))MEMORY[0x1E4F1C220];
  CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
  double Current = CFAbsoluteTimeGetCurrent();
  double v10 = *((double *)this + 6);
  BOOL v11 = v10 + 10.0 < Current || v10 == 0.0;
  double v12 = 2.0;
  if (!v11) {
    double v12 = 10.0;
  }
  uint64_t v7 = CFRunLoopTimerCreate(v8, Current + v12, 1.0e30, 0, 0, (CFRunLoopTimerCallBack)HTTPCookieStorage::_syncTimerFired, &context);
  *((void *)this + 4) = v7;
  if (v7)
  {
LABEL_10:
    if (CFRunLoopTimerIsValid(v7)) {
      CFRunLoopAddTimer(a2, *((CFRunLoopTimerRef *)this + 4), a3);
    }
  }
}

void ___ZL27additionalPropertiesClassesv_block_invoke()
{
  CFStringRef v0 = (void *)MEMORY[0x1E4F1CAD0];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, v7, v8, v9, objc_opt_class(), 0);
  BOOL v11 = (void *)additionalPropertiesClasses(void)::additionalPropertiesClasses;
  additionalPropertiesClasses(void)::additionalPropertiesClasses = v10;
}

CFTypeRef StorageSession::copyCacheStorage(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 12;
  os_unfair_lock_lock(this + 12);
  if (!LOBYTE(this[13]._os_unfair_lock_opaque))
  {
    LOBYTE(this[13]._os_unfair_lock_opaque) = 1;
    if (!*(void *)&this[4]._os_unfair_lock_opaque && !LOBYTE(this[14]._os_unfair_lock_opaque))
    {
      CFGetAllocator(&this[-4]);
      CFStringRef v4 = *(const __CFString **)&this[18]._os_unfair_lock_opaque;
      CFDictionaryRef v3 = *(const __CFDictionary **)&this[20]._os_unfair_lock_opaque;
      CFBooleanRef v18 = 0;
      value = 0;
      CFTypeRef v16 = 0;
      CFBooleanRef BOOLean = 0;
      BOOL v5 = v3
        && ((CFDictionaryGetValueIfPresent(v3, @"kCFURLStorageSessionIsPrivate", (const void **)&value),
             CFDictionaryGetValueIfPresent(v3, @"kCFURLStorageSessionIsDefault", (const void **)&v18),
             CFDictionaryGetValueIfPresent(v3, @"kCFURLStorageSessionProcessSharing", (const void **)&BOOLean),
             CFDictionaryGetValueIfPresent(v3, @"kCFURLStorageSessionAppIdentifier", (const void **)&v16),
             !value)
          ? (LODWORD(v3) = 0)
          : (LODWORD(v3) = CFBooleanGetValue((CFBooleanRef)value)),
            BOOLean)
        && CFBooleanGetValue(BOOLean) == 1;
      CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef v7 = (const __CFString *)v16;
      if (v18) {
        CFBooleanGetValue(v18);
      }
      if (v7) {
        CFStringRef v4 = v7;
      }
      if (v3) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = 20971520;
      }
      if (v5)
      {
        if (__CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::onceToken != -1) {
          dispatch_once(&__CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::onceToken, &__block_literal_global_2723);
        }
        if (__CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::sharedCachesDirectory
          && (CFURLRef v9 = CFURLCreateCopyAppendingPathComponent(v6, (CFURLRef)__CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::sharedCachesDirectory, v4, 1u)) != 0&& (v10 = v9, v11 = CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle), CFRelease(v10), v11))
        {
          uint64_t block = (std::__shared_weak_count *)MEMORY[0x1E4F143A8];
          uint64_t v21 = 3221225472;
          CFErrorRef v22 = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2699;
          double v23 = &__block_descriptor_40_e5_v8__0l;
          size_t v24 = _URLCacheRegisterClass;
          if (_CFURLCacheClassRegistration != -1) {
            dispatch_once(&_CFURLCacheClassRegistration, &block);
          }
          uint64_t Instance = _CFRuntimeCreateInstance();
          *(void *)(Instance + 16) = 0;
          *(void *)(Instance + 24) = 0;
          uint64_t v13 = (std::__shared_weak_count *)operator new(0x298uLL);
          v13->__shared_owners_ = 0;
          v13->__shared_weak_owners_ = 0;
          v13->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6678;
          __CFURLCache::__CFURLCache((__CFURLCache *)&v13[1], (const _CFURLCache *)Instance, 0x400000, v8, v11, 0);
          uint64_t block = v13 + 1;
          uint64_t v21 = (uint64_t)v13;
          std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)&block, &v13[1].__shared_owners_, (uint64_t)&v13[1]);
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          unsigned __int8 v14 = *(std::__shared_weak_count **)(Instance + 24);
          *(void *)(Instance + 16) = v13 + 1;
          *(void *)(Instance + 24) = v13;
          if (v14) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v14);
          }
          std::__shared_weak_count::__release_shared[abi:nn180100](v13);
          *(unsigned char *)(*(void *)(Instance + 16) + 528) = 1;
          CFRelease(v11);
        }
        else
        {
          uint64_t Instance = 0;
        }
      }
      else
      {
        uint64_t Instance = __CFURLCacheCreateInternal(v6, 0x400000, v8, v4, 0, 0, 0);
      }
      *(void *)&this[4]._os_unfair_lock_opaque = Instance;
    }
  }
  os_unfair_lock_unlock(v2);
  if (LOBYTE(this[14]._os_unfair_lock_opaque))
  {
    return (CFTypeRef)CFURLCacheCopySharedURLCache();
  }
  else
  {
    CFTypeRef result = *(CFTypeRef *)&this[4]._os_unfair_lock_opaque;
    if (result)
    {
      return CFRetain(result);
    }
  }
  return result;
}

void sub_18417955C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void CFHTTPCookieStorageScheduleWithRunLoop(uint64_t a1, __CFRunLoop *a2, __CFString *a3)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFAllocatorRef v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_error_impl(&dword_184085000, v6, OS_LOG_TYPE_ERROR, "CFHTTPCookieStorageScheduleWithRunLoop should no longer be called", v8, 2u);
    }
  }
  else
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    if (a1) {
      CFStringRef v7 = (HTTPCookieStorage *)(a1 + 16);
    }
    else {
      CFStringRef v7 = 0;
    }
    HTTPCookieStorage::scheduleWithRunLoop(v7, a2, a3);
  }
}

void ___ZN12__CFURLCache13AddCacheTask0ERNSt3__110unique_ptrI16__CFURLCacheNodeNS0_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  __retainStorageAssertion(*(void **)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = *(id *)(a1 + 48);
  if (!v2) {
    goto LABEL_46;
  }
  BOOL v32 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 28));
  if (([(NSURLStorageURLCacheDB *)(id)v2 openAndPrepareWriteCacheDB_NoLock] & 1) == 0)
  {
LABEL_45:
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 28));
    goto LABEL_46;
  }
  if (!v3)
  {
    -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
    goto LABEL_45;
  }
  BOOL v5 = (__CFString *)v3;
  CFAllocatorRef v6 = _ExtractCStringfromCFStringRef(v5, &v32);
  if (!v6)
  {

LABEL_22:
    -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
    goto LABEL_45;
  }
  CFStringRef v7 = -[NSURLStorageURLCacheDB getEntryIDandReceiverDataForRequestKey:]((sqlite3_stmt **)v2, v6);
  uint64_t v8 = v7;
  if (v7)
  {
    sqlite3_int64 v9 = *(void *)v7;
    if (*(void *)v7)
    {
      if (v7[20])
      {
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFStringRef v12 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *((const UInt8 **)v7 + 1), *((int *)v7 + 4), 0x8000100u, 0);
        if (v12)
        {
          id Property = objc_getProperty((id)v2, v11, 160, 1);
          uint64_t FS2 = _CFURLCacheCreateFS2((uint64_t)Property);
          uint64_t v15 = FS2;
          if (FS2)
          {
            CFStringRef v16 = CFStringCreateWithFormat(v10, 0, @"%@/%@", *(void *)(FS2 + 80), v12);
            CFStringRef v17 = v16;
            if (v16)
            {
              BOOL v33 = 0;
              CFBooleanRef v18 = _ExtractCStringfromCFStringRef(v16, &v33);
              CFStringRef cf = v17;
              if (v18)
              {
                int v30 = v18;
                if (unlink(v18) == -1)
                {
                  if (CFNLog::onceToken != -1) {
                    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
                  }
                  log = CFNLog::logger;
                  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                  {
                    int v28 = *__error();
                    *(_DWORD *)buf = 136315394;
                    CFMutableDictionaryRef v35 = v30;
                    __int16 v36 = 1024;
                    int v37 = v28;
                    _os_log_error_impl(&dword_184085000, log, OS_LOG_TYPE_ERROR, "unlink of file %s failed.  Errno=%{errno}d", buf, 0x12u);
                  }
                  int v19 = 0;
                }
                else
                {
                  int v19 = 1;
                }
                if (v33) {
                  MEMORY[0x18531B6B0](v30, 0x1000C8077774924);
                }
              }
              else
              {
                if (CFNLog::onceToken != -1) {
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
                }
                uint64_t v21 = CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl(&dword_184085000, v21, OS_LOG_TYPE_ERROR, "purgeItemFromFileSystemStoreForKey - unable to determine path to file for unlink.", buf, 2u);
                }
                int v19 = 0;
              }
              CFRelease(cf);
              if (v19) {
                [(NSURLStorageURLCacheDB *)(void *)v2 updateFSBackedCacheUsageOnDisk];
              }
            }
            (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
          }
          CFRelease(v12);
        }
      }
      double v23 = (void *)v8[1];
      if (v23) {
        free(v23);
      }
      free(v8);
      sqlite3_reset(*(sqlite3_stmt **)(v2 + 96));
      if (sqlite3_bind_int64(*(sqlite3_stmt **)(v2 + 112), 1, v9))
      {
        if (v32) {
          MEMORY[0x18531B6B0](v6, 0x1000C8077774924);
        }
LABEL_44:
        sqlite3_reset(*(sqlite3_stmt **)(v2 + 112));

        -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
        goto LABEL_45;
      }
      int v25 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v2, *(sqlite3_stmt **)(v2 + 112));
      if (v25 && v25 != 101)
      {
        if (v32) {
          MEMORY[0x18531B6B0](v6, 0x1000C8077774924);
        }
        goto LABEL_44;
      }
      sqlite3_reset(*(sqlite3_stmt **)(v2 + 112));
      if (sqlite3_bind_int64(*(sqlite3_stmt **)(v2 + 120), 1, v9))
      {
        if (v32) {
          MEMORY[0x18531B6B0](v6, 0x1000C8077774924);
        }
LABEL_54:
        sqlite3_reset(*(sqlite3_stmt **)(v2 + 120));

        -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
        goto LABEL_45;
      }
      int v26 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v2, *(sqlite3_stmt **)(v2 + 120));
      if (v26 && v26 != 101)
      {
        if (v32) {
          MEMORY[0x18531B6B0](v6, 0x1000C8077774924);
        }
        goto LABEL_54;
      }
      sqlite3_reset(*(sqlite3_stmt **)(v2 + 120));
      if (sqlite3_bind_int64(*(sqlite3_stmt **)(v2 + 128), 1, v9))
      {
        if (v32) {
          MEMORY[0x18531B6B0](v6, 0x1000C8077774924);
        }
LABEL_63:
        sqlite3_reset(*(sqlite3_stmt **)(v2 + 128));

        -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
        goto LABEL_45;
      }
      int v27 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v2, *(sqlite3_stmt **)(v2 + 128));
      if (v27 && v27 != 101)
      {
        if (v32) {
          MEMORY[0x18531B6B0](v6, 0x1000C8077774924);
        }
        goto LABEL_63;
      }
      sqlite3_reset(*(sqlite3_stmt **)(v2 + 128));

      if (v32) {
        MEMORY[0x18531B6B0](v6, 0x1000C8077774924);
      }
      goto LABEL_22;
    }
  }
  if (v32) {
    MEMORY[0x18531B6B0](v6, 0x1000C8077774924);
  }

  -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
  -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
  -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 28));
  if (v8)
  {
    std::string::size_type v20 = (void *)v8[1];
    if (v20) {
      free(v20);
    }
    free(v8);
  }
LABEL_46:

  __releaseStorageAssertion(v24);
}

void sub_18417A218(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __CFURLCache::PurgePersistentCache(__CFURLCache *this)
{
  void v17[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 552);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 552));
  CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 67));
  pthread_mutex_unlock(v2);
  id v3 = __CFURLCache::createAndOpenCacheDB(this);
  if (v3)
  {
    CFStringRef v4 = v3;
    uint64_t v5 = *((void *)this + 17);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZN12__CFURLCache20PurgePersistentCacheEv_block_invoke;
    block[3] = &unk_1E5257FB0;
    block[4] = v5;
    void block[5] = v3;
    dispatch_block_t v6 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, QOS_CLASS_UTILITY, 0, block);
    dispatch_async(*((dispatch_queue_t *)this + 17), v6);
    _Block_release(v6);
  }
  if (*((unsigned char *)this + 632) && *((void *)this + 78))
  {
    __retainStorageAssertion(*((void **)this + 17));
    char v7 = 0;
    uint64_t v8 = 0;
    v17[0] = "DROP table IF EXISTS cfurl_vary_state;";
    v17[1] = "DROP TRIGGER IF EXISTS cfurl_vary_state_delete;";
    do
    {
      char v9 = v7;
      CFAllocatorRef v10 = (const char *)v17[v8];
      errmsg = 0;
      if (sqlite3_exec(*((sqlite3 **)this + 78), v10, 0, 0, &errmsg))
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        CFStringRef v11 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          CFStringRef v16 = errmsg;
          _os_log_impl(&dword_184085000, v11, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
        }
        sqlite3_free(errmsg);
      }
      char v7 = 1;
      uint64_t v8 = 1;
    }
    while ((v9 & 1) == 0);
    __CFURLCache::_createVaryStateTable((sqlite3 **)this);
    __releaseStorageAssertion(v12);
  }
}

void ___ZN19URLConnectionLoader29ensureLoaderHasProtocolNoLockEP12NSURLRequest_block_invoke(uint64_t a1)
{
  v8[19] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 40);
  if (*(unsigned char *)(v1 + 136) && *(double *)(v1 + 128) <= CFAbsoluteTimeGetCurrent())
  {
    if (!*(unsigned char *)(v1 + 160))
    {
      uint64_t v3 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_156, 1);
      if (v3)
      {
        CFStringRef v4 = (DiagnosticLogging *)v3;
        if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v3 + 16))(v3, "Did Timeout", 0))
        {
          uint64_t v5 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 24))(v1);
          CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          v8[0] = off_1ECF9A530;
          v8[2] = 0;
          v8[3] = 0;
          v8[1] = CFStringCreateWithCString(v6, "Loader", 0x8000100u);
          (*(void (**)(DiagnosticLogging *))(*(void *)v4 + 64))(v4);
          AutoString::~AutoString((AutoString *)v8);
          if (v5) {
            CFRelease(v5);
          }
          (*(void (**)(DiagnosticLogging *, const char *, __CFString *))(*(void *)v4 + 72))(v4, "Timeout Interval", @"%.3f seconds");
          URLConnectionLoader::logTimings((URLConnectionLoader *)v1, v4);
          (*(void (**)(DiagnosticLogging *))(*(void *)v4 + 8))(v4);
        }
      }
      (*(void (**)(void, void *))(**(void **)(v1 + 32) + 40))(*(void *)(v1 + 32), &__block_literal_global_163);
    }
    char v7 = *(NSObject **)(a1 + 32);
    dispatch_source_cancel(v7);
  }
  else
  {
    URLConnectionLoader::scheduleTimeoutTimer((URLConnectionLoader *)v1);
  }
}

void sub_18417A894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_72c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 80);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__110shared_ptrI11RequestBodyEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_72c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 80);
  *(void *)(result + 72) = *(void *)(a2 + 72);
  *(void *)(result + 80) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t __copy_helper_block_e8_32c39_ZTSNSt3__110shared_ptrI11RequestBodyEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN25HTTP2ConnectionCacheEntry15shouldIdleCloseEdd_block_invoke(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)(a1 + 40);
  double v5 = *(double *)(a1 + 48);
  uint64_t v8 = 0;
  char v9 = &v8;
  uint64_t v10 = 0x2020000000;
  CFIndex v11 = 0;
  uint64_t v6 = *(int *)(a2 + 304);
  CFIndex v11 = CFArrayGetCount(*(CFArrayRef *)(a2 + 232)) + v6;
  uint64_t v7 = v9[3];
  _Block_object_dispose(&v8, 8);
  if (v7 > 0) {
    goto LABEL_2;
  }
  if (v4 != v5 && *(unsigned char *)(a2 + 597))
  {
    if (*(double *)(a2 + 248) <= v5) {
      goto LABEL_8;
    }
LABEL_2:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    return;
  }
  if (*(double *)(a2 + 248) > v4) {
    goto LABEL_2;
  }
LABEL_8:

  HTTP2Connection::stop((HTTP2Connection *)a2, 0);
}

void sub_18417AA48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN24HTTPConnectionCacheEntry28_findOrCreateEmptyConnectionENSt3__110shared_ptrINS_15EnqueuedRequestEEEPNS_22ConnectionSearchStatusE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    double v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      CFErrorRef v22 = v5;
      uint64_t v6 = *(void *)(a1 + 40);
      if (v6)
      {
        int v7 = *(_DWORD *)(v6 + 120);
        uint64_t v8 = (v7 - 1);
        if (v7 >= 1)
        {
          do
          {
            if ((v8 & 0x80000000) == 0)
            {
              uint64_t v9 = *(void *)(*(void *)(v6 + 104) + 8);
              if (v8 <= (unint64_t)((*(void *)(*(void *)(v6 + 104) + 16) - v9) >> 4))
              {
                uint64_t v10 = (uint64_t *)(v9 + 16 * v8);
                uint64_t v12 = *v10;
                CFIndex v11 = (std::__shared_weak_count *)v10[1];
                if (v11) {
                  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                if (v12)
                {
                  uint64_t v13 = *(void *)(v12 + 16);
                  if (*(void *)(v12 + 24) - v13 >= 1)
                  {
                    uint64_t v14 = 0;
                    uint64_t v15 = 0;
                    do
                    {
                      CFStringRef v16 = (uint64_t *)(v13 + v14);
                      uint64_t v17 = *v16;
                      CFBooleanRef v18 = (std::__shared_weak_count *)v16[1];
                      if (v18) {
                        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 80))(v17);
                      uint64_t v20 = v19;
                      if (v19
                        && !(*(unsigned int (**)(uint64_t))(*(void *)v19 + 176))(v19)
                        && (*(unsigned int (**)(uint64_t))(*(void *)v20 + 232))(v20))
                      {
                        (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 240))(v20, a2);
                      }
                      if (v18) {
                        std::__shared_weak_count::__release_shared[abi:nn180100](v18);
                      }
                      ++v15;
                      uint64_t v13 = *(void *)(v12 + 16);
                      v14 += 16;
                    }
                    while (v15 < (*(void *)(v12 + 24) - v13) >> 4);
                  }
                }
                if (v11) {
                  std::__shared_weak_count::__release_shared[abi:nn180100](v11);
                }
              }
            }
          }
          while (v8-- > 0);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v22);
    }
  }
}

void sub_18417AC5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  _Unwind_Resume(a1);
}

void ___ZN20HTTP3ConnectionCache21_connectionsRemoveAllEb_block_invoke(uint64_t a1, const HTTPConnectionCacheKey *a2, uint64_t a3)
{
  double v4 = *(HTTP3ConnectionCache **)(a1 + 32);
  uint64_t v5 = *(void *)(a3 + 24);
  uint64_t v6 = *(std::__shared_weak_count **)(a3 + 32);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HTTP3ConnectionCacheEntry::stopConnections(*(HTTP3ConnectionCacheEntry **)(v5 + 104), *(HTTP3ConnectionCacheEntry **)(v5 + 112), *(unsigned char *)(a1 + 40));
  HTTP3ConnectionCache::_entryRemove(v4, a2);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_18417AD08(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN20HTTP3ConnectionCache17_timersInitializeEv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

uint64_t ___ZN20HTTP3ConnectionCache15enableCellTimerEv_block_invoke_8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

uint64_t ___ZN20HTTP3ConnectionCache12_entryRemoveEPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))();
}

void ___ZN20HTTP2ConnectionCache32_onqueue_base_remove_connectionsEbb_block_invoke_2(uint64_t a1, void *a2, HTTP2ConnectionCacheEntry *a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000;
  char v14 = 1;
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = ___ZN25HTTP2ConnectionCacheEntry15shouldIdleCloseEdd_block_invoke;
  context[3] = &unk_1E5254D08;
  long long v10 = *(_OWORD *)(a1 + 40);
  void context[4] = &v11;
  CFArrayRef v7 = (const __CFArray *)*((void *)a3 + 11);
  v16.CFIndex length = CFArrayGetCount(v7);
  v16.location = 0;
  CFArrayApplyFunction(v7, v16, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, context);
  LODWORD(v7) = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  if (v7)
  {
    HTTP2ConnectionCacheEntry::stopConnections(a3, 0);
    TubeManager::invalidateKey(*(void *)(v6 + 104), a2, 1, 1u);
    uint64_t v8 = *(__CFArray **)(a1 + 56);
    CFArrayAppendValue(v8, a2);
  }
}

void sub_18417AEE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP3Connection4stopEb_block_invoke(uint64_t a1)
{
}

uint64_t ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_37(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_36(void *a1, dispatch_data_t data, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = a1[8];
  if (a5)
  {
    if (!data || !dispatch_data_get_size(data))
    {
      uint64_t v11 = *(void *)(a1[5] + 8);
      *(void *)(v11 + 48) = a4;
      *(void *)(v11 + 56) = a5;
      goto LABEL_9;
    }
    goto LABEL_6;
  }
  if (data)
  {
LABEL_6:
    *(void *)(v9 + 168) += dispatch_data_get_size(data);
    goto LABEL_7;
  }
  if ((*(unsigned char *)(v9 + 32) & 8) == 0)
  {
LABEL_7:
    if (a3) {
      *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
    }
LABEL_9:
    if (*(void *)(a1[9] + 192))
    {
      if (data)
      {
        dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(v9 + 192), data);
        dispatch_release(*(dispatch_object_t *)(v9 + 192));
        *(void *)(v9 + 192) = 0;
        *(void *)(*(void *)(a1[7] + 8) + 40) = concat;
        goto LABEL_17;
      }
      goto LABEL_14;
    }
    goto LABEL_15;
  }
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
  if (*(void *)(a1[9] + 192))
  {
LABEL_14:
    *(void *)(*(void *)(a1[7] + 8) + 40) = *(void *)(v9 + 192);
    *(void *)(v9 + 192) = 0;
    goto LABEL_17;
  }
LABEL_15:
  *(void *)(*(void *)(a1[7] + 8) + 40) = data;
  uint64_t v13 = *(NSObject **)(*(void *)(a1[7] + 8) + 40);
  if (v13) {
    dispatch_retain(v13);
  }
LABEL_17:
  char v14 = *(uint64_t (**)(void))(a1[4] + 16);

  return v14();
}

void *std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 60) {
      abort();
    }
    uint64_t v6 = result;
    CFTypeRef result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>(a4);
    *uint64_t v6 = result;
    v6[1] = result;
    for (void v6[2] = &result[2 * v7]; a2 != a3; a2 += 2)
    {
      uint64_t v8 = a2[1];
      *CFTypeRef result = *a2;
      result[1] = v8;
      if (v8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
      }
      result += 2;
    }
    v6[1] = result;
  }
  return result;
}

uint64_t std::deque<void({block_pointer} {__strong})(std::shared_ptr<HTTP3Framer>,unsigned long long,BOOL),std::allocator<void({block_pointer} {__strong})(std::shared_ptr<HTTP3Framer>,unsigned long long,BOOL)>>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    double v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    double v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 >> 9];
    uint64_t v7 = (void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v5) >> 6) & 0x3FFFFFFFFFFFFF8))
       + 8 * ((*(void *)(a1 + 40) + v5) & 0x1FF);
    if (v7 != (void **)v8)
    {
      do
      {
        uint64_t v9 = *v7++;

        if ((char *)v7 - (unsigned char *)*v6 == 4096)
        {
          long long v10 = (void **)v6[1];
          ++v6;
          uint64_t v7 = v10;
        }
      }
      while (v7 != (void **)v8);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }
  void *v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 256;
    goto LABEL_14;
  }
  if (v12 == 2)
  {
    uint64_t v13 = 512;
LABEL_14:
    *(void *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      char v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<HTTP3ConnectionCacheEntry>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::__shared_ptr_emplace<HTTP3ConnectionCache>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t std::__shared_ptr_emplace<HTTP3Connection>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void HTTP3ConnectionCacheEntryWrapper::~HTTP3ConnectionCacheEntryWrapper(HTTP3ConnectionCacheEntryWrapper *this)
{
  *(void *)this = &unk_1ECFA52E8;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    *((void *)this + 5) = 0;
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  HTTP3ConnectionCacheEntryWrapper::~HTTP3ConnectionCacheEntryWrapper(this);
  uint64_t v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_18417C140(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 32);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  _Unwind_Resume(exception_object);
}

void HTTP3ConnectionCacheWrapper::~HTTP3ConnectionCacheWrapper(HTTP3ConnectionCacheWrapper *this)
{
  *(void *)this = &unk_1ECFA3A98;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  *(void *)this = &unk_1ECF9FF58;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  HTTP3ConnectionCacheWrapper::~HTTP3ConnectionCacheWrapper(this);
  uint64_t v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void HTTP3ConnectionCacheWrapper::invalidateAllConnections(HTTP3ConnectionCacheWrapper *this, char a2)
{
  uint64_t v3 = (CFTypeRef *)*((void *)this + 4);
  HTTP3ConnectionCache::_timersStop((HTTP3ConnectionCache *)v3);
  uint64_t v7 = &unk_1ECFA03B0;
  CFAllocatorRef v4 = CFGetAllocator(v3[11]);
  CFTypeRef cf = CFDictionaryCreateMutableCopy(v4, 0, (CFDictionaryRef)v3[11]);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  uint64_t v5[2] = ___ZN20HTTP3ConnectionCache21_connectionsRemoveAllEb_block_invoke;
  v5[3] = &__block_descriptor_41_e14_v24__0r_v8_v16l;
  v5[4] = v3;
  char v6 = a2;
  CFDictionaryApplyFunction((CFDictionaryRef)cf, (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit, v5);
  uint64_t v7 = &unk_1ECFA03B0;
  CFRelease(cf);
}

void sub_18417C328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf)
{
}

void HTTP3ConnectionCacheEntry::~HTTP3ConnectionCacheEntry(HTTP3ConnectionCacheEntry *this)
{
  *(void *)this = &unk_1ECFA3220;
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    *((void *)this + 10) = 0;
  }
  uint64_t v3 = *((void *)this + 11);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
    *((void *)this + 11) = 0;
  }
  if (*((void *)this + 12)) {
    *((void *)this + 12) = 0;
  }
  uint64_t v4 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v7 = (void **)((char *)this + 104);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&v7);
  unint64_t v5 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  *(void *)this = &unk_1ECF9B550;
  char v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
}

{
  uint64_t vars8;

  HTTP3ConnectionCacheEntry::~HTTP3ConnectionCacheEntry(this);

  JUMPOUT(0x18531B6D0);
}

void sub_18417C468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v12 = *(void *)(v10 + 128);
  *(void *)(v10 + 128) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  a10 = (void **)(v10 + 104);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a10);
  uint64_t v13 = *(std::__shared_weak_count **)(v10 + 32);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  *(void *)uint64_t v10 = &unk_1ECF9B550;
  char v14 = *(std::__shared_weak_count **)(v10 + 16);
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(a1);
}

void HTTP3ConnectionCacheEntry::stopConnections(HTTP3ConnectionCacheEntry *this, HTTP3ConnectionCacheEntry *a2, char a3)
{
  if (this != a2)
  {
    unint64_t v5 = this;
    do
    {
      char v6 = *(HTTP3Connection **)v5;
      uint64_t v7 = (std::__shared_weak_count *)*((void *)v5 + 1);
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      HTTP3Connection::stop(v6, a3);
      if (v7) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v7);
      }
      unint64_t v5 = (HTTP3ConnectionCacheEntry *)((char *)v5 + 16);
    }
    while (v5 != a2);
  }
}

void sub_18417C560(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void HTTP3ConnectionCache::~HTTP3ConnectionCache(HTTP3ConnectionCache *this)
{
  *(void *)this = &unk_1ECFA1340;
  uint64_t v2 = *((void *)this + 8);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    *((void *)this + 8) = 0;
  }
  *((void *)this + 9) = 0;
  if (*((unsigned char *)this + 96)) {
    HTTP3ConnectionCache::_timersStop(this);
  }
  uint64_t v3 = *((void *)this + 13);
  if (v3) {
    dispatch_source_cancel(v3);
  }
  uint64_t v4 = *((void *)this + 14);
  if (v4)
  {
    dispatch_source_cancel(v4);
    unint64_t v5 = (void *)*((void *)this + 14);
  }
  else
  {
    unint64_t v5 = 0;
  }

  *((void *)this + 10) = &unk_1ECFA03B0;
  CFRelease(*((CFTypeRef *)this + 11));
  *(void *)this = &unk_1ECF9B550;
  char v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
}

{
  uint64_t vars8;

  HTTP3ConnectionCache::~HTTP3ConnectionCache(this);

  JUMPOUT(0x18531B6D0);
}

void sub_18417C67C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 80) = &unk_1ECFA03B0;
  CFRelease(*(CFTypeRef *)(v1 + 88));
  *(void *)uint64_t v1 = &unk_1ECF9B550;
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(a1);
}

uint64_t HTTP3ConnectionCache::_entryRemove(HTTP3ConnectionCache *this, const HTTPConnectionCacheKey *a2)
{
  (*(void (**)(const HTTPConnectionCacheKey *))(*(void *)a2 + 40))(a2);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  char v6 = ___ZN20HTTP3ConnectionCache12_entryRemoveEPK22HTTPConnectionCacheKey_block_invoke;
  uint64_t v7 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v8 = a2;
  if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 11), a2))
  {
    TubeManager::invalidateKey(*((void *)this + 9), a2, 1, 2u);
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 11), a2);
    if (!CFDictionaryGetCount(*((CFDictionaryRef *)this + 11))) {
      HTTP3ConnectionCache::_timersStop(this);
    }
  }
  return v6((uint64_t)v5);
}

void sub_18417C7E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

void HTTP3ConnectionCache::_timersStop(HTTP3ConnectionCache *this)
{
  if (*((unsigned char *)this + 96))
  {
    *((unsigned char *)this + 96) = 0;
    dispatch_source_set_timer(*((dispatch_source_t *)this + 13), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    uint64_t v2 = *((void *)this + 14);
    dispatch_source_set_timer(v2, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit(uint64_t a1, uint64_t a2, void *aBlock)
{
  unint64_t v5 = (void (**)(id, uint64_t, uint64_t))_Block_copy(aBlock);
  v5[2](v5, a1, a2);
}

void sub_18417C8C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HTTP3Connection::~HTTP3Connection(HTTP3Connection *this)
{
  *(void *)this = &unk_1ECF9D5F0;
  *((void *)this + 3) = &unk_1ECF9D640;
  uint64_t v2 = (HTTPStallTimer *)*((void *)this + 122);
  if (v2)
  {
    HTTPStallTimer::invalidate(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 123);
    *((_OWORD *)this + 61) = 0u;
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
  }
  uint64_t v4 = (void *)*((void *)this + 11);
  if (v4)
  {
    do
    {
      unint64_t v5 = (void *)v4[2];
      free(v4);
      uint64_t v4 = v5;
    }
    while (v5);
  }
  char v6 = (void *)*((void *)this + 14);
  if (v6)
  {
    do
    {
      uint64_t v7 = (void *)*v6;
      free(v6);
      char v6 = v7;
    }
    while (v7);
  }
  free(*((void **)this + 13));
  free(*((void **)this + 31));
  uint64_t v8 = (FILE *)*((void *)this + 29);
  if (v8)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
    fwrite("cleaned up", 0xAuLL, 1uLL, *((FILE **)this + 29));
    fputc(10, *((FILE **)this + 29));
  }
  uint64_t v9 = (void *)*((void *)this + 44);
  if (v9)
  {
    do
    {
      uint64_t v10 = (void *)*v9;
      free(v9);
      uint64_t v9 = v10;
    }
    while (v10);
  }
  int v11 = *((_DWORD *)this + 126);
  if ((v11 - 1) > 4)
  {
    if ((v11 - 8) > 6) {
      goto LABEL_18;
    }
    uint64_t v12 = (_DWORD *)*((void *)this + 69);
    if (!v12) {
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v12 = (_DWORD *)*((void *)this + 70);
    if (!v12) {
      goto LABEL_18;
    }
  }
LABEL_17:
  free(v12);
LABEL_18:
  int v13 = *((_DWORD *)this + 83);
  unsigned int v14 = *((_DWORD *)this + 84);
  while (v13 != v14)
  {
    uint64_t v12 = *(_DWORD **)(*((void *)this + 43) + 8 * v14);
    unsigned int v14 = (v14 + 1) % *((_DWORD *)this + 82);
    *((_DWORD *)this + 84) = v14;
    int v15 = v12[2] - 1;
    v12[2] = v15;
    if (!v15) {
      goto LABEL_17;
    }
  }
  free(*((void **)this + 43));
  *((void *)this + 41) = 0;
  *((void *)this + 42) = 0;
  *((void *)this + 43) = 0;
  uint64_t v16 = (FILE *)*((void *)this + 40);
  if (v16)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v16);
    fwrite("cleaned up", 0xAuLL, 1uLL, *((FILE **)this + 40));
    fputc(10, *((FILE **)this + 40));
  }
  uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 150);
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  }
  double v24 = (void **)((char *)this + 1136);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&v24);
  CFBooleanRef v18 = (std::__shared_weak_count *)*((void *)this + 141);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  std::deque<void({block_pointer} {__strong})(std::shared_ptr<HTTP3Framer>,unsigned long long,BOOL),std::allocator<void({block_pointer} {__strong})(std::shared_ptr<HTTP3Framer>,unsigned long long,BOOL)>>::~deque[abi:nn180100]((uint64_t)this + 1072);

  uint64_t v19 = (std::__shared_weak_count *)*((void *)this + 129);
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v19);
  }
  uint64_t v20 = (std::__shared_weak_count *)*((void *)this + 127);
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  }

  uint64_t v21 = (std::__shared_weak_count *)*((void *)this + 123);
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  }
  CFErrorRef v22 = (std::__shared_weak_count *)*((void *)this + 121);
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  HTTP2ServerPush::~HTTP2ServerPush((HTTP3Connection *)((char *)this + 624));
  *((void *)this + 3) = &unk_1ECF9B550;
  double v23 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v23) {
    std::__shared_weak_count::__release_weak(v23);
  }
}

{
  uint64_t vars8;

  HTTP3Connection::~HTTP3Connection(this);

  JUMPOUT(0x18531B6D0);
}

void HTTP3Connection::stop(HTTP3Connection *this, char a2)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v8, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
  uint64_t v4 = *((void *)this + 125);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN15HTTP3Connection4stopEb_block_invoke;
  block[3] = &__block_descriptor_49_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e5_v8__0l;
  block[4] = v8;
  char v6 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v7 = a2;
  dispatch_async(v4, block);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
}

void HTTP3Connection::_cleanupConnection(HTTP3Connection *this, uint64_t a2, uint64_t a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 920) & 4) == 0)
  {
    if (*((void *)this + 124)) {
      HTTP3Connection::_stopStallRecovery(this);
    }
    char v6 = (HTTPStallTimer *)*((void *)this + 122);
    if (v6)
    {
      HTTPStallTimer::invalidate(v6);
      char v7 = (std::__shared_weak_count *)*((void *)this + 123);
      *((_OWORD *)this + 61) = 0u;
      if (v7) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v7);
      }
    }
    if (a2 != -1) {
      (*(void (**)(void, uint64_t))(**((void **)this + 126) + 112))(*((void *)this + 126), a2);
    }
    uint64_t v8 = (*(uint64_t (**)(void))(**((void **)this + 126) + 120))(*((void *)this + 126));
    if (v8 != -1)
    {
      uint64_t v9 = (void *)v8;
      if (v8 != 256)
      {
        uint64_t v10 = CFN_LOG_h3connection();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          uint64_t v31 = *((void *)this + 152);
          *(_DWORD *)buf = 134218496;
          *(void *)&uint8_t buf[4] = this;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v31;
          *(_WORD *)&unsigned char buf[22] = 2048;
          uint64_t v38 = v9;
          _os_log_error_impl(&dword_184085000, v10, OS_LOG_TYPE_ERROR, "%p %llu closed with peer error %llu", buf, 0x20u);
        }
      }
    }
    uint64_t v11 = *((void *)this + 145);
    unint64_t v12 = *((void *)this + 146);
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>(&v34, *((void **)this + 142), *((void **)this + 143), (uint64_t)(*((void *)this + 143) - *((void *)this + 142)) >> 4);
    uint64_t v13 = v34;
    uint64_t v14 = v35;
    if (v34 != v35)
    {
      uint64_t v15 = v11 | v12;
      if (v15) {
        unint64_t v16 = v12;
      }
      else {
        unint64_t v16 = v12 & 0xFFFFFFFF00000000 | 0xFFFFFFFC;
      }
      if (v15) {
        uint64_t v17 = v11;
      }
      else {
        uint64_t v17 = 4;
      }
      do
      {
        uint64_t v19 = *(HTTP3Stream **)v13;
        CFBooleanRef v18 = *(std::__shared_weak_count **)(v13 + 8);
        if (v18) {
          atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        HTTP3Stream::_cleanupStream((uint64_t)v19, 256, 1);
        *((void *)v19 + 33) = v17;
        *((void *)v19 + 34) = v16;
        HTTP3Stream::_protocolCallback(v19);
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v18);
        }
        v13 += 16;
      }
      while (v13 != v14);
    }
    uint64_t v20 = *((void *)this + 126);
    uint64_t v21 = *(std::__shared_weak_count **)(v20 + 168);
    *(void *)(v20 + 160) = 0;
    *(void *)(v20 + 168) = 0;
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v21);
    }
    (*(void (**)(void, uint64_t))(**((void **)this + 126) + 152))(*((void *)this + 126), a3);
    *((unsigned char *)this + 920) |= 4u;
    CFErrorRef v22 = (std::__shared_weak_count *)*((void *)this + 121);
    if (v22)
    {
      double v23 = std::__shared_weak_count::lock(v22);
      if (v23)
      {
        double v24 = v23;
        int v25 = (void *)*((void *)this + 120);
        if (v25)
        {
          std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v32, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
          int v26 = (std::__shared_weak_count *)v25[2];
          if (!v26 || (uint64_t v27 = v25[1], (v28 = std::__shared_weak_count::lock(v26)) == 0))
          {
            std::__throw_bad_weak_ptr[abi:nn180100]();
            __break(1u);
            return;
          }
          uint64_t v29 = v28;
          uint64_t v30 = v25[11];
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&uint8_t buf[8] = 3321888768;
          *(void *)&uint8_t buf[16] = ___ZN25HTTP3ConnectionCacheEntry16connectionClosedENSt3__110shared_ptrI15HTTP3ConnectionEE_block_invoke;
          uint64_t v38 = &__block_descriptor_64_ea8_32c53_ZTSNSt3__110shared_ptrI25HTTP3ConnectionCacheEntryEE48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e5_v8__0l;
          uint64_t v39 = v27;
          uint64_t v40 = v29;
          atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
          uint64_t v41 = v32;
          __darwin_ino64_t v42 = v33;
          if (v33) {
            atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v30 + 96))(v30, buf);
          if (v42) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v42);
          }
          if (v40) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v40);
          }
          std::__shared_weak_count::__release_shared[abi:nn180100](v29);
          if (v33) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v33);
          }
        }
        std::__shared_weak_count::__release_shared[abi:nn180100](v24);
      }
    }
    *(void *)buf = &v34;
    std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  }
}

void sub_18417CFE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, char a11, uint64_t a12, uint64_t a13, void **a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v23);
  a14 = (void **)&a11;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a14);
  _Unwind_Resume(a1);
}

void NWIOConnection::closeWithQUICApplicationError(nw_connection_t *this)
{
  uint64_t v2 = nw_protocol_copy_quic_connection_definition();
  nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(this[34], v2);
  if (v3)
  {
    nw_quic_connection_close_with_error();
    nw_release(v3);
  }
  if (v2)
  {
    nw_release(v2);
  }
}

void sub_18417D0F0(_Unwind_Exception *a1)
{
  nw_release(v2);
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

void HTTPEngine::_connectionLost(HTTPEngine *this)
{
  *((_DWORD *)this + 8) |= 2u;
  if (!*((void *)this + 25) && !*((void *)this + 26) && !*((void *)this + 39))
  {
    uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 11);
    if (v2)
    {
      nw_protocol_metadata_t v3 = std::__shared_weak_count::lock(v2);
      if (v3)
      {
        uint64_t v4 = v3;
        uint64_t v5 = *((void *)this + 10);
        if (v5) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 24))(v5, 4, 4294967292);
        }
        std::__shared_weak_count::__release_shared[abi:nn180100](v4);
      }
    }
  }
}

void sub_18417D1C8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void sub_18417D2EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18417D3AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void xx_CFHTTPCookieStorageRemoveObserver(OpaqueCFHTTPCookieStorage *a1, __CFRunLoop *a2, const __CFString *a3, __CFAllocator *a4, const __CFAllocator *a5)
{
  if (gObserverLock)
  {
    AutoScalar::AutoScalar((AutoScalar *)&v17, a4);
    CFTypeRef v9 = v18;
    AutoScalar::AutoScalar((AutoScalar *)&v15, a5);
    Array = cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a1, a2, a3, v9, cf, 0);
    uint64_t v15 = &unk_1ECF9A500;
    if (cf) {
      CFRelease(cf);
    }
    uint64_t v17 = &unk_1ECF9A500;
    if (v18) {
      CFRelease(v18);
    }
    os_unfair_lock_lock((os_unfair_lock_t)gObserverLock);
    CFStringRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(gObserverDict + 8), Array);
    if (Value)
    {
      unint64_t v12 = Value;
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
      }
      uint64_t v13 = (char *)a1 + 16;
      if (!a1) {
        uint64_t v13 = 0;
      }
      uint64_t v14 = (__CFSet *)*((void *)v13 + 3);
      if (v14) {
        CFSetRemoveValue(v14, v12);
      }
      CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v12);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(gObserverDict + 8), Array);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)gObserverLock);
    if (Array) {
      CFRelease(Array);
    }
  }
}

void sub_18417D8A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf, uint64_t a17, CFTypeRef a18)
{
  if (cf) {
    CFRelease(cf);
  }
  if (a18) {
    CFRelease(a18);
  }
  _Unwind_Resume(exception_object);
}

void xx_CFHTTPCookieStorageAddObserver(OpaqueCFHTTPCookieStorage *a1, __CFRunLoop *a2, const __CFString *a3, void (*a4)(OpaqueCFHTTPCookieStorage *, void *), void *a5)
{
  context.version = MEMORY[0x1E4F143A8];
  context.info = (void *)3221225472;
  context.retain = (const void *(__cdecl *)(const void *))___ZL19_dispatch_once_funcPlPFvvE_block_invoke_11780;
  context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e5_v8__0l;
  context.copyDescription = (CFStringRef (__cdecl *)(const void *))_initObserverLock;
  if (gObserverLockOnce != -1) {
    dispatch_once(&gObserverLockOnce, &context);
  }
  operator new();
}

void sub_18417DBB8(_Unwind_Exception *exception_object)
{
  *(void *)(v1 - 96) = &unk_1ECF9A500;
  nw_protocol_metadata_t v3 = *(const void **)(v1 - 88);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(v1 - 80) = &unk_1ECF9A500;
  uint64_t v4 = *(const void **)(v1 - 72);
  if (v4) {
    CFRelease(v4);
  }
  _Unwind_Resume(exception_object);
}

void APSRelayEngine::~APSRelayEngine(id *this)
{
  APSRelayEngine::~APSRelayEngine(this);

  JUMPOUT(0x18531B6D0);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;

  *this = &unk_1ECF9C6C8;

  uint64_t v2 = (std::__shared_weak_count *)this[17];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  nw_protocol_metadata_t v3 = (std::__shared_weak_count *)this[15];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)this[13];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)this[9];
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  char v6 = (std::__shared_weak_count *)this[7];
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  char v7 = (std::__shared_weak_count *)this[5];
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  *this = &unk_1ECF9B550;
  uint64_t v8 = (std::__shared_weak_count *)this[2];
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_18417DD4C(_Unwind_Exception *exception_object)
{
  nw_protocol_metadata_t v3 = (std::__shared_weak_count *)v1[17];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)v1[15];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)v1[13];
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  char v6 = (std::__shared_weak_count *)v1[9];
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  char v7 = (std::__shared_weak_count *)v1[7];
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)v1[5];
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  *uint64_t v1 = &unk_1ECF9B550;
  CFTypeRef v9 = (std::__shared_weak_count *)v1[2];
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__throw_bad_weak_ptr[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_weak_ptr was thrown in -fno-exceptions mode");
  return APSRelayEngine::cancel(v0);
}

uint64_t APSRelayEngine::cancel(uint64_t this)
{
  if ((*(unsigned char *)(this + 24) & 1) == 0)
  {
    *(unsigned char *)(this + 24) |= 1u;
    if (*(void *)(this + 168))
    {
      if (!*(void *)(this + 160) && !*(_DWORD *)(this + 88)) {
        return [*(id *)(this + 168) cancelMessage:*(void *)(this + 152)];
      }
    }
  }
  return this;
}

void ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  char v6 = (std::__shared_weak_count *)a1[7];
  if (v6)
  {
    uint64_t v11 = a1[5];
    unint64_t v12 = std::__shared_weak_count::lock(v6);
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = a1[6];
      if (v14)
      {
        id v15 = a2;
        id v16 = a3;
        id v17 = a5;
        uint64_t v18 = *(void *)(v14 + 64);
        v20[0] = MEMORY[0x1E4F143A8];
        v20[1] = 3321888768;
        v20[2] = ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke_2;
        void v20[3] = &unk_1ECFA8038;
        v20[4] = a2;
        void v20[5] = a3;
        v20[8] = v11;
        v20[9] = a4;
        v20[6] = a5;
        uint64_t v19 = (std::__shared_weak_count *)a1[9];
        v20[10] = a1[8];
        uint64_t v21 = v19;
        if (v19) {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v22 = v14;
        double v23 = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        v20[7] = a1[4];
        (*(void (**)(uint64_t, void *))(*(void *)v18 + 96))(v18, v20);
        if (v23) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v23);
        }
        if (v21) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v21);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v13);
    }
  }
}

void sub_18417DF64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_48c39_ZTSNSt3__18weak_ptrI14APSRelayEngineEE64c39_ZTSNSt3__110shared_ptrIK10__CFStringEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  nw_protocol_metadata_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *__copy_helper_block_e8_48c39_ZTSNSt3__18weak_ptrI14APSRelayEngineEE64c39_ZTSNSt3__110shared_ptrIK10__CFStringEE(void *result, void *a2)
{
  uint64_t v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[9];
  result[8] = a2[8];
  result[9] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke_2(uint64_t a1)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 64);
  v50[0] = MEMORY[0x1E4F143A8];
  v50[1] = 3221225472;
  CFStringRef v51 = ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke_3;
  CFStringRef v52 = &unk_1E52582F0;
  long long v2 = *(_OWORD *)(a1 + 32);
  long long v53 = v2;
  uint64_t v54 = *(void *)(a1 + 48);
  if ((*(unsigned char *)(v1 + 24) & 1) == 0)
  {
    *(void *)(v1 + 160) = v2;
    id v4 = (id)v2;
    if ([*(id *)(v1 + 160) hasAttemptedAPSDelivery])
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v5 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(a1 + 80);
        int buf = 138543362;
        *(void *)buf_4 = v6;
        _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@ attempted APSP", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v7 = *(void *)(v1 + 176);
      if (v7) {
        *(unsigned char *)(v7 + 11) = 1;
      }
    }
    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v8 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(a1 + 80);
        int buf = 138543362;
        *(void *)buf_4 = v9;
        _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@ did not attempt APSP", (uint8_t *)&buf, 0xCu);
      }
    }
    if ([*(id *)(v1 + 160) deliveryMechanism] == 1)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v10 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a1 + 80);
        int buf = 138543362;
        *(void *)buf_4 = v11;
        _os_log_impl(&dword_184085000, v10, OS_LOG_TYPE_DEFAULT, "%{public}@ arriving via APSP", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v12 = *(void *)(v1 + 176);
      if (v12) {
        *(unsigned char *)(v12 + 12) = 1;
      }
    }
    else if ([*(id *)(v1 + 160) deliveryMechanism] == 2)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v13 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = *(void *)(a1 + 80);
        int buf = 138543362;
        *(void *)buf_4 = v14;
        _os_log_impl(&dword_184085000, v13, OS_LOG_TYPE_DEFAULT, "%{public}@ arriving via APSF", (uint8_t *)&buf, 0xCu);
      }
    }
    id v15 = *(void **)(a1 + 40);
    if (v15 || !*(void *)(v1 + 160))
    {
      id v16 = (void *)[v15 domain];
      if ([v16 isEqualToString:*MEMORY[0x1E4F289A0]])
      {
        *(void *)(v1 + 80) = _CFStreamErrorFromCFError(*(__CFError **)(a1 + 40));
        *(void *)(v1 + 88) = v17;
      }
      else
      {
        *(void *)(v1 + 80) = 15;
        *(_DWORD *)(v1 + 88) = -1004;
      }
    }
    else
    {
      uint64_t v21 = *(void *)(a1 + 96);
      double Current = CFAbsoluteTimeGetCurrent();
      uint64_t v23 = *(void *)(v21 + 176);
      if (v23) {
        *(double *)(v23 + 200) = Current;
      }
      uint64_t v24 = objc_msgSend(*(id *)(v21 + 160), "deliveryMechanism", Current);
      int v25 = *(void **)(v21 + 160);
      if (v24 == 1)
      {
        objc_msgSend((id)objc_msgSend(v25, "requestStart"), "timeIntervalSinceReferenceDate");
        uint64_t v27 = *(void *)(v21 + 176);
        if (v27) {
          *(void *)(v27 + 176) = v26;
        }
        objc_msgSend((id)objc_msgSend(*(id *)(v21 + 160), "requestEnd"), "timeIntervalSinceReferenceDate");
        uint64_t v29 = *(void *)(v21 + 176);
        if (v29) {
          *(void *)(v29 + 184) = v28;
        }
        objc_msgSend((id)objc_msgSend(*(id *)(v21 + 160), "responseReceived"), "timeIntervalSinceReferenceDate");
        uint64_t v31 = *(void *)(v21 + 176);
        if (v31) {
          *(void *)(v31 + 192) = v30;
        }
      }
      else if ([v25 deliveryMechanism] == 2 && objc_msgSend(*(id *)(v21 + 160), "timingData"))
      {
        uint64_t v32 = *(void *)(v21 + 176);
        id v33 = (id)[*(id *)(v21 + 160) timingData];
        uint64_t v34 = v33;
        if (v32)
        {
          uint64_t v35 = [v33 objectForKeyedSubscript:@"_kCFNTimingDataInternalTransactionMetrics"];
          if (v35)
          {
            uint64_t v36 = [MEMORY[0x1E4F28DC0] unarchivedObjectOfClass:objc_opt_class() fromData:v35 error:0];
            uint64_t v38 = v36;
            if (v36) {
              id Property = objc_getProperty(v36, v37, 88, 1);
            }
            else {
              id Property = 0;
            }
            id v40 = Property;
            objc_setProperty_atomic((id)v32, v41, v40, 88);

            if (v38)
            {
              *(unsigned char *)(v32 + 8) = v38[8];
              *(unsigned char *)(v32 + 9) = v38[9];
              *(void *)(v32 + 96) = *((void *)v38 + 12);
              *(void *)(v32 + 104) = *((void *)v38 + 13);
              *(void *)(v32 + 112) = *((void *)v38 + 14);
              *(void *)(v32 + 120) = *((void *)v38 + 15);
              *(void *)(v32 + 128) = *((void *)v38 + 16);
              *(void *)(v32 + 136) = *((void *)v38 + 17);
              *(void *)(v32 + 176) = *((void *)v38 + 22);
              *(void *)(v32 + 184) = *((void *)v38 + 23);
              *(void *)(v32 + 192) = *((void *)v38 + 24);
              *(void *)(v32 + 200) = *((void *)v38 + 25);
              BOOL v42 = v38[10] != 0;
            }
            else
            {
              BOOL v42 = 0;
              *(_WORD *)(v32 + 8) = 0;
              *(_OWORD *)(v32 + 96) = 0u;
              *(_OWORD *)(v32 + 112) = 0u;
              *(_OWORD *)(v32 + 128) = 0u;
              *(_OWORD *)(v32 + 176) = 0u;
              *(_OWORD *)(v32 + 192) = 0u;
            }
            *(unsigned char *)(v32 + 10) = v42;
          }
        }
      }
      uint64_t v43 = *(void *)(a1 + 96);
      BOOL v44 = *(void **)(v43 + 160);
      if (v44)
      {
        int v45 = objc_msgSend((id)objc_msgSend(v44, "responseStatusCode"), "intValue");
        [*(id *)(v43 + 160) responseHeaders];
        if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
          dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
        }
        uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
        CFStringRef v47 = Instance;
        if (Instance)
        {
          Instance[1] = 0u;
          CFStringRef v47 = Instance + 1;
          Instance[18] = 0u;
          Instance[19] = 0u;
          Instance[16] = 0u;
          Instance[17] = 0u;
          Instance[14] = 0u;
          Instance[15] = 0u;
          Instance[12] = 0u;
          Instance[13] = 0u;
          Instance[10] = 0u;
          Instance[11] = 0u;
          Instance[8] = 0u;
          Instance[9] = 0u;
          Instance[6] = 0u;
          Instance[7] = 0u;
          Instance[4] = 0u;
          Instance[5] = 0u;
          Instance[2] = 0u;
          Instance[3] = 0u;
        }
        HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&buf, @"HTTP/1.1");
        HTTPMessage::HTTPMessage(v47, "httpresponse", *(CFTypeRef *)&buf_4[4]);
        *(void *)CFStringRef v47 = &unk_1ECF9FD98;
        *((void *)v47 + 1) = &unk_1ECF9FE08;
        *((void *)v47 + 2) = &unk_1ECF9FE28;
        *((_DWORD *)v47 + 32) = v45;
        *((void *)v47 + 17) = 0;
        v47[10] = 0u;
        v47[11] = 0u;
        v47[12] = 0u;
        v47[13] = 0u;
        v47[14] = 0u;
        v47[15] = 0u;
        v47[16] = 0u;
        v47[17] = 0u;
        *((unsigned char *)v47 + 296) = 0;
        operator new();
      }
    }
    uint64_t v18 = *(void *)(a1 + 56);
    uint64_t v19 = *(std::__shared_weak_count **)(v1 + 136);
    uint64_t v48 = *(void *)(v1 + 128);
    CFStringRef v49 = v19;
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *, void, void, void, uint64_t, uint64_t))(v18 + 16))(v18, &v48, *(void *)(v1 + 144), *(void *)(v1 + 80), *(void *)(v1 + 88), [*(id *)(v1 + 160) sentByteCount], objc_msgSend(*(id *)(v1 + 160), "receivedByteCount"));
    if (v49) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v49);
    }
  }
  return ((uint64_t (*)(void *))v51)(v50);
}

void sub_18417E994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, void (*a20)(char *))
{
  a20(&a18);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_80c39_ZTSNSt3__110shared_ptrIK10__CFStringEE96c42_ZTSNSt3__110shared_ptrI14APSRelayEngineEE(uint64_t a1)
{
  long long v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_e8_80c39_ZTSNSt3__110shared_ptrIK10__CFStringEE96c42_ZTSNSt3__110shared_ptrI14APSRelayEngineEE(void *result, void *a2)
{
  uint64_t v2 = a2[11];
  result[10] = a2[10];
  result[11] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[13];
  result[12] = a2[12];
  result[13] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN14APSRelayEngine18processTransactionENSt3__110shared_ptrI18HTTPRequestMessageEENS1_IK8__CFDataEENS1_I17CoreSchedulingSetEENS1_IK10__CFStringEEdU13block_pointerFvNS1_I19HTTPResponseMessageEEP11objc_object13CFStreamErrorxxE_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
}

void StringSerializable::~StringSerializable(StringSerializable *this)
{
  *(void *)this = &unk_1ECF9F718;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9F718;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

void std::__shared_ptr_pointer<HTTPResponseMessage *,Deleter_release<HTTPResponseMessage>,std::allocator<HTTPResponseMessage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void HTTPVersionMixedValue::~HTTPVersionMixedValue(HTTPVersionMixedValue *this)
{
  *(void *)this = &unk_1ECF9F718;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9F718;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

void sub_18417ED5C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18417EF1C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t _copyPrivateProtocolSchedulingSet(void)
{
  if (_copyPrivateProtocolSchedulingSet(void)::sOnce != -1) {
    dispatch_once(&_copyPrivateProtocolSchedulingSet(void)::sOnce, &__block_literal_global_350);
  }
  CFStringRef v0 = *(uint64_t (**)(void))(*(void *)_copyPrivateProtocolSchedulingSet(void)::sppss + 88);

  return v0();
}

void ___ZL33_copyPrivateProtocolSchedulingSetv_block_invoke()
{
  NewPrivateRunLoopThread = (__CFRunLoop *)CoreSchedulingSet::createNewPrivateRunLoopThread((uint64_t)"com.apple.CFNetwork.CustomProtocols", 0, 0);
  uint64_t v1 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 120, 0);
  *uint64_t v1 = 0u;
  v1[1] = 0u;
  v1[2] = 0u;
  v1[3] = 0u;
  v1[4] = 0u;
  v1[5] = 0u;
  v1[6] = 0u;
  *((void *)v1 + 14) = 0;
  RunLoopSchedulingSet::RunLoopSchedulingSet((RunLoopSchedulingSet *)v1, NewPrivateRunLoopThread, (const __CFString *)*MEMORY[0x1E4F1D418], "privateloader");
  _copyPrivateProtocolSchedulingSet(void)::sppss = v2;
}

uint64_t ___ZN12XTubeManager27_markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t))(*(void *)a3 + 40))(a3);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN12XTubeManager27_markReusedAfterAPSleepWakeEv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e5_v8__0l;
  v6[4] = a3;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)a2 + 96))(a2, v6);
}

uint64_t ___ZN12XTubeManager27_markReusedAfterAPSleepWakeEv_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = v2[4];
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = v3 + 80;
    do
    {
      uint64_t v6 = *(void *)(v5 + v4);
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 144))(v6);
      }
      v4 += 8;
    }
    while (v4 != 24);
    uint64_t v2 = *(void **)(a1 + 32);
  }
  uint64_t v7 = *(uint64_t (**)(void))(*v2 + 48);

  return v7();
}

void sub_18417FBA0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_18417FD00(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12XTubeManager23logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t))(*(void *)a3 + 40))(a3);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN12XTubeManager23logConnectionsAtAPSleepEv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e5_v8__0l;
  v6[4] = a3;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)a2 + 96))(a2, v6);
}

uint64_t ___ZN12XTubeManager23logConnectionsAtAPSleepEv_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = v2[4];
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = v3 + 80;
    do
    {
      uint64_t v6 = *(void *)(v5 + v4);
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 112))(v6);
      }
      v4 += 8;
    }
    while (v4 != 24);
    uint64_t v2 = *(void **)(a1 + 32);
  }
  uint64_t v7 = *(uint64_t (**)(void))(*v2 + 48);

  return v7();
}

void RetainableTypedDict<CoreSchedulingSet const*,GlueTubeManager *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0310;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<CoreSchedulingSet const*,GlueTubeManager *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0310;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void sub_184180904(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void ___ZN12XTubeManager25setCurrentSSLMethodForKeyEPK22HTTPConnectionCacheKeyPK10__CFStringPK17CoreSchedulingSet_block_invoke(uint64_t a1, GlueTubeManager *this)
{
  uint64_t v3 = *(const void **)(a1 + 32);
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    uint64_t TManager = GlueTubeManager::_findOrCreateTManager((uint64_t)this, 0);
    if (v3)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(TManager + 128), v3, v4);
      uint64_t v6 = (__CFDictionary *)*((void *)GlueTubeManager::_findOrCreateSManager(this) + 16);
      CFDictionarySetValue(v6, v3, v4);
    }
    else
    {
      GlueTubeManager::_findOrCreateSManager(this);
    }
  }
  else
  {
    if (*((void *)this + 4))
    {
      uint64_t v7 = GlueTubeManager::_findOrCreateTManager((uint64_t)this, 0);
      if (v3) {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v7 + 128), v3);
      }
    }
    if (*((void *)this + 5))
    {
      SManager = GlueTubeManager::_findOrCreateSManager(this);
      if (v3)
      {
        uint64_t v9 = (__CFDictionary *)*((void *)SManager + 16);
        CFDictionaryRemoveValue(v9, v3);
      }
    }
  }
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void *___ZN12XTubeManager22getPATTimestampsForKeyEPK22HTTPConnectionCacheKeyPK17CoreSchedulingSet_block_invoke(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = (const void *)result[5];
  uint64_t v5 = *(void *)(a2 + 32);
  if (v5) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6 || (CFTypeRef result = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 112), v4)) == 0) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = result[3];
  }
  *(void *)(*(void *)(v3[4] + 8) + 40) = v7;
  return result;
}

void non-virtual thunk to'CFURLProtocol_NS::~CFURLProtocol_NS(CFURLProtocol_NS *this)
{
}

{
  CFURLProtocol_NS::~CFURLProtocol_NS((CFURLProtocol_NS *)((char *)this - 16));
}

{
  CFURLProtocol_NS::~CFURLProtocol_NS((CFURLProtocol_NS *)((char *)this - 8));
}

{
  CFURLProtocol_NS::~CFURLProtocol_NS((CFURLProtocol_NS *)((char *)this - 8));
}

void CFURLProtocol_NS::~CFURLProtocol_NS(CFURLProtocol_NS *this)
{
  *(void *)this = &unk_1ECF9DBC0;
  *((void *)this + 1) = &unk_1ECF9DCC8;
  *((void *)this + 2) = &unk_1ECF9DCE8;

  uint64_t v2 = *((void *)this + 18);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }

  URLProtocol::~URLProtocol((URLProtocol *)this);
}

void sub_184180D98(_Unwind_Exception *a1)
{
  URLProtocol::~URLProtocol(v1);
  _Unwind_Resume(a1);
}

uint64_t URLProtocol::attemptRedirection(URLProtocol *this, __CFHTTPMessage *a2)
{
  return 0;
}

uint64_t URLProtocol::_protocolInterface_isCachedResponseValidNonBlocking(URLProtocol *this, const _CFCachedURLResponse *a2)
{
  return 0;
}

uint64_t CFURLProtocol_NS::_protocolInterface_useCredential(CFURLProtocol_NS *this, CFTypeRef cf, CFTypeRef a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  CFRetain((char *)this - 16);
  uint64_t v6 = *((void *)this + 18);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = ___ZN16CFURLProtocol_NS32_protocolInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke;
  v8[3] = &__block_descriptor_56_e5_v8__0l;
  v8[4] = this;
  v8[5] = a3;
  void v8[6] = cf;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v8);
}

void ___ZN16CFURLProtocol_NS32_protocolInterface_useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = *(void **)(v2 + 128);
  if (!v3) {
    goto LABEL_10;
  }
  objc_sync_enter(*(id *)(v2 + 128));
  uint64_t v4 = (const void *)v3[4];
  if (!v4)
  {
    objc_sync_exit(v3);
    goto LABEL_10;
  }
  CFTypeRef v5 = CFRetain(v4);
  objc_sync_exit(v3);
  if (!v5)
  {
LABEL_10:
    uint64_t v8 = (CFTypeRef *)(a1 + 5);
    goto LABEL_11;
  }
  CFTypeRef v6 = CFAutorelease(v5);
  uint64_t v8 = (CFTypeRef *)(a1 + 5);
  uint64_t v7 = (const void *)a1[5];
  if (v7 && v6 && CFEqual(v7, v6))
  {
    uint64_t v9 = a1[6];
    uint64_t v10 = (void *)[-[__NSCFURLProtocolClient_NS challenge](*(id **)(v2 + 128)) sender];
    if (v9) {
      objc_msgSend(v10, "useCredential:forAuthenticationChallenge:", -[NSURLCredential _initWithCFURLCredential:]([NSURLCredential alloc], "_initWithCFURLCredential:", a1[6]), -[__NSCFURLProtocolClient_NS challenge](*(id **)(v2 + 128)));
    }
    else {
      [v10 performDefaultHandlingForAuthenticationChallenge:-[__NSCFURLProtocolClient_NS challenge](*(id **)(v2 + 128))];
    }
  }
LABEL_11:
  uint64_t v11 = (const void *)a1[6];
  if (v11) {
    CFRelease(v11);
  }
  if (*v8) {
    CFRelease(*v8);
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

void sub_184180FD8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t CFURLProtocol_NS::_protocolInterface_cancelLoad(CFURLProtocol_NS *this)
{
  CFRetain((char *)this - 16);
  uint64_t v2 = *((void *)this + 18);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZN16CFURLProtocol_NS29_protocolInterface_cancelLoadEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  void v4[4] = this;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 96))(v2, v4);
}

void ___ZN16CFURLProtocol_NS29_protocolInterface_cancelLoadEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(v1 + 120);
  if (v2)
  {
    [v2 stopLoading];

    *(void *)(v1 + 120) = 0;
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t CFURLProtocol_NS::_protocolInterface_startLoad(CFURLProtocol_NS *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  CFRetain((char *)this - 16);
  uint64_t v4 = *((void *)this + 18);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN16CFURLProtocol_NS28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  v6[4] = this;
  void v6[5] = cf;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, v6);
}

void ___ZN16CFURLProtocol_NS28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 120)) {
    __assert_rtn("_protocolInterface_startLoad_block_invoke", "LocalSession.mm", 1917, "_protocolInstance == nil");
  }
  if (*(void *)(a1 + 40)) {
    id v3 = [[NSCachedURLResponse alloc] _initWithCFCachedURLResponse:*(void *)(a1 + 40)];
  }
  else {
    id v3 = 0;
  }
  uint64_t v4 = *(void **)(v1 + 80);
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  CFTypeRef v6 = (void *)[*(id *)(v1 + 112) alloc];
  if (isKindOfClass) {
    uint64_t v7 = objc_msgSend(v6, "initWithRequest:cachedResponse:client:", objc_msgSend(v4, "currentRequest"), v3, *(void *)(v1 + 128));
  }
  else {
    uint64_t v7 = [v6 initWithTask:v4 cachedResponse:v3 client:*(void *)(v1 + 128)];
  }
  *(void *)(v1 + 120) = v7;

  [*(id *)(v1 + 120) startLoading];
  uint64_t v8 = *(const void **)(a1 + 40);
  if (v8) {
    CFRelease(v8);
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

void CFURLProtocol_NS::forgetProtocolClient(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 35;
  os_unfair_lock_lock(this + 35);
  int os_unfair_lock_opaque_low = LOBYTE(this[34]._os_unfair_lock_opaque);
  LOBYTE(this[34]._os_unfair_lock_opaque) = 1;
  os_unfair_lock_unlock(v2);
  if (!os_unfair_lock_opaque_low)
  {
    CFRetain(&this[-4]);
    uint64_t v4 = *(void *)&this[36]._os_unfair_lock_opaque;
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    void v5[2] = ___ZN16CFURLProtocol_NS20forgetProtocolClientEv_block_invoke;
    v5[3] = &__block_descriptor_40_e5_v8__0l;
    v5[4] = this;
    (*(void (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, v5);
  }
}

void ___ZN16CFURLProtocol_NS20forgetProtocolClientEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(v1 + 128);
  if (v2)
  {
    *(void *)(v1 + 128) = 0;
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    v4[2] = __38____NSCFURLProtocolClient_NS_teardown__block_invoke;
    v4[3] = &unk_1E5258228;
    void v4[4] = v2;
    -[__NSCFURLProtocolClient_NS withCustomProtocolScheduling:](v2, (uint64_t)v4);
  }
  id v3 = *(void **)(v1 + 120);
  *(void *)(v1 + 120) = 0;
  if (v3)
  {
    [v3 stopLoading];
  }
  URLProtocol::forgetProtocolClient((URLProtocol *)v1);

  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t CFURLProtocol_NS::initialize(URLProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3)
{
  URLProtocol::initialize(this, a2, a3);
  CFTypeRef v5 = [__NSCFURLProtocolClient_NS alloc];
  if (v5)
  {
    v9.receiver = v5;
    v9.super_class = (Class)__NSCFURLProtocolClient_NS;
    CFTypeRef v6 = [(URLProtocol *)&v9 init];
    uint64_t v7 = v6;
    if (v6)
    {
      *((void *)v6 + 1) = a3;
      (*((void (**)(URLProtocolClient *))a3->var0 + 2))(a3);
      *((void *)v7 + 2) = this;
      CFRetain((char *)this - 16);
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  *((void *)this + 16) = v7;
  return 1;
}

CFStringRef CFURLProtocol_NS::copyDebugDesc(CFURLProtocol_NS *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s", "copyDebugDesc");
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke()
{
}

void sub_1841815A8(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
}

void sub_184181A40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184181CB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184181E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_184181F18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841820E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184182330(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184182484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_184182568(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184182694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841828EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184182A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_184182B30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184182D7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184182EB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_184183098(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841831E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1841832BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18418339C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841835F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184183744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_184183824(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184183958(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184183B30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184183C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_184183D48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184183F3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841840D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841842C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184184448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_184184528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184184798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1841849B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184184BC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184184DE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184185020(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841851C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841853CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841855D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841857AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184185998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HTTP2Diagnostic::LOG_FRAME(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  uint64_t v7 = a1;
  if (a5) {
    (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)a1 + 72))(a1, "h2     ", @"[%llu] %s %s frame<length=%ld, flags=0x%x, stream_id=%d> error_code=%d");
  }
  else {
    (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)a1 + 72))(a1, "h2     ", @"[%llu] %s %s frame<length=%ld, flags=0x%x, stream_id=%d>");
  }
  switch(*(unsigned char *)(a2 + 12))
  {
    case 1:
      uint64_t v8 = *(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72);
      goto LABEL_7;
    case 2:
      uint64_t v8 = *(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72);
LABEL_7:
      objc_super v9 = "h2 prio";
      uint64_t v10 = @"[%llu] (dep_stream_id=%d, weight=%d, exclusive=%d)";
      goto LABEL_63;
    case 3:
      nghttp2_strerror();
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72))(v7, "h2 rsts", @"[%llu] (error_code=%s(%d))");
      goto LABEL_66;
    case 4:
      if (*(unsigned char *)(a2 + 13)) {
        goto LABEL_66;
      }
      memset(&v53, 0, sizeof(v53));
      if (!*(void *)(a2 + 16)) {
        goto LABEL_66;
      }
      uint64_t v50 = v7;
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      std::string::size_type v52 = *MEMORY[0x1E4FBA408];
      std::string::size_type v49 = *(void *)(MEMORY[0x1E4FBA408] + 64);
      std::string::size_type v48 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      do
      {
        std::string::size_type size = HIBYTE(v53.__r_.__value_.__r.__words[2]);
        if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = v53.__r_.__value_.__l.__size_;
        }
        if (size) {
          std::string::append(&v53, "\n");
        }
        std::string::append(&v53, "[");
        std::to_string(&v57, a4);
        if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v14 = &v57;
        }
        else {
          uint64_t v14 = (std::string *)v57.__r_.__value_.__r.__words[0];
        }
        if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v15 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v15 = v57.__r_.__value_.__l.__size_;
        }
        std::string::append(&v53, (const std::string::value_type *)v14, v15);
        if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v57.__r_.__value_.__l.__data_);
        }
        std::string::append(&v53, "] [");
        unsigned int v16 = *(_DWORD *)(*(void *)(a2 + 24) + v11) - 1;
        uint64_t v17 = "UNKNOWN";
        if (v16 <= 5) {
          uint64_t v17 = off_1E52528D0[v16];
        }
        std::string::append(&v53, v17);
        std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)&v57);
        *(_DWORD *)((char *)v58 + *(void *)(v57.__r_.__value_.__r.__words[2] - 24)) = *(_DWORD *)((unsigned char *)v58
                                                                                                  + *(void *)(v57.__r_.__value_.__r.__words[2] - 24)) & 0xFFFFFFB5 | 8;
        std::ostream::operator<<();
        std::stringbuf::str();
        uint64_t v18 = std::string::insert(&v54, 0, "(0x");
        long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
        v55.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v19;
        v18->__r_.__value_.__l.__size_ = 0;
        v18->__r_.__value_.__r.__words[2] = 0;
        v18->__r_.__value_.__r.__words[0] = 0;
        uint64_t v20 = std::string::append(&v55, "):");
        long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v21;
        v20->__r_.__value_.__l.__size_ = 0;
        v20->__r_.__value_.__r.__words[2] = 0;
        v20->__r_.__value_.__r.__words[0] = 0;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v23 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v23 = __p.__r_.__value_.__l.__size_;
        }
        std::string::append(&v53, (const std::string::value_type *)p_p, v23);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v55.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v54.__r_.__value_.__l.__data_);
        }
        std::to_string(&__p, *(_DWORD *)(*(void *)(a2 + 24) + v11 + 4));
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v24 = &__p;
        }
        else {
          uint64_t v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v25 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v25 = __p.__r_.__value_.__l.__size_;
        }
        std::string::append(&v53, (const std::string::value_type *)v24, v25);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        std::string::append(&v53, "]");
        v57.__r_.__value_.__r.__words[0] = v52;
        *(std::string::size_type *)((char *)v57.__r_.__value_.__r.__words + *(void *)(v52 - 24)) = v49;
        v57.__r_.__value_.__r.__words[2] = v48;
        v58[0] = MEMORY[0x1E4FBA470] + 16;
        if (v60 < 0) {
          operator delete(v59);
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x18531B660](v61);
        ++v12;
        v11 += 8;
      }
      while (*(void *)(a2 + 16) > v12);
      uint64_t v7 = v50;
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
      {
        CFStringRef v47 = (void *)v53.__r_.__value_.__r.__words[0];
        if (!v53.__r_.__value_.__l.__size_) {
          goto LABEL_115;
        }
      }
      else if (!*((unsigned char *)&v53.__r_.__value_.__s + 23))
      {
        goto LABEL_66;
      }
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v50 + 72))(v50, "h2 stgs", @"%s");
      if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_66;
      }
      CFStringRef v47 = (void *)v53.__r_.__value_.__r.__words[0];
LABEL_115:
      operator delete(v47);
LABEL_66:
      unsigned int v32 = *(unsigned __int8 *)(a2 + 13);
      if (!*(unsigned char *)(a2 + 13)) {
        return;
      }
      int v33 = *(unsigned __int8 *)(a2 + 12);
      int v34 = 1;
      memset(&__p, 0, sizeof(__p));
      unsigned int v35 = v32;
      do
      {
        if ((v34 & v32) != 0)
        {
          if ((v33 & 0xFFFFFFFD) == 4)
          {
            if (v34 & v32) {
              uint64_t v36 = "ACK";
            }
            else {
              uint64_t v36 = 0;
            }
          }
          else
          {
            uint64_t v36 = 0;
            switch(v33)
            {
              case 0:
                uint64_t v36 = "END_STREAM";
                if ((v34 & v32 & 1) == 0) {
                  goto LABEL_77;
                }
                break;
              case 1:
                uint64_t v36 = "END_STREAM";
                if ((v34 & v32 & 1) == 0)
                {
                  uint64_t v36 = "END_HEADERS";
                  if ((v34 & v32 & 4) == 0)
                  {
                    uint64_t v36 = "PADDED";
                    if ((v34 & v32 & 8) == 0)
                    {
                      uint64_t v36 = "PRIORITY";
                      if ((v34 & v32 & 0x20) == 0) {
                        goto LABEL_103;
                      }
                    }
                  }
                }
                break;
              case 5:
                uint64_t v36 = "END_HEADERS";
                if ((v34 & v32 & 4) == 0)
                {
LABEL_77:
                  uint64_t v36 = "PADDED";
                  if ((v34 & v32 & 8) == 0) {
                    goto LABEL_103;
                  }
                }
                break;
              case 9:
                uint64_t v36 = "END_HEADERS";
                if ((v34 & v32 & 4) == 0) {
LABEL_103:
                }
                  uint64_t v36 = 0;
                break;
              default:
                break;
            }
          }
          std::string::basic_string[abi:nn180100]<0>(&v57, v36);
          std::string::size_type v37 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
          char v38 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
          std::string::size_type v39 = v57.__r_.__value_.__l.__size_;
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v40 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v40 = v57.__r_.__value_.__l.__size_;
          }
          if (v40)
          {
            std::string::size_type v41 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v41 = __p.__r_.__value_.__l.__size_;
            }
            if (v41)
            {
              std::string::append(&__p, " | ");
              std::string::size_type v37 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
              std::string::size_type v39 = v57.__r_.__value_.__l.__size_;
              char v38 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
            }
            if (v38 >= 0) {
              BOOL v42 = &v57;
            }
            else {
              BOOL v42 = (std::string *)v57.__r_.__value_.__r.__words[0];
            }
            if (v38 >= 0) {
              std::string::size_type v43 = v37;
            }
            else {
              std::string::size_type v43 = v39;
            }
            std::string::append(&__p, (const std::string::value_type *)v42, v43);
            char v38 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
          }
          if (v38 < 0) {
            operator delete(v57.__r_.__value_.__l.__data_);
          }
        }
        int v34 = 2 * v34;
        BOOL v44 = v35 > 1;
        v35 >>= 1;
      }
      while (v44);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        CFStringRef v46 = (void *)__p.__r_.__value_.__r.__words[0];
        uint64_t v45 = v7;
        if (!__p.__r_.__value_.__l.__size_) {
          goto LABEL_110;
        }
      }
      else
      {
        uint64_t v45 = v7;
        if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
          return;
        }
      }
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v45 + 72))(v45, "h2 flgs", @"[%llu] %s");
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
      CFStringRef v46 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_110:
      operator delete(v46);
      return;
    case 5:
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72))(v7, "h2 pshp", @"[%llu] (padlen=%zu, promised_stream_id=%d)");
      goto LABEL_66;
    case 6:
      uint64_t v51 = v7;
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)&v57);
      for (uint64_t i = 0; i != 8; ++i)
      {
        std::string::size_type v27 = v57.__r_.__value_.__r.__words[2];
        std::string::size_type v28 = v57.__r_.__value_.__r.__words[2];
        *(void *)((char *)&v58[2] + *(void *)(v57.__r_.__value_.__r.__words[2] - 24)) = 2;
        uint64_t v29 = (const std::ios_base *)((char *)&v57.__r_.__value_.__r.__words[2] + *(void *)(v28 - 24));
        if (v29[1].__fmtflags_ == -1)
        {
          std::ios_base::getloc(v29);
          uint64_t v30 = std::locale::use_facet((const std::locale *)&__p, MEMORY[0x1E4FBA258]);
          ((void (*)(const std::locale::facet *, uint64_t))v30->__vftable[2].~facet_0)(v30, 32);
          std::locale::~locale((std::locale *)&__p);
          std::string::size_type v27 = v57.__r_.__value_.__r.__words[2];
        }
        v29[1].__fmtflags_ = 48;
        *(_DWORD *)((char *)v58 + *(void *)(v27 - 24)) = *(_DWORD *)((unsigned char *)v58 + *(void *)(v27 - 24)) & 0xFFFFFFB5 | 8;
        std::ostream::operator<<();
      }
      std::stringbuf::str();
      uint64_t v7 = v51;
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v51 + 72))(v51, "h2 ping", @"[%llu] (opaque_data=%s)");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      v57.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4FBA408];
      std::string::size_type v31 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      *(std::string::size_type *)((char *)v57.__r_.__value_.__r.__words
                                + *(void *)(v57.__r_.__value_.__r.__words[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408]
                                                                                                  + 64);
      v57.__r_.__value_.__r.__words[2] = v31;
      v58[0] = MEMORY[0x1E4FBA470] + 16;
      if (v60 < 0) {
        operator delete(v59);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x18531B660](v61);
      goto LABEL_66;
    case 7:
      nghttp2_strerror();
      uint64_t v8 = *(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72);
      objc_super v9 = "h2 gowy";
      uint64_t v10 = @"[%llu] (last_stream_id=%d, error_code=%s(%d), opaque_data_len=%zu)";
LABEL_63:
      v8(v7, v9, v10);
      goto LABEL_66;
    case 8:
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v7 + 72))(v7, "h2 updt", @"[%llu] (window_size_increment=%d)");
      goto LABEL_66;
    default:
      goto LABEL_66;
  }
}

void sub_1841865DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,std::locale a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  CFTypeRef v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  uint64_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x1E4FBA488] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1841869F4(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x18531B660](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA408];
  uint64_t v3 = *MEMORY[0x1E4FBA408];
  *(void *)a1 = *MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x18531B660](a1 + 128);
  return a1;
}

uint64_t ___Z33cf_nghttp2_on_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 53;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t cf_nghttp2_on_invalid_frame_recv_callback(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_6, 2);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v7 + 16))(v7, "h2 frame", 0))
    {
      HTTP2Diagnostic::LOG_FRAME(v8, a2, 2, *(void *)(a4 + 72), a3);
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
  }
  return 0;
}

uint64_t ___Z41cf_nghttp2_on_invalid_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_frameiPv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 88;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN15HTTP2Connection31submitWindowUpdateForPushStreamEii_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(HTTP2Connection **)(a1 + 32);
  if (*((void *)v1 + 20))
  {
    int v2 = nghttp2_submit_window_update();
    if (v2 < 0)
    {
      int v3 = v2;
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v4 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v5 = (const __CFString *)(*(uint64_t (**)(HTTP2Connection *))(*(void *)v1 + 24))(v1);
        int v6 = 136315394;
        uint64_t v7 = _cfnAutoreleaseInDebug(v5);
        __int16 v8 = 1024;
        int v9 = v3;
        _os_log_error_impl(&dword_184085000, v4, OS_LOG_TYPE_ERROR, "Could not submit window update on [%s], error code: %d", (uint8_t *)&v6, 0x12u);
      }
    }
    HTTP2Connection::_onqueue_scheduleIO(v1);
  }
  CFRelease((char *)v1 - 16);
}

void HTTP2ServerPushStream::safe_data_deleter(dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
}

void *std::string::basic_string[abi:nn180100](void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    int v6 = operator new(v7 + 1);
    __dst[1] = __len;
    std::locale __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    int v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

uint64_t ___Z33cf_nghttp2_on_frame_send_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 215;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___Z33cf_nghttp2_on_frame_send_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 194;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t cf_nghttp2_on_frame_not_send_callback(int a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_13, 2);
  if (v8)
  {
    uint64_t v9 = v8;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v8 + 16))(v8, "h2 frame", 0))
    {
      HTTP2Diagnostic::LOG_FRAME(v9, a2, 3, *(void *)(a4 + 72), a3);
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
  }
  int v10 = *(unsigned __int8 *)(a2 + 12);
  if (a3 == -522 && v10 == 1)
  {
    uint64_t stream_user_data = nghttp2_session_get_stream_user_data();
    if (stream_user_data)
    {
      uint64_t v13 = *(HTTP2Stream **)stream_user_data;
      uint64_t v12 = *(std::__shared_weak_count **)(stream_user_data + 8);
      uint64_t v14 = *(HTTP2Stream **)stream_user_data;
      if (v12)
      {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v14 = *(HTTP2Stream **)stream_user_data;
      }
      HTTP2Connection::flushBatchedDataForStream((uint64_t **)a4, v14);
      HTTP2Stream::cleanUpInUserDataResetCallback(v13, a1, *(_DWORD *)(a2 + 8), (HTTP2Connection *)6, a4);
      if (v12) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v12);
      }
    }
    int v10 = *(unsigned __int8 *)(a2 + 12);
  }
  if (v10 == 3)
  {
    uint64_t v15 = nghttp2_session_get_stream_user_data();
    if (v15)
    {
      uint64_t v17 = *(HTTP2Stream **)v15;
      unsigned int v16 = *(std::__shared_weak_count **)(v15 + 8);
      uint64_t v18 = *(HTTP2Stream **)v15;
      if (v16)
      {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v18 = *(HTTP2Stream **)v15;
      }
      HTTP2Connection::flushBatchedDataForStream((uint64_t **)a4, v18);
      HTTP2Stream::cleanUpInUserDataResetCallback(v17, a1, *(_DWORD *)(a2 + 8), (HTTP2Connection *)*(unsigned int *)(a2 + 16), a4);
      if (v16) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v16);
      }
    }
  }
  return 0;
}

void sub_184187130(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___Z37cf_nghttp2_on_frame_not_send_callbackP15nghttp2_sessionPK13nghttp2_frameiPv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 248;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t cf_nghttp2_on_invalid_header_callback(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (a4 == 4 && *a3 == 1953722216 && nghttp2_check_header_value()) {
    return 0;
  }
  else {
    return 4294966775;
  }
}

uint64_t cf_nghttp2_error_callback2(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v8 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = *(void *)(a5 + 72);
    int v11 = 134218498;
    uint64_t v12 = v10;
    __int16 v13 = 1024;
    int v14 = a2;
    __int16 v15 = 2080;
    uint64_t v16 = a3;
    _os_log_error_impl(&dword_184085000, v8, OS_LOG_TYPE_ERROR, "HTTP/2 error encountered on Connection %llu (Code %d): %s", (uint8_t *)&v11, 0x1Cu);
  }
  return 0;
}

double CFNA::_CFNetworkAgentGetTTL(CFNA *this)
{
  uint64_t v1 = getenv("CFNETWORKAGENT_TTL");
  if (v1) {
    return (double)strtol(v1, 0, 10);
  }
  else {
    return 86400.0;
  }
}

const __CFString *CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore(CFNA *this, const __CFString *a2, const char *a3)
{
  values[2] = *(void **)MEMORY[0x1E4F143B8];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (!CFNA::sQueryResultsCache) {
    CFNA::sQueryResultsCache = (uint64_t)CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  int v6 = getenv("CFNETWORKAGENT_KEY_SPACE_ROOT");
  if (v6) {
    size_t v7 = v6;
  }
  else {
    size_t v7 = "com.apple.CFNetwork.netcompat";
  }
  CFStringRef v8 = CFStringCreateWithCString(v5, v7, 0x600u);
  if (v8)
  {
    CFStringRef v9 = v8;
    CFStringRef v10 = CFStringCreateWithFormat(v5, 0, @"%@.%s", v8, a2);
    if (v10)
    {
      CFStringRef v11 = v10;
      values[0] = (void *)v10;
      values[1] = this;
      CFArrayRef v12 = CFArrayCreate(v5, (const void **)values, 2, MEMORY[0x1E4F1D510]);
      CFRelease(v11);
      CFRelease(v9);
      if (v12)
      {
        CFStringRef v13 = CFStringCreateByCombiningStrings(v5, v12, @":");
        if (!v13)
        {
          CFStringRef v23 = 0;
LABEL_34:
          CFRelease(v12);
          return v23;
        }
        CFStringRef v14 = v13;
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)CFNA::sQueryResultsCache, v13);
        if (Value)
        {
          CFArrayRef v16 = Value;
          if (CFArrayGetCount(Value) == 2)
          {
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v16, 1);
            if (ValueAtIndex)
            {
              CFStringRef v18 = ValueAtIndex;
              double Current = CFAbsoluteTimeGetCurrent();
              double v20 = Current - CFStringGetDoubleValue(v18);
              if (v20 <= CFNA::_CFNetworkAgentGetTTL(v21))
              {
                CFStringRef v22 = (const __CFString *)CFArrayGetValueAtIndex(v16, 0);
                CFStringRef v23 = v22;
                if (v22) {
                  CFRetain(v22);
                }
                goto LABEL_33;
              }
            }
          }
          goto LABEL_28;
        }
        memset(&context, 0, sizeof(context));
        uint64_t v24 = SCDynamicStoreCreate(v5, @"CFNETWORK_AGENT__STORE__", 0, &context);
        if (!v24)
        {
LABEL_28:
          CFStringRef v23 = 0;
LABEL_33:
          CFRelease(v14);
          goto LABEL_34;
        }
        std::string::size_type v25 = v24;
        CFArrayRef v26 = SCDynamicStoreCopyKeyList(v24, v14);
        if (!v26)
        {
          CFStringRef v23 = 0;
          goto LABEL_32;
        }
        CFArrayRef v27 = v26;
        if (CFArrayGetCount(v26) < 1
          || (CFStringRef v28 = (const __CFString *)CFArrayGetValueAtIndex(v27, 0),
              (CFArrayRef v29 = (const __CFArray *)SCDynamicStoreCopyValue(v25, v28)) == 0))
        {
          CFStringRef v23 = 0;
          goto LABEL_30;
        }
        CFArrayRef v30 = v29;
        if (CFArrayGetCount(v29) == 2)
        {
          CFStringRef v23 = (const __CFString *)CFArrayGetValueAtIndex(v30, 1);
          if (!v23)
          {
LABEL_27:
            CFRelease(v30);
LABEL_30:
            CFRelease(v27);
LABEL_32:
            CFRelease(v25);
            goto LABEL_33;
          }
          double v31 = CFAbsoluteTimeGetCurrent();
          double v32 = v31 - CFStringGetDoubleValue(v23);
          if (v32 <= CFNA::_CFNetworkAgentGetTTL(v33))
          {
            CFStringRef v35 = (const __CFString *)CFArrayGetValueAtIndex(v30, 0);
            CFStringRef v23 = v35;
            if (v35) {
              CFRetain(v35);
            }
            CFDictionarySetValue((CFMutableDictionaryRef)CFNA::sQueryResultsCache, v14, v30);
            goto LABEL_27;
          }
        }
        CFStringRef v23 = 0;
        goto LABEL_27;
      }
    }
    else
    {
      CFRelease(v9);
    }
  }
  return 0;
}

__n128 __Block_byref_object_copy__129(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__130(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void ___ZN14StrictSecurity33performSystemTrustEvaluationAsyncEPK8__CFDataNS_21SessionStrengthPolicyEN14CFNetworkTrust26SignatureAlgorithmStrengthEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFviE_block_invoke(uint64_t a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109120;
    v8[1] = a2;
    _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "System Trust Evaluation yielded status(%d)", (uint8_t *)v8, 8u);
  }
  if (a2)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFAllocatorRef v5 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v8[0]) = 0;
      _os_log_error_impl(&dword_184085000, v5, OS_LOG_TYPE_ERROR, "ATS failed system trust", (uint8_t *)v8, 2u);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  size_t v7 = *(std::__shared_weak_count **)(v6 + 56);
  *(void *)(v6 + 48) = 0;
  *(void *)(v6 + 56) = 0;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
}

void std::__shared_ptr_emplace<CFNetworkTrust>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6720;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<CFNetworkTrust>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6720;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void __performStrictTrustEvaluationAsync_block_invoke(uint64_t a1, int a2)
{
  if (a2)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    int v3 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_error_impl(&dword_184085000, v3, OS_LOG_TYPE_ERROR, "StrictTrustEvaluate failed", v6, 2u);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  CFAllocatorRef v5 = *(std::__shared_weak_count **)(v4 + 56);
  *(void *)(v4 + 48) = 0;
  *(void *)(v4 + 56) = 0;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void HTTPRequestParserClient::addHeader(HTTPRequestParserClient *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  CFAllocatorRef v5 = (CFDictionaryRef *)(*(uint64_t (**)(HTTPRequestParserClient *))(*(void *)this + 40))(this);

  HTTPHeaderDict::addValue(v5, a2, a3);
}

BOOL HTTPRequestParserClient::completeFirstLine(HTTPRequestParserClient *this, const UInt8 *a2, uint64_t a3)
{
  if ((*((void *)this + 3)
     || *(void *)((*(uint64_t (**)(HTTPRequestParserClient *))(*(void *)this + 32))(this) + 8))
    && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v27[0]) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "shouldn't be", (uint8_t *)v27, 2u);
  }
  uint64_t v6 = (const char *)&a2[a3];
  CFStringRef v28 = 0;
  v27[0] = a2;
  CFArrayRef v30 = (const char *)&a2[a3];
  if (a3 < 1) {
    return 0;
  }
  uint64_t v7 = MEMORY[0x1E4F14390];
  CFStringRef v8 = a2;
  while (1)
  {
    unsigned int v9 = *(char *)v8;
    if ((v9 & 0x80000000) != 0) {
      break;
    }
    if ((*(_DWORD *)(v7 + 4 * v9 + 60) & 0x4000) != 0) {
      goto LABEL_14;
    }
LABEL_11:
    if (++v8 >= (const UInt8 *)v6) {
      return 0;
    }
  }
  if (!__maskrune(v9, 0x4000uLL)) {
    goto LABEL_11;
  }
LABEL_14:
  v27[1] = v8;
  CFStringRef v11 = (const char *)(v8 + 1);
  while (v11 < v6)
  {
    CFArrayRef v12 = v11;
    unsigned int v13 = *v11;
    if ((v13 & 0x80000000) != 0) {
      int v14 = __maskrune(v13, 0x4000uLL);
    }
    else {
      int v14 = *(_DWORD *)(v7 + 4 * v13 + 60) & 0x4000;
    }
    CFStringRef v11 = v12 + 1;
    if (!v14)
    {
      _OWORD v27[2] = v12;
      __int16 v15 = v6;
      while (v15 > v12)
      {
        unsigned int v17 = *--v15;
        unsigned int v16 = v17;
        if ((v17 & 0x80000000) != 0)
        {
          if (__maskrune(v16, 0x4000uLL))
          {
LABEL_26:
            CFStringRef v18 = (const UInt8 *)(v15 + 1);
            CFArrayRef v29 = v18;
            long long v19 = v18;
            while (v19 > (const UInt8 *)v12)
            {
              unsigned int v21 = *(char *)--v19;
              unsigned int v20 = v21;
              if ((v21 & 0x80000000) != 0)
              {
                if (!__maskrune(v20, 0x4000uLL))
                {
LABEL_32:
                  CFStringRef v22 = (const char *)(v19 + 1);
                  CFStringRef v28 = v19 + 1;
                  BOOL result = FirstLineFieldsBase::checkFields((uint64_t)v27, 3, (unint64_t)a2, (unint64_t)v6);
                  if (result)
                  {
                    CFIndex v23 = v8 - a2;
                    CFAllocatorRef v24 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                    *((void *)this + 3) = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, v23, 0x201u, 0);
                    uint64_t v25 = (*(uint64_t (**)(HTTPRequestParserClient *))(*(void *)this + 32))(this);
                    *(void *)(v25 + 8) = CFStringCreateWithBytes(v24, v18, v6 - (const char *)v18, 0x201u, 0);
                    if (v22 == v12) {
                      CFArrayRef v26 = 0;
                    }
                    else {
                      CFArrayRef v26 = strndup(v12, v22 - v12);
                    }
                    *((void *)this + 4) = v26;
                    return v26 != 0;
                  }
                  return result;
                }
              }
              else if ((*(_DWORD *)(v7 + 4 * v20 + 60) & 0x4000) == 0)
              {
                goto LABEL_32;
              }
            }
            return 0;
          }
        }
        else if ((*(_DWORD *)(v7 + 4 * v16 + 60) & 0x4000) != 0)
        {
          goto LABEL_26;
        }
      }
      return 0;
    }
  }
  return 0;
}

void HTTPRequestParserClient::HTTPRequestParserClient(HTTPRequestParserClient *this, CFTypeRef cf)
{
  *(void *)this = &unk_1ECFA29D0;
  *((void *)this + 2) = &unk_1ECFA1360;
  *((void *)this + 3) = 0;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  *((void *)this + 1) = v3;
  *((void *)this + 4) = 0;
}

void sub_184187C74(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 16) = &unk_1ECF9F718;
  CFTypeRef v3 = *(const void **)(v1 + 24);
  if (v3) {
    CFRelease(v3);
  }
  _Unwind_Resume(exception_object);
}

void HTTPMethodMixedValue::~HTTPMethodMixedValue(HTTPMethodMixedValue *this)
{
  *(void *)this = &unk_1ECF9F718;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9F718;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

void HTTPHeaderKeyMixedValue::~HTTPHeaderKeyMixedValue(HTTPHeaderKeyMixedValue *this)
{
  *(void *)this = &unk_1ECF9F718;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9F718;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

void sub_1841888D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,void (*a23)(char *))
{
}

void sub_184188D5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void (*a18)(char *))
{
}

void CoreStreamImplementation::_streamImpl_deprecated_Unschedule(CoreStreamImplementation *this, __CFRunLoop *a2, const __CFString *a3)
{
}

void CoreStreamImplementation::_streamImpl_deprecated_Schedule(CoreStreamImplementation *this, __CFRunLoop *a2, const __CFString *a3)
{
}

void CoreStreamImplementation::_streamImpl_UpdateScheduling(CoreStreamImplementation *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke;
  v6[3] = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v6[4] = this;
  CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)a2, v6);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke_2;
  v5[3] = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v5[4] = this;
  CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)a3, v5);
}

uint64_t ___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 160))();
}

uint64_t ___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 152))();
}

void CoreStreamImplementation::_streamImpl_openAsync()
{
}

uint64_t CoreStreamImplementation::_streamImpl_workQueue(CoreStreamImplementation *this)
{
  return 0;
}

void CoreStreamImplementation::_streamImpl_CanWrite(CoreStreamImplementation *this)
{
}

void CoreStreamImplementation::_streamImpl_Write(CoreStreamImplementation *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
}

void CoreStreamImplementation::_streamImpl_CanRead(CoreStreamImplementation *this)
{
}

void CoreStreamImplementation::_streamImpl_Read(CoreStreamImplementation *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
}

uint64_t CoreReadStreamScheduleWithRunLoop(CoreStreamBase *a1, CoreSchedulingSet *this, const __CFString *cf1)
{
  CFAllocatorRef v5 = a1;
  if (a1)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    CFAllocatorRef v5 = (CoreStreamBase *)((char *)v5 + 16);
  }
  uint64_t v6 = (const CoreSchedulingSet *)CoreSchedulingSet::create(this, cf1, cf1);
  CoreStreamBase::_streamInterface_UpdateScheduling(v5, v6);
  uint64_t v7 = *(uint64_t (**)(const CoreSchedulingSet *))(*(void *)v6 + 48);

  return v7(v6);
}

void CoreReadStreamUnscheduleFromRunLoop(CoreStreamBase *this)
{
  uint64_t v1 = this;
  if (this)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v1 = (CoreStreamBase *)((char *)v1 + 16);
  }
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1) {
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
  }
  int v2 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;

  CoreStreamBase::_streamInterface_UpdateScheduling(v1, v2);
}

uint64_t CoreWriteStreamScheduleWithRunLoop(CoreStreamBase *a1, CoreSchedulingSet *this, const __CFString *cf1)
{
  CFAllocatorRef v5 = a1;
  if (a1)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    CFAllocatorRef v5 = (CoreStreamBase *)((char *)v5 + 16);
  }
  uint64_t v6 = (const CoreSchedulingSet *)CoreSchedulingSet::create(this, cf1, cf1);
  CoreStreamBase::_streamInterface_UpdateScheduling(v5, v6);
  uint64_t v7 = *(uint64_t (**)(const CoreSchedulingSet *))(*(void *)v6 + 48);

  return v7(v6);
}

void CoreWriteStreamUnscheduleFromRunLoop(CoreStreamBase *this)
{
  uint64_t v1 = this;
  if (this)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    uint64_t v1 = (CoreStreamBase *)((char *)v1 + 16);
  }
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1) {
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
  }
  int v2 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;

  CoreStreamBase::_streamInterface_UpdateScheduling(v1, v2);
}

void CFStreamCreatePairWithSocketToCFHost(CFAllocatorRef alloc, CFHostRef host, SInt32 port, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
}

void __CFStreamCreatePairWithSocketToCFHost(const __CFAllocator *a1, __CFHost *a2, const __CFAllocator *a3, __CFReadStream **a4, __CFWriteStream **a5, int a6)
{
  if (TCFObject<SocketStream>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_311);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v13 = Instance;
    int v14 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B8uLL);
    SocketStream::SocketStream(v14, v15);
    SocketStream::initialize(v16, a2, a3);
    if ((*(unsigned int (**)(SocketStream *, __CFReadStream **, __CFWriteStream **))(*(void *)(v13 + 16)
                                                                                               + 64))(v14, a4, a5))
    {
      unint64_t v17 = (*(unsigned int *)(v13 + 264) | ((unint64_t)*(unsigned __int16 *)(v13 + 268) << 32)) & 0xFFFFFF7FFFFFFFFFLL;
      __int16 v18 = 128;
      if (!a6) {
        __int16 v18 = 0;
      }
      *(_DWORD *)(v13 + 264) = *(_DWORD *)(v13 + 264);
      *(_WORD *)(v13 + 268) = WORD2(v17) | v18;
    }
    CFRelease((CFTypeRef)v13);
  }
  else
  {
    SocketStream::SocketStream(0, v12);
  }
}

void SocketStream::SocketStream(SocketStream *this, const char *a2)
{
  *(void *)this = &unk_1ECF9DFA8;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9B550;
  *((void *)this + 3) = &unk_1ECF9A380;
  *((void *)this + 2) = &unk_1ECF9A478;
  CFTypeRef v3 = (void *)((char *)this + 32);
  _CoreLockable::_CoreLockable((SocketStream *)((char *)this + 32), 1);
  *CFTypeRef v3 = &unk_1ECF9B530;
  if (SocketStream::observableProperties(void)::onceToken != -1) {
    dispatch_once(&SocketStream::observableProperties(void)::onceToken, &__block_literal_global_6916);
  }
  NotificationStation::NotificationStation((SocketStream *)((char *)this + 104), (CFTypeRef)SocketStream::observableProperties(void)::observableProps);
  *(void *)this = &unk_1ECF9BF70;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C070;
  *((void *)this + 2) = &unk_1ECF9C108;
  *((void *)this + 3) = &unk_1ECF9C208;
  *((void *)this + 4) = &unk_1ECF9C290;
  *((_DWORD *)this + 62) = 0;
  *((_WORD *)this + 126) = 0;
  *((void *)this + 8__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  *(_OWORD *)((char *)this + 664) = 0u;
  *((void *)this + 86) = 0;
  *((_DWORD *)this + 106) = 0;
  *((void *)this + 52) = 0;
}

void sub_184189520(_Unwind_Exception *a1)
{
  *(void *)(v1 + 32) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
  *CFTypeRef v3 = v2;
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke()
{
}

void sub_1841895CC(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void CFStreamCreatePairWithSocketToNetService(CFAllocatorRef alloc, CFNetServiceRef service, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
  if (TCFObject<SocketStream>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_311);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v9 = Instance;
    CFStringRef v10 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B8uLL);
    SocketStream::SocketStream(v10, v11);
    SocketStream::initialize(v12, service);
    if ((*(unsigned int (**)(SocketStream *, CFReadStreamRef *, CFWriteStreamRef *))(*(void *)(v9 + 16)
                                                                                               + 64))(v10, readStream, writeStream))
    {
      *(_WORD *)(v9 + 268) = (*(unsigned int *)(v9 + 264) | ((unint64_t)*(unsigned __int16 *)(v9 + 268) << 32) | 0x8000000000) >> 32;
    }
    CFRelease((CFTypeRef)v9);
  }
  else
  {
    SocketStream::SocketStream(0, v8);
  }
}

void _CFStreamCreatePairWithNativeSocket(const __CFAllocator *a1, int a2, __CFReadStream **a3, __CFWriteStream **a4)
{
  if (TCFObject<SocketStream>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_311);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v9 = Instance;
    CFStringRef v10 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B8uLL);
    SocketStream::SocketStream(v10, v11);
    *(_DWORD *)bytes = a2;
    SocketStream::commonInitialization(v12);
    *(_DWORD *)(v9 + 264) |= 0x100u;
    CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)v9);
    CFDataRef v14 = CFDataCreate(v13, bytes, 4);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v9 + 352), &unk_1EC0A0F98, v14);
    if (v14) {
      CFRelease(v14);
    }
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v9 + 352), &unk_1EC0A0F28, (const void *)*MEMORY[0x1E4F1CFC8]);
    if (*(void *)(v9 + 232)) {
      SocketStream::setLoggerPrefixWithNativeHandle(v10, *(unsigned int *)bytes);
    }
    if ((*(unsigned int (**)(SocketStream *, __CFReadStream **, __CFWriteStream **))(*(void *)v10 + 64))(v10, a3, a4))
    {
      *(_WORD *)(v9 + 268) = (*(unsigned int *)(v9 + 264) | ((unint64_t)*(unsigned __int16 *)(v9 + 268) << 32) | 0x8000000000) >> 32;
    }
    CFRelease((CFTypeRef)v9);
  }
  else
  {
    SocketStream::SocketStream(0, v8);
  }
}

void _CFSocketStreamCreatePair(__CFAllocator *a1, const __CFString *a2, const __CFAllocator *a3, int a4, const __CFData *a5, __CFReadStream **a6, __CFWriteStream **a7)
{
  if (a2)
  {
    CFArrayRef v12 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(a1, a2, (const __CFAllocator *)(unsigned __int16)a3);
    if (v12 || (CFArrayRef v12 = CFHostCreateWithName(a1, a2)) != 0)
    {
      __CFStreamCreatePairWithSocketToCFHost(a1, v12, a3, a6, a7, 1);
      CFRelease(v12);
    }
    else
    {
      if (a6) {
        *a6 = 0;
      }
      if (a7) {
        *a7 = 0;
      }
    }
  }
  else if (a5)
  {
    CFDataRef v13 = (const __CFData *)*((void *)a5 + 2);
    _CFStreamCreatePairWithCFSocketSignaturePieces(a1, v13, (uint64_t)a6, (uint64_t)a7, a5, a6, a7);
  }
  else
  {
    _CFStreamCreatePairWithNativeSocket(a1, a4, a6, a7);
  }
}

void _CFStreamCreatePairWithCFSocketSignaturePieces(const __CFAllocator *a1, const __CFData *a2, uint64_t a3, uint64_t a4, const __CFData *a5, __CFReadStream **a6, __CFWriteStream **a7)
{
  if (TCFObject<SocketStream>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_311);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v12 = Instance;
    CFDataRef v13 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B8uLL);
    SocketStream::SocketStream(v13, v14);
    SocketStream::commonInitialization(v15);
    CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)v12);
    CFHostRef v17 = CFHostCreateWithAddress(v16, a2);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v12 + 352), &unk_1EC0A0FD0, v17);
    CFRelease(v17);
    if ((*(unsigned int (**)(SocketStream *, uint64_t, uint64_t))(*(void *)(v12 + 16) + 64))(v13, a3, a4)) {
      *(_WORD *)(v12 + 268) = (*(unsigned int *)(v12 + 264) | ((unint64_t)*(unsigned __int16 *)(v12 + 268) << 32) | 0x8000000000) >> 32;
    }
    CFRelease((CFTypeRef)v12);
  }
  else
  {
    SocketStream::SocketStream(0, v11);
  }
}

BOOL _CFHTTPReadStreamIsAtMark(uint64_t a1)
{
  if (a1)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v2 = a1 + 16;
  }
  else
  {
    uint64_t v2 = 0;
  }
  CFTypeRef v3 = (pthread_mutex_t *)(v2 + 136);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 136));
  BOOL v4 = (~(*(unsigned __int16 *)(v2 + 232) | (*(unsigned __int8 *)(v2 + 234) << 16)) & 0x201) == 0;
  pthread_mutex_unlock(v3);
  return v4;
}

uint64_t CFReadStreamCreateHTTPStream(const __CFAllocator *a1, __CFReadStream *a2, int a3)
{
  HTTPStreamWithConnInfo = __CoreReadStreamCreateHTTPStreamWithConnInfo(a1, a2, a3, 0);
  uint64_t v5 = _CFReadStreamCreateWithCoreStream((uint64_t)a1, (uint64_t)HTTPStreamWithConnInfo);
  if (HTTPStreamWithConnInfo) {
    CFRelease(HTTPStreamWithConnInfo);
  }
  return v5;
}

_OWORD *__CoreReadStreamCreateHTTPStreamWithConnInfo(const __CFAllocator *a1, __CFReadStream *a2, int a3, HTTPNetConnection *a4)
{
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v9 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v9 = Instance + 1;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  CoreReadStreamBase::CoreReadStreamBase((CoreReadStreamBase *)v9, v8);
  *(void *)uint64_t v9 = &unk_1ECF9C888;
  *((void *)v9 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C8F0;
  *((void *)v9 + 15) = &unk_1ECF9C910;
  _CoreLockable::_CoreLockable((_CoreLockable *)(v9 + 8), 1);
  *((void *)v9 + 25) = a4;
  *(void *)uint64_t v9 = &unk_1ECF9CAD8;
  *((void *)v9 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9CB78;
  *((void *)v9 + 15) = &unk_1ECF9CB98;
  *((void *)v9 + 16) = &unk_1ECF9CC50;
  *((_WORD *)v9 + 116) = 0;
  *((unsigned char *)v9 + 234) = 0;
  if (a2) {
    CFTypeRef v10 = CFRetain(a2);
  }
  else {
    CFTypeRef v10 = 0;
  }
  *((void *)v9 + 26) = v10;
  CFAllocatorRef v11 = CFGetAllocator(v9 - 1);
  *((void *)v9 + 28) = CFHTTPMessageCreateEmpty(v11, a3 == 0);
  *((void *)v9 + 30) = -2;
  *((void *)v9 + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  *((void *)v9 + 32) = 0;
  *((void *)v9 + 33) = 0;
  return v9 - 1;
}

void sub_184189E2C(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1ECF9F028;
  *((void *)v1 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9F090;
  *((void *)v1 + 15) = &unk_1ECF9F0B0;
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

const void *CFWriteStreamCreateHTTPStream(const __CFAllocator *a1, __CFHTTPMessage *a2, int a3, __CFWriteStream *a4)
{
  BOOL result = (const void *)__CoreWriteStreamCreateHTTPStreamWithConnInfo(a1, a2, a3, a4, 0);
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = _CFWriteStreamCreateWithCoreStream();
    CFRelease(v5);
    return (const void *)v6;
  }
  return result;
}

uint64_t __CoreWriteStreamCreateHTTPStreamWithConnInfo(const __CFAllocator *a1, __CFHTTPMessage *a2, int a3, __CFWriteStream *a4, HTTPNetConnection *a5)
{
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v11 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v11 = Instance + 16;
    *(void *)(Instance + 304) = 0;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 288) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  CoreWriteStreamBase::CoreWriteStreamBase((CoreWriteStreamBase *)v11, v10);
  *(void *)uint64_t v11 = &unk_1ECF9D1A0;
  *(void *)(v11 + 8) = &unk_1ECF9D208;
  *(void *)(v11 + 120) = &unk_1ECF9D228;
  _CoreLockable::_CoreLockable((_CoreLockable *)(v11 + 128), 1);
  *(void *)(v11 + 200) = a5;
  *(void *)uint64_t v11 = &unk_1ECF9D768;
  *(void *)(v11 + 8) = &unk_1ECF9D808;
  *(void *)(v11 + 120) = &unk_1ECF9D828;
  *(void *)(v11 + 128) = &unk_1ECF9D8E0;
  *(_WORD *)(v11 + 224) = 0;
  if (a4)
  {
    CFTypeRef v12 = CFRetain(a4);
    __int16 v13 = *(_WORD *)(v11 + 224);
  }
  else
  {
    __int16 v13 = 0;
    CFTypeRef v12 = 0;
  }
  *(void *)(v11 + 208) = v12;
  *(void *)(v11 + 216) = 0;
  *(_OWORD *)(v11 + 232) = 0u;
  *(_OWORD *)(v11 + 248) = 0u;
  *(void *)(v11 + 264) = 0;
  *(void *)(v11 + 280) = 0;
  *(void *)(v11 + 288) = 0;
  if (a3)
  {
    v13 |= 0x200u;
    *(_WORD *)(v11 + 224) = v13;
  }
  *(_WORD *)(v11 + 224) = v13 | 4;
  if (a2)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    ++*(void *)(v11 + 80);
    (*(void (**)(void, uint64_t, __CFHTTPMessage *))(**(void **)(v11 + 24) + 32))(*(void *)(v11 + 24), 0x1EC0A35E0, a2);
    --*(void *)(v11 + 80);
  }
  return v11 - 16;
}

void sub_18418A18C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 128) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 136));
  CoreStreamBase::~CoreStreamBase((CoreStreamBase *)v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HSTSPolicy::~HSTSPolicy(HSTSPolicy *this)
{
}

{
  HSTSPolicy::~HSTSPolicy((HSTSPolicy *)((char *)this - 8));
}

CFStringRef HSTSPolicy::copyDebugDesc(HSTSPolicy *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<HSTSPolicy@%p <%p>> { HSTSCache=%p }", (char *)this - 16, this, *((void *)this + 2));
}

void *_CFHSTSPolicyCreateWithProperties(uint64_t a1, CFDictionaryRef theDict)
{
  if (!theDict || CFDictionaryGetValue(theDict, @"hsts_persistent") == (const void *)*MEMORY[0x1E4F1CFC8])
  {
    if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1) {
      dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
    }
    uint64_t Instance = (void *)_CFRuntimeCreateInstance();
    CFTypeRef v3 = Instance;
    if (Instance)
    {
      Instance[2] = 0;
      Instance[3] = 0;
      CFTypeRef v3 = Instance + 2;
      Instance[4] = 0;
    }
    CFTypeRef cf = 0;
    HSTSPolicy::HSTSPolicy(v3, a1, 0, (uint64_t *)&cf);
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    if (HSTSPolicy::getDefaultPolicy(void)::sOnce != -1) {
      dispatch_once(&HSTSPolicy::getDefaultPolicy(void)::sOnce, &__block_literal_global_3);
    }
    CFTypeRef v3 = (void *)HSTSPolicy::getDefaultPolicy(void)::sHSTSPolicy;
    CFRetain((CFTypeRef)(HSTSPolicy::getDefaultPolicy(void)::sHSTSPolicy - 16));
  }
  if (!v3 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Must have a valid HSTS Policy now", v6, 2u);
  }
  return v3 - 2;
}

void sub_18418A380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

CFDictionaryRef HSTSPolicy::copyExternalRepresentationOfHSTSPolicies(HSTSPolicy *this)
{
  uint64_t v2 = (char *)this - 16;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v5 = *((void *)this + 2);
  uint64_t v12 = 0;
  __int16 v13 = &v12;
  uint64_t v14 = 0x2020000000;
  uint64_t v15 = 0;
  uint64_t v6 = *(NSObject **)(v5 + 16);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = ___ZNK9HSTSCache40copyInternalRepresentationOfHSTSPoliciesEv_block_invoke;
  v11[3] = &unk_1E5257C30;
  void v11[4] = &v12;
  void v11[5] = v5;
  dispatch_sync(v6, v11);
  CFDictionaryRef v7 = (const __CFDictionary *)v13[3];
  _Block_object_dispose(&v12, 8);
  if (v7)
  {
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)mapToExternalRepresentation, Mutable);
    CFRelease(v7);
  }
  CFAllocatorRef v8 = CFGetAllocator(v2);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(v8, Mutable);
  CFRelease(Mutable);
  return Copy;
}

void mapToExternalRepresentation(const __CFString *a1, CFDictionaryRef theDict, __CFDictionary *a3)
{
  if (a1)
  {
    if (theDict)
    {
      CFArrayRef Value = CFDictionaryGetValue(theDict, @"HSTS Host");
      if (Value)
      {
        CFDictionaryRef v7 = Value;
        CFTypeID v8 = CFGetTypeID(Value);
        if (v8 == CFBooleanGetTypeID() && v7 == (const void *)*MEMORY[0x1E4F1CFD0])
        {
          CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          double valuePtr = HSTSParser::getTimeForKey(theDict, (const __CFDictionary *)@"Expiry", v11);
          if (valuePtr > 0.0)
          {
            CFNumberRef v12 = CFNumberCreate(v9, kCFNumberDoubleType, &valuePtr);
            if (v12)
            {
              CFNumberRef v13 = v12;
              CFDictionarySetValue(Mutable, @"_kCFNetworkHSTSExpiry", v12);
              CFRelease(v13);
            }
          }
          uint64_t v14 = CFDictionaryGetValue(theDict, @"Include Subdomains");
          if (v14)
          {
            uint64_t v15 = v14;
            CFTypeID v16 = CFGetTypeID(v14);
            if (v16 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)int buf = 0;
              _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
            }
            if (v7 == v15) {
              CFDictionarySetValue(Mutable, @"_kCFNetworkHSTSIncludeSubDomains", v7);
            }
          }
          if (forceHTTPSByHSTSPreload(a1)) {
            CFDictionarySetValue(Mutable, @"_kCFNetworkHSTSPreloaded", v7);
          }
          if (Mutable)
          {
            CFDictionaryRef Copy = CFDictionaryCreateCopy(v9, Mutable);
            CFRelease(Mutable);
            if (Copy)
            {
              CFStringRef v18 = CFStringCreateCopy(v9, a1);
              if (v18)
              {
                CFStringRef v19 = v18;
                CFDictionarySetValue(a3, v18, Copy);
                CFRelease(v19);
              }
              CFRelease(Copy);
            }
          }
        }
      }
    }
  }
}

uint64_t HSTSPolicy::updateHSTSInfoForHost(HSTSPolicy *this, const __CFString *a2, const __CFDictionary *a3)
{
  if (_HSTSIsDisabled(void)::sDisableHSTSOnce != -1) {
    dispatch_once(&_HSTSIsDisabled(void)::sDisableHSTSOnce, &__block_literal_global_16);
  }
  if (_HSTSIsDisabled(void)::sHSTSIsDisabled || _isIPAddress(a2, 1)) {
    return 0;
  }
  if (!a3 || HSTSParser::getTimeForKey(a3, (const __CFDictionary *)@"Expiry", v6) == 0.0)
  {
    CFTypeID v8 = (HSTSCache *)*((void *)this + 2);
    CFStringRef v9 = a2;
    CFDictionaryRef v10 = 0;
LABEL_10:
    HSTSCache::modifyHSTSStore(v8, v9, v10, 0);
    return 1;
  }
  if (CFStringGetLength(a2) < 2) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a2);
  if (CFStringGetCharacterAtIndex(a2, Length - 1) != 46)
  {
    CFTypeID v8 = (HSTSCache *)*((void *)this + 2);
    CFStringRef v9 = a2;
    CFDictionaryRef v10 = a3;
    goto LABEL_10;
  }
  v13.CFIndex length = CFStringGetLength(a2) - 1;
  v13.location = 0;
  uint64_t result = (uint64_t)CFStringCreateWithSubstring(0, a2, v13);
  if (result)
  {
    CFNumberRef v12 = (const void *)result;
    HSTSCache::modifyHSTSStore(*((HSTSCache **)this + 2), (CFTypeRef)result, a3, 0);
    CFRelease(v12);
    return 1;
  }
  return result;
}

uint64_t HSTSPolicy::handleSTSHeader(HSTSPolicy *this, const __CFString *a2, const __CFURL *a3)
{
  CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
  if (!a2) {
    return 1;
  }
  int v72 = v6;
  CFURLRef v73 = a3;
  CFIndex v74 = this;
  CFIndex Length = CFStringGetLength(a2);
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  CFStringRef theString = a2;
  uint64_t v94 = 0;
  CFIndex v95 = Length;
  int64_t v80 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a2);
  CStringPtr = 0;
  CFStringRef v92 = (UniChar *)CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a2, 0x600u);
  }
  CFTypeRef cf1 = 0;
  CFIndex v11 = 0;
  int v79 = 0;
  int64_t v97 = 0;
  CFStringRef v93 = CStringPtr;
  int64_t v96 = 0;
  CFTypeRef cf2 = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  DoubleCFArrayRef Value = -1.0;
  CFStringRef v77 = a2;
  do
  {
    if (v11 >= v80)
    {
      int v33 = 0;
      int64_t v18 = v11;
LABEL_47:
      int64_t v35 = v18;
      goto LABEL_48;
    }
    BOOL v13 = 0;
    int v14 = 0;
    CFIndex v15 = -v11;
    CFIndex v16 = v11 + 64;
    uint64_t v17 = -1;
    int64_t v18 = v11;
    while (1)
    {
      if ((unint64_t)v18 >= 4) {
        uint64_t v19 = 4;
      }
      else {
        uint64_t v19 = v18;
      }
      if (v18 < 0 || (CFIndex v20 = v95, v95 <= v18))
      {
        UniChar v21 = 0;
        BOOL v22 = !v13;
        goto LABEL_15;
      }
      if (v92)
      {
        UniChar v21 = v92[v18 + v94];
      }
      else if (v93)
      {
        UniChar v21 = v93[v94 + v18];
      }
      else
      {
        if (v97 <= v18 || (int64_t v28 = v96, v96 > v18))
        {
          uint64_t v29 = v19 + v15;
          CFIndex v30 = v16 - v19;
          int64_t v31 = v18 - v19;
          CFIndex v32 = v31 + 64;
          if (v31 + 64 >= v95) {
            CFIndex v32 = v95;
          }
          int64_t v96 = v31;
          int64_t v97 = v32;
          if (v95 >= v30) {
            CFIndex v20 = v30;
          }
          v98.CFIndex length = v20 + v29;
          v98.location = v31 + v94;
          CFStringGetCharacters(theString, v98, buffer);
          int64_t v28 = v96;
        }
        UniChar v21 = buffer[v18 - v28];
      }
      BOOL v22 = !v13;
      if (!v13 && v21 == 59) {
        break;
      }
      if (!v13 && v21 == 44)
      {
        int v33 = 1;
        goto LABEL_45;
      }
LABEL_15:
      int v23 = v21;
      int IsCharacterMember = CFCharacterSetIsCharacterMember(Predefined, v21);
      if (v14) {
        int64_t v25 = v18;
      }
      else {
        int64_t v25 = v17;
      }
      if (v14) {
        CFIndex v26 = v11;
      }
      else {
        CFIndex v26 = v18;
      }
      if (v23 == 34) {
        BOOL v27 = v22;
      }
      else {
        BOOL v27 = v13;
      }
      if (!IsCharacterMember)
      {
        int v14 = 1;
        uint64_t v17 = v25;
        BOOL v13 = v27;
        CFIndex v11 = v26;
      }
      ++v18;
      --v15;
      ++v16;
      if (v80 == v18)
      {
        int v33 = 0;
        int64_t v18 = v80;
        goto LABEL_45;
      }
    }
    int v33 = 0;
LABEL_45:
    BOOL v34 = __CFADD__(v17, 1);
    int64_t v35 = v17 + 1;
    a2 = v77;
    if (v34) {
      goto LABEL_47;
    }
LABEL_48:
    if (v35 - v11 != CFStringGetLength(@"includeSubDomains")
      || (v103.location = v11,
          v103.CFIndex length = v35 - v11,
          !CFStringFindWithOptions(a2, @"includeSubDomains", v103, 9uLL, 0)))
    {
      v104.location = v11;
      v104.CFIndex length = v35 - v11;
      if (!CFStringFindWithOptions(a2, @"max-age", v104, 9uLL, &result)) {
        goto LABEL_134;
      }
      if (v79) {
        return 1;
      }
      CFIndex v38 = result.length + result.location;
      while (2)
      {
        if (v38 >= v35)
        {
LABEL_132:
          int v79 = 1;
          goto LABEL_134;
        }
        if (v38 < 0 || (int64_t v39 = v95, v95 <= v38))
        {
          UniChar v42 = 0;
        }
        else
        {
          std::string::size_type v40 = v92;
          if (v92)
          {
            CFIndex v41 = v94 + v38;
            goto LABEL_61;
          }
          if (v93)
          {
            UniChar v42 = v93[v94 + v38];
          }
          else
          {
            if (v97 <= v38 || (int64_t v46 = v96, v96 > v38))
            {
              CFIndex v47 = v38 - 4;
              if ((unint64_t)v38 < 4) {
                CFIndex v47 = 0;
              }
              if (v47 + 64 < v95) {
                int64_t v39 = v47 + 64;
              }
              int64_t v96 = v47;
              int64_t v97 = v39;
              v99.location = v94 + v47;
              v99.CFIndex length = v39 - v47;
              CFStringGetCharacters(theString, v99, buffer);
              int64_t v46 = v96;
            }
            CFIndex v41 = v38 - v46;
            std::string::size_type v40 = buffer;
LABEL_61:
            UniChar v42 = v40[v41];
          }
          if (v42 == 61)
          {
            do
            {
              if (++v38 >= v35) {
                goto LABEL_64;
              }
              UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(a2, v38);
            }
            while (CFCharacterSetIsCharacterMember(Predefined, CharacterAtIndex));
            int64_t v44 = v95;
            if (v38 - 1 >= -1 && v95 > v38)
            {
              if (v92)
              {
                UniChar v45 = v92[v94 + v38];
              }
              else if (v93)
              {
                UniChar v45 = v93[v94 + v38];
              }
              else
              {
                if (v97 <= v38 || (int64_t v48 = v96, v96 > v38))
                {
                  CFIndex v49 = v38 - 4;
                  if ((unint64_t)v38 < 4) {
                    CFIndex v49 = 0;
                  }
                  if (v49 + 64 < v95) {
                    int64_t v44 = v49 + 64;
                  }
                  int64_t v96 = v49;
                  int64_t v97 = v44;
                  v100.location = v94 + v49;
                  v100.CFIndex length = v44 - v49;
                  CFStringGetCharacters(theString, v100, buffer);
                  int64_t v44 = v95;
                  int64_t v48 = v96;
                }
                UniChar v45 = buffer[v38 - v48];
              }
              if (v45 == 34) {
                ++v38;
              }
            }
            if (v44 <= v35)
            {
              UniChar v50 = 0;
            }
            else if (v92)
            {
              UniChar v50 = v92[v94 + v35];
            }
            else if (v93)
            {
              UniChar v50 = v93[v94 + v35];
            }
            else
            {
              if (v97 <= v35 || (int64_t v60 = v96, v96 > v35))
              {
                int64_t v61 = v35 - 4;
                if ((unint64_t)v35 < 4) {
                  int64_t v61 = 0;
                }
                if (v61 + 64 < v44) {
                  int64_t v44 = v61 + 64;
                }
                int64_t v96 = v61;
                int64_t v97 = v44;
                v101.location = v94 + v61;
                v101.CFIndex length = v44 - v61;
                CFStringGetCharacters(theString, v101, buffer);
                int64_t v44 = v95;
                int64_t v60 = v96;
              }
              UniChar v50 = buffer[v35 - v60];
            }
            unint64_t v51 = v35 - 1;
            if (v44 < v35)
            {
              UniChar v52 = 0;
              goto LABEL_107;
            }
            std::string v53 = v92;
            if (v92)
            {
              unint64_t v54 = v94 + v51;
              goto LABEL_102;
            }
            if (v93)
            {
              UniChar v52 = v93[v94 + v51];
            }
            else
            {
              if (v97 < v35 || (int64_t v62 = v96, v96 >= v35))
              {
                int64_t v63 = v35 - 5;
                if (v51 < 4) {
                  int64_t v63 = 0;
                }
                if (v63 + 64 < v44) {
                  int64_t v44 = v63 + 64;
                }
                int64_t v96 = v63;
                int64_t v97 = v44;
                v102.location = v94 + v63;
                v102.CFIndex length = v44 - v63;
                CFStringGetCharacters(theString, v102, buffer);
                int64_t v62 = v96;
              }
              unint64_t v54 = v51 - v62;
              std::string v53 = buffer;
LABEL_102:
              UniChar v52 = v53[v54];
            }
LABEL_107:
            if (v50 == 34) {
              int64_t v55 = v35 - 1;
            }
            else {
              int64_t v55 = v35;
            }
            int64_t v35 = v55 - (v52 == 34);
            v105.CFIndex length = v35 - v38;
            v105.location = v38;
            CFStringRef v56 = CFStringCreateWithSubstring(alloc, a2, v105);
            v85[0] = MEMORY[0x1E4F143A8];
            v85[1] = 3221225472;
            uint64_t v86 = ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke;
            CFStringRef v87 = &__block_descriptor_40_e5_v8__0l;
            CFStringRef v88 = v56;
            if (v56)
            {
              CFStringRef v57 = v56;
              CFCharacterSetRef v58 = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
              CFCharacterSetRef InvertedSet = CFCharacterSetCreateInvertedSet(0, v58);
              v81[0] = MEMORY[0x1E4F143A8];
              v81[1] = 3221225472;
              CFStringRef v82 = ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke_2;
              CFStringRef v83 = &__block_descriptor_40_e5_v8__0l;
              CFCharacterSetRef v84 = InvertedSet;
              v106.CFIndex length = CFStringGetLength(v57);
              v106.location = 0;
              if (!CFStringFindCharacterFromSet(v57, InvertedSet, v106, 0, 0))
              {
                DoubleCFArrayRef Value = CFStringGetDoubleValue(v57);
                if (DoubleValue > 1.79769313e308) {
                  DoubleCFArrayRef Value = 1.79769313e308;
                }
              }
              v82((uint64_t)v81);
              v86((uint64_t)v85);
            }
            else
            {
              ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke((uint64_t)v85);
            }
            goto LABEL_64;
          }
        }
        if (!CFCharacterSetIsCharacterMember(Predefined, v42)) {
          goto LABEL_132;
        }
LABEL_64:
        ++v38;
        continue;
      }
    }
    std::string::size_type v37 = cf1;
    if (!cf1)
    {
      CFTypeRef cf1 = cf2;
      goto LABEL_134;
    }
    CFTypeRef cf1 = cf2;
    if (CFEqual(v37, cf2)) {
      return 1;
    }
LABEL_134:
    if (v18 == v80) {
      break;
    }
    CFIndex v11 = v18 + 1;
  }
  while (!v33);
  if (DoubleValue < 0.0) {
    return 1;
  }
  if (cf1)
  {
    CFTypeID v66 = CFGetTypeID(cf1);
    if (v66 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      buffer[0] = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)buffer, 2u);
    }
    BOOL v67 = cf2 == cf1;
  }
  else
  {
    BOOL v67 = 0;
  }
  uint64_t updated = 1;
  CFDictionaryRef HSTSInfo = HSTSParser::createHSTSInfo(v72, (const __CFAllocator *)v67, DoubleValue, 1, 0, v36);
  if (HSTSInfo)
  {
    CFDictionaryRef v69 = HSTSInfo;
    CFStringRef v70 = CFURLCopyHostName(v73);
    if (v70)
    {
      CFStringRef v71 = v70;
      uint64_t updated = HSTSPolicy::updateHSTSInfoForHost(v74, v70, v69);
      CFRelease(v71);
    }
    else
    {
      uint64_t updated = 0;
    }
    CFRelease(v69);
  }
  return updated;
}

void sub_18418B098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,void (*a30)(char *))
{
}

void NotificationStation::notifyPropertyChanged(NotificationStation *this, const __CFString *value, const void *a3)
{
  if (!*((unsigned char *)this + 88))
  {
    CFSetRef v20 = (const __CFSet *)*((void *)this + 9);
    if (!v20 || !CFSetContainsValue(v20, value)) {
      return;
    }
  }
  CFAllocatorRef v6 = (std::mutex *)((char *)this + 8);
  std::mutex::lock((std::mutex *)((char *)this + 8));
  uint64_t v7 = *(void *)this;
  if (*(void *)this)
  {
    if (value) {
      CFRetain(value);
    }
    v21[0] = value;
    v21[1] = (CFStringRef)CFTypeRefRelease<__CFString const*>;
    uint64_t v8 = std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::find<std::unique_ptr<__CFString const,void (*)(__CFString const*)>>(v7, v21);
    if (value) {
      CFTypeRefRelease<__CFString const*>(value);
    }
    if (*(void *)this + 8 != v8)
    {
      CFStringRef v9 = *(void ***)(v8 + 48);
      CFDictionaryRef v10 = *v9;
      while (v10 != v9[1])
      {
        CFIndex v11 = (std::__shared_weak_count *)v10[1];
        if (v11)
        {
          CFNumberRef v12 = std::__shared_weak_count::lock(v11);
          if (v12 && *v10)
          {
            (*(void (**)(void, const __CFString *, const void *))(*(void *)*v10 + 16))(*v10, value, a3);
            v10 += 2;
LABEL_26:
            std::__shared_weak_count::__release_shared[abi:nn180100](v12);
            goto LABEL_27;
          }
        }
        else
        {
          CFNumberRef v12 = 0;
        }
        uint64_t v13 = *(void *)(v8 + 48);
        int v14 = v10 + 2;
        CFIndex v15 = *(void **)(v13 + 8);
        if (v10 + 2 == v15)
        {
          CFIndex v16 = v10;
        }
        else
        {
          do
          {
            CFIndex v16 = v14;
            long long v17 = *(_OWORD *)v14;
            void *v14 = 0;
            v14[1] = 0;
            int64_t v18 = (std::__shared_weak_count *)*(v14 - 1);
            *((_OWORD *)v14 - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v17;
            if (v18) {
              std::__shared_weak_count::__release_weak(v18);
            }
            v14 += 2;
          }
          while (v16 + 2 != v15);
          int v14 = *(void **)(v13 + 8);
        }
        while (v14 != v16)
        {
          uint64_t v19 = (std::__shared_weak_count *)*(v14 - 1);
          if (v19) {
            std::__shared_weak_count::__release_weak(v19);
          }
          v14 -= 2;
        }
        *(void *)(v13 + 8) = v16;
        if (v12) {
          goto LABEL_26;
        }
LABEL_27:
        CFStringRef v9 = *(void ***)(v8 + 48);
      }
    }
  }

  std::mutex::unlock(v6);
}

void sub_18418B2AC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

CFTypeID CFHTTPMessageGetTypeID(void)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  return *(void *)(HTTPMessage::Class(void)::sClass_OBJTYPE + 96);
}

CFHTTPMessageRef CFHTTPMessageCreateRequest(CFAllocatorRef alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = (HTTPRequestMessage *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v8 = (HTTPRequestMessage *)(Instance + 16);
    *(void *)(Instance + 192) = 0;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  HTTPMethodMixedValue::HTTPMethodMixedValue((HTTPMethodMixedValue *)&v12, requestMethod);
  HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v10, httpVersion);
  HTTPRequestMessage::HTTPRequestMessage(v8, &v12, url, cf);
  CFDictionaryRef v10 = &unk_1ECF9F718;
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef v12 = &unk_1ECF9F718;
  if (v13) {
    CFRelease(v13);
  }
  return (HTTPRequestMessage *)((char *)v8 - 16);
}

void sub_18418B45C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf, uint64_t a11, CFTypeRef a12)
{
  if (cf) {
    CFRelease(cf);
  }
  if (a12) {
    CFRelease(a12);
  }
  _Unwind_Resume(exception_object);
}

Boolean CFHTTPMessageIsRequest(CFHTTPMessageRef message)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t v2 = (char *)message + 16;
  if (!message) {
    uint64_t v2 = 0;
  }
  return v2[24] == 0;
}

void CFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData)
{
  if (!bodyData || (CFTypeID v3 = CFGetTypeID(bodyData), v3 == CFDataGetTypeID()))
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (message) {
      BOOL v4 = (char *)message + 16;
    }
    else {
      BOOL v4 = 0;
    }
    uint64_t v5 = *(void (**)(void))(*(void *)v4 + 64);
    v5();
  }
}

void _CFHTTPMessageAddHeaderFieldValue(uint64_t a1, __CFString *a2, __CFString *a3)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (a1) {
    CFAllocatorRef v6 = (HTTPMessage *)(a1 + 16);
  }
  else {
    CFAllocatorRef v6 = 0;
  }

  HTTPMessage::addHeaderFieldStringValue(v6, a2, a3);
}

Boolean CFHTTPMessageIsHeaderComplete(CFHTTPMessageRef message)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t v2 = (char *)message + 16;
  if (!message) {
    uint64_t v2 = 0;
  }
  return *((void *)v2 + 11) == 0;
}

CFDataRef CFHTTPMessageCopySerializedMessage(CFHTTPMessageRef message)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (message) {
    uint64_t v2 = (CFHTTPMessageRef)((char *)message + 16);
  }
  else {
    uint64_t v2 = 0;
  }
  CFTypeID v3 = HTTPMessage::copySerializedHeaders(v2, 0);
  if (v3)
  {
    CFDataRef v5 = v3;
    CFAllocatorRef v6 = (const __CFData **)*((void *)v2 + 6);
    if (!v6) {
      return v5;
    }
    CFDataRef Length = HTTPBodyData::getLength(v6, v4);
    CFAllocatorRef v8 = CFGetAllocator((char *)v2 - 16);
    CFIndex v9 = CFDataGetLength(v5);
    MutableCFDictionaryRef Copy = CFDataCreateMutableCopy(v8, (CFIndex)Length + v9, v5);
    CFRelease(v5);
    CFIndex v11 = (HTTPBodyData *)*((void *)v2 + 6);
    HTTPBodyData::logit(v11, v12);
    CFDataRef v13 = (const __CFData *)*((void *)v11 + 2);
    if (v13 || (CFDataRef v13 = (const __CFData *)*((void *)v11 + 3)) != 0) {
      BytePtr = CFDataGetBytePtr(v13);
    }
    else {
      BytePtr = 0;
    }
    CFDataAppendBytes(MutableCopy, BytePtr, (CFIndex)Length);
    if (!message) {
      return MutableCopy;
    }
  }
  else
  {
    MutableCFDictionaryRef Copy = 0;
    if (!message) {
      return MutableCopy;
    }
  }
  if (MutableCopy) {
    return MutableCopy;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (!*((unsigned char *)message + 40)) {
    return 0;
  }
  if (*((void *)message + 38)) {
    return 0;
  }
  if (*((unsigned char *)message + 176)) {
    return 0;
  }
  int v16 = *((_DWORD *)message + 36);
  if (v16 != 200 && v16 != -1) {
    return 0;
  }
  CFAllocatorRef v17 = CFGetAllocator(message);

  return CFDataCreate(v17, (const UInt8 *)"\r\n\r\n", 4);
}

CFStringRef CFHTTPMessageCopyResponseStatusLine(CFHTTPMessageRef response)
{
  if (!response) {
    return 0;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (!*((unsigned char *)response + 40)) {
    return 0;
  }
  uint64_t v2 = *((void *)response + 38);
  if (v2 || *((unsigned char *)response + 176))
  {
    if (v2) {
      CFTypeID v3 = (const char *)*((void *)response + 38);
    }
    else {
      CFTypeID v3 = (char *)response + 176;
    }
  }
  else
  {
    CFTypeID v3 = (const char *)(*(uint64_t (**)(char *, void))(*((void *)response + 2) + 88))((char *)response + 16, 0);
  }
  if (v3) {
    BOOL v4 = v3;
  }
  else {
    BOOL v4 = "";
  }
  CFAllocatorRef v5 = CFGetAllocator(response);

  return CFStringCreateWithCString(v5, v4, 0x201u);
}

void _CFHTTPMessageSetResponseProxyURL(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*(unsigned char *)(a1 + 40))
    {
      HTTPResponseMessage::setResponseURL((HTTPResponseMessage *)(a1 + 16), cf, 1);
    }
  }
}

uint64_t _CFHTTPMessageGetAuthentication(__CFHTTPMessage *a1, int a2)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  BOOL v4 = (char *)a1 + 16;
  if (!a1) {
    BOOL v4 = 0;
  }
  uint64_t v5 = 80;
  if (!a2) {
    uint64_t v5 = 72;
  }
  return *(void *)&v4[v5];
}

CFTypeRef _CFHTTPMessageSetAuthentication(__CFHTTPMessage *a1, CFTypeRef cf, int a3)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (a1) {
    CFAllocatorRef v6 = (char *)a1 + 16;
  }
  else {
    CFAllocatorRef v6 = 0;
  }
  if (a3) {
    uint64_t v7 = 80;
  }
  else {
    uint64_t v7 = 72;
  }
  CFTypeRef result = *(CFTypeRef *)&v6[v7];
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)&v6[v7] = result;
  }
  return result;
}

void sub_18418BB8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_48c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void _CFHSTSPolicyResetHSTSHostsSinceDate(uint64_t a1, CFTypeRef a2)
{
  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1) {
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
  }
  uint64_t v4 = a1 + 16;
  if (!a1) {
    uint64_t v4 = 0;
  }
  uint64_t v5 = *(HSTSCache **)(v4 + 16);

  HSTSCache::modifyHSTSStore(v5, 0, 0, a2);
}

void std::__shared_ptr_pointer<__CFString *,Deleter_CFRelease,std::allocator<__CFString>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void __Block_byref_object_copy__604(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__605(uint64_t a1)
{
}

uint64_t ___ZL13countSegmentsPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1)
{
  return 1;
}

void sub_18418E570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL17resumeDataClassesv_block_invoke()
{
  CFStringRef v0 = (void *)MEMORY[0x1E4F1CA80];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  resumeDataClasses(void)::resumeDataClasses = (uint64_t)(id)objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, objc_opt_class(), 0);
  gotLoadHelper_x20__OBJC_CLASS___SZExtractor(v7);
  if (objc_opt_class())
  {
    uint64_t v8 = [*(id *)(v1 + 2640) knownSZExtractorImplementations];
    [(id)resumeDataClasses(void)::resumeDataClasses unionSet:v8];
  }
  uint64_t result = objc_opt_class();
  if (result)
  {
    CFIndex v11 = (void *)resumeDataClasses(void)::resumeDataClasses;
    gotLoadHelper_x8__OBJC_CLASS___STRemoteExtractor(v10);
    uint64_t v12 = objc_opt_class();
    return [v11 addObject:v12];
  }
  return result;
}

uint64_t BlockHolderVar<>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void ___ZN14HTTPStallTimer5setupEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 40);
        if (v6)
        {
          if (*(void *)(v6 + 16))
          {
            std::__tree<std::shared_ptr<void>>::destroy(*(void **)(v6 + 8));
            *(void *)uint64_t v6 = v6 + 8;
            *(void *)(v6 + 16) = 0;
            *(void *)(v6 + 8) = 0;
            uint64_t v7 = *(void *)(v5 + 48);
            if (v7)
            {
              uint64_t v8 = *(void (**)(void *))(v7 + 8);
              uint64_t v9 = *(void *)(v7 + 16);
              double v10 = (void *)(v7 + (v9 >> 1));
              if (v9) {
                uint64_t v8 = *(void (**)(void *))(*v10 + v8);
              }
              v8(v10);
            }
          }
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_18418ECF4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void sub_18418EED8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'TunnelProxy<HTTPEngine>::errorOccurred(uint64_t result, uint64_t a2, int a3)
{
  if (!*(_DWORD *)(result + 104))
  {
    *(void *)(result + 96) = a2;
    *(_DWORD *)(result + 104) = a3;
    TunnelProxy<HTTPEngine>::newConnectionRequired(result - 104);
  }
  return result;
}

void TunnelProxy<HTTPEngine>::newConnectionRequired(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 120);
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  ++*(_DWORD *)(a1 + 272);
  *(unsigned char *)(a1 + 97) = 1;
  TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(&v4, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16), a1);
  long long v3 = v4;
  long long v4 = 0uLL;
  TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion(a1, v3, *((std::__shared_weak_count **)&v3 + 1), 1, *(void *)(a1 + 200), *(void *)(a1 + 208));
}

void sub_18418F010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(void *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v7, a2, a3);
  uint64_t v6 = v8;
  *a1 = a4;
  a1[1] = v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
  }
}

void TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a3)
  {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v7 = *(void *)(a1 + 240);
    if (!v7) {
      goto LABEL_13;
    }
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 240);
    if (!v7) {
      goto LABEL_14;
    }
  }
  uint64_t v8 = *(void (**)(void *, uint64_t *, uint64_t, uint64_t, uint64_t))(v7 + 8);
  uint64_t v9 = *(void *)(v7 + 16);
  double v10 = (void *)(v7 + (v9 >> 1));
  if (v9) {
    uint64_t v8 = *(void (**)(void *, uint64_t *, uint64_t, uint64_t, uint64_t))(*v10 + v8);
  }
  uint64_t v11 = a2;
  uint64_t v12 = a3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v8(v10, &v11, a4, a5, a6);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  if (!a3) {
LABEL_14:
  }
    SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::SmartBlockWithArgs();
  std::__shared_weak_count::__release_shared[abi:nn180100](a3);
LABEL_13:
  std::__shared_weak_count::__release_shared[abi:nn180100](a3);
  goto LABEL_14;
}

void sub_18418F17C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_initial(uint64_t *a1, uint64_t *a2)
{
  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_normal;
  a1[2] = 0;
  uint64_t v2 = *a1;
  long long v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  uint64_t v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_18418F258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'TunnelProxy<HTTPEngine>::~TunnelProxy(uint64_t a1)
{
  TunnelProxy<HTTPEngine>::~TunnelProxy((NetworkProxy *)(a1 - 104));

  JUMPOUT(0x18531B6D0);
}

{
  TunnelProxy<HTTPEngine>::~TunnelProxy((NetworkProxy *)(a1 - 104));
}

void TunnelProxy<HTTPEngine>::~TunnelProxy(NetworkProxy *this)
{
  *(void *)this = &unk_1ECF9B118;
  *((void *)this + 13) = &unk_1ECF9B1C0;
  uint64_t v2 = *((void *)this + 24);
  if (v2) {
    dispatch_release(v2);
  }
  long long v3 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 31);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 28);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 19);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  double v10 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }

  NetworkProxy::~NetworkProxy(this);
}

void NetworkProxy::~NetworkProxy(NetworkProxy *this)
{
  *(void *)this = &unk_1ECF9BE20;
  uint64_t v2 = (const void *)*((void *)this + 11);
  *((void *)this + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  if (v2) {
    CFRelease(v2);
  }
  long long v3 = (const void *)*((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  *(void *)this = &unk_1ECF9B550;
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

{
  uint64_t vars8;

  NetworkProxy::~NetworkProxy(this);

  JUMPOUT(0x18531B6D0);
}

uint64_t TunnelProxy<HTTPEngine>::errorOccurred(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(_DWORD *)(a1 + 208))
  {
    *(void *)(a1 + 200) = a2;
    *(_DWORD *)(a1 + 208) = a3;
    TunnelProxy<HTTPEngine>::newConnectionRequired(a1);
  }
  return a1;
}

uint64_t TunnelProxy<HTTPEngine>::proxyResponseData(uint64_t a1)
{
  return *(void *)(a1 + 192);
}

uint64_t TunnelProxy<HTTPEngine>::proxyResponse(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 176);
  if (v1) {
    return v1 - 16;
  }
  else {
    return 0;
  }
}

void TunnelProxy<HTTPEngine>::continueProxyEstablishment(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (!*(_DWORD *)(a1 + 208))
  {
    *(unsigned char *)(a1 + 97) = 0;
    uint64_t v14 = *a3;
    CFIndex v15 = (std::__shared_weak_count *)a3[1];
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      TunnelProxy<HTTPEngine>::setTunnelEstablishedCompletion(a1, v14, (uint64_t)v15);
      std::__shared_weak_count::__release_shared[abi:nn180100](v15);
    }
    else
    {
      TunnelProxy<HTTPEngine>::setTunnelEstablishedCompletion(a1, v14, 0);
    }
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<HTTPEngine::HTTPEngineDelegate,TunnelProxy<HTTPEngine>>(&v17, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16), a1);
    std::allocate_shared[abi:nn180100]<HTTPEngine,std::allocator<HTTPEngine>,std::shared_ptr<TransportConnection> &,std::shared_ptr<HTTPEngine::HTTPEngineDelegate>,void>((uint64_t *)&v19, *(void *)a2, *(std::__shared_weak_count **)(a2 + 8), &v17);
    int v16 = *(std::__shared_weak_count **)(a1 + 120);
    *(_OWORD *)(a1 + 112) = v19;
    if (v16) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v16);
    }
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v18);
    }
    HTTPEngine::initialize(*(void *)(a1 + 112));
  }
  TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(&v17, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16), a1);
  uint64_t v5 = v18;
  uint64_t v6 = *a3;
  if (!*a3)
  {
    if (!v18) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  uint64_t v7 = v17;
  uint64_t v8 = *(void *)(a1 + 200);
  uint64_t v9 = *(void *)(a1 + 208);
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  double v10 = *(void (**)(void *, long long *, void, uint64_t, uint64_t))(v6 + 8);
  uint64_t v11 = *(void *)(v6 + 16);
  uint64_t v12 = (void *)(v6 + (v11 >> 1));
  if (v11) {
    double v10 = *(void (**)(void *, long long *, void, uint64_t, uint64_t))(*v12 + v10);
  }
  *(void *)&long long v19 = v7;
  *((void *)&v19 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v10(v12, &v19, 0, v8, v9);
  if (*((void *)&v19 + 1)) {
    std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v19 + 1));
  }
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
LABEL_18:
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
LABEL_19:
  *(void *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 208) = 0;
}

void sub_18418F62C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void TunnelProxy<HTTPEngine>::setTunnelEstablishedCompletion(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 248);
  *(void *)(a1 + 240) = a2;
  *(void *)(a1 + 248) = a3;
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    a2 = *(void *)(a1 + 240);
  }
  if (a2)
  {
    *(void *)(a2 + 8) = BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_normal;
    *(void *)(a2 + 16) = 0;
  }
}

void TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<HTTPEngine::HTTPEngineDelegate,TunnelProxy<HTTPEngine>>(void *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v8, a2, a3);
  uint64_t v6 = a4 + 104;
  uint64_t v7 = v9;
  if (!a4) {
    uint64_t v6 = 0;
  }
  *a1 = v6;
  a1[1] = v7;
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
    }
  }
}

void std::allocate_shared[abi:nn180100]<HTTPEngine,std::allocator<HTTPEngine>,std::shared_ptr<TransportConnection> &,std::shared_ptr<HTTPEngine::HTTPEngineDelegate>,void>(uint64_t *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4)
{
  uint64_t v8 = operator new(0x178uLL);
  uint64_t v9 = v8;
  v8[1] = 0;
  _DWORD v8[2] = 0;
  *uint64_t v8 = &unk_1ECFA6528;
  uint64_t v10 = (uint64_t)(v8 + 3);
  v14[0] = a2;
  v14[1] = (uint64_t)a3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *a4;
  uint64_t v12 = (std::__shared_weak_count *)a4[1];
  v13[0] = v11;
  v13[1] = (uint64_t)v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  HTTPEngine::HTTPEngine((uint64_t)(v8 + 3), v14, v13);
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  if (a3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a3);
  }
  *a1 = v10;
  a1[1] = (uint64_t)v9;

  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)a1, v9 + 4, v10);
}

void sub_18418F810(_Unwind_Exception *a1)
{
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v5);
  _Unwind_Resume(a1);
}

uint64_t TunnelProxy<HTTPEngine>::completeTask(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 272) - 1;
  *(_DWORD *)(result + 272) = v1;
  if (!v1)
  {
    uint64_t v2 = *(void *)(result + 256);
    if (v2)
    {
      long long v3 = *(void (**)(void *, uint64_t))(v2 + 8);
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = (void *)(v2 + (v4 >> 1));
      if (v4) {
        long long v3 = *(void (**)(void *, uint64_t))(*v5 + v3);
      }
      v3(v5, 1);
    }
    SmartBlockWithArgs<BOOL>::SmartBlockWithArgs();
  }
  return result;
}

void SmartBlockWithArgs<BOOL>::SmartBlockWithArgs()
{
}

void sub_18418F9B0(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void TunnelProxy<HTTPEngine>::establishTunnel(uint64_t a1)
{
}

void sub_18418FA88(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a3)
  {
    uint64_t v4 = *(void (**)(void))(*(void *)v3 + 144);
    v4();
  }
  else
  {
    ++*(_DWORD *)(v3 + 272);
    uint64_t v5 = *(void *)(v3 + 112);
    uint64_t v6 = *(void *)(v3 + 160);
    uint64_t v7 = *(std::__shared_weak_count **)(v3 + 168);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_2;
    v9[3] = &__block_descriptor_40_e93_v40__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8___qi_24l;
    v9[4] = v3;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    _DWORD v8[2] = ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_3;
    v8[3] = &__block_descriptor_40_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
    v8[4] = v3;
    HTTPEngine::readResponse(v5, v6, (uint64_t)v7, 0, v9, v8, &__block_literal_global_726);
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
  }
}

void sub_18418FBE4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_2(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  if (a4)
  {
    uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 144);
    uint64_t v6 = *(void *)(a1 + 32);
    v5(v6, a3, a4);
  }
  else
  {
    uint64_t v7 = *a2;
    uint64_t v8 = a2[1];
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = *(std::__shared_weak_count **)(v4 + 184);
    *(void *)(v4 + 176) = v7;
    *(void *)(v4 + 184) = v8;
    if (v9)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
      uint64_t v7 = *(void *)(v4 + 176);
    }
    int v10 = *(_DWORD *)(v7 + 128);
    if (v10 == 407)
    {
      if (!*(void *)(v4 + 144))
      {
        uint64_t v11 = operator new(0x50uLL);
        v11[1] = 0;
        v11[2] = 0;
        *uint64_t v11 = &unk_1ECFA6560;
        v11[3] = &unk_1ECF9A9A0;
        *((_OWORD *)v11 + 2) = 0u;
        *((_OWORD *)v11 + 3) = 0u;
        *((_OWORD *)v11 + 4) = 0u;
        *(void *)&long long v12 = v11 + 3;
        *((void *)&v12 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v11;
        CFDataRef v13 = *(std::__shared_weak_count **)(v4 + 152);
        *(_OWORD *)(v4 + 144) = v12;
        if (v13) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v13);
        }
      }
      ++*(_DWORD *)(v4 + 272);
      uint64_t v14 = *(void *)(v4 + 224);
      if (v14) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
      }
      std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v26, *(void *)(v4 + 8), *(std::__shared_weak_count **)(v4 + 16));
      uint64_t v15 = *(void *)(v4 + 168);
      if (v15) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v16 = *(void *)(v4 + 184);
      if (v16) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
      }
      *(void *)int buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke;
      int64_t v28 = &__block_descriptor_40_e91_v40__0_shared_ptr_HTTPRequestMessage____HTTPRequestMessage_____shared_weak_count__8___qi_24l;
      uint64_t v29 = v4;
      SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::SmartBlockWithArgs();
    }
    if (v10 != 200)
    {
      uint64_t v17 = *(void *)(v4 + 112);
      uint64_t v19 = *(void *)(v17 + 56);
      uint64_t v18 = *(void *)(v17 + 64);
      if (v18) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
      }
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFSetRef v20 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        if (v19) {
          uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 256))(v19);
        }
        else {
          uint64_t v25 = 0;
        }
        *(_DWORD *)int buf = 134218240;
        *(void *)&uint8_t buf[4] = v25;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v10;
        _os_log_error_impl(&dword_184085000, v20, OS_LOG_TYPE_ERROR, "HTTPS Proxy Connection [%llu] received status code %d", buf, 0x12u);
      }
      if ((v10 - 300) >= 0x64) {
        int v21 = -2096;
      }
      else {
        int v21 = -2098;
      }
      *(void *)(v4 + 200) = 4;
      *(_DWORD *)(v4 + 208) = v21;
      TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(buf, *(void *)(v4 + 8), *(std::__shared_weak_count **)(v4 + 16), v4);
      long long v22 = *(_OWORD *)buf;
      *(void *)int buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion(v4, v22, *((std::__shared_weak_count **)&v22 + 1), 0, *(void *)(v4 + 200), *(void *)(v4 + 208));
    }
    HTTPEngine::setProperty(*(HTTPEngine **)(v4 + 112), (CFStringRef)&unk_1EC0A3768, (const void *)*MEMORY[0x1E4F1CFD0]);
    CFAllocatorRef v24 = *(HTTPMessage **)(v4 + 176);
    int v23 = (HTTPMessage **)(v4 + 176);
    HTTPMessage::ensureParserFinished(v24);
    HTTPMessage::removeHeaderFieldValue(*v23, 0x143153CAu);
    HTTPMessage::removeHeaderFieldValue(*v23, 0x144173D0u);
  }
}

void sub_184190058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_3(uint64_t a1, dispatch_object_t object, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8 = *(void *)(a1 + 32);
  if (object)
  {
    int v10 = *(NSObject **)(v8 + 192);
    if (!v10)
    {
      dispatch_retain(object);
      *(void *)(v8 + 192) = object;
      if (a4) {
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    *(void *)(v8 + 192) = dispatch_data_create_concat(*(dispatch_data_t *)(v8 + 192), object);
    dispatch_release(v10);
  }
  if (a4)
  {
LABEL_5:
    uint64_t v11 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 144);
    v11(v8, a3, a4);
    return;
  }
LABEL_9:
  if (!a5) {
    return;
  }
  long long v12 = *(HTTPMessage **)(v8 + 176);
  if (*((_DWORD *)v12 + 32) == 200)
  {
    TunnelProxy<HTTPEngine>::completeTask(v8, 1);
    CFDataRef v13 = *(std::__shared_weak_count **)(v8 + 152);
    *(void *)(v8 + 144) = 0;
    *(void *)(v8 + 152) = 0;
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v13);
    }
    uint64_t v14 = *(std::__shared_weak_count **)(v8 + 224);
    *(void *)(v8 + 216) = 0;
    *(void *)(v8 + 224) = 0;
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v14);
    }
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(&v23, *(void *)(v8 + 8), *(std::__shared_weak_count **)(v8 + 16), v8);
    long long v15 = v23;
    long long v23 = 0uLL;
    TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion(v8, v15, *((std::__shared_weak_count **)&v15 + 1), 0, 0, 0);
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  CFStringRef v16 = HTTPMessage::copyHeaderFieldValue(v12, 0x13921375u);
  CFStringRef v17 = v16;
  if (v16 && CFStringCompare(v16, @"close", 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(v17);
    goto LABEL_31;
  }
  uint64_t v18 = *(HTTPMessage **)(v8 + 176);
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  CFStringRef v19 = HTTPMessage::copyHeaderFieldValue(v18, 0x11B152B9u);
  CFStringRef v20 = v19;
  if (v19)
  {
    CFComparisonResult v21 = CFStringCompare(v19, @"close", 1uLL);
    CFRelease(v20);
    if (v17) {
      CFRelease(v17);
    }
    if (v21 == kCFCompareEqualTo)
    {
LABEL_31:
      HTTPEngine::_cleanupConnection(*(HTTPEngine **)(v8 + 112), 0);
      TunnelProxy<HTTPEngine>::newConnectionRequired(v8);
    }
  }
  else if (v17)
  {
    CFRelease(v17);
  }
  BOOL v22 = *(_DWORD *)(v8 + 208) != 0;

  TunnelProxy<HTTPEngine>::completeTask(v8, v22);
}

void sub_18419037C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  CFRelease(v11);
  if (v10) {
    CFRelease(v10);
  }
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<__CFDictionary const*,Deleter_CFRelease,std::allocator<__CFDictionary const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!a4 || a4 == -1002)
  {
    uint64_t v6 = *a2;
    uint64_t v5 = a2[1];
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v7 = *(std::__shared_weak_count **)(v4 + 168);
    *(void *)(v4 + 160) = v6;
    *(void *)(v4 + 168) = v5;
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
    SmartBlockWithArgs<BOOL>::SmartBlockWithArgs();
  }
  *(_DWORD *)(v4 + 208) = a4;
  *(void *)(v4 + 200) = a3;
  TunnelProxy<HTTPEngine>::completeTask(v4, 1);
  TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(&v9, *(void *)(v4 + 8), *(std::__shared_weak_count **)(v4 + 16), v4);
  long long v8 = v9;
  long long v9 = 0uLL;
  TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion(v4, v8, *((std::__shared_weak_count **)&v8 + 1), 0, *(void *)(v4 + 200), *(void *)(v4 + 208));
}

void sub_18419054C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 24);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  _Unwind_Resume(exception_object);
}

void SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::SmartBlockWithArgs()
{
}

void sub_184190638(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v3 = *(void (**)(uint64_t *, uint64_t *))(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | (unint64_t)v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if (v3 == BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial && v5 != 0)
  {
    uint64_t v7 = (void *)(v1 + (v2 >> 1));
    if (v2) {
      long long v8 = *(void (**)(uint64_t *, uint64_t *))(*v7
    }
                                                       + BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial);
    else {
      long long v8 = BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial;
    }
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    ((void (*)(void *, uint64_t *, void, void))v8)(v7, &v10, 0, 0);
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
  }
  _Block_release(*(const void **)v1);
  return MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
}

void sub_184190740(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial(uint64_t *a1, uint64_t *a2)
{
  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_normal;
  a1[2] = 0;
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  int v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184190804(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_normal(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  int v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_184190878(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

double ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke_2(uint64_t a1, int a2)
{
  if (a2)
  {
    double result = NAN;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 112) + 176) = xmmword_1843D16E0;
  }
  return result;
}

uint64_t std::__shared_ptr_emplace<AuthLiaison>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<AuthLiaison>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6560;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<AuthLiaison>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6560;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL> *,SmartBlockWithArgs<BOOL>::Deleter,std::allocator<BlockHolderVar<BOOL>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<BOOL>::invoke_initial && v5 != 0)
  {
    uint64_t v7 = (void *)(v1 + (v2 >> 1));
    if (v2) {
      (*(void (**)(void *, void))(*v7 + BlockHolderVar<BOOL>::invoke_initial))(v7, 0);
    }
    else {
      ((void (*)(void *, void))BlockHolderVar<BOOL>::invoke_initial)(v7, 0);
    }
  }
  _Block_release(*(const void **)v1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL> *,SmartBlockWithArgs<BOOL>::Deleter,std::allocator<BlockHolderVar<BOOL>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t BlockHolderVar<BOOL>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<BOOL>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

uint64_t BlockHolderVar<BOOL>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void std::__shared_ptr_emplace<HTTPEngine>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6528;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTPEngine>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6528;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void TunnelProxy<HTTPEngine>::establishProxyConnection(uint64_t a1, uint64_t *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CFStringRef v4 = CFStringCreateWithFormat(0, 0, @"%@:%d", *(void *)(a1 + 48), *(unsigned __int16 *)(a1 + 64));
  CFURLRef v5 = CFURLCreateWithString(0, v4, 0);
  if (v5)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v7 = (HTTPRequestMessage *)Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 16) = 0u;
      uint64_t v7 = (HTTPRequestMessage *)(Instance + 16);
      *(void *)(Instance + 192) = 0;
      *(_OWORD *)(Instance + 160) = 0u;
      *(_OWORD *)(Instance + 176) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 144) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
    }
    HTTPMethodMixedValue::HTTPMethodMixedValue((HTTPMethodMixedValue *)v31, (CFStringRef)&unk_1EC0A3308);
    HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v29, @"HTTP/1.1");
    HTTPRequestMessage::HTTPRequestMessage(v7, v31, v5, cf);
    int64_t v28 = v7;
    uint64_t v29 = &unk_1ECF9F718;
    if (cf) {
      CFRelease(cf);
    }
    v31[0] = &unk_1ECF9F718;
    if (v31[1]) {
      CFRelease(v31[1]);
    }
    CFStringRef v8 = v4;
    if (*(_DWORD *)(a1 + 64) == 443) {
      CFStringRef v8 = *(const __CFString **)(a1 + 48);
    }
    HTTPMessage::setHeaderFieldStringValue(v7, (const __CFString *)&unk_1EC0A2310, v8);
    if (dyld_program_sdk_at_least()) {
      goto LABEL_19;
    }
    uint64_t v9 = *(void *)(a1 + 232);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    uint64_t v10 = v9 ? (HTTPMessage *)(v9 + 16) : 0;
    CFStringRef v11 = HTTPMessage::copyHeaderFieldValue(v10, 0x14E15421u);
    if (!v11)
    {
LABEL_19:
      pthread_once(&initControl, initializeUserAgentString);
      if (sUserAgentString)
      {
        pthread_once(&initControl, initializeUserAgentString);
        CFStringRef v11 = (const __CFString *)CFRetain((CFTypeRef)sUserAgentString);
      }
      else
      {
        CFStringRef v11 = 0;
      }
    }
    HTTPMessage::setHeaderFieldStringValue(v7, @"User-Agent", v11);
    uint64_t v14 = *(void *)(a1 + 232);
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (v14) {
      long long v15 = (HTTPMessage *)(v14 + 16);
    }
    else {
      long long v15 = 0;
    }
    CFStringRef v16 = HTTPMessage::copyHeaderFieldValue(v15, 0x1382736Bu);
    if (v16) {
      HTTPMessage::setHeaderFieldStringValue(v7, (const __CFString *)&unk_1EC0A2658, v16);
    }
    HTTPMessage::setHeaderFieldStringValue(v7, (const __CFString *)&unk_1EC0A2690, @"keep-alive");
    HTTPMessage::setHeaderFieldStringValue(v7, @"Connection", @"keep-alive");
    if (v16) {
      CFRelease(v16);
    }
    if (v11) {
      CFRelease(v11);
    }
    CFRelease(v5);
    if (v4) {
LABEL_40:
    }
      CFRelease(v4);
  }
  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    long long v12 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      CFDataRef v13 = *(const void **)(a1 + 48);
      LODWORD(v31[0]) = 138412290;
      *(CFTypeRef *)((char *)v31 + 4) = v13;
      _os_log_impl(&dword_184085000, v12, OS_LOG_TYPE_DEFAULT, "Invalid URL for CONNECT request %@", (uint8_t *)v31, 0xCu);
    }
    *(void *)(a1 + 200) = 4;
    *(_DWORD *)(a1 + 208) = -2096;
    int64_t v28 = 0;
    if (v4) {
      goto LABEL_40;
    }
  }
  uint64_t v17 = *(void *)std::shared_ptr<HTTPRequestMessage>::operator=[abi:nn180100]<HTTPRequestMessage,Deleter_release<HTTPRequestMessage>,void>(a1 + 160, &v28);
  if (v28) {
    CFRelease((char *)v28 - 16);
  }
  if (v17)
  {
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<HTTPEngine::HTTPEngineDelegate,TunnelProxy<HTTPEngine>>(&v29, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16), a1);
    std::allocate_shared[abi:nn180100]<HTTPEngine,std::allocator<HTTPEngine>,std::shared_ptr<TransportConnection> &,std::shared_ptr<HTTPEngine::HTTPEngineDelegate>,void>((uint64_t *)v31, *(void *)(a1 + 128), *(std::__shared_weak_count **)(a1 + 136), (uint64_t *)&v29);
    uint64_t v18 = *(std::__shared_weak_count **)(a1 + 120);
    *(_OWORD *)(a1 + 112) = *(_OWORD *)v31;
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v18);
    }
    if (cf) {
      std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)cf);
    }
    CFStringRef v19 = *(std::__shared_weak_count **)(a1 + 136);
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    if (v19) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v19);
    }
    HTTPEngine::initialize(*(void *)(a1 + 112));
  }
  TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>(&v29, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16), a1);
  CFStringRef v20 = (std::__shared_weak_count *)cf;
  uint64_t v21 = *a2;
  if (*a2)
  {
    BOOL v22 = v29;
    uint64_t v23 = *(void *)(a1 + 200);
    uint64_t v24 = *(void *)(a1 + 208);
    if (cf) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)cf + 1, 1uLL, memory_order_relaxed);
    }
    uint64_t v25 = *(void (**)(void *, CFTypeRef *, void, uint64_t, uint64_t))(v21 + 8);
    uint64_t v26 = *(void *)(v21 + 16);
    BOOL v27 = (void *)(v21 + (v26 >> 1));
    if (v26) {
      uint64_t v25 = *(void (**)(void *, CFTypeRef *, void, uint64_t, uint64_t))(*v27 + v25);
    }
    v31[0] = v22;
    v31[1] = v20;
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v25(v27, v31, 0, v23, v24);
    if (v31[1]) {
      std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v31[1]);
    }
    if (v20)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v20);
      goto LABEL_65;
    }
  }
  else if (cf)
  {
LABEL_65:
    std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  }
}

void sub_184191074(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  if (v16)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::shared_ptr<HTTPRequestMessage>::operator=[abi:nn180100]<HTTPRequestMessage,Deleter_release<HTTPRequestMessage>,void>(uint64_t a1, void *a2)
{
  if (*a2) {
    operator new();
  }
  *a2 = 0;
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = 0u;
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  return a1;
}

void std::__shared_ptr_pointer<HTTPRequestMessage *,Deleter_release<HTTPRequestMessage>,std::allocator<HTTPRequestMessage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t NetworkProxy::getEndpointPort(NetworkProxy *this)
{
  return *((unsigned int *)this + 16);
}

uint64_t NetworkProxy::getEndpointHost@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 56);
  *a2 = *(void *)(this + 48);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t NetworkProxy::host@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 32);
  *a2 = *(void *)(this + 24);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t NetworkProxy::getPort(NetworkProxy *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t TunnelProxy<HTTPEngine>::getType()
{
  return 3;
}

CFTypeRef TunnelProxy<HTTPEngine>::copyCONNECTEndpointProperties(uint64_t a1)
{
  CFNumberRef v2 = CFNumberCreate(0, kCFNumberCFIndexType, (const void *)(a1 + 40));
  CFDictionaryRef v3 = _newConnPropsForHTTPSProxy(0, *(__CFHTTPMessage **)(a1 + 232), *(__CFString **)(a1 + 24), v2);
  CFDictionaryRef v4 = v3;
  if (!v3)
  {
    CFTypeRef v6 = 0;
    if (!v2) {
      return v6;
    }
    goto LABEL_8;
  }
  CFArrayRef Value = CFDictionaryGetValue(v3, &unk_1EC0A5678);
  if (Value) {
    CFTypeRef v6 = CFRetain(Value);
  }
  else {
    CFTypeRef v6 = 0;
  }
  CFRelease(v4);
  if (v2) {
LABEL_8:
  }
    CFRelease(v2);
  return v6;
}

void sub_184191384(_Unwind_Exception *a1)
{
  CFRelease(v2);
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(a1);
}

__CFString *TunnelProxy<HTTPEngine>::prettyType()
{
  return @"https";
}

void TunnelProxy<HTTPEngine>::~TunnelProxy(NetworkProxy *a1)
{
  TunnelProxy<HTTPEngine>::~TunnelProxy(a1);

  JUMPOUT(0x18531B6D0);
}

CFWriteStreamRef CFWriteStreamCreateWithFTPURL(CFAllocatorRef alloc, CFURLRef ftpURL)
{
  if (!ftpURL) {
    return 0;
  }
  CFURLRef CFFTPHappyURL = _CreateCFFTPHappyURL(ftpURL);
  if (!CFFTPHappyURL) {
    return 0;
  }
  CFURLRef v4 = CFFTPHappyURL;
  if (!_ValidFTPPathname(CFFTPHappyURL)) {
    goto LABEL_31;
  }
  CFStringRef v5 = CFURLCopyScheme(v4);
  if (!v5) {
    goto LABEL_31;
  }
  CFStringRef v6 = v5;
  if (CFStringCompare(v5, @"ftp", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v6, @"ftps", 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(v6);
    CFStringRef v8 = CFURLCopyHostName(v4);
    if (v8)
    {
      CFRelease(v8);
      CFStringRef v9 = CFURLCopyUserName(v4);
      CFStringRef v10 = v9;
      if (v9 && !_ValidFTPString(v9))
      {
        CFStringRef v19 = v10;
      }
      else
      {
        CFStringRef v11 = CFURLCopyPassword(v4);
        CFStringRef v12 = v11;
        if (!v11 || _ValidFTPString(v11))
        {
          CFDataRef v13 = CFAllocatorAllocate(alloc, 144, 0);
          if (v13)
          {
            uint64_t v14 = v13;
            *((_OWORD *)v13 + 7) = 0u;
            *((_OWORD *)v13 + 8) = 0u;
            *((_OWORD *)v13 + 5) = 0u;
            *((_OWORD *)v13 + 6) = 0u;
            *((_OWORD *)v13 + 3) = 0u;
            *((_OWORD *)v13 + 4) = 0u;
            *((_OWORD *)v13 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
            *((_OWORD *)v13 + 2) = 0u;
            *(_OWORD *)CFDataRef v13 = 0u;
            *(_WORD *)CFDataRef v13 = 129;
            v13[1] = CFURLCopyAbsoluteURL(v4);
            v14[10] = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            v14[11] = Mutable;
            CFStringRef v16 = (const void *)v14[1];
            if (v16)
            {
              if (!v14[10] || !Mutable) {
                goto LABEL_34;
              }
              long long v23 = 1uLL;
              uint64_t v24 = _FTPStreamFinalize;
              uint64_t v25 = _FTPStreamCopyDescription;
              uint64_t v26 = _FTPStreamOpen;
              BOOL v27 = _FTPStreamOpenCompleted;
              int64_t v28 = _FTPStreamWrite;
              uint64_t v29 = _FTPStreamCanWrite;
              uint64_t v30 = _FTPStreamClose;
              int64_t v31 = _FTPStreamCopyProperty;
              uint64_t v32 = _FTPStreamSetProperty;
              uint64_t v33 = 0;
              BOOL v34 = _FTPStreamSchedule;
              int64_t v35 = _FTPStreamUnschedule;
              uint64_t v17 = CoreWriteStreamCreate((uint64_t)alloc, &v23, (uint64_t)v14);
              if (v17)
              {
                uint64_t v18 = v17;
                void v14[4] = v17;
                if (v10)
                {
                  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
                    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
                  }
                  ++*(void *)(v18 + 96);
                  (*(void (**)(void, __CFString *, const __CFString *))(**(void **)(v18 + 40) + 32))(*(void *)(v18 + 40), @"kCFStreamPropertyFTPUserName_prevalidated", v10);
                  --*(void *)(v18 + 96);
                }
                if (v12)
                {
                  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
                    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
                  }
                  ++*(void *)(v18 + 96);
                  (*(void (**)(void, __CFString *, const __CFString *))(**(void **)(v18 + 40) + 32))(*(void *)(v18 + 40), @"kCFStreamPropertyFTPPassword_prevalidated", v12);
                  --*(void *)(v18 + 96);
                }
LABEL_41:
                CFRelease(v4);
                if (v10) {
                  CFRelease(v10);
                }
                if (v12) {
                  CFRelease(v12);
                }
                if (v18)
                {
                  uint64_t v7 = (__CFWriteStream *)_CFWriteStreamCreateWithCoreStream();
                  CFURLRef v4 = (const __CFURL *)v18;
                  goto LABEL_32;
                }
                return 0;
              }
              CFStringRef v16 = (const void *)v14[1];
              if (v16) {
LABEL_34:
              }
                CFRelease(v16);
            }
            CFStringRef v20 = (const void *)v14[10];
            if (v20) {
              CFRelease(v20);
            }
            uint64_t v21 = (const void *)v14[11];
            if (v21) {
              CFRelease(v21);
            }
            CFAllocatorDeallocate(alloc, v14);
          }
          uint64_t v18 = 0;
          goto LABEL_41;
        }
        if (v10) {
          CFRelease(v10);
        }
        CFStringRef v19 = v12;
      }
      CFRelease(v19);
    }
LABEL_31:
    uint64_t v7 = 0;
    goto LABEL_32;
  }
  CFRelease(v4);
  uint64_t v7 = 0;
  CFURLRef v4 = (const __CFURL *)v6;
LABEL_32:
  CFRelease(v4);
  return v7;
}

CFURLRef _CreateCFFTPHappyURL(const __CFURL *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFURLRef v1 = CFURLCopyAbsoluteURL(a1);
  if (v1)
  {
    CFURLRef v2 = v1;
    CFIndex v3 = CFURLGetBytes(v1, buffer, 2048);
    if (v3 == -1)
    {
      CFIndex v7 = CFURLGetBytes(v2, 0, 0);
      CFStringRef v8 = (UInt8 *)malloc_type_malloc(v7, 0x75D81533uLL);
      if (!v8)
      {
        CFURLRef v6 = 0;
LABEL_10:
        CFRelease(v2);
        return v6;
      }
      CFStringRef v5 = v8;
      CFIndex v4 = CFURLGetBytes(v2, v8, v7);
    }
    else
    {
      CFIndex v4 = v3;
      CFStringRef v5 = buffer;
    }
    CFAllocatorRef v9 = CFGetAllocator(v2);
    CFURLRef v6 = CFURLCreateAbsoluteURLWithBytes(v9, v5, v4, 0, 0, 0);
    if (v5 != buffer) {
      free(v5);
    }
    goto LABEL_10;
  }
  return 0;
}

uint64_t _ValidFTPPathname(const __CFURL *a1)
{
  CFStringRef v1 = _CFURLCopyPathReplacingPercentEscapes(a1);
  if (!v1) {
    return 0;
  }
  CFStringRef v2 = v1;
  CFIndex Length = CFStringGetLength(v1);
  CFStringRef theString = v2;
  uint64_t v27 = 0;
  CFIndex v28 = Length;
  CharactersPtr = CFStringGetCharactersPtr(v2);
  CStringPtr = 0;
  uint64_t v25 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(v2, 0x600u);
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v26 = CStringPtr;
  if (Length < 1)
  {
LABEL_32:
    uint64_t v21 = 1;
    goto LABEL_35;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 64;
  while (1)
  {
    uint64_t v11 = (unint64_t)v9 >= 4 ? 4 : v9;
    CFIndex v12 = v28;
    if (v28 <= v9) {
      break;
    }
    if (v25)
    {
      UniChar v13 = v25[v9 + v27];
    }
    else if (v26)
    {
      UniChar v13 = v26[v27 + v9];
    }
    else
    {
      if (v30 <= v9 || v7 > v9)
      {
        uint64_t v15 = v11 + v6;
        uint64_t v16 = v10 - v11;
        uint64_t v17 = v9 - v11;
        CFIndex v18 = v17 + 64;
        if (v17 + 64 >= v28) {
          CFIndex v18 = v28;
        }
        uint64_t v29 = v17;
        uint64_t v30 = v18;
        if (v28 >= v16) {
          CFIndex v12 = v16;
        }
        v31.CFIndex length = v12 + v15;
        v31.location = v17 + v27;
        CFStringGetCharacters(theString, v31, buffer);
        uint64_t v7 = v29;
      }
      UniChar v13 = buffer[v9 - v7];
    }
    if (v13 != 10 && v13 != 13) {
      break;
    }
    int v20 = 1;
LABEL_31:
    ++v9;
    --v6;
    ++v10;
    int v8 = v20;
    if (Length == v9) {
      goto LABEL_32;
    }
  }
  int v20 = 0;
  if (!v8) {
    goto LABEL_31;
  }
  uint64_t v21 = 0;
LABEL_35:
  CFRelease(v2);
  return v21;
}

uint64_t _ValidFTPString(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  uint64_t v23 = 0;
  CFIndex v24 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  uint64_t v21 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  BOOL v22 = CStringPtr;
  if (Length < 1) {
    return 1;
  }
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  for (uint64_t i = 64; ; ++i)
  {
    uint64_t v9 = (unint64_t)v7 >= 4 ? 4 : v7;
    CFIndex v10 = v24;
    if (v24 > v7)
    {
      if (v21)
      {
        UniChar v11 = v21[v7 + v23];
      }
      else if (v22)
      {
        UniChar v11 = v22[v23 + v7];
      }
      else
      {
        if (v26 <= v7 || v6 > v7)
        {
          uint64_t v13 = v9 + v5;
          uint64_t v14 = i - v9;
          uint64_t v15 = v7 - v9;
          CFIndex v16 = v15 + 64;
          if (v15 + 64 >= v24) {
            CFIndex v16 = v24;
          }
          uint64_t v25 = v15;
          uint64_t v26 = v16;
          if (v24 >= v14) {
            CFIndex v10 = v14;
          }
          v27.CFIndex length = v10 + v13;
          v27.location = v15 + v23;
          CFStringGetCharacters(theString, v27, buffer);
          uint64_t v6 = v25;
        }
        UniChar v11 = buffer[v7 - v6];
      }
      if (v11 == 10 || v11 == 13) {
        break;
      }
    }
    ++v7;
    --v5;
    if (Length == v7) {
      return 1;
    }
  }
  return 0;
}

void _FTPStreamUnschedule(uint64_t a1, __CFRunLoop *a2, const __CFString *a3, uint64_t a4)
{
  if (_SchedulesRemoveRunLoopAndMode(*(const __CFArray **)(a4 + 80), a2, a3))
  {
    uint64_t v9 = *(__CFRunLoopSource **)(a4 + 96);
    if (v9) {
      CFRunLoopRemoveSource(a2, v9, a3);
    }
    CFIndex v10 = *(void **)(a4 + 56);
    if (v10) {
      _CFTypeUnscheduleFromRunLoop(v10, (uint64_t)a2, (uint64_t)a3);
    }
    UniChar v11 = *(void **)(a4 + 24);
    if (v11) {
      _CFTypeUnscheduleFromRunLoop(v11, (uint64_t)a2, (uint64_t)a3);
    }
    CFIndex v12 = *(NetConnection **)(a4 + 128);
    if (v12)
    {
      NetConnection::unschedule(v12, (uint64_t *)a4, v7, v8);
    }
  }
}

uint64_t _FTPStreamSchedule(uint64_t a1, CoreSchedulingSet *a2, const __CFString *a3, uint64_t a4)
{
  uint64_t result = _SchedulesAddRunLoopAndMode(*(const __CFArray **)(a4 + 80), a2, a3);
  if (result)
  {
    CFStringRef v8 = *(__CFRunLoopSource **)(a4 + 96);
    if (v8) {
      CFRunLoopAddSource((CFRunLoopRef)a2, v8, a3);
    }
    uint64_t v9 = *(void **)(a4 + 56);
    if (v9) {
      _CFTypeScheduleOnRunLoop(v9, (uint64_t)a2, (uint64_t)a3);
    }
    CFIndex v10 = *(void **)(a4 + 24);
    if (v10) {
      _CFTypeScheduleOnRunLoop(v10, (uint64_t)a2, (uint64_t)a3);
    }
    uint64_t result = *(void *)(a4 + 128);
    if (result)
    {
      return NetConnection::schedule(result, (uint64_t *)a4, a2, a3);
    }
  }
  return result;
}

uint64_t _FTPStreamSetProperty(int a1, __CFString *cf1, const __CFString *a3, uint64_t a4)
{
  if (CFEqual(cf1, @"kCFStreamPropertyFTPProxy"))
  {
    if (*(void *)(a4 + 128) || *(void *)(a4 + 24)) {
      return 0;
    }
    if (a3)
    {
      CFTypeID v7 = CFGetTypeID(a3);
      if (v7 == CFDictionaryGetTypeID())
      {
        CFStringRef v8 = *(__CFDictionary **)(a4 + 88);
        uint64_t v9 = (__CFString *)&unk_1EC0A1120;
LABEL_7:
        CFDictionaryRemoveValue(v8, v9);
LABEL_8:
        CFIndex v10 = *(__CFDictionary **)(a4 + 88);
LABEL_9:
        UniChar v11 = cf1;
LABEL_10:
        CFDictionarySetValue(v10, v11, a3);
        return 1;
      }
      return 0;
    }
    goto LABEL_61;
  }
  if (CFEqual(cf1, &unk_1EC0A1120))
  {
    if (*(void *)(a4 + 128) || *(void *)(a4 + 24)) {
      return 0;
    }
    if (a3)
    {
      CFTypeID v15 = CFGetTypeID(a3);
      if (v15 == CFDictionaryGetTypeID()
        && !CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), @"kCFStreamPropertyFTPProxy"))
      {
        CFStringRef v8 = *(__CFDictionary **)(a4 + 88);
        uint64_t v9 = @"kCFStreamPropertyFTPProxy";
        goto LABEL_7;
      }
      return 0;
    }
    goto LABEL_61;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPUsePassiveMode"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1CFC8])) {
      __int16 v13 = *(_WORD *)a4 & 0xFFFE;
    }
    else {
      __int16 v13 = *(_WORD *)a4 | 1;
    }
    __int16 v14 = v13 | 2;
    goto LABEL_21;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPFetchResourceInfo"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1CFD0])) {
      __int16 v14 = *(_WORD *)a4 | 4;
    }
    else {
      __int16 v14 = *(_WORD *)a4 & 0xFFFB;
    }
LABEL_21:
    *(_WORD *)a4 = v14;
    return 1;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPFetchNameList"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1CFD0])) {
      __int16 v14 = *(_WORD *)a4 | 8;
    }
    else {
      __int16 v14 = *(_WORD *)a4 & 0xFFF7;
    }
    goto LABEL_21;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPFileTransferOffset"))
  {
    CFIndex v16 = (void *)(a4 + 72);
    if (a3) {
      CFNumberGetValue((CFNumberRef)a3, kCFNumberLongLongType, v16);
    }
    else {
      *CFIndex v16 = 0;
    }
    return 1;
  }
  if (CFEqual(cf1, @"_kCFStreamPropertyFTPLogInOnly"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1CFD0])) {
      __int16 v14 = *(_WORD *)a4 | 0x200;
    }
    else {
      __int16 v14 = *(_WORD *)a4 & 0xFDFF;
    }
    goto LABEL_21;
  }
  if (CFEqual(cf1, @"_kCFStreamPropertyFTPRemoveResource"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1CFD0])) {
      __int16 v14 = *(_WORD *)a4 | 0x100;
    }
    else {
      __int16 v14 = *(_WORD *)a4 & 0xFEFF;
    }
    goto LABEL_21;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPResourceSize")) {
    return 0;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPAttemptPersistentConnection"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E4F1CFC8])) {
      goto LABEL_8;
    }
LABEL_61:
    CFIndex v10 = *(__CFDictionary **)(a4 + 88);
LABEL_62:
    UniChar v11 = cf1;
    goto LABEL_63;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPUserName") || CFEqual(cf1, @"kCFStreamPropertyFTPPassword"))
  {
    if (a3)
    {
      CFTypeID v17 = CFGetTypeID(a3);
      if (v17 == CFStringGetTypeID())
      {
        uint64_t result = _ValidFTPString(a3);
        if (!result) {
          return result;
        }
        goto LABEL_8;
      }
      return 0;
    }
    goto LABEL_61;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPUserName_prevalidated"))
  {
    CFIndex v10 = *(__CFDictionary **)(a4 + 88);
    UniChar v11 = @"kCFStreamPropertyFTPUserName";
    if (a3) {
      goto LABEL_10;
    }
LABEL_63:
    CFDictionaryRemoveValue(v10, v11);
    return 1;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPPassword_prevalidated"))
  {
    CFIndex v10 = *(__CFDictionary **)(a4 + 88);
    UniChar v11 = @"kCFStreamPropertyFTPPassword";
    if (a3) {
      goto LABEL_10;
    }
    goto LABEL_63;
  }
  CFIndex v18 = *(const void **)(a4 + 24);
  if (!v18) {
    goto LABEL_82;
  }
  CFTypeID v19 = CFGetTypeID(v18);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t v20 = *(void *)(a4 + 24);
  if (v20) {
    uint64_t v21 = v20 + 16;
  }
  else {
    uint64_t v21 = 0;
  }
  if (v19 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
    && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  ++*(void *)(v21 + 80);
  uint64_t result = (*(uint64_t (**)(void, __CFString *, const __CFString *))(**(void **)(v21 + 24) + 32))(*(void *)(v21 + 24), cf1, a3);
  --*(void *)(v21 + 80);
  if (!result)
  {
LABEL_82:
    CFIndex v10 = *(__CFDictionary **)(a4 + 88);
    if (a3) {
      goto LABEL_9;
    }
    goto LABEL_62;
  }
  return result;
}

CFArrayRef _FTPStreamCopyProperty(int a1, CFTypeRef cf1, uint64_t a3)
{
  if (CFEqual(cf1, @"kCFStreamPropertyFTPUsePassiveMode"))
  {
    uint64_t v5 = (const void **)MEMORY[0x1E4F1CFD0];
    uint64_t v6 = (const void **)MEMORY[0x1E4F1CFC8];
    BOOL v7 = (*(_WORD *)a3 & 1) == 0;
    goto LABEL_7;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPFetchResourceInfo"))
  {
    uint64_t v5 = (const void **)MEMORY[0x1E4F1CFD0];
    uint64_t v6 = (const void **)MEMORY[0x1E4F1CFC8];
    BOOL v7 = (*(_WORD *)a3 & 4) == 0;
    goto LABEL_7;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPFetchNameList"))
  {
    uint64_t v5 = (const void **)MEMORY[0x1E4F1CFD0];
    uint64_t v6 = (const void **)MEMORY[0x1E4F1CFC8];
    BOOL v7 = (*(_WORD *)a3 & 8) == 0;
LABEL_7:
    if (v7) {
      uint64_t v5 = v6;
    }
LABEL_9:
    CFArrayRef Value = *v5;
    if (!*v5) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (!CFEqual(cf1, @"kCFStreamPropertyFTPFileTransferOffset"))
  {
    if (CFEqual(cf1, @"kCFStreamPropertyFTPResourceSize"))
    {
      CFDictionaryRef v34 = *(const __CFDictionary **)(a3 + 64);
      if (!v34) {
        goto LABEL_11;
      }
      CFArrayRef Value = CFDictionaryGetValue(v34, @"kCFFTPResourceSize");
      if (!Value) {
        goto LABEL_11;
      }
    }
    else
    {
      if (!CFEqual(cf1, @"kCFStreamPropertyFTPAttemptPersistentConnection"))
      {
        if (CFEqual(cf1, @"_kCFStreamPropertyFTPLogInOnly"))
        {
          uint64_t v5 = (const void **)MEMORY[0x1E4F1CFD0];
          uint64_t v6 = (const void **)MEMORY[0x1E4F1CFC8];
          BOOL v7 = (*(_WORD *)a3 & 0x200) == 0;
        }
        else
        {
          if (!CFEqual(cf1, @"_kCFStreamPropertyFTPRemoveResource")) {
            goto LABEL_11;
          }
          uint64_t v5 = (const void **)MEMORY[0x1E4F1CFD0];
          uint64_t v6 = (const void **)MEMORY[0x1E4F1CFC8];
          BOOL v7 = (*(_WORD *)a3 & 0x100) == 0;
        }
        goto LABEL_7;
      }
      CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 88), cf1);
      if (!Value)
      {
        uint64_t v5 = (const void **)MEMORY[0x1E4F1CFD0];
        goto LABEL_9;
      }
    }
LABEL_10:
    CFArrayRef result = (CFArrayRef)CFRetain(Value);
    if (result) {
      return result;
    }
    goto LABEL_11;
  }
  CFAllocatorRef v27 = CFGetAllocator(*(CFTypeRef *)(a3 + 88));
  CFArrayRef result = CFNumberCreate(v27, kCFNumberLongLongType, (const void *)(a3 + 72));
  if (result) {
    return result;
  }
LABEL_11:
  CFIndex v10 = *(const void **)(a3 + 24);
  if (v10)
  {
    CFTypeID v11 = CFGetTypeID(v10);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v12 = *(void *)(a3 + 24);
    if (v12) {
      uint64_t v13 = v12 + 16;
    }
    else {
      uint64_t v13 = 0;
    }
    if (v11 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
      && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    ++*(void *)(v13 + 80);
    CFArrayRef result = (CFArrayRef)(*(uint64_t (**)(void, CFTypeRef))(**(void **)(v13 + 24) + 40))(*(void *)(v13 + 24), cf1);
    --*(void *)(v13 + 80);
    if (result) {
      return result;
    }
  }
  uint64_t v14 = *(void *)(a3 + 128);
  if (!v14) {
    goto LABEL_30;
  }
  uint64_t v15 = *(void *)(v14 + 96);
  if (v15) {
    pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
  }
  uint64_t v16 = *(void *)(v14 + 128);
  if (v16) {
    uint64_t v17 = *(void *)(v16 + 8);
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v18 = *(void *)(v14 + 96);
  if (v18) {
    pthread_mutex_unlock((pthread_mutex_t *)(v18 + 8));
  }
  if (v17 != a3) {
    goto LABEL_30;
  }
  uint64_t v23 = *(void *)(a3 + 128);
  uint64_t v24 = *(void *)(v23 + 96);
  if (!v24)
  {
    uint64_t v26 = *(void *)(v23 + 152);
    if (!v26) {
      goto LABEL_55;
    }
LABEL_52:
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    ++*(void *)(v26 + 96);
    CFArrayRef result = (CFArrayRef)(*(uint64_t (**)(void, CFTypeRef))(**(void **)(v26 + 40) + 40))(*(void *)(v26 + 40), cf1);
    --*(void *)(v26 + 96);
    if (result) {
      return result;
    }
    goto LABEL_55;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v24 + 8));
  uint64_t v25 = *(void *)(v23 + 96);
  uint64_t v26 = *(void *)(v23 + 152);
  if (v25) {
    pthread_mutex_unlock((pthread_mutex_t *)(v25 + 8));
  }
  if (v26) {
    goto LABEL_52;
  }
LABEL_55:
  uint64_t v29 = *(void *)(a3 + 128);
  uint64_t v30 = *(void *)(v29 + 96);
  if (v30)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v30 + 8));
    uint64_t v31 = *(void *)(v29 + 96);
    uint64_t v32 = *(void *)(v29 + 144);
    if (v31) {
      pthread_mutex_unlock((pthread_mutex_t *)(v31 + 8));
    }
  }
  else
  {
    uint64_t v32 = *(void *)(v29 + 144);
  }
  if (!v32) {
    goto LABEL_30;
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  ++*(void *)(v32 + 96);
  CFArrayRef result = (CFArrayRef)(*(uint64_t (**)(void, CFTypeRef))(**(void **)(v32 + 40) + 40))(*(void *)(v32 + 40), cf1);
  --*(void *)(v32 + 96);
  if (!result)
  {
LABEL_30:
    CFArrayRef result = (CFArrayRef)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 88), cf1);
    if (result)
    {
      CFStringRef v19 = (const __CFString *)result;
      CFTypeID v20 = CFGetTypeID(result);
      if (v20 == CFStringGetTypeID())
      {
        CFAllocatorRef v21 = CFGetAllocator(*(CFTypeRef *)(a3 + 88));
        return (CFArrayRef)CFStringCreateCopy(v21, v19);
      }
      else if (v20 == CFDataGetTypeID())
      {
        CFAllocatorRef v22 = CFGetAllocator(*(CFTypeRef *)(a3 + 88));
        return CFDataCreateCopy(v22, (CFDataRef)v19);
      }
      else if (v20 == CFDictionaryGetTypeID())
      {
        CFAllocatorRef v28 = CFGetAllocator(*(CFTypeRef *)(a3 + 88));
        return CFDictionaryCreateCopy(v28, (CFDictionaryRef)v19);
      }
      else if (v20 == CFArrayGetTypeID())
      {
        CFAllocatorRef v33 = CFGetAllocator(*(CFTypeRef *)(a3 + 88));
        return CFArrayCreateCopy(v33, (CFArrayRef)v19);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void **_FTPStreamClose(uint64_t a1, uint64_t a2)
{
  _InvalidateServer(a2);
  invalidatePacExecutionContext(a2);
  CFIndex v3 = *(const void **)(a2 + 24);
  if (v3)
  {
    CFTypeID v4 = CFGetTypeID(v3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v4 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
    {
      _ReleaseDataReadStream(a2);
    }
    else
    {
      _CFTypeInvalidate(*(char **)(a2 + 24));
      _CFTypeUnscheduleFromMultipleRunLoops(*(void **)(a2 + 24), *(const __CFArray **)(a2 + 80));
      uint64_t v5 = *(void *)(a2 + 24);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      if (v5) {
        uint64_t v6 = (CoreStreamBase *)(v5 + 16);
      }
      else {
        uint64_t v6 = 0;
      }
      CoreStreamBase::_streamInterface_Close(v6);
      BOOL v7 = *(const void **)(a2 + 24);
      if (v7) {
        CFRelease(v7);
      }
      *(void *)(a2 + 24) = 0;
    }
  }
  CFArrayRef result = *(void ***)(a2 + 128);
  if (result)
  {
    if (NetConnection::getState((NetConnection *)result, 0, (uint64_t *)a2) == 2)
    {
      CFArrayRef v9 = *(const __CFArray **)(a2 + 80);
      CFIndex Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        CFIndex v11 = Count;
        for (CFIndex i = 0; i < v11; i += 2)
        {
          uint64_t v13 = *(NetConnection **)(a2 + 128);
          CFArrayGetValueAtIndex(v9, i);
          CFArrayGetValueAtIndex(v9, i + 1);
          NetConnection::unschedule(v13, (uint64_t *)a2, v14, v15);
        }
      }
      NetConnection::requestIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
      uint64_t v16 = *(NetConnection **)(a2 + 128);
      return (void **)NetConnection::responseIsComplete(v16, (void *)a2);
    }
    else
    {
      uint64_t v17 = *(NetConnection **)(a2 + 128);
      return NetConnection::dequeue(v17, (void *)a2);
    }
  }
  return result;
}

void _InvalidateServer(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 56);
  if (v2)
  {
    CFArrayRef v3 = *(const __CFArray **)(a1 + 80);
    if (v3)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v2, v3);
      CFStringRef v2 = *(void **)(a1 + 56);
    }
    CFSocketInvalidate((CFSocketRef)v2);
    CFTypeID v4 = *(const void **)(a1 + 56);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 56) = 0;
  }
}

void invalidatePacExecutionContext(uint64_t a1)
{
  CFStringRef v2 = *(char **)(a1 + 96);
  if (v2)
  {
    _CFTypeInvalidate(v2);
    _CFTypeUnscheduleFromMultipleRunLoops(*(void **)(a1 + 96), *(const __CFArray **)(a1 + 80));
    CFArrayRef v3 = *(const void **)(a1 + 96);
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 96) = 0;
  }
}

void _ReleaseDataReadStream(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 80);
  CFArrayRef v3 = *(char **)(a1 + 24);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (v3) {
    CFTypeID v4 = (CoreStreamBase *)(v3 + 16);
  }
  else {
    CFTypeID v4 = 0;
  }
  (*(void (**)(CoreStreamBase *, void, void))(*(void *)v4 + 56))(v4, 0, 0);
  _CFTypeUnscheduleFromMultipleRunLoops(v3, v2);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  CoreStreamBase::_streamInterface_Close(v4);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + 24) = 0;
}

uint64_t _FTPStreamCanWrite(int a1, char *a2)
{
  CFArrayRef v3 = (NetConnection *)*((void *)a2 + 16);
  if (v3)
  {
    NetConnection::getState(v3, 1, (uint64_t *)a2);
    uint64_t v4 = *((void *)a2 + 16);
    if (v4)
    {
      long long v24 = 0uLL;
      uint64_t v5 = *(void *)(v4 + 96);
      if (v5)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
        uint64_t v6 = *(void *)(v4 + 96);
        uint64_t v7 = *(void *)(v4 + 144);
        if (v6) {
          pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
        }
      }
      else
      {
        uint64_t v7 = *(void *)(v4 + 144);
      }
      uint64_t v13 = *((void *)a2 + 16);
      uint64_t v14 = *(void *)(v13 + 96);
      if (v14)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v14 + 8));
        uint64_t v15 = *(void *)(v13 + 96);
        uint64_t v16 = *(void *)(v13 + 152);
        if (v15) {
          pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8));
        }
        if (v16)
        {
LABEL_19:
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
          }
          CFIndex v17 = *(void *)(v16 + 72);
          uint64_t v16 = *(void *)(v16 + 80);
          *(void *)&long long v24 = v17;
          *((void *)&v24 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v16;
          int v18 = v16;
          if (v16) {
            goto LABEL_29;
          }
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v16 = *(void *)(v13 + 152);
        if (v16) {
          goto LABEL_19;
        }
      }
      CFIndex v17 = 0;
      int v18 = 0;
LABEL_25:
      if (v7)
      {
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
        }
        CFIndex v17 = *(void *)(v7 + 72);
        uint64_t v16 = *(void *)(v7 + 80);
        *(void *)&long long v24 = v17;
        *((void *)&v24 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v16;
        int v18 = v16;
      }
LABEL_29:
      if (!v18) {
        goto LABEL_40;
      }
      if (!*(_DWORD *)((*(uint64_t (**)(void))(**((void **)a2 + 16) + 80))(*((void *)a2 + 16)) + 20))
      {
        CFIndex v19 = *((void *)a2 + 15);
        if (v19 < CFArrayGetCount(*((CFArrayRef *)a2 + 14)))
        {
          uint64_t v20 = *((void *)a2 + 16);
          ++*((void *)a2 + 15);
          *(_OWORD *)(a2 + 40) = v24;
          (*(void (**)(uint64_t, long long *))(*(void *)v20 + 64))(v20, &v24);
          goto LABEL_40;
        }
      }
      uint64_t v21 = *((void *)a2 + 4);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      if (v21) {
        uint64_t v12 = (CoreStreamBase *)(v21 + 16);
      }
      else {
        uint64_t v12 = 0;
      }
      v10.CFIndex domain = v17;
      *(void *)&v10.SInt32 error = v16;
      goto LABEL_39;
    }
    uint64_t v8 = *((void *)a2 + 4);
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    uint64_t v9 = v8 + 16;
    if (!v8) {
      uint64_t v9 = 0;
    }
    *(void *)&v10.SInt32 error = *(void *)(v9 + 64);
    if (v10.error)
    {
      v10.CFIndex domain = *(void *)(v9 + 56);
      uint64_t v11 = *((void *)a2 + 4);
      if (v11) {
        uint64_t v12 = (CoreStreamBase *)(v11 + 16);
      }
      else {
        uint64_t v12 = 0;
      }
LABEL_39:
      CoreStreamBase::_signalEvent(v12, 8, v10, 1);
    }
  }
LABEL_40:
  uint64_t v22 = *((void *)a2 + 3);
  if (!v22) {
    return 0;
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  return CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)(v22 + 16));
}

uint64_t _FTPStreamWrite(int a1, unsigned __int8 *a2, uint64_t a3, void *a4, uint64_t *a5)
{
  *a4 = 0;
  a4[1] = 0;
  while (1)
  {
    uint64_t v9 = (NetConnection *)a5[16];
    if (!v9)
    {
LABEL_29:
      uint64_t v25 = 0;
      goto LABEL_37;
    }
    uint64_t v10 = a5[3];
    if (v10)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)(v10 + 16))) {
        goto LABEL_29;
      }
      uint64_t v9 = (NetConnection *)a5[16];
    }
    NetConnection::getState(v9, 1, a5);
    uint64_t v11 = a5[16];
    if (!v11) {
      break;
    }
    uint64_t v12 = *(void *)(v11 + 96);
    if (v12)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
      uint64_t v13 = *(void *)(v11 + 96);
      uint64_t v14 = *(void *)(v11 + 144);
      if (v13) {
        pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
      }
    }
    else
    {
      uint64_t v14 = *(void *)(v11 + 144);
    }
    uint64_t v15 = a5[16];
    uint64_t v16 = *(void *)(v15 + 96);
    if (v16)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
      uint64_t v17 = *(void *)(v15 + 96);
      uint64_t v18 = *(void *)(v15 + 152);
      if (v17) {
        pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
      }
      if (v18)
      {
LABEL_17:
        if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
          dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
        }
        uint64_t v19 = *(void *)(v18 + 80);
        *a4 = *(void *)(v18 + 72);
        a4[1] = v19;
        if (v19) {
          goto LABEL_27;
        }
LABEL_23:
        if (v14)
        {
          if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
          }
          uint64_t v20 = *(void *)(v14 + 80);
          *a4 = *(void *)(v14 + 72);
          a4[1] = v20;
          LODWORD(v19) = v20;
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v18 = *(void *)(v15 + 152);
      if (v18) {
        goto LABEL_17;
      }
    }
    LODWORD(v19) = *((_DWORD *)a4 + 2);
    if (!v19) {
      goto LABEL_23;
    }
LABEL_27:
    if (v19)
    {
      uint64_t v25 = -1;
      goto LABEL_37;
    }
  }
  uint64_t v21 = a5[4];
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  uint64_t v22 = v21 + 16;
  if (!v21) {
    uint64_t v22 = 0;
  }
  uint64_t v24 = *(void *)(v22 + 56);
  uint64_t v23 = *(void *)(v22 + 64);
  *a4 = v24;
  a4[1] = v23;
  if (v23) {
    uint64_t v25 = -1;
  }
  else {
    uint64_t v25 = 0;
  }
LABEL_37:
  uint64_t v26 = a5[3];
  if (v26)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    uint64_t v25 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)(v26 + 16), a2, a3);
    if (v25 <= 0)
    {
      uint64_t v27 = a5[3];
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      uint64_t v28 = v27 + 16;
      if (!v27) {
        uint64_t v28 = 0;
      }
      *(_OWORD *)a4 = *(_OWORD *)(v28 + 56);
    }
  }
  return v25;
}

uint64_t _FTPStreamOpenCompleted(char *a1, uint64_t a2, char *a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  if (!*((void *)a3 + 3)) {
    goto LABEL_12;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t v6 = *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96);
  CFTypeID v7 = CFGetTypeID(*((CFTypeRef *)a3 + 3));
  uint64_t v8 = *((void *)a3 + 3);
  if (v8) {
    uint64_t v9 = (CoreStreamBase *)(v8 + 16);
  }
  else {
    uint64_t v9 = 0;
  }
  if (v7 != v6)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1) {
      goto LABEL_11;
    }
    CFIndex v38 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
    int64_t v39 = &__block_literal_global_3661;
    goto LABEL_66;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    CFIndex v38 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
    int64_t v39 = &__block_literal_global_20142;
LABEL_66:
    dispatch_once(v38, v39);
  }
LABEL_11:
  unint64_t Status = CoreStreamBase::_streamInterface_GetStatus(v9);
  if (Status >= 2)
  {
    if (Status != 7) {
      return 1;
    }
    CFTypeID v16 = CFGetTypeID(a1);
    if (a1) {
      uint64_t v17 = a1 + 16;
    }
    else {
      uint64_t v17 = 0;
    }
    if (v16 == v6)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1) {
        goto LABEL_37;
      }
      std::string::size_type v40 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
      CFIndex v41 = &__block_literal_global_20142;
    }
    else
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
      {
LABEL_37:
        *(_OWORD *)a2 = *(_OWORD *)(v17 + 56);
        return 1;
      }
      std::string::size_type v40 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
      CFIndex v41 = &__block_literal_global_3661;
    }
    dispatch_once(v40, v41);
    goto LABEL_37;
  }
LABEL_12:
  uint64_t v11 = (NetConnection *)*((void *)a3 + 16);
  if (!v11) {
    goto LABEL_29;
  }
  NetConnection::getState(v11, 1, (uint64_t *)a3);
  uint64_t v12 = *((void *)a3 + 16);
  if (!v12) {
    goto LABEL_29;
  }
  uint64_t v13 = *(void *)(v12 + 96);
  if (v13) {
    pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
  }
  uint64_t v14 = *(void *)(v12 + 128);
  if (v14) {
    uint64_t v15 = *(char **)(v14 + 8);
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v18 = *(void *)(v12 + 96);
  if (v18) {
    pthread_mutex_unlock((pthread_mutex_t *)(v18 + 8));
  }
  if (v15 != a3) {
    goto LABEL_29;
  }
  uint64_t v25 = *((void *)a3 + 16);
  uint64_t v26 = *(void *)(v25 + 96);
  if (v26)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v26 + 8));
    uint64_t v27 = *(void *)(v25 + 96);
    uint64_t v28 = *(void *)(v25 + 152);
    if (v27) {
      pthread_mutex_unlock((pthread_mutex_t *)(v27 + 8));
    }
  }
  else
  {
    uint64_t v28 = *(void *)(v25 + 152);
  }
  uint64_t v30 = *((void *)a3 + 16);
  uint64_t v31 = *(void *)(v30 + 96);
  if (v31)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v31 + 8));
    uint64_t v32 = *(void *)(v30 + 96);
    uint64_t v33 = *(void *)(v30 + 144);
    if (v32) {
      pthread_mutex_unlock((pthread_mutex_t *)(v32 + 8));
    }
  }
  else
  {
    uint64_t v33 = *(void *)(v30 + 144);
  }
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  if (v28)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v28 + 16)) == 7)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      long long v34 = *(_OWORD *)(v28 + 72);
LABEL_59:
      *(_OWORD *)a2 = v34;
      uint64_t v35 = *((void *)a3 + 16);
      if (v35)
      {
        if (!*(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)v35 + 80))(v35) + 20))
        {
          CFIndex v36 = *((void *)a3 + 15);
          if (v36 < CFArrayGetCount(*((CFArrayRef *)a3 + 14)))
          {
            uint64_t v37 = *((void *)a3 + 16);
            ++*((void *)a3 + 15);
            *(_OWORD *)(a3 + 40) = *(_OWORD *)a2;
            (*(void (**)(uint64_t, uint64_t))(*(void *)v37 + 64))(v37, a2);
            return 0;
          }
        }
      }
      _ReportError((uint64_t)a3, (CFStreamError *)a2);
      uint64_t v19 = 1;
      goto LABEL_30;
    }
  }
  if (v33)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v33 + 16)) == 7)
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      long long v34 = *(_OWORD *)(v33 + 72);
      goto LABEL_59;
    }
  }
LABEL_29:
  uint64_t v19 = 0;
LABEL_30:
  uint64_t v20 = (const void *)*((void *)a3 + 7);
  if (v20)
  {
    CFAllocatorRef v21 = CFGetAllocator(v20);
    CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v21, *((CFSocketRef *)a3 + 7), 0);
    if (RunLoopSource)
    {
      uint64_t v23 = RunLoopSource;
      double Current = CFRunLoopGetCurrent();
      CFRunLoopAddSource(Current, v23, @"_FTPStreamOpenCompleted");
      CFRunLoopRunInMode(@"_FTPStreamOpenCompleted", 0.0, 1u);
      CFRunLoopRemoveSource(Current, v23, @"_FTPStreamOpenCompleted");
      CFRelease(v23);
    }
  }
  return v19;
}

void _ReportError(uint64_t a1, CFStreamError *a2)
{
  uint64_t v4 = *(void *)(a1 + 128);
  if (v4)
  {
    if (!*(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)v4 + 80))(v4) + 20))
    {
      CFIndex v5 = *(void *)(a1 + 120);
      if (v5 < CFArrayGetCount(*(CFArrayRef *)(a1 + 112)))
      {
        uint64_t v6 = *(void *)(a1 + 128);
        ++*(void *)(a1 + 120);
        *(CFStreamError *)(a1 + 40) = *a2;
        CFTypeID v7 = *(void (**)(void))(*(void *)v6 + 64);
        v7();
        return;
      }
    }
    uint64_t v8 = *(void *)(a1 + 128);
    *(_WORD *)a1 |= 0x400u;
    if (v8) {
      (*(void (**)(uint64_t, CFStreamError *))(*(void *)v8 + 64))(v8, a2);
    }
  }
  else
  {
    *(_WORD *)a1 |= 0x400u;
  }
  uint64_t v9 = *(const void **)(a1 + 24);
  if (v9)
  {
    CFTypeID v10 = CFGetTypeID(v9);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v10 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
    {
      _ReleaseDataReadStream(a1);
    }
    else
    {
      _CFTypeInvalidate(*(char **)(a1 + 24));
      _CFTypeUnscheduleFromMultipleRunLoops(*(void **)(a1 + 24), *(const __CFArray **)(a1 + 80));
      uint64_t v11 = *(void *)(a1 + 24);
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      if (v11) {
        uint64_t v12 = (CoreStreamBase *)(v11 + 16);
      }
      else {
        uint64_t v12 = 0;
      }
      CoreStreamBase::_streamInterface_Close(v12);
      uint64_t v13 = *(const void **)(a1 + 24);
      if (v13) {
        CFRelease(v13);
      }
      *(void *)(a1 + 24) = 0;
    }
  }
  CFTypeID v14 = CFGetTypeID(*(CFTypeRef *)(a1 + 32));
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t v15 = *(void *)(a1 + 32);
  if (v15) {
    CFTypeID v16 = (CoreStreamBase *)(v15 + 16);
  }
  else {
    CFTypeID v16 = 0;
  }
  if (v14 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
    {
      if (a2) {
        goto LABEL_33;
      }
    }
    else
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      if (a2) {
        goto LABEL_33;
      }
    }
LABEL_35:
    *(void *)&v17.SInt32 error = 0;
    v17.CFIndex domain = 0;
    goto LABEL_36;
  }
  if (!a2) {
    goto LABEL_35;
  }
LABEL_33:
  CFStreamError v17 = *a2;
LABEL_36:

  CoreStreamBase::_signalEvent(v16, 8, v17, 1);
}

uint64_t _FTPStreamOpen(const void *a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  if (_FTPStreamOpen(void const*,CFStreamError *,unsigned char *,_CFFTPStreamContext *)::onceToken != -1) {
    dispatch_once(&_FTPStreamOpen(void const*,CFStreamError *,unsigned char *,_CFFTPStreamContext *)::onceToken, &__block_literal_global_793);
  }
  SInt32 valuePtr = -1;
  CFAllocatorRef v8 = CFGetAllocator(a1);
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), @"kCFStreamPropertyFTPAttemptPersistentConnection");
  if (Value) {
    BOOL v10 = CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F1CFC8]) != 0;
  }
  else {
    BOOL v10 = 0;
  }
  *(_DWORD *)(a2 + 8) = 0;
  *(void *)a2 = 0;
  CFArrayRef v11 = *(const __CFArray **)(a4 + 112);
  if (v11 || (*(_WORD *)a4 & 0x1000) != 0)
  {
    if ((*(_WORD *)a4 & 0x1000) == 0) {
      goto LABEL_24;
    }
LABEL_49:
    *a3 = 0;
    return 1;
  }
  uint64_t v12 = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), @"kCFStreamPropertyFTPProxy");
  if (!v12 || (uint64_t v13 = (__CFDictionary *)CFRetain(v12)) == 0)
  {
    CFTypeID v14 = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), &unk_1EC0A1120);
    if (!v14 || (uint64_t v13 = (__CFDictionary *)CFRetain(v14)) == 0) {
      uint64_t v13 = CFNetworkCopySystemProxySettings();
    }
  }
  *(_WORD *)a4 &= ~0x1000u;
  CFArrayRef v15 = (const __CFArray *)__CFNetworkCopyProxiesForURLWithInterface(*(const __CFURL **)(a4 + 8), v13, 0);
  if (v13) {
    CFRelease(v13);
  }
  *(void *)(a4 + 120) = 0;
  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, 0);
  if (!v15)
  {
    uint64_t v29 = 6;
    uint64_t v28 = 0xFFFFFFFFLL;
    goto LABEL_44;
  }
  CFDictionaryRef v17 = ValueAtIndex;
  uint64_t v18 = CFDictionaryGetValue(ValueAtIndex, @"kCFProxyTypeKey");
  if (!CFEqual(@"kCFProxyTypeAutoConfigurationURL", v18))
  {
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    *(void *)(a4 + 112) = v15;
    goto LABEL_44;
  }
  v84[0] = 0;
  v84[1] = a4;
  memset(&v84[2], 0, 24);
  uint64_t v19 = (PAC *)CFDictionaryGetValue(v17, @"kCFProxyAutoConfigurationURLKey");
  CFArrayRef v20 = *(const __CFArray **)(a4 + 80);
  *(void *)(a4 + 96) = PAC::CreatePACTicket(v19, *(const void **)(a4 + 8), 0, 0, (const __CFString *)PACExecutionComplete_FTPStream, (void (*)(void *, const __CFArray *, __CFError *))v84, v21);
  *(_WORD *)a4 |= 0x1000u;
  if (v20 && CFArrayGetCount(v20) >= 1)
  {
    CFIndex Count = CFArrayGetCount(v20);
    if (Count >= 1)
    {
      CFIndex v23 = Count;
      uint64_t v75 = v8;
      BOOL v24 = v10;
      for (CFIndex i = 0; i < v23; i += 2)
      {
        uint64_t v26 = (__CFRunLoop *)CFArrayGetValueAtIndex(v20, i);
        CFStringRef v27 = (const __CFString *)CFArrayGetValueAtIndex(v20, i + 1);
        CFRunLoopAddSource(v26, *(CFRunLoopSourceRef *)(a4 + 96), v27);
      }
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      BOOL v10 = v24;
      CFAllocatorRef v8 = v75;
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  context.version = 0;
  context.info = (void *)a4;
  memset(&context.retain, 0, 24);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  int64_t v39 = CFRunLoopTimerCreate(v8, Current + 60.0, -1.0, 0, 0, (CFRunLoopTimerCallBack)PACTimerCallback_FTPStream, &context);
  std::string::size_type v40 = CFRunLoopGetCurrent();
  CFRunLoopAddSource(v40, *(CFRunLoopSourceRef *)(a4 + 96), @"_kProxySupportSyncPACExecutionRunLoopMode");
  CFIndex v41 = CFRunLoopGetCurrent();
  CFRunLoopAddTimer(v41, v39, @"_kProxySupportSyncPACExecutionRunLoopMode");
  while ((*(_WORD *)a4 & 0x1000) != 0)
    CFRunLoopRunInMode(@"_kProxySupportSyncPACExecutionRunLoopMode", 1.0e10, 1u);
  CFRunLoopTimerInvalidate(v39);
  if (v39) {
    CFRelease(v39);
  }
  UniChar v42 = *(__CFError **)(a4 + 104);
  if (!v42)
  {
LABEL_42:
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    goto LABEL_43;
  }
  uint64_t v29 = _CFStreamErrorFromCFError(v42);
  uint64_t v28 = v43;
LABEL_43:
  CFRelease(v15);
LABEL_44:
  *(void *)a2 = v29;
  *(void *)(a2 + 8) = v28;
  if (*(void *)(a4 + 128))
  {
    uint64_t result = 1;
    *a3 = 1;
    return result;
  }
  if ((*(_WORD *)a4 & 0x1000) != 0) {
    goto LABEL_49;
  }
  if (v28)
  {
    uint64_t result = 0;
    *a3 = 1;
    return result;
  }
  CFArrayRef v11 = *(const __CFArray **)(a4 + 112);
LABEL_24:
  uint64_t v30 = *(void *)(a4 + 120);
  if (v30 == CFArrayGetCount(v11))
  {
    *a3 = 1;
    if (*(_DWORD *)(a4 + 48))
    {
      uint64_t result = 0;
      *(_OWORD *)a2 = *(_OWORD *)(a4 + 40);
      return result;
    }
    uint64_t result = 0;
    *(void *)a2 = 1;
    int v44 = 57;
    goto LABEL_130;
  }
  *(void *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 48) = 0;
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a4 + 88), @"kCFStreamPropertyFTPProxy");
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a4 + 88), &unk_1EC0A1120);
  *(_WORD *)a4 &= 0xFFCFu;
  uint64_t v32 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 112), *(void *)(a4 + 120));
  CFStringRef v33 = 0;
  CFStringRef v34 = 0;
  if (CFEqual(v32, &unk_1ECFD1C00))
  {
LABEL_56:
    CFStringRef v47 = CFURLCopyScheme(*(CFURLRef *)(a4 + 8));
    if (valuePtr < 0) {
      SInt32 valuePtr = CFURLGetPortNumber(*(CFURLRef *)(a4 + 8));
    }
    if (!v34) {
      CFStringRef v34 = CFURLCopyHostName(*(CFURLRef *)(a4 + 8));
    }
    if (CFStringCompare(v47, @"ftp", 1uLL))
    {
      if (!CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), &unk_1EC0A10B0)) {
        _FTPStreamSetProperty(0, (__CFString *)&unk_1EC0A10B0, (const __CFString *)&unk_1EC0A13C0, a4);
      }
      if (valuePtr == -1) {
        SInt32 valuePtr = 990;
      }
      if (v33) {
        int v48 = 4;
      }
      else {
        int v48 = 2;
      }
      if (v47) {
LABEL_69:
      }
        CFRelease(v47);
    }
    else
    {
      if (valuePtr == -1) {
        SInt32 valuePtr = 21;
      }
      if (v33) {
        int v48 = 3;
      }
      else {
        int v48 = 1;
      }
      if (v47) {
        goto LABEL_69;
      }
    }
    *a3 = 0;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    if (*(void *)(a4 + 128))
    {
LABEL_121:
      if (v34) {
        CFRelease(v34);
      }
      CFStringRef v71 = *(NetConnection **)(a4 + 128);
      if (!v71 || !NetConnection::enqueue(v71, (void *)a4, 0))
      {
        *a3 = 1;
        if (*__error())
        {
          int v72 = __error();
          uint64_t result = 0;
          int v44 = *v72;
          *(void *)a2 = 1;
        }
        else
        {
          uint64_t result = 0;
          *(void *)a2 = 1;
          int v44 = 12;
        }
LABEL_130:
        *(_DWORD *)(a2 + 8) = v44;
        return result;
      }
      if (v10) {
        NetConnection::doNotAllowMoreRequests(*(NetConnection **)(a4 + 128));
      }
      return 1;
    }
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    BOOL v77 = v10;
    if (v34)
    {
      CFDictionaryRef v50 = *(const __CFDictionary **)(a4 + 88);
      SInt32 v51 = valuePtr;
      UniChar v52 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate(v8, 48, 0);
      *(_OWORD *)UniChar v52 = 0u;
      *((_OWORD *)v52 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
      *((_OWORD *)v52 + 2) = 0u;
      CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v52, v8);
      void *v53 = &unk_1ECFA5E70;
      CFDictionaryRef Copy = (AutoDict *)CFStringCreateCopy(v8, v34);
      *((void *)v52 + 3) = Copy;
      *((_DWORD *)v52 + 8) = v51;
      *((_DWORD *)v52 + 9) = v48;
      if (v50)
      {
        EmptyDict = CFDictionaryCreateCopy(v8, v50);
      }
      else
      {
        EmptyDict = (const void *)AutoDict::getEmptyDict(Copy);
        if (EmptyDict) {
          EmptyDict = CFRetain(EmptyDict);
        }
      }
      BOOL v10 = v77;
      *((void *)v52 + 5) = EmptyDict;
    }
    else
    {
      UniChar v52 = 0;
    }
    long long v80 = 0u;
    long long v81 = 0u;
    v78[0] = 0;
    long long v79 = 0u;
    v78[1] = v52;
    os_unfair_lock_lock((os_unfair_lock_t)&gFTPSpinLock);
    p_opt_class_meths = &OBJC_PROTOCOL___NSURLDownloadDecoder.opt_class_meths;
    if (!gFTPConnectionCache) {
      _FTPConnectionCacheCreate();
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&gFTPSpinLock);
    os_unfair_lock_lock((os_unfair_lock_t)(gFTPConnectionCache + 8));
    CFDictionaryApplyFunction((CFDictionaryRef)gFTPConnectionTimeouts, (CFDictionaryApplierFunction)_FTPConnectionCacheExpiration, Mutable);
    os_unfair_lock_unlock((os_unfair_lock_t)(gFTPConnectionCache + 8));
    CFAllocatorRef v76 = *(__CFDictionary **)(a4 + 88);
    if (v10)
    {
      NewConnection = (NetConnection_Classic *)createNewConnection(v8, _kFTPConnectionCallBacks, (uint64_t)v78);
      if (NewConnection)
      {
        CFCharacterSetRef v58 = NewConnection;
        setConnectionProperties(NewConnection, v76);
        goto LABEL_105;
      }
LABEL_108:
      os_unfair_lock_lock((os_unfair_lock_t)&p_opt_class_meths[335][1]);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gFTPConnectionTimeouts, *(const void **)(a4 + 128));
      BOOL v10 = v77;
      if (CFArrayGetCount(Mutable))
      {
        CFIndex v66 = CFArrayGetCount(Mutable);
        if (v66 >= 1)
        {
          unint64_t v67 = v66 + 1;
          do
          {
            uint64_t v68 = CFArrayGetValueAtIndex(Mutable, v67 - 2);
            CFDictionaryRemoveValue((CFMutableDictionaryRef)gFTPConnectionTimeouts, v68);
            if (v68 != *(const void **)(a4 + 128))
            {
              uint64_t v69 = *((void *)v68 + 12);
              if (v69) {
                pthread_mutex_lock((pthread_mutex_t *)(v69 + 8));
              }
              *((_WORD *)v68 + 44) &= ~1u;
              NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)v68);
              uint64_t v70 = *((void *)v68 + 12);
              if (v70) {
                pthread_mutex_unlock((pthread_mutex_t *)(v70 + 8));
              }
            }
            --v67;
          }
          while (v67 > 1);
        }
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(gFTPConnectionCache + 8));
      if (v52) {
        (*(void (**)(CFAllocatedReferenceCountedObject *))(*(void *)v52 + 48))(v52);
      }
      goto LABEL_121;
    }
    uint64_t v73 = _kFTPConnectionCallBacks;
    uint64_t v59 = gFTPConnectionCache;
    int64_t v60 = (os_unfair_lock_s *)(gFTPConnectionCache + 8);
    os_unfair_lock_lock((os_unfair_lock_t)(gFTPConnectionCache + 8));
    uint64_t v74 = v59;
    int64_t v61 = (NetConnection *)CFDictionaryGetValue(*(CFDictionaryRef *)(v59 + 16), v52);
    if (v61)
    {
      CFCharacterSetRef v58 = v61;
      if (NetConnection::willEnqueueRequests(v61))
      {
        int64_t v62 = v60;
        (*(void (**)(NetConnection_Classic *))(*(void *)v58 + 40))(v58);
        goto LABEL_104;
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v74 + 16), v52);
    }
    uint64_t v65 = (NetConnection_Classic *)createNewConnection(v8, v73, (uint64_t)v78);
    if (!v65)
    {
      os_unfair_lock_unlock(v60);
      p_opt_class_meths = &OBJC_PROTOCOL___NSURLDownloadDecoder.opt_class_meths;
      goto LABEL_108;
    }
    CFCharacterSetRef v58 = v65;
    int64_t v62 = v60;
    setConnectionProperties(v65, v76);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v74 + 16), v52, v58);
LABEL_104:
    p_opt_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NSURLDownloadDecoder + 48);
    os_unfair_lock_unlock(v62);
LABEL_105:
    *(void *)(a4 + 128) = v58;
    if (!*(void *)(a4 + 136)) {
      operator new();
    }
    goto LABEL_108;
  }
  uint64_t v35 = CFDictionaryGetValue((CFDictionaryRef)v32, @"kCFProxyTypeKey");
  CFIndex v36 = CFDictionaryGetValue((CFDictionaryRef)v32, @"kCFProxyPortNumberKey");
  CFStringRef v33 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v32, @"kCFProxyHostNameKey");
  if (CFEqual(v35, @"kCFProxyTypeFTP"))
  {
    uint64_t v37 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFDictionaryAddValue(v37, @"FTPProxy", v33);
    CFDictionaryAddValue(v37, @"FTPPort", v36);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a4 + 88), @"kCFStreamPropertyFTPProxy", v37);
    if (v37) {
      CFRelease(v37);
    }
    if (v33) {
      CFRetain(v33);
    }
    CFNumberGetValue((CFNumberRef)v36, kCFNumberSInt32Type, &valuePtr);
    CFStringRef v34 = v33;
    goto LABEL_56;
  }
  if (CFEqual(v35, @"kCFProxyTypeSOCKS"))
  {
    UniChar v45 = CFDictionaryGetValue((CFDictionaryRef)v32, @"kCFProxyUsernameKey");
    int64_t v46 = CFDictionaryGetValue((CFDictionaryRef)v32, @"kCFProxyPasswordKey");
    _SetSOCKS5ProxyInformation(v8, a4, v33, v36, v45, v46);
    CFStringRef v33 = 0;
LABEL_55:
    CFStringRef v34 = 0;
    goto LABEL_56;
  }
  if (!CFEqual(v35, @"kCFProxyTypeHTTP") && !CFEqual(v35, @"kCFProxyTypeHTTPS")) {
    goto LABEL_55;
  }
  LODWORD(v84[0]) = 0;
  if ((*(_WORD *)a4 & 0x80) != 0)
  {
    ++*(void *)(a4 + 120);
    return _FTPStreamOpen(a1, a2, a3, a4);
  }
  else
  {
    CFNumberGetValue((CFNumberRef)v36, kCFNumberSInt32Type, v84);
    CFStringRef v63 = CFStringCreateWithFormat(v8, 0, @"http://%@:%d", v33, LODWORD(v84[0]));
    CFURLRef v64 = CFURLCreateWithString(v8, v63, 0);
    if (v63) {
      CFRelease(v63);
    }
    _StartHTTPRequest(v8, (_WORD *)a4, (void *)a2, v64);
    if (v64) {
      CFRelease(v64);
    }
    *a3 = 1;
    return *(_DWORD *)(a2 + 8) == 0;
  }
}

void sub_184194140(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x1081C4076DFA842);
  _Unwind_Resume(a1);
}

void _SetSOCKS5ProxyInformation(const __CFAllocator *a1, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F1D460], a3);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F1D468], a4);
  if (a5) {
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F1D470], a5);
  }
  if (a6) {
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F1D450], a6);
  }
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 88), &unk_1EC0A1120, Mutable);
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

void _StartHTTPRequest(const __CFAllocator *a1, _WORD *a2, void *a3, const __CFURL *a4)
{
  v38.version = 0;
  v38.info = a2;
  memset(&v38.retain, 0, 24);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), @"kCFStreamPropertyFTPUserName");
  CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), @"kCFStreamPropertyFTPPassword");
  BOOL v10 = (__CFHTTPMessage *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), @"_kCFStreamPropertyFTPLastHTTPResponse");
  *a2 |= 0x10u;
  *a3 = 0;
  a3[1] = 0;
  if (Value)
  {
    CFRetain(Value);
    if (v9)
    {
LABEL_3:
      CFRetain(v9);
      goto LABEL_6;
    }
  }
  else
  {
    CFStringRef Value = CFURLCopyUserName(*((CFURLRef *)a2 + 1));
    if (v9) {
      goto LABEL_3;
    }
  }
  CFStringRef v9 = CFURLCopyPassword(*((CFURLRef *)a2 + 1));
LABEL_6:
  *(_OWORD *)CFTypeRef cf = 0u;
  *(_OWORD *)uint64_t v43 = 0u;
  *(_OWORD *)std::string::size_type v40 = 0u;
  *(_OWORD *)CFIndex v41 = 0u;
  *(_OWORD *)int64_t v39 = 0u;
  _CFURLCopyComponents();
  if (Value) {
    CFStringRef v11 = CFURLCreateStringByAddingPercentEscapes(a1, Value, 0, 0, 0x8000100u);
  }
  else {
    CFStringRef v11 = 0;
  }
  v39[1] = v11;
  if (!v40[0])
  {
    if (v9) {
      CFStringRef v12 = CFURLCreateStringByAddingPercentEscapes(a1, v9, 0, 0, 0x8000100u);
    }
    else {
      CFStringRef v12 = 0;
    }
    v40[0] = v12;
  }
  if (cf[1])
  {
    CFRelease(cf[1]);
    cf[1] = 0;
  }
  if (v43[0])
  {
    CFRelease(v43[0]);
    v43[0] = 0;
  }
  if (cf[0])
  {
    CFRelease(cf[0]);
    cf[0] = 0;
  }
  if (Value) {
    CFRelease(Value);
  }
  if (v9) {
    CFRelease(v9);
  }
  CFURLRef v13 = (const __CFURL *)_CFURLCreateFromComponents();
  if (v39[0]) {
    CFRelease(v39[0]);
  }
  if (v39[1]) {
    CFRelease(v39[1]);
  }
  if (v40[0]) {
    CFRelease(v40[0]);
  }
  if (v40[1]) {
    CFRelease(v40[1]);
  }
  if (v41[1]) {
    CFRelease(v41[1]);
  }
  if (v43[1]) {
    CFRelease(v43[1]);
  }
  if (v13)
  {
    Request = CFHTTPMessageCreateRequest(a1, @"GET", v13, @"HTTP/1.1");
    CFRelease(v13);
    if (!v10) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
  Request = CFHTTPMessageCreateRequest(a1, @"GET", *((CFURLRef *)a2 + 1), @"HTTP/1.1");
  if (v10)
  {
LABEL_38:
    CFStringRef v15 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), @"kCFStreamPropertyFTPProxyUser");
    CFStringRef v16 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), @"kCFStreamPropertyFTPProxyPassword");
    CFHTTPMessageAddAuthentication(Request, v10, v15, v16, 0, 1u);
  }
LABEL_39:
  valuePtr[0] = MEMORY[0x1E4F143A8];
  valuePtr[1] = 3221225472;
  void valuePtr[2] = __CFReadStreamCreateForHTTPRequest_block_invoke;
  valuePtr[3] = &__block_descriptor_48_e26__v16__0____CFReadStream__8l;
  valuePtr[4] = a1;
  valuePtr[5] = Request;
  CFDictionaryRef v17 = (__CFReadStream *)CFReadStreamCreate();
  if (v17)
  {
    uint64_t v18 = v17;
    uint64_t v19 = CoreReadStreamCreateWithCFReadStream(a1, v17);
    CFRelease(v18);
  }
  else
  {
    uint64_t v19 = 0;
  }
  *((void *)a2 + 3) = v19;
  CFRelease(Request);
  if (*((void *)a2 + 3))
  {
    CFStringRef v20 = CFURLCopyScheme(a4);
    CFStringRef v21 = CFURLCopyHostName(a4);
    LODWORD(valuePtr[0]) = CFURLGetPortNumber(a4);
    CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFNumberRef v23 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, valuePtr);
    BOOL v24 = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), @"kCFStreamPropertyFTPAttemptPersistentConnection");
    if (v21)
    {
      CFStringRef Copy = CFStringCreateCopy(v22, v21);
      CFRelease(v21);
    }
    else
    {
      CFStringRef Copy = 0;
    }
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (CFStringCompare(v20, @"http", 1uLL))
    {
      CFDictionarySetValue(Mutable, &unk_1EC0A3CE0, Copy);
      uint64_t v28 = (__CFString *)&unk_1EC0A3CA8;
    }
    else
    {
      CFDictionarySetValue(Mutable, @"FTPProxy", Copy);
      uint64_t v28 = @"FTPPort";
    }
    CFDictionarySetValue(Mutable, v28, v23);
    uint64_t v29 = *((void *)a2 + 3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v29) {
      uint64_t v30 = v29 + 16;
    }
    else {
      uint64_t v30 = 0;
    }
    ++*(void *)(v30 + 80);
    (*(void (**)(void, void *, __CFDictionary *))(**(void **)(v30 + 24) + 32))(*(void *)(v30 + 24), &unk_1EC0A3EA0, Mutable);
    --*(void *)(v30 + 80);
    if (Mutable) {
      CFRelease(Mutable);
    }
    uint64_t v31 = *MEMORY[0x1E4F1CFD0];
    if (!v24 || CFEqual(v24, (CFTypeRef)*MEMORY[0x1E4F1CFD0]))
    {
      uint64_t v32 = *((void *)a2 + 3);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      if (v32) {
        uint64_t v33 = v32 + 16;
      }
      else {
        uint64_t v33 = 0;
      }
      ++*(void *)(v33 + 80);
      (*(void (**)(void, void *, uint64_t))(**(void **)(v33 + 24) + 32))(*(void *)(v33 + 24), &unk_1EC0A3DC0, v31);
      --*(void *)(v33 + 80);
    }
    CFDictionaryApplyFunction(*((CFDictionaryRef *)a2 + 11), (CFDictionaryApplierFunction)_StreamPropertyApplier, *((void **)a2 + 3));
    uint64_t v34 = *((void *)a2 + 3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v34) {
      uint64_t v35 = v34 + 16;
    }
    else {
      uint64_t v35 = 0;
    }
    CoreReadStream::setClient(v35, -1, (uint64_t)_DataStreamCallBack, &v38);
    _CFTypeScheduleOnMultipleRunLoops(*((void **)a2 + 3), *((const __CFArray **)a2 + 10));
    uint64_t v36 = *((void *)a2 + 3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v36) {
      uint64_t v37 = (CoreStreamBase *)(v36 + 16);
    }
    else {
      uint64_t v37 = 0;
    }
    CoreStreamBase::_streamInterface_Open(v37);
    if (Copy) {
      CFRelease(Copy);
    }
    if (v23) {
      CFRelease(v23);
    }
    if (v20) {
      CFRelease(v20);
    }
  }
  else
  {
    if (*__error())
    {
      int v26 = *__error();
      *a3 = 1;
    }
    else
    {
      *a3 = 1;
      int v26 = 12;
    }
    *((_DWORD *)a3 + 2) = v26;
  }
}

void _FTPConnectionCacheCreate(void)
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (!_kFTPConnectionCallBacks)
  {
    uint64_t v1 = CFAllocatorAllocate(v0, 80, 0);
    _kFTPConnectionCallBacks = (uint64_t)v1;
    *uint64_t v1 = 0;
    v1[1] = _CFFTPNetConnectionContextAllocate;
    v1[2] = _CFFTPNetConnectionContextFinalize;
    v1[3] = _FTPConnectionCreateStreams;
    v1[4] = _FTPConnectionRequestStateChanged;
    v1[5] = _FTPConnectionTransmitRequest;
    v1[6] = _FTPConnectionReceiveResponse;
    v1[7] = _FTPResponseStreamCallBack;
    v1[8] = _FTPRequestStreamCallBack;
    v1[9] = _FTPCopyRunLoopArrayCallBack;
  }
  gFTPConnectionTimeouts = (uint64_t)CFDictionaryCreateMutable(v0, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, MEMORY[0x1E4F1D540]);
  operator new();
}

void sub_184194A54(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10A1C406B6A53AFLL);
  _Unwind_Resume(a1);
}

uint64_t NetConnection::doNotAllowMoreRequests(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  *((_WORD *)this + 44) &= ~1u;
  uint64_t result = NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
  uint64_t v4 = *((void *)this + 12);
  if (v4)
  {
    return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  }
  return result;
}

void _FTPConnectionCacheExpiration(const void *a1, uint64_t a2, __CFArray *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (Current >= MEMORY[0x185319AB0](a2))
  {
    CFArrayAppendValue(a3, a1);
  }
}

CFArrayRef _FTPCopyRunLoopArrayCallBack(uint64_t a1)
{
  return CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFArrayRef *)(a1 + 80));
}

void _FTPRequestStreamCallBack(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  if (a3 == 16) {
    goto LABEL_24;
  }
  if (a3 == 8)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    uint64_t v8 = a2 + 16;
    if (!a2) {
      uint64_t v8 = 0;
    }
    long long v9 = *(_OWORD *)(v8 + 56);
    goto LABEL_25;
  }
  if (a3 != 4) {
    return;
  }
  if ((*(unsigned char *)a5 & 0x10) == 0)
  {
    _FTPConnectionTransmitRequest(a1, a4, a5);
    return;
  }
  if (!*(void *)(a5 + 40)) {
    return;
  }
  MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a5 + 56));
  uint64_t v11 = *(void *)(a5 + 40);
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    uint64_t v15 = *(void *)(a5 + 40);
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    uint64_t v11 = v15;
  }
  if (a2) {
    uint64_t v12 = a2 + 16;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)v12, MutableBytePtr, v11);
  if (v13 < 0)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    long long v9 = *(_OWORD *)(v12 + 56);
    goto LABEL_25;
  }
  if (!v13)
  {
LABEL_24:
    long long v9 = xmmword_1843D1930;
LABEL_25:
    long long v16 = v9;
    _ReportError(a1, (CFStreamError *)&v16);
    return;
  }
  size_t v14 = *(void *)(a5 + 40) - v13;
  *(void *)(a5 + 40) = v14;

  memmove(MutableBytePtr, &MutableBytePtr[v13], v14);
}

void _FTPConnectionTransmitRequest(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[12];
  if (!v6)
  {
    uint64_t v8 = a2[18];
LABEL_7:
    uint64_t v11 = a2[19];
    goto LABEL_8;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  uint64_t v7 = a2[12];
  uint64_t v8 = a2[18];
  if (!v7) {
    goto LABEL_7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  uint64_t v9 = a2[12];
  if (!v9) {
    goto LABEL_7;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  uint64_t v10 = a2[12];
  uint64_t v11 = a2[19];
  if (v10) {
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
  }
LABEL_8:
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  if (v8) {
    uint64_t v12 = (CoreStreamBase *)(v8 + 16);
  }
  else {
    uint64_t v12 = 0;
  }
  if (CoreStreamBase::_streamInterface_CanWrite(v12))
  {
    if ((*(unsigned char *)a3 & 0x10) != 0)
    {
      _FTPRequestStreamCallBack(a1, v8, 4, a2, a3);
    }
    else
    {
      CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kCFStreamPropertyFTPUserName");
      CFAllocatorRef v14 = CFGetAllocator(*(CFTypeRef *)(a1 + 80));
      uint64_t v15 = *(void *)(a3 + 8);
      uint64_t v16 = *(void *)(v15 + 24);
      int v17 = *(_DWORD *)(v15 + 36);
      uint64_t v18 = *(int *)(v15 + 32);
      if (Value)
      {
        CFRetain(Value);
      }
      else
      {
        CFStringRef Value = CFURLCopyUserName(*(CFURLRef *)(a1 + 8));
        if (!Value) {
          CFStringRef Value = CFRetain(@"anonymous");
        }
      }
      if ((v17 - 3) <= 1)
      {
        BOOL v20 = v17 == 4 && v18 == 990;
        BOOL v21 = v18 == 21 && v17 == 3;
        if (v21 || v20) {
          CFStringRef v22 = CFStringCreateWithFormat(v14, 0, @"%@@%@", Value, v16);
        }
        else {
          CFStringRef v22 = CFStringCreateWithFormat(v14, 0, @"%@@%@:%ld", Value, v16, v18);
        }
        CFStringRef v23 = v22;
        CFRelease(Value);
        CFStringRef Value = v23;
      }
      CFStringRef v24 = CFStringCreateWithFormat(v14, 0, @"USER %@\r\n", Value);
      CFRelease(Value);
      *(unsigned char *)a3 |= 0x10u;
      if (v24)
      {
        _WriteCommand(a3, a1, v24);
        CFRelease(v24);
      }
      else
      {
        long long v32 = xmmword_1843D16F0;
        SInt32 v25 = *__error();
        if (!v25) {
          SInt32 v25 = 12;
        }
        DWORD2(v32) = v25;
        _ReportError(a1, (CFStreamError *)&v32);
      }
    }
  }
  if (*(void *)(a1 + 128))
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v11) {
      int v26 = (CoreStreamBase *)(v11 + 16);
    }
    else {
      int v26 = 0;
    }
    if (CoreStreamBase::_streamInterface_CanRead(v26))
    {
      uint64_t v27 = a2[12];
      if (v27)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v27 + 8));
        uint64_t v28 = a2[12];
        uint64_t v29 = a2[19];
        if (v28) {
          pthread_mutex_unlock((pthread_mutex_t *)(v28 + 8));
        }
      }
      else
      {
        uint64_t v29 = a2[19];
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      if (v29) {
        uint64_t v30 = (CoreStreamBase *)(v29 + 16);
      }
      else {
        uint64_t v30 = 0;
      }
      if (CoreStreamBase::_streamInterface_CanRead(v30)) {
        _FTPResponseStreamCallBack(a1, v29, 2, v31, a3);
      }
    }
  }
}

CFIndex _WriteCommand(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  CFIndex v7 = CFStringGetLength(a3);
  v19.location = 0;
  v19.CFIndex length = v7;
  CFIndex Bytes = CFStringGetBytes(a3, v19, 0, 0x5Fu, 0, 0, 0, 0);
  uint64_t v9 = *(void *)(a2 + 128);
  uint64_t v10 = *(void *)(v9 + 96);
  if (v10)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
    uint64_t v11 = *(void *)(v9 + 96);
    uint64_t v12 = *(void *)(v9 + 144);
    if (v11) {
      pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
    }
  }
  else
  {
    uint64_t v12 = *(void *)(v9 + 144);
  }
  if (Length - *(void *)(a1 + 40) < Bytes) {
    CFDataSetLength(*(CFMutableDataRef *)(a1 + 56), Bytes + *(void *)(a1 + 40));
  }
  MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 56));
  v20.location = 0;
  v20.CFIndex length = v7;
  CFIndex result = CFStringGetBytes(a3, v20, 0, 0x5Fu, 0, &MutableBytePtr[*(void *)(a1 + 40)], Bytes, 0);
  CFIndex v15 = *(void *)(a1 + 40) + Bytes;
  *(void *)(a1 + 40) = v15;
  if (v15)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    if (v12) {
      uint64_t v16 = (CoreStreamBase *)(v12 + 16);
    }
    else {
      uint64_t v16 = 0;
    }
    CFIndex result = CoreStreamBase::_streamInterface_CanWrite(v16);
    if (result)
    {
      uint64_t v17 = *(void *)(a2 + 128);
      return _FTPRequestStreamCallBack(a2, v12, 4, v17, a1);
    }
  }
  return result;
}

void _FTPResponseStreamCallBack(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  switch(a3)
  {
    case 16:
      goto LABEL_115;
    case 8:
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      uint64_t v13 = a2 + 16;
      if (!a2) {
        uint64_t v13 = 0;
      }
      long long v14 = *(_OWORD *)(v13 + 56);
      break;
    case 2:
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(a5 + 48));
      uint64_t v9 = *(void *)(a5 + 32);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      uint64_t v10 = a2 ? a2 + 16 : 0;
      if (!CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)v10)) {
        return;
      }
      uint64_t v11 = Length - v9;
      if (v11 <= 2047)
      {
        CFDataSetLength(*(CFMutableDataRef *)(a5 + 48), *(void *)(a5 + 32) + 2048);
        if (CFDataGetLength(*(CFDataRef *)(a5 + 48)) < *(void *)(a5 + 32) + 2048)
        {
          uint64_t v12 = &xmmword_1843D1960;
LABEL_116:
          long long v14 = *v12;
          break;
        }
        uint64_t v11 = 2048;
      }
      CFIndex v15 = &CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a5 + 48))[*(void *)(a5 + 32)];
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      uint64_t v16 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)v10, v15, v11);
      if ((v16 & 0x8000000000000000) == 0)
      {
        if (v16)
        {
          uint64_t v17 = *(void *)(a5 + 32) + v16;
          *(void *)(a5 + 32) = v17;
          if (!v17) {
            return;
          }
          uint64_t v18 = MEMORY[0x1E4F14390];
          while (1)
          {
            int v44 = 0;
            UniChar v45 = 0;
            MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a5 + 48));
            uint64_t Line = _FindLine(MutableBytePtr, *(void *)(a5 + 32), (const unsigned __int8 **)&v45, (const unsigned __int8 **)&v44);
            if (!Line) {
              return;
            }
            uint64_t v21 = Line;
            CFStringRef v22 = v45;
            if (!v45) {
              goto LABEL_101;
            }
            int64_t v23 = v44 - v45;
            if (v44 - v45 < 4) {
              break;
            }
            uint64_t v24 = *v45;
            if ((*(_DWORD *)(v18 + 4 * v24 + 60) & 0x400) == 0) {
              break;
            }
            uint64_t v25 = v45[1];
            if ((*(_DWORD *)(v18 + 4 * v25 + 60) & 0x400) == 0) {
              break;
            }
            uint64_t v26 = v45[2];
            if ((*(_DWORD *)(v18 + 4 * v26 + 60) & 0x400) == 0) {
              break;
            }
            int v27 = v45[3];
            if (v27 != 45 && v27 != 32) {
              break;
            }
            int v28 = 100 * v24 + 10 * v25 + v26;
            if ((v28 - 5428) > 0x1F3) {
              break;
            }
            SInt32 v29 = v28 - 5328;
            if (v27 == 32)
            {
              char v30 = *(unsigned char *)a5;
              if ((*(unsigned char *)a5 & 1) != 0 && v29 != *(_DWORD *)(a5 + 16))
              {
                long long v46 = xmmword_1843D1700;
                DWORD2(v46) = v29;
                goto LABEL_126;
              }
              *(_DWORD *)(a5 + 16) = v29;
              char v31 = v30 & 0xFE;
            }
            else
            {
              if (v29 == -1) {
                break;
              }
              *(_DWORD *)(a5 + 16) = v29;
              char v31 = *(unsigned char *)a5 | 1;
            }
            *(unsigned char *)a5 = v31;
LABEL_42:
            int v32 = *(_DWORD *)(a5 + 20);
            if ((v31 & 2) != 0)
            {
              if (v32 > 8)
              {
                if (v32 <= 0xE)
                {
                  if ((v31 & 1) == 0)
                  {
                    *(_DWORD *)(a5 + 20) = 8;
                    _StartProcess(a5, a1);
                  }
                  goto LABEL_101;
                }
              }
              else
              {
                *(unsigned char *)a5 = v31 & 0xFD;
              }
            }
            switch(v32)
            {
              case 0:
                if ((v31 & 1) == 0) {
                  _HandleConnect(a5, a1, v22, v23);
                }
                break;
              case 1:
                if ((v31 & 1) == 0) {
                  _HandleUsername(a5, a1);
                }
                break;
              case 2:
                if ((v31 & 1) == 0) {
                  _HandlePassword(a5, a1);
                }
                break;
              case 3:
                if ((v31 & 1) == 0) {
                  _HandleSystem(a5, a1, v22, v23);
                }
                break;
              case 4:
                if ((v31 & 1) == 0) {
                  _HandleSiteDirStyle(a5, a1, v22, v23);
                }
                break;
              case 5:
                if ((v31 & 1) == 0)
                {
                  *(_DWORD *)(a5 + 20) = 6;
                  _WriteCommand(a5, a1, @"PWD\r\n");
                }
                break;
              case 6:
                if ((v31 & 1) == 0) {
                  _HandlePrintWorkingDirectory(a5, a1, (char *)v22, v23);
                }
                break;
              case 7:
                if ((v31 & 1) == 0) {
                  _HandleType(a5, a1);
                }
                break;
              case 9:
                if ((v31 & 1) == 0) {
                  _HandleChangeDirectory(a5, a1);
                }
                break;
              case 10:
                if ((v31 & 1) == 0) {
                  _HandlePassive(a5, (_WORD *)a1, (uint64_t)v22);
                }
                break;
              case 11:
                if ((v31 & 1) == 0) {
                  _HandlePort(a5, a1);
                }
                break;
              case 12:
                if (!*(void *)(a1 + 64))
                {
                  CFAllocatorRef v33 = CFGetAllocator(*(CFTypeRef *)(a1 + 88));
                  CFFTPCreateParsedResourceListing(v33, v22, v23, (CFDictionaryRef *)(a1 + 64));
                }
                if ((v31 & 1) != 0 || (*(_DWORD *)(v18 + 4 * *v22 + 60) & 0x400) == 0) {
                  break;
                }
                CFAllocatorRef v34 = CFGetAllocator(*(CFTypeRef *)(a1 + 88));
                CFAllocatorRef v35 = v34;
                if (*(void *)(a1 + 72))
                {
                  CFStringRef v36 = CFStringCreateWithFormat(v34, 0, @"REST %lld\r\n", *(void *)(a1 + 72));
                  *(_DWORD *)(a5 + 20) = 14;
LABEL_77:
                  _WriteCommand(a5, a1, v36);
                  if (v36) {
                    CFRelease(v36);
                  }
                  break;
                }
                CFStringRef PathForContext = _CreatePathForContext(v34, a5, *(__CFURL **)(a1 + 8));
                if (PathForContext)
                {
                  CFStringRef v40 = PathForContext;
                  CFStringRef v36 = CFStringCreateWithFormat(v35, 0, @"RETR %@\r\n", PathForContext);
                  *(_DWORD *)(a5 + 20) = 15;
                  *(_WORD *)a1 &= ~0x800u;
                  CFRelease(v40);
                  uint64_t v41 = *(void *)(a1 + 24);
                  if (v41)
                  {
                    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
                      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
                    }
                    CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v41 + 16));
                  }
                  goto LABEL_77;
                }
                long long v46 = xmmword_1843D1920;
                _ReportError(a1, (CFStreamError *)&v46);
                break;
              case 13:
                if ((v31 & 1) == 0) {
                  _HandleSize(a5, a1, (uint64_t)v22, v23);
                }
                break;
              case 14:
                if ((v31 & 1) == 0) {
                  _HandleRestart(a5, a1);
                }
                break;
              case 15:
                if ((v31 & 1) == 0) {
                  goto LABEL_90;
                }
                break;
              case 16:
                if ((v31 & 1) == 0) {
                  goto LABEL_90;
                }
                break;
              case 17:
                if ((v31 & 1) == 0) {
                  goto LABEL_90;
                }
                break;
              case 18:
                if ((v31 & 1) == 0) {
LABEL_90:
                }
                  _HandleRetrieve(a5, a1);
                break;
              case 19:
                if ((v31 & 1) == 0) {
                  goto LABEL_100;
                }
                break;
              case 20:
                if ((v31 & 1) == 0) {
                  goto LABEL_100;
                }
                break;
              case 21:
                if ((v31 & 1) == 0) {
                  goto LABEL_100;
                }
                break;
              case 22:
                if ((v31 & 1) == 0) {
                  _HandleRenameFrom(a5, a1);
                }
                break;
              case 23:
                if ((v31 & 1) == 0) {
LABEL_100:
                }
                  _HandleMakeDirectory(a5, a1);
                break;
              default:
                break;
            }
LABEL_101:
            uint64_t v37 = *(void *)(a5 + 32);
            size_t v38 = v37 - v21;
            *(void *)(a5 + 32) = v37 - v21;
            if (v37 != v21)
            {
              memmove(MutableBytePtr, &MutableBytePtr[v21], v38);
              size_t v38 = *(void *)(a5 + 32);
            }
            if (!v38) {
              return;
            }
          }
          char v31 = *(unsigned char *)a5;
          if ((*(unsigned char *)a5 & 1) == 0)
          {
            long long v46 = xmmword_1843D1710;
            SInt32 v29 = -1;
LABEL_126:
            *(_DWORD *)(a5 + 16) = v29;
            goto LABEL_118;
          }
          goto LABEL_42;
        }
        if ((*(unsigned char *)a5 & 8) != 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 136) + 8));
          uint64_t v42 = *(void *)(a1 + 128);
          if (v42)
          {
            (*(void (**)(uint64_t))(*(void *)v42 + 72))(v42);
            NetConnection::dequeue(*(NetConnection **)(a1 + 128), (void *)a1);
            uint64_t v43 = *(void *)(a1 + 128);
            if (v43) {
              (*(void (**)(uint64_t))(*(void *)v43 + 48))(v43);
            }
            *(void *)(a1 + 128) = 0;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 136) + 8));
          _FTPStreamOpen(*(void *)(a1 + 32), &v46, &v45, a1);
          return;
        }
LABEL_115:
        uint64_t v12 = &xmmword_1843D1930;
        goto LABEL_116;
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      long long v14 = *(_OWORD *)(v10 + 56);
      break;
    default:
      return;
  }
  long long v46 = v14;
LABEL_118:
  _ReportError(a1, (CFStreamError *)&v46);
}

uint64_t _FindLine(const unsigned __int8 *a1, uint64_t a2, const unsigned __int8 **a3, const unsigned __int8 **a4)
{
  uint64_t v4 = 0;
  *a3 = 0;
  *a4 = 0;
  if (a1 && a2)
  {
    CFIndex v5 = &a1[a2 - 1];
    if (v5 < a1)
    {
      return a2;
    }
    else
    {
      uint64_t v6 = a1;
      while (1)
      {
        int v7 = *v6;
        if (v7 != 10 && v7 != 13) {
          break;
        }
        if (++v6 > v5) {
          return a2;
        }
      }
      if (v6 <= v5)
      {
        for (CFIndex i = v6 + 1; v7 != 10 && v7 != 13; ++i)
        {
          if (i > v5) {
            return v6 - a1;
          }
          unsigned __int8 v12 = *i;
          LOBYTE(v7) = v12;
        }
        uint64_t v13 = i - 1;
        *a3 = v6;
        *a4 = v13;
        do
        {
          int v14 = *v13;
          if (v14 != 13 && v14 != 10) {
            break;
          }
          ++v13;
        }
        while (v13 <= v5);
        return v13 - a1;
      }
      else
      {
        return v6 - a1;
      }
    }
  }
  return v4;
}

void _StartProcess(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)a2 & 0x200) != 0)
  {
    CFTypeID v6 = CFGetTypeID(*(CFTypeRef *)(a2 + 32));
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v7 = *(void *)(a2 + 32);
    if (v7) {
      uint64_t v8 = (CoreStreamBase *)(v7 + 16);
    }
    else {
      uint64_t v8 = 0;
    }
    if (v6 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
      && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    v15.CFIndex domain = 0;
    *(void *)&v15.SInt32 error = 0;
    CoreStreamBase::_signalEvent(v8, 1, v15, 1);
    _ConnectionComplete(a1, a2);
  }
  else
  {
    CFAllocatorRef v4 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
    *(unsigned char *)a1 &= ~2u;
    if ((*(unsigned char *)a2 & 0x80) == 0
      && (CFURLHasDirectoryPath(*(CFURLRef *)(a2 + 8)) || _IsRoot(*(const __CFURL **)(a2 + 8))))
    {
      CFStringRef PathForContext = _CreatePathForContext(v4, a1, *(__CFURL **)(a2 + 8));
      if (!PathForContext)
      {
LABEL_6:
        long long v13 = xmmword_1843D1920;
        _ReportError(a2, (CFStreamError *)&v13);
        return;
      }
    }
    else
    {
      CFURLRef v9 = *(const __CFURL **)(a2 + 8);
      CFStringRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(v4, v9);
      *(void *)(a2 + 8) = PathComponent;
      CFStringRef PathForContext = _CreatePathForContext(v4, a1, PathComponent);
      uint64_t v11 = *(const void **)(a2 + 8);
      if (v11) {
        CFRelease(v11);
      }
      *(void *)(a2 + 8) = v9;
      if (!PathForContext) {
        goto LABEL_6;
      }
    }
    CFStringRef v12 = CFStringCreateWithFormat(v4, 0, @"CWD %@\r\n", PathForContext);
    CFRelease(PathForContext);
    *(_DWORD *)(a1 + 20) = 9;
    _WriteCommand(a1, a2, v12);
    if (v12)
    {
      CFRelease(v12);
    }
  }
}

void _HandleConnect(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4)
{
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4 >= 0xC8)
  {
    if (v4 < 0x12C)
    {
      CFAllocatorRef v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 80));
      CFStringRef v9 = CFStringCreateWithBytes(v8, a3, a4, 0x8000100u, 0);
      if (v9 || (CFStringRef v9 = CFStringCreateWithBytes(v8, a3, a4, 0x201u, 0)) != 0)
      {
        v11.CFIndex length = CFStringGetLength(v9);
        v11.location = 0;
        if (CFStringFindWithOptions(v9, @"Mac OS X Server", v11, 0, 0)) {
          *(unsigned char *)a1 |= 4u;
        }
        CFRelease(v9);
      }
      *(_DWORD *)(a1 + 20) = 1;
    }
    else
    {
      long long v10 = xmmword_1843D1700;
      DWORD2(v10) = v4;
      _ReportError(a2, (CFStreamError *)&v10);
    }
  }
}

void _HandleUsername(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  if (v3 - 400 <= 0xFFFFFF37)
  {
    long long v9 = xmmword_1843D1700;
LABEL_3:
    DWORD2(v9) = v3;
    _ReportError(a2, (CFStreamError *)&v9);
    return;
  }
  if (v3 < 0x12C)
  {
    *(_DWORD *)(a1 + 20) = 3;
    _WriteCommand(a1, a2, @"SYST\r\n");
  }
  else
  {
    CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 88), @"kCFStreamPropertyFTPPassword");
    if (Value)
    {
      CFTypeID v6 = Value;
      CFRetain(Value);
    }
    else
    {
      CFTypeID v6 = CFURLCopyPassword(*(CFURLRef *)(a2 + 8));
      if (!v6) {
        CFTypeID v6 = CFRetain(@"cfnetwork@apple.com");
      }
    }
    CFAllocatorRef v7 = CFGetAllocator(*(CFTypeRef *)(a2 + 80));
    CFStringRef v8 = CFStringCreateWithFormat(v7, 0, @"PASS %@\r\n", v6);
    if (v6) {
      CFRelease(v6);
    }
    if (!v8)
    {
      long long v9 = xmmword_1843D16F0;
      unsigned int v3 = *__error();
      if (!v3) {
        unsigned int v3 = 12;
      }
      goto LABEL_3;
    }
    *(_DWORD *)(a1 + 20) = 2;
    _WriteCommand(a1, a2, v8);
    CFRelease(v8);
  }
}

void _HandlePassword(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  if (v2 - 400 > 0xFFFFFF37 && v2 < 0x12C)
  {
    *(_DWORD *)(a1 + 20) = 3;
    _WriteCommand(a1, a2, @"SYST\r\n");
  }
  else
  {
    long long v3 = xmmword_1843D1700;
    DWORD2(v3) = v2;
    _ReportError(a2, (CFStreamError *)&v3);
  }
}

void _HandleSystem(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4)
{
  if ((*(_DWORD *)(a1 + 16) - 200) > 0x63)
  {
    CFStringRef v9 = 0;
    goto LABEL_6;
  }
  CFAllocatorRef v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  CFStringRef v9 = CFStringCreateWithBytes(v8, a3, a4, 0x8000100u, 0);
  CFIndex Length = CFStringGetLength(v9);
  if (!v9)
  {
LABEL_6:
    char v11 = 1;
    goto LABEL_7;
  }
  v14.CFIndex length = Length;
  v14.location = 0;
  if (CFStringFindWithOptions(v9, @"Windows_NT", v14, 0, 0))
  {
    *(_DWORD *)(a1 + 20) = 4;
    _WriteCommand(a1, a2, @"SITE DIRSTYLE\r\n");
LABEL_11:
    CFRelease(v9);
    return;
  }
  char v11 = 0;
LABEL_7:
  if ((*(unsigned char *)a1 & 4) != 0)
  {
    *(_DWORD *)(a1 + 20) = 5;
    CFStringRef v12 = @"SITE TRUTH ON\r\n";
  }
  else
  {
    *(_DWORD *)(a1 + 20) = 6;
    CFStringRef v12 = @"PWD\r\n";
  }
  _WriteCommand(a1, a2, v12);
  if ((v11 & 1) == 0) {
    goto LABEL_11;
  }
}

void _HandleSiteDirStyle(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4)
{
  if ((*(_DWORD *)(a1 + 16) - 200) <= 0x63)
  {
    CFAllocatorRef v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
    CFStringRef v9 = CFStringCreateWithBytes(v8, a3, a4, 0x8000100u, 0);
    v12.CFIndex length = CFStringGetLength(v9);
    v12.location = 0;
    if (CFStringFindWithOptions(v9, @"MSDOS-like directory output is on", v12, 0, 0))
    {
      *(_DWORD *)(a1 + 20) = 4;
      _WriteCommand(a1, a2, @"SITE DIRSTYLE\r\n");
      if (v9)
      {
        CFRelease(v9);
      }
      return;
    }
    if (v9) {
      CFRelease(v9);
    }
  }
  if ((*(unsigned char *)a1 & 4) != 0)
  {
    *(_DWORD *)(a1 + 20) = 5;
    CFStringRef v10 = @"SITE TRUTH ON\r\n";
  }
  else
  {
    *(_DWORD *)(a1 + 20) = 6;
    CFStringRef v10 = @"PWD\r\n";
  }

  _WriteCommand(a1, a2, v10);
}

CFIndex _HandlePrintWorkingDirectory(uint64_t a1, uint64_t a2, char *__s, size_t __n)
{
  if ((*(_DWORD *)(a1 + 16) - 200) <= 0x63)
  {
    CFAllocatorRef v8 = (char *)memchr(__s, 34, __n);
    if (v8)
    {
      CFStringRef v9 = (const UInt8 *)(v8 + 1);
      CFStringRef v10 = (const UInt8 *)&__s[__n - 1];
      while (v10 != v9)
      {
        char v11 = v10;
        CFRange v12 = (char *)(v10 + 1);
        int v13 = *v10--;
        if (v13 == 34)
        {
          int v15 = *(v12 - 2);
          CFRange v14 = v12 - 2;
          if (v15 == 47) {
            uint64_t v16 = (const UInt8 *)v14;
          }
          else {
            uint64_t v16 = v11;
          }
          CFAllocatorRef v17 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
          *(void *)(a1 + 24) = CFStringCreateWithBytes(v17, v9, v16 - v9, 0x8000100u, 0);
          break;
        }
      }
    }
  }
  *(_DWORD *)(a1 + 20) = 7;

  return _WriteCommand(a1, a2, @"TYPE I\r\n");
}

void _HandleType(uint64_t a1, uint64_t a2)
{
  SInt32 v2 = *(_DWORD *)(a1 + 16);
  if ((v2 - 300) > 0xFFFFFF9B)
  {
    *(_DWORD *)(a1 + 20) = 8;
    _StartProcess(a1, a2);
  }
  else
  {
    long long v3 = xmmword_1843D1700;
    DWORD2(v3) = v2;
    _ReportError(a2, (CFStreamError *)&v3);
  }
}

void _HandlePassive(uint64_t a1, _WORD *a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 - 300) <= 0xFFFFFF9B)
  {
    *(_OWORD *)int v44 = xmmword_1843D1700;
    *(_DWORD *)&v44[8] = v5;
    CFTypeID v6 = (CFStreamError *)v44;
LABEL_38:
    _ReportError((uint64_t)a2, v6);
    return;
  }
  int ProtocolFamily = _GetProtocolFamily(*((void *)a2 + 16), (uint64_t)v44);
  if (ProtocolFamily == 30)
  {
    *(_OWORD *)bytes = *(_OWORD *)v44;
    *(_OWORD *)&bytes[12] = *(_OWORD *)&v44[12];
    unsigned int v22 = *(unsigned __int8 *)(a3 + 3);
    uint64_t v21 = (const char *)(a3 + 3);
    unsigned int v20 = v22;
    if (!v22) {
      goto LABEL_37;
    }
    while ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v20 + 60) & 0x400) == 0)
    {
      unsigned int v23 = *(unsigned __int8 *)++v21;
      unsigned int v20 = v23;
      if (!v23) {
        goto LABEL_37;
      }
    }
    LODWORD(v41.version) = 0;
    if (sscanf(v21, "%u", &v41) != 1) {
      goto LABEL_37;
    }
    int v24 = 0;
    *(_WORD *)&bytes[2] = bswap32(LOWORD(v41.version)) >> 16;
  }
  else
  {
    if (ProtocolFamily == 2)
    {
      unsigned int v12 = *(unsigned __int8 *)(a3 + 3);
      char v11 = (const char *)(a3 + 3);
      unsigned int v10 = v12;
      v43[0] = 0;
      v43[1] = 0;
      if (v12)
      {
        int v13 = 0;
        unsigned int v14 = 0;
        unsigned int v15 = 0;
        uint64_t v16 = MEMORY[0x1E4F14390];
        while (1)
        {
          if ((*(_DWORD *)(v16 + 4 * v10 + 60) & 0x400) != 0)
          {
            LODWORD(v41.version) = 0;
            if (sscanf(v11, "%u", &v41) != 1) {
              goto LABEL_37;
            }
            char v17 = 8 * v13;
            if (v13 > 3)
            {
              v14 |= LODWORD(v41.version) << (40 - v17);
              if (v13 != 4)
              {
                unsigned int v3 = bswap32(v15);
                HIDWORD(v43[0]) = v3;
                LOWORD(v43[0]) = 528;
                WORD1(v43[0]) = bswap32(v14) >> 16;
                int v24 = 1;
                goto LABEL_22;
              }
            }
            else
            {
              v15 |= LODWORD(v41.version) << (24 - v17);
            }
            --v11;
            do
              unsigned int v18 = *(unsigned __int8 *)++v11;
            while ((*(_DWORD *)(v16 + 4 * v18 + 60) & 0x400) != 0);
            ++v13;
          }
          unsigned int v19 = *(unsigned __int8 *)++v11;
          unsigned int v10 = v19;
          if (!v19) {
            goto LABEL_37;
          }
        }
      }
      goto LABEL_37;
    }
    int v24 = 0;
  }
LABEL_22:
  CFArrayRef v25 = (const __CFArray *)*((void *)a2 + 14);
  if (!v25
    || (CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v25, *((void *)a2 + 15)),
        CFEqual(ValueAtIndex, (CFTypeRef)*MEMORY[0x1E4F1D260]))
    || CFEqual(ValueAtIndex, &unk_1ECFD1C00))
  {
    if (v24)
    {
      if (*(_DWORD *)&v44[4] == v3) {
        goto LABEL_33;
      }
LABEL_37:
      *(_OWORD *)&v41.version = xmmword_1843D1900;
      CFTypeID v6 = (CFStreamError *)&v41;
      goto LABEL_38;
    }
    if (*(void *)&v44[8] != *(void *)&bytes[8] || *(void *)&v44[16] != *(void *)&bytes[16]) {
      goto LABEL_37;
    }
  }
LABEL_33:
  CFAllocatorRef v28 = CFGetAllocator(*((CFTypeRef *)a2 + 11));
  CFAllocatorRef v29 = v28;
  v41.version = 0;
  v41.info = a2;
  memset(&v41.retain, 0, 24);
  if (v24)
  {
    char v30 = (const UInt8 *)v43;
    CFIndex v31 = 16;
  }
  else
  {
    char v30 = bytes;
    CFIndex v31 = 28;
  }
  CFDataRef v35 = CFDataCreate(v28, v30, v31);
  if (!v35
    || ((v36 = a2 + 12, (*a2 & 0x80) != 0) ? (v37 = 0, size_t v38 = a2 + 12) : (v37 = a2 + 12, size_t v38 = 0),
        _CoreSocketStreamCreateWithSignature(v29, v35, v37, v38, v32, v33, v34),
        CFRelease(v35),
        !*v36))
  {
    long long v40 = xmmword_1843D1960;
    CFTypeID v6 = (CFStreamError *)&v40;
    goto LABEL_38;
  }
  uint64_t v39 = *v36 + 16;
  if ((*a2 & 0x80) != 0)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    CoreWriteStream::setClient(v39, -1, (uint64_t)_DataStreamCallBack, &v41);
  }
  else
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    CoreReadStream::setClient(v39, -1, (uint64_t)_DataStreamCallBack, &v41);
  }
  _CFTypeScheduleOnMultipleRunLoops(*((void **)a2 + 3), *((const __CFArray **)a2 + 10));
  CFDictionaryApplyFunction(*((CFDictionaryRef *)a2 + 11), (CFDictionaryApplierFunction)_StreamPropertyApplier, *((void **)a2 + 3));
  _StartTransfer(a1, (uint64_t)a2);
}

void _HandlePort(uint64_t a1, uint64_t a2)
{
  SInt32 v2 = *(_DWORD *)(a1 + 16);
  if ((v2 - 300) > 0xFFFFFF9B)
  {
    _StartTransfer(a1, a2);
  }
  else
  {
    long long v3 = xmmword_1843D1700;
    DWORD2(v3) = v2;
    _ReportError(a2, (CFStreamError *)&v3);
  }
}

void _HandleSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  CFAllocatorRef v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  int v9 = *(_DWORD *)(a1 + 16);
  if ((v9 - 500) <= 0x63)
  {
    CFStringRef PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)(a2 + 8));
    char v11 = *(const void **)(a2 + 64);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(a2 + 64) = 0;
    }
    *(_DWORD *)(a1 + 20) = 12;
    CFStringRef v12 = CFStringCreateWithFormat(v8, 0, @"STAT %@\r\n", PathComponent);
    if (PathComponent) {
      CFRelease(PathComponent);
    }
    goto LABEL_27;
  }
  if (v9 == 213)
  {
    if (a4 < 1)
    {
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v13 = 0;
      while ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *(unsigned __int8 *)(a3 + v13) + 60) & 0x400) != 0)
      {
        if (a4 == ++v13) {
          goto LABEL_25;
        }
      }
    }
    if (v13 < a4)
    {
      while ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *(unsigned __int8 *)(a3 + v13) + 60) & 0x400) == 0)
      {
        if (a4 == ++v13) {
          goto LABEL_25;
        }
      }
      unsigned int v14 = (const char *)(a3 + v13);
      __endptr[0] = 0;
      unint64_t v15 = strtouq(v14, __endptr, 0);
      unint64_t valuePtr = v15;
      if (v15 == -1)
      {
        if (*__error()) {
          goto LABEL_25;
        }
      }
      else if (!v15 && __endptr[0] == v14)
      {
        goto LABEL_25;
      }
      keys[0] = @"kCFFTPResourceSize";
      CFGregorianDate values = CFNumberCreate(v8, kCFNumberLongLongType, &valuePtr);
      if (values)
      {
        *(void *)(a2 + 64) = CFDictionaryCreate(v8, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (values) {
          CFRelease(values);
        }
      }
    }
  }
LABEL_25:
  if (*(void *)(a2 + 72))
  {
    CFStringRef v12 = CFStringCreateWithFormat(v8, 0, @"REST %lld\r\n", *(void *)(a2 + 72));
    *(_DWORD *)(a1 + 20) = 14;
  }
  else
  {
    CFStringRef PathForContext = _CreatePathForContext(v8, a1, *(__CFURL **)(a2 + 8));
    if (!PathForContext)
    {
      *(_OWORD *)__endptr = xmmword_1843D1920;
      _ReportError(a2, (CFStreamError *)__endptr);
      return;
    }
    CFStringRef v17 = PathForContext;
    CFStringRef v12 = CFStringCreateWithFormat(v8, 0, @"RETR %@\r\n", PathForContext);
    *(_DWORD *)(a1 + 20) = 15;
    *(_WORD *)a2 &= ~0x800u;
    CFRelease(v17);
    uint64_t v18 = *(void *)(a2 + 24);
    if (v18)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v18 + 16));
    }
  }
LABEL_27:
  _WriteCommand(a1, a2, v12);
  if (v12) {
    CFRelease(v12);
  }
}

CFIndex CFFTPCreateParsedResourceListing(CFAllocatorRef alloc, const UInt8 *buffer, CFIndex bufferLength, CFDictionaryRef *parsed)
{
  CFIndex v4 = 0;
  uint64_t v156 = *MEMORY[0x1E4F143B8];
  *parsed = 0;
  if (!buffer) {
    return v4;
  }
  CFIndex v5 = bufferLength;
  if (!bufferLength) {
    return v4;
  }
  CFTypeID v6 = buffer;
  CFIndex v4 = 0;
  uint64_t v7 = MEMORY[0x1E4F14390];
  for (CFIndex i = bufferLength; ; i -= v11)
  {
    dispatch_data_t v137 = 0;
    uint64_t v138 = 0;
    uint64_t Line = _FindLine(v6, i, (const unsigned __int8 **)&v138, (const unsigned __int8 **)&v137);
    v4 += Line;
    unsigned int v10 = v138;
    if (!v138) {
      return v4;
    }
    uint64_t v11 = Line;
    if (*(_DWORD *)v138 != 1635020660 || *((_WORD *)v138 + 2) != 8300) {
      break;
    }
LABEL_172:
    if (v4 >= v5) {
      return v4;
    }
    v6 += v11;
  }
  __s = (void *)i;
  uint64_t v155 = 0;
  long long v153 = 0u;
  long long v154 = 0u;
  long long v151 = 0u;
  long long v152 = 0u;
  long long v149 = 0u;
  long long v150 = 0u;
  long long v147 = 0u;
  long long v148 = 0u;
  uint64_t v13 = v137;
  if (v138 >= v137) {
    goto LABEL_171;
  }
  unint64_t v14 = 0;
  do
  {
    if (v10 >= v13)
    {
      int v18 = v14;
      break;
    }
    int64_t v15 = v13 - v10;
    while (1)
    {
      uint64_t v16 = *v10;
      if ((char)*v10 < 0) {
        break;
      }
      if ((*(_DWORD *)(v7 + 4 * v16 + 60) & 0x4000) == 0) {
        goto LABEL_19;
      }
LABEL_17:
      ++v10;
      if (!--v15)
      {
        int v18 = v14;
        unsigned int v10 = v13;
        goto LABEL_28;
      }
    }
    if (__maskrune(v16, 0x4000uLL)) {
      goto LABEL_17;
    }
LABEL_19:
    *((void *)&v147 + v14) = v10;
    while (v10 < v13)
    {
      uint64_t v17 = *v10;
      if ((char)*v10 < 0)
      {
        if (__maskrune(v17, 0x4000uLL)) {
          break;
        }
      }
      else if ((*(_DWORD *)(v7 + 4 * v17 + 60) & 0x4000) != 0)
      {
        break;
      }
      ++v10;
    }
    int v18 = v14 + 1;
    if (v14 > 0xE) {
      break;
    }
    ++v14;
  }
  while (v10 < v13);
LABEL_28:
  uint64_t v138 = v10;
  if (!v18)
  {
LABEL_171:
    CFIndex i = (CFIndex)__s;
    goto LABEL_172;
  }
  int v131 = v6;
  int valuePtr = 0;
  unsigned int v19 = (const UInt8 *)v147;
  unsigned int v20 = *(unsigned __int8 *)v147;
  if (v20 <= 0x63)
  {
    switch(v20)
    {
      case '-':
        int v21 = 0;
        int v22 = 8;
        break;
      case 'b':
        int v21 = 0;
        int v22 = 6;
        break;
      case 'c':
        int v21 = 0;
        int v22 = 2;
        break;
      default:
        goto LABEL_145;
    }
    goto LABEL_44;
  }
  if (*(unsigned __int8 *)v147 > 0x6Fu)
  {
    if (v20 == 112)
    {
      int v21 = 0;
      int v136 = 1;
      goto LABEL_45;
    }
    if (v20 != 115) {
      goto LABEL_145;
    }
    int v21 = 0;
    int v22 = 12;
LABEL_44:
    int v136 = v22;
    goto LABEL_45;
  }
  if (v20 == 100)
  {
    int v21 = 0;
    int v136 = 4;
  }
  else
  {
    if (v20 == 108)
    {
      int v136 = 10;
      int v21 = 1;
      goto LABEL_45;
    }
LABEL_145:
    int v21 = 0;
    int v136 = 0;
  }
LABEL_45:
  CFIndex v23 = (CFIndex)&v13[-v147];
  if ((uint64_t)&v13[-v147] >= 11)
  {
    int v25 = 0;
    unint64_t v26 = 0;
    char v27 = 6;
    while (1)
    {
      int v28 = *(unsigned __int8 *)(v147 + v26 + 1);
      if (v28 == 45)
      {
        int v29 = 1;
      }
      else if (v28 == 114)
      {
        int v29 = 1;
        v25 |= 1 << (v27 + 2);
        int valuePtr = v25;
      }
      else
      {
        int v29 = 0;
      }
      int v30 = *(unsigned __int8 *)(v147 + v26 + 2);
      if (v30 != 45)
      {
        if (v30 == 119)
        {
          v25 |= 1 << (v27 + 1);
          int valuePtr = v25;
        }
        else
        {
          int v29 = 0;
        }
      }
      int v24 = 0;
      unsigned int v31 = *(unsigned __int8 *)(v147 + v26 + 3);
      if (v31 <= 0x72) {
        break;
      }
      if (v31 == 115)
      {
        v25 |= 1 << v27;
        int valuePtr = v25;
LABEL_67:
        if (v26 > 2)
        {
          if ((v26 - 3) > 2) {
            goto LABEL_75;
          }
          v25 |= 0x400u;
        }
        else
        {
          v25 |= 0x800u;
        }
        goto LABEL_74;
      }
      if (v31 == 116)
      {
        v25 |= 1 << v27;
        int valuePtr = v25;
LABEL_70:
        if ((v26 - 6) > 2) {
          goto LABEL_75;
        }
        v25 |= 0x200u;
        goto LABEL_74;
      }
      if (v31 != 120) {
        goto LABEL_79;
      }
      v25 |= 1 << v27;
LABEL_74:
      int valuePtr = v25;
LABEL_75:
      if (v26 > 5)
      {
        int v24 = v29;
        goto LABEL_79;
      }
      v26 += 3;
      v27 -= 3;
      int v24 = v29;
      if (!v29) {
        goto LABEL_79;
      }
    }
    if (v31 == 45) {
      goto LABEL_75;
    }
    if (v31 != 83)
    {
      if (v31 != 84) {
        goto LABEL_79;
      }
      goto LABEL_70;
    }
    goto LABEL_67;
  }
  int v24 = 0;
LABEL_79:
  CFDataRef v32 = (unsigned __int8 *)*((void *)&v148 + 1);
  if (!*((void *)&v148 + 1) || !(void)v149)
  {
LABEL_165:
    if (!v24)
    {
      keys[0] = @"kCFFTPResourceName";
      CFStringRef v79 = CFStringCreateWithBytes(alloc, v19, v23, 0, 0);
      values[0] = (void *)v79;
      if (v79)
      {
        CFStringRef v80 = v79;
        if (!CFStringHasPrefix(v79, @"<") || !CFStringHasSuffix(v80, @">"))
        {
          *parsed = CFDictionaryCreate(alloc, (const void **)keys, (const void **)values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          CFDateRef v83 = (CFDateRef)values[0];
          if (values[0]) {
            goto LABEL_182;
          }
          return v4;
        }
        CFRelease(v80);
      }
    }
    CFIndex v5 = bufferLength;
    CFTypeID v6 = v131;
    goto LABEL_171;
  }
  v127 = &v13[-v147];
  CFIndex v128 = v4;
  int v126 = v21;
  unint64_t v134 = 0;
  int v33 = 3;
  unsigned int v34 = 2;
  while (2)
  {
    int64_t v35 = v13 - v32;
    if (v13 - v32 < 9) {
      goto LABEL_140;
    }
    uint64_t v36 = 0;
    uint64_t v37 = &_CFFTPGetDateTimeFunc(__CFAllocator const*,unsigned char const*,long,__CFDate const**)::kMonthStrs;
    while (*(unsigned __int16 *)v32 != (unsigned __int16)*v37 || v32[2] != *((unsigned __int8 *)v37 + 2))
    {
      ++v36;
      uint64_t v37 = (__int16 *)((char *)v37 + 3);
      if (v36 == 12) {
        goto LABEL_140;
      }
    }
    uint64_t v39 = v32[3];
    if ((char)v32[3] < 0)
    {
      if (!__maskrune(v39, 0x4000uLL)) {
        goto LABEL_140;
      }
    }
    else if ((*(_DWORD *)(v7 + 4 * v39 + 60) & 0x4000) == 0)
    {
      goto LABEL_140;
    }
    unsigned __int8 v40 = v36 + 1;
    uint64_t v41 = 4;
    while (1)
    {
      uint64_t v42 = v32[v41];
      if ((*(_DWORD *)(v7 + 4 * v42 + 60) & 0x400) != 0) {
        break;
      }
      if (v35 == ++v41) {
        goto LABEL_140;
      }
    }
    if (v41 == v35) {
      goto LABEL_140;
    }
    uint64_t v43 = v41 + 1;
    if (v41 + 1 == v35) {
      goto LABEL_140;
    }
    unsigned __int8 v44 = v42 - 48;
    uint64_t v45 = v32[v43];
    int v46 = *(_DWORD *)(v7 + 4 * v45 + 60);
    uint64_t v47 = v41 + 2;
    unsigned __int8 v48 = v45 + 10 * v44 - 48;
    if ((v46 & 0x400) != 0)
    {
      unsigned __int8 v44 = v48;
      int64_t v49 = v47;
    }
    else
    {
      int64_t v49 = v43;
    }
    if (v49 == v35) {
      goto LABEL_140;
    }
    uint64_t v50 = v32[v49];
    unsigned __int8 v120 = v40;
    unsigned __int8 v119 = v44;
    if ((char)v32[v49] < 0)
    {
      if (!__maskrune(v50, 0x4000uLL)) {
        goto LABEL_140;
      }
    }
    else if ((*(_DWORD *)(v7 + 4 * v50 + 60) & 0x4000) == 0)
    {
      goto LABEL_140;
    }
    if (v49 < v35)
    {
      while ((*(_DWORD *)(v7 + 4 * v32[v49] + 60) & 0x400) == 0)
      {
        if (v35 == ++v49)
        {
          char v51 = 0;
          uint64_t v118 = 0;
          int v117 = 0;
LABEL_117:
          int64_t v49 = v13 - v32;
          goto LABEL_132;
        }
      }
    }
    if (v49 >= v35)
    {
      int v117 = 0;
LABEL_125:
      uint64_t v54 = 0;
      char v51 = 0;
      goto LABEL_126;
    }
    int v52 = 0;
    while (1)
    {
      uint64_t v53 = v32[v49];
      if ((*(_DWORD *)(v7 + 4 * v53 + 60) & 0x400) == 0) {
        break;
      }
      ++v49;
      int v52 = v53 + 10 * v52 - 48;
      if (v35 == v49)
      {
        int v117 = v52;
        char v51 = 0;
        uint64_t v118 = 0;
        goto LABEL_117;
      }
    }
    int v117 = v52;
    if (v53 != 58) {
      goto LABEL_125;
    }
    if (++v49 >= v35)
    {
      uint64_t v54 = 0;
    }
    else
    {
      uint64_t v54 = 0;
      while (1)
      {
        uint64_t v55 = v32[v49];
        if ((*(_DWORD *)(v7 + 4 * v55 + 60) & 0x400) == 0) {
          break;
        }
        uint64_t v54 = (v55 + 10 * v54 - 48);
        if (++v49 >= v35)
        {
          uint64_t v118 = v54;
          int64_t v49 = v13 - v32;
          char v51 = 1;
          goto LABEL_132;
        }
      }
    }
    char v51 = 1;
LABEL_126:
    char cf = v51;
    uint64_t v118 = v54;
    if (v49 == v35)
    {
      int64_t v49 = v13 - v32;
      break;
    }
    uint64_t v56 = v32[v49];
    if ((char)v32[v49] < 0) {
      int v57 = __maskrune(v56, 0x4000uLL);
    }
    else {
      int v57 = *(_DWORD *)(v7 + 4 * v56 + 60) & 0x4000;
    }
    char v51 = cf;
    if (!v57)
    {
LABEL_140:
      CFDataRef v32 = (unsigned __int8 *)*((void *)&v147 + ++v33);
      ++v34;
      if (!v32) {
        goto LABEL_164;
      }
      continue;
    }
    break;
  }
LABEL_132:
  char cfb = v51;
  CFTimeZoneRef v58 = CFTimeZoneCopyDefault();
  double Current = CFAbsoluteTimeGetCurrent();
  CFAbsoluteTimeGetGregorianDate(Current, v58);
  if (cfb)
  {
    CFAbsoluteTime v60 = Current + 86400.0;
    unsigned int year = CFAbsoluteTimeGetGregorianDate(v60, v58).year;
    *(void *)&v157.unsigned int year = year | (unint64_t)(v118 << 56) | ((unint64_t)v119 << 40) & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)v120 << 32) & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)v117 << 48);
    v157.second = 0.0;
    CFAbsoluteTime AbsoluteTime = CFGregorianDateGetAbsoluteTime(v157, v58);
    unint64_t v63 = (unint64_t)v119 << 40;
    unint64_t v62 = (unint64_t)v120 << 32;
    unint64_t v64 = (unint64_t)v117 << 48;
    uint64_t v65 = v118;
    unsigned int v66 = year - (AbsoluteTime > v60);
  }
  else
  {
    unint64_t v64 = 0;
    uint64_t v65 = 0;
    unsigned int v66 = v117 + 1900;
    if (v117 >= 100) {
      unsigned int v66 = v117;
    }
    unint64_t v63 = (unint64_t)v119 << 40;
    unint64_t v62 = (unint64_t)v120 << 32;
  }
  *(void *)&v158.unsigned int year = v63 | v62 | v64 | v66 | (v65 << 56);
  v158.second = 0.0;
  CFAbsoluteTime v67 = CFGregorianDateGetAbsoluteTime(v158, v58);
  if (v58) {
    CFRelease(v58);
  }
  CFDateRef v68 = CFDateCreate(alloc, v67);
  if (!v68) {
    goto LABEL_140;
  }
  CFDateRef cfa = v68;
  uint64_t v69 = (char *)&v32[v49];
  signed int v70 = v34;
  do
  {
    int v71 = v70;
    BOOL v72 = v24 != 0;
    if (v71) {
      BOOL v72 = 0;
    }
    char v73 = v71 < 0 || v72;
    if (v73) {
      goto LABEL_157;
    }
    int v74 = _ReadSize(*((char **)&v147 + v71), &v134);
    signed int v70 = v71 - 1;
  }
  while (!v74);
  if (v24 && v71 == 1)
  {
LABEL_157:
    uint64_t v75 = 0;
    CFAllocatorRef v76 = 0;
    goto LABEL_158;
  }
  CFAllocatorRef v76 = (const UInt8 *)*((void *)&v147 + v70);
  int v81 = v71 - 2;
  if (!v24 || v81)
  {
    if (!v24
      || v81 != 1
      || (int v121 = (const UInt8 *)*((void *)&v147 + v70),
          int Size = _ReadSize(*((char **)&v147 + 1), (unint64_t *)keys),
          CFAllocatorRef v76 = v121,
          uint64_t v75 = (UInt8 *)v121,
          !Size))
    {
      uint64_t v75 = (UInt8 *)*((void *)&v147 + v81);
    }
  }
  else
  {
    uint64_t v75 = (UInt8 *)*((void *)&v147 + v70);
  }
  do
  {
LABEL_158:
    BOOL v77 = (const UInt8 *)*((void *)&v147 + ++v34);
    if (v77) {
      BOOL v78 = v69 > (char *)v77;
    }
    else {
      BOOL v78 = 0;
    }
  }
  while (v78);
  if (!v77)
  {
    CFRelease(cfa);
LABEL_164:
    CFIndex v23 = (CFIndex)v127;
    CFIndex v4 = v128;
    goto LABEL_165;
  }
  long long v145 = 0u;
  long long v146 = 0u;
  *(_OWORD *)keys = 0u;
  long long v144 = 0u;
  long long v141 = 0u;
  long long v142 = 0u;
  *(_OWORD *)CFGregorianDate values = 0u;
  long long v140 = 0u;
  __sa = v75;
  uint64_t v85 = v76;
  if (v126)
  {
    while (1)
    {
      uint64_t v86 = (_WORD *)*((void *)&v147 + v34);
      if (!v86) {
        break;
      }
      ++v34;
      if (*v86 == 15917)
      {
        CFStringRef v87 = (const UInt8 *)*((void *)&v147 + v34);
        goto LABEL_189;
      }
    }
  }
  CFStringRef v87 = 0;
LABEL_189:
  if (v24)
  {
    keys[0] = @"kCFFTPResourceMode";
    values[0] = CFNumberCreate(alloc, kCFNumberSInt32Type, &valuePtr);
    LODWORD(v88) = values[0] != 0;
  }
  else
  {
    LODWORD(v88) = 0;
  }
  uint64_t v89 = v88;
  *(void *)((unint64_t)keys | (8 * v8HSTSPolicy::~HSTSPolicy((HSTSPolicy *)((char *)this - 8)) = @"kCFFTPResourceName";
  if (v87) {
    uint64_t v90 = *((void *)&v147 + v34 - 1) - 1;
  }
  else {
    uint64_t v90 = (uint64_t)v13;
  }
  CFStringRef v91 = CFStringCreateWithBytes(alloc, v77, v90 - (void)v77, 0, 0);
  *(void *)((unint64_t)values | (8 * v8HSTSPolicy::~HSTSPolicy((HSTSPolicy *)((char *)this - 8)) = v91;
  if (v91)
  {
    CFStringRef v92 = v91;
    if (CFStringHasPrefix(v91, @"<")
      && CFStringHasSuffix(v92, @">")
      && (CFIndex location = CFStringFind(v92, @">", 0).location,
          CFIndex v94 = CFStringFind(v92, @"<", 4uLL).location,
          location < v94))
    {
      v159.CFIndex length = v94 + ~location;
      v159.CFIndex location = location + 1;
      CFStringRef Copy = CFStringCreateWithSubstring(alloc, v92, v159);
    }
    else
    {
      CFStringRef Copy = CFStringCreateCopy(alloc, v92);
    }
    CFStringRef v96 = Copy;
    if (Copy)
    {
      CFRelease(v92);
      *(void *)((unint64_t)values | (8 * v8HSTSPolicy::~HSTSPolicy((HSTSPolicy *)((char *)this - 8)) = v96;
    }
    uint64_t v89 = (v88 + 1);
    LODWORD(v88) = v88 + 1;
  }
  keys[v89] = @"kCFFTPResourceLink";
  if (v87) {
    CFStringRef v97 = CFStringCreateWithBytes(alloc, v87, v13 - v87, 0, 0);
  }
  else {
    CFStringRef v97 = CFStringCreateWithCString(alloc, "", 0x8000100u);
  }
  values[v89] = (void *)v97;
  if (v97) {
    LODWORD(v88) = v88 + 1;
  }
  if ((v73 & 1) == 0)
  {
    if (v85 && v85 == __sa)
    {
      CFRange v99 = __sa - 1;
      do
      {
        uint64_t v100 = v99[1];
        if ((char)v99[1] < 0) {
          int v101 = __maskrune(v100, 0x4000uLL);
        }
        else {
          int v101 = *(_DWORD *)(v7 + 4 * v100 + 60) & 0x4000;
        }
        ++v99;
      }
      while (!v101);
      unint64_t v102 = 0;
      do
      {
        CFRange v103 = (char *)memchr(__sa, byte_1843D19B8[v102], v99 - __sa);
        if (v103) {
          BOOL v104 = 1;
        }
        else {
          BOOL v104 = v102 >= 3;
        }
        ++v102;
      }
      while (!v104);
      CFRange v98 = (UInt8 *)v103;
      if (v103) {
        uint64_t v85 = (const UInt8 *)(v103 + 1);
      }
      else {
        uint64_t v85 = __sa;
      }
    }
    else
    {
      CFRange v98 = 0;
    }
    if (__sa)
    {
      if (!v98)
      {
        CFRange v98 = __sa - 1;
        do
        {
          uint64_t v105 = v98[1];
          if ((char)v98[1] < 0) {
            int v106 = __maskrune(v105, 0x4000uLL);
          }
          else {
            int v106 = *(_DWORD *)(v7 + 4 * v105 + 60) & 0x4000;
          }
          ++v98;
        }
        while (!v106);
      }
      keys[v88] = @"kCFFTPResourceOwner";
      CFStringRef v107 = CFStringCreateWithBytes(alloc, __sa, v98 - __sa, 0, 0);
      values[v88] = (void *)v107;
      if (v107) {
        LODWORD(v88) = v88 + 1;
      }
    }
    if (v85)
    {
      unsigned int v108 = v85 - 1;
      do
      {
        uint64_t v109 = v108[1];
        if ((char)v108[1] < 0) {
          int v110 = __maskrune(v109, 0x4000uLL);
        }
        else {
          int v110 = *(_DWORD *)(v7 + 4 * v109 + 60) & 0x4000;
        }
        ++v108;
      }
      while (!v110);
      keys[v88] = @"kCFFTPResourceGroup";
      CFStringRef v111 = CFStringCreateWithBytes(alloc, v85, v108 - v85, 0, 0);
      values[v88] = (void *)v111;
      if (v111) {
        LODWORD(v88) = v88 + 1;
      }
    }
    keys[v88] = @"kCFFTPResourceSize";
    CFNumberRef v112 = CFNumberCreate(alloc, kCFNumberLongLongType, &v134);
    values[v88] = v112;
    if (v112) {
      LODWORD(v88) = v88 + 1;
    }
  }
  CFIndex v4 = v128;
  keys[v88] = @"kCFFTPResourceType";
  CFNumberRef v113 = CFNumberCreate(alloc, kCFNumberIntType, &v136);
  values[v88] = v113;
  if (v113) {
    int v114 = v88 + 1;
  }
  else {
    int v114 = v88;
  }
  keys[v114] = @"kCFFTPResourceModDate";
  if (v113) {
    uint64_t v88 = v88 + 1;
  }
  else {
    uint64_t v88 = v88;
  }
  values[v114] = (void *)CFRetain(cfa);
  *parsed = CFDictionaryCreate(alloc, (const void **)keys, (const void **)values, (v114 + 1), MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  do
  {
    int v115 = values[v88];
    if (v115) {
      CFRelease(v115);
    }
    BOOL v78 = v88-- <= 0;
  }
  while (!v78);
  CFDateRef v83 = cfa;
LABEL_182:
  CFRelease(v83);
  return v4;
}

CFStringRef _CreatePathForContext(const __CFAllocator *a1, uint64_t a2, __CFURL *a3)
{
  CFStringRef v5 = _CFURLCopyPathReplacingPercentEscapes(a3);
  if (!v5) {
    return 0;
  }
  CFStringRef v6 = v5;
  if (!CFStringGetLength(v5))
  {
    CFRelease(v6);
    CFStringRef v6 = (const __CFString *)CFRetain(@"/");
  }
  if (CFStringHasPrefix(v6, @"//"))
  {
    v10.CFIndex length = CFStringGetLength(v6) - 1;
    v10.CFIndex location = 1;
    CFStringRef v7 = CFStringCreateWithSubstring(a1, v6, v10);
    if (!v7) {
      return v6;
    }
  }
  else
  {
    if (!*(void *)(a2 + 24)) {
      return v6;
    }
    CFStringRef v7 = CFStringCreateWithFormat(a1, 0, @"%@%@", *(void *)(a2 + 24), v6);
    if (!v7) {
      return v6;
    }
  }
  CFStringRef v8 = v7;
  if (v6) {
    CFRelease(v6);
  }
  return v8;
}

void _HandleRestart(uint64_t a1, uint64_t a2)
{
  SInt32 v3 = *(_DWORD *)(a1 + 16);
  if ((v3 - 400) <= 0xFFFFFF9B)
  {
    long long v10 = xmmword_1843D1700;
    DWORD2(v10) = v3;
LABEL_13:
    _ReportError(a2, (CFStreamError *)&v10);
    return;
  }
  CFAllocatorRef v5 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  CFStringRef PathForContext = _CreatePathForContext(v5, a1, *(__CFURL **)(a2 + 8));
  if (!PathForContext)
  {
    long long v10 = xmmword_1843D1920;
    goto LABEL_13;
  }
  CFStringRef v7 = PathForContext;
  CFStringRef v8 = CFStringCreateWithFormat(v5, 0, @"RETR %@\r\n", PathForContext);
  CFRelease(v7);
  *(_DWORD *)(a1 + 20) = 15;
  *(_WORD *)a2 &= ~0x800u;
  uint64_t v9 = *(void *)(a2 + 24);
  if (v9)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v9 + 16));
  }
  _WriteCommand(a1, a2, v8);
  if (v8)
  {
    CFRelease(v8);
  }
}

void _HandleRetrieve(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  if (v2 >= 0xC8)
  {
    if ((*(unsigned char *)a1 & 2) != 0)
    {
      *(_DWORD *)(a1 + 20) = 8;
      _StartProcess(a1, a2);
    }
    else if (v2 < 0x12C)
    {
      _ConnectionComplete(a1, a2);
    }
    else
    {
      long long v3 = xmmword_1843D1700;
      DWORD2(v3) = v2;
      _ReportError(a2, (CFStreamError *)&v3);
    }
  }
}

void _HandleChangeDirectory(uint64_t a1, uint64_t a2)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  char v4 = *(unsigned char *)a1;
  int v5 = *(_DWORD *)(a1 + 16);
  if ((*(unsigned char *)a1 & 8) == 0 || v5 != 421)
  {
    if ((v5 - 300) <= 0xFFFFFF9B)
    {
      sockaddr v43 = (sockaddr)xmmword_1843D1700;
      *(_DWORD *)&v43.sa_data[6] = v5;
      *(unsigned char *)a1 = v4 & 0xF7;
LABEL_10:
      p_CFSocketContext context = (CFStreamError *)&v43;
LABEL_11:
      _ReportError(a2, p_context);
      return;
    }
    CFAllocatorRef v9 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
    *(unsigned char *)a1 &= ~8u;
    if ((*(unsigned char *)a2 & 0x80) == 0)
    {
LABEL_37:
      if (*(_DWORD *)(a1 + 20) != 9) {
        return;
      }
      if (*(_WORD *)a2)
      {
        int ProtocolFamily = _GetProtocolFamily(*(void *)(a2 + 128), (uint64_t)&v43);
        *(_DWORD *)(a1 + 20) = 10;
        if (ProtocolFamily == 30)
        {
          CFStringRef v24 = @"EPSV\r\n";
        }
        else
        {
          if (ProtocolFamily != 2)
          {
            *(_OWORD *)&context.version = xmmword_1843D1720;
            p_CFSocketContext context = (CFStreamError *)&context;
            goto LABEL_11;
          }
          CFStringRef v24 = @"PASV\r\n";
        }
        _WriteCommand(a1, a2, v24);
        return;
      }
      socklen_t v41 = 255;
      int v42 = 1;
      context.version = 0;
      context.info = (void *)a2;
      memset(&context.retain, 0, 24);
      uint64_t v19 = *(void *)(a2 + 128);
      uint64_t v20 = *(void *)(v19 + 96);
      if (v20)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v20 + 8));
        uint64_t v21 = *(void *)(v19 + 96);
        uint64_t v22 = *(void *)(v19 + 144);
        if (v21) {
          pthread_mutex_unlock((pthread_mutex_t *)(v21 + 8));
        }
      }
      else
      {
        uint64_t v22 = *(void *)(v19 + 144);
      }
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
        dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      }
      if (v22) {
        uint64_t v25 = v22 + 16;
      }
      else {
        uint64_t v25 = 0;
      }
      ++*(void *)(v25 + 80);
      CFDataRef v26 = (const __CFData *)(*(uint64_t (**)(void, void *))(**(void **)(v25 + 24) + 40))(*(void *)(v25 + 24), &unk_1EC0A0F98);
      --*(void *)(v25 + 80);
      if (!v26) {
        goto LABEL_54;
      }
      CFDataRef v27 = v26;
      long long v56 = 0u;
      memset(v57, 0, sizeof(v57));
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      sockaddr v43 = (sockaddr)0;
      BytePtr = (int *)CFDataGetBytePtr(v26);
      if (getsockname(*BytePtr, &v43, &v41)) {
        goto LABEL_53;
      }
      CFRelease(v27);
      int v29 = CFSocketCreate(v9, v43.sa_family, 1, 6, 2uLL, (CFSocketCallBack)_SocketCallBack, &context);
      *(void *)(a2 + 56) = v29;
      if (v29)
      {
        CFSocketNativeHandle Native = CFSocketGetNative(v29);
        setsockopt(Native, 0xFFFF, 4, &v42, 4u);
        CFIndex v31 = v43.sa_family == 2 ? 16 : 28;
        *(_WORD *)v43.sa_CFDataRef data = 0;
        CFDataRef v32 = CFDataCreateWithBytesNoCopy(v9, &v43.sa_len, v31, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
        if (v32)
        {
          CFDataRef v27 = v32;
          if (CFSocketSetAddress(*(CFSocketRef *)(a2 + 56), v32))
          {
LABEL_53:
            CFRelease(v27);
            goto LABEL_54;
          }
          CFRelease(v27);
          if (!*(void *)(a2 + 80))
          {
LABEL_69:
            CFDataRef v35 = CFSocketCopyAddress(*(CFSocketRef *)(a2 + 56));
            uint64_t v36 = CFDataGetBytePtr(v35);
            int v37 = v36[1];
            if (v37 == 30)
            {
              CFStringRef v38 = CFStringCreateWithFormat(v9, 0, @"EPRT |2|%x:%x:%x:%x:%x:%x:%x:%x|%u|\r\n", bswap32(*((unsigned __int16 *)v36 + 4)) >> 16, bswap32(*((unsigned __int16 *)v36 + 5)) >> 16, bswap32(*((unsigned __int16 *)v36 + 6)) >> 16, bswap32(*((unsigned __int16 *)v36 + 7)) >> 16, bswap32(*((unsigned __int16 *)v36 + 8)) >> 16, bswap32(*((unsigned __int16 *)v36 + 9)) >> 16, bswap32(*((unsigned __int16 *)v36 + 10)) >> 16, bswap32(*((unsigned __int16 *)v36 + 11)) >> 16, bswap32(*((unsigned __int16 *)v36 + 1)) >> 16);
            }
            else
            {
              if (v37 != 2)
              {
                sockaddr v43 = (sockaddr)xmmword_1843D1720;
                _ReportError(a2, (CFStreamError *)&v43);
LABEL_76:
                CFRelease(v35);
                return;
              }
              CFStringRef v38 = CFStringCreateWithFormat(v9, 0, @"PORT %u,%u,%u,%u,%u,%u\r\n", v36[4], v36[5], v36[6], v36[7], v36[2], v36[3]);
            }
            CFStringRef v39 = v38;
            if (v38)
            {
              *(_DWORD *)(a1 + 20) = 11;
              _WriteCommand(a1, a2, v38);
              CFRelease(v39);
            }
            goto LABEL_76;
          }
          CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v9, *(CFSocketRef *)(a2 + 56), 0);
          if (RunLoopSource)
          {
            CFRunLoopSourceRef v34 = RunLoopSource;
            _CFTypeScheduleOnMultipleRunLoops(RunLoopSource, *(const __CFArray **)(a2 + 80));
            CFRelease(v34);
            goto LABEL_69;
          }
        }
      }
LABEL_54:
      _InvalidateServer(a2);
      sockaddr v43 = (sockaddr)xmmword_1843D16F0;
      *(_DWORD *)&v43.sa_data[6] = *__error();
      if (!*(_DWORD *)&v43.sa_data[6])
      {
        *(void *)&v43.sa_len = 1;
        *(_DWORD *)&v43.sa_data[6] = 57;
      }
      goto LABEL_10;
    }
    CFStringRef PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)(a2 + 8));
    CFStringRef v11 = PathComponent;
    if ((*(_WORD *)a2 & 0x100) != 0)
    {
      CFStringRef v14 = @"RMD %@\r\n";
      int v15 = 20;
      if (!CFURLHasDirectoryPath(*(CFURLRef *)(a2 + 8)))
      {
        int IsRoot = _IsRoot(*(const __CFURL **)(a2 + 8));
        int v15 = IsRoot ? 20 : 21;
        if (!IsRoot) {
          CFStringRef v14 = @"DELE %@\r\n";
        }
      }
      *(_DWORD *)(a1 + 20) = v15;
      CFStringRef v12 = CFStringCreateWithFormat(v9, 0, v14, v11);
    }
    else
    {
      if (*(void *)(a2 + 16))
      {
        CFStringRef v12 = CFStringCreateWithFormat(v9, 0, @"RNFR %@\r\n", PathComponent);
        int v13 = 22;
      }
      else
      {
        if (!CFURLHasDirectoryPath(*(CFURLRef *)(a2 + 8)) && !_IsRoot(*(const __CFURL **)(a2 + 8)))
        {
LABEL_35:
          if (v11) {
            CFRelease(v11);
          }
          goto LABEL_37;
        }
        CFStringRef v12 = CFStringCreateWithFormat(v9, 0, @"MKD %@\r\n", v11);
        int v13 = 19;
      }
      *(_DWORD *)(a1 + 20) = v13;
    }
    _WriteCommand(a1, a2, v12);
    if (v12) {
      CFRelease(v12);
    }
    uint64_t v17 = *(void *)(a2 + 32);
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    if (v17) {
      int v18 = (CoreStreamBase *)(v17 + 16);
    }
    else {
      int v18 = 0;
    }
    v59.CFIndex domain = 0;
    *(void *)&v59.SInt32 error = 0;
    CoreStreamBase::_signalEvent(v18, 1, v59, 1);
    goto LABEL_35;
  }
  pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a2 + 136) + 8));
  uint64_t v6 = *(void *)(a2 + 128);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 72))(v6);
    NetConnection::dequeue(*(NetConnection **)(a2 + 128), (void *)a2);
    uint64_t v7 = *(void *)(a2 + 128);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 48))(v7);
    }
    *(void *)(a2 + 128) = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a2 + 136) + 8));
  _FTPStreamOpen(*(void *)(a2 + 32), &v43, &context, a2);
}

void _HandleMakeDirectory(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)a1 & 2) != 0)
  {
    *(_DWORD *)(a1 + 20) = 8;
    _StartProcess(a1, a2);
  }
  else
  {
    SInt32 v2 = *(_DWORD *)(a1 + 16);
    if ((v2 - 300) > 0xFFFFFF9B)
    {
      _ConnectionComplete(a1, a2);
    }
    else
    {
      long long v3 = xmmword_1843D1700;
      DWORD2(v3) = v2;
      _ReportError(a2, (CFStreamError *)&v3);
    }
  }
}

void _HandleRenameFrom(uint64_t a1, uint64_t a2)
{
  SInt32 v3 = *(_DWORD *)(a1 + 16);
  if ((v3 - 400) <= 0xFFFFFF9B)
  {
    long long v11 = xmmword_1843D1700;
    DWORD2(v1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v3;
LABEL_9:
    _ReportError(a2, (CFStreamError *)&v11);
    return;
  }
  CFAllocatorRef v5 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v6 = *(__CFURL **)(a2 + 16);
  *(void *)(a2 + 8) = v6;
  CFStringRef PathForContext = _CreatePathForContext(v5, a1, v6);
  if (!PathForContext)
  {
    long long v11 = xmmword_1843D1920;
    goto LABEL_9;
  }
  CFStringRef v9 = PathForContext;
  *(void *)(a2 + 8) = v7;
  *(_DWORD *)(a1 + 20) = 23;
  CFStringRef v10 = CFStringCreateWithFormat(v5, 0, @"RNTO %@\r\n", PathForContext);
  CFRelease(v9);
  _WriteCommand(a1, a2, v10);
  if (v10)
  {
    CFRelease(v10);
  }
}

void _ConnectionComplete(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 20);
  CFArrayRef v5 = *(const __CFArray **)(a2 + 80);
  CFIndex Count = CFArrayGetCount(v5);
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    for (CFIndex i = 0; i < v7; i += 2)
    {
      CFStringRef v9 = *(NetConnection **)(a2 + 128);
      CFArrayGetValueAtIndex(v5, i);
      CFArrayGetValueAtIndex(v5, i + 1);
      NetConnection::unschedule(v9, (uint64_t *)a2, v10, v11);
    }
  }
  *(_DWORD *)(a1 + 20) = 8;
  NetConnection::requestIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
  if (v4 != 15 || (*(_WORD *)a2 & 0x800) != 0)
  {
    NetConnection::responseIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
    __int16 v12 = *(_WORD *)a2 & 0xF7FF;
  }
  else
  {
    __int16 v12 = *(_WORD *)a2 | 0x800;
  }
  *(_WORD *)a2 = v12;
  if (!*(void *)(a2 + 56) && !*(void *)(a2 + 24))
  {
    CFTypeID v13 = CFGetTypeID(*(CFTypeRef *)(a2 + 32));
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v14 = *(void *)(a2 + 32);
    if (v14) {
      int v15 = (CoreStreamBase *)(v14 + 16);
    }
    else {
      int v15 = 0;
    }
    if (v13 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
      && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    v16.CFIndex domain = 0;
    *(void *)&v16.SInt32 error = 0;
    CoreStreamBase::_signalEvent(v15, 16, v16, 1);
  }
}

uint64_t _IsRoot(const __CFURL *a1)
{
  Boolean isAbsolute = 0;
  CFStringRef v2 = CFURLCopyStrictPath(a1, &isAbsolute);
  CFStringRef v3 = CFURLCopyResourceSpecifier(a1);
  if (!((unint64_t)v2 | (unint64_t)v3)) {
    return 1;
  }
  int v4 = v3;
  if (v2) {
    CFRelease(v2);
  }
  if (v4) {
    CFRelease(v4);
  }
  return 0;
}

uint64_t _GetProtocolFamily(uint64_t a1, uint64_t a2)
{
  socklen_t v13 = 255;
  uint64_t v4 = *(void *)(a1 + 96);
  if (v4)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    uint64_t v5 = *(void *)(a1 + 96);
    uint64_t v6 = *(void *)(a1 + 144);
    if (v5) {
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 144);
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  if (v6) {
    uint64_t v7 = v6 + 16;
  }
  else {
    uint64_t v7 = 0;
  }
  ++*(void *)(v7 + 80);
  CFDataRef v8 = (const __CFData *)(*(uint64_t (**)(void, void *))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), &unk_1EC0A0F98);
  --*(void *)(v7 + 80);
  if (!v8) {
    return 255;
  }
  CFDataRef v9 = v8;
  *(_OWORD *)(a2 + 239) = 0u;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  BytePtr = (int *)CFDataGetBytePtr(v8);
  if (getpeername(*BytePtr, (sockaddr *)a2, &v13)) {
    uint64_t v11 = 255;
  }
  else {
    uint64_t v11 = *(unsigned __int8 *)(a2 + 1);
  }
  CFRelease(v9);
  return v11;
}

void _SocketCallBack(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, _WORD *a5)
{
  v21.version = 0;
  v21.info = a5;
  memset(&v21.retain, 0, 24);
  CFAllocatorRef v8 = CFGetAllocator(*((CFTypeRef *)a5 + 11));
  if (!a4 || *a4 == -1)
  {
    CFStreamError v20 = (CFStreamError)xmmword_1843D1910;
    _ReportError((uint64_t)a5, &v20);
    return;
  }
  if (a2 != 2) {
    return;
  }
  CFDataRef v9 = a5 + 12;
  if ((*a5 & 0x80) != 0)
  {
    CFStringRef v10 = 0;
  }
  else
  {
    CFStringRef v10 = a5 + 12;
    CFDataRef v9 = 0;
  }
  _CoreStreamCreatePairWithNativeSocket(v8, *a4, v10, v9);
  CFDictionaryApplyFunction(*((CFDictionaryRef *)a5 + 11), (CFDictionaryApplierFunction)_StreamPropertyApplier, *((void **)a5 + 3));
  CFTypeID v11 = CFGetTypeID(*((CFTypeRef *)a5 + 3));
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    CFTypeID v16 = v11;
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    CFTypeID v11 = v16;
  }
  uint64_t v12 = *((void *)a5 + 3);
  if (v12) {
    uint64_t v13 = v12 + 16;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v11 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    CoreReadStream::setClient(v13, -1, (uint64_t)_DataStreamCallBack, &v21);
    _CFTypeScheduleOnMultipleRunLoops(*((void **)a5 + 3), *((const __CFArray **)a5 + 10));
    uint64_t v14 = *((void *)a5 + 3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1) {
      goto LABEL_20;
    }
    uint64_t v17 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
    int v18 = &__block_literal_global_20142;
  }
  else
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      uint64_t v19 = v13;
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
      uint64_t v13 = v19;
    }
    CoreWriteStream::setClient(v13, -1, (uint64_t)_DataStreamCallBack, &v21);
    _CFTypeScheduleOnMultipleRunLoops(*((void **)a5 + 3), *((const __CFArray **)a5 + 10));
    uint64_t v14 = *((void *)a5 + 3);
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1) {
      goto LABEL_20;
    }
    uint64_t v17 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
    int v18 = &__block_literal_global_3661;
  }
  dispatch_once(v17, v18);
LABEL_20:
  if (v14) {
    int v15 = (CoreStreamBase *)(v14 + 16);
  }
  else {
    int v15 = 0;
  }
  CoreStreamBase::_streamInterface_Open(v15);

  _InvalidateServer((uint64_t)a5);
}

void _CoreStreamCreatePairWithNativeSocket(const __CFAllocator *a1, int a2, void *a3, void *a4)
{
  CFTypeRef v9 = 0;
  CFTypeRef cf = 0;
  if (a3) {
    p_CFTypeRef cf = (__CFReadStream **)&cf;
  }
  else {
    p_CFTypeRef cf = 0;
  }
  if (a4) {
    CFAllocatorRef v8 = (__CFWriteStream **)&v9;
  }
  else {
    CFAllocatorRef v8 = 0;
  }
  _CFStreamCreatePairWithNativeSocket(a1, a2, p_cf, v8);
  if (a3) {
    *a3 = CoreReadStreamCreateWithCFReadStream(a1, (__CFReadStream *)cf);
  }
  if (a4) {
    *a4 = CoreWriteStreamCreateWithCFWriteStream(a1, (__CFWriteStream *)v9);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v9) {
    CFRelease(v9);
  }
}

void _DataStreamCallBack(char *cf, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  if (a2 != 16 || (*(_WORD *)a3 & 0x10) != 0)
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v6 = *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96);
    CFTypeID v7 = CFGetTypeID(cf);
    if (cf) {
      CFAllocatorRef v8 = cf + 16;
    }
    else {
      CFAllocatorRef v8 = 0;
    }
    if (v7 == v6)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1)
      {
LABEL_12:
        CFStreamError v18 = *(CFStreamError *)(v8 + 56);
        if ((*(_WORD *)a3 & 0x30) != 0x10) {
          goto LABEL_24;
        }
        if (v4 == 8)
        {
          CFIndex v9 = *(void *)(a3 + 120);
          if (v9 >= CFArrayGetCount(*(CFArrayRef *)(a3 + 112))) {
            goto LABEL_23;
          }
        }
        else
        {
          if (v4 != 2) {
            goto LABEL_24;
          }
          if (_ProcessHTTPResponse(a3, &v18))
          {
            if (!v18.error)
            {
              if ((*(_WORD *)a3 & 0x40) != 0) {
                return;
              }
              goto LABEL_33;
            }
LABEL_23:
            uint64_t v4 = 8;
            goto LABEL_24;
          }
          CFIndex v10 = *(void *)(a3 + 120);
          if (v10 >= CFArrayGetCount(*(CFArrayRef *)(a3 + 112)))
          {
LABEL_33:
            uint64_t v4 = 2;
LABEL_24:
            CFTypeID v11 = CFGetTypeID(*(CFTypeRef *)(a3 + 32));
            uint64_t v12 = *(void *)(a3 + 32);
            if (v12) {
              uint64_t v13 = (CoreStreamBase *)(v12 + 16);
            }
            else {
              uint64_t v13 = 0;
            }
            if (v11 == v6)
            {
              if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1) {
                goto LABEL_31;
              }
              CFTypeID v16 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
              uint64_t v17 = &__block_literal_global_20142;
            }
            else
            {
              if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
              {
LABEL_31:
                CoreStreamBase::_signalEvent(v13, v4, v18, 1);
                return;
              }
              CFTypeID v16 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
              uint64_t v17 = &__block_literal_global_3661;
            }
            dispatch_once(v16, v17);
            goto LABEL_31;
          }
        }
        _RollOverHTTPRequest(a3, &v18);
        if (!v18.error) {
          return;
        }
        goto LABEL_23;
      }
      uint64_t v14 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
      int v15 = &__block_literal_global_20142;
    }
    else
    {
      if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1) {
        goto LABEL_12;
      }
      uint64_t v14 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
      int v15 = &__block_literal_global_3661;
    }
    dispatch_once(v14, v15);
    goto LABEL_12;
  }
}

uint64_t _ProcessHTTPResponse(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (v4) {
    uint64_t v5 = v4 + 16;
  }
  else {
    uint64_t v5 = 0;
  }
  ++*(void *)(v5 + 80);
  uint64_t result = (*(uint64_t (**)(void, void *))(**(void **)(v5 + 24) + 40))(*(void *)(v5 + 24), &unk_1EC0A3F48);
  --*(void *)(v5 + 80);
  *a2 = 0;
  a2[1] = 0;
  if (result)
  {
    CFTypeID v7 = (const void *)result;
    ResponseStatusCFIndex Code = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)result);
    if (ResponseStatusCode > 299)
    {
      int v9 = ResponseStatusCode;
      if (ResponseStatusCode == 407
        && (*(_WORD *)a1 & 0x40) == 0
        && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kCFStreamPropertyFTPProxyUser")
        && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kCFStreamPropertyFTPProxyPassword"))
      {
        *(_WORD *)a1 |= 0x40u;
        _ReleaseDataReadStream(a1);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 88), @"_kCFStreamPropertyFTPLastHTTPResponse", v7);
        _FTPStreamOpen(*(void *)(a1 + 32), a2, &v10, a1);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 88), @"_kCFStreamPropertyFTPLastHTTPResponse");
      }
      else
      {
        *a2 = 6;
        *((_DWORD *)a2 + 2) = v9;
      }
    }
    else
    {
      *(_WORD *)a1 |= 0x20u;
    }
    CFRelease(v7);
    return 1;
  }
  return result;
}

uint64_t _RollOverHTTPRequest(uint64_t a1, _OWORD *a2)
{
  _ReleaseDataReadStream(a1);
  ++*(void *)(a1 + 120);
  *(_OWORD *)(a1 + 40) = *a2;
  *(_WORD *)a1 &= ~0x40u;
  return _FTPStreamOpen(*(void *)(a1 + 32), a2, &v5, a1);
}

uint64_t _StreamPropertyApplier(const void *a1, const void *a2, char *cf)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (v6 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
    && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  if (cf) {
    CFTypeID v7 = cf + 16;
  }
  else {
    CFTypeID v7 = 0;
  }
  ++*((void *)v7 + 10);
  uint64_t result = (*(uint64_t (**)(void, const void *, const void *))(**((void **)v7 + 3) + 32))(*((void *)v7 + 3), a1, a2);
  --*((void *)v7 + 10);
  return result;
}

CFStringRef _CFURLCopyPathReplacingPercentEscapes(const __CFURL *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFStringRef result = CFURLCopyPath(a1);
  if (result)
  {
    CFStringRef v4 = result;
    CFStringRef v5 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v2, result, &stru_1ECFAD558, 0);
    CFRelease(v4);
    return v5;
  }
  return result;
}

uint64_t _ReadSize(char *__str, unint64_t *a2)
{
  *a2 = 0;
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *__str + 60) & 0x400) == 0) {
    return 0;
  }
  CFStringRef v5 = __str;
  do
  {
    unsigned int v7 = *v5++;
    __darwin_ct_rune_t v6 = v7;
    int v8 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v7 + 60);
  }
  while ((v8 & 0x400) != 0);
  if ((v6 & 0x80) != 0)
  {
    uint64_t result = __maskrune(v6, 0x4000uLL);
    if (!result) {
      return result;
    }
  }
  else
  {
    uint64_t result = v8 & 0x4000;
    if ((v8 & 0x4000) == 0) {
      return result;
    }
  }
  *a2 = strtouq(__str, 0, 10);
  return 1;
}

void _StartTransfer(uint64_t a1, uint64_t a2)
{
  CFStringRef PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)(a2 + 8));
  CFAllocatorRef v5 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  CFAllocatorRef v6 = v5;
  if ((*(_WORD *)a2 & 0x80) != 0)
  {
    *(_DWORD *)(a1 + 20) = 18;
    CFStringRef v7 = CFStringCreateWithFormat(v5, 0, @"STOR %@\r\n", PathComponent);
    uint64_t v8 = *(void *)(a2 + 24);
    if (!v8) {
      goto LABEL_14;
    }
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1) {
      goto LABEL_13;
    }
    int v9 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
    char v10 = &__block_literal_global_3661;
    goto LABEL_30;
  }
  if (CFURLHasDirectoryPath(*(CFURLRef *)(a2 + 8)) || _IsRoot(*(const __CFURL **)(a2 + 8)))
  {
    if ((*(_WORD *)a2 & 8) != 0)
    {
      CFStringRef v7 = CFStringCreateWithFormat(v6, 0, @"NLST %@\r\n", PathComponent);
      *(_DWORD *)(a1 + 20) = 16;
      uint64_t v8 = *(void *)(a2 + 24);
      if (!v8) {
        goto LABEL_14;
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1) {
        goto LABEL_13;
      }
    }
    else
    {
      CFStringRef v7 = (const __CFString *)CFRetain(@"LIST\r\n");
      *(_DWORD *)(a1 + 20) = 17;
      uint64_t v8 = *(void *)(a2 + 24);
      if (!v8) {
        goto LABEL_14;
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1) {
        goto LABEL_13;
      }
    }
LABEL_29:
    int v9 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
    char v10 = &__block_literal_global_20142;
LABEL_30:
    dispatch_once(v9, v10);
LABEL_13:
    CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v8 + 16));
    goto LABEL_14;
  }
  if ((*(_WORD *)a2 & 4) != 0)
  {
    *(_DWORD *)(a1 + 20) = 13;
    CFStringRef v7 = CFStringCreateWithFormat(v6, 0, @"SIZE %@\r\n", PathComponent);
  }
  else if (*(void *)(a2 + 72))
  {
    CFStringRef v7 = CFStringCreateWithFormat(v6, 0, @"REST %lld\r\n", *(void *)(a2 + 72));
    *(_DWORD *)(a1 + 20) = 14;
  }
  else
  {
    CFStringRef v7 = CFStringCreateWithFormat(v6, 0, @"RETR %@\r\n", PathComponent);
    *(_DWORD *)(a1 + 20) = 15;
    *(_WORD *)a2 &= ~0x800u;
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1) {
        goto LABEL_13;
      }
      goto LABEL_29;
    }
  }
LABEL_14:
  if (PathComponent) {
    CFRelease(PathComponent);
  }
  _WriteCommand(a1, a2, v7);
  if (v7)
  {
    CFRelease(v7);
  }
}

void _CoreSocketStreamCreateWithSignature(const __CFAllocator *a1, const __CFData *a2, void *a3, void *a4, const __CFData *a5, __CFReadStream **a6, __CFWriteStream **a7)
{
  CFTypeRef v12 = 0;
  CFTypeRef cf = 0;
  if (a3) {
    p_CFTypeRef cf = &cf;
  }
  else {
    p_CFTypeRef cf = 0;
  }
  if (a4) {
    CFTypeID v11 = &v12;
  }
  else {
    CFTypeID v11 = 0;
  }
  _CFStreamCreatePairWithCFSocketSignaturePieces(a1, a2, (uint64_t)p_cf, (uint64_t)v11, a5, a6, a7);
  if (a3) {
    *a3 = CoreReadStreamCreateWithCFReadStream(a1, (__CFReadStream *)cf);
  }
  if (a4) {
    *a4 = CoreWriteStreamCreateWithCFWriteStream(a1, (__CFWriteStream *)v12);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v12) {
    CFRelease(v12);
  }
}

void _FTPConnectionReceiveResponse(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[12];
  if (!v6)
  {
    uint64_t v8 = a2[19];
LABEL_7:
    uint64_t v11 = a2[18];
    goto LABEL_8;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  uint64_t v7 = a2[12];
  uint64_t v8 = a2[19];
  if (!v7) {
    goto LABEL_7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  uint64_t v9 = a2[12];
  if (!v9) {
    goto LABEL_7;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  uint64_t v10 = a2[12];
  uint64_t v11 = a2[18];
  if (v10) {
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
  }
LABEL_8:
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (v8) {
    CFTypeRef v12 = (CoreStreamBase *)(v8 + 16);
  }
  else {
    CFTypeRef v12 = 0;
  }
  if (CoreStreamBase::_streamInterface_CanRead(v12)) {
    _FTPResponseStreamCallBack(a1, v8, 2, v13, a3);
  }
  if (*(void *)(a1 + 128))
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    if (v11) {
      uint64_t v14 = (CoreStreamBase *)(v11 + 16);
    }
    else {
      uint64_t v14 = 0;
    }
    if (CoreStreamBase::_streamInterface_CanWrite(v14))
    {
      _FTPConnectionTransmitRequest(a1, a2, a3);
    }
  }
}

void _FTPConnectionRequestStateChanged(uint64_t a1, int a2, uint64_t a3, NetConnection *a4, uint64_t a5)
{
  switch(a2)
  {
    case 1:
      *(void *)(a1 + 128) = a4;
      break;
    case 2:
      CFArrayRef v9 = *(const __CFArray **)(a1 + 80);
      CFIndex Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        CFIndex v11 = Count;
        for (CFIndex i = 0; i < v11; i += 2)
        {
          CFDictionaryRef ValueAtIndex = (CoreSchedulingSet *)CFArrayGetValueAtIndex(v9, i);
          CFStringRef v14 = (const __CFString *)CFArrayGetValueAtIndex(v9, i + 1);
          NetConnection::schedule((uint64_t)a4, (uint64_t *)a1, ValueAtIndex, v14);
        }
      }
      int v15 = *(_DWORD *)(a5 + 20);
      if (v15 == 8)
      {
        _StartProcess(a5, a1);
      }
      else if (v15 >= 9)
      {
        *(unsigned char *)a5 |= 2u;
        CFStreamError v18 = *(NetConnection **)(a1 + 128);
        NetConnection::getState(v18, 1, (uint64_t *)a1);
      }
      break;
    case 5:
      CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kCFStreamPropertyFTPAttemptPersistentConnection");
      if (Value)
      {
        int v17 = CFEqual(Value, (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
        *(unsigned char *)a5 |= 8u;
        if (v17) {
          goto LABEL_20;
        }
      }
      else
      {
        *(unsigned char *)a5 |= 8u;
      }
      CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      CFDateRef v21 = CFDateCreate(v19, Current + 180.0);
      if (v21)
      {
        CFDateRef v22 = v21;
        CFDictionarySetValue((CFMutableDictionaryRef)gFTPConnectionTimeouts, *(const void **)(a1 + 128), v21);
        CFRelease(v22);
      }
      goto LABEL_20;
    case 7:
LABEL_20:
      CFArrayRef v23 = *(const __CFArray **)(a1 + 80);
      CFIndex v24 = CFArrayGetCount(v23);
      NetConnection::dequeue(a4, (void *)a1);
      if (v24 >= 1)
      {
        for (CFIndex j = 0; j < v24; j += 2)
        {
          CFArrayGetValueAtIndex(v23, j);
          CFArrayGetValueAtIndex(v23, j + 1);
          NetConnection::unschedule(a4, (uint64_t *)a1, v26, v27);
        }
      }
      uint64_t v28 = *(void *)(a1 + 128);
      if (v28) {
        (*(void (**)(uint64_t))(*(void *)v28 + 48))(v28);
      }
      *(void *)(a1 + 128) = 0;
      if (a2 == 7 && (*(_WORD *)a1 & 0x400) == 0)
      {
        char v33 = 0;
        _FTPStreamOpen(*(void *)(a1 + 32), &v34, &v33, a1);
        if (v33)
        {
          if (v34.error) {
            uint64_t v29 = 8;
          }
          else {
            uint64_t v29 = 1;
          }
          CFTypeID v30 = CFGetTypeID(*(CFTypeRef *)(a1 + 32));
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
          }
          uint64_t v31 = *(void *)(a1 + 32);
          if (v31) {
            CFDataRef v32 = (CoreStreamBase *)(v31 + 16);
          }
          else {
            CFDataRef v32 = 0;
          }
          if (v30 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
            && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          {
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
          }
          CoreStreamBase::_signalEvent(v32, v29, v34, 1);
        }
      }
      break;
    default:
      return;
  }
}

uint64_t _FTPConnectionCreateStreams(__CFAllocator *a1, uint64_t a2, void **a3, void **a4)
{
  uint64_t v7 = *(void *)(a2 + 8);
  CFStringRef v8 = *(const __CFString **)(v7 + 24);
  uint64_t v9 = *(unsigned int *)(v7 + 32);
  int v10 = *(_DWORD *)(v7 + 36);
  unsigned int valuePtr = *(_DWORD *)(v7 + 32);
  CFDictionaryRef v11 = *(const __CFDictionary **)(v7 + 40);
  *a3 = 0;
  *a4 = 0;
  if ((v10 - 3) <= 1)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v11, @"kCFStreamPropertyFTPProxy");
    CFNumberRef v13 = (const __CFNumber *)CFDictionaryGetValue(Value, @"FTPPort");
    CFStringRef v8 = (const __CFString *)CFDictionaryGetValue(Value, @"FTPProxy");
    if (v13)
    {
      CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr);
      uint64_t v9 = valuePtr;
    }
    else
    {
      if (v10 == 3) {
        uint64_t v9 = 21;
      }
      else {
        uint64_t v9 = 990;
      }
      unsigned int valuePtr = v9;
    }
  }
  CFTypeRef v20 = 0;
  CFTypeRef cf = 0;
  CFStringRef v14 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(a1, v8, (const __CFAllocator *)(unsigned __int16)v9);
  if (v14 || (CFStringRef v14 = CFHostCreateWithName(a1, v8)) != 0)
  {
    __CFStreamCreatePairWithSocketToCFHost(a1, v14, (const __CFAllocator *)v9, (__CFReadStream **)&cf, (__CFWriteStream **)&v20, 0);
    CFRelease(v14);
    int v15 = (__CFReadStream *)cf;
  }
  else
  {
    int v15 = 0;
    CFTypeRef v20 = 0;
    CFTypeRef cf = 0;
  }
  *a4 = CoreReadStreamCreateWithCFReadStream(a1, v15);
  *a3 = CoreWriteStreamCreateWithCFWriteStream(a1, (__CFWriteStream *)v20);
  if (cf) {
    CFRelease(cf);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (*a4 && (CFTypeID v16 = *a3) != 0)
  {
    uint64_t v17 = *MEMORY[0x1E4F1CFD0];
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    ++v16[12];
    (*(void (**)(void, uint64_t, uint64_t))(*(void *)v16[5] + 32))(v16[5], 0x1EC0A0390, v17);
    --v16[12];
    CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)_StreamPropertyApplier, *a4);
    CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)_StreamPropertyApplier, *a3);
    return 0;
  }
  else
  {
    __error();
    return 1;
  }
}

void _CFFTPNetConnectionContextFinalize(CFAllocatorRef allocator, void *ptr)
{
  uint64_t v4 = ptr[1];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
  }
  CFAllocatorRef v5 = (const void *)ptr[3];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)ptr[6];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)ptr[7];
  if (v7) {
    CFRelease(v7);
  }

  CFAllocatorDeallocate(allocator, ptr);
}

_OWORD *_CFFTPNetConnectionContextAllocate(const __CFAllocator *a1, long long *a2)
{
  uint64_t v4 = CFAllocatorAllocate(a1, 64, 0);
  long long v5 = a2[3];
  long long v7 = *a2;
  long long v6 = a2[1];
  v4[2] = a2[2];
  v4[3] = v5;
  _OWORD *v4 = v7;
  v4[1] = v6;
  *((void *)v4 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = *((void *)a2 + 1);
  (*(void (**)(void))(**((void **)a2 + 1) + 40))(*((void *)a2 + 1));
  if (!*((void *)v4 + 6)) {
    *((void *)v4 + 6) = CFDataCreateMutable(a1, 0);
  }
  if (!*((void *)v4 + 7)) {
    *((void *)v4 + 7) = CFDataCreateMutable(a1, 0);
  }
  *(unsigned char *)v4 &= ~4u;
  return v4;
}

void PACTimerCallback_FTPStream(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v3 = CFGetAllocator(*(CFTypeRef *)(a2 + 32));
  CFCFStreamError Error = __cfnCreateCFError(v3, @"kCFErrorDomainCFNetwork", 308, v4, v5, v6, v7, v8, 0);
  PACExecutionComplete_FTPStream(a2, 0, CFError);
  CFAbsoluteTime Current = CFRunLoopGetCurrent();

  CFRunLoopStop(Current);
}

void PACExecutionComplete_FTPStream(uint64_t a1, const void *a2, void *a3)
{
  v17.CFIndex domain = 0;
  *(void *)&v17.SInt32 error = 0;
  *(_WORD *)a1 &= ~0x1000u;
  invalidatePacExecutionContext(a1);
  *(void *)(a1 + 96) = 0;
  if (a3)
  {
    CFRetain(a3);
    *(void *)(a1 + 104) = a3;
    CFIndex v6 = _CFStreamErrorFromCFError((__CFError *)a3);
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)(a1 + 32);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v9) {
      int v10 = (CoreStreamBase *)(v9 + 16);
    }
    else {
      int v10 = 0;
    }
    uint64_t v11 = 8;
    v12.CFIndex domain = v6;
    *(void *)&v12.SInt32 error = v8;
  }
  else
  {
    if (a2) {
      CFRetain(a2);
    }
    *(void *)(a1 + 112) = a2;
    CFArrayRef v13 = *(const __CFArray **)(a1 + 80);
    if (v13 && CFArrayGetCount(v13) >= 1 && (_FTPStreamOpen(*(void *)(a1 + 32), &v17, &v16, a1), v17.error))
    {
      uint64_t v14 = *(void *)(a1 + 32);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      if (v14) {
        int v10 = (CoreStreamBase *)(v14 + 16);
      }
      else {
        int v10 = 0;
      }
      CFStreamError v12 = v17;
      uint64_t v11 = 8;
    }
    else
    {
      uint64_t v15 = *(void *)(a1 + 32);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      if (v15) {
        int v10 = (CoreStreamBase *)(v15 + 16);
      }
      else {
        int v10 = 0;
      }
      uint64_t v11 = 1;
      v12.CFIndex domain = 0;
      *(void *)&v12.SInt32 error = 0;
    }
  }

  CoreStreamBase::_signalEvent(v10, v11, v12, 1);
}

void ___ZL14_FTPStreamOpenPKvP13CFStreamErrorPhP19_CFFTPStreamContext_block_invoke()
{
}

CFStringRef _FTPStreamCopyDescription(const void *a1, uint64_t a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  uint64_t v5 = @"upload";
  if ((*(_WORD *)a2 & 0x80) == 0) {
    uint64_t v5 = @"download";
  }
  return CFStringCreateWithFormat(v4, 0, @"<FTPStream %p>{%@, url = %@, flags = %p }", a1, v5, *(void *)(a2 + 8), a2);
}

void _FTPStreamFinalize(const void *a1, void *a2)
{
  _FTPStreamClose((uint64_t)a1, (uint64_t)a2);
  CFAllocatorRef v4 = (const void *)a2[1];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a2[2];
  if (v5) {
    CFRelease(v5);
  }
  CFIndex v6 = (const void *)a2[10];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a2[11];
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)a2[14];
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)a2[8];
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = a2[17];
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  CFAllocatorRef v11 = CFGetAllocator(a1);

  CFAllocatorDeallocate(v11, a2);
}

CFReadStreamRef CFReadStreamCreateWithFTPURL(CFAllocatorRef alloc, CFURLRef ftpURL)
{
  if (!ftpURL) {
    return 0;
  }
  CFURLRef CFFTPHappyURL = _CreateCFFTPHappyURL(ftpURL);
  if (!CFFTPHappyURL) {
    return 0;
  }
  CFURLRef v4 = CFFTPHappyURL;
  if (!_ValidFTPPathname(CFFTPHappyURL)) {
    goto LABEL_31;
  }
  CFStringRef v5 = CFURLCopyScheme(v4);
  if (!v5) {
    goto LABEL_31;
  }
  CFStringRef v6 = v5;
  if (CFStringCompare(v5, @"ftp", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v6, @"ftps", 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(v6);
    CFStringRef v8 = CFURLCopyHostName(v4);
    if (v8)
    {
      CFRelease(v8);
      CFStringRef v9 = CFURLCopyUserName(v4);
      CFStringRef v10 = v9;
      if (v9 && !_ValidFTPString(v9))
      {
        CFStringRef v19 = v10;
      }
      else
      {
        CFStringRef v11 = CFURLCopyPassword(v4);
        CFStringRef v12 = v11;
        if (!v11 || _ValidFTPString(v11))
        {
          CFArrayRef v13 = CFAllocatorAllocate(alloc, 144, 0);
          if (v13)
          {
            uint64_t v14 = v13;
            *((_OWORD *)v13 + 7) = 0u;
            *((_OWORD *)v13 + 8) = 0u;
            *((_OWORD *)v13 + 5) = 0u;
            *((_OWORD *)v13 + 6) = 0u;
            *((_OWORD *)v13 + 3) = 0u;
            *((_OWORD *)v13 + 4) = 0u;
            *((_OWORD *)v13 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
            *((_OWORD *)v13 + 2) = 0u;
            *(_OWORD *)CFArrayRef v13 = 0u;
            *(_WORD *)CFArrayRef v13 = 1;
            v13[1] = CFURLCopyAbsoluteURL(v4);
            v14[10] = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            v14[11] = Mutable;
            char v16 = (const void *)v14[1];
            if (v16)
            {
              if (!v14[10] || !Mutable) {
                goto LABEL_34;
              }
              uint64_t v29 = 0;
              uint64_t v34 = 0;
              long long v23 = 1uLL;
              CFIndex v24 = _FTPStreamFinalize;
              uint64_t v25 = _FTPStreamCopyDescription;
              CFDataRef v26 = _FTPStreamOpen;
              CFStringRef v27 = _FTPStreamOpenCompleted;
              uint64_t v28 = _FTPStreamRead;
              CFTypeID v30 = _FTPStreamCanRead;
              uint64_t v31 = _FTPStreamClose;
              CFDataRef v32 = _FTPStreamCopyProperty;
              char v33 = _FTPStreamSetProperty;
              CFDataRef v35 = _FTPStreamSchedule;
              uint64_t v36 = _FTPStreamUnschedule;
              CFStreamError v17 = CoreReadStreamCreate((uint64_t)alloc, &v23, (uint64_t)v14);
              if (v17)
              {
                uint64_t v18 = (uint64_t)v17;
                void v14[4] = v17;
                if (v10)
                {
                  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
                    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
                  }
                  ++*(void *)(v18 + 96);
                  (*(void (**)(void, __CFString *, const __CFString *))(**(void **)(v18 + 40) + 32))(*(void *)(v18 + 40), @"kCFStreamPropertyFTPUserName_prevalidated", v10);
                  --*(void *)(v18 + 96);
                }
                if (v12)
                {
                  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
                    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
                  }
                  ++*(void *)(v18 + 96);
                  (*(void (**)(void, __CFString *, const __CFString *))(**(void **)(v18 + 40) + 32))(*(void *)(v18 + 40), @"kCFStreamPropertyFTPPassword_prevalidated", v12);
                  --*(void *)(v18 + 96);
                }
LABEL_41:
                CFRelease(v4);
                if (v10) {
                  CFRelease(v10);
                }
                if (v12) {
                  CFRelease(v12);
                }
                if (v18)
                {
                  uint64_t v7 = (__CFReadStream *)_CFReadStreamCreateWithCoreStream((uint64_t)alloc, v18);
                  CFURLRef v4 = (const __CFURL *)v18;
                  goto LABEL_32;
                }
                return 0;
              }
              char v16 = (const void *)v14[1];
              if (v16) {
LABEL_34:
              }
                CFRelease(v16);
            }
            CFTypeRef v20 = (const void *)v14[10];
            if (v20) {
              CFRelease(v20);
            }
            CFDateRef v21 = (const void *)v14[11];
            if (v21) {
              CFRelease(v21);
            }
            CFAllocatorDeallocate(alloc, v14);
          }
          uint64_t v18 = 0;
          goto LABEL_41;
        }
        if (v10) {
          CFRelease(v10);
        }
        CFStringRef v19 = v12;
      }
      CFRelease(v19);
    }
LABEL_31:
    uint64_t v7 = 0;
    goto LABEL_32;
  }
  CFRelease(v4);
  uint64_t v7 = 0;
  CFURLRef v4 = (const __CFURL *)v6;
LABEL_32:
  CFRelease(v4);
  return v7;
}

uint64_t _FTPStreamCanRead(int a1, char *a2)
{
  CFAllocatorRef v3 = (NetConnection *)*((void *)a2 + 16);
  if (!v3) {
    goto LABEL_34;
  }
  NetConnection::getState(v3, 1, (uint64_t *)a2);
  uint64_t v4 = *((void *)a2 + 16);
  if (!v4)
  {
    uint64_t v8 = *((void *)a2 + 4);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    uint64_t v9 = v8 + 16;
    if (!v8) {
      uint64_t v9 = 0;
    }
    *(void *)&v10.SInt32 error = *(void *)(v9 + 64);
    if (!v10.error) {
      goto LABEL_34;
    }
    v10.CFIndex domain = *(void *)(v9 + 56);
    uint64_t v11 = *((void *)a2 + 4);
    if (v11) {
      CFStringRef v12 = (CoreStreamBase *)(v11 + 16);
    }
    else {
      CFStringRef v12 = 0;
    }
    uint64_t v13 = 1;
    goto LABEL_41;
  }
  CFStreamError v30 = (CFStreamError)0;
  uint64_t v5 = *(void *)(v4 + 96);
  if (v5)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
    uint64_t v6 = *(void *)(v4 + 96);
    uint64_t v7 = *(void *)(v4 + 144);
    if (v6) {
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
    }
  }
  else
  {
    uint64_t v7 = *(void *)(v4 + 144);
  }
  uint64_t v14 = *((void *)a2 + 16);
  uint64_t v15 = *(void *)(v14 + 96);
  if (v15)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
    uint64_t v16 = *(void *)(v14 + 96);
    uint64_t v17 = *(void *)(v14 + 152);
    if (v16) {
      pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
    }
    if (v17)
    {
LABEL_20:
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      CFIndex v18 = *(void *)(v17 + 72);
      uint64_t v17 = *(void *)(v17 + 80);
      v30.CFIndex domain = v18;
      *(void *)&v30.SInt32 error = v17;
      int v19 = v17;
      if (v17) {
        goto LABEL_30;
      }
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v17 = *(void *)(v14 + 152);
    if (v17) {
      goto LABEL_20;
    }
  }
  CFIndex v18 = 0;
  int v19 = 0;
LABEL_26:
  if (v7)
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    CFIndex v18 = *(void *)(v7 + 72);
    uint64_t v17 = *(void *)(v7 + 80);
    v30.CFIndex domain = v18;
    *(void *)&v30.SInt32 error = v17;
    int v19 = v17;
  }
LABEL_30:
  if (!v19)
  {
LABEL_34:
    uint64_t v13 = 0;
    goto LABEL_42;
  }
  if (!*(_DWORD *)((*(uint64_t (**)(void))(**((void **)a2 + 16) + 80))(*((void *)a2 + 16)) + 20))
  {
    CFIndex v20 = *((void *)a2 + 15);
    if (v20 < CFArrayGetCount(*((CFArrayRef *)a2 + 14)))
    {
      uint64_t v21 = *((void *)a2 + 16);
      ++*((void *)a2 + 15);
      *(CFStreamError *)(a2 + 40) = v30;
      (*(void (**)(uint64_t, CFStreamError *))(*(void *)v21 + 64))(v21, &v30);
      goto LABEL_34;
    }
  }
  uint64_t v22 = *((void *)a2 + 4);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (v22) {
    CFStringRef v12 = (CoreStreamBase *)(v22 + 16);
  }
  else {
    CFStringRef v12 = 0;
  }
  uint64_t v13 = 1;
  v10.CFIndex domain = v18;
  *(void *)&v10.SInt32 error = v17;
LABEL_41:
  CoreStreamBase::_signalEvent(v12, 8, v10, 1);
LABEL_42:
  uint64_t v23 = *((void *)a2 + 3);
  if (!v23) {
    return v13;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t v13 = CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v23 + 16));
  if (!v13)
  {
    uint64_t v24 = *((void *)a2 + 3);
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v24) {
      uint64_t v25 = (CoreStreamBase *)(v24 + 16);
    }
    else {
      uint64_t v25 = 0;
    }
    if (CoreStreamBase::_streamInterface_GetStatus(v25) != 5) {
      return 0;
    }
    uint64_t v13 = 1;
  }
  if ((*(_WORD *)a2 & 0x30) != 0x10) {
    return v13;
  }
  if (!_ProcessHTTPResponse((uint64_t)a2, &v30))
  {
    CFIndex v26 = *((void *)a2 + 15);
    if (v26 >= CFArrayGetCount(*((CFArrayRef *)a2 + 14))) {
      return v13;
    }
    _RollOverHTTPRequest((uint64_t)a2, &v30);
  }
  if (!v30.error) {
    return 0;
  }
  uint64_t v27 = *((void *)a2 + 4);
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (v27) {
    uint64_t v28 = (CoreStreamBase *)(v27 + 16);
  }
  else {
    uint64_t v28 = 0;
  }
  CoreStreamBase::_signalEvent(v28, 8, v30, 1);
  return v13;
}

uint64_t _FTPStreamRead(int a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unsigned char *a5, char *a6)
{
  uint64_t v11 = a6 + 40;
  while (2)
  {
    while (2)
    {
      *a5 = 0;
      *(void *)a4 = 0;
      *(_DWORD *)(a4 + 8) = 0;
LABEL_3:
      CFStringRef v12 = (NetConnection *)*((void *)a6 + 16);
      while (1)
      {
        if (!v12) {
          goto LABEL_39;
        }
        uint64_t v13 = *((void *)a6 + 3);
        if (v13)
        {
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
          }
          if (CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v13 + 16))) {
            goto LABEL_39;
          }
          CFStringRef v12 = (NetConnection *)*((void *)a6 + 16);
        }
        NetConnection::getState(v12, 1, (uint64_t *)a6);
        uint64_t v14 = *((void *)a6 + 16);
        if (!v14) {
          break;
        }
        uint64_t v15 = *(void *)(v14 + 96);
        if (v15)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
          uint64_t v16 = *(void *)(v14 + 96);
          uint64_t v17 = *(void *)(v14 + 144);
          if (v16) {
            pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
          }
        }
        else
        {
          uint64_t v17 = *(void *)(v14 + 144);
        }
        uint64_t v18 = *((void *)a6 + 16);
        uint64_t v19 = *(void *)(v18 + 96);
        if (v19)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v19 + 8));
          uint64_t v20 = *(void *)(v18 + 96);
          uint64_t v21 = *(void *)(v18 + 152);
          if (v20) {
            pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8));
          }
          if (v21)
          {
LABEL_19:
            if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
              dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
            }
            uint64_t v22 = *(void *)(v21 + 80);
            *(void *)a4 = *(void *)(v21 + 72);
            *(void *)(a4 + 8) = v22;
            if (v22) {
              goto LABEL_29;
            }
LABEL_25:
            if (v17)
            {
              if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
                dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
              }
              uint64_t v23 = *(void *)(v17 + 80);
              *(void *)a4 = *(void *)(v17 + 72);
              *(void *)(a4 + 8) = v23;
              LODWORD(v22) = v23;
            }
            goto LABEL_29;
          }
        }
        else
        {
          uint64_t v21 = *(void *)(v18 + 152);
          if (v21) {
            goto LABEL_19;
          }
        }
        LODWORD(v22) = *(_DWORD *)(a4 + 8);
        if (!v22) {
          goto LABEL_25;
        }
LABEL_29:
        CFStringRef v12 = (NetConnection *)*((void *)a6 + 16);
        if (v22)
        {
          if (!*(_DWORD *)((*(uint64_t (**)(NetConnection *))(*(void *)v12 + 80))(v12) + 20))
          {
            CFIndex v24 = *((void *)a6 + 15);
            if (v24 < CFArrayGetCount(*((CFArrayRef *)a6 + 14)))
            {
              uint64_t v25 = *((void *)a6 + 16);
              ++*((void *)a6 + 15);
              *uint64_t v11 = *(_OWORD *)a4;
              (*(void (**)(uint64_t, uint64_t))(*(void *)v25 + 64))(v25, a4);
              goto LABEL_3;
            }
          }
          goto LABEL_38;
        }
      }
      uint64_t v26 = *((void *)a6 + 4);
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      uint64_t v27 = v26 + 16;
      if (!v26) {
        uint64_t v27 = 0;
      }
      uint64_t v29 = *(void *)(v27 + 56);
      uint64_t v28 = *(void *)(v27 + 64);
      *(void *)a4 = v29;
      *(void *)(a4 + 8) = v28;
      if (v28)
      {
LABEL_38:
        *a5 = 1;
        uint64_t v30 = -1;
        goto LABEL_40;
      }
LABEL_39:
      uint64_t v30 = 0;
LABEL_40:
      uint64_t v31 = *((void *)a6 + 3);
      if (!v31) {
        return v30;
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      uint64_t v32 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)(v31 + 16), a2, a3);
      uint64_t v30 = v32;
      if ((*(_WORD *)a6 & 0x30) != 0x10)
      {
LABEL_52:
        if (v30 <= 0)
        {
          __int16 v34 = *(_WORD *)a6;
          if ((*(_WORD *)a6 & 0x800) != 0)
          {
            uint64_t v36 = (NetConnection *)*((void *)a6 + 16);
            if (v36)
            {
              NetConnection::responseIsComplete(v36, a6);
              __int16 v34 = *(_WORD *)a6;
            }
            __int16 v35 = v34 & 0xF7FF;
          }
          else
          {
            __int16 v35 = v34 | 0x800;
          }
          *(_WORD *)a6 = v35;
          *a5 = 1;
          uint64_t v37 = *((void *)a6 + 3);
          if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
            dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
          }
          uint64_t v38 = v37 + 16;
          if (!v37) {
            uint64_t v38 = 0;
          }
          *(_OWORD *)a4 = *(_OWORD *)(v38 + 56);
        }
        return v30;
      }
      if (v32 < 0 || !_ProcessHTTPResponse((uint64_t)a6, (void *)a4))
      {
        CFIndex v33 = *((void *)a6 + 15);
        if (v33 < CFArrayGetCount(*((CFArrayRef *)a6 + 14)))
        {
          _RollOverHTTPRequest((uint64_t)a6, (_OWORD *)a4);
          if (*(_DWORD *)(a4 + 8)) {
            goto LABEL_55;
          }
          continue;
        }
        goto LABEL_52;
      }
      break;
    }
    if (!*(_DWORD *)(a4 + 8))
    {
      if ((*(_WORD *)a6 & 0x40) == 0) {
        goto LABEL_52;
      }
      continue;
    }
    break;
  }
LABEL_55:
  *a5 = 1;
  return v30;
}

id cookieNotificationQueue(void)
{
  if (cookieNotificationQueue(void)::onceToken != -1) {
    dispatch_once(&cookieNotificationQueue(void)::onceToken, &__block_literal_global_879);
  }
  CFAllocatorRef v0 = (void *)cookieNotificationQueue(void)::notificaionQueue;

  return v0;
}

void sub_18419AA40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL23cookieNotificationQueuev_block_invoke()
{
  CFAllocatorRef v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  CFAllocatorRef v0 = dispatch_queue_attr_make_with_qos_class(v3, QOS_CLASS_UTILITY, 0);
  dispatch_queue_t v1 = dispatch_queue_create("com.apple.NSHTTPCookieManagerNotification", v0);
  CFAllocatorRef v2 = (void *)cookieNotificationQueue(void)::notificaionQueue;
  cookieNotificationQueue(void)::notificaionQueue = (uint64_t)v1;
}

void sub_18419AB88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_18419AC94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_18419AF54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419B0E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_18419B35C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419B518(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419B854(_Unwind_Exception *a1)
{
  uint64_t v5 = v3;

  _Unwind_Resume(a1);
}

void sub_18419BA00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__901(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__902(uint64_t a1)
{
}

void sub_18419BDE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419BFAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419C1B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419C338(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419C45C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_18419C59C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419C6B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419C9C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_18419CD14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_18419D0FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_18419D34C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_18419D508(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419D5A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419D654(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419D890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_18419D944(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419DA08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18419DAD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFReadStreamRef CFReadStreamCreateForHTTPRequest(CFAllocatorRef alloc, CFHTTPMessageRef request)
{
  return (CFReadStreamRef)CFReadStreamCreate();
}

void __CFReadStreamCreateForHTTPRequest_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 32), 152, 0);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  void v4[4] = 0u;
  void v4[5] = 0u;
  void v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  *((void *)v4 + 18) = 0;
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*(unsigned char *)(v5 + 40)) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = (HTTPRequestMessage *)(v5 + 16);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }

  HTTPReadStream::HTTPReadStream((HTTPReadStream *)v4, a2, v6, 0);
}

CFReadStreamRef CFReadStreamCreateForStreamedHTTPRequest(CFAllocatorRef alloc, CFHTTPMessageRef requestHeaders, CFReadStreamRef requestBody)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!requestBody || CFReadStreamGetStatus(requestBody) != kCFStreamStatusOpen) {
    return (CFReadStreamRef)CFReadStreamCreate();
  }
  CFLog();
  CFReadStreamSetClient(requestBody, 0, 0, 0);
  CFWriteStreamRef writeStream = 0;
  CFReadStreamRef readStream = 0;
  CFStreamCreateBoundPair(alloc, &readStream, &writeStream, 0x8000);
  CFWriteStreamOpen(writeStream);
  *(_OWORD *)keys = xmmword_1E5252DB8;
  values[0] = requestBody;
  values[1] = writeStream;
  CFDictionaryRef v5 = CFDictionaryCreate(alloc, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(writeStream);
  pthread_attr_init(&v11);
  pthread_attr_setdetachstate(&v11, 2);
  pthread_t v8 = 0;
  if (pthread_create(&v8, &v11, (void *(__cdecl *)(void *))_boundPairReadingThread, v5))
  {
    CFRelease(v5);
    CFLog();
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = (__CFReadStream *)CFReadStreamCreate();
  }
  pthread_attr_destroy(&v11);
  CFRelease(readStream);
  return v6;
}

void ___ZL24_handleAlreadyOpenStreamPK13__CFAllocatorP15__CFHTTPMessageP14__CFReadStream_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 32), 152, 0);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  void v4[4] = 0u;
  void v4[5] = 0u;
  void v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  *((void *)v4 + 18) = 0;
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*(unsigned char *)(v5 + 40)) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = (HTTPRequestMessage *)(v5 + 16);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(__CFReadStream **)(a1 + 48);

  HTTPReadStream::HTTPReadStream((HTTPReadStream *)v4, a2, v6, v7);
}

void __CFReadStreamCreateForStreamedHTTPRequest_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 32), 152, 0);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  void v4[4] = 0u;
  void v4[5] = 0u;
  void v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  *((void *)v4 + 18) = 0;
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*(unsigned char *)(v5 + 40)) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = (HTTPRequestMessage *)(v5 + 16);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(__CFReadStream **)(a1 + 48);

  HTTPReadStream::HTTPReadStream((HTTPReadStream *)v4, a2, v6, v7);
}

void _boundPairReadingThread(void *a1)
{
}

void non-virtual thunk to'GlueTubeManager::~GlueTubeManager(GlueTubeManager *this)
{
  CFAllocatorRef v2 = (char *)this - 24;
  GlueTubeManager::~GlueTubeManager((GlueTubeManager *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  GlueTubeManager::~GlueTubeManager((GlueTubeManager *)((char *)this - 24));
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_nw_context}*,Deleter_NWRelease<NSObject  {objcproto13OS_nw_context}*>,std::allocator<NSObject  {objcproto13OS_nw_context}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<NWIOConnection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA67C8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<NWIOConnection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA67C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

_OWORD *GlueTubeManager::_findOrCreateSManager(GlueTubeManager *this)
{
  dispatch_queue_t v1 = (_OWORD *)*((void *)this + 5);
  if (!v1)
  {
    dispatch_queue_t v1 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 152, 0);
    *dispatch_queue_t v1 = 0u;
    v1[1] = 0u;
    v1[2] = 0u;
    v1[3] = 0u;
    v1[4] = 0u;
    v1[5] = 0u;
    v1[6] = 0u;
    v1[7] = 0u;
    v1[8] = 0u;
    *((void *)v1 + 18) = 0;
    CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);
    uint64_t v4 = *((void *)this + 6);
    long long v8 = *(_OWORD *)((char *)this + 56);
    long long v9 = *(_OWORD *)((char *)this + 72);
    uint64_t v10 = *((void *)this + 11);
    CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)v1, v3);
    *(void *)uint64_t v5 = &unk_1ECF9BEC0;
    *(void *)(v5 + 24) = &unk_1ECF9BF28;
    *(_OWORD *)(v5 + 40) = xmmword_1843D16C0;
    uint64_t v6 = v5 + 40;
    *(_OWORD *)(v5 + 56) = xmmword_1843D16D0;
    *(void *)(v5 + 72) = 0x7800000078;
    *(void *)(v5 + 104) = &unk_1ECFA0330;
    *((void *)v1 + 14) = CFDictionaryCreateMutable(v3, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
    *((void *)v1 + 15) = &unk_1ECFA03D0;
    *((void *)v1 + 16) = CFDictionaryCreateMutable(v3, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, MEMORY[0x1E4F1D540]);
    *((void *)v1 + 17) = CFArrayCreateMutable(v3, 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    *((void *)v1 + 18) = CFArrayCreateMutable(v3, 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    if (!v4) {
      __assert_rtn("STubeManager", "STubeManager.cpp", 24, "schedulingSet");
    }
    *((void *)v1 + 4) = v4;
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
    *(_OWORD *)uint64_t v6 = v8;
    *(_OWORD *)(v6 + 16) = v9;
    *(void *)(v6 + 32) = v10;
    *((void *)v1 + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
    *((void *)v1 + 12) = 0;
    *((void *)v1 + 10) = 0;
    *((void *)this + 5) = v1;
  }
  return v1;
}

void sub_18419E3F8(_Unwind_Exception *a1)
{
  CFRelease(*(CFTypeRef *)(v1 + 136));
  *(void *)(v1 + 120) = v3;
  CFRelease(*(CFTypeRef *)(v1 + 128));
  *(void *)(v1 + 104) = v2;
  CFRelease(*(CFTypeRef *)(v1 + 112));
  void *v4 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t _CFServerCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!_ServerTypeId)
  {
    _ServerTypeId = _CFRuntimeRegisterClass();
    if (!_ServerTypeId) {
      return 0;
    }
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v6 = Instance;
  if (!Instance) {
    return v6;
  }
  *(void *)(Instance + 16) = 0;
  *(void *)(Instance + 24) = 0;
  *(_DWORD *)(Instance + 40) = 0;
  *(void *)(Instance + 32) = 0;
  *(void *)(Instance + 56) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)Instance);
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  uint64_t v7 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  long long v8 = dispatch_queue_create("com.apple.CFNetwork.CFServer", v7);
  *(void *)(v6 + 48) = tcp_listener_create();
  dispatch_release(v8);
  if (!*(void *)(v6 + 48))
  {
    _CFServerInvalidate(v6);
    CFRelease((CFTypeRef)v6);
    return 0;
  }
  tcp_listener_set_accept_handler_f();
  tcp_listener_set_error_handler_f();
  *(void *)(v6 + 64) = a2;
  uint64_t v9 = *(void *)(a3 + 32);
  long long v10 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(v6 + 72) = *(_OWORD *)a3;
  *(void *)(v6 + 104) = v9;
  *(_OWORD *)(v6 + 88) = v10;
  if (*(void *)(v6 + 80))
  {
    pthread_attr_t v11 = *(uint64_t (**)(void))(v6 + 88);
    if (v11) {
      *(void *)(v6 + 80) = v11();
    }
  }
  return v6;
}

uint64_t _CFServerInvalidate(uint64_t a1)
{
  if (*(void *)(a1 + 80))
  {
    uint64_t v2 = *(void (**)(void))(a1 + 96);
    if (v2) {
      v2();
    }
  }
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
    *(void *)(a1 + 56) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v6 = *(const void **)(a1 + 32);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + 32) = 0;
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    tcp_listener_cancel();
    uint64_t result = tcp_listener_release();
    *(void *)(a1 + 48) = 0;
  }
  return result;
}

uint64_t _tcp_listener_ErrorCallback(uint64_t result, int a2)
{
  if (*(void *)(result + 64))
  {
    uint64_t v2 = result;
    uint64_t result = *(void *)(result + 56);
    if (*(_DWORD *)(result + 40))
    {
      if (a2 >> 5 == 134215679)
      {
        if (a2 > -65549)
        {
          if (a2 == -65548)
          {
            a2 = -72001;
            goto LABEL_15;
          }
          if (a2 == -65540)
          {
            a2 = -72004;
            goto LABEL_15;
          }
LABEL_14:
          a2 = -72000;
          goto LABEL_15;
        }
        if (a2 != -65555)
        {
          if (a2 == -65554)
          {
            a2 = -72002;
LABEL_15:
            uint64_t v3 = 10;
            goto LABEL_16;
          }
          goto LABEL_14;
        }
        uint64_t v3 = 10;
        a2 = -72008;
      }
      else
      {
        uint64_t v3 = 1;
      }
LABEL_16:
      v4[0] = MEMORY[0x1E4F143A8];
      v4[1] = 3221225472;
      v4[2] = ___ZL18_ServerHandleErrorP6Serveri_block_invoke;
      v4[3] = &__block_descriptor_56_e5_v8__0l;
      void v4[4] = v2;
      void v4[5] = v3;
      int v5 = a2;
      int v6 = 0;
      return (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 96))(result, v4);
    }
  }
  return result;
}

uint64_t ___ZL18_ServerHandleErrorP6Serveri_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)(a1 + 32) + 64))(*(void *)(a1 + 32), 0xFFFFFFFFLL, a1 + 40, *(void *)(*(void *)(a1 + 32) + 80));
}

uint64_t _tcp_listener_AcceptCallback()
{
  return tcp_connection_start();
}

_DWORD *___ZL28_tcp_listener_AcceptCallbackPvPU28objcproto17OS_tcp_connection8NSObject_block_invoke(_DWORD *result, int a2)
{
  if (a2 == 1)
  {
    uint64_t v9 = v2;
    uint64_t v10 = v3;
    uint64_t v4 = result;
    int v5 = tcp_connection_copy_socket();
    uint64_t result = (_DWORD *)tcp_connection_cancel();
    uint64_t v6 = *((void *)v4 + 5);
    if (*(void *)(v6 + 64))
    {
      uint64_t result = *(_DWORD **)(v6 + 56);
      if (result[10])
      {
        void v7[5] = 0;
        void v7[6] = 0;
        v7[0] = MEMORY[0x1E4F143A8];
        v7[1] = 3221225472;
        int v7[2] = ___ZL19_ServerHandleAcceptP6Serveri_block_invoke;
        v7[3] = &__block_descriptor_60_e5_v8__0l;
        v7[4] = v6;
        int v8 = v5;
        return (_DWORD *)(*(uint64_t (**)(_DWORD *, void *))(*(void *)result + 96))(result, v7);
      }
    }
  }
  return result;
}

uint64_t ___ZL19_ServerHandleAcceptP6Serveri_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 32) + 64))(*(void *)(a1 + 32), *(unsigned int *)(a1 + 56), a1 + 40, *(void *)(*(void *)(a1 + 32) + 80));
}

CFStringRef _ServerCopyDescription(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  uint64_t v3 = (uint64_t (*)(void))a1[13];
  if (v3) {
    CFStringRef v4 = (CFStringRef)v3(a1[10]);
  }
  else {
    CFStringRef v4 = CFStringCreateWithFormat(v2, 0, @"<%p>", a1[10]);
  }
  CFStringRef v5 = v4;
  CFStringRef v6 = CFStringCreateWithFormat(v2, 0, @"<Server %p>{tcp_listener=%p, info=%@}", a1, a1[6], v4);
  CFRelease(v5);
  return v6;
}

uint64_t _CFServerScheduleWithRunLoopAndMode(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 56))(*(void *)(a1 + 56));
  *(void *)(a1 + 56) = result;
  return result;
}

uint64_t _CFServerGetPort(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    unsigned int port = tcp_listener_get_port();
    if (port) {
      return __rev16(port);
    }
    CFLog();
  }
  return *(unsigned __int16 *)(a1 + 40);
}

uint64_t _CFServerStart(uint64_t a1, __CFString *a2, const void *a3, unsigned int a4)
{
  v31[1] = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 48)) {
    return 0;
  }
  if (!*(_DWORD *)(*(void *)(a1 + 56) + 40))
  {
    CFRunLoopRef Current = CFRunLoopGetCurrent();
    *(void *)(a1 + 56) = (*(uint64_t (**)(void, CFRunLoopRef, void))(**(void **)(a1 + 56) + 56))(*(void *)(a1 + 56), Current, *MEMORY[0x1E4F1D410]);
  }
  if (a4 < 0x10000)
  {
    if (a2) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = &stru_1ECFAD558;
    }
    *(void *)(a1 + 16) = CFRetain(v9);
    if (a3)
    {
      *(void *)(a1 + 24) = CFRetain(a3);
      *(void *)(a1 + 32) = &stru_1ECFAD558;
      *(_DWORD *)(a1 + 4dispatch_get_global_queue(0, 0) = a4;
      CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
      CFIndex v11 = CFStringGetLength(*(CFStringRef *)(a1 + 24));
      CFIndex v12 = CFStringGetLength(*(CFStringRef *)(a1 + 32));
      CFIndex v13 = v12 + 1;
      uint64_t v16 = MEMORY[0x1F4188790](v12, v14, v15);
      uint64_t v19 = MEMORY[0x1F4188790](v16, v17, v18);
      uint64_t v22 = (char *)v31 - ((MEMORY[0x1F4188790](v19, v20, v21) + 16) & 0xFFFFFFFFFFFFFFF0);
      CFStringGetCString(*(CFStringRef *)(a1 + 16), (char *)v31 - ((Length + 16) & 0xFFFFFFFFFFFFFFF0), Length + 1, 0x8000100u);
      CFStringGetCString(*(CFStringRef *)(a1 + 24), (char *)v31 - ((v11 + 16) & 0xFFFFFFFFFFFFFFF0), v11 + 1, 0x8000100u);
      CFStringGetCString(*(CFStringRef *)(a1 + 32), v22, v13, 0x8000100u);
      tcp_listener_set_service();
      if (!*(_DWORD *)(a1 + 40)) {
        goto LABEL_16;
      }
    }
    else
    {
      *(void *)(a1 + 24) = 0;
      *(void *)(a1 + 32) = &stru_1ECFAD558;
      *(_DWORD *)(a1 + 4dispatch_get_global_queue(0, 0) = a4;
      if (!a4) {
        goto LABEL_16;
      }
    }
    CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)a1);
    CFStringRef v24 = CFStringCreateWithFormat(v23, 0, @"%u", *(unsigned int *)(a1 + 40));
    CFIndex v25 = CFStringGetLength(v24);
    MEMORY[0x1F4188790](v25, v26, v25 + 1);
    CFStringGetCString(v24, (char *)v31 - v27, v28, 0x8000100u);
    int v29 = tcp_listener_set_port();
    CFRelease(v24);
    if (v29) {
      return 0;
    }
LABEL_16:
    tcp_listener_start();
    return 1;
  }
  tcp_listener_release();
  return 0;
}

void non-virtual thunk to'ActualCredentialStorage::~ActualCredentialStorage(ActualCredentialStorage *this)
{
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 24));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 16));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 16));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 8));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 8));
}

uint64_t non-virtual thunk to'ActualCredentialStorage::useSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result = *((void *)this + 13);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 88))();
  }
  return result;
}

uint64_t non-virtual thunk to'ActualCredentialStorage::setUseSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result = *((void *)this + 13);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 80))();
  }
  return result;
}

uint64_t non-virtual thunk to'ActualCredentialStorage::setDefaultCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  return ActualCredentialStorage::setDefaultCredentialForProtectionSpace((ActualCredentialStorage *)((char *)this - 8), a2, a3);
}

uint64_t ActualCredentialStorage::setDefaultCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t result = (*(uint64_t (**)(void, void))(**((void **)this + 13) + 64))(*((void *)this + 13), 0);
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    int v6 = *((_DWORD *)a2 + 13);
    if ((v6 - 3) < 2)
    {
      uint64_t v7 = *((void *)this + 14);
      if (v7)
      {
        int v8 = *(uint64_t (**)(void))(*(void *)v7 + 72);
        goto LABEL_10;
      }
LABEL_14:
      int v8 = *(uint64_t (**)(void))(**((void **)this + 13) + 64);
      return v8();
    }
    if (v6 != 1) {
      goto LABEL_14;
    }
    uint64_t result = *((void *)this + 14);
    if (result)
    {
      int v8 = *(uint64_t (**)(void))(*(void *)result + 72);
LABEL_10:
      return v8();
    }
  }
  return result;
}

uint64_t non-virtual thunk to'ActualCredentialStorage::copyDefaultCredentialForProtectionSpace(ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  return ActualCredentialStorage::copyDefaultCredentialForProtectionSpace((ActualCredentialStorage *)((char *)this - 8), a2);
}

uint64_t ActualCredentialStorage::copyDefaultCredentialForProtectionSpace(ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 13) + 56))(*((void *)this + 13));
  if (!result)
  {
    uint64_t result = *((void *)this + 14);
    if (result)
    {
      CFStringRef v4 = *(uint64_t (**)(void))(*(void *)result + 64);
      return v4();
    }
  }
  return result;
}

uint64_t non-virtual thunk to'ActualCredentialStorage::removeCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  return ActualCredentialStorage::removeCredentialForProtectionSpace((ActualCredentialStorage *)((char *)this - 8), a2, a3);
}

uint64_t ActualCredentialStorage::removeCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  (*(void (**)(void))(**((void **)this + 13) + 48))(*((void *)this + 13));
  uint64_t result = *((void *)this + 14);
  if (result)
  {
    CFStringRef v5 = *(uint64_t (**)(void))(*(void *)result + 56);
    return v5();
  }
  return result;
}

void non-virtual thunk to'ActualCredentialStorage::setCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

void ActualCredentialStorage::setCredentialForProtectionSpace(ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  int v6 = (void *)(*(uint64_t (**)(ActualCredentialStorage *, _CFURLProtectionSpace *))(*(void *)this + 112))(this, a3);
  (*(void (**)(ActualCredentialStorage *, const _CFURLCredential *, _CFURLProtectionSpace *))(*(void *)this + 104))(this, a2, a3);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if (a2) {
    uint64_t v7 = (char *)a2 + 16;
  }
  else {
    uint64_t v7 = 0;
  }
  int v8 = *((_DWORD *)v7 + 9);
  if ((v8 - 3) >= 2)
  {
    if (v8 == 1) {
      goto LABEL_11;
    }
LABEL_10:
    (*(void (**)(void, const _CFURLCredential *, _CFURLProtectionSpace *))(**((void **)this + 13) + 40))(*((void *)this + 13), a2, a3);
    goto LABEL_11;
  }
  uint64_t v9 = *((void *)this + 14);
  if (!v9) {
    goto LABEL_10;
  }
  (*(void (**)(uint64_t, const _CFURLCredential *, _CFURLProtectionSpace *))(*(void *)v9 + 48))(v9, a2, a3);
LABEL_11:
  if (!a2 || v6)
  {
    if (a2 && v6)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      CFIndex v11 = (const void *)v6[9];
      if (!v11)
      {
        CFIndex v11 = (const void *)(*(uint64_t (**)(void *))(v6[2] + 104))(v6 + 2);
        v6[9] = v11;
        if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
        }
      }
      CFIndex v12 = (const void *)*((void *)a2 + 9);
      if (!v12)
      {
        CFIndex v12 = (const void *)(*(uint64_t (**)(char *))(*((void *)a2 + 2) + 104))((char *)a2 + 16);
        *((void *)a2 + 9) = v12;
      }
      if (v12 && v11 && CFEqual(v12, v11)) {
        (*(void (**)(ActualCredentialStorage *, const _CFURLCredential *, _CFURLProtectionSpace *))(*(void *)this + 120))(this, a2, a3);
      }
    }
    else if (!v6)
    {
      return;
    }
    CFRelease(v6);
  }
  else
  {
    uint64_t v10 = *(void (**)(ActualCredentialStorage *, const _CFURLCredential *, _CFURLProtectionSpace *))(*(void *)this + 120);
    v10(this, a2, a3);
  }
}

const __CFDictionary *non-virtual thunk to'ActualCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(ActualCredentialStorage *this, const __CFString *a2, uint64_t a3)
{
  return ActualCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain((ActualCredentialStorage *)((char *)this - 8), a2, a3);
}

const __CFDictionary *ActualCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(ActualCredentialStorage *this, const __CFString *a2, uint64_t a3)
{
  CFDictionaryRef v6 = (const __CFDictionary *)(*(uint64_t (**)(void))(**((void **)this + 13) + 24))(*((void *)this + 13));
  uint64_t v7 = *((void *)this + 14);
  if (!v7) {
    return v6;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(void *)v7 + 40))(v7, a2, a3);
  CFDictionaryRef v9 = ActualCredentialStorage::mergeProtectionSpaceToNameToCredentialsDict(this, v6, v8);
  if (v8) {
    CFRelease(v8);
  }
  if (v6) {
    CFRelease(v6);
  }
  return v9;
}

const __CFDictionary *ActualCredentialStorage::mergeProtectionSpaceToNameToCredentialsDict(ActualCredentialStorage *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  CFDictionaryRef v4 = a2;
  CFContainerEnumeratorBase::setup((unint64_t)v17, a2, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictKeyData);
  CFContainerEnumeratorBase::setup((unint64_t)&v19, v4, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
  CFContainerEnumeratorBase::setup((unint64_t)v12, a3, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictKeyData);
  CFContainerEnumeratorBase::setup((unint64_t)&v14, a3, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
  if (!v20)
  {
    if (!a3)
    {
      CFDictionaryRef v4 = 0;
      goto LABEL_17;
    }
LABEL_14:
    CFDictionaryRef v4 = (const __CFDictionary *)CFRetain(a3);
    goto LABEL_17;
  }
  if (!v15)
  {
    a3 = v4;
    if (!v4) {
      goto LABEL_17;
    }
    goto LABEL_14;
  }
  CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
  theDict = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v20 >= 1)
  {
    for (uint64_t i = 0; i < v20; ++i)
      CFDictionarySetValue(theDict, *(const void **)(v18 + 8 * i), *(const void **)(v21 + 8 * i));
  }
  if (v15 >= 1)
  {
    for (uint64_t j = 0; j < v15; ++j)
      CFDictionarySetValue(theDict, *(const void **)(v13 + 8 * j), *(const void **)(v16 + 8 * j));
  }
  CFDictionaryRef v9 = theDict;
  if (theDict)
  {
    CFDictionaryRef v4 = (const __CFDictionary *)CFRetain(theDict);
    CFDictionaryRef v9 = theDict;
  }
  else
  {
    CFDictionaryRef v4 = 0;
  }
  CFRelease(v9);
LABEL_17:
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v14);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v12);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v19);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v17);
  return v4;
}

void sub_18419F698(_Unwind_Exception *a1, uint64_t a2, CFTypeRef cf, ...)
{
  va_start(va, cf);
  CFRelease(cf);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v4);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v3);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&STACK[0x230]);
  _Unwind_Resume(a1);
}

void RetainableTypedDict<_CFURLProtectionSpace *,__CFDictionary const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0290;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<_CFURLProtectionSpace *,__CFDictionary const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0290;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

const __CFDictionary *non-virtual thunk to'ActualCredentialStorage::copyAllCredentials(ActualCredentialStorage *this)
{
  return ActualCredentialStorage::copyAllCredentials((ActualCredentialStorage *)((char *)this - 8));
}

const __CFDictionary *ActualCredentialStorage::copyAllCredentials(ActualCredentialStorage *this)
{
  CFDictionaryRef v2 = (const __CFDictionary *)(*(uint64_t (**)(void))(**((void **)this + 13) + 24))(*((void *)this + 13));
  uint64_t v3 = *((void *)this + 14);
  if (!v3) {
    return v2;
  }
  CFDictionaryRef v4 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 32))(v3);
  CFDictionaryRef v5 = ActualCredentialStorage::mergeProtectionSpaceToNameToCredentialsDict(this, v2, v4);
  if (v4) {
    CFRelease(v4);
  }
  if (v2) {
    CFRelease(v2);
  }
  return v5;
}

CFTypeRef non-virtual thunk to'ActualCredentialStorage::copyCredentialsForProtectionSpace(ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  return ActualCredentialStorage::copyCredentialsForProtectionSpace((ActualCredentialStorage *)((char *)this - 8), a2);
}

CFTypeRef ActualCredentialStorage::copyCredentialsForProtectionSpace(ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  CFDictionaryRef v4 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 13) + 16))(*((void *)this + 13));
  uint64_t v5 = *((void *)this + 14);
  if (!v5) {
    return v4;
  }
  CFAllocatorRef v6 = (const void *)(*(uint64_t (**)(uint64_t, _CFURLProtectionSpace *))(*(void *)v5 + 24))(v5, a2);
  CFContainerEnumeratorBase::setup((unint64_t)v20, v4, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictKeyData);
  CFContainerEnumeratorBase::setup((unint64_t)&v22, v4, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
  CFContainerEnumeratorBase::setup((unint64_t)v15, v6, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictKeyData);
  CFContainerEnumeratorBase::setup((unint64_t)&v17, v6, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
  if (v23)
  {
    if (v18)
    {
      CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
      theDict = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v23 >= 1)
      {
        for (uint64_t i = 0; i < v23; ++i)
          CFDictionarySetValue(theDict, *(const void **)(v21 + 8 * i), *(const void **)(v24 + 8 * i));
      }
      if (v18 >= 1)
      {
        for (uint64_t j = 0; j < v18; ++j)
          CFDictionarySetValue(theDict, *(const void **)(v16 + 8 * j), *(const void **)(v19 + 8 * j));
      }
      uint64_t v10 = theDict;
      if (theDict)
      {
        CFTypeRef v11 = CFRetain(theDict);
        uint64_t v10 = theDict;
      }
      else
      {
        CFTypeRef v11 = 0;
      }
      CFRelease(v10);
      goto LABEL_19;
    }
    CFIndex v12 = v4;
    if (!v4) {
      goto LABEL_16;
    }
  }
  else
  {
    CFIndex v12 = v6;
    if (!v6)
    {
LABEL_16:
      CFTypeRef v11 = 0;
      goto LABEL_19;
    }
  }
  CFTypeRef v11 = CFRetain(v12);
LABEL_19:
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v17);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v15);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v22);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v20);
  if (v6) {
    CFRelease(v6);
  }
  if (v4) {
    CFRelease(v4);
  }
  return v11;
}

void sub_18419FB34(_Unwind_Exception *a1, uint64_t a2, CFTypeRef cf, ...)
{
  va_start(va, cf);
  CFRelease(cf);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v4);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v3);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&STACK[0x230]);
  _Unwind_Resume(a1);
}

void RetainableTypedDict<__CFString const*,_CFURLCredential const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA02D0;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<__CFString const*,_CFURLCredential const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA02D0;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

uint64_t ActualCredentialStorage::useSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result = *((void *)this + 14);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 88))();
  }
  return result;
}

uint64_t ActualCredentialStorage::setUseSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result = *((void *)this + 14);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 80))();
  }
  return result;
}

CFStringRef ActualCredentialStorage::copyDebugSummary(ActualCredentialStorage *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"shared credential storage %p, session %p, persistent %p", (char *)this - 16, *((void *)this + 13), *((void *)this + 14));
}

CFStringRef ActualCredentialStorage::copyDebugDesc(ActualCredentialStorage *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<ActualCredentialStorage@%p<%p> { session %p, persistent %p }", (char *)this - 16, this, *((void *)this + 13), *((void *)this + 14));
}

void non-virtual thunk to'MemoryCredentialStorage::~MemoryCredentialStorage(MemoryCredentialStorage *this)
{
  CFDictionaryRef v2 = (char *)this - 24;
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)((char *)this - 24));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  CFDictionaryRef v2 = (char *)this - 16;
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)((char *)this - 16));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)((char *)this - 16));
}

void RetainableTypedDict<_CFURLProtectionSpace *,__CFDictionary *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0250;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<_CFURLProtectionSpace *,__CFDictionary *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0250;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<_CFURLProtectionSpace *,__CFString const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0270;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<_CFURLProtectionSpace *,__CFString const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0270;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

uint64_t CredentialStorageBase::useSystemKeychain(CredentialStorageBase *this)
{
  return 0;
}

void non-virtual thunk to'MemoryCredentialStorage::setDefaultCredentialForProtectionSpace(CFMutableDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

void MemoryCredentialStorage::setDefaultCredentialForProtectionSpace(CFMutableDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *key)
{
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    CFAllocatorRef v6 = (const void *)*((void *)a2 + 9);
    if (v6
      || (CFAllocatorRef v6 = (const void *)(*(uint64_t (**)(char *))(*((void *)a2 + 2) + 104))((char *)a2 + 16),
          (*((void *)a2 + 9) = v6) != 0))
    {
      CFDictionarySetValue(this[7], key, v6);
    }
    CFAllocatorRef v7 = (void (*)(CFMutableDictionaryRef *, const _CFURLCredential *, _CFURLProtectionSpace *))*((void *)*this + 5);
    v7(this, a2, key);
  }
  else
  {
    CFDictionaryRef v8 = this[7];
    CFDictionaryRemoveValue(v8, key);
  }
}

CFTypeRef non-virtual thunk to'MemoryCredentialStorage::copyDefaultCredentialForProtectionSpace(CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  return MemoryCredentialStorage::copyDefaultCredentialForProtectionSpace(this - 2, a2);
}

CFTypeRef MemoryCredentialStorage::copyDefaultCredentialForProtectionSpace(CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  CFDictionaryRef Value = CFDictionaryGetValue(this[7], a2);
  if (!Value) {
    return 0;
  }
  uint64_t v5 = Value;
  CFDictionaryRef v6 = (const __CFDictionary *)CFDictionaryGetValue(this[5], a2);
  CFAllocatorRef v7 = CFDictionaryGetValue(v6, v5);
  if (!v7) {
    return 0;
  }

  return CFRetain(v7);
}

void non-virtual thunk to'MemoryCredentialStorage::removeCredentialForProtectionSpace(CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

void MemoryCredentialStorage::removeCredentialForProtectionSpace(CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *key)
{
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if (a2) {
    CFDictionaryRef v6 = (void *)((char *)a2 + 16);
  }
  else {
    CFDictionaryRef v6 = 0;
  }
  CFAllocatorRef v7 = (const void *)v6[7];
  if (v7 || (CFAllocatorRef v7 = (const void *)(*(uint64_t (**)(void *))(*v6 + 104))(v6), (v6[7] = v7) != 0))
  {
    CFDictionaryRef Value = (__CFDictionary *)CFDictionaryGetValue(this[5], key);
    if (Value)
    {
      CFDictionaryRef v9 = Value;
      CFDictionaryRemoveValue(Value, v7);
      if (!CFDictionaryGetCount(v9)) {
        CFDictionaryRemoveValue(this[5], key);
      }
    }
    uint64_t v10 = CFDictionaryGetValue(this[7], key);
    if (v10 && CFEqual(v10, v7))
    {
      CFTypeRef v11 = this[7];
      CFDictionaryRemoveValue(v11, key);
    }
  }
}

void non-virtual thunk to'MemoryCredentialStorage::setCredentialForProtectionSpace(CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

void MemoryCredentialStorage::setCredentialForProtectionSpace(CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *key)
{
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if (a2) {
    CFDictionaryRef v6 = (void *)((char *)a2 + 16);
  }
  else {
    CFDictionaryRef v6 = 0;
  }
  CFAllocatorRef v7 = (const void *)v6[7];
  if (v7 || (CFAllocatorRef v7 = (const void *)(*(uint64_t (**)(void *))(*v6 + 104))(v6), (v6[7] = v7) != 0))
  {
    CFDictionaryRef Value = (void *)CFDictionaryGetValue(this[5], key);
    if (!Value)
    {
      CFDictionaryRef Value = CFDictionaryCreateMutable(this[1], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionarySetValue(this[5], key, Value);
      if (Value) {
        CFRelease(Value);
      }
    }
    CFDictionarySetValue((CFMutableDictionaryRef)Value, v7, a2);
  }
}

uint64_t non-virtual thunk to'MemoryCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(MemoryCredentialStorage *this, const __CFString *a2)
{
  return (*(uint64_t (**)(void))(*((void *)this - 2) + 24))();
}

CFDictionaryRef non-virtual thunk to'MemoryCredentialStorage::copyAllCredentials(CFAllocatorRef *this)
{
  return CFDictionaryCreateCopy(*(this - 1), this[3]);
}

CFDictionaryRef non-virtual thunk to'MemoryCredentialStorage::copyCredentialsForProtectionSpace(CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  return MemoryCredentialStorage::copyCredentialsForProtectionSpace(this - 2, a2);
}

CFDictionaryRef MemoryCredentialStorage::copyCredentialsForProtectionSpace(CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  CFDictionaryRef result = (CFDictionaryRef)CFDictionaryGetValue(this[5], a2);
  if (result)
  {
    CFDictionaryRef v4 = result;
    CFAllocatorRef v5 = this[1];
    return CFDictionaryCreateCopy(v5, v4);
  }
  return result;
}

uint64_t MemoryCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(MemoryCredentialStorage *this, const __CFString *a2)
{
  return (*(uint64_t (**)(void))(*(void *)this + 24))();
}

CFDictionaryRef MemoryCredentialStorage::copyAllCredentials(CFAllocatorRef *this)
{
  return CFDictionaryCreateCopy(this[1], this[5]);
}

void sub_1841A0704(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'PersistentCredentialStorage::~PersistentCredentialStorage(PersistentCredentialStorage *this)
{
  CFDictionaryRef v2 = (char *)this - 24;
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)((char *)this - 24));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  CFDictionaryRef v2 = (char *)this - 16;
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)((char *)this - 16));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)((char *)this - 16));
}

void PersistentCredentialStorage::~PersistentCredentialStorage(PersistentCredentialStorage *this)
{
  *(void *)this = &unk_1ECFA3B98;
  *((void *)this + 2) = &unk_1ECFA3C08;
  *((void *)this + 3) = &unk_1ECFA3C70;
  CFDictionaryRef v2 = (const void *)*((void *)this + 4);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  PersistentCredentialStorage::~PersistentCredentialStorage(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1841A0A68(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'PersistentCredentialStorage::useSystemKeychain(PersistentCredentialStorage *this)
{
  return *((unsigned __int8 *)this + 24);
}

uint64_t non-virtual thunk to'PersistentCredentialStorage::setUseSystemKeychain(uint64_t this, char a2)
{
  *(unsigned char *)(this + 24) = a2;
  return this;
}

void non-virtual thunk to'PersistentCredentialStorage::setDefaultCredentialForProtectionSpace(PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

void PersistentCredentialStorage::setDefaultCredentialForProtectionSpace(PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    if (*((_DWORD *)a2 + 13) != 3
      && *((_DWORD *)a2 + 13) != 4
      && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v18[0]) = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "ephemeral credential in persistent store", (uint8_t *)v18, 2u);
    }
  }
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  CFDictionaryRef v6 = (const URLProtectionSpace *)((char *)a3 + 16);
  if (*((_DWORD *)a3 + 18) == 7)
  {
    if (a2)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      if (*((_DWORD *)a2 + 12) == 3) {
        PersistentCredentialStorage::setIdentityCredentialForProtectionSpace(*((PersistentCredentialStorage **)this + 1), (const URLCredentialClientCertificate *)((char *)a2 + 16), (const URLProtectionSpace *)((char *)a3 + 16));
      }
    }
    else
    {
      PersistentCredentialStorage::removeIdentityPreferenceForProtectionSpace(*((PersistentCredentialStorage **)this + 1), (const URLProtectionSpace *)((char *)a3 + 16));
    }
    return;
  }
  uint64_t v7 = (*(uint64_t (**)(PersistentCredentialStorage *, _CFURLProtectionSpace *))(*(void *)this + 64))(this, a3);
  if (!v7)
  {
    int v12 = 1;
    if (!a2) {
      return;
    }
    goto LABEL_38;
  }
  uint64_t v9 = v7;
  uint64_t v10 = URLCredential_PasswordBased::safelyCast(v7, v8);
  if (v10)
  {
    CFTypeRef v11 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 128))(v10);
    if (v11) {
      CFRelease(v11);
    }
  }
  if (a2 && CFEqual((CFTypeRef)v9, a2))
  {
    int v12 = 0;
    goto LABEL_34;
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  QueryFromProtectionSpaceAndCred = createQueryFromProtectionSpaceAndCred(*((const __CFAllocator **)this + 1), v6, (const URLCredential *)(v9 + 16), *((unsigned __int8 *)this + 40), *((const __CFString **)this + 4));
  AttrsFromProtectionSpaceAndCred = createAttrsFromProtectionSpaceAndCred(*((const __CFAllocator **)this + 1), v6, (const URLCredential *)(v9 + 16), 0);
  int v15 = off_1EC09E208(QueryFromProtectionSpaceAndCred, AttrsFromProtectionSpaceAndCred);
  if (v15)
  {
    int v16 = v15;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v17 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v18[0] = 67109634;
      v18[1] = v16;
      __int16 v19 = 2112;
      uint64_t v20 = QueryFromProtectionSpaceAndCred;
      __int16 v21 = 2112;
      uint64_t v22 = AttrsFromProtectionSpaceAndCred;
      _os_log_debug_impl(&dword_184085000, v17, OS_LOG_TYPE_DEBUG, "CredStore - setDefaultCredForProtSpace - Error removing cred.  Error=%d, query=%@, attrs=%@", (uint8_t *)v18, 0x1Cu);
      if (!QueryFromProtectionSpaceAndCred) {
        goto LABEL_31;
      }
      goto LABEL_30;
    }
  }
  if (QueryFromProtectionSpaceAndCred) {
LABEL_30:
  }
    CFRelease(QueryFromProtectionSpaceAndCred);
LABEL_31:
  if (AttrsFromProtectionSpaceAndCred) {
    CFRelease(AttrsFromProtectionSpaceAndCred);
  }
  int v12 = 1;
LABEL_34:
  CFRelease((CFTypeRef)v9);
  if (!a2) {
    return;
  }
LABEL_38:
  if (v12)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    PersistentCredentialStorage::updateOrAddCredential(this, (const URLCredential *)((char *)a2 + 16), v6, 1);
  }
}

void PersistentCredentialStorage::removeIdentityPreferenceForProtectionSpace(PersistentCredentialStorage *this, const URLProtectionSpace *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(this, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v4 = URLProtectionSpace::copyNameForIdentityPreference(a2);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B788], v4);
  CFRelease(v4);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B978], (const void *)*MEMORY[0x1E4F3B990]);
  int v5 = off_1EC09E210(Mutable);
  if (v5)
  {
    int v6 = v5;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v8[0] = 67109378;
      v8[1] = v6;
      __int16 v9 = 2112;
      uint64_t v10 = Mutable;
      _os_log_debug_impl(&dword_184085000, v7, OS_LOG_TYPE_DEBUG, "CredStore - removeIdentityPref - Error removing Identity prefs.  Error=%d, query=%@", (uint8_t *)v8, 0x12u);
    }
  }
  CFRelease(Mutable);
}

void PersistentCredentialStorage::setIdentityCredentialForProtectionSpace(PersistentCredentialStorage *this, const URLCredentialClientCertificate *a2, const URLProtectionSpace *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(this, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v6 = URLProtectionSpace::copyNameForIdentityPreference(a3);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B788], v6);
  CFRelease(v6);
  uint64_t v7 = (const void *)*MEMORY[0x1E4F3BD48];
  CFDictionaryRef v8 = (const void *)(*(uint64_t (**)(const URLCredentialClientCertificate *))(*(void *)a2 + 120))(a2);
  CFDictionarySetValue(Mutable, v7, v8);
  int v9 = off_1EC09E200(Mutable, 0);
  if (v9)
  {
    int v10 = v9;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v11 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v12[0] = 67109378;
      v12[1] = v10;
      __int16 v13 = 2112;
      uint64_t v14 = Mutable;
      _os_log_debug_impl(&dword_184085000, v11, OS_LOG_TYPE_DEBUG, "CredStore - setIdentityCred - Error adding cred.  Error=%d, attrs=%@", (uint8_t *)v12, 0x12u);
    }
  }
  CFRelease(Mutable);
}

__CFDictionary *createQueryFromProtectionSpaceAndCred(const __CFAllocator *a1, const URLProtectionSpace *a2, const URLCredential *a3, int a4, const __CFString *a5)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v11 = (const void *)*MEMORY[0x1E4F3B7C0];
  AutoScalar::AutoScalar((AutoScalar *)&v25, (const __CFAllocator *)*((unsigned int *)a2 + 10));
  CFDictionarySetValue(Mutable, v11, value);
  CFIndex v25 = &unk_1ECF9A500;
  if (value) {
    CFRelease(value);
  }
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B978], (const void *)*MEMORY[0x1E4F3B998]);
  int v12 = (const void *)*((void *)a2 + 4);
  if (a5)
  {
    CFStringRef v13 = CFStringCreateWithFormat(a1, 0, @"%@ (%@)", *((void *)a2 + 4), a5, v25);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B848], v13);
    CFRelease(v13);
  }
  else
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (v12 && CFGetTypeID(v12) == TypeID) {
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B848], v12);
    }
  }
  SecAttrProtocol = (const void *)URLProtectionSpace::getSecAttrProtocol((URLProtectionSpace *)*((unsigned int *)a2 + 11));
  CFTypeID v15 = CFStringGetTypeID();
  if (SecAttrProtocol && CFGetTypeID(SecAttrProtocol) == v15) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B7C8], SecAttrProtocol);
  }
  if (*((_DWORD *)a3 + 9) == 4) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B878], (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  if ((*((_DWORD *)a2 + 11) - 9) <= 0xFFFFFFFB)
  {
    int v16 = (const void *)*((void *)a2 + 6);
    CFTypeID v17 = CFStringGetTypeID();
    if (v16 && CFGetTypeID(v16) == v17) {
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B838], v16);
    }
    uint64_t v18 = (const void *)*((void *)a3 + 7);
    if (v18)
    {
      CFTypeID v19 = CFStringGetTypeID();
    }
    else
    {
      uint64_t v18 = (const void *)(*(uint64_t (**)(const URLCredential *))(*(void *)a3 + 104))(a3);
      *((void *)a3 + 7) = v18;
      CFTypeID v19 = CFStringGetTypeID();
      if (!v18) {
        goto LABEL_22;
      }
    }
    if (CFGetTypeID(v18) == v19) {
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B5C0], v18);
    }
  }
LABEL_22:
  int v21 = *((_DWORD *)a2 + 14);
  if (v21 == 4)
  {
    uint64_t v23 = (const void **)MEMORY[0x1E4F3B5F8];
  }
  else if (v21 == 2 && (unsigned int v22 = *((_DWORD *)a2 + 11) - 1, v22 < 6))
  {
    uint64_t v23 = (const void **)qword_1E5252DF0[v22];
  }
  else
  {
    uint64_t v23 = (const void **)MEMORY[0x1E4F3B5F0];
  }
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B5E8], *v23);
  if (a4) {
    setUseSystemKeychain(Mutable);
  }
  return Mutable;
}

void sub_1841A142C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

__CFDictionary *createAttrsFromProtectionSpaceAndCred(const __CFAllocator *a1, const URLProtectionSpace *a2, const URLCredential *a3, int a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (a4) {
    int v9 = @"default";
  }
  else {
    int v9 = &stru_1ECFAD558;
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (CFGetTypeID(v9) == TypeID) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B660], v9);
  }
  uint64_t v11 = (const void *)*((void *)a3 + 7);
  if (v11)
  {
    CFTypeID v12 = CFStringGetTypeID();
  }
  else
  {
    uint64_t v11 = (const void *)(*(uint64_t (**)(const URLCredential *))(*(void *)a3 + 104))(a3);
    *((void *)a3 + 7) = v11;
    CFTypeID v12 = CFStringGetTypeID();
    if (!v11) {
      goto LABEL_11;
    }
  }
  if (CFGetTypeID(v11) == v12) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B5C0], v11);
  }
LABEL_11:
  uint64_t v14 = URLCredential_PasswordBased::safelyCast((uint64_t)a3 - 16, v13);
  if (v14)
  {
    CFStringRef v15 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v14 + 128))(v14);
    if (v15)
    {
      CFStringRef v16 = v15;
      CFIndex v29 = 1023;
      ptr = _CFStringGetOrCreateCString(a1, v15, v31, &v29, 0x8000100u);
      CFDataRef v17 = CFDataCreate(a1, (const UInt8 *)ptr, v29);
      if (v17)
      {
        CFTypeID v18 = CFDataGetTypeID();
        if (CFGetTypeID(v17) == v18) {
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3BD38], v17);
        }
        CFRelease(v17);
      }
      CFRelease(v16);
      if (ptr && v31 != ptr) {
        CFAllocatorDeallocate(a1, ptr);
      }
    }
  }
  CFTypeID v19 = (const void *)*((void *)a2 + 4);
  CFStringRef v20 = (const __CFString *)*((void *)a3 + 7);
  if ((v20
     || (CFStringRef v20 = (const __CFString *)(*(uint64_t (**)(const URLCredential *))(*(void *)a3 + 104))(a3),
         (*((void *)a3 + 7) = v20) != 0))
    && CFStringGetLength(v20))
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_5505);
    }
    CFStringRef v21 = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, @"KEYCHAIN_LABEL_FORMAT%@%@", @"%@ (%@)", 0);
    CFStringRef v22 = CFStringCreateWithFormat(a1, 0, v21, v19, v20);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B788], v22);
    if (v21) {
      CFRelease(v21);
    }
    CFRelease(v22);
  }
  else
  {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B788], v19);
  }
  if (*((_DWORD *)a2 + 14) == 4)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_5505);
    }
    CFStringRef v23 = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, @"KEYCHAIN_WEB_FORM_PASSWORD", @"Web form password", 0);
    CFTypeID v24 = CFStringGetTypeID();
    if (v23)
    {
      if (CFGetTypeID(v23) == v24) {
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B678], v23);
      }
      CFRelease(v23);
    }
  }
  if (*((_DWORD *)a3 + 9) == 4) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B878], (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  if (!*((_DWORD *)a3 + 8))
  {
    CFDictionaryRef v26 = (const __CFDictionary *)*((void *)a3 + 10);
    if (v26)
    {
      uint64_t v27 = (const void *)*MEMORY[0x1E4F3B670];
      if (CFDictionaryGetValue(v26, (const void *)*MEMORY[0x1E4F3B670]))
      {
        CFDictionaryRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)a3 + 10), v27);
        CFDictionarySetValue(Mutable, v27, Value);
      }
    }
  }
  return Mutable;
}

void sub_1841A1890(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  if (ptr)
  {
    if (v13 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  _Unwind_Resume(exception_object);
}

void PersistentCredentialStorage::updateOrAddCredential(PersistentCredentialStorage *this, const URLCredential *a2, const URLProtectionSpace *a3, int a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  QueryFromProtectionSpaceAndCred = createQueryFromProtectionSpaceAndCred(*((const __CFAllocator **)this + 1), a3, a2, *((unsigned __int8 *)this + 40), *((const __CFString **)this + 4));
  AttrsFromProtectionSpaceAndCred = createAttrsFromProtectionSpaceAndCred(*((const __CFAllocator **)this + 1), a3, a2, a4);
  int v10 = off_1EC09E208(QueryFromProtectionSpaceAndCred, AttrsFromProtectionSpaceAndCred);
  if (!v10) {
    goto LABEL_12;
  }
  int v11 = v10;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFTypeID v12 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    int v17 = 67109634;
    int v18 = v11;
    __int16 v19 = 2112;
    CFStringRef v20 = QueryFromProtectionSpaceAndCred;
    __int16 v21 = 2112;
    CFStringRef v22 = AttrsFromProtectionSpaceAndCred;
    _os_log_debug_impl(&dword_184085000, v12, OS_LOG_TYPE_DEBUG, "CredStore - updateOrAddCredential - Error update cred.  Error=%d, query=%@, attrs=%@", (uint8_t *)&v17, 0x1Cu);
  }
  updateAttrsWithValuesForModifyingStore(AttrsFromProtectionSpaceAndCred, a3, 0, *((void *)this + 4), v13);
  if (*((unsigned char *)this + 40)) {
    setUseSystemKeychain(AttrsFromProtectionSpaceAndCred);
  }
  int v14 = off_1EC09E200(AttrsFromProtectionSpaceAndCred, 0);
  if (!v14) {
    goto LABEL_12;
  }
  int v15 = v14;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFStringRef v16 = CFNLog::logger;
  if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
LABEL_12:
    if (!QueryFromProtectionSpaceAndCred) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  int v17 = 67109378;
  int v18 = v15;
  __int16 v19 = 2112;
  CFStringRef v20 = AttrsFromProtectionSpaceAndCred;
  _os_log_debug_impl(&dword_184085000, v16, OS_LOG_TYPE_DEBUG, "CredStore - updateOrAddCredential - Error add cred.  Error=%d, attrs=%@", (uint8_t *)&v17, 0x12u);
  if (QueryFromProtectionSpaceAndCred) {
LABEL_13:
  }
    CFRelease(QueryFromProtectionSpaceAndCred);
LABEL_14:
  if (AttrsFromProtectionSpaceAndCred) {
    CFRelease(AttrsFromProtectionSpaceAndCred);
  }
}

void updateAttrsWithValuesForModifyingStore(__CFDictionary *a1, const URLProtectionSpace *a2, const URLCredential *a3, uint64_t a4, const __CFString *a5)
{
  char v6 = (char)a3;
  CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E4F3B978], (const void *)*MEMORY[0x1E4F3B998]);
  int v9 = (const void *)*((void *)a2 + 4);
  if (a4)
  {
    CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ (%@)", *((void *)a2 + 4), a4);
    CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E4F3B848], v10);
    CFRelease(v10);
  }
  else
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (v9 && CFGetTypeID(v9) == TypeID) {
      CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E4F3B848], v9);
    }
  }
  int v11 = (const void *)*MEMORY[0x1E4F3B7C0];
  AutoScalar::AutoScalar((AutoScalar *)&v24, (const __CFAllocator *)*((unsigned int *)a2 + 10));
  CFDictionarySetValue(a1, v11, value);
  CFTypeID v24 = &unk_1ECF9A500;
  if (value) {
    CFRelease(value);
  }
  int v12 = *((_DWORD *)a2 + 14);
  if (v12 != 2)
  {
    if (v12 == 4)
    {
      CFStringRef v13 = (const void *)*MEMORY[0x1E4F3B5E8];
      int v14 = (const void *)*MEMORY[0x1E4F3B5F8];
      int v15 = a1;
LABEL_17:
      CFDictionarySetValue(v15, v13, v14);
      goto LABEL_18;
    }
    goto LABEL_13;
  }
  unsigned int v17 = *((_DWORD *)a2 + 11) - 1;
  if (v17 > 5)
  {
LABEL_13:
    int v18 = (const void **)MEMORY[0x1E4F3B5F0];
    goto LABEL_14;
  }
  int v18 = (const void **)qword_1E5252DF0[v17];
LABEL_14:
  CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E4F3B5E8], *v18);
  __int16 v19 = (const void *)*((void *)a2 + 6);
  CFTypeID v20 = CFStringGetTypeID();
  if (v19 && CFGetTypeID(v19) == v20)
  {
    CFStringRef v13 = (const void *)*MEMORY[0x1E4F3B838];
    int v15 = a1;
    int v14 = v19;
    goto LABEL_17;
  }
LABEL_18:
  SecAttrProtocol = (const void *)URLProtectionSpace::getSecAttrProtocol((URLProtectionSpace *)*((unsigned int *)a2 + 11));
  CFTypeID v22 = CFStringGetTypeID();
  if (SecAttrProtocol && CFGetTypeID(SecAttrProtocol) == v22) {
    CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E4F3B7C8], SecAttrProtocol);
  }
  if ((v6 & 1) == 0)
  {
    CFTypeID v23 = CFStringGetTypeID();
    if (CFGetTypeID(&stru_1ECFAD558) == v23) {
      CFDictionarySetValue(a1, (const void *)*MEMORY[0x1E4F3B7B8], &stru_1ECFAD558);
    }
  }
  CFDictionaryRemoveValue(a1, (const void *)*MEMORY[0x1E4F3B670]);
}

void sub_1841A1D5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void setUseSystemKeychain(CFMutableDictionaryRef theDict)
{
  if (URLCredentialStorageUtilities::isSystemKeychainSupported(void)::onceToken != -1) {
    dispatch_once(&URLCredentialStorageUtilities::isSystemKeychainSupported(void)::onceToken, &__block_literal_global_1271);
  }
  if (URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser)
  {
    CFDictionaryRef v2 = (const void *)*MEMORY[0x1E4F3BD20];
    CFAllocatorRef v3 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionarySetValue(theDict, v2, v3);
  }
}

CFTypeRef non-virtual thunk to'PersistentCredentialStorage::copyDefaultCredentialForProtectionSpace(PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  return PersistentCredentialStorage::copyDefaultCredentialForProtectionSpace((PersistentCredentialStorage *)((char *)this - 16), a2);
}

CFTypeRef PersistentCredentialStorage::copyDefaultCredentialForProtectionSpace(PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  CFDictionaryRef v2 = a2;
  if (a2)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
    }
    CFDictionaryRef v2 = (_CFURLProtectionSpace *)((char *)v2 + 16);
  }
  if (*((_DWORD *)v2 + 14) != 7)
  {
    StorageQuery::StorageQuery((StorageQuery *)v10, *((const __CFAllocator **)this + 1), (const URLProtectionSpace *)v2, *((unsigned char *)this + 40), *((const __CFString **)this + 4));
    if (StorageQuery::performQuery((StorageQuery *)v10))
    {
      CFDictionaryRef Value = CFDictionaryGetValue(v10[3], (char *)v2 - 16);
      if (Value)
      {
        CFDictionaryRef v7 = (const __CFDictionary *)StorageQuery::copyNameAndCredsDictForProtectionSpace(v10, (const URLProtectionSpace *)v2);
        CFTypeRef v8 = v7;
        if (!v7)
        {
LABEL_15:
          StorageQuery::~StorageQuery((StorageQuery *)v10);
          return v8;
        }
        int v9 = CFDictionaryGetValue(v7, Value);
        CFRelease(v8);
        if (v9)
        {
          CFTypeRef v8 = CFRetain(v9);
          goto LABEL_15;
        }
      }
    }
    CFTypeRef v8 = 0;
    goto LABEL_15;
  }
  CFStringRef v4 = (PersistentCredentialStorage *)*((void *)this + 1);

  return PersistentCredentialStorage::copyIdentityCredentialForProtectionSpace(v4, (const URLProtectionSpace *)v2);
}

void sub_1841A1F3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  StorageQuery::~StorageQuery((StorageQuery *)va);
  _Unwind_Resume(a1);
}

const void *PersistentCredentialStorage::copyIdentityCredentialForProtectionSpace(PersistentCredentialStorage *this, const URLProtectionSpace *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(this, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v4 = URLProtectionSpace::copyNameForIdentityPreference(a2);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B788], v4);
  CFRelease(v4);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3BC80], (const void *)*MEMORY[0x1E4F1CFD0]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F3B978], (const void *)*MEMORY[0x1E4F3B990]);
  CFTypeRef cf = 0;
  int v5 = (*((uint64_t (**)(__CFDictionary *, CFTypeRef *))&_gFwStubs + 1))(Mutable, &cf);
  if (v5)
  {
    int v6 = v5;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFDictionaryRef v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 67109378;
      int v13 = v6;
      __int16 v14 = 2112;
      int v15 = Mutable;
      _os_log_debug_impl(&dword_184085000, v7, OS_LOG_TYPE_DEBUG, "CredStore - copyIdentPrefs - Error copying Identity cred.  Error=%d, query=%@", buf, 0x12u);
    }
    goto LABEL_6;
  }
  if (!cf)
  {
LABEL_6:
    CFTypeRef v8 = 0;
    goto LABEL_7;
  }
  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != SecIdentityGetTypeID())
  {
    if (cf) {
      CFRelease(cf);
    }
    goto LABEL_6;
  }
  CFTypeRef v8 = CFURLCredentialCreateWithIdentityAndCertificateArray(*MEMORY[0x1E4F1CF80], cf, 0, 3);
  if (cf) {
    CFRelease(cf);
  }
LABEL_7:
  CFRelease(Mutable);
  return v8;
}

void StorageQuery::StorageQuery(StorageQuery *this, const __CFAllocator *a2, const URLProtectionSpace *a3, char a4, const __CFString *a5)
{
  *(void *)this = &unk_1ECF9C2B0;
  *((unsigned char *)this + 49) = a4;
  *((unsigned char *)this + 5dispatch_get_global_queue(0, 0) = 0;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = cfTypeCreateMutableDictionary(a2, *MEMORY[0x1E4F3BB80], *MEMORY[0x1E4F3BB88], 0, 0);
  *((void *)this + 2) = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((void *)this + 4) = a2;
  *((void *)this + 5) = a5;
  *((void *)this + 3) = Mutable;
  *((unsigned char *)this + 48) = 0;
  if (!a3) {
    goto LABEL_17;
  }
  CFTypeID v10 = (const void *)*((void *)a3 + 4);
  if (a5)
  {
    CFStringRef v11 = CFStringCreateWithFormat(a2, 0, @"%@ (%@)", *((void *)a3 + 4), a5);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E4F3B848], v11);
    CFRelease(v11);
  }
  else if (v10)
  {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E4F3B848], v10);
  }
  SecAttrProtocol = (const void *)URLProtectionSpace::getSecAttrProtocol((URLProtectionSpace *)*((unsigned int *)a3 + 11));
  if (SecAttrProtocol) {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E4F3B7C8], SecAttrProtocol);
  }
  int v13 = (const void *)*((void *)a3 + 6);
  if (v13) {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E4F3B838], v13);
  }
  int v14 = *((_DWORD *)a3 + 14);
  if (v14 == 2)
  {
    unsigned int v17 = *((_DWORD *)a3 + 11);
    if (v17 <= 6 && ((1 << v17) & 0x62) != 0) {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E4F3B5E8], (const void *)*MEMORY[0x1E4F3B600]);
    }
    goto LABEL_17;
  }
  if (v14 != 8)
  {
    if (v14 == 7)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E4F3B978], (const void *)*MEMORY[0x1E4F3B990]);
      int v15 = (const void **)MEMORY[0x1E4F1CFD0];
      uint64_t v16 = (const void **)MEMORY[0x1E4F3BC80];
LABEL_18:
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), *v16, *v15);
      goto LABEL_19;
    }
LABEL_17:
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E4F3BC68], (const void *)*MEMORY[0x1E4F1CFD0]);
    int v15 = (const void **)MEMORY[0x1E4F3B998];
    uint64_t v16 = (const void **)MEMORY[0x1E4F3B978];
    goto LABEL_18;
  }
  *((unsigned char *)this + 48) = 1;
LABEL_19:
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x1E4F3B878], (const void *)*MEMORY[0x1E4F3B880]);
  if (*((unsigned char *)this + 49)) {
    setUseSystemKeychain(*((CFMutableDictionaryRef *)this + 1));
  }
}

void sub_1841A23CC(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t StorageQuery::performQuery(StorageQuery *this)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  int v1 = (*((uint64_t (**)(void, CFTypeRef *))&_gFwStubs + 1))(*((void *)this + 1), &cf);
  if (*((unsigned char *)this + 48)) {
    BOOL v2 = 0;
  }
  else {
    BOOL v2 = v1 == 0;
  }
  if (!v2 || cf == 0)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFStringRef v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v51 = *((void *)this + 1);
      *(_DWORD *)int buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v1;
      *(_WORD *)CFDateRef v83 = 2112;
      *(void *)&v83[2] = v51;
      _os_log_debug_impl(&dword_184085000, v4, OS_LOG_TYPE_DEBUG, "CredStore - performQuery - Error copying matching creds.  Error=%d, query=%@", buf, 0x12u);
    }
    uint64_t result = (uint64_t)cf;
    if (cf)
    {
      CFRelease(cf);
      return 0;
    }
  }
  else
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    CFIndex v74 = Count;
    if (Count >= 1)
    {
      CFIndex v7 = 0;
      key = (void *)*MEMORY[0x1E4F3B848];
      uint64_t v73 = *MEMORY[0x1E4F3B7C0];
      uint64_t v72 = *MEMORY[0x1E4F3B7C8];
      uint64_t v71 = *MEMORY[0x1E4F3B5E8];
      uint64_t v70 = *MEMORY[0x1E4F3B838];
      uint64_t v69 = *MEMORY[0x1E4F3B660];
      CFTypeRef cf2 = (CFTypeRef)*MEMORY[0x1E4F3B7E8];
      CFTypeRef v64 = (CFTypeRef)*MEMORY[0x1E4F3B7F8];
      CFTypeRef v60 = (CFTypeRef)*MEMORY[0x1E4F3B7D0];
      CFTypeRef v58 = (CFTypeRef)*MEMORY[0x1E4F3B7E0];
      CFTypeRef v56 = (CFTypeRef)*MEMORY[0x1E4F3B7F0];
      CFTypeRef v54 = (CFTypeRef)*MEMORY[0x1E4F3B800];
      CFTypeRef v53 = (CFTypeRef)*MEMORY[0x1E4F3B7D8];
      CFTypeRef v52 = (CFTypeRef)*MEMORY[0x1E4F3B818];
      CFTypeRef v65 = (CFTypeRef)*MEMORY[0x1E4F3B5F0];
      CFTypeRef v62 = (CFTypeRef)*MEMORY[0x1E4F3B600];
      CFTypeRef v59 = (CFTypeRef)*MEMORY[0x1E4F3B608];
      CFTypeRef v57 = (CFTypeRef)*MEMORY[0x1E4F3B5F8];
      CFTypeRef v55 = (CFTypeRef)*MEMORY[0x1E4F3B610];
      CFAbsoluteTime v67 = (void *)*MEMORY[0x1E4F3B5C0];
      unint64_t v63 = (void *)*MEMORY[0x1E4F3BD38];
      int64_t v61 = (void *)*MEMORY[0x1E4F3B878];
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)cf, v7);
        if (ValueAtIndex)
        {
          MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(0, 0, ValueAtIndex);
          CFDictionaryRef v10 = MutableCopy;
          if (MutableCopy)
          {
            CFStringRef Value = (const __CFString *)CFDictionaryGetValue(MutableCopy, key);
            CFStringRef v12 = Value;
            if (Value && (CFTypeID v13 = CFGetTypeID(Value), v13 == CFStringGetTypeID()))
            {
              CFIndex location = CFStringFind(v12, @" ", 0).location;
              CFIndex v15 = location;
              if (*((void *)this + 5))
              {
                if (location == -1) {
                  goto LABEL_117;
                }
                uint64_t v16 = CFStringGetLength(v12) - location;
                if (v16 < 4) {
                  goto LABEL_117;
                }
                v100.CFIndex length = v16 - 3;
                v100.CFIndex location = v15 + 2;
                CFStringRef v17 = CFStringCreateWithSubstring(*((CFAllocatorRef *)this + 4), v12, v100);
                if (!v17) {
                  goto LABEL_117;
                }
                if (CFStringCompare(*((CFStringRef *)this + 5), v17, 0))
                {
                  CFRelease(v17);
LABEL_117:
                  CFRelease(v10);
                  goto LABEL_118;
                }
                v101.CFIndex location = 0;
                v101.CFIndex length = v15;
                CFStringRef v25 = CFStringCreateWithSubstring(*((CFAllocatorRef *)this + 4), v12, v101);
                CFDictionarySetValue(v10, key, v25);
                if (v25) {
                  CFRelease(v25);
                }
                CFRelease(v17);
              }
              else if (location != -1)
              {
                goto LABEL_117;
              }
            }
            else if (*((void *)this + 5))
            {
              goto LABEL_117;
            }
          }
        }
        else
        {
          CFDictionaryRef v10 = 0;
        }
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
        }
        uint64_t Instance = _CFRuntimeCreateInstance();
        *(_OWORD *)(Instance + 16) = 0u;
        *(_OWORD *)(Instance + 8dispatch_get_global_queue(0, 0) = 0u;
        *(_OWORD *)(Instance + 96) = 0u;
        *(void *)(Instance + 112) = 0;
        *(_OWORD *)(Instance + 48) = 0u;
        *(_OWORD *)(Instance + 64) = 0u;
        *(_OWORD *)(Instance + 32) = 0u;
        *(void *)(Instance + 16) = &unk_1ECF9F738;
        *(void *)(Instance + 24) = &unk_1ECF9F790;
        *(void *)(Instance + 32) = &gConstantCFStringValueTable[3780];
        *(unsigned char *)(Instance + 96) = 0;
        *(unsigned char *)(Instance + 104) = 0;
        *(void *)(Instance + 112) = 1;
        char v19 = *((unsigned char *)this + 50);
        *(_OWORD *)CFTypeRef cf1 = 0u;
        *(_OWORD *)CFStringRef theString = 0u;
        *(_OWORD *)number = 0u;
        *(void *)int buf = key;
        *(void *)CFDateRef v83 = CFStringGetTypeID();
        v83[8] = 1;
        uint64_t v84 = v73;
        CFTypeID TypeID = CFNumberGetTypeID();
        char v86 = 1;
        uint64_t v87 = v72;
        CFTypeID v88 = CFStringGetTypeID();
        char v89 = 1;
        uint64_t v90 = v71;
        CFTypeID v91 = CFStringGetTypeID();
        char v92 = 0;
        uint64_t v93 = v70;
        CFTypeID v94 = CFStringGetTypeID();
        char v95 = 0;
        uint64_t v96 = v69;
        uint64_t v20 = 0;
        CFTypeID v97 = CFStringGetTypeID();
        char v98 = 0;
        __int16 v21 = (const void **)&v83[8];
        do
        {
          CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(v10, *(v21 - 2));
          number[v20] = v22;
          if (v22)
          {
            if ((const void *)CFGetTypeID(v22) != *(v21 - 1))
            {
              if (*(unsigned char *)v21) {
                goto LABEL_116;
              }
              number[v20] = 0;
            }
          }
          else if (*(unsigned char *)v21)
          {
            goto LABEL_116;
          }
          v21 += 3;
          ++v20;
        }
        while (v20 != 6);
        CFTypeRef v23 = cf1[0];
        if (!cf1[0]) {
          goto LABEL_116;
        }
        if (CFEqual(cf1[0], cf2))
        {
          int v24 = 1;
        }
        else if (CFEqual(v23, v64))
        {
          int v24 = 2;
        }
        else if (CFEqual(v23, v60))
        {
          int v24 = 3;
        }
        else if (CFEqual(v23, v58))
        {
          int v24 = 4;
        }
        else if (CFEqual(v23, v56))
        {
          int v24 = 5;
        }
        else if (CFEqual(v23, v54))
        {
          int v24 = 6;
        }
        else if (CFEqual(v23, v53))
        {
          int v24 = 7;
        }
        else
        {
          if (!CFEqual(v23, v52)) {
            goto LABEL_116;
          }
          int v24 = 8;
        }
        CFTypeRef v26 = cf1[1];
        if (!cf1[1] || CFEqual(cf1[1], v65)) {
          break;
        }
        if (CFEqual(v26, v62))
        {
          int v27 = 2;
        }
        else if (CFEqual(v26, v59))
        {
          int v27 = 3;
        }
        else if (CFEqual(v26, v57))
        {
          int v27 = 4;
        }
        else
        {
          if (!CFEqual(v26, v55)) {
            break;
          }
          int v27 = 5;
        }
LABEL_63:
        CFStringRef v28 = theString[0];
        if (theString[0])
        {
          if (CFStringGetLength(theString[0])) {
            CFStringRef v29 = v28;
          }
          else {
            CFStringRef v29 = 0;
          }
        }
        else
        {
          CFStringRef v29 = 0;
        }
        uint64_t valuePtr = 0;
        CFNumberGetValue(number[1], kCFNumberCFIndexType, &valuePtr);
        int v30 = valuePtr;
        if (theString[1]) {
          BOOL v66 = CFEqual(theString[1], @"default") != 0;
        }
        else {
          BOOL v66 = 0;
        }
        *(unsigned char *)(Instance + 96) = v19;
        URLProtectionSpace::initialize(Instance + 16, (const __CFString *)number[0], v30, v24, v29, v27);
        uint64_t v31 = CFDictionaryGetValue(v10, v67);
        uint64_t v32 = v31;
        if (v31)
        {
          CFTypeID v33 = CFGetTypeID(v31);
          if (v33 == CFStringGetTypeID())
          {
            CFDataRef v34 = (const __CFData *)CFDictionaryGetValue(v10, v63);
            CFDataRef v35 = v34;
            if (v34)
            {
              CFTypeID v36 = CFGetTypeID(v34);
              if (v36 == CFDataGetTypeID())
              {
                CFAllocatorRef v37 = (const __CFAllocator *)*((void *)this + 4);
                CFDictionaryRef v39 = (const __CFDictionary *)CFPropertyListCreateWithData(v37, v35, 0, 0, 0);
                if (v39)
                {
                  unsigned __int8 v40 = URLCredential::createFromPropertyList(v37, v39, v38);
                  CFRelease(v39);
                  if (v40) {
                    goto LABEL_93;
                  }
                }
              }
            }
            if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
              dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
            }
            uint64_t v41 = _CFRuntimeCreateInstance();
            unsigned __int8 v40 = (URLCredentialInternetPassword *)v41;
            if (v41)
            {
              *(_OWORD *)(v41 + 16) = 0u;
              unsigned __int8 v40 = (URLCredentialInternetPassword *)(v41 + 16);
              *(void *)(v41 + 112) = 0;
              *(_OWORD *)(v41 + 8dispatch_get_global_queue(0, 0) = 0u;
              *(_OWORD *)(v41 + 96) = 0u;
              *(_OWORD *)(v41 + 48) = 0u;
              *(_OWORD *)(v41 + 64) = 0u;
              *(_OWORD *)(v41 + 32) = 0u;
            }
            URLCredentialInternetPassword::URLCredentialInternetPassword(v40);
            if (!v10 || (CFBooleanRef v42 = (const __CFBoolean *)CFDictionaryGetValue(v10, v61)) == 0)
            {
              BOOL v43 = 0;
              if (!v40) {
                goto LABEL_116;
              }
LABEL_89:
              if (v43) {
                uint64_t v44 = 4;
              }
              else {
                uint64_t v44 = 3;
              }
              if ((*(unsigned int (**)(URLCredentialInternetPassword *, const void *, void, uint64_t, const __CFDictionary *))(*(void *)v40 + 144))(v40, v32, 0, v44, v10))
              {
LABEL_93:
                if (*((unsigned char *)this + 49)) {
                  (*(void (**)(URLCredentialInternetPassword *, uint64_t))(*(void *)v40 + 80))(v40, 1);
                }
                if (*((void *)this + 5)) {
                  (*(void (**)(URLCredentialInternetPassword *))(*(void *)v40 + 88))(v40);
                }
                long long v45 = (__CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 2), (const void *)Instance);
                if (v45)
                {
                  long long v46 = (const void *)*((void *)v40 + 7);
                  if (!v46)
                  {
                    long long v46 = (const void *)(*(uint64_t (**)(URLCredentialInternetPassword *))(*(void *)v40 + 104))(v40);
                    *((void *)v40 + 7) = v46;
                  }
                  if (!CFDictionaryContainsKey(v45, v46))
                  {
                    long long v47 = (const void *)*((void *)v40 + 7);
                    if (!v47)
                    {
                      long long v47 = (const void *)(*(uint64_t (**)(URLCredentialInternetPassword *))(*(void *)v40 + 104))(v40);
                      *((void *)v40 + 7) = v47;
                    }
                    CFDictionarySetValue(v45, v47, (char *)v40 - 16);
                  }
                  if (!v66) {
                    goto LABEL_115;
                  }
                }
                else
                {
                  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 4), 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 2), (const void *)Instance, Mutable);
                  long long v49 = (const void *)*((void *)v40 + 7);
                  if (!v49)
                  {
                    long long v49 = (const void *)(*(uint64_t (**)(URLCredentialInternetPassword *))(*(void *)v40 + 104))(v40);
                    *((void *)v40 + 7) = v49;
                  }
                  CFDictionarySetValue(Mutable, v49, (char *)v40 - 16);
                  CFRelease(Mutable);
                }
                long long v50 = (const void *)*((void *)v40 + 7);
                if (v50
                  || (long long v50 = (const void *)(*(uint64_t (**)(URLCredentialInternetPassword *))(*(void *)v40 + 104))(v40),
                      (*((void *)v40 + 7) = v50) != 0))
                {
                  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 3), (const void *)Instance, v50);
                }
              }
LABEL_115:
              CFRelease((char *)v40 - 16);
              goto LABEL_116;
            }
            BOOL v43 = CFBooleanGetValue(v42) != 0;
            if (v40) {
              goto LABEL_89;
            }
          }
        }
LABEL_116:
        CFRelease((CFTypeRef)Instance);
        if (v10) {
          goto LABEL_117;
        }
LABEL_118:
        if (++v7 == v74) {
          goto LABEL_124;
        }
      }
      int v27 = 1;
      goto LABEL_63;
    }
LABEL_124:
    CFRelease(cf);
    return 1;
  }
  return result;
}

void sub_1841A2F2C(_Unwind_Exception *a1)
{
  if (v1) {
    CFRelease(v1);
  }
  CFRelease(v2);
  CFRelease(v3);
  _Unwind_Resume(a1);
}

void StorageQuery::~StorageQuery(StorageQuery *this)
{
  *(void *)this = &unk_1ECF9C2B0;
  BOOL v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  CFStringRef v4 = (const void *)*((void *)this + 3);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)this = &unk_1ECF9B550;
}

{
  uint64_t vars8;

  StorageQuery::~StorageQuery(this);

  JUMPOUT(0x18531B6D0);
}

void sub_1841A301C(_Unwind_Exception *a1)
{
  *int v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

CFTypeRef StorageQuery::copyNameAndCredsDictForProtectionSpace(CFDictionaryRef *this, const URLProtectionSpace *a2)
{
  CFStringRef Value = CFDictionaryGetValue(this[2], (char *)a2 - 16);
  if (!Value)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    *(_OWORD *)(Instance + 16) = 0u;
    int v6 = (URLProtectionSpace *)(Instance + 16);
    *(_OWORD *)(Instance + 8dispatch_get_global_queue(0, 0) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(void *)(Instance + 112) = 0;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(void *)(Instance + 16) = &unk_1ECF9F738;
    *(void *)(Instance + 24) = &unk_1ECF9F790;
    *(void *)(Instance + 32) = &gConstantCFStringValueTable[3780];
    *(unsigned char *)(Instance + 96) = 0;
    *(unsigned char *)(Instance + 104) = 0;
    *(void *)(Instance + 112) = 1;
    CFTypeRef v7 = (CFTypeRef)*((void *)a2 + 4);
    *(void *)(Instance + 4dispatch_get_global_queue(0, 0) = *((void *)a2 + 3);
    if (v7) {
      CFTypeRef v7 = CFRetain(v7);
    }
    *(void *)(Instance + 48) = v7;
    *(void *)(Instance + 56) = *((void *)a2 + 5);
    CFTypeRef v8 = (CFTypeRef)*((void *)a2 + 6);
    if (v8) {
      CFTypeRef v8 = CFRetain(v8);
    }
    *(void *)(Instance + 64) = v8;
    *(_DWORD *)(Instance + 72) = *((_DWORD *)a2 + 14);
    CFTypeRef v9 = (CFTypeRef)*((void *)a2 + 8);
    if (v9) {
      CFTypeRef v9 = CFRetain(v9);
    }
    *(void *)(Instance + 8dispatch_get_global_queue(0, 0) = v9;
    URLProtectionSpace::calcHash(v6);
    *(_DWORD *)(Instance + 56) = 0;
    URLProtectionSpace::calcHash(v6);
    CFStringRef Value = CFDictionaryGetValue(this[2], (const void *)Instance);
    CFRelease((CFTypeRef)Instance);
    if (!Value) {
      return 0;
    }
  }

  return CFRetain(Value);
}

void non-virtual thunk to'PersistentCredentialStorage::removeCredentialForProtectionSpace(PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

void PersistentCredentialStorage::removeCredentialForProtectionSpace(PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
    }
    int v6 = (char *)a3 + 16;
  }
  else
  {
    int v6 = 0;
  }
  CFStringRef v7 = (const __CFString *)*((void *)v6 + 4);
  if (v7 && CFStringGetLength(v7) > 0)
  {
    if (*((_DWORD *)v6 + 14) == 7)
    {
      CFTypeRef v8 = (PersistentCredentialStorage *)*((void *)this + 1);
      PersistentCredentialStorage::removeIdentityPreferenceForProtectionSpace(v8, (const URLProtectionSpace *)v6);
    }
    else if (a2)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      if (!*((_DWORD *)a2 + 12))
      {
        CFDictionaryRef v9 = (const __CFDictionary *)*((void *)a2 + 12);
        if (v9)
        {
          CFAllocatorRef v10 = CFGetAllocator(a2);
          MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(v10, 0, v9);
          updateAttrsWithValuesForModifyingStore(MutableCopy, (const URLProtectionSpace *)v6, (const URLCredential *)1, *((void *)this + 4), v12);
          CFAllocatorRef v13 = CFGetAllocator(a2);
          int v14 = CFDictionaryCreateMutableCopy(v13, 0, MutableCopy);
          CFDictionarySetValue(v14, (const void *)*MEMORY[0x1E4F3B978], (const void *)*MEMORY[0x1E4F3B998]);
          if (*((unsigned char *)this + 40)) {
            setUseSystemKeychain(v14);
          }
          int v15 = off_1EC09E210(v14);
          if (v15)
          {
            int v16 = v15;
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
            }
            CFStringRef v17 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            {
              v18[0] = 67109378;
              v18[1] = v16;
              __int16 v19 = 2112;
              uint64_t v20 = v14;
              _os_log_debug_impl(&dword_184085000, v17, OS_LOG_TYPE_DEBUG, "CredStore - removeCredForProtSpace - Error removing cred.  Error=%d, query=%@", (uint8_t *)v18, 0x12u);
            }
          }
          CFRelease(v14);
          CFRelease(MutableCopy);
        }
      }
    }
  }
  else
  {
    CFLog();
  }
}

void non-virtual thunk to'PersistentCredentialStorage::setCredentialForProtectionSpace(PersistentCredentialStorage **this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

void PersistentCredentialStorage::setCredentialForProtectionSpace(PersistentCredentialStorage **this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    if (*((_DWORD *)a2 + 13) != 3
      && *((_DWORD *)a2 + 13) != 4
      && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)CFStringRef v7 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "ephemeral credential in persistent store", v7, 2u);
    }
  }
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  if (*((_DWORD *)a3 + 18) == 7)
  {
    if (a2)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      if (*((_DWORD *)a2 + 12) == 3) {
        PersistentCredentialStorage::setIdentityCredentialForProtectionSpace(this[1], (const URLCredentialClientCertificate *)((char *)a2 + 16), (const URLProtectionSpace *)((char *)a3 + 16));
      }
    }
  }
  else
  {
    if (a2)
    {
      if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
        dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
      }
      int v6 = (const URLCredential *)((char *)a2 + 16);
    }
    else
    {
      int v6 = 0;
    }
    PersistentCredentialStorage::updateOrAddCredential((PersistentCredentialStorage *)this, v6, (const URLProtectionSpace *)((char *)a3 + 16), 0);
  }
}

CFMutableDictionaryRef non-virtual thunk to'PersistentCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(PersistentCredentialStorage *this, const __CFString *a2, int a3)
{
  return PersistentCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain((PersistentCredentialStorage *)((char *)this - 16), a2, a3);
}

CFMutableDictionaryRef PersistentCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain(PersistentCredentialStorage *this, CFStringRef theString1, int a3)
{
  if (theString1 && CFEqual(theString1, @"com.apple.cfnetwork"))
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFStringRef v7 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFStringRef v17 = 0;
      _os_log_impl(&dword_184085000, v7, OS_LOG_TYPE_DEFAULT, "Enforcing strict auth scheme matching", v17, 2u);
    }
    int v6 = 1;
  }
  else
  {
    int v6 = 0;
  }
  CFTypeRef v8 = (const void **)MEMORY[0x1E4F3BD08];
  if (a3)
  {
    StorageQuery::StorageQuery((StorageQuery *)v17, *((const __CFAllocator **)this + 1), 0, *((unsigned char *)this + 40), *((const __CFString **)this + 4));
    if (v6) {
      char v20 = 1;
    }
    CFDictionaryRef v9 = (const void *)*MEMORY[0x1E4F1CFC8];
    CFDictionarySetValue(theDict, *v8, (const void *)*MEMORY[0x1E4F1CFC8]);
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E4F3B878], v9);
    if (StorageQuery::performQuery((StorageQuery *)v17) && cf) {
      CFDictionaryRef v10 = (const __CFDictionary *)CFRetain(cf);
    }
    else {
      CFDictionaryRef v10 = 0;
    }
    StorageQuery::~StorageQuery((StorageQuery *)v17);
  }
  else
  {
    CFDictionaryRef v10 = 0;
  }
  StorageQuery::StorageQuery((StorageQuery *)v17, *((const __CFAllocator **)this + 1), 0, *((unsigned char *)this + 40), *((const __CFString **)this + 4));
  if (v6) {
    char v20 = 1;
  }
  if (theString1)
  {
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E4F3B550], theString1);
    CFDictionarySetValue(theDict, *v8, (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  if (StorageQuery::performQuery((StorageQuery *)v17) && cf)
  {
    CFDictionaryRef v11 = (const __CFDictionary *)CFRetain(cf);
    CFDictionaryRef v12 = v11;
    BOOL v13 = v10 != 0;
    BOOL v14 = v11 != 0;
    if (v10 && v11)
    {
      MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(*((CFAllocatorRef *)this + 1), 0, v10);
      if (MutableCopy) {
        CFDictionaryApplyFunction(v12, (CFDictionaryApplierFunction)_merge_dictionaries, MutableCopy);
      }
      CFRelease(v10);
      CFRelease(v12);
      goto LABEL_37;
    }
  }
  else
  {
    BOOL v14 = 0;
    CFDictionaryRef v12 = 0;
    BOOL v13 = v10 != 0;
  }
  if (!v10 || (MutableCFStringRef Copy = v10, v14))
  {
    if (!v12) {
      BOOL v13 = 1;
    }
    if (v13) {
      MutableCFStringRef Copy = 0;
    }
    else {
      MutableCFStringRef Copy = v12;
    }
  }
LABEL_37:
  StorageQuery::~StorageQuery((StorageQuery *)v17);
  return MutableCopy;
}

void sub_1841A3898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void _merge_dictionaries(const void *a1, CFTypeRef cf, __CFDictionary *a3)
{
  if (a1)
  {
    if (cf)
    {
      CFTypeID v6 = CFGetTypeID(cf);
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (a3)
      {
        if (v6 == TypeID)
        {
          CFDictionarySetValue(a3, a1, cf);
        }
      }
    }
  }
}

CFTypeRef non-virtual thunk to'PersistentCredentialStorage::copyAllCredentials(PersistentCredentialStorage *this)
{
  return PersistentCredentialStorage::copyAllCredentials((PersistentCredentialStorage *)((char *)this - 16));
}

CFTypeRef PersistentCredentialStorage::copyAllCredentials(PersistentCredentialStorage *this)
{
  StorageQuery::StorageQuery((StorageQuery *)v3, *((const __CFAllocator **)this + 1), 0, *((unsigned char *)this + 40), *((const __CFString **)this + 4));
  if (StorageQuery::performQuery((StorageQuery *)v3) && cf) {
    CFTypeRef v1 = CFRetain(cf);
  }
  else {
    CFTypeRef v1 = 0;
  }
  StorageQuery::~StorageQuery((StorageQuery *)v3);
  return v1;
}

void sub_1841A39A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  StorageQuery::~StorageQuery((StorageQuery *)va);
  _Unwind_Resume(a1);
}

__CFDictionary *non-virtual thunk to'PersistentCredentialStorage::copyCredentialsForProtectionSpace(PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  return PersistentCredentialStorage::copyCredentialsForProtectionSpace((PersistentCredentialStorage *)((char *)this - 16), a2);
}

__CFDictionary *PersistentCredentialStorage::copyCredentialsForProtectionSpace(PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  BOOL v2 = a2;
  if (a2)
  {
    if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
      dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
    }
    BOOL v2 = (_CFURLProtectionSpace *)((char *)v2 + 16);
  }
  int v4 = *((_DWORD *)v2 + 14);
  if ((v4 - 8) < 5) {
    return 0;
  }
  if (v4 != 7)
  {
    StorageQuery::StorageQuery((StorageQuery *)v10, *((const __CFAllocator **)this + 1), (const URLProtectionSpace *)v2, *((unsigned char *)this + 40), *((const __CFString **)this + 4));
    if (StorageQuery::performQuery((StorageQuery *)v10)) {
      int v5 = StorageQuery::copyNameAndCredsDictForProtectionSpace(v10, (const URLProtectionSpace *)v2);
    }
    else {
      int v5 = 0;
    }
    StorageQuery::~StorageQuery((StorageQuery *)v10);
    return (__CFDictionary *)v5;
  }
  int v5 = PersistentCredentialStorage::copyIdentityCredentialForProtectionSpace(*((PersistentCredentialStorage **)this + 1), (const URLProtectionSpace *)v2);
  if (!v5) {
    return (__CFDictionary *)v5;
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*((void *)this + 1);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t v8 = v5[9];
  if (!v8)
  {
    uint64_t v8 = (*(uint64_t (**)(void *))(v5[2] + 104))(v5 + 2);
    v5[9] = v8;
  }
  MutableDictionary = cfTypeCreateMutableDictionary(v7, v8, v5, 0, 0);
  CFRelease(v5);
  return MutableDictionary;
}

void sub_1841A3B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  StorageQuery::~StorageQuery((StorageQuery *)va);
  _Unwind_Resume(a1);
}

uint64_t PersistentCredentialStorage::useSystemKeychain(PersistentCredentialStorage *this)
{
  return *((unsigned __int8 *)this + 40);
}

uint64_t PersistentCredentialStorage::setUseSystemKeychain(uint64_t this, char a2)
{
  *(unsigned char *)(this + 4dispatch_get_global_queue(0, 0) = a2;
  return this;
}

void sub_1841A3DE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841A4018(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841A45A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GetSvcTicketForHostWithPassword(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  double Helper_x8__GSSCreateCredentialFromUUID = gotLoadHelper_x8__GSSCreateCredentialFromUUID(a1);
  if (!*(void *)(v18 + 768)) {
    return 1;
  }
  __int16 v19 = v16;
  char v20 = v15;
  uint64_t v21 = v14;
  CFNumberRef v22 = v13;
  CFTypeRef v23 = v12;
  int v24 = v11;
  CFStringRef v25 = v10;
  size_t v53 = 0;
  CFTypeRef v54 = 0;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t inited = 0;
  int v47 = 0;
  _DWORD *v14 = 0;
  if (v10 && !strcmp(v10, "localhost")) {
    CFStringRef v25 = 0;
  }
  if (a10)
  {
    uint64_t inited = GSSCreateCredentialFromUUID_delayInitStub(Helper_x8__GSSCreateCredentialFromUUID);
  }
  else if (v23)
  {
    __s = 0;
    long long v46 = (char *)v23;
    size_t v45 = strlen(v23);
    uint64_t v27 = gss_import_name_delayInitStub(v29);
    if (v27) {
      goto LABEL_29;
    }
    if (v19)
    {
      CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef v31 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v19, 0x8000100u);
      if (v31)
      {
        CFStringRef v33 = v31;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v30, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (Mutable)
        {
          CFDataRef v35 = Mutable;
          CFDictionarySetValue(Mutable, @"kGSSICPassword", v33);
          gss_aapl_initial_cred_delayInitStub(v36);
          CFRelease(v35);
        }
        CFRelease(v33);
      }
      gss_release_name_delayInitStub(v32);
    }
    else
    {
      uint64_t v27 = gss_acquire_cred_delayInitStub(v28);
      gss_release_name_delayInitStub(v42);
      if (v27) {
        goto LABEL_29;
      }
    }
  }
  if (v22)
  {
    long long v46 = (char *)v22;
    size_t v45 = strlen(v22);
    uint64_t v27 = gss_import_name_delayInitStub(v26);
    if (v27) {
      goto LABEL_29;
    }
  }
  else
  {
    __s = 0;
    asprintf(&__s, "%s@%s", v24, v25);
    long long v46 = __s;
    size_t v45 = strlen(__s);
    uint64_t v27 = gss_import_name_delayInitStub(v37);
    free(__s);
    if (v27) {
      goto LABEL_29;
    }
  }
  uint64_t v38 = gss_init_sec_context_delayInitStub(v28);
  size_t v39 = v53;
  if (v38 > 1)
  {
    uint64_t v27 = v38;
    if (!v53) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (!v53) {
    goto LABEL_26;
  }
  unsigned __int8 v40 = v54;
  uint64_t v41 = malloc_type_malloc(v53, 0x40FE505BuLL);
  void *v20 = v41;
  if (v41)
  {
    *uint64_t v21 = v39;
    memcpy(v41, v40, v39);
LABEL_26:
    uint64_t v27 = 0;
    goto LABEL_29;
  }
  uint64_t v27 = 12;
LABEL_29:
  if (v53) {
LABEL_30:
  }
    gss_release_buffer_delayInitStub(v28);
LABEL_31:
  if (v49) {
    gss_delete_sec_context_delayInitStub(v28);
  }
  if (v50) {
    gss_release_name_delayInitStub(v28);
  }
  if (inited) {
    gss_release_cred_delayInitStub(v28);
  }
  return v27;
}

uint64_t __DestroyAllKerberosTickets_block_invoke(double a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    return gss_destroy_cred_delayInitStub(a1);
  }
  return result;
}

void __ListAllKerberosTickets_block_invoke(int a1, int a2, CFTypeRef obj)
{
}

uint64_t CFURLCredentialStorageCopyCredentialsForProtectionSpace(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
  }
  uint64_t v4 = a1 + 16;
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(v5 + 8) + 16))();
  uint64_t v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_1229, 1);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v7 + 16))(v7, "CopyCredentials", 0))
    {
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (a1)
      {
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
        }
      }
      else
      {
        uint64_t v4 = 0;
      }
      int v15 = off_1ECF9A530;
      CFStringRef v10 = CFStringCreateWithCString(v9, "Store", 0x8000100u);
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      CFStringRef v16 = v10;
      if (v4)
      {
        CFDictionaryRef v11 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4);
        CFStringRef v10 = v16;
      }
      else
      {
        CFDictionaryRef v11 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v8 + 64))(v8, v10, v11);
      if (v4 && v11) {
        CFRelease(v11);
      }
      AutoString::~AutoString((AutoString *)&v15);
      if (a2)
      {
        a2 += 16;
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
        }
      }
      int v15 = off_1ECF9A530;
      CFStringRef v12 = CFStringCreateWithCString(v9, "Space", 0x8000100u);
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      CFStringRef v16 = v12;
      if (a2)
      {
        BOOL v13 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
        CFStringRef v12 = v16;
      }
      else
      {
        BOOL v13 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v8 + 64))(v8, v12, v13);
      if (a2 && v13) {
        CFRelease(v13);
      }
      AutoString::~AutoString((AutoString *)&v15);
      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)v8 + 96))(v8, "Result", v6);
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
  }
  return v6;
}

void sub_1841A4CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __CFURLCredentialStorageCopyCredentialsForProtectionSpace_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  BOOL v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 49;
  *(void *)(a1 + 4dispatch_get_global_queue(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t CFURLCredentialStorageCopyAllCredentials(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
  }
  uint64_t v2 = a1 + 16;
  if (a1) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(v3 + 8) + 24))();
  uint64_t v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_9, 1);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v5 + 16))(v5, "CopyAllCredentials", 0))
    {
      CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (a1)
      {
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
        {
          CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
          CFAllocatorRef v7 = v11;
        }
      }
      else
      {
        uint64_t v2 = 0;
      }
      CFStringRef v12 = off_1ECF9A530;
      CFStringRef v8 = CFStringCreateWithCString(v7, "Store", 0x8000100u);
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      CFStringRef v13 = v8;
      if (v2)
      {
        CFAllocatorRef v9 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 32))(v2);
        CFStringRef v8 = v13;
      }
      else
      {
        CFAllocatorRef v9 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v6 + 64))(v6, v8, v9);
      if (v2 && v9) {
        CFRelease(v9);
      }
      AutoString::~AutoString((AutoString *)&v12);
      (*(void (**)(uint64_t, const char *, uint64_t))(*(void *)v6 + 96))(v6, "Result", v4);
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
  }
  return v4;
}

void sub_1841A4FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __CFURLCredentialStorageCopyAllCredentials_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 60;
  *(void *)(a1 + 4dispatch_get_global_queue(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t CFURLCredentialStorageSetCredentialForProtectionSpace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_15, 1);
  if (v6)
  {
    uint64_t v7 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v6 + 16))(v6, "SetCredential", 0))
    {
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (a1)
      {
        uint64_t v9 = a1 + 16;
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
        }
      }
      else
      {
        uint64_t v9 = 0;
      }
      char v20 = off_1ECF9A530;
      CFStringRef v10 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      CFStringRef v21 = v10;
      if (v9)
      {
        CFAllocatorRef v11 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9);
        CFStringRef v10 = v21;
      }
      else
      {
        CFAllocatorRef v11 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v7 + 64))(v7, v10, v11);
      if (v9 && v11) {
        CFRelease(v11);
      }
      AutoString::~AutoString((AutoString *)&v20);
      if (a3)
      {
        uint64_t v12 = a3 + 16;
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
        }
      }
      else
      {
        uint64_t v12 = 0;
      }
      char v20 = off_1ECF9A530;
      CFStringRef v13 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      CFStringRef v21 = v13;
      if (v12)
      {
        uint64_t v14 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v12 + 32))(v12);
        CFStringRef v13 = v21;
      }
      else
      {
        uint64_t v14 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v7 + 64))(v7, v13, v14);
      if (v12 && v14) {
        CFRelease(v14);
      }
      AutoString::~AutoString((AutoString *)&v20);
      if (a2)
      {
        uint64_t v15 = a2 + 16;
        if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      char v20 = off_1ECF9A530;
      CFStringRef v16 = CFStringCreateWithCString(v8, "Credential", 0x8000100u);
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      CFStringRef v21 = v16;
      if (v15)
      {
        uint64_t v17 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 32))(v15);
        CFStringRef v16 = v21;
      }
      else
      {
        uint64_t v17 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v7 + 64))(v7, v16, v17);
      if (v15 && v17) {
        CFRelease(v17);
      }
      AutoString::~AutoString((AutoString *)&v20);
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
  }
  if (a1) {
    uint64_t v18 = a1 + 16;
  }
  else {
    uint64_t v18 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)(v18 + 8) + 40))();
}

void sub_1841A54D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __CFURLCredentialStorageSetCredentialForProtectionSpace_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 82;
  *(void *)(a1 + 4dispatch_get_global_queue(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void CFURLCredentialStorageRemoveCredentialForProtectionSpace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_19, 1);
  if (v6)
  {
    uint64_t v7 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v6 + 16))(v6, "RemoveCredential", 0))
    {
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (a1)
      {
        uint64_t v9 = a1 + 16;
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
        }
      }
      else
      {
        uint64_t v9 = 0;
      }
      char v20 = off_1ECF9A530;
      CFStringRef v10 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      CFStringRef v21 = v10;
      if (v9)
      {
        CFAllocatorRef v11 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9);
        CFStringRef v10 = v21;
      }
      else
      {
        CFAllocatorRef v11 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v7 + 64))(v7, v10, v11);
      if (v9 && v11) {
        CFRelease(v11);
      }
      AutoString::~AutoString((AutoString *)&v20);
      if (a3)
      {
        uint64_t v12 = a3 + 16;
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
        }
      }
      else
      {
        uint64_t v12 = 0;
      }
      char v20 = off_1ECF9A530;
      CFStringRef v13 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      CFStringRef v21 = v13;
      if (v12)
      {
        uint64_t v14 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v12 + 32))(v12);
        CFStringRef v13 = v21;
      }
      else
      {
        uint64_t v14 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v7 + 64))(v7, v13, v14);
      if (v12 && v14) {
        CFRelease(v14);
      }
      AutoString::~AutoString((AutoString *)&v20);
      if (a2)
      {
        uint64_t v15 = a2 + 16;
        if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      char v20 = off_1ECF9A530;
      CFStringRef v16 = CFStringCreateWithCString(v8, "Credential", 0x8000100u);
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      CFStringRef v21 = v16;
      if (v15)
      {
        uint64_t v17 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 32))(v15);
        CFStringRef v16 = v21;
      }
      else
      {
        uint64_t v17 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v7 + 64))(v7, v16, v17);
      if (v15 && v17) {
        CFRelease(v17);
      }
      AutoString::~AutoString((AutoString *)&v20);
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t v18 = a2 + 16;
  if (!a2) {
    uint64_t v18 = 0;
  }
  if (*(_DWORD *)(v18 + 36) != 4)
  {
    if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
      dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
    }
    if (a1) {
      uint64_t v19 = a1 + 16;
    }
    else {
      uint64_t v19 = 0;
    }
    (*(void (**)(void))(*(void *)(v19 + 8) + 48))();
  }
}

void sub_1841A59F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __CFURLCredentialStorageRemoveCredentialForProtectionSpace_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 95;
  *(void *)(a1 + 4dispatch_get_global_queue(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___Z67CFURLCredentialStorageRemoveCredentialForProtectionSpaceWithOptionsP23_CFURLCredentialStoragePK16_CFURLCredentialP21_CFURLProtectionSpacePK14__CFDictionary_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 114;
  *(void *)(a1 + 4dispatch_get_global_queue(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t CFURLCredentialStorageCopyDefaultCredentialForProtectionSpace(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
  }
  uint64_t v4 = a1 + 16;
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(v5 + 8) + 56))();
  uint64_t v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_25_1247, 1);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v7 + 16))(v7, "CopyDefaultCredential", 0))
    {
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (a1)
      {
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
        }
      }
      else
      {
        uint64_t v4 = 0;
      }
      uint64_t v18 = off_1ECF9A530;
      CFStringRef v10 = CFStringCreateWithCString(v9, "Store", 0x8000100u);
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      CFStringRef v19 = v10;
      if (v4)
      {
        CFAllocatorRef v11 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4);
        CFStringRef v10 = v19;
      }
      else
      {
        CFAllocatorRef v11 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v8 + 64))(v8, v10, v11);
      if (v4 && v11) {
        CFRelease(v11);
      }
      AutoString::~AutoString((AutoString *)&v18);
      if (a2)
      {
        a2 += 16;
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
        }
      }
      uint64_t v18 = off_1ECF9A530;
      CFStringRef v12 = CFStringCreateWithCString(v9, "Space", 0x8000100u);
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      CFStringRef v19 = v12;
      if (a2)
      {
        CFStringRef v13 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
        CFStringRef v12 = v19;
      }
      else
      {
        CFStringRef v13 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v8 + 64))(v8, v12, v13);
      if (a2 && v13) {
        CFRelease(v13);
      }
      AutoString::~AutoString((AutoString *)&v18);
      if (v6)
      {
        uint64_t v14 = v6 + 16;
        if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
        }
      }
      else
      {
        uint64_t v14 = 0;
      }
      uint64_t v18 = off_1ECF9A530;
      CFStringRef v15 = CFStringCreateWithCString(v9, "Result", 0x8000100u);
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      CFStringRef v19 = v15;
      if (v14)
      {
        CFStringRef v16 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v14 + 32))(v14);
        CFStringRef v15 = v19;
      }
      else
      {
        CFStringRef v16 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v8 + 64))(v8, v15, v16);
      if (v14 && v16) {
        CFRelease(v16);
      }
      AutoString::~AutoString((AutoString *)&v18);
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
  }
  return v6;
}

void sub_1841A5F20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __CFURLCredentialStorageCopyDefaultCredentialForProtectionSpace_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 145;
  *(void *)(a1 + 4dispatch_get_global_queue(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t CFURLCredentialStorageSetDefaultCredentialForProtectionSpace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_28, 1);
  if (v6)
  {
    uint64_t v7 = v6;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v6 + 16))(v6, "SetDefaultCredential", 0))
    {
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (a1)
      {
        uint64_t v9 = a1 + 16;
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
        }
      }
      else
      {
        uint64_t v9 = 0;
      }
      uint64_t v20 = off_1ECF9A530;
      CFStringRef v10 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      CFStringRef v21 = v10;
      if (v9)
      {
        CFAllocatorRef v11 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9);
        CFStringRef v10 = v21;
      }
      else
      {
        CFAllocatorRef v11 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v7 + 64))(v7, v10, v11);
      if (v9 && v11) {
        CFRelease(v11);
      }
      AutoString::~AutoString((AutoString *)&v20);
      if (a3)
      {
        uint64_t v12 = a3 + 16;
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
        }
      }
      else
      {
        uint64_t v12 = 0;
      }
      uint64_t v20 = off_1ECF9A530;
      CFStringRef v13 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      CFStringRef v21 = v13;
      if (v12)
      {
        uint64_t v14 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v12 + 32))(v12);
        CFStringRef v13 = v21;
      }
      else
      {
        uint64_t v14 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v7 + 64))(v7, v13, v14);
      if (v12 && v14) {
        CFRelease(v14);
      }
      AutoString::~AutoString((AutoString *)&v20);
      if (a2)
      {
        uint64_t v15 = a2 + 16;
        if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      uint64_t v20 = off_1ECF9A530;
      CFStringRef v16 = CFStringCreateWithCString(v8, "Result", 0x8000100u);
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      CFStringRef v21 = v16;
      if (v15)
      {
        uint64_t v17 = (__CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 32))(v15);
        CFStringRef v16 = v21;
      }
      else
      {
        uint64_t v17 = @"null";
      }
      (*(void (**)(uint64_t, CFStringRef, __CFString *))(*(void *)v7 + 64))(v7, v16, v17);
      if (v15 && v17) {
        CFRelease(v17);
      }
      AutoString::~AutoString((AutoString *)&v20);
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
  }
  if (a1) {
    uint64_t v18 = a1 + 16;
  }
  else {
    uint64_t v18 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)(v18 + 8) + 64))();
}

void sub_1841A63F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __CFURLCredentialStorageSetDefaultCredentialForProtectionSpace_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 157;
  *(void *)(a1 + 4dispatch_get_global_queue(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t URLCredentialStorage::initialize(URLCredentialStorage *this, CFTypeRef cf)
{
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  *((void *)this + 12) = v3;
  return 1;
}

uint64_t ___ZN29URLCredentialStorageUtilities25isSystemKeychainSupportedEv_block_invoke()
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3221225472;
  uint64_t v18 = ___ZN29URLCredentialStorageUtilities25isSystemKeychainSupportedEv_block_invoke_2;
  CFStringRef v19 = &__block_descriptor_40_e5_v8__0l;
  CFDictionaryRef inited = (const __CFDictionary *)MKBUserTypeDeviceMode_delayInitStub(COERCE_DOUBLE(3221225472));
  if (inited)
  {
    gotLoadHelper_x8__kMKBDeviceModeKey(v1);
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(inited, **(const void ***)(v2 + 256));
    gotLoadHelper_x8__kMKBUserTypeKey(v4);
    CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(inited, **(const void ***)(v5 + 336));
    CFStringRef v8 = v6;
    if (Value) {
      BOOL v9 = v6 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9
      || (gotLoadHelper_x8__kMKBDeviceModeMultiUser(v7), CFStringCompare(Value, **(CFStringRef **)(v10 + 264), 0)))
    {
      BOOL v12 = 0;
    }
    else
    {
      gotLoadHelper_x8__kMKBUserTypeEphemeral(v11);
      BOOL v12 = CFEqual(v8, **(CFStringRef **)(v16 + 328));
    }
    URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser = v12;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFStringRef v13 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 67109634;
      *(_DWORD *)uint64_t v23 = URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser;
      *(_WORD *)&v23[4] = 2112;
      *(void *)&v23[6] = Value;
      __int16 v24 = 2112;
      CFStringRef v25 = v8;
      _os_log_impl(&dword_184085000, v13, OS_LOG_TYPE_DEFAULT, "Device is multi-user=%d for mode %@ userType %@", buf, 0x1Cu);
    }
    CFRelease(inited);
  }
  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v14 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 138412290;
      *(void *)uint64_t v23 = v21;
      _os_log_error_impl(&dword_184085000, v14, OS_LOG_TYPE_ERROR, "MKBUserTypeDeviceMode returned NULL: %@", buf, 0xCu);
    }
  }
  return ((uint64_t (*)(void *))v18)(v17);
}

void sub_1841A6740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void (*a11)(uint64_t *))
{
  CFRelease(v11);
  a11(&a9);
  _Unwind_Resume(a1);
}

void ___ZN29URLCredentialStorageUtilities25isSystemKeychainSupportedEv_block_invoke_2(uint64_t a1)
{
  double v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t CFURLCredentialStorageIsSystemKeychainSupported()
{
  if (URLCredentialStorageUtilities::isSystemKeychainSupported(void)::onceToken != -1) {
    dispatch_once(&URLCredentialStorageUtilities::isSystemKeychainSupported(void)::onceToken, &__block_literal_global_1271);
  }
  return URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser;
}

uint64_t CFURLCredentialStorageSetUseSystemKeychain(uint64_t a1)
{
  if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1) {
    dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_3_1277);
  }
  if (a1) {
    uint64_t v2 = a1 + 16;
  }
  else {
    uint64_t v2 = 0;
  }
  CFTypeRef v3 = *(uint64_t (**)(void))(*(void *)(v2 + 8) + 72);

  return v3();
}

id ___ZN2H329reportServerProtocolViolationEP8NSStringNS_23ServerProtocolViolationE_block_invoke(uint64_t a1)
{
  void v6[2] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  v5[1] = @"violationType";
  v6[0] = v1;
  v5[0] = @"domain";
  uint64_t v2 = [NSNumber numberWithUnsignedChar:*(unsigned __int8 *)(a1 + 40)];
  v6[1] = v2;
  CFTypeRef v3 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v6 forKeys:v5 count:2];

  return v3;
}

void sub_1841A6914(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL _CFHostIsDomainTopLevelForCookiePolicy(const __CFString *a1)
{
  return isTopLevelDomain(a1, 1);
}

BOOL _CFHostIsDomainTopLevelForCertificatePolicy(const __CFString *a1)
{
  return isTopLevelDomain(a1, 0);
}

CFStringRef _cfnCreateRegistrableDomain(const __CFString *a1)
{
  *(void *)&v10[255] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  IDNAEncodedCFStringRef Domain = createIDNAEncodedDomain(a1);
  if (!CFStringGetCString(IDNAEncodedDomain, buffer, 256, 0x600u))
  {
    CFStringRef v5 = 0;
    if (!IDNAEncodedDomain) {
      return v5;
    }
LABEL_16:
    CFRelease(IDNAEncodedDomain);
    return v5;
  }
  size_t v2 = strlen(buffer);
  uint64_t v3 = v2;
  if (v2 && buffer[v2 - 1] == 46)
  {
    buffer[v2 - 1] = 0;
    uint64_t v3 = v2 - 1;
  }
  TopLevelCFStringRef Domain = _CFHostGetTopLevelDomain((unint64_t)buffer, v3, 1);
  CFStringRef v5 = 0;
  if (TopLevelDomain && TopLevelDomain > v10)
  {
    CFStringRef v6 = TopLevelDomain - 2;
    do
    {
      double v7 = v6;
      if (v6 < buffer) {
        break;
      }
      --v6;
    }
    while (*v7 != 46);
    CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7 + 1, 0x600u);
  }
  if (IDNAEncodedDomain) {
    goto LABEL_16;
  }
  return v5;
}

void sub_1841A6A94(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL12creatEnqueueP17HTTPNetConnectionP15__CFHTTPMessageP14__CFReadStream_block_invoke(uint64_t a1, __CFReadStream *a2)
{
  double v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 40), 184, 0);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  void v4[4] = 0u;
  void v4[5] = 0u;
  void v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((void *)v4 + 22) = 0;
  HTTPNetStreamInfo::HTTPNetStreamInfo((HTTPNetStreamInfo *)v4, a2, *(CFTypeRef *)(a1 + 48), *(HTTPNetConnection **)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  (*(void (**)(uint64_t, void, void))(*(void *)v6 + 112))(v6, 0, 0);
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void MetaConnectionCache::getPendingTubeForProtocolWithKey()
{
}

void MetaConnectionCache::ingestTube()
{
}

void MetaConnectionCache::ingestTube(MetaConnectionCache *this, Tube *a2)
{
}

void MetaConnectionCache::initWithSchedulingSet()
{
}

void MetaConnectionCache::initWithSchedulingSet(MetaConnectionCache *this, const CoreSchedulingSet *a2, TubeManager *a3)
{
}

BOOL MetaConnectionCache::equals(MetaConnectionCache *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

CFStringRef MetaConnectionCache::copyDebugDesc(MetaConnectionCache *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"MetaConnectionCache<%p>", this);
}

void MetaNetStreamInfo::getAuthState(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t MetaNetStreamInfo::getHTTPConnectionInfo(MetaNetStreamInfo *this)
{
  return 0;
}

CFTypeID CFNetServiceBrowserGetTypeID(void)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = _CFNetServiceBrowserRegisterClass;
  if (_kCFNetServiceBrowserRegisterClass != -1) {
    dispatch_once(&_kCFNetServiceBrowserRegisterClass, block);
  }
  return _kCFNetServiceBrowserTypeID;
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

void *_CFNetServiceBrowserRegisterClass(void)
{
  uint64_t result = malloc_type_calloc(1uLL, 0x60uLL, 0x10D00408820D60FuLL);
  _kCFNetServiceBrowserClass = (uint64_t)result;
  if (result)
  {
    *uint64_t result = 0;
    result[1] = "CFNetServiceBrowser";
    result[4] = _NetServiceBrowserDestroy;
    uint64_t result = (void *)_CFRuntimeRegisterClass();
    _kCFNetServiceBrowserCFTypeID TypeID = (uint64_t)result;
  }
  return result;
}

void _NetServiceBrowserDestroy(__CFNetServiceBrowser *a1)
{
  size_t v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if (*((void *)a1 + 14))
  {
    uint64_t v3 = (void (*)(void))*((void *)a1 + 16);
    if (v3) {
      v3();
    }
  }
  double v4 = (char *)*((void *)a1 + 5);
  if (v4)
  {
    uint64_t v5 = *((void *)a1 + 11);
    if (v5)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v4, v5);
      double v4 = (char *)*((void *)a1 + 5);
    }
    _CFTypeInvalidate(v4);
    CFRelease(*((CFTypeRef *)a1 + 5));
  }
  uint64_t v6 = (_DNSServiceRef_t *)*((void *)a1 + 6);
  if (v6) {
    DNSServiceRefDeallocate(v6);
  }
  double v7 = (const void *)*((void *)a1 + 8);
  if (v7) {
    CFRelease(v7);
  }
  CFStringRef v8 = (const void *)*((void *)a1 + 9);
  if (v8) {
    CFRelease(v8);
  }
  BOOL v9 = (const void *)*((void *)a1 + 10);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = (const void *)*((void *)a1 + 11);
  if (v10) {
    CFRelease(v10);
  }

  os_unfair_lock_unlock(v2);
}

CFNetServiceBrowserRef CFNetServiceBrowserCreate(CFAllocatorRef alloc, CFNetServiceBrowserClientCallBack clientCB, CFNetServiceClientContext *clientContext)
{
  uint64_t v3 = 0;
  if (clientCB && clientContext)
  {
    if (!CFNetServiceBrowserGetTypeID()) {
      return 0;
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v3 = (void *)Instance;
    if (Instance)
    {
      memset(&v18, 0, sizeof(v18));
      *(_OWORD *)(Instance + 8dispatch_get_global_queue(0, 0) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(void *)(Instance + 96) = clientCB;
      long long v12 = *(_OWORD *)&clientContext->version;
      long long v13 = *(_OWORD *)&clientContext->retain;
      *(void *)(Instance + 136) = clientContext->copyDescription;
      *(_OWORD *)(Instance + 12dispatch_get_global_queue(0, 0) = v13;
      *(_OWORD *)(Instance + 104) = v12;
      uint64_t v14 = *(void *)(Instance + 112);
      if (v14)
      {
        uint64_t v15 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v3[15];
        if (v15) {
          v3[14] = v15(v14, v8, v9, v10, v11);
        }
      }
      uint64_t v16 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
      v3[11] = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
      v3[8] = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], &v18);
      v3[9] = CFArrayCreateMutable(alloc, 0, v16);
      v3[10] = CFArrayCreateMutable(alloc, 0, v16);
      if (!v3[11])
      {
        CFRelease(v3);
        return 0;
      }
    }
  }
  return (CFNetServiceBrowserRef)v3;
}

void CFNetServiceBrowserInvalidate(CFNetServiceBrowserRef browser)
{
  size_t v2 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  if (*((void *)browser + 14))
  {
    uint64_t v3 = (void (*)(void))*((void *)browser + 16);
    if (v3) {
      v3();
    }
  }
  uint64_t v4 = *((void *)browser + 5);
  if (v4)
  {
    _CFTypeUnscheduleFromMultipleRunLoops(v4, *((void *)browser + 11));
    _CFTypeInvalidate(*((void *)browser + 5));
    CFRelease(*((CFTypeRef *)browser + 5));
    *((void *)browser + 5) = 0;
  }
  uint64_t v5 = (_DNSServiceRef_t *)*((void *)browser + 6);
  if (v5)
  {
    DNSServiceRefDeallocate(v5);
    *((void *)browser + 6) = 0;
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)browser + 8));
    CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 9));
    CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 10));
  }
  *((_OWORD *)browser + 7) = 0u;
  *((_OWORD *)browser + 8) = 0u;
  *((_OWORD *)browser + 6) = 0u;

  os_unfair_lock_unlock(v2);
}

Boolean CFNetServiceBrowserSearchForDomains(CFNetServiceBrowserRef browser, Boolean registrationDomains, CFStreamError *error)
{
  int v3 = registrationDomains;
  if (error) {
    uint64_t v5 = error;
  }
  else {
    uint64_t v5 = (CFStreamError *)&v21;
  }
  v5->CFIndex domain = 0;
  *(void *)&v5->SInt32 error = 0;
  CFRetain(browser);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  context.version = 0;
  context.info = browser;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
  context.copyDescription = 0;
  if (!*((void *)browser + 12))
  {
    Boolean v9 = 0;
    *((void *)browser + 3) = 10;
    int v10 = -72006;
    goto LABEL_9;
  }
  int v6 = -72008;
  double v7 = (const void *)*((void *)browser + 5);
  if (v7)
  {
    CFTypeID v8 = CFGetTypeID(v7);
    if (v8 == CFSocketGetTypeID())
    {
      Boolean v9 = 0;
      *((void *)browser + 3) = 10;
      int v10 = -72003;
LABEL_9:
      *((_DWORD *)browser + 8) = v10;
      goto LABEL_28;
    }
    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)browser + 5), *((const __CFArray **)browser + 11));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)browser + 5));
    CFRelease(*((CFTypeRef *)browser + 5));
    *((void *)browser + 5) = 0;
  }
  *((unsigned char *)browser + 2dispatch_get_global_queue(0, 0) = 1;
  if (v3) {
    DNSServiceFlags v11 = 128;
  }
  else {
    DNSServiceFlags v11 = 64;
  }
  DNSServiceErrorType v12 = DNSServiceEnumerateDomains((DNSServiceRef *)browser + 6, v11, 0, (DNSServiceDomainEnumReply)_DomainEnumReply, browser);
  *((_DWORD *)browser + 8) = v12;
  if (v12 <= -65549)
  {
    if (v12 == -65555) {
      goto LABEL_27;
    }
    if (v12 == -65554)
    {
      int v6 = -72002;
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (v12 == -65548)
  {
    int v6 = -72001;
    goto LABEL_27;
  }
  if (v12)
  {
    if (v12 == -65540)
    {
      int v6 = -72004;
LABEL_27:
      Boolean v9 = 0;
      *((void *)browser + 3) = 10;
      *((_DWORD *)browser + 8) = v6;
      goto LABEL_28;
    }
LABEL_26:
    int v6 = -72000;
    goto LABEL_27;
  }
  CFAllocatorRef v13 = CFGetAllocator(browser);
  dnssd_sock_t v14 = DNSServiceRefSockFD(*((DNSServiceRef *)browser + 6));
  uint64_t v15 = CFSocketCreateWithNative(v13, v14, 1uLL, (CFSocketCallBack)_SocketCallBack, &context);
  *((void *)browser + 5) = v15;
  if (v15)
  {
    uint64_t v16 = v15;
    CFOptionFlags SocketFlags = CFSocketGetSocketFlags(v15);
    CFSocketSetSocketFlags(v16, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
    if (CFArrayGetCount(*((CFArrayRef *)browser + 11)))
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)browser + 5), *((const __CFArray **)browser + 11));
      Boolean v9 = 1;
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)browser + 4);
      Boolean v9 = _BrowserBlockUntilComplete((os_unfair_lock_s *)browser);
      os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
    }
  }
  else
  {
    if (*__error()) {
      int v19 = *__error();
    }
    else {
      int v19 = 12;
    }
    *((void *)browser + 3) = 1;
    *((_DWORD *)browser + 8) = v19;
    DNSServiceRefDeallocate(*((DNSServiceRef *)browser + 6));
    Boolean v9 = 0;
    *((void *)browser + 6) = 0;
  }
LABEL_28:
  *uint64_t v5 = *(CFStreamError *)((char *)browser + 24);
  os_unfair_lock_unlock((os_unfair_lock_t)browser + 4);
  CFRelease(browser);
  return v9;
}

BOOL _BrowserBlockUntilComplete(os_unfair_lock_s *a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  CFNetServiceBrowserScheduleWithRunLoop((CFNetServiceBrowserRef)a1, Current, @"_kCFNetServiceBrowserBlockingMode");
  os_unfair_lock_lock(a1 + 4);
  while (*(void *)&a1[10]._os_unfair_lock_opaque)
  {
    os_unfair_lock_unlock(a1 + 4);
    CFRunLoopRunInMode(@"_kCFNetServiceBrowserBlockingMode", 1.79769313e308, 1u);
    os_unfair_lock_lock(a1 + 4);
  }
  BOOL v3 = a1[8]._os_unfair_lock_opaque == 0;
  os_unfair_lock_unlock(a1 + 4);
  CFNetServiceBrowserUnscheduleFromRunLoop((CFNetServiceBrowserRef)a1, Current, @"_kCFNetServiceBrowserBlockingMode");
  return v3;
}

void CFNetServiceBrowserScheduleWithRunLoop(CFNetServiceBrowserRef browser, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  int v6 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  if (_SchedulesAddRunLoopAndMode(*((const __CFArray **)browser + 11), runLoop, runLoopMode))
  {
    double v7 = (void *)*((void *)browser + 5);
    if (v7) {
      _CFTypeScheduleOnRunLoop(v7, (uint64_t)runLoop, (uint64_t)runLoopMode);
    }
  }

  os_unfair_lock_unlock(v6);
}

void CFNetServiceBrowserUnscheduleFromRunLoop(CFNetServiceBrowserRef browser, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  int v6 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)browser + 11), runLoop, runLoopMode))
  {
    double v7 = (void *)*((void *)browser + 5);
    if (v7) {
      _CFTypeUnscheduleFromRunLoop(v7, (uint64_t)runLoop, (uint64_t)runLoopMode);
    }
  }

  os_unfair_lock_unlock(v6);
}

void _SocketCallBack(__CFSocket *a1, unint64_t a2, const __CFData *a3, const void *a4, DNSServiceRef *cf)
{
  CFRetain(cf);
  int v6 = (_DNSServiceRef_t *)DNSServiceProcessResult(cf[6]);
  if (v6)
  {
    if (*((unsigned char *)cf + 20)) {
      _DomainEnumReply(v6, 0, v7, (int)v6, 0, (char *)cf);
    }
    else {
      _BrowseReply(v6, 0, v7, (int)v6, 0, 0, 0, (char *)cf);
    }
  }

  CFRelease(cf);
}

void _DomainEnumReply(_DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, char *cf)
{
  if (a4 != -65570)
  {
    uint64_t v19 = v6;
    uint64_t v20 = v7;
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    if (!*((void *)cf + 6))
    {
      CFAllocatorRef v13 = 0;
      uint64_t v14 = 0;
      CFStringRef v15 = 0;
LABEL_19:
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
      if (v13 && v15)
      {
        if ((a2 & 2) != 0) {
          int v17 = 2;
        }
        else {
          int v17 = 10;
        }
        v13(cf, v17 | a2 & 5u, v15, &v18, v14);
      }
      else if (!v15)
      {
LABEL_27:
        CFRelease(cf);
        return;
      }
      CFRelease(v15);
      goto LABEL_27;
    }
    if (!a4)
    {
      if (a5)
      {
        CFAllocatorRef v16 = CFGetAllocator(cf);
        CFStringRef v15 = CFStringCreateWithCString(v16, a5, 0x8000100u);
      }
      else
      {
        CFStringRef v15 = 0;
      }
      goto LABEL_18;
    }
    int v12 = -72008;
    if (a4 > -65549)
    {
      if (a4 == -65548)
      {
        int v12 = -72001;
        goto LABEL_17;
      }
      if (a4 == -65540)
      {
        int v12 = -72004;
        goto LABEL_17;
      }
    }
    else
    {
      if (a4 == -65555)
      {
LABEL_17:
        *((void *)cf + 3) = 10;
        *((_DWORD *)cf + 8) = v12;
        _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
        CFSocketInvalidate(*((CFSocketRef *)cf + 5));
        CFRelease(*((CFTypeRef *)cf + 5));
        *((void *)cf + 5) = 0;
        DNSServiceRefDeallocate(*((DNSServiceRef *)cf + 6));
        CFStringRef v15 = 0;
        *((void *)cf + 6) = 0;
LABEL_18:
        CFAllocatorRef v13 = (void (*)(char *, void, CFStringRef, long long *, uint64_t))*((void *)cf + 12);
        long long v18 = *(_OWORD *)(cf + 24);
        uint64_t v14 = *((void *)cf + 14);
        goto LABEL_19;
      }
      if (a4 == -65554)
      {
        int v12 = -72002;
        goto LABEL_17;
      }
    }
    int v12 = -72000;
    goto LABEL_17;
  }
}

void _BrowseReply(_DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, const char *a6, const char *a7, char *cf)
{
  if (a4 != -65570)
  {
    uint64_t v46 = v8;
    uint64_t v47 = v9;
    long long v45 = 0uLL;
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    if (!*((void *)cf + 6)) {
      goto LABEL_51;
    }
    if (a4)
    {
      int v16 = -72008;
      if (a4 > -65549)
      {
        if (a4 == -65548)
        {
          int v16 = -72001;
          goto LABEL_20;
        }
        if (a4 == -65540)
        {
          int v16 = -72004;
          goto LABEL_20;
        }
      }
      else
      {
        if (a4 == -65555)
        {
LABEL_20:
          *((void *)cf + 3) = 10;
          *((_DWORD *)cf + 8) = v16;
          _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
          CFSocketInvalidate(*((CFSocketRef *)cf + 5));
          CFRelease(*((CFTypeRef *)cf + 5));
          *((void *)cf + 5) = 0;
          DNSServiceRefDeallocate(*((DNSServiceRef *)cf + 6));
          *((void *)cf + 6) = 0;
          CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)cf + 8));
          CFArrayRemoveAllValues(*((CFMutableArrayRef *)cf + 9));
          CFArrayRemoveAllValues(*((CFMutableArrayRef *)cf + 10));
          goto LABEL_21;
        }
        if (a4 == -65554)
        {
          int v16 = -72002;
          goto LABEL_20;
        }
      }
      int v16 = -72000;
      goto LABEL_20;
    }
    if (!a5 || !a6 || !a7) {
      goto LABEL_21;
    }
    CFAllocatorRef v17 = CFGetAllocator(cf);
    CFStringRef v18 = CFStringCreateWithCString(v17, a7, 0x8000100u);
    CFStringRef v19 = CFStringCreateWithCString(v17, a6, 0x8000100u);
    CFStringRef v20 = CFStringCreateWithCString(v17, a5, 0x8000100u);
    CFStringRef v21 = v20;
    if (v18 && v19 && v20)
    {
      CFNetServiceRef v22 = CFNetServiceCreate(v17, v18, v19, v20, -1);
    }
    else
    {
      CFNetServiceRef v22 = 0;
      double v32 = 0;
      if (!v18) {
        goto LABEL_34;
      }
    }
    CFRelease(v18);
    double v32 = v22;
LABEL_34:
    if (v19) {
      CFRelease(v19);
    }
    if (v21) {
      CFRelease(v21);
    }
    if (!v32) {
      goto LABEL_21;
    }
    uint64_t v33 = *((void *)cf + 7);
    if (v33)
    {
      unsigned int v34 = 7;
    }
    else
    {
      if ((v33 & 2) == 0) {
        goto LABEL_56;
      }
      unsigned int v34 = 9;
    }
    _ServiceSetInfo(v32, v34, (const void *)*MEMORY[0x1E4F1CFD0], 0);
LABEL_56:
    unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)cf + 8), v32);
    if ((a2 & 2) != 0)
    {
      if (!Value)
      {
        CFArrayRef v43 = (const __CFArray *)*((void *)cf + 10);
        v49.CFIndex length = CFArrayGetCount(v43);
        v49.CFIndex location = 0;
        FirstIndexOfunsigned int Value = CFArrayGetFirstIndexOfValue(v43, v49, v32);
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)cf + 8), v32, (const void *)1);
        CFArrayAppendValue(*((CFMutableArrayRef *)cf + 9), v32);
        if (FirstIndexOfValue != -1)
        {
          double v42 = (__CFArray *)*((void *)cf + 10);
          goto LABEL_65;
        }
LABEL_66:
        CFRelease(v32);
LABEL_21:
        uint64_t v23 = (void (*)(char *, uint64_t, const void *, long long *, uint64_t))*((void *)cf + 12);
        long long v45 = *(_OWORD *)(cf + 24);
        uint64_t v24 = *((void *)cf + 14);
        if (v23 && DWORD2(v45))
        {
          os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
          v23(cf, 0, 0, &v45, v24);
LABEL_52:
          CFRelease(cf);
          return;
        }
        if ((a2 & 1) == 0 && v23)
        {
          CFIndex Count = CFArrayGetCount(*((CFArrayRef *)cf + 9));
          CFIndex v26 = CFArrayGetCount(*((CFArrayRef *)cf + 10));
          uint64_t v44 = v26;
          if (Count < 1)
          {
            CFIndex v28 = v26 - 1;
            if (v26 >= 1)
            {
              uint64_t v29 = *((void *)cf + 5);
LABEL_44:
              CFIndex v35 = 0;
              do
              {
                CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 10), v35);
                os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
                v23(cf, (v28 != v35) | 8, ValueAtIndex, &v45, v24);
                os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
              }
              while (v29 == *((void *)cf + 5) && v44 - 1 != v35++);
            }
          }
          else
          {
            CFIndex v27 = 0;
            CFIndex v28 = v26 - 1;
            uint64_t v29 = *((void *)cf + 5);
            CFIndex v30 = v26 - 1 + Count;
            while (1)
            {
              CFStringRef v31 = CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 9), v27);
              os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
              v23(cf, v30 != v27, v31, &v45, v24);
              os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
              if (v29 != *((void *)cf + 5)) {
                break;
              }
              if (Count == ++v27)
              {
                if (v44 > 0) {
                  goto LABEL_44;
                }
                break;
              }
            }
          }
          CFArrayRemoveAllValues(*((CFMutableArrayRef *)cf + 9));
          CFArrayRemoveAllValues(*((CFMutableArrayRef *)cf + 10));
        }
LABEL_51:
        os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
        goto LABEL_52;
      }
      size_t v39 = (const void *)(Value + 1);
    }
    else
    {
      size_t v39 = (const void *)(Value - 1);
      if (Value == 1)
      {
        CFArrayRef v40 = (const __CFArray *)*((void *)cf + 9);
        v48.CFIndex length = CFArrayGetCount(v40);
        v48.CFIndex location = 0;
        FirstIndexOfunsigned int Value = CFArrayGetFirstIndexOfValue(v40, v48, v32);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)cf + 8), v32);
        CFArrayAppendValue(*((CFMutableArrayRef *)cf + 10), v32);
        if (FirstIndexOfValue != -1)
        {
          double v42 = (__CFArray *)*((void *)cf + 9);
LABEL_65:
          CFArrayRemoveValueAtIndex(v42, FirstIndexOfValue);
          goto LABEL_66;
        }
        goto LABEL_66;
      }
    }
    CFDictionaryReplaceValue(*((CFMutableDictionaryRef *)cf + 8), v32, v39);
    goto LABEL_66;
  }
}

BOOL _CFNetServiceBrowserSearchForServices(char *cf, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (a5) {
    *a5 = 0;
  }
  CFRetain(cf);
  int v10 = (os_unfair_lock_s *)(cf + 16);
  os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
  v39[0] = a3;
  v39[1] = a2;
  context.version = 0;
  context.info = cf;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
  context.copyDescription = 0;
  if (!*((void *)cf + 12))
  {
    if (!a5)
    {
LABEL_35:
      BOOL v19 = 0;
      goto LABEL_37;
    }
    BOOL v19 = 0;
    *a5 = __cfnCreateCFError(0, @"kCFErrorDomainCFNetwork", -72006, v11, v12, v13, v14, v15, 0);
    goto LABEL_32;
  }
  int v16 = -72008;
  CFAllocatorRef v17 = (const void *)*((void *)cf + 5);
  if (v17)
  {
    CFTypeID v18 = CFGetTypeID(v17);
    if (v18 == CFSocketGetTypeID())
    {
      BOOL v19 = 0;
      *((void *)cf + 3) = 10;
      *((_DWORD *)cf + 8) = -72003;
      goto LABEL_32;
    }
    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)cf + 5));
    CFRelease(*((CFTypeRef *)cf + 5));
    *((void *)cf + 5) = 0;
  }
  lock = (os_unfair_lock_s *)(cf + 16);
  uint64_t v20 = 0;
  char v21 = 1;
  do
  {
    char v22 = v21;
    CFStringRef v23 = (const __CFString *)v39[v20];
    if (v23)
    {
      CFIndex usedBufLen = 0;
      v43.CFIndex length = CFStringGetLength(v23);
      uint64_t v24 = (UInt8 *)&regtype[1024 * v20];
      v43.CFIndex location = 0;
      CFStringGetBytes(v23, v43, 0x8000100u, 0, 0, v24, 1023, &usedBufLen);
      v24[usedBufLen] = 0;
    }
    else
    {
      regtype[1024 * v20] = 0;
    }
    char v21 = 0;
    uint64_t v20 = 1;
  }
  while ((v22 & 1) != 0);
  cf[20] = 0;
  *((void *)cf + 7) = a4;
  if (a4) {
    DNSServiceFlags v25 = 0x100000;
  }
  else {
    DNSServiceFlags v25 = (a4 << 19) & 0x100000;
  }
  DNSServiceErrorType v26 = DNSServiceBrowse((DNSServiceRef *)cf + 6, v25, 0, regtype, v41, (DNSServiceBrowseReply)_BrowseReply, cf);
  *((_DWORD *)cf + 8) = v26;
  if (v26 <= -65549)
  {
    int v10 = (os_unfair_lock_s *)(cf + 16);
    if (v26 == -65555) {
      goto LABEL_31;
    }
    if (v26 == -65554)
    {
      int v16 = -72002;
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (v26 == -65548)
  {
    int v16 = -72001;
    int v10 = (os_unfair_lock_s *)(cf + 16);
    goto LABEL_31;
  }
  int v10 = (os_unfair_lock_s *)(cf + 16);
  if (v26)
  {
    if (v26 == -65540)
    {
      int v16 = -72004;
LABEL_31:
      BOOL v19 = 0;
      *((void *)cf + 3) = 10;
      *((_DWORD *)cf + 8) = v16;
      goto LABEL_32;
    }
LABEL_30:
    int v16 = -72000;
    goto LABEL_31;
  }
  CFAllocatorRef v27 = CFGetAllocator(cf);
  dnssd_sock_t v28 = DNSServiceRefSockFD(*((DNSServiceRef *)cf + 6));
  uint64_t v29 = CFSocketCreateWithNative(v27, v28, 1uLL, (CFSocketCallBack)_SocketCallBack, &context);
  CFIndex v30 = v29;
  *((void *)cf + 5) = v29;
  if (v29)
  {
    CFOptionFlags SocketFlags = CFSocketGetSocketFlags(v29);
    CFSocketSetSocketFlags(v30, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
    if (CFArrayGetCount(*((CFArrayRef *)cf + 11)))
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
      BOOL v19 = 1;
      int v10 = (os_unfair_lock_s *)(cf + 16);
      goto LABEL_37;
    }
    os_unfair_lock_unlock(lock);
    BOOL v19 = _BrowserBlockUntilComplete((os_unfair_lock_s *)cf);
    int v10 = (os_unfair_lock_s *)(cf + 16);
    os_unfair_lock_lock(lock);
  }
  else
  {
    if (*__error()) {
      int v34 = *__error();
    }
    else {
      int v34 = 12;
    }
    CFIndex v35 = (_DNSServiceRef_t *)*((void *)cf + 6);
    *((void *)cf + 3) = 1;
    *((_DWORD *)cf + 8) = v34;
    DNSServiceRefDeallocate(v35);
    BOOL v19 = 0;
    *((void *)cf + 6) = 0;
    int v10 = (os_unfair_lock_s *)(cf + 16);
  }
LABEL_32:
  if (a5 && !v19)
  {
    if (!*a5)
    {
      CFAllocatorRef v32 = CFGetAllocator(cf);
      BOOL v19 = 0;
      *a5 = __cfnCreateCFErrorWithStreamError(v32, (int *)cf + 6);
      goto LABEL_37;
    }
    goto LABEL_35;
  }
LABEL_37:
  os_unfair_lock_unlock(v10);
  CFRelease(cf);
  return v19;
}

Boolean CFNetServiceBrowserSearchForServices(CFNetServiceBrowserRef browser, CFStringRef domain, CFStringRef serviceType, CFStreamError *error)
{
  CFTypeRef cf = 0;
  BOOL v5 = _CFNetServiceBrowserSearchForServices((char *)browser, (uint64_t)domain, (uint64_t)serviceType, 0, (CFErrorRef *)&cf);
  Boolean v6 = v5;
  if (error && !v5)
  {
    error->CFIndex domain = _CFStreamErrorFromCFError((__CFError *)cf);
    *(void *)&error->SInt32 error = v7;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

void CFNetServiceBrowserStopSearch(CFNetServiceBrowserRef browser, CFStreamError *error)
{
  v16[0] = 10;
  if (error) {
    BOOL v3 = error;
  }
  else {
    BOOL v3 = (CFStreamError *)v16;
  }
  uint64_t v4 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  BOOL v5 = (void *)*((void *)browser + 5);
  if (v5)
  {
    v15.version = 0;
    v15.info = browser;
    v15.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
    v15.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
    memset(&v15.copyDescription, 0, 40);
    v15.perform = (void (__cdecl *)(void *))_BrowserCancel;
    _CFTypeUnscheduleFromMultipleRunLoops(v5, *((const __CFArray **)browser + 11));
    _CFTypeInvalidate(*((char **)browser + 5));
    CFRelease(*((CFTypeRef *)browser + 5));
    Boolean v6 = (_DNSServiceRef_t *)*((void *)browser + 6);
    if (v6)
    {
      DNSServiceRefDeallocate(v6);
      *((void *)browser + 6) = 0;
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)browser + 8));
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 9));
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 10));
    }
    v16[1] = 4294895291;
    *(CFStreamError *)((char *)browser + 24) = *v3;
    CFAllocatorRef v7 = CFGetAllocator(browser);
    CFRunLoopSourceRef v8 = CFRunLoopSourceCreate(v7, 0, &v15);
    *((void *)browser + 5) = v8;
    if (v8)
    {
      CFArrayRef v9 = (const __CFArray *)*((void *)browser + 11);
      CFIndex Count = CFArrayGetCount(v9);
      _CFTypeScheduleOnMultipleRunLoops(*((void **)browser + 5), v9);
      CFRunLoopSourceSignal(*((CFRunLoopSourceRef *)browser + 5));
      if (Count >= 1)
      {
        for (CFIndex i = 0; i < Count; i += 2)
        {
          CFDictionaryRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v9, i);
          if (CFRunLoopIsWaiting(ValueAtIndex))
          {
            CFStringRef v13 = CFRunLoopCopyCurrentMode(ValueAtIndex);
            if (v13)
            {
              CFStringRef v14 = v13;
              if (CFRunLoopContainsSource(ValueAtIndex, *((CFRunLoopSourceRef *)browser + 5), v13)) {
                CFRunLoopWakeUp(ValueAtIndex);
              }
              CFRelease(v14);
            }
          }
        }
      }
    }
  }
  os_unfair_lock_unlock(v4);
}

void _BrowserCancel(__CFNetServiceBrowser *a1)
{
  CFRetain(a1);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  size_t v2 = (void *)*((void *)a1 + 5);
  if (v2)
  {
    BOOL v3 = (void (*)(__CFNetServiceBrowser *, void, void, long long *, uint64_t))*((void *)a1 + 12);
    long long v9 = *(_OWORD *)((char *)a1 + 24);
    uint64_t v5 = *((void *)a1 + 14);
    uint64_t v4 = (void (*)(void))*((void *)a1 + 15);
    Boolean v6 = (void (*)(uint64_t))*((void *)a1 + 16);
    if (v3) {
      BOOL v7 = v5 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7 && v4 != 0)
    {
      v4(*((void *)a1 + 14));
      size_t v2 = (void *)*((void *)a1 + 5);
    }
    _CFTypeUnscheduleFromMultipleRunLoops(v2, *((const __CFArray **)a1 + 11));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)a1 + 5));
    CFRelease(*((CFTypeRef *)a1 + 5));
    *((void *)a1 + 5) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
    if (v3)
    {
      v3(a1, 0, 0, &v9, v5);
      if (v5)
      {
        if (v6) {
          v6(v5);
        }
      }
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  }
  CFRelease(a1);
}

uint64_t ___ZN11URLProtocol20sendDidFinishLoadingEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  size_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 199;
  *(void *)(a1 + 4dispatch_get_global_queue(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

void std::__shared_ptr_emplace<HTTP3Connection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6870;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTP3Connection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6870;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ___ZN25HTTP3ConnectionCacheEntry16connectionClosedENSt3__110shared_ptrI15HTTP3ConnectionEE_block_invoke(void *a1)
{
  uint64_t v1 = a1[4];
  uint64_t v2 = a1[6];
  BOOL v3 = (std::__shared_weak_count *)a1[7];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(void **)(v1 + 104);
  uint64_t v5 = *(void **)(v1 + 112);
  Boolean v6 = v4;
  if (v4 != v5)
  {
    while (*v6 != v2)
    {
      v6 += 2;
      if (v6 == v5)
      {
        Boolean v6 = *(void **)(v1 + 112);
        break;
      }
    }
  }
  if (v6 == v5)
  {
    Boolean v6 = *(void **)(v1 + 112);
  }
  else
  {
    BOOL v7 = v6 + 2;
    if (v6 + 2 != v5)
    {
      do
      {
        Boolean v6 = v7;
        long long v8 = *(_OWORD *)v7;
        *BOOL v7 = 0;
        v7[1] = 0;
        long long v9 = (std::__shared_weak_count *)*(v7 - 1);
        *((_OWORD *)v7 - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v8;
        if (v9) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v9);
        }
        BOOL v7 = v6 + 2;
      }
      while (v6 + 2 != v5);
      uint64_t v5 = *(void **)(v1 + 112);
    }
    while (v5 != v6)
    {
      int v10 = (std::__shared_weak_count *)*(v5 - 1);
      if (v10) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v10);
      }
      v5 -= 2;
    }
    *(void *)(v1 + 112) = v6;
    uint64_t v4 = *(void **)(v1 + 104);
  }
  if (v6 == v4)
  {
    uint64_t v11 = *(std::__shared_weak_count **)(v1 + 32);
    if (v11)
    {
      uint64_t v12 = std::__shared_weak_count::lock(v11);
      if (v12)
      {
        CFStringRef v13 = v12;
        CFStringRef v14 = *(HTTP3ConnectionCache **)(v1 + 24);
        if (v14) {
          HTTP3ConnectionCache::_entryRemove(v14, *(const HTTPConnectionCacheKey **)(v1 + 80));
        }
        std::__shared_weak_count::__release_shared[abi:nn180100](v13);
      }
    }
  }
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void sub_1841A84A4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c53_ZTSNSt3__110shared_ptrI25HTTP3ConnectionCacheEntryEE48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  BOOL v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_ea8_32c53_ZTSNSt3__110shared_ptrI25HTTP3ConnectionCacheEntryEE48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void _CFTypeScheduleOnRunLoop(void *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceRef RunLoopSource = (void *)CFRetain(a1);
LABEL_7:
    CFTypeRef v10 = RunLoopSource;
    uint64_t v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x1E4F1C288];
    goto LABEL_8;
  }
  if (v6 == CFMachPortGetTypeID())
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFMachPortCreateRunLoopSource(v8, (CFMachPortRef)a1, 0);
    goto LABEL_7;
  }
  if (v6 == CFSocketGetTypeID())
  {
    CFAllocatorRef v9 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v9, (CFSocketRef)a1, 0);
    goto LABEL_7;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CoreReadStreamScheduleWithRunLoop;
  if (v6 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CoreWriteStreamScheduleWithRunLoop;
    if (v6 != *(void *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
    {
      CFTypeID TypeID = CFReadStreamGetTypeID();
      uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E4F1C260];
      if (v6 != TypeID)
      {
        CFTypeID v14 = CFWriteStreamGetTypeID();
        uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E4F1C2C8];
        if (v6 != v14)
        {
          if (HostBase::Class(void)::sOnce_HostBase != -1) {
            dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
          }
          uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFHostScheduleWithRunLoop;
          if (v6 != *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
          {
            CFTypeID v15 = SCNetworkReachabilityGetTypeID();
            uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E4F41A90];
            if (v6 != v15)
            {
              if (v6 == CFRunLoopTimerGetTypeID())
              {
                CFTypeRef v10 = CFRetain(a1);
                uint64_t v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x1E4F1C290];
LABEL_8:
                if (v10)
                {
                  v11(a2, v10, a3);
                  CFRelease(v10);
                }
                return;
              }
              CFTypeID v16 = CFNetServiceGetTypeID();
              uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceScheduleWithRunLoop;
              if (v6 != v16)
              {
                CFTypeID v17 = CFNetServiceBrowserGetTypeID();
                uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceBrowserScheduleWithRunLoop;
                if (v6 != v17)
                {
                  CFTypeID v18 = CFNetServiceMonitorGetTypeID();
                  uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceMonitorScheduleWithRunLoop;
                  if (v6 != v18)
                  {
                    CFTypeID v19 = SCNetworkConnectionGetTypeID();
                    uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E4F41A80];
                    if (v6 != v19) {
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  v12(a1, a2, a3);
}

void _CFTypeUnscheduleFromRunLoop(void *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceRef RunLoopSource = (void *)CFRetain(a1);
LABEL_7:
    CFTypeRef v10 = RunLoopSource;
    uint64_t v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x1E4F1C298];
    goto LABEL_8;
  }
  if (v6 == CFMachPortGetTypeID())
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFMachPortCreateRunLoopSource(v8, (CFMachPortRef)a1, 0);
    goto LABEL_7;
  }
  if (v6 == CFSocketGetTypeID())
  {
    CFAllocatorRef v9 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v9, (CFSocketRef)a1, 0);
    goto LABEL_7;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CoreReadStreamUnscheduleFromRunLoop;
  if (v6 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CoreWriteStreamUnscheduleFromRunLoop;
    if (v6 != *(void *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
    {
      CFTypeID TypeID = CFReadStreamGetTypeID();
      uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E4F1C270];
      if (v6 != TypeID)
      {
        CFTypeID v14 = CFWriteStreamGetTypeID();
        uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E4F1C2D8];
        if (v6 != v14)
        {
          if (HostBase::Class(void)::sOnce_HostBase != -1) {
            dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
          }
          uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFHostUnscheduleFromRunLoop;
          if (v6 != *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
          {
            CFTypeID v15 = SCNetworkReachabilityGetTypeID();
            uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E4F41A98];
            if (v6 != v15)
            {
              if (v6 == CFRunLoopTimerGetTypeID())
              {
                CFTypeRef v10 = CFRetain(a1);
                uint64_t v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x1E4F1C2A0];
LABEL_8:
                if (v10)
                {
                  v11(a2, v10, a3);
                  CFRelease(v10);
                }
                return;
              }
              CFTypeID v16 = CFNetServiceGetTypeID();
              uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceUnscheduleFromRunLoop;
              if (v6 != v16)
              {
                CFTypeID v17 = CFNetServiceBrowserGetTypeID();
                uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceBrowserUnscheduleFromRunLoop;
                if (v6 != v17)
                {
                  CFTypeID v18 = CFNetServiceMonitorGetTypeID();
                  uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceMonitorUnscheduleFromRunLoop;
                  if (v6 != v18)
                  {
                    CFTypeID v19 = SCNetworkConnectionGetTypeID();
                    uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1E4F41A88];
                    if (v6 != v19) {
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  v12(a1, a2, a3);
}

void _CFTypeScheduleOnMultipleRunLoops(void *a1, const __CFArray *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceRef RunLoopSource = (void *)CFRetain(a1);
LABEL_9:
    CFTypeRef v6 = RunLoopSource;
    BOOL v7 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x1E4F1C288];
LABEL_10:
    CFTypeRef v10 = v7;
    if (v6)
    {
      CFIndex Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        CFIndex v12 = Count;
        for (CFIndex i = 0; i < v12; i += 2)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          CFTypeID v15 = CFArrayGetValueAtIndex(a2, i + 1);
          v10(ValueAtIndex, v6, v15);
        }
      }
      CFRelease(v6);
    }
    return;
  }
  if (v4 == CFRunLoopTimerGetTypeID())
  {
    CFTypeRef v6 = CFRetain(a1);
    BOOL v7 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x1E4F1C290];
    goto LABEL_10;
  }
  if (v4 == CFMachPortGetTypeID())
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFMachPortCreateRunLoopSource(v8, (CFMachPortRef)a1, 0);
    goto LABEL_9;
  }
  if (v4 == CFSocketGetTypeID())
  {
    CFAllocatorRef v9 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v9, (CFSocketRef)a1, 0);
    goto LABEL_9;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  CFTypeID v16 = (void (*)(void *, const void *, const void *))CoreReadStreamScheduleWithRunLoop;
  if (v4 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)) {
    goto LABEL_33;
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  CFTypeID v16 = (void (*)(void *, const void *, const void *))CoreWriteStreamScheduleWithRunLoop;
  if (v4 == *(void *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96)) {
    goto LABEL_33;
  }
  CFTypeID TypeID = CFReadStreamGetTypeID();
  CFTypeID v16 = (void (*)(void *, const void *, const void *))MEMORY[0x1E4F1C260];
  if (v4 == TypeID) {
    goto LABEL_33;
  }
  CFTypeID v18 = CFWriteStreamGetTypeID();
  CFTypeID v16 = (void (*)(void *, const void *, const void *))MEMORY[0x1E4F1C2C8];
  if (v4 == v18) {
    goto LABEL_33;
  }
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  CFTypeID v16 = (void (*)(void *, const void *, const void *))CFHostScheduleWithRunLoop;
  if (v4 == *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96)) {
    goto LABEL_33;
  }
  CFTypeID v19 = CFNetServiceGetTypeID();
  CFTypeID v16 = (void (*)(void *, const void *, const void *))CFNetServiceScheduleWithRunLoop;
  if (v4 == v19) {
    goto LABEL_33;
  }
  CFTypeID v20 = CFNetServiceBrowserGetTypeID();
  CFTypeID v16 = (void (*)(void *, const void *, const void *))CFNetServiceBrowserScheduleWithRunLoop;
  if (v4 == v20
    || (CFTypeID v21 = CFNetServiceMonitorGetTypeID(),
        CFTypeID v16 = (void (*)(void *, const void *, const void *))CFNetServiceMonitorScheduleWithRunLoop,
        v4 == v21)
    || (CFTypeID v22 = SCNetworkReachabilityGetTypeID(),
        CFTypeID v16 = (void (*)(void *, const void *, const void *))MEMORY[0x1E4F41A90],
        v4 == v22)
    || (CFTypeID v23 = SCNetworkConnectionGetTypeID(),
        CFTypeID v16 = (void (*)(void *, const void *, const void *))MEMORY[0x1E4F41A80],
        v4 == v23))
  {
LABEL_33:
    uint64_t v24 = v16;
    CFIndex v25 = CFArrayGetCount(a2);
    if (v25 >= 1)
    {
      CFIndex v26 = v25;
      for (CFIndex j = 0; j < v26; j += 2)
      {
        dnssd_sock_t v28 = CFArrayGetValueAtIndex(a2, j);
        uint64_t v29 = CFArrayGetValueAtIndex(a2, j + 1);
        v24(a1, v28, v29);
      }
    }
  }
}

void _CFTypeUnscheduleFromMultipleRunLoops(void *a1, const __CFArray *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceRef RunLoopSource = (void *)CFRetain(a1);
LABEL_7:
    CFTypeRef v8 = RunLoopSource;
    CFAllocatorRef v9 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x1E4F1C298];
    goto LABEL_8;
  }
  if (v4 == CFMachPortGetTypeID())
  {
    CFAllocatorRef v6 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFMachPortCreateRunLoopSource(v6, (CFMachPortRef)a1, 0);
    goto LABEL_7;
  }
  if (v4 == CFSocketGetTypeID())
  {
    CFAllocatorRef v7 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v7, (CFSocketRef)a1, 0);
    goto LABEL_7;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  CFTypeID v16 = (void (*)(void *, const void *, const void *))CoreReadStreamUnscheduleFromRunLoop;
  if (v4 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    CFTypeID v16 = (void (*)(void *, const void *, const void *))CoreWriteStreamUnscheduleFromRunLoop;
    if (v4 != *(void *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
    {
      CFTypeID TypeID = CFReadStreamGetTypeID();
      CFTypeID v16 = (void (*)(void *, const void *, const void *))MEMORY[0x1E4F1C270];
      if (v4 != TypeID)
      {
        CFTypeID v18 = CFWriteStreamGetTypeID();
        CFTypeID v16 = (void (*)(void *, const void *, const void *))MEMORY[0x1E4F1C2D8];
        if (v4 != v18)
        {
          if (HostBase::Class(void)::sOnce_HostBase != -1) {
            dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
          }
          CFTypeID v16 = (void (*)(void *, const void *, const void *))CFHostUnscheduleFromRunLoop;
          if (v4 != *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
          {
            CFTypeID v19 = SCNetworkReachabilityGetTypeID();
            CFTypeID v16 = (void (*)(void *, const void *, const void *))MEMORY[0x1E4F41A98];
            if (v4 != v19)
            {
              if (v4 == CFRunLoopTimerGetTypeID())
              {
                CFTypeRef v8 = CFRetain(a1);
                CFAllocatorRef v9 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x1E4F1C2A0];
LABEL_8:
                CFTypeRef v10 = v9;
                if (v8)
                {
                  CFIndex Count = CFArrayGetCount(a2);
                  if (Count >= 1)
                  {
                    CFIndex v12 = Count;
                    for (CFIndex i = 0; i < v12; i += 2)
                    {
                      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
                      CFTypeID v15 = CFArrayGetValueAtIndex(a2, i + 1);
                      v10(ValueAtIndex, v8, v15);
                    }
                  }
                  CFRelease(v8);
                }
                return;
              }
              CFTypeID v26 = CFNetServiceGetTypeID();
              CFTypeID v16 = (void (*)(void *, const void *, const void *))CFNetServiceUnscheduleFromRunLoop;
              if (v4 != v26)
              {
                CFTypeID v27 = CFNetServiceBrowserGetTypeID();
                CFTypeID v16 = (void (*)(void *, const void *, const void *))CFNetServiceBrowserUnscheduleFromRunLoop;
                if (v4 != v27)
                {
                  CFTypeID v28 = CFNetServiceMonitorGetTypeID();
                  CFTypeID v16 = (void (*)(void *, const void *, const void *))CFNetServiceMonitorUnscheduleFromRunLoop;
                  if (v4 != v28)
                  {
                    CFTypeID v29 = SCNetworkConnectionGetTypeID();
                    CFTypeID v16 = (void (*)(void *, const void *, const void *))MEMORY[0x1E4F41A88];
                    if (v4 != v29) {
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  CFTypeID v20 = v16;
  CFIndex v21 = CFArrayGetCount(a2);
  if (v21 >= 1)
  {
    CFIndex v22 = v21;
    for (CFIndex j = 0; j < v22; j += 2)
    {
      uint64_t v24 = CFArrayGetValueAtIndex(a2, j);
      CFIndex v25 = CFArrayGetValueAtIndex(a2, j + 1);
      v20(a1, v24, v25);
    }
  }
}

void _CFTypeInvalidate(char *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceInvalidate((CFRunLoopSourceRef)a1);
  }
  else if (v2 == CFMachPortGetTypeID())
  {
    CFMachPortInvalidate((CFMachPortRef)a1);
  }
  else if (v2 == CFSocketGetTypeID())
  {
    CFSocketInvalidate((CFSocketRef)a1);
  }
  else
  {
    if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
      dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    }
    if (v2 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)) {
      goto LABEL_19;
    }
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    }
    if (v2 == *(void *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
    {
LABEL_19:
      if (a1) {
        uint64_t v3 = a1 + 16;
      }
      else {
        uint64_t v3 = 0;
      }
      CFTypeID v4 = *(void (**)(void))(*(void *)v3 + 56);
      v4();
    }
    else if (v2 == CFReadStreamGetTypeID())
    {
      CFReadStreamSetClient((CFReadStreamRef)a1, 0, 0, 0);
    }
    else if (v2 == CFWriteStreamGetTypeID())
    {
      CFWriteStreamSetClient((CFWriteStreamRef)a1, 0, 0, 0);
    }
    else
    {
      if (HostBase::Class(void)::sOnce_HostBase != -1) {
        dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
      }
      if (v2 == *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
      {
        CFHostSetClient((CFHostRef)a1, 0, 0);
      }
      else if (v2 == SCNetworkReachabilityGetTypeID())
      {
        SCNetworkReachabilitySetCallback((SCNetworkReachabilityRef)a1, 0, 0);
      }
      else if (v2 == CFRunLoopTimerGetTypeID())
      {
        CFRunLoopTimerInvalidate((CFRunLoopTimerRef)a1);
      }
      else if (v2 == CFNetServiceGetTypeID())
      {
        CFNetServiceSetClient((CFNetServiceRef)a1, 0, 0);
      }
      else if (v2 == CFNetServiceBrowserGetTypeID())
      {
        CFNetServiceBrowserInvalidate((CFNetServiceBrowserRef)a1);
      }
      else if (v2 == CFNetServiceMonitorGetTypeID())
      {
        CFNetServiceMonitorInvalidate((CFNetServiceMonitorRef)a1);
      }
    }
  }
}

uint64_t _SchedulesAddRunLoopAndMode(const __CFArray *a1, const void *a2, const void *a3)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count)
  {
    CFIndex v7 = Count;
    v8.CFIndex location = 0;
    v8.CFIndex length = Count;
    do
    {
      FirstIndexOfunsigned int Value = CFArrayGetFirstIndexOfValue(a1, v8, a2);
      if (FirstIndexOfValue == -1) {
        break;
      }
      CFIndex v10 = FirstIndexOfValue;
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1, FirstIndexOfValue + 1);
      if (CFEqual(ValueAtIndex, a3)) {
        return 0;
      }
      v8.CFIndex location = v10 + 2;
      v8.CFIndex length = v7 - (v10 + 2);
    }
    while (v7 != v10 + 2);
  }
  CFArrayAppendValue(a1, a2);
  CFArrayAppendValue(a1, a3);
  return 1;
}

CFIndex _SchedulesRemoveRunLoopAndMode(const __CFArray *a1, const void *a2, const void *a3)
{
  CFIndex result = CFArrayGetCount(a1);
  if (result)
  {
    CFIndex v7 = result;
    v8.CFIndex location = 0;
    v8.CFIndex length = result;
    while (1)
    {
      FirstIndexOfunsigned int Value = CFArrayGetFirstIndexOfValue(a1, v8, a2);
      if (FirstIndexOfValue == -1) {
        return 0;
      }
      CFIndex v10 = FirstIndexOfValue;
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1, FirstIndexOfValue + 1);
      if (CFEqual(ValueAtIndex, a3)) {
        break;
      }
      v8.CFIndex location = v10 + 2;
      v8.CFIndex length = v7 - (v10 + 2);
      if (v7 == v10 + 2) {
        return 0;
      }
    }
    v12.CFIndex location = v10;
    v12.CFIndex length = 2;
    CFArrayReplaceValues(a1, v12, 0, 0);
    return 1;
  }
  return result;
}

uint64_t _SchedulesFind(const __CFArray *a1, const void *a2, const void *a3)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    return -1;
  }
  CFIndex v7 = Count;
  v8.CFIndex location = 0;
  v8.CFIndex length = Count;
  while (1)
  {
    FirstIndexOfunsigned int Value = CFArrayGetFirstIndexOfValue(a1, v8, a2);
    CFIndex v10 = FirstIndexOfValue;
    if (FirstIndexOfValue == -1) {
      break;
    }
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1, FirstIndexOfValue + 1);
    if (CFEqual(ValueAtIndex, a3)) {
      break;
    }
    v8.CFIndex location = v10 + 2;
    v8.CFIndex length = v7 - (v10 + 2);
    if (v7 == v10 + 2) {
      return -1;
    }
  }
  return v10;
}

void sub_1841A9864(_Unwind_Exception *a1)
{
  CFTypeID v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1841A9A6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1841A9B14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841AA540(_Unwind_Exception *a1)
{
  CFAllocatorRef v9 = v8;

  _Unwind_Resume(a1);
}

void ___ZL22supportedDraftVersionsv_block_invoke()
{
  uint64_t v0 = objc_msgSend(MEMORY[0x1E4F1CA80], "setWithObjects:", @"3", @"6", 0);
  uint64_t v1 = (void *)supportedDraftVersions(void)::supportedDraftVersions;
  supportedDraftVersions(void)::supportedDraftVersions = v0;
}

void ___ZL17resumeDataClassesv_block_invoke_1669()
{
  uint64_t v0 = (void *)MEMORY[0x1E4F1CA80];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, objc_opt_class(), 0);
  CFRange v8 = (void *)resumeDataClasses(void)::resumeDataClasses;
  resumeDataClasses(void)::resumeDataClasses = v7;
}

void sub_1841AA858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841AA980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  _Unwind_Resume(a1);
}

void sub_1841AAC6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841AB050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  _Unwind_Resume(a1);
}

void AuthLiaison::~AuthLiaison(AuthLiaison *this)
{
  AuthLiaison::~AuthLiaison(this);

  JUMPOUT(0x18531B6D0);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1ECF9A9A0;
  (*(void (**)(void))(**((void **)this + 5) + 24))(*((void *)this + 5));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  *(void *)this = &unk_1ECF9B550;
}

void sub_1841AB198(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (std::__shared_weak_count *)v1[6];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)v1[4];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)v1[2];
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(exception_object);
}

void AuthLiaison::negotiateAuthentication(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  *(void *)(a1 + 4dispatch_get_global_queue(0, 0) = a2;
  *(void *)(a1 + 48) = a3;
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    a2 = *(void *)(a1 + 40);
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2))
  {
    uint64_t v5 = (const void *)(*(uint64_t (**)(void))(**(void **)(a1 + 40) + 32))(*(void *)(a1 + 40));
    CFRetain(v5);
  }
  operator new();
}

void sub_1841AB82C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  CFIndex v35 = *(std::__shared_weak_count **)(v33 - 104);
  if (v35) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v35);
  }
  if (v32)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v32);
    std::__shared_weak_count::__release_shared[abi:nn180100](v32);
  }
  _Block_object_dispose(&a31, 8);
  std::__shared_weak_count::__release_shared[abi:nn180100](v31);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__1737(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void ___ZN11AuthLiaison23negotiateAuthenticationENSt3__110shared_ptrI14MetaAuthClientEENS1_I12NetworkProxyEENS1_I18HTTPRequestMessageEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJS7_13CFStreamErrorEE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*(void *)a2
    && (uint64_t v4 = *(void *)(a1 + 40),
        AuthenticationState::canApplyHeadersToRequest(*(AuthenticationState **)a2, *(HTTPRequestMessage **)(a1 + 48))))
  {
    uint64_t v5 = *(AuthenticationState **)a2;
    uint64_t v6 = *(void *)(a2 + 8);
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v7 = *(std::__shared_weak_count **)(v4 + 32);
    *(void *)(v4 + 24) = v5;
    *(void *)(v4 + 32) = v6;
    if (v7)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
      uint64_t v5 = *(AuthenticationState **)(v4 + 24);
    }
    if ((*(unsigned int (**)(AuthenticationState *, void, uint64_t, uint64_t))(*(void *)v5 + 24))(v5, *(void *)(a1 + 48), v4, 1))
    {
      if (UnitTestNotificationCenter::shared(void)::onceToken != -1) {
        dispatch_once(&UnitTestNotificationCenter::shared(void)::onceToken, &__block_literal_global_1742);
      }
      NotificationStation::notifyPropertyChanged((NotificationStation *)UnitTestNotificationCenter::shared(void)::shared, @"AuthBrokerQueryCount", (const void *)*MEMORY[0x1E4F1CFD0]);
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFRange v8 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(a1 + 64);
        LODWORD(v24) = 138543362;
        *(void *)((char *)&v24 + 4) = v9;
        _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "Applied proxy auth to %{public}@", (uint8_t *)&v24, 0xCu);
      }
    }
    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFIndex v21 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        uint64_t v22 = *(void *)(a1 + 64);
        LODWORD(v24) = 138543362;
        *(void *)((char *)&v24 + 4) = v22;
        _os_log_error_impl(&dword_184085000, v21, OS_LOG_TYPE_ERROR, "Failed to apply proxy auth to %{public}@", (uint8_t *)&v24, 0xCu);
      }
    }
  }
  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFIndex v10 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = *(void *)(a1 + 64);
      LODWORD(v24) = 138543362;
      *(void *)((char *)&v24 + 4) = v23;
      _os_log_error_impl(&dword_184085000, v10, OS_LOG_TYPE_ERROR, "Failed to get applicable proxy auth %{public}@", (uint8_t *)&v24, 0xCu);
    }
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
    *(void *)(v11 + 48) = 4;
    *(_DWORD *)(v11 + 56) = -2097;
  }
  uint64_t v12 = *(void *)(a1 + 48);
  CFStringRef v13 = *(std::__shared_weak_count **)(a1 + 56);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = *(void *)(a1 + 80);
  if (!v14)
  {
    if (!v13) {
      return;
    }
    goto LABEL_35;
  }
  uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v16 = *(void *)(v15 + 48);
  uint64_t v17 = *(void *)(v15 + 56);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CFTypeID v18 = *(void (**)(void *, long long *, uint64_t, uint64_t))(v14 + 8);
  uint64_t v19 = *(void *)(v14 + 16);
  CFTypeID v20 = (void *)(v14 + (v19 >> 1));
  if (v19) {
    CFTypeID v18 = *(void (**)(void *, long long *, uint64_t, uint64_t))(*v20 + v18);
  }
  *(void *)&long long v24 = v12;
  *((void *)&v24 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v18(v20, &v24, v16, v17);
  if (*((void *)&v24 + 1)) {
    std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v24 + 1));
  }
  if (v13)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v13);
LABEL_35:
    std::__shared_weak_count::__release_shared[abi:nn180100](v13);
  }
}

void sub_1841ABC78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs()
{
}

void sub_1841ABD6C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<AuthenticationState>> *,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<AuthenticationState>>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v3 = *(void (**)(uint64_t *, uint64_t *))(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | (unint64_t)v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if (v3 == BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial && v5 != 0)
  {
    uint64_t v7 = (uint64_t *)(v1 + (v2 >> 1));
    if (v2) {
      CFRange v8 = *(void (**)(uint64_t *, uint64_t *))(*v7
    }
                                                       + BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial);
    else {
      CFRange v8 = BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial;
    }
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    v8(v7, &v10);
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
  }
  _Block_release(*(const void **)v1);
  return MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
}

void sub_1841ABE6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<AuthenticationState>> *,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<AuthenticationState>>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial(uint64_t *a1, uint64_t *a2)
{
  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_normal;
  a1[2] = 0;
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  int v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_1841ABF30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_normal(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  int v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_1841ABFA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c46_ZTSNSt3__110shared_ptrI18HTTPRequestMessageEE64c39_ZTSNSt3__110shared_ptrIK10__CFStringEE80c85_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI18HTTPRequestMessageEE13CFStreamErrorEE(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[7];
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void *__copy_helper_block_e8_48c46_ZTSNSt3__110shared_ptrI18HTTPRequestMessageEE64c39_ZTSNSt3__110shared_ptrIK10__CFStringEE80c85_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI18HTTPRequestMessageEE13CFStreamErrorEE(void *result, void *a2)
{
  uint64_t v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[9];
  result[8] = a2[8];
  result[9] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[11];
  result[10] = a2[10];
  result[11] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN26UnitTestNotificationCenter6sharedEv_block_invoke_1751()
{
}

void std::__shared_ptr_pointer<__CFString const*,Deleter_CFRelease,std::allocator<__CFString const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

CFStringRef _ServiceCopyDebugDesc(__CFNetService *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), 0);
  int v5 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)4);
  uint64_t v6 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)2);
  uint64_t v7 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)1);
  CFRange v8 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)3);
  CFStringRef v9 = CFStringCreateWithFormat(v3, 0, @"<CFNetService %p>{domain=%@, type=%@, name=%@, specific=%@, addresses=%@}", a1, Value, v5, v6, v7, v8);
  os_unfair_lock_unlock(v2);
  return v9;
}

CFHashCode _ServiceHash(__CFNetService *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)2);
  CFHashCode v4 = CFHash(Value);
  if (CFEqual(Value, &stru_1ECFAD558))
  {
    CFStringRef v5 = SCDynamicStoreCopyComputerName(0, 0);
    if (v5)
    {
      CFStringRef v6 = v5;
      CFHashCode v4 = CFHash(v5);
      CFRelease(v6);
    }
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

BOOL _ServiceEqual(__CFNetService *a1, __CFNetService *a2)
{
  CFHashCode v4 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  CFStringRef v5 = (os_unfair_lock_s *)((char *)a2 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 4);
  unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)4);
  uint64_t v7 = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), (const void *)4);
  if (!CFEqual(Value, v7)) {
    goto LABEL_19;
  }
  CFRange v8 = (__CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), 0);
  CFStringRef v9 = (__CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), 0);
  if (CFEqual(v8, &stru_1ECFAD558)) {
    CFRange v8 = &stru_1ECFAD558;
  }
  uint64_t v10 = CFEqual(v9, &stru_1ECFAD558) ? &stru_1ECFAD558 : v9;
  if (!CFEqual(v8, v10)) {
    goto LABEL_19;
  }
  uint64_t v11 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)2);
  CFStringRef v12 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), (const void *)2);
  if (CFEqual(v11, v12))
  {
    BOOL v13 = 1;
    goto LABEL_20;
  }
  if (!CFEqual(v11, &stru_1ECFAD558) && !CFEqual(v12, &stru_1ECFAD558)
    || (CFStringRef v14 = SCDynamicStoreCopyComputerName(0, 0)) == 0)
  {
LABEL_19:
    BOOL v13 = 0;
    goto LABEL_20;
  }
  CFStringRef v15 = v14;
  if (CFEqual(v11, &stru_1ECFAD558)) {
    uint64_t v11 = v15;
  }
  if (CFEqual(v12, &stru_1ECFAD558)) {
    CFStringRef v16 = v15;
  }
  else {
    CFStringRef v16 = v12;
  }
  BOOL v13 = CFEqual(v11, v16) != 0;
  CFRelease(v15);
LABEL_20:
  os_unfair_lock_unlock(v4);
  os_unfair_lock_unlock(v5);
  return v13;
}

void _ServiceDestroy(os_unfair_lock_s *a1)
{
  uint64_t v2 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  if (*(void *)&a1[30]._os_unfair_lock_opaque)
  {
    CFAllocatorRef v3 = *(void (**)(void))&a1[34]._os_unfair_lock_opaque;
    if (v3) {
      v3();
    }
  }
  _CleanupService_NoLock((__CFNetService *)a1);
  CFHashCode v4 = *(const void **)&a1[22]._os_unfair_lock_opaque;
  if (v4) {
    CFRelease(v4);
  }
  CFStringRef v5 = *(const void **)&a1[20]._os_unfair_lock_opaque;
  if (v5) {
    CFRelease(v5);
  }
  CFStringRef v6 = *(const void **)&a1[12]._os_unfair_lock_opaque;
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = *(const void **)&a1[16]._os_unfair_lock_opaque;
  if (v7) {
    CFRelease(v7);
  }
  CFRange v8 = *(const void **)&a1[24]._os_unfair_lock_opaque;
  if (v8) {
    CFRelease(v8);
  }

  os_unfair_lock_unlock(v2);
}

void _CleanupService_NoLock(__CFNetService *a1)
{
  if (CFArrayGetCount(*((CFArrayRef *)a1 + 8)))
  {
    CFArrayRef v2 = (const __CFArray *)*((void *)a1 + 12);
    if (v2) {
      _UnscheduleSources(*((const __CFArray **)a1 + 8), v2);
    }
    _InvalidateSources(*((__CFArray **)a1 + 8));
  }
  CFAllocatorRef v3 = (_DNSServiceRef_t *)*((void *)a1 + 9);
  if (v3)
  {
    DNSServiceRefDeallocate(v3);
    *((void *)a1 + 9) = 0;
  }
  CFHashCode v4 = (const void *)*((void *)a1 + 5);
  if (v4)
  {
    CFRelease(v4);
    *((void *)a1 + 5) = 0;
  }
  CFStringRef v5 = (__CFSet *)*((void *)a1 + 11);

  CFSetRemoveAllValues(v5);
}

void _UnscheduleSources(const __CFArray *a1, const __CFArray *a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0; i != v5; ++i)
    {
      CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      _CFTypeUnscheduleFromMultipleRunLoops(ValueAtIndex, a2);
    }
  }
}

void _InvalidateSources(__CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i != v3; ++i)
    {
      CFDictionaryRef ValueAtIndex = (char *)CFArrayGetValueAtIndex(a1, i);
      _CFTypeInvalidate(ValueAtIndex);
    }
  }

  CFArrayRemoveAllValues(a1);
}

CFNetServiceRef CFNetServiceCreate(CFAllocatorRef alloc, CFStringRef domain, CFStringRef serviceType, CFStringRef name, SInt32 port)
{
  uint64_t v5 = 0;
  if (domain && serviceType && name)
  {
    if (!CFNetServiceGetTypeID()) {
      return 0;
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v5 = Instance;
    if (Instance)
    {
      memset(&keyCallBacks, 0, sizeof(keyCallBacks));
      memset(&v16, 0, sizeof(v16));
      *(_OWORD *)(Instance + 8dispatch_get_global_queue(0, 0) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(void *)(Instance + 144) = 0;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(void *)(Instance + 48) = CFDictionaryCreateMutable(alloc, 0, &keyCallBacks, MEMORY[0x1E4F1D540]);
      *(void *)(v5 + 8dispatch_get_global_queue(0, 0) = CFDictionaryCreateMutable(alloc, 0, &keyCallBacks, &v16);
      *(void *)(v5 + 88) = CFSetCreateMutable(alloc, 0, MEMORY[0x1E4F1D548]);
      CFStringRef v12 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
      *(void *)(v5 + 96) = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(alloc, 0, v12);
      *(void *)(v5 + 64) = Mutable;
      CFStringRef v14 = *(__CFDictionary **)(v5 + 48);
      if (v14 && *(void *)(v5 + 96) && *(void *)(v5 + 80) && Mutable)
      {
        CFDictionaryAddValue(v14, 0, domain);
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v5 + 48), (const void *)4, serviceType);
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v5 + 48), (const void *)2, name);
        *(_DWORD *)(v5 + 56) = port;
        return (CFNetServiceRef)v5;
      }
      CFRelease((CFTypeRef)v5);
      return 0;
    }
  }
  return (CFNetServiceRef)v5;
}

CFNetServiceRef CFNetServiceCreateCopy(CFAllocatorRef alloc, CFNetServiceRef service)
{
  CFTypeID TypeID = (void *)CFNetServiceGetTypeID();
  os_unfair_lock_lock((os_unfair_lock_t)service + 4);
  if (TypeID)
  {
    uint64_t Instance = _CFRuntimeCreateInstance();
    CFTypeID TypeID = (void *)Instance;
    if (Instance)
    {
      memset(&keyCallBacks, 0, sizeof(keyCallBacks));
      memset(&v12, 0, sizeof(v12));
      *(_OWORD *)(Instance + 8dispatch_get_global_queue(0, 0) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(void *)(Instance + 144) = 0;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(void *)(Instance + 48) = CFDictionaryCreateMutable(alloc, 0, &keyCallBacks, MEMORY[0x1E4F1D540]);
      TypeID[10] = CFDictionaryCreateMutable(alloc, 0, &keyCallBacks, &v12);
      CFStringRef v6 = (void *)TypeID[6];
      if (v6) {
        CFDictionaryApplyFunction(*((CFDictionaryRef *)service + 6), (CFDictionaryApplierFunction)_DictionaryApplier, v6);
      }
      TypeID[11] = CFSetCreateMutable(alloc, 0, MEMORY[0x1E4F1D548]);
      uint64_t v7 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
      TypeID[12] = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(alloc, 0, v7);
      TypeID[8] = Mutable;
      CFDictionaryRef v9 = (const __CFDictionary *)TypeID[6];
      if (!v9
        || !TypeID[12]
        || !Mutable
        || !TypeID[10]
        || (CFIndex Count = CFDictionaryGetCount(v9), Count != CFDictionaryGetCount(*((CFDictionaryRef *)service + 6))))
      {
        CFRelease(TypeID);
        CFTypeID TypeID = 0;
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)service + 4);
  return (CFNetServiceRef)TypeID;
}

void _DictionaryApplier(const void *a1, const __CFString *cf, void *a3)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFStringGetTypeID())
  {
    CFAllocatorRef v7 = CFGetAllocator(a3);
    CFStringRef Copy = CFStringCreateCopy(v7, cf);
    if (!Copy) {
      return;
    }
LABEL_3:
    CFDictionaryRef v9 = Copy;
    CFDictionaryAddValue((CFMutableDictionaryRef)a3, a1, Copy);
    CFRelease(v9);
    return;
  }
  if (v6 == CFArrayGetTypeID())
  {
    CFAllocatorRef v10 = CFGetAllocator(a3);
    CFStringRef Copy = CFArrayCreateCopy(v10, (CFArrayRef)cf);
    if (!Copy) {
      return;
    }
    goto LABEL_3;
  }

  CFDictionaryAddValue((CFMutableDictionaryRef)a3, a1, cf);
}

CFStringRef CFNetServiceGetDomain(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 0);
}

const void *CFNetServiceGetInfo(uint64_t a1, unsigned int a2)
{
  CFHashCode v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  unsigned int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), (const void *)a2);
  os_unfair_lock_unlock(v4);
  return Value;
}

CFStringRef CFNetServiceGetType(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 4u);
}

CFStringRef CFNetServiceGetName(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 2u);
}

CFArrayRef CFNetServiceGetAddressing(CFNetServiceRef theService)
{
  return (CFArrayRef)CFNetServiceGetInfo((uint64_t)theService, 3u);
}

CFStringRef CFNetServiceGetTargetHost(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 5u);
}

SInt32 CFNetServiceGetPortNumber(CFNetServiceRef theService)
{
  return *((_DWORD *)theService + 14);
}

CFDataRef CFNetServiceGetTXTData(CFNetServiceRef theService)
{
  CFDataRef result = (CFDataRef)CFNetServiceGetInfo((uint64_t)theService, 1u);
  if (result)
  {
    CFDataRef v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFDataGetTypeID()) {
      return v2;
    }
    else {
      return 0;
    }
  }
  return result;
}

Boolean CFNetServiceSetTXTData(CFNetServiceRef theService, CFDataRef txtRecord)
{
  return _ServiceSetInfo(theService, 1u, txtRecord, 1);
}

uint64_t _ServiceSetInfo(__CFNetService *a1, unsigned int a2, const void *a3, int a4)
{
  CFRange v8 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if ((*((unsigned char *)a1 + 20) & 2) != 0)
  {
LABEL_27:
    uint64_t v11 = 0;
    goto LABEL_29;
  }
  CFDictionaryRef v9 = (__CFDictionary *)*((void *)a1 + 6);
  unint64_t v10 = a2;
  if (a3) {
    CFDictionarySetValue(v9, (const void *)a2, a3);
  }
  else {
    CFDictionaryRemoveValue(v9, (const void *)a2);
  }
  if (a2 == 8)
  {
    int valuePtr = 0;
    uint64_t v11 = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, &valuePtr);
    *((_DWORD *)a1 + 14) = valuePtr;
    goto LABEL_29;
  }
  if (!a4 || (CFDictionaryValueCallBacks v12 = (_DNSServiceRef_t *)*((void *)a1 + 9)) == 0)
  {
LABEL_28:
    uint64_t v11 = 1;
    goto LABEL_29;
  }
  if (a2 != 1)
  {
    if ((a2 & 0xFFFF0000) == 0x10000)
    {
      CFStringRef v15 = (_DNSRecordRef_t *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 10), (const void *)a2);
      CFDictionaryValueCallBacks v16 = v15;
      value = v15;
      if (a3)
      {
        uint64_t v17 = (_DNSServiceRef_t *)*((void *)a1 + 9);
        if (v15)
        {
          uint16_t Length = CFDataGetLength((CFDataRef)a3);
          BytePtr = CFDataGetBytePtr((CFDataRef)a3);
          DNSServiceErrorType updated = DNSServiceUpdateRecord(v17, v16, 0, Length, BytePtr, 0);
        }
        else
        {
          uint64_t v21 = (unsigned __int16)CFDataGetLength((CFDataRef)a3);
          uint64_t v22 = CFDataGetBytePtr((CFDataRef)a3);
          DNSServiceErrorType updated = DNSServiceAddRecord(v17, (DNSRecordRef *)&value, 0, a2, v21, v22, 0);
          CFDictionaryAddValue(*((CFMutableDictionaryRef *)a1 + 10), (const void *)a2, value);
        }
      }
      else
      {
        DNSServiceErrorType updated = v15 ? DNSServiceRemoveRecord(*((DNSServiceRef *)a1 + 9), v15, 0) : 0;
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a1 + 10), (const void *)a2);
      }
      if (updated)
      {
        if (value) {
          DNSServiceRemoveRecord(*((DNSServiceRef *)a1 + 9), (DNSRecordRef)value, 0);
        }
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a1 + 10), (const void *)v10);
        goto LABEL_27;
      }
    }
    goto LABEL_28;
  }
  if (a3)
  {
    uint16_t v13 = CFDataGetLength((CFDataRef)a3);
    CFStringRef v14 = CFDataGetBytePtr((CFDataRef)a3);
  }
  else
  {
    uint16_t v13 = 0;
    CFStringRef v14 = 0;
  }
  uint64_t v11 = DNSServiceUpdateRecord(v12, 0, 0, v13, v14, 0) == 0;
LABEL_29:
  os_unfair_lock_unlock(v8);
  return v11;
}

uint64_t CFNetServiceSetInfo(__CFNetService *a1, unsigned int a2, const void *a3)
{
  return _ServiceSetInfo(a1, a2, a3, 1);
}

Boolean CFNetServiceRegisterWithOptions(CFNetServiceRef theService, CFOptionFlags options, CFStreamError *error)
{
  int v3 = options;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  int v5 = -72008;
  CFTypeID v6 = (CFStreamError *)&v38;
  if (error) {
    CFTypeID v6 = error;
  }
  v6->CFIndex domain = 0;
  *(void *)&v6->SInt32 error = 0;
  int v34 = v6;
  CFRetain(theService);
  lock = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  context.version = 0;
  context.info = theService;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
  context.copyDescription = 0;
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)1);
  if (CFArrayGetCount(*((CFArrayRef *)theService + 8)))
  {
    if ((*((unsigned char *)theService + 20) & 8) != 0)
    {
      _UnscheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
      _InvalidateSources(*((__CFArray **)theService + 8));
    }
    else
    {
      *((void *)theService + 3) = 10;
      *((_DWORD *)theService + 8) = -72003;
    }
  }
  uint64_t v8 = 0;
  CFDictionaryRef v9 = dword_18430BA98;
  do
  {
    unsigned int v10 = *v9++;
    CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)v10);
    if (v11)
    {
      CFStringRef v12 = v11;
      CFIndex usedBufLen = 0;
      v43.CFIndex length = CFStringGetLength(v11);
      v43.CFIndex location = 0;
      CFStringGetBytes(v12, v43, 0x8000100u, 0, 0, (UInt8 *)&name[v8], 1023, (CFIndex *)&usedBufLen);
      name[v8 + (void)usedBufLen] = 0;
    }
    else
    {
      name[v8] = 0;
    }
    v8 += 1024;
  }
  while (v8 != 3072);
  DNSServiceFlags v13 = v3 & 0x120800 | (8 * (v3 & 1));
  CFBooleanRef v14 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)7);
  if (v14 && CFBooleanGetValue(v14)) {
    v13 |= 0x100000u;
  }
  CFBooleanRef v15 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)9);
  if (v15 && CFBooleanGetValue(v15)) {
    v13 |= 0x100000u;
  }
  if ((v3 & 0x200000) != 0 && (CFIndex usedBufLen = 0, !getifaddrs(&usedBufLen)))
  {
    uint64_t v22 = usedBufLen;
    if (usedBufLen)
    {
      uint32_t v16 = 0;
      do
      {
        if (v22->ifa_addr->sa_family == 30)
        {
          ifa_name = v22->ifa_name;
          if (!strncasecmp(ifa_name, "awdl0", 5uLL)) {
            uint32_t v16 = if_nametoindex(ifa_name);
          }
        }
        uint64_t v22 = v22->ifa_next;
      }
      while (v22);
      long long v24 = usedBufLen;
    }
    else
    {
      long long v24 = 0;
      uint32_t v16 = 0;
    }
    MEMORY[0x18531BE20](v24);
  }
  else
  {
    uint32_t v16 = 0;
  }
  unsigned int v17 = bswap32(*((unsigned __int16 *)theService + 28)) >> 16;
  if (Value)
  {
    uint16_t Length = CFDataGetLength(Value);
    txtRecord = CFDataGetBytePtr(Value);
  }
  else
  {
    uint16_t Length = 0;
    txtRecord = 0;
  }
  DNSServiceErrorType v20 = DNSServiceRegister((DNSServiceRef *)theService + 9, v13, v16, name, v40, v41, 0, v17, Length, txtRecord, (DNSServiceRegisterReply)_RegisterReply, theService);
  *((_DWORD *)theService + 8) = v20;
  if (v20 <= -65549)
  {
    uint64_t v21 = (os_unfair_lock_s *)((char *)theService + 16);
    if (v20 == -65555) {
      goto LABEL_46;
    }
    if (v20 == -65554)
    {
      int v5 = -72002;
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  uint64_t v21 = (os_unfair_lock_s *)((char *)theService + 16);
  if (v20 == -65548)
  {
    int v5 = -72001;
    goto LABEL_46;
  }
  if (v20)
  {
    if (v20 == -65540)
    {
      int v5 = -72004;
LABEL_46:
      LOBYTE(v26) = 0;
      *((void *)theService + 3) = 10;
      *((_DWORD *)theService + 8) = v5;
LABEL_47:
      CFTypeID v27 = v34;
      goto LABEL_48;
    }
LABEL_45:
    int v5 = -72000;
    goto LABEL_46;
  }
  CFDictionaryApplyFunction(*((CFDictionaryRef *)theService + 6), (CFDictionaryApplierFunction)_AddRecords, theService);
  int v25 = *((_DWORD *)theService + 8);
  if (v25 <= -65549)
  {
    if (v25 == -65555) {
      goto LABEL_59;
    }
    if (v25 == -65554)
    {
      int v5 = -72002;
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  if (v25 == -65548)
  {
    int v5 = -72001;
    goto LABEL_59;
  }
  if (v25)
  {
    if (v25 == -65540)
    {
      int v5 = -72004;
LABEL_59:
      *((void *)theService + 3) = 10;
      *((_DWORD *)theService + 8) = v5;
      DNSServiceRefDeallocate(*((DNSServiceRef *)theService + 9));
      *((void *)theService + 9) = 0;
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)theService + 10));
      LOBYTE(v26) = 0;
      goto LABEL_47;
    }
LABEL_58:
    int v5 = -72000;
    goto LABEL_59;
  }
  CFAllocatorRef v29 = CFGetAllocator(theService);
  dnssd_sock_t v30 = DNSServiceRefSockFD(*((DNSServiceRef *)theService + 9));
  CFStringRef v31 = CFSocketCreateWithNative(v29, v30, 1uLL, (CFSocketCallBack)_SocketCallBack_NetService, &context);
  CFTypeID v26 = v31;
  if (!v31)
  {
    int v33 = *__error();
    *((void *)theService + 3) = 1;
    *((_DWORD *)theService + 8) = v33;
    DNSServiceRefDeallocate(*((DNSServiceRef *)theService + 9));
    *((void *)theService + 9) = 0;
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)theService + 10));
    goto LABEL_47;
  }
  CFOptionFlags SocketFlags = CFSocketGetSocketFlags(v31);
  CFSocketSetSocketFlags(v26, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
  CFArrayAppendValue(*((CFMutableArrayRef *)theService + 8), v26);
  CFRelease(v26);
  *((_DWORD *)theService + 8) = 0;
  *((void *)theService + 3) = 0;
  *((unsigned char *)theService + 20) |= 4u;
  CFTypeID v27 = v34;
  if (CFArrayGetCount(*((CFArrayRef *)theService + 12)))
  {
    _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    LOBYTE(v26) = 1;
  }
  else
  {
    os_unfair_lock_unlock(lock);
    LOBYTE(v26) = _ServiceBlockUntilComplete(theService);
    os_unfair_lock_lock(lock);
  }
LABEL_48:
  *CFTypeID v27 = *(CFStreamError *)((char *)theService + 24);
  os_unfair_lock_unlock(v21);
  CFRelease(theService);
  return v26;
}

void _ScheduleSources(const __CFArray *a1, const __CFArray *a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0; i != v5; ++i)
    {
      CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      _CFTypeScheduleOnMultipleRunLoops(ValueAtIndex, a2);
    }
  }
}

BOOL _ServiceBlockUntilComplete(__CFNetService *a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  CFNetServiceScheduleWithRunLoop(a1, Current, @"_kCFNetServiceBlockingMode");
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  while (CFArrayGetCount(*((CFArrayRef *)a1 + 8)))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
    CFRunLoopRunInMode(@"_kCFNetServiceBlockingMode", 1.79769313e308, 1u);
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  }
  BOOL v3 = *((_DWORD *)a1 + 8) == 0;
  os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  CFNetServiceUnscheduleFromRunLoop(a1, Current, @"_kCFNetServiceBlockingMode");
  return v3;
}

void CFNetServiceScheduleWithRunLoop(CFNetServiceRef theService, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  CFTypeID v6 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (_SchedulesAddRunLoopAndMode(*((const __CFArray **)theService + 12), runLoop, runLoopMode))
  {
    CFIndex Count = CFArrayGetCount(*((CFArrayRef *)theService + 8));
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      for (CFIndex i = 0; i != v8; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)theService + 8), i);
        _CFTypeScheduleOnRunLoop(ValueAtIndex, runLoop, runLoopMode);
      }
    }
  }

  os_unfair_lock_unlock(v6);
}

void CFNetServiceUnscheduleFromRunLoop(CFNetServiceRef theService, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  CFTypeID v6 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)theService + 12), runLoop, runLoopMode))
  {
    CFIndex Count = CFArrayGetCount(*((CFArrayRef *)theService + 8));
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      for (CFIndex i = 0; i != v8; ++i)
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)theService + 8), i);
        _CFTypeUnscheduleFromRunLoop(ValueAtIndex, runLoop, runLoopMode);
      }
    }
  }

  os_unfair_lock_unlock(v6);
}

void _SocketCallBack_NetService(__CFSocket *a1, unint64_t a2, const __CFData *a3, const void *a4, char *cf)
{
  CFRetain(cf);
  DNSServiceErrorType v6 = DNSServiceProcessResult(*((DNSServiceRef *)cf + 9));
  if (!v6) {
    goto LABEL_13;
  }
  int v7 = -72008;
  long long v10 = xmmword_1843D1730;
  if (v6 <= -65549)
  {
    if (v6 == -65555) {
      goto LABEL_11;
    }
    if (v6 == -65554)
    {
      int v7 = -72002;
      goto LABEL_11;
    }
LABEL_9:
    int v7 = -72000;
    goto LABEL_11;
  }
  if (v6 != -65548)
  {
    if (v6 == -65540)
    {
      int v7 = -72004;
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  int v7 = -72001;
LABEL_11:
  DWORD2(v1dispatch_get_global_queue(0, 0) = v7;
  os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
  _CleanupService_NoLock((__CFNetService *)cf);
  cf[20] &= 0xF9u;
  CFIndex v8 = (void (*)(char *, long long *, uint64_t))*((void *)cf + 13);
  uint64_t v9 = *((void *)cf + 15);
  *(_OWORD *)(cf + 24) = v10;
  os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  if (v8) {
    v8(cf, &v10, v9);
  }
LABEL_13:
  CFRelease(cf);
}

void _AddRecords(const void *a1, CFDataRef theData, void *a3)
{
  if ((a1 & 0xFFFF0000) == 0x10000)
  {
    RecordRef[7] = v3;
    RecordRef[8] = v4;
    if (!*((_DWORD *)a3 + 8))
    {
      RecordRef[0] = 0;
      CFIndex v8 = (_DNSServiceRef_t *)*((void *)a3 + 9);
      uint16_t Length = CFDataGetLength(theData);
      BytePtr = CFDataGetBytePtr(theData);
      DNSServiceErrorType v11 = DNSServiceAddRecord(v8, RecordRef, 0, (uint16_t)a1, Length, BytePtr, 0);
      *((_DWORD *)a3 + 8) = v11;
      if (!v11) {
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)a3 + 10), a1, RecordRef[0]);
      }
    }
  }
}

void _RegisterReply(_DNSServiceRef_t *a1, unsigned int a2, int a3, const char *a4, const char *a5, const char *a6, char *cf)
{
  v21[3] = *MEMORY[0x1E4F143B8];
  if (a3 != -65570)
  {
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    if (!*((void *)cf + 9))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
LABEL_24:
      CFRelease(cf);
      return;
    }
    CFAllocatorRef v12 = CFGetAllocator(cf);
    v21[0] = a4;
    v21[1] = a5;
    CFStringRef v21[2] = a6;
    if (!a3)
    {
LABEL_15:
      for (uint64_t i = 0; i != 3; ++i)
      {
        CFBooleanRef v15 = (const char *)v21[i];
        if (v15)
        {
          CFStringRef v16 = CFStringCreateWithCString(v12, v15, 0x8000100u);
          if (v16)
          {
            CFStringRef v17 = v16;
            CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 6), (const void *)dword_18430BA98[i], v16);
            CFRelease(v17);
          }
        }
      }
      CFTypeID v18 = (void (*)(char *, long long *, uint64_t))*((void *)cf + 13);
      long long v20 = *(_OWORD *)(cf + 24);
      uint64_t v19 = *((void *)cf + 15);
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
      if (v18 && (a3 || (cf[20] & 1) == 0)) {
        v18(cf, &v20, v19);
      }
      goto LABEL_24;
    }
    int v13 = -72008;
    if (a3 > -65549)
    {
      if (a3 == -65548)
      {
        int v13 = -72001;
        goto LABEL_14;
      }
      if (a3 == -65540)
      {
        int v13 = -72004;
        goto LABEL_14;
      }
    }
    else
    {
      if (a3 == -65555)
      {
LABEL_14:
        *((void *)cf + 3) = 10;
        *((_DWORD *)cf + 8) = v13;
        goto LABEL_15;
      }
      if (a3 == -65554)
      {
        int v13 = -72002;
        goto LABEL_14;
      }
    }
    int v13 = -72000;
    goto LABEL_14;
  }
}

Boolean CFNetServiceResolveWithTimeout(CFNetServiceRef theService, CFTimeInterval timeout, CFStreamError *error)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (error) {
    CFIndex v5 = error;
  }
  else {
    CFIndex v5 = (CFStreamError *)&v21;
  }
  v5->CFIndex domain = 0;
  *(void *)&v5->SInt32 error = 0;
  CFRetain(theService);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  *((void *)theService + 3) = 0;
  *((_DWORD *)theService + 8) = 0;
  if (CFArrayGetCount(*((CFArrayRef *)theService + 8)))
  {
    if ((*((unsigned char *)theService + 20) & 8) == 0)
    {
      Boolean v6 = 0;
      *((void *)theService + 3) = 10;
      *((_DWORD *)theService + 8) = -72003;
      goto LABEL_29;
    }
    _UnscheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    _InvalidateSources(*((__CFArray **)theService + 8));
    int v7 = (const void *)*((void *)theService + 5);
    if (v7)
    {
      CFRelease(v7);
      *((void *)theService + 5) = 0;
    }
  }
  if (*((_DWORD *)theService + 8))
  {
    Boolean v6 = 0;
    goto LABEL_29;
  }
  uint64_t v8 = 0;
  uint64_t v9 = &dword_18430BA98;
  do
  {
    unsigned int v10 = *v9++;
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)v10);
    if (Value)
    {
      CFStringRef v12 = Value;
      context.version = 0;
      v26.CFIndex length = CFStringGetLength(Value);
      v26.CFIndex location = 0;
      CFStringGetBytes(v12, v26, 0x8000100u, 0, 0, (UInt8 *)&v22[v8], 1023, &context.version);
      v22[v8 + context.version] = 0;
    }
    else
    {
      v22[v8] = 0;
    }
    v8 += 1024;
  }
  while (v8 != 3072);
  _ServiceCreateQuery_NoLock((CFDictionaryRef *)theService, 0, 0, v22, v23, v24);
  int v13 = *((_DWORD *)theService + 8);
  if (timeout > 0.0 && !v13)
  {
    context.version = 0;
    context.info = theService;
    memset(&context.retain, 0, 24);
    CFAbsoluteTime v14 = CFAbsoluteTimeGetCurrent() + timeout;
    CFAllocatorRef v15 = CFGetAllocator(theService);
    CFRunLoopTimerRef v16 = CFRunLoopTimerCreate(v15, v14, 0.0, 0, 0, (CFRunLoopTimerCallBack)_LongTimerCallBack, &context);
    if (!v16)
    {
      if (*__error())
      {
        int v18 = *__error();
        *((void *)theService + 3) = 1;
      }
      else
      {
        *((void *)theService + 3) = 1;
        int v18 = 12;
      }
      *((_DWORD *)theService + 8) = v18;
      if (v18) {
        goto LABEL_21;
      }
      goto LABEL_26;
    }
    CFRunLoopTimerRef v17 = v16;
    CFArrayAppendValue(*((CFMutableArrayRef *)theService + 8), v16);
    CFRelease(v17);
    int v13 = *((_DWORD *)theService + 8);
  }
  if (v13)
  {
LABEL_21:
    _InvalidateSources(*((__CFArray **)theService + 8));
    DNSServiceRefDeallocate(*((DNSServiceRef *)theService + 9));
    Boolean v6 = 0;
    *((void *)theService + 9) = 0;
    goto LABEL_29;
  }
LABEL_26:
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)theService + 6), (const void *)3);
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)theService + 6), (const void *)1);
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)theService + 6), (const void *)5);
  *((_DWORD *)theService + 14) = -1;
  *((unsigned char *)theService + 20) |= 2u;
  if (CFArrayGetCount(*((CFArrayRef *)theService + 12)))
  {
    _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    Boolean v6 = 1;
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)theService + 4);
    Boolean v6 = _ServiceBlockUntilComplete(theService);
    os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  }
LABEL_29:
  *CFIndex v5 = *(CFStreamError *)((char *)theService + 24);
  *((_DWORD *)theService + 8) = 0;
  *((void *)theService + 3) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)theService + 4);
  CFRelease(theService);
  return v6;
}

void _ServiceCreateQuery_NoLock(CFDictionaryRef *a1, uint64_t a2, unsigned int a3, const char *a4, const char *a5, const char *a6)
{
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a1[6], (const void *)7);
  if (Value) {
    int v13 = (CFBooleanGetValue(Value) != 0) << 20;
  }
  else {
    int v13 = 0;
  }
  CFBooleanRef v14 = (const __CFBoolean *)CFDictionaryGetValue(a1[6], (const void *)9);
  if (v14 && CFBooleanGetValue(v14)) {
    int v13 = 0x100000;
  }
  CFAllocatorRef v15 = a1 + 9;
  if (a3)
  {
    if (*v15)
    {
      CFAllocatorRef v16 = CFGetAllocator(a1);
      CFStringRef v17 = CFStringCreateWithCString(v16, a4, 0x8000100u);
      if (!v17) {
        goto LABEL_20;
      }
      CFStringRef v18 = v17;
      CFStringRef v19 = CFStringCreateWithFormat(v16, 0, @"%@%d.%d", v17, a3, a2);
      if (v19)
      {
        CFStringRef v20 = v19;
        CFIndex Length = CFStringGetLength(v19);
        MutableCFStringRef Copy = CFStringCreateMutableCopy(v16, Length, v20);
        CFStringLowercase(MutableCopy, 0);
        CFRelease(v20);
        CFRelease(v18);
        if (!MutableCopy) {
          goto LABEL_20;
        }
        if (!CFSetContainsValue(a1[11], MutableCopy))
        {
          CFSetSetValue(a1[11], MutableCopy);
          sdRef.version = (CFIndex)a1[9];
          *((_DWORD *)a1 + 8) = DNSServiceQueryRecord((DNSServiceRef *)&sdRef, v13 | 0x4000, a2, a4, a3, 1u, (DNSServiceQueryRecordReply)_QueryRecordReply_NetService, a1);
        }
        uint64_t v23 = MutableCopy;
      }
      else
      {
        uint64_t v23 = (__CFString *)v18;
      }
      CFRelease(v23);
    }
    else
    {
      *((_DWORD *)a1 + 8) = -65537;
    }
  }
  else
  {
    DNSServiceErrorType Connection = DNSServiceCreateConnection(v15);
    *((_DWORD *)a1 + 8) = Connection;
    if (!Connection)
    {
      sdRef.version = (CFIndex)a1[9];
      *((_DWORD *)a1 + 8) = DNSServiceResolve((DNSServiceRef *)&sdRef, v13 | 0x4000, a2, a4, a5, a6, (DNSServiceResolveReply)_ResolveReply, a1);
    }
  }
LABEL_20:
  int v25 = *((_DWORD *)a1 + 8);
  if (v25)
  {
    int v26 = -72008;
    if (v25 > -65549)
    {
      if (v25 == -65548)
      {
        int v26 = -72001;
        goto LABEL_33;
      }
      if (v25 == -65540)
      {
        int v26 = -72004;
        goto LABEL_33;
      }
    }
    else
    {
      if (v25 == -65555)
      {
LABEL_33:
        a1[3] = (CFDictionaryRef)10;
        *((_DWORD *)a1 + 8) = v26;
        return;
      }
      if (v25 == -65554)
      {
        int v26 = -72002;
        goto LABEL_33;
      }
    }
    int v26 = -72000;
    goto LABEL_33;
  }
  if (!a3)
  {
    sdRef.version = 0;
    sdRef.info = a1;
    sdRef.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
    sdRef.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
    sdRef.copyDescription = 0;
    CFAllocatorRef v27 = CFGetAllocator(a1);
    dnssd_sock_t v28 = DNSServiceRefSockFD(a1[9]);
    CFAllocatorRef v29 = CFSocketCreateWithNative(v27, v28, 1uLL, (CFSocketCallBack)_SocketCallBack_NetService, &sdRef);
    if (v29)
    {
      dnssd_sock_t v30 = v29;
      CFOptionFlags SocketFlags = CFSocketGetSocketFlags(v29);
      CFSocketSetSocketFlags(v30, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
      CFArrayAppendValue(a1[8], v30);
      _CFTypeScheduleOnMultipleRunLoops(v30, a1[12]);
      CFRelease(v30);
    }
  }
}

void _LongTimerCallBack(__CFRunLoopTimer *a1, char *cf)
{
  CFRetain(cf);
  os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
  if (CFArrayGetCount(*((CFArrayRef *)cf + 8)))
  {
    _CleanupService_NoLock((__CFNetService *)cf);
    *((void *)cf + 3) = 10;
    *((_DWORD *)cf + 8) = -72007;
    BOOL v3 = (void (*)(char *, long long *, uint64_t))*((void *)cf + 13);
    long long v5 = *(_OWORD *)(cf + 24);
    uint64_t v4 = *((void *)cf + 15);
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
    if (v3) {
      v3(cf, &v5, v4);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  }
  CFRelease(cf);
}

void _QueryRecordReply_NetService(_DNSServiceRef_t *a1, char a2, int a3, int a4, const char *a5, int a6, unsigned __int16 a7, int a8, _DWORD *a9, unsigned int a10, char *cf)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a4 != -65570)
  {
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    CFAllocatorRef v16 = CFGetAllocator(cf);
    CFBooleanRef Value = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)cf + 6), (const void *)3);
    if (!Value)
    {
      CFBooleanRef Value = CFArrayCreateMutable(v16, 0, MEMORY[0x1E4F1D510]);
      CFDictionaryAddValue(*((CFMutableDictionaryRef *)cf + 6), (const void *)3, Value);
      CFRelease(Value);
    }
    if (a4 == -65554) {
      goto LABEL_32;
    }
    if (a4)
    {
      int v20 = -72008;
      if (a4 != -65555)
      {
        if (a4 == -65548)
        {
          int v20 = -72001;
        }
        else if (a4 == -65540)
        {
          int v20 = -72004;
        }
        else
        {
          int v20 = -72000;
        }
      }
      *((void *)cf + 3) = 10;
      *((_DWORD *)cf + 8) = v20;
      long long v24 = (void (*)(char *, _OWORD *, uint64_t))*((void *)cf + 13);
      v31[0] = *(_OWORD *)(cf + 24);
      uint64_t v25 = *((void *)cf + 15);
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
      if (v24) {
        v24(cf, v31, v25);
      }
      goto LABEL_33;
    }
    unsigned int v18 = *((_DWORD *)cf + 14);
    long long v43 = 0u;
    memset(v44, 0, sizeof(v44));
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v32 = 0u;
    memset(v31, 0, sizeof(v31));
    if (a6 == 1)
    {
      if (a8 == 4)
      {
        LOWORD(v31[0]) = 528;
        WORD1(v31[0]) = bswap32(v18) >> 16;
        DWORD1(v31[0]) = *a9;
        CFIndex v19 = 16;
LABEL_19:
        CFDataRef v21 = CFDataCreate(v16, (const UInt8 *)v31, v19);
        if (v21)
        {
          CFDataRef v22 = v21;
          if ((a2 & 2) != 0)
          {
            CFArrayAppendValue((CFMutableArrayRef)Value, v21);
          }
          else
          {
            v46.CFIndex length = CFArrayGetCount((CFArrayRef)Value);
            v46.CFIndex location = 0;
            FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue((CFArrayRef)Value, v46, v22);
            if (FirstIndexOfValue != -1) {
              CFArrayRemoveValueAtIndex((CFMutableArrayRef)Value, FirstIndexOfValue);
            }
          }
          CFRelease(v22);
        }
      }
    }
    else if (a6 == 28 && a8 == 16)
    {
      LOWORD(v31[0]) = 7708;
      WORD1(v31[0]) = bswap32(v18) >> 16;
      *(_OWORD *)((char *)v31 + 8) = *(_OWORD *)a9;
      if (BYTE8(v31[0]) == 254 && (BYTE9(v31[0]) & 0xC0) == 0x80) {
        DWORD2(v31[1]) = a3;
      }
      CFIndex v19 = 28;
      goto LABEL_19;
    }
    double v26 = dbl_1843D1740[(a2 & 1) == 0];
    double v27 = CFAbsoluteTimeGetCurrent() + v26;
    dnssd_sock_t v28 = (__CFRunLoopTimer *)*((void *)cf + 5);
    if (v28)
    {
      CFRunLoopTimerSetNextFireDate(v28, v27);
    }
    else
    {
      *(void *)&v31[0] = 0;
      *((void *)&v31[0] + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = cf;
      *(void *)&long long v32 = 0;
      v31[1] = 0uLL;
      CFAllocatorRef v29 = CFGetAllocator(cf);
      CFRunLoopTimerRef v30 = CFRunLoopTimerCreate(v29, v27, 10000000.0, 0, 0, (CFRunLoopTimerCallBack)_ShortTimerCallBack, (CFRunLoopTimerContext *)v31);
      *((void *)cf + 5) = v30;
      CFArrayAppendValue(*((CFMutableArrayRef *)cf + 8), v30);
      _CFTypeScheduleOnMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 12));
    }
LABEL_32:
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
LABEL_33:
    CFRelease(cf);
  }
}

void _ShortTimerCallBack(__CFRunLoopTimer *a1, char *cf)
{
  CFRetain(cf);
  os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
  BOOL v3 = (void (*)(char *, long long *, uint64_t))*((void *)cf + 13);
  long long v5 = *(_OWORD *)(cf + 24);
  uint64_t v4 = *((void *)cf + 15);
  os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  if (v3)
  {
    v3(cf, &v5, v4);
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    _CleanupService_NoLock((__CFNetService *)cf);
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  }
  CFRelease(cf);
}

void _ResolveReply(_DNSServiceRef_t *a1, unsigned int a2, unsigned int a3, int a4, const char *a5, const char *a6, unsigned int a7, unsigned int a8, const unsigned __int8 *a9, char *a10)
{
  if (a4 == -65570) {
    return;
  }
  uint64_t v32 = v10;
  uint64_t v33 = v11;
  CFRetain(a10);
  os_unfair_lock_lock((os_unfair_lock_t)a10 + 4);
  if (!*((void *)a10 + 9))
  {
    BOOL v18 = 0;
LABEL_9:
    BOOL v19 = 0;
    goto LABEL_44;
  }
  if (a4)
  {
    int v17 = -72000;
    if (a4 > -65549)
    {
      if (a4 == -65548)
      {
        int v17 = -72001;
      }
      else if (a4 == -65540)
      {
        int v17 = -72004;
      }
    }
    else if (a4 == -65555)
    {
      int v17 = -72008;
    }
    else if (a4 == -65554)
    {
      int v17 = -72002;
    }
    BOOL v18 = 0;
    BOOL v19 = 0;
    *((void *)a10 + 3) = 10;
    *((_DWORD *)a10 + 8) = v17;
    goto LABEL_44;
  }
  CFAllocatorRef v20 = CFGetAllocator(a10);
  CFAllocatorRef v21 = v20;
  if (a9) {
    CFDataRef v22 = CFDataCreate(v20, a9, a8);
  }
  else {
    CFDataRef v22 = 0;
  }
  CFBooleanRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)a10 + 6), (const void *)1);
  if (a6) {
    CFStringRef v24 = CFStringCreateWithCString(v21, a6, 0x8000100u);
  }
  else {
    CFStringRef v24 = 0;
  }
  CFArrayRef v25 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)a10 + 6), (const void *)3);
  *((_DWORD *)a10 + 14) = __rev16(a7);
  if (Value && v22)
  {
    BOOL v18 = CFEqual(Value, v22) == 0;
LABEL_35:
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)1);
    goto LABEL_36;
  }
  if (Value && !v22)
  {
    BOOL v18 = 1;
    goto LABEL_35;
  }
  if (Value) {
    BOOL v26 = 1;
  }
  else {
    BOOL v26 = v22 == 0;
  }
  BOOL v18 = !v26;
  if (Value) {
    goto LABEL_35;
  }
LABEL_36:
  if (v22)
  {
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)1, v22);
    CFRelease(v22);
  }
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)5);
  if (v24)
  {
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)5, v24);
    CFRelease(v24);
  }
  _ServiceCreateQuery_NoLock((__CFNetService *)a10, a3, 1u, a6, 0, 0, v27);
  _ServiceCreateQuery_NoLock((__CFNetService *)a10, a3, 0x1Cu, a6, 0, 0, v28);
  if (*((_DWORD *)a10 + 8))
  {
    *((void *)a10 + 3) = 10;
    *((_DWORD *)a10 + 8) = -72000;
  }
  if (!v25) {
    goto LABEL_9;
  }
  BOOL v19 = CFArrayGetCount(v25) != 0;
LABEL_44:
  if (*((_DWORD *)a10 + 8) || v18 && v19)
  {
    CFAllocatorRef v29 = (void (*)(char *, long long *, uint64_t))*((void *)a10 + 13);
    long long v31 = *(_OWORD *)(a10 + 24);
    uint64_t v30 = *((void *)a10 + 15);
    os_unfair_lock_unlock((os_unfair_lock_t)a10 + 4);
    if (v29) {
      v29(a10, &v31, v30);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a10 + 4);
  }
  CFRelease(a10);
}

void CFNetServiceCancel(CFNetServiceRef theService)
{
  CFDataRef v2 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (CFArrayGetCount(*((CFArrayRef *)theService + 8)))
  {
    v12.version = 0;
    v12.info = theService;
    v12.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
    v12.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
    memset(&v12.copyDescription, 0, 40);
    v12.perform = (void (__cdecl *)(void *))_ServiceCancel;
    _CleanupService_NoLock(theService);
    *((unsigned char *)theService + 20) &= 0xF1u;
    *((void *)theService + 3) = 10;
    *((_DWORD *)theService + 8) = -72005;
    CFAllocatorRef v3 = CFGetAllocator(theService);
    CFRunLoopSourceRef v4 = CFRunLoopSourceCreate(v3, 0, &v12);
    if (v4)
    {
      CFRunLoopSourceRef v5 = v4;
      CFArrayRef v6 = (const __CFArray *)*((void *)theService + 12);
      CFIndex Count = CFArrayGetCount(v6);
      *((unsigned char *)theService + 20) |= 8u;
      CFArrayAppendValue(*((CFMutableArrayRef *)theService + 8), v5);
      _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
      CFRunLoopSourceSignal(v5);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i < Count; i += 2)
        {
          CFDictionaryRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v6, i);
          if (CFRunLoopIsWaiting(ValueAtIndex))
          {
            CFStringRef v10 = CFRunLoopCopyCurrentMode(ValueAtIndex);
            if (v10)
            {
              CFStringRef v11 = v10;
              if (CFRunLoopContainsSource(ValueAtIndex, v5, v10)) {
                CFRunLoopWakeUp(ValueAtIndex);
              }
              CFRelease(v11);
            }
          }
        }
      }
      CFRelease(v5);
    }
  }
  os_unfair_lock_unlock(v2);
}

void _ServiceCancel(__CFNetService *a1)
{
  CFRetain(a1);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if (CFArrayGetCount(*((CFArrayRef *)a1 + 8)))
  {
    long long v5 = *(_OWORD *)((char *)a1 + 24);
    uint64_t v2 = *((void *)a1 + 15);
    CFAllocatorRef v3 = (void (*)(__CFNetService *, long long *, uint64_t))*((void *)a1 + 13);
    _UnscheduleSources(*((const __CFArray **)a1 + 8), *((const __CFArray **)a1 + 12));
    _InvalidateSources(*((__CFArray **)a1 + 8));
    CFRunLoopSourceRef v4 = (const void *)*((void *)a1 + 5);
    if (v4)
    {
      CFRelease(v4);
      *((void *)a1 + 5) = 0;
    }
  }
  else
  {
    CFAllocatorRef v3 = 0;
    uint64_t v2 = 0;
  }
  *((unsigned char *)a1 + 20) &= ~8u;
  os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  if (v3) {
    v3(a1, &v5, v2);
  }
  CFRelease(a1);
}

Boolean CFNetServiceSetClient(CFNetServiceRef theService, CFNetServiceClientCallBack clientCB, CFNetServiceClientContext *clientContext)
{
  CFArrayRef v6 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (*((void *)theService + 15))
  {
    int v7 = (void (*)(void))*((void *)theService + 17);
    if (v7) {
      v7();
    }
  }
  if (clientCB && clientContext)
  {
    if (!*((void *)theService + 13) && CFArrayGetCount(*((CFArrayRef *)theService + 8))) {
      _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    }
    *((void *)theService + 13) = clientCB;
    long long v8 = *(_OWORD *)&clientContext->version;
    long long v9 = *(_OWORD *)&clientContext->retain;
    *((void *)theService + 18) = clientContext->copyDescription;
    *((_OWORD *)theService + 7) = v8;
    *((_OWORD *)theService + 8) = v9;
    if (*((void *)theService + 15))
    {
      CFStringRef v10 = (uint64_t (*)(void))*((void *)theService + 16);
      if (v10) {
        *((void *)theService + 15) = v10();
      }
    }
  }
  else
  {
    _CleanupService_NoLock(theService);
    *((unsigned char *)theService + 20) &= 0xF0u;
    *(_OWORD *)((char *)theService + 104) = 0u;
    *(_OWORD *)((char *)theService + 12dispatch_get_global_queue(0, 0) = 0u;
    *(_OWORD *)((char *)theService + 136) = 0u;
  }
  os_unfair_lock_unlock(v6);
  return 1;
}

CFDictionaryRef CFNetServiceCreateDictionaryWithTXTData(CFAllocatorRef alloc, CFDataRef txtRecord)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFDataGetLength(txtRecord);
  BytePtr = CFDataGetBytePtr(txtRecord);
  if ((unint64_t)(Length - 1) > 0xFFFE) {
    return 0;
  }
  CFArrayRef v6 = BytePtr;
  unsigned int Count = TXTRecordGetCount(Length, BytePtr);
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(alloc, 0, &CFNetServiceCreateDictionaryWithTXTData::kTXTDictionaryKeyCallBacks, MEMORY[0x1E4F1D540]);
  if (Mutable && Count)
  {
    uint16_t v9 = 0;
    CFDataRef v10 = (const __CFData *)*MEMORY[0x1E4F1D260];
    while (1)
    {
      uint8_t valueLen = 0;
      value = 0;
      if (!TXTRecordGetItemAtIndex(Length, v6, v9, 0x100u, key, &valueLen, (const void **)&value)) {
        break;
      }
LABEL_17:
      if (Count <= ++v9) {
        return Mutable;
      }
    }
    CFStringRef v11 = CFStringCreateWithCString(alloc, key, 0x8000100u);
    CFDataRef v12 = v10;
    if (value) {
      CFDataRef v12 = CFDataCreate(alloc, (const UInt8 *)value, valueLen);
    }
    if (v12 && v11)
    {
      if (CFStringGetLength(v11) && !CFDictionaryGetValue(Mutable, v11)) {
        CFDictionaryAddValue(Mutable, v11, v12);
      }
    }
    else if (!v12)
    {
      goto LABEL_15;
    }
    CFRelease(v12);
LABEL_15:
    if (v11) {
      CFRelease(v11);
    }
    goto LABEL_17;
  }
  return Mutable;
}

BOOL TXTDictionaryKeyEqual(const __CFString *a1, const __CFString *a2)
{
  return CFStringCompare(a1, a2, 1uLL) == kCFCompareEqualTo;
}

void TXTDictionaryKeyRelease(const __CFAllocator *a1, CFTypeRef cf)
{
}

CFTypeRef TXTDictionaryKeyRetain(const __CFAllocator *a1, CFTypeRef cf)
{
  return CFRetain(cf);
}

CFDataRef CFNetServiceCreateTXTDataWithDictionary(CFAllocatorRef alloc, CFDictionaryRef keyValuePairs)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFDictionaryGetCount(keyValuePairs);
  long long v5 = (const void **)CFAllocatorAllocate(alloc, 8 * Count, 0);
  CFArrayRef v6 = (const void **)CFAllocatorAllocate(alloc, 8 * Count, 0);
  int v7 = v6;
  if (v5 && v6)
  {
    CFTypeID TypeID = CFStringGetTypeID();
    CFTypeID v9 = CFDataGetTypeID();
    CFDictionaryGetKeysAndValues(keyValuePairs, v5, v7);
    TXTRecordCreate(&txtRecord, 0, 0);
    if (Count < 1)
    {
      uint64_t v10 = 0;
    }
    else
    {
      uint64_t v10 = 0;
      uint64_t v23 = (const void *)*MEMORY[0x1E4F1D260];
      while (1)
      {
        CFIndex usedBufLen = 0;
        CFTypeID v11 = CFGetTypeID(v7[v10]);
        if (CFGetTypeID(v5[v10]) != TypeID) {
          break;
        }
        CFIndex Length = CFStringGetLength((CFStringRef)v5[v10]);
        v29.CFIndex location = 0;
        v29.CFIndex length = Length;
        CFIndex Bytes = CFStringGetBytes((CFStringRef)v5[v10], v29, 0x600u, 0, 0, buffer, 256, &usedBufLen);
        if (!Length || Bytes < Length || usedBufLen > 255) {
          break;
        }
        buffer[usedBufLen] = 0;
        if (v11 == TypeID)
        {
          CFIndex v14 = CFStringGetLength((CFStringRef)v7[v10]);
          v30.CFIndex location = 0;
          v30.CFIndex length = v14;
          if (CFStringGetBytes((CFStringRef)v7[v10], v30, 0x8000100u, 0, 0, v25, 256, &usedBufLen) < v14
            || usedBufLen > 255)
          {
            break;
          }
          uint8_t v15 = usedBufLen;
          BytePtr = v25;
        }
        else if (v11 != v9 || CFDataGetLength((CFDataRef)v7[v10]) > 255 || CFDataGetLength((CFDataRef)v7[v10]) < 0)
        {
          if (v7[v10] != v23) {
            break;
          }
          uint8_t v15 = 0;
          BytePtr = 0;
        }
        else
        {
          uint8_t v17 = CFDataGetLength((CFDataRef)v7[v10]);
          BytePtr = CFDataGetBytePtr((CFDataRef)v7[v10]);
          uint8_t v15 = v17;
        }
        if (TXTRecordSetValue(&txtRecord, (const char *)buffer, v15, BytePtr)) {
          break;
        }
        if (Count == ++v10) {
          goto LABEL_28;
        }
      }
    }
    if (v10 == Count)
    {
LABEL_28:
      BytesPtr = (const UInt8 *)TXTRecordGetBytesPtr(&txtRecord);
      unsigned int v22 = TXTRecordGetLength(&txtRecord);
      CFDataRef v18 = CFDataCreate(alloc, BytesPtr, v22);
    }
    else
    {
      CFDataRef v18 = 0;
    }
    TXTRecordDeallocate(&txtRecord);
LABEL_31:
    CFAllocatorDeallocate(alloc, v5);
    CFDataRef v19 = v18;
    if (!v7) {
      return v19;
    }
    goto LABEL_24;
  }
  CFDataRef v18 = 0;
  CFDataRef v19 = 0;
  if (v5) {
    goto LABEL_31;
  }
  if (v6) {
LABEL_24:
  }
    CFAllocatorDeallocate(alloc, v7);
  return v19;
}

CFNetServiceRef _CFNetServiceCreateFromServiceName(const __CFAllocator *a1, CFStringRef theString)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (!theString || !CFStringGetCString(theString, buffer, 1009, 0x8000100u)) {
    return 0;
  }
  uint64_t v3 = 0;
  v52[0] = 0;
  while (1)
  {
    uint64_t v4 = v52[v3];
    if (v4 > 0x3F)
    {
LABEL_7:
      long long v5 = buffer;
      CFArrayRef v6 = buffer;
      goto LABEL_8;
    }
    if (!v52[v3]) {
      break;
    }
    v3 += v4 + 1;
    if ((unint64_t)v3 >= 0x101) {
      goto LABEL_7;
    }
  }
  CFDataRef v18 = &v52[v3];
  CFArrayRef v6 = buffer;
  if ((unint64_t)v3 > 0xFE || (char v19 = buffer[0]) == 0)
  {
    long long v5 = &v52[v3];
    goto LABEL_8;
  }
  CFArrayRef v6 = buffer;
  do
  {
    if (v19 == 46)
    {
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "AppendDNSNameString: Illegal empty label in name \"%s\"", buffer);
      return 0;
    }
    if (v3 <= 254) {
      uint64_t v20 = 254;
    }
    else {
      uint64_t v20 = v3;
    }
    for (uint64_t i = v3; ; ++i)
    {
      if (!v19 || v19 == 46)
      {
        uint64_t v20 = i;
LABEL_42:
        uint64_t v3 = i + 1;
        long long v5 = &v52[i + 1];
        uint64_t i = v20;
        goto LABEL_43;
      }
      if (v20 == i) {
        goto LABEL_42;
      }
      unsigned int v22 = v6 + 1;
      if (v19 == 92) {
        break;
      }
LABEL_40:
      v52[i + 1] = v19;
      char v19 = *v22;
      CFArrayRef v6 = v22;
    }
    int v23 = *v22;
    if (*v22)
    {
      char v19 = *v22;
      unsigned int v22 = v6 + 2;
      if (v23 - 48 <= 9)
      {
        int v24 = *v22;
        if ((v24 - 48) <= 9)
        {
          int v25 = v6[3];
          if ((v25 - 48) <= 9)
          {
            int v26 = 100 * v23 + 10 * v24 + v25;
            unsigned __int8 v27 = v6 + 4;
            if (v26 < 5584)
            {
              char v19 = v26 + 48;
              unsigned int v22 = v27;
            }
          }
        }
      }
      goto LABEL_40;
    }
    char v19 = 0;
    uint64_t v3 = i + 1;
    long long v5 = &v52[i + 1];
    ++v6;
LABEL_43:
    uint64_t v28 = (uint64_t)&v5[~(unint64_t)v18];
    if (v28 > 63) {
      return 0;
    }
    if (v19) {
      ++v6;
    }
    char *v18 = v28;
    char v19 = *v6;
    if (!*v6) {
      break;
    }
    CFDataRef v18 = v5;
  }
  while (i < 254);
LABEL_8:
  *long long v5 = 0;
  if (*v6) {
    return 0;
  }
  uint64_t v7 = v52[0];
  if (v52[0] - 64 < 0xFFFFFFC1) {
    return 0;
  }
  uint64_t v8 = 0;
  uint64_t v9 = v52[0] + 1;
  do
  {
    uint64_t v10 = v8 + 1;
    v50[v8] = v52[v8];
    uint64_t v8 = v10;
  }
  while (v9 != v10);
  uint64_t v11 = v52[v10];
  if ((v11 - 64) < 0xFFFFFFC1) {
    return 0;
  }
  if (v52[v10 + 1] != 95) {
    return 0;
  }
  uint64_t v12 = 0;
  int v13 = &v52[v7 + 1];
  uint64_t v14 = v7 + 2 + v11;
  uint64_t v15 = v11 + 1;
  do
  {
    v49[v12] = v13[v12];
    ++v12;
  }
  while (v15 != v12);
  CFAllocatorRef v16 = &v13[v12];
  if (*v16 != 4 || v16[1] != 95) {
    return 0;
  }
  int v17 = v16[2] & 0xDF;
  if (v17 != 84)
  {
    if (v17 != 85 || (v16[3] & 0xDF) != 0x44) {
      return 0;
    }
LABEL_55:
    if ((v16[4] & 0xDF) != 0x50) {
      return 0;
    }
    uint64_t v31 = 0;
    do
    {
      v49[v31 + v12] = v52[v14 + v31];
      ++v31;
    }
    while (v31 != 5);
    uint64_t v32 = v14 + v31;
    v49[v12 + v31] = 0;
    unsigned int v33 = v52[v14 + v31];
    if (v52[v32])
    {
      long long v34 = v48;
      while (v33 <= 0x3F && v32 + v33 + 1 <= 254)
      {
        unsigned int v35 = v33 + 1;
        do
        {
          unsigned __int8 v36 = v52[v32++];
          *v34++ = v36;
          --v35;
        }
        while (v35);
        unsigned int v33 = v52[v32];
        if (!v52[v32]) {
          goto LABEL_67;
        }
      }
      return 0;
    }
    long long v34 = v48;
LABEL_67:
    unsigned __int8 *v34 = 0;
    if (v50[0] <= 0x3Fu)
    {
      if (v50[0])
      {
        long long v37 = &v50[v50[0] + 1];
        long long v38 = (char *)&v51;
        long long v39 = cStr;
        do
        {
          char v40 = *v38++;
          *v39++ = v40;
        }
        while (v38 < v37);
      }
      else
      {
        long long v39 = cStr;
      }
      char *v39 = 0;
    }
    _DNSServiceConvertDomainNameToCString_withescape(v49, (unsigned __int8 *)v46);
    _DNSServiceConvertDomainNameToCString_withescape(v48, (unsigned __int8 *)v45);
    CFStringRef v41 = CFStringCreateWithCString(a1, cStr, 0x8000100u);
    CFStringRef v42 = CFStringCreateWithCString(a1, v46, 0x8000100u);
    CFStringRef v43 = CFStringCreateWithCString(a1, v45, 0x8000100u);
    CFStringRef v44 = v43;
    if (v41)
    {
      if (v42 && v43)
      {
        CFNetServiceRef v29 = CFNetServiceCreate(a1, v43, v42, v41, -1);
        CFRelease(v41);
        CFRelease(v42);
        CFRelease(v44);
        return v29;
      }
      CFRelease(v41);
    }
    if (v42) {
      CFRelease(v42);
    }
    if (v44) {
      CFRelease(v44);
    }
    return 0;
  }
  if ((v16[3] & 0xDF) == 0x43) {
    goto LABEL_55;
  }
  return 0;
}

CFNetServiceRef _CFNetServiceCreateFromURL(const __CFAllocator *a1, CFURLRef anURL)
{
  if (!anURL) {
    return 0;
  }
  CFStringRef v3 = CFURLCopyHostName(anURL);
  if (!v3) {
    return 0;
  }
  CFStringRef v4 = v3;
  CFNetServiceRef v5 = _CFNetServiceCreateFromServiceName(a1, v3);
  CFRelease(v4);
  return v5;
}

CFTypeID CFNetServiceMonitorGetTypeID(void)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_1802;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = _CFNetServiceMonitorRegisterClass;
  if (_kCFNetServiceMonitorRegisterClass != -1) {
    dispatch_once(&_kCFNetServiceMonitorRegisterClass, block);
  }
  return _kCFNetServiceMonitorTypeID;
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_1802(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

void *_CFNetServiceMonitorRegisterClass(void)
{
  CFDataRef result = malloc_type_calloc(1uLL, 0x60uLL, 0x10D00408820D60FuLL);
  _kCFNetServiceMonitorClass = (uint64_t)result;
  if (result)
  {
    *CFDataRef result = 0;
    result[1] = "CFNetServiceMonitor";
    result[4] = _MonitorDestroy;
    CFDataRef result = (void *)_CFRuntimeRegisterClass();
    _kCFNetServiceMonitorCFTypeID TypeID = (uint64_t)result;
  }
  return result;
}

void _MonitorDestroy(__CFNetServiceMonitor *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if (*((void *)a1 + 13))
  {
    CFStringRef v3 = (void (*)(void))*((void *)a1 + 15);
    if (v3) {
      v3();
    }
  }
  uint64_t v4 = *((void *)a1 + 6);
  if (v4)
  {
    uint64_t v5 = *((void *)a1 + 10);
    if (v5)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v4, v5);
      uint64_t v4 = *((void *)a1 + 6);
    }
    _CFTypeInvalidate(v4);
    CFRelease(*((CFTypeRef *)a1 + 6));
  }
  CFArrayRef v6 = (_DNSServiceRef_t *)*((void *)a1 + 7);
  if (v6) {
    DNSServiceRefDeallocate(v6);
  }
  uint64_t v7 = (const void *)*((void *)a1 + 5);
  if (v7)
  {
    CFRelease(v7);
    *((void *)a1 + 5) = 0;
  }
  uint64_t v8 = (const void *)*((void *)a1 + 10);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)*((void *)a1 + 8);
  if (v9) {
    CFRelease(v9);
  }

  os_unfair_lock_unlock(v2);
}

CFNetServiceMonitorRef CFNetServiceMonitorCreate(CFAllocatorRef alloc, CFNetServiceRef theService, CFNetServiceMonitorClientCallBack clientCB, CFNetServiceClientContext *clientContext)
{
  uint64_t v4 = 0;
  if (clientCB && clientContext)
  {
    if (!CFNetServiceMonitorGetTypeID()) {
      return 0;
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v4 = (__CFNetServiceMonitor *)Instance;
    if (Instance)
    {
      *(void *)(Instance + 128) = 0;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 8dispatch_get_global_queue(0, 0) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(void *)(Instance + 88) = clientCB;
      long long v11 = *(_OWORD *)&clientContext->version;
      long long v10 = *(_OWORD *)&clientContext->retain;
      *(void *)(Instance + 128) = clientContext->copyDescription;
      *(_OWORD *)(Instance + 96) = v11;
      *(_OWORD *)(Instance + 112) = v10;
      if (*(void *)(Instance + 104))
      {
        uint64_t v12 = *(uint64_t (**)(void))(Instance + 112);
        if (v12) {
          *(void *)(Instance + 104) = v12();
        }
      }
      CFMutableArrayRef Mutable = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
      *((void *)v4 + 1dispatch_get_global_queue(0, 0) = Mutable;
      if (Mutable)
      {
        *((void *)v4 + 5) = CFRetain(theService);
        return v4;
      }
      CFRelease(v4);
      return 0;
    }
  }
  return v4;
}

void CFNetServiceMonitorInvalidate(CFNetServiceMonitorRef monitor)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  if (*((void *)monitor + 13))
  {
    CFStringRef v3 = (void (*)(void))*((void *)monitor + 15);
    if (v3) {
      v3();
    }
  }
  uint64_t v4 = *((void *)monitor + 6);
  if (v4)
  {
    _CFTypeUnscheduleFromMultipleRunLoops(v4, *((void *)monitor + 10));
    _CFTypeInvalidate(*((void *)monitor + 6));
    CFRelease(*((CFTypeRef *)monitor + 6));
    *((void *)monitor + 6) = 0;
  }
  uint64_t v5 = (_DNSServiceRef_t *)*((void *)monitor + 7);
  if (v5)
  {
    DNSServiceRefDeallocate(v5);
    *((void *)monitor + 7) = 0;
  }
  CFArrayRef v6 = (const void *)*((void *)monitor + 5);
  if (v6)
  {
    CFRelease(v6);
    *((void *)monitor + 5) = 0;
  }
  *(_OWORD *)((char *)monitor + 12dispatch_get_global_queue(0, 0) = 0u;
  *(_OWORD *)((char *)monitor + 104) = 0u;
  *(_OWORD *)((char *)monitor + 88) = 0u;

  os_unfair_lock_unlock(v2);
}

Boolean CFNetServiceMonitorStart(CFNetServiceMonitorRef monitor, CFNetServiceMonitorType recordType, CFStreamError *error)
{
  CFStringRef v3 = (char *)MEMORY[0x1F4188790](monitor, *(void *)&recordType, error);
  int v6 = v5;
  uint64_t v7 = v3;
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (v4) {
    uint64_t v8 = v4;
  }
  else {
    uint64_t v8 = &v33;
  }
  *(void *)uint64_t v8 = 0;
  *((void *)v8 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  CFRetain(v3);
  os_unfair_lock_lock((os_unfair_lock_t)v7 + 4);
  v34[0] = CFNetServiceGetInfo(*((void *)v7 + 5), 0);
  v34[1] = CFNetServiceGetInfo(*((void *)v7 + 5), 4u);
  CFStringRef v34[2] = CFNetServiceGetInfo(*((void *)v7 + 5), 2u);
  context.version = 0;
  context.info = v7;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
  context.copyDescription = 0;
  if (!*((void *)v7 + 11))
  {
    Boolean v11 = 0;
    *((void *)v7 + 3) = 10;
    int v12 = -72006;
    goto LABEL_9;
  }
  uint64_t v9 = (const void *)*((void *)v7 + 6);
  if (v9)
  {
    CFTypeID v10 = CFGetTypeID(v9);
    if (v10 == CFSocketGetTypeID())
    {
      Boolean v11 = 0;
      *((void *)v7 + 3) = 10;
      int v12 = -72003;
LABEL_9:
      *((_DWORD *)v7 + 8) = v12;
      goto LABEL_39;
    }
    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)v7 + 6), *((const __CFArray **)v7 + 10));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)v7 + 6));
    CFRelease(*((CFTypeRef *)v7 + 6));
    *((void *)v7 + 6) = 0;
  }
  uint64_t v13 = 0;
  uint64_t v14 = (const __CFString **)v34;
  do
  {
    CFIndex usedBufLen = 0;
    CFStringRef v15 = *v14++;
    v40.CFIndex length = CFStringGetLength(v15);
    v40.CFIndex location = 0;
    CFStringGetBytes(v15, v40, 0x8000100u, 0, 0, (UInt8 *)&domain[v13], 1023, &usedBufLen);
    domain[v13 + usedBufLen] = 0;
    v13 += 1024;
  }
  while (v13 != 3072);
  if (v6 == 1) {
    uint16_t v16 = 16;
  }
  else {
    uint16_t v16 = v6;
  }
  if (v6 == 1) {
    uint16_t v17 = 1;
  }
  else {
    uint16_t v17 = HIWORD(v6);
  }
  DNSServiceConstructFullName(v38, v37, v36, domain);
  *((_DWORD *)v7 + 18) = v6;
  CFBooleanRef Info = (const __CFBoolean *)CFNetServiceGetInfo(*((void *)v7 + 5), 7u);
  if (Info) {
    int v19 = (CFBooleanGetValue(Info) != 0) << 20;
  }
  else {
    int v19 = 0;
  }
  CFBooleanRef v20 = (const __CFBoolean *)CFNetServiceGetInfo(*((void *)v7 + 5), 9u);
  if (v20 && CFBooleanGetValue(v20)) {
    int v19 = 0x100000;
  }
  int v21 = -72008;
  DNSServiceErrorType Record = DNSServiceQueryRecord((DNSServiceRef *)v7 + 7, v19 | 0x100, 0, v38, v16, v17, (DNSServiceQueryRecordReply)_QueryRecordReply, v7);
  *((_DWORD *)v7 + 8) = Record;
  if (Record <= -65549)
  {
    if (Record == -65555) {
      goto LABEL_38;
    }
    if (Record == -65554)
    {
      int v21 = -72002;
      goto LABEL_38;
    }
    goto LABEL_37;
  }
  if (Record == -65548)
  {
    int v21 = -72001;
    goto LABEL_38;
  }
  if (Record)
  {
    if (Record == -65540)
    {
      int v21 = -72004;
LABEL_38:
      Boolean v11 = 0;
      *((void *)v7 + 3) = 10;
      *((_DWORD *)v7 + 8) = v21;
      goto LABEL_39;
    }
LABEL_37:
    int v21 = -72000;
    goto LABEL_38;
  }
  CFAllocatorRef v23 = CFGetAllocator(v7);
  dnssd_sock_t v24 = DNSServiceRefSockFD(*((DNSServiceRef *)v7 + 7));
  int v25 = CFSocketCreateWithNative(v23, v24, 1uLL, (CFSocketCallBack)_SocketCallBack_Mon, &context);
  *((void *)v7 + 6) = v25;
  if (v25)
  {
    int v26 = v25;
    CFOptionFlags SocketFlags = CFSocketGetSocketFlags(v25);
    CFSocketSetSocketFlags(v26, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
    if (CFArrayGetCount(*((CFArrayRef *)v7 + 10)))
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)v7 + 6), *((const __CFArray **)v7 + 10));
      Boolean v11 = 1;
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 4);
      CFRunLoopRef Current = CFRunLoopGetCurrent();
      CFNetServiceMonitorScheduleWithRunLoop((CFNetServiceMonitorRef)v7, Current, @"_kCFNetServiceMonitorBlockingMode");
      os_unfair_lock_lock((os_unfair_lock_t)v7 + 4);
      while (*((void *)v7 + 6))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)v7 + 4);
        CFRunLoopRunInMode(@"_kCFNetServiceMonitorBlockingMode", 1.79769313e308, 1u);
        os_unfair_lock_lock((os_unfair_lock_t)v7 + 4);
      }
      Boolean v11 = *((_DWORD *)v7 + 8) == 0;
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 4);
      CFNetServiceMonitorUnscheduleFromRunLoop((CFNetServiceMonitorRef)v7, Current, @"_kCFNetServiceMonitorBlockingMode");
      os_unfair_lock_lock((os_unfair_lock_t)v7 + 4);
    }
  }
  else
  {
    if (*__error()) {
      int v29 = *__error();
    }
    else {
      int v29 = 12;
    }
    *((void *)v7 + 3) = 1;
    *((_DWORD *)v7 + 8) = v29;
    DNSServiceRefDeallocate(*((DNSServiceRef *)v7 + 7));
    Boolean v11 = 0;
    *((void *)v7 + 7) = 0;
  }
LABEL_39:
  *(_OWORD *)uint64_t v8 = *(_OWORD *)(v7 + 24);
  os_unfair_lock_unlock((os_unfair_lock_t)v7 + 4);
  CFRelease(v7);
  return v11;
}

void CFNetServiceMonitorScheduleWithRunLoop(CFNetServiceMonitorRef monitor, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  int v6 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  if (_SchedulesAddRunLoopAndMode(*((const __CFArray **)monitor + 10), runLoop, runLoopMode))
  {
    uint64_t v7 = *((void *)monitor + 6);
    if (v7) {
      _CFTypeScheduleOnRunLoop(v7, runLoop, runLoopMode);
    }
  }

  os_unfair_lock_unlock(v6);
}

void CFNetServiceMonitorUnscheduleFromRunLoop(CFNetServiceMonitorRef monitor, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  int v6 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)monitor + 10), runLoop, runLoopMode))
  {
    uint64_t v7 = *((void *)monitor + 6);
    if (v7) {
      _CFTypeUnscheduleFromRunLoop(v7, runLoop, runLoopMode);
    }
  }

  os_unfair_lock_unlock(v6);
}

void _SocketCallBack_Mon(__CFSocket *a1, unint64_t a2, const __CFData *a3, const void *a4, DNSServiceRef *cf)
{
  CFRetain(cf);
  int v6 = (_DNSServiceRef_t *)DNSServiceProcessResult(cf[7]);
  if (v6) {
    _QueryRecordReply(v6, 0, v7, (int)v6, v8, 0, 0, 0, 0, v9, (unsigned int *)cf);
  }

  CFRelease(cf);
}

void _QueryRecordReply(_DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, unsigned __int16 a6, unsigned __int16 a7, unsigned int a8, const UInt8 *a9, unsigned int a10, unsigned int *a11)
{
  if (a4 != -65570)
  {
    uint64_t v28 = v11;
    uint64_t v29 = v12;
    CFRetain(a11);
    os_unfair_lock_lock((os_unfair_lock_t)a11 + 4);
    if (!*((void *)a11 + 7))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)a11 + 4);
LABEL_36:
      CFRelease(a11);
      return;
    }
    uint16_t v16 = (__CFNetService *)CFRetain(*((CFTypeRef *)a11 + 5));
    uint64_t v17 = a11[18];
    if (a4)
    {
      int v18 = -72008;
      if (a4 > -65549)
      {
        if (a4 == -65548)
        {
          int v18 = -72001;
          goto LABEL_20;
        }
        if (a4 == -65540)
        {
          int v18 = -72004;
          goto LABEL_20;
        }
      }
      else
      {
        if (a4 == -65555)
        {
LABEL_20:
          *((void *)a11 + 3) = 10;
          a11[8] = v18;
          _CFTypeUnscheduleFromMultipleRunLoops(*((void **)a11 + 6), *((const __CFArray **)a11 + 10));
          CFSocketInvalidate(*((CFSocketRef *)a11 + 6));
          CFRelease(*((CFTypeRef *)a11 + 6));
          *((void *)a11 + 6) = 0;
          DNSServiceRefDeallocate(*((DNSServiceRef *)a11 + 7));
          CFDataRef v20 = 0;
          int v19 = 0;
          *((void *)a11 + 7) = 0;
          goto LABEL_30;
        }
        if (a4 == -65554)
        {
          int v18 = -72002;
          goto LABEL_20;
        }
      }
      int v18 = -72000;
      goto LABEL_20;
    }
    int v19 = 0;
    CFDataRef v20 = 0;
    if ((a2 & 2) == 0 || !a9) {
      goto LABEL_30;
    }
    CFAllocatorRef v21 = CFGetAllocator(a11);
    CFDataRef v20 = CFDataCreate(v21, a9, a8);
    unsigned int v22 = (const void *)*((void *)a11 + 8);
    if (v22 && v20)
    {
      int v23 = CFEqual(v22, v20);
      unsigned int v22 = (const void *)*((void *)a11 + 8);
      if (!v23)
      {
        int v19 = 1;
        if (!v22) {
          goto LABEL_29;
        }
        goto LABEL_28;
      }
      BOOL v24 = v22 == 0;
    }
    else
    {
      BOOL v24 = v22 == 0;
      if (v22 && !v20)
      {
        int v19 = 1;
LABEL_28:
        CFRelease(v22);
LABEL_29:
        *((void *)a11 + 8) = v20;
        _ServiceSetInfo(v16, v17, v20, 0);
LABEL_30:
        int v25 = (void (*)(unsigned int *, __CFNetService *, uint64_t, CFDataRef, long long *, uint64_t))*((void *)a11 + 11);
        long long v27 = *(_OWORD *)(a11 + 6);
        uint64_t v26 = *((void *)a11 + 13);
        os_unfair_lock_unlock((os_unfair_lock_t)a11 + 4);
        if (v25 && (a2 & 2) != 0 && v19) {
          v25(a11, v16, v17, v20, &v27, v26);
        }
        if (v16) {
          CFRelease(v16);
        }
        goto LABEL_36;
      }
    }
    if (v20) {
      int v19 = v24;
    }
    else {
      int v19 = 0;
    }
    if (!v22) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
}

void CFNetServiceMonitorStop(CFNetServiceMonitorRef monitor, CFStreamError *error)
{
  v16[0] = 10;
  if (error) {
    CFStringRef v3 = error;
  }
  else {
    CFStringRef v3 = (CFStreamError *)v16;
  }
  uint64_t v4 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  int v5 = (void *)*((void *)monitor + 6);
  if (v5)
  {
    v15.version = 0;
    v15.info = monitor;
    v15.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
    v15.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
    memset(&v15.copyDescription, 0, 40);
    v15.perform = (void (__cdecl *)(void *))_MonitorCancel;
    _CFTypeUnscheduleFromMultipleRunLoops(v5, *((const __CFArray **)monitor + 10));
    _CFTypeInvalidate(*((char **)monitor + 6));
    CFRelease(*((CFTypeRef *)monitor + 6));
    int v6 = (_DNSServiceRef_t *)*((void *)monitor + 7);
    if (v6)
    {
      DNSServiceRefDeallocate(v6);
      *((void *)monitor + 7) = 0;
    }
    v16[1] = 4294895291;
    *(CFStreamError *)((char *)monitor + 24) = *v3;
    CFAllocatorRef v7 = CFGetAllocator(monitor);
    CFRunLoopSourceRef v8 = CFRunLoopSourceCreate(v7, 0, &v15);
    *((void *)monitor + 6) = v8;
    if (v8)
    {
      CFArrayRef v9 = (const __CFArray *)*((void *)monitor + 10);
      CFIndex Count = CFArrayGetCount(v9);
      _CFTypeScheduleOnMultipleRunLoops(*((void **)monitor + 6), v9);
      CFRunLoopSourceSignal(*((CFRunLoopSourceRef *)monitor + 6));
      if (Count >= 1)
      {
        for (CFIndex i = 0; i < Count; i += 2)
        {
          CFDictionaryRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v9, i);
          if (CFRunLoopIsWaiting(ValueAtIndex))
          {
            CFStringRef v13 = CFRunLoopCopyCurrentMode(ValueAtIndex);
            if (v13)
            {
              CFStringRef v14 = v13;
              if (CFRunLoopContainsSource(ValueAtIndex, *((CFRunLoopSourceRef *)monitor + 6), v13)) {
                CFRunLoopWakeUp(ValueAtIndex);
              }
              CFRelease(v14);
            }
          }
        }
      }
    }
  }
  os_unfair_lock_unlock(v4);
}

void _MonitorCancel(__CFNetServiceMonitor *a1)
{
  CFRetain(a1);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  uint64_t v2 = (void *)*((void *)a1 + 6);
  if (v2)
  {
    long long v5 = *(_OWORD *)((char *)a1 + 24);
    uint64_t v3 = *((void *)a1 + 13);
    uint64_t v4 = (void (*)(__CFNetServiceMonitor *, void, void, void, long long *, uint64_t))*((void *)a1 + 11);
    _CFTypeUnscheduleFromMultipleRunLoops(v2, *((const __CFArray **)a1 + 10));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)a1 + 6));
    CFRelease(*((CFTypeRef *)a1 + 6));
    *((void *)a1 + 6) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
    if (v4) {
      v4(a1, 0, 0, 0, &v5, v3);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  }
  CFRelease(a1);
}

__CFDictionary *CFNetDiagnosticCreateBasic(const __CFAllocator *a1, const void *a2, const void *a3, const void *a4)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    CFArrayRef v9 = MainBundle;
    CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, (CFStringRef)*MEMORY[0x1E4F1D008]);
    if (ValueForInfoDictionaryKey) {
      CFDictionaryAddValue(Mutable, @"NDNameKey", ValueForInfoDictionaryKey);
    }
    CFStringRef Identifier = CFBundleGetIdentifier(v9);
    if (Identifier) {
      CFDictionaryAddValue(Mutable, @"NDBundleKey", Identifier);
    }
  }
  if (a2) {
    CFDictionaryAddValue(Mutable, @"NDRemoteHostKey", a2);
  }
  if (a3) {
    CFDictionaryAddValue(Mutable, @"NDProtocolKey", a3);
  }
  if (a4) {
    CFDictionaryAddValue(Mutable, @"NDPortKey", a4);
  }
  CFDictionaryAddValue(Mutable, @"NDMethodKey", @"CFNetDiagnosticCreateBasic");
  return Mutable;
}

CFNetDiagnosticRef CFNetDiagnosticCreateWithURL(CFAllocatorRef alloc, CFURLRef url)
{
  if (!CFURLCanBeDecomposed(url)) {
    return 0;
  }
  SInt32 valuePtr = CFURLGetPortNumber(url);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    int v6 = MainBundle;
    CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, (CFStringRef)*MEMORY[0x1E4F1D008]);
    if (ValueForInfoDictionaryKey) {
      CFDictionaryAddValue(Mutable, @"NDNameKey", ValueForInfoDictionaryKey);
    }
    CFStringRef Identifier = CFBundleGetIdentifier(v6);
    if (Identifier) {
      CFDictionaryAddValue(Mutable, @"NDBundleKey", Identifier);
    }
  }
  CFStringRef v9 = CFURLCopyHostName(url);
  if (v9)
  {
    CFStringRef v10 = v9;
    CFDictionaryAddValue(Mutable, @"NDRemoteHostKey", v9);
    CFRelease(v10);
  }
  CFStringRef v11 = CFURLCopyScheme(url);
  if (v11)
  {
    CFStringRef v12 = v11;
    CFDictionaryAddValue(Mutable, @"NDProtocolKey", v11);
    CFRelease(v12);
  }
  CFNumberRef v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  if (v13)
  {
    CFNumberRef v14 = v13;
    CFDictionaryAddValue(Mutable, @"NDPortKey", v13);
    CFRelease(v14);
  }
  CFDictionaryAddValue(Mutable, @"NDMethodKey", @"CFNetDiagnosticCreateWithURL");
  return Mutable;
}

CFNetDiagnosticRef CFNetDiagnosticCreateWithStreams(CFAllocatorRef alloc, CFReadStreamRef readStream, CFWriteStreamRef writeStream)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    long long v5 = MainBundle;
    CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, (CFStringRef)*MEMORY[0x1E4F1D008]);
    if (ValueForInfoDictionaryKey) {
      CFDictionaryAddValue(Mutable, @"NDNameKey", ValueForInfoDictionaryKey);
    }
    CFStringRef Identifier = CFBundleGetIdentifier(v5);
    if (Identifier) {
      CFDictionaryAddValue(Mutable, @"NDBundleKey", Identifier);
    }
  }
  CFDictionaryAddValue(Mutable, @"NDMethodKey", @"CFNetDiagnosticCreateWithStreams");
  return Mutable;
}

void CFNetDiagnosticSetName(CFNetDiagnosticRef details, CFStringRef name)
{
  if (name) {
    CFDictionaryAddValue(details, @"NDNameKey", name);
  }
}

void CFNetDiagnosticSetProtocol(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionaryAddValue(a1, @"NDProtocolKey", value);
  }
}

void CFNetDiagnosticSetServiceID(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionaryAddValue(a1, @"NDServiceIDKey", value);
  }
}

CFNetDiagnosticStatus CFNetDiagnosticDiagnoseProblemInteractively(CFNetDiagnosticRef details)
{
  if (CFNetDiagnosticDiagnoseProblemInteractively::sOnce != -1) {
    dispatch_once(&CFNetDiagnosticDiagnoseProblemInteractively::sOnce, &__block_literal_global_1859);
  }
  return -66560;
}

void __CFNetDiagnosticDiagnoseProblemInteractively_block_invoke()
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v0 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_error_impl(&dword_184085000, v0, OS_LOG_TYPE_ERROR, "CFNetDiagnosticDiagnoseProblemInteractively is no longer supported. Please stop using it.", v1, 2u);
  }
}

uint64_t CFNetDiagnosticCopyNetworkStatusActively(const __CFDictionary *a1, CFStringRef *a2, double a3)
{
  uint64_t v6 = -66557;
  if (!mach_timebase_info(&info))
  {
    uint64_t v7 = mach_absolute_time();
    uint32_t numer = info.numer;
    uint32_t denom = info.denom;
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    SCDynamicStoreRef v11 = SCDynamicStoreCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"CFNetDiagnostics", 0, 0);
    if (v11)
    {
      CFStringRef v12 = v11;
      uint64_t v46 = v7;
      uint64_t v13 = mach_absolute_time();
      CFStringRef v14 = (const __CFString *)*MEMORY[0x1E4F41B10];
      CFStringRef domain = (const __CFString *)*MEMORY[0x1E4F41AC8];
      CFStringRef NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(v10, (CFStringRef)*MEMORY[0x1E4F41AC8], (CFStringRef)*MEMORY[0x1E4F41B10]);
      store = v12;
      CFDictionaryRef v16 = (const __CFDictionary *)SCDynamicStoreCopyValue(v12, NetworkGlobalEntity);
      if (v16)
      {
        CFDictionaryRef v17 = v16;
        CFDictionaryRef theDict = a1;
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v16, (const void *)*MEMORY[0x1E4F41CA8]);
        if (Value)
        {
          CFStringRef v19 = Value;
          double v20 = (double)numer * -0.000000001 / (double)denom;
          CFRetain(Value);
          CFRelease(v17);
          CFRelease(NetworkGlobalEntity);
          if (CFNetDiagnosticPing(v19, 1, (a3 + v20 * (double)(v13 - v46)), 0))
          {
            CFStringRef v21 = SCDynamicStoreKeyCreateNetworkGlobalEntity(v10, domain, v14);
            CFDictionaryRef v22 = (const __CFDictionary *)SCDynamicStoreCopyValue(store, v21);
            if (v22)
            {
              CFDictionaryRef v23 = v22;
              CFStringRef v24 = (const __CFString *)CFDictionaryGetValue(v22, (const void *)*MEMORY[0x1E4F41AE0]);
              if (v24)
              {
                CFStringRef v25 = v24;
                CFRetain(v24);
                CFRelease(v23);
                CFRelease(v21);
                CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(v10, domain, v25, (CFStringRef)*MEMORY[0x1E4F41B08]);
                CFDictionaryRef v27 = (const __CFDictionary *)SCDynamicStoreCopyValue(store, NetworkServiceEntity);
                if (v27)
                {
                  CFDictionaryRef v28 = v27;
                  CFArrayRef v29 = (const __CFArray *)CFDictionaryGetValue(v27, (const void *)*MEMORY[0x1E4F41BC0]);
                  CFArrayRef v30 = v29;
                  if (v29) {
                    CFRetain(v29);
                  }
                  CFRelease(v28);
                }
                else
                {
                  CFArrayRef v30 = 0;
                }
                CFRelease(NetworkServiceEntity);
                CFRelease(v25);
                uint64_t v31 = store;
                if (!v30) {
                  goto LABEL_18;
                }
                CFIndex Count = CFArrayGetCount(v30);
                uint64_t v34 = mach_absolute_time();
                if (Count >= 1)
                {
                  uint64_t v35 = ((a3 + v20 * (double)(v34 - v46)) / (double)Count);
                  uint64_t v36 = 1;
                  do
                  {
                    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v30, v36 - 1);
                    BOOL v38 = CFNetDiagnosticPing(ValueAtIndex, 1, v35, 0);
                    if (v36 >= Count) {
                      break;
                    }
                    ++v36;
                  }
                  while (!v38);
                  if (v38)
                  {
                    CFErrorRef err = 0;
                    uint64_t v39 = mach_absolute_time();
                    if (CFNetDiagnosticPing(@"www.apple.com", 1, (a3 + v20 * (double)(v39 - v46)), &err))
                    {
                      CFStringRef v40 = (const __CFString *)CFDictionaryGetValue(theDict, @"NDRemoteHostKey");
                      uint64_t v41 = -66559;
                      if (!v40) {
                        goto LABEL_45;
                      }
                      CFStringRef v42 = v40;
                      if (CFEqual(v40, @"www.apple.com")) {
                        goto LABEL_45;
                      }
                      uint64_t v43 = mach_absolute_time();
                      if (CFNetDiagnosticPing(v42, 1, (a3 + v20 * (double)(v43 - v46)), &err))
                      {
                        uint64_t v41 = -66552;
LABEL_45:
                        CFRelease(v30);
                        uint64_t v6 = v41;
                        goto LABEL_18;
                      }
                      if (CFErrorGetDomain(err) == (CFErrorDomain)*MEMORY[0x1E4F1D160] && CFErrorGetCode(err) == 65) {
                        uint64_t v6 = -66555;
                      }
                      else {
                        uint64_t v6 = -66553;
                      }
                    }
                    else if (CFErrorGetDomain(err) == (CFErrorDomain)*MEMORY[0x1E4F1D160] && CFErrorGetCode(err) == 65)
                    {
                      uint64_t v6 = -66556;
                    }
                    CFRelease(err);
                    uint64_t v41 = v6;
                    goto LABEL_45;
                  }
                }
                uint64_t v41 = -66556;
                goto LABEL_45;
              }
              CFRelease(v23);
            }
            CFRelease(v21);
          }
          else
          {
            uint64_t v6 = -66554;
          }
          uint64_t v31 = store;
LABEL_18:
          CFRelease(v19);
          goto LABEL_19;
        }
        CFRelease(v17);
      }
      CFRelease(NetworkGlobalEntity);
      uint64_t v31 = store;
LABEL_19:
      CFRelease(v31);
    }
  }
  if (a2) {
    *a2 = _CFNetDiagnosticCopyLocalizedDescription(v6);
  }
  return v6;
}

CFStringRef _CFNetDiagnosticCopyLocalizedDescription(uint64_t a1)
{
  if (__CFNGetCFNetworkBundle::onceToken != -1) {
    dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_5505);
  }
  uint64_t v2 = (__CFBundle *)__CFNGetCFNetworkBundle::bundle;
  switch(a1)
  {
    case -66559:
      CFStringRef v3 = @"CONNECTION_UP";
      goto LABEL_13;
    case -66558:
      CFStringRef v3 = @"CONNECTION_INDETERMINATE";
      goto LABEL_13;
    case -66557:
      CFStringRef v3 = @"CONNECTION_DOWN";
      goto LABEL_13;
    case -66556:
      CFStringRef v3 = @"NAMESERVER_DOWN";
      goto LABEL_13;
    case -66555:
      CFStringRef v3 = @"NAMELOOKUP_FAILED";
      goto LABEL_13;
    case -66554:
      CFStringRef v3 = @"ROUTER_DOWN";
      goto LABEL_13;
    case -66553:
      CFStringRef v3 = @"SERVER_DOWN";
      goto LABEL_13;
    case -66552:
      CFStringRef v3 = @"SERVER_UP";
LABEL_13:
      CFStringRef result = CFBundleCopyLocalizedString(v2, v3, v3, 0);
      break;
    default:
      CFStringRef result = 0;
      break;
  }
  return result;
}

CFNetDiagnosticStatus CFNetDiagnosticCopyNetworkStatusPassively(CFNetDiagnosticRef details, CFStringRef *description)
{
  CFNetDiagnosticStatus v4 = -66560;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  SCDynamicStoreRef v6 = SCDynamicStoreCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"CFNetDiagnostics", 0, 0);
  if (v6)
  {
    uint64_t v7 = v6;
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(details, @"NDServiceIDKey");
    if (Value)
    {
      uint64_t v9 = _CFNetDiagnosticCopyNetworkStatusPassivelyInterfaceSpecific(v7, Value, description);
      goto LABEL_18;
    }
    CFStringRef NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(v5, (CFStringRef)*MEMORY[0x1E4F41AC0], (CFStringRef)*MEMORY[0x1E4F41B10]);
    CFDictionaryRef v11 = (const __CFDictionary *)SCDynamicStoreCopyValue(v7, NetworkGlobalEntity);
    if (v11)
    {
      CFDictionaryRef v12 = v11;
      CFArrayRef v13 = (const __CFArray *)CFDictionaryGetValue(v11, (const void *)*MEMORY[0x1E4F41EF8]);
      if (v13)
      {
        CFArrayRef v14 = v13;
        CFRetain(v13);
        CFRelease(v12);
        CFRelease(NetworkGlobalEntity);
        CFIndex Count = CFArrayGetCount(v14);
        uint64_t v9 = -66557;
        if (Count >= 1)
        {
          CFIndex v16 = Count;
          for (CFIndex i = 0; v16 != i; ++i)
          {
            CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v14, i);
            uint64_t v19 = _CFNetDiagnosticCopyNetworkStatusPassivelyInterfaceSpecific(v7, ValueAtIndex, 0);
            if (v19 == -66558)
            {
              uint64_t v9 = -66558;
            }
            else if (v19 == -66559)
            {
              uint64_t v9 = -66559;
              if (!description)
              {
LABEL_15:
                CFRelease(v14);
                goto LABEL_18;
              }
LABEL_14:
              *description = _CFNetDiagnosticCopyLocalizedDescription(v9);
              goto LABEL_15;
            }
          }
        }
        if (!description) {
          goto LABEL_15;
        }
        goto LABEL_14;
      }
      CFRelease(v12);
    }
    CFRelease(NetworkGlobalEntity);
    uint64_t v9 = -66560;
LABEL_18:
    CFRelease(v7);
    return v9;
  }
  return v4;
}

uint64_t _CFNetDiagnosticCopyNetworkStatusPassivelyInterfaceSpecific(const __SCDynamicStore *a1, CFStringRef serviceID, const __CFString **a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = -66557;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)*MEMORY[0x1E4F41AC0], serviceID, (CFStringRef)*MEMORY[0x1E4F41B20]);
  CFDictionaryRef v9 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, NetworkServiceEntity);
  if (!v9) {
    goto LABEL_37;
  }
  CFDictionaryRef v10 = v9;
  CFDictionaryRef v11 = (const void *)*MEMORY[0x1E4F420D8];
  CFStringRef Value = CFDictionaryGetValue(v9, (const void *)*MEMORY[0x1E4F41D28]);
  int v13 = CFEqual(v11, Value);
  CFArrayRef v14 = CFDictionaryGetValue(v10, (const void *)*MEMORY[0x1E4F41D20]);
  if (v14)
  {
    CFRunLoopSourceContext v15 = v14;
    if (CFEqual(v14, (CFTypeRef)*MEMORY[0x1E4F420D0])) {
      goto LABEL_11;
    }
    BOOL v16 = CFEqual(v15, (CFTypeRef)*MEMORY[0x1E4F420C8]) == 0;
  }
  else
  {
    BOOL v16 = 1;
  }
  if (v13) {
    BOOL v17 = !v16;
  }
  else {
    BOOL v17 = 1;
  }
  if (v17)
  {
LABEL_11:
    CFStringRef v40 = a3;
    CFStringRef v18 = (const __CFString *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x1E4F41D18]);
    CFStringRef v19 = (const __CFString *)*MEMORY[0x1E4F41AC8];
    CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity(v7, (CFStringRef)*MEMORY[0x1E4F41AC8], v18, (CFStringRef)*MEMORY[0x1E4F41B28]);
    CFDictionaryRef v21 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, NetworkInterfaceEntity);
    if (v21)
    {
      CFDictionaryRef v22 = v21;
      CFBooleanRef v23 = (const __CFBoolean *)CFDictionaryGetValue(v21, (const void *)*MEMORY[0x1E4F41D30]);
      CFBooleanRef v24 = (const __CFBoolean *)CFDictionaryGetValue(v22, (const void *)*MEMORY[0x1E4F41D38]);
      if (v23)
      {
        LODWORD(v23) = CFBooleanGetValue(v23);
      }
      else if (v24)
      {
        LODWORD(v23) = CFBooleanGetValue(v24) == 0;
      }
      else
      {
        LODWORD(v23) = 1;
      }
      CFRelease(v22);
    }
    else
    {
      LODWORD(v23) = 0;
    }
    CFRelease(NetworkInterfaceEntity);
    a3 = v40;
    goto LABEL_23;
  }
  memset(&context, 0, sizeof(context));
  CFStringRef v25 = SCNetworkConnectionCreateWithServiceID(v7, serviceID, 0, &context);
  CFBooleanRef v23 = v25;
  if (v25)
  {
    BOOL v26 = (SCNetworkConnectionGetStatus(v25) - 1) < 2;
    CFBooleanRef v27 = v23;
    LODWORD(v23) = v26;
    CFRelease(v27);
  }
  CFStringRef v19 = (const __CFString *)*MEMORY[0x1E4F41AC8];
LABEL_23:
  CFStringRef v28 = SCDynamicStoreKeyCreateNetworkServiceEntity(v7, v19, serviceID, (CFStringRef)*MEMORY[0x1E4F41B10]);
  CFDictionaryRef v29 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, v28);
  if (!v29)
  {
    BOOL v37 = 0;
    goto LABEL_33;
  }
  CFDictionaryRef v30 = v29;
  CFArrayRef v31 = (const __CFArray *)CFDictionaryGetValue(v29, (const void *)*MEMORY[0x1E4F41C60]);
  if (!v31
    || (CFArrayRef v32 = v31, !CFArrayGetCount(v31))
    || (CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v32, 0)) == 0
    || (int v34 = (int)v23, !CFStringGetCString(ValueAtIndex, (char *)&context, 16, 0x600u))
    || (in_addr_t v35 = inet_addr((const char *)&context), v35 == -1))
  {
    CFRelease(v30);
    BOOL v37 = v23 != 0;
    goto LABEL_33;
  }
  unsigned __int16 v36 = v35;
  CFRelease(v30);
  BOOL v37 = v34 != 0;
  if (v36 != 65193)
  {
LABEL_33:
    uint64_t v38 = -66559;
    goto LABEL_34;
  }
  uint64_t v38 = -66558;
LABEL_34:
  if (v37) {
    uint64_t v6 = v38;
  }
  CFRelease(v28);
  CFRelease(v10);
LABEL_37:
  CFRelease(NetworkServiceEntity);
  if (a3) {
    *a3 = _CFNetDiagnosticCopyLocalizedDescription(v6);
  }
  return v6;
}

void TrustExceptionManager::~TrustExceptionManager(TrustExceptionManager *this)
{
  *(void *)this = &unk_1ECFA20D0;
  *((void *)this + 2) = &unk_1ECFA0410;
  CFRelease(*((CFTypeRef *)this + 3));
  *(void *)this = &unk_1ECF9B550;

  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECFA20D0;
  *((void *)this + 2) = &unk_1ECFA0410;
  CFRelease(*((CFTypeRef *)this + 3));
  *(void *)this = &unk_1ECF9B550;
}

void RetainableTypedDict<__CFData const*,__CFData const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0410;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<__CFData const*,__CFData const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0410;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void TrustExceptionManager::storeTrustExceptions(TrustExceptionManager *this, const __CFData *a2, SecTrustRef trust)
{
  if (a2 && trust)
  {
    if (TrustExceptionManager::_isSharingdProcess(void)::onceToken != -1) {
      dispatch_once(&TrustExceptionManager::_isSharingdProcess(void)::onceToken, &__block_literal_global_3_1894);
    }
    if (!TrustExceptionManager::_isSharingdProcess(void)::isSharingd)
    {
      CFDataRef v6 = SecTrustCopyExceptions(trust);
      if (v6)
      {
        CFDataRef v7 = v6;
        CFDataRef Copy = CFDataCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6);
        if (Copy)
        {
          os_unfair_lock_lock((os_unfair_lock_t)this + 2);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 3), a2, Copy);
          CFRelease(Copy);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
        }
        CFRelease(v7);
      }
    }
  }
}

void sub_1841B1260(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN21TrustExceptionManager18_isSharingdProcessEv_block_invoke()
{
  uint64_t v0 = (const char **)_CFGetProgname();
  uint64_t result = strcmp(*v0, "sharingd");
  TrustExceptionManager::_isSharingdProcess(void)::isSharingd = result == 0;
  return result;
}

CFTypeID CFHostGetTypeID(void)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  return *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96);
}

CFHostRef CFHostCreateCopy(CFAllocatorRef alloc, CFHostRef host)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  CFNetDiagnosticStatus v4 = (HostBase *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    CFNetDiagnosticStatus v4 = (HostBase *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  if (host)
  {
    if (HostBase::Class(void)::sOnce_HostBase != -1) {
      dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
    }
    CFAllocatorRef v5 = (CFHostRef)((char *)host + 16);
  }
  else
  {
    CFAllocatorRef v5 = 0;
  }
  HostBase::HostBase(v4, v5);
  *(void *)CFNetDiagnosticStatus v4 = &unk_1ECF9B6D0;
  *((void *)v4 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9B740;
  *((void *)v4 + 18) = copyHostQueue();
  *((void *)v4 + 19) = dispatch_group_create();
  return (HostBase *)((char *)v4 - 16);
}

void sub_1841B1414(_Unwind_Exception *a1)
{
  HostBase::~HostBase(v1);
  _Unwind_Resume(a1);
}

CFHostRef CFHostCreateWithName(CFAllocatorRef allocator, CFStringRef hostname)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  CFAllocatorRef v5 = (DispatchHost *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    CFAllocatorRef v5 = (DispatchHost *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  Array = cfTypeCreateArray(allocator, hostname, 0, 0, 0);
  DispatchHost::DispatchHost(v5, (const __CFString *)&unk_1EC0A4958, Array, 0);
  if (Array) {
    CFRelease(Array);
  }
  if (v5) {
    return (DispatchHost *)((char *)v5 - 16);
  }
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  CFDataRef v7 = (_OWORD *)_CFRuntimeCreateInstance();
  CFAllocatorRef v5 = (DispatchHost *)v7;
  if (v7)
  {
    v7[1] = 0u;
    CFAllocatorRef v5 = (DispatchHost *)(v7 + 1);
    v7[8] = 0u;
    v7[9] = 0u;
    void v7[6] = 0u;
    void v7[7] = 0u;
    v7[4] = 0u;
    void v7[5] = 0u;
    int v7[2] = 0u;
    v7[3] = 0u;
  }
  CFRunLoopSourceRef v8 = cfTypeCreateArray(allocator, hostname, 0, 0, 0);
  Host::Host(v5, (const __CFString *)&unk_1EC0A4958, v8, 0);
  if (v8) {
    CFRelease(v8);
  }
  if (v5) {
    return (DispatchHost *)((char *)v5 - 16);
  }
  else {
    return 0;
  }
}

void sub_1841B15B8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

CFHostRef CFHostCreateWithAddress(CFAllocatorRef allocator, CFDataRef addr)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  CFAllocatorRef v5 = (DispatchHost *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    CFAllocatorRef v5 = (DispatchHost *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  Array = cfTypeCreateArray(allocator, addr, 0, 0, 0);
  DispatchHost::DispatchHost(v5, (const __CFString *)&unk_1EC0A4920, Array, 0);
  if (Array) {
    CFRelease(Array);
  }
  if (v5) {
    return (DispatchHost *)((char *)v5 - 16);
  }
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  CFDataRef v7 = (_OWORD *)_CFRuntimeCreateInstance();
  CFAllocatorRef v5 = (DispatchHost *)v7;
  if (v7)
  {
    v7[1] = 0u;
    CFAllocatorRef v5 = (DispatchHost *)(v7 + 1);
    v7[8] = 0u;
    v7[9] = 0u;
    void v7[6] = 0u;
    void v7[7] = 0u;
    v7[4] = 0u;
    void v7[5] = 0u;
    int v7[2] = 0u;
    v7[3] = 0u;
  }
  CFRunLoopSourceRef v8 = cfTypeCreateArray(allocator, addr, 0, 0, 0);
  Host::Host(v5, (const __CFString *)&unk_1EC0A4920, v8, 0);
  if (v8) {
    CFRelease(v8);
  }
  if (v5) {
    return (DispatchHost *)((char *)v5 - 16);
  }
  else {
    return 0;
  }
}

void sub_1841B1764(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _CFHostCreateWithNameAndPortForConnect(const __CFAllocator *a1, const __CFString *a2, const __CFAllocator *a3)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  CFDataRef v7 = (DispatchHost *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    CFDataRef v7 = (DispatchHost *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  Array = cfTypeCreateArray(a1, a2, 0, 0, 0);
  AutoScalar::AutoScalar((AutoScalar *)&v10, a3);
  DispatchHost::DispatchHost(v7, (const __CFString *)&unk_1EC0A4958, Array, 0x1EC0A4808, cf, 0);
  CFDictionaryRef v10 = &unk_1ECF9A500;
  if (cf) {
    CFRelease(cf);
  }
  if (Array) {
    CFRelease(Array);
  }
  if (v7) {
    return (uint64_t)v7 - 16;
  }
  else {
    return 0;
  }
}

void sub_1841B18B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  if (v14) {
    CFRelease(v14);
  }
  _Unwind_Resume(exception_object);
}

CFTypeRef CFHostGetInfo(uint64_t a1, int a2, BOOL *a3)
{
  CFAllocatorRef v5 = (const void *)infoToString(a2);
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  if (a1) {
    uint64_t v6 = a1 + 16;
  }
  else {
    uint64_t v6 = 0;
  }
  CFRetain((CFTypeRef)(v6 - 16));
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 32));
  ++*(void *)(v6 + 16);
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 96), v5);
  if (Value) {
    CFTypeRef v8 = CFRetain(Value);
  }
  else {
    CFTypeRef v8 = 0;
  }
  HostBase::unlock((HostBase *)v6);
  if (a3) {
    *a3 = v8 != 0;
  }
  if (v8)
  {
    if (v8 == (CFTypeRef)*MEMORY[0x1E4F1D260]
      || (CFTypeID v9 = CFGetTypeID(v8), v9 == CFErrorGetTypeID())
      || v8 == (CFTypeRef)*MEMORY[0x1E4F1CFC8])
    {
      CFRelease(v8);
      return 0;
    }
    else
    {
      if (HostBase::Class(void)::sOnce_HostBase != -1) {
        dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
      }
      CFRetain((CFTypeRef)(v6 - 16));
      pthread_mutex_lock((pthread_mutex_t *)(v6 + 32));
      ++*(void *)(v6 + 16);
      CFMutableArrayRef Mutable = *(__CFDictionary **)(v6 + 128);
      if (!Mutable)
      {
        CFAllocatorRef v11 = CFGetAllocator((CFTypeRef)(v6 - 16));
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v11, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        *(void *)(v6 + 128) = Mutable;
      }
      CFDictionarySetValue(Mutable, v5, v8);
      CFRelease(v8);
      HostBase::unlock((HostBase *)v6);
    }
  }
  return v8;
}

uint64_t infoToString(int a1)
{
  if (!v2 & v1)
  {
    switch(a1)
    {
      case 65531:
        CFStringRef v3 = &_kCFHostByPassMasterAddressLookupString;
        return *v3;
      case 65532:
        CFStringRef v3 = &_kCFHostMasterAddressLookupString;
        return *v3;
      case 65533:
        CFStringRef v3 = &_kCFHostIPv6AddressesString;
        return *v3;
      case 65534:
        CFStringRef v3 = &_kCFHostIPv4AddressesString;
        return *v3;
      default:
        uint64_t result = 0;
        break;
    }
  }
  else
  {
    switch(a1)
    {
      case -1:
        CFStringRef v3 = &_kCFNullHostInfoTypeString;
        break;
      case 0:
        CFStringRef v3 = &kCFHostAddressesString;
        break;
      case 1:
        CFStringRef v3 = &kCFHostNamesString;
        break;
      case 2:
        CFStringRef v3 = &kCFHostReachabilityString;
        break;
      default:
        JUMPOUT(0);
    }
    return *v3;
  }
  return result;
}

Boolean CFHostSetClient(CFHostRef theHost, CFHostClientCallBack clientCB, CFHostClientContext *clientContext)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  if (theHost) {
    uint64_t v6 = (CFHostRef)((char *)theHost + 16);
  }
  else {
    uint64_t v6 = 0;
  }
  if ((unint64_t)clientCB | (unint64_t)clientContext)
  {
    CFAllocatorRef v8 = CFGetAllocator((char *)v6 - 16);
    CFTypeID v9 = (StubHostDelegate *)CFAllocatorAllocate(v8, 96, 0);
    *(_OWORD *)CFTypeID v9 = 0u;
    *((_OWORD *)v9 + 2) = 0u;
    *((_OWORD *)v9 + 3) = 0u;
    *((_OWORD *)v9 + 4) = 0u;
    *((_OWORD *)v9 + 5) = 0u;
    *((_OWORD *)v9 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
    uint64_t v10 = (uint64_t)v9 + 16;
    StubHostDelegate::StubHostDelegate(v9, v8, clientContext);
    *CFAllocatorRef v11 = &unk_1ECF9F9D8;
    *(void *)uint64_t v10 = &unk_1ECF9FA10;
    v11[11] = clientCB;
    Boolean v12 = HostBase::setDelegate(v6, v10);
    (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
    return v12;
  }
  else
  {
    return HostBase::setDelegate(v6, 0);
  }
}

uint64_t _CFHostSetClientInfoCallback(__CFHost *a1, unint64_t a2, CFHostClientContext *a3)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  if (a1) {
    uint64_t v6 = (__CFHost *)((char *)a1 + 16);
  }
  else {
    uint64_t v6 = 0;
  }
  if (a2 | (unint64_t)a3)
  {
    CFAllocatorRef v8 = CFGetAllocator((char *)v6 - 16);
    CFTypeID v9 = (StubHostDelegate *)CFAllocatorAllocate(v8, 96, 0);
    *(_OWORD *)CFTypeID v9 = 0u;
    *((_OWORD *)v9 + 2) = 0u;
    *((_OWORD *)v9 + 3) = 0u;
    *((_OWORD *)v9 + 4) = 0u;
    *((_OWORD *)v9 + 5) = 0u;
    *((_OWORD *)v9 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
    uint64_t v10 = (uint64_t)v9 + 16;
    StubHostDelegate::StubHostDelegate(v9, v8, a3);
    *CFAllocatorRef v11 = &unk_1ECF9ED50;
    *(void *)uint64_t v10 = &unk_1ECF9ED88;
    v11[11] = a2;
    uint64_t v12 = HostBase::setDelegate(v6, v10);
    (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
    return v12;
  }
  else
  {
    return HostBase::setDelegate(v6, 0);
  }
}

CFArrayRef CFHostGetAddressing(CFHostRef theHost, Boolean *hasBeenResolved)
{
  return (CFArrayRef)CFHostGetInfo((uint64_t)theHost, 0, (BOOL *)hasBeenResolved);
}

CFArrayRef CFHostGetNames(CFHostRef theHost, Boolean *hasBeenResolved)
{
  return (CFArrayRef)CFHostGetInfo((uint64_t)theHost, 1, (BOOL *)hasBeenResolved);
}

CFDataRef CFHostGetReachability(CFHostRef theHost, Boolean *hasBeenResolved)
{
  return (CFDataRef)CFHostGetInfo((uint64_t)theHost, 2, (BOOL *)hasBeenResolved);
}

Boolean CFHostStartInfoResolution(CFHostRef theHost, CFHostInfoType info, CFStreamError *error)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  if (theHost) {
    uint64_t v6 = (char *)theHost + 16;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = infoToString(info);
  CFAllocatorRef v8 = (__CFError *)(*(uint64_t (**)(char *, uint64_t, void, void))(*(void *)v6 + 56))(v6, v7, 0, 0);
  if (v8)
  {
    CFTypeID v9 = v8;
    if (error)
    {
      error->CFStringRef domain = _CFStreamErrorFromCFError(v8);
      *(void *)&error->SInt32 error = v10;
    }
    CFRelease(v9);
    return 0;
  }
  else
  {
    if (error)
    {
      error->SInt32 error = 0;
      error->CFStringRef domain = 0;
    }
    return 1;
  }
}

uint64_t _CFHostStartInfoResolutionForInterface(uint64_t a1)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  if (a1) {
    uint64_t v2 = a1 + 16;
  }
  else {
    uint64_t v2 = 0;
  }
  CFStringRef v3 = *(uint64_t (**)(void))(*(void *)v2 + 56);

  return v3();
}

void CFHostCancelInfoResolution(CFHostRef theHost, CFHostInfoType info)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  if (theHost) {
    CFNetDiagnosticStatus v4 = (char *)theHost + 16;
  }
  else {
    CFNetDiagnosticStatus v4 = 0;
  }
  uint64_t v5 = infoToString(info);
  uint64_t v6 = *(void (**)(char *, uint64_t))(*(void *)v4 + 64);

  v6(v4, v5);
}

void CFHostScheduleWithRunLoop(CFHostRef theHost, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  if (theHost) {
    CFNetDiagnosticStatus v4 = (char *)theHost + 16;
  }
  else {
    CFNetDiagnosticStatus v4 = 0;
  }
  uint64_t v5 = *(void (**)(void))(*(void *)v4 + 72);

  v5();
}

void CFHostUnscheduleFromRunLoop(CFHostRef theHost, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  if (HostBase::Class(void)::sOnce_HostBase != -1) {
    dispatch_once(&HostBase::Class(void)::sOnce_HostBase, &__block_literal_global_17861);
  }
  if (theHost) {
    CFNetDiagnosticStatus v4 = (char *)theHost + 16;
  }
  else {
    CFNetDiagnosticStatus v4 = 0;
  }
  uint64_t v5 = *(void (**)(void))(*(void *)v4 + 80);

  v5();
}

BOOL CFNetDiagnosticPingWithOptions(const __CFString *a1, const __CFDictionary *a2, CFErrorRef *a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  bzero(buffer, 0x400uLL);
  if (!a1 || !CFStringGetLength(a1) || !CFStringGetCString(a1, buffer, 1024, 0x8000100u))
  {
    BOOL v11 = 0;
    int v12 = 22;
    goto LABEL_7;
  }
  *(_DWORD *)&char __dst[8] = 0;
  *(void *)__dst = inet_addr(buffer);
  if (*(_DWORD *)__dst == -1)
  {
    BOOL v16 = gethostbyname(buffer);
    if (!v16)
    {
      BOOL v11 = 0;
      int v12 = 65;
      goto LABEL_7;
    }
    h_addrnw_endpoint_type_t type = v16->h_addrtype;
    memcpy(__dst, *(const void **)v16->h_addr_list, v16->h_length);
    int v10 = h_addrtype << 8;
  }
  else
  {
    int v10 = 512;
  }
  int v52 = v10;
  int v58 = 0;
  int valuePtr = 10;
  int v55 = 0;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"kCFNetDiagnosticPingOptionTimeout");
  if (Value) {
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  }
  int v56 = 0;
  CFNumberRef v19 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kCFNetDiagnosticPingOptionTypeOfService");
  if (v19) {
    CFNumberGetValue(v19, kCFNumberIntType, &v56);
  }
  int v57 = 0;
  CFNumberRef v20 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kCFNetDiagnosticPingOptionTrafficClass");
  if (v20) {
    CFNumberGetValue(v20, kCFNumberIntType, &v57);
  }
  int v55 = 1;
  CFNumberRef v21 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kCFNetDiagnosticPingOptionPacketCount");
  if (v21) {
    CFNumberGetValue(v21, kCFNumberIntType, &v55);
  }
  int v58 = 0;
  CFNumberRef v22 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kCFNetDiagnosticPingOptionDataLength");
  if (v22) {
    CFNumberGetValue(v22, kCFNumberIntType, &v58);
  }
  LODWORD(v61.tv_sec) = 51200;
  CFBooleanRef v23 = getprotobyname("icmp");
  if (!v23)
  {
    int v12 = 46;
LABEL_37:
    BOOL v11 = 0;
    goto LABEL_7;
  }
  int v24 = socket(2, 2, v23->p_proto);
  int v25 = v24;
  if (v24 < 0)
  {
    int v12 = 1;
    goto LABEL_37;
  }
  setsockopt(v24, 0xFFFF, 4098, &v61, 4u);
  *(void *)&v64.sa_len = 1;
  *(_DWORD *)&v64.sa_data[6] = 0;
  if (setsockopt(v25, 0xFFFF, 4102, &v64, 0x10u))
  {
    close(v25);
    int v12 = *__error();
  }
  else
  {
    int v12 = 0;
  }
  BOOL v11 = 0;
  if (v12 || v55 < 1) {
    goto LABEL_110;
  }
  unsigned int v26 = 0;
  BOOL v11 = 0;
  int v51 = *(_DWORD *)__dst;
  uint64_t v50 = *(void *)&__dst[4];
  while (1)
  {
    int v27 = v57;
    int v28 = v58;
    int v29 = v56;
    *(_DWORD *)&v64.sa_len = v52;
    *(_DWORD *)&v64.sa_data[2] = v51;
    *(void *)&v64.sa_data[6] = v50;
    size_t v30 = v58 + 48;
    CFArrayRef v31 = (unsigned __int16 *)malloc_type_calloc(1uLL, v30, 0xC9121D6uLL);
    CFArrayRef v32 = v31;
    if (!v31)
    {
      int v12 = 12;
      break;
    }
    *CFArrayRef v31 = 8;
    CFTypeRef v31[3] = bswap32(v26) >> 16;
    _OWORD v31[2] = bswap32(getpid()) >> 16;
    if (!gettimeofday((timeval *)v32 + 2, 0))
    {
      uint64_t v49 = v28;
      if (v28 >= 1)
      {
        char v33 = v32 + 24;
        uint64_t v34 = v49;
        do
        {
          *v33++ = random();
          --v34;
        }
        while (v34);
      }
      if (!v27) {
        goto LABEL_56;
      }
      LODWORD(v61.tv_sec) = v27;
      if (!setsockopt(v25, 0xFFFF, 4230, &v61, 4u)) {
        goto LABEL_56;
      }
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      in_addr_t v35 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)&v65.sa_len = 0;
        _os_log_error_impl(&dword_184085000, v35, OS_LOG_TYPE_ERROR, "setsockopt SO_TRAFFIC_CLASS failed", &v65.sa_len, 2u);
        if (!v29) {
          goto LABEL_62;
        }
      }
      else
      {
LABEL_56:
        if (!v29) {
          goto LABEL_62;
        }
      }
      LODWORD(v61.tv_sec) = v29;
      if (setsockopt(v25, 0, 3, &v61, 4u))
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        unsigned __int16 v36 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)&v65.sa_len = 0;
          _os_log_error_impl(&dword_184085000, v36, OS_LOG_TYPE_ERROR, "setsockopt IP_TOS failed", &v65.sa_len, 2u);
        }
      }
LABEL_62:
      if ((int)v30 < 2)
      {
        int v37 = 0;
        unsigned int v41 = v30;
        uint64_t v39 = v32;
      }
      else
      {
        int v37 = 0;
        unsigned int v38 = v49 + 50;
        uint64_t v39 = v32;
        do
        {
          int v40 = *v39++;
          v37 += v40;
          v38 -= 2;
        }
        while (v38 > 3);
        unsigned int v41 = v38 - 2;
      }
      if (v41 == 1) {
        v37 += *(unsigned __int8 *)v39;
      }
      v32[1] = ~(HIWORD(v37) + v37 + (((v37 >> 16) + (unsigned __int16)v37) >> 16));
      ssize_t v42 = sendto(v25, v32, v30, 0, &v64, 0x10u);
      if (v42 < 0 || v42 != v30)
      {
        if (*__error()) {
          int v12 = *__error();
        }
        else {
          int v12 = 1;
        }
      }
      else
      {
        int v12 = 0;
      }
      free(v32);
      if (v12) {
        break;
      }
      goto LABEL_76;
    }
    if (!*__error())
    {
      int v12 = 1;
      break;
    }
    int v12 = *__error();
    if (v12) {
      break;
    }
LABEL_76:
    __darwin_time_t v43 = valuePtr;
    if (valuePtr <= 0)
    {
      int v12 = 22;
      break;
    }
    char v44 = 1;
    while (1)
    {
      socklen_t v60 = 16;
      ssize_t v45 = recvfrom(v25, &v64, 0x800uLL, 0, &v65, &v60);
      int v46 = v45;
      if ((v45 & 0x8000000000000000) == 0) {
        break;
      }
      int v12 = *__error();
      if (v44) {
        goto LABEL_82;
      }
LABEL_83:
      if (v12 == 35) {
        goto LABEL_87;
      }
      if (v12) {
        goto LABEL_101;
      }
      uint64_t v47 = 4 * (v64.sa_len & 0xF);
      if (((v46 - v47) & 0xFFFFFFF0) < 0x30uLL || (CFRange v48 = &v64.sa_len + v47, *v48)) {
LABEL_87:
      }
        BOOL v11 = 0;
      else {
        BOOL v11 = *((unsigned __int16 *)v48 + 2) == bswap32(getpid()) >> 16;
      }
      if (gettimeofday(&v59, 0))
      {
        if (*__error()) {
          int v12 = *__error();
        }
        else {
          int v12 = 1;
        }
      }
      else
      {
        int v12 = 0;
      }
      if (v12 || v59.tv_sec - v61.tv_sec - (v59.tv_usec < v61.tv_usec) >= v43) {
        goto LABEL_102;
      }
      char v44 = 0;
      if (v11)
      {
        int v12 = 0;
        BOOL v11 = 1;
        goto LABEL_102;
      }
    }
    int v12 = 0;
    if ((v44 & 1) == 0) {
      goto LABEL_83;
    }
LABEL_82:
    if (!gettimeofday(&v61, 0)) {
      goto LABEL_83;
    }
    if (*__error()) {
      int v12 = *__error();
    }
    else {
      int v12 = 1;
    }
LABEL_101:
    BOOL v11 = 0;
LABEL_102:
    if (!v12 && v55 > (__int16)++v26) {
      continue;
    }
    break;
  }
LABEL_110:
  close(v25);
LABEL_7:
  if (a3)
  {
    if (v12)
    {
      CFCFStreamError Error = __cfnCreateCFError(0, (CFErrorDomain)*MEMORY[0x1E4F1D160], v12, v5, v6, v7, v8, v9, 0);
      goto LABEL_10;
    }
    if (!v11)
    {
      CFCFStreamError Error = __cfnCreateCFError(0, (CFErrorDomain)*MEMORY[0x1E4F1D160], 60, v5, v6, v7, v8, v9, 0);
LABEL_10:
      *a3 = CFError;
    }
  }
  if (v12) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = !v11;
  }
  return !v14;
}

BOOL CFNetDiagnosticPing(const __CFString *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v11 = a3;
  uint64_t valuePtr = a2;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberCFIndexType, &v11);
  CFDictionarySetValue(Mutable, @"kCFNetDiagnosticPingOptionPacketCount", v7);
  CFDictionarySetValue(Mutable, @"kCFNetDiagnosticPingOptionTimeout", v8);
  BOOL v9 = CFNetDiagnosticPingWithOptions(a1, Mutable, a4);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(Mutable);
  return v9;
}

CFStringRef _CFNetworkCopyDefaultUserAgentString()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  pthread_once(&initControl, initializeUserAgentString);
  CFStringRef v1 = (const __CFString *)sUserAgentString;

  return CFStringCreateCopy(v0, v1);
}

CFStringRef copyMIMETypeForExtension(CFStringRef inTag)
{
  CFStringRef result = UTTypeCreatePreferredIdentifierForTag((CFStringRef)*MEMORY[0x1E4F224F8], inTag, (CFStringRef)*MEMORY[0x1E4F22590]);
  if (result)
  {
    CFStringRef v2 = result;
    CFStringRef v3 = UTTypeCopyPreferredTagWithClass(result, (CFStringRef)*MEMORY[0x1E4F22500]);
    CFRelease(v2);
    return v3;
  }
  return result;
}

CFStringRef copyPreferredExtensionForMIMEType(CFStringRef inTag)
{
  CFStringRef result = UTTypeCreatePreferredIdentifierForTag((CFStringRef)*MEMORY[0x1E4F22500], inTag, (CFStringRef)*MEMORY[0x1E4F22590]);
  if (result)
  {
    CFStringRef v2 = result;
    CFStringRef v3 = UTTypeCopyPreferredTagWithClass(result, (CFStringRef)*MEMORY[0x1E4F224F8]);
    CFRelease(v2);
    return v3;
  }
  return result;
}

CFStringRef createSanitizedFileNameFromString(const __CFString *cf)
{
  if (!createSanitizedFileNameFromString::charsToReplaceWithADash) {
    createSanitizedFileNameFromString::charsToReplaceWithADash = (uint64_t)CFCharacterSetCreateWithCharactersInString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @":/");
  }
  CFAllocatorRef v2 = CFGetAllocator(cf);
  CFMutableStringRef Mutable = CFStringCreateMutable(v2, 0);
  if (!Mutable) {
    return 0;
  }
  CFNetDiagnosticStatus v4 = Mutable;
  UniChar chars = 0;
  CFIndex Length = CFStringGetLength(cf);
  CFStringRef v26 = cf;
  uint64_t v29 = 0;
  CFIndex v30 = Length;
  CharactersPtr = CFStringGetCharactersPtr(cf);
  CStringPtr = 0;
  int v27 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(cf, 0x600u);
  }
  int v28 = CStringPtr;
  int64_t v31 = 0;
  int64_t v32 = 0;
  if (Length >= 1)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    int64_t v10 = 0;
    uint64_t v11 = 64;
    do
    {
      if ((unint64_t)v10 >= 4) {
        uint64_t v12 = 4;
      }
      else {
        uint64_t v12 = v10;
      }
      CFIndex v13 = v30;
      if (v30 <= v10)
      {
        UniChar chars = 0;
      }
      else
      {
        if (v27)
        {
          UniChar v14 = v27[v10 + v29];
        }
        else if (v28)
        {
          UniChar v14 = v28[v29 + v10];
        }
        else
        {
          int64_t v15 = v31;
          if (v32 <= v10 || v31 > v10)
          {
            uint64_t v17 = v12 + v8;
            uint64_t v18 = v11 - v12;
            int64_t v19 = v10 - v12;
            CFIndex v20 = v19 + 64;
            if (v19 + 64 >= v30) {
              CFIndex v20 = v30;
            }
            int64_t v31 = v19;
            int64_t v32 = v20;
            if (v30 >= v18) {
              CFIndex v13 = v18;
            }
            v33.CFIndex length = v13 + v17;
            v33.CFIndex location = v19 + v29;
            CFStringGetCharacters(v26, v33, buffer);
            int64_t v15 = v31;
          }
          UniChar v14 = buffer[v10 - v15];
        }
        UniChar chars = v14;
        if (v14)
        {
          if (v9 || v14 != 46)
          {
            if (CFCharacterSetIsCharacterMember((CFCharacterSetRef)createSanitizedFileNameFromString::charsToReplaceWithADash, v14))
            {
              CFStringAppend(v4, @"_");
              int v9 = 1;
            }
            else
            {
              int v9 = 1;
              CFStringAppendCharacters(v4, &chars, 1);
            }
          }
          else
          {
            int v9 = 0;
          }
        }
      }
      ++v10;
      --v8;
      ++v11;
    }
    while (Length != v10);
  }
  if (CFStringGetLength(v4))
  {
    CFAllocatorRef v21 = CFGetAllocator(cf);
    CFStringRef Copy = CFStringCreateCopy(v21, v4);
  }
  else
  {
    CFStringRef Copy = 0;
  }
  CFRelease(v4);
  return Copy;
}

CFStringRef createFilenameFromContentDispositionHeader(const __CFString *a1)
{
  CFStringRef v1 = a1;
  CFIndex Length = CFStringGetLength(a1);
  buffer.CFStringRef theString = v1;
  buffer.rangeToBuffer.CFIndex location = 0;
  buffer.rangeToBuffer.CFIndex length = Length;
  CharactersPtr = CFStringGetCharactersPtr(v1);
  CStringPtr = 0;
  buffer.directUniCharBuffer = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(v1, 0x600u);
  }
  buffer.CFIndex bufferedRangeStart = 0;
  buffer.bufferedRangeEnd = 0;
  buffer.directCStringBuffer = CStringPtr;
  CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  uint64_t v6 = 0;
  int64_t v7 = 0;
  CFIndex v8 = Length - 1;
  if (Length <= 1) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = Length;
  }
  for (uint64_t i = 64; ; ++i)
  {
    uint64_t v11 = (unint64_t)v7 >= 4 ? 4 : v7;
    CFIndex v12 = buffer.rangeToBuffer.length;
    if (buffer.rangeToBuffer.length <= v7)
    {
      UniChar v13 = 0;
    }
    else if (buffer.directUniCharBuffer)
    {
      UniChar v13 = buffer.directUniCharBuffer[v7 + buffer.rangeToBuffer.location];
    }
    else if (buffer.directCStringBuffer)
    {
      UniChar v13 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
    }
    else
    {
      CFIndex bufferedRangeStart = buffer.bufferedRangeStart;
      BOOL v15 = buffer.bufferedRangeEnd > v7 && buffer.bufferedRangeStart <= v7;
      if (!v15)
      {
        uint64_t v16 = v11 + v6;
        CFIndex v17 = i - v11;
        CFIndex v18 = v7 - v11;
        CFIndex v19 = v18 + 64;
        if (v18 + 64 >= buffer.rangeToBuffer.length) {
          CFIndex v19 = buffer.rangeToBuffer.length;
        }
        buffer.CFIndex bufferedRangeStart = v18;
        buffer.bufferedRangeEnd = v19;
        if (buffer.rangeToBuffer.length >= v17) {
          CFIndex v12 = v17;
        }
        v237.CFIndex length = v12 + v16;
        v237.CFIndex location = v18 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v237, buffer.buffer);
        CFIndex bufferedRangeStart = buffer.bufferedRangeStart;
      }
      UniChar v13 = buffer.buffer[v7 - bufferedRangeStart];
    }
    if (!CFCharacterSetIsCharacterMember(Predefined, v13)) {
      break;
    }
    ++v7;
    --v6;
    if (v9 == v7) {
      return 0;
    }
  }
  if (Length - v7 < 9) {
    return 0;
  }
  CFStringRef v20 = 0;
  uint64_t v21 = 0x1EC0A3D18;
  CFNumberRef v22 = &buffer.buffer[1];
  CFIndex v23 = 1 - Length;
LABEL_31:
  v253.CFIndex location = v7;
  v253.CFIndex length = 8;
  if (!CFStringFindWithOptions(v1, @"filename", v253, 9uLL, &result)) {
    goto LABEL_236;
  }
  int64_t v7 = result.length + result.location;
  if (result.length + result.location >= Length) {
    goto LABEL_413;
  }
  if (v7 < 0) {
    goto LABEL_43;
  }
  CFIndex v24 = buffer.rangeToBuffer.length;
  if (buffer.rangeToBuffer.length <= v7) {
    goto LABEL_43;
  }
  directUniCharBuffer = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
  if (buffer.directUniCharBuffer)
  {
    CFIndex v26 = buffer.rangeToBuffer.location + v7;
LABEL_37:
    UniChar v27 = directUniCharBuffer->buffer[v26];
    goto LABEL_40;
  }
  if (!buffer.directCStringBuffer)
  {
    if (buffer.bufferedRangeEnd <= v7 || (CFIndex v66 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
    {
      CFIndex v67 = v7 - 4;
      if ((unint64_t)v7 < 4) {
        CFIndex v67 = 0;
      }
      if (v67 + 64 < buffer.rangeToBuffer.length) {
        CFIndex v24 = v67 + 64;
      }
      buffer.CFIndex bufferedRangeStart = v67;
      buffer.bufferedRangeEnd = v24;
      v240.CFIndex location = buffer.rangeToBuffer.location + v67;
      v240.CFIndex length = v24 - v67;
      CFStringGetCharacters(buffer.theString, v240, buffer.buffer);
      CFIndex v66 = buffer.bufferedRangeStart;
    }
    CFIndex v26 = v7 - v66;
    directUniCharBuffer = &buffer;
    goto LABEL_37;
  }
  UniChar v27 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
LABEL_40:
  if (v27 != 42)
  {
LABEL_43:
    if (v20) {
      goto LABEL_236;
    }
    CFCharacterSetRef theSet = 0;
    CFIndex v232 = v23;
    CFIndex v227 = v8;
    CFStringRef v228 = (const __CFString *)v21;
    int v28 = v22;
    char v29 = 0;
    goto LABEL_45;
  }
  if (++v7 >= Length) {
    goto LABEL_413;
  }
  CFCharacterSetRef theSet = (CFCharacterSetRef)v20;
  CFIndex v232 = v23;
  CFIndex v227 = v8;
  CFStringRef v228 = (const __CFString *)v21;
  int v28 = v22;
  char v29 = 1;
LABEL_45:
  int64_t v30 = -v7;
  int64_t v31 = v7 + 64;
  do
  {
    if ((unint64_t)v7 >= 4) {
      uint64_t v32 = 4;
    }
    else {
      uint64_t v32 = v7;
    }
    if (v7 < 0 || (CFIndex v33 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v7))
    {
      UniChar v34 = 0;
    }
    else if (buffer.directUniCharBuffer)
    {
      UniChar v34 = buffer.directUniCharBuffer[v7 + buffer.rangeToBuffer.location];
    }
    else if (buffer.directCStringBuffer)
    {
      UniChar v34 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
    }
    else
    {
      if (buffer.bufferedRangeEnd <= v7 || (CFIndex v36 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
      {
        uint64_t v37 = v32 + v30;
        CFIndex v38 = v31 - v32;
        CFIndex v39 = v7 - v32;
        CFIndex v40 = v39 + 64;
        if (v39 + 64 >= buffer.rangeToBuffer.length) {
          CFIndex v40 = buffer.rangeToBuffer.length;
        }
        buffer.CFIndex bufferedRangeStart = v39;
        buffer.bufferedRangeEnd = v40;
        if (buffer.rangeToBuffer.length >= v38) {
          CFIndex v33 = v38;
        }
        v238.CFIndex length = v33 + v37;
        v238.CFIndex location = v39 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v238, buffer.buffer);
        CFIndex v36 = buffer.bufferedRangeStart;
      }
      UniChar v34 = buffer.buffer[v7 - v36];
    }
    int v35 = v34;
    if (!CFCharacterSetIsCharacterMember(Predefined, v34)) {
      break;
    }
    ++v7;
    --v30;
    ++v31;
  }
  while (v7 < Length);
  if (v35 != 61)
  {
    CFNumberRef v22 = v28;
    CFIndex v8 = v227;
    uint64_t v21 = (uint64_t)v228;
LABEL_92:
    CFStringRef v20 = (CFStringRef)theSet;
    CFIndex v23 = v232;
    goto LABEL_236;
  }
  unint64_t v41 = v7 + 1;
  if (v7 + 1 >= Length)
  {
LABEL_417:
    CFStringRef v20 = (CFStringRef)theSet;
    goto LABEL_413;
  }
  CFNumberRef v22 = v28;
  int64_t v42 = ~v7;
  int64_t v43 = v7 + 65;
  CFIndex v8 = v227;
  while (1)
  {
    CFIndex v44 = v7 + 1;
    uint64_t v45 = v41 >= 4 ? 4 : v41;
    if (v44 < 0 || (CFIndex v46 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v44))
    {
      UniChar v47 = 0;
    }
    else if (buffer.directUniCharBuffer)
    {
      UniChar v47 = buffer.directUniCharBuffer[v7 + 1 + buffer.rangeToBuffer.location];
    }
    else if (buffer.directCStringBuffer)
    {
      UniChar v47 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 1 + v7];
    }
    else
    {
      if (buffer.bufferedRangeEnd <= v44 || (CFIndex v48 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v44))
      {
        uint64_t v49 = v45 + v42;
        CFIndex v50 = v43 - v45;
        int64_t v51 = v7 - v45;
        CFIndex v52 = v51 + 1;
        CFIndex v53 = v51 + 65;
        if (v53 >= buffer.rangeToBuffer.length) {
          CFIndex v53 = buffer.rangeToBuffer.length;
        }
        buffer.CFIndex bufferedRangeStart = v52;
        buffer.bufferedRangeEnd = v53;
        if (buffer.rangeToBuffer.length >= v50) {
          CFIndex v46 = v50;
        }
        v239.CFIndex length = v46 + v49;
        v239.CFIndex location = v52 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v239, buffer.buffer);
        CFIndex v48 = buffer.bufferedRangeStart;
      }
      UniChar v47 = v22[v7 - v48];
    }
    if (!CFCharacterSetIsCharacterMember(Predefined, v47)) {
      break;
    }
    ++v41;
    ++v7;
    --v42;
    ++v43;
    if (v227 == v7)
    {
      int64_t v7 = Length;
      goto LABEL_94;
    }
  }
  ++v7;
LABEL_94:
  uint64_t v54 = 0x1EC0A42C8;
  CFStringRef v20 = (CFStringRef)theSet;
  CFIndex v23 = v232;
  if ((v29 & 1) == 0)
  {
    if (theSet)
    {
      BOOL v61 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT);
      uint64_t v54 = 0x1EC0A42C8;
      if (v61)
      {
        LOWORD(v236.location) = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "filename should be NULL", (uint8_t *)&v236, 2u);
        uint64_t v54 = 0x1EC0A42C8;
      }
    }
    if (Length <= v7) {
      goto LABEL_413;
    }
    uint64_t v21 = (uint64_t)v228;
    if ((v7 & 0x8000000000000000) == 0)
    {
      CFIndex v62 = buffer.rangeToBuffer.length;
      if (buffer.rangeToBuffer.length > v7)
      {
        p_CFStringInlineBuffer buffer = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
        if (buffer.directUniCharBuffer)
        {
          CFIndex v64 = buffer.rangeToBuffer.location + v7;
          goto LABEL_114;
        }
        if (buffer.directCStringBuffer)
        {
          UniChar v65 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
        }
        else
        {
          if (buffer.bufferedRangeEnd <= v7 || (CFIndex v104 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
          {
            CFIndex v105 = v7 - 4;
            if ((unint64_t)v7 < 4) {
              CFIndex v105 = 0;
            }
            if (v105 + 64 < buffer.rangeToBuffer.length) {
              CFIndex v62 = v105 + 64;
            }
            buffer.CFIndex bufferedRangeStart = v105;
            buffer.bufferedRangeEnd = v62;
            v243.CFIndex location = buffer.rangeToBuffer.location + v105;
            v243.CFIndex length = v62 - v105;
            CFStringGetCharacters(buffer.theString, v243, buffer.buffer);
            uint64_t v54 = 0x1EC0A42C8;
            uint64_t v21 = (uint64_t)v228;
            CFIndex v104 = buffer.bufferedRangeStart;
          }
          CFIndex v64 = v7 - v104;
          p_CFStringInlineBuffer buffer = &buffer;
LABEL_114:
          UniChar v65 = p_buffer->buffer[v64];
        }
        if (v65 == 59 || v65 == 44) {
          goto LABEL_236;
        }
        if (v65 == 34)
        {
          v222 = v22;
          int64_t v70 = v7 + 1;
          if (v7 + 1 >= Length) {
            goto LABEL_413;
          }
          CFIndex v71 = buffer.rangeToBuffer.length;
          if (buffer.rangeToBuffer.length <= v70)
          {
            UniChar v72 = 0;
          }
          else
          {
            if (buffer.directUniCharBuffer)
            {
              UniChar v72 = buffer.directUniCharBuffer[buffer.rangeToBuffer.location + v70];
            }
            else if (buffer.directCStringBuffer)
            {
              UniChar v72 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v70];
            }
            else
            {
              if (buffer.bufferedRangeEnd <= v70 || (CFIndex v175 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v70))
              {
                CFIndex v176 = v7 - 3;
                if ((unint64_t)v70 < 4) {
                  CFIndex v176 = 0;
                }
                if (v176 + 64 < buffer.rangeToBuffer.length) {
                  CFIndex v71 = v176 + 64;
                }
                buffer.CFIndex bufferedRangeStart = v176;
                buffer.bufferedRangeEnd = v71;
                v250.CFIndex location = buffer.rangeToBuffer.location + v176;
                v250.CFIndex length = v71 - v176;
                CFStringGetCharacters(buffer.theString, v250, buffer.buffer);
                int64_t v70 = v7 + 1;
                CFIndex v175 = buffer.bufferedRangeStart;
              }
              UniChar v72 = buffer.buffer[v70 - v175];
              uint64_t v54 = 0x1EC0A42C8;
              uint64_t v21 = (uint64_t)v228;
            }
            if (v72 == 34)
            {
              uint64_t v87 = v7 + 2;
              goto LABEL_366;
            }
          }
          int v177 = 0;
          int64_t v178 = v70;
          while (1)
          {
            if (v72 == 92)
            {
              int v177 = 1;
              uint64_t v179 = 2;
            }
            else
            {
              if (v72 == 34)
              {
                CFIndex v185 = v178 - v70;
                CFIndex v186 = v70;
                CFAllocatorRef v187 = CFGetAllocator(v1);
                v257.CFIndex location = v186;
                v257.CFIndex length = v185;
                float v188 = (__CFString *)CFStringCreateWithSubstring(v187, v1, v257);
                uint64_t v189 = v188;
                if (v177 && v188 && (CFMutableStringRef v190 = cdReplaceQuotedPairs(v188)) != 0)
                {
                  CFStringRef v20 = v190;
                  CFRelease(v189);
                }
                else
                {
                  CFStringRef v20 = v189;
                }
                uint64_t v87 = v178 + 1;
LABEL_366:
                CFNumberRef v22 = v222;
LABEL_188:
                int64_t v7 = v87;
                if (v87 >= Length) {
                  goto LABEL_413;
                }
                goto LABEL_236;
              }
              uint64_t v179 = 1;
            }
            v178 += v179;
            if (v178 >= Length) {
              goto LABEL_413;
            }
            UniChar v72 = 0;
            if ((v178 & 0x8000000000000000) == 0)
            {
              UniChar v72 = 0;
              CFIndex v180 = buffer.rangeToBuffer.length;
              if (buffer.rangeToBuffer.length > v178)
              {
                if (buffer.directUniCharBuffer)
                {
                  UniChar v72 = buffer.directUniCharBuffer[buffer.rangeToBuffer.location + v178];
                }
                else if (buffer.directCStringBuffer)
                {
                  UniChar v72 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v178];
                }
                else
                {
                  if (buffer.bufferedRangeEnd <= v178
                    || (CFIndex v181 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v178))
                  {
                    CFIndex v182 = v178 - 4;
                    if ((unint64_t)v178 < 4) {
                      CFIndex v182 = 0;
                    }
                    if (v182 + 64 < buffer.rangeToBuffer.length) {
                      CFIndex v180 = v182 + 64;
                    }
                    buffer.CFIndex bufferedRangeStart = v182;
                    buffer.bufferedRangeEnd = v180;
                    uint64_t v183 = v54;
                    v251.CFIndex location = buffer.rangeToBuffer.location + v182;
                    int64_t v184 = v70;
                    v251.CFIndex length = v180 - v182;
                    CFStringGetCharacters(buffer.theString, v251, buffer.buffer);
                    int64_t v70 = v184;
                    uint64_t v54 = v183;
                    uint64_t v21 = (uint64_t)v228;
                    CFIndex v181 = buffer.bufferedRangeStart;
                  }
                  UniChar v72 = buffer.buffer[v178 - v181];
                }
              }
            }
          }
        }
      }
    }
    v223 = v22;
    unint64_t v73 = v7 + 1;
    if (v7 + 1 >= Length) {
      goto LABEL_413;
    }
    CFStringRef v229 = (CFStringRef)v21;
    uint64_t v74 = 0;
    int64_t v75 = ~v7;
    int64_t v76 = v7 + 65;
    BOOL v77 = &v223[v7];
    while (1)
    {
      CFIndex v78 = v7 + v74 + 1;
      if (v73 >= 4) {
        uint64_t v79 = 4;
      }
      else {
        uint64_t v79 = v73;
      }
      if ((v78 & 0x8000000000000000) == 0)
      {
        CFIndex v80 = buffer.rangeToBuffer.length;
        if (buffer.rangeToBuffer.length > v78)
        {
          if (buffer.directUniCharBuffer)
          {
            UniChar v81 = buffer.directUniCharBuffer[v7 + 1 + v74 + buffer.rangeToBuffer.location];
          }
          else if (buffer.directCStringBuffer)
          {
            UniChar v81 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 1 + v7 + v74];
          }
          else
          {
            if (buffer.bufferedRangeEnd <= v78 || (CFIndex v82 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v78))
            {
              uint64_t v83 = v79 + v75;
              CFIndex v84 = v76 - v79;
              v224 = v77;
              CFIndex v85 = v7 + v74 + 1 - v79;
              uint64_t v86 = v7 + v74 + 65 - v79;
              if (v86 >= buffer.rangeToBuffer.length) {
                uint64_t v86 = buffer.rangeToBuffer.length;
              }
              buffer.CFIndex bufferedRangeStart = v85;
              buffer.bufferedRangeEnd = v86;
              if (buffer.rangeToBuffer.length >= v84) {
                CFIndex v80 = v84;
              }
              v241.CFIndex length = v80 + v83;
              v241.CFIndex location = v85 + buffer.rangeToBuffer.location;
              CFStringGetCharacters(buffer.theString, v241, buffer.buffer);
              BOOL v77 = v224;
              CFIndex v82 = buffer.bufferedRangeStart;
            }
            UniChar v81 = v77[v74 - v82];
          }
          if (v81 > 0x3Au)
          {
            if (v81 == 59) {
              goto LABEL_160;
            }
            if (v81 == 92)
            {
LABEL_184:
              v7 += v74 + 1;
              uint64_t v21 = (uint64_t)v229;
              CFNumberRef v22 = v223;
              goto LABEL_92;
            }
          }
          else
          {
            if (v81 == 34) {
              goto LABEL_184;
            }
            if (v81 == 44)
            {
LABEL_160:
              uint64_t v87 = v7 + v74 + 1;
LABEL_161:
              CFIndex v88 = v87 - v7;
              CFCharacterSetRef theSeta = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
              if (v87 - v7 >= 2)
              {
                unint64_t v89 = v87 - 1;
                uint64_t v90 = 1 - v87;
                CFIndex v91 = v87;
                uint64_t v92 = v87 + 63;
                CFCharacterSetRef v218 = (CFCharacterSetRef)v91;
                while (1)
                {
                  uint64_t v93 = v89 >= 4 ? 4 : v89;
                  if (v91 >= 1 && (CFIndex v94 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length >= v91))
                  {
                    if (buffer.directUniCharBuffer)
                    {
                      UniChar v95 = buffer.directUniCharBuffer[v91 - 1 + buffer.rangeToBuffer.location];
                    }
                    else if (buffer.directCStringBuffer)
                    {
                      UniChar v95 = buffer.directCStringBuffer[buffer.rangeToBuffer.location - 1 + v91];
                    }
                    else
                    {
                      if (buffer.bufferedRangeEnd < v91
                        || (CFIndex v96 = buffer.bufferedRangeStart, buffer.bufferedRangeStart >= v91))
                      {
                        uint64_t v97 = v93 + v90;
                        CFIndex v98 = v92 - v93;
                        CFIndex v99 = v91 - v93;
                        CFIndex v100 = v99 - 1;
                        CFIndex v101 = v99 + 63;
                        if (v101 >= buffer.rangeToBuffer.length) {
                          CFIndex v101 = buffer.rangeToBuffer.length;
                        }
                        buffer.CFIndex bufferedRangeStart = v100;
                        buffer.bufferedRangeEnd = v101;
                        if (buffer.rangeToBuffer.length >= v98) {
                          CFIndex v94 = v98;
                        }
                        v242.CFIndex length = v94 + v97;
                        v242.CFIndex location = v100 + buffer.rangeToBuffer.location;
                        CFStringGetCharacters(buffer.theString, v242, buffer.buffer);
                        CFIndex v96 = buffer.bufferedRangeStart;
                      }
                      UniChar v95 = *((_WORD *)&result.length + v91 - v96 + 3);
                    }
                  }
                  else
                  {
                    UniChar v95 = 0;
                  }
                  if (!CFCharacterSetIsCharacterMember(theSeta, v95)) {
                    break;
                  }
                  uint64_t v102 = v91 - v7;
                  --v89;
                  ++v90;
                  --v92;
                  --v91;
                  if (v102 <= 2)
                  {
                    CFIndex v88 = 1;
                    goto LABEL_186;
                  }
                }
                CFIndex v88 = v91 - v7;
LABEL_186:
                uint64_t v87 = (uint64_t)v218;
              }
              CFAllocatorRef v103 = CFGetAllocator(v1);
              v256.CFIndex location = v7;
              v256.CFIndex length = v88;
              CFStringRef v20 = CFStringCreateWithSubstring(v103, v1, v256);
              uint64_t v21 = (uint64_t)v229;
              CFNumberRef v22 = v223;
              CFIndex v23 = v232;
              goto LABEL_188;
            }
          }
        }
      }
      ++v73;
      ++v74;
      --v75;
      ++v76;
      if (!(v232 + v7 + v74))
      {
        uint64_t v87 = Length;
        goto LABEL_161;
      }
    }
  }
  uint64_t v55 = Length - v7;
  if (Length <= v7 || v55 < 8) {
    goto LABEL_413;
  }
  v236.CFIndex location = 0;
  v236.CFIndex length = 0;
  v254.CFIndex location = v7;
  v254.CFIndex length = 5;
  int v56 = CFStringFindWithOptions(v1, (CFStringRef)&unk_1EC0A42C8, v254, 9uLL, &v236);
  if (!v56 && (unint64_t)v55 >= 0xD)
  {
    v255.CFIndex location = v7;
    v255.CFIndex length = 10;
    CFStringFindWithOptions(v1, v228, v255, 9uLL, &v236);
  }
  CFIndex v57 = v236.length;
  if (!v236.length)
  {
    CFStringRef v68 = 0;
    BOOL v69 = (unint64_t)v55 > 0xA;
    goto LABEL_234;
  }
  int range_12 = v56;
  unint64_t v221 = v22;
  CFIndex location = v236.location;
  int64_t v7 = v236.location + v236.length;
  if (v236.location + v236.length >= Length) {
    goto LABEL_417;
  }
  if (v7 < 0) {
    goto LABEL_233;
  }
  CFIndex v59 = buffer.rangeToBuffer.length;
  if (buffer.rangeToBuffer.length <= v7) {
    goto LABEL_233;
  }
  if (buffer.directUniCharBuffer)
  {
    UniChar v60 = buffer.directUniCharBuffer[buffer.rangeToBuffer.location + v7];
  }
  else if (buffer.directCStringBuffer)
  {
    UniChar v60 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
  }
  else
  {
    if (buffer.bufferedRangeEnd <= v7 || (CFIndex v106 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
    {
      CFIndex v107 = v7 - 4;
      if ((unint64_t)v7 < 4) {
        CFIndex v107 = 0;
      }
      if (v107 + 64 < buffer.rangeToBuffer.length) {
        CFIndex v59 = v107 + 64;
      }
      buffer.CFIndex bufferedRangeStart = v107;
      buffer.bufferedRangeEnd = v59;
      v244.CFIndex location = buffer.rangeToBuffer.location + v107;
      v244.CFIndex length = v59 - v107;
      CFStringGetCharacters(buffer.theString, v244, buffer.buffer);
      CFIndex v106 = buffer.bufferedRangeStart;
    }
    UniChar v60 = buffer.buffer[v7 - v106];
  }
  CFIndex v8 = v227;
  if (v60 != 39)
  {
LABEL_233:
    CFStringRef v68 = 0;
    BOOL v69 = 1;
    CFNumberRef v22 = v221;
    goto LABEL_234;
  }
  CFCharacterSetRef v219 = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
  CFIndex v108 = v57 + location;
  unint64_t v109 = v57 + location + 1;
  CFIndex v110 = ~(v57 + location);
  uint64_t v111 = v57 + location + 65;
  uint64_t v112 = -2 - (v57 + location);
  CFIndex v113 = v108 + 66;
  while (1)
  {
    CFIndex v114 = v7 + 1;
    if (v109 >= 4) {
      uint64_t v115 = 4;
    }
    else {
      uint64_t v115 = v109;
    }
    if (v114 >= Length) {
      goto LABEL_417;
    }
    CFIndex v225 = v113;
    if (v7 >= -1)
    {
      CFIndex v116 = buffer.rangeToBuffer.length;
      if (buffer.rangeToBuffer.length > v114) {
        break;
      }
    }
    UniChar v117 = 0;
LABEL_231:
    int v124 = v117;
    uint64_t v125 = v112;
    CFIndex v126 = v110;
    CFIndex v127 = v8;
    unint64_t v128 = v109;
    uint64_t v129 = v111;
    int IsCharacterMember = CFCharacterSetIsCharacterMember(v219, v117);
    uint64_t v131 = v129;
    unint64_t v132 = v128;
    CFIndex v8 = v127;
    unint64_t v109 = v132 + 1;
    CFIndex v110 = v126 - 1;
    uint64_t v111 = v131 + 1;
    ++v7;
    uint64_t v112 = v125 - 1;
    CFIndex v113 = v225 + 1;
    if (v124 != 45 && !IsCharacterMember) {
      goto LABEL_233;
    }
  }
  if (buffer.directUniCharBuffer)
  {
    UniChar v117 = buffer.directUniCharBuffer[v7 + 1 + buffer.rangeToBuffer.location];
  }
  else if (buffer.directCStringBuffer)
  {
    UniChar v117 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 1 + v7];
  }
  else
  {
    if (buffer.bufferedRangeEnd <= v114 || (CFIndex v118 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v114))
    {
      uint64_t v119 = v115 + v110;
      CFIndex v120 = v111 - v115;
      int64_t v121 = v7 - v115;
      uint64_t v214 = v111;
      CFIndex range = v110;
      CFIndex v122 = v121 + 1;
      CFIndex v123 = v121 + 65;
      if (v123 >= buffer.rangeToBuffer.length) {
        CFIndex v123 = buffer.rangeToBuffer.length;
      }
      buffer.CFIndex bufferedRangeStart = v122;
      buffer.bufferedRangeEnd = v123;
      if (buffer.rangeToBuffer.length >= v120) {
        CFIndex v116 = v120;
      }
      v245.CFIndex length = v116 + v119;
      v245.CFIndex location = v122 + buffer.rangeToBuffer.location;
      CFStringGetCharacters(buffer.theString, v245, buffer.buffer);
      uint64_t v111 = v214;
      CFIndex v110 = range;
      CFIndex v118 = buffer.bufferedRangeStart;
    }
    UniChar v117 = v221[v7 - v118];
  }
  if (v117 != 39) {
    goto LABEL_231;
  }
  unint64_t v162 = v7 + 2;
  if (v7 + 2 >= Length) {
    goto LABEL_417;
  }
  CFIndex v163 = v225;
  CFCharacterSetRef v220 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  while (1)
  {
    CFIndex v164 = v7 + 2;
    uint64_t v165 = v162 >= 4 ? 4 : v162;
    if (v164 < 0 || (CFIndex v166 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v164))
    {
      UniChar v167 = 0;
    }
    else if (buffer.directUniCharBuffer)
    {
      UniChar v167 = buffer.directUniCharBuffer[v7 + 2 + buffer.rangeToBuffer.location];
    }
    else if (buffer.directCStringBuffer)
    {
      UniChar v167 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 2 + v7];
    }
    else
    {
      if (buffer.bufferedRangeEnd <= v164 || (CFIndex v169 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v164))
      {
        uint64_t v170 = v165 + v112;
        CFIndex v171 = v163 - v165;
        int64_t v172 = v7 - v165;
        CFIndex v173 = v172 + 2;
        CFIndex v174 = v172 + 66;
        if (v174 >= buffer.rangeToBuffer.length) {
          CFIndex v174 = buffer.rangeToBuffer.length;
        }
        buffer.CFIndex bufferedRangeStart = v173;
        buffer.bufferedRangeEnd = v174;
        if (buffer.rangeToBuffer.length >= v171) {
          CFIndex v166 = v171;
        }
        v249.CFIndex length = v166 + v170;
        v249.CFIndex location = v173 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v249, buffer.buffer);
        CFIndex v169 = buffer.bufferedRangeStart;
      }
      UniChar v167 = buffer.buffer[v7 + 2 - v169];
    }
    if (!CFCharacterSetIsCharacterMember(v220, v167)) {
      break;
    }
    ++v162;
    CFIndex v168 = v7 + 3;
    ++v7;
    --v112;
    ++v163;
    if (v168 >= Length) {
      goto LABEL_417;
    }
  }
  CFIndex rangea = v7 + 2;
  uint64_t v226 = v112;
  CFStringRef v68 = 0;
  BOOL v69 = 1;
  if (v167 == 44 || v167 == 59)
  {
    v7 += 2;
    goto LABEL_411;
  }
  v7 += 2;
  unsigned __int16 CharacterFromInlineBuffer = v167;
  while (2)
  {
    if (CharacterFromInlineBuffer > 0x3Au)
    {
      if (CharacterFromInlineBuffer == 59) {
        goto LABEL_379;
      }
      if (CharacterFromInlineBuffer == 92)
      {
LABEL_402:
        CFStringRef v68 = 0;
        BOOL v69 = 1;
        goto LABEL_411;
      }
LABEL_377:
      if (++v7 >= Length) {
        goto LABEL_379;
      }
      unsigned __int16 CharacterFromInlineBuffer = CFStringGetCharacterFromInlineBuffer(&buffer, v7);
      continue;
    }
    break;
  }
  if (CharacterFromInlineBuffer == 34) {
    goto LABEL_402;
  }
  if (CharacterFromInlineBuffer != 44) {
    goto LABEL_377;
  }
LABEL_379:
  CFIndex v192 = v7 - rangea;
  if (v7 - rangea >= 2)
  {
    unint64_t v193 = v7 - 1;
    int64_t v194 = 1 - v7;
    int64_t v195 = v7 + 63;
    CFIndex v196 = v7;
    while (1)
    {
      uint64_t v197 = v193 >= 4 ? 4 : v193;
      if (v196 >= 1 && (CFIndex v198 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length >= v196))
      {
        if (buffer.directUniCharBuffer)
        {
          UniChar v199 = buffer.directUniCharBuffer[v196 - 1 + buffer.rangeToBuffer.location];
        }
        else if (buffer.directCStringBuffer)
        {
          UniChar v199 = buffer.directCStringBuffer[buffer.rangeToBuffer.location - 1 + v196];
        }
        else
        {
          if (buffer.bufferedRangeEnd < v196 || (CFIndex v200 = buffer.bufferedRangeStart, buffer.bufferedRangeStart >= v196))
          {
            uint64_t v201 = v197 + v194;
            CFIndex v202 = v195 - v197;
            CFIndex v203 = v196 - v197;
            CFIndex v204 = v203 - 1;
            CFIndex v205 = v203 + 63;
            if (v205 >= buffer.rangeToBuffer.length) {
              CFIndex v205 = buffer.rangeToBuffer.length;
            }
            buffer.CFIndex bufferedRangeStart = v204;
            buffer.bufferedRangeEnd = v205;
            if (buffer.rangeToBuffer.length >= v202) {
              CFIndex v198 = v202;
            }
            v252.CFIndex length = v198 + v201;
            v252.CFIndex location = v204 + buffer.rangeToBuffer.location;
            CFStringGetCharacters(buffer.theString, v252, buffer.buffer);
            CFIndex v200 = buffer.bufferedRangeStart;
          }
          UniChar v199 = *((_WORD *)&result.length + v196 - v200 + 3);
        }
      }
      else
      {
        UniChar v199 = 0;
      }
      if (!CFCharacterSetIsCharacterMember(v220, v199)) {
        break;
      }
      uint64_t v206 = v226 + v196;
      --v193;
      ++v194;
      --v195;
      --v196;
      if (v206 <= 2)
      {
        CFIndex v192 = 1;
        goto LABEL_404;
      }
    }
    CFIndex v192 = v226 + v196;
  }
LABEL_404:
  CFAllocatorRef v207 = CFGetAllocator(v1);
  v258.CFIndex location = rangea;
  v258.CFIndex length = v192;
  CFStringRef v208 = CFStringCreateWithSubstring(v207, v1, v258);
  if (v208)
  {
    CFStringRef v209 = v208;
    CFAllocatorRef v210 = CFGetAllocator(v1);
    if (range_12) {
      CFStringEncoding v211 = 134217984;
    }
    else {
      CFStringEncoding v211 = 513;
    }
    CFStringRef v68 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v210, v209, &stru_1ECFAD558, v211);
    CFRelease(v209);
  }
  else
  {
    CFStringRef v68 = 0;
  }
  BOOL v69 = v7 < Length;
LABEL_411:
  CFNumberRef v22 = v221;
  CFIndex v8 = v227;
LABEL_234:
  uint64_t v21 = (uint64_t)v228;
  CFStringRef v20 = (CFStringRef)theSet;
  CFIndex v23 = v232;
  if (!v69 || v68)
  {
    if (!v68) {
      goto LABEL_413;
    }
    if (theSet) {
      CFRelease(theSet);
    }
    goto LABEL_414;
  }
LABEL_236:
  while (2)
  {
    if (v7 >= Length) {
      goto LABEL_413;
    }
LABEL_237:
    if (v7 < 0 || (CFIndex v133 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v7))
    {
LABEL_279:
      ++v7;
      continue;
    }
    break;
  }
  unint64_t v134 = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
  if (buffer.directUniCharBuffer)
  {
    CFIndex v135 = buffer.rangeToBuffer.location + v7;
    goto LABEL_241;
  }
  if (buffer.directCStringBuffer)
  {
    UniChar v136 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
  }
  else
  {
    if (buffer.bufferedRangeEnd <= v7 || (CFIndex v150 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
    {
      CFIndex v151 = v7 - 4;
      if ((unint64_t)v7 < 4) {
        CFIndex v151 = 0;
      }
      if (v151 + 64 < buffer.rangeToBuffer.length) {
        CFIndex v133 = v151 + 64;
      }
      buffer.CFIndex bufferedRangeStart = v151;
      buffer.bufferedRangeEnd = v133;
      v247.CFIndex location = buffer.rangeToBuffer.location + v151;
      v247.CFIndex length = v133 - v151;
      CFStringGetCharacters(buffer.theString, v247, buffer.buffer);
      CFIndex v150 = buffer.bufferedRangeStart;
    }
    CFIndex v135 = v7 - v150;
    unint64_t v134 = &buffer;
LABEL_241:
    UniChar v136 = v134->buffer[v135];
  }
  if (v136 != 34)
  {
    if (v136 != 44 && v136 != 59) {
      goto LABEL_279;
    }
    if (++v7 >= Length) {
      goto LABEL_413;
    }
    CFIndex v233 = v23;
    CFIndex v152 = v8;
    long long v153 = v22;
    while (1)
    {
      CFCharacterSetRef v154 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      if (v7 < 0 || (CFIndex v155 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v7))
      {
        UniChar v158 = 0;
      }
      else
      {
        uint64_t v156 = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
        if (buffer.directUniCharBuffer)
        {
          CFIndex v157 = buffer.rangeToBuffer.location + v7;
        }
        else
        {
          if (buffer.directCStringBuffer)
          {
            UniChar v158 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
            goto LABEL_288;
          }
          if (buffer.bufferedRangeEnd <= v7 || (CFIndex v160 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
          {
            CFIndex v161 = v7 - 4;
            if ((unint64_t)v7 < 4) {
              CFIndex v161 = 0;
            }
            if (v161 + 64 < buffer.rangeToBuffer.length) {
              CFIndex v155 = v161 + 64;
            }
            buffer.CFIndex bufferedRangeStart = v161;
            buffer.bufferedRangeEnd = v155;
            v248.CFIndex location = buffer.rangeToBuffer.location + v161;
            v248.CFIndex length = v155 - v161;
            CFStringGetCharacters(buffer.theString, v248, buffer.buffer);
            CFIndex v160 = buffer.bufferedRangeStart;
          }
          CFIndex v157 = v7 - v160;
          uint64_t v156 = &buffer;
        }
        UniChar v158 = v156->buffer[v157];
      }
LABEL_288:
      int v159 = v158;
      if (!CFCharacterSetIsCharacterMember(v154, v158) && v159 != 59 && v159 != 44)
      {
        CFNumberRef v22 = v153;
        CFIndex v8 = v152;
        CFIndex v23 = v233;
        if (Length - v7 < 9) {
          goto LABEL_413;
        }
        goto LABEL_31;
      }
      if (++v7 >= Length) {
        goto LABEL_413;
      }
    }
  }
  CFStringRef v137 = v1;
  CFIndex v138 = v8;
  v139 = v22;
  CFIndex v140 = v23;
  uint64_t v141 = v21;
  CFStringRef v142 = v20;
  for (CFIndex j = v7 + 1; ; ++j)
  {
    if (j >= Length)
    {
LABEL_412:
      CFStringRef v20 = v142;
      goto LABEL_413;
    }
    if (v7 >= -1)
    {
      CFIndex v144 = buffer.rangeToBuffer.length;
      if (buffer.rangeToBuffer.length > j) {
        break;
      }
    }
LABEL_258:
    int64_t v7 = j;
  }
  long long v145 = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
  if (buffer.directUniCharBuffer)
  {
    CFIndex v146 = buffer.rangeToBuffer.location + j;
LABEL_251:
    UniChar v147 = v145->buffer[v146];
    goto LABEL_254;
  }
  if (!buffer.directCStringBuffer)
  {
    if (buffer.bufferedRangeEnd <= j || (CFIndex v148 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > j))
    {
      CFIndex v149 = j - 4;
      if ((unint64_t)j < 4) {
        CFIndex v149 = 0;
      }
      if (v149 + 64 < buffer.rangeToBuffer.length) {
        CFIndex v144 = v149 + 64;
      }
      buffer.CFIndex bufferedRangeStart = v149;
      buffer.bufferedRangeEnd = v144;
      v246.CFIndex location = buffer.rangeToBuffer.location + v149;
      v246.CFIndex length = v144 - v149;
      CFStringGetCharacters(buffer.theString, v246, buffer.buffer);
      CFIndex v148 = buffer.bufferedRangeStart;
    }
    CFIndex v146 = j - v148;
    long long v145 = &buffer;
    goto LABEL_251;
  }
  UniChar v147 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + j];
LABEL_254:
  if (v147 == 92)
  {
    if (++j >= Length) {
      goto LABEL_412;
    }
    goto LABEL_258;
  }
  if (v147 != 34) {
    goto LABEL_258;
  }
  int64_t v7 = j + 1;
  BOOL v15 = j + 1 < Length;
  CFStringRef v20 = v142;
  uint64_t v21 = v141;
  CFIndex v23 = v140;
  CFNumberRef v22 = v139;
  CFIndex v8 = v138;
  CFStringRef v1 = v137;
  if (v15) {
    goto LABEL_237;
  }
LABEL_413:
  CFStringRef v68 = v20;
  if (!v20) {
    return 0;
  }
LABEL_414:
  CFStringRef SanitizedFileNameFromString = createSanitizedFileNameFromString(v68);
  CFRelease(v68);
  return SanitizedFileNameFromString;
}

CFMutableStringRef cdReplaceQuotedPairs(__CFString *a1)
{
  MutableCFStringRef Copy = a1;
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = Length - 1;
  if (Length > 1)
  {
    CFIndex v4 = Length;
    CFAllocatorRef v5 = CFGetAllocator(MutableCopy);
    MutableCFStringRef Copy = CFStringCreateMutableCopy(v5, 0, MutableCopy);
    for (CFIndex i = 0; i < v4; ++i)
    {
      v10.CFIndex location = i;
      v10.CFIndex length = v3;
      if (!CFStringFindWithOptions(MutableCopy, @"\\"", v10, 0, &range)) {
        break;
      }
      v9.CFIndex location = range.location;
      v9.CFIndex length = 1;
      CFStringDelete(MutableCopy, v9);
      --v4;
      v3 -= 2;
    }
  }
  else
  {
    CFRetain(MutableCopy);
  }
  return MutableCopy;
}

uint64_t CFStringGetCharacterFromInlineBuffer(CFStringInlineBuffer *buffer, int64_t a2)
{
  if (a2 < 0)
  {
    return 0;
  }
  else
  {
    CFIndex length = buffer->rangeToBuffer.length;
    if (length <= a2)
    {
      return 0;
    }
    else
    {
      directUniCharBuffer = buffer->directUniCharBuffer;
      if (directUniCharBuffer)
      {
        return directUniCharBuffer[buffer->rangeToBuffer.location + a2];
      }
      else
      {
        directCStringBuffer = buffer->directCStringBuffer;
        if (directCStringBuffer)
        {
          return (unsigned __int16)directCStringBuffer[buffer->rangeToBuffer.location + a2];
        }
        else
        {
          if (buffer->bufferedRangeEnd <= a2
            || (CFIndex bufferedRangeStart = buffer->bufferedRangeStart, bufferedRangeStart > a2))
          {
            CFIndex v10 = a2 - 4;
            if ((unint64_t)a2 < 4) {
              CFIndex v10 = 0;
            }
            if (v10 + 64 < length) {
              CFIndex length = v10 + 64;
            }
            buffer->CFIndex bufferedRangeStart = v10;
            buffer->bufferedRangeEnd = length;
            v11.CFIndex location = buffer->rangeToBuffer.location + v10;
            v11.CFIndex length = length - v10;
            CFStringGetCharacters(buffer->theString, v11, buffer->buffer);
            CFIndex bufferedRangeStart = buffer->bufferedRangeStart;
          }
          return buffer->buffer[a2 - bufferedRangeStart];
        }
      }
    }
  }
}

CFStringRef createExtensionFromFilename(const __CFString *a1)
{
  CFStringRef v1 = a1;
  CFIndex Length = CFStringGetLength(a1);
  if (Length >= 2)
  {
    CFIndex v4 = Length;
    CFIndex v5 = Length - 1;
    while (v5)
    {
      CFIndex v6 = v5;
      int CharacterAtIndex = CFStringGetCharacterAtIndex(v1, v5);
      if (CharacterAtIndex == 47) {
        break;
      }
      CFIndex v5 = v6 - 1;
      if (CharacterAtIndex == 46)
      {
        CFIndex v8 = v6 + 1;
        if (v8 != 3) {
          goto LABEL_14;
        }
        if (CFStringGetLength(v1) <= 1 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)CFIndex v10 = 0;
          _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "createExtensionFromFilename(): passed a bogus filename", v10, 2u);
        }
        if (CFStringGetCharacterAtIndex(v1, 1) != 58
          || (CFStringGetCharacterAtIndex(v1, 0) & 0xFFDFu) - 91 < 0xFFFFFFE6)
        {
LABEL_14:
          CFAllocatorRef v9 = CFGetAllocator(v1);
          v11.CFIndex length = v4 - v8;
          v11.CFIndex location = v8;
          return CFStringCreateWithSubstring(v9, v1, v11);
        }
        break;
      }
    }
  }
  CFRetain(v1);
  return v1;
}

CFStringRef _CFURLCopyPathExtension_WorksWithMoreSchemes(const __CFURL *a1)
{
  CFStringRef v2 = CFURLCopyPathExtension(a1);
  if (!v2)
  {
    CFStringRef v3 = CFURLCopyPath(a1);
    if (v3)
    {
      CFStringRef v4 = v3;
      CFIndex Length = CFStringGetLength(v3);
      if (Length < 1)
      {
        CFStringRef v2 = 0;
      }
      else
      {
        CFIndex v6 = Length;
        CFCharacterSetRef v7 = CFCharacterSetCreateWithCharactersInString(0, @"./;=");
        v13.CFIndex location = 0;
        v13.CFIndex length = v6;
        if (CFStringFindCharacterFromSet(v4, v7, v13, 4uLL, &result)
          && CFStringGetCharacterAtIndex(v4, result.location) == 46)
        {
          CFCharacterSetRef v8 = CFCharacterSetCreateWithCharactersInString(0, @";=?");
          v14.CFIndex location = 0;
          v14.CFIndex length = v6;
          CFStringRef v2 = 0;
          if (!CFStringFindCharacterFromSet(v4, v8, v14, 4uLL, &v11))
          {
            v9.CFIndex length = v6 + ~result.location;
            if (v9.length < 1)
            {
              CFStringRef v2 = 0;
            }
            else
            {
              v9.CFIndex location = result.location + 1;
              CFStringRef v2 = CFStringCreateWithSubstring(0, v4, v9);
            }
          }
          CFRelease(v8);
        }
        else
        {
          CFStringRef v2 = 0;
        }
        CFRelease(v7);
      }
      CFRelease(v4);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

char *_CFNetworkIsKnownHSTSHostWithSession(char *a1, os_unfair_lock_s *a2)
{
  CFStringRef v3 = _HSTSPolicyForSession(a2);
  if (v3)
  {
    CFStringRef v4 = v3;
    if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy == -1)
    {
      if (a1) {
        goto LABEL_4;
      }
    }
    else
    {
      dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
      if (a1)
      {
LABEL_4:
        CFIndex v5 = (NSString *)[a1 host];
        if (v5) {
          a1 = (char *)HSTSPolicy::isKnownHSTSHost((HSTSPolicy *)(v4 + 2), v5, &v7);
        }
        else {
          a1 = 0;
        }
      }
    }
    CFRelease(v4);
    return a1;
  }
  return 0;
}

void *_HSTSPolicyForSession(os_unfair_lock_s *a1)
{
  if (a1)
  {
    if (StorageSession::Class(void)::sOnce_StorageSession != -1) {
      dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_19595);
    }
    return StorageSession::copyHSTSStorage(a1 + 4);
  }
  else
  {
    CFRange result = (void *)+[NSURLSession _sharedSessionForConnection]();
    if (result)
    {
      CFStringRef v3 = (void *)result[14];
      return (void *)[v3 copyHSTSPolicy];
    }
  }
  return result;
}

void *_CFNetworkCopyHSTSPolicies(os_unfair_lock_s *a1)
{
  CFRange result = _HSTSPolicyForSession(a1);
  if (result)
  {
    CFStringRef v2 = result;
    if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1) {
      dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
    }
    CFDictionaryRef v3 = HSTSPolicy::copyExternalRepresentationOfHSTSPolicies((HSTSPolicy *)(v2 + 2));
    CFRelease(v2);
    return v3;
  }
  return result;
}

void _CFNetworkResetHSTS(const __CFURL *a1, os_unfair_lock_s *a2)
{
  CFDictionaryRef v3 = (HSTSCache **)_HSTSPolicyForSession(a2);
  if (v3)
  {
    CFStringRef v4 = v3;
    CFStringRef v5 = CFURLCopyHostName(a1);
    if (v5)
    {
      CFStringRef v6 = v5;
      if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1) {
        dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
      }
      HSTSCache::modifyHSTSStore(v4[4], v6, 0, 0);
      CFRelease(v6);
    }
    CFRelease(v4);
  }
}

void _CFNetworkResetHSTSHostsSinceDate(os_unfair_lock_s *a1, const void *a2)
{
  CFDictionaryRef v3 = (HSTSCache **)_HSTSPolicyForSession(a1);
  if (v3)
  {
    CFStringRef v4 = v3;
    if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1) {
      dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
    }
    HSTSCache::modifyHSTSStore(v4[4], 0, 0, a2);
    CFRelease(v4);
  }
}

void _CFNetworkResetHSTSHostsWithSession(os_unfair_lock_s *a1)
{
}

void _CFNetworkResetHSTSHosts()
{
}

CFRunLoopSourceRef CFNetworkExecuteProxyAutoConfigurationURL(CFURLRef proxyAutoConfigURL, CFURLRef targetURL, CFProxyAutoConfigurationResultCallback cb, CFStreamClientContext *clientContext)
{
  return PAC::CreatePACTicket(proxyAutoConfigURL, targetURL, 0, 0, (const __CFString *)cb, (void (*)(void *, const __CFArray *, __CFError *))clientContext, v4);
}

CFRunLoopSourceRef CFNetworkExecuteProxyAutoConfigurationScript(CFStringRef proxyAutoConfigurationScript, CFURLRef targetURL, CFProxyAutoConfigurationResultCallback cb, CFStreamClientContext *clientContext)
{
  return PAC::CreatePACTicket((PAC *)proxyAutoConfigurationScript, targetURL, 0, 0, (const __CFString *)cb, (void (*)(void *, const __CFArray *, __CFError *))clientContext, v4);
}

CFDictionaryRef _newConnPropsForHTTPSProxy(CFAllocatorRef allocator, __CFHTTPMessage *a2, __CFString *a3, const __CFNumber *a4)
{
  CFDictionaryRef v6 = a2;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  keys = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  CFGregorianDate values = 0;
  CFTypeRef cf = 0;
  CFDictionaryRef v15 = 0;
  if (a2)
  {
    keys = &unk_1EC0A2B28;
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    CFCharacterSetRef v8 = (CFDictionaryRef)((char *)v6 + 16);
    CFGregorianDate values = (void *)HTTPMessage::copyHeaderFieldValue(v8, 0x14E15421u);
    if (!values)
    {
      pthread_once(&initControl, initializeUserAgentString);
      CFGregorianDate values = (void *)sUserAgentString;
      CFRetain((CFTypeRef)sUserAgentString);
    }
    uint64_t v17 = 0x1EC0A2658;
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    CFTypeRef cf = HTTPMessage::copyHeaderFieldValue(v8, 0x1382736Bu);
    if (cf) {
      CFIndex v9 = 2;
    }
    else {
      CFIndex v9 = 1;
    }
    CFDictionaryRef v6 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, v9, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFRelease(values);
    if (cf) {
      CFRelease(cf);
    }
  }
  keys = &unk_1EC0A56B0;
  uint64_t v17 = 0x1EC0A56E8;
  CFGregorianDate values = a3;
  CFTypeRef cf = a4;
  if (v6)
  {
    uint64_t v18 = 0x1EC0A5640;
    CFDictionaryRef v15 = v6;
    CFDictionaryRef v10 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFRelease(v6);
  }
  else
  {
    CFDictionaryRef v10 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  keys = &unk_1EC0A5678;
  CFGregorianDate values = v10;
  CFDictionaryRef v11 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(v10);
  return v11;
}

CFDictionaryRef newConnPropsForSOCKSProxy(CFAllocatorRef allocator, const __CFString *a2, const __CFNumber *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v7 = (void *)*MEMORY[0x1E4F1D468];
  keys[0] = *(void **)MEMORY[0x1E4F1D460];
  keys[1] = v7;
  values[0] = (void *)a2;
  values[1] = a3;
  CFCharacterSetRef v8 = (void *)*MEMORY[0x1E4F1D478];
  CFStringRef v9 = (const __CFString *)*MEMORY[0x1E4F1D4B0];
  if (a6) {
    CFStringRef v9 = a6;
  }
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  keys[2] = v8;
  CFStringRef v18 = 0;
  CFStringRef v19 = 0;
  values[2] = (void *)v9;
  if (a4)
  {
    uint64_t v10 = *MEMORY[0x1E4F1D450];
    uint64_t v21 = *MEMORY[0x1E4F1D470];
    uint64_t v22 = v10;
    CFStringRef v18 = a4;
    CFStringRef v19 = a5;
    CFIndex v11 = 5;
  }
  else
  {
    CFIndex v11 = 3;
  }
  CFIndex v12 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  CFRange v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  CFDictionaryRef v14 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, v11, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  keys[0] = &unk_1EC0A1120;
  values[0] = v14;
  CFDictionaryRef v15 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, 1, v12, v13);
  CFRelease(v14);
  return v15;
}

unint64_t hasTokenInList(const __CFString *a1, const __CFString *a2)
{
  uint64_t Length = CFStringGetLength(a1);
  CFIndex v5 = CFStringGetLength(a2);
  v17.CFIndex location = 0;
  v17.CFIndex length = Length;
  if (Length < 1) {
    return 0;
  }
  CFIndex v6 = v5;
  v18.CFIndex location = 0;
  v18.CFIndex length = Length;
  unint64_t result = CFStringFindWithOptions(a1, a2, v18, 1uLL, &v17);
  if (!result) {
    return result;
  }
  if (!v17.location)
  {
    unsigned int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v17.length);
    BOOL v11 = CharacterAtIndex > 0x2C;
    uint64_t v12 = 1 << CharacterAtIndex;
LABEL_7:
    uint64_t v14 = v12 & 0x100100000200;
    return !v11 && v14 != 0;
  }
  uint64_t v8 = Length - v17.location;
  unsigned int v9 = CFStringGetCharacterAtIndex(a1, v17.location - 1);
  unsigned int v10 = v9;
  if (v6 == v8)
  {
    BOOL v11 = v9 > 0x2C;
    uint64_t v12 = 1 << v9;
    goto LABEL_7;
  }
  unint64_t result = 0;
  if (v10 <= 0x2C && ((1 << v10) & 0x100100000200) != 0)
  {
    unsigned int v16 = CFStringGetCharacterAtIndex(a1, v17.length + v17.location);
    if (v16 <= 0x2C) {
      return (0x100100000200uLL >> v16) & 1;
    }
    return 0;
  }
  return result;
}

uint64_t convertIPAddress(const __CFString *a1, int a2, void *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(a1);
  LOBYTE(result) = 0;
  if (Length)
  {
    if (Length <= 56)
    {
      LODWORD(result) = CFStringGetCString(a1, buffer, 57, 0x600u);
      if (result) {
        LOBYTE(result) = inet_pton(a2, buffer, a3);
      }
    }
  }
  return result;
}

BOOL haveTheSameOrigin(NSURL *a1, NSURL *a2)
{
  uint64_t v4 = [(NSURL *)a1 host];
  uint64_t v5 = [(NSURL *)a2 host];
  if (v4 && v5)
  {
    if (![(id)v4 caseInsensitiveCompare:v5]) {
      goto LABEL_6;
    }
    return 0;
  }
  if (v4 | v5) {
    return 0;
  }
LABEL_6:
  uint64_t v6 = [(NSURL *)a1 scheme];
  uint64_t v7 = [(NSURL *)a2 scheme];
  if (v6 && v7)
  {
    if ([(id)v6 caseInsensitiveCompare:v7]) {
      return 0;
    }
  }
  else if (v6 | v7)
  {
    return 0;
  }
  BestPortCFNumberRef Value = getBestPortValue(a1);
  return BestPortValue == getBestPortValue(a2);
}

uint64_t getBestPortValue(NSURL *a1)
{
  CFStringRef v2 = [(NSURL *)a1 port];
  if (!v2)
  {
    uint64_t v4 = [(NSString *)[(NSURL *)a1 scheme] lowercaseString];
    if (!v4) {
      return 0;
    }
    CFStringRef v2 = (NSNumber *)[&unk_1ECFD1BD8 objectForKeyedSubscript:v4];
    if (!v2) {
      return 0;
    }
  }

  return [(NSNumber *)v2 unsignedShortValue];
}

uint64_t ___Z23createIDNAEncodedDomainPK10__CFString_block_invoke()
{
  int v1 = 0;
  uint64_t result = MEMORY[0x18531E9D0](60, &v1);
  createIDNAEncodedDomain(__CFString const*)::idna = result;
  if (v1 >= 1) {
    abort();
  }
  return result;
}

void sub_1841B50E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

NSMutableURLRequest *CFURLRequestCreateMutable(double a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v6 = [(NSURLRequest *)[NSMutableURLRequest alloc] initWithURL:a3 cachePolicy:a4 timeoutInterval:a1];
  uint64_t v7 = v6;
  if (a5) {
    [(NSMutableURLRequest *)v6 setMainDocumentURL:a5];
  }
  return v7;
}

uint64_t CFURLRequestCreateCopy(uint64_t a1, void *a2)
{
  return [a2 copy];
}

uint64_t CFURLRequestCreateMutableCopy(uint64_t a1, void *a2)
{
  return [a2 mutableCopy];
}

uint64_t CFURLRequestCreateHTTPRequest(int a1, __CFAllocator *a2, __CFHTTPMessage *a3, int a4, NSURLRequestCachePolicy a5, double a6)
{
  return _constructRequestFromParts(a2, a3, (const __CFArray *)a4, a5, a6, 0);
}

uint64_t CFURLRequestCreateMutableHTTPRequest(int a1, __CFAllocator *a2, __CFHTTPMessage *a3, int a4, NSURLRequestCachePolicy a5, double a6)
{
  return _constructRequestFromParts(a2, a3, (const __CFArray *)a4, a5, a6, (const __CFURL *)1);
}

uint64_t CFURLRequestGetURL(void *a1)
{
  return *(void *)([a1 _inner] + 8);
}

uint64_t CFURLRequestGetCachePolicy(void *a1)
{
  return *(unsigned int *)([a1 _inner] + 16);
}

double CFURLRequestGetTimeoutInterval(void *a1)
{
  return *(double *)([a1 _inner] + 24);
}

uint64_t CFURLRequestGetSSLProperties(void *a1)
{
  return *(void *)([a1 _inner] + 72);
}

uint64_t CFURLRequestGetMainDocumentURL(void *a1)
{
  return *(void *)([a1 _inner] + 32);
}

uint64_t CFURLRequestGetProxySettings(void *a1)
{
  return *(void *)([a1 _inner] + 48);
}

HTTPBodyData **CFURLRequestCopyHTTPRequestBody(void *a1)
{
  uint64_t result = *(HTTPBodyData ***)([a1 _inner] + 56);
  if (result)
  {
    return (HTTPBodyData **)HTTPMessage::copyBody(result);
  }
  return result;
}

HTTPMessage *CFURLRequestCopyHTTPHeaderFieldValue(void *a1, const __CFString *a2)
{
  uint64_t result = *(HTTPMessage **)([a1 _inner] + 56);
  if (result)
  {
    return (HTTPMessage *)HTTPMessage::copyHeaderFieldValue(result, a2);
  }
  return result;
}

HTTPMessage *CFURLRequestCopyAllHTTPHeaderFields(void *a1)
{
  uint64_t result = *(HTTPMessage **)([a1 _inner] + 56);
  if (result)
  {
    return HTTPMessage::copyAllHeaderFields(result);
  }
  return result;
}

CFArrayRef CFURLRequestCopyHTTPRequestBodyParts(void *a1)
{
  uint64_t v1 = *(void *)([a1 _inner] + 56);
  if (!v1) {
    return 0;
  }
  CFArrayRef v2 = *(const __CFArray **)(v1 + 208);
  if (!v2) {
    return 0;
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];

  return CFArrayCreateCopy(v3, v2);
}

uint64_t CFURLRequestShouldHandleHTTPCookies(void *a1)
{
  return *(_WORD *)([a1 _inner] + 64) & 1;
}

CFTypeRef CFURLRequestCopyHTTPCookieStorage(void *a1)
{
  uint64_t v1 = *(void *)([a1 _inner] + 56);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 192);
    if (v2)
    {
      CFRetain(*(CFTypeRef *)(v1 + 192));
      return (CFTypeRef)v2;
    }
  }
  CFAllocatorRef v3 = +[NSHTTPCookieStorage sharedHTTPCookieStorage];
  if (!v3) {
    return 0;
  }
  uint64_t v4 = [(NSHTTPCookieStorage *)v3 _cookieStorage];
  if (!v4) {
    return 0;
  }

  return CFRetain(v4);
}

uint64_t CFURLRequestSetCachePolicy(void *a1, int a2)
{
  uint64_t result = [a1 _inner];
  *(_WORD *)(result + 64) |= 0x400u;
  *(void *)(result + 16) = a2;
  return result;
}

uint64_t CFURLRequestSetTimeoutInterval(void *a1, double a2)
{
  uint64_t result = [a1 _inner];
  *(_WORD *)(result + 64) |= 0x800u;
  *(double *)(result + 24) = a2;
  return result;
}

CFTypeRef CFURLRequestSetMainDocumentURL(void *a1, CFTypeRef a2)
{
  uint64_t v3 = [a1 _inner];
  CFTypeRef result = *(CFTypeRef *)(v3 + 32);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2) {
      CFTypeRef result = CFRetain(a2);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(v3 + 32) = result;
  }
  return result;
}

CFDictionaryRef CFURLRequestSetProxySettings(void *a1, const __CFDictionary *a2)
{
  uint64_t v3 = [a1 _inner];
  *(_WORD *)(v3 + 64) |= 0x1000u;
  CFDictionaryRef result = *(CFDictionaryRef *)(v3 + 48);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2) {
      CFDictionaryRef result = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    }
    else {
      CFDictionaryRef result = 0;
    }
    *(void *)(v3 + 48) = result;
  }
  return result;
}

CFDictionaryRef CFURLRequestSetSSLProperties(void *a1, const __CFDictionary *a2)
{
  uint64_t v3 = [a1 _inner];
  *(_WORD *)(v3 + 64) |= 0x2000u;
  CFDictionaryRef result = *(CFDictionaryRef *)(v3 + 72);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2) {
      CFDictionaryRef result = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
    }
    else {
      CFDictionaryRef result = 0;
    }
    *(void *)(v3 + 72) = result;
  }
  return result;
}

void CFURLRequestSetHTTPRequestBodyParts(void *a1, const __CFArray *a2)
{
  uint64_t v3 = (URLRequest *)[a1 _inner];

  URLRequest::_setHTTPBodyParts(v3, a2, 0);
}

uint64_t CFURLRequestSetShouldHandleHTTPCookies(void *a1, int a2)
{
  uint64_t result = [a1 _inner];
  __int16 v4 = *(_WORD *)(result + 64);
  __int16 v5 = v4 | 0x21;
  __int16 v6 = v4 & 0xFFDE | 0x20;
  if (a2) {
    __int16 v6 = v5;
  }
  *(_WORD *)(result + 64) = v6;
  return result;
}

CFTypeRef CFURLRequestSetHTTPCookieStorage(void *a1, CFTypeRef a2)
{
  uint64_t v3 = [a1 _inner];
  fHTTPRequest = *(HTTPRequest **)(v3 + 56);
  if (!fHTTPRequest)
  {
    __int16 v5 = (URLRequest *)v3;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v7);
    URLRequest::createHTTPRequest(v5, &v7);
    CFTypeRef v7 = &unk_1ECF9F718;
    if (cf) {
      CFRelease(cf);
    }
    fHTTPRequest = v5->fHTTPRequest;
  }
  CFTypeRef result = (CFTypeRef)*((void *)fHTTPRequest + 24);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2) {
      CFTypeRef result = CFRetain(a2);
    }
    else {
      CFTypeRef result = 0;
    }
    *((void *)fHTTPRequest + 24) = result;
  }
  return result;
}

void sub_1841B605C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void CFURLRequestSetHTTPCookieStorageAcceptPolicy()
{
  if (CFURLRequestSetHTTPCookieStorageAcceptPolicy::sOnce != -1) {
    dispatch_once(&CFURLRequestSetHTTPCookieStorageAcceptPolicy::sOnce, &__block_literal_global_2124);
  }
}

void __CFURLRequestSetHTTPCookieStorageAcceptPolicy_block_invoke()
{
}

void _CFURLRequestSetProtocolProperty(void *a1, const __CFString *cf1, CFStringRef a3)
{
  if (CFEqual(cf1, @"_kNSURLRequestKey"))
  {
    if (_CFURLRequestSetProtocolProperty::sOnce != -1)
    {
      dispatch_once(&_CFURLRequestSetProtocolProperty::sOnce, &__block_literal_global_8_2130);
    }
  }
  else
  {
    int v6 = CFEqual(cf1, @"_kCFHTTPCookiePolicyPropertySiteForCookies");
    if (a3 && v6)
    {
      CFTypeID v7 = CFGetTypeID(a3);
      if (v7 != CFURLGetTypeID()) {
        return;
      }
      a3 = CFURLGetString((CFURLRef)a3);
    }
    uint64_t v8 = (URLRequest *)[a1 _inner];
    URLRequest::setProtocolProperty(v8, cf1, a3);
  }
}

CFNumberRef _CFURLRequestCreateArchiveList(CFNumberRef result, void *a2, uint64_t *a3, const void ***a4, uint64_t *a5, const __CFDictionary **a6)
{
  if (a2)
  {
    CFAllocatorRef v10 = result;
    BOOL v11 = (URLRequest *)[a2 _inner];
    return URLRequest::createArchiveList(v11, v10, a3, a4, a5, a6);
  }
  else if (a5)
  {
    *a5 = 22;
  }
  return result;
}

CFTypeRef _CFURLRequestCopyContentDispositionEncodingFallbackArray(void *a1)
{
  CFTypeRef result = *(CFTypeRef *)([a1 _inner] + 80);
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

CFTypeRef _CFURLRequestSetContentDispositionEncodingFallbackArray(void *a1, CFTypeRef a2)
{
  uint64_t v3 = [a1 _inner];
  CFTypeRef result = *(CFTypeRef *)(v3 + 80);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2) {
      CFTypeRef result = CFRetain(a2);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(v3 + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = result;
  }
  return result;
}

uint64_t CFURLRequestSetNetworkServiceType(void *a1, int a2)
{
  uint64_t result = [a1 _inner];
  *(_WORD *)(result + 64) |= 0x40u;
  *(_DWORD *)(result + 104) = a2;
  return result;
}

void CFURLRequestSetShouldPipelineHTTP(void *a1, char a2, char a3)
{
  uint64_t v5 = [a1 _inner];
  *(_WORD *)(v5 + 64) |= 0x200u;
  fHTTPRequest = *(HTTPRequest **)(v5 + 56);
  if (!fHTTPRequest)
  {
    CFTypeID v7 = (URLRequest *)v5;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v8);
    URLRequest::createHTTPRequest(v7, &v8);
    CFTypeRef v8 = &unk_1ECF9F718;
    if (cf) {
      CFRelease(cf);
    }
    fHTTPRequest = v7->fHTTPRequest;
  }
  *((unsigned char *)fHTTPRequest + 216) = a2;
  *((unsigned char *)fHTTPRequest + 217) = a3;
}

void sub_1841B63DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void _CFURLRequestSetShouldPipelineNonIdempotentHTTP(void *a1, char a2)
{
  uint64_t v3 = [a1 _inner];
  fHTTPRequest = *(HTTPRequest **)(v3 + 56);
  if (!fHTTPRequest)
  {
    uint64_t v5 = (URLRequest *)v3;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v6);
    URLRequest::createHTTPRequest(v5, &v6);
    CFTypeRef v6 = &unk_1ECF9F718;
    if (cf) {
      CFRelease(cf);
    }
    fHTTPRequest = v5->fHTTPRequest;
  }
  *((unsigned char *)fHTTPRequest + 218) = a2;
}

void sub_1841B6498(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void _CFURLRequestSetShouldSkipPipelineProbe(void *a1, char a2)
{
  uint64_t v3 = [a1 _inner];
  fHTTPRequest = *(HTTPRequest **)(v3 + 56);
  if (!fHTTPRequest)
  {
    uint64_t v5 = (URLRequest *)v3;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v6);
    URLRequest::createHTTPRequest(v5, &v6);
    CFTypeRef v6 = &unk_1ECF9F718;
    if (cf) {
      CFRelease(cf);
    }
    fHTTPRequest = v5->fHTTPRequest;
  }
  *((unsigned char *)fHTTPRequest + 219) = a2;
}

void sub_1841B6554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CFURLRequestSetRequestPriority(void *a1, uint64_t a2)
{
  uint64_t result = [a1 _inner];
  *(void *)(result + 88) = a2;
  return result;
}

uint64_t CFURLRequestGetRequestPriority(void *a1)
{
  return *(void *)([a1 _inner] + 88);
}

char *CFURLRequestSetShouldStartSynchronously(void *a1, int a2)
{
  uint64_t v3 = [a1 _inner];
  uint64_t result = *(char **)(v3 + 8);
  if (!result
    || (uint64_t result = _CFNetworkIsKnownHSTSHostWithSession(result, *(os_unfair_lock_s **)(v3 + 232)), !result))
  {
    __int16 v5 = *(_WORD *)(v3 + 64);
    __int16 v6 = v5 | 0x4004;
    __int16 v7 = v5 & 0xBFFB | 0x4000;
    if (a2) {
      __int16 v7 = v6;
    }
    *(_WORD *)(v3 + 64) = v7;
  }
  return result;
}

uint64_t CFURLRequestSetAllowsCellularAccess(void *a1, int a2)
{
  uint64_t result = [a1 _inner];
  __int16 v4 = *(_WORD *)(result + 64);
  __int16 v5 = v4 | 0x88;
  __int16 v6 = v4 & 0xFF77 | 0x80;
  if (a2) {
    __int16 v6 = v5;
  }
  *(_WORD *)(result + 64) = v6;
  return result;
}

void _CFURLRequestSetStorageSession(void *a1, const void *a2)
{
  uint64_t v3 = [a1 _inner];
  __int16 v4 = *(const void **)(v3 + 232);
  if (v4 != a2)
  {
    if (v4) {
      CFRelease(v4);
    }
    if (a2) {
      CFTypeRef v5 = CFRetain(a2);
    }
    else {
      CFTypeRef v5 = 0;
    }
    *(void *)(v3 + 232) = v5;
  }
  uint64_t v6 = *(void *)(v3 + 56);
  if (v6)
  {
    __int16 v7 = *(const void **)(v6 + 192);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(v6 + 192) = 0;
    }
  }
}

uint64_t _CFURLRequestSetAllowedProtocolTypes(void *a1, uint64_t a2)
{
  uint64_t result = [a1 _inner];
  *(void *)(result + 96) = a2;
  return result;
}

uint64_t CFURLResponseGetTypeID()
{
  if (CFURLResponseGetTypeID::sOnce != -1) {
    dispatch_once(&CFURLResponseGetTypeID::sOnce, &__block_literal_global_2138);
  }
  return CFURLResponseGetTypeID::sID;
}

uint64_t __CFURLResponseGetTypeID_block_invoke()
{
  CFAllocatorRef v0 = [NSURLResponse alloc];
  CFURLResponseGetTypeID::sID = CFGetTypeID(v0);

  return CFLog();
}

uint64_t CFURLResponseGetURL(void *a1)
{
  return *(void *)([a1 _inner] + 8);
}

uint64_t CFURLResponseGetRecommendedCachePolicy(void *a1)
{
  return *(unsigned int *)([a1 _inner] + 72);
}

__CFString *CFURLResponseGetMIMEType(void *a1)
{
  uint64_t v1 = (URLResponse *)[a1 _inner];

  return URLResponse::getMIMEType(v1);
}

double CFURLResponseGetCreationTime(void *a1)
{
  uint64_t v1 = (URLResponse *)[a1 _inner];

  return URLResponse::getCreationTime(v1);
}

uint64_t CFURLResponseSetExpectedContentLength(void *a1, uint64_t a2)
{
  uint64_t result = [a1 _inner];
  *(void *)(result + 32) = a2;
  uint64_t v4 = *(void *)(result + 88);
  if (v4)
  {
    *(_WORD *)(v4 + 297) |= 0x100u;
    *(_WORD *)(*(void *)(result + 88) + 297) |= 0x2000u;
  }
  return result;
}

uint64_t CFURLResponseSetExpiration(void *a1, double a2)
{
  uint64_t result = [a1 _inner];
  *(double *)(result + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = a2;
  uint64_t v4 = *(void *)(result + 88);
  if (v4) {
    *(_WORD *)(v4 + 297) |= 0x1000u;
  }
  return result;
}

uint64_t _CFURLResponseSetCreationTime(void *a1, double a2)
{
  uint64_t result = [a1 _inner];
  *(double *)(result + 48) = a2;
  return result;
}

uint64_t CFURLResponseSetRecommendedCachePolicy(void *a1, int a2)
{
  uint64_t result = [a1 _inner];
  *(_DWORD *)(result + 72) = a2;
  return result;
}

uint64_t _CFURLResponseGetSSLCertificateContext(void *a1)
{
  return *(void *)([a1 _inner] + 64);
}

uint64_t CFURLResponseGetHTTPResponse(void *a1)
{
  uint64_t v1 = *(void *)([a1 _inner] + 88);
  if (v1) {
    return v1 - 16;
  }
  else {
    return 0;
  }
}

double _CFURLResponseGetFreshnessLifetime(void *a1)
{
  uint64_t v1 = (URLResponse *)[a1 _inner];
  if (!v1->fHTTP) {
    return 1.79769313e308;
  }

  URLResponse::freshnessLifetimeForResponse(v1);
  return result;
}

CFNumberRef _CFURLResponseCreateArchiveList(CFNumberRef result, void *a2, uint64_t *a3, const void ***a4, uint64_t *a5)
{
  if (a2)
  {
    CFAllocatorRef v8 = result;
    uint64_t v9 = (URLResponse *)[a2 _inner];
    return URLResponse::createArchiveList(v9, v8, a3, a4, a5);
  }
  else if (a5)
  {
    *a5 = 7;
  }
  return result;
}

CFStringRef CFURLResponseCopySuggestedFilename(void *a1)
{
  uint64_t v1 = (URLResponse *)[a1 _inner];

  return URLResponse::copySuggestedFilename(v1);
}

BOOL CFURLResponseDataIsEncoded(void *a1)
{
  uint64_t v1 = *(void *)([a1 _inner] + 88);
  return v1 && ((*(unsigned __int16 *)(v1 + 297) | (*(unsigned __int8 *)(v1 + 299) << 16)) & 0x10000) != 0;
}

uint64_t CFURLResponseConnectionDidFallback(void *a1)
{
  return *(unsigned __int8 *)([a1 _inner] + 96);
}

uint64_t _CFURLProtocolSendDidFinishLoadingCallback(void *a1)
{
  uint64_t v2 = (void *)[a1 client];

  return [v2 URLProtocolDidFinishLoading:a1];
}

uint64_t _CFURLProtocolSendDidLoadDataCallback(void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)[a1 client];

  return [v4 URLProtocol:a1 didLoadData:a2];
}

uint64_t _CFURLProtocolSendDidReceiveResponseCallback(void *a1, uint64_t a2)
{
  id v3 = +[NSURLResponse _responseWithCFURLResponse:a2];
  uint64_t v4 = (void *)[a1 client];

  return [v4 URLProtocol:a1 didReceiveResponse:v3 cacheStoragePolicy:2];
}

uint64_t _CFURLProtocolSendDidFailCallback(void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)[a1 client];

  return [v4 URLProtocol:a1 didFailWithError:a2];
}

uint64_t CFURLProtocolGetCachedResponse()
{
  return 0;
}

uint64_t CFURLProtocolGetClient(uint64_t result)
{
  if (result) {
    result += 40;
  }
  return result;
}

const void *CFURLCredentialCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v9 = (const void *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    *(void *)(Instance + 112) = 0;
    *(_OWORD *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    URLCredentialInternetPassword::URLCredentialInternetPassword((URLCredentialInternetPassword *)(Instance + 16));
    if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)v10 + 144))(v10, a2, a3, a5, 0))
    {
      CFRelease(v9);
      return 0;
    }
  }
  else
  {
    URLCredentialInternetPassword::URLCredentialInternetPassword(0);
  }
  return v9;
}

const void *CFURLCredentialCreateWithIdentityAndCertificateArray(uint64_t a1, const void *a2, const __CFArray *a3, int a4)
{
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  CFAllocatorRef v8 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
    URLCredentialClientCertificate::URLCredentialClientCertificate((URLCredentialClientCertificate *)(Instance + 1));
    if (!URLCredentialClientCertificate::initialize(v9, a2, a3, a4))
    {
      CFRelease(v8);
      return 0;
    }
  }
  else
  {
    URLCredentialClientCertificate::URLCredentialClientCertificate(0);
  }
  return v8;
}

uint64_t CFURLCredentialCreateWithTrust(uint64_t a1, const void *a2)
{
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v4 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    *(void *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    URLCredentialServerTrust::URLCredentialServerTrust((URLCredentialServerTrust *)(Instance + 16));
    *(_DWORD *)(v5 + 36) = 2;
    if (a2) {
      CFTypeRef v6 = CFRetain(a2);
    }
    else {
      CFTypeRef v6 = 0;
    }
    *(void *)(v4 + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = v6;
  }
  else
  {
    URLCredentialServerTrust::URLCredentialServerTrust(0);
  }
  return v4;
}

const void *_CFURLCredentialCreateForKerberosTicketWithUUID(const __CFAllocator *a1, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4, const __CFUUID *a5)
{
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v10 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
    URLCredentialKerberosTicket::URLCredentialKerberosTicket((URLCredentialKerberosTicket *)(Instance + 1));
    if (!URLCredentialKerberosTicket::initialize(v11, a2, a3, a4, a5))
    {
      CFRelease(v10);
      return 0;
    }
  }
  else
  {
    URLCredentialKerberosTicket::URLCredentialKerberosTicket(0);
  }
  return v10;
}

const void *_CFURLCredentialCreateForKerberosTicket(const __CFAllocator *a1, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4)
{
  return _CFURLCredentialCreateForKerberosTicketWithUUID(a1, a2, a3, a4, 0);
}

const void *_CFURLCredentialCreateXMobileMeAuthToken(uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  CFAllocatorRef v8 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
    URLCredentialXMobileMeAuthToken::URLCredentialXMobileMeAuthToken((URLCredentialXMobileMeAuthToken *)(Instance + 1));
    if (!URLCredentialXMobileMeAuthToken::initialize(v9, a2, a3, a4))
    {
      CFRelease(v8);
      return 0;
    }
  }
  else
  {
    URLCredentialXMobileMeAuthToken::URLCredentialXMobileMeAuthToken(0);
  }
  return v8;
}

const void *_CFURLCredentialCreateOAuth2(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  CFTypeRef v6 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
    URLCredentialOAuth2::URLCredentialOAuth2((URLCredentialOAuth2 *)(Instance + 1));
    if (!URLCredentialOAuth2::initialize(v7, a2, a3))
    {
      CFRelease(v6);
      return 0;
    }
  }
  else
  {
    URLCredentialOAuth2::URLCredentialOAuth2(0);
  }
  return v6;
}

const void *_CFURLCredentialCreateOAuth1(uint64_t a1, objc_object *a2, int a3, const __CFString *a4)
{
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  CFAllocatorRef v8 = (const void *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    *(void *)(Instance + 96) = 0;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    URLCredentialOAuth1::URLCredentialOAuth1((URLCredentialOAuth1 *)(Instance + 16));
    if (!URLCredentialOAuth1::initialize(v9, a2, a3, a4))
    {
      CFRelease(v8);
      return 0;
    }
  }
  else
  {
    URLCredentialOAuth1::URLCredentialOAuth1(0);
  }
  return v8;
}

uint64_t CFURLCredentialGetPersistence(uint64_t a1)
{
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(unsigned int *)(v2 + 36);
}

uint64_t CFURLCredentialGetUsername(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if (*(_DWORD *)(a1 + 48) && *(_DWORD *)(a1 + 48) != 4 && *(_DWORD *)(a1 + 48) != 2 && *(_DWORD *)(a1 + 48) != 6) {
    return 0;
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 16) + 112);

  return v2();
}

uint64_t CFURLCredentialCopyPassword(uint64_t a1, const _CFURLCredential *a2)
{
  uint64_t result = URLCredential_PasswordBased::safelyCast(a1, a2);
  if (result)
  {
    id v3 = *(uint64_t (**)(void))(*(void *)result + 128);
    return v3();
  }
  return result;
}

uint64_t CFURLCredentialContainsPassword(uint64_t a1, const _CFURLCredential *a2)
{
  uint64_t result = URLCredential_PasswordBased::safelyCast(a1, a2);
  if (result)
  {
    id v3 = *(uint64_t (**)(void))(*(void *)result + 136);
    return v3();
  }
  return result;
}

CFTypeRef _CFURLCredentialCreateArchive(CFAllocatorRef allocator, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    v2 += 16;
  }
  CFTypeRef cf = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if ((*(unsigned int (**)(uint64_t, CFTypeRef *))(*(void *)v2 + 72))(v2, &cf))
  {
    if (!cf) {
      return 0;
    }
    CFTypeRef v4 = CFRetain(cf);
  }
  else
  {
    CFTypeRef v4 = 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v4;
}

void sub_1841B78CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _CFURLCredentialCopyOAuthToken(const _CFURLCredential *a1)
{
  if (!a1) {
    return 0;
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if (*((_DWORD *)a1 + 12) != 6) {
    return 0;
  }
  uint64_t v2 = *(uint64_t (**)(char *))(*((void *)a1 + 2) + 128);

  return v2((char *)a1 + 16);
}

uint64_t _CFURLCredentialCopyOAuth1Account(const _CFURLCredential *a1)
{
  if (!a1) {
    return 0;
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if (*((_DWORD *)a1 + 12) != 7) {
    return 0;
  }
  uint64_t v2 = *(uint64_t (**)(char *))(*((void *)a1 + 2) + 128);

  return v2((char *)a1 + 16);
}

uint64_t _CFURLCredentialGetOAuth1PID(const _CFURLCredential *a1)
{
  if (!a1) {
    return 0;
  }
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  if (*((_DWORD *)a1 + 12) != 7) {
    return 0;
  }
  uint64_t v2 = *(uint64_t (**)(char *))(*((void *)a1 + 2) + 152);

  return v2((char *)a1 + 16);
}

char *_CFURLCredentialCreateFromArchive(URLCredential *a1, const __CFDictionary *a2, const void *a3)
{
  id v3 = URLCredential::createFromPropertyList(a1, a2, a3);
  if (v3) {
    return (char *)v3 - 16;
  }
  else {
    return 0;
  }
}

uint64_t CFURLProtectionSpaceGetHost(uint64_t a1)
{
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(void *)(v2 + 32);
}

uint64_t CFURLProtectionSpaceGetPort(uint64_t a1)
{
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(unsigned int *)(v2 + 40);
}

uint64_t CFURLProtectionSpaceGetServerType(uint64_t a1)
{
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(unsigned int *)(v2 + 44);
}

uint64_t CFURLProtectionSpaceGetRealm(uint64_t a1)
{
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(void *)(v2 + 48);
}

uint64_t CFURLProtectionSpaceGetAuthenticationScheme(uint64_t a1)
{
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(unsigned int *)(v2 + 56);
}

uint64_t CFURLProtectionSpaceReceivesCredentialSecurely(uint64_t a1)
{
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  int v3 = *(_DWORD *)(v2 + 44);
  if (v3 == 2 || v3 == 4) {
    return 1;
  }
  unsigned int v6 = *(_DWORD *)(v2 + 56);
  BOOL v7 = v6 > 4;
  unsigned int v8 = (9u >> v6) & 1;
  if (v7) {
    return 1;
  }
  else {
    return v8;
  }
}

uint64_t CFURLProtectionSpaceGetServerTrust(uint64_t a1)
{
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(void *)(v2 + 72);
}

CFTypeRef _CFURLProtectionSpaceCreateArchive(const __CFAllocator *a1, uint64_t a2)
{
  CFTypeRef cf = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  if (a2) {
    uint64_t v3 = a2 + 16;
  }
  else {
    uint64_t v3 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, CFTypeRef *))(*(void *)v3 + 64))(v3, &cf))
  {
    if (!cf) {
      return 0;
    }
    CFTypeRef v4 = CFRetain(cf);
  }
  else
  {
    CFTypeRef v4 = 0;
  }
  if (cf) {
    CFRelease(cf);
  }
  return v4;
}

void sub_1841B7E70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void Archiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Archiver(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 8);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

uint64_t Archiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Archiver(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t _CFURLProtectionSpaceCreateFromArchive(const __CFAllocator *a1, CFTypeRef cf)
{
  cfa[1] = a1;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  cfa[0] = v3;
  cfa[2] = a1;
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(void *)(Instance + 16) = &unk_1ECF9F738;
  *(void *)(Instance + 24) = &unk_1ECF9F790;
  *(void *)(Instance + 32) = &gConstantCFStringValueTable[3780];
  *(unsigned char *)(Instance + 96) = 0;
  *(unsigned char *)(Instance + 104) = 0;
  *(void *)(Instance + 112) = 1;
  if (!URLProtectionSpace::initializeFromPropertyList((URLProtectionSpace *)(Instance + 16), (CFDictionaryRef *)cfa))
  {
    CFRelease((CFTypeRef)Instance);
    uint64_t Instance = 0;
  }
  if (cfa[0]) {
    CFRelease(cfa[0]);
  }
  return Instance;
}

void sub_1841B804C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void Dearchiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Dearchiver(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 8);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

uint64_t Dearchiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Dearchiver(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

CFTypeRef URLProtectionSpace::setDistinguishedNames(URLProtectionSpace *this, CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 8);
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *((void *)this + 8) = result;
  }
  return result;
}

uint64_t authMethodToAuthScheme(NSString *a1)
{
  if (!a1) {
    return 1;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodDefault"]) {
    return 1;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodHTTPBasic"]) {
    return 2;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodHTTPDigest"]) {
    return 3;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodHTMLForm"]) {
    return 4;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodNTLM"]) {
    return 5;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodNegotiate"]) {
    return 6;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodClientCertificate"]) {
    return 7;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodServerTrust"]) {
    return 8;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodXMobileMeAuthToken"]) {
    return 9;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodOAuth"]) {
    return 10;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodPrivateAccessToken"]) {
    return 11;
  }
  if ([(NSString *)a1 isEqualToString:@"NSURLAuthenticationMethodOAuthBearerToken"]) {
    return 12;
  }
  return 1;
}

id AppSSO::AppSSOProtocolLog(AppSSO *this)
{
  if (AppSSO::AppSSOProtocolLog(void)::onceToken != -1) {
    dispatch_once(&AppSSO::AppSSOProtocolLog(void)::onceToken, &__block_literal_global_2448);
  }
  uint64_t v1 = (void *)AppSSO::AppSSOProtocolLog(void)::ssoLog;

  return v1;
}

void ___ZN6AppSSOL17AppSSOProtocolLogEv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.CFNetwork", "AppSSOProtocol");
  uint64_t v1 = (void *)AppSSO::AppSSOProtocolLog(void)::ssoLog;
  AppSSO::AppSSOProtocolLog(void)::ssoLog = (uint64_t)v0;
}

char *AppSSOProtocol::_instantiateProtocol(AppSSOProtocol *this, const __CFAllocator *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  CFAllocatorRef v6 = a2;
  if (TCFObject<URLProtocol>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLProtocol>::Class(void)::sOnce, &__block_literal_global_55);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  unsigned int v8 = (URLProtocol *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    unsigned int v8 = (URLProtocol *)(Instance + 16);
    *(void *)(Instance + 144) = 0;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }
  *(_OWORD *)((char *)v8 + 104) = 0u;
  *(_OWORD *)((char *)v8 + 12_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)((char *)v8 + 88) = 0u;
  *(_OWORD *)((char *)v8 + 72) = 0u;
  *(_OWORD *)((char *)v8 + 56) = 0u;
  *(_OWORD *)((char *)v8 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)((char *)v8 + 24) = 0u;
  *(void *)unsigned int v8 = &unk_1ECF9C6E8;
  *((void *)v8 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C7E8;
  *((void *)v8 + 2) = &unk_1ECF9C808;
  *((void *)v8 + 14) = 0;
  *((void *)v8 + 15) = 0;
  *((unsigned char *)v8 + 128) = 0;
  if (AppSSOProtocol::initialize(v8, (NSURLSessionTask *)v6, a3))
  {
    uint64_t v9 = (char *)v8 - 16;
  }
  else
  {
    (*(void (**)(URLProtocol *))(*(void *)v8 + 64))(v8);
    CFRelease((char *)v8 - 16);
    uint64_t v9 = 0;
  }

  return v9;
}

void sub_1841B933C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t AppSSOProtocol::initialize(URLProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2;
  URLProtocol::initialize(this, v5, a3);
  CFAllocatorRef v6 = [(NSURLSessionTask *)v5 session];

  if (v6)
  {
    [(NSURLSessionTask *)v5 _loggableDescription];
    objc_claimAutoreleasedReturnValue();
    operator new();
  }

  return 0;
}

void sub_1841B94AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void non-virtual thunk to'AppSSOProtocol::~AppSSOProtocol(AppSSOProtocol *this)
{
  uint64_t v1 = (URLProtocol *)((char *)this - 16);
  *((void *)this - 2) = &unk_1ECF9C6E8;
  *((void *)this - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C7E8;
  *(void *)this = &unk_1ECF9C808;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  URLProtocol::~URLProtocol(v1);
}

{
  URLProtocol *v1;
  std::__shared_weak_count *v2;
  uint64_t vars8;

  uint64_t v1 = (URLProtocol *)((char *)this - 16);
  *((void *)this - 2) = &unk_1ECF9C6E8;
  *((void *)this - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C7E8;
  *(void *)this = &unk_1ECF9C808;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  URLProtocol::~URLProtocol(v1);
}

{
  URLProtocol *v1;
  std::__shared_weak_count *v2;
  uint64_t vars8;

  uint64_t v1 = (URLProtocol *)((char *)this - 8);
  *((void *)this - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C6E8;
  *(void *)this = &unk_1ECF9C7E8;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C808;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  URLProtocol::~URLProtocol(v1);
}

{
  URLProtocol *v1;
  std::__shared_weak_count *v2;
  uint64_t vars8;

  uint64_t v1 = (URLProtocol *)((char *)this - 8);
  *((void *)this - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C6E8;
  *(void *)this = &unk_1ECF9C7E8;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C808;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  URLProtocol::~URLProtocol(v1);
}

void AppSSOProtocol::subclassUpdateScheduling(AppSSOProtocol *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  CFTypeRef v4 = AppSSO::AppSSOProtocolLog(this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *((void *)this + 14);
    int v6 = 134218242;
    BOOL v7 = this;
    __int16 v8 = 2114;
    uint64_t v9 = v5;
    _os_log_debug_impl(&dword_184085000, v4, OS_LOG_TYPE_DEBUG, "%p update scheduling %{public}@", (uint8_t *)&v6, 0x16u);
  }
}

void AppSSOProtocol::_protocolInterface_setIsDownload(AppSSOProtocol *this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = AppSSO::AppSSOProtocolLog(this);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *((void *)this + 14);
    int v4 = 134218242;
    uint64_t v5 = this;
    __int16 v6 = 2114;
    uint64_t v7 = v3;
    _os_log_debug_impl(&dword_184085000, v2, OS_LOG_TYPE_DEBUG, "%p setIsDownload %{public}@", (uint8_t *)&v4, 0x16u);
  }
}

void AppSSOProtocol::_protocolInterface_useCredential(AppSSOProtocol *this, const _CFURLCredential *a2, _CFURLAuthChallenge *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  int v4 = AppSSO::AppSSOProtocolLog(this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = *((void *)this + 14);
    int v6 = 134218242;
    uint64_t v7 = this;
    __int16 v8 = 2114;
    uint64_t v9 = v5;
    _os_log_debug_impl(&dword_184085000, v4, OS_LOG_TYPE_DEBUG, "%p use credential %{public}@", (uint8_t *)&v6, 0x16u);
  }
}

void AppSSOProtocol::_protocolInterface_resumeLoad(AppSSOProtocol *this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = AppSSO::AppSSOProtocolLog(this);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *((void *)this + 14);
    int v4 = 134218242;
    uint64_t v5 = this;
    __int16 v6 = 2114;
    uint64_t v7 = v3;
    _os_log_debug_impl(&dword_184085000, v2, OS_LOG_TYPE_DEBUG, "%p resume load %{public}@", (uint8_t *)&v4, 0x16u);
  }
}

void AppSSOProtocol::_protocolInterface_haltLoad(AppSSOProtocol *this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = AppSSO::AppSSOProtocolLog(this);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *((void *)this + 14);
    int v4 = 134218242;
    uint64_t v5 = this;
    __int16 v6 = 2114;
    uint64_t v7 = v3;
    _os_log_debug_impl(&dword_184085000, v2, OS_LOG_TYPE_DEBUG, "%p halt load %{public}@", (uint8_t *)&v4, 0x16u);
  }
}

void AppSSOProtocol::_protocolInterface_cancelLoad(AppSSOProtocol *this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = AppSSO::AppSSOProtocolLog(this);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *((void *)this + 14);
    int v4 = 134218242;
    uint64_t v5 = this;
    __int16 v6 = 2114;
    uint64_t v7 = v3;
    _os_log_debug_impl(&dword_184085000, v2, OS_LOG_TYPE_DEBUG, "%p cancel load %{public}@", (uint8_t *)&v4, 0x16u);
  }

  *((unsigned char *)this + 128) = 1;
}

void AppSSOProtocol::_protocolInterface_startLoad(id *this, const _CFCachedURLResponse *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = this[10];
  if (v3)
  {
    int v4 = v3;
    uint64_t v5 = [v3 session];
    if (v5)
    {
      __int16 v6 = AppSSO::AppSSOProtocolLog(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        id v7 = this[14];
        *(_DWORD *)int buf = 134218242;
        CFRange v18 = this;
        __int16 v19 = 2114;
        id v20 = v7;
        _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "%p starting load for %{public}@", buf, 0x16u);
      }

      CFRetain(this - 2);
      operator new();
    }
  }
  uint64_t v8 = AppSSO::AppSSOProtocolLog((AppSSO *)v3);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    id v16 = this[14];
    *(_DWORD *)int buf = 134218242;
    CFRange v18 = this;
    __int16 v19 = 2114;
    id v20 = v16;
    _os_log_error_impl(&dword_184085000, v8, OS_LOG_TYPE_ERROR, "%p did not start load for %{public}@", buf, 0x16u);
  }

  CFAllocatorRef v9 = CFGetAllocator(this - 2);
  CFCFStreamError Error = __cfnCreateCFError(v9, @"kCFErrorDomainCFNetwork", -1000, v10, v11, v12, v13, v14, 0);
  URLProtocol::sendDidFail((URLProtocol *)this, CFError);
  if (CFError) {
    CFRelease(CFError);
  }
}

void sub_1841B9DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v18);

  _Unwind_Resume(a1);
}

void ___ZN14AppSSOProtocol28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke(int a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  operator new();
}

void sub_1841B9F5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11URLProtocol11sendDidFailEP9__CFError_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 231;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void __destroy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN14AppSSOProtocol28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke_2(uint64_t a1)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 128)) {
    return;
  }
  uint64_t v2 = *(void **)(a1 + 48);
  id v3 = *(id *)(v1 + 88);
  if (v3)
  {
    int v4 = v3;
    if ([v3 cfURL])
    {
      uint64_t v5 = *(HTTPMessage **)([v4 _inner] + 56);
      if (v5) {
        CFMutableDictionaryRef v6 = HTTPMessage::copyAllHeaderFields(v5);
      }
      else {
        CFMutableDictionaryRef v6 = 0;
      }
      CFDictionaryRef v15 = [MEMORY[0x1E4F1CA60] dictionaryWithDictionary:v6];
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      id v16 = v2;
      uint64_t v17 = [v16 countByEnumeratingWithState:&v31 objects:v35 count:16];
      if (v17)
      {
        uint64_t v18 = *(void *)v32;
        do
        {
          for (uint64_t i = 0; i != v17; ++i)
          {
            if (*(void *)v32 != v18) {
              objc_enumerationMutation(v16);
            }
            id v20 = *(id *)(*((void *)&v31 + 1) + 8 * i);
            uint64_t v21 = [v16 objectForKeyedSubscript:v20];
            [v15 setObject:v21 forKeyedSubscript:v20];
          }
          uint64_t v17 = [v16 countByEnumeratingWithState:&v31 objects:v35 count:16];
        }
        while (v17);
      }

      uint64_t v22 = *(HTTPBodyData ***)([v4 _inner] + 56);
      if (!v22 || (CFArrayRef v23 = HTTPMessage::copyBody(v22)) == 0)
      {
        CFArrayRef v23 = CFURLRequestCopyHTTPRequestBodyParts(v4);
        CFArrayRef v24 = v23;
        if (v23)
        {
          CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v23, 0);
          CFIndex v26 = ValueAtIndex;
          if (ValueAtIndex)
          {
            CFTypeID v27 = CFGetTypeID(ValueAtIndex);
            if (v27 == CFDataGetTypeID()) {
              CFRetain(v26);
            }
          }
          CFRelease(v24);
        }
      }
      int v28 = AppSSO::AppSSOProtocolLog(v23);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v29 = *(void *)(v1 + 112);
        buf[0] = 134218242;
        *(void *)&buf[1] = v1;
        __int16 v40 = 2114;
        uint64_t v41 = v29;
        _os_log_impl(&dword_184085000, v28, OS_LOG_TYPE_DEFAULT, "%p continuing load of %{public}@", (uint8_t *)buf, 0x16u);
      }
      else
      {

        if (!v1) {
          goto LABEL_32;
        }
      }
      CFRetain((CFTypeRef)(v1 - 16));
LABEL_32:
      operator new();
    }
  }
  id v7 = AppSSO::AppSSOProtocolLog((AppSSO *)v3);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    uint64_t v30 = *(void *)(v1 + 112);
    *(_DWORD *)int v35 = 134218242;
    uint64_t v36 = v1;
    __int16 v37 = 2114;
    uint64_t v38 = v30;
    _os_log_error_impl(&dword_184085000, v7, OS_LOG_TYPE_ERROR, "%p did not continue load for %{public}@", v35, 0x16u);
  }

  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)(v1 - 16));
  CFCFStreamError Error = __cfnCreateCFError(v8, @"kCFErrorDomainCFNetwork", -1008, v9, v10, v11, v12, v13, 0);
  URLProtocol::sendDidFail((URLProtocol *)v1, CFError);
  if (CFError) {
    CFRelease(CFError);
  }
}

void sub_1841BA644(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFTypeRef cf, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  CFRelease(v23);

  if (cf) {
    CFRelease(cf);
  }

  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN14AppSSOProtocol24continueLoadAfterCookiesEPK14__CFDictionary_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v7 = a2;
  CFAllocatorRef v8 = AppSSO::AppSSOProtocolLog(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(a1 + 32);
    *(_DWORD *)int buf = 134218754;
    uint64_t v12 = v9;
    __int16 v13 = 2112;
    uint64_t v14 = v7;
    __int16 v15 = 2112;
    uint64_t v16 = a3;
    __int16 v17 = 2112;
    uint64_t v18 = a4;
    _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "getResponse for AppSSOProtocol %p returns response %@ data %@ error %@", buf, 0x2Au);
  }

  uint64_t v10 = v7;
  operator new();
}

void sub_1841BAACC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a18);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v23);
  std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  std::__shared_weak_count::__release_shared[abi:nn180100](v21);

  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *> *,SmartBlockWithArgs<NSURLResponse * {__strong},__CFData const*,__CFError *>::Deleter,std::allocator<BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_initial
    && v5 != 0)
  {
    id v7 = (void *)(v1 + (v2 >> 1));
    if (v2) {
      (*(void (**)(void *, void, void, void))(*v7
    }
                                                               + BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_initial))(v7, 0, 0, 0);
    else {
      ((void (*)(void *, void, void, void))BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_initial)(v7, 0, 0, 0);
    }
  }

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *> *,SmartBlockWithArgs<NSURLResponse * {__strong},__CFData const*,__CFError *>::Deleter,std::allocator<BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

uint64_t BlockHolderVar<NSURLResponse * {__strong},__CFData const*,__CFError *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

void ___ZN14AppSSOProtocol24continueLoadAfterCookiesEPK14__CFDictionary_block_invoke_2(AppSSO *a1)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((void *)a1 + 4);
  if (*(unsigned char *)(v1 + 128)) {
    return;
  }
  uint64_t v2 = (void *)*((void *)a1 + 6);
  CFDataRef v3 = (const __CFData *)*((void *)a1 + 8);
  BOOL v4 = (AppSSO *)*((void *)a1 + 10);
  int v5 = AppSSO::AppSSOProtocolLog(a1);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 134218754;
    *(void *)&uint8_t buf[4] = v1;
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = v2;
    *(_WORD *)&unsigned char buf[22] = 2112;
    CFDataRef v64 = v3;
    LOWORD(v65) = 2112;
    *(void *)((char *)&v65 + 2) = v4;
    _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "%p Handling auth response %@ data %@ error %@", buf, 0x2Au);
  }

  if (v2 && !v4)
  {
    uint64_t v7 = *(void *)([v2 _inner] + 88);
    if (v7) {
      uint64_t v8 = v7 - 16;
    }
    else {
      uint64_t v8 = 0;
    }
    if (v7)
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      if (!*(unsigned char *)(v8 + 40)) {
        goto LABEL_51;
      }
      CFArrayRef v9 = HTTPResponseMessage::copyCookiesStrings((os_unfair_lock_s *)(v8 + 16));
      if (!v9)
      {
LABEL_46:
        unsigned int v34 = *(_DWORD *)(v8 + 144) - 301;
        BOOL v35 = v34 > 7;
        int v36 = (1 << v34) & 0xC3;
        if (!v35 && v36 != 0)
        {
          v55[0] = 0;
          HTTPMessage::copyLastHeaderFieldValue((HTTPMessage *)(v8 + 16), 0x13011336u);
          operator new();
        }
LABEL_51:
        v55[0] = (__CFURL *)MEMORY[0x1E4F143A8];
        v55[1] = (__CFURL *)3221225472;
        int v56 = ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke;
        CFIndex v57 = &__block_descriptor_40_e31_v16__0__URLProtocolClient_____8l;
        int v58 = v2;
        uint64_t v38 = v55;
        uint64_t v39 = *(void *)(v1 + 96);
        if (v39)
        {
          uint64_t v40 = (*(uint64_t (**)(void))(*(void *)v39 + 16))(*(void *)(v1 + 96));
          uint64_t v41 = (void *)MEMORY[0x18531D6D0](v40);
          v56((uint64_t)v38, *(void *)(v1 + 96));
          (*(void (**)(uint64_t))(*(void *)v39 + 24))(v39);
        }

        int64_t v43 = AppSSO::AppSSOProtocolLog(v42);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v44 = *(void *)(v1 + 112);
          *(_DWORD *)int buf = 134218242;
          *(void *)&uint8_t buf[4] = v1;
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v44;
          _os_log_impl(&dword_184085000, v43, OS_LOG_TYPE_DEFAULT, "%p sent response %{public}@", buf, 0x16u);
        }

        if (v3)
        {
          CFIndex Length = CFDataGetLength(v3);
          CFIndex v46 = *(Throttler **)(v1 + 64);
          if (v46)
          {
            CFIndex v47 = CFDataGetLength(v3);
            Throttler::noteOutstandingBytes(v46, v47);
          }
          *(void *)int buf = MEMORY[0x1E4F143A8];
          *(void *)&uint8_t buf[8] = 3221225472;
          *(void *)&uint8_t buf[16] = ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke;
          CFDataRef v64 = (const __CFData *)&__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
          *(void *)&long long v65 = v3;
          *((void *)&v65 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = Length;
          CFIndex v48 = buf;
          uint64_t v49 = *(void *)(v1 + 96);
          if (v49)
          {
            uint64_t v50 = (*(uint64_t (**)(void))(*(void *)v49 + 16))(*(void *)(v1 + 96));
            int64_t v51 = (void *)MEMORY[0x18531D6D0](v50);
            (*(void (**)(unsigned char *, void))&buf[16])(v48, *(void *)(v1 + 96));
            (*(void (**)(uint64_t))(*(void *)v49 + 24))(v49);
          }

          CFIndex v53 = AppSSO::AppSSOProtocolLog(v52);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v54 = *(void *)(v1 + 112);
            *(_DWORD *)CFIndex v59 = 134218242;
            uint64_t v60 = v1;
            __int16 v61 = 2114;
            uint64_t v62 = v54;
            _os_log_impl(&dword_184085000, v53, OS_LOG_TYPE_DEFAULT, "%p sent data %{public}@", v59, 0x16u);
          }
        }
        URLProtocol::sendDidFinishLoading((URLProtocol *)v1);
        return;
      }
      uint64_t v10 = *(void **)(v1 + 88);
      if (!v10
        || ![*(id *)(v1 + 80) shouldHandleCookiesAndSchemeIsAppropriate]
        || !*(void *)([v10 _inner] + 8))
      {
LABEL_45:
        CFRelease(v9);
        goto LABEL_46;
      }
      *(void *)int buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = ___ZN14AppSSOProtocol24handleCookiesForResponseEP19HTTPResponseMessage_block_invoke;
      CFDataRef v64 = (const __CFData *)&__block_descriptor_40_e5_v8__0l;
      *(void *)&long long v65 = 0;
      uint64_t v11 = *(void *)([v10 _inner] + 56);
      if (v11 && (uint64_t v12 = *(OpaqueCFHTTPCookieStorage **)(v11 + 192)) != 0)
      {
        __int16 v13 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 40, 0);
        v13[4] = 0;
        *(_OWORD *)__int16 v13 = 0u;
        *((_OWORD *)v13 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
        CFXCookieStorage::CFXCookieStorage((CFXCookieStorage *)v13, v12);
      }
      else
      {
        id v31 = *(id *)(v1 + 80);
        if (!v31) {
          goto LABEL_44;
        }
        long long v32 = v31;
        __int16 v13 = (void *)[*(id *)(v1 + 80) _createXCookieStorage];

        if (!v13) {
          goto LABEL_44;
        }
      }
      (*(void (**)(void *, CFArrayRef, void))(*v13 + 64))(v13, v9, *(void *)(v1 + 80));
LABEL_44:
      (*(void (**)(unsigned char *))&buf[16])(buf);
      goto LABEL_45;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v22 = (id)CFNLog::logger;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      uint64_t v33 = *(void *)(v1 + 112);
      *(_DWORD *)int buf = 138543362;
      *(void *)&uint8_t buf[4] = v33;
      _os_log_error_impl(&dword_184085000, v22, OS_LOG_TYPE_ERROR, "%{public}@ AppSSOProtocol did not receive HTTP response", buf, 0xCu);
    }

    CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)(v1 - 16));
    CFCFStreamError Error = __cfnCreateCFError(v23, @"kCFErrorDomainCFNetwork", -1011, v24, v25, v26, v27, v28, 0);
    URLProtocol::sendDidFail((URLProtocol *)v1, CFError);
    goto LABEL_39;
  }
  isPerformDefaultHandlingCFStreamError Error = (AppSSO *)AppSSO::isPerformDefaultHandlingError(v4, v6);
  if (!isPerformDefaultHandlingError)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v19 = (id)CFNLog::logger;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = *(void *)(v1 + 112);
      *(_DWORD *)int buf = 138543874;
      *(void *)&uint8_t buf[4] = v30;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v2;
      *(_WORD *)&unsigned char buf[22] = 2112;
      CFDataRef v64 = v4;
      _os_log_error_impl(&dword_184085000, v19, OS_LOG_TYPE_ERROR, "%{public}@ AppSSOProtocol received response %@ error %@ canceling", buf, 0x20u);
    }

    CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (v4)
    {
      CFCFStreamError Error = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionarySetValue(CFError, (const void *)*MEMORY[0x1E4F28A50], v4);
    }
    else
    {
      CFCFStreamError Error = 0;
    }
    uint64_t v29 = CFErrorCreate(v20, @"kCFErrorDomainCFNetwork", -1012, CFError);
    URLProtocol::sendDidFail((URLProtocol *)v1, v29);
    if (v29) {
      CFRelease(v29);
    }
LABEL_39:
    if (CFError) {
      CFRelease(CFError);
    }
    return;
  }
  __int16 v15 = AppSSO::AppSSOProtocolLog(isPerformDefaultHandlingError);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = *(void *)(v1 + 112);
    *(_DWORD *)int buf = 138543362;
    *(void *)&uint8_t buf[4] = v16;
    _os_log_impl(&dword_184085000, v15, OS_LOG_TYPE_DEFAULT, "Performing default handling for %{public}@", buf, 0xCu);
  }

  id v17 = *(id *)(v1 + 80);
  objc_msgSend(v17, "set_preventsAppSSO:", 1);
  objc_msgSend(v17, "set_appSSOFallback:", 1);
  uint64_t v18 = [v17 currentRequest];
  URLProtocol::sendWasRedirected((URLProtocol *)v1, v18, 0);
}

void sub_1841BB854(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23)
{
  if (v23) {
    CFRelease(v23);
  }
  CFRelease(v25);
  if (v24) {
    CFRelease(v24);
  }
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE48c42_ZTSNSt3__110shared_ptrI14_CFURLResponseEE64c36_ZTSNSt3__110shared_ptrIK8__CFDataEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[11];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  CFDataRef v3 = (std::__shared_weak_count *)a1[9];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  BOOL v4 = (std::__shared_weak_count *)a1[7];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  int v5 = (std::__shared_weak_count *)a1[5];
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void *__copy_helper_block_ea8_32c42_ZTSNSt3__110shared_ptrI14AppSSOProtocolEE48c42_ZTSNSt3__110shared_ptrI14_CFURLResponseEE64c36_ZTSNSt3__110shared_ptrIK8__CFDataEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[9];
  result[8] = a2[8];
  result[9] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a2[11];
  result[10] = a2[10];
  result[11] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void _ApplyOriginalComponents(NSURLRequest *a1, CFTypeRef *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3) {
    goto LABEL_28;
  }
  CFTypeRef v5 = *a2;
  uint64_t v6 = [(NSURLRequest *)v3 cfURL];
  if (!v5 || !v6) {
    goto LABEL_28;
  }
  long long v19 = 0u;
  *(_OWORD *)CFTypeRef cf = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  memset(theString1, 0, sizeof(theString1));
  long long v14 = 0u;
  long long v15 = 0u;
  memset(theString2, 0, sizeof(theString2));
  if (_CFURLCopyComponents() && _CFURLCopyComponents())
  {
    if (cf[0]) {
      BOOL v7 = (void)v16 == 0;
    }
    else {
      BOOL v7 = 0;
    }
    int v8 = v7;
    if (v7) {
      *(void *)&long long v16 = CFRetain(cf[0]);
    }
    if (theString1[0])
    {
      if (theString2[0])
      {
        if (theString1[3])
        {
          if (theString2[3])
          {
            if (CFStringCompare(theString1[0], theString2[0], 1uLL) == kCFCompareEqualTo
              && CFStringCompare(theString1[3], theString2[3], 1uLL) == kCFCompareEqualTo)
            {
              int32x4_t v10 = (int32x4_t)vtstq_s64(*(int64x2_t *)&theString1[1], *(int64x2_t *)&theString1[1]);
              *(int32x2_t *)v10.i8 = vmovn_s64((int64x2_t)v10);
              v10.i32[0] = vmovn_s32(v10).u32[0];
              int64x2_t v11 = vceqzq_s64(*(int64x2_t *)&theString2[1]);
              v10.i32[1] = vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v11, v11)).i32[1];
              if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(*(int16x4_t *)v10.i8, 0xFuLL))) & 1) != 0
                && (void)v18 == (void)v14)
              {
                theString2[1] = (CFStringRef)CFRetain(theString1[1]);
                CFStringRef v12 = theString1[2];
                if (theString1[2]) {
                  CFStringRef v12 = (const __CFString *)CFRetain(theString1[2]);
                }
                theString2[2] = v12;
                goto LABEL_22;
              }
            }
          }
        }
      }
    }
    if (v8)
    {
LABEL_22:
      CFArrayRef v9 = (const void *)_CFURLCreateFromComponents();
      goto LABEL_24;
    }
  }
  CFArrayRef v9 = 0;
LABEL_24:
  _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper((uint64_t)theString2);
  _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper((uint64_t)theString1);
  if (v9)
  {
    CFRetain(v9);
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = v9;
    CFRelease(v9);
  }
LABEL_28:
}

void sub_1841BBC74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  CFRelease(v20);

  _Unwind_Resume(a1);
}

void ___ZN14AppSSOProtocol27handleAuthorizationResponseEP14_CFURLResponsePK8__CFDataP9__CFError_block_invoke(uint64_t a1)
{
}

void URLProtocol::sendWasRedirected(URLProtocol *this, NSURLRequest *a2, _CFURLResponse *a3)
{
  CFTypeRef v5 = a2;
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  CFStringRef v12 = ___ZN11URLProtocol17sendWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke;
  __int16 v13 = &unk_1E5255ED8;
  uint64_t v6 = v5;
  long long v14 = v6;
  long long v15 = a3;
  BOOL v7 = v11;
  uint64_t v8 = *((void *)this + 12);
  if (v8)
  {
    uint64_t v9 = (*(uint64_t (**)(void))(*(void *)v8 + 16))(*((void *)this + 12));
    int32x4_t v10 = (void *)MEMORY[0x18531D6D0](v9);
    v12((uint64_t)v7, *((void *)this + 12));
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
}

void sub_1841BBDD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN11URLProtocol22sendDidReceiveResponseEP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 64))(a2, *(void *)(a1 + 32));
}

uint64_t ___ZN11URLProtocol15sendDidLoadDataEPK8__CFDatax_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 72))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t ___ZN11URLProtocol17sendWasRedirectedEP12NSURLRequestP14_CFURLResponse_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 40))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper(uint64_t a1)
{
  uint64_t v2 = *(const void **)a1;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 16);
  if (v4) {
    CFRelease(v4);
  }
  CFTypeRef v5 = *(const void **)(a1 + 24);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 40);
  if (v6) {
    CFRelease(v6);
  }
  BOOL v7 = *(const void **)(a1 + 48);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = *(const void **)(a1 + 56);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = *(const void **)(a1 + 64);
  if (v9) {
    CFRelease(v9);
  }
  int32x4_t v10 = *(const void **)(a1 + 72);
  if (v10) {
    CFRelease(v10);
  }
  return a1;
}

uint64_t ___ZN14AppSSOProtocol24handleCookiesForResponseEP19HTTPResponseMessage_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  return result;
}

void std::__shared_ptr_pointer<__CFData const*,Deleter_CFRelease,std::allocator<__CFData const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<__CFError *,Deleter_CFRelease,std::allocator<__CFError>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<_CFURLResponse *,Deleter_CFRelease,std::allocator<_CFURLResponse>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void std::__shared_ptr_pointer<_CFURLResponse *,Deleter_CFRelease,std::allocator<_CFURLResponse>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<AppSSOProtocol *,Deleter_release<AppSSOProtocol>,std::allocator<AppSSOProtocol>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    CFRelease((CFTypeRef)(v1 - 16));
  }
}

void std::__shared_ptr_pointer<AppSSOProtocol *,Deleter_release<AppSSOProtocol>,std::allocator<AppSSOProtocol>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void AppSSOProtocol::~AppSSOProtocol(URLProtocol *this)
{
  *(void *)this = &unk_1ECF9C6E8;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C7E8;
  *((void *)this + 2) = &unk_1ECF9C808;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  URLProtocol::~URLProtocol(this);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ECF9C6E8;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9C7E8;
  *((void *)this + 2) = &unk_1ECF9C808;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  URLProtocol::~URLProtocol(this);
}

CFStringRef AppSSOProtocol::copyDebugDesc(AppSSOProtocol *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<AppSSOProtocol instance %p>", this);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_2529()
{
}

void sub_1841BC240(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

CFTypeRef AppSSOProtocol::_createCanonicalRequest(AppSSOProtocol *this, CFTypeRef cf, const _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  if (cf) {
    return CFRetain(cf);
  }
  else {
    return 0;
  }
}

uint64_t CFURLAuthChallengeGetProtectionSpace(uint64_t a1)
{
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(void *)(v2 + 24);
}

uint64_t CFURLAuthChallengeGetProposedCredential(uint64_t a1)
{
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(void *)(v2 + 32);
}

uint64_t CFURLAuthChallengeGetPreviousFailureCount(uint64_t a1)
{
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(void *)(v2 + 40);
}

uint64_t CFURLAuthChallengeGetError(uint64_t a1)
{
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(void *)(v2 + 56);
}

uint64_t CFURLAuthChallengeGetFailureResponse(uint64_t a1)
{
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(void *)(v2 + 48);
}

void Archiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Archiver(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 8);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

uint64_t Archiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Archiver(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t _CFURLAuthChallengeCreateFromArchive(const __CFAllocator *a1, CFTypeRef cf)
{
  cfa[1] = a1;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0;
  }
  cfa[0] = v3;
  cfa[2] = a1;
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(void *)(Instance + 16) = &unk_1ECF9E058;
  *(void *)(Instance + 24) = &unk_1ECF9E0B0;
  *(void *)(Instance + 32) = &gConstantCFStringValueTable[3766];
  if (!URLAuthChallenge::initializeFromPropertyList((URLAuthChallenge *)(Instance + 16), (CFDictionaryRef *)cfa))
  {
    CFRelease((CFTypeRef)Instance);
    uint64_t Instance = 0;
  }
  if (cfa[0]) {
    CFRelease(cfa[0]);
  }
  return Instance;
}

void sub_1841BC5E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void Dearchiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Dearchiver(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 8);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

uint64_t Dearchiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Dearchiver(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t CFHTTPCookieGetTypeID()
{
  if (CFHTTPCookieGetTypeID::sOnce != -1) {
    dispatch_once(&CFHTTPCookieGetTypeID::sOnce, &__block_literal_global_2553);
  }
  return CFHTTPCookieGetTypeID::sResult;
}

CFTypeID __CFHTTPCookieGetTypeID_block_invoke()
{
  v2[4] = *MEMORY[0x1E4F143B8];
  CFLog();
  v1[0] = @"Name";
  v1[1] = @"Value";
  v2[0] = @"name";
  v2[1] = @"value";
  v1[2] = @"Path";
  v1[3] = @"Domain";
  v2[2] = @"/";
  v2[3] = @"fake.com";
  CFTypeID result = CFGetTypeID(+[NSHTTPCookie cookieWithProperties:](NSHTTPCookie, "cookieWithProperties:", [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v2 forKeys:v1 count:4]));
  CFHTTPCookieGetTypeID::sResult = result;
  return result;
}

CFArrayRef _CFHTTPParsedCookiesWithResponseHeaderFields(const __CFAllocator *a1, CFDictionaryRef theDict, const __CFURL *a3)
{
  CFNumberRef Value = CFDictionaryGetValue(theDict, &unk_1EC0A28C0);
  if (Value)
  {
    Array = cfTypeCreateArray(a1, Value, 0, 0, 0);
    CookiesWithCookieStrings = _createCookiesWithCookieStrings(a1, Array, a3, 0, 1);
    if (Array) {
      CFRelease(Array);
    }
    if (CookiesWithCookieStrings) {
      return CookiesWithCookieStrings;
    }
  }
  uint64_t v9 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];

  return CFArrayCreate(a1, 0, 0, v9);
}

void sub_1841BC874(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

const void *_CFHTTPCookieCreateWithStringAndPartition(const __CFAllocator *a1, uint64_t a2, const __CFURL *a3, uint64_t a4)
{
  Array = cfTypeCreateArray(a1, a2, 0, 0, 0);
  CookiesWithCookieStrings = _createCookiesWithCookieStrings(a1, Array, a3, a4, 1);
  if (Array) {
    CFRelease(Array);
  }
  if (!CookiesWithCookieStrings) {
    return 0;
  }
  if (CFArrayGetCount(CookiesWithCookieStrings) < 1)
  {
    int32x4_t v10 = 0;
  }
  else
  {
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(CookiesWithCookieStrings, 0);
    int32x4_t v10 = ValueAtIndex;
    if (ValueAtIndex) {
      CFRetain(ValueAtIndex);
    }
  }
  CFRelease(CookiesWithCookieStrings);
  return v10;
}

void sub_1841BC948(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef _CFHTTPCookieCreateCookiesWithResponseMessage(CFAllocatorRef allocator, uint64_t a2, const __CFURL *a3, uint64_t a4)
{
  if (a2)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    uint64_t v8 = *(unsigned char *)(a2 + 40) ? (os_unfair_lock_s *)(a2 + 16) : 0;
    CFArrayRef v9 = HTTPResponseMessage::copyCookiesStrings(v8);
    if (v9)
    {
      CFArrayRef v10 = v9;
      if (CFArrayGetCount(v9) <= 0)
      {
        CFRelease(v10);
      }
      else
      {
        CookiesWithCookieStrings = _createCookiesWithCookieStrings(allocator, v10, a3, a4, 1);
        CFRelease(v10);
        if (CookiesWithCookieStrings) {
          return CookiesWithCookieStrings;
        }
      }
    }
  }
  __int16 v13 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];

  return CFArrayCreate(allocator, 0, 0, v13);
}

uint64_t CFHTTPCookieCreateWithProperties(uint64_t a1, uint64_t a2)
{
  CFTypeRef v3 = [NSHTTPCookie alloc];

  return (uint64_t)[(NSHTTPCookie *)v3 _initWithProperties:a2 fromString:0];
}

BOOL CFHTTPCookie_domainMatches(OpaqueCFHTTPCookie *a1, const __CFURL *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  uint64_t v4 = [(OpaqueCFHTTPCookie *)a1 _inner];
  CFTypeRef v5 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  if (*v5 < 0x14) {
    return 0;
  }
  uint64_t v6 = v5[4];
  if (!v6) {
    return 0;
  }
  uint64_t v7 = *v5;
  if (v7 <= v6) {
    return 0;
  }
  uint64_t v8 = (char *)v5 + v6;
  CFArrayRef v9 = (char *)v5 + v7;
  CFArrayRef v10 = v8;
  while (*v10)
  {
    if (++v10 >= v9) {
      return 0;
    }
  }
  size_t v12 = strlen(v8);
  if (!v12) {
    return 0;
  }
  size_t v13 = v12;
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id v31 = off_1ECF9A530;
  CFStringRef v15 = CFStringCreateWithCString(v14, v8, 0x8000100u);
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  long long v32 = (__CFString *)v15;
  uint64_t Length = CFStringGetLength(v15);
  if (CFStringCompare(@".^filecookies^", v15, 0))
  {
    if (!looksLikeDomainName(__CFString const*)::allowedSymbolsSet) {
      looksLikeDomainName(__CFString const*)::allowedSymbolsSet = (uint64_t)CFCharacterSetCreateWithCharactersInString(0, @"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-_[]:");
    }
    if (Length >= 1)
    {
      CFIndex v17 = 0;
      CFIndex v18 = 0;
      while (1)
      {
        v30.CFIndex location = 0;
        v30.CFIndex length = 0;
        v37.CFIndex location = v17;
        v37.CFIndex length = Length;
        int CharacterFromSet = CFStringFindCharacterFromSet(v15, (CFCharacterSetRef)looksLikeDomainName(__CFString const*)::allowedSymbolsSet, v37, 0, &v30);
        if (Length != 1 && !CharacterFromSet) {
          break;
        }
        if (v30.location > v17 + 2) {
          break;
        }
        if (v30.location == v17 + 2)
        {
          v38.CFIndex location = v17;
          v38.CFIndex length = 2;
          if (CFStringCompareWithOptions(v15, @"--", v38, 0)) {
            break;
          }
          v17 += 3;
          uint64_t v20 = -3;
        }
        else if (v30.location == v17)
        {
          if (v18 == v17 && CFStringGetCharacterAtIndex(v15, v17) == 45) {
            break;
          }
          ++v17;
          uint64_t v20 = -1;
        }
        else
        {
          if (CFStringGetCharacterAtIndex(v15, v17) != 46 || v17 && CFStringGetCharacterAtIndex(v15, v17 - 1) == 45) {
            break;
          }
          CFIndex v18 = v17 + 1;
          uint64_t v20 = -2;
          v17 += 2;
        }
        BOOL v21 = __OFADD__(v20, Length);
        Length += v20;
        if ((Length < 0) ^ v21 | (Length == 0)) {
          goto LABEL_32;
        }
      }
      AutoString::~AutoString((AutoString *)&v31);
      return 0;
    }
  }
LABEL_32:
  AutoString::~AutoString((AutoString *)&v31);
  CFGetAllocator(a1);
  CookieHostName::CookieHostName((CookieHostName *)&v31, a2, v22);
  if (v33) {
    uint64_t v24 = (CookieUtils *)((char *)&v32->isa + 1);
  }
  else {
    uint64_t v24 = 0;
  }
  if (CookieUtils::looksLikeIPAddress(v24, v23))
  {
    int v26 = strcmp(v8, (const char *)&v32->isa + 1);
  }
  else
  {
    if (*v8 == 46)
    {
      if (v33) {
        uint64_t v28 = (CookieUtils *)v32;
      }
      else {
        uint64_t v28 = 0;
      }
      BOOL v11 = CookieUtils::web_domainMatches_LCC_LCC(v28, v8, v25);
      goto LABEL_50;
    }
    if (v33) {
      uint64_t v29 = (char *)&v32->isa + 1;
    }
    else {
      uint64_t v29 = 0;
    }
    int v26 = strncmp(v29, v8, v13 - (v8[v13] == 46));
  }
  BOOL v11 = v26 == 0;
LABEL_50:
  id v31 = (void (**)(AutoString *__hidden))&unk_1ECF9C868;
  if (v35 != &v34) {
    free(v35);
  }
  return v11;
}

void sub_1841BCDEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t *a46)
{
  if (a46 != &a14) {
    free(a46);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CFHTTPCookieCopyProperties(void *a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)[a1 _inner] + 40);

  return v1();
}

uint64_t CFHTTPCookieIsHTTPOnly(void *a1)
{
  uint64_t v1 = [a1 _inner];
  uint64_t v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
  if (*v2 >= 0xCu) {
    return (v2[2] >> 2) & 1;
  }
  else {
    return 0;
  }
}

uint64_t CFHTTPCookieGetFlags(void *a1)
{
  uint64_t v1 = [a1 _inner];
  uint64_t v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
  if (*v2 >= 0xCu) {
    return v2[2] & 0x7F;
  }
  else {
    return 0;
  }
}

uint64_t CFHTTPCookieIsSecure(void *a1)
{
  uint64_t v1 = [a1 _inner];
  uint64_t v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
  if (*v2 >= 0xCu) {
    return v2[2] & 1;
  }
  else {
    return 0;
  }
}

double CFHTTPCookieGetExpirationTime(void *a1)
{
  if (CFHTTPCookieGetExpirationTime::sOnce != -1) {
    dispatch_once(&CFHTTPCookieGetExpirationTime::sOnce, &__block_literal_global_22_2577);
  }
  uint64_t v2 = [a1 _inner];
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
  if (*(_DWORD *)v3 >= 0xCu && (*(_DWORD *)(v3 + 8) & 2) != 0 || *(_DWORD *)v3 < 0x30u) {
    return 0.0;
  }
  else {
    return floor(*(double *)(v3 + 40));
  }
}

uint64_t __CFHTTPCookieGetExpirationTime_block_invoke()
{
  return CFLog();
}

void CookieHostName::~CookieHostName(CookieHostName *this)
{
  *(void *)this = &unk_1ECF9C868;
  uint64_t v2 = (char *)*((void *)this + 35);
  if (v2 != (char *)this + 24) {
    free(v2);
  }

  JUMPOUT(0x18531B6D0);
}

{
  char *v2;

  *(void *)this = &unk_1ECF9C868;
  uint64_t v2 = (char *)*((void *)this + 35);
  if (v2 != (char *)this + 24) {
    free(v2);
  }
}

BOOL CookieUtils::web_domainMatches_LCC_LCC(CookieUtils *this, const char *a2, const unsigned __int8 *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex v17 = off_1ECF9A530;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  CFStringRef theString1 = CFStringCreateWithCString(v4, (const char *)this, 0x8000100u);
  v16[0] = off_1ECF9A530;
  CFStringRef v5 = CFStringCreateWithCString(v4, a2, 0x8000100u);
  void v16[2] = 0;
  v16[3] = 0;
  v16[1] = v5;
  if (CFEqual(theString1, v5)) {
    goto LABEL_17;
  }
  if (CFStringHasSuffix(theString1, @"."))
  {
    MutableCFStringRef Copy = (__CFString *)CFRetain(theString1);
  }
  else
  {
    CFAllocatorRef v7 = CFGetAllocator(theString1);
    CFIndex Length = CFStringGetLength(theString1);
    MutableCFStringRef Copy = CFStringCreateMutableCopy(v7, Length + 1, theString1);
    CFStringAppend(MutableCopy, @".");
  }
  if (CFStringHasSuffix(v5, @"."))
  {
    if (v5) {
      CFArrayRef v9 = (__CFString *)CFRetain(v5);
    }
    else {
      CFArrayRef v9 = 0;
    }
  }
  else
  {
    CFAllocatorRef v10 = CFGetAllocator(v5);
    CFIndex v11 = CFStringGetLength(v5);
    CFArrayRef v9 = CFStringCreateMutableCopy(v10, v11 + 1, v5);
    CFStringAppend(v9, @".");
  }
  CFComparisonResult v12 = CFStringCompare(MutableCopy, v9, 0);
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v12)
  {
    if (CFStringGetCharacterAtIndex(theString1, 0) == 46)
    {
      CFStringRef v13 = (const __CFString *)CFRetain(theString1);
    }
    else
    {
      AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)v21, 0, @".%@", theString1);
      if (v22) {
        CFStringRef v13 = (const __CFString *)CFRetain(v22);
      }
      else {
        CFStringRef v13 = 0;
      }
      AutoString::~AutoString((AutoString *)v21);
    }
    if (CFStringHasSuffix(v13, v5))
    {
      BOOL v14 = !isTopLevelDomain(v5, 1);
      if (!v13) {
        goto LABEL_27;
      }
      goto LABEL_26;
    }
    BOOL v14 = 0;
    if (v13) {
LABEL_26:
    }
      CFRelease(v13);
  }
  else
  {
LABEL_17:
    BOOL v14 = 1;
  }
LABEL_27:
  AutoString::~AutoString((AutoString *)v16);
  AutoString::~AutoString((AutoString *)&v17);
  return v14;
}

void sub_1841BD3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  AutoString::~AutoString((AutoString *)(v30 - 208));
  AutoString::~AutoString((AutoString *)&a11);
  AutoString::~AutoString((AutoString *)&a30);
  _Unwind_Resume(a1);
}

uint64_t _cookiePathDomainAndNameComparator(void *a1, void *a2, void *a3)
{
  uint64_t v4 = objc_msgSend(a1, "_inner", a3);
  uint64_t v5 = [a2 _inner];
  uint64_t v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  if (*v6 >= 0x1C && (v7 = v6[6], v7) && (uint64_t v8 = *v6, v8 > v7))
  {
    unint64_t v9 = (unint64_t)v6 + v7;
    CFAllocatorRef v10 = (char *)v6 + v8;
    CFIndex v11 = (unsigned char *)v9;
    while (*v11)
    {
      if (++v11 >= v10) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    unint64_t v9 = 0;
  }
  CFComparisonResult v12 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  if (*v12 >= 0x1C && (uint64_t v13 = v12[6], v13) && (v14 = *v12, v14 > v13))
  {
    unint64_t v15 = (unint64_t)v12 + v13;
    long long v16 = (char *)v12 + v14;
    CFIndex v17 = (unsigned char *)v15;
    while (*v17)
    {
      if (++v17 >= v16) {
        goto LABEL_14;
      }
    }
  }
  else
  {
LABEL_14:
    unint64_t v15 = 0;
  }
  if (v9)
  {
    int64_t v18 = strlen((const char *)v9);
    if (v15)
    {
LABEL_17:
      int64_t v19 = strlen((const char *)v15);
      goto LABEL_20;
    }
  }
  else
  {
    int64_t v18 = 0;
    if (v15) {
      goto LABEL_17;
    }
  }
  int64_t v19 = 0;
LABEL_20:
  if (v18 != v19)
  {
    if (v18 > v19) {
      return -1;
    }
    else {
      return 1;
    }
  }
  if (v9 | v15)
  {
    if (!v9 && v15) {
      return 1;
    }
    if (v9 && !v15) {
      return -1;
    }
    int v45 = strcmp((const char *)v9, (const char *)v15);
    if (v45 < 0) {
      return -1;
    }
    if (v45) {
      return 1;
    }
  }
  uint64_t v20 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  if (*v20 >= 0x14 && (uint64_t v21 = v20[4], v21) && (v22 = *v20, v22 > v21))
  {
    unint64_t v23 = (unint64_t)v20 + v21;
    uint64_t v24 = (char *)v20 + v22;
    uint64_t v25 = (unsigned char *)v23;
    while (*v25)
    {
      if (++v25 >= v24) {
        goto LABEL_28;
      }
    }
  }
  else
  {
LABEL_28:
    unint64_t v23 = 0;
  }
  int v26 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  if (*v26 >= 0x14 && (uint64_t v27 = v26[4], v27) && (v28 = *v26, v28 > v27))
  {
    unint64_t v29 = (unint64_t)v26 + v27;
    uint64_t v30 = (char *)v26 + v28;
    id v31 = (unsigned char *)v29;
    while (*v31)
    {
      if (++v31 >= v30) {
        goto LABEL_35;
      }
    }
  }
  else
  {
LABEL_35:
    unint64_t v29 = 0;
  }
  if (!(v23 | v29)) {
    goto LABEL_37;
  }
  if (!v23 && v29) {
    return 1;
  }
  if (v23 && !v29) {
    return -1;
  }
  int v46 = strcmp((const char *)v23, (const char *)v29);
  if (v46 < 0) {
    return -1;
  }
  if (v46) {
    return 1;
  }
LABEL_37:
  long long v32 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  if (*v32 >= 0x18 && (uint64_t v33 = v32[5], v33) && (v34 = *v32, v34 > v33))
  {
    unint64_t v35 = (unint64_t)v32 + v33;
    uint64_t v36 = (char *)v32 + v34;
    CFRange v37 = (unsigned char *)v35;
    while (*v37)
    {
      if (++v37 >= v36) {
        goto LABEL_43;
      }
    }
  }
  else
  {
LABEL_43:
    unint64_t v35 = 0;
  }
  CFRange v38 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  if (*v38 >= 0x18 && (v39 = v38[5], v39) && (uint64_t v40 = *v38, v40 > v39))
  {
    unint64_t v41 = (unint64_t)v38 + v39;
    uint64_t v42 = (char *)v38 + v40;
    int64_t v43 = (unsigned char *)v41;
    while (*v43)
    {
      if (++v43 >= v42) {
        goto LABEL_50;
      }
    }
  }
  else
  {
LABEL_50:
    unint64_t v41 = 0;
  }
  if (!(v35 | v41)) {
    return 0;
  }
  if (!v35 && v41) {
    return 1;
  }
  if (v35 && !v41) {
    return -1;
  }
  int v47 = strcmp((const char *)v35, (const char *)v41);
  if (v47 < 0) {
    return -1;
  }
  else {
    return v47 != 0;
  }
}

uint64_t formUnschedule(__CFReadStream *a1, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode, void *a4)
{
  uint64_t v7 = (__CFReadStream *)a4[2];
  if (v7) {
    CFReadStreamUnscheduleFromRunLoop(v7, runLoop, runLoopMode);
  }
  uint64_t result = (*(uint64_t (**)(void, CFRunLoopRef, CFRunLoopMode))(*(void *)*a4 + 64))(*a4, runLoop, runLoopMode);
  *a4 = result;
  return result;
}

uint64_t formSetProperty(__CFReadStream *a1, CFTypeRef cf1, const __CFNumber *a3, void *a4)
{
  uint64_t result = CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E4F1D448]);
  if (result)
  {
    uint64_t valuePtr = 0;
    CFNumberGetValue(a3, kCFNumberSInt64Type, &valuePtr);
    a4[6] = valuePtr;
    return 1;
  }
  return result;
}

CFStringRef formCopyProperty(__CFReadStream *a1, CFTypeRef cf1, void *a3)
{
  if (!CFEqual(cf1, &unk_1EC0A20E0)) {
    return 0;
  }
  CFAllocatorRef v5 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v5, 0, @"%lld", a3[5]);
}

void ___ZN12__CFURLCacheD2Ev_block_invoke(uint64_t a1)
{
}

CFStringRef _CFURLCacheCopyDescription(const void *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFURLCache %p [%p]>", a1, v3);
}

uint64_t _CFURLCacheHash(void *a1)
{
  return *(void *)(a1[2] + 208);
}

BOOL _CFURLCacheEqual(void *a1, void *a2)
{
  return a1[2] == a2[2];
}

CFStringRef _CFCachedURLResponseCopyDescription(const void *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFCachedURLResponse %p [%p]>", a1, v3);
}

uint64_t _CFCachedURLResponseHash(void *a1)
{
  return *(void *)(a1[2] + 64);
}

BOOL _CFCachedURLResponseEqual(void *a1, void *a2)
{
  return a1[2] == a2[2];
}

void ___ZN12__CFURLCache13logCacheEventE19CFURLCacheEventTypePK13_CFURLRequest_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 32);
  if (v2) {
    (*(void (**)(uint64_t, void, void, void, void))(v2 + 16))(v2, *(unsigned int *)(a1 + 56), *(void *)(a1 + 40), *(void *)(a1 + 48), 0);
  }
  CFAllocatorRef v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4)
  {
    CFRelease(v4);
  }
}

void ___ZN21__CFCachedURLResponse10GetRequestEv_block_invoke(uint64_t a1)
{
}

void std::__split_buffer<__CFURLCacheNode **>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v11);
      CFAllocatorRef v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      unint64_t v15 = *(uint64_t **)(a1 + 8);
      long long v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        long long v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        int64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)int64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        CFAllocatorRef v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      CFAllocatorRef v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    CFAllocatorRef v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void __CFURLCache::_createVaryStateTable(sqlite3 **this)
{
  uint64_t v2 = 0;
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  errmsg = 0;
  do
  {
    if (sqlite3_exec(this[78], off_1E52530F0[v2], 0, 0, &errmsg))
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      CFAllocatorRef v3 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136315138;
        uint64_t v6 = errmsg;
        _os_log_impl(&dword_184085000, v3, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
      }
      sqlite3_free(errmsg);
    }
    ++v2;
  }
  while (v2 != 5);
}

void std::__shared_ptr_emplace<__CFURLCache>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6678;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<__CFURLCache>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6678;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t CFURLCacheCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, const __CFString *a4)
{
  return __CFURLCacheCreateInternal(a1, a2, a3, a4, 0, 0, 0);
}

uint64_t CFURLCacheCopySharedURLCache()
{
  pthread_mutex_lock(&gSharedInstanceLock);
  Internal = (const void *)gSharedInstance;
  if (!gSharedInstance)
  {
    Internal = (const void *)__CFURLCacheCreateInternal((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 0x400000, 20971520, 0, 0, 0, 0);
    gShareduint64_t Instance = (uint64_t)Internal;
  }
  CFRetain(Internal);
  uint64_t v1 = gSharedInstance;
  pthread_mutex_unlock(&gSharedInstanceLock);
  return v1;
}

uint64_t __CFURLCacheVaryStateForURL(void *a1, __CFString *a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t TypeID = CFURLCacheGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    CFAllocatorRef v5 = (__CFURLCache *)a1[2];
    return __CFURLCache::_varyStateForURL(v5, a2);
  }
  if ((objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }

  return [a1 performSelector:sel__varyStateForURL_ withObject:a2];
}

uint64_t __CFURLCache::_varyStateForURL(__CFURLCache *this, __CFString *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!*((void *)this + 78)) {
    return 0;
  }
  std::string::basic_string[abi:nn180100]<0>(&v11, "SELECT * from cfurl_vary_state where request_key=\"");
  std::string::append(&v11, (const std::string::value_type *)[(__CFString *)a2 UTF8String]);
  std::string::append(&v11, "\"");
  errmsg = 0;
  __retainStorageAssertion(*((void **)this + 17));
  uint64_t v9 = 0;
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v4 = &v11;
  }
  else {
    uint64_t v4 = (std::string *)v11.__r_.__value_.__r.__words[0];
  }
  if (sqlite3_exec(*((sqlite3 **)this + 78), (const char *)v4, (int (__cdecl *)(void *, int, char **, char **))select_callback, &v9, &errmsg))
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136315138;
      uint64_t v13 = errmsg;
      _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
    }
    sqlite3_free(errmsg);
  }
  __releaseStorageAssertion(v5);
  uint64_t v7 = v9;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  return v7;
}

void sub_1841BE254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t select_callback(void *a1, int a2, char **a3, char **a4)
{
  if (a2 >= 1)
  {
    uint64_t v18 = v4;
    uint64_t v19 = v5;
    uint64_t v9 = 0;
    uint64_t v10 = a2;
    do
    {
      std::string::basic_string[abi:nn180100]<0>(&v15, a4[v9]);
      if (v17 < 0)
      {
        if (v16 == 10)
        {
          BOOL v13 = *(void *)v15 != 0x6174735F79726176 || v15[4] != 25972;
          operator delete(v15);
          if (!v13)
          {
LABEL_23:
            *a1 = [NSString stringWithUTF8String:a3[v9]];
            return 0;
          }
        }
        else
        {
          operator delete(v15);
        }
      }
      else if (v17 == 10 && v15 == (_WORD *)0x6174735F79726176 && (unsigned __int16)v16 == 25972)
      {
        goto LABEL_23;
      }
      ++v9;
    }
    while (v10 != v9);
  }
  return 0;
}

void ___ZN21__CFCachedURLResponse22SetNSCachedURLResponseEPKv_block_invoke(uint64_t a1)
{
}

void __CFURLCache::_updateVaryStateForURL(__CFURLCache *this, __CFString *a2, __CFString *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 78) && *((void *)this + 22))
  {
    errmsg = 0;
    __retainStorageAssertion(*((void **)this + 17));
    std::string::basic_string[abi:nn180100]<0>(&__p, "INSERT OR REPLACE INTO cfurl_vary_state(request_key, vary_state) VALUES ('");
    std::string::append(&__p, (const std::string::value_type *)[(__CFString *)a3 UTF8String]);
    std::string::append(&__p, "', '");
    std::string::append(&__p, (const std::string::value_type *)[(__CFString *)a2 UTF8String]);
    std::string::append(&__p, "');");
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (sqlite3_exec(*((sqlite3 **)this + 78), (const char *)p_p, 0, 0, &errmsg))
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v8 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136315138;
        uint64_t v12 = errmsg;
        _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
      }
      sqlite3_free(errmsg);
    }
    __releaseStorageAssertion(v7);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1841BE520(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t ___ZL50__CFURLCacheAddCachedResponseForRequestWithSessionPK11_CFURLCacheP12NSURLSessionPK20_CFCachedURLResponsePK13_CFURLRequestPKv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 752;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN12__CFURLCache20PurgePersistentCacheEv_block_invoke(uint64_t a1)
{
  __retainStorageAssertion(*(void **)(a1 + 32));
  CFAllocatorRef v3 = *(os_unfair_lock_s **)(a1 + 40);
  if (v3)
  {
    os_unfair_lock_lock(v3 + 7);
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    uint64_t v19 = __44__NSURLStorageURLCacheDB_deleteAllResponses__block_invoke;
    uint64_t v20 = &unk_1E5258228;
    uint64_t v21 = v3;
    uint64_t v5 = [(NSURLStorageURLCacheDB *)v3 openReadWriteConnection];
    uint64_t v6 = v5;
    if (v5)
    {
      v13[0] = MEMORY[0x1E4F143A8];
      v13[1] = 3221225472;
      uint64_t v14 = __44__NSURLStorageURLCacheDB_deleteAllResponses__block_invoke_2;
      unint64_t v15 = &unk_1E5258250;
      uint64_t v16 = v3;
      char v17 = v5;
      int v12 = 141;
      if (sqlite3_file_control(v5, 0, 101, &v12))
      {
        id v8 = objc_getProperty(v3, v7, 168, 1);
        uint64_t v9 = sqlite3_errmsg(v6);
        uint64_t v10 = sqlite3_errcode(v6);
        NSLog(&cfstr_ErrorNsurlstor_15.isa, v6, v8, v9, v10);

        v14((uint64_t)v13);
        v19((uint64_t)v18);
        goto LABEL_7;
      }
      v14((uint64_t)v13);
    }
    v19((uint64_t)v18);
    [(NSURLStorageURLCacheDB *)(uint64_t)v3 updateToCurrentSchema];
  }
LABEL_7:

  __releaseStorageAssertion(v2);
}

void sub_1841BE74C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void (*a16)(char *), uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,void (*a22)(char *))
{
}

void ___ZN12__CFURLCache30removeCachedResponsesSinceDateEPK8__CFDate_block_invoke(uint64_t a1)
{
  __retainStorageAssertion(*(void **)(a1 + 32));
  double v2 = *(os_unfair_lock_s **)(a1 + 40);
  id v4 = *(id *)(a1 + 48);
  if (v2)
  {
    BOOL v44 = 0;
    uint64_t v5 = [(NSURLStorageURLCacheDB *)v2 openReadWriteConnection];
    CFStringRef v6 = [v4 description];
    double v7 = (__CFString *)v6;
    if (v6) {
      id v8 = _ExtractCStringfromCFStringRef(v6, &v44);
    }
    else {
      id v8 = 0;
    }
    errmsg = 0;
    uint64_t v9 = sqlite3_mprintf("SELECT receiver_data from cfurl_cache_receiver_data WHERE isDataOnFS > 0 AND entry_ID in (SELECT entry_ID FROM cfurl_cache_response WHERE time_stamp >= \"%s\")", v8);
    if (sqlite3_exec(v5, v9, (int (__cdecl *)(void *, int, char **, char **))SQLdeleteSinceDateCallback, v2, &errmsg)
      && errmsg)
    {
      objc_getProperty(v2, v10, 168, 1);
      CFLog();
      sqlite3_free(errmsg);
    }
    sqlite3_free(v9);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:](v2, "BEGIN IMMEDIATE;",
                         v5,
                         0))
    {
      id v12 = objc_getProperty(v2, v11, 168, 1);
      uint64_t v13 = sqlite3_errmsg(v5);
      uint64_t v14 = sqlite3_errcode(v5);
      NSLog(&cfstr_ErrorNsurlstor_10.isa, v5, v12, v13, v14);
    }
    unint64_t v15 = sqlite3_mprintf("DELETE from cfurl_cache_receiver_data WHERE entry_ID in (SELECT entry_ID FROM cfurl_cache_response WHERE time_stamp >= \"%s\")", v8);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:](v2, v15, v5, 0))
    {
      id v17 = objc_getProperty(v2, v16, 168, 1);
      uint64_t v18 = sqlite3_errmsg(v5);
      uint64_t v19 = sqlite3_errcode(v5);
      NSLog(&cfstr_ErrorNsurlstor_11.isa, v5, v17, v18, v19);
    }
    sqlite3_free(v15);
    uint64_t v20 = sqlite3_mprintf("DELETE from cfurl_cache_blob_data WHERE entry_ID in (SELECT entry_ID FROM cfurl_cache_response WHERE time_stamp >= \"%s\")", v8);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:](v2, v20, v5, 0))
    {
      id v22 = objc_getProperty(v2, v21, 168, 1);
      unint64_t v23 = sqlite3_errmsg(v5);
      uint64_t v24 = sqlite3_errcode(v5);
      NSLog(&cfstr_ErrorNsurlstor_11.isa, v5, v22, v23, v24);
    }
    sqlite3_free(v20);
    uint64_t v25 = sqlite3_mprintf("DELETE from cfurl_cache_response WHERE time_stamp >= \"%s\"", v8);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:](v2, v25, v5, 0))
    {
      id v27 = objc_getProperty(v2, v26, 168, 1);
      uint64_t v28 = sqlite3_errmsg(v5);
      uint64_t v29 = sqlite3_errcode(v5);
      NSLog(&cfstr_ErrorNsurlstor_11.isa, v5, v27, v28, v29);
    }
    sqlite3_free(v25);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:](v2, "COMMIT;",
                         v5,
                         0))
    {
      id v31 = objc_getProperty(v2, v30, 168, 1);
      long long v32 = sqlite3_errmsg(v5);
      uint64_t v33 = sqlite3_errcode(v5);
      NSLog(&cfstr_ErrorNsurlstor_12.isa, v5, v31, v32, v33);
    }
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:](v2, "PRAGMA incremental_vacuum(500);",
                         v5,
                         0))
    {
      id v35 = objc_getProperty(v2, v34, 168, 1);
      uint64_t v36 = sqlite3_errmsg(v5);
      uint64_t v37 = sqlite3_errcode(v5);
      NSLog(&cfstr_ErrorNsurlstor_13.isa, v5, v35, v36, v37);
    }
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:](v2, "PRAGMA wal_checkpoint;",
                         v5,
                         0))
    {
      id v39 = objc_getProperty(v2, v38, 168, 1);
      uint64_t v40 = sqlite3_errmsg(v5);
      uint64_t v41 = sqlite3_errcode(v5);
      NSLog(&cfstr_ErrorNsurlstor_14.isa, v5, v39, v40, v41);
    }
    if (v8 && v44) {
      MEMORY[0x18531B6B0](v8, 0x1000C8077774924);
    }
    if (v5) {
      sqlite3_close(v5);
    }
  }

  __releaseStorageAssertion(v42);
}

void sub_1841BEBD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *_CFURLCacheSetMemoryLimit(void *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v5 = result;
    uint64_t TypeID = CFURLCacheGetTypeID();
    uint64_t result = (void *)CFGetTypeID(v5);
    if ((void *)TypeID == result)
    {
      uint64_t v7 = v5[2];
      *(void *)(v7 + 168) = a2;
      if (a3 < 1 || a3 >= a2)
      {
        double v8 = *(double *)(v7 + 200);
        a3 = (uint64_t)(v8 * (double)a2);
        *(void *)(v7 + 192) = (uint64_t)(v8 * (double)*(uint64_t *)(v7 + 176));
      }
      *(void *)(v7 + 184) = a3;
    }
    else
    {
      uint64_t v9 = (const char *)_CFURLCacheSetMemoryLimit::s;
      if (!_CFURLCacheSetMemoryLimit::s)
      {
        uint64_t v9 = sel_registerName("_nscfBridgeURLCacheSetMemoryCapacity:");
        _CFURLCacheSetMemoryLimit::s = (uint64_t)v9;
      }
      return objc_msgSend(v5, v9, a2);
    }
  }
  return result;
}

void _CFURLCacheSetCacheEventCallBackBlock(uint64_t a1, void *aBlock, dispatch_object_t object)
{
  uint64_t v5 = *(void *)(a1 + 16);
  CFStringRef v6 = *(const void **)(v5 + 32);
  if (v6 != aBlock)
  {
    if (v6)
    {
      _Block_release(v6);
      uint64_t v5 = *(void *)(a1 + 16);
      *(void *)(v5 + 32) = 0;
    }
    if (aBlock)
    {
      double v8 = _Block_copy(aBlock);
      uint64_t v5 = *(void *)(a1 + 16);
      *(void *)(v5 + 32) = v8;
    }
  }
  uint64_t v9 = *(NSObject **)(v5 + 24);
  if (v9 != object)
  {
    if (v9)
    {
      dispatch_release(v9);
      uint64_t v5 = *(void *)(a1 + 16);
      *(void *)(v5 + 24) = 0;
    }
    if (object)
    {
      *(void *)(v5 + 24) = object;
      dispatch_retain(object);
    }
  }
}

void _CFCachedURLResponseSetBecameFileBackedCallBackBlock(void *a1, const void *a2, NSObject *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = CFURLCacheCopySharedURLCache();
  if (!v6 || (uint64_t v7 = (const void *)v6, TypeID = CFURLCacheGetTypeID(), v9 = CFGetTypeID(v7), CFRelease(v7), TypeID == v9))
  {
    uint64_t v10 = a1[2];
    std::string v11 = *(const void **)(v10 + 16);
    if (v11 != a2)
    {
      if (v11)
      {
        _Block_release(v11);
        uint64_t v10 = a1[2];
        *(void *)(v10 + 16) = 0;
      }
      if (a2)
      {
        id v12 = _Block_copy(a2);
        uint64_t v10 = a1[2];
        *(void *)(v10 + 16) = v12;
      }
    }
    uint64_t v13 = *(NSObject **)(v10 + 8);
    if (v13 == a3) {
      goto LABEL_28;
    }
    if (v13)
    {
      dispatch_release(v13);
      uint64_t v10 = a1[2];
      *(void *)(v10 + 8) = 0;
    }
    if (!a3 || (*(void *)(v10 + 8) = a3, dispatch_retain(a3), (uint64_t v10 = a1[2]) != 0))
    {
LABEL_28:
      if (*(void *)(v10 + 16) && *(void *)(v10 + 8))
      {
        uint64_t v14 = (os_unfair_lock_s *)(v10 + 88);
        os_unfair_lock_lock((os_unfair_lock_t)(v10 + 88));
        *(void *)&long long buf = MEMORY[0x1E4F143A8];
        *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3221225472;
        uint64_t v25 = (uint64_t)___ZN21__CFCachedURLResponse6GetKeyEv_block_invoke;
        CFTypeRef v26 = &__block_descriptor_40_e5_v8__0l;
        uint64_t v27 = v10;
        unint64_t v15 = *(const void **)(v10 + 128);
        os_unfair_lock_unlock(v14);
        if (v15)
        {
          uint64_t v16 = CFURLCacheCopySharedURLCache();
          if (v16)
          {
            id v17 = (void *)v16;
            uint64_t v18 = *(void *)(v16 + 16);
            if (v18)
            {
              pthread_mutex_lock((pthread_mutex_t *)(v18 + 456));
              uint64_t v19 = v17[2];
              uint64_t v20 = *(__CFDictionary **)(v19 + 520);
              if (v20)
              {
                CFDictionaryAddValue(v20, v15, a1);
                *(void *)&long long buf = 0;
                *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &buf;
                uint64_t v25 = 0x2020000000;
                CFTypeRef v26 = 0;
                CFTypeRef v26 = CFRetain(v15);
                dispatch_time_t v21 = dispatch_time(0, 10000000000);
                block[0] = MEMORY[0x1E4F143A8];
                block[1] = 3221225472;
                block[2] = ___CFCachedURLResponseSetBecameFileBackedCallBackBlock_block_invoke;
                block[3] = &unk_1E5257868;
                block[4] = &buf;
                dispatch_after(v21, a3, block);
                _Block_object_dispose(&buf, 8);
                uint64_t v19 = v17[2];
              }
              pthread_mutex_unlock((pthread_mutex_t *)(v19 + 456));
            }
            CFRelease(v17);
          }
        }
        else
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          id v22 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 134217984;
            *(void *)((char *)&buf + 4) = a1;
            _os_log_error_impl(&dword_184085000, v22, OS_LOG_TYPE_ERROR, "VM: ADD attempt FAILED for cached response %p. No key found.", (uint8_t *)&buf, 0xCu);
          }
        }
      }
    }
  }
}

void ___ZN21__CFCachedURLResponse6GetKeyEv_block_invoke(uint64_t a1)
{
}

const void *_CFCachedURLResponseGetMemMappedData(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (*(unsigned char *)(v1 + 120) && (CFArrayRef v2 = *(const __CFArray **)(v1 + 80)) != 0) {
    return CFArrayGetValueAtIndex(v2, 0);
  }
  else {
    return 0;
  }
}

void *CFURLCacheCurrentMemoryUsage(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(v1))
    {
      return *(void **)(v1[2] + 144);
    }
    else
    {
      CFAllocatorRef v3 = (const char *)CFURLCacheCurrentMemoryUsage(_CFURLCache const*)::s;
      if (!CFURLCacheCurrentMemoryUsage(_CFURLCache const*)::s)
      {
        CFAllocatorRef v3 = sel_registerName("_nscfBridgeURLCacheCurrentMemoryUsage");
        CFURLCacheCurrentMemoryUsage(_CFURLCache const*)::s = (uint64_t)v3;
      }
      return [v1 v3];
    }
  }
  return result;
}

uint64_t CFCachedURLResponseCreateWithData()
{
  v1[5] = *MEMORY[0x1E4F143B8];
  v1[0] = MEMORY[0x1E4F143A8];
  v1[1] = 3221225472;
  v1[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2699;
  v1[3] = &__block_descriptor_40_e5_v8__0l;
  void v1[4] = _CachedURLResponseRegisterClass;
  if (_CFCachedURLResponseClassRegistration != -1) {
    dispatch_once(&_CFCachedURLResponseClassRegistration, v1);
  }
  if (_CFRuntimeCreateInstance()) {
    operator new();
  }
  return 0;
}

void sub_1841BF384(_Unwind_Exception *exception_object)
{
}

uint64_t CFCachedURLResponseGetWrappedResponse(uint64_t result)
{
  if (result) {
    return *(void *)(*(void *)(result + 16) + 32);
  }
  return result;
}

__CFData *CFCachedURLResponseGetReceiverData(__CFData *result)
{
  if (result) {
    return __CFCachedURLResponse::GetReceiverData(*((__CFCachedURLResponse **)result + 2));
  }
  return result;
}

uint64_t CFCachedURLResponseGetStoragePolicy(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(*(void *)(a1 + 16) + 56);
  }
  else {
    return 2;
  }
}

uint64_t CFCachedURLResponseSetStoragePolicy(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(*(void *)(result + 16) + 56) = a2;
  }
  return result;
}

void ___ZN12__CFURLCache6ShrinkEP22NSURLStorageURLCacheDB_block_invoke(void *a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  CFArrayRef v2 = (__CFURLCache *)a1[5];
  __retainStorageAssertion(*(void **)(*(void *)(a1[6] + 16) + 136));
  uint64_t v5 = a1[4];
  if (v5)
  {
    buf[0] = 0;
    uint64_t v6 = [(NSURLStorageURLCacheDB *)(void *)v5 openReadWriteConnection];
    if (v6)
    {
      uint64_t v7 = v6;
      if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((os_unfair_lock_s *)v5, "BEGIN IMMEDIATE", v6, 0))
      {
        CFLog();
      }
      else
      {
        double v8 = sqlite3_mprintf("SELECT receiver_data, entry_ID from cfurl_cache_receiver_data WHERE isDataOnFS > 0 AND entry_ID in \t\t\t\t\t\t\t\t (SELECT entry_ID from cfurl_cache_response WHERE entry_ID > 0 ORDER BY time_stamp ASC LIMIT %d)", 1500);
        uint64_t v9 = sqlite3_exec(v7, v8, (int (__cdecl *)(void *, int, char **, char **))SQLHostForDeleteCallback, (void *)v5, 0);
        sqlite3_free(v8);
        if (v9)
        {
          uint64_t v31 = v9;
          CFLog();
        }
        objc_msgSend(*(id *)(v5 + 136), "componentsJoinedByString:", @",", v31);
        CFStringRef v10 = (const __CFString *)objc_claimAutoreleasedReturnValue();
        std::string v11 = (__CFString *)v10;
        if (v10)
        {
          CStringfromCFStringRef = _ExtractCStringfromCFStringRef(v10, (BOOL *)buf);
          uint64_t v13 = CStringfromCFStringRef;
          if (CStringfromCFStringRef)
          {
            uint64_t v14 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_blob_data", CStringfromCFStringRef);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((os_unfair_lock_s *)v5, v14, v7, 0);
            sqlite3_free(v14);
            unint64_t v15 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_receiver_data", v13);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((os_unfair_lock_s *)v5, v15, v7, 0);
            sqlite3_free(v15);
            uint64_t v16 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_response", v13);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((os_unfair_lock_s *)v5, v16, v7, 0);
            sqlite3_free(v16);
            if (buf[0]) {
              MEMORY[0x18531B6B0](v13, 0x1000C8077774924);
            }
          }
        }
        [*(id *)(v5 + 136) removeAllObjects];
        id v17 = sqlite3_mprintf("SELECT entry_ID from cfurl_cache_receiver_data WHERE isDataOnFS < 1 AND entry_ID in \t\t\t\t\t\t\t\t (SELECT entry_ID from cfurl_cache_response WHERE entry_ID > 0 ORDER BY time_stamp ASC LIMIT %d)", 500);
        uint64_t v18 = sqlite3_exec(v7, v17, (int (__cdecl *)(void *, int, char **, char **))SQLHostForDeleteCallback, (void *)v5, 0);
        sqlite3_free(v17);
        if (v18)
        {
          uint64_t v32 = v18;
          CFLog();
        }
        objc_msgSend(*(id *)(v5 + 136), "componentsJoinedByString:", @",", v32);
        uint64_t v19 = (__CFString *)objc_claimAutoreleasedReturnValue();

        if (v19)
        {
          uint64_t v20 = _ExtractCStringfromCFStringRef(v19, (BOOL *)buf);
          dispatch_time_t v21 = v20;
          if (v20)
          {
            id v22 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_blob_data", v20);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((os_unfair_lock_s *)v5, v22, v7, 0);
            sqlite3_free(v22);
            unint64_t v23 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_receiver_data", v21);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((os_unfair_lock_s *)v5, v23, v7, 0);
            sqlite3_free(v23);
            uint64_t v24 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_response", v21);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((os_unfair_lock_s *)v5, v24, v7, 0);
            sqlite3_free(v24);
            if (buf[0]) {
              MEMORY[0x18531B6B0](v21, 0x1000C8077774924);
            }
          }
        }
        [*(id *)(v5 + 136) removeAllObjects];
        -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((os_unfair_lock_s *)v5, "COMMIT", v7, 0);
        -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]((os_unfair_lock_s *)v5, "PRAGMA incremental_vacuum(500);",
          v7,
          0);
      }
      sqlite3_close(v7);
    }
  }
  __releaseStorageAssertion(v4);
  CFTypeRef v26 = (void *)a1[4];
  if (v26)
  {
    [(NSURLStorageURLCacheDB *)(void *)a1[4] updateFSBackedCacheUsageOnDisk];
    -[NSURLStorageURLCacheDB updateSQLiteDBCacheUsageOnDisk](v26);
    unint64_t v27 = v26[25];
    unint64_t v28 = a1[4];
    if (v28) {
      unint64_t v28 = *(void *)(v28 + 176);
    }
    if (v27 > v28)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v29 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 134217984;
        unint64_t v34 = v27;
        _os_log_error_impl(&dword_184085000, v29, OS_LOG_TYPE_ERROR, "Cache storage usage (%lu) still exceeds limit after cache shrinking. Purging persistent cache.", buf, 0xCu);
      }
      __CFURLCache::PurgePersistentCache(v2);
    }
  }
  uint64_t v30 = (void *)a1[6];
  *(unsigned char *)(v30[2] + 12__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  CFRelease(v30);
}

void sub_1841BF8BC(_Unwind_Exception *exception_object)
{
}

void ___ZL39notifyCachedURLResponseBecameFileBackedPK20_CFCachedURLResponse_block_invoke(uint64_t a1)
{
  CFArrayRef v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(v2[2] + 16);
  if (!v3 || ((*(void (**)(void))(v3 + 16))(), (CFArrayRef v2 = *(void **)(a1 + 32)) != 0))
  {
    CFRelease(v2);
  }
}

uint64_t _CFURLCachePurgeMemoryCache(uint64_t a1)
{
  return __CFURLCache::PurgeMemoryCache(*(__CFURLCache **)(a1 + 16));
}

uint64_t _CFURLCacheGetSharedCache(void)
{
  return gSharedInstance;
}

void _CFURLCacheFlush(uint64_t a1, void *a2)
{
  if (IsCFURLCache(a1))
  {
    double v4 = *(NSObject **)(*(void *)(a1 + 16) + 136);
    dispatch_async(v4, a2);
  }
  else
  {
    CFURLCacheCurrentDiskUsage((__CFURLCache **)a1);
    uint64_t v5 = (void (*)(void *))a2[2];
    v5(a2);
  }
}

void non-virtual thunk to'HTTP2Connection::_onqueue_pingWithPongHandler(uint64_t a1, const void *a2)
{
}

void HTTP2Connection::_onqueue_pingWithPongHandler(uint64_t a1, const void *a2)
{
  if (!*(void *)(a1 + 160)) {
    return;
  }
  nghttp2_submit_ping();
  uint64_t v5 = _Block_copy(a2);
  unint64_t v6 = *(void *)(a1 + 664);
  unint64_t v7 = *(void *)(a1 + 680);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v2 = *(void *)(a1 + 664);
      if (v6 >= v7) {
        unint64_t v2 = v6 % v7;
      }
    }
    else
    {
      unint64_t v2 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void **)(*(void *)(a1 + 672) + 8 * v2);
    if (v9)
    {
      for (uint64_t i = (void *)*v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6) {
            goto LABEL_76;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v2) {
            break;
          }
        }
      }
    }
  }
  id v12 = operator new(0x28uLL);
  *id v12 = 0;
  v12[1] = v6;
  _DWORD v12[2] = v6;
  v12[3] = 0;
  v12[4] = v5;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 696) + 1);
  float v14 = *(float *)(a1 + 704);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *(void *)(a1 + 680);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_32;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 696) / *(float *)(a1 + 704));
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *(void *)(a1 + 680);
      }
      else
      {
        if (prime)
        {
LABEL_32:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v19 = operator new(8 * *(void *)&prime);
          uint64_t v20 = *(void **)(a1 + 672);
          *(void *)(a1 + 672) = v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          *(int8x8_t *)(a1 + 68_CFNetworkResetHSTSHostsSinceDate(0, 0) = prime;
          do
            *(void *)(*(void *)(a1 + 672) + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          id v22 = *(void **)(a1 + 688);
          if (v22)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)(a1 + 672) + 8 * v23) = a1 + 688;
            unint64_t v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  uint64_t v30 = *(void *)(a1 + 672);
                  if (!*(void *)(v30 + 8 * v29))
                  {
                    *(void *)(v30 + 8 * v29) = v22;
                    goto LABEL_57;
                  }
                  *id v22 = *v28;
                  *unint64_t v28 = **(void **)(*(void *)(a1 + 672) + 8 * v29);
                  **(void **)(*(void *)(a1 + 672) + 8 * v29) = v28;
                  unint64_t v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_57:
                id v22 = v28;
                unint64_t v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_61;
        }
        unint64_t v34 = *(void **)(a1 + 672);
        *(void *)(a1 + 672) = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        *(void *)(a1 + 68_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
      }
    }
LABEL_61:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v2 = v6 % v7;
      }
      else {
        unint64_t v2 = v6;
      }
    }
    else
    {
      unint64_t v2 = (v7 - 1) & v6;
    }
  }
  uint64_t v31 = *(void *)(a1 + 672);
  uint64_t v32 = *(void **)(v31 + 8 * v2);
  if (v32)
  {
    *id v12 = *v32;
  }
  else
  {
    *id v12 = *(void *)(a1 + 688);
    *(void *)(a1 + 688) = v12;
    *(void *)(v31 + 8 * v2) = a1 + 688;
    if (!*v12) {
      goto LABEL_75;
    }
    unint64_t v33 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v33 >= v7) {
        v33 %= v7;
      }
    }
    else
    {
      v33 &= v7 - 1;
    }
    uint64_t v32 = (void *)(*(void *)(a1 + 672) + 8 * v33);
  }
  void *v32 = v12;
LABEL_75:
  ++*(void *)(a1 + 696);
  unint64_t v6 = *(void *)(a1 + 664);
LABEL_76:
  *(void *)(a1 + 664) = v6 + 1;

  HTTP2Connection::_onqueue_scheduleIO((HTTP2Connection *)a1);
}

void sub_1841BFDFC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void HTTP2Connection::closeConnection(HTTP2Connection *this, char a2)
{
  CFRetain((char *)this - 16);
  double v4 = *((void *)this + 21);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZN15HTTP2Connection15closeConnectionEb_block_invoke;
  v5[3] = &__block_descriptor_41_e5_v8__0l;
  v5[4] = this;
  char v6 = a2;
  dispatch_async(v4, v5);
}

void std::__shared_ptr_emplace<TCPIOConnectionTest::EnqueedRead>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 40);
  if (v1) {
    _Block_release(v1);
  }
}

void std::__shared_ptr_emplace<TCPIOConnectionTest::EnqueedRead>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6D08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<TCPIOConnectionTest::EnqueedRead>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6D08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t HTTP2Server::write(HTTP2Server *this)
{
  uint64_t result = nghttp2_session_want_write();
  if (result)
  {
    uint64_t v8 = 0;
    uint64_t result = MEMORY[0x18531C3F0](*((void *)this + 5), &v8);
    uint64_t v3 = *((void *)this + 7);
    if (v3)
    {
      uint64_t v4 = result;
      uint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v3 + 8);
      uint64_t v6 = *(void *)(v3 + 16);
      unint64_t v7 = (void *)(v3 + (v6 >> 1));
      if (v6) {
        uint64_t v5 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v7 + v5);
      }
      return v5(v7, v8, v4);
    }
  }
  return result;
}

void ___ZN15HTTP2Connection15closeConnectionEb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(HTTP2Connection **)(a1 + 32);
  HTTP2Connection::_onqueue_closeConnection(v1, *(unsigned char *)(a1 + 40), 0);

  CFRelease((char *)v1 - 16);
}

void HTTP2Connection::stopStallRecovery(dispatch_source_t *this)
{
  dispatch_source_cancel(this[90]);
  unint64_t v2 = this[90];
  this[90] = 0;
  if (v2) {
    dispatch_release(v2);
  }
  this[32] = 0;
}

void non-virtual thunk to'HTTP2Connection::~HTTP2Connection(HTTP2Connection *this)
{
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 24));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 16));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 16));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 8));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 8));
}

void ___ZN15HTTP2ConnectionD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void RetainableTypedDict<__CFNumber const*,__CFDictionary *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA02B0;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<__CFNumber const*,__CFDictionary *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA02B0;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

uint64_t non-virtual thunk to'HTTP2Connection::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t HTTP2Connection::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 264) = 1;
  HTTP2Connection::stopIfNoOutstandingRequests((HTTP2Connection *)a1);
  v13.CFStringRef domain = 4;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 232));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0;
    *(void *)&v13.SInt32 error = 4294967291;
    do
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 232), v6);
      uint64_t v9 = (HTTP2Stream *)*((void *)ValueAtIndex + 3);
      uint64_t v8 = (std::__shared_weak_count *)*((void *)ValueAtIndex + 4);
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if ((a2 & 0xFFFFFFFD) == 1
        && (uint64_t v10 = *((void *)v9 + 2)) != 0
        && (*(unsigned int (**)(uint64_t, CFStreamError *, void))(*(void *)v10 + 280))(v10, &v13, 0)
         - 5 <= 5)
      {
        HTTP2Stream::setError(v9, v13);
        HTTP2Stream::closeStreamWithErrorCode(v9);
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        HTTP2Connection::cancelStream(a1, (uint64_t)v9, v8);
        if (!v8) {
          goto LABEL_16;
        }
        std::__shared_weak_count::__release_shared[abi:nn180100](v8);
      }
      else
      {
        uint64_t v11 = *((void *)v9 + 2);
        if (v11) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 248))(v11, a2);
        }
        if (!v8) {
          goto LABEL_16;
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
LABEL_16:
      ++v6;
    }
    while (v5 != v6);
  }
  return 1;
}

void sub_1841C0288(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void HTTP2Connection::stopIfNoOutstandingRequests(HTTP2Connection *this)
{
  CFRetain((char *)this - 16);
  unint64_t v2 = *((void *)this + 21);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN15HTTP2Connection27stopIfNoOutstandingRequestsEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
}

void ___ZN15HTTP2Connection27stopIfNoOutstandingRequestsEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(int *)(v1 + 304);
  if (!(CFArrayGetCount(*(CFArrayRef *)(v1 + 232)) + v2)) {
    HTTP2Connection::_onqueue_closeConnection((HTTP2Connection *)v1, 0, 0);
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

void non-virtual thunk to'HTTP2Connection::connErrorOccurred(CFStreamError *this, CFStreamError a2)
{
  this[8] = a2;
  HTTP2Connection::closeConnection((HTTP2Connection *)&this[-1], 0);
}

void non-virtual thunk to'HTTP2Connection::connEventDisconnected(HTTP2Connection *this)
{
}

void HTTP2Connection::connEventDisconnected(HTTP2Connection *this)
{
  if (!(*((void *)this + 18) | *((unsigned int *)this + 38)))
  {
    *((void *)this + 18) = 4;
    *((_DWORD *)this + 38) = -4;
    HTTP2Connection::closeConnection(this, 0);
  }
}

void non-virtual thunk to'HTTP2Connection::connEventReadClose(HTTP2Connection *this)
{
  if (!(*((void *)this + 16) | *((unsigned int *)this + 34)))
  {
    *((unsigned char *)this + 248) = 1;
    HTTP2Connection::stopIfNoOutstandingRequests((HTTP2Connection *)((char *)this - 16));
  }
}

void HTTP2Connection::connErrorOccurred(CFStreamError *this, CFStreamError a2)
{
  this[9] = a2;
  HTTP2Connection::closeConnection((HTTP2Connection *)this, 0);
}

void HTTP2Connection::connEventReadClose(HTTP2Connection *this)
{
  if (!(*((void *)this + 18) | *((unsigned int *)this + 38)))
  {
    *((unsigned char *)this + 264) = 1;
    HTTP2Connection::stopIfNoOutstandingRequests(this);
  }
}

CFStringRef HTTP2Connection::copyDebugDesc(HTTP2Connection *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"HTTP2Connection<%p>", this);
}

BOOL HTTP2Connection::equals(HTTP2Connection *this, const CFObject *a2)
{
  CFTypeID v4 = CFGetTypeID((char *)this - 16);
  if (v4 != CFGetTypeID((char *)a2 - 16)) {
    return 1;
  }
  uint64_t v5 = (*(uint64_t (**)(const CFObject *))(*(void *)a2 + 8))(a2);
  return v5 == (*(uint64_t (**)(HTTP2Connection *))(*(void *)this + 8))(this);
}

void std::__shared_ptr_emplace<IOConnWrapper>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA66B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<IOConnWrapper>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA66B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke_2(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 642) && *(void *)(v1 + 56))
  {
    *(_DWORD *)uint64_t valuePtr = 3;
    CFNumberRef v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, valuePtr);
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    uint64_t v3 = ___ZN15HTTP2Connection11handleStallEv_block_invoke;
    unint64_t v17 = ___ZN15HTTP2Connection11handleStallEv_block_invoke;
    uint64_t v18 = &__block_descriptor_40_e5_v8__0l;
    CFNumberRef v19 = v2;
    if (v2)
    {
      uint64_t v4 = *(void *)(v1 + 56);
      if (*(_DWORD *)v4 != 2)
      {
        if (*(_DWORD *)v4 != 1) {
          __assert_rtn("setProperty", "TCPIOConnectionTest.hpp", 247, "false");
        }
        (*(void (**)(void, uint64_t, CFNumberRef))(**(void **)(v4 + 8) + 200))(*(void *)(v4 + 8), 0x1EC09EFE0, v2);
        uint64_t v3 = v17;
      }
    }
    v3((uint64_t)v16);
  }
  if (*(_DWORD *)(v1 + 176) == 2 && *(unsigned char *)(v1 + 641) && !*(void *)(v1 + 720))
  {
    dispatch_source_t v5 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(v1 + 168));
    CFIndex v6 = *(NSObject **)(v1 + 720);
    *(void *)(v1 + 72_CFNetworkResetHSTSHostsSinceDate(0, 0) = v5;
    if (v6) {
      dispatch_release(v6);
    }
    double Current = CFAbsoluteTimeGetCurrent();
    double v8 = Current - *(double *)(v1 + 248);
    if (v8 >= 30.0)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v10 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(v1 + 72);
        *(_DWORD *)uint64_t valuePtr = 134218240;
        *(void *)&valuePtr[4] = v11;
        *(_WORD *)&valuePtr[12] = 2048;
        *(double *)&valuePtr[14] = v8;
        _os_log_impl(&dword_184085000, v10, OS_LOG_TYPE_DEFAULT, "Connection %llu idle %f will initiate stall recovery", valuePtr, 0x16u);
      }
      int64_t v9 = 0;
      *(double *)(v1 + 256) = Current + -3.0;
    }
    else
    {
      *(void *)(v1 + 256) = 0;
      int64_t v9 = (uint64_t)((30.0 - v8) * 1000000000.0);
    }
    id v12 = *(NSObject **)(v1 + 720);
    dispatch_time_t v13 = dispatch_time(0x8000000000000000, v9);
    dispatch_source_set_timer(v12, v13, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    CFRetain((CFTypeRef)(v1 - 16));
    float v14 = *(NSObject **)(v1 + 720);
    *(void *)uint64_t valuePtr = MEMORY[0x1E4F143A8];
    *(void *)&valuePtr[8] = 3221225472;
    *(void *)&valuePtr[16] = ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke;
    id v22 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v23 = v1;
    dispatch_source_set_cancel_handler(v14, valuePtr);
    BOOL v15 = *(NSObject **)(v1 + 720);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 3221225472;
    handler[2] = ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_71;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = v1;
    dispatch_source_set_event_handler(v15, handler);
    dispatch_resume(*(dispatch_object_t *)(v1 + 720));
  }
}

void sub_1841C0904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void (*a11)(uint64_t *))
{
}

void std::__shared_ptr_pointer<BlockHolderVar<> *,SmartBlockWithArgs<>::Deleter,std::allocator<BlockHolderVar<>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t BlockHolderVar<>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void std::__shared_ptr_emplace<HTTPStallTimer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6790;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTPStallTimer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6790;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ___ZN15HTTP2Connection11handleStallEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFNumberRef v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(v1 + 72);
    int v4 = 134217984;
    uint64_t v5 = v3;
    _os_log_debug_impl(&dword_184085000, v2, OS_LOG_TYPE_DEBUG, "Connection %llu recovery timer canceled", (uint8_t *)&v4, 0xCu);
  }
  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_71(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  double Current = CFAbsoluteTimeGetCurrent();
  double v3 = *(double *)(v1 + 256);
  if (v3 == 0.0)
  {
    *(double *)(v1 + 256) = Current;
    double v3 = Current;
  }
  double v4 = Current - v3;
  if (v4 < 9.0)
  {
    uint64_t v5 = *(NSObject **)(v1 + 720);
    dispatch_time_t v6 = dispatch_time(0x8000000000000000, (uint64_t)((9.0 - v4) * 1000000000.0));
    dispatch_source_set_timer(v5, v6, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    void v15[2] = ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_2;
    v15[3] = &__block_descriptor_40_e23_v24__0____CFError__8d16l;
    v15[4] = v1;
    (*(void (**)(uint64_t, void *))(*(void *)v1 + 56))(v1, v15);
    return;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  unint64_t v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(v1 + 72);
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl(&dword_184085000, v7, OS_LOG_TYPE_DEFAULT, "Connection %llu reached max hang time, will retry applicable streams", buf, 0xCu);
  }
  if (*(void *)(v1 + 720)) {
    HTTP2Connection::stopStallRecovery((dispatch_source_t *)v1);
  }
  *(unsigned char *)(v1 + 264) = 1;
  HTTP2Connection::stop((HTTP2Connection *)v1, 0);
  *(_OWORD *)long long buf = xmmword_1843D1780;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 232));
  if (Count >= 1)
  {
    CFIndex v10 = 0;
    while (1)
    {
      CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 232), v10);
      dispatch_time_t v13 = (HTTP2Stream *)*((void *)ValueAtIndex + 3);
      id v12 = (std::__shared_weak_count *)*((void *)ValueAtIndex + 4);
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v14 = *((void *)v13 + 2);
      if (v14)
      {
        if ((*(unsigned int (**)(uint64_t, uint8_t *, void))(*(void *)v14 + 280))(v14, buf, 0) - 5 <= 5) {
          break;
        }
      }
      if (v12) {
        goto LABEL_22;
      }
LABEL_23:
      if (Count == ++v10) {
        return;
      }
    }
    HTTP2Stream::setError(v13, *(CFStreamError *)buf);
    HTTP2Stream::closeStreamWithErrorCode(v13);
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    HTTP2Connection::cancelStream(v1, (uint64_t)v13, v12);
    if (!v12) {
      goto LABEL_23;
    }
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
LABEL_22:
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
    goto LABEL_23;
  }
}

void sub_1841C0DA4(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2)
  {
    if (*(void *)(v2 + 720))
    {
      HTTP2Connection::stopStallRecovery((dispatch_source_t *)v2);
    }
  }
  else
  {
    *(void *)(v2 + 256) = 0;
    double v3 = *(NSObject **)(v2 + 720);
    if (v3)
    {
      dispatch_time_t v4 = dispatch_time(0x8000000000000000, 45000000000);
      dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    }
  }
}

void std::__shared_ptr_emplace<PropertyObserver>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6950;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<PropertyObserver>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6950;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_pointer<HTTP2Connection *,Deleter_release<HTTP2Connection>,std::allocator<HTTP2Connection>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void NotificationStation::~NotificationStation(NotificationStation *this)
{
  uint64_t v2 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v2) {
    (*((void (**)(void))this + 10))();
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
  std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100]((uint64_t *)this, 0);
}

BOOL HTTP2StreamEqualCallBack(const void *a1, const void *a2)
{
  if (!a1 || !a2) {
    __assert_rtn("HTTP2StreamEqualCallBack", "HTTP2Connection.cpp", 1785, "value1 && value2");
  }
  return a1 == a2;
}

CFIndex ___ZN15HTTP2Connection24countOutstandingRequestsEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(int *)(v2 + 304);
  CFIndex result = CFArrayGetCount(*(CFArrayRef *)(v2 + 232));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result + v3;
  return result;
}

IOConnWrapper *___ZN15HTTP2Connection9copyTrustEv_block_invoke(uint64_t a1)
{
  CFIndex result = *(IOConnWrapper **)(*(void *)(a1 + 40) + 56);
  if (result)
  {
    CFIndex result = (IOConnWrapper *)IOConnWrapper::copyProperty(result, @"kCFStreamPropertySSLPeerTrust");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  }
  return result;
}

void MemPool::~MemPool(MemPool *this)
{
  uint64_t v2 = (void **)*((void *)this + 1);
  uint64_t v3 = (void **)*((void *)this + 2);
  if (v2 != v3)
  {
    do
    {
      dispatch_time_t v4 = *v2;
      v2 += 2;
      free(v4);
    }
    while (v2 != v3);
    uint64_t v2 = (void **)*((void *)this + 1);
  }
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
}

void __destroy_helper_block_e8_64c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 72);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_64c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(result + 72) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::string>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    uint64_t v8 = (uint64_t *)a2;
  }
  else {
    uint64_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    BOOL v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
            return;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v18 = (void *)(a1 + 16);
  CFNumberRef v19 = (char *)operator new(0x40uLL);
  v29[0] = v19;
  v29[1] = a1 + 16;
  *(void *)CFNumberRef v19 = 0;
  *((void *)v19 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v11;
  *((_OWORD *)v19 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = *(_OWORD *)a3;
  *((void *)v19 + 4) = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_OWORD *)(v19 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = *(_OWORD *)(a3 + 24);
  *((void *)v19 + 7) = *(void *)(a3 + 40);
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  char v30 = 1;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>(a1, v25);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  uint64_t v26 = *(void *)a1;
  uint64_t v27 = *(void **)(*(void *)a1 + 8 * v3);
  if (v27)
  {
    *(void *)CFNumberRef v19 = *v27;
LABEL_44:
    *uint64_t v27 = v19;
    goto LABEL_45;
  }
  *(void *)CFNumberRef v19 = *v18;
  void *v18 = v19;
  *(void *)(v26 + 8 * v3) = v18;
  if (*(void *)v19)
  {
    unint64_t v28 = *(void *)(*(void *)v19 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12) {
        v28 %= v12;
      }
    }
    else
    {
      v28 &= v12 - 1;
    }
    uint64_t v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_44;
  }
LABEL_45:
  v29[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v29);
}

void sub_1841C132C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string,std::string>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  dispatch_time_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_2(uint64_t a1, int a2)
{
  unint64_t v3 = *(HTTP2Stream **)(a1 + 40);
  if (!a2)
  {
    v19.CFStringRef domain = 1;
    *(void *)&v19.SInt32 error = 53;
    goto LABEL_18;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  HTTP2Stream::beginHeaders(v3);
  for (uint64_t i = *(uint64_t **)(*(void *)(a1 + 56) + 96); i; uint64_t i = (uint64_t *)*i)
  {
    if (*((char *)i + 39) < 0)
    {
      dispatch_time_t v6 = (unsigned __int8 *)i[2];
      size_t v7 = i[3];
    }
    else
    {
      dispatch_time_t v6 = (unsigned __int8 *)(i + 2);
      size_t v7 = *((unsigned __int8 *)i + 39);
    }
    if (*((char *)i + 63) < 0)
    {
      uint64_t v8 = (unsigned __int8 *)i[5];
      size_t v9 = i[6];
    }
    else
    {
      uint64_t v8 = (unsigned __int8 *)(i + 5);
      size_t v9 = *((unsigned __int8 *)i + 63);
    }
    HTTP2Stream::processHeaderLine(*(HTTP2Stream **)(a1 + 40), v6, v7, v8, v9);
  }
  uint64_t v10 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_12_2841, 2);
  if (v10)
  {
    uint64_t v11 = v10;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v10 + 16))(v10, "h2 info push promise", 0))
    {
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v11 + 72))(v11, "h2 psps", @"[%llu] finish push promise processing stream_id=%d");
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
  }
  HTTP2Stream::endHeaders(*(HTTP2Stream **)(a1 + 40));
  uint64_t v12 = *(void *)(a1 + 56);
  uint8x8_t v13 = *(NSObject **)(v12 + 152);
  if (v13)
  {
    HTTP2Stream::bufferDataFromDataFrame(*(void *)(a1 + 40), v13, 0);
    uint64_t v12 = *(void *)(a1 + 56);
  }
  unint64_t v14 = (HTTP2Connection *)*(unsigned int *)(v12 + 256);
  if (v14)
  {
    BOOL v15 = *(HTTP2Stream **)(a1 + 40);
    CFIndex v16 = HTTP2Connection::http2ErrorCodeToCFStreamError(v14);
    uint64_t v18 = v17;
    unint64_t v3 = v15;
    v19.CFStringRef domain = v16;
    *(void *)&v19.SInt32 error = v18;
LABEL_18:
    HTTP2Stream::setError(v3, v19);
    goto LABEL_20;
  }
  int v20 = *(_DWORD *)(a1 + 64);
  CFRetain((CFTypeRef)(v4 - 16));
  float v21 = *(NSObject **)(v4 + 168);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN15HTTP2Connection24removeServerPushedStreamEi_block_invoke;
  block[3] = &__block_descriptor_44_e5_v8__0l;
  block[4] = v4;
  int v24 = v20;
  dispatch_async(v21, block);
LABEL_20:
  HTTP2Stream::closeStreamWithErrorCode(*(HTTP2Stream **)(a1 + 40));
  BOOL v22 = *(HTTP2Stream **)(a1 + 40);

  HTTP2Stream::breakStreamUserDataCycle(v22);
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_3_35()
{
  return nghttp2_submit_priority();
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_2_29@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 485;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_23@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 477;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN15HTTP2Connection24removeServerPushedStreamEi_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  HTTP2ServerPush::_removeStream((HTTP2ServerPush *)(v1 + 288), *(_DWORD *)(a1 + 40), 1);

  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_3@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 451;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t *a1, unint64_t a2)
{
  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      uint64_t v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      uint64_t v6 = *a1 - 0x3C5A37A36834CED9 * (v5 + a2);
      uint64_t v8 = a1[2];
      uint64_t v7 = a1[3];
      uint64_t v9 = __ROR8__(v6 + v7, 52);
      uint64_t v10 = v6 + a1[1];
      uint64_t v11 = __ROR8__(v10, 7);
      uint64_t v12 = v10 + v8;
      uint64_t v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      uint64_t v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      uint64_t v15 = __ROR8__(v14 + v13, 52);
      uint64_t v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v5 + a2), 37) + v9;
      uint64_t v17 = __ROR8__(v13, 37);
      uint64_t v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      uint64_t v19 = __ROR8__(v18, 7);
      uint64_t v20 = v16 + __ROR8__(v12, 31);
      uint64_t v21 = v18 + v5;
      uint64_t v22 = v21 + v14;
      unint64_t v23 = 0x9AE16A3B2F90404FLL;
      unint64_t v24 = 0xC3A5C85C97CB3127 * (v22 + v20) - 0x651E95C4D06FBFB1 * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      unint64_t v25 = v20 - 0x3C5A37A36834CED9 * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }
    unint64_t v4 = 0x9DDFEA08EB382D69;
    uint64_t v32 = *(uint64_t *)((char *)a1 + a2 - 48);
    uint64_t v33 = *(uint64_t *)((char *)a1 + a2 - 40);
    uint64_t v34 = *(uint64_t *)((char *)a1 + a2 - 24);
    uint64_t v36 = *(uint64_t *)((char *)a1 + a2 - 64);
    uint64_t v35 = *(uint64_t *)((char *)a1 + a2 - 56);
    uint64_t v37 = *(uint64_t *)((char *)a1 + a2 - 16);
    uint64_t v38 = *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v39 = v35 + v37;
    unint64_t v40 = 0x9DDFEA08EB382D69
        * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))));
    unint64_t v41 = 0x9DDFEA08EB382D69 * (v40 ^ (v40 >> 47));
    unint64_t v42 = v36 + a2 + v35 + v32;
    uint64_t v43 = v42 + v33;
    unint64_t v44 = __ROR8__(v42, 44) + v36 + a2 + __ROR8__(v33 + v36 + a2 - 0x622015F714C7D297 * (v40 ^ (v40 >> 47)), 21);
    uint64_t v45 = v35 + v37 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    uint64_t v46 = v45 + v34 + v37;
    uint64_t v47 = __ROR8__(v46, 44);
    uint64_t v48 = v46 + v38;
    uint64_t v49 = v47 + v45 + __ROR8__(v45 + v33 + v38, 21);
    uint64_t v51 = *a1;
    uint64_t v50 = a1 + 4;
    unint64_t v52 = v51 - 0x4B6D499041670D8DLL * v33;
    uint64_t v53 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      uint64_t v54 = *(v50 - 3);
      uint64_t v55 = v52 + v43 + v39 + v54;
      uint64_t v56 = v50[2];
      uint64_t v57 = v50[3];
      uint64_t v58 = v50[1];
      unint64_t v39 = v58 + v43 - 0x4B6D499041670D8DLL * __ROR8__(v39 + v44 + v56, 42);
      uint64_t v59 = v41 + v48;
      uint64_t v60 = *(v50 - 2);
      uint64_t v61 = *(v50 - 1);
      uint64_t v62 = *(v50 - 4) - 0x4B6D499041670D8DLL * v44;
      uint64_t v63 = v62 + v48 + v61;
      uint64_t v64 = v62 + v54 + v60;
      uint64_t v43 = v64 + v61;
      uint64_t v65 = __ROR8__(v64, 44) + v62;
      unint64_t v66 = (0xB492B66FBE98F273 * __ROR8__(v55, 37)) ^ v49;
      unint64_t v52 = 0xB492B66FBE98F273 * __ROR8__(v59, 33);
      unint64_t v44 = v65 + __ROR8__(v63 + v66, 21);
      unint64_t v67 = v52 + v49 + *v50;
      uint64_t v48 = v67 + v58 + v56 + v57;
      uint64_t v49 = __ROR8__(v67 + v58 + v56, 44) + v67 + __ROR8__(v39 + v60 + v67 + v57, 21);
      v50 += 8;
      unint64_t v41 = v66;
      v53 += 64;
    }
    while (v53);
    unint64_t v68 = v52
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) >> 47));
    unint64_t v69 = 0x9DDFEA08EB382D69
        * (v68 ^ (v66
                - 0x4B6D499041670D8DLL * (v39 ^ (v39 >> 47))
                - 0x622015F714C7D297
                * ((0x9DDFEA08EB382D69
                  * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) ^ ((0x9DDFEA08EB382D69 * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) >> 47))));
    unint64_t v70 = 0x9DDFEA08EB382D69 * (v68 ^ (v69 >> 47) ^ v69);
    goto LABEL_13;
  }
  if (a2 > 0x10)
  {
    uint64_t v26 = a1[1];
    unint64_t v27 = 0xB492B66FBE98F273 * *a1;
    uint64_t v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    unint64_t v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v23 = 0x9DDFEA08EB382D69;
    unint64_t v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v28 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a1 + a2 - 16)));
    unint64_t v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    unint64_t v25 = 0x9DDFEA08EB382D69 * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }
  if (a2 < 9)
  {
    if (a2 >= 4)
    {
      uint64_t v72 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v23 = 0x9DDFEA08EB382D69;
      unint64_t v73 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a1) + a2) ^ v72);
      unint64_t v31 = v72 ^ (v73 >> 47) ^ v73;
      goto LABEL_8;
    }
    unint64_t v4 = 0x9AE16A3B2F90404FLL;
    if (!a2) {
      return v4;
    }
    unint64_t v70 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v4 *= v70 ^ (v70 >> 47);
    return v4;
  }
  uint64_t v2 = *(uint64_t *)((char *)a1 + a2 - 8);
  uint64_t v3 = __ROR8__(v2 + a2, a2);
  return (0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) >> 47))) ^ v2;
}

BOOL std::equal_to<std::string>::operator()[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1;
  }
  uint64_t v6 = v2 - 1;
  do
  {
    int v8 = *a1++;
    int v7 = v8;
    int v10 = *a2++;
    int v9 = v10;
    BOOL v12 = v6-- != 0;
    BOOL v13 = v7 == v9;
    BOOL v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

void std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      uint64_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  int v5 = operator new(8 * prime);
  uint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  int v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    BOOL v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *int v8 = *v14;
          void *v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          BOOL v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        int v8 = v14;
        BOOL v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

void HTTP2Connection::setErrorOnAllStreams(HTTP2Connection *this, int a2)
{
  CFRetain((char *)this - 16);
  int8x8_t v4 = *((void *)this + 21);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZN15HTTP2Connection20setErrorOnAllStreamsEj_block_invoke;
  v5[3] = &__block_descriptor_44_e5_v8__0l;
  v5[4] = this;
  int v6 = a2;
  dispatch_async(v4, v5);
}

void ___ZN15HTTP2Connection20setErrorOnAllStreamsEj_block_invoke(uint64_t a1)
{
  CFIndex v1 = 0;
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (HTTP2Connection *)*(unsigned int *)(a1 + 40);
  while (v1 < CFArrayGetCount(*(CFArrayRef *)(v2 + 232)))
  {
    CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 232), v1);
    int v6 = (HTTP2Stream *)*((void *)ValueAtIndex + 3);
    int v5 = (std::__shared_weak_count *)*((void *)ValueAtIndex + 4);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    CFIndex v7 = HTTP2Connection::http2ErrorCodeToCFStreamError(v3);
    uint64_t v9 = v8;
    v11.CFStringRef domain = v7;
    *(void *)&v11.SInt32 error = v9;
    HTTP2Stream::setError(v6, v11);
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    }
    ++v1;
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN15HTTP2Connection20changeStreamPriorityENSt3__110shared_ptrI11HTTP2StreamEEl_block_invoke(void *a1)
{
  uint64_t v1 = a1[4];
  if (*(void *)(v1 + 160))
  {
    uint64_t v3 = a1[5];
    uint64_t v2 = (std::__shared_weak_count *)a1[6];
    if (v2) {
      atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if ((*(_DWORD *)(v3 + 56) & 0xFFFFFFFE) != 2)
    {
      nghttp2_priority_spec_init();
      if (!nghttp2_submit_priority())
      {
        int8x8_t v4 = *(void **)(v1 + 128);
        if (v4) {
          dispatch_async(*(dispatch_queue_t *)(v1 + 168), v4);
        }
      }
    }
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v2);
    }
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

void sub_1841C2134(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c40_ZTSKNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c40_ZTSKNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

std::string *HTTP2Diagnostic::APPEND_RECV_HEADER(std::string *a1, uint64_t a2, uint64_t a3, int a4, unint64_t a5)
{
  std::string::append(a1, "[");
  std::to_string(&__p, a5);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  std::string::append(a1, (const std::string::value_type *)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string::append(a1, "] recv (stream_id=");
  std::to_string(&__p, a4);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint8x8_t v12 = &__p;
  }
  else {
    uint8x8_t v12 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v13 = __p.__r_.__value_.__l.__size_;
  }
  std::string::append(a1, (const std::string::value_type *)v12, v13);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string::append(a1, ") ");
  int v14 = *(char *)(a2 + 23);
  if (v14 >= 0) {
    size_t v15 = (const std::string::value_type *)a2;
  }
  else {
    size_t v15 = *(const std::string::value_type **)a2;
  }
  if (v14 >= 0) {
    std::string::size_type v16 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v16 = *(void *)(a2 + 8);
  }
  std::string::append(a1, v15, v16);
  std::string::append(a1, ": ");
  if (__CFNCanLogSensitiveContent::onceToken != -1) {
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_38);
  }
  if (__CFNCanLogSensitiveContent::ok)
  {
    if (*(char *)(a3 + 23) < 0) {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
    }
    else {
      std::string __p = *(std::string *)a3;
    }
  }
  else
  {
    std::string::basic_string[abi:nn180100]<0>(&__p, "<redacted>");
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v17 = &__p;
  }
  else {
    uint64_t v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
  }
  std::string::append(a1, (const std::string::value_type *)v17, v18);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return std::string::append(a1, "\n");
}

void sub_1841C2350(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN15HTTP2Connection22handlePUSHPROMISEframeEPK13nghttp2_frame_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1272;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN15HTTP2Connection18handleHEADERSFrameEPK13nghttp2_frame_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 1301;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t _CFHTTPAuthenticationUpdateFromResponse(uint64_t a1, __CFHTTPMessage *a2, void *a3)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a1) {
    int v6 = (HTTPAuthentication *)(a1 + 16);
  }
  else {
    int v6 = 0;
  }

  return HTTPAuthentication::updateFromResponse(v6, a2, a3);
}

Boolean CFHTTPAuthenticationIsValid(CFHTTPAuthenticationRef auth, CFStreamError *error)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (auth) {
    int8x8_t v4 = (char *)auth + 16;
  }
  else {
    int8x8_t v4 = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
  CFIndex v5 = *((void *)v4 + 11);
  uint64_t v7 = *((void *)v4 + 12);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
  if (error)
  {
    error->CFStringRef domain = v5;
    *(void *)&error->SInt32 error = v7;
  }
  return v7 == 0;
}

CFStringRef _CFHTTPAuthenticationIsConnectionBasedAuth(_CFHTTPAuthentication *a1)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a1) {
    uint64_t v2 = (_CFHTTPAuthentication *)((char *)a1 + 16);
  }
  else {
    uint64_t v2 = 0;
  }

  return HTTPAuthentication::isConnectionBasedAuth(v2);
}

Boolean CFHTTPAuthenticationRequiresOrderedRequests(CFHTTPAuthenticationRef auth)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (auth) {
    uint64_t v2 = (char *)auth + 16;
  }
  else {
    uint64_t v2 = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 16));
  CFStringRef Property_Locked = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)v2, @"kCFHTTPAuthenticationPropertyMethod");
  Boolean v4 = 1;
  int ExactString = _findExactString(Property_Locked, 1u);
  if (ExactString != 6324248 && ExactString != 5316627)
  {
    if (ExactString == 2146311)
    {
      if (!HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)v2, @"Nextnonce")) {
        Boolean v4 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)v2, @"Qop") != 0;
      }
    }
    else
    {
      Boolean v4 = 0;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v2 + 16));
  return v4;
}

Boolean CFHTTPMessageApplyCredentials(CFHTTPMessageRef request, CFHTTPAuthenticationRef auth, CFStringRef username, CFStringRef password, CFStreamError *error)
{
  CFAllocatorRef v10 = CFGetAllocator(request);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v10, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    uint8x8_t v12 = Mutable;
    if (username)
    {
      if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
        dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
      }
      if (auth) {
        std::string::size_type v13 = (CFHTTPAuthenticationRef)((char *)auth + 16);
      }
      else {
        std::string::size_type v13 = 0;
      }
      if (HTTPAuthentication::requiresAccountDomain(v13))
      {
        CFAllocatorRef v14 = CFGetAllocator(username);
        CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v14, username, @"\\"");
        if (ArrayBySeparatingStrings)
        {
          CFArrayRef v16 = ArrayBySeparatingStrings;
          if (CFArrayGetCount(ArrayBySeparatingStrings) == 2)
          {
            CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v16, 0);
            CFDictionaryAddValue(v12, @"kCFHTTPAuthenticationAccountDomain", ValueAtIndex);
            std::string::size_type v18 = CFArrayGetValueAtIndex(v16, 1);
            uint64_t v19 = v12;
          }
          else
          {
            uint64_t v19 = v12;
            std::string::size_type v18 = username;
          }
          CFDictionaryAddValue(v19, @"kCFHTTPAuthenticationUsername", v18);
          CFRelease(v16);
          if (!password) {
            goto LABEL_15;
          }
          goto LABEL_14;
        }
      }
      CFDictionaryAddValue(v12, @"kCFHTTPAuthenticationUsername", username);
    }
    if (!password)
    {
LABEL_15:
      Boolean v20 = CFHTTPMessageApplyCredentialDictionary(request, auth, v12, error);
      CFRelease(v12);
      LOBYTE(Mutable) = v20;
      return Mutable;
    }
LABEL_14:
    CFDictionaryAddValue(v12, @"kCFHTTPAuthenticationPassword", password);
    goto LABEL_15;
  }
  return Mutable;
}

Boolean CFHTTPMessageApplyCredentialDictionary(CFHTTPMessageRef request, CFHTTPAuthenticationRef auth, CFDictionaryRef dict, CFStreamError *error)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (auth) {
    uint64_t v8 = (char *)auth + 16;
  }
  else {
    uint64_t v8 = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
  HTTPAuthentication::applyCredentials_Locked((CFMutableDictionaryRef *)v8, request, dict, error);
  Boolean v10 = v9;
  pthread_mutex_unlock((pthread_mutex_t *)(v8 + 16));
  return v10;
}

Boolean CFHTTPAuthenticationRequiresAccountDomain(CFHTTPAuthenticationRef auth)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (auth) {
    uint64_t v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  }
  else {
    uint64_t v2 = 0;
  }

  return HTTPAuthentication::requiresAccountDomain(v2);
}

Boolean CFHTTPAuthenticationAppliesToRequest(CFHTTPAuthenticationRef auth, CFHTTPMessageRef request)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (auth) {
    Boolean v4 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  }
  else {
    Boolean v4 = 0;
  }

  return HTTPAuthentication::appliesToRequest(v4, request);
}

CFTypeID CFHTTPAuthenticationGetTypeID(void)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  return *(void *)(HTTPAuthentication::Class(void)::sClass_OBJTYPE + 96);
}

_OWORD *_CFHTTPAuthenticationCreateFromResponseInternal(const __CFAllocator *a1, CFHTTPMessageRef response, const __CFString *a3, char a4, const void *a5, const __CFString *a6, const __CFString *a7, const __CFUUID *a8, char a9, unsigned __int8 a10)
{
  if (!response) {
    return 0;
  }
  ResponseStatusCFIndex Code = CFHTTPMessageGetResponseStatusCode(response);
  CFIndex v17 = ResponseStatusCode;
  if (ResponseStatusCode != 407 && ResponseStatusCode != 401) {
    return 0;
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t v18 = 88;
  if (v17 == 407) {
    uint64_t v18 = 96;
  }
  uint64_t v19 = *(const void **)((char *)response + v18);
  if (!v19 || !CFHTTPAuthenticationIsValid(*(CFHTTPAuthenticationRef *)((char *)response + v18), 0))
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
    }
    uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
    uint64_t v21 = Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      Instance[14] = 0u;
      Instance[15] = 0u;
      Instance[12] = 0u;
      Instance[13] = 0u;
      Instance[10] = 0u;
      Instance[11] = 0u;
      Instance[8] = 0u;
      Instance[9] = 0u;
      Instance[6] = 0u;
      Instance[7] = 0u;
      Instance[4] = 0u;
      Instance[5] = 0u;
      Instance[2] = 0u;
      Instance[3] = 0u;
      HTTPAuthentication::HTTPAuthentication((HTTPAuthentication *)(Instance + 1));
      *((unsigned char *)v21 + 177) = a4;
      HTTPAuthentication::_initialize(v23, response, 0, a5, a6, a7, v24);
      HTTPAuthentication::initializeSchemes((HTTPAuthentication *)(v21 + 1), response, a3);
    }
    else
    {
      HTTPAuthentication::HTTPAuthentication(0);
    }
    return v21;
  }

  return CFRetain(v19);
}

CFHTTPAuthenticationRef CFHTTPAuthenticationCreateFromResponse(CFAllocatorRef alloc, CFHTTPMessageRef response)
{
  return (CFHTTPAuthenticationRef)_CFHTTPAuthenticationCreateFromResponseInternal(alloc, response, 0, 1, 0, 0, 0, 0, 0, v3);
}

_OWORD *_CFHTTPAuthenticationCreateFromResponseWithFlags(const __CFAllocator *a1, __CFHTTPMessage *a2, __CFUUID *a3, char a4)
{
  return _CFHTTPAuthenticationCreateFromResponseInternal(a1, a2, 0, 1, 0, 0, 0, a3, a4, v5);
}

CFDictionaryRef _CFHTTPAuthenticationApplyHeaderToRequest(_CFHTTPAuthentication *a1, __CFHTTPMessage *a2, const void *a3)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a1) {
    int v6 = (CFDictionaryRef *)((char *)a1 + 16);
  }
  else {
    int v6 = 0;
  }

  return HTTPAuthentication::applyHeaderToRequest(v6, a2, a3);
}

uint64_t _CFHTTPAuthenticationDisassociateConnection(uint64_t a1, const void *a2)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a1) {
    uint64_t v4 = a1 + 16;
  }
  else {
    uint64_t v4 = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v4 + 152), a2);

  return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
}

uint64_t _CFHTTPAuthenticationSetPreferredScheme(uint64_t a1, const void *a2)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a1) {
    uint64_t v4 = a1 + 16;
  }
  else {
    uint64_t v4 = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
  CFDictionaryRef v5 = *(const __CFDictionary **)(v4 + 144);
  if (v5 && (CFNumberRef Value = CFDictionaryGetValue(v5, a2)) != 0)
  {
    CFTypeRef v7 = CFRetain(Value);
    uint64_t v8 = *(const void **)(v4 + 136);
    *(void *)(v4 + 136) = v7;
    if (v8) {
      CFRelease(v8);
    }
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
  return v9;
}

BOOL _CFHTTPAuthenticationRequiresPersistentConnection(CFHTTPAuthenticationRef auth)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  uint64_t v2 = (__CFString *)CFHTTPAuthenticationCopyMethod(auth);
  if (!v2) {
    return 0;
  }
  BOOL v4 = v2 == @"Negotiate" || v2 == @"NTLM";
  CFRelease(v2);
  return v4;
}

CFStringRef CFHTTPAuthenticationCopyRealm(CFHTTPAuthenticationRef auth)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (auth) {
    uint64_t v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  }
  else {
    uint64_t v2 = 0;
  }

  return (CFStringRef)HTTPAuthentication::copyRealm(v2);
}

CFArrayRef CFHTTPAuthenticationCopyDomains(CFHTTPAuthenticationRef auth)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (auth) {
    uint64_t v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  }
  else {
    uint64_t v2 = 0;
  }

  return (CFArrayRef)HTTPAuthentication::lockAndCopyProperty(v2, @"Domain");
}

CFStringRef CFHTTPAuthenticationCopyMethod(CFHTTPAuthenticationRef auth)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (auth) {
    uint64_t v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  }
  else {
    uint64_t v2 = 0;
  }

  return HTTPAuthentication::lockAndCopyProperty(v2, @"kCFHTTPAuthenticationPropertyMethod");
}

Boolean CFHTTPAuthenticationRequiresUserNameAndPassword(CFHTTPAuthenticationRef auth)
{
  return 1;
}

BOOL _CFHTTPAuthenticationPasswordInClear(uint64_t a1)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a1) {
    uint64_t v2 = a1 + 16;
  }
  else {
    uint64_t v2 = 0;
  }
  unsigned __int8 v3 = (pthread_mutex_t *)(v2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 16));
  CFStringRef Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)v2, @"kCFHTTPAuthenticationPropertyMethod");
  pthread_mutex_unlock(v3);
  BOOL result = 1;
  if (Property_Locked)
  {
    BOOL v5 = Property_Locked == @"Digest" || Property_Locked == @"Negotiate";
    if (v5 || Property_Locked == @"NTLM") {
      return 0;
    }
  }
  return result;
}

BOOL _CFHTTPAuthenticationConnectionAuthenticated(_CFHTTPAuthentication *a1, const void *a2)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 32));
  CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 21), a2);
  if (!Value) {
    goto LABEL_6;
  }
  BOOL v5 = Value;
  CFStringRef Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked((_CFHTTPAuthentication *)((char *)a1 + 16), @"kCFHTTPAuthenticationPropertyMethod");
  if (Property_Locked == @"NTLM")
  {
    if (v5[2]) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  if (Property_Locked == @"Negotiate")
  {
    if (!v5[2]) {
      goto LABEL_12;
    }
LABEL_10:
    if (v5[1])
    {
      BOOL v7 = *v5 == 0;
      goto LABEL_13;
    }
LABEL_12:
    BOOL v7 = 0;
    goto LABEL_13;
  }
LABEL_6:
  BOOL v7 = 1;
LABEL_13:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 32));
  return v7;
}

_CFHTTPAuthentication *_CFHTTPMessageCanRetry(__CFHTTPMessage *a1)
{
  BOOL v2 = CFHTTPMessageGetResponseStatusCode(a1) == 407;
  BOOL result = (_CFHTTPAuthentication *)_CFHTTPMessageGetAuthentication(a1, v2);
  if (result)
  {
    return (_CFHTTPAuthentication *)CFHTTPAuthenticationIsValid(result, 0);
  }
  return result;
}

Boolean CFHTTPMessageAddAuthentication(CFHTTPMessageRef request, CFHTTPMessageRef authenticationFailureResponse, CFStringRef username, CFStringRef password, CFStringRef authenticationScheme, Boolean forProxy)
{
  CFStringRef v6 = (const __CFString *)forProxy;
  Boolean v10 = (char *)authenticationFailureResponse;
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  if (!authenticationFailureResponse
    || (CFAllocatorRef v12 = CFGetAllocator(authenticationFailureResponse),
        (Boolean v10 = (char *)_CFHTTPAuthenticationCreateFromResponseInternal(v12, (CFHTTPMessageRef)v10, authenticationScheme, 1, 0, 0, 0, 0, 0, v27)) == 0))
  {
    int v15 = 0;
    if (!authenticationScheme) {
      goto LABEL_38;
    }
    goto LABEL_9;
  }
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 32));
  if (!authenticationScheme)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
    }
    CFStringRef Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)(v10 + 16), @"kCFHTTPAuthenticationPropertyMethod");
    if (Property_Locked != @"NTLM")
    {
      authenticationScheme = Property_Locked;
      goto LABEL_37;
    }
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
    }
    authenticationScheme = @"Digest";
    CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)v10 + 20), @"Digest");
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication == -1)
    {
      if (!Value)
      {
LABEL_32:
        authenticationScheme = (CFStringRef)gConstantCFStringValueTable;
        CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)v10 + 20), gConstantCFStringValueTable);
        if (!Value)
        {
LABEL_40:
          Boolean v14 = 0;
          goto LABEL_41;
        }
        if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
        {
          uint64_t v26 = Value;
          dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
          CFNumberRef Value = v26;
        }
      }
    }
    else
    {
      unint64_t v25 = Value;
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
      CFNumberRef Value = v25;
      if (!v25) {
        goto LABEL_32;
      }
    }
    unint64_t v23 = (const void *)*((void *)v10 + 19);
    *((void *)v10 + 19) = Value;
    if (v23) {
      CFRelease(v23);
    }
LABEL_37:
    int v15 = 1;
    if (!authenticationScheme)
    {
LABEL_38:
      Boolean v14 = 0;
      if (!v15) {
        return v14;
      }
      goto LABEL_41;
    }
LABEL_9:
    if (CFStringCompare(authenticationScheme, (CFStringRef)gConstantCFStringValueTable, 1uLL) == kCFCompareEqualTo)
    {
      Boolean v14 = HTTPAuthentication::setBasicAuthenticationOnRequest_NoAuthFromResponse(request, username, password, v6, 0, v16);
      if ((v15 & 1) == 0) {
        return v14;
      }
      goto LABEL_41;
    }
    if (!v15) {
      return 0;
    }
LABEL_11:
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
    }
    if (!*((_DWORD *)v10 + 28) && CFStringCompare(authenticationScheme, @"Digest", 1uLL) == kCFCompareEqualTo)
    {
      if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
        dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
      }
      CFStringRef v17 = (const __CFString *)HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)(v10 + 16), @"kCFHTTPAuthenticationPropertyMethod");
      if (CFStringCompare(authenticationScheme, v17, 1uLL) == kCFCompareEqualTo)
      {
        keys[0] = @"kCFHTTPAuthenticationUsername";
        keys[1] = @"kCFHTTPAuthenticationPassword";
        values[0] = (void *)username;
        values[1] = (void *)password;
        CFAllocatorRef v18 = CFGetAllocator(request);
        CFDictionaryRef v19 = CFDictionaryCreate(v18, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
          dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
        }
        HTTPAuthentication::applyCredentials_Locked((CFMutableDictionaryRef *)v10 + 2, request, v19, 0);
        Boolean v14 = v20;
        CFRelease(v19);
        goto LABEL_41;
      }
    }
    goto LABEL_40;
  }
  if (CFStringCompare(authenticationScheme, (CFStringRef)gConstantCFStringValueTable, 1uLL)) {
    goto LABEL_11;
  }
  Boolean v14 = HTTPAuthentication::setBasicAuthenticationOnRequest_NoAuthFromResponse(request, username, password, v6, 0, v13);
LABEL_41:
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v10 + 32));
  CFRelease(v10);
  return v14;
}

unsigned __int8 *_CFHTTPAuthenticationIsFirstNTLMTransaction(_CFHTTPAuthentication *a1, void *key)
{
  BOOL result = 0;
  if (a1 && key)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
    }
    BOOL result = (unsigned __int8 *)*((void *)a1 + 21);
    if (result)
    {
      BOOL result = (unsigned __int8 *)CFDictionaryGetValue((CFDictionaryRef)result, key);
      if (result) {
        return (unsigned __int8 *)result[24];
      }
    }
  }
  return result;
}

void _CFHTTPAuthenticationApplyProxyAuthorizationToRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  Boolean v10 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    buf[0] = 138413314;
    *(void *)&buf[1] = a1;
    __int16 v12 = 2112;
    uint64_t v13 = a2;
    __int16 v14 = 2112;
    uint64_t v15 = a3;
    v16[0] = 2112;
    *(void *)&v16[1] = a4;
    void v16[5] = 2048;
    uint64_t v17 = a5;
    _os_log_debug_impl(&dword_184085000, v10, OS_LOG_TYPE_DEBUG, "Applying proxy auth: response=%@, proxyURL=%@, request=%@, credentials=%@, handle=%p", (uint8_t *)buf, 0x34u);
  }
  CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%p", a5);
  operator new();
}

void sub_1841C41BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void (*a17)(char *), uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,std::__shared_weak_count *a27,CFTypeRef cf,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40)
{
  a17(&a15);
  _Block_object_dispose(&a20, 8);
  if (a27) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a27);
  }
  if (cf) {
    CFRelease(cf);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v41);
  std::__shared_weak_count::__release_shared[abi:nn180100](v40);
  _Unwind_Resume(a1);
}

CFStringRef _CFHTTPAuthenticationCreateNTLMHeaderForRequest(uint64_t a1, int a2, void *key)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0;
  }
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 152), key);

  return HTTPAuthentication::createNTLMHeaderForRequest_Mac(v5, Value, key);
}

CFStringRef _CFHTTPAuthenticationCreateNegotiateHeaderForRequest(uint64_t a1, int a2, void *key)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0;
  }
  CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 152), key);

  return HTTPAuthentication::createNegotiateHeaderForRequest_Mac();
}

uint64_t _CFHTTPAuthenticationGetSchemesDict(uint64_t a1)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(void *)(v2 + 144);
}

CFArrayRef _CFHTTPAuthenticationCopySortedAuthSchemes(uint64_t a1)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a1) {
    uint64_t v2 = (HTTPAuthentication *)(a1 + 16);
  }
  else {
    uint64_t v2 = 0;
  }
  CFArrayRef v3 = (const __CFArray *)HTTPAuthentication::copyServerSupportedSchemes(v2);
  if (!v3) {
    return 0;
  }
  CFArrayRef v4 = v3;
  MutableCFStringRef Copy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v3);
  v7.CFIndex length = CFArrayGetCount(MutableCopy);
  v7.CFIndex location = 0;
  CFArraySortValues(MutableCopy, v7, (CFComparatorFunction)sortArrayBySecurityStrength, 0);
  CFRelease(v4);
  return MutableCopy;
}

void sub_1841C44C0(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFHTTPAuthenticationGetPATSchemes(uint64_t a1)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(void *)(v2 + 232);
}

void _CFHTTPAuthenticationGetPATAuthHeaders()
{
}

void sub_1841C4634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a20);
  }
  _Unwind_Resume(exception_object);
}

void SmartBlockWithArgs<__CFDictionary const*,__CFError *>::SmartBlockWithArgs()
{
}

void sub_1841C4724(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFDictionary const*,__CFError *> *,SmartBlockWithArgs<__CFDictionary const*,__CFError *>::Deleter,std::allocator<BlockHolderVar<__CFDictionary const*,__CFError *>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial
    && v5 != 0)
  {
    CFRange v7 = (void *)(v1 + (v2 >> 1));
    if (v2) {
      (*(void (**)(void *, void, void))(*v7
    }
                                                       + BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial))(v7, 0, 0);
    else {
      ((void (*)(void *, void, void))BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial)(v7, 0, 0);
    }
  }
  _Block_release(*(const void **)v1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFDictionary const*,__CFError *> *,SmartBlockWithArgs<__CFDictionary const*,__CFError *>::Deleter,std::allocator<BlockHolderVar<__CFDictionary const*,__CFError *>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

uint64_t BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t _CFHTTPAuthenticationCheckOriginAllowedAsThirdParty(double a1)
{
  double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(a1);
  return [*(id *)(v2 + 312) checkOriginAllowedAsThirdParty:Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher];
}

uint64_t _CFHTTPAuthenticationUsingAppSSO(double a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  gotLoadHelper_x9__SOErrorDomain(a1);
  int v3 = *(unsigned __int8 *)(v2 + 2128);
  BOOL v4 = *(void *)(v1 + 2112) != 0;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v5 = v4 & ~v3;
  CFStringRef v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    v8[0] = 67109120;
    v8[1] = v5;
    _os_log_debug_impl(&dword_184085000, v6, OS_LOG_TYPE_DEBUG, "CFHTTPAuthentication using AppSSO %{BOOL}d", (uint8_t *)v8, 8u);
  }
  return v5;
}

uint64_t _CFHTTPAuthenticationAppSSOIsPerformDefaultHandlingError(AppSSO *a1, __CFError *a2)
{
  return AppSSO::isPerformDefaultHandlingError(a1, a2);
}

AppSSO *_CFHTTPAuthenticationAppSSOShouldManageURL(AppSSO *a1, const __CFString *a2, const __CFURL *a3, uint64_t a4, const __CFData *a5, double a6)
{
  return AppSSO::shouldManageURL(a1, a2, a3, a4, a5, a6);
}

void _CFHTTPAuthenticationGetAuthHeadersFromAppSSO(const void *a1)
{
  if (a1) {
    CFTypeRef v1 = CFRetain(a1);
  }
  else {
    CFTypeRef v1 = 0;
  }
  CFTypeRef v2 = v1;
  operator new();
}

void sub_1841C4AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  _Unwind_Resume(a1);
}

void _CFHTTPAuthenticationDisableAppSSO()
{
  AppSSO::AppSSODisabled = 1;
}

uint64_t _CFHTTPAuthenticationFailedToGetKerberosTicket(uint64_t a1)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(unsigned __int8 *)(v2 + 224);
}

BOOL _CFHTTPAuthenticationCanRecoverFromKerberosFailure(KerberosAccountBroker *a1, const __CFData *a2, const __CFString *a3)
{
  return KerberosAccountBroker::getKerberosAccountBrokerForApplication(a1, a2, a3) != 0;
}

void _CFHTTPAuthenticationAskAccountsForCreds(uint64_t a1, const void *a2, KerberosAccountBroker *this, __CFData *a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  KerberosAccountBrokerForApplication = (void *)KerberosAccountBroker::getKerberosAccountBrokerForApplication(this, a4, (const __CFString *)this);
  if (KerberosAccountBrokerForApplication)
  {
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    void v18[2] = ___CFHTTPAuthenticationAskAccountsForCreds_block_invoke;
    v18[3] = &unk_1E52531D0;
    v18[6] = a6;
    v18[7] = a7;
    v18[8] = a2;
    v18[9] = this;
    v18[10] = a4;
    v18[4] = a8;
    void v18[5] = a1;
    KerberosAccountBroker::getKerberosCredentialForURL(KerberosAccountBrokerForApplication, a5, a2, (uint64_t)v18);
  }
  else
  {
    uint64_t v17 = *(void (**)(uint64_t, void, void))(a8 + 16);
    v17(a8, 0, 0);
  }
}

void _CFHTTPAuthenticationClearAccountRefreshState(const __CFURL *a1, KerberosAccountBroker *this, __CFData *a3)
{
  KerberosAccountBrokerForApplication = (NSObject **)KerberosAccountBroker::getKerberosAccountBrokerForApplication(this, a3, (const __CFString *)a3);
  if (KerberosAccountBrokerForApplication)
  {
    KerberosAccountBroker::clearAccountRefreshState(KerberosAccountBrokerForApplication, a1);
  }
}

BOOL _CFHTTPAuthenticationIsSecondNTLMTransaction(uint64_t a1)
{
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (a1) {
    uint64_t v2 = (HTTPAuthentication *)(a1 + 16);
  }
  else {
    uint64_t v2 = 0;
  }

  return HTTPAuthentication::isSecondNTLMTransaction(v2);
}

uint64_t _CFHTTPAuthenticationFetchProxyCredentialFromAuthBroker(_CFURLCredential *a1, _CFURLProtectionSpace *a2, const __CFString *a3, uint64_t a4)
{
  if (AuthBrokerAgentClient::AuthBrokerIsAvailable((AuthBrokerAgentClient *)a1))
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    if (a1)
    {
      uint64_t v9 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 56, 0);
      *uint64_t v9 = 0u;
      v9[1] = 0u;
      v9[2] = 0u;
      *((void *)v9 + 6) = 0;
      NetworkProxyCredential::NetworkProxyCredential((NetworkProxyCredential *)v9, v8, a1);
      *(_DWORD *)(v10 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 2;
    }
    else
    {
      uint64_t v9 = 0;
    }
    uint64_t v13 = (NetworkProxyAuthorizationElements *)CFAllocatorAllocate(v8, 80, 0);
    *(_OWORD *)uint64_t v13 = 0u;
    *((_OWORD *)v13 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
    *((_OWORD *)v13 + 2) = 0u;
    *((_OWORD *)v13 + 3) = 0u;
    *((_OWORD *)v13 + 4) = 0u;
    NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(v13, v8, (NetworkProxyCredential *)v9, a2, 0, a3);
    SmartBlockWithArgs<NetworkProxyCredential *>::SmartBlockWithArgs();
  }
  CFStreamError v11 = *(uint64_t (**)(uint64_t, void))(a4 + 16);

  return v11(a4, 0);
}

void sub_1841C51F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void SmartBlockWithArgs<NetworkProxyCredential *>::SmartBlockWithArgs()
{
}

void sub_1841C52F0(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BlockHolderVar<NetworkProxyCredential *> *,SmartBlockWithArgs<NetworkProxyCredential *>::Deleter,std::allocator<BlockHolderVar<NetworkProxyCredential *>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<NetworkProxyCredential *>::invoke_initial && v5 != 0)
  {
    CFRange v7 = (void *)(v1 + (v2 >> 1));
    if (v2) {
      (*(void (**)(void *, void))(*v7
    }
                                               + BlockHolderVar<NetworkProxyCredential *>::invoke_initial))(v7, 0);
    else {
      ((void (*)(void *, void))BlockHolderVar<NetworkProxyCredential *>::invoke_initial)(v7, 0);
    }
  }
  _Block_release(*(const void **)v1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<BlockHolderVar<NetworkProxyCredential *> *,SmartBlockWithArgs<NetworkProxyCredential *>::Deleter,std::allocator<BlockHolderVar<NetworkProxyCredential *>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t BlockHolderVar<NetworkProxyCredential *>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<NetworkProxyCredential *>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

uint64_t BlockHolderVar<NetworkProxyCredential *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

CFAllocatedReferenceCountedObject *SyncClient::SyncClient(CFAllocatedReferenceCountedObject *a1, const __CFAllocator *a2, void *a3, NSObject *a4, const void *a5)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(a1, a2);
  *uint64_t v10 = &unk_1ECF9A920;
  CFDictionaryRef v10[7] = a4;
  dispatch_retain(a4);
  *((void *)a1 + 8) = _Block_copy(a5);
  *((void *)a1 + 6) = CFDataCreateMutable(a2, 0);
  v16[0] = 1;
  v16[1] = a1;
  void v16[2] = CFAllocatedReferenceCountedObject::_retainable_instance_retain;
  v16[3] = CFAllocatedReferenceCountedObject::_retainable_instance_release;
  v16[4] = CFAllocatedReferenceCountedObject::_retainable_copyDescription;
  void v16[5] = 0;
  _WORD v16[6] = SyncClient::synchClientDidReceiveResponse;
  v16[7] = SyncClient::synchClientDidReceiveData;
  v16[8] = 0;
  unsigned char v16[9] = SyncClient::synchClientDidFinishLoading;
  v16[11] = 0;
  v16[12] = 0;
  v16[10] = SyncClient::synchClientDidFail;
  uint64_t v11 = *((void *)a1 + 1);
  __int16 v12 = (void *)MEMORY[0x18531D6D0]();
  uint64_t v13 = CFURLConnectionCreateWithProperties(v11, a3, v16, 0);
  *((void *)a1 + 3) = v13;
  __int16 v14 = dispatch_queue_create("com.apple.CFURLConnectionSynchronous", 0);
  CFURLConnectionSetDelegateDispatchQueue(*((void *)a1 + 3), (uint64_t)v14);
  dispatch_release(v14);
  return a1;
}

void SyncClient::synchClientDidFail(SyncClient *this, CFTypeRef cf, __CFError *a3, const void *a4)
{
  if (!*((void *)a3 + 5))
  {
    CFStringRef v6 = (const void *)*((void *)a3 + 6);
    if (v6) {
      CFRelease(v6);
    }
    *((void *)a3 + 6) = 0;
    if (cf) {
      CFTypeRef v7 = CFRetain(cf);
    }
    else {
      CFTypeRef v7 = 0;
    }
    *((void *)a3 + 5) = v7;
    SyncClient::cleanup(a3);
  }
}

void SyncClient::cleanup(SyncClient *this)
{
  (*(void (**)(SyncClient *))(*(void *)this + 40))(this);
  CFURLConnectionCancel(*((void *)this + 3));
  if (!*((void *)this + 5))
  {
    unint64_t v3 = (void *)*((void *)this + 4);
    if (v3)
    {
      CFURLRef v4 = *(const __CFURL **)([v3 _inner] + 8);
      if (v4)
      {
        CFStringRef v5 = CFURLCopyScheme(v4);
        if (v5)
        {
          CFStringRef v6 = v5;
          if (CFEqual(v5, @"http")
            || CFEqual(v6, (CFStringRef)&unk_1EC0A5D78))
          {
            uint64_t v7 = *(void *)([*((id *)this + 4) _inner] + 88);
            CFAllocatorRef v8 = v7 ? (__CFHTTPMessage *)(v7 - 16) : 0;
            if (v7 && (CFHTTPMessageGetResponseStatusCode(v8) == 401 || CFHTTPMessageGetResponseStatusCode(v8) == 407))
            {
              id v9 = *((id *)this + 4);
              CFRelease(*((CFTypeRef *)this + 4));
              *((void *)this + 4) = 0;
              CFCFStreamError Error = __cfnCreateCFError(*((CFAllocatorRef *)this + 1), @"kCFErrorDomainCFNetwork", -1012, v10, v11, v12, v13, v14, 0);
              *((void *)this + 5) = CFError;
              if (CFError)
              {
                CFDictionaryRef v16 = CFErrorCopyUserInfo(CFError);
                if (v16)
                {
                  CFDictionaryRef v17 = v16;
                  CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                  MutableCFStringRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v16);
                  CFRelease(v17);
                  if (MutableCopy)
                  {
                    CFDictionarySetValue(MutableCopy, @"_kCFURLErrorAuthFailedResponseKey", v9);
                    CFStringRef Domain = CFErrorGetDomain(*((CFErrorRef *)this + 5));
                    CFIndex Code = CFErrorGetCode(*((CFErrorRef *)this + 5));
                    CFErrorRef v22 = CFErrorCreate(v18, Domain, Code, MutableCopy);
                    CFRelease(MutableCopy);
                    unint64_t v23 = (const void *)*((void *)this + 5);
                    if (v23) {
                      CFRelease(v23);
                    }
                    if (v22)
                    {
                      *((void *)this + 5) = CFRetain(v22);
                      CFRelease(v22);
                    }
                    else
                    {
                      *((void *)this + 5) = 0;
                    }
                  }
                }
              }
            }
          }
          CFRelease(v6);
        }
      }
    }
  }
  uint64_t v2 = *((void *)this + 7);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN10SyncClient7cleanupEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
}

uint64_t ___ZN10SyncClient7cleanupEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  (*(void (**)(void))(v1[8] + 16))();
  uint64_t v2 = *(uint64_t (**)(void *))(*v1 + 48);

  return v2(v1);
}

void SyncClient::synchClientDidFinishLoading(SyncClient *this, _CFURLConnection *a2, const void *a3)
{
}

void SyncClient::synchClientDidReceiveData(SyncClient *this, CFDataRef theData, const __CFData *a3, uint64_t a4, const void *a5)
{
  CFStringRef v6 = *(__CFData **)(a4 + 48);
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);

  CFDataAppendBytes(v6, BytePtr, Length);
}

void SyncClient::synchClientDidReceiveResponse(SyncClient *this, _CFURLConnection *a2, _CFURLResponse *a3, const void *a4)
{
  if (*((void *)a3 + 4))
  {
    SyncClient::cleanup((SyncClient *)a3);
  }
  else
  {
    *((void *)a3 + 4) = a2;
  }
}

uint64_t SyncClient::equals(SyncClient *this, const CFAllocatedReferenceCountedObject *a2)
{
  return 0;
}

void SyncClient::~SyncClient(SyncClient *this)
{
  SyncClient::~SyncClient(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  const void *v2;
  const void *v3;
  const void *v4;

  *(void *)this = &unk_1ECF9A920;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }

  CFAllocatorRef v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }
  CFURLRef v4 = (const void *)*((void *)this + 6);
  if (v4) {
    CFRelease(v4);
  }
  dispatch_release(*((dispatch_object_t *)this + 7));
  _Block_release(*((const void **)this + 8));
}

uint64_t CFURLConnectionSendSynchronousRequest(void *a1, void *a2, void *a3, double a4)
{
  CFAllocatorRef v8 = CFGetAllocator(a1);
  id v9 = (void *)[a1 mutableCopy];
  if (*(double *)([v9 _inner] + 24) >= a4)
  {
    uint64_t v10 = [v9 _inner];
    *(_WORD *)(v10 + 64) |= 0x800u;
    *(double *)(v10 + 24) = a4;
  }
  uint64_t v11 = dispatch_semaphore_create(0);
  uint64_t v12 = dispatch_queue_create("com.apple.CFURLConnectionSynchronous", 0);
  uint64_t v33 = 0;
  uint64_t v34 = &v33;
  uint64_t v35 = 0x2020000000;
  uint64_t v36 = 0;
  uint64_t v29 = 0;
  unint64_t v30 = &v29;
  uint64_t v31 = 0x2020000000;
  uint64_t v32 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2020000000;
  uint64_t v28 = 0;
  uint64_t v13 = CFAllocatorAllocate(v8, 72, 0);
  *((_OWORD *)v13 + 2) = 0u;
  *((_OWORD *)v13 + 3) = 0u;
  *(_OWORD *)uint64_t v13 = 0u;
  *((_OWORD *)v13 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  *((void *)v13 + 8) = 0;
  v24[0] = MEMORY[0x1E4F143A8];
  v24[1] = 3221225472;
  v24[2] = __CFURLConnectionSendSynchronousRequest_block_invoke;
  v24[3] = &unk_1E5253220;
  void v24[6] = &v29;
  v24[7] = &v25;
  v24[4] = v11;
  v24[5] = &v33;
  SyncClient::SyncClient((CFAllocatedReferenceCountedObject *)v13, v8, v9, v12, v24);
  CFURLConnectionStart(*((void *)v13 + 3));
  dispatch_semaphore_wait(v11, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v11);
  dispatch_release(v12);
  (*(void (**)(void *))(*(void *)v13 + 48))(v13);
  if (v34[3] || v26[3])
  {
    if (!v9) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  CFCFStreamError Error = __cfnCreateCFError(v8, @"kCFErrorDomainCFNetwork", -1001, v14, v15, v16, v17, v18, 0);
  v26[3] = (uint64_t)CFError;
  if (v9) {
LABEL_6:
  }
    CFRelease(v9);
LABEL_7:
  CFDictionaryRef v19 = (void *)v30[3];
  if (a2) {
    *a2 = v19;
  }
  else {

  }
  Boolean v20 = (const void *)v26[3];
  if (a3)
  {
    *a3 = v20;
  }
  else if (v20)
  {
    CFRelease(v20);
  }
  uint64_t v21 = v34[3];
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
  return v21;
}

void sub_1841C5CCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

intptr_t __CFURLConnectionSendSynchronousRequest_block_invoke(void *a1, CFTypeRef cf, void *a3, const void *a4)
{
  if (cf) {
    CFTypeRef v7 = CFRetain(cf);
  }
  else {
    CFTypeRef v7 = 0;
  }
  *(void *)(*(void *)(a1[5] + 8) + 24) = v7;
  *(void *)(*(void *)(a1[6] + 8) + 24) = a3;
  if (a4) {
    CFTypeRef v8 = CFRetain(a4);
  }
  else {
    CFTypeRef v8 = 0;
  }
  *(void *)(*(void *)(a1[7] + 8) + 24) = v8;
  id v9 = a1[4];

  return dispatch_semaphore_signal(v9);
}

uint64_t serviceTypeToString(int a1)
{
  switch(a1)
  {
    case 1:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVoIP;
      goto LABEL_14;
    case 2:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVideo;
      goto LABEL_14;
    case 3:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeBackground;
      goto LABEL_14;
    case 4:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVoice;
      goto LABEL_14;
    case 5:
      uint64_t v1 = &kCFStreamNetworkServiceTypeBackgroundSystemInitiated;
      goto LABEL_14;
    case 6:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeResponsiveData;
      goto LABEL_14;
    case 7:
      uint64_t v1 = &kCFStreamNetworkServiceTypeOAM;
      goto LABEL_14;
    case 8:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeAVStreaming;
      goto LABEL_14;
    case 9:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeResponsiveAV;
      goto LABEL_14;
    case 10:
      uint64_t v1 = &kCFStreamNetworkServiceTypeNetworkControl;
      goto LABEL_14;
    case 11:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeCallSignaling;
LABEL_14:
      uint64_t result = *v1;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t ___Z24addProhibitedNetworkTypePU27objcproto16OS_nw_parameters8NSObject19nw_interface_type_t_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (MEMORY[0x18531EBC0](a3) != MEMORY[0x1E4F145F8]) {
    return 1;
  }
  uint64_t value = xpc_uint64_get_value(a3);
  uint64_t result = 1;
  if (value == *(_DWORD *)(a1 + 40))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return result;
}

uint64_t ___Z27removeProhibitedNetworkTypePU27objcproto16OS_nw_parameters8NSObject19nw_interface_type_t_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (MEMORY[0x18531EBC0](a3) == MEMORY[0x1E4F145F8] && xpc_uint64_get_value(a3) != *(_DWORD *)(a1 + 40)) {
    xpc_array_append_value(*(xpc_object_t *)(a1 + 32), a3);
  }
  return 1;
}

void addProhibitedNetworkSubtype(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = nw_parameters_copy_prohibited_interface_subtypes();
  if (v3)
  {
    xpc_object_t v4 = (xpc_object_t)v3;
    uint64_t v7 = 0;
    CFTypeRef v8 = &v7;
    uint64_t v9 = 0x2020000000;
    char v10 = 0;
  }
  else
  {
    xpc_object_t v4 = xpc_array_create(0, 0);
    uint64_t v7 = 0;
    CFTypeRef v8 = &v7;
    uint64_t v9 = 0x2020000000;
    char v10 = 0;
    if (!v4) {
      goto LABEL_7;
    }
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___Z27addProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke;
  v5[3] = &unk_1E5253248;
  unsigned int v6 = a2;
  v5[4] = &v7;
  xpc_array_apply(v4, v5);
  if (!*((unsigned char *)v8 + 24))
  {
    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, a2);
    nw_parameters_set_prohibited_interface_subtypes();
  }
  xpc_release(v4);
LABEL_7:
  _Block_object_dispose(&v7, 8);
}

void sub_1841C6068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z27addProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (MEMORY[0x18531EBC0](a3) != MEMORY[0x1E4F145F8]) {
    return 1;
  }
  uint64_t value = xpc_uint64_get_value(a3);
  uint64_t result = 1;
  if (value == *(_DWORD *)(a1 + 40))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return result;
}

void removeProhibitedNetworkSubtype(uint64_t a1, int a2)
{
  uint64_t v3 = nw_parameters_copy_prohibited_interface_subtypes();
  if (v3)
  {
    xpc_object_t v4 = (void *)v3;
    xpc_object_t v5 = xpc_array_create(0, 0);
    if (v5)
    {
      unsigned int v6 = v5;
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3221225472;
      int v7[2] = ___Z30removeProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke;
      v7[3] = &unk_1E5253270;
      int v8 = a2;
      v7[4] = v5;
      xpc_array_apply(v4, v7);
      xpc_release(v4);
      nw_parameters_set_prohibited_interface_subtypes();
      xpc_release(v6);
    }
    else
    {
      xpc_release(v4);
    }
  }
}

uint64_t ___Z30removeProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (MEMORY[0x18531EBC0](a3) == MEMORY[0x1E4F145F8] && xpc_uint64_get_value(a3) != *(_DWORD *)(a1 + 40)) {
    xpc_array_append_value(*(xpc_object_t *)(a1 + 32), a3);
  }
  return 1;
}

uint64_t tlsProtocolVersionForSSLProtocol(SSLProtocol a1, int a2)
{
  int v2 = a1 - 1;
  uint64_t result = 769;
  switch(v2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return result;
    case 6:
      uint64_t result = 770;
      break;
    case 7:
      uint64_t result = 771;
      break;
    case 9:
      uint64_t result = 772;
      break;
    default:
      if (a2) {
        uint64_t result = sec_protocol_options_get_default_min_tls_protocol_version();
      }
      else {
        uint64_t result = sec_protocol_options_get_default_max_tls_protocol_version();
      }
      break;
  }
  return result;
}

void non-virtual thunk to'CFNNSURLRequest::~CFNNSURLRequest(CFNNSURLRequest *this)
{
}

{
  CFNNSURLRequest::~CFNNSURLRequest((CFNNSURLRequest *)((char *)this - 8));
}

void CFNNSURLRequest::~CFNNSURLRequest(CFNNSURLRequest *this)
{
  *(void *)this = &unk_1ECF9D110;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9D158;
  int v2 = (void *)*((void *)this + 2);
  if (v2) {

  }
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9B550;
}

void sub_1841C6358(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

CFStringRef CFNNSURLRequest::copyDebugDesc(CFNNSURLRequest *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFNNSURLRequest@%p>", this);
}

uint64_t BrotliDataDecoder::isInitialized(BrotliDataDecoder *this)
{
  return *((unsigned __int8 *)this + 48);
}

uint64_t BrotliDataDecoderHolder::decoder(BrotliDataDecoderHolder *this)
{
  return (uint64_t)this + 8;
}

void BrotliDataDecoderHolder::~BrotliDataDecoderHolder(BrotliDataDecoderHolder *this)
{
}

{
  BrotliDataDecoder::~BrotliDataDecoder((BrotliDataDecoderHolder *)((char *)this + 8));
}

CFStringRef BrotliDataDecoderHolder::copyDebugDesc(BrotliDataDecoderHolder *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<BrotliDecoder@%p>", this);
}

uint64_t DeflateDataDecoder::isInitialized(DeflateDataDecoder *this)
{
  return *((unsigned __int8 *)this + 120);
}

uint64_t DeflateDataDecoderHolder::decoder(DeflateDataDecoderHolder *this)
{
  return (uint64_t)this + 8;
}

void DeflateDataDecoderHolder::~DeflateDataDecoderHolder(DeflateDataDecoderHolder *this)
{
}

{
  DeflateDataDecoder::~DeflateDataDecoder((DeflateDataDecoderHolder *)((char *)this + 8));
}

CFStringRef DeflateDataDecoderHolder::copyDebugDesc(DeflateDataDecoderHolder *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<GZipDecoder@%p>", this);
}

CFStringRef GZIPDataDecoderHolder::copyDebugDesc(GZIPDataDecoderHolder *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<GZipDecoder@%p>", this);
}

_OWORD *CFURLDataDecoderCreateWithResponse(const __CFAllocator *a1, _CFURLResponse *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = *(void *)([(_CFURLResponse *)a2 _inner] + 88);
  if (!v3) {
    return 0;
  }
  CFStringRef v4 = CFHTTPMessageCopyHeaderFieldValue((CFHTTPMessageRef)(v3 - 16), (CFStringRef)&unk_1EC0A2070);
  if (!v4) {
    return 0;
  }
  CFStringRef v5 = v4;
  unsigned __int8 v6 = determineHTTPEncodingFromString(v4);
  uint64_t v7 = CFURLDataDecoderCreateWithContentEncoding(a1, v6);
  CFRelease(v5);
  return v7;
}

void ___ZN25DownloadDataDecoderHolder5ClassEv_block_invoke()
{
}

void sub_1841C6608(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t MacBinaryDownloadDataDecoder::supportsResume(MacBinaryDownloadDataDecoder *this)
{
  return 1;
}

uint64_t MacBinaryDownloadDataDecoder::getMIMEType(MacBinaryDownloadDataDecoder *this)
{
  return 0x1EC0A4B18;
}

uint64_t MacBinaryDownloadDataDecoder::isInitialized(MacBinaryDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 8);
}

void non-virtual thunk to'MacBinaryDownloadDataDecoderHolder::~MacBinaryDownloadDataDecoderHolder(MacBinaryDownloadDataDecoderHolder *this)
{
  *(void *)this = &unk_1ECF9FBD0;
}

{
  *(void *)this = &unk_1ECF9FBD0;
}

uint64_t MacBinaryDownloadDataDecoderHolder::downloadDecoder(MacBinaryDownloadDataDecoderHolder *this)
{
  return (uint64_t)this + 16;
}

void MacBinaryDownloadDataDecoderHolder::~MacBinaryDownloadDataDecoderHolder(MacBinaryDownloadDataDecoderHolder *this)
{
  *((void *)this + 2) = &unk_1ECF9FBD0;
}

{
  *((void *)this + 2) = &unk_1ECF9FBD0;
}

CFStringRef DownloadDataDecoderHolder::copyDebugDesc(DownloadDataDecoderHolder *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<%sDownloadDataDecoder@%p>", *((void *)this + 1), this);
}

uint64_t BinHexDownloadDataDecoder::supportsResume(BinHexDownloadDataDecoder *this)
{
  return 1;
}

uint64_t BinHexDownloadDataDecoder::getMIMEType(BinHexDownloadDataDecoder *this)
{
  return 0x1EC0A4AE0;
}

uint64_t BinHexDownloadDataDecoder::isInitialized(BinHexDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 8);
}

void non-virtual thunk to'BinHexDownloadDataDecoderHolder::~BinHexDownloadDataDecoderHolder(BinHexDownloadDataDecoderHolder *this)
{
  *(void *)this = &unk_1ECF9FBD0;
}

{
  *(void *)this = &unk_1ECF9FBD0;
}

uint64_t BinHexDownloadDataDecoderHolder::downloadDecoder(BinHexDownloadDataDecoderHolder *this)
{
  return (uint64_t)this + 16;
}

void BinHexDownloadDataDecoderHolder::~BinHexDownloadDataDecoderHolder(BinHexDownloadDataDecoderHolder *this)
{
  *((void *)this + 2) = &unk_1ECF9FBD0;
}

{
  *((void *)this + 2) = &unk_1ECF9FBD0;
}

uint64_t DownloadDataDecoder::createResumeInformation(DownloadDataDecoder *this, const __CFAllocator *a2)
{
  return 0;
}

uint64_t DownloadDataDecoder::supportsResume(DownloadDataDecoder *this)
{
  return 0;
}

uint64_t GZipDownloadDataDecoder::getMIMEType(GZipDownloadDataDecoder *this)
{
  return 0x1EC0A4DB8;
}

uint64_t GZipDownloadDataDecoder::isInitialized(GZipDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 136);
}

uint64_t GZipDownloadDataDecoderHolder::downloadDecoder(GZipDownloadDataDecoderHolder *this)
{
  return (uint64_t)this + 16;
}

void GZipDownloadDataDecoderHolder::~GZipDownloadDataDecoderHolder(GZipDownloadDataDecoderHolder *this)
{
}

{
  GZipDownloadDataDecoder::~GZipDownloadDataDecoder((GZipDownloadDataDecoderHolder *)((char *)this + 16));
}

uint64_t CFURLDownloadDataDecoderDecodeData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
    dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2928);
  }
  if (a1) {
    uint64_t v8 = a1 + 16;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (const void *)(v8 - 16);
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 56))(v8);
  CFAllocatorRef v11 = CFGetAllocator(v9);
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, CFAllocatorRef, uint64_t, uint64_t))(*(void *)v10 + 40);

  return v12(v10, a2, v11, a3, a4);
}

CFDictionaryRef BinHexDownloadDataDecoder::createResumeInformation(BinHexDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 152) || *((unsigned char *)this + 153)) {
    return 0;
  }
  CFDataRef v22 = 0;
  uint64_t v23 = 0;
  CFDictionaryRef v19 = 0;
  uint64_t v20 = 0;
  __int16 valuePtr = *((unsigned char *)this + 48) != 0;
  CFNumberRef v6 = CFNumberCreate(allocator, kCFNumberSInt16Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 36);
  CFNumberRef v8 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 40);
  CFNumberRef v9 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 44);
  CFNumberRef v10 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 32);
  CFDataRef v11 = CFDataCreate(allocator, (const UInt8 *)this + 20, *((unsigned int *)this + 7));
  CFDataRef v12 = CFDataCreate(allocator, (const UInt8 *)this + 9, *((unsigned int *)this + 4));
  keys[0] = @"NSURLDownloadDecoderMIMEType";
  values[0] = (void *)(*(uint64_t (**)(BinHexDownloadDataDecoder *))(*(void *)this + 24))(this);
  values[1] = v6;
  keys[1] = @"NSURLDownloadBinHexDataForkCRCChecked";
  keys[2] = @"NSURLDownloadBinHexCRC";
  values[2] = v7;
  values[3] = v8;
  keys[3] = @"NSURLDownloadBinHexDataForkBytesRemaining";
  keys[4] = @"NSURLDownloadBinHexResourceForkBytesRemaining";
  values[4] = v9;
  values[5] = v10;
  CFNumberRef cf = v10;
  keys[5] = @"NSURLDownloadBinHexDecodedDataOffset";
  keys[6] = @"NSURLDownloadBinHexDecodedData";
  keys[7] = @"NSURLDownloadBinHexEncodedData";
  values[6] = v11;
  values[7] = v12;
  if (*((unsigned char *)this + 50))
  {
    CFDataRef v13 = CFDataCreate(allocator, (const UInt8 *)this + 157, 1);
    CFDictionaryRef v19 = @"NSURLDownloadBinHexFirstCRCByte";
    CFDataRef v22 = v13;
    CFIndex v14 = 9;
  }
  else
  {
    CFDataRef v13 = 0;
    CFIndex v14 = 8;
  }
  if (*((unsigned char *)this + 155))
  {
    CFDataRef v15 = CFDataCreate(allocator, (const UInt8 *)this + 156, 1);
    keys[v14] = @"NSURLDownloadBinHexRepeatByte";
    values[v14++] = v15;
  }
  else
  {
    CFDataRef v15 = 0;
  }
  CFDictionaryRef v3 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, v14, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v6) {
    CFRelease(v6);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v3;
}

__CFDictionary *BinHexDownloadDataDecoder::createFileAttributesDictionary(BinHexDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 152)) {
    return 0;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    *(void *)bytes = *((void *)this + 17);
    LOWORD(v9) = *((_DWORD *)this + 36);
    CFDataRef v5 = CFDataCreate(allocator, bytes, 32);
    if (v5)
    {
      CFDataRef v6 = v5;
      CFDictionaryAddValue(Mutable, @"kCFURLDownloadFinderInfoAttr", v5);
      CFRelease(v6);
    }
  }
  return Mutable;
}

uint64_t BinHexDownloadDataDecoder::isFinishedDecoding(BinHexDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 49);
}

CFStringRef BinHexDownloadDataDecoder::createFilenameWithOriginalFilename(ConstStr255Param pStr, CFAllocatorRef alloc, CFTypeRef cf)
{
  if (pStr[72]) {
    return CFStringCreateWithPascalString(alloc, pStr + 72, 0);
  }
  else {
    return (CFStringRef)CFRetain(cf);
  }
}

BOOL BinHexDownloadDataDecoder::decodeData(BinHexDownloadDataDecoder *this, CFDataRef theData, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  *a4 = 0;
  *a5 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  *((void *)this + 7) = BytePtr;
  *((void *)this + 8) = &BytePtr[CFDataGetLength(theData)];
  if (!*((unsigned char *)this + 152)) {
    BinHexDownloadDataDecoder::decodeDownloadHeader(this);
  }
  *a4 = BinHexDownloadDataDecoder::decodeForkWithData(this, a3, (unsigned int *)this + 10, (unsigned __int8 *)this + 48);
  if (*((unsigned char *)this + 48)) {
    *a5 = BinHexDownloadDataDecoder::decodeForkWithData(this, a3, (unsigned int *)this + 11, (unsigned __int8 *)this + 49);
  }
  return *((unsigned char *)this + 153) == 0;
}

uint64_t BinHexDownloadDataDecoder::decodeDownloadHeader(BinHexDownloadDataDecoder *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  memset(v16, 0, 19);
  memset(__src, 0, sizeof(__src));
  *(_WORD *)CFIndex v14 = 0;
  CFStringRef v4 = (char *)this + 56;
  CFAllocatorRef v2 = (void *)*((void *)this + 7);
  CFDictionaryRef v3 = (unsigned __int8 *)*((void *)v4 + 1);
  while (1)
  {
    uint64_t result = (uint64_t)memchr(v2, 40, v3 - (unsigned char *)v2);
    *((void *)this + 7) = result;
    if (!result) {
      break;
    }
    uint64_t v6 = result;
    if ((v3 - result) <= 0x2C) {
      break;
    }
    uint64_t result = memcmp((const void *)result, "(This file must be converted with BinHex 4.0)", 0x2DuLL);
    if (!result)
    {
      CFNumberRef v7 = (unsigned __int8 *)(v6 + 45);
      *((void *)this + 7) = v6 + 45;
      if ((unsigned __int8 *)(v6 + 45) != v3)
      {
        while (1)
        {
          CFNumberRef v8 = v7 + 1;
          *((void *)this + 7) = v7 + 1;
          int v9 = *v7;
          if (v9 != 10 && v9 != 13) {
            break;
          }
          CFNumberRef v7 = v8;
          if (v8 == v3) {
            goto LABEL_27;
          }
        }
        if (v9 == 58)
        {
          uint64_t result = BinHexDownloadDataDecoder::decodeIntoBuffer(this, (unsigned __int8 *)__src, 1u, 0);
          if (result != 1) {
            *((unsigned char *)this + 153) = 1;
          }
          int v11 = LOBYTE(__src[0]);
          if (LOBYTE(__src[0]) - 64 > 0xFFFFFFC0)
          {
            if (BinHexDownloadDataDecoder::decodeIntoBuffer(this, (unsigned __int8 *)__src + 1, LOBYTE(__src[0]), 0) != v11)*((unsigned char *)this + 153) = 1; {
            uint64_t result = BinHexDownloadDataDecoder::decodeIntoBuffer(this, v16, 0x13u, 0);
            }
            if (result != 19) {
              *((unsigned char *)this + 153) = 1;
            }
            if (!v16[0])
            {
              uint64_t result = BinHexDownloadDataDecoder::decodeIntoBuffer(this, v14, 2u, 1);
              if (result != 2) {
                *((unsigned char *)this + 153) = 1;
              }
              if (*((unsigned __int16 *)this + 18) == bswap32(*(unsigned __int16 *)v14) >> 16)
              {
                uint64_t result = (uint64_t)memcpy((char *)this + 72, __src, LOBYTE(__src[0]) + 1);
                unsigned int v12 = bswap32(*(unsigned int *)&v16[5]);
                *((_DWORD *)this + 34) = bswap32(*(unsigned int *)&v16[1]);
                *((_DWORD *)this + 35) = v12;
                *((_DWORD *)this + 36) = __rev16(*(unsigned __int16 *)&v16[9]);
                unsigned int v13 = bswap32(*(unsigned int *)&v16[15]);
                *((_DWORD *)this + 1_CFNetworkResetHSTSHostsSinceDate(0, 0) = bswap32(*(unsigned int *)&v16[11]);
                *((_DWORD *)this + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v13;
                *((_DWORD *)this + 9) = 0;
                *((unsigned char *)this + 152) = 1;
                return result;
              }
            }
          }
        }
      }
      break;
    }
    CFAllocatorRef v2 = (void *)(v6 + 1);
    *((void *)this + 7) = v6 + 1;
  }
LABEL_27:
  *((unsigned char *)this + 153) = 1;
  return result;
}

__CFData *BinHexDownloadDataDecoder::decodeForkWithData(BinHexDownloadDataDecoder *this, const __CFAllocator *a2, unsigned int *a3, unsigned __int8 *a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](this, a2, a3);
  CFNumberRef v8 = v7;
  uint64_t v9 = v4;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  unsigned int v10 = *v6;
  if (*v6)
  {
    int v11 = v6;
    CFAllocatorRef v12 = v5;
    CFMutableDictionaryRef Mutable = 0;
    while (1)
    {
      unsigned int v14 = v10 >= 0x2000 ? 0x2000 : v10;
      unsigned int v15 = BinHexDownloadDataDecoder::decodeIntoBuffer((BinHexDownloadDataDecoder *)v9, bytes, v14, 0);
      if (!v15) {
        break;
      }
      unsigned int v16 = v15;
      if (!Mutable) {
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(v12, 0);
      }
      CFDataAppendBytes(Mutable, bytes, v16);
      unsigned int v10 = *v11 - v16;
      BOOL v17 = *v11 == v16;
      *int v11 = v10;
      if (v17) {
        goto LABEL_13;
      }
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
LABEL_13:
    if (!*v8)
    {
      if (*(unsigned char *)(v9 + 50))
      {
        bytes[0] = *(unsigned char *)(v9 + 157);
        uint64_t v18 = &bytes[1];
        int v19 = 1;
        uint64_t v20 = (BinHexDownloadDataDecoder *)v9;
        unsigned int v21 = 1;
      }
      else
      {
        int v19 = 2;
        uint64_t v18 = bytes;
        uint64_t v20 = (BinHexDownloadDataDecoder *)v9;
        unsigned int v21 = 2;
      }
      int v22 = BinHexDownloadDataDecoder::decodeIntoBuffer(v20, v18, v21, 1);
      if (v22 == 1 && !*(unsigned char *)(v9 + 50))
      {
        *(unsigned char *)(v9 + 5_CFNetworkResetHSTSHostsSinceDate(0, 0) = 1;
        *(unsigned char *)(v9 + 157) = bytes[0];
      }
      else
      {
        if (v22 != v19 || *(unsigned __int16 *)(v9 + 36) != bswap32(*(unsigned __int16 *)bytes) >> 16) {
          *(unsigned char *)(v9 + 153) = 1;
        }
        *CFNumberRef v8 = 1;
        *(_DWORD *)(v9 + 36) = 0;
        *(unsigned char *)(v9 + 5_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
      }
    }
  }
  return Mutable;
}

uint64_t BinHexDownloadDataDecoder::decodeIntoBuffer(BinHexDownloadDataDecoder *this, unsigned __int8 *a2, unsigned int a3, int a4)
{
  if (*((unsigned char *)this + 153)) {
    return 0;
  }
  unsigned int v35 = *((_DWORD *)this + 4);
  unsigned int v8 = *((_DWORD *)this + 8);
  unsigned int v38 = *((_DWORD *)this + 7);
  uint64_t v9 = *((unsigned int *)this + 9);
  unsigned int v10 = (unsigned __int8 *)*((void *)this + 7);
  int v33 = (int)a2;
  uint64_t v34 = (unsigned __int8 *)*((void *)this + 8);
  int v11 = *((unsigned __int8 *)this + 155);
  unsigned int v12 = *((_DWORD *)this + 37);
  if (!v12)
  {
    uint64_t v14 = *((unsigned __int8 *)this + 156);
    unsigned int v15 = a2;
LABEL_10:
    unsigned int v36 = a2 + a3;
    while (v8 != v38)
    {
      unsigned int v17 = v8 + 1;
      uint64_t v18 = *((unsigned __int8 *)this + v8 + 20);
      if (v18 != 144)
      {
        unsigned int v21 = 1;
        ++v8;
        goto LABEL_19;
      }
      unsigned int v19 = v35;
      if (v17 == v38)
      {
        int v24 = *((unsigned __int8 *)this + 154);
        if (*((unsigned char *)this + 154))
        {
LABEL_44:
          uint64_t result = 0;
          *((unsigned char *)this + 153) = 1;
          return result;
        }
LABEL_26:
        if (v24) {
          BOOL v25 = 1;
        }
        else {
          BOOL v25 = v10 == v34;
        }
        if (v25) {
          goto LABEL_45;
        }
        uint64_t v26 = v10;
        while (1)
        {
          int v27 = *v26++;
          int v28 = sixBitTable[v27];
          if (v28 != 64)
          {
            if (v28 == 65)
            {
              *((unsigned char *)this + 154) = 1;
            }
            else
            {
              if (v28 == 66) {
                goto LABEL_44;
              }
              uint64_t v29 = (char *)this + v19++;
              v29[9] = v28;
            }
            if (v19 == 4 || *((unsigned char *)this + 154)) {
              break;
            }
          }
          unsigned int v10 = v26;
          if (v26 == v34)
          {
            unsigned int v10 = v34;
            goto LABEL_45;
          }
        }
        ++v10;
        unsigned int v30 = v38 - v8;
        if (v38 != v8) {
          memmove((char *)this + 20, (char *)this + v8 + 20, v38 - v8);
        }
        unsigned int v8 = 0;
        unsigned __int8 v31 = *((unsigned char *)this + 11);
        unsigned int v32 = *((unsigned __int8 *)this + 10);
        *((unsigned char *)this + v30 + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = (v31 >> 2) | (16 * v32);
        *((unsigned char *)this + v30 + 2_CFNetworkResetHSTSHostsSinceDate(0, 0) = (v32 >> 4) | (4 * *((unsigned char *)this + 9));
        *((unsigned char *)this + v30 + 22) = *((unsigned char *)this + 12) | (v31 << 6);
        unsigned int v38 = v30 + ((6 * v19) >> 3);
        unsigned int v35 = 0;
      }
      else
      {
        v8 += 2;
        int v20 = *((unsigned __int8 *)this + v17 + 20);
        if (v20)
        {
          if (!v11) {
            goto LABEL_44;
          }
          unsigned int v21 = v20 - 1;
          uint64_t v18 = v14;
        }
        else
        {
          unsigned int v21 = 1;
          uint64_t v18 = 144;
        }
LABEL_19:
        unsigned int v22 = v36 - v15;
        if (v21 >= v36 - v15) {
          uint64_t v23 = v22;
        }
        else {
          uint64_t v23 = v21;
        }
        uint64_t v14 = v18;
        uint64_t v9 = handleRepeatCount(v23, v18, v9, v15, a4);
        v15 += v23;
        int v11 = 1;
        if (v21 > v22)
        {
          *((_DWORD *)this + 37) = v21 - v23;
          goto LABEL_43;
        }
      }
    }
    int v24 = *((unsigned __int8 *)this + 154);
    unsigned int v8 = v38;
    unsigned int v19 = v35;
    goto LABEL_26;
  }
  if (v12 >= a3) {
    uint64_t v13 = a3;
  }
  else {
    uint64_t v13 = v12;
  }
  uint64_t v14 = *((unsigned __int8 *)this + 156);
  uint64_t v9 = handleRepeatCount(v13, *((unsigned __int8 *)this + 156), v9, a2, a4);
  unsigned int v15 = &a2[v13];
  int v16 = *((_DWORD *)this + 37) - v13;
  *((_DWORD *)this + 37) = v16;
  if (!v16) {
    goto LABEL_10;
  }
LABEL_43:
  unsigned int v19 = v35;
LABEL_45:
  *((_DWORD *)this + 4) = v19;
  *((_DWORD *)this + 7) = v38;
  *((_DWORD *)this + 8) = v8;
  *((_DWORD *)this + 9) = v9;
  *((unsigned char *)this + 156) = v14;
  *((unsigned char *)this + 155) = v11;
  uint64_t result = (v15 - v33);
  *((void *)this + 7) = v10;
  return result;
}

uint64_t handleRepeatCount(int a1, unsigned int a2, uint64_t a3, unsigned __int8 *a4, int a5)
{
  if (a1)
  {
    if (a5) {
      unsigned int v5 = 0;
    }
    else {
      unsigned int v5 = a2;
    }
    do
    {
      *a4 = a2;
      int v6 = 8;
      unsigned int v7 = v5;
      do
      {
        int v8 = 2 * a3;
        if ((a3 & 0x8000) != 0) {
          int v8 = (2 * a3) & 0xFFFE ^ 0x1021;
        }
        a3 = v8 ^ (v7 >> 7);
        unsigned int v7 = 2 * (v7 & 0x7F);
        --v6;
      }
      while (v6);
      ++a4;
      --a1;
    }
    while (a1);
  }
  return a3;
}

BOOL BinHexDownloadDataDecoder::canDecodeHeaderData(BinHexDownloadDataDecoder *this, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  *((void *)this + 7) = BytePtr;
  *((void *)this + 8) = &BytePtr[CFDataGetLength(theData)];
  BinHexDownloadDataDecoder::decodeDownloadHeader(this);
  BOOL result = *((unsigned char *)this + 153) == 0;
  *((_DWORD *)this + 4) = 0;
  *((unsigned char *)this + 72) = 0;
  *(void *)((char *)this + 36) = 0;
  *(void *)((char *)this + 28) = 0;
  *(void *)((char *)this + 43) = 0;
  *(void *)((char *)this + 148) = 0;
  return result;
}

void BinHexDownloadDataDecoder::~BinHexDownloadDataDecoder(BinHexDownloadDataDecoder *this)
{
  *(void *)this = &unk_1ECF9FBD0;
  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9FBD0;
}

uint64_t DownloadDataDecoder::createFileAttributesDictionary(DownloadDataDecoder *this, const __CFAllocator *a2)
{
  return 0;
}

uint64_t DownloadDataDecoder::isFinishedDecoding(DownloadDataDecoder *this)
{
  return 1;
}

uint64_t DownloadDataDecoder::createFilenameWithOriginalFilename(DownloadDataDecoder *this, const __CFAllocator *a2, const __CFString *a3)
{
  return 0;
}

uint64_t DownloadDataDecoder::decodeData(DownloadDataDecoder *this, const __CFData *a2, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  return 0;
}

uint64_t DownloadDataDecoder::canDecodeHeaderData(DownloadDataDecoder *this, const __CFData *a2)
{
  return 0;
}

uint64_t DownloadDataDecoder::isInitialized(DownloadDataDecoder *this)
{
  return 0;
}

void sub_1841C7724(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841C78A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841C7988(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841C7C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

void sub_1841C7D3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841C80B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

void sub_1841C8344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  _Unwind_Resume(a1);
}

void sub_1841C8400(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841C8770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

void sub_1841C8870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841C8AE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841C8C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  _Block_object_dispose(&a17, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__3154(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = *(void *)(a2 + 40);
  *(void *)(a2 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  return result;
}

void __Block_byref_object_dispose__3155(uint64_t a1)
{
}

void sub_1841C8F4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__CFData *DeflateDataDecoder::decodeData(DeflateDataDecoder *this, const __CFAllocator *a2, const __CFData *a3, unsigned __int8 *a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](this, a2, a3);
  int v6 = v5;
  CFDataRef v8 = v7;
  uint64_t v9 = v4;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v10, 0);
  *int v6 = 0;
  if (!Mutable) {
    return Mutable;
  }
  *(void *)(v9 + 8) = CFDataGetBytePtr(v8);
  int Length = CFDataGetLength(v8);
  *(_DWORD *)(v9 + 16) = Length;
  if (!Length) {
    return Mutable;
  }
  int v13 = 1;
  while (1)
  {
    while (1)
    {
      *(void *)(v9 + 32) = v20;
      *(_DWORD *)(v9 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0x4000;
      unsigned int v14 = inflate((z_streamp)(v9 + 8), 0);
      unsigned int v15 = v14;
      int v16 = *(_DWORD *)(v9 + 40);
      if (*(_DWORD *)(v9 + 16)) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v14 == -5;
      }
      if (v17) {
        goto LABEL_17;
      }
      if (v14 > 1) {
        break;
      }
      CFDataAppendBytes(Mutable, v20, 0x4000 - v16);
      if (v15 == 1) {
        return Mutable;
      }
      if (!*(_DWORD *)(v9 + 16)) {
        goto LABEL_17;
      }
    }
    if (v14 != -3 || !v13) {
      goto LABEL_20;
    }
    CFDataSetLength(Mutable, 0);
    inflateEnd((z_streamp)(v9 + 8));
    if (inflateInit2_((z_streamp)(v9 + 8), -15, "1.2.12", 112)) {
      break;
    }
    *(void *)(v9 + 8) = CFDataGetBytePtr(v8);
    int v18 = CFDataGetLength(v8);
    int v13 = 0;
    *(_DWORD *)(v9 + 16) = v18;
    if (!v18)
    {
LABEL_17:
      if (v16) {
        return Mutable;
      }
    }
  }
  *(unsigned char *)(v9 + 12_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
LABEL_20:
  CFRelease(Mutable);
  return 0;
}

void DeflateDataDecoder::~DeflateDataDecoder(DeflateDataDecoder *this)
{
  DeflateDataDecoder::~DeflateDataDecoder(this);

  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9F168;
  if (*((unsigned char *)this + 120)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  *(void *)this = &unk_1ECF9AAB8;
}

void sub_1841C91E4(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9AAB8;
  _Unwind_Resume(a1);
}

uint64_t DataDecoder::decodeData(DataDecoder *this, const __CFAllocator *a2, const __CFData *a3, unsigned __int8 *a4)
{
  *a4 = 0;
  return 0;
}

uint64_t DataDecoder::isInitialized(DataDecoder *this)
{
  return 0;
}

void DataDecoder::~DataDecoder(DataDecoder *this)
{
  *(void *)this = &unk_1ECF9AAB8;
  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9AAB8;
}

__CFDictionary *GZipDownloadDataDecoder::createFileAttributesDictionary(GZipDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  if (!*((void *)this + 16)) {
    return 0;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFDateRef v5 = CFDateCreate(allocator, (double)*((unint64_t *)this + 16) - *MEMORY[0x1E4F1CF78]);
    if (v5)
    {
      CFDateRef v6 = v5;
      CFDictionaryAddValue(Mutable, @"kCFURLDownloadFileModDate", v5);
    }
    else
    {
      CFDateRef v6 = Mutable;
      CFMutableDictionaryRef Mutable = 0;
    }
    CFRelease(v6);
  }
  return Mutable;
}

uint64_t GZipDownloadDataDecoder::isFinishedDecoding(GZipDownloadDataDecoder *this)
{
  if (*((_DWORD *)this + 4) | *((unsigned __int8 *)this + 138)) {
    return *((unsigned __int8 *)this + 138);
  }
  else {
    return 1;
  }
}

CFStringRef GZipDownloadDataDecoder::createFilenameWithOriginalFilename(GZipDownloadDataDecoder *this, CFAllocatorRef alloc, const __CFString *a3)
{
  CFStringRef v4 = (const __CFString *)*((void *)this + 15);
  if (v4)
  {
    return CFStringCreateCopy(alloc, v4);
  }
  CFStringRef ExtensionFromFilename = createExtensionFromFilename(a3);
  if (ExtensionFromFilename)
  {
    CFStringRef v8 = ExtensionFromFilename;
    if (CFStringCompare(ExtensionFromFilename, @"gz", 1uLL) && CFStringCompare(v8, @"gzip", 1uLL))
    {
      if (CFStringCompare(v8, @"tgz", 1uLL))
      {
        if (CFStringCompare(v8, @"cpgz", 1uLL))
        {
          CFStringRef v9 = (const __CFString *)CFRetain(a3);
LABEL_13:
          CFStringRef v12 = v9;
LABEL_23:
          CFRelease(v8);
          return v12;
        }
        int v13 = @"cpio";
      }
      else
      {
        int v13 = @"tar";
      }
      CFIndex Length = CFStringGetLength(a3);
      CFIndex v15 = CFStringGetLength(v8);
      if (Length > v15 + 1)
      {
        v20.CFIndex length = Length + ~v15;
        v20.CFIndex location = 0;
        CFStringRef v16 = CFStringCreateWithSubstring(alloc, a3, v20);
        if (v16)
        {
          CFStringRef v17 = v16;
          CFStringRef v12 = CFStringCreateWithFormat(alloc, 0, @"%@.%@", v16, v13);
          CFRelease(v17);
          goto LABEL_23;
        }
      }
    }
    else
    {
      CFIndex v10 = CFStringGetLength(a3);
      CFIndex v11 = CFStringGetLength(v8);
      if (v10 > v11 + 1)
      {
        v19.CFIndex length = v10 + ~v11;
        v19.CFIndex location = 0;
        CFStringRef v9 = CFStringCreateWithSubstring(alloc, a3, v19);
        goto LABEL_13;
      }
    }
    CFStringRef v12 = 0;
    goto LABEL_23;
  }

  return (CFStringRef)CFRetain(a3);
}

BOOL GZipDownloadDataDecoder::decodeData(GZipDownloadDataDecoder *this, CFDataRef theData, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  CFDataRef v8 = 0;
  LODWORD(v13) = 0;
  *a5 = 0;
  if (!*((unsigned char *)this + 137))
  {
    int v9 = gzipDecodeHeader(theData, (uInt *)&v13, a3, (const __CFString **)this + 15, (unint64_t *)this + 16, &v12);
    *((unsigned char *)this + 137) = v9;
    if (!v9)
    {
      GzipDecodedCFDataRef Data = 0;
      goto LABEL_5;
    }
    CFDataRef v8 = (const __CFData *)v13;
  }
  GzipDecodedCFDataRef Data = (const __CFData *)createGzipDecodedData((z_stream_s *)((char *)this + 8), (unsigned __int8 *)this + 138, theData, v8);
LABEL_5:
  *a4 = GzipDecodedData;
  return GzipDecodedData != 0;
}

uint64_t GZipDownloadDataDecoder::canDecodeHeaderData(GZipDownloadDataDecoder *this, const __CFData *a2)
{
  return gzipDecodeHeader(a2, 0, 0, 0, 0, &v3);
}

void GZipDownloadDataDecoder::~GZipDownloadDataDecoder(GZipDownloadDataDecoder *this)
{
  GZipDownloadDataDecoder::~GZipDownloadDataDecoder(this);

  JUMPOUT(0x18531B6D0);
}

{
  const void *v2;

  *(void *)this = &unk_1ECFA2928;
  if (*((unsigned char *)this + 136)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  CFAllocatorRef v2 = (const void *)*((void *)this + 15);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)this = &unk_1ECF9FBD0;
}

void sub_1841C96D0(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9FBD0;
  _Unwind_Resume(a1);
}

CFDictionaryRef MacBinaryDownloadDataDecoder::createResumeInformation(MacBinaryDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)CFGregorianDate values = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  CFNumberRef v4 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 80);
  CFNumberRef v5 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 12);
  CFNumberRef v6 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 84);
  CFNumberRef v7 = v6;
  if (v4 && v5 && v6)
  {
    *(void *)&long long v11 = @"NSURLDownloadDecoderMIMEType";
    *((void *)&v11 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = @"NSURLDownloadMacBinaryDataForkLength";
    *(void *)&long long v12 = @"NSURLDownloadMacBinaryOffset";
    *((void *)&v12 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = @"NSURLDownloadMacBinaryResourceForkLength";
    values[0] = (void *)(*(uint64_t (**)(MacBinaryDownloadDataDecoder *))(*(void *)this + 24))(this);
    values[1] = v4;
    *(void *)&long long v14 = v5;
    *((void *)&v14 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v7;
    CFDictionaryRef v8 = CFDictionaryCreate(allocator, (const void **)&v11, (const void **)values, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  else
  {
    CFDictionaryRef v8 = 0;
    CFDictionaryRef v9 = 0;
    if (!v4) {
      goto LABEL_7;
    }
  }
  CFRelease(v4);
  CFDictionaryRef v9 = v8;
LABEL_7:
  if (v5) {
    CFRelease(v5);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v9;
}

__CFDictionary *MacBinaryDownloadDataDecoder::createFileAttributesDictionary(MacBinaryDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFAbsoluteTime at = 0.0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v14 = 0;
    *(void *)bytes = *(void *)((char *)this + 100);
    LOWORD(v14) = *((_WORD *)this + 44);
    LOWORD(v16) = *((_WORD *)this + 45);
    CFDataRef v5 = CFDataCreate(allocator, bytes, 32);
    if (v5)
    {
      CFDataRef v6 = v5;
      CFDictionaryAddValue(Mutable, @"kCFURLDownloadFinderInfoAttr", v5);
      CFRelease(v6);
    }
    if (convertLocalMacTimeToCFAbsoluteTime(*((_DWORD *)this + 23), &at))
    {
      CFDateRef v7 = CFDateCreate(allocator, at);
      if (v7)
      {
        CFDateRef v8 = v7;
        CFDictionaryAddValue(Mutable, @"kCFURLDownloadFileCreateDate", v7);
        CFRelease(v8);
      }
    }
    if (convertLocalMacTimeToCFAbsoluteTime(*((_DWORD *)this + 24), &at))
    {
      CFDateRef v9 = CFDateCreate(allocator, at);
      if (v9)
      {
        CFDateRef v10 = v9;
        CFDictionaryAddValue(Mutable, @"kCFURLDownloadFileModDate", v9);
        CFRelease(v10);
      }
    }
  }
  return Mutable;
}

CFTimeZoneRef convertLocalMacTimeToCFAbsoluteTime(unsigned int a1, double *a2)
{
  CFTimeZoneRef result = CFTimeZoneCopySystem();
  if (result)
  {
    CFTimeZoneRef v5 = result;
    CFAbsoluteTime v6 = (double)a1 - *MEMORY[0x1E4F1CF68];
    CFTimeInterval SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(result, v6);
    double v8 = CFTimeZoneGetSecondsFromGMT(v5, v6 - SecondsFromGMT);
    CFRelease(v5);
    *a2 = v6 - v8;
    return (const __CFTimeZone *)1;
  }
  return result;
}

BOOL MacBinaryDownloadDataDecoder::isFinishedDecoding(MacBinaryDownloadDataDecoder *this)
{
  return *((_DWORD *)this + 3) >= (int)(((*((_DWORD *)this + 20) + 255) & 0xFFFFFF80) + *((_DWORD *)this + 21));
}

CFStringRef MacBinaryDownloadDataDecoder::createFilenameWithOriginalFilename(const unsigned __int8 *pStr, CFAllocatorRef alloc, CFTypeRef cf)
{
  if (pStr[16]) {
    return CFStringCreateWithPascalString(alloc, pStr + 16, *((__int16 *)pStr + 54));
  }
  else {
    return (CFStringRef)CFRetain(cf);
  }
}

uint64_t MacBinaryDownloadDataDecoder::decodeData(MacBinaryDownloadDataDecoder *this, CFDataRef theData, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  v35[1] = *MEMORY[0x1E4F143B8];
  *a4 = 0;
  *a5 = 0;
  CFDataRef Length = (const __CFData *)CFDataGetLength(theData);
  signed int v13 = (int)Length;
  if (*((_DWORD *)this + 3))
  {
    unsigned int v14 = *((_DWORD *)this + 20);
    unsigned int v15 = *((_DWORD *)this + 21);
  }
  else
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFDataRef Length = (const __CFData *)memcpy((char *)this + 16, BytePtr + 1, BytePtr[1] + 1);
    *((_DWORD *)this + 25) = bswap32(*(_DWORD *)(BytePtr + 65));
    *((_DWORD *)this + 26) = bswap32(*(_DWORD *)(BytePtr + 69));
    unsigned int v14 = bswap32(*(_DWORD *)(BytePtr + 83));
    *((_DWORD *)this + 2_CFNetworkResetHSTSHostsSinceDate(0, 0) = v14;
    unsigned int v15 = bswap32(*(_DWORD *)(BytePtr + 87));
    *((_DWORD *)this + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v15;
    *((_DWORD *)this + 23) = bswap32(*(_DWORD *)(BytePtr + 91));
    *((_DWORD *)this + 24) = bswap32(*(_DWORD *)(BytePtr + 95));
    __int16 v17 = BytePtr[101] | (BytePtr[73] << 8);
    *((_WORD *)this + 44) = v17;
    UInt8 v18 = BytePtr[107];
    *((_WORD *)this + 44) = v17 & 0xAC4E;
    *((_WORD *)this + 45) = v18 & 4;
    if (BytePtr[102] == 109 && BytePtr[103] == 66 && BytePtr[104] == 73 && BytePtr[105] == 78) {
      *((_WORD *)this + 54) = BytePtr[106];
    }
  }
  int v19 = v14 + 128;
  int v20 = *((_DWORD *)this + 3);
  if (v14) {
    BOOL v21 = v19 <= v20;
  }
  else {
    BOOL v21 = 1;
  }
  if (v21)
  {
    unsigned int v22 = v15;
  }
  else
  {
    unsigned int v22 = v15;
    if (v20 + v13 >= 129)
    {
      if (v20 >= 128) {
        uint64_t v23 = 0;
      }
      else {
        uint64_t v23 = (128 - v20);
      }
      signed int v24 = v19 - v20;
      if (v24 >= v13) {
        signed int v24 = v13;
      }
      int v25 = v24 - v23;
      uint64_t v26 = CFDataGetBytePtr(theData);
      CFDataRef Length = CFDataCreate(a3, &v26[v23], v25);
      *a4 = Length;
      int v20 = *((_DWORD *)this + 3);
      unsigned int v22 = *((_DWORD *)this + 21);
    }
  }
  if (v22)
  {
    signed int v27 = (v14 + 255) & 0xFFFFFF80;
    if ((int)(v27 + v15) > v20 && v20 + v13 > v27)
    {
      CFIndex v29 = (v27 - v20) & ~((v27 - v20) >> 31);
      if ((int)(v27 + v15 - v20) >= v13) {
        unsigned int v30 = v13;
      }
      else {
        unsigned int v30 = v27 + v15 - v20;
      }
      size_t v31 = (int)(v30 - v29);
      MEMORY[0x1F4188790](Length, v11, v12);
      int v33 = (UInt8 *)v35 - v32;
      bzero((char *)v35 - v32, v31);
      v36.CFIndex location = v29;
      v36.CFIndex length = v31;
      CFDataGetBytes(theData, v36, v33);
      *a5 = CFDataCreate(a3, v33, v31);
      int v20 = *((_DWORD *)this + 3);
    }
  }
  *((_DWORD *)this + 3) = v20 + v13;
  return 1;
}

BOOL MacBinaryDownloadDataDecoder::canDecodeHeaderData(MacBinaryDownloadDataDecoder *this, CFDataRef theData)
{
  if (CFDataGetLength(theData) < 128) {
    return 0;
  }
  BytePtr = CFDataGetBytePtr(theData);
  if (*BytePtr || BytePtr[74] || BytePtr[1] - 64 < 0xFFFFFFC1) {
    return 0;
  }
  if (BytePtr[102] != 109 || BytePtr[103] != 66 || BytePtr[104] != 73 || BytePtr[105] != 78)
  {
    uint64_t v4 = 0;
    unsigned __int16 v5 = 0;
    do
      unsigned __int16 v5 = gMagic[((unsigned __int16)(v5 ^ (BytePtr[v4++] << 8)) >> 8)] ^ (v5 << 8);
    while (v4 != 124);
    if ((BytePtr[125] | (BytePtr[124] << 8)) != v5)
    {
      if (!BytePtr[82] && !BytePtr[126] && !BytePtr[127])
      {
        uint64_t v8 = 0;
        while (!BytePtr[v8 + 99])
        {
          if (++v8 == 27)
          {
            uint64_t v6 = 0;
            int v9 = bswap32(*(_DWORD *)(BytePtr + 83));
            if (v9 < 0x800000)
            {
              int v10 = bswap32(*(_DWORD *)(BytePtr + 87));
              if (v10 < 0x800000) {
                return (v9 | v10) != 0;
              }
            }
            return v6;
          }
        }
      }
      return 0;
    }
  }
  return BytePtr[123] < 0x82u;
}

void MacBinaryDownloadDataDecoder::~MacBinaryDownloadDataDecoder(MacBinaryDownloadDataDecoder *this)
{
  *(void *)this = &unk_1ECF9FBD0;
  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9FBD0;
}

uint64_t _CFNetworkDoesNeedProxy(const __CFString *a1, const __CFArray *a2, const void *a3)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (const void *)*MEMORY[0x1E4F1CFC8];
  if (a3) {
    unsigned __int16 v5 = a3;
  }
  else {
    unsigned __int16 v5 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  if (!v5)
  {
    CFDateRef v7 = (const void *)*MEMORY[0x1E4F1CFD0];
    goto LABEL_10;
  }
  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 == CFNumberGetTypeID())
  {
    LODWORD(valuePtr) = 0;
    CFNumberGetValue((CFNumberRef)v5, kCFNumberSInt32Type, &valuePtr);
    CFDateRef v7 = (const void *)*MEMORY[0x1E4F1CFD0];
    if (!valuePtr) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  CFDateRef v7 = (const void *)*MEMORY[0x1E4F1CFD0];
  if ((const void *)*MEMORY[0x1E4F1CFD0] == v5) {
LABEL_10:
  }
    uint64_t v4 = v7;
LABEL_11:
  if (CFStringCompare(a1, @"localhost", 1uLL) == kCFCompareEqualTo) {
    return 0;
  }
  if (CFStringCompare(a1, @"127.0.0.1", 1uLL) == kCFCompareEqualTo) {
    return 0;
  }
  if (CFStringCompare(a1, @"::1", 1uLL) == kCFCompareEqualTo) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  if (v4)
  {
    if (CFEqual(v4, v7) && CFStringFind(a1, @".", 0).location == -1) {
      return 0;
    }
  }
  if (!a2) {
    return 1;
  }
  CFIndex Count = CFArrayGetCount(a2);
  if (!Count) {
    return 1;
  }
  if (CFStringHasSuffix(a1, @"."))
  {
    CFAllocatorRef v9 = CFGetAllocator(a1);
    CFIndex v10 = CFStringGetLength(a1);
    CFStringRef theString = CFStringCreateMutableCopy(v9, v10, a1);
    CFIndex v11 = CFStringGetLength(a1);
    v68.CFIndex length = CFStringGetLength(@".");
    v68.CFIndex location = v11 - 1;
    CFStringDelete(theString, v68);
    a1 = theString;
  }
  else
  {
    CFStringRef theString = 0;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, a1, @".");
  CFArrayRef v15 = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings) {
    goto LABEL_30;
  }
  CFIndex v16 = CFArrayGetCount(ArrayBySeparatingStrings);
  CFIndex v17 = v16;
  if (v16 == 5)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v15, 4);
    BOOL v58 = 0;
    if (CFStringGetLength(ValueAtIndex) || Length >= 17)
    {
      uint64_t v18 = 5;
      goto LABEL_32;
    }
LABEL_114:
    CFAllocatorRef v52 = CFGetAllocator(a1);
    CFAllocatorRef valuePtr = v52;
    uint64_t v64 = 1023;
    if (a1)
    {
      uint64_t v53 = _CFStringGetOrCreateCString(v52, a1, v66, &v64, 0x600u);
    }
    else
    {
      v66[0] = 0;
      uint64_t v64 = 0;
      uint64_t v53 = v66;
    }
    ptr = v53;
    uint64_t v18 = v17;
    BOOL v58 = inet_pton(2, (const char *)v53, &v62) == 1;
    if (ptr && v66 != ptr) {
      CFAllocatorDeallocate(valuePtr, ptr);
    }
    goto LABEL_32;
  }
  uint64_t v18 = v16;
  if (v16 == 4)
  {
    if (Length > 16)
    {
      BOOL v58 = 0;
      uint64_t v18 = 4;
      goto LABEL_32;
    }
    goto LABEL_114;
  }
  if (!v16)
  {
    CFRelease(v15);
    CFArrayRef v15 = 0;
LABEL_30:
    uint64_t v18 = 0;
  }
  BOOL v58 = 0;
LABEL_32:
  if (Count >= 1)
  {
    CFIndex v19 = 0;
    uint64_t v57 = v18;
    CFIndex idx = v18 - 1;
    while (1)
    {
      CFStringRef v20 = (const __CFString *)CFArrayGetValueAtIndex(a2, v19);
      if (CFStringHasSuffix(v20, @"."))
      {
        CFAllocatorRef v21 = CFGetAllocator(v20);
        CFIndex v22 = CFStringGetLength(v20);
        MutableCFStringRef Copy = CFStringCreateMutableCopy(v21, v22, v20);
        CFIndex v24 = CFStringGetLength(v20);
        v69.CFIndex length = CFStringGetLength(@".");
        v69.CFIndex location = v24 - 1;
        CFStringDelete(MutableCopy, v69);
        CFStringRef v20 = MutableCopy;
      }
      else
      {
        MutableCFStringRef Copy = 0;
      }
      if (CFStringCompare(a1, v20, 1uLL))
      {
        if (!v58
          || (v70.CFIndex length = CFStringGetLength(v20),
              v70.CFIndex location = 0,
              !CFStringFindWithOptions(v20, @"/", v70, 0, 0)))
        {
          if (v15)
          {
            CFArrayRef v39 = CFStringCreateArrayBySeparatingStrings(0, v20, @".");
            CFArrayRef v26 = v39;
            if (v39)
            {
              CFIndex v40 = CFArrayGetCount(v39);
              if (v40 >= 2 && v57 >= 1)
              {
                CFIndex v42 = v40 - 1;
                CFIndex v43 = idx;
                while (1)
                {
                  CFStringRef v44 = (const __CFString *)CFArrayGetValueAtIndex(v15, v43);
                  CFStringRef v45 = (const __CFString *)CFArrayGetValueAtIndex(v26, v42);
                  CFStringRef v46 = v45;
                  if (!v42 && !CFStringGetLength(v45)) {
                    CFStringRef v46 = @"*";
                  }
                  if (CFStringCompare(v44, v46, 1uLL))
                  {
                    if (CFStringCompare(v46, @"*", 1uLL)) {
                      break;
                    }
                    while (1)
                    {
                      CFStringRef v47 = (const __CFString *)CFArrayGetValueAtIndex(v26, v42);
                      CFStringRef v48 = v47;
                      if (!v42 && !CFStringGetLength(v47)) {
                        CFStringRef v48 = @"*";
                      }
                      if (CFStringCompare(v48, @"*", 1uLL)) {
                        break;
                      }
                      BOOL v49 = v42-- <= 0;
                      if (v49) {
                        goto LABEL_92;
                      }
                    }
                    if (v43 < 0) {
                      break;
                    }
                    while (1)
                    {
                      CFStringRef v50 = (const __CFString *)CFArrayGetValueAtIndex(v15, v43);
                      if (CFStringCompare(v48, v50, 1uLL) == kCFCompareEqualTo) {
                        break;
                      }
                      BOOL v49 = v43-- <= 0;
                      if (v49) {
                        goto LABEL_82;
                      }
                    }
                  }
                  else
                  {
                    if (!(v43 | v42))
                    {
LABEL_92:
                      BOOL v12 = 0;
                      goto LABEL_83;
                    }
                    --v43;
                    --v42;
                  }
                  BOOL v12 = 1;
                  if (v43 < 0 || v42 < 0) {
                    goto LABEL_83;
                  }
                }
              }
LABEL_82:
              BOOL v12 = 1;
              goto LABEL_83;
            }
          }
LABEL_87:
          BOOL v12 = 1;
          if (!MutableCopy) {
            goto LABEL_89;
          }
LABEL_88:
          CFRelease(MutableCopy);
          goto LABEL_89;
        }
        CFArrayRef v25 = CFStringCreateArrayBySeparatingStrings(0, v20, @"/");
        CFArrayRef v26 = v25;
        if (!v25) {
          goto LABEL_87;
        }
        if (CFArrayGetCount(v25) != 2) {
          goto LABEL_82;
        }
        CFStringRef v27 = (const __CFString *)CFArrayGetValueAtIndex(v26, 1);
        IntCFNumberRef Value = CFStringGetIntValue(v27);
        if ((IntValue - 1) > 0x1F) {
          goto LABEL_82;
        }
        CFStringRef v28 = (const __CFString *)CFArrayGetValueAtIndex(v26, 0);
        CFArrayRef v29 = CFStringCreateArrayBySeparatingStrings(0, v28, @".");
        CFArrayRef v30 = v29;
        if (!v29) {
          goto LABEL_82;
        }
        CFIndex v31 = CFArrayGetCount(v29);
        if (v31 > 4)
        {
          BOOL v12 = 1;
        }
        else
        {
          CFAllocatorRef v32 = CFGetAllocator(a1);
          CFStringRef v33 = (const __CFString *)CFArrayGetValueAtIndex(v30, 0);
          CFMutableStringRef v34 = CFStringCreateMutableCopy(v32, 0, v33);
          for (CFIndex i = 1; i != 4; ++i)
          {
            if (i < v31 && (CFStringRef v36 = (const __CFString *)CFArrayGetValueAtIndex(v30, i), CFStringGetLength(v36))) {
              CFStringAppendFormat(v34, 0, @".%@", v36);
            }
            else {
              CFStringAppend(v34, @".0");
            }
          }
          if (CFStringGetLength(v34) > 16)
          {
            BOOL v12 = 1;
          }
          else
          {
            CFAllocatorRef v37 = CFGetAllocator(a1);
            CFAllocatorRef valuePtr = v37;
            uint64_t v64 = 1023;
            if (v34)
            {
              unsigned int v38 = _CFStringGetOrCreateCString(v37, v34, v66, &v64, 0x600u);
            }
            else
            {
              v66[0] = 0;
              uint64_t v64 = 0;
              unsigned int v38 = v66;
            }
            ptr = v38;
            BOOL v12 = inet_pton(2, (const char *)v38, &v61) != 1
               || (bswap32(v62) & (~(-1 << IntValue) << -(char)IntValue)) != bswap32(v61);
            if (ptr && v66 != ptr) {
              CFAllocatorDeallocate(valuePtr, ptr);
            }
          }
          if (v34) {
            CFRelease(v34);
          }
        }
        CFRelease(v30);
LABEL_83:
        CFRelease(v26);
      }
      else
      {
        BOOL v12 = 0;
      }
      if (MutableCopy) {
        goto LABEL_88;
      }
LABEL_89:
      if (v12 && ++v19 < Count) {
        continue;
      }
      goto LABEL_106;
    }
  }
  BOOL v12 = 1;
LABEL_106:
  if (theString) {
    CFRelease(theString);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v12;
}

void sub_1841CA698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFAllocatorRef allocator,uint64_t a21,void *ptr)
{
  if (ptr)
  {
    if (a11 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef CFNetworkCopyProxiesForURL(CFURLRef url, CFDictionaryRef proxySettings)
{
  return (CFArrayRef)__CFNetworkCopyProxiesForURLWithInterface(url, proxySettings, 0);
}

CFDictionaryRef CFNetworkCopySystemProxySettings(void)
{
  if (_CFNetworkCopySystemProxySettings::onceToken != -1) {
    dispatch_once(&_CFNetworkCopySystemProxySettings::onceToken, &__block_literal_global_3339);
  }
  pthread_mutex_lock(&__sCFNSystemProxyDictLock);
  if (!__sProxyOverrideDict || (CFDictionaryRef v0 = (const __CFDictionary *)CFRetain((CFTypeRef)__sProxyOverrideDict)) == 0)
  {
    if (!_CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary) {
      goto LABEL_22;
    }
    uint64_t v1 = _CFNetworkCopySystemProxySettings::configWatcher;
    int check = 0;
    if (notify_check(*(_DWORD *)_CFNetworkCopySystemProxySettings::configWatcher, &check)) {
      BOOL v2 = 1;
    }
    else {
      BOOL v2 = check == 0;
    }
    int v3 = !v2;
    uint32_t v4 = notify_check(*(_DWORD *)(v1 + 4), &check);
    if (check) {
      BOOL v5 = v4 == 0;
    }
    else {
      BOOL v5 = 0;
    }
    CFDictionaryRef v6 = (CFDictionaryRef)_CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary;
    if (v5 || v3 != 0)
    {
      _CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary = 0;
      if (!v6) {
        goto LABEL_22;
      }
      CFRelease(v6);
      CFDictionaryRef v6 = (CFDictionaryRef)_CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary;
    }
    if (v6)
    {
LABEL_23:
      CFDictionaryRef v0 = (const __CFDictionary *)CFRetain(v6);
      goto LABEL_25;
    }
LABEL_22:
    CFDictionaryRef v6 = SCDynamicStoreCopyProxies(0);
    _CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary = (uint64_t)v6;
    if (!v6)
    {
      CFDictionaryRef v0 = 0;
      goto LABEL_25;
    }
    goto LABEL_23;
  }
LABEL_25:
  pthread_mutex_unlock(&__sCFNSystemProxyDictLock);
  return v0;
}

void sub_1841CA88C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x1000C4000313F17);
  _Unwind_Resume(a1);
}

uint64_t _CFNetworkSetOverrideSystemProxySettings(const void *a1)
{
  pthread_mutex_lock(&__sCFNSystemProxyDictLock);
  if (a1) {
    CFTypeRef v2 = CFRetain(a1);
  }
  else {
    CFTypeRef v2 = 0;
  }
  __sProxyOverrideDict = (uint64_t)v2;

  return pthread_mutex_unlock(&__sCFNSystemProxyDictLock);
}

void sub_1841CAB74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841CAD34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1841CADD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1841CAEE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1841CB090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_1841CB294(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id getCookieLogHandle(void)
{
  if (getCookieLogHandle(void)::onceToken != -1) {
    dispatch_once(&getCookieLogHandle(void)::onceToken, &__block_literal_global_3456);
  }
  CFDictionaryRef v0 = (void *)cookieLogHandle;

  return v0;
}

void ___Z18getCookieLogHandlev_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.cfnetwork", "cookies");
  uint64_t v1 = (void *)cookieLogHandle;
  cookieLogHandle = (uint64_t)v0;
}

uint64_t CFURLDownloadCreate(uint64_t a1, void *a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v6 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    *(void *)(Instance + 336) = 0;
    *(_OWORD *)(Instance + 304) = 0u;
    *(_OWORD *)(Instance + 32_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 288) = 0u;
    *(_OWORD *)(Instance + 24_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 16_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    URLDownload::URLDownload((URLDownload *)(Instance + 16));
    if (!a2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(allocator) = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CFURLDownloadCreate(): Asked to create from a NULL request!", (uint8_t *)&allocator, 2u);
    }
    URLDownload::_internal_setClient(v6 + 16, a3);
    CFGetAllocator((CFTypeRef)v6);
    *(void *)(v6 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = [a2 copy];
    if (*(void *)([a2 _inner] + 32))
    {
      CFAllocatorRef v7 = CFGetAllocator((CFTypeRef)v6);
      URLPortion::URLPortion((URLPortion *)&allocator, v7, *(CFURLRef *)([a2 _inner] + 32), 1);
      CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)v6);
      size_t v9 = strlen(__s);
      *(void *)(v6 + 24_CFNetworkResetHSTSHostsSinceDate(0, 0) = CFURLCreateWithBytes(v8, (const UInt8 *)__s, v9, 0x201u, 0);
      if (ptr != v15) {
        CFAllocatorDeallocate(allocator, ptr);
      }
    }
    else
    {
      *(void *)(v6 + 24_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
    }
    CFAllocatorRef allocator = (CFAllocatorRef)3;
    v15[0] = v6 + 16;
    v15[1] = DownloadConnectionClient::_implRetain;
    void v15[2] = DownloadConnectionClient::_implRelease;
    v15[3] = DownloadConnectionClient::_copyDescription;
    v15[4] = DownloadConnectionClient::_willSendRequestCallback;
    void v15[5] = DownloadConnectionClient::_didReceiveResponseCallback;
    v15[6] = DownloadConnectionClient::_didReceiveDataCallback;
    v15[7] = DownloadConnectionClient::_didStopBufferingDataCallback;
    v15[8] = DownloadConnectionClient::_connectionDidFinishLoadingCallback;
    v15[9] = DownloadConnectionClient::_didFailCallback;
    v15[10] = DownloadConnectionClient::_willCacheResponseCallback;
    v15[11] = DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback;
    v15[12] = 0;
    v15[13] = DownloadConnectionClient::_shouldUseCredentialStorageCallback;
    v15[14] = 0;
    CFAllocatorRef v10 = CFGetAllocator((CFTypeRef)v6);
    DownloadConnectionProperties = createDownloadConnectionProperties(v10);
    CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)v6);
    *(void *)(v6 + 32) = CFURLConnectionCreateWithProperties((uint64_t)v12, a2, &allocator, DownloadConnectionProperties);
    if (DownloadConnectionProperties) {
      CFRelease(DownloadConnectionProperties);
    }
    *(unsigned char *)(v6 + 297) = 1;
    *(void *)(v6 + 28_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  }
  else
  {
    URLDownload::URLDownload(0);
  }
  return v6;
}

void sub_1841CC360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const __CFAllocator *allocator, uint64_t a10)
{
  if ((uint64_t *)STACK[0x208] != &a10) {
    CFAllocatorDeallocate(allocator, (void *)STACK[0x208]);
  }
  _Unwind_Resume(a1);
}

uint64_t CFURLDownloadCreateWithResumeInformation(uint64_t a1, const __CFDictionary *a2, const void *a3, void *a4)
{
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = Instance;
  if (!Instance)
  {
    URLDownload::URLDownload(0);
    return v8;
  }
  *(_OWORD *)(Instance + 16) = 0u;
  *(void *)(Instance + 336) = 0;
  *(_OWORD *)(Instance + 304) = 0u;
  *(_OWORD *)(Instance + 32_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)(Instance + 272) = 0u;
  *(_OWORD *)(Instance + 288) = 0u;
  *(_OWORD *)(Instance + 24_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)(Instance + 256) = 0u;
  *(_OWORD *)(Instance + 208) = 0u;
  *(_OWORD *)(Instance + 224) = 0u;
  *(_OWORD *)(Instance + 176) = 0u;
  *(_OWORD *)(Instance + 192) = 0u;
  *(_OWORD *)(Instance + 144) = 0u;
  *(_OWORD *)(Instance + 16_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)(Instance + 112) = 0u;
  *(_OWORD *)(Instance + 128) = 0u;
  *(_OWORD *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  URLDownload::URLDownload((URLDownload *)(Instance + 16));
  if (!a2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(valuePtr[0]) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithResumeInformation(): Asked to create from NULL resumeInformation!", (uint8_t *)valuePtr, 2u);
    if (!a3)
    {
LABEL_7:
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        LOWORD(valuePtr[0]) = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithResumeData(): Asked to create from a NULL path!", (uint8_t *)valuePtr, 2u);
      }
    }
  }
  else if (!a3)
  {
    goto LABEL_7;
  }
  URLDownload::_internal_setClient(v8 + 16, a4);
  CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)v8);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"NSURLDownloadURL");
  if (!Value)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"kCFURLDownloadResumeURL");
    if (!Value) {
      goto LABEL_101;
    }
  }
  CFTypeID v11 = CFGetTypeID(Value);
  if (v11 != CFStringGetTypeID()) {
    goto LABEL_101;
  }
  CFURLRef v12 = CFURLCreateWithString(v9, Value, 0);
  if (!v12) {
    goto LABEL_101;
  }
  signed int v13 = (NSMutableURLRequest *)v12;
  unsigned int v14 = CFDictionaryGetValue(a2, @"NSURLDownloadBytesReceived");
  if (!v14)
  {
    unsigned int v14 = CFDictionaryGetValue(a2, @"kCFURLDownloadResumeBytesReceived");
    if (!v14) {
      goto LABEL_100;
    }
  }
  CFTypeID v15 = CFGetTypeID(v14);
  if (v15 != CFNumberGetTypeID()) {
    goto LABEL_100;
  }
  CFNumberRef number = (const __CFNumber *)v14;
  CFIndex v16 = (__CFString *)CFDictionaryGetValue(a2, @"NSURLDownloadEntityTag");
  if (v16 || (CFIndex v16 = (__CFString *)CFDictionaryGetValue(a2, @"kCFURLDownloadResumeEntityTag")) != 0)
  {
    CFTypeID v17 = CFGetTypeID(v16);
    if (v17 == CFStringGetTypeID()) {
      uint64_t v18 = v16;
    }
    else {
      uint64_t v18 = 0;
    }
    uint64_t v83 = v18;
  }
  else
  {
    uint64_t v83 = 0;
  }
  uint64_t v86 = v13;
  CFAllocatorRef v89 = v9;
  CFIndex v19 = (__CFString *)CFDictionaryGetValue(a2, @"NSURLDownloadServerModificationDate");
  CFIndex v85 = a3;
  if (v19
    || (CFIndex v19 = (__CFString *)CFDictionaryGetValue(a2, @"kCFURLDownloadResumeServerModificationDateString")) != 0)
  {
    CFTypeID v20 = CFGetTypeID(v19);
    if (v20 == CFStringGetTypeID()) {
      CFAllocatorRef v21 = v19;
    }
    else {
      CFAllocatorRef v21 = 0;
    }
    CFIndex v82 = v21;
  }
  else
  {
    CFIndex v82 = 0;
  }
  CFArrayRef v22 = (const __CFArray *)CFDictionaryGetValue(a2, @"NSURLDownloadDecoders");
  if (!v22 || (v23 = v22, uint64_t Count = CFArrayGetCount(v22), Count < 1))
  {
LABEL_80:
    signed int v13 = [(NSURLRequest *)[NSMutableURLRequest alloc] initWithURL:v13 cachePolicy:0 timeoutInterval:60.0];
    CFRelease(v86);
    if (!v13) {
      goto LABEL_101;
    }
    if (!CFNumberGetValue(number, kCFNumberSInt64Type, (void *)(v8 + 288))) {
      goto LABEL_100;
    }
    URLDownload::_internal_setServerModificationDateString((URLDownload *)(v8 + 16), v82);
    URLDownload::_internal_setEntityTag((URLDownload *)(v8 + 16), v83);
    if (!*(void *)(v8 + 256) && !*(void *)(v8 + 248)) {
      goto LABEL_100;
    }
    CFStringRef v71 = CFStringCreateWithFormat(v89, 0, @"bytes=%lld-", *(void *)(v8 + 288));
    if (!v71) {
      goto LABEL_100;
    }
    CFStringRef v72 = v71;
    CFStringRef v73 = *(const __CFString **)(v8 + 248);
    if (!v73) {
      CFStringRef v73 = *(const __CFString **)(v8 + 256);
    }
    CFURLRequestSetHTTPHeaderFieldValue(v13, @"If-Range", v73);
    CFURLRequestSetHTTPHeaderFieldValue(v13, (const __CFString *)&unk_1EC0A2700, v72);
    CFRelease(v72);
    URLDownload::_internal_setRequest((URLDownload *)(v8 + 16), (_CFURLRequest *)v13);
    CFRelease(v13);
    CFStringRef v74 = (const __CFString *)CFDictionaryGetValue(a2, @"NSURLDownloadOriginatingURLString");
    if (v74)
    {
      int64_t v75 = CFURLCreateWithString(v89, v74, 0);
    }
    else
    {
      UniChar v81 = *(void **)(v8 + 40);
      if (!v81) {
        goto LABEL_101;
      }
      int64_t v75 = *(const void **)([v81 _inner] + 32);
      if (v75) {
        int64_t v75 = CFRetain(v75);
      }
    }
    *(void *)(v8 + 24_CFNetworkResetHSTSHostsSinceDate(0, 0) = v75;
    if (!*(void *)(v8 + 40)) {
      goto LABEL_101;
    }
    valuePtr[0] = 3;
    valuePtr[1] = v8 + 16;
    void valuePtr[2] = DownloadConnectionClient::_implRetain;
    valuePtr[3] = DownloadConnectionClient::_implRelease;
    valuePtr[4] = DownloadConnectionClient::_copyDescription;
    valuePtr[5] = DownloadConnectionClient::_willSendRequestCallback;
    void valuePtr[6] = DownloadConnectionClient::_didReceiveResponseCallback;
    stat valuePtr[7] = DownloadConnectionClient::_didReceiveDataCallback;
    valuePtr[8] = DownloadConnectionClient::_didStopBufferingDataCallback;
    valuePtr[9] = DownloadConnectionClient::_connectionDidFinishLoadingCallback;
    valuePtr[10] = DownloadConnectionClient::_didFailCallback;
    valuePtr[11] = DownloadConnectionClient::_willCacheResponseCallback;
    valuePtr[12] = DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback;
    valuePtr[13] = 0;
    valuePtr[14] = DownloadConnectionClient::_shouldUseCredentialStorageCallback;
    valuePtr[15] = 0;
    CFAllocatorRef v76 = CFGetAllocator((CFTypeRef)v8);
    DownloadConnectionProperties = createDownloadConnectionProperties(v76);
    CFAllocatorRef v78 = CFGetAllocator((CFTypeRef)v8);
    *(void *)(v8 + 32) = CFURLConnectionCreateWithProperties((uint64_t)v78, *(void **)(v8 + 40), valuePtr, DownloadConnectionProperties);
    if (DownloadConnectionProperties) {
      CFRelease(DownloadConnectionProperties);
    }
    *(unsigned char *)(v8 + 297) = 1;
    *(void *)(v8 + 28_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
    *(_WORD *)(v8 + 30_CFNetworkResetHSTSHostsSinceDate(0, 0) = 256;
    if (v85) {
      CFTypeRef v79 = CFRetain(v85);
    }
    else {
      CFTypeRef v79 = 0;
    }
    *(void *)(v8 + 216) = v79;
    return v8;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v9, Count, MEMORY[0x1E4F1D510]);
  *(void *)(v8 + 272) = Mutable;
  if (!Mutable) {
    goto LABEL_100;
  }
  CFIndex v25 = 0;
  CFArrayRef v87 = v23;
  while (1)
  {
    CFDictionaryRef theDict = (const __CFDictionary *)CFArrayGetValueAtIndex(v23, v25);
    CFStringRef v26 = (const __CFString *)CFDictionaryGetValue(theDict, @"NSURLDownloadDecoderMIMEType");
    if (CFStringCompare(v26, @"application/mac-binhex40", 1uLL) == kCFCompareEqualTo)
    {
      if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
        dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2928);
      }
      CFIndex v40 = (_OWORD *)_CFRuntimeCreateInstance();
      CFStringRef v28 = v40;
      if (v40)
      {
        v40[1] = 0u;
        CFStringRef v28 = v40 + 1;
        v40[10] = 0u;
        v40[11] = 0u;
        v40[8] = 0u;
        v40[9] = 0u;
        v40[6] = 0u;
        void v40[7] = 0u;
        v40[4] = 0u;
        v40[5] = 0u;
        CFTypeRef v40[2] = 0u;
        v40[3] = 0u;
      }
      *(void *)CFStringRef v28 = &unk_1ECFA3168;
      *((void *)v28 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = "GZip";
      *((void *)v28 + 2) = &unk_1ECFA30C0;
      LOWORD(valuePtr[0]) = 0;
      *(void *)((char *)v28 + 44) = 0;
      *((_DWORD *)v28 + 8) = 0;
      *((unsigned char *)v28 + 88) = 0;
      *(void *)((char *)v28 + 52) = 0;
      *(void *)((char *)v28 + 59) = 0;
      *(void *)((char *)v28 + 164) = 0;
      *((unsigned char *)v28 + 24) = 0;
      CFNumberRef v41 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSURLDownloadBinHexDataForkCRCChecked");
      CFNumberRef v42 = v41;
      if (!v41) {
        goto LABEL_75;
      }
      CFTypeID v43 = CFGetTypeID(v41);
      if (v43 != CFNumberGetTypeID()) {
        goto LABEL_75;
      }
      CFNumberGetValue(v42, kCFNumberSInt16Type, valuePtr);
      *((unsigned char *)v28 + 64) = LOWORD(valuePtr[0]) != 0;
      CFNumberRef v44 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSURLDownloadBinHexCRC");
      CFNumberRef v45 = v44;
      if (!v44) {
        goto LABEL_75;
      }
      CFTypeID v46 = CFGetTypeID(v44);
      if (v46 != CFNumberGetTypeID()) {
        goto LABEL_75;
      }
      CFNumberGetValue(v45, kCFNumberSInt32Type, (char *)v28 + 52);
      CFNumberRef v47 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSURLDownloadBinHexDataForkBytesRemaining");
      CFNumberRef v48 = v47;
      if (!v47) {
        goto LABEL_75;
      }
      CFTypeID v49 = CFGetTypeID(v47);
      if (v49 != CFNumberGetTypeID()) {
        goto LABEL_75;
      }
      CFNumberGetValue(v48, kCFNumberSInt32Type, (char *)v28 + 56);
      CFNumberRef v50 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSURLDownloadBinHexResourceForkBytesRemaining");
      CFNumberRef v51 = v50;
      if (!v50) {
        goto LABEL_75;
      }
      CFTypeID v52 = CFGetTypeID(v50);
      if (v52 != CFNumberGetTypeID()) {
        goto LABEL_75;
      }
      CFNumberGetValue(v51, kCFNumberSInt32Type, (char *)v28 + 60);
      CFNumberRef v53 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSURLDownloadBinHexDecodedDataOffset");
      CFNumberRef v54 = v53;
      if (!v53) {
        goto LABEL_75;
      }
      CFTypeID v55 = CFGetTypeID(v53);
      if (v55 != CFNumberGetTypeID()) {
        goto LABEL_75;
      }
      CFNumberGetValue(v54, kCFNumberSInt32Type, v28 + 3);
      CFDataRef v56 = (const __CFData *)CFDictionaryGetValue(theDict, @"NSURLDownloadBinHexDecodedData");
      CFDataRef v57 = v56;
      if (!v56) {
        goto LABEL_75;
      }
      CFTypeID v58 = CFGetTypeID(v56);
      if (v58 != CFDataGetTypeID()) {
        goto LABEL_75;
      }
      uint64_t Length = CFDataGetLength(v57);
      if (Length > 8) {
        goto LABEL_75;
      }
      v92.CFIndex location = 0;
      v92.CFIndex length = Length;
      CFDataGetBytes(v57, v92, (UInt8 *)v28 + 36);
      *((_DWORD *)v28 + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = Length;
      CFDataRef v60 = (const __CFData *)CFDictionaryGetValue(theDict, @"NSURLDownloadBinHexEncodedData");
      CFDataRef v61 = v60;
      if (!v60) {
        goto LABEL_75;
      }
      CFTypeID v62 = CFGetTypeID(v60);
      if (v62 != CFDataGetTypeID()) {
        goto LABEL_75;
      }
      uint64_t v63 = CFDataGetLength(v61);
      if (v63 > 3) {
        goto LABEL_75;
      }
      v93.CFIndex location = 0;
      v93.CFIndex length = v63;
      CFDataGetBytes(v61, v93, (UInt8 *)v28 + 25);
      *((_DWORD *)v28 + 8) = v63;
      CFDataRef v64 = (const __CFData *)CFDictionaryGetValue(theDict, @"NSURLDownloadBinHexFirstCRCByte");
      CFDataRef v65 = v64;
      if (v64)
      {
        CFTypeID v66 = CFGetTypeID(v64);
        if (v66 == CFDataGetTypeID())
        {
          CFArrayRef v23 = v87;
          if (CFDataGetLength(v65) != 1) {
            goto LABEL_75;
          }
          v94.CFIndex location = 0;
          v94.CFIndex length = 1;
          CFDataGetBytes(v65, v94, (UInt8 *)v28 + 173);
          *((unsigned char *)v28 + 66) = 1;
        }
      }
      CFDataRef v67 = (const __CFData *)CFDictionaryGetValue(theDict, @"NSURLDownloadBinHexRepeatByte");
      CFDataRef v68 = v67;
      if (!v67) {
        goto LABEL_74;
      }
      CFTypeID v69 = CFGetTypeID(v67);
      if (v69 != CFDataGetTypeID()) {
        goto LABEL_74;
      }
      CFArrayRef v23 = v87;
      if (CFDataGetLength(v68) == 1)
      {
        v95.CFIndex location = 0;
        v95.CFIndex length = 1;
        CFDataGetBytes(v68, v95, (UInt8 *)v28 + 172);
        *((unsigned char *)v28 + 17__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
LABEL_74:
        *((unsigned char *)v28 + 168) = 1;
        *((unsigned char *)v28 + 24) = 1;
        CFArrayRef v23 = v87;
      }
LABEL_75:
      unsigned int v38 = (uint64_t (**)(void))&unk_1ECFA4F80;
      *(void *)CFStringRef v28 = &unk_1ECFA4F80;
      CFArrayRef v39 = &unk_1ECFA4FD0;
      goto LABEL_76;
    }
    if (CFStringCompare(v26, @"application/macbinary", 1uLL)) {
      goto LABEL_99;
    }
    if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
      dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2928);
    }
    CFStringRef v27 = (_OWORD *)_CFRuntimeCreateInstance();
    CFStringRef v28 = v27;
    if (v27)
    {
      v27[1] = 0u;
      CFStringRef v28 = v27 + 1;
      v27[7] = 0u;
      v27[8] = 0u;
      void v27[5] = 0u;
      v27[6] = 0u;
      void v27[3] = 0u;
      v27[4] = 0u;
      _OWORD v27[2] = 0u;
    }
    *(void *)CFStringRef v28 = &unk_1ECFA3168;
    *((void *)v28 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = "GZip";
    *((_DWORD *)v28 + 7) = 0;
    *((void *)v28 + 12) = 0;
    *((void *)v28 + 2) = &unk_1ECFA4678;
    *((_WORD *)v28 + 62) = 0;
    *((unsigned char *)v28 + 32) = 0;
    *((void *)v28 + 13) = 0;
    *((_DWORD *)v28 + 28) = 0;
    *((unsigned char *)v28 + 24) = 0;
    CFNumberRef v29 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSURLDownloadMacBinaryDataForkLength");
    CFNumberRef v30 = v29;
    if (v29)
    {
      CFTypeID v31 = CFGetTypeID(v29);
      if (v31 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v30, kCFNumberSInt32Type, v28 + 6);
        CFNumberRef v32 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSURLDownloadMacBinaryOffset");
        CFNumberRef v33 = v32;
        if (v32)
        {
          CFTypeID v34 = CFGetTypeID(v32);
          if (v34 == CFNumberGetTypeID())
          {
            CFNumberGetValue(v33, kCFNumberSInt32Type, (char *)v28 + 28);
            CFNumberRef v35 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"NSURLDownloadMacBinaryResourceForkLength");
            CFNumberRef v36 = v35;
            if (v35)
            {
              CFTypeID v37 = CFGetTypeID(v35);
              if (v37 == CFNumberGetTypeID())
              {
                CFNumberGetValue(v36, kCFNumberSInt32Type, (char *)v28 + 100);
                *((unsigned char *)v28 + 24) = 1;
              }
            }
          }
        }
      }
    }
    unsigned int v38 = (uint64_t (**)(void))&unk_1ECFA53E0;
    *(void *)CFStringRef v28 = &unk_1ECFA53E0;
    CFArrayRef v39 = &unk_1ECFA5430;
    CFArrayRef v23 = v87;
LABEL_76:
    *((void *)v28 + 2) = v39;
    uint64_t v70 = ((uint64_t (**)(_OWORD *))v38)[7](v28);
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v70 + 16))(v70)) {
      break;
    }
    CFArrayAppendValue(*(CFMutableArrayRef *)(v8 + 272), v28 - 1);
    CFRelease(v28 - 1);
    if (Count == ++v25) {
      goto LABEL_80;
    }
  }
  CFRelease(v28 - 1);
LABEL_99:
  CFRelease(*(CFTypeRef *)(v8 + 272));
  *(void *)(v8 + 272) = 0;
LABEL_100:
  CFRelease(v13);
LABEL_101:
  CFRelease((CFTypeRef)v8);
  return 0;
}

void sub_1841CD008(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9FBD0;
  _Unwind_Resume(a1);
}

void sub_1841CD028(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9FBD0;
  _Unwind_Resume(a1);
}

uint64_t CFURLDownloadCreateAndStartWithLoadingConnection(uint64_t a1, char *a2, _CFURLRequest *a3, _CFURLResponse *a4, void *a5)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v10 = Instance;
  if (!Instance)
  {
    URLDownload::URLDownload(0);
    return v10;
  }
  *(_OWORD *)(Instance + 16) = 0u;
  *(void *)(Instance + 336) = 0;
  *(_OWORD *)(Instance + 304) = 0u;
  *(_OWORD *)(Instance + 32_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)(Instance + 272) = 0u;
  *(_OWORD *)(Instance + 288) = 0u;
  *(_OWORD *)(Instance + 24_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)(Instance + 256) = 0u;
  *(_OWORD *)(Instance + 208) = 0u;
  *(_OWORD *)(Instance + 224) = 0u;
  *(_OWORD *)(Instance + 176) = 0u;
  *(_OWORD *)(Instance + 192) = 0u;
  *(_OWORD *)(Instance + 144) = 0u;
  *(_OWORD *)(Instance + 16_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)(Instance + 112) = 0u;
  *(_OWORD *)(Instance + 128) = 0u;
  *(_OWORD *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  URLDownload::URLDownload((URLDownload *)(Instance + 16));
  if (!a2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(allocator) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithConnection(): Asked to create from a NULL connection!", (uint8_t *)&allocator, 2u);
    if (a3) {
      goto LABEL_9;
    }
  }
  else if (a3)
  {
    goto LABEL_9;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(allocator) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithConnection(): Asked to create with a NULL request!", (uint8_t *)&allocator, 2u);
  }
LABEL_9:
  if (!a4 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(allocator) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithConnection(): Asked to create with a NULL response!", (uint8_t *)&allocator, 2u);
  }
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_66);
  }
  if (a2) {
    CFTypeID v11 = a2 + 16;
  }
  else {
    CFTypeID v11 = 0;
  }
  if (!(*(unsigned int (**)(char *))(*(void *)v11 + 152))(v11))
  {
    CFRelease((CFTypeRef)v10);
    return 0;
  }
  URLDownload::_internal_setClient(v10 + 16, a5);
  URLDownload::_internal_setRequest((URLDownload *)(v10 + 16), a3);
  URLDownload::_internal_setResponse((URLDownload *)(v10 + 16), a4);
  if (*(void *)([(_CFURLRequest *)a3 _inner] + 32))
  {
    CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)v10);
    URLPortion::URLPortion((URLPortion *)&allocator, v12, *(CFURLRef *)([(_CFURLRequest *)a3 _inner] + 32), 1);
    CFAllocatorRef v13 = CFGetAllocator((CFTypeRef)v10);
    size_t v14 = strlen(__s);
    *(void *)(v10 + 24_CFNetworkResetHSTSHostsSinceDate(0, 0) = CFURLCreateWithBytes(v13, (const UInt8 *)__s, v14, 0x201u, 0);
    if (ptr != v31) {
      CFAllocatorDeallocate(allocator, ptr);
    }
    if (a2) {
      goto LABEL_22;
    }
  }
  else
  {
    *(void *)(v10 + 24_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
    if (a2)
    {
LABEL_22:
      CFTypeRef v15 = CFRetain(a2);
      goto LABEL_27;
    }
  }
  CFTypeRef v15 = 0;
LABEL_27:
  *(void *)(v10 + 32) = v15;
  *(unsigned char *)(v10 + 297) = 1;
  *(void *)(v10 + 28_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(unsigned char *)(v10 + 30_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  CFAllocatorRef allocator = (CFAllocatorRef)3;
  v31[0] = v10 + 16;
  v31[1] = DownloadConnectionClient::_implRetain;
  _OWORD v31[2] = DownloadConnectionClient::_implRelease;
  CFTypeRef v31[3] = DownloadConnectionClient::_copyDescription;
  v31[4] = DownloadConnectionClient::_willSendRequestCallback;
  void v31[5] = DownloadConnectionClient::_didReceiveResponseCallback;
  void v31[6] = DownloadConnectionClient::_didReceiveDataCallback;
  v31[7] = DownloadConnectionClient::_didStopBufferingDataCallback;
  v31[8] = DownloadConnectionClient::_connectionDidFinishLoadingCallback;
  v31[9] = DownloadConnectionClient::_didFailCallback;
  v31[10] = DownloadConnectionClient::_willCacheResponseCallback;
  v31[11] = DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback;
  v31[12] = 0;
  v31[13] = DownloadConnectionClient::_shouldUseCredentialStorageCallback;
  v31[14] = 0;
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_66);
  }
  (*(void (**)(char *, CFAllocatorRef *))(*(void *)v11 + 144))(v11, &allocator);
  if (!*(unsigned char *)(v10 + 298))
  {
    *(unsigned char *)(v10 + 298) = 1;
    CFRetain((CFTypeRef)v10);
  }
  if (!*(unsigned char *)(v10 + 302))
  {
    *(unsigned char *)(v10 + 302) = 1;
    uint64_t v24 = *(void *)(v10 + 184);
    if (v24)
    {
      CFIndex v25 = *(void (**)(uint64_t, void))(v24 + 40);
      if (v25) {
        v25(v10, *(void *)(v24 + 8));
      }
    }
  }
  uint64_t v16 = *(void *)(v10 + 184);
  if (v16)
  {
    CFTypeID v17 = *(uint64_t (**)(uint64_t, void, _CFURLResponse *, void))(v16 + 48);
    if (v17)
    {
      uint64_t v18 = (_CFURLRequest *)v17(v10, *(void *)(v10 + 40), a4, *(void *)(v16 + 8));
      CFIndex v19 = v18;
      if (v18 != *(_CFURLRequest **)(v10 + 40))
      {
        if (v18)
        {
          URLDownload::_internal_setRequest((URLDownload *)(v10 + 16), v18);
          URLDownload::_internal_setResponse((URLDownload *)(v10 + 16), 0);
          CFTypeID v20 = *(const void **)(v10 + 32);
          if (v20) {
            CFRelease(v20);
          }
          v29[0] = 3;
          v29[1] = v10 + 16;
          void v29[2] = DownloadConnectionClient::_implRetain;
          void v29[3] = DownloadConnectionClient::_implRelease;
          v29[4] = DownloadConnectionClient::_copyDescription;
          void v29[5] = DownloadConnectionClient::_willSendRequestCallback;
          v29[6] = DownloadConnectionClient::_didReceiveResponseCallback;
          v29[7] = DownloadConnectionClient::_didReceiveDataCallback;
          v29[8] = DownloadConnectionClient::_didStopBufferingDataCallback;
          v29[9] = DownloadConnectionClient::_connectionDidFinishLoadingCallback;
          v29[10] = DownloadConnectionClient::_didFailCallback;
          v29[11] = DownloadConnectionClient::_willCacheResponseCallback;
          v29[12] = DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback;
          v29[13] = 0;
          v29[14] = DownloadConnectionClient::_shouldUseCredentialStorageCallback;
          v29[15] = 0;
          CFAllocatorRef v21 = CFGetAllocator((CFTypeRef)v10);
          DownloadConnectionProperties = createDownloadConnectionProperties(v21);
          CFAllocatorRef v23 = CFGetAllocator((CFTypeRef)v10);
          *(void *)(v10 + 32) = CFURLConnectionCreateWithProperties((uint64_t)v23, *(void **)(v10 + 40), v29, DownloadConnectionProperties);
          if (DownloadConnectionProperties) {
            CFRelease(DownloadConnectionProperties);
          }
          if (!*(unsigned char *)(v10 + 298))
          {
            *(unsigned char *)(v10 + 298) = 1;
            CFRetain((CFTypeRef)v10);
          }
          CFRelease(v19);
        }
        return v10;
      }
      if (v18) {
        CFRelease(v18);
      }
    }
    uint64_t v26 = *(void *)(v10 + 184);
    if (v26)
    {
      CFStringRef v27 = *(void (**)(uint64_t, _CFURLResponse *, void))(v26 + 64);
      if (v27) {
        v27(v10, a4, *(void *)(v26 + 8));
      }
    }
  }
  return v10;
}

void sub_1841CD69C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,const __CFAllocator *allocator,uint64_t a26)
{
  if ((uint64_t *)STACK[0x288] != &a26) {
    CFAllocatorDeallocate(allocator, (void *)STACK[0x288]);
  }
  _Unwind_Resume(a1);
}

uint64_t CFURLDownloadCreateWithResumeData(CFAllocatorRef allocator, CFDataRef data, const void *a3, void *a4)
{
  if (!data && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithResumeData(): Asked to create from NULL resumeData!", buf, 2u);
    if (a3) {
      goto LABEL_6;
    }
  }
  else if (a3)
  {
    goto LABEL_6;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFTypeID v11 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CFURLDownloadCreateWithResumeData(): Asked to create from a NULL path!", v11, 2u);
  }
LABEL_6:
  CFErrorRef error = 0;
  CFDictionaryRef v8 = (const __CFDictionary *)CFPropertyListCreateWithData(allocator, data, 0, 0, &error);
  if (!v8 && error)
  {
    CFRelease(error);
    return 0;
  }
  if (!v8) {
    return 0;
  }
  uint64_t v9 = CFURLDownloadCreateWithResumeInformation((uint64_t)allocator, v8, a3, a4);
  CFRelease(v8);
  return v9;
}

void CFURLDownloadSetDestination(uint64_t a1, CFURLRef url, int a3)
{
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  if (a1) {
    uint64_t v6 = a1 + 16;
  }
  else {
    uint64_t v6 = 0;
  }
  if (!*(void *)(v6 + 200))
  {
    if (a3 || !objectExistsAtURL(url))
    {
      if (url) {
        CFURLRef v7 = (const __CFURL *)CFRetain(url);
      }
      else {
        CFURLRef v7 = 0;
      }
LABEL_30:
      *(void *)(v6 + 20_CFNetworkResetHSTSHostsSinceDate(0, 0) = v7;
      *(unsigned char *)(v6 + 283) = a3;
      return;
    }
    CFAllocatorRef v8 = CFGetAllocator(url);
    CFStringRef v9 = CFURLCopyPathExtension(url);
    if (!v9)
    {
      CFURLRef v14 = (const __CFURL *)CFRetain(url);
      CFTypeRef v15 = 0;
LABEL_18:
      CFStringRef PathComponent = CFURLCopyLastPathComponent(v14);
      if (v14) {
        CFRelease(v14);
      }
      CFURLRef v17 = CFURLCreateCopyDeletingLastPathComponent(v8, url);
      uint64_t v18 = 1;
      while (1)
      {
        CFStringRef v19 = v15
            ? CFStringCreateWithFormat(v8, 0, @"%@-%d.%@", PathComponent, v18, v15)
            : CFStringCreateWithFormat(v8, 0, @"%@-%d", PathComponent, v18, v22);
        CFStringRef v20 = v19;
        CFURLRef v7 = CFURLCreateCopyAppendingPathComponent(v8, v17, v19, 0);
        CFRelease(v20);
        if (!objectExistsAtURL(v7)) {
          break;
        }
        CFRelease(v7);
        BOOL v21 = __CFADD__(v18, 1);
        uint64_t v18 = (v18 + 1);
        if (v21)
        {
          CFURLRef v7 = 0;
          break;
        }
      }
      CFRelease(PathComponent);
      CFRelease(v17);
      if (v15) {
        CFRelease(v15);
      }
      goto LABEL_30;
    }
    CFStringRef v10 = v9;
    CFURLRef v11 = CFURLCreateCopyDeletingPathExtension(v8, url);
    CFStringRef v12 = CFURLCopyPathExtension(v11);
    if (v12)
    {
      CFStringRef v13 = v12;
      CFURLRef v14 = CFURLCreateCopyDeletingPathExtension(v8, v11);
      CFTypeRef v15 = CFStringCreateWithFormat(v8, 0, @"%@.%@", v13, v10);
      CFRelease(v13);
      if (!v11)
      {
LABEL_15:
        CFRelease(v10);
        goto LABEL_18;
      }
    }
    else
    {
      CFTypeRef v15 = CFRetain(v10);
      CFURLRef v14 = (const __CFURL *)CFRetain(v11);
      if (!v11) {
        goto LABEL_15;
      }
    }
    CFRelease(v11);
    goto LABEL_15;
  }
}

void CFURLDownloadSetDeletesUponFailure(uint64_t a1, char a2)
{
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  uint64_t v4 = a1 + 16;
  if (!a1) {
    uint64_t v4 = 0;
  }
  *(unsigned char *)(v4 + 28__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = a2;
}

uint64_t CFURLDownloadDeletesUponFailure(uint64_t a1)
{
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  return *(unsigned __int8 *)(v2 + 281);
}

CFDictionaryRef CFURLDownloadCopyResumeData(char *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  if (a1) {
    int v3 = (URLDownload *)(a1 + 16);
  }
  else {
    int v3 = 0;
  }
  CFDictionaryRef result = URLDownload::createResumeInformation(v3, v2);
  if (result)
  {
    CFDictionaryRef v5 = result;
    CFDataRef Data = CFPropertyListCreateData(v2, result, kCFPropertyListXMLFormat_v1_0, 0, 0);
    CFRelease(v5);
    return Data;
  }
  return result;
}

uint64_t CFURLDownloadScheduleWithRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  if (a1) {
    uint64_t v6 = a1 + 16;
  }
  else {
    uint64_t v6 = 0;
  }
  CFURLConnectionScheduleWithRunLoop(*(void *)(v6 + 16), a2, a3);
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 288) + 56))(*(void *)(v6 + 288), a2, a3);
  *(void *)(v6 + 288) = result;
  return result;
}

void CFURLDownloadStart(uint64_t a1)
{
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  if (a1) {
    uint64_t v2 = a1 + 16;
  }
  else {
    uint64_t v2 = 0;
  }
  if (!*(unsigned char *)(v2 + 282))
  {
    *(unsigned char *)(v2 + 282) = 1;
    CFRetain((CFTypeRef)(v2 - 16));
  }
  uint64_t v3 = *(void *)(v2 + 16);

  CFURLConnectionStart(v3);
}

void CFURLDownloadCancel(uint64_t a1)
{
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  if (a1) {
    uint64_t v2 = (URLDownload *)(a1 + 16);
  }
  else {
    uint64_t v2 = 0;
  }

  URLDownload::_internal_downloadCancel(v2, 0);
}

void AutoArray::~AutoArray(AutoArray *this)
{
  *(void *)this = &unk_1ECFA5BB8;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECFA5BB8;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

void sub_1841CE3EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t AutoScalar::isEmpty(AutoScalar *this)
{
  return 0;
}

uint64_t AutoScalar::getRef(AutoScalar *this)
{
  return *((void *)this + 1);
}

void AutoScalar::~AutoScalar(AutoScalar *this)
{
  *(void *)this = &unk_1ECF9A500;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9A500;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

void non-virtual thunk to'HTTPServerService_NW::~HTTPServerService_NW(HTTPServerService_NW *this)
{
}

{
  HTTPServerService_NW::~HTTPServerService_NW((HTTPServerService_NW *)((char *)this - 56));
}

{
  HTTPServerService_NW::~HTTPServerService_NW((HTTPServerService_NW *)((char *)this - 8));
}

{
  HTTPServerService_NW::~HTTPServerService_NW((HTTPServerService_NW *)((char *)this - 8));
}

void HTTPServerService_NW::~HTTPServerService_NW(HTTPServerService_NW *this)
{
  *(void *)this = &unk_1ECFA1510;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECFA15D0;
  *((void *)this + 7) = &unk_1ECFA1638;
  uint64_t v2 = *((void *)this + 41);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    *((void *)this + 4__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  }

  HTTPServerService::~HTTPServerService(this);
}

void sub_1841CF020(_Unwind_Exception *a1)
{
  HTTPServerService::~HTTPServerService(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTPServerService_NW::canceled_onQueue(HTTPServerService_NW *this)
{
  if (!*((unsigned char *)this + 336))
  {
    *((unsigned char *)this + 336) = 1;
    uint64_t v2 = (Listener *)*((void *)this + 40);
    if (v2) {
      Listener::_onqueue_invalidate(v2);
    }
  }
  *((unsigned char *)this + 305) = 0;
}

void HTTPServerService_NW::canceled_onQueue(HTTPServerService_NW *this)
{
  if (!*((unsigned char *)this + 344))
  {
    *((unsigned char *)this + 344) = 1;
    uint64_t v2 = (Listener *)*((void *)this + 41);
    if (v2) {
      Listener::_onqueue_invalidate(v2);
    }
  }
  *((unsigned char *)this + 313) = 0;
}

void Listener::_onqueue_invalidate(Listener *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    *((void *)this + 4) = 0;
    nw_listener_cancel(v2);
    CFRelease(v2);
  }
  else
  {
    uint64_t v3 = *((void *)this + 8);
    if (v3)
    {
      CFRelease((CFTypeRef)(v3 - 16));
      *((void *)this + 8) = 0;
    }
  }
}

void non-virtual thunk to'HTTPServerService_NW::scheduled_onQueue(HTTPServerService_NW *this)
{
}

void HTTPServerService_NW::scheduled_onQueue(HTTPServerService_NW *this)
{
  if (!*((unsigned char *)this + 344) && !*((void *)this + 41)) {
    (*(void (**)(HTTPServerService_NW *, void))(*(void *)this + 80))(this, 0);
  }

  HTTPServerService::scheduled_onQueue(this);
}

void HTTPServerService_NW::errorHandler_onQueue(HTTPServerService_NW *this, __CFError *a2)
{
}

uint64_t HTTPServerService_NW::createServerInstance(HTTPServerService_NW *this)
{
  return 0;
}

uint64_t HTTPServerService_NW::getPort(HTTPServerService_NW *this)
{
  uint64_t v1 = *((void *)this + 41);
  if (v1) {
    uint64_t v2 = (unsigned __int16 *)(v1 + 48);
  }
  else {
    uint64_t v2 = (unsigned __int16 *)((char *)this + 296);
  }
  return *v2;
}

uint64_t HTTPServerService_NW::setupTLSOnStreams(HTTPServerService_NW *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return 1;
}

void HTTPServerService_NW::ensureServerExists(uint64_t a1, NSObject *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 88));
  if (*(void *)(a1 + 328))
  {
    if (a2)
    {
      dispatch_semaphore_signal(a2);
    }
    return;
  }
  if (a2)
  {
    uint64_t v4 = *(void **)(a1 + 336);
    if (!v4)
    {
      uint64_t v4 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:0];
      *(void *)(a1 + 336) = v4;
    }
    [v4 addObject:a2];
  }
  if (!*(unsigned char *)(a1 + 345))
  {
    *(unsigned char *)(a1 + 345) = 1;
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v6 = (unsigned __int16 *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 72, 0);
    *(_OWORD *)uint64_t v6 = 0u;
    *((_OWORD *)v6 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((void *)v6 + 8) = 0;
    *((_OWORD *)v6 + 2) = 0u;
    unsigned __int16 v7 = *(_WORD *)(a1 + 296);
    CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)v6, v5);
    *(void *)uint64_t v8 = &unk_1ECFA5B40;
    *(void *)(v8 + 24) = &unk_1ECFA5B98;
    *(void *)(v8 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
    *((void *)v6 + 4) = 0;
    *(_WORD *)(v8 + 48) = 0;
    *(void *)(v8 + 56) = 0;
    *(void *)(v8 + 64) = a1;
    CFRetain((CFTypeRef)(a1 - 16));
    v6[24] = v7;
    *((void *)v6 + 7) = 0;
    if ((*(uint64_t (**)(unsigned __int16 *, uint64_t))(*(void *)v6 + 64))(v6, 0x1EC0A4760)) {
      operator new();
    }
    snprintf(__str, 0x20uLL, "%u", v6[24]);
    uint64_t v36 = 0;
    CFTypeID v37 = &v36;
    uint64_t v38 = 0x3052000000;
    CFArrayRef v39 = __Block_byref_object_copy__3637;
    CFIndex v40 = __Block_byref_object_dispose__3638;
    sec_identity_t v41 = 0;
    CFStringRef v9 = (HTTPServer *)*((void *)v6 + 8);
    if (v9 && (CFArrayRef v10 = (const __CFArray *)HTTPServer::copyServerTrustChain(v9), (v11 = v10) != 0))
    {
      CFIndex Count = CFArrayGetCount(v10);
      if (Count)
      {
        CFStringRef ValueAtIndex = (AutoArray *)CFArrayGetValueAtIndex(v11, 0);
        CFURLRef v14 = ValueAtIndex;
        if (Count == 1)
        {
          CFArrayRef EmptyArray = (const __CFArray *)AutoArray::getEmptyArray(ValueAtIndex);
          sec_identity_t v16 = sec_identity_create_with_certificates(v14, EmptyArray);
        }
        else
        {
          MutableCFStringRef Copy = CFArrayCreateMutableCopy(v5, Count, v11);
          CFArrayRemoveValueAtIndex(MutableCopy, 0);
          sec_identity_t v16 = sec_identity_create_with_certificates(v14, MutableCopy);
          if (MutableCopy) {
            CFRelease(MutableCopy);
          }
        }
      }
      else
      {
        sec_identity_t v16 = 0;
      }
      CFRelease(v11);
    }
    else
    {
      sec_identity_t v16 = 0;
    }
    sec_identity_t v41 = v16;
    if (v37[5])
    {
      uint64_t v18 = v35;
      v35[0] = MEMORY[0x1E4F143A8];
      v35[1] = 3221225472;
      void v35[2] = ___ZN8Listener5startEv_block_invoke;
      v35[3] = &unk_1E5253408;
      uint8_t v35[4] = &v36;
      v35[5] = v6;
    }
    else
    {
      uint64_t v18 = (void *)*MEMORY[0x1E4F38C90];
    }
    secure_tcp = nw_parameters_create_secure_tcp(v18, (nw_parameters_configure_protocol_block_t)*MEMORY[0x1E4F38C88]);
    CFStringRef v20 = (void *)(*(uint64_t (**)(unsigned __int16 *, uint64_t))(*(void *)v6 + 64))(v6, 0x1EC0A4300);
    BOOL v21 = v20;
    if (v20)
    {
      if (CFEqual(v20, @"all"))
      {
        nw_parameters_set_use_awdl();
      }
      else
      {
        [v21 UTF8String];
        uint64_t v22 = nw_interface_create_with_name();
        if (v22)
        {
          nw_parameters_require_interface(secure_tcp, v22);
          CFRelease(v22);
        }
      }
    }
    if ((*(uint64_t (**)(unsigned __int16 *, uint64_t))(*(void *)v6 + 64))(v6, 0x1EC0A46B8) == *MEMORY[0x1E4F1CFD0]) {
      nw_parameters_set_reuse_local_address(secure_tcp, 1);
    }
    CFAllocatorRef v23 = nw_listener_create_with_port(__str, secure_tcp);
    *((void *)v6 + 4) = v23;
    nw_listener_set_queue(v23, *(dispatch_queue_t *)(*((void *)v6 + 8) + 88));
    if (secure_tcp) {
      CFRelease(secure_tcp);
    }
    v31[0] = MEMORY[0x1E4F143A8];
    v31[1] = 3221225472;
    CFNumberRef v32 = ___ZN8Listener5startEv_block_invoke_2;
    CFNumberRef v33 = &__block_descriptor_40_e44_v32__0__NSString_8__NSString_16__NSString_24l;
    uint64_t v34 = v6;
    uint64_t v24 = (void *)(*(uint64_t (**)(void, uint64_t))(**((void **)v6 + 8) + 64))(*((void *)v6 + 8), 0x1EC0A4728);
    if (!v24) {
      goto LABEL_42;
    }
    CFStringRef Copy = (CFStringRef)(*(uint64_t (**)(void, uint64_t))(**((void **)v6 + 8) + 64))(*((void *)v6 + 8), 0x1EC0A4488);
    if (Copy)
    {
      v32((uint64_t)v31, v24, (void *)Copy, &stru_1ECFAD558);
    }
    else
    {
      CFStringRef Copy = CFStringCreateCopy(v5, &stru_1ECFAD558);
      v32((uint64_t)v31, v24, (void *)Copy, &stru_1ECFAD558);
      if (!Copy)
      {
LABEL_41:
        CFRelease(v24);
LABEL_42:
        (*(void (**)(unsigned __int16 *))(*(void *)v6 + 40))(v6);
        uint64_t v26 = *((void *)v6 + 4);
        handler[0] = MEMORY[0x1E4F143A8];
        handler[1] = 3221225472;
        handler[2] = ___ZN8Listener5startEv_block_invoke_3;
        handler[3] = &__block_descriptor_40_e34_v20__0i8__NSObject_OS_nw_error__12l;
        handler[4] = v6;
        nw_listener_set_state_changed_handler(v26, handler);
        CFStringRef v27 = *((void *)v6 + 4);
        v29[0] = MEMORY[0x1E4F143A8];
        v29[1] = 3221225472;
        void v29[2] = ___ZN8Listener5startEv_block_invoke_4;
        void v29[3] = &__block_descriptor_40_e36_v16__0__NSObject_OS_nw_connection__8l;
        v29[4] = v6;
        nw_listener_set_new_connection_handler(v27, v29);
        nw_listener_start(*((nw_listener_t *)v6 + 4));
        _Block_object_dispose(&v36, 8);
        CFStringRef v28 = *(void (**)(unsigned __int16 *))(*(void *)v6 + 48);
        v28(v6);
        return;
      }
    }
    CFRelease(Copy);
    goto LABEL_41;
  }
}

void sub_1841CF910(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0xE1C40D30581F4);
  void *v2 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__3637(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__3638(uint64_t a1)
{
}

void ___ZN8Listener5startEv_block_invoke(uint64_t a1, NSObject *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 40);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFAllocatorRef v5 = CFNLog::logger;
  BOOL v6 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
  unsigned __int16 v7 = (const void **)MEMORY[0x1E4F1CFD0];
  if (v6)
  {
    int v8 = *(unsigned __int16 *)(v4 + 48);
    BOOL v9 = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(v4 + 56) + 8), @"kCFHTTPServerRequireClientCertificate") != 0;
    BOOL v10 = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(v4 + 56) + 8), @"kCFHTTPServerRequireClientCertificate") == *v7;
    v12[0] = 67109632;
    v12[1] = v8;
    __int16 v13 = 1024;
    BOOL v14 = v9;
    __int16 v15 = 1024;
    BOOL v16 = v10;
    _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "CFHTTPServer configuring TLS {port=%u, wants_client_cert=%{BOOL}d, requires_client_cert=%{BOOL}d}", (uint8_t *)v12, 0x14u);
  }
  sec_protocol_options_set_local_identity(a2, *(sec_identity_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
  CFArrayRef v11 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  if (v11) {
    CFRelease(v11);
  }
  sec_protocol_options_set_verify_block(a2, &__block_literal_global_3647, *(dispatch_queue_t *)(*(void *)(v4 + 64) + 88));
  if (CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(v4 + 56) + 8), @"kCFHTTPServerRequireClientCertificate"))
  {
    if (CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(v4 + 56) + 8), @"kCFHTTPServerRequireClientCertificate") == *v7)sec_protocol_options_set_peer_authentication_required(a2, 1); {
    else
    }
      sec_protocol_options_set_peer_authentication_optional(a2, 1);
  }
}

void ___ZN8Listener5startEv_block_invoke_2(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  bonjour_service = nw_advertise_descriptor_create_bonjour_service((const char *)[a3 UTF8String], (const char *)objc_msgSend(a2, "UTF8String"), (const char *)objc_msgSend(a4, "UTF8String"));
  if (bonjour_service)
  {
    BOOL v6 = bonjour_service;
    nw_listener_set_advertise_descriptor(*(nw_listener_t *)(v4 + 32), bonjour_service);
    CFRelease(v6);
  }
}

uint64_t ___ZN8Listener5startEv_block_invoke_3(uint64_t result, int a2, nw_error_t error)
{
  if (a2 != 1)
  {
    uint64_t v5 = *(void *)(result + 32);
    uint64_t v6 = *(void *)(v5 + 64);
    if (v6 && !*(void *)(v6 + 328))
    {
      *(void *)(v6 + 328) = v5;
      (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
      unsigned __int16 v7 = *(void **)(v6 + 336);
      if (v7)
      {
        *(void *)(v6 + 336) = 0;
        [v7 enumerateObjectsUsingBlock:&__block_literal_global_11];
        CFRelease(v7);
      }
      if (*(unsigned char *)(v6 + 344)) {
        Listener::_onqueue_invalidate(*(Listener **)(v6 + 328));
      }
    }
    if (a2 == 2)
    {
      uint64_t result = *(void *)(v5 + 32);
      if (result)
      {
        uint64_t result = nw_listener_get_port((nw_listener_t)result);
        *(_WORD *)(v5 + 48) = result;
      }
    }
    else
    {
      if (error) {
        CFErrorRef v8 = nw_error_copy_cf_error(error);
      }
      else {
        CFErrorRef v8 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D160], 22, 0);
      }
      CFErrorRef v9 = v8;
      uint64_t v10 = *(void *)(v5 + 64);
      if (v10)
      {
        *(void *)(v5 + 64) = 0;
        CFArrayRef v11 = (const void *)(v10 - 16);
        (*(void (**)(uint64_t, CFErrorRef))(*(void *)v10 + 168))(v10, v9);
        CFRelease(v11);
      }
      CFRelease(v9);
      CFStringRef v12 = *(NSObject **)(v5 + 32);
      if (v12)
      {
        nw_listener_set_state_changed_handler(v12, 0);
        nw_listener_set_new_connection_handler(*(nw_listener_t *)(v5 + 32), 0);
      }
      __int16 v13 = *(uint64_t (**)(uint64_t))(*(void *)v5 + 48);
      return v13(v5);
    }
  }
  return result;
}

void ___ZN8Listener5startEv_block_invoke_4(uint64_t a1, nw_connection_t connection)
{
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3[4])
  {
    uint64_t v4 = dispatch_queue_create("com.apple.cfnetwork.httpserver-connection-queue", 0);
    nw_connection_set_queue(connection, v4);
    uint64_t v5 = v3[8];
    uint64_t v6 = *(void *)(v5 + 88);
    if (v6) {
      CFRetain(*(CFTypeRef *)(v5 + 88));
    }
    v8[0] = 0;
    v8[1] = v8;
    _DWORD v8[2] = 0x2020000000;
    char v9 = 0;
    (*(void (**)(void *))(*v3 + 40))(v3);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 3221225472;
    handler[2] = ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke;
    handler[3] = &unk_1E52533C0;
    handler[7] = v8;
    handler[8] = v3;
    handler[4] = connection;
    void handler[5] = v4;
    handler[6] = v6;
    nw_connection_set_state_changed_handler(connection, handler);
    dispatch_release(v4);
    nw_connection_start(connection);
    _Block_object_dispose(v8, 8);
  }
  else
  {
    nw_connection_cancel(connection);
  }
}

void sub_1841CFF0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke(uint64_t result, int a2)
{
  if ((a2 - 3) <= 2)
  {
    block[11] = v2;
    block[12] = v3;
    uint64_t v4 = result;
    if (!*(unsigned char *)(*(void *)(*(void *)(result + 56) + 8) + 24))
    {
      uint64_t v5 = *(void *)(result + 64);
      unsigned int v6 = 6u >> ((a2 - 3) & 7);
      nw_connection_set_state_changed_handler(*(nw_connection_t *)(result + 32), 0);
      *(unsigned char *)(*(void *)(*(void *)(v4 + 56) + 8) + 24) = 1;
      if (v6)
      {
        nw_connection_cancel(*(nw_connection_t *)(v4 + 32));
      }
      else
      {
        (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
        unsigned __int16 v7 = *(const void **)(v4 + 32);
        if (v7) {
          CFRetain(v7);
        }
        CFErrorRef v8 = *(const void **)(v4 + 40);
        if (v8)
        {
          CFRetain(v8);
          uint64_t v9 = *(void *)(v4 + 40);
        }
        else
        {
          uint64_t v9 = 0;
        }
        uint64_t v10 = *(NSObject **)(v4 + 48);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_2;
        block[3] = &unk_1E5257B78;
        void block[5] = v9;
        void block[6] = v5;
        block[4] = *(void *)(v4 + 32);
        dispatch_async(v10, block);
      }
      dispatch_release(*(dispatch_object_t *)(v4 + 48));
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48))(v5);
    }
  }
  return result;
}

uint64_t ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  uint64_t v3 = *(NSObject **)(a1 + 32);
  if (v2[4])
  {
    uint64_t v4 = v2[8];
    if (v4)
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v4 + 88));
      uint64_t v5 = [NWStreamPair alloc];
      if (v5)
      {
        v17.receiver = v5;
        v17.super_class = (Class)NWStreamPair;
        unsigned int v6 = objc_msgSendSuper2(&v17, sel_initWithLoggableName_, "nwstream");
        if (v6)
        {
          unsigned __int16 v7 = v6;
          void v6[2] = v3;
          if (v3)
          {
            CFRetain(v3);
            CFErrorRef v8 = v7[2];
          }
          else
          {
            CFErrorRef v8 = 0;
          }
          uint64_t v9 = nw_connection_copy_endpoint(v8);
          uint64_t v10 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
          if (v9)
          {
            CFArrayRef v11 = v9;
            address = nw_endpoint_get_address(v9);
            v7[11] = CFDataCreate(*v10, &address->sa_len, address->sa_len);
            CFRelease(v11);
          }
          uint64_t v18 = 0;
          CFStringRef v19 = &v18;
          uint64_t v20 = 0x2020000000;
          uint64_t v21 = 0;
          *(void *)long long buf = MEMORY[0x1E4F143A8];
          uint64_t v23 = 3221225472;
          uint64_t v24 = __39__NWStreamPair_copyConnectionPeerTrust__block_invoke;
          CFIndex v25 = &unk_1E52566F8;
          uint64_t v26 = &v18;
          -[NWStreamPair withTLSMetadata:]((uint64_t)v7, (uint64_t)buf);
          uint64_t v13 = v19[3];
          _Block_object_dispose(&v18, 8);
          v7[12] = v13;
          CFMutableArrayRef Mutable = CFArrayCreateMutable(*v10, 0, MEMORY[0x1E4F1D510]);
          *(void *)long long buf = MEMORY[0x1E4F143A8];
          uint64_t v23 = 3221225472;
          uint64_t v24 = __39__NWStreamPair_copyConnectionPeerCerts__block_invoke;
          CFIndex v25 = &__block_descriptor_40_e44_v16__0__NSObject_OS_sec_protocol_metadata__8l;
          uint64_t v26 = Mutable;
          -[NWStreamPair withTLSMetadata:]((uint64_t)v7, (uint64_t)buf);
          if (!CFArrayGetCount(Mutable))
          {
            CFRelease(Mutable);
            CFMutableArrayRef Mutable = 0;
          }
          v7[13] = Mutable;
          v7[3] = 0;
          v7[4] = 0;
          void v7[7] = 0;
          operator new();
        }
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "if we have an _nwListener, we should have a _server", buf, 2u);
    }
  }
  nw_connection_cancel(v3);
  nw_release(*(void **)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
  __int16 v15 = *(uint64_t (**)(void *))(*v2 + 48);

  return v15(v2);
}

void sub_1841D06E8(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  MEMORY[0x18531B6D0](v1, 0x10F1C40C157D38ELL);
  _Unwind_Resume(a1);
}

intptr_t ___ZN20HTTPServerService_NW15listenerStartedEP8Listener_block_invoke(int a1, dispatch_semaphore_t dsema)
{
  return dispatch_semaphore_signal(dsema);
}

uint64_t ___ZN8Listener5startEv_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, 1);
}

void HTTPServerSSLSettings::~HTTPServerSSLSettings(HTTPServerSSLSettings *this)
{
  *(void *)this = &unk_1ECF9DDC8;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18531B6D0);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9DDC8;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

void non-virtual thunk to'Listener::~Listener(Listener *this)
{
  uint64_t v2 = (char *)this - 24;
  Listener::~Listener((Listener *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  Listener::~Listener((Listener *)((char *)this - 24));
}

void Listener::~Listener(Listener *this)
{
  *(void *)this = &unk_1ECFA5B40;
  *((void *)this + 3) = &unk_1ECFA5B98;
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  Listener::~Listener(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

const void *Listener::_getProperty(Listener *this, const __CFString *a2)
{
  uint64_t v2 = *((void *)this + 8);
  if (!v2) {
    return 0;
  }
  CFAllocatorRef v3 = (const void *)(*(uint64_t (**)(uint64_t, const __CFString *))(*(void *)v2 + 64))(v2, a2);
  uint64_t v4 = v3;
  if (v3) {
    CFAutorelease(v3);
  }
  return v4;
}

uint64_t Listener::operator CoreLoggable *(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  if (v1) {
    return v1 + 56;
  }
  else {
    return 0;
  }
}

uint64_t CoreStreamClient::coreStreamClientCopyCFStreamRef(CoreStreamClient *this)
{
  return 0;
}

void CoreWriteStreamClient::coreStreamEventsAvailable(CoreWriteStreamClient *this, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*((void *)this + 1) && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    if (!v2) {
      return;
    }
  }
  else if (!a2)
  {
    return;
  }
  uint64_t v4 = 1;
  do
  {
    if ((v4 & ~v2) == 0)
    {
      (*(void (**)(CoreWriteStreamClient *, void, uint64_t))(*(void *)this + 56))(this, *((void *)this + 1), v4);
      v2 &= ~v4;
    }
    v4 *= 2;
  }
  while (v2);
}

void ___ZN15CoreWriteStream5ClassEv_block_invoke()
{
}

void sub_1841D0AF0(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_UpdateScheduling(CoreWriteStreamFromCFWriteStream *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  CoreSchedulingSet::_scheduleStream((uint64_t)a2, *((void *)this + 1), (void (*)(uint64_t, uint64_t))_CFStreamUnscheduleFromDispatchQueue, MEMORY[0x1E4F1C2D8]);
  uint64_t v5 = *((void *)this + 1);
  unsigned int v6 = (void (*)(uint64_t, uint64_t))MEMORY[0x1E4F1C2D0];
  uint64_t v7 = MEMORY[0x1E4F1C2C8];

  CoreSchedulingSet::_scheduleStream((uint64_t)a3, v5, v6, v7);
}

uint64_t non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_CanWrite(CFWriteStreamRef *this)
{
  return CFWriteStreamCanAcceptBytes(this[1]);
}

CFIndex non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_Write(CFWriteStreamRef *this, const unsigned __int8 *a2, CFIndex a3, CFStreamError *a4)
{
  return CoreWriteStreamFromCFWriteStream::_streamImpl_Write(this - 15, a2, a3, a4);
}

CFIndex CoreWriteStreamFromCFWriteStream::_streamImpl_Write(CFWriteStreamRef *this, const unsigned __int8 *a2, CFIndex a3, CFStreamError *a4)
{
  if (a4)
  {
    a4->CFStringRef domain = 0;
    a4->CFErrorRef error = 0;
    CFIndex v6 = CFWriteStreamWrite(this[16], a2, a3);
    if (CFWriteStreamGetStatus(this[16]) == kCFStreamStatusError)
    {
      uint64_t v7 = this[16];
      if (v7 && (CFErrorRef v8 = CFWriteStreamCopyError(v7)) != 0)
      {
        uint64_t v9 = v8;
        CFIndex v10 = _CFStreamErrorFromCFError(v8);
        uint64_t v12 = v11;
        CFRelease(v9);
      }
      else
      {
        uint64_t v12 = 0;
        CFIndex v10 = 0;
      }
      a4->CFStringRef domain = v10;
      *(void *)&a4->CFErrorRef error = v12;
    }
    else
    {
      a4->CFErrorRef error = 0;
      a4->CFStringRef domain = 0;
    }
    return v6;
  }
  else
  {
    uint64_t v13 = this[16];
    return CFWriteStreamWrite(v13, a2, a3);
  }
}

void non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_Close(CoreWriteStreamFromCFWriteStream *this)
{
  if (*((unsigned char *)this + 16))
  {
    if (!*((unsigned char *)this + 17))
    {
      *((unsigned char *)this + 17) = 1;
      CFWriteStreamClose(*((CFWriteStreamRef *)this + 1));
    }
  }
}

BOOL non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_OpenCompleted(CFWriteStreamRef *this, CFStreamError *a2)
{
  return CoreWriteStreamFromCFWriteStream::_streamImpl_OpenCompleted(this - 15, a2);
}

BOOL CoreWriteStreamFromCFWriteStream::_streamImpl_OpenCompleted(CFWriteStreamRef *this, CFStreamError *a2)
{
  CFStreamStatus Status = CFWriteStreamGetStatus(this[16]);
  uint64_t v5 = Status;
  if (a2)
  {
    if (Status == kCFStreamStatusError)
    {
      CFIndex v6 = this[16];
      if (v6 && (uint64_t v7 = CFWriteStreamCopyError(v6)) != 0)
      {
        CFErrorRef v8 = v7;
        CFIndex v9 = _CFStreamErrorFromCFError(v7);
        uint64_t v11 = v10;
        CFRelease(v8);
      }
      else
      {
        uint64_t v11 = 0;
        CFIndex v9 = 0;
      }
      a2->CFStringRef domain = v9;
      *(void *)&a2->CFErrorRef error = v11;
    }
    else
    {
      a2->CFStringRef domain = 0;
      a2->CFErrorRef error = 0;
    }
  }
  return v5 > 1;
}

uint64_t non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_Open(CoreWriteStreamFromCFWriteStream *this, CFStreamError *a2, BOOL *a3)
{
  return CoreWriteStreamFromCFWriteStream::_streamImpl_Open((CoreWriteStreamFromCFWriteStream *)((char *)this - 120), (unint64_t)a2, a3);
}

uint64_t CoreWriteStreamFromCFWriteStream::_streamImpl_Open(CoreWriteStreamFromCFWriteStream *this, unint64_t a2, BOOL *a3)
{
  if (a2)
  {
    *(void *)a2 = 0;
    *(_DWORD *)(a2 + 8) = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  *((unsigned char *)this + 136) = CFWriteStreamOpen(*((CFWriteStreamRef *)this + 16));
  if (a2 | (unint64_t)a3)
  {
    CFStreamStatus Status = CFWriteStreamGetStatus(*((CFWriteStreamRef *)this + 16));
    if (a3) {
      *a3 = Status > kCFStreamStatusOpening;
    }
    if (a2 && Status == kCFStreamStatusError)
    {
      uint64_t v7 = (__CFWriteStream *)*((void *)this + 16);
      if (v7 && (CFErrorRef v8 = CFWriteStreamCopyError(v7)) != 0)
      {
        CFIndex v9 = v8;
        CFIndex v10 = _CFStreamErrorFromCFError(v8);
        uint64_t v12 = v11;
        CFRelease(v9);
      }
      else
      {
        uint64_t v12 = 0;
        CFIndex v10 = 0;
      }
      *(void *)a2 = v10;
      *(void *)(a2 + 8) = v12;
    }
  }
  return *((unsigned __int8 *)this + 136);
}

CFTypeRef non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_CopyProperty(CFWriteStreamRef *this, const __CFString *a2)
{
  return CFWriteStreamCopyProperty(this[1], a2);
}

uint64_t non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_SetProperty(CFWriteStreamRef *this, const __CFString *a2, const void *a3)
{
  return CFWriteStreamSetProperty(this[1], a2, a3);
}

void non-virtual thunk to'CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream(CoreWriteStreamFromCFWriteStream *this)
{
}

{
  CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream((CoreWriteStreamFromCFWriteStream *)((char *)this - 120));
}

{
  CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream((CoreWriteStreamFromCFWriteStream *)((char *)this - 8));
}

{
  CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream((CoreWriteStreamFromCFWriteStream *)((char *)this - 8));
}

void CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream(CoreWriteStreamFromCFWriteStream *this)
{
  *(void *)this = &unk_1ECFA5178;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECFA5210;
  uint64_t v2 = (const void *)*((void *)this + 16);
  *((void *)this + 15) = &unk_1ECFA5230;
  *((void *)this + 16) = 0;
  if (v2) {
    CFRelease(v2);
  }

  CoreStreamBase::~CoreStreamBase(this);
}

void sub_1841D0F00(_Unwind_Exception *a1)
{
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

void CoreWriteStreamFromCFWriteStream::_streamImpl_UpdateScheduling(CoreWriteStreamFromCFWriteStream *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  CoreSchedulingSet::_scheduleStream((uint64_t)a2, *((void *)this + 16), (void (*)(uint64_t, uint64_t))_CFStreamUnscheduleFromDispatchQueue, MEMORY[0x1E4F1C2D8]);
  uint64_t v5 = *((void *)this + 16);
  CFIndex v6 = (void (*)(uint64_t, uint64_t))MEMORY[0x1E4F1C2D0];
  uint64_t v7 = MEMORY[0x1E4F1C2C8];

  CoreSchedulingSet::_scheduleStream((uint64_t)a3, v5, v6, v7);
}

void CoreWriteStreamFromCFWriteStream::_streamImpl_Close(CoreWriteStreamFromCFWriteStream *this)
{
  if (*((unsigned char *)this + 136))
  {
    if (!*((unsigned char *)this + 137))
    {
      *((unsigned char *)this + 137) = 1;
      CFWriteStreamClose(*((CFWriteStreamRef *)this + 16));
    }
  }
}

CFTypeRef CoreWriteStreamFromCFWriteStream::_streamImpl_CopyProperty(CFWriteStreamRef *this, const __CFString *a2)
{
  return CFWriteStreamCopyProperty(this[16], a2);
}

uint64_t CoreWriteStreamFromCFWriteStream::_streamImpl_SetProperty(CFWriteStreamRef *this, const __CFString *a2, const void *a3)
{
  return CFWriteStreamSetProperty(this[16], a2, a3);
}

uint64_t CoreWriteStreamFromCFWriteStream::_streamImpl_CanWrite(CFWriteStreamRef *this)
{
  return CFWriteStreamCanAcceptBytes(this[16]);
}

CFWriteStreamRef CoreWriteStreamFromCFWriteStream::streamSetClient(CFWriteStreamRef *this, CFOptionFlags a2, CoreStreamClient *a3)
{
  if (a3)
  {
    clientContext.version = 0;
    clientContext.mach_timebase_info info = this;
    clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
    clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
    CFWriteStreamSetClient(this[16], a2, (CFWriteStreamClientCallBack)CoreWriteStreamFromCFWriteStream::_writeStreamClientCallBack, &clientContext);
    return (CFWriteStreamRef)CoreStreamBase::streamSetClient((uint64_t)this, a2, a3);
  }
  else
  {
    CFWriteStreamSetClient(this[16], 0, 0, 0);
    CFWriteStreamRef result = this[2];
    this[2] = 0;
    if (result)
    {
      uint64_t v7 = *(uint64_t (**)(void))(*(void *)result + 24);
      return (CFWriteStreamRef)v7();
    }
  }
  return result;
}

void CoreWriteStreamFromCFWriteStream::_writeStreamClientCallBack(CoreWriteStreamFromCFWriteStream *this, uint64_t a2, CoreStreamBase *a3, void *a4)
{
  if (a2 == 8)
  {
    if (this && (uint64_t v5 = CFWriteStreamCopyError(this)) != 0)
    {
      CFIndex v6 = v5;
      CFIndex v7 = _CFStreamErrorFromCFError(v5);
      uint64_t v9 = v8;
      CFRelease(v6);
    }
    else
    {
      uint64_t v9 = 0;
      CFIndex v7 = 0;
    }
    CFIndex v10 = a3;
    a2 = 8;
    v11.CFStringRef domain = v7;
    *(void *)&v11.CFErrorRef error = v9;
  }
  else
  {
    CFIndex v10 = a3;
    v11.CFStringRef domain = 0;
    *(void *)&v11.CFErrorRef error = 0;
  }

  CoreStreamBase::_signalEvent(v10, a2, v11, 1);
}

void CoreWriteStreamBase::CoreWriteStreamBase(CoreWriteStreamBase *this, const char *a2)
{
  *((_DWORD *)this + 26) = 0;
  *((void *)this + 3) = (char *)this + 120;
  *(void *)this = &unk_1ECF9FA90;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9FAF8;
  *((void *)this + 15) = &unk_1ECF9FB18;
}

uint64_t CoreWriteStream::setClient(uint64_t a1, uint64_t a2, uint64_t a3, const CFStreamClientContext *a4)
{
  if (a3)
  {
    uint64_t v8 = a1 - 16;
    CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)(a1 - 16));
    CFIndex v10 = (char *)CFAllocatorAllocate(v9, 96, 0);
    *(_OWORD *)CFIndex v10 = 0u;
    *((_OWORD *)v10 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 4) = 0u;
    CFStreamError v11 = v10 + 64;
    CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)(a1 - 16));
    ClassicStreamClient::ClassicStreamClient((ClassicStreamClient *)v10, v12, a4);
    *((void *)v10 + 9) = v8;
    *((void *)v10 + 1_CFNetworkResetHSTSHostsSinceDate(0, 0) = v8;
    *(void *)CFIndex v10 = &unk_1ECF9EF00;
    *((void *)v10 + 8) = &unk_1ECF9EF70;
    *((void *)v10 + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = a3;
  }
  else
  {
    CFStreamError v11 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 56))(a1, a2, v11);
  if (v11)
  {
    BOOL v14 = *(uint64_t (**)(char *))(*(void *)v11 + 24);
    return v14(v11);
  }
  return result;
}

uint64_t non-virtual thunk to'ClassicWriteClient::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ClassicWriteClient::coreStreamWriteEvent(a1 - 64, a2, a3);
}

uint64_t ClassicWriteClient::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  CFIndex v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 88);
  uint64_t v7 = *(void *)(a1 + 32);

  return v6(a2, a3, v7);
}

void non-virtual thunk to'ClassicWriteClient::coreStreamEventsAvailable(ClassicWriteClient *this, uint64_t a2)
{
}

void ClassicWriteClient::coreStreamEventsAvailable(ClassicWriteClient *this, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*((void *)this + 10) && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
    if (!v2) {
      return;
    }
  }
  else if (!a2)
  {
    return;
  }
  uint64_t v4 = 1;
  do
  {
    if ((v4 & ~v2) == 0)
    {
      (*(void (**)(ClassicWriteClient *, void, uint64_t))(*(void *)this + 80))(this, *((void *)this + 10), v4);
      v2 &= ~v4;
    }
    v4 *= 2;
  }
  while (v2);
}

CFStringRef non-virtual thunk to'ClassicWriteClient::coreStreamClientCopyDescription(ClassicWriteClient *this)
{
  return ClassicStreamClient::clientCopyDescription((ClassicWriteClient *)((char *)this - 64));
}

uint64_t non-virtual thunk to'ClassicWriteClient::coreStreamClientRelease(ClassicWriteClient *this)
{
  return (*(uint64_t (**)(void))(*((void *)this - 8) + 48))();
}

ClassicWriteClient *non-virtual thunk to'ClassicWriteClient::coreStreamClientRetain(ClassicWriteClient *this)
{
  return this;
}

void non-virtual thunk to'ClassicWriteClient::~ClassicWriteClient(ClassicWriteClient *this)
{
  uint64_t v2 = (char *)this - 64;
  ClassicWriteClient::~ClassicWriteClient((ClassicWriteClient *)((char *)this - 64));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 7);

  CFAllocatorDeallocate(v3, v2);
}

{
  ClassicWriteClient::~ClassicWriteClient((ClassicWriteClient *)((char *)this - 64));
}

void ClassicWriteClient::~ClassicWriteClient(ClassicWriteClient *this)
{
  *((void *)this + 1_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *((void *)this + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  *((void *)this + 8) = &unk_1ECFA1BD0;
  *((void *)this + 9) = 0;
  *(void *)this = &unk_1ECF9FA48;
  if (*((void *)this + 4))
  {
    uint64_t v1 = (void (*)(void))*((void *)this + 6);
    if (v1) {
      v1();
    }
  }
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  ClassicWriteClient::~ClassicWriteClient(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

uint64_t ClassicWriteClient::coreStreamClientRelease(ClassicWriteClient *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

char *ClassicWriteClient::coreStreamClientRetain(ClassicWriteClient *this)
{
  uint64_t v1 = (char *)this + 64;
  (*(void (**)(ClassicWriteClient *))(*(void *)this + 40))(this);
  return v1;
}

BOOL ClassicWriteClient::equals(ClassicWriteClient *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

uint64_t CoreWriteStreamCreate(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v7 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v7 = Instance + 16;
    *(void *)(Instance + 256) = 0;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 24_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 16_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }
  CoreWriteStreamBase::CoreWriteStreamBase((CoreWriteStreamBase *)v7, v6);
  *(void *)uint64_t v7 = &unk_1ECFA4448;
  *(void *)(v7 + 8) = &unk_1ECFA44E8;
  *(void *)(v7 + 12_CFNetworkResetHSTSHostsSinceDate(0, 0) = &unk_1ECFA4508;
  long long v9 = a2[1];
  long long v8 = a2[2];
  *(_OWORD *)(v7 + 136) = *a2;
  *(_OWORD *)(v7 + 168) = v8;
  *(_OWORD *)(v7 + 152) = v9;
  long long v10 = a2[3];
  long long v11 = a2[4];
  long long v12 = a2[5];
  *(_OWORD *)(v7 + 232) = a2[6];
  *(_OWORD *)(v7 + 216) = v12;
  *(_OWORD *)(v7 + 20_CFNetworkResetHSTSHostsSinceDate(0, 0) = v11;
  *(_OWORD *)(v7 + 184) = v10;
  uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 144);
  if (v13) {
    a3 = v13(v7 - 16, a3);
  }
  *(void *)(v7 + 128) = a3;
  return v7 - 16;
}

void sub_1841D17DC(_Unwind_Exception *a1)
{
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Unschedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 120);
  if (v3) {
    return v3(this - 136, a2, a3, *(void *)(this + 8));
  }
  return this;
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Schedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 112);
  if (v3) {
    return v3(this - 136, a2, a3, *(void *)(this + 8));
  }
  return this;
}

BOOL non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_CanWrite(CoreWriteStreamWithCallbacks *this)
{
  uint64_t v1 = (unsigned int (*)(char *, void))*((void *)this + 9);
  return v1 && v1((char *)this - 136, *((void *)this + 1)) != 0;
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_Write(CoreWriteStreamWithCallbacks *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  if (a4)
  {
    a4->CFStringRef domain = 0;
    a4->CFErrorRef error = 0;
  }
  uint64_t v4 = (uint64_t (*)(char *, const unsigned __int8 *))*((void *)this + 8);
  if (v4) {
    return v4((char *)this - 136, a2);
  }
  else {
    return -1;
  }
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_Close(uint64_t this)
{
  uint64_t v1 = *(uint64_t (**)(uint64_t, void))(this + 80);
  if (v1) {
    return v1(this - 136, *(void *)(this + 8));
  }
  return this;
}

BOOL non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_OpenCompleted(CoreWriteStreamWithCallbacks *this, CFStreamError *a2)
{
  if (a2)
  {
    a2->CFStringRef domain = 0;
    a2->CFErrorRef error = 0;
  }
  uint64_t v2 = (unsigned int (*)(char *))*((void *)this + 7);
  return v2 && v2((char *)this - 136) != 0;
}

BOOL non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_Open(CoreWriteStreamWithCallbacks *this, CFStreamError *a2, unsigned __int8 *a3)
{
  if (a2)
  {
    a2->CFStringRef domain = 0;
    a2->CFErrorRef error = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  CFAllocatorRef v3 = (unsigned int (*)(char *))*((void *)this + 6);
  return v3 && v3((char *)this - 136) != 0;
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_RequestEvents(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t, void))(this + 104);
  if (v2) {
    return v2(this - 136, a2, *(void *)(this + 8));
  }
  return this;
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_CopyProperty(CoreWriteStreamWithCallbacks *this, const __CFString *a2)
{
  uint64_t v2 = (uint64_t (*)(char *, const __CFString *, void))*((void *)this + 11);
  if (v2) {
    return v2((char *)this - 136, a2, *((void *)this + 1));
  }
  else {
    return 0;
  }
}

BOOL non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_SetProperty(CoreWriteStreamWithCallbacks *this, const __CFString *a2, const void *a3)
{
  CFAllocatorRef v3 = (unsigned int (*)(char *, const __CFString *, const void *, void))*((void *)this + 12);
  return v3 && v3((char *)this - 136, a2, a3, *((void *)this + 1)) != 0;
}

void non-virtual thunk to'CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks(CoreWriteStreamWithCallbacks *this)
{
}

{
  CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks((CoreWriteStreamWithCallbacks *)((char *)this - 120));
}

{
  CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks((CoreWriteStreamWithCallbacks *)((char *)this - 8));
}

{
  CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks((CoreWriteStreamWithCallbacks *)((char *)this - 8));
}

void CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks(CoreWriteStreamWithCallbacks *this)
{
  *(void *)this = &unk_1ECFA4448;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECFA44E8;
  *((void *)this + 15) = &unk_1ECFA4508;
  uint64_t v2 = (void (*)(char *, void))*((void *)this + 19);
  if (v2) {
    v2((char *)this - 16, *((void *)this + 16));
  }

  CoreStreamBase::~CoreStreamBase(this);
}

void sub_1841D1A68(_Unwind_Exception *a1)
{
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Unschedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 240);
  if (v3) {
    return v3(this - 16, a2, a3, *(void *)(this + 128));
  }
  return this;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Schedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 232);
  if (v3) {
    return v3(this - 16, a2, a3, *(void *)(this + 128));
  }
  return this;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_Close(uint64_t this)
{
  uint64_t v1 = *(uint64_t (**)(uint64_t, void))(this + 200);
  if (v1) {
    return v1(this - 16, *(void *)(this + 128));
  }
  return this;
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_OpenCompleted(CoreWriteStreamWithCallbacks *this, CFStreamError *a2)
{
  if (a2)
  {
    a2->CFStringRef domain = 0;
    a2->CFErrorRef error = 0;
  }
  uint64_t v2 = (unsigned int (*)(char *))*((void *)this + 22);
  return v2 && v2((char *)this - 16) != 0;
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_Open(CoreWriteStreamWithCallbacks *this, CFStreamError *a2, unsigned __int8 *a3)
{
  if (a2)
  {
    a2->CFStringRef domain = 0;
    a2->CFErrorRef error = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  CFAllocatorRef v3 = (unsigned int (*)(char *))*((void *)this + 21);
  return v3 && v3((char *)this - 16) != 0;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_CopyProperty(CoreWriteStreamWithCallbacks *this, const __CFString *a2)
{
  uint64_t v2 = (uint64_t (*)(char *, const __CFString *, void))*((void *)this + 26);
  if (v2) {
    return v2((char *)this - 16, a2, *((void *)this + 16));
  }
  else {
    return 0;
  }
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_SetProperty(CoreWriteStreamWithCallbacks *this, const __CFString *a2, const void *a3)
{
  CFAllocatorRef v3 = (unsigned int (*)(char *, const __CFString *, const void *, void))*((void *)this + 27);
  return v3 && v3((char *)this - 16, a2, a3, *((void *)this + 16)) != 0;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_RequestEvents(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t, void))(this + 224);
  if (v2) {
    return v2(this - 16, a2, *(void *)(this + 128));
  }
  return this;
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_CanWrite(CoreWriteStreamWithCallbacks *this)
{
  uint64_t v1 = (unsigned int (*)(char *, void))*((void *)this + 24);
  return v1 && v1((char *)this - 16, *((void *)this + 16)) != 0;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_Write(CoreWriteStreamWithCallbacks *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  if (a4)
  {
    a4->CFStringRef domain = 0;
    a4->CFErrorRef error = 0;
  }
  uint64_t v4 = (uint64_t (*)(char *, const unsigned __int8 *))*((void *)this + 23);
  if (v4) {
    return v4((char *)this - 16, a2);
  }
  else {
    return -1;
  }
}

_OWORD *CoreWriteStreamCreateWithCFWriteStream(const __CFAllocator *a1, __CFWriteStream *a2)
{
  if (!a2) {
    return 0;
  }
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v5 = (CoreWriteStreamBase *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v5 = (CoreWriteStreamBase *)(Instance + 1);
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  CoreWriteStreamBase::CoreWriteStreamBase(v5, v4);
  *(void *)uint64_t v5 = &unk_1ECFA5178;
  *((void *)v5 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECFA5210;
  *((void *)v5 + 15) = &unk_1ECFA5230;
  *((void *)v5 + 16) = CFRetain(a2);
  *((_WORD *)v5 + 68) = 0;
  return (_OWORD *)((char *)v5 - 16);
}

void sub_1841D1D74(_Unwind_Exception *a1)
{
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFWriteStreamCreateWithCoreStream()
{
  if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }

  return CFWriteStreamCreate();
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_unschedule(int a1, __CFRunLoop *a2, const __CFString *a3, os_unfair_lock_s *this)
{
  return CoreStreamBase::_streamInterface_Deprecated_Unschedule(this, a2, a3);
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_schedule(int a1, __CFRunLoop *a2, const __CFString *a3, os_unfair_lock_s *this)
{
  return CoreStreamBase::_streamInterface_Deprecated_Schedule(this, a2, a3);
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_requestEvents(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a3 + 80))(a3);
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_setProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  ++*(void *)(a4 + 80);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a4 + 24) + 32))(*(void *)(a4 + 24));
  --*(void *)(a4 + 80);
  return result;
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_copyProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ++*(void *)(a3 + 80);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a3 + 24) + 40))(*(void *)(a3 + 24));
  --*(void *)(a3 + 80);
  return result;
}

void CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_close(uint64_t a1, CoreStreamBase *a2)
{
  (*(void (**)(CoreStreamBase *, void, void))(*(void *)a2 + 56))(a2, 0, 0);

  CoreStreamBase::_streamInterface_Close(a2);
}

uint64_t CoreWriteStreamCFStreamSupport::_stream_canWrite(CoreWriteStreamCFStreamSupport *this, __CFWriteStream *a2, void *a3)
{
  uint64_t v4 = CoreStreamBase::_streamInterface_CanWrite(a2);
  if (!v4)
  {
    uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(a2);
    if (Status == 5 || Status == 7) {
      CFWriteStreamSignalEvent();
    }
  }
  return v4;
}

uint64_t CoreWriteStreamCFStreamSupport::_stream_write(CoreWriteStreamCFStreamSupport *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, void *a6)
{
  if (a4)
  {
    *(void *)a4 = 0;
    *(_DWORD *)(a4 + 8) = 0;
  }
  uint64_t v8 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)a5, (const unsigned __int8 *)a2, (uint64_t)a3);
  uint64_t Status = CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)a5);
  if (a4 && Status == 7) {
    *(CFStreamError *)a4 = *(CFStreamError *)((char *)a5 + 56);
  }
  return v8;
}

BOOL CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_openCompleted(int a1, uint64_t a2, CoreStreamBase *this)
{
  uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (a2)
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(void *)a2 = 0;
    if (Status == 7) {
      *(_OWORD *)a2 = *(_OWORD *)((char *)this + 56);
    }
  }
  return Status > 1;
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_open(int a1, uint64_t a2, unsigned char *a3, CoreStreamBase *this)
{
  if (a2)
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(void *)a2 = 0;
  }
  if (a3)
  {
    *a3 = 0;
    uint64_t v7 = CoreStreamBase::_streamInterface_Open(this);
    if (v7)
    {
      uint64_t v8 = v7;
      *a3 = (*(uint64_t (**)(char *, uint64_t))(*((void *)this + 15) + 64))((char *)this + 120, a2);
      return v8;
    }
    if (!a2) {
      return 0;
    }
LABEL_10:
    uint64_t v8 = 0;
    *(_OWORD *)a2 = *(_OWORD *)((char *)this + 56);
    return v8;
  }
  uint64_t v9 = CoreStreamBase::_streamInterface_Open(this);
  uint64_t v8 = v9;
  if (a2 && !v9) {
    goto LABEL_10;
  }
  return v8;
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_copyDescription(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
}

void CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_finalize(uint64_t a1, uint64_t a2)
{
}

__CFWriteStream *CoreWriteStreamCFStreamSupport::_stream_create_and_bump_refcount(CoreWriteStreamCFStreamSupport *this, __CFWriteStream *a2, void *a3)
{
  uint64_t v5 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  CFAllocatorRef v6 = CFGetAllocator(this);
  uint64_t v7 = CFAllocatorAllocate(v6, 56, 0);
  *uint64_t v7 = 0u;
  v7[1] = 0u;
  int v7[2] = 0u;
  *((void *)v7 + 6) = 0;
  CFAllocatorRef v8 = CFGetAllocator(this);
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)v7, v8);
  *(void *)uint64_t v7 = &unk_1ECFA4DA0;
  *((void *)v7 + 3) = &unk_1ECFA4E10;
  *((void *)v7 + 4) = v5;
  *((void *)v7 + 5) = this;
  *((void *)v7 + 6) = CFRetain(v5);
  (*(void (**)(__CFWriteStream *, uint64_t, uint64_t))(*(void *)a2 + 56))(a2, -1, (uint64_t)v7 + 24);
  (*(void (**)(_OWORD *))(*(void *)v7 + 48))(v7);
  return a2;
}

void sub_1841D229C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 24) = &unk_1ECFA1BD0;
  *(void *)(v1 + 32) = 0;
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CoreWriteStreamCFStreamSupport::coreStreamWriteEvent(a1 - 24, a2, a3);
}

uint64_t CoreWriteStreamCFStreamSupport::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 48) && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  if (a3 == 8 && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1) {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3661);
  }
  return CFWriteStreamSignalEvent();
}

CFTypeRef non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientCopyCFStreamRef(CoreWriteStreamCFStreamSupport *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 2);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

CFStringRef non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientCopyDescription(CoreWriteStreamCFStreamSupport *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<write side %p to stream %p>", *((void *)this + 3), *((void *)this + 2));
}

uint64_t non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientRelease(CoreWriteStreamCFStreamSupport *this)
{
  return CoreWriteStreamCFStreamSupport::coreStreamClientRelease((CoreWriteStreamCFStreamSupport *)((char *)this - 24));
}

uint64_t CoreWriteStreamCFStreamSupport::coreStreamClientRelease(CoreWriteStreamCFStreamSupport *this)
{
  uint64_t v2 = (const void *)*((void *)this + 6);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = *(uint64_t (**)(CoreWriteStreamCFStreamSupport *))(*(void *)this + 48);

  return v3(this);
}

uint64_t non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientRetain(CoreWriteStreamCFStreamSupport *this)
{
  return CoreWriteStreamCFStreamSupport::coreStreamClientRetain((CoreWriteStreamCFStreamSupport *)((char *)this - 24));
}

uint64_t CoreWriteStreamCFStreamSupport::coreStreamClientRetain(CoreWriteStreamCFStreamSupport *this)
{
  (*(void (**)(CoreWriteStreamCFStreamSupport *))(*(void *)this + 40))(this);
  uint64_t v2 = (const void *)*((void *)this + 6);
  if (v2) {
    CFRetain(v2);
  }
  return (uint64_t)this + 24;
}

void non-virtual thunk to'CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport(CoreWriteStreamCFStreamSupport *this)
{
  uint64_t v2 = (char *)this - 24;
  CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport((CoreWriteStreamCFStreamSupport *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport((CoreWriteStreamCFStreamSupport *)((char *)this - 24));
}

void CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport(CoreWriteStreamCFStreamSupport *this)
{
  *(void *)this = &unk_1ECFA4DA0;
  *((void *)this + 3) = &unk_1ECFA4E10;
  uint64_t v2 = (const void *)*((void *)this + 6);
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 3) = &unk_1ECFA1BD0;
  *((void *)this + 4) = 0;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1841D2568(_Unwind_Exception *a1)
{
  *(void *)(v1 + 24) = &unk_1ECFA1BD0;
  *(void *)(v1 + 32) = 0;
  _Unwind_Resume(a1);
}

CFStringRef CoreWriteStreamCFStreamSupport::coreStreamClientCopyDescription(CoreWriteStreamCFStreamSupport *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<write side %p to stream %p>", *((void *)this + 6), *((void *)this + 5));
}

CFTypeRef CoreWriteStreamCFStreamSupport::coreStreamClientCopyCFStreamRef(CoreWriteStreamCFStreamSupport *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 5);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

BOOL CoreWriteStreamCFStreamSupport::equals(CoreWriteStreamCFStreamSupport *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

uint64_t ___ZL17resumeDataClassesv_block_invoke_3759()
{
  os_log_t v0 = (void *)MEMORY[0x1E4F1CA80];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  resumeDataClasses(void)::resumeDataClasses = (uint64_t)(id)objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, objc_opt_class(), 0);
  gotLoadHelper_x20__OBJC_CLASS___SZExtractor(v7);
  if (objc_opt_class())
  {
    uint64_t v8 = [*(id *)(v1 + 2640) knownSZExtractorImplementations];
    [(id)resumeDataClasses(void)::resumeDataClasses unionSet:v8];
  }
  uint64_t result = objc_opt_class();
  if (result)
  {
    long long v11 = (void *)resumeDataClasses(void)::resumeDataClasses;
    gotLoadHelper_x8__OBJC_CLASS___STRemoteExtractor(v10);
    uint64_t v12 = objc_opt_class();
    return [v11 addObject:v12];
  }
  return result;
}

void sub_1841D31E0(_Unwind_Exception *a1)
{
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_3851()
{
}

void sub_1841D3558(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'NSCFURLProtocolClient::~NSCFURLProtocolClient(NSCFURLProtocolClient *this)
{
  this[-1].var3 = &unk_1ECFA1E90;
  this->var1 = 0;
  this->var2 = 0;
  this->var0 = (void **)&unk_1ECF9B550;
  JUMPOUT(0x18531B6D0);
}

{
  this[-1].var3 = &unk_1ECFA1E90;
  this->var1 = 0;
  this->var2 = 0;
  this->var0 = (void **)&unk_1ECF9B550;
}

void NSCFURLProtocolClient::~NSCFURLProtocolClient(NSCFURLProtocolClient *this)
{
  this->var0 = (void **)&unk_1ECFA1E90;
  this->var2 = 0;
  this->var3 = 0;
  this->var1 = (void **)&unk_1ECF9B550;
  JUMPOUT(0x18531B6D0);
}

{
  this->var0 = (void **)&unk_1ECFA1E90;
  this->var2 = 0;
  this->var3 = 0;
  this->var1 = (void **)&unk_1ECF9B550;
}

uint64_t NSCFURLProtocolClient::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 152))(result, 0);
  }
  return result;
}

void NSCFURLProtocolClient::protocolReceivedSocketStreamsForUpgradeHeaderAvailable(NSCFURLProtocolClient *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream) {
    CFReadStreamClose(stream);
  }
  if (a3)
  {
    CFWriteStreamClose(a3);
  }
}

void NSCFURLProtocolClient::protocolDidReceiveAuthenticationChallenge(NSCFURLProtocolClient *this, _CFURLAuthChallenge *a2)
{
  id v3 = +[NSURLAuthenticationChallenge _createAuthenticationChallengeForCFAuthChallenge:a2 sender:this->var3];
  [this->var2 URLProtocol:this->var3 didReceiveAuthenticationChallenge:v3];
}

uint64_t NSCFURLProtocolClient::protocolDidFail(NSCFURLProtocolClient *this, __CFError *a2)
{
  return [this->var2 URLProtocol:this->var3 didFailWithError:a2];
}

uint64_t NSCFURLProtocolClient::protocolDidFinishLoading(NSCFURLProtocolClient *this)
{
  return [this->var2 URLProtocolDidFinishLoading:this->var3];
}

uint64_t NSCFURLProtocolClient::protocolDidLoadData(NSCFURLProtocolClient *this, const __CFData *a2)
{
  return [this->var2 URLProtocol:this->var3 didLoadData:a2];
}

uint64_t NSCFURLProtocolClient::protocolDidReceiveResponse(NSCFURLProtocolClient *this, _CFURLResponse *a2)
{
  id v4 = +[NSURLResponse _responseWithCFURLResponse:a2];
  id var2 = this->var2;
  id var3 = this->var3;
  uint64_t v7 = *(int *)([(_CFURLResponse *)a2 _inner] + 72);

  return [var2 URLProtocol:var3 didReceiveResponse:v4 cacheStoragePolicy:v7];
}

void NSCFURLProtocolClient::protocolCacheResponseIsValid(NSCFURLProtocolClient *this, const _CFCachedURLResponse *a2)
{
  id v3 = [[NSCachedURLResponse alloc] _initWithCFCachedURLResponse:a2];
  [this->var2 URLProtocol:this->var3 cachedResponseIsValid:v3];
}

uint64_t NSCFURLProtocolClient::protocolWasRedirected(NSCFURLProtocolClient *this, NSURLRequest *a2, _CFURLResponse *a3)
{
  id v5 = +[NSURLResponse _responseWithCFURLResponse:a3];
  id var2 = this->var2;
  id var3 = this->var3;

  return [var2 URLProtocol:var3 wasRedirectedToRequest:a2 redirectResponse:v5];
}

CFStringRef NSCFURLProtocolClient::protocolCopyDescription(NSCFURLProtocolClient *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"NSCFURLProtocolClient@%p:%p { %@ }", this, this->var2, this->var2);
}

void NSCFURLProtocolClient::protocolReleaseClient(NSCFURLProtocolClient *this)
{
}

id NSCFURLProtocolClient::protocolRetainClient(NSCFURLProtocolClient *this)
{
  return this->var2;
}

void non-virtual thunk to'ClassicURLConnection::~ClassicURLConnection(ClassicURLConnection *this)
{
}

{
  ClassicURLConnection::~ClassicURLConnection((ClassicURLConnection *)((char *)this - 16));
}

{
  ClassicURLConnection::~ClassicURLConnection((ClassicURLConnection *)((char *)this - 8));
}

{
  ClassicURLConnection::~ClassicURLConnection((ClassicURLConnection *)((char *)this - 8));
}

void ClassicURLConnection::~ClassicURLConnection(ClassicURLConnection *this)
{
  *(void *)this = &unk_1ECFA1090;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECFA1180;
  *((void *)this + 2) = &unk_1ECFA11E0;
  uint64_t v2 = *((void *)this + 4);
  if (v2 && !*(unsigned char *)(v2 + 25) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "loader not invalidated", buf, 2u);
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3 && !*(unsigned char *)(v3 + 25) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "client not invalidated", v6, 2u);
  }
  uint64_t v4 = *((void *)this + 4);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }

  *((void *)this + 2) = &unk_1ECF9B550;
}

void sub_1841D3E24(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void non-virtual thunk to'ClassicURLConnection::cancel(ClassicURLConnection *this)
{
}

void ClassicURLConnection::cancel(ClassicURLConnection *this)
{
  if (!(*(unsigned int (**)(void))(**((void **)this + 3) + 40))(*((void *)this + 3)))
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZN20ClassicURLConnection6cancelEv_block_invoke;
    void v3[3] = &__block_descriptor_40_e39_v16__0__ConnectionClientInterface_____8l;
    v3[4] = this;
    CFRetain((char *)this - 16);
    uint64_t v2 = *((void *)this + 3);
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    v4[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
    v4[3] = &unk_1E5253560;
    void v4[4] = v3;
    void v4[5] = this;
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    void v5[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
    v5[3] = &unk_1E5257C58;
    v5[4] = v4;
    void v5[5] = v2;
    URLConnectionInstanceData::withWorkQueueAsync(v2, (uint64_t)v5);
  }
}

void ___ZN20ClassicURLConnection6cancelEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  CFRetain((CFTypeRef)(v3 - 16));
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0, 0);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZN20ClassicURLConnection6cancelEv_block_invoke_2;
  v5[3] = &__block_descriptor_40_e5_v8__0l;
  v5[4] = v3;
  if (!(*(unsigned int (**)(uint64_t, dispatch_queue_global_t, void *))(*(void *)a2 + 48))(a2, global_queue, v5))CFRelease((CFTypeRef)(v3 - 16)); {
}
  }

void ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void ___ZN20ClassicURLConnection6cancelEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0, 0);
  uint64_t v3 = global_queue;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN20ClassicURLConnection6cancelEv_block_invoke_3;
  v9[3] = &__block_descriptor_40_e5_v8__0l;
  v9[4] = v1;
  if (!*(void *)(v1 + 32) && !*(void *)(v1 + 24))
  {
    dispatch_async(global_queue, v9);
    return;
  }
  std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject  {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>(&v21, global_queue, v9);
  if (*(void *)(v1 + 32))
  {
    uint64_t v12 = (NSObject **)MEMORY[0x1E4F143A8];
    uint64_t v13 = 3321888768;
    BOOL v14 = ___ZN20ClassicURLConnection25invalidateConnectionAsyncEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
    __int16 v15 = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
    uint64_t v4 = v22;
    uint64_t v16 = v1;
    objc_super v17 = v21;
    uint64_t v18 = v22;
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject  {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>(&v19, v3, &v12);
    uint64_t v5 = *(void *)(v1 + 32);
    uint64_t v6 = v20;
    double v10 = v19;
    long long v11 = v20;
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, NSObject ***))(*(void *)v5 + 16))(v5, &v10);
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
    uint64_t v7 = v18;
    if (!v18) {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v8 = *(void *)(v1 + 24);
    uint64_t v4 = v22;
    uint64_t v12 = v21;
    uint64_t v13 = (uint64_t)v22;
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, NSObject ***))(*(void *)v8 + 16))(v8, &v12);
    uint64_t v7 = (std::__shared_weak_count *)v13;
    if (!v13) {
      goto LABEL_14;
    }
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v7);
LABEL_14:
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void sub_1841D42A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a17);
  }
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN20ClassicURLConnection6cancelEv_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(__CFRunLoopSource **)(v1 + 40);
  if (v2)
  {
    CFRunLoopSourceInvalidate(v2);
    uint64_t v3 = *(const void **)(v1 + 40);
    *(void *)(v1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = *(__CFRunLoop **)(v1 + 48);
    if (v4)
    {
      CFRunLoopWakeUp(v4);
      uint64_t v5 = *(const void **)(v1 + 48);
      *(void *)(v1 + 48) = 0;
      if (v5) {
        CFRelease(v5);
      }
    }
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN20ClassicURLConnection25invalidateConnectionAsyncEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = *(void *)(a1[4] + 24);
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  uint64_t v5 = v2;
  uint64_t v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v3 + 16))(v3, &v5);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_1841D43E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<CoreSchedulingSetOneOff>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6B10;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<CoreSchedulingSetOneOff>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6B10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ClassicURLConnection::withLoaderClientAsync(uint64_t a1, uint64_t a2)
{
}

void ClassicURLConnection::withLoaderClientAsync(uint64_t a1, uint64_t a2)
{
  CFRetain((CFTypeRef)(a1 - 16));
  uint64_t v4 = *(void *)(a1 + 24);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZN20ClassicURLConnection21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke;
  v5[3] = &unk_1E5253588;
  v5[4] = a2;
  void v5[5] = a1;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN19URLConnectionClient21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke;
  void v6[3] = &unk_1E5257C58;
  v6[4] = v5;
  void v6[5] = v4;
  URLConnectionInstanceData::withWorkQueueAsync(v4, (uint64_t)v6);
}

void ___ZN20ClassicURLConnection21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN19URLConnectionClient21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t non-virtual thunk to'ClassicURLConnection::loaderClientSupportsDispatchData(ClassicURLConnection *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 24))();
}

CFStringRef non-virtual thunk to'ClassicURLConnection::copyDebugDesc(ClassicURLConnection *this)
{
  uint64_t v2 = (char *)this - 8;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 24);
  return CFStringCreateWithFormat(v3, 0, @"<CFURLConnection %p> { request = %@ }", v2, *((void *)this + 6));
}

id non-virtual thunk to'ClassicURLConnection::copyOriginalImmutableRequest(id *this)
{
  uint64_t v1 = (void *)[this[6] originalRequest];

  return v1;
}

uint64_t ClassicURLConnection::loaderClientSupportsDispatchData(ClassicURLConnection *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 24))();
}

id ClassicURLConnection::copyOriginalImmutableRequest(id *this)
{
  uint64_t v1 = (void *)[this[7] originalRequest];

  return v1;
}

CFTypeRef ClassicURLConnection::copyPeerAddress(ClassicURLConnection *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = (os_unfair_lock_s *)(v1 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 208));
  CFAllocatorRef v3 = *(const void **)(v1 + 200);
  if (v3) {
    CFTypeRef v4 = CFRetain(v3);
  }
  else {
    CFTypeRef v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

uint64_t ClassicURLConnection::canUpdateForCFURLDownload(ClassicURLConnection *this)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  char v10 = 0;
  uint64_t v2 = dispatch_semaphore_create(0);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN20ClassicURLConnection25canUpdateForCFURLDownloadEv_block_invoke;
  void v6[3] = &unk_1E5253538;
  v6[4] = v2;
  void v6[5] = &v7;
  CFRetain((char *)this - 16);
  uint64_t v3 = *((void *)this + 3);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  void v11[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v11[3] = &unk_1E5253560;
  void v11[4] = v6;
  void v11[5] = this;
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  _DWORD v12[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v12[3] = &unk_1E5257C58;
  v12[4] = v11;
  v12[5] = v3;
  URLConnectionInstanceData::withWorkQueueAsync(v3, (uint64_t)v12);
  dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v2);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1841D4848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t ___ZN20ClassicURLConnection25canUpdateForCFURLDownloadEv_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  uint64_t v3 = *(NSObject **)(a1 + 32);

  return dispatch_semaphore_signal(v3);
}

void ClassicURLConnection::updateClientForCFURLDownload_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = dispatch_semaphore_create(0);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN20ClassicURLConnection33updateClientForCFURLDownload_syncEP24CFURLConnectionClient_V1_block_invoke;
  void v6[3] = &unk_1E5253510;
  v6[4] = v4;
  void v6[5] = a2;
  CFRetain((CFTypeRef)(a1 - 16));
  uint64_t v5 = *(void *)(a1 + 24);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  int v7[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v7[3] = &unk_1E5253560;
  v7[4] = v6;
  void v7[5] = a1;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  _DWORD v8[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  void v8[3] = &unk_1E5257C58;
  v8[4] = v7;
  void v8[5] = v5;
  URLConnectionInstanceData::withWorkQueueAsync(v5, (uint64_t)v8);
  dispatch_semaphore_wait(v4, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v4);
}

intptr_t ___ZN20ClassicURLConnection33updateClientForCFURLDownload_syncEP24CFURLConnectionClient_V1_block_invoke(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(a1 + 40));
  uint64_t v3 = *(NSObject **)(a1 + 32);

  return dispatch_semaphore_signal(v3);
}

void ClassicURLConnection::unscheduleLoaderFromRunLoop(ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v3 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_error_impl(&dword_184085000, v3, OS_LOG_TYPE_ERROR, "Rescheduling the CFNetwork loader is no longer supported", v4, 2u);
  }
}

void ClassicURLConnection::scheduleLoaderWithRunLoop(ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v3 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_error_impl(&dword_184085000, v3, OS_LOG_TYPE_ERROR, "Rescheduling the CFNetwork loader is no longer supported", v4, 2u);
  }
}

uint64_t ClassicURLConnection::setDelegateDispatchQueue(CoreSchedulingSet *a1, NSObject *a2)
{
  if (a2)
  {
    Empty = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 96, 0);
    *(_OWORD *)Empty = 0u;
    *((_OWORD *)Empty + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
    *((_OWORD *)Empty + 2) = 0u;
    *((_OWORD *)Empty + 3) = 0u;
    *((_OWORD *)Empty + 4) = 0u;
    *((_OWORD *)Empty + 5) = 0u;
    QCoreSchedulingSet::QCoreSchedulingSet(Empty, a2);
  }
  else
  {
    Empty = (CFAllocatedReferenceCountedObject *)CoreSchedulingSet::createEmpty(a1);
  }
  ClassicURLConnection::setDelegateScheduling((ClassicURLConnection *)a1, (const CoreSchedulingSet *)Empty);
  uint64_t v5 = *(uint64_t (**)(CFAllocatedReferenceCountedObject *))(*(void *)Empty + 48);

  return v5(Empty);
}

void ClassicURLConnection::setDelegateScheduling(ClassicURLConnection *this, const CoreSchedulingSet *a2)
{
  (*(void (**)(const CoreSchedulingSet *))(*(void *)a2 + 40))(a2);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZN20ClassicURLConnection21setDelegateSchedulingEPK17CoreSchedulingSet_block_invoke;
  v5[3] = &__block_descriptor_40_e39_v16__0__ConnectionClientInterface_____8l;
  v5[4] = a2;
  CFRetain((char *)this - 16);
  uint64_t v4 = *((void *)this + 3);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  void v6[3] = &unk_1E5253560;
  v6[4] = v5;
  void v6[5] = this;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  int v7[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v7[3] = &unk_1E5257C58;
  v7[4] = v6;
  void v7[5] = v4;
  URLConnectionInstanceData::withWorkQueueAsync(v4, (uint64_t)v7);
}

uint64_t ___ZN20ClassicURLConnection21setDelegateSchedulingEPK17CoreSchedulingSet_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a2 + 32))(a2)) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 64))(a2, *(void *)(a1 + 32));
  }
  uint64_t v4 = *(uint64_t (**)(void))(**(void **)(a1 + 32) + 48);

  return v4();
}

void ClassicURLConnection::unscheduleFromRunLoop(ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFStringRef v4 = (const __CFString *)*MEMORY[0x1E4F1D418];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN20ClassicURLConnection21unscheduleFromRunLoopEP11__CFRunLoopPK10__CFString_block_invoke;
  void v6[3] = &__block_descriptor_48_e39_v16__0__ConnectionClientInterface_____8l;
  if (a3) {
    CFStringRef v4 = a3;
  }
  v6[4] = a2;
  void v6[5] = v4;
  CFRetain((char *)this - 16);
  uint64_t v5 = *((void *)this + 3);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  int v7[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v7[3] = &unk_1E5253560;
  v7[4] = v6;
  void v7[5] = this;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  _DWORD v8[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  void v8[3] = &unk_1E5257C58;
  v8[4] = v7;
  void v8[5] = v5;
  URLConnectionInstanceData::withWorkQueueAsync(v5, (uint64_t)v8);
}

uint64_t ___ZN20ClassicURLConnection21unscheduleFromRunLoopEP11__CFRunLoopPK10__CFString_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  if (!result)
  {
    if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1) {
      dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
    }
    uint64_t v4 = CoreSchedulingSet::getEmptySet(void)::sEmptySet;
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 64);
    return v5(a2, v4);
  }
  return result;
}

uint64_t ClassicURLConnection::scheduleWithRunLoop(ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  if (a3) {
    CFStringRef v5 = a3;
  }
  else {
    CFStringRef v5 = (const __CFString *)*MEMORY[0x1E4F1D418];
  }
  ClassicURLConnection::pinThisRunLoop(this, a2, v5);
  uint64_t v7 = (const CoreSchedulingSet *)CoreSchedulingSet::create((CoreSchedulingSet *)a2, v5, v6);
  ClassicURLConnection::setDelegateScheduling(this, v7);
  uint64_t v8 = *(uint64_t (**)(const CoreSchedulingSet *))(*(void *)v7 + 48);

  return v8(v7);
}

void ClassicURLConnection::pinThisRunLoop(ClassicURLConnection *this, CFRunLoopRef rl, CFRunLoopMode mode)
{
  CFStringRef v5 = (__CFRunLoopSource *)*((void *)this + 5);
  if (!v5)
  {
    v8.version = 0;
    v8.mach_timebase_info info = (char *)this - 16;
    v8.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E4F1C280];
    v8.release = (void (__cdecl *)(const void *))MEMORY[0x1E4F1C278];
    memset(&v8.copyDescription, 0, 40);
    v8.perform = (void (__cdecl *)(void *))_doNothingPerform;
    CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
    CFStringRef v5 = CFRunLoopSourceCreate(v7, 0, &v8);
    *((void *)this + 5) = v5;
    if (!*((void *)this + 6))
    {
      *((void *)this + 6) = rl;
      if (rl)
      {
        CFRetain(rl);
        CFStringRef v5 = (__CFRunLoopSource *)*((void *)this + 5);
      }
    }
  }
  CFRunLoopAddSource(rl, v5, mode);
}

void ClassicURLConnection::resume(ClassicURLConnection *this)
{
  uint64_t v2 = *((void *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 136));
  *(unsigned char *)(v2 + 14_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 136));
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZN20ClassicURLConnection6resumeEv_block_invoke;
  v4[3] = &__block_descriptor_40_e39_v16__0__ConnectionClientInterface_____8l;
  void v4[4] = this;
  CFRetain((char *)this - 16);
  uint64_t v3 = *((void *)this + 3);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v5[3] = &unk_1E5253560;
  v5[4] = v4;
  void v5[5] = this;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  void v6[3] = &unk_1E5257C58;
  v6[4] = v5;
  void v6[5] = v3;
  URLConnectionInstanceData::withWorkQueueAsync(v3, (uint64_t)v6);
}

uint64_t ___ZN20ClassicURLConnection6resumeEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 56) _metrics];
  if (v3) {
    v4.n128_u64[0] = *(void *)(v3 + 56);
  }
  CFStringRef v5 = *(uint64_t (**)(uint64_t, __n128))(*(void *)a2 + 56);

  return v5(a2, v4);
}

void ClassicURLConnection::halt(id *this)
{
  if (!(*(unsigned int (**)(id))(*(void *)this[3] + 64))(this[3]))
  {
    [this[7] _metrics];
    uint64_t v2 = (os_unfair_lock_s *)this[3];
    os_unfair_lock_lock(v2 + 34);
    LOBYTE(v2[35]._os_unfair_lock_opaque) = 1;
    os_unfair_lock_unlock(v2 + 34);
  }
}

void ClassicURLConnection::rejectChallenge(ClassicURLConnection *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZN20ClassicURLConnection15rejectChallengeEP19_CFURLAuthChallenge_block_invoke;
  v5[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
  v5[4] = cf;
  CFRetain((char *)this - 16);
  uint64_t v4 = *((void *)this + 4);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  void v6[3] = &unk_1E5255CA0;
  v6[4] = v5;
  void v6[5] = this;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  int v7[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v7[3] = &unk_1E5257C58;
  v7[4] = v6;
  void v7[5] = v4;
  URLConnectionInstanceData::withWorkQueueAsync(v4, (uint64_t)v7);
}

void ___ZN20ClassicURLConnection15rejectChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 88))(a2, *(void *)(a1 + 32));
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

void ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void ClassicURLConnection::performDefaultHandlingForChallenge(ClassicURLConnection *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZN20ClassicURLConnection34performDefaultHandlingForChallengeEP19_CFURLAuthChallenge_block_invoke;
  v5[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
  v5[4] = cf;
  CFRetain((char *)this - 16);
  uint64_t v4 = *((void *)this + 4);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  void v6[3] = &unk_1E5255CA0;
  v6[4] = v5;
  void v6[5] = this;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  int v7[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v7[3] = &unk_1E5257C58;
  v7[4] = v6;
  void v7[5] = v4;
  URLConnectionInstanceData::withWorkQueueAsync(v4, (uint64_t)v7);
}

void ___ZN20ClassicURLConnection34performDefaultHandlingForChallengeEP19_CFURLAuthChallenge_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 72))(a2, *(void *)(a1 + 32));
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3)
  {
    CFRelease(v3);
  }
}

void ClassicURLConnection::useCredential(ClassicURLConnection *this, CFTypeRef cf, CFTypeRef a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  int v7[2] = ___ZN20ClassicURLConnection13useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke;
  v7[3] = &__block_descriptor_48_e29_v16__0__LoaderInterface_____8l;
  v7[4] = cf;
  void v7[5] = a3;
  CFRetain((char *)this - 16);
  uint64_t v6 = *((void *)this + 4);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  _DWORD v8[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  void v8[3] = &unk_1E5255CA0;
  v8[4] = v7;
  void v8[5] = this;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v9[3] = &unk_1E5257C58;
  v9[4] = v8;
  void v9[5] = v6;
  URLConnectionInstanceData::withWorkQueueAsync(v6, (uint64_t)v9);
}

void ___ZN20ClassicURLConnection13useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 80))(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    CFRelease(v4);
  }
}

void ClassicURLConnection::start(id *this)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  uint64_t v3 = Current;
  if (Current)
  {
    CFRetain(Current);
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CFRunLoopGetCurrent() unexpectedly returned NULL", buf, 2u);
  }
  CFRetain(this - 2);
  if (!this[5]) {
    ClassicURLConnection::pinThisRunLoop((ClassicURLConnection *)this, v3, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
  }
  uint64_t v4 = (void *)[this[7] originalRequest];
  if (v4 && (*(_WORD *)([v4 _inner] + 64) & 4) != 0) {
    (*(void (**)(id))(*(void *)this[3] + 56))(this[3]);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZN20ClassicURLConnection5startEv_block_invoke;
  void v6[3] = &__block_descriptor_48_e39_v16__0__ConnectionClientInterface_____8l;
  v6[4] = this;
  void v6[5] = v3;
  CFRetain(this - 2);
  uint64_t v5 = (uint64_t)this[3];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  int v7[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v7[3] = &unk_1E5253560;
  v7[4] = v6;
  void v7[5] = this;
  *(void *)long long buf = MEMORY[0x1E4F143A8];
  uint64_t v9 = 3221225472;
  char v10 = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  long long v11 = &unk_1E5257C58;
  uint64_t v12 = v7;
  uint64_t v13 = v5;
  URLConnectionInstanceData::withWorkQueueAsync(v5, (uint64_t)buf);
}

void ___ZN20ClassicURLConnection5startEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = [*(id *)(v4 + 56) _metrics];
  if (v5) {
    v6.n128_u64[0] = *(void *)(v5 + 56);
  }
  (*(void (**)(uint64_t, void, void, __n128))(*(void *)a2 + 40))(a2, *(void *)(a1 + 40), *MEMORY[0x1E4F1D418], v6);
  CFAllocatorRef v7 = *(const void **)(a1 + 40);
  if (v7) {
    CFRelease(v7);
  }

  CFRelease((CFTypeRef)(v4 - 16));
}

CFStringRef ClassicURLConnection::copyDebugDesc(ClassicURLConnection *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"<CFURLConnection %p> { request = %@ }", this, *((void *)this + 7));
}

__CFDictionary *createUpdatedSocketPropertiesForRequest(_CFURLRequest *a1, const __CFDictionary *a2, const __CFDictionary *a3)
{
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFAllocatorRef v7 = v6;
  if (a2) {
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(v6, 0, a2);
  }
  else {
    MutableCFStringRef Copy = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  }
  uint64_t v9 = MutableCopy;
  uint64_t v10 = *(void *)([(_CFURLRequest *)a1 _inner] + 96);
  uint64_t v11 = allowNewHTTP(void)::onceToken;
  if (v10 == 16) {
    goto LABEL_14;
  }
  if (allowNewHTTP(void)::onceToken != -1) {
    dispatch_once(&allowNewHTTP(void)::onceToken, &__block_literal_global_3898);
  }
  int v12 = allowNewHTTP(void)::result;
  if (a3)
  {
    CFBooleanRef v13 = (const __CFBoolean *)CFDictionaryGetValue(a3, &unk_1EC0A37D8);
    if (v13) {
      int v12 = CFBooleanGetValue(v13);
    }
  }
  if (!v12) {
    CFDictionaryAddValue(v9, &unk_1EC09ED40, (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  if (v10 != 64)
  {
    uint64_t v11 = allowNewHTTP(void)::onceToken;
LABEL_14:
    if (v11 != -1) {
      dispatch_once(&allowNewHTTP(void)::onceToken, &__block_literal_global_3898);
    }
    int v14 = allowNewHTTP(void)::result;
    if (a3)
    {
      CFBooleanRef v15 = (const __CFBoolean *)CFDictionaryGetValue(a3, &unk_1EC0A3810);
      if (v15) {
        int v14 = CFBooleanGetValue(v15);
      }
    }
    if (!v14) {
      CFDictionaryAddValue(v9, &unk_1EC09ED78, (const void *)*MEMORY[0x1E4F1CFD0]);
    }
  }
  CFStringRef v16 = *(const __CFString **)([(_CFURLRequest *)a1 _inner] + 112);
  objc_super v17 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (v16) {
    CFStringRef value = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v16);
  }
  else {
    CFStringRef value = 0;
  }
  NetworkServiceTypeString = (const void *)ClassicURLConnection::getNetworkServiceTypeString(*(_DWORD *)([(_CFURLRequest *)a1 _inner] + 104));
  __int16 v19 = *(_WORD *)([(_CFURLRequest *)a1 _inner] + 64);
  if (a2)
  {
    CFDictionaryRef v20 = (const __CFDictionary *)CFDictionaryGetValue(a2, &unk_1EC0A0A58);
    CFDictionaryRef v21 = v20;
    if (v20
      && !CFDictionaryGetValue(v20, @"kConditionalConnectionIdentifier")
      && CFDictionaryGetValue(v21, @"kConditionalConnectionLaunchOnDemand")
      && (CFURLRef v26 = *(const __CFURL **)([(_CFURLRequest *)a1 _inner] + 8)) != 0)
    {
      CFStringRef v22 = CFURLGetString(v26);
    }
    else
    {
      CFStringRef v22 = 0;
    }
  }
  else
  {
    CFStringRef v22 = 0;
    CFDictionaryRef v21 = 0;
  }
  double v23 = *(double *)([(_CFURLRequest *)a1 _inner] + 136);
  double valuePtr = v23;
  double v24 = *(double *)([(_CFURLRequest *)a1 _inner] + 144);
  double v46 = v24;
  if (NetworkServiceTypeString || value || (v19 & 8) == 0 || v22)
  {
    if (!v9) {
      goto LABEL_66;
    }
    if (NetworkServiceTypeString) {
      CFDictionarySetValue(v9, &unk_1EC0A0668, NetworkServiceTypeString);
    }
    if (value) {
      CFDictionarySetValue(v9, &unk_1EC0A0A20, value);
    }
    if ((v19 & 8) == 0) {
      CFDictionarySetValue(v9, &unk_1EC0A0E48, (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    if (v22) {
      goto LABEL_47;
    }
  }
  else if (v23 == 0.0 || v24 == 0.0 || !v9)
  {
    goto LABEL_66;
  }
  if (v23 == 0.0 || v24 == 0.0) {
    goto LABEL_66;
  }
LABEL_47:
  if (v21) {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutableCopy(v7, 0, v21);
  }
  else {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D048], MEMORY[0x1E4F1D540]);
  }
  CFStringRef v27 = Mutable;
  if (Mutable)
  {
    if (v22) {
      CFDictionarySetValue(Mutable, @"kConditionalConnectionIdentifier", v22);
    }
    if (v23 == 0.0 || v24 == 0.0) {
      goto LABEL_65;
    }
    CFNumberRef v28 = CFNumberCreate(v7, kCFNumberDoubleType, &valuePtr);
    CFNumberRef v29 = CFNumberCreate(v7, kCFNumberDoubleType, &v46);
    CFNumberRef v30 = v29;
    if (v28 && v29)
    {
      CFDictionarySetValue(v27, @"kConditionalConnectionRequirementTimeWindowDelay", v28);
      CFDictionarySetValue(v27, @"kConditionalConnectionRequirementTimeWindowDuration", v30);
    }
    else if (!v28)
    {
      goto LABEL_63;
    }
    CFRelease(v28);
LABEL_63:
    if (v30) {
      CFRelease(v30);
    }
LABEL_65:
    CFDictionarySetValue(v9, &unk_1EC0A0A58, v27);
    CFRelease(v27);
  }
LABEL_66:
  if (!a2) {
    goto LABEL_87;
  }
  CFDictionaryRef v31 = (const __CFDictionary *)CFDictionaryGetValue(a2, &unk_1EC0A0A58);
  CFAllocatorRef v32 = *v17;
  if (v31) {
    CFDictionaryRef v33 = CFDictionaryCreateMutableCopy(*v17, 0, v31);
  }
  else {
    CFDictionaryRef v33 = CFDictionaryCreateMutable(*v17, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  CFDictionaryRef v34 = v33;
  if (v33
    && !CFDictionaryGetValue(v33, @"kConditionalConnectionIdentifier")
    && CFDictionaryGetValue(v34, @"kConditionalConnectionLaunchOnDemand")
    && (CFURLRef v44 = *(const __CFURL **)([(_CFURLRequest *)a1 _inner] + 8)) != 0)
  {
    CFStringRef v35 = CFURLGetString(v44);
  }
  else
  {
    CFStringRef v35 = 0;
  }
  double v36 = *(double *)([(_CFURLRequest *)a1 _inner] + 136);
  double v49 = v36;
  double v37 = *(double *)([(_CFURLRequest *)a1 _inner] + 144);
  double v48 = v37;
  if (v36 != 0.0 && v37 != 0.0)
  {
    CFNumberRef v38 = CFNumberCreate(v32, kCFNumberDoubleType, &v49);
    CFNumberRef v39 = CFNumberCreate(v32, kCFNumberDoubleType, &v48);
    CFNumberRef v40 = v39;
    if (v38 && v39)
    {
      CFDictionarySetValue(v34, @"kConditionalConnectionRequirementTimeWindowDelay", v38);
      CFDictionarySetValue(v34, @"kConditionalConnectionRequirementTimeWindowDuration", v40);
    }
    else if (!v38)
    {
      goto LABEL_80;
    }
    CFRelease(v38);
LABEL_80:
    if (v40) {
      CFRelease(v40);
    }
  }
  if (v35) {
    CFDictionarySetValue(v34, @"kConditionalConnectionIdentifier", v35);
  }
  if (v34)
  {
    if (CFDictionaryGetCount(v34)) {
      CFDictionarySetValue(v9, &unk_1EC0A0A58, v34);
    }
    else {
      CFDictionaryRemoveValue(v9, &unk_1EC0A0A58);
    }
    CFStringRef v41 = value;
    CFRelease(v34);
    if (!value) {
      goto LABEL_89;
    }
    goto LABEL_88;
  }
LABEL_87:
  CFDictionaryRemoveValue(v9, &unk_1EC0A0A58);
  CFStringRef v41 = value;
  if (value) {
LABEL_88:
  }
    CFRelease(v41);
LABEL_89:
  CFDictionaryAddValue(v9, &unk_1EC09E528, (const void *)objc_msgSend(NSNumber, "numberWithUnsignedInteger:", *(void *)(-[_CFURLRequest _inner](a1, "_inner") + 184)));
  CFTypeRef v42 = *(CFTypeRef *)([(_CFURLRequest *)a1 _inner] + 120);
  if (v42
    || (CFTypeRef v42 = (id)URLRequest::copyMainDocumentRegistrableDomain((URLRequest *)[(_CFURLRequest *)a1 _inner])) != 0)
  {
    CFDictionaryAddValue(v9, &unk_1EC09F1A0, v42);
  }
  return v9;
}

uint64_t ___ZL12allowNewHTTPv_block_invoke()
{
  uint64_t result = _CFGetProgname();
  if (result)
  {
    uint64_t v1 = *(const char **)result;
    if (*(void *)result)
    {
      uint64_t result = strncmp(*(const char **)result, "com.apple.WebKit", 0x10uLL);
      if (result && (uint64_t result = strcmp(v1, "MobileSafari"), result))
      {
        uint64_t result = strncmp(v1, "com.apple.Safari", 0x10uLL);
        BOOL v2 = result == 0;
      }
      else
      {
        BOOL v2 = 1;
      }
      allowNewHTTP(void)::uint64_t result = v2;
    }
  }
  return result;
}

void sub_1841D63F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1841D64B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'SessionConnectionLoadable::~SessionConnectionLoadable(SessionConnectionLoadable *this)
{
  this[-1].id var2 = (void **)&unk_1ECFA3328;
  this[-1].id var3 = &unk_1ECFA3428;
  this->var0 = (void **)&unk_1ECF9B550;
  JUMPOUT(0x18531B6D0);
}

{
  this[-1].id var2 = (void **)&unk_1ECFA3328;
  this[-1].id var3 = &unk_1ECFA3428;
  this->var0 = (void **)&unk_1ECF9B550;
}

{
  this[-1].id var3 = &unk_1ECFA3328;
  this->var0 = (void **)&unk_1ECFA3428;
  this->var1 = (void **)&unk_1ECF9B550;
  JUMPOUT(0x18531B6D0);
}

{
  this[-1].id var3 = &unk_1ECFA3328;
  this->var0 = (void **)&unk_1ECFA3428;
  this->var1 = (void **)&unk_1ECF9B550;
}

void non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_captureTransportConnection(uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

void SessionConnectionLoadable::_loaderClientEvent_captureTransportConnection(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 24);
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  uint64_t v5 = *a2;
  CFAllocatorRef v6 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  [v3 _captureTransportConnection:&v5 extraBytes:a3];
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_1841D73C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_capturedSocketStreams(SessionConnectionLoadable *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return [this->var2 _capturedSocketInputStream:a2 outputStream:a3];
}

void non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_asyncError(SessionConnectionLoadable *this, const __CFString *a2, CFIndex a3)
{
}

void SessionConnectionLoadable::_loaderClientEvent_asyncError(SessionConnectionLoadable *this, const __CFString *a2, CFIndex a3)
{
  CFErrorRef v4 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, 0);
  (*((void (**)(SessionConnectionLoadable *, CFErrorRef))this->var0 + 21))(this, v4);
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_AlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 16) _alternatePathAvailable:a2];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_ConditionalRequirementsChanged(SessionConnectionLoadable *this, int a2)
{
  return [this->var2 _conditionalRequirementsChanged:a2 != 0];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_ConnectionWaiting(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 16) _connectionIsWaitingWithReason:a2];
}

void non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidTimeout(SessionConnectionLoadable *this)
{
}

void SessionConnectionLoadable::_loaderClientEvent_DidTimeout(SessionConnectionLoadable *this)
{
  keys[2] = *(void **)MEMORY[0x1E4F143B8];
  int valuePtr = -2102;
  keys[0] = @"_kCFStreamErrorDomainKey";
  keys[1] = @"_kCFStreamErrorCodeKey";
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &kCFStreamErrorDomainHTTP);
  values[1] = CFNumberCreate(v2, kCFNumberIntType, &valuePtr);
  CFDictionaryRef v4 = CFDictionaryCreate(v2, (const void **)keys, (const void **)values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v5 = 0;
  char v6 = 1;
  do
  {
    char v7 = v6;
    CFRunLoopSourceContext v8 = values[v5];
    if (v8) {
      CFRelease(v8);
    }
    char v6 = 0;
    uint64_t v5 = 1;
  }
  while ((v7 & 1) != 0);
  id var3 = this->var3;
  if (var3
    && (Property = objc_getProperty(var3, v3, 8, 1), (uint64_t v11 = Property) != 0)
    && [Property _proxySettings]
    && [v11 _proxyHandshakePending]
    && !objc_msgSend((id)objc_msgSend((id)objc_msgSend(v11, "currentRequest_URL"), "scheme"), "caseInsensitiveCompare:", @"https"))
  {
    CFIndex v12 = 310;
  }
  else
  {
    CFIndex v12 = -1001;
  }
  CFErrorRef v13 = CFErrorCreate(v2, @"kCFErrorDomainCFNetwork", v12, v4);
  if (v4) {
    CFRelease(v4);
  }
  (*((void (**)(SessionConnectionLoadable *, CFErrorRef))this->var0 + 21))(this, v13);
  if (v13) {
    CFRelease(v13);
  }
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidReceiveInformationalResponse(SessionConnectionLoadable *this, _CFURLResponse *a2)
{
  return [this->var2 _didReceiveInformationalResponse:a2];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStreamFromOffset(SessionConnectionLoadable *this, uint64_t a2)
{
  return [this->var2 _needNewBodyStreamFromOffset:a2];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStream(SessionConnectionLoadable *this)
{
  return [this->var2 _needNewBodyStream];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForRedirection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForRedirection(a1 - 8, a2, a3, a4);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForRedirection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3) {
    id v7 = +[NSURLResponse _responseWithCFURLResponse:](NSHTTPURLResponse, "_responseWithCFURLResponse:");
  }
  else {
    id v7 = 0;
  }
  CFRunLoopSourceContext v8 = *(void **)(a1 + 24);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN25SessionConnectionLoadable48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke;
  v10[3] = &unk_1E5254F60;
  void v10[4] = a4;
  return [v8 _redirectRequest:a2 redirectResponse:v7 completion:v10];
}

uint64_t ___ZN25SessionConnectionLoadable48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClient_SupportsDispatchData(SessionConnectionLoadable *this)
{
  return 1;
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_capturedSocketStreams(SessionConnectionLoadable *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return [this->var3 _capturedSocketInputStream:a2 outputStream:a3];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_AlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 24) _alternatePathAvailable:a2];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_ConditionalRequirementsChanged(SessionConnectionLoadable *this, int a2)
{
  return [this->var3 _conditionalRequirementsChanged:a2 != 0];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_ConnectionWaiting(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 24) _connectionIsWaitingWithReason:a2];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForEstablishedConnection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 24);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZN25SessionConnectionLoadable58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke;
  v5[3] = &unk_1E5254F60;
  v5[4] = a3;
  return [v3 _willSendRequestForEstablishedConnection:a2 completion:v5];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidFailWithError(SessionConnectionLoadable *this, __CFError *a2)
{
  return [this->var3 _didFinishWithError:a2];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidSendBodyData(SessionConnectionLoadable *this, UploadProgressInfo *a2)
{
  id var3 = this->var3;
  UploadProgressInfo v4 = *a2;
  return [var3 _didSendBodyData:&v4];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidReceiveInformationalResponse(SessionConnectionLoadable *this, _CFURLResponse *a2)
{
  return [this->var3 _didReceiveInformationalResponse:a2];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStreamFromOffset(SessionConnectionLoadable *this, uint64_t a2)
{
  return [this->var3 _needNewBodyStreamFromOffset:a2];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStream(SessionConnectionLoadable *this)
{
  return [this->var3 _needNewBodyStream];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidReceiveChallenge(SessionConnectionLoadable *this, _CFURLAuthChallenge *a2)
{
  id v3 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:a2 sender:this->var3];
  id var3 = this->var3;

  return [var3 _didReceiveChallenge:v3];
}

uint64_t SessionConnectionLoadable::cancel(SessionConnectionLoadable *this)
{
  return [this->var3 cancel];
}

const void *SessionConnectionLoadable::copyDebugDesc(SessionConnectionLoadable *this)
{
  uint64_t v1 = (const void *)[this->var3 description];
  CFAllocatorRef v2 = v1;
  if (v1) {
    CFRetain(v1);
  }
  return v2;
}

id SessionConnectionLoadable::copyOriginalImmutableRequest(SessionConnectionLoadable *this, const char *a2)
{
  id var3 = this->var3;
  if (var3) {
    id var3 = objc_getProperty(var3, a2, 8, 1);
  }
  id v3 = (void *)[var3 originalRequest];

  return v3;
}

void AutoStringWithFormat::~AutoStringWithFormat(AutoStringWithFormat *this)
{
  AutoString::~AutoString(this);

  JUMPOUT(0x18531B6D0);
}

void AutoStringWithFormatAndArgs::~AutoStringWithFormatAndArgs(AutoStringWithFormatAndArgs *this)
{
  AutoString::~AutoString(this);

  JUMPOUT(0x18531B6D0);
}

uint64_t AutoString::getCString(AutoString *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result)
  {
    CFIndex Length = CFStringGetLength(*((CFStringRef *)this + 1));
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    CFIndex v5 = MaximumSizeForEncoding + 1;
    if (MaximumSizeForEncoding > 118)
    {
      id v7 = CFGetAllocator(*((CFTypeRef *)this + 1));
      if (v7) {
        id v7 = CFRetain(v7);
      }
      *((void *)this + 3) = v7;
      char v6 = (char *)CFAllocatorAllocate((CFAllocatorRef)v7, v5, 0);
    }
    else
    {
      char v6 = (char *)this + 32;
    }
    *((void *)this + 2) = v6;
    CFStringGetCString(*((CFStringRef *)this + 1), v6, v5, 0x8000100u);
    return *((void *)this + 2);
  }
  return result;
}

void AutoStringWithFormat::AutoStringWithFormat(AutoStringWithFormat *this, CFAllocatorRef alloc, const __CFString *a3, ...)
{
  va_start(va, a3);
  *(void *)this = &unk_1ECFA0F40;
  CFStringRef v4 = CFStringCreateWithFormatAndArguments(alloc, 0, a3, va);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v4;
}

void sub_1841D7C14(_Unwind_Exception *a1)
{
  AutoString::~AutoString(v1);
  _Unwind_Resume(a1);
}

void AutoStringArray::addFormat(CFTypeRef *this, const __CFString *a2, ...)
{
  va_start(va, a2);
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = CFGetAllocator(*this);
  CFIndex v5 = &unk_1ECFA38D0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  CFStringRef v6 = CFStringCreateWithFormatAndArguments(v4, 0, a2, va);
  CFArrayAppendValue((CFMutableArrayRef)*this, v6);
  AutoString::~AutoString((AutoString *)&v5);
}

void sub_1841D7CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection14_watchdogTouchEb_block_invoke(uint64_t a1)
{
  CFAllocatorRef v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    id v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      CFAllocatorRef v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 3)
      {
        v7.CFStringRef domain = 4;
        *(void *)&v7.CFErrorRef error = 4294965192;
        NWIOConnection::_handleTimeout((NWIOConnection *)v5, v7);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1841D7D78(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void NWIOConnection::_handleTimeout(NWIOConnection *this, CFStreamError a2)
{
  uint64_t v2 = *(void *)&a2.error;
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  BOOL v4 = a2.domain == 0;
  BOOL v5 = a2.error == 0;
  if (v4 && v5) {
    CFIndex domain = 1;
  }
  else {
    CFIndex domain = a2.domain;
  }
  if (v4 && v5) {
    uint64_t error = 60;
  }
  else {
    uint64_t error = a2.error;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v8 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v9 = *((void *)this + 36);
    int v10 = 134218496;
    uint64_t v11 = v9;
    __int16 v12 = 2048;
    CFIndex v13 = domain;
    __int16 v14 = 1024;
    int v15 = error;
    _os_log_error_impl(&dword_184085000, v8, OS_LOG_TYPE_ERROR, "Connection %llu: timed out with error(%ld:%d)", (uint8_t *)&v10, 0x1Cu);
  }
  if (*((void *)this + 34))
  {
    *(void *)&v17.uint64_t error = v2 & 0xFFFFFFFF00000000 | error;
    v17.CFIndex domain = domain;
    NWIOConnection::_handleError(this, v17);
    NWIOConnection::_cleanupConnection((CFMutableDictionaryRef *)this, 0);
  }
}

void NWIOConnection::_signalError(NWIOConnection *this)
{
  uint64_t v2 = *((void *)this + 20);
  id v3 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v2)
  {
    (*(void (**)(uint64_t, void, void))(*(void *)v2 + 40))(v2, *((void *)this + 47), *((void *)this + 48));
    int v5 = *((unsigned __int16 *)this + 124);
    BOOL v4 = (char *)this + 248;
    int v6 = v4[2];
    *(_WORD *)BOOL v4 = v5 & 0xFFFD;
    v4[2] = (v5 & 0xFFFFFFFD | (v6 << 16)) >> 16;
    if (!v3) {
      return;
    }
  }
  else
  {
    *((_WORD *)this + 124) |= 2u;
    if (!v3) {
      return;
    }
  }

  std::__shared_weak_count::__release_shared[abi:nn180100](v3);
}

void sub_1841D7F84(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'NWIOConnection::~NWIOConnection(NWIOConnection *this)
{
  NWIOConnection::~NWIOConnection((NWIOConnection *)((char *)this - 112));

  JUMPOUT(0x18531B6D0);
}

{
  NWIOConnection::~NWIOConnection((NWIOConnection *)((char *)this - 112));
}

uint64_t NWIOConnection::logConnectionAtAPSleep(uint64_t this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(this + 681))
  {
    uint64_t v1 = this;
    *(unsigned char *)(this + 68__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v3 = *(void *)(v1 + 200);
    if (v3) {
      double v4 = *(double *)(v3 + 176);
    }
    else {
      double v4 = 0.0;
    }
    unsigned int v5 = ((Current - v4) * 1000.0);
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      unsigned int v7 = v5;
      _os_log_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "logConnectionAtAPSleep: idleDuration=%u", buf, 8u);
    }
    return AnalyticsSendEventLazy_delayInitStub(COERCE_DOUBLE(3221225472));
  }
  return this;
}

uint64_t ___ZN14NWIOConnection22logConnectionAtAPSleepEv_block_invoke(uint64_t a1)
{
  v3[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = @"idleDuration";
  v3[0] = [NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 32)];
  return [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v3 forKeys:&v2 count:1];
}

NSObject *NWIOConnection::copyConnectionParameters(NWIOConnection *this)
{
  uint64_t result = *((void *)this + 37);
  if (result) {
    return nw_parameters_copy(result);
  }
  return result;
}

uint64_t NWIOConnection::copyConnectionEndpoint(NWIOConnection *this)
{
  uint64_t v1 = *((void *)this + 38);
  if (v1) {
    nw_retain(*((void **)this + 38));
  }
  return v1;
}

uint64_t __Block_byref_object_copy__4125(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__4126(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v2) {
    CFRelease(v2);
  }
}

uint64_t NWIOConnection::createPeerTrustUsingTrustData(uint64_t this, const __CFData *a2)
{
  if (a2)
  {
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke;
    v2[3] = &__block_descriptor_48_e24_v20__0____CFString__8B16l;
    v2[4] = this;
    void v2[5] = a2;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)this + 344))(this, v2);
  }
  return this;
}

void ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  v5[1] = v5;
  void v5[2] = 0x2020000000;
  v5[3] = 0;
  uint64_t v0 = MEMORY[0x1E4F143A8];
  uint64_t v1 = 3221225472;
  uint64_t v2 = ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke_2;
  uint64_t v3 = &unk_1E5257868;
  double v4 = v5;
  SecTrustDeserialize();
  operator new();
}

void sub_1841D8668(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  unsigned int v7 = va_arg(va1, void (*)(uint64_t *));
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  v7((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void std::__shared_ptr_pointer<__SecTrust *,Deleter_CFRelease,std::allocator<__SecTrust>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void NWIOConnection::setPeerCerts(NWIOConnection *this, CFTypeRef cf)
{
  if (cf)
  {
    CFRetain(cf);
    operator new();
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 61);
  *((void *)this + 6_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *((void *)this + 6__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void std::__shared_ptr_pointer<__CFArray const*,Deleter_CFRelease,std::allocator<__CFArray const>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void NWIOConnection::coalesce(NWIOConnection *this)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  int v1 = *((unsigned __int16 *)this + 124) | (*((unsigned __int8 *)this + 250) << 16);
  if ((v1 & 0x20000) == 0)
  {
    *((_WORD *)this + 124) = *((_WORD *)this + 124);
    *((unsigned char *)this + 25_CFNetworkResetHSTSHostsSinceDate(0, 0) = (v1 | 0x20000u) >> 16;
    uint64_t v3 = *((void *)this + 25);
    if (v3) {
      *(unsigned char *)(v3 + 24) = 1;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *((void *)this + 36);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v5;
      _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "Connection %llu: will be coalesced", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v6 = *((void *)this + 56);
    unsigned int v7 = (std::__shared_weak_count *)*((void *)this + 57);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *((void *)this + 60);
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 61);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v10 = *((void *)this + 32);
    uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 33);
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    v13[0] = 0;
    v13[1] = 0;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v12[0] = v8;
    v12[1] = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)&long long buf = MEMORY[0x1E4F143A8];
    *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768;
    int v15 = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke;
    uint64_t v16 = &__block_descriptor_88_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE56c38_ZTSNSt3__110shared_ptrI10__SecTrustEE72c37_ZTSNSt3__110shared_ptrIK9__CFArrayEE_e144_v60__0B8_shared_ptr___SecTrust______SecTrust_____shared_weak_count__12_shared_ptr_const___CFArray______CFArray_____shared_weak_count__28___qi_44l;
    CFStreamError v17 = this;
    uint64_t v18 = v10;
    __int16 v19 = v11;
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v20 = v6;
    CFDictionaryRef v21 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v22 = v8;
    double v23 = v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    NWIOConnection::_tlsProcessValidateServerTrust_Invoke((uint64_t)this, (uint64_t)v13, v6, (uint64_t)v7, (uint64_t)v12, (uint64_t)&buf);
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
    }
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
    if (v23) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v23);
    }
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v21);
    }
    if (v19) {
      std::__shared_weak_count::__release_weak(v19);
    }
    if (v11) {
      std::__shared_weak_count::__release_weak(v11);
    }
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
    }
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
  }
}

void sub_1841D8A3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,std::__shared_weak_count *a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a23);
  }
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a21);
  }
  if (a19)
  {
    std::__shared_weak_count::__release_weak(a19);
    if (!v24)
    {
LABEL_7:
      if (!v23) {
        goto LABEL_8;
      }
      goto LABEL_15;
    }
  }
  else if (!v24)
  {
    goto LABEL_7;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v24);
  if (!v23)
  {
LABEL_8:
    if (!v25) {
      goto LABEL_9;
    }
    goto LABEL_16;
  }
LABEL_15:
  std::__shared_weak_count::__release_shared[abi:nn180100](v23);
  if (!v25)
  {
LABEL_9:
    if (!v24) {
      goto LABEL_10;
    }
    goto LABEL_17;
  }
LABEL_16:
  std::__shared_weak_count::__release_weak(v25);
  if (!v24)
  {
LABEL_10:
    if (!v23) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_17:
  std::__shared_weak_count::__release_shared[abi:nn180100](v24);
  if (!v23) {
LABEL_12:
  }
    _Unwind_Resume(exception_object);
LABEL_11:
  std::__shared_weak_count::__release_shared[abi:nn180100](v23);
  goto LABEL_12;
}

void ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke(void *a1, int a2, uint64_t a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  unsigned int v7 = (std::__shared_weak_count *)a1[6];
  if (v7)
  {
    uint64_t v11 = (NWIOConnection *)a1[4];
    __int16 v12 = std::__shared_weak_count::lock(v7);
    if (v12)
    {
      CFIndex v13 = v12;
      uint64_t v14 = a1[5];
      if (v14 && (*(_WORD *)(v14 + 248) & 0x60) == 0 && (*(_DWORD *)(v14 + 136) - 5) >= 3)
      {
        if (a5 || a6)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          CFDictionaryRef v21 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            uint64_t v22 = *((void *)v11 + 36);
            *(_DWORD *)long long buf = 134218496;
            uint64_t v25 = v22;
            __int16 v26 = 2048;
            CFIndex v27 = a5;
            __int16 v28 = 1024;
            int v29 = a6;
            _os_log_error_impl(&dword_184085000, v21, OS_LOG_TYPE_ERROR, "Connection %llu: coalesced TLS Trust encountered error %ld:%d", buf, 0x1Cu);
          }
          v31.CFIndex domain = a5;
          *(void *)&v31.uint64_t error = a6;
          NWIOConnection::_handleError(v11, v31);
        }
        else if (a2)
        {
          v23[0] = MEMORY[0x1E4F143A8];
          v23[1] = 3221225472;
          void v23[2] = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_288;
          v23[3] = &__block_descriptor_40_e45_v24__0____CFDictionary__8____CFDictionary__16l;
          v23[4] = v11;
          (*(void (**)(NWIOConnection *, void *))(*(void *)v11 + 336))(v11, v23);
          uint64_t v16 = a1[7];
          uint64_t v15 = a1[8];
          if (v15) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
          }
          CFStreamError v17 = (std::__shared_weak_count *)*((void *)v11 + 57);
          *((void *)v11 + 56) = v16;
          *((void *)v11 + 57) = v15;
          if (v17) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v17);
          }
          uint64_t v19 = a1[9];
          uint64_t v18 = a1[10];
          if (v18) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v20 = (std::__shared_weak_count *)*((void *)v11 + 61);
          *((void *)v11 + 6_CFNetworkResetHSTSHostsSinceDate(0, 0) = v19;
          *((void *)v11 + 6__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v18;
          if (v20) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v20);
          }
          NWIOConnection::_tlsProcessHandshakeComplete(v11);
          NWIOConnection::_completeEndpointSetup(v11);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v13);
    }
  }
}

void sub_1841D8D08(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__197(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__198(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void std::__shared_ptr_pointer<__CFArray *,Deleter_CFRelease,std::allocator<__CFArray>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void __destroy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE56c38_ZTSNSt3__110shared_ptrI10__SecTrustEE72c37_ZTSNSt3__110shared_ptrIK9__CFArrayEE(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void *__copy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE56c38_ZTSNSt3__110shared_ptrI10__SecTrustEE72c37_ZTSNSt3__110shared_ptrIK9__CFArrayEE(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[10];
  result[9] = a2[9];
  result[10] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_288(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v5 = MEMORY[0x1E4F143A8];
  uint64_t v6 = 3221225472;
  unsigned int v7 = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_2;
  uint64_t v8 = &__block_descriptor_56_e24_v20__0____CFString__8B16l;
  uint64_t v9 = v3;
  uint64_t v10 = a2;
  uint64_t v11 = a3;
  return (*(uint64_t (**)(void))(*(void *)v3 + 344))();
}

void ___ZN14NWIOConnection39_tlsCopyClientCertificatesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke(uint64_t a1, sec_certificate_t certificate)
{
  SecCertificateRef v3 = sec_certificate_copy_ref(certificate);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 48), v3);
  if (v3)
  {
    CFRelease(v3);
  }
}

void sub_1841D8F2C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection39_tlsCopyDistinguishedNamesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke(uint64_t a1, NSObject *a2)
{
  if (CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0)) {
    operator new();
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3321888768;
  void v5[2] = ___ZN14NWIOConnection39_tlsCopyDistinguishedNamesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke_2;
  v5[3] = &__block_descriptor_48_e8_32c35_ZTSNSt3__110shared_ptrI8__CFDataEE_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
  void v5[4] = 0;
  uint64_t v6 = 0;
  dispatch_data_apply(a2, v5);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 48), 0);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_1841D9084(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN14NWIOConnection39_tlsCopyDistinguishedNamesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke_2(uint64_t a1, int a2, int a3, UInt8 *bytes, CFIndex length)
{
  return 1;
}

void __destroy_helper_block_e8_32c35_ZTSNSt3__110shared_ptrI8__CFDataEE(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c35_ZTSNSt3__110shared_ptrI8__CFDataEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_pointer<__CFData *,Deleter_CFRelease,std::allocator<__CFData>>::__on_zero_shared(uint64_t a1)
{
  int v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void std::__shared_ptr_pointer<__CFData *,Deleter_CFRelease,std::allocator<__CFData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_2(void *a1, void *a2, char a3)
{
  if (a2)
  {
    if ((a3 & 1) == 0)
    {
      uint64_t v5 = a1[4];
      uint64_t v4 = (void *)a1[5];
      uint64_t v6 = a1[6];
      CFStringRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 368), &unk_1EC09E5D0);
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 3221225472;
      _DWORD v8[2] = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_3;
      void v8[3] = &__block_descriptor_40_e66_v40__0____CFString__8____CFArray__16____CFData__24____CFString__32l;
      v8[4] = v5;
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 3221225472;
      v9[2] = ___ZN18H2CoalescingEngine31updateCoalescingConnectionEntryEP14__CFDictionaryPKS0_PK10__CFStringPK9__CFArrayU13block_pointerFvS6_S9_PK8__CFDataS6_E_block_invoke;
      v9[3] = &unk_1E52578A0;
      v9[4] = v8;
      __NSURLSession_CoalescingGetCoalescingCCEntryHostWithDNSRecord(v4, v6, a2, Value, 0, (uint64_t)v9);
    }
  }
}

void ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  unsigned int v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(v6 + 288);
    int v9 = 134218242;
    uint64_t v10 = v8;
    __int16 v11 = 2112;
    uint64_t v12 = a5;
    _os_log_impl(&dword_184085000, v7, OS_LOG_TYPE_DEFAULT, "Connection %llu: coalesced with %@", (uint8_t *)&v9, 0x16u);
  }
}

uint64_t ___ZN18H2CoalescingEngine31updateCoalescingConnectionEntryEP14__CFDictionaryPKS0_PK10__CFStringPK9__CFArrayU13block_pointerFvS6_S9_PK8__CFDataS6_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN14NWIOConnection21copyProperty_offqueueEPK10__CFString_block_invoke(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 216))(*(void *)(a1 + 40), *(void *)(a1 + 48));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t ___ZN14NWIOConnection20setProperty_offqueueEPK10__CFStringPKv_block_invoke(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void, void, void))(**(void **)(a1 + 40) + 200))(*(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t NWIOConnection::_copyNetworkSignature(uint64_t this, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  *(void *)this = 0;
  if (*(void *)(a2 + 336))
  {
    SecCertificateRef v3 = (void *)this;
    this = *(void *)(a2 + 344);
    if (this)
    {
      this = nw_endpoint_get_type((nw_endpoint_t)this);
      if (this == 1)
      {
        this = (uint64_t)nw_endpoint_get_address(*(nw_endpoint_t *)(a2 + 344));
        if (this)
        {
          unsigned __int8 v14 = 20;
          this = MEMORY[0x1F4188790](this, v4, v5);
          int v6 = *(unsigned __int8 *)(this + 1);
          if (v6 == 30)
          {
            this = nw_path_get_ipv6_network_signature();
          }
          else
          {
            if (v6 != 2) {
              return this;
            }
            this = nw_path_get_ipv4_network_signature();
          }
          if (this)
          {
            MEMORY[0x1F4188790](this, v7, v8);
            uint64_t v10 = &v13[-v9];
            unint64_t v11 = 0;
            uint64_t v12 = &v13[-v9];
            do
            {
              snprintf(v12, 3uLL, "%.2x", v13[v11++]);
              v12 += 2;
            }
            while (v11 < v14);
            this = (uint64_t)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"0x%s", v10);
            *SecCertificateRef v3 = this;
          }
        }
      }
    }
  }
  return this;
}

void sub_1841D95BC(_Unwind_Exception *a1)
{
  *int v1 = 0;
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c36_ZTSNSt3__110shared_ptrI9__CFArrayEE(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c36_ZTSNSt3__110shared_ptrI9__CFArrayEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void NWIOConnection::_setPropertyForSSLSettings(CFDictionaryRef *this, const __CFString *a2, const void *a3)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(this[46], @"kCFStreamPropertySSLSettings");
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (Value) {
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(v7, 0, Value);
  }
  else {
    MutableCFStringRef Copy = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  uint64_t v9 = MutableCopy;
  if (a3) {
    CFDictionarySetValue(MutableCopy, a2, a3);
  }
  else {
    CFDictionaryRemoveValue(MutableCopy, a2);
  }
  CFDictionarySetValue(this[46], @"kCFStreamPropertySSLSettings", v9);
  if (v9)
  {
    CFRelease(v9);
  }
}

void sub_1841D96E8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>(uint64_t a1, void *a2)
{
  if (*a2) {
    operator new();
  }
  *a2 = 0;
  SecCertificateRef v3 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = 0u;
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  return a1;
}

uint64_t ___ZN14NWIOConnection26_applyPropertyToConnectionEPK10__CFString_block_invoke(xpc_object_t *a1, size_t a2, void *a3)
{
  xpc_object_t value = xpc_array_get_value(a1[4], a2);
  uint64_t v6 = MEMORY[0x18531EBC0](a3);
  uint64_t v7 = MEMORY[0x1E4F145F0];
  if (v6 == MEMORY[0x1E4F145F0] && MEMORY[0x18531EBC0](value) == v7)
  {
    string_ptr = xpc_string_get_string_ptr(a3);
    if (strncmp(string_ptr, "Persistent", 0x20uLL)
      || (uint64_t v9 = xpc_string_get_string_ptr(value), strncmp(v9, "Persistent", 0x20uLL)))
    {
      xpc_array_append_value(a1[5], a3);
      xpc_array_append_value(a1[6], value);
    }
  }
  return 1;
}

void ___ZN14NWIOConnection26_applyPropertyToConnectionEPK10__CFString_block_invoke_156(uint64_t a1)
{
  int v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t NWIOConnection::_toDiagnosticLog(NSObject **a1, uint64_t a2)
{
  uint64_t v4 = a1[43];
  if (v4 && nw_endpoint_get_type(v4) == nw_endpoint_type_address) {
    nw_endpoint_get_description();
  }
  uint64_t v5 = a1[44];
  if (v5 && nw_endpoint_get_type(v5) == nw_endpoint_type_address) {
    nw_endpoint_get_description();
  }
  uint64_t v6 = a1[38];
  if (v6 && nw_endpoint_get_type(v6) == nw_endpoint_type_host) {
    nw_endpoint_get_hostname(a1[38]);
  }
  return (*(uint64_t (**)(uint64_t, const char *, __CFString *))(*(void *)a2 + 72))(a2, "Connection", @"{ conn (%llu), local %s => peer %s %s }");
}

void ___ZN14NWIOConnection52_applyPropertyToConnection_EventHandlerAdaptiveWriteEU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    SecCertificateRef v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2) {
        NWIOConnection::_handleEvent_AdaptiveWriteTimeout((NWIOConnection *)v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1841D99D8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void NWIOConnection::_handleEvent_AdaptiveWriteTimeout(NWIOConnection *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 36);
    int v4 = 134217984;
    uint64_t v5 = v3;
    _os_log_impl(&dword_184085000, v2, OS_LOG_TYPE_DEFAULT, "Connection %llu: encountered write timeout event", (uint8_t *)&v4, 0xCu);
  }
  v7.CFIndex domain = 4;
  *(void *)&v7.uint64_t error = 4294965196;
  NWIOConnection::_handleTimeout(this, v7);
}

uint64_t ___ZN14NWIOConnection52_applyPropertyToConnection_EventHandlerAdaptiveWriteEU13block_pointerFvvE_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 4030;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN14NWIOConnection51_applyPropertyToConnection_EventHandlerAdaptiveReadEU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2) {
        NWIOConnection::_handleEvent_AdaptiveReadTimeout((NWIOConnection *)v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1841D9BA8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void NWIOConnection::_handleEvent_AdaptiveReadTimeout(NWIOConnection *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 36);
    int v4 = 134217984;
    uint64_t v5 = v3;
    _os_log_impl(&dword_184085000, v2, OS_LOG_TYPE_DEFAULT, "Connection %llu: encountered read timeout event", (uint8_t *)&v4, 0xCu);
  }
  v7.CFIndex domain = 4;
  *(void *)&v7.uint64_t error = 4294965195;
  NWIOConnection::_handleTimeout(this, v7);
}

uint64_t ___ZN14NWIOConnection51_applyPropertyToConnection_EventHandlerAdaptiveReadEU13block_pointerFvvE_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 3988;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN14NWIOConnection57_applyPropertyToConnection_EventHandlerExcessiveKeepaliveEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2) {
        NWIOConnection::_handleEvent_ExcessiveKeepalive((NWIOConnection *)v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1841D9D78(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::_handleEvent_ExcessiveKeepalive(NWIOConnection *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 36);
    int v5 = 134217984;
    uint64_t v6 = v3;
    _os_log_impl(&dword_184085000, v2, OS_LOG_TYPE_DEFAULT, "Connection %llu: encountered excessive keepalive event", (uint8_t *)&v5, 0xCu);
  }
  uint64_t result = *((void *)this + 79);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, 0);
  }
  return result;
}

void ___ZN14NWIOConnection52_applyPropertyToConnection_EventHandlerLowThroughputEU13block_pointerFvyEb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7 && (*(_WORD *)(v7 + 248) & 0x60) == 0 && (*(_DWORD *)(v7 + 136) - 5) >= 2) {
        NWIOConnection::_handleEvent_LowThroughput((NWIOConnection *)v7, a2);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }
}

void sub_1841D9F00(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::_handleEvent_LowThroughput(NWIOConnection *this, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  int v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *((void *)this + 36);
    int v7 = 134218240;
    uint64_t v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = a2;
    _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "Connection %llu: encountered low throughput event %llu", (uint8_t *)&v7, 0x16u);
  }
  uint64_t result = *((void *)this + 80);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, 0);
  }
  return result;
}

void NWIOConnection::setReusedAfterAPSleepWake(NWIOConnection *this)
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "setReusedAfterAPSleepWake", v3, 2u);
  }
  uint64_t v2 = *((void *)this + 25);
  if (v2) {
    *(unsigned char *)(v2 + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
  }
}

void NWIOConnection::setQUICMaxStreamsUnidirectional(nw_connection_t *this, uint64_t a2)
{
  int v4 = nw_protocol_copy_quic_connection_definition();
  nw_protocol_metadata_t v5 = nw_connection_copy_protocol_metadata(this[34], v4);
  nw_protocol_metadata_t v6 = v5;
  if (v5)
  {
    MEMORY[0x18531D430](v5, a2);
    nw_release(v6);
  }
  if (v4)
  {
    nw_release(v4);
  }
}

void sub_1841DA10C(_Unwind_Exception *a1)
{
  nw_release(v2);
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::unregisterContext(uint64_t a1)
{
  return MEMORY[0x1F40F2CC0](*(void *)(a1 + 272));
}

uint64_t NWIOConnection::registerContext(uint64_t a1)
{
  return MEMORY[0x1F40F2C18](*(void *)(a1 + 272));
}

uint64_t ___ZN14NWIOConnection4openEv_block_invoke(uint64_t a1)
{
  return NWIOConnection::_signalEstablished(*(NWIOConnection **)(a1 + 32));
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_59(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  id v2 = (id)nw_quic_connection_copy_sec_protocol_options();
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void __destroy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t a1)
{
  int v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v3) {
    return;
  }
  nw_protocol_metadata_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return;
  }
  nw_protocol_metadata_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7 && (*(_WORD *)(v7 + 248) & 0x60) == 0 && (*(_DWORD *)(v7 + 136) - 5) >= 2)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v8 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(v7 + 288);
      int v18 = 134218240;
      uint64_t v19 = v9;
      __int16 v20 = 1024;
      int v21 = a2;
      _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "Connection %llu: received advisory(%d)", (uint8_t *)&v18, 0x12u);
    }
    if ((nw_connection_uses_multipath() & 1) == 0)
    {
      uint64_t v10 = *(void *)(v7 + 160);
      uint64_t v11 = *(std::__shared_weak_count **)(v7 + 168);
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!v10)
        {
          std::__shared_weak_count::__release_shared[abi:nn180100](v11);
          goto LABEL_19;
        }
      }
      else if (!v10)
      {
LABEL_19:
        if ((a2 & 0xFFFFFFFE) == 2)
        {
          int v13 = *(unsigned __int16 *)(v7 + 248);
          int v14 = v13 | (*(unsigned __int8 *)(v7 + 250) << 16);
          if ((v13 & 0x80) == 0)
          {
            *(unsigned char *)(v7 + 25_CFNetworkResetHSTSHostsSinceDate(0, 0) = BYTE2(v14);
            *(_WORD *)(v7 + 248) = v14 | 0x80;
            NotificationStation::notifyPropertyChanged((NotificationStation *)(v7 + 16), @"__kCFStreamPropertyDoNotReuse", (const void *)*MEMORY[0x1E4F1CFD0]);
          }
        }
        else if (a2 == 1)
        {
          uint64_t v15 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_137, 2);
          uint64_t v16 = v15;
          if (v15
            && (*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v15 + 16))(v15, "Better Route Detected", 0))
          {
            NWIOConnection::_toDiagnosticLog((NSObject **)v7, v16);
            (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
          }
          uint64_t v17 = *(void *)(v7 + 656);
          if (v17) {
            (*(void (**)(void))(v17 + 16))();
          }
          NWIOConnection::_terminateConnectionIfAppropriate((CFDictionaryRef *)v7, 1);
        }
        goto LABEL_29;
      }
      char v12 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 48))(v10, a2);
      if (v11) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v11);
      }
      if (v12) {
        goto LABEL_29;
      }
      goto LABEL_19;
    }
  }
LABEL_29:

  std::__shared_weak_count::__release_shared[abi:nn180100](v6);
}

void sub_1841DA4BC(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_83(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    nw_protocol_metadata_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      nw_protocol_metadata_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7 && (*(_WORD *)(v7 + 248) & 0x60) == 0 && (*(_DWORD *)(v7 + 136) - 5) >= 2) {
        NWIOConnection::_handleEvent_LowThroughput((NWIOConnection *)v7, a2);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }
}

void sub_1841DA574(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_88(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2) {
        NWIOConnection::_handleEvent_ExcessiveKeepalive((NWIOConnection *)v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1841DA604(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_2_89(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2) {
        NWIOConnection::_handleEvent_AdaptiveReadTimeout((NWIOConnection *)v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1841DA694(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2) {
        NWIOConnection::_handleEvent_AdaptiveWriteTimeout((NWIOConnection *)v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1841DA724(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void NWIOConnection::_terminateConnectionIfAppropriate(CFDictionaryRef *this, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Value = CFDictionaryGetValue(this[46], &unk_1EC0A09E8);
  if (!Value) {
    goto LABEL_8;
  }
  uint64_t v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v18) = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v18, 2u);
  }
  if ((const void *)*MEMORY[0x1E4F1CFD0] == v5)
  {
LABEL_8:
    CFDictionaryRef v8 = this[81];
    BOOL v7 = v8 == 0;
    if ((a2 & 1) == 0)
    {
      if (v8) {
        return;
      }
      uint64_t v9 = this + 31;
      __int16 v10 = *((_WORD *)this + 124);
      uint64_t v13 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_113, 2);
      if (v13)
      {
        uint64_t v14 = v13;
        if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v13 + 16))(v13, "_networkReachabilityChanged", 0))
        {
          NWIOConnection::_toDiagnosticLog((NSObject **)this, v14);
          (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v14 + 72))(v14, "conn", @"issuing error to ECONNABORTED");
          (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
        }
      }
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v15 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        CFDictionaryRef v16 = this[36];
        int v18 = 134217984;
        CFDictionaryRef v19 = v16;
        _os_log_impl(&dword_184085000, v15, OS_LOG_TYPE_DEFAULT, "Connection %llu: reachability changed, issuing ECONNABORTED", (uint8_t *)&v18, 0xCu);
      }
      *((_WORD *)this + 124) |= 0x80u;
      v21.CFIndex domain = 1;
      *(void *)&v21.uint64_t error = 53;
      NWIOConnection::_handleError((NWIOConnection *)this, v21);
      goto LABEL_27;
    }
  }
  else
  {
    if (!a2) {
      return;
    }
    BOOL v7 = 0;
  }
  if (nw_connection_uses_multipath() || !v7) {
    return;
  }
  uint64_t v9 = this + 31;
  __int16 v10 = *((_WORD *)this + 124);
  uint64_t v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_106, 2);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v11 + 16))(v11, "_networkReachabilityChanged", 0))
    {
      NWIOConnection::_toDiagnosticLog((NSObject **)this, v12);
      (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v12 + 72))(v12, "conn", @"keeping alive");
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  if (!CFDictionaryGetValue(this[46], &unk_1EC0A0A20)
    && !CFDictionaryGetValue(this[46], &unk_1EC0A0BE0)
    && !CFDictionaryGetValue(this[46], &unk_1EC0A0C18))
  {
    *v9 |= 0x80u;
  }
LABEL_27:
  if (((((v10 & 0x80) == 0) ^ ((*v9 & 0x80u) >> 7)) & 1) == 0)
  {
    if ((*v9 & 0x80) != 0) {
      uint64_t v17 = (const void **)MEMORY[0x1E4F1CFD0];
    }
    else {
      uint64_t v17 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    NotificationStation::notifyPropertyChanged((NotificationStation *)(this + 2), @"__kCFStreamPropertyDoNotReuse", *v17);
  }
}

uint64_t ___ZN14NWIOConnection33_terminateConnectionIfAppropriateEb_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 2310;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection33_terminateConnectionIfAppropriateEb_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 2298;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection29_handleEvent_ViabilityChangedEb_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 2917;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection23_handleEvent_BetterPathE36nw_connection_alternate_path_state_t_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 2899;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection25_handleEvent_DisconnectedEPU22objcproto11OS_nw_error8NSObject_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 2788;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void NWIOConnection::_startTLS(NWIOConnection *this)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  int v1 = *((unsigned __int16 *)this + 124) | (*((unsigned __int8 *)this + 250) << 16);
  if ((*((_WORD *)this + 124) & 0xA00) == 0x200 && (*((_DWORD *)this + 34) - 3) <= 1)
  {
    *((unsigned char *)this + 25_CFNetworkResetHSTSHostsSinceDate(0, 0) = BYTE2(v1);
    *((_WORD *)this + 124) = v1 | 0x800;
    options = nw_tls_create_options();
    NWIOConnection::_tlsConfigure((uint64_t)this, options);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    int v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *((void *)this + 36);
      int v6 = 134217984;
      uint64_t v7 = v5;
      _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "Connection %llu: enabling TLS", (uint8_t *)&v6, 0xCu);
    }
    if (nw_settings_get_signposts_enabled()) {
      kdebug_trace();
    }
    nw_connection_append_and_start_application_protocol();
    if (options) {
      nw_release(options);
    }
  }
}

void sub_1841DAE7C(_Unwind_Exception *exception_object)
{
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_181(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v5)
  {
    uint64_t v7 = 0;
    goto LABEL_8;
  }
  uint64_t v7 = std::__shared_weak_count::lock(v5);
  if (!v7 || (uint64_t v8 = *(void *)(a1 + 32)) == 0)
  {
LABEL_8:
    (*(void (**)(uint64_t, void))(a3 + 16))(a3, 0);
    if (!v7) {
      return;
    }
    goto LABEL_9;
  }
  if ((*(_WORD *)(v8 + 248) & 0x60) == 0 && (*(_DWORD *)(v8 + 136) - 5) > 2)
  {
    sec_retain(a2);
    operator new();
  }
  (*(void (**)(uint64_t, void))(a3 + 16))(a3, 0);
LABEL_9:
  std::__shared_weak_count::__release_shared[abi:nn180100](v7);
}

void sub_1841DB35C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a16) {
    std::__shared_weak_count::__release_weak(a16);
  }
  if (a24) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a24);
  }
  if (a22) {
    std::__shared_weak_count::__release_weak(a22);
  }
  if (v26) {
    std::__shared_weak_count::__release_weak(v26);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v25);
  std::__shared_weak_count::__release_shared[abi:nn180100](v25);
  std::__shared_weak_count::__release_shared[abi:nn180100](v24);
  _Unwind_Resume(a1);
}

void NWIOConnection::_tlsCreateIdentityFromClientCertificates(sec_identity_t *a1, CFArrayRef *a2)
{
  *a1 = 0;
  if (*a2 && CFArrayGetCount(*a2) >= 1)
  {
    CFStringRef ValueAtIndex = (__SecIdentity *)CFArrayGetValueAtIndex(*a2, 0);
    CFIndex Count = CFArrayGetCount(*a2);
    if (Count < 2)
    {
      CFMutableArrayRef Mutable = 0;
    }
    else
    {
      CFIndex v6 = Count - 1;
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count - 1, MEMORY[0x1E4F1D510]);
      v9.CFIndex location = 1;
      v9.CFIndex length = v6;
      CFArrayAppendArray(Mutable, *a2, v9);
    }
    *a1 = sec_identity_create_with_certificates(ValueAtIndex, Mutable);
    if (Mutable)
    {
      CFRelease(Mutable);
    }
  }
}

void sub_1841DB54C(_Unwind_Exception *exception_object)
{
  *int v1 = 0;
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke(uint64_t a1)
{
  int v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_2(uint64_t a1)
{
  int v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_3(uint64_t a1)
{
  int v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  int v4 = (std::__shared_weak_count *)a1[5];
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5)
    {
      uint64_t v6 = a1[4];
      if (v6)
      {
        uint64_t v8 = a1[6];
        uint64_t v7 = (std::__shared_weak_count *)a1[7];
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v28 = 0;
        int v29 = &v28;
        uint64_t v30 = 0x4012000000;
        CFStreamError v31 = __Block_byref_object_copy__212;
        CFAllocatorRef v32 = __Block_byref_object_dispose__213;
        CFDictionaryRef v33 = &unk_18441BEED;
        uint64_t v34 = 0;
        uint64_t v35 = 0;
        if ((*(_WORD *)(v6 + 248) & 0x60) != 0 || (*(_DWORD *)(v6 + 136) - 5) <= 2)
        {
          uint64_t v34 = 1;
          LODWORD(v35) = 89;
          *(void *)long long buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          uint64_t handler = 0;
          CFIndex v27 = 0;
          (*(void (**)(uint64_t, unsigned char *, uint64_t *, uint64_t, uint64_t))(a2 + 16))(a2, buf, &handler, 1, v35);
          CFRange v9 = v27;
          if (v27) {
LABEL_9:
          }
            std::__shared_weak_count::__release_shared[abi:nn180100](v9);
        }
        else
        {
          if (*(int *)(v6 + 528) <= 0) {
            *(_DWORD *)(v6 + 528) = 1;
          }
          if (v8)
          {
            *(void *)long long buf = 0;
            *(void *)&uint8_t buf[8] = buf;
            *(void *)&uint8_t buf[16] = 0x4012000000;
            double v37 = __Block_byref_object_copy__197;
            CFNumberRef v38 = __Block_byref_object_dispose__198;
            CFNumberRef v39 = (uint64_t *)&unk_18441BEED;
            CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
            operator new();
          }
          if (*(void *)(v6 + 144))
          {
            uint64_t v11 = *(std::__shared_weak_count **)(v6 + 264);
            if (v11)
            {
              __int16 v10 = std::__shared_weak_count::lock(v11);
              if (v10) {
                uint64_t v12 = *(void *)(v6 + 256);
              }
              else {
                uint64_t v12 = 0;
              }
            }
            else
            {
              uint64_t v12 = 0;
              __int16 v10 = 0;
            }
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
            }
            uint64_t v15 = CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v16 = *(void *)(v6 + 288);
              CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v6 + 496));
              *(_DWORD *)long long buf = 134218240;
              *(void *)&uint8_t buf[4] = v16;
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = Count;
              _os_log_impl(&dword_184085000, v15, OS_LOG_TYPE_DEFAULT, "Connection %llu: issuing challenge for client certificates, DNs(%ld)", buf, 0x16u);
            }
            uint64_t v18 = *(void *)(v6 + 144);
            uint64_t v19 = *(void *)(v6 + 496);
            *(void *)long long buf = MEMORY[0x1E4F143A8];
            *(void *)&uint8_t buf[8] = 3321888768;
            *(void *)&uint8_t buf[16] = ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke_242;
            double v37 = (__n128 (*)(__n128 *, __n128 *))&unk_1ECFAA010;
            CFNumberRef v38 = (void (*)(uint64_t))a2;
            CFNumberRef v39 = &v28;
            CFMutableArrayRef Mutable = (CFMutableArrayRef)v6;
            uint64_t v41 = v12;
            CFTypeRef v42 = v10;
            if (v10) {
              atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v18 + 40))(v18, v19, buf);
            if (v42) {
              std::__shared_weak_count::__release_shared[abi:nn180100](v42);
            }
            goto LABEL_11;
          }
          uint64_t v13 = *(void *)(v6 + 520);
          *(void *)long long buf = *(void *)(v6 + 512);
          *(void *)&uint8_t buf[8] = v13;
          if (v13) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v14 = *(std::__shared_weak_count **)(v6 + 504);
          uint64_t v24 = *(void *)(v6 + 496);
          uint64_t v25 = v14;
          if (v14) {
            atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          (*(void (**)(uint64_t, unsigned char *, uint64_t *, uint64_t, uint64_t))(a2 + 16))(a2, buf, &v24, v29[6], v29[7]);
          CFRange v9 = v25;
          if (v25) {
            goto LABEL_9;
          }
        }
        __int16 v10 = *(std::__shared_weak_count **)&buf[8];
LABEL_11:
        if (v10) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v10);
        }
        _Block_object_dispose(&v28, 8);
        if (v7) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v7);
        }
LABEL_21:
        std::__shared_weak_count::__release_shared[abi:nn180100](v5);
        return;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v22 = 0;
  double v23 = 0;
  uint64_t v20 = 0;
  CFStreamError v21 = 0;
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t, uint64_t))(a2 + 16))(a2, &v22, &v20, 1, 89);
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  }
  if (v23) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v23);
  }
  if (v5) {
    goto LABEL_21;
  }
}

void sub_1841DBB40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v19);
  }
  _Block_object_dispose(va, 8);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v18);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke_236(void *a1, uint64_t a2, CFIndex a3, uint64_t a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (!v5)
  {
    CFRange v9 = 0;
    goto LABEL_23;
  }
  CFRange v9 = std::__shared_weak_count::lock(v5);
  if (!v9 || (uint64_t v10 = a1[5]) == 0)
  {
LABEL_23:
    (*(void (**)(void))(a1[4] + 16))();
    if (!v9) {
      return;
    }
    goto LABEL_33;
  }
  CFArrayRef v12 = *(const __CFArray **)a2;
  uint64_t v11 = *(atomic_ullong **)(a2 + 8);
  if (v11) {
    atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = a1[4];
  if ((*(_WORD *)(v10 + 248) & 0x60) == 0 && (*(_DWORD *)(v10 + 136) - 5) >= 3)
  {
    if (!a3 && !a4)
    {
      v20[0] = v12;
      v20[1] = (CFArrayRef)v11;
      if (v11) {
        atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed);
      }
      NWIOConnection::_tlsCreateIdentityFromClientCertificates(&v21, v20);
      if (v11) {
        std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v11);
      }
      sec_identity_t v14 = v21;
      if (v21 && *(int *)(v10 + 528) <= 1) {
        *(_DWORD *)(v10 + 528) = 2;
      }
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v15 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *(void *)(v10 + 288);
        if (v12) {
          CFIndex Count = CFArrayGetCount(v12);
        }
        else {
          CFIndex Count = -1;
        }
        *(_DWORD *)long long buf = 134218240;
        uint64_t v23 = v16;
        __int16 v24 = 2048;
        CFIndex v25 = Count;
        _os_log_impl(&dword_184085000, v15, OS_LOG_TYPE_DEFAULT, "Connection %llu: providing TLS Client Identity (%ld elements)", buf, 0x16u);
      }
      (*(void (**)(uint64_t, sec_identity_t))(v13 + 16))(v13, v14);
      if (v14) {
        sec_release(v14);
      }
      goto LABEL_31;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v18 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = *(void *)(v10 + 288);
      *(_DWORD *)long long buf = 134218496;
      uint64_t v23 = v19;
      __int16 v24 = 2048;
      CFIndex v25 = a3;
      __int16 v26 = 1024;
      int v27 = a4;
      _os_log_error_impl(&dword_184085000, v18, OS_LOG_TYPE_ERROR, "Connection %llu: TLS Client Certificates encountered error %ld:%d", buf, 0x1Cu);
    }
    v30.CFIndex domain = a3;
    *(void *)&v30.uint64_t error = a4;
    NWIOConnection::_handleError((NWIOConnection *)v10, v30);
  }
  (*(void (**)(uint64_t, void))(v13 + 16))(v13, 0);
LABEL_31:
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v11);
  }
LABEL_33:

  std::__shared_weak_count::__release_shared[abi:nn180100](v9);
}

void sub_1841DBF20(_Unwind_Exception *a1)
{
  if (v3) {
    sec_release(v3);
  }
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TLSCallbackClientCertificate>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<TLSCallbackClientCertificate>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6C98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<TLSCallbackClientCertificate>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6C98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *__copy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke(uint64_t a1, const void *a2)
{
}

void ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke_242(void *a1, const __CFArray *a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    uint64_t v4 = a1[6];
    if ((*(_WORD *)(v4 + 248) & 0x60) == 0 && (*(_DWORD *)(v4 + 136) - 5) > 2)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      uint64_t v6 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(v4 + 288);
        if (a2) {
          CFIndex Count = CFArrayGetCount(a2);
        }
        else {
          CFIndex Count = -1;
        }
        *(_DWORD *)long long buf = 134218240;
        uint64_t v10 = v7;
        __int16 v11 = 2048;
        CFIndex v12 = Count;
        _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "Connection %llu: received response for client certificates (%ld elements)", buf, 0x16u);
      }
      if (a2) {
        CFRetain(a2);
      }
      operator new();
    }
  }
  uint64_t v3 = *(void *)(a1[5] + 8);
  *(void *)(v3 + 48) = 1;
  *(_DWORD *)(v3 + 56) = 89;
  (*(void (**)(void))(a1[4] + 16))();
}

void sub_1841DC3B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  if (a12)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
    if (!v21)
    {
LABEL_5:
      if (!v20) {
LABEL_10:
      }
        _Unwind_Resume(exception_object);
LABEL_9:
      std::__shared_weak_count::__release_shared[abi:nn180100](v20);
      goto LABEL_10;
    }
  }
  else if (!v21)
  {
    goto LABEL_5;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  if (!v20) {
    goto LABEL_10;
  }
  goto LABEL_9;
}

void std::__shared_ptr_emplace<TLSCallbackQueue>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6988;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<TLSCallbackQueue>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6988;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_pointer<NSObject  {objcproto24OS_sec_protocol_metadata}*,Deleter_SecRelease<NSObject  {objcproto24OS_sec_protocol_metadata}*>,std::allocator<NSObject  {objcproto24OS_sec_protocol_metadata}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<TLSCallbackServerTrust>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6AD8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<TLSCallbackServerTrust>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6AD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t ___ZN14NWIOConnection18_handleEvent_ReadyEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 2556;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_nw_connection}*,Deleter_NWRelease<NSObject  {objcproto16OS_nw_connection}*>,std::allocator<NSObject  {objcproto16OS_nw_connection}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_2(uint64_t a1, int a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2 == 1)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (v3)
    {
      uint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v6 = *(void *)(a1 + 32);
        if (v6 && (*(_WORD *)(v6 + 248) & 0x60) == 0 && (*(_DWORD *)(v6 + 136) - 5) >= 2)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          uint64_t v7 = CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v8 = *(void *)(v6 + 288);
            int v11 = 134217984;
            uint64_t v12 = v8;
            _os_log_impl(&dword_184085000, v7, OS_LOG_TYPE_DEFAULT, "Connection %llu: encountered bidirectional stream limit updated event", (uint8_t *)&v11, 0xCu);
          }
          uint64_t v9 = *(void *)(v6 + 160);
          uint64_t v10 = *(std::__shared_weak_count **)(v6 + 168);
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v9) {
            (*(void (**)(uint64_t))(*(void *)v9 + 56))(v9);
          }
          if (v10) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v10);
          }
        }
        std::__shared_weak_count::__release_shared[abi:nn180100](v5);
      }
    }
  }
}

void sub_1841DC7A4(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection30_conditionalSchedulingSIMSetupEv_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  if ((*(_WORD *)(v1 + 248) & 0x60) == 0 && (*(_DWORD *)(v1 + 136) - 5) >= 3) {
    return NWIOConnection::_startConnection_Completion(*(NWIOConnection **)(result + 32));
  }
  return result;
}

void ___ZN14NWIOConnection30_conditionalSchedulingSIMSetupEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if ((*(_WORD *)(v1 + 248) & 0x60) == 0 && (*(_DWORD *)(v1 + 136) - 5) >= 3)
  {
    v2.CFIndex domain = 1;
    *(void *)&v2.uint64_t error = 60;
    NWIOConnection::_handleError((NWIOConnection *)v1, v2);
  }
}

void std::__shared_ptr_emplace<ConditionalConnectionSIMScheduler>::__on_zero_shared(uint64_t a1)
{
  ConditionalConnectionSIMScheduler::cancel((ConditionalConnectionSIMScheduler *)(a1 + 24));
  uint64_t v2 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = 0;
  if (v2) {
    (*(void (**)(void))(a1 + 120))();
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 104);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void std::__shared_ptr_emplace<ConditionalConnectionSIMScheduler>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6CD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<ConditionalConnectionSIMScheduler>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6CD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  if ((*(_WORD *)(v2 + 248) & 0x60) != 0 || (*(_DWORD *)(v2 + 136) - 5) < 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(v6 + 288);
    int v9 = 134218240;
    uint64_t v10 = v8;
    __int16 v11 = 2048;
    uint64_t v12 = a2;
    _os_log_impl(&dword_184085000, v7, OS_LOG_TYPE_DEFAULT, "Connection %llu: activity(%p) start handler called", (uint8_t *)&v9, 0x16u);
  }
  uint64_t v3 = 1;
  *(unsigned char *)(v6 + 592) = 1;
  NWIOConnection::_startConnection_Completion((NWIOConnection *)v6);
  return v3;
}

void ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke_276(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 40);
  if ((*(_WORD *)(v2 + 248) & 0x60) == 0 && (*(_DWORD *)(v2 + 136) - 5) >= 3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(v5 + 288);
      int v8 = 134218240;
      uint64_t v9 = v7;
      __int16 v10 = 2048;
      uint64_t v11 = a2;
      _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "Connection %llu: activity(%p) suspend handler called", (uint8_t *)&v8, 0x16u);
    }
    if (*(void *)(*(void *)(a1 + 40) + 624)) {
      (*(void (**)(void))(*(void *)(v5 + 624) + 16))();
    }
    NWIOConnection::_terminateConnectionIfAppropriate((CFDictionaryRef *)v5, 0);
  }
}

uint64_t ___ZN14NWIOConnection27_startConnection_CompletionEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 2161;
  *(void *)(a1 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN14NWIOConnection29_connectionAttemptTimerCreateEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 3)
      {
        v7.CFIndex domain = 4;
        *(void *)&v7.uint64_t error = 4294965190;
        NWIOConnection::_handleTimeout((NWIOConnection *)v5, v7);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1841DCC50(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection16_kickTimerCreateEv_block_invoke(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = a1[5];
      if (v6 && (*(_WORD *)(v6 + 248) & 0x60) == 0 && (*(_DWORD *)(v6 + 136) - 5) >= 3)
      {
        CFStreamError v7 = *(NSObject **)(v3 + 272);
        if (v7) {
          nw_connection_restart(v7);
        }
        double v8 = *(double *)(v3 + 536) + *(double *)(v3 + 536);
        *(double *)(v3 + 536) = v8;
        uint64_t v9 = *(NSObject **)(v3 + 544);
        dispatch_time_t v10 = dispatch_time(0x8000000000000000, (uint64_t)(v8 * 1000000000.0));
        dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    }
  }
}

void sub_1841DCD38(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

CFStringRef CFAllocatedReferenceCountedObject::copyDebugDesc(CFAllocatedReferenceCountedObject *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFAllocatedObject@%p>", this);
}

void CFAllocatedReferenceCountedObject::~CFAllocatedReferenceCountedObject(CFAllocatorRef *this)
{
}

uint64_t CFAllocatedReferenceCountedObject::_retainable_copyDescription(CFAllocatedReferenceCountedObject *this, const void *a2)
{
  return (*(uint64_t (**)(void))(*(void *)this + 16))();
}

CFStringRef CFObject::copyDebugDescHeader(CFObject *this)
{
  uint64_t v2 = (char *)this - 16;
  CFGetTypeID((char *)this - 16);
  ClassWithuint64_t TypeID = _CFRuntimeGetClassWithTypeID();
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s %p [%p]>", *(void *)(ClassWithTypeID + 8), v2, this);
}

uint64_t CFObject::copyFormattingDesc(CFObject *this, const __CFDictionary *a2)
{
  return 0;
}

uint64_t CFObject::hash(CFObject *this)
{
  return (uint64_t)this - 16;
}

BOOL CFObject::equals(CFObject *this, const CFObject *a2)
{
  return this == a2;
}

uint64_t CFObject::_cfobj_equal(CFObject *this, char *a2, const void *a3)
{
  return CFEqual((char *)this - 16, a2 - 16);
}

CFStringRef CFObject::_cfobj_copyDescription(CFObject *this, const void *a2)
{
  return CFCopyDescription((char *)this - 16);
}

void CFAllocatedObject::~CFAllocatedObject(CFAllocatorRef *this)
{
}

CFAllocatedReferenceCountedObject *CFAllocatedReferenceCountedObject::_retainable_instance_retain(CFAllocatedReferenceCountedObject *this, const void *a2)
{
  return this;
}

uint64_t CFAllocatedReferenceCountedObject::_retainable_instance_release(CFAllocatedReferenceCountedObject *this, const void *a2)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

uint64_t CFClass::CopyDebugDescObj(CFClass *this, const void *a2)
{
  if (this) {
    uint64_t v2 = (char *)this + 16;
  }
  else {
    uint64_t v2 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v2 + 24))();
}

uint64_t CFClass::CopyFormattingDescObj(CFClass *this, const void *a2, const __CFDictionary *a3)
{
  if (this) {
    uint64_t v3 = (char *)this + 16;
  }
  else {
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(char *, const void *))(*(void *)v3 + 16))(v3, a2);
}

uint64_t CFClass::HashObj(CFClass *this, const void *a2)
{
  if (this) {
    uint64_t v2 = (char *)this + 16;
  }
  else {
    uint64_t v2 = 0;
  }
  return (*(uint64_t (**)(void))(*(void *)v2 + 8))();
}

uint64_t CFClass::EqualObj(CFClass *this, char *a2, const void *a3)
{
  if (this) {
    uint64_t v3 = (char *)this + 16;
  }
  else {
    uint64_t v3 = 0;
  }
  if (a2) {
    uint64_t v4 = a2 + 16;
  }
  else {
    uint64_t v4 = 0;
  }
  return (**(uint64_t (***)(char *, char *, const void *))v3)(v3, v4, a3);
}

CFObject *CFObject::_cfobj_instance_retain(CFObject *this, void *a2)
{
  return this;
}

void CFObject::_cfobj_instance_release(CFObject *this, void *a2)
{
}

CFStringRef CFObject::_cfobj_instance_copyDescription(CFObject *this, void *a2)
{
  return CFCopyDescription((char *)this - 16);
}

void ___Z26_cfnAutoreleaseDebugBufferl_block_invoke_2(uint64_t a1)
{
  int v2 = _cfnAutoreleaseDebugBuffer(long)::pPos;
  size_t v3 = *(void *)(a1 + 40);
  _cfnAutoreleaseDebugBuffer(long)::pPos += v3;
  if (_cfnAutoreleaseDebugBuffer(long)::pPos >= 0x200)
  {
    int v2 = 0;
    _cfnAutoreleaseDebugBuffer(long)::pPos = 0;
  }
  uint64_t v4 = (void *)(_cfnAutoreleaseDebugBuffer(long)::pBuffer + v2);
  bzero(v4, v3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
}

dispatch_queue_t ___Z26_cfnAutoreleaseDebugBufferl_block_invoke()
{
  _cfnAutoreleaseDebugBuffer(long)::pBuffer = (uint64_t)malloc_type_malloc(0x200uLL, 0x5FBE3EDAuLL);
  dispatch_queue_t result = dispatch_queue_create("circLock", 0);
  _cfnAutoreleaseDebugBuffer(long)::sLock = (uint64_t)result;
  return result;
}

char *_cfnAutoreleaseInDebug(const __CFString *a1)
{
  if (!a1) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  if (_cfnAutoreleaseDebugBuffer(long)::sOnce != -1) {
    dispatch_once(&_cfnAutoreleaseDebugBuffer(long)::sOnce, &__block_literal_global_4366);
  }
  if (v3 >= 512) {
    goto LABEL_7;
  }
  uint64_t v7 = 0;
  double v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___Z26_cfnAutoreleaseDebugBufferl_block_invoke_2;
  void v6[3] = &unk_1E5257C30;
  v6[4] = &v7;
  void v6[5] = v3;
  dispatch_sync((dispatch_queue_t)_cfnAutoreleaseDebugBuffer(long)::sLock, v6);
  uint64_t v4 = (char *)v8[3];
  _Block_object_dispose(&v7, 8);
  if (v4) {
    CFStringGetCString(a1, v4, v3, 0x8000100u);
  }
  else {
LABEL_7:
  }
    uint64_t v4 = "-";
  CFRelease(a1);
  return v4;
}

_OWORD *CFURLConnectionCreate(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = (void *)MEMORY[0x18531D6D0]();
  uint64_t v7 = CFURLConnectionCreateWithProperties(a1, a2, a3, 0);
  return v7;
}

_OWORD *CFURLConnectionCreateWithProperties(uint64_t a1, void *a2, void *a3, const __CFDictionary *a4)
{
  uint64_t v6 = MEMORY[0x18531D6D0]();
  if (!a2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "CFURLConnectionCreate(): Asked to create from a NULL request!", buf, 2u);
  }
  uint64_t v7 = (_CFURLRequest *)[a2 mutableCopy];
  if (a4)
  {
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a4, @"kCFURLConnectionSocketStreamProperties");
    if (Value)
    {
      CFDictionaryRef v9 = (const __CFDictionary *)CFDictionaryGetValue(Value, &unk_1EC0A0A58);
      if (v9)
      {
        CFDictionaryRef v10 = v9;
        if (CFDictionaryContainsKey(v9, @"kConditionalConnectionRequirementTimeWindowDelay")
          || CFDictionaryContainsKey(v10, @"kConditionalConnectionRequirementTimeWindowStartTime"))
        {
          uint64_t v11 = [(_CFURLRequest *)v7 _inner];
          *(_WORD *)(v11 + 64) |= 0x400u;
          *(void *)(v11 + CFRelease((char *)this - 16) = 1;
        }
      }
    }
    uint64_t v12 = CFDictionaryGetValue(a4, &unk_1EC0A3880);
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = [(_CFURLRequest *)v7 _inner];
      CFRetain(v13);
      uint64_t v15 = *(const void **)(v14 + 200);
      if (v15) {
        CFRelease(v15);
      }
      *(void *)(v14 + 20_CFNetworkResetHSTSHostsSinceDate(0, 0) = v13;
    }
  }
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v17 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v17 = Instance + 1;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
  }
  *(void *)uint64_t v17 = &unk_1ECFA1090;
  *((void *)v17 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECFA1180;
  *((void *)v17 + 2) = &unk_1ECFA11E0;
  if (a4)
  {
    CFDictionaryRef v18 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"kCFURLConnectionSocketStreamProperties");
    CFDictionaryRef v19 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"kCFURLConnectionURLConnectionProperties");
    UpdatedSocketPropertiesForRequest = createUpdatedSocketPropertiesForRequest(v7, v18, v19);
  }
  else
  {
    UpdatedSocketPropertiesForRequest = createUpdatedSocketPropertiesForRequest(v7, 0, 0);
    CFDictionaryRef v19 = 0;
  }
  uint64_t v21 = +[NSURLSession _sharedSessionForConnection]();
  if (v21)
  {
    uint64_t v22 = [[CONNECTION_SessionTask alloc] initWithRequest:a2 mutableCurrent:v7 connProps:v19 sockProps:UpdatedSocketPropertiesForRequest session:v21];
    if (!UpdatedSocketPropertiesForRequest) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  uint64_t v22 = 0;
  if (UpdatedSocketPropertiesForRequest) {
LABEL_23:
  }
    CFRelease(UpdatedSocketPropertiesForRequest);
LABEL_24:
  *((void *)v17 + 7) = v22;
  CFAllocatorRef v23 = CFGetAllocator(v17 - 1);
  uint64_t v24 = [*((id *)v17 + 7) session];
  SCNetworkConnectionContext context = (void *)v6;
  if (v24) {
    CFIndex v25 = *(NSObject **)(v24 + 120);
  }
  else {
    CFIndex v25 = 0;
  }
  __int16 v26 = CFAllocatorAllocate(v23, 288, 0);
  _OWORD *v26 = 0u;
  v26[2] = 0u;
  v26[5] = 0u;
  v26[6] = 0u;
  v26[7] = 0u;
  v26[8] = 0u;
  v26[9] = 0u;
  v26[10] = 0u;
  v26[11] = 0u;
  v26[12] = 0u;
  v26[13] = 0u;
  v26[14] = 0u;
  v26[15] = 0u;
  v26[16] = 0u;
  v26[17] = 0u;
  void v26[4] = 0u;
  v26[3] = 0u;
  v26[1] = 0u;
  int v27 = (void *)*((void *)v17 + 7);
  uint64_t v28 = URLConnectionInstanceData::URLConnectionInstanceData((uint64_t)v26, (uint64_t)v17 + 8, v25);
  *(void *)uint64_t v28 = &unk_1ECFA0730;
  *((void *)v26 + 2) = &unk_1ECFA0878;
  *((void *)v26 + 6) = &unk_1ECFA0898;
  *(void *)(v28 + 56) = &unk_1ECFA0950;
  *((void *)v26 + 8) = &unk_1ECFA09A8;
  *(void *)(v28 + 2CFRelease((char *)this - 16) = v17;
  *(void *)(v28 + 88) = v27;
  *(void *)(v28 + 12_CFNetworkResetHSTSHostsSinceDate(0, 0) = 1;
  *(unsigned char *)(v28 + 232) = 0;
  *(void *)long long buf = MEMORY[0x1E4F143A8];
  uint64_t v35 = 3221225472;
  double v36 = ___ZN19URLConnectionClientC2EP20ClassicURLConnectionP16NSURLSessionTaskPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
  double v37 = &__block_descriptor_40_e24_v16__0r__XURLCache_____8l;
  uint64_t v38 = v28;
  [v27 _withXURLCache:buf];
  *((unsigned char *)v26 + 132) = 0;
  *((_DWORD *)v26 + 32) = 0;
  *((unsigned char *)v26 + 14_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
  *((_DWORD *)v26 + 34) = 0;
  *((void *)v26 + 25) = 0;
  *((_DWORD *)v26 + 52) = 0;
  *((unsigned char *)v26 + 24) = 1;
  *(void *)__int16 v26 = &unk_1ECFA3C90;
  *((void *)v26 + 2) = &unk_1ECFA3E70;
  *((void *)v26 + 6) = &unk_1ECFA3E90;
  *((void *)v26 + 7) = &unk_1ECFA3F48;
  *((void *)v26 + 8) = &unk_1ECFA3FA0;
  *((void *)v26 + 33) = 0;
  *((void *)v26 + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  URLConnectionClient_Classic::setDelegate((uint64_t)v26, (uint64_t)a3);
  *((void *)v17 + 3) = v26;
  buf[0] = 0x80;
  if (a3)
  {
    uint8_t v29 = 0x80;
    switch(*a3)
    {
      case 3:
      case 4:
        goto LABEL_38;
      case 5:
      case 6:
        goto LABEL_36;
      case 7:
        goto LABEL_34;
      case 8:
        goto LABEL_32;
      case 9:
        if (a3[23])
        {
          uint8_t v29 = -112;
          buf[0] = -112;
        }
        if (a3[22])
        {
          v29 |= 0x20u;
          buf[0] = v29;
        }
LABEL_32:
        if (a3[21])
        {
          v29 |= 8u;
          buf[0] = v29;
        }
LABEL_34:
        if (a3[19]) {
          CFLog();
        }
LABEL_36:
        if (a3[17])
        {
          v29 |= 1u;
          buf[0] = v29;
        }
LABEL_38:
        if (a3[13]) {
          buf[0] = v29 | 2;
        }
        if (a3[14]) {
          *(_WORD *)(*((void *)v17 + 3) + 76) |= 0x100u;
        }
        break;
      default:
        break;
    }
  }
  CFStreamError v30 = (URLConnectionLoader_Classic *)CFAllocatorAllocate(v23, 224, 0);
  *(_OWORD *)CFStreamError v30 = 0u;
  *((_OWORD *)v30 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  *((_OWORD *)v30 + 2) = 0u;
  *((_OWORD *)v30 + 3) = 0u;
  *((_OWORD *)v30 + 4) = 0u;
  *((_OWORD *)v30 + 5) = 0u;
  *((_OWORD *)v30 + 6) = 0u;
  *((_OWORD *)v30 + 7) = 0u;
  *((_OWORD *)v30 + 8) = 0u;
  *((_OWORD *)v30 + 9) = 0u;
  *((_OWORD *)v30 + 1_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
  *((_OWORD *)v30 + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  *((_OWORD *)v30 + 12) = 0u;
  *((_OWORD *)v30 + 13) = 0u;
  URLConnectionLoader_Classic::URLConnectionLoader_Classic(v30, (InterfaceRequiredForLoader *)((char *)v17 + 8), (const ConfigFlags *)buf, (__NSURLSessionLocal *)[*((id *)v17 + 7) session], v25);
  *((void *)v17 + 4) = v30;

  if (v7) {
    CFRelease(v7);
  }
  return v17 - 1;
}

void sub_1841DD904(_Unwind_Exception *a1)
{
  URLConnectionClient::~URLConnectionClient(v1);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI13URLConnectionE5ClassEv_block_invoke()
{
}

void sub_1841DD9A8(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void CFURLConnectionStart(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  if (a1) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)v3 + 56))(v3);
}

void CFURLConnectionCancel(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  if (a1) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = 0;
  }
  (*(void (**)(void))(*(void *)(v3 + 8) + 48))();
}

void CFURLConnectionUseCredential(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  if (a1) {
    uint64_t v7 = a1 + 16;
  }
  else {
    uint64_t v7 = 0;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 64))(v7, a2, a3);
}

void CFURLConnectionPerformDefaultHandlingForChallenge(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 72))(v5, a2);
}

void CFURLConnectionRejectChallenge(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 80))(v5, a2);
}

void CFURLConnectionHalt(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  if (a1) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)v3 + 88))(v3);
}

void CFURLConnectionResume(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  if (a1) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)v3 + 96))(v3);
}

void CFURLConnectionScheduleWithRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  if (a1) {
    uint64_t v7 = a1 + 16;
  }
  else {
    uint64_t v7 = 0;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 104))(v7, a2, a3);
}

void CFURLConnectionUnscheduleFromRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  if (a1) {
    uint64_t v7 = a1 + 16;
  }
  else {
    uint64_t v7 = 0;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 112))(v7, a2, a3);
}

void CFURLConnectionScheduleDownloadWithRunLoop()
{
  if (CFURLConnectionScheduleDownloadWithRunLoop::onceToken != -1) {
    dispatch_once(&CFURLConnectionScheduleDownloadWithRunLoop::onceToken, &__block_literal_global_4401);
  }
}

void __CFURLConnectionScheduleDownloadWithRunLoop_block_invoke()
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v0 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_error_impl(&dword_184085000, v0, OS_LOG_TYPE_ERROR, "Scheduling the NSURLConnection loader is no longer supported.", v1, 2u);
  }
}

void CFURLConnectionSetDelegateDispatchQueue(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
  }
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 120))(v5, a2);
}

void CFURLConnectionInvalidateConnectionCache()
{
  uint64_t v0 = (void *)MEMORY[0x18531D6D0]();
  uint64_t v1 = +[NSURLSession _sharedSessionForConnection]();
  if (v1)
  {
    int v2 = *(CFDictionaryRef **)(v1 + 168);
    if (v2) {
      XTubeManager::invalidateAllConnections(v2, 0);
    }
  }
}

void *_CFURLConnectionCopyTimingData(void *a1)
{
  int v2 = (void *)MEMORY[0x18531D6D0]();
  if (a1)
  {
    if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
      dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_12_4393);
    }
    uint64_t v3 = (void *)a1[9];
    if (!v3) {
      goto LABEL_9;
    }
    id Property = (id)[v3 _metrics];
    if (Property) {
      id Property = objc_getProperty(Property, v5, 96, 1);
    }
    id v6 = -[__CFN_TransactionMetrics legacyStaticMetrics]((uint64_t)Property);
    if (v6) {
      a1 = CFRetain(v6);
    }
    else {
LABEL_9:
    }
      a1 = 0;
  }
  return a1;
}

void non-virtual thunk to'HTTPRequest::~HTTPRequest(HTTPRequest *this)
{
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 128));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 16));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 16));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 8));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 8));
}

void non-virtual thunk to'HTTPResponse::~HTTPResponse(HTTPResponse *this)
{
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 16));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 8));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 8));
}

uint64_t non-virtual thunk to'URLProtocol::_throttle_getMaximumWaitTime(URLProtocol *this)
{
  uint64_t result = [*((id *)this + 8) _timeoutInterval];
  if (v3 + -2.0 >= 0.0) {
    return objc_msgSend(*((id *)this + 8), "_timeoutInterval", 0.0);
  }
  return result;
}

uint64_t non-virtual thunk to'URLProtocol::_throttle_unthrottle(URLProtocol *this)
{
  uint64_t v1 = *((void *)this - 2);
  *((unsigned char *)this + 56) = 0;
  return (*(uint64_t (**)(void))(v1 + 112))();
}

uint64_t non-virtual thunk to'URLProtocol::_throttle_throttle(URLProtocol *this)
{
  uint64_t v1 = *((void *)this - 2);
  *((unsigned char *)this + 56) = 1;
  return (*(uint64_t (**)(void))(v1 + 104))();
}

uint64_t URLProtocol::needsThrottler(URLProtocol *this)
{
  return 0;
}

uint64_t URLProtocol::_throttle_getMaximumWaitTime(URLProtocol *this)
{
  uint64_t result = [*((id *)this + 10) _timeoutInterval];
  if (v3 + -2.0 >= 0.0) {
    return objc_msgSend(*((id *)this + 10), "_timeoutInterval", 0.0);
  }
  return result;
}

uint64_t URLProtocol::_throttle_getCurrentSuspensionThreshold(URLProtocol *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 168))();
}

uint64_t URLProtocol::_throttle_unthrottle(URLProtocol *this)
{
  *((unsigned char *)this + 72) = 0;
  return (*(uint64_t (**)(void))(*(void *)this + 112))();
}

uint64_t URLProtocol::_throttle_throttle(URLProtocol *this)
{
  *((unsigned char *)this + 72) = 1;
  return (*(uint64_t (**)(void))(*(void *)this + 104))();
}

void URLProtocol::setBytesPerSecondLimit(URLProtocol *this, uint64_t a2)
{
  int v2 = (Throttler *)*((void *)this + 8);
  if (v2) {
    Throttler::setMaximumBPSTarget(v2, a2);
  }
}

uint64_t URLProtocol::getCurrentBodyStream(URLProtocol *this)
{
  return 0;
}

BOOL XCredentialStorage::equals(XCredentialStorage *this, XCredentialStorage *a2)
{
  return this == a2;
}

uint64_t NSXCredentialStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = (void *)MEMORY[0x18531D6D0]();
    id v6 = (void *)[*(id *)(a1 + 24) allCredentials];
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    _DWORD v8[2] = ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke;
    void v8[3] = &__block_descriptor_40_e15_v32__0_8_16_B24l;
    v8[4] = a1;
    [v6 enumerateKeysAndObjectsUsingBlock:v8];
  }
  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

uint64_t ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  void v5[2] = ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke_2;
  v5[3] = &unk_1E5253C30;
  void v5[4] = a2;
  void v5[5] = v3;
  return [a3 enumerateKeysAndObjectsUsingBlock:v5];
}

uint64_t ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(*(void *)(a1 + 40) + 24) removeCredential:a3 forProtectionSpace:*(void *)(a1 + 32)];
}

uint64_t NSXCredentialStorage::copyCredentialsForProtectionSpace(NSXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000;
  uint64_t v16 = 0;
  id v6 = (void *)MEMORY[0x18531D6D0]();
  id v7 = [[NSURLProtectionSpace alloc] _initWithCFURLProtectionSpace:a2];
  double v8 = dispatch_group_create();
  dispatch_group_enter(v8);
  CFDictionaryRef v9 = (void *)*((void *)this + 3);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  void v12[2] = ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke;
  v12[3] = &unk_1E5253C08;
  v12[4] = v8;
  v12[5] = &v13;
  [v9 getCredentialsForProtectionSpace:v7 task:a3 completionHandler:v12];
  dispatch_group_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v8);
  uint64_t v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_1841DE620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke(uint64_t a1, void *a2)
{
  if (a2 && [a2 count])
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    v4[2] = ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke_2;
    v4[3] = &unk_1E5253BE0;
    void v4[4] = *(void *)(a1 + 40);
    [a2 enumerateKeysAndObjectsUsingBlock:v4];
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = cfTypeCreateMutableDictionary((const __CFAllocator *)*MEMORY[0x1E4F1CF80], 0, 0);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke_2(uint64_t a1, const void *a2, void *a3)
{
  uint64_t v5 = (const void *)[a3 _cfurlcredential];
  if (v5)
  {
    CFTypeRef v6 = CFRetain(v5);
    if (v6)
    {
      id v7 = v6;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), a2, v6);
      CFRelease(v7);
    }
  }
}

uint64_t NSXCredentialStorage::copyDefaultCredentialForProtectionSpace(NSXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000;
  uint64_t v16 = 0;
  CFTypeRef v6 = (void *)MEMORY[0x18531D6D0]();
  id v7 = [[NSURLProtectionSpace alloc] _initWithCFURLProtectionSpace:a2];
  double v8 = dispatch_group_create();
  dispatch_group_enter(v8);
  CFDictionaryRef v9 = (void *)*((void *)this + 3);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  void v12[2] = ___ZNK20NSXCredentialStorage39copyDefaultCredentialForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke;
  v12[3] = &unk_1E5253BB8;
  v12[4] = v8;
  v12[5] = &v13;
  [v9 getDefaultCredentialForProtectionSpace:v7 task:a3 completionHandler:v12];
  dispatch_group_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v8);
  uint64_t v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_1841DE8CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZNK20NSXCredentialStorage39copyDefaultCredentialForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke(uint64_t a1, void *a2)
{
  CFTypeRef v3 = (CFTypeRef)[a2 _cfurlcredential];
  if (v3) {
    CFTypeRef v3 = CFRetain(v3);
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v3;
  uint64_t v4 = *(NSObject **)(a1 + 32);

  dispatch_group_leave(v4);
}

void NSXCredentialStorage::removeCredentialForProtectionSpace(id *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  double v8 = (void *)MEMORY[0x18531D6D0]();
  objc_msgSend(this[3], "removeCredential:forProtectionSpace:options:task:", -[NSURLCredential _initWithCFURLCredential:]([NSURLCredential alloc], "_initWithCFURLCredential:", a2), -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]([NSURLProtectionSpace alloc], "_initWithCFURLProtectionSpace:", a3), 0, a4);
}

void NSXCredentialStorage::setCredentialForProtectionSpace(id *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  double v8 = (void *)MEMORY[0x18531D6D0]();
  objc_msgSend(this[3], "setCredential:forProtectionSpace:task:", -[NSURLCredential _initWithCFURLCredential:]([NSURLCredential alloc], "_initWithCFURLCredential:", a2), -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]([NSURLProtectionSpace alloc], "_initWithCFURLProtectionSpace:", a3), a4);
}

void NSXCredentialStorage::setDefaultCredentialForProtectionSpace(id *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  double v8 = (void *)MEMORY[0x18531D6D0]();
  objc_msgSend(this[3], "setDefaultCredential:forProtectionSpace:task:", -[NSURLCredential _initWithCFURLCredential:]([NSURLCredential alloc], "_initWithCFURLCredential:", a2), -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]([NSURLProtectionSpace alloc], "_initWithCFURLProtectionSpace:", a3), a4);
}

CFAllocatedReferenceCountedObject *XCredentialStorage::createCFXCredentialStorage(XCredentialStorage *this, _CFURLCredentialStorage *a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v4 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 32, 0);
  *(_OWORD *)uint64_t v4 = 0u;
  *((_OWORD *)v4 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v4, v3);
  *uint64_t v5 = &unk_1ECFA1018;
  if (this) {
    CFTypeRef v6 = CFRetain(this);
  }
  else {
    CFTypeRef v6 = 0;
  }
  *((void *)v4 + 3) = v6;
  return v4;
}

uint64_t CFXCredentialStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = (const void *)CFURLCredentialStorageCopyAllCredentials(*(void *)(a1 + 24));
    if (v5)
    {
      CFTypeRef v6 = v5;
      CFContainerEnumeratorBase::setup((unint64_t)v14, v5, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictKeyData);
      CFContainerEnumeratorBase::setup((unint64_t)&v16, v6, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
      if (v17 >= 1)
      {
        for (uint64_t i = 0; i < v17; ++i)
        {
          uint64_t v8 = *(void *)(v15 + 8 * i);
          CFContainerEnumeratorBase::setup((unint64_t)&v11, *(CFTypeRef *)(v18 + 8 * i), MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
          if (v12 >= 1)
          {
            for (uint64_t j = 0; j < v12; ++j)
              CFURLCredentialStorageRemoveCredentialForProtectionSpace(*(void *)(a1 + 24), *(void *)(v13 + 8 * j), v8);
          }
          CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v11);
        }
      }
      CFRelease(v6);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v16);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v14);
    }
  }
  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

void sub_1841DED70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v43);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a43);
  _Unwind_Resume(a1);
}

uint64_t CFXCredentialStorage::copyCredentialsForProtectionSpace(CFXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  return CFURLCredentialStorageCopyCredentialsForProtectionSpace(*((void *)this + 3), (uint64_t)a2);
}

uint64_t CFXCredentialStorage::copyDefaultCredentialForProtectionSpace(CFXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  return CFURLCredentialStorageCopyDefaultCredentialForProtectionSpace(*((void *)this + 3), (uint64_t)a2);
}

void CFXCredentialStorage::removeCredentialForProtectionSpace(CFXCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
}

uint64_t CFXCredentialStorage::setCredentialForProtectionSpace(CFXCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  return CFURLCredentialStorageSetCredentialForProtectionSpace(*((void *)this + 3), (uint64_t)a2, (uint64_t)a3);
}

uint64_t CFXCredentialStorage::setDefaultCredentialForProtectionSpace(CFXCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  return CFURLCredentialStorageSetDefaultCredentialForProtectionSpace(*((void *)this + 3), (uint64_t)a2, (uint64_t)a3);
}

void CFXCredentialStorage::~CFXCredentialStorage(CFXCredentialStorage *this)
{
  *(void *)this = &unk_1ECFA1018;
  int v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);

  CFAllocatorDeallocate(v3, this);
}

{
  const void *v1;

  *(void *)this = &unk_1ECFA1018;
  uint64_t v1 = (const void *)*((void *)this + 3);
  if (v1) {
    CFRelease(v1);
  }
}

unint64_t URLRequest::hash(URLRequest *this)
{
  CFHashCode fURL = (CFHashCode)this->fURL;
  if (fURL) {
    CFHashCode fURL = CFHash((CFTypeRef)fURL);
  }
  return fURL ^ (4 * this->fCachePolicy);
}

CFStringRef URLRequest::copyDebugSummary(URLRequest *this)
{
  fHTTPRequest = this->fHTTPRequest;
  if (fHTTPRequest)
  {
    uint64_t v3 = (*(uint64_t (**)(HTTPRequest *))(*(void *)fHTTPRequest + 32))(fHTTPRequest);
    if (v3)
    {
      uint64_t v4 = (const void *)v3;
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"request %@", v3);
      CFRelease(v4);
      if (v5) {
        return v5;
      }
    }
  }
  CFHashCode fURL = this->fURL;
  if (fURL)
  {
    CFURLRef v7 = CFURLCopyAbsoluteURL(fURL);
    if (v7)
    {
      CFURLRef v8 = v7;
      if (__CFNCanLogSensitiveContent::onceToken != -1) {
        dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_38);
      }
      if (__CFNCanLogSensitiveContent::ok)
      {
        CFStringRef v9 = CFURLGetString(v8);
        if (!v9)
        {
          CFRelease(v8);
          goto LABEL_15;
        }
        CFStringRef v10 = (const __CFString *)CFRetain(v9);
      }
      else
      {
        CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@://%@/<redacted>", [(__CFURL *)v8 scheme], [(__CFURL *)v8 host]);
      }
      CFStringRef v5 = v10;
      CFRelease(v8);
      if (v5) {
        return v5;
      }
    }
  }
LABEL_15:

  return (CFStringRef)CFRetain(@"request has no url");
}

CFStringRef URLRequest::copyDebugDesc(URLRequest *this)
{
  CFHashCode fURL = this->fURL;
  if (fURL) {
    CFStringRef v3 = CFURLGetString(fURL);
  }
  else {
    CFStringRef v3 = @"Null URL";
  }
  if ((*(_WORD *)&this->fFlags & 2) != 0) {
    uint64_t v4 = "CFMutableURLRequest";
  }
  else {
    uint64_t v4 = "CFURLRequest";
  }
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<%s %p> { url = %@ }", v4, this, v3);
}

CFTypeRef HTTPRequest::setCookieStorage(HTTPRequest *this, CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 24);
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    CFTypeRef result = CFRetain(cf);
    *((void *)this + 24) = result;
  }
  return result;
}

uint64_t ___ZN10URLRequest10initializeEPK14__CFDictionary_block_invoke(uint64_t a1, const __CFString *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 32);
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t result = [a3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = *(void *)v11;
    do
    {
      uint64_t v9 = 0;
      do
      {
        if (*(void *)v11 != v8) {
          objc_enumerationMutation(a3);
        }
        HTTPMessage::addHeaderFieldStringValue(*(HTTPMessage **)(v5 + 56), a2, *(const __CFString **)(*((void *)&v10 + 1) + 8 * v9++));
      }
      while (v7 != v9);
      uint64_t result = [a3 countByEnumeratingWithState:&v10 objects:v14 count:16];
      uint64_t v7 = result;
    }
    while (result);
  }
  return result;
}

void non-virtual thunk to'CoreStreamBase::~CoreStreamBase(CoreStreamBase *this)
{
  CoreStreamBase::~CoreStreamBase((CoreStreamBase *)((char *)this - 8));

  JUMPOUT(0x18531B6D0);
}

{
  CoreStreamBase::~CoreStreamBase((CoreStreamBase *)((char *)this - 8));
}

void CoreStreamBase::~CoreStreamBase(CoreStreamBase *this)
{
  *(void *)this = &unk_1ECF9C9C8;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9CA18;
  *((void *)this + 3) = 0;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 26);
  uint64_t v3 = *((void *)this + 14);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
    *((void *)this + 14) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 26);
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9B550;
}

{
  uint64_t vars8;

  CoreStreamBase::~CoreStreamBase(this);

  JUMPOUT(0x18531B6D0);
}

void sub_1841DF39C(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t CoreStreamBase::streamSetClient(uint64_t this, uint64_t a2, CoreStreamClient *a3)
{
  uint64_t v3 = *(void *)(this + 16);
  *(void *)(this + CFRelease((char *)this - 16) = a3;
  if (a3)
  {
    uint64_t v5 = this;
    this = (*(uint64_t (**)(CoreStreamClient *))(*(void *)a3 + 16))(a3);
    if (*(void *)(v5 + 32) != a2)
    {
      *(void *)(v5 + 32) = a2;
      ++*(void *)(v5 + 80);
      this = (*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 24) + 48))(*(void *)(v5 + 24), a2);
      --*(void *)(v5 + 80);
    }
  }
  if (v3)
  {
    CFTypeRef v6 = *(uint64_t (**)(uint64_t))(*(void *)v3 + 24);
    return v6(v3);
  }
  return this;
}

CFStringRef CoreStreamBase::copyDebugDesc(CoreStreamBase *this)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  uint64_t v3 = (SES *)*((void *)this + 4);
  uint64_t v4 = (SES *)*((void *)this + 5);
  uint64_t v5 = *((void *)this + 12);
  strcpy(v12, "e:");
  uint64_t v7 = &v12[SES::pushEvent(v3, (unint64_t)&v12[2], (char *)&v13, v6) + 2];
  unint64_t v8 = (unint64_t)&v7[snprintf(v7, (char *)&v13 - v7, " p:")];
  unint64_t v10 = SES::pushEvent(v4, v8, (char *)&v13, v9);
  snprintf((char *)(v8 + v10), (size_t)&v13 - v8 - v10, " s:%c", aNoorwecx[v5]);
  return CFStringCreateWithFormat(v2, 0, @"CoreStreamBase<%s>(%p %s)", "", this, v12);
}

unint64_t SES::pushEvent(SES *this, unint64_t a2, char *a3, char *a4)
{
  unint64_t v5 = a2;
  if (a2 < (unint64_t)a3)
  {
    int v7 = (int)this;
    unint64_t v8 = 0;
    do
    {
      __darwin_ct_rune_t v9 = aOrwedm[v8];
      if (((1 << v8) & v7) == 0) {
        LOBYTE(v9) = __tolower(v9);
      }
      *(unsigned char *)(a2 + v8) = v9;
      unint64_t v10 = a2 + v8 + 1;
      unint64_t v11 = v8 + 1;
      if (v8 > 4) {
        break;
      }
      ++v8;
    }
    while (v10 < (unint64_t)a3);
    unint64_t v5 = a2 + v11;
  }
  return v5 - a2;
}

uint64_t CoreStreamBase::copySchedulingSet(os_unfair_lock_s *this)
{
  CFAllocatorRef v2 = this + 26;
  os_unfair_lock_lock(this + 26);
  uint64_t Empty = *(void *)&this[28]._os_unfair_lock_opaque;
  if (!Empty)
  {
    uint64_t Empty = CoreSchedulingSet::createEmpty(v3);
    *(void *)&this[28]._os_unfair_lock_opaque = Empty;
  }
  (*(void (**)(uint64_t))(*(void *)Empty + 40))(Empty);
  os_unfair_lock_unlock(v2);
  return Empty;
}

void CoreStreamBase::setSchedulingSet(os_unfair_lock_s *this, const CoreSchedulingSet *a2)
{
  uint64_t v4 = this + 26;
  os_unfair_lock_lock(this + 26);
  uint64_t v5 = *(void *)&this[28]._os_unfair_lock_opaque;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 48))(v5);
    *(void *)&this[28]._os_unfair_lock_opaque = 0;
  }
  if (a2) {
    *(void *)&this[28]._os_unfair_lock_opaque = (*(uint64_t (**)(const CoreSchedulingSet *))(*(void *)a2 + 88))(a2);
  }

  os_unfair_lock_unlock(v4);
}

uint64_t CoreStreamBase::_streamInterface_Open(CoreStreamBase *this)
{
  uint64_t v1 = 0;
  char v8 = 0;
  if (!*((void *)this + 12))
  {
    ++*((void *)this + 10);
    *((void *)this + 12) = 1;
    long long v7 = 0uLL;
    uint64_t v3 = (*(uint64_t (**)(void, long long *, char *))(**((void **)this + 3) + 56))(*((void *)this + 3), &v7, &v8);
    uint64_t v1 = v3;
    if (DWORD2(v7))
    {
      *((void *)this + 12) = 7;
      *(_OWORD *)((char *)this + 56) = v7;
      *((void *)this + 5) |= 8uLL;
      uint64_t v4 = 8;
    }
    else
    {
      if (v3) {
        BOOL v5 = v8 == 0;
      }
      else {
        BOOL v5 = 1;
      }
      if (v5) {
        goto LABEL_12;
      }
      if (*((void *)this + 12) == 1) {
        *((void *)this + 12) = 2;
      }
      uint64_t v4 = 1;
    }
    CoreStreamBase::_streamSetEventAndScheduleDelivery(this, v4, 0);
LABEL_12:
    --*((void *)this + 10);
  }
  return v1;
}

void CoreStreamBase::_streamSetEventAndScheduleDelivery(CoreStreamBase *this, uint64_t a2, int a3)
{
  uint64_t v6 = *((void *)this + 4);
  long long v7 = (os_unfair_lock_s *)((char *)this + 104);
  os_unfair_lock_lock((os_unfair_lock_t)this + 26);
  uint64_t v8 = *((void *)this + 14);
  os_unfair_lock_unlock(v7);
  if (v8)
  {
    uint64_t v9 = v6 & a2;
    uint64_t v10 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)this);
    unint64_t v11 = (_DWORD *)v10;
    *((void *)this + 5) |= v9;
    if (*((void *)this + 2) && *(_DWORD *)(v10 + 40))
    {
      if (!a3 || *((void *)this + 10)) {
        goto LABEL_6;
      }
      if (CoreSchedulingSet::currentlyInContext((CoreSchedulingSet *)v10))
      {
        uint64_t v13 = (CoreStreamClient *)*((void *)this + 2);
        if (v13)
        {
          CFRetain((char *)this - 16);
          (*(void (**)(CoreStreamClient *))(*(void *)v13 + 16))(v13);
          CoreStreamBase::_callClientNow(this, v13);
          (*(void (**)(CoreStreamClient *))(*(void *)v13 + 24))(v13);
          CFRelease((char *)this - 16);
        }
        goto LABEL_8;
      }
      if (v11[10])
      {
LABEL_6:
        uint64_t v12 = *((void *)this + 2);
        if (v12)
        {
          CFRetain((char *)this - 16);
          (*(void (**)(uint64_t))(*(void *)v12 + 16))(v12);
          v14[0] = MEMORY[0x1E4F143A8];
          v14[1] = 3221225472;
          unsigned __int8 v14[2] = ___ZN14CoreStreamBase34_streamSetEventAndScheduleDeliveryEmh_block_invoke;
          v14[3] = &__block_descriptor_48_e5_v8__0l;
          void v14[4] = this;
          v14[5] = v12;
          (*(void (**)(_DWORD *, void *))(*(void *)v11 + 96))(v11, v14);
        }
      }
    }
LABEL_8:
    (*(void (**)(_DWORD *))(*(void *)v11 + 48))(v11);
  }
}

void *CoreStreamBase::_callClientNow(void *this, CoreStreamClient *a2)
{
  CFAllocatorRef v2 = this;
  uint64_t v3 = this[10];
  this[10] = v3 + 1;
  if (a2)
  {
    uint64_t v4 = this[4] & this[5];
    this[5] = 0;
    this = (void *)(*(uint64_t (**)(CoreStreamClient *, uint64_t))(*(void *)a2 + 40))(a2, v4);
    uint64_t v3 = v2[10] - 1;
  }
  v2[10] = v3;
  return this;
}

void ___ZN14CoreStreamBase34_streamSetEventAndScheduleDeliveryEmh_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 72)) {
    CoreStreamBase::_callClientNow(*(void **)(a1 + 32), *(CoreStreamClient **)(a1 + 40));
  }
  (*(void (**)(void))(**(void **)(a1 + 40) + 24))(*(void *)(a1 + 40));

  CFRelease((CFTypeRef)(v2 - 16));
}

void CoreStreamBase::_streamInterface_Close(CoreStreamBase *this)
{
  uint64_t v1 = *((void *)this + 12);
  if (v1) {
    BOOL v2 = v1 == 6;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2 && (v1 != 7 || !*((unsigned char *)this + 72)))
  {
    *((unsigned char *)this + 72) = 1;
    ++*((void *)this + 10);
    (*(void (**)(void))(**((void **)this + 3) + 72))(*((void *)this + 3));
    *((void *)this + 12) = 6;
    --*((void *)this + 10);
    CoreStreamBase::setSchedulingSet((os_unfair_lock_s *)this, 0);
  }
}

uint64_t CoreStreamBase::_streamInterface_Deprecated_Schedule(os_unfair_lock_s *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6 = CoreStreamBase::copySchedulingSet(this);
  long long v7 = (const CoreSchedulingSet *)(*(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *))(*(void *)v6 + 56))(v6, a2, a3);
  CoreStreamBase::_streamInterface_UpdateScheduling((CoreStreamBase *)this, v7);
  uint64_t v8 = *(uint64_t (**)(const CoreSchedulingSet *))(*(void *)v7 + 48);

  return v8(v7);
}

void CoreStreamBase::_streamInterface_UpdateScheduling(CoreStreamBase *this, const CoreSchedulingSet *a2)
{
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000;
  uint64_t v16 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000;
  uint64_t v12 = 0;
  uint64_t v4 = (char *)this - 16;
  CFRetain((char *)this - 16);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  _DWORD v8[2] = ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke;
  void v8[3] = &unk_1E5253C78;
  void v8[6] = this;
  void v8[7] = a2;
  v8[4] = &v9;
  void v8[5] = &v13;
  ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke((uint64_t)v8);
  uint64_t v5 = v14[3];
  if (v5)
  {
    (*(void (**)(uint64_t, uint64_t, const CoreSchedulingSet *))(*(void *)v5 + 144))(v5, v10[3], a2);
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    int v7[2] = ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke_2;
    v7[3] = &unk_1E5257C30;
    v7[4] = &v9;
    void v7[5] = this;
    ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke_2((uint64_t)v7);
  }
  uint64_t v6 = v10[3];
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 48))(v6);
  }
  CFRelease(v4);
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(&v13, 8);
}

void sub_1841DFEAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 96), 8);
  _Unwind_Resume(a1);
}

void ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)v2);
  if ((*(unsigned int (**)(uint64_t, void))(*(void *)v3 + 24))(v3, *(void *)(a1 + 56)))
  {
    uint64_t v4 = *(void (**)(uint64_t))(*(void *)v3 + 48);
    v4(v3);
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v3;
    CoreStreamBase::setSchedulingSet((os_unfair_lock_s *)v2, *(const CoreSchedulingSet **)(a1 + 56));
    ++*(void *)(v2 + 88);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = *(void *)(v2 + 24);
  }
}

uint64_t ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  --*(void *)(v2 + 88);
  uint64_t v3 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)v2);
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v5)
  {
    if (!*(_DWORD *)(v5 + 40))
    {
      if (*(_DWORD *)(v3 + 40))
      {
        uint64_t v6 = *(void *)(v2 + 40);
        if (v6) {
          CoreStreamBase::_streamSetEventAndScheduleDelivery((CoreStreamBase *)v2, v6, 0);
        }
      }
    }
  }
  long long v7 = *(uint64_t (**)(uint64_t))(*(void *)v4 + 48);

  return v7(v4);
}

uint64_t CoreStreamBase::_streamInterface_Deprecated_Unschedule(os_unfair_lock_s *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6 = CoreStreamBase::copySchedulingSet(this);
  long long v7 = (const CoreSchedulingSet *)(*(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *))(*(void *)v6 + 64))(v6, a2, a3);
  CoreStreamBase::_streamInterface_UpdateScheduling((CoreStreamBase *)this, v7);
  uint64_t v8 = *(uint64_t (**)(const CoreSchedulingSet *))(*(void *)v7 + 48);

  return v8(v7);
}

uint64_t CoreStreamBase::_streamInterface_GetStatus(CoreStreamBase *this)
{
  uint64_t result = *((void *)this + 12);
  if (result == 1)
  {
    ++*((void *)this + 10);
    long long v5 = 0uLL;
    int v3 = (*(uint64_t (**)(void, long long *))(**((void **)this + 3) + 64))(*((void *)this + 3), &v5);
    --*((void *)this + 10);
    if (DWORD2(v5))
    {
      *((void *)this + 12) = 7;
      *(_OWORD *)((char *)this + 56) = v5;
      *((void *)this + 5) |= 8uLL;
      uint64_t v4 = 8;
    }
    else
    {
      if (!v3 || *((void *)this + 12) != 1) {
        return *((void *)this + 12);
      }
      *((void *)this + 12) = 2;
      uint64_t v4 = 1;
    }
    CoreStreamBase::_streamSetEventAndScheduleDelivery(this, v4, 0);
    return *((void *)this + 12);
  }
  return result;
}

void CoreStreamBase::_signalEvent(CoreStreamBase *this, uint64_t a2, CFStreamError a3, int a4)
{
  uint64_t v5 = *(void *)&a3.error;
  CFIndex domain = a3.domain;
  uint64_t v8 = *((void *)this + 12);
  uint64_t v9 = 0;
  switch(v8)
  {
    case 0:
    case 6:
    case 7:
      goto LABEL_21;
    case 1:
      if (a2) {
        *((void *)this + 12) = 2;
      }
      BOOL v10 = 1;
      if ((a2 & 0x10) != 0) {
        goto LABEL_7;
      }
      goto LABEL_9;
    case 5:
      uint64_t v9 = a2 & 8;
      if ((a2 & 8) != 0) {
        goto LABEL_12;
      }
      goto LABEL_21;
    default:
      a2 &= ~1uLL;
      BOOL v10 = v8 < 5;
      if ((a2 & 0x10) != 0)
      {
LABEL_7:
        if (v10) {
          *((void *)this + 12) = 5;
        }
      }
LABEL_9:
      uint64_t v9 = a2;
      if ((a2 & 8) == 0) {
        goto LABEL_21;
      }
LABEL_12:
      if (a3.domain == *MEMORY[0x1E4F1D430]
        && (a3.error + 9850) <= 0x2B
        && ((1 << (LOBYTE(a3.error) + 122)) & 0xC7803E80081) != 0)
      {
        ++*((void *)this + 10);
        CFBooleanRef v11 = (const __CFBoolean *)(*(uint64_t (**)(void, __CFString *))(**((void **)this + 3) + 40))(*((void *)this + 3), @"kCFStreamPropertyConnectionIsCellular");
        --*((void *)this + 10);
        if (v11)
        {
          CFBooleanRef v12 = v11;
          if (!CFBooleanGetValue(v11)) {
            __CFNReportSSLSymptom(domain, v5);
          }
          CFRelease(v12);
        }
        else
        {
          __CFNReportSSLSymptom(domain, v5);
        }
      }
      *((void *)this + 7) = domain;
      *((void *)this + 8) = v5;
      *((void *)this + 12) = 7;
LABEL_21:
      CoreStreamBase::_streamSetEventAndScheduleDelivery(this, v9, a4);
      return;
  }
}

uint64_t CoreStreamBase::_streamInterface_Read(CoreStreamBase *this, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6 = *((void *)this + 12);
  if (v6 == 1)
  {
    CoreStreamBase::blockingWaitForOpen(this);
    uint64_t v6 = *((void *)this + 12);
  }
  if ((unint64_t)(v6 - 2) >= 2)
  {
    if (v6 == 5) {
      return 0;
    }
    else {
      return -1;
    }
  }
  else
  {
    ++*((void *)this + 10);
    *((void *)this + 5) &= ~2uLL;
    *((void *)this + 12) = 3;
    long long v12 = 0uLL;
    char v11 = 0;
    uint64_t v7 = (*(uint64_t (**)(void, unsigned __int8 *, uint64_t, long long *, char *))(**((void **)this + 3)
                                                                                           + 80))(*((void *)this + 3), a2, a3, &v12, &v11);
    if (DWORD2(v12))
    {
      if (*((uint64_t *)this + 12) <= 5)
      {
        *(_OWORD *)((char *)this + 56) = v12;
        *((void *)this + 12) = 7;
        *((void *)this + 5) |= 8uLL;
        CoreStreamBase::_streamSetEventAndScheduleDelivery(this, 8, 0);
      }
      uint64_t v8 = -1;
    }
    else
    {
      uint64_t v8 = v7;
      uint64_t v10 = *((void *)this + 12);
      if (v11)
      {
        if (v10 <= 4)
        {
          *((void *)this + 12) = 5;
          *((void *)this + 5) |= 0x10uLL;
          CoreStreamBase::_streamSetEventAndScheduleDelivery(this, 16, 0);
        }
      }
      else if (v10 == 3)
      {
        *((void *)this + 12) = 2;
      }
    }
    --*((void *)this + 10);
  }
  return v8;
}

void CoreStreamBase::blockingWaitForOpen(CoreStreamBase *this)
{
  uint64_t v2 = (char *)this - 16;
  CFRetain((char *)this - 16);
  uint64_t v11 = 0;
  long long v12 = &v11;
  uint64_t v13 = 0x2020000000;
  uint64_t v14 = 0;
  ++*((void *)this + 11);
  v12[3] = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)this);
  double Current = (CoreSchedulingSet *)CFRunLoopGetCurrent();
  uint64_t v5 = (const CoreSchedulingSet *)CoreSchedulingSet::create(Current, @"CoreStreamOpenBlocking", v4);
  CoreStreamBase::_streamInterface_UpdateScheduling(this, v5);
  (*(void (**)(const CoreSchedulingSet *))(*(void *)v5 + 48))(v5);
  CFAllocatorRef v6 = CFGetAllocator(v2);
  CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
  uint64_t v8 = CFRunLoopTimerCreateWithHandler(v6, v7 + 1.0e30, 0.0, 0, 0, &__block_literal_global_4707);
  uint64_t v9 = CFRunLoopGetCurrent();
  CFRunLoopAddTimer(v9, v8, @"CoreStreamOpenBlocking");
  while (CoreStreamBase::_streamInterface_GetStatus(this) <= 1)
    CFRunLoopRunInMode(@"CoreStreamOpenBlocking", 1.0e30, 1u);
  CoreStreamBase::_streamInterface_UpdateScheduling(this, (const CoreSchedulingSet *)v12[3]);
  (*(void (**)(uint64_t))(*(void *)v12[3] + 48))(v12[3]);
  CFRunLoopTimerInvalidate(v8);
  CFRunLoopRunInMode(@"CoreStreamOpenBlocking", 1.0e30, 0);
  uint64_t v10 = CFRunLoopGetCurrent();
  CFRunLoopRemoveTimer(v10, v8, @"CoreStreamOpenBlocking");
  if (v8) {
    CFRelease(v8);
  }
  --*((void *)this + 11);
  CFRelease(v2);
  _Block_object_dispose(&v11, 8);
}

void sub_1841E0764(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14CoreStreamBase19blockingWaitForOpenEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  ++*(void *)(v2 + 88);
  uint64_t result = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)v2);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t ___ZN14CoreStreamBase19blockingWaitForOpenEv_block_invoke_3(uint64_t result)
{
  return result;
}

uint64_t CoreStreamBase::_streamInterface_CanRead(CoreStreamBase *this)
{
  if ((unint64_t)(CoreStreamBase::_streamInterface_GetStatus(this) - 4) < 0xFFFFFFFFFFFFFFFELL) {
    return 0;
  }
  ++*((void *)this + 10);
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 3) + 88))(*((void *)this + 3));
  --*((void *)this + 10);
  return result;
}

uint64_t CoreStreamBase::_streamInterface_Write(CoreStreamBase *this, const unsigned __int8 *a2, uint64_t a3)
{
  if (CoreStreamBase::_streamInterface_GetStatus(this) == 1) {
    CoreStreamBase::blockingWaitForOpen(this);
  }
  uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (Status != 4 && Status != 2) {
    return -1;
  }
  ++*((void *)this + 10);
  *((void *)this + 12) = 4;
  uint64_t v7 = *((void *)this + 5);
  if (v7) {
    *((void *)this + 5) = v7 & 0xFFFFFFFFFFFFFFFBLL;
  }
  long long v13 = 0uLL;
  uint64_t v8 = (*(uint64_t (**)(void, const unsigned __int8 *, uint64_t, long long *))(**((void **)this + 3) + 96))(*((void *)this + 3), a2, a3, &v13);
  uint64_t v9 = v8;
  if (DWORD2(v13))
  {
    *((void *)this + 12) = 7;
    *(_OWORD *)((char *)this + 56) = v13;
    *((void *)this + 5) |= 8uLL;
    uint64_t v10 = this;
    uint64_t v11 = 8;
  }
  else
  {
    if (v8)
    {
      if (*((void *)this + 12) == 4) {
        *((void *)this + 12) = 2;
      }
      goto LABEL_10;
    }
    *((void *)this + 12) = 5;
    *((void *)this + 5) |= 0x10uLL;
    uint64_t v10 = this;
    uint64_t v11 = 16;
  }
  CoreStreamBase::_streamSetEventAndScheduleDelivery(v10, v11, 0);
LABEL_10:
  --*((void *)this + 10);
  return v9;
}

uint64_t CoreStreamBase::_streamInterface_CanWrite(CoreStreamBase *this)
{
  uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (Status != 4 && Status != 2) {
    return 0;
  }
  ++*((void *)this + 10);
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 3) + 104))(*((void *)this + 3));
  --*((void *)this + 10);
  return result;
}

_CFURLRequest *createCFRequest(const InternalInit *a1)
{
  uint64_t v2 = (_CFURLRequest *)[a1->var1 mutableCopy];
  if (v2)
  {
    uint64_t v3 = objc_msgSend((id)objc_msgSend(a1->var1, "URL"), "host");
    if (v3)
    {
      uint64_t v4 = v3;
      id v5 = +[NSURLRequest allowsSpecificHTTPSCertificateForHost:v3];
      if (v5) {
        setSSLProp(v2, @"_kCFStreamSSLTrustedLeafCertificates", v5);
      }
      if (+[NSURLRequest allowsAnyHTTPSCertificateForHost:v4])
      {
        setSSLProp(v2, (const __CFString *)&unk_1EC0A1778, (const void *)*MEMORY[0x1E4F1CFC8]);
      }
    }
    int v6 = [a1->var1 HTTPShouldHandleCookies];
    uint64_t v7 = [(_CFURLRequest *)v2 _inner];
    __int16 v8 = *(_WORD *)(v7 + 64);
    __int16 v9 = v8 | 0x21;
    __int16 v10 = v8 & 0xFFDE | 0x20;
    if (v6) {
      __int16 v10 = v9;
    }
    *(_WORD *)(v7 + 64) = v10;
  }
  return v2;
}

void setSSLProp(_CFURLRequest *a1, const __CFString *a2, const void *a3)
{
  CFDictionaryRef v6 = *(const __CFDictionary **)([(_CFURLRequest *)a1 _inner] + 72);
  if (v6) {
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(0, 0, v6);
  }
  else {
    MutableCFStringRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  CFDictionaryRef v8 = MutableCopy;
  CFDictionarySetValue(MutableCopy, a2, a3);
  CFURLRequestSetSSLProperties(a1, v8);

  CFRelease(v8);
}

CFStringRef URLResponse::copyDebugSummary(URLResponse *this)
{
  if (__CFNCanLogSensitiveContent::onceToken != -1) {
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_38);
  }
  if (__CFNCanLogSensitiveContent::ok) {
    uint64_t v2 = [(__CFURL *)this->fURL absoluteString];
  }
  else {
    uint64_t v2 = [NSString stringWithFormat:@"%@://%@/<redacted>", -[__CFURL scheme](this->fURL, "scheme"), -[__CFURL host](this->fURL, "host")];
  }
  uint64_t v3 = v2;
  fHTTP = this->fHTTP;
  if (!fHTTP) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"response from %@", v3);
  }
  id v5 = (const void *)(*(uint64_t (**)(HTTPResponse *))(*(void *)fHTTP + 32))(fHTTP);
  CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"response from %@, %@", v3, v5);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

CFStringRef URLResponse::copyDebugDesc(URLResponse *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<URLResponse %p { url = %@ }", this, this->fURL);
}

const __CFString *URLResponse::copySuggestedFilename(URLResponse *this)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  fHTTP = this->fHTTP;
  if (fHTTP)
  {
    HeaderFieldCFDictionaryRef Value = HTTPMessage::copyLastHeaderFieldValue((HTTPMessage *)fHTTP, 0x11C272BFu);
    if (HeaderFieldValue)
    {
      CFStringRef v4 = HeaderFieldValue;
      CFStringRef FilenameFromContentDispositionHeader = createFilenameFromContentDispositionHeader(HeaderFieldValue);
      CFRelease(v4);
      if (FilenameFromContentDispositionHeader) {
        goto LABEL_29;
      }
    }
  }
  CFHashCode fURL = this->fURL;
  if (!fURL)
  {
LABEL_28:
    CFStringRef FilenameFromContentDispositionHeader = (const __CFString *)CFRetain(@"Unknown");
    goto LABEL_29;
  }
  fMIMEType = this->fMIMEType;
  CFURLRef SemiColonEscapedURLIfParamterIsPresent = cfnCreateSemiColonEscapedURLIfParamterIsPresent(this->fURL);
  if (SemiColonEscapedURLIfParamterIsPresent)
  {
    CFURLRef v9 = SemiColonEscapedURLIfParamterIsPresent;
    CFStringRef PathComponent = CFURLCopyLastPathComponent(SemiColonEscapedURLIfParamterIsPresent);
    CFRelease(v9);
    if (!PathComponent) {
      goto LABEL_12;
    }
  }
  else
  {
    CFStringRef PathComponent = CFURLCopyLastPathComponent(fURL);
    if (!PathComponent) {
      goto LABEL_12;
    }
  }
  if (CFStringGetLength(PathComponent) && !CFEqual(PathComponent, @"/")) {
    goto LABEL_17;
  }
  CFRelease(PathComponent);
LABEL_12:
  CFStringRef v11 = CFURLCopyHostName(fURL);
  if (!v11) {
    goto LABEL_28;
  }
  CFStringRef PathComponent = v11;
  if (CFStringCompare(v11, @"localhost", 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(PathComponent);
    goto LABEL_28;
  }
  if (fMIMEType)
  {
    CFStringRef v12 = copyPreferredExtensionForMIMEType(fMIMEType);
    if (v12)
    {
      CFStringRef v13 = v12;
      CFAllocatorRef v14 = CFGetAllocator(fURL);
      CFStringRef v15 = CFStringCreateWithFormat(v14, 0, @"%@.%@", PathComponent, v13);
      CFRelease(PathComponent);
      CFRelease(v13);
      CFStringRef PathComponent = v15;
      if (!v15) {
        goto LABEL_28;
      }
    }
  }
LABEL_17:
  if (CFStringGetLength(PathComponent)
    && (CFStringRef SanitizedFileNameFromString = createSanitizedFileNameFromString(PathComponent)) != 0)
  {
    CFStringRef FilenameFromContentDispositionHeader = SanitizedFileNameFromString;
    uint64_t v17 = this->fMIMEType;
    if (v17)
    {
      if (CFStringCompare(v17, (CFStringRef)&unk_1EC0A4B50, 1uLL))
      {
        CFStringRef v18 = copyPreferredExtensionForMIMEType(this->fMIMEType);
        if (v18)
        {
          CFStringRef v19 = v18;
          CFStringRef v20 = copyExtensionFromName(FilenameFromContentDispositionHeader);
          if (!v20)
          {
            CFAllocatorRef v21 = CFGetAllocator(FilenameFromContentDispositionHeader);
            CFStringRef v22 = CFStringCreateWithFormat(v21, 0, @"%@.%@", FilenameFromContentDispositionHeader, v19);
            CFStringRef v20 = FilenameFromContentDispositionHeader;
            CFStringRef FilenameFromContentDispositionHeader = v22;
          }
          CFRelease(v20);
          CFRelease(v19);
        }
      }
    }
  }
  else
  {
    CFStringRef FilenameFromContentDispositionHeader = (const __CFString *)CFRetain(@"Unknown");
  }
  CFRelease(PathComponent);
LABEL_29:
  int64_t MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(FilenameFromContentDispositionHeader);
  if (MaximumSizeOfFileSystemRepresentation != -1)
  {
    CFIndex v24 = MaximumSizeOfFileSystemRepresentation;
    if (MaximumSizeOfFileSystemRepresentation >= 257)
    {
      CFIndex v25 = (char *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0x7116E0C4uLL);
      if (!v25) {
        return FilenameFromContentDispositionHeader;
      }
    }
    else
    {
      CFIndex v25 = buffer;
    }
    if (CFStringGetFileSystemRepresentation(FilenameFromContentDispositionHeader, v25, v24)
      && (CFAllocatorRef v26 = CFGetAllocator(FilenameFromContentDispositionHeader),
          (CFStringRef v27 = CFStringCreateWithFileSystemRepresentation(v26, v25)) != 0))
    {
      CFStringRef v28 = v27;
      if (FilenameFromContentDispositionHeader) {
        CFRelease(FilenameFromContentDispositionHeader);
      }
    }
    else
    {
      CFStringRef v28 = FilenameFromContentDispositionHeader;
    }
    if (v25 != buffer) {
      free(v25);
    }
    return v28;
  }
  return FilenameFromContentDispositionHeader;
}

CFStringRef copyExtensionFromName(const __CFString *a1)
{
  v10.CFIndex length = CFStringGetLength(a1);
  v10.CFIndex location = 0;
  if (!CFStringFindWithOptions(a1, @".", v10, 4uLL, &v9)) {
    return 0;
  }
  CFIndex location = v9.location;
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v4 = Length + ~v9.location;
  if (v4 < 1) {
    return 0;
  }
  CFIndex v5 = location + 1;
  v11.CFIndex location = v5;
  v11.CFIndex length = Length + ~v9.location;
  int v6 = CFStringFindWithOptions(a1, @" ", v11, 0, 0);
  CFStringRef result = 0;
  if (!v6)
  {
    CFAllocatorRef v8 = CFGetAllocator(a1);
    v12.CFIndex location = v5;
    v12.CFIndex length = v4;
    return CFStringCreateWithSubstring(v8, a1, v12);
  }
  return result;
}

void sub_1841E63FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1841E69B8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1841E81D4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1841E9230(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1841E9370(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

id copyDecodedResumeData(NSData *a1)
{
  if (!a1) {
    return 0;
  }
  id v2 = (id)[objc_alloc(MEMORY[0x1E4F28DC0]) initForReadingFromData:a1 error:0];
  [v2 setDecodingFailurePolicy:1];
  if (resumeDataClasses(void)::onceToken != -1) {
    dispatch_once(&resumeDataClasses(void)::onceToken, &__block_literal_global_446);
  }
  uint64_t v3 = objc_msgSend((id)objc_msgSend(v2, "decodeObjectOfClasses:forKey:", resumeDataClasses(void)::resumeDataClasses, @"NSKeyedArchiveRootObjectKey"), "copy");
  [v2 finishDecoding];
  if (v3) {
    return (id)v3;
  }
  CFIndex v4 = (void *)[MEMORY[0x1E4F28F98] propertyListWithData:a1 options:0 format:0 error:0];

  return v4;
}

uint64_t ___ZL17resumeDataClassesv_block_invoke_5250()
{
  uint64_t v0 = (void *)MEMORY[0x1E4F1CA80];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  resumeDataClasses(void)::resumeDataClasses = (uint64_t)(id)objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, objc_opt_class(), 0);
  gotLoadHelper_x20__OBJC_CLASS___SZExtractor(v7);
  if (objc_opt_class())
  {
    uint64_t v9 = [*(id *)(v1 + 2640) knownSZExtractorImplementations];
    [(id)resumeDataClasses(void)::resumeDataClasses unionSet:v9];
  }
  gotLoadHelper_x20__OBJC_CLASS___STRemoteExtractor(v8);
  uint64_t result = objc_opt_class();
  if (result)
  {
    CFRange v11 = (void *)resumeDataClasses(void)::resumeDataClasses;
    uint64_t v12 = objc_opt_class();
    return [v11 addObject:v12];
  }
  return result;
}

uint64_t __Block_byref_object_copy__131(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__132(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v2) {
    CFRelease(v2);
  }
}

void non-virtual thunk to'URLDownload::~URLDownload(URLDownload *this)
{
}

{
  URLDownload::~URLDownload((URLDownload *)((char *)this - 8));
}

void URLDownload::~URLDownload(URLDownload *this)
{
  *(void *)this = &unk_1ECF9B1F8;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9B240;
  URLDownload::_internal_releaseClient(this);
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 25);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 26);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 27);
  if (v6) {
    CFRelease(v6);
  }
  double v7 = (const void *)*((void *)this + 29);
  if (v7) {
    CFRelease(v7);
  }
  double v8 = (const void *)*((void *)this + 30);
  if (v8) {
    CFRelease(v8);
  }

  uint64_t v9 = (const void *)*((void *)this + 32);
  if (v9) {
    CFRelease(v9);
  }
  CFRange v10 = (const void *)*((void *)this + 31);
  if (v10) {
    CFRelease(v10);
  }
  CFRange v11 = (const void *)*((void *)this + 28);
  if (v11) {
    CFRelease(v11);
  }
  (*(void (**)(void))(**((void **)this + 36) + 48))(*((void *)this + 36));
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_1ECF9B550;
}

void sub_1841EA998(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

double URLDownload::_internal_releaseClient(URLDownload *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 21) && atomic_fetch_add((atomic_uint *volatile)this + 44, 0xFFFFFFFF) == 1)
  {
    if (!*((void *)this + 20) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = "T *ClientContextHolder<CFURLDownloadClient>::forget() [T = CFURLDownloadClient]";
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s called before remember", (uint8_t *)&v4, 0xCu);
    }
    if (*((void *)this + 5))
    {
      uint64_t v2 = (void (*)(void))*((void *)this + 7);
      if (v2) {
        v2();
      }
    }
    double result = 0.0;
    *((_OWORD *)this + 9) = 0u;
    *((_OWORD *)this + 1_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
    *((_OWORD *)this + 7) = 0u;
    *((_OWORD *)this + 8) = 0u;
    *((_OWORD *)this + 5) = 0u;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 3) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 2) = 0u;
  }
  return result;
}

CFStringRef URLDownload::copyDebugDesc(URLDownload *this)
{
  uint64_t v2 = (char *)this - 16;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  uint64_t v4 = *((void *)this + 21);
  if (!v4)
  {
    uint64_t v11 = *((void *)this + 3);
    uint64_t v12 = (__CFString *)*((void *)this + 26);
    if (!v12) {
      uint64_t v12 = @"path not determined";
    }
    return CFStringCreateWithFormat(v3, 0, @"<CFURLDownload %p [%p]> {connection = %@, path = %@, client = %p}", v2, v3, v11, v12, v4);
  }
  uint64_t v5 = *(uint64_t (**)(void))(v4 + 32);
  if (!v5)
  {
    uint64_t v11 = *((void *)this + 3);
    uint64_t v12 = (__CFString *)*((void *)this + 26);
    if (!v12) {
      uint64_t v12 = @"path not determined";
    }
LABEL_16:
    uint64_t v4 = *(void *)(v4 + 8);
    return CFStringCreateWithFormat(v3, 0, @"<CFURLDownload %p [%p]> {connection = %@, path = %@, client = %p}", v2, v3, v11, v12, v4);
  }
  uint64_t v6 = v5(*(void *)(v4 + 8));
  if (!v6)
  {
    uint64_t v4 = *((void *)this + 21);
    uint64_t v11 = *((void *)this + 3);
    uint64_t v12 = (__CFString *)*((void *)this + 26);
    if (!v12) {
      uint64_t v12 = @"path not determined";
    }
    if (!v4) {
      return CFStringCreateWithFormat(v3, 0, @"<CFURLDownload %p [%p]> {connection = %@, path = %@, client = %p}", v2, v3, v11, v12, v4);
    }
    goto LABEL_16;
  }
  double v7 = (const void *)v6;
  double v8 = (__CFString *)*((void *)this + 26);
  if (!v8) {
    double v8 = @"path not determined";
  }
  CFStringRef v9 = CFStringCreateWithFormat(v3, 0, @"<CFURLDownload %p [%p]> {connection = %@, path = %@, client = %@}", v2, v3, *((void *)this + 3), v8, v6);
  CFRelease(v7);
  return v9;
}

void ___ZN11URLDownload5ClassEv_block_invoke()
{
}

void sub_1841EAC3C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t URLDownload::_internal_setClient(uint64_t result, void *__src)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (__src)
  {
    uint64_t v3 = result;
    if (*__src && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v6) = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "you shouldn't be using CFURLDownload; use NSURLSession ",
        (uint8_t *)&v6,
        2u);
    }
    uint64_t v4 = v3 + 32;
    if (*(void *)(v3 + 160) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      int v6 = 136315138;
      double v7 = "T *ClientContextHolder<CFURLDownloadClient>::remember(const T *) [T = CFURLDownloadClient]";
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s called before forget", (uint8_t *)&v6, 0xCu);
    }
    memmove((void *)(v3 + 32), __src, 0x80uLL);
    double result = *(void *)(v3 + 40);
    if (result)
    {
      uint64_t v5 = *(uint64_t (**)(void))(v3 + 48);
      if (v5)
      {
        double result = v5();
        *(void *)(v3 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = result;
      }
    }
    *(void *)(v3 + 16_CFNetworkResetHSTSHostsSinceDate(0, 0) = v4;
    *(void *)(v3 + 168) = v4;
    *(_DWORD *)(v3 + 176) = 1;
  }
  return result;
}

__CFDictionary *createDownloadConnectionProperties(const __CFAllocator *a1)
{
  MutableDictionary = cfTypeCreateMutableDictionary(a1, 0x1EC09F7C0, *MEMORY[0x1E4F1CFD0], 0, 0);
  uint64_t v3 = cfTypeCreateMutableDictionary(a1, @"kCFURLConnectionSocketStreamProperties", MutableDictionary, 0, 0);
  if (MutableDictionary) {
    CFRelease(MutableDictionary);
  }
  return v3;
}

uint64_t DownloadConnectionClient::_shouldUseCredentialStorageCallback(DownloadConnectionClient *this, _CFURLConnection *a2, const void *a3)
{
  return *((unsigned __int8 *)a2 + 320);
}

void DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback(DownloadConnectionClient *this, const _CFURLCredential *cf, _CFURLAuthChallenge *a3, const void *a4)
{
  if (!*((unsigned char *)a3 + 286))
  {
    *((unsigned char *)a3 + 286) = 1;
    uint64_t v14 = *((void *)a3 + 21);
    if (v14)
    {
      CFStringRef v15 = *(void (**)(char *, void))(v14 + 40);
      if (v15) {
        v15((char *)a3 - 16, *(void *)(v14 + 8));
      }
    }
  }
  uint64_t v6 = *((void *)a3 + 21);
  if (v6 && (double v7 = *(void (**)(char *, const _CFURLCredential *, uint64_t))(v6 + 56)) != 0)
  {
    if (cf)
    {
      CFTypeRef v8 = CFRetain(cf);
      uint64_t v6 = *((void *)a3 + 21);
      double v7 = *(void (**)(char *, const _CFURLCredential *, uint64_t))(v6 + 56);
    }
    else
    {
      CFTypeRef v8 = 0;
    }
    *((void *)a3 + 24) = v8;
    uint64_t v16 = *(void *)(v6 + 8);
    v7((char *)a3 - 16, cf, v16);
  }
  else
  {
    if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
      dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
    }
    CFStringRef v9 = (char *)cf + 16;
    if (!cf) {
      CFStringRef v9 = 0;
    }
    uint64_t v10 = *((void *)v9 + 4);
    if (v10
      && (uint64_t v11 = URLCredential_PasswordBased::safelyCast(*((void *)v9 + 4), cf)) != 0
      && (*(unsigned int (**)(uint64_t))(*(void *)v11 + 136))(v11))
    {
      uint64_t v12 = *((void *)a3 + 2);
      uint64_t v13 = v10;
    }
    else
    {
      uint64_t v12 = *((void *)a3 + 2);
      uint64_t v13 = 0;
    }
    CFURLConnectionUseCredential(v12, v13, (uint64_t)cf);
  }
}

uint64_t DownloadConnectionClient::_willCacheResponseCallback(DownloadConnectionClient *this, _CFURLConnection *a2, const _CFCachedURLResponse *a3, const void *a4)
{
  return 0;
}

void DownloadConnectionClient::_didFailCallback(DownloadConnectionClient *this, _CFURLConnection *a2, __CFError *a3, const void *a4)
{
  if (!*((unsigned char *)a3 + 286))
  {
    *((unsigned char *)a3 + 286) = 1;
    uint64_t v6 = *((void *)a3 + 21);
    if (v6)
    {
      double v7 = *(void (**)(char *, void))(v6 + 40);
      if (v7) {
        v7((char *)a3 - 16, *(void *)(v6 + 8));
      }
    }
  }

  URLDownload::_internal_downloadCancel(a3, (__CFError *)a2);
}

void URLDownload::_internal_downloadCancel(URLDownload *this, __CFError *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 287))
  {
    *((unsigned char *)this + 287) = 1;
    uint64_t v4 = *((void *)this + 2);
    if (v4) {
      CFURLConnectionCancel(v4);
    }
    uint64_t v5 = (AsyncTargetFile *)*((void *)this + 33);
    if (v5)
    {
      AsyncTargetFile::close(v5, (uint64_t *)this + 34);
      (*(void (**)(void))(**((void **)this + 33) + 48))(*((void *)this + 33));
      *((void *)this + 33) = 0;
      if (*((unsigned char *)this + 281))
      {
        FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v6, *((CFURLRef *)this + 26), 0, 0, 1u);
        if (v6)
        {
          if (unlink(v7)) {
            __error();
          }
        }
      }
    }
    URLDownload::_internal_downloadFailed(this, a2);
  }
}

uint64_t AsyncTargetFile::close(AsyncTargetFile *this, uint64_t *a2)
{
  uint64_t v6 = 0;
  double v7 = &v6;
  uint64_t v8 = 0x2020000000;
  int v9 = -1;
  *a2 = 0;
  uint64_t v2 = *((void *)this + 3);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN15AsyncTargetFile5closeEPx_block_invoke;
  block[3] = &unk_1E5257A50;
  block[4] = &v6;
  void block[5] = this;
  void block[6] = a2;
  dispatch_sync(v2, block);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void URLDownload::_internal_downloadFailed(URLDownload *this, __CFError *a2)
{
  int v4 = URLDownload::_internal_downloadEnded(this);
  uint64_t v5 = *((void *)this + 21);
  if (v5)
  {
    if (a2)
    {
      uint64_t v6 = *(void (**)(char *, __CFError *, void))(v5 + 120);
      if (v6) {
        v6((char *)this - 16, a2, *(void *)(v5 + 8));
      }
    }
  }
  if (v4)
  {
    URLDownload::_internal_releaseClient(this);
    CFRelease((char *)this - 16);
  }
}

uint64_t URLDownload::_internal_downloadEnded(URLDownload *this)
{
  if (!*((unsigned char *)this + 282)) {
    return 0;
  }
  *((unsigned char *)this + 282) = 0;
  uint64_t v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 2) = 0;
  uint64_t v3 = (const void *)*((void *)this + 24);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)this + 24) = 0;
  return 1;
}

int *___ZN15AsyncTargetFile5closeEPx_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  double result = (int *)*(unsigned int *)(v2 + 20);
  if (result == -1)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 22;
  }
  else
  {
    fstat((int)result, &v5);
    **(void **)(a1 + 48) = v5.st_size;
    double result = (int *)close(*(_DWORD *)(v2 + 20));
    if (result)
    {
      double result = __error();
      int v4 = *result;
    }
    else
    {
      int v4 = 0;
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
    *(_DWORD *)(v2 + 2_CFNetworkResetHSTSHostsSinceDate(0, 0) = -1;
  }
  return result;
}

void DownloadConnectionClient::_connectionDidFinishLoadingCallback(DownloadConnectionClient *this, _CFURLConnection *a2, const void *a3)
{
  int v4 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  *((unsigned char *)a2 + 284) = 1;
  if (!*((unsigned char *)a2 + 280))
  {
    CFDataRef v6 = (const __CFData *)*((void *)a2 + 31);
    if (v6)
    {
      *((unsigned char *)a2 + 28_CFNetworkResetHSTSHostsSinceDate(0, 0) = 1;
      double v7 = URLDownload::_internal_downloadProcessData((URLDownload *)a2, v6);
      CFRelease(*((CFTypeRef *)a2 + 31));
      *((void *)a2 + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
      if (v7)
      {
        URLDownload::_internal_downloadCancel((URLDownload *)a2, v7);
        CFRelease(v7);
      }
    }
    else if (!*((void *)a2 + 33))
    {
      URLDownload::_internal_downloadOpenTarget((URLDownload *)a2);
      *((void *)a2 + 33) = v8;
      if (!v8) {
        URLDownload::_internal_downloadFailedWithCFNetworkError((URLDownload *)a2, -3000);
      }
    }
  }
  uint64_t v5 = *((void *)a2 + 33);
  if (v5)
  {
    *((void *)a2 + 33) = 0;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke;
    v9[3] = &__block_descriptor_48_e61_v16__0__CFURLDownloadClient_q_v_____________________________8l;
    v9[4] = a2;
    void v9[5] = v5;
    URLDownload::_internal_withClientScheduling((uint64_t)a2, (uint64_t)v9);
  }

  CFRelease(v4);
}

void sub_1841EB440(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

CFErrorRef URLDownload::_internal_downloadProcessData(URLDownload *this, CFDataRef theData)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFDataGetLength(theData);
  if (!*((unsigned char *)this + 280))
  {
    CFDataRef v6 = (__CFData *)*((void *)this + 31);
    if (v6)
    {
      CFIndex v7 = Length;
      BytePtr = CFDataGetBytePtr(theData);
      CFDataAppendBytes(v6, BytePtr, v7);
      MutableCFStringRef Copy = (const __CFData *)*((void *)this + 31);
    }
    else
    {
      CFAllocatorRef v10 = CFGetAllocator((char *)this - 16);
      MutableCFStringRef Copy = CFDataCreateMutableCopy(v10, 0, theData);
      *((void *)this + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = MutableCopy;
      if (!MutableCopy)
      {
        CFAllocatorRef v41 = CFGetAllocator((char *)this - 16);
        return __cfnCreateCFError(v41, (CFErrorDomain)*MEMORY[0x1E4F1D160], 12, v42, v43, v44, v45, v46, 0);
      }
    }
    if (CFDataGetLength(MutableCopy) > 0x2000)
    {
      CFDataRef v5 = (const __CFData *)*((void *)this + 31);
      *((void *)this + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
      *((unsigned char *)this + 28_CFNetworkResetHSTSHostsSinceDate(0, 0) = 1;
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  if (!theData)
  {
LABEL_8:
    CFDataRef v5 = 0;
    goto LABEL_10;
  }
  CFDataRef v5 = (const __CFData *)CFRetain(theData);
LABEL_10:
  if (!*((void *)this + 33))
  {
    if (*((unsigned char *)this + 285))
    {
      URLDownload::_internal_downloadOpenTarget(this);
      *((void *)this + 33) = v19;
      if (!v19)
      {
        CFAllocatorRef v20 = CFGetAllocator((char *)this - 16);
        return __cfnCreateCFError(v20, @"kCFErrorDomainCFNetwork", -3001, v21, v22, v23, v24, v25, 0);
      }
    }
  }
  if (!v5 || !CFDataGetLength(v5))
  {
    if (!*((unsigned char *)this + 287))
    {
      uint64_t v27 = *((void *)this + 21);
      if (v27)
      {
        CFStringRef v28 = *(void (**)(char *, void, void))(v27 + 80);
        if (v28) {
          v28((char *)this - 16, 0, *(void *)(v27 + 8));
        }
      }
    }
    CFErrorRef v18 = 0;
    if (!v5) {
      return v18;
    }
    goto LABEL_105;
  }
  CFArrayRef v87 = 0;
  CFIndex v88 = 0;
  CFArrayRef v11 = (const __CFArray *)*((void *)this + 32);
  if (!v11)
  {
    CFAllocatorRef v29 = CFGetAllocator((char *)this - 16);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v29, 0, MEMORY[0x1E4F1D510]);
    *((void *)this + 32) = Mutable;
    if (!Mutable)
    {
      CFAllocatorRef v47 = CFGetAllocator((char *)this - 16);
      CFCFStreamError Error = __cfnCreateCFError(v47, (CFErrorDomain)*MEMORY[0x1E4F1D160], 12, v48, v49, v50, v51, v52, 0);
      goto LABEL_40;
    }
    if (!URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray)
    {
      CFGregorianDate values = &unk_1EC0A4DB8;
      uint64_t v90 = 0x1EC0A4AE0;
      CFIndex v91 = (uint64_t (*)(void *))@"application/macbinary";
      CFArrayRef v31 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 3, MEMORY[0x1E4F1D510]);
      uint64_t v32 = 0;
      atomic_compare_exchange_strong(&URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray, (unint64_t *)&v32, (unint64_t)v31);
      if (v32)
      {
        if (v31) {
          CFRelease(v31);
        }
      }
    }
    uint64_t v33 = *((void *)this + 21);
    if (v33) {
      BOOL v85 = *(void *)(v33 + 88) != 0;
    }
    else {
      BOOL v85 = 0;
    }
    CFIndex Count = CFArrayGetCount((CFArrayRef)URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray);
    if (Count < 1)
    {
LABEL_75:
      if (CFArrayGetCount(*((CFArrayRef *)this + 32)))
      {
        CFDataRef v67 = v87;
        CFTypeRef v53 = v88;
LABEL_79:
        if (!*((void *)this + 33))
        {
          URLDownload::_internal_downloadOpenTarget(this);
          *((void *)this + 33) = v68;
          if (!v68)
          {
            CFAllocatorRef v79 = CFGetAllocator((char *)this - 16);
            CFErrorRef v18 = __cfnCreateCFError(v79, @"kCFErrorDomainCFNetwork", -3001, v80, v81, v82, v83, v84, 0);
            if (v18)
            {
LABEL_101:
              if (v53) {
                CFRelease(v53);
              }
              if (v67) {
                CFRelease(v67);
              }
              goto LABEL_105;
            }
          }
        }
        CFRetain((char *)this - 16);
        CFTypeID v69 = (const void *)*((void *)this + 2);
        if (v69)
        {
          CFTypeRef v70 = CFRetain(v69);
          if (v53) {
            goto LABEL_83;
          }
        }
        else
        {
          CFTypeRef v70 = 0;
          if (v53)
          {
LABEL_83:
            CFIndex v71 = CFDataGetLength((CFDataRef)v53);
            if (v67)
            {
LABEL_84:
              CFIndex v72 = CFDataGetLength((CFDataRef)v67);
              goto LABEL_88;
            }
LABEL_87:
            CFIndex v72 = 0;
LABEL_88:
            CFIndex v73 = v72 + v71;
            os_unfair_lock_lock((os_unfair_lock_t)this + 76);
            *((void *)this + 37) += v73;
            os_unfair_lock_unlock((os_unfair_lock_t)this + 76);
            CFStringRef v74 = (void *)*((void *)this + 33);
            v86[0] = MEMORY[0x1E4F143A8];
            v86[1] = 3221225472;
            int v86[2] = ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke;
            v86[3] = &__block_descriptor_48_e11_v20__0Q8i16l;
            v86[4] = this;
            v86[5] = v70;
            if (v53)
            {
              CFIndex v75 = CFDataGetLength((CFDataRef)v53);
              if (v67) {
                goto LABEL_90;
              }
            }
            else
            {
              CFIndex v75 = 0;
              if (v67)
              {
LABEL_90:
                CFIndex v76 = CFDataGetLength((CFDataRef)v67);
                if (!v53) {
                  goto LABEL_95;
                }
                goto LABEL_94;
              }
            }
            CFIndex v76 = 0;
            if (!v53)
            {
LABEL_95:
              if (v67) {
                CFRetain(v67);
              }
              (*(void (**)(void *))(*v74 + 40))(v74);
              BOOL v77 = v74[3];
              CFGregorianDate values = (void *)MEMORY[0x1E4F143A8];
              uint64_t v90 = 3221225472;
              CFIndex v91 = ___ZN15AsyncTargetFile5writeEPK8__CFDataS2_U13block_pointerFvmiE_block_invoke;
              CFRange v92 = &unk_1E52544D0;
              CFTypeRef v95 = v53;
              CFIndex v96 = v75;
              uint64_t v97 = v67;
              CFIndex v98 = v76;
              CFRange v93 = v86;
              CFRange v94 = v74;
              dispatch_async(v77, &values);
              if (*((void *)this + 37) > 0x200000uLL)
              {
                int v78 = *((_DWORD *)this + 77);
                *((_DWORD *)this + 77) = v78 + 1;
                if (!v78) {
                  CFURLConnectionHalt((uint64_t)v70);
                }
              }
              CFErrorRef v18 = 0;
              goto LABEL_101;
            }
LABEL_94:
            CFRetain(v53);
            goto LABEL_95;
          }
        }
        CFIndex v71 = 0;
        if (v67) {
          goto LABEL_84;
        }
        goto LABEL_87;
      }
      CFTypeRef v53 = CFRetain(v5);
LABEL_78:
      CFDataRef v67 = 0;
      goto LABEL_79;
    }
    CFIndex v55 = 0;
    CFDataRef v56 = v5;
    while (1)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray, v55);
      CFGetAllocator((char *)this - 16);
      if (CFStringCompare(ValueAtIndex, (CFStringRef)&unk_1EC0A4DB8, 1uLL))
      {
        if (CFStringCompare(ValueAtIndex, @"application/mac-binhex40", 1uLL))
        {
          if (CFStringCompare(ValueAtIndex, @"application/macbinary", 1uLL)) {
            goto LABEL_70;
          }
          if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
            dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2928);
          }
          uint64_t Instance = _CFRuntimeCreateInstance();
          *(_OWORD *)(Instance + CFRelease((char *)this - 16) = 0u;
          uint64_t v59 = (_OWORD *)(Instance + 16);
          *(_OWORD *)(Instance + 112) = 0u;
          *(_OWORD *)(Instance + 128) = 0u;
          *(_OWORD *)(Instance + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
          *(_OWORD *)(Instance + 96) = 0u;
          *(_OWORD *)(Instance + 48) = 0u;
          *(_OWORD *)(Instance + 64) = 0u;
          *(_OWORD *)(Instance + 32) = 0u;
          CFDataRef v60 = (void *)(Instance + 32);
          *(_DWORD *)(Instance + 44) = 0;
          *(_WORD *)(Instance + 14_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
          *(unsigned char *)(Instance + 48) = 0;
          *(void *)(Instance + 112) = 0;
          *(void *)(Instance + 12_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
          *(_DWORD *)(Instance + 128) = 0;
          *(unsigned char *)(Instance + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 1;
          CFDataRef v61 = (uint64_t (**)(void))&unk_1ECFA53E0;
          *(void *)(Instance + CFRelease((char *)this - 16) = &unk_1ECFA53E0;
          *(void *)(Instance + 24) = "GZip";
          CFTypeID v62 = &unk_1ECFA5430;
        }
        else
        {
          if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
            dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2928);
          }
          uint64_t v64 = _CFRuntimeCreateInstance();
          *(_OWORD *)(v64 + CFRelease((char *)this - 16) = 0u;
          uint64_t v59 = (_OWORD *)(v64 + 16);
          *(_OWORD *)(v64 + 48) = 0u;
          *(_OWORD *)(v64 + 64) = 0u;
          *(_OWORD *)(v64 + 8_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
          *(_OWORD *)(v64 + 96) = 0u;
          *(_OWORD *)(v64 + 16_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0u;
          *(_OWORD *)(v64 + 176) = 0u;
          *(_OWORD *)(v64 + 128) = 0u;
          *(_OWORD *)(v64 + 144) = 0u;
          *(_OWORD *)(v64 + 112) = 0u;
          *(_OWORD *)(v64 + 32) = 0u;
          CFDataRef v60 = (void *)(v64 + 32);
          *(_DWORD *)(v64 + 48) = 0;
          *(unsigned char *)(v64 + 104) = 0;
          *(void *)(v64 + 6_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
          *(void *)(v64 + 68) = 0;
          *(void *)(v64 + 75) = 0;
          *(void *)(v64 + 18_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0;
          *(unsigned char *)(v64 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 1;
          CFDataRef v61 = (uint64_t (**)(void))&unk_1ECFA4F80;
          *(void *)(v64 + CFRelease((char *)this - 16) = &unk_1ECFA4F80;
          *(void *)(v64 + 24) = "GZip";
          CFTypeID v62 = &unk_1ECFA4FD0;
        }
      }
      else
      {
        if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
          dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2928);
        }
        uint64_t v63 = (_OWORD *)_CFRuntimeCreateInstance();
        uint64_t v59 = v63;
        if (v63)
        {
          v63[1] = 0uLL;
          uint64_t v59 = v63 + 1;
          v63[9] = 0uLL;
          v63[10] = 0uLL;
          v63[7] = 0uLL;
          v63[8] = 0uLL;
          v63[5] = 0uLL;
          v63[6] = 0uLL;
          v63[3] = 0uLL;
          v63[4] = 0uLL;
          v63[2] = 0uLL;
        }
        *(void *)uint64_t v59 = &unk_1ECFA3168;
        *((void *)v59 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = "GZip";
        CFDataRef v60 = v59 + 1;
        *((void *)v59 + 2) = &unk_1ECFA2928;
        *(_OWORD *)((char *)v59 + 4_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0uLL;
        *(_OWORD *)((char *)v59 + 56) = 0uLL;
        *(_OWORD *)((char *)v59 + 72) = 0uLL;
        *(_OWORD *)((char *)v59 + --*(void *)(*(void *)(result + 32) + 88) = 0uLL;
        *(_OWORD *)((char *)v59 + 104) = 0uLL;
        *(_OWORD *)((char *)v59 + 12_CFNetworkResetHSTSHostsSinceDate(0, 0) = 0uLL;
        *(_OWORD *)((char *)v59 + 24) = 0uLL;
        *((unsigned char *)v59 + 152) = inflateInit2_((z_streamp)((char *)v59 + 24), -15, "1.2.12", 112) == 0;
        *((void *)v59 + 17) = 0;
        *(_WORD *)((char *)v59 + 153) = 0;
        CFDataRef v61 = (uint64_t (**)(void))&unk_1ECFA4990;
        *(void *)uint64_t v59 = &unk_1ECFA4990;
        CFTypeID v62 = &unk_1ECFA49E0;
      }
      *CFDataRef v60 = v62;
      uint64_t v65 = ((uint64_t (**)(_OWORD *))v61)[7](v59);
      if (!(*(unsigned int (**)(uint64_t))(*(void *)v65 + 16))(v65)) {
        goto LABEL_69;
      }
      if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
        dispatch_once(&DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder, &__block_literal_global_2928);
      }
      uint64_t v66 = (*(uint64_t (**)(_OWORD *))(*(void *)v59 + 56))(v59);
      if (!(*(unsigned int (**)(uint64_t, const __CFData *))(*(void *)v66 + 32))(v66, v56)
        || !CFURLDownloadDataDecoderDecodeData((uint64_t)(v59 - 1), (uint64_t)v56, (uint64_t)&v88, (uint64_t)&v87))
      {
LABEL_69:
        CFRelease(v59 - 1);
LABEL_70:
        ++v55;
        goto LABEL_71;
      }
      if (v85
        && !(*(unsigned int (**)(char *, const __CFString *, void))(*((void *)this + 21) + 88))((char *)this - 16, ValueAtIndex, *(void *)(*((void *)this + 21) + 8)))
      {
        CFRelease(v59 - 1);
        goto LABEL_75;
      }
      CFArrayAppendValue(*((CFMutableArrayRef *)this + 32), v59 - 1);
      CFRelease(v59 - 1);
      if (v56 != v5) {
        CFRelease(v56);
      }
      CFIndex v55 = 0;
      CFDataRef v56 = (const __CFData *)v88;
LABEL_71:
      if (v55 >= Count || !v56) {
        goto LABEL_75;
      }
    }
  }
  CFIndex v12 = CFArrayGetCount(v11);
  if (v12 < 1) {
    goto LABEL_75;
  }
  CFIndex v13 = v12;
  CFTypeRef v14 = CFRetain(v5);
  CFIndex v15 = 0;
  while (1)
  {
    uint64_t v16 = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), v15);
    int v17 = CFURLDownloadDataDecoderDecodeData((uint64_t)v16, (uint64_t)v14, (uint64_t)&v88, (uint64_t)&v87);
    if (v14) {
      CFRelease(v14);
    }
    if (!v17) {
      break;
    }
    CFTypeRef v14 = v88;
    if (v13 == ++v15) {
      goto LABEL_75;
    }
  }
  CFAllocatorRef v34 = CFGetAllocator((char *)this - 16);
  CFCFStreamError Error = __cfnCreateCFError(v34, @"kCFErrorDomainCFNetwork", -3006, v35, v36, v37, v38, v39, 0);
LABEL_40:
  CFErrorRef v18 = CFError;
  if (!CFError)
  {
    CFTypeRef v53 = 0;
    goto LABEL_78;
  }
LABEL_105:
  CFRelease(v5);
  return v18;
}

void sub_1841EBED0(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ECF9FBD0;
  _Unwind_Resume(a1);
}

void URLDownload::_internal_downloadOpenTarget(URLDownload *this)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 25)) {
    operator new();
  }
  uint64_t v2 = *((void *)this + 21);
  if (v2)
  {
    if (*(void *)(v2 + 96))
    {
      uint64_t v3 = (void *)*((void *)this + 23);
      if (v3)
      {
        CFStringRef v4 = URLResponse::copySuggestedFilename((URLResponse *)[v3 _inner]);
        if (v4)
        {
          CFStringRef v5 = v4;
          CFTypeRef v6 = URLDownload::_internal_copySuggestedFilenameFromOriginalFilename(this, v4);
          (*(void (**)(char *, CFTypeRef, void))(*((void *)this + 21) + 96))((char *)this - 16, v6, *(void *)(*((void *)this + 21) + 8));
          CFRelease(v5);
          CFRelease(v6);
          if (*((void *)this + 25)) {
            operator new();
          }
        }
      }
    }
  }
  if (*((void *)this + 27))
  {
    uint64_t v7 = [*((id *)this + 3) _inner];
    CFURLRef v8 = *(const __CFURL **)(v7 + 8);
    if (v8)
    {
      CFURLRef SemiColonEscapedURLIfParamterIsPresent = cfnCreateSemiColonEscapedURLIfParamterIsPresent(*(const __CFURL **)(v7 + 8));
      if (SemiColonEscapedURLIfParamterIsPresent)
      {
        CFURLRef v10 = SemiColonEscapedURLIfParamterIsPresent;
        CFStringRef PathComponent = CFURLCopyLastPathComponent(SemiColonEscapedURLIfParamterIsPresent);
        CFRelease(v10);
        if (!PathComponent) {
          goto LABEL_21;
        }
      }
      else
      {
        CFStringRef PathComponent = CFURLCopyLastPathComponent(v8);
        if (!PathComponent) {
          goto LABEL_21;
        }
      }
      if (CFStringGetLength(PathComponent)
        || (CFRelease(PathComponent), (CFStringRef PathComponent = CFURLCopyHostName(v8)) != 0))
      {
        CFStringRef v12 = (const __CFString *)URLDownload::_internal_copySuggestedFilenameFromOriginalFilename(this, PathComponent);
        CFAllocatorRef v13 = CFGetAllocator((char *)this - 16);
        if (CFURLCreateCopyAppendingPathComponent(v13, *((CFURLRef *)this + 27), v12, 0)) {
          operator new();
        }
        if (v12) {
          CFRelease(v12);
        }
        CFRelease(PathComponent);
      }
    }
  }
LABEL_21:
  operator new();
}

void sub_1841EC4A0(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x1000C4048165BC6);
  _Unwind_Resume(a1);
}

void URLDownload::_internal_downloadFailedWithCFNetworkError(URLDownload *this, CFIndex a2)
{
  CFAllocatorRef v4 = CFGetAllocator((char *)this - 16);
  CFCFStreamError Error = __cfnCreateCFError(v4, @"kCFErrorDomainCFNetwork", a2, v5, v6, v7, v8, v9, 0);
  URLDownload::_internal_downloadCancel(this, CFError);
  if (CFError)
  {
    CFRelease(CFError);
  }
}

uint64_t ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = AsyncTargetFile::close(*(AsyncTargetFile **)(a1 + 40), (uint64_t *)(v2 + 272));
  (*(void (**)(void))(**(void **)(a1 + 40) + 48))(*(void *)(a1 + 40));
  if (v3)
  {
    CFAllocatorRef v4 = v7;
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    uint64_t v5 = ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_3;
  }
  else
  {
    CFAllocatorRef v4 = v8;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    uint64_t v5 = ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_2;
  }
  v4[2] = v5;
  v4[3] = &__block_descriptor_40_e61_v16__0__CFURLDownloadClient_q_v_____________________________8l;
  void v4[4] = v2;
  return URLDownload::_internal_withClientScheduling(v2, (uint64_t)v4);
}

uint64_t URLDownload::_internal_withClientScheduling(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v4 = *(_DWORD **)(a1 + 288);
  if (v4[10])
  {
    uint64_t v5 = (_OWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)v4 + 88))(v4);
  }
  else
  {
    uint64_t v6 = +[NSURLConnection resourceLoaderRunLoop];
    uint64_t v5 = CoreSchedulingSet::create((CoreSchedulingSet *)v6, (const __CFString *)*MEMORY[0x1E4F1D418], v7);
  }
  uint64_t v8 = v5;
  CFRetain((CFTypeRef)(a1 - 16));
  if ((atomic_fetch_add((atomic_uint *volatile)(a1 + 176), 1u) & 0x80000000) != 0) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = *(void *)(a1 + 168);
  }
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  void v11[2] = ___ZN11URLDownload30_internal_withClientSchedulingEU13block_pointerFvP19CFURLDownloadClientE_block_invoke;
  v11[3] = &unk_1E5257CF8;
  void v11[4] = a2;
  void v11[5] = a1;
  void v11[6] = v9;
  (*(void (**)(_OWORD *, void *))(*(void *)v8 + 96))(v8, v11);
  return (*(uint64_t (**)(_OWORD *))(*(void *)v8 + 48))(v8);
}

void ___ZN11URLDownload30_internal_withClientSchedulingEU13block_pointerFvP19CFURLDownloadClientE_block_invoke(void *a1)
{
  uint64_t v1 = (URLDownload *)a1[5];
  (*(void (**)(void, void))(a1[4] + 16))(a1[4], a1[6]);
  URLDownload::_internal_releaseClient(v1);

  CFRelease((char *)v1 - 16);
}

void ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_2(uint64_t a1)
{
}

void ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_3(uint64_t a1)
{
}

void URLDownload::_internal_downloadFinished(URLDownload *this)
{
  int v2 = URLDownload::_internal_downloadEnded(this);
  uint64_t v3 = *((void *)this + 21);
  if (v3)
  {
    CFAllocatorRef v4 = *(void (**)(char *, void))(v3 + 112);
    if (v4) {
      v4((char *)this - 16, *(void *)(v3 + 8));
    }
  }
  if (v2)
  {
    URLDownload::_internal_releaseClient(this);
    CFRelease((char *)this - 16);
  }
}