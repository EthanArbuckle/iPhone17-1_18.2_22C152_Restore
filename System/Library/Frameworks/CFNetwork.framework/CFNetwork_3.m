void ReadBuffer::~ReadBuffer(ReadBuffer *this)
{
  uint64_t vars8;

  ReadBuffer::~ReadBuffer(this);

  JUMPOUT(0x18531B6D0);
}

{
  id var2;

  this->var0 = (void **)&unk_1ECF9A8E0;
  var2 = this->var2;
  if (var2) {
    CFRelease(var2);
  }
  this->var0 = (void **)&unk_1ECF9B550;
}

void sub_18428B97C(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

NSObject *ReadBuffer::countOfAvailableBytes(ReadBuffer *this)
{
  result = this->var2;
  if (result) {
    result = dispatch_data_get_size(result);
  }
  if (result != this->var3) {
    __assert_rtn("countOfAvailableBytes", "HTTPServerNWStream.mm", 41, "(_dataBuffer == NULL? 0 : dispatch_data_get_size(_dataBuffer)) == _dataBufferSize");
  }
  return result;
}

BOOL ___ZN10ReadBuffer11copyOutDataEPhl_block_invoke(void *a1, int a2, int a3, void *__src, size_t a5)
{
  uint64_t v6 = *(void *)(*(void *)(a1[4] + 8) + 24);
  if (a1[5] - v6 >= a5) {
    size_t v7 = a5;
  }
  else {
    size_t v7 = a1[5] - v6;
  }
  memcpy((void *)(a1[6] + v6), __src, v7);
  *(void *)(*(void *)(a1[4] + 8) + 24) += v7;
  return *(void *)(*(void *)(a1[4] + 8) + 24) < a1[5];
}

uint64_t PerSide_CFWriteStream::fillinCB(CFWriteStreamCallBacks *)::{lambda(__CFWriteStream *,__CFError **,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2) {
    __assert_rtn("_offqueue_canWrite", "HTTPServerNWStream.mm", 569, "error != NULL");
  }
  uint64_t v8 = 0;
  v9 = &v8;
  uint64_t v10 = 0x2020000000;
  char v11 = 0;
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    v4 = *(NSObject **)(v3 + 40);
  }
  else {
    v4 = 0;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN21PerSide_CFWriteStream18_offqueue_canWriteEPP9__CFError_block_invoke;
  block[3] = &unk_1E5257A50;
  block[4] = &v8;
  block[5] = a3;
  block[6] = a2;
  dispatch_sync(v4, block);
  uint64_t v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void *___ZN21PerSide_CFWriteStream18_offqueue_canWriteEPP9__CFError_block_invoke(uint64_t a1)
{
  result = *(void **)(a1 + 40);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result[5] < 0xFFFFLL;
  if (*(void *)(a1 + 48))
  {
    result = (void *)(*(uint64_t (**)(void *))(*result + 32))(result);
    **(void **)(a1 + 48) = result;
  }
  return result;
}

uint64_t PerSide_CFWriteStream::fillinCB(CFWriteStreamCallBacks *)::{lambda(__CFWriteStream *,unsigned char const*,long,__CFError **,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  if (!a4) {
    __assert_rtn("_offqueue_write", "HTTPServerNWStream.mm", 526, "error != NULL");
  }
  uint64_t v24 = 0;
  v25 = &v24;
  uint64_t v26 = 0x2020000000;
  uint64_t v27 = 0;
  uint64_t v9 = MEMORY[0x1E4F143A8];
  while (1)
  {
    uint64_t v18 = 0;
    v19 = &v18;
    uint64_t v20 = 0x3052000000;
    v21 = __Block_byref_object_copy__14834;
    v22 = __Block_byref_object_dispose__14835;
    uint64_t v23 = 0;
    uint64_t v10 = *(void *)(a5 + 8);
    if (v10) {
      char v11 = *(NSObject **)(v10 + 40);
    }
    else {
      char v11 = 0;
    }
    block[0] = v9;
    block[1] = 3221225472;
    block[2] = ___ZN21PerSide_CFWriteStream15_offqueue_writeEPKhlPP9__CFError_block_invoke;
    block[3] = &unk_1E5256770;
    block[6] = a5;
    void block[7] = a4;
    block[4] = &v24;
    block[5] = &v18;
    block[8] = a3;
    block[9] = a2;
    dispatch_sync(v11, block);
    v12 = v19[5];
    if (v12)
    {
      dispatch_semaphore_wait(v12, 0xFFFFFFFFFFFFFFFFLL);
      v13 = v19;
      v14 = (const void *)v19[5];
      if (v14)
      {
        CFRelease(v14);
        v13 = v19;
      }
      v13[5] = 0;
    }
    _Block_object_dispose(&v18, 8);
    uint64_t v15 = v25[3];
    if (v15) {
      break;
    }
    if (*a4)
    {
      uint64_t v15 = 0;
      break;
    }
  }
  _Block_object_dispose(&v24, 8);
  return v15;
}

void sub_18428C4DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void __Block_byref_object_copy__14834(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__14835(uint64_t a1)
{
}

void ___ZN21PerSide_CFWriteStream15_offqueue_writeEPKhlPP9__CFError_block_invoke(uint64_t a1)
{
  v2 = *(void **)(a1 + 48);
  uint64_t v3 = v2[5];
  if (v3 == 0xFFFF)
  {
    **(void **)(a1 + 56) = (*(uint64_t (**)(void))(*v2 + 32))(*(void *)(a1 + 48));
    if (**(void **)(a1 + 56))
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -1;
    }
    else
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = dispatch_semaphore_create(0);
      v2[6] = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    }
    return;
  }
  uint64_t v4 = 0xFFFF - v3;
  if (v4 >= *(void *)(a1 + 64)) {
    uint64_t v4 = *(void *)(a1 + 64);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  v2[5] += *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  uint64_t v5 = dispatch_data_create(*(const void **)(a1 + 72), *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), 0, 0);
  uint64_t v6 = v2[1];
  if (!v6) {
    goto LABEL_15;
  }
  size_t v7 = *(CFErrorRef **)(a1 + 56);
  if (!v7) {
    __assert_rtn("-[NWStreamPair _onqueue_writeData:outError:]", "HTTPServerNWStream.mm", 807, "error != NULL");
  }
  uint64_t v8 = *(const void **)(v6 + 64);
  if (v8)
  {
    uint64_t v9 = (__CFError *)CFRetain(v8);
    *size_t v7 = v9;
    if (v9) {
      goto LABEL_15;
    }
  }
  else
  {
    *size_t v7 = 0;
  }
  if (!*(unsigned char *)(v6 + 81))
  {
    size_t size = dispatch_data_get_size(v5);
    CFRetain((CFTypeRef)v6);
    ++*(void *)(v6 + 112);
    char v11 = *(NSObject **)(v6 + 16);
    v12 = *MEMORY[0x1E4F38C58];
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __44__NWStreamPair__onqueue_writeData_outError___block_invoke;
    v13[3] = &unk_1E52571A0;
    v13[4] = v6;
    v13[5] = size;
    nw_connection_send(v11, v5, v12, 0, v13);
    if (!v5) {
      return;
    }
    goto LABEL_16;
  }
  *size_t v7 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F1D160], 22, 0);
LABEL_15:
  if (!v5) {
    return;
  }
LABEL_16:

  CFRelease(v5);
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,unsigned long,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + 32) |= a2;
}

uint64_t PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFString const*,void const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a4 + 48))(a4);
}

uint64_t PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFString const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a3 + 40))(a3);
}

uint64_t PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#4}::__invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
}

BOOL PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFError **,void *)#1}::__invoke(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (!a2) {
    __assert_rtn("_offqueue_openCompleted", "HTTPServerNWStream.mm", 260, "error != NULL");
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
  *a2 = v4;
  return v4 == 0;
}

BOOL PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFError **,unsigned char *,void *)#1}::__invoke(uint64_t a1, uint64_t *a2, unsigned char *a3, void *a4)
{
  if (!a2 || !a3) {
    __assert_rtn("_offqueue_open", "HTTPServerNWStream.mm", 244, "error != NULL && openComplete != NULL");
  }
  *a2 = (*(uint64_t (**)(void *))(*a4 + 32))(a4);
  *a3 = 1;
  uint64_t v7 = *a2;
  if (!*a2)
  {
    uint64_t v7 = a4[1];
    if (v7)
    {
      uint64_t v9 = *(NSObject **)(v7 + 40);
      if (v9)
      {
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = ___ZN7PerSideIP15__CFWriteStream22CFWriteStreamCallBacksE14_offqueue_openEPP9__CFErrorPh_block_invoke;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = a4;
        dispatch_async(v9, block);
        uint64_t v7 = *a2;
      }
      else
      {
        uint64_t v7 = 0;
      }
    }
  }
  return v7 == 0;
}

void ___ZN7PerSideIP15__CFWriteStream22CFWriteStreamCallBacksE14_offqueue_openEPP9__CFErrorPh_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  if (v1)
  {
    if (!*(unsigned char *)(v1 + 48))
    {
      *(unsigned char *)(v1 + 48) = 1;
      -[NWStreamPair _onqueue_issue_read](v1);
    }
  }
}

CFStringRef PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#3}::__invoke(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<NWStreamPair<%p>::PerSideBase<%s>(%p)", *(void *)(a2 + 8), *(void *)(a2 + 16), a2);
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#2}::__invoke(int a1, PerSideBase *this)
{
}

void PerSideBase::_offqueue_finalize(PerSideBase *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!v1) {
    __assert_rtn("_offqueue_finalize", "HTTPServerNWStream.mm", 203, "_owner != nil");
  }
  *((void *)this + 1) = 0;
  v2 = *(NSObject **)(v1 + 40);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN11PerSideBase18_offqueue_finalizeEv_block_invoke;
  v3[3] = &unk_1E5258250;
  v3[4] = v1;
  v3[5] = this;
  dispatch_async(v2, v3);
}

void ___ZN11PerSideBase18_offqueue_finalizeEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (*(void *)(v2 + 24) == v3)
    {
      if (v3) {
        (*(void (**)(void))(*(void *)v3 + 8))(*(void *)(a1 + 40));
      }
      *(void *)(v2 + 24) = 0;
    }
    if (*(void *)(v2 + 32) == v3)
    {
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
      }
      *(void *)(v2 + 32) = 0;
    }
  }
  uint64_t v4 = *(void **)(a1 + 32);
}

uint64_t PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t PerSide_CFReadStream::fillinCB(CFReadStreamCallBacks *)::{lambda(__CFReadStream *,__CFError **,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2) {
    __assert_rtn("_offqueue_canRead", "HTTPServerNWStream.mm", 450, "error != NULL");
  }
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2020000000;
  char v11 = 0;
  uint64_t v3 = *(void *)(a3 + 8);
  if (v3) {
    uint64_t v4 = *(NSObject **)(v3 + 40);
  }
  else {
    uint64_t v4 = 0;
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN20PerSide_CFReadStream17_offqueue_canReadEPP9__CFError_block_invoke;
  block[3] = &unk_1E5257A50;
  block[4] = &v8;
  void block[5] = a3;
  block[6] = a2;
  dispatch_sync(v4, block);
  uint64_t v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

NSObject *___ZN20PerSide_CFReadStream17_offqueue_canReadEPP9__CFError_block_invoke(NSObject *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *((void *)result[5].isa + 1);
  if (v2)
  {
    isa = result[6].isa;
    if (!isa) {
      __assert_rtn("-[NWStreamPair _onqueue_canRead:]", "HTTPServerNWStream.mm", 850, "error != NULL");
    }
    CFTypeRef v4 = *(CFTypeRef *)(v2 + 56);
    if (v4) {
      CFTypeRef v4 = CFRetain(v4);
    }
    void *isa = v4;
    result = ReadBuffer::countOfAvailableBytes(*(ReadBuffer **)(v2 + 72));
    BOOL v5 = (uint64_t)result > 0 || *isa || *(unsigned char *)(v2 + 80) || *(unsigned char *)(v2 + 82) != 0;
  }
  else
  {
    BOOL v5 = 0;
  }
  *(unsigned char *)(*((void *)v1[4].isa + 1) + 24) = v5;
  return result;
}

uint64_t PerSide_CFReadStream::fillinCB(CFReadStreamCallBacks *)::{lambda(__CFReadStream *,unsigned char *,long,__CFError **,unsigned char *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned char *a5, uint64_t a6)
{
  if (!a4 || !a5) {
    __assert_rtn("_offqueue_read", "HTTPServerNWStream.mm", 417, "error != NULL && atEOF != NULL");
  }
  uint64_t v26 = 0;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x2020000000;
  uint64_t v29 = 0;
  uint64_t v10 = MEMORY[0x1E4F143A8];
  while (1)
  {
    uint64_t v20 = 0;
    v21 = &v20;
    uint64_t v22 = 0x3052000000;
    uint64_t v23 = __Block_byref_object_copy__14834;
    uint64_t v24 = __Block_byref_object_dispose__14835;
    uint64_t v25 = 0;
    uint64_t v11 = *(void *)(a6 + 8);
    if (v11) {
      v12 = *(NSObject **)(v11 + 40);
    }
    else {
      v12 = 0;
    }
    block[0] = v10;
    block[1] = 3221225472;
    block[2] = ___ZN20PerSide_CFReadStream14_offqueue_readEPhlPP9__CFErrorS0__block_invoke;
    block[3] = &unk_1E5256748;
    block[6] = a6;
    void block[7] = a2;
    block[8] = a3;
    block[9] = a4;
    void block[10] = a5;
    block[4] = &v26;
    void block[5] = &v20;
    dispatch_sync(v12, block);
    v13 = v21[5];
    if (v13)
    {
      dispatch_semaphore_wait(v13, 0xFFFFFFFFFFFFFFFFLL);
      v14 = v21;
      uint64_t v15 = (const void *)v21[5];
      if (v15)
      {
        CFRelease(v15);
        v14 = v21;
      }
      v14[5] = 0;
    }
    _Block_object_dispose(&v20, 8);
    uint64_t v16 = v27[3];
    if (v16) {
      break;
    }
    if (*a4)
    {
      uint64_t v16 = -1;
      break;
    }
    if (*a5)
    {
      uint64_t v16 = 0;
      break;
    }
  }
  _Block_object_dispose(&v26, 8);
  return v16;
}

void sub_18428CF44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v14 - 136), 8);
  _Unwind_Resume(a1);
}

void ___ZN20PerSide_CFReadStream14_offqueue_readEPhlPP9__CFErrorS0__block_invoke(void *a1)
{
  uint64_t v2 = a1[6];
  uint64_t v3 = *(void *)(v2 + 8);
  if (!v3)
  {
    uint64_t v19 = 0;
    goto LABEL_24;
  }
  BOOL v5 = (void *)a1[9];
  CFTypeRef v4 = (unsigned char *)a1[10];
  if (v5) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    __assert_rtn("-[NWStreamPair _onqueue_readToBuffer:length:outError:outEOF:]", "HTTPServerNWStream.mm", 831, "error != NULL && atEOF != NULL");
  }
  uint64_t v7 = a1[7];
  uint64_t v8 = a1[8];
  unsigned char *v4 = *(unsigned char *)(v3 + 80);
  CFTypeRef v9 = *(CFTypeRef *)(v3 + 56);
  if (v9) {
    CFTypeRef v9 = CFRetain(v9);
  }
  *BOOL v5 = v9;
  if (v8)
  {
    uint64_t v10 = *(void *)(v3 + 72);
    if (*(void *)(v10 + 24))
    {
      uint64_t v23 = 0x2020000000;
      uint64_t v24 = 0;
      v12 = (NSObject **)(v10 + 16);
      uint64_t v11 = *(NSObject **)(v10 + 16);
      uint64_t v21 = 0;
      uint64_t v22 = &v21;
      applier[0] = MEMORY[0x1E4F143A8];
      applier[1] = 3221225472;
      applier[2] = ___ZN10ReadBuffer11copyOutDataEPhl_block_invoke;
      applier[3] = &unk_1E5256720;
      applier[4] = &v21;
      applier[5] = v8;
      applier[6] = v7;
      dispatch_data_apply(v11, applier);
      v13 = *(NSObject **)(v10 + 16);
      size_t size = dispatch_data_get_size(v13);
      if (size != *(void *)(v10 + 24)) {
        __assert_rtn("copyOutData", "HTTPServerNWStream.mm", 101, "dispatch_data_get_size(_dataBuffer) == _dataBufferSize");
      }
      uint64_t v15 = v22;
      size_t v16 = v22[3];
      if (size == v16)
      {
        if (v13)
        {
          CFRelease(v13);
          uint64_t v15 = v22;
        }
        NSObject *v12 = 0;
        *(void *)(v10 + 24) = 0;
      }
      else
      {
        subrange = dispatch_data_create_subrange(v13, v16, size - v16);
        NSObject *v12 = subrange;
        if (v13)
        {
          CFRelease(v13);
          subrange = *v12;
        }
        uint64_t v15 = v22;
        uint64_t v18 = *(void *)(v10 + 24) - v22[3];
        *(void *)(v10 + 24) = v18;
        if (dispatch_data_get_size(subrange) != v18) {
          __assert_rtn("copyOutData", "HTTPServerNWStream.mm", 112, "dispatch_data_get_size(_dataBuffer) == _dataBufferSize");
        }
      }
      uint64_t v19 = v15[3];
      _Block_object_dispose(&v21, 8);
      if (v19) {
        goto LABEL_23;
      }
    }
    else if (*(void *)(v10 + 16))
    {
      __assert_rtn("copyOutData", "HTTPServerNWStream.mm", 85, "_dataBuffer == NULL");
    }
  }
  uint64_t v19 = 0;
  if (!*(unsigned char *)(v3 + 80))
  {
    *(unsigned char *)(v3 + 80) = 1;
    unsigned char *v4 = 1;
  }
LABEL_23:
  -[NWStreamPair _onqueue_issue_read](v3);
LABEL_24:
  *(void *)(*(void *)(a1[4] + 8) + 24) = v19;
  if (!*(void *)(*(void *)(a1[4] + 8) + 24) && !*(unsigned char *)a1[10] && !*(void *)a1[9])
  {
    *(void *)(*(void *)(a1[5] + 8) + 40) = dispatch_semaphore_create(0);
    *(void *)(v2 + 40) = *(void *)(*(void *)(a1[5] + 8) + 40);
  }
}

void sub_18428D230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,unsigned long,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + 32) |= a2;
}

uint64_t PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFString const*,void const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a4 + 48))(a4);
}

uint64_t PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFString const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a3 + 40))(a3);
}

uint64_t PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#4}::__invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
}

BOOL PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFError **,void *)#1}::__invoke(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (!a2) {
    __assert_rtn("_offqueue_openCompleted", "HTTPServerNWStream.mm", 260, "error != NULL");
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
  *a2 = v4;
  return v4 == 0;
}

BOOL PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFError **,unsigned char *,void *)#1}::__invoke(uint64_t a1, uint64_t *a2, unsigned char *a3, void *a4)
{
  if (!a2 || !a3) {
    __assert_rtn("_offqueue_open", "HTTPServerNWStream.mm", 244, "error != NULL && openComplete != NULL");
  }
  *a2 = (*(uint64_t (**)(void *))(*a4 + 32))(a4);
  *a3 = 1;
  uint64_t v7 = *a2;
  if (!*a2)
  {
    uint64_t v7 = a4[1];
    if (v7)
    {
      CFTypeRef v9 = *(NSObject **)(v7 + 40);
      if (v9)
      {
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = ___ZN7PerSideIP14__CFReadStream21CFReadStreamCallBacksE14_offqueue_openEPP9__CFErrorPh_block_invoke;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = a4;
        dispatch_async(v9, block);
        uint64_t v7 = *a2;
      }
      else
      {
        uint64_t v7 = 0;
      }
    }
  }
  return v7 == 0;
}

void ___ZN7PerSideIP14__CFReadStream21CFReadStreamCallBacksE14_offqueue_openEPP9__CFErrorPh_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  if (v1)
  {
    if (!*(unsigned char *)(v1 + 48))
    {
      *(unsigned char *)(v1 + 48) = 1;
      -[NWStreamPair _onqueue_issue_read](v1);
    }
  }
}

CFStringRef PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#3}::__invoke(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<NWStreamPair<%p>::PerSideBase<%s>(%p)", *(void *)(a2 + 8), *(void *)(a2 + 16), a2);
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#2}::__invoke(int a1, PerSideBase *this)
{
}

uint64_t PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t *PerSide_CFWriteStream::_onqueue_streamNowScheduled(uint64_t *this)
{
  if (this[5] <= 65534) {
    return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t))(*this + 56))(this, 4);
  }
  return this;
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::_offqueue_signalError(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::signalStream(v2, 8, a2);
  }
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::signalStream(const void *a1, uint64_t a2, const void *a3)
{
  CFRetain(a1);
  if (a3) {
    CFRetain(a3);
  }
  BOOL v6 = +[NSURLConnection resourceLoaderRunLoop];
  uint64_t v7 = (const void *)*MEMORY[0x1E4F1D418];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN7PerSideIP15__CFWriteStream22CFWriteStreamCallBacksE12signalStreamES1_mP9__CFError_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = a1;
  void block[5] = a2;
  block[6] = a3;
  CFRunLoopPerformBlock(v6, v7, block);
  CFRunLoopWakeUp(v6);
}

void ___ZN7PerSideIP15__CFWriteStream22CFWriteStreamCallBacksE12signalStreamES1_mP9__CFError_block_invoke(uint64_t a1)
{
  CFWriteStreamSignalEvent();
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    CFRelease(v3);
  }
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::_offqueue_signalEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::signalStream(v2, a2, 0);
  }
}

uint64_t PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::_offqueue_setProperty()
{
  return 0;
}

CFTypeRef PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::_offqueue_copyProperty(uint64_t a1, const __CFString *a2)
{
  return -[NWStreamPair _offqueue_owner_copyProperty:](*(void *)(a1 + 8), a2);
}

CFTypeRef PerSide_CFWriteStream::_onqueue_copyPendingError(PerSide_CFWriteStream *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1 && (uint64_t v2 = *(const void **)(v1 + 64)) != 0) {
    return CFRetain(v2);
  }
  else {
    return 0;
  }
}

void PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::_onqueue_closed(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2) {
    CFRelease(v2);
  }
}

void PerSideBase::_offqueue_close(PerSideBase *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    uint64_t v2 = *(NSObject **)(v1 + 40);
  }
  else {
    uint64_t v2 = 0;
  }
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN11PerSideBase15_offqueue_closeEv_block_invoke;
  v3[3] = &unk_1E5258250;
  v3[4] = v1;
  v3[5] = this;
  dispatch_async(v2, v3);
}

uint64_t ___ZN11PerSideBase15_offqueue_closeEv_block_invoke(uint64_t a1)
{
  uint64_t v3 = a1 + 32;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v3 + 8);
  if (v1)
  {
    if (*(void *)(v1 + 24) == v2) {
      *(unsigned char *)(v1 + 82) = 1;
    }
    if (*(void *)(v1 + 32) == v2) {
      *(unsigned char *)(v1 + 81) = 1;
    }
    -[NWStreamPair _onqueue_checkForCompletion](v1);
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 24);

  return v4(v2);
}

void PerSide_CFWriteStream::~PerSide_CFWriteStream(PerSide_CFWriteStream *this)
{
  PerSide_CFWriteStream::~PerSide_CFWriteStream(this);

  JUMPOUT(0x18531B6D0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1ECFA2070;
  if (*((void *)this + 6)) {
    __assert_rtn("~PerSide_CFWriteStream", "HTTPServerNWStream.mm", 500, "_writeBlockedSemaphore == NULL");
  }

  PerSideBase::~PerSideBase(this);
}

void sub_18428D94C(_Unwind_Exception *a1)
{
  PerSideBase::~PerSideBase(v1);
  _Unwind_Resume(a1);
}

void PerSideBase::~PerSideBase(PerSideBase *this)
{
  *(void *)this = &unk_1ECF9AFE0;
  if (*((void *)this + 1)) {
    __assert_rtn("~PerSideBase", "HTTPServerNWStream.mm", 186, "_owner == nil");
  }
  *(void *)this = &unk_1ECF9B550;
}

void sub_18428D9E8(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::_offqueue_signalError(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    PerSide<__CFReadStream *,CFReadStreamCallBacks>::signalStream(v2, 8, a2);
  }
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::signalStream(const void *a1, uint64_t a2, const void *a3)
{
  CFRetain(a1);
  if (a3) {
    CFRetain(a3);
  }
  BOOL v6 = +[NSURLConnection resourceLoaderRunLoop];
  uint64_t v7 = (const void *)*MEMORY[0x1E4F1D418];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN7PerSideIP14__CFReadStream21CFReadStreamCallBacksE12signalStreamES1_mP9__CFError_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = a1;
  void block[5] = a2;
  block[6] = a3;
  CFRunLoopPerformBlock(v6, v7, block);
  CFRunLoopWakeUp(v6);
}

void ___ZN7PerSideIP14__CFReadStream21CFReadStreamCallBacksE12signalStreamES1_mP9__CFError_block_invoke(uint64_t a1)
{
  CFReadStreamSignalEvent();
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    CFRelease(v3);
  }
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::_offqueue_signalEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    PerSide<__CFReadStream *,CFReadStreamCallBacks>::signalStream(v2, a2, 0);
  }
}

uint64_t PerSide<__CFReadStream *,CFReadStreamCallBacks>::_offqueue_setProperty()
{
  return 0;
}

CFTypeRef PerSide<__CFReadStream *,CFReadStreamCallBacks>::_offqueue_copyProperty(uint64_t a1, const __CFString *a2)
{
  return -[NWStreamPair _offqueue_owner_copyProperty:](*(void *)(a1 + 8), a2);
}

CFTypeRef PerSide_CFReadStream::_onqueue_copyPendingError(PerSide_CFReadStream *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1 && (uint64_t v2 = *(const void **)(v1 + 56)) != 0) {
    return CFRetain(v2);
  }
  else {
    return 0;
  }
}

void PerSide<__CFReadStream *,CFReadStreamCallBacks>::_onqueue_closed(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2) {
    CFRelease(v2);
  }
}

void PerSide_CFReadStream::~PerSide_CFReadStream(PerSide_CFReadStream *this)
{
  PerSide_CFReadStream::~PerSide_CFReadStream(this);

  JUMPOUT(0x18531B6D0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1ECFA1878;
  if (*((void *)this + 5)) {
    __assert_rtn("~PerSide_CFReadStream", "HTTPServerNWStream.mm", 387, "_readBlockedSemaphore == nil");
  }

  PerSideBase::~PerSideBase(this);
}

void sub_18428DC5C(_Unwind_Exception *a1)
{
  PerSideBase::~PerSideBase(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'CFNAccountStore::~CFNAccountStore(CFNAccountStore *this)
{
  uint64_t v2 = (char *)this - 24;
  CFNAccountStore::~CFNAccountStore((CFNAccountStore *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  CFNAccountStore::~CFNAccountStore((CFNAccountStore *)((char *)this - 24));
}

void CFNAccountStore::~CFNAccountStore(CFNAccountStore *this)
{
  *(void *)this = &unk_1ECF9D098;
  *((void *)this + 3) = &unk_1ECF9D0F0;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2) {

  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  CFNAccountStore::~CFNAccountStore(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_18428DD4C(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t CFNAccountStore::initializeACAccountStore(CFNAccountStore *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v2 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = *((void *)this + 5);
    int v7 = 138412290;
    uint64_t v8 = v6;
    _os_log_debug_impl(&dword_184085000, v2, OS_LOG_TYPE_DEBUG, "SSO Initializing ACAccountStore with effectiveBundleID %@", (uint8_t *)&v7, 0xCu);
  }
  gotLoadHelper_x8__OBJC_CLASS___ACAccountStore(v3);
  uint64_t result = [objc_alloc(*(Class *)(v4 + 2512)) initWithEffectiveBundleID:*((void *)this + 5)];
  *((void *)this + 4) = result;
  return result;
}

uint64_t CFNAccountStore::initialize(CFNAccountStore *this, const __CFString *a2, double a3)
{
  gotLoadHelper_x8__OBJC_CLASS___ACAccountStore(a3);
  uint64_t result = objc_opt_class();
  if (result)
  {
    if (a2)
    {
      CFAllocatorRef v6 = CFGetAllocator(a2);
      CFStringRef Copy = CFStringCreateCopy(v6, a2);
    }
    else
    {
      CFStringRef Copy = 0;
    }
    *((void *)this + 5) = Copy;
    (*(void (**)(CFNAccountStore *))(*(void *)this + 64))(this);
    return *((void *)this + 4) != 0;
  }
  return result;
}

CFStringRef CFNAccountStore::copyDebugDesc(CFNAccountStore *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFNAccountStore@%p>", this);
}

uint64_t ___ZN15CFNAccountStore26renewCredentialsForAccountEP11objc_objectPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvlP9__CFErrorE_block_invoke(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  if (a3) {
    CFRetain(a3);
  }
  int v7 = *(NSObject **)(a1 + 32);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN15CFNAccountStore26renewCredentialsForAccountEP11objc_objectPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvlP9__CFErrorE_block_invoke_2;
  block[3] = &unk_1E5256798;
  block[6] = *(void *)(a1 + 48);
  void block[7] = v6;
  block[8] = a2;
  block[4] = a3;
  void block[5] = v7;
  dispatch_async(v7, block);

  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 48))(v6);
}

uint64_t ___ZN15CFNAccountStore26renewCredentialsForAccountEP11objc_objectPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvlP9__CFErrorE_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  double v3 = *(const void **)(a1 + 32);
  if (v3) {
    CFRelease(v3);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 48);

  return v4(v2);
}

uint64_t ___ZN15CFNAccountStore32kerberosAccountsForDomainFromURLEPK7__CFURLPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvPK9__CFArrayP9__CFErrorE_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6 = *(void *)(a1 + 48);
  (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  if (a2) {
    CFRetain(a2);
  }
  if (a3) {
    CFRetain(a3);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN15CFNAccountStore32kerberosAccountsForDomainFromURLEPK7__CFURLPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvPK9__CFArrayP9__CFErrorE_block_invoke_2;
  block[3] = &unk_1E52573C8;
  uint64_t v10 = v6;
  block[4] = a2;
  void block[5] = a3;
  long long v9 = *(_OWORD *)(a1 + 32);
  dispatch_async((dispatch_queue_t)v9, block);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 48))(v6);
}

uint64_t ___ZN15CFNAccountStore32kerberosAccountsForDomainFromURLEPK7__CFURLPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvPK9__CFArrayP9__CFErrorE_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  double v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 32);
  if (v4) {
    CFRelease(v4);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  BOOL v5 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 48);

  return v5(v2);
}

dispatch_data_t BrotliDataDecoder::decodeData(BrotliDataDecoder *this, const __CFAllocator *a2, CFDataRef theData, unsigned __int8 *a4)
{
  *a4 = 0;
  *((void *)this + 4) = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  *((void *)this + 2) = 0x4000;
  *((void *)this + 3) = BytePtr;
  uint64_t alloc = dispatch_data_create_alloc();
  if (!alloc) {
    return 0;
  }
  long long v9 = alloc;
  unint64_t v10 = 0x4000;
  while (1)
  {
    compression_status v11 = compression_stream_process((compression_stream *)((char *)this + 8), 0);
    if (v11) {
      break;
    }
    if (*((void *)this + 2))
    {
      *a4 = 1;
      goto LABEL_11;
    }
    v10 <<= v10 >> 26 == 0;
    *((void *)this + 2) = v10;
    v12 = dispatch_data_create_alloc();
    if (!v12) {
      goto LABEL_9;
    }
    v13 = v12;
    dispatch_data_t concat = dispatch_data_create_concat(v9, v12);
    dispatch_release(v13);
    dispatch_release(v9);
    long long v9 = concat;
  }
  if (v11 == COMPRESSION_STATUS_ERROR)
  {
LABEL_9:
    dispatch_data_t subrange = 0;
    goto LABEL_12;
  }
LABEL_11:
  size_t size = dispatch_data_get_size(v9);
  dispatch_data_t subrange = dispatch_data_create_subrange(v9, 0, size - *((void *)this + 2));
LABEL_12:
  dispatch_release(v9);
  return subrange;
}

void BrotliDataDecoder::~BrotliDataDecoder(BrotliDataDecoder *this)
{
  BrotliDataDecoder::~BrotliDataDecoder(this);

  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9E100;
  if (*((unsigned char *)this + 48)) {
    compression_stream_destroy((compression_stream *)((char *)this + 8));
  }
  *(void *)this = &unk_1ECF9AAB8;
}

void sub_18428E464(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9AAB8;
  _Unwind_Resume(a1);
}

void ___ZL28CFNWaitUntilDeviceIsUnlockedv_block_invoke(uint64_t a1, double a2)
{
  if (MKBDeviceUnlockedSinceBoot_delayInitStub(a2) == 1)
  {
    double v3 = *(NSObject **)(a1 + 32);
    dispatch_semaphore_signal(v3);
  }
  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v4 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v5 = 0;
      _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "Device is locked - waiting", v5, 2u);
    }
  }
}

uint64_t ___ZL28CFNWaitUntilDeviceIsUnlockedv_block_invoke_386(uint64_t result, int a2)
{
  if (*(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + 24) == a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
  }
  return result;
}

uint64_t ___ZL28CFNWaitUntilDeviceIsUnlockedv_block_invoke_387(uint64_t a1)
{
  uint64_t result = notify_cancel(*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

void _systemPowerNotificationsCallback(os_unfair_lock_s *a1, unsigned int a2, int a3, intptr_t notificationID)
{
  if (!a1) {
    return;
  }
  if (a3 == -536870288) {
    goto LABEL_10;
  }
  if (a3 != -536870144)
  {
    if (a3 != -536870272) {
      return;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10[0]) = 0;
      _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "kIOMessageSystemWillSleep", (uint8_t *)v10, 2u);
    }
    os_unfair_lock_lock(a1 + 12);
    BYTE1(a1[17]._os_unfair_lock_opaque) = 1;
    os_unfair_lock_unlock(a1 + 12);
LABEL_10:
    if (IOAllowPowerChange(a1[13]._os_unfair_lock_opaque, notificationID))
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      int v7 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v10[0]) = 0;
        _os_log_error_impl(&dword_184085000, v7, OS_LOG_TYPE_ERROR, "IOAllowPowerChange failed!", (uint8_t *)v10, 2u);
      }
    }
    return;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v8 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10[0]) = 0;
    _os_log_impl(&dword_184085000, v8, OS_LOG_TYPE_DEFAULT, "kIOMessageSystemHasPoweredOn", (uint8_t *)v10, 2u);
  }
  long long v9 = *(NSObject **)&a1[30]._os_unfair_lock_opaque;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = __52__NSURLSession_handleSystemHasPoweredOnNotification__block_invoke;
  v10[3] = &unk_1E5258228;
  v10[4] = a1;
  dispatch_async(v9, v10);
}

void sub_18428FF28(_Unwind_Exception *a1)
{
  double v3 = v2;
  CFRelease(v3);
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(a1);
}

void sub_1842901EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::__shared_weak_count *a30)
{
  if (a30) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a30);
  }
  _Unwind_Resume(a1);
}

void non-virtual thunk to'GlueConnectionEstablishment::connectionWaitingNotification()
{
}

void non-virtual thunk to'GlueConnectionEstablishment::connectionEstablished(GlueConnectionEstablishment *this, CFStreamError a2)
{
}

void non-virtual thunk to'GlueConnectionEstablishment::needClientCert()
{
}

void non-virtual thunk to'GlueConnectionEstablishment::needServerTrust()
{
}

void non-virtual thunk to'GlueConnectionEstablishment::postConnectConfiguration()
{
}

void non-virtual thunk to'GlueConnectionEstablishment::preConnectConfiguration()
{
}

void non-virtual thunk to'ProxyConnectionEstablishment::~ProxyConnectionEstablishment(ProxyConnectionEstablishment *this)
{
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment((ProxyConnectionEstablishment *)((char *)this - 8));

  JUMPOUT(0x18531B6D0);
}

{
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment((ProxyConnectionEstablishment *)((char *)this - 8));
}

void ProxyConnectionEstablishment::ssPostProxyConnectionConfiguration()
{
}

void sub_184291048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  if (a5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a5);
  }
  NetworkProxyContext::~NetworkProxyContext((NetworkProxyContext *)va);
  (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  _Unwind_Resume(a1);
}

void makeProxy<>(void *a1, const NetworkProxyContext *a2)
{
  *a1 = 0;
  a1[1] = 0;
  int v4 = (*(uint64_t (**)(void))(**(void **)a2 + 40))();
  if (v4 == 2)
  {
    uint64_t v6 = (std::__shared_weak_count *)operator new(0x80uLL);
    v6->__shared_owners_ = 0;
    v6->__shared_weak_owners_ = 0;
    v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6640;
    NetworkProxy::NetworkProxy((NetworkProxy *)&v6[1], a2);
    *(void *)&long long v8 = v7;
    *((void *)&v8 + 1) = v6;
    shared_weak_owners = (std::__shared_weak_count *)v6[1].__shared_weak_owners_;
    if (shared_weak_owners)
    {
      if (shared_weak_owners->__shared_owners_ != -1)
      {
LABEL_12:
        *(_OWORD *)a1 = v8;
        return;
      }
      long long v10 = v8;
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v6[1].__shared_owners_ = v7;
      v6[1].__shared_weak_owners_ = (uint64_t)v6;
      std::__shared_weak_count::__release_weak(shared_weak_owners);
    }
    else
    {
      long long v10 = v8;
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v6[1].__shared_owners_ = v7;
      v6[1].__shared_weak_owners_ = (uint64_t)v6;
    }
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    long long v8 = v10;
    goto LABEL_12;
  }
  if (v4 == 3)
  {
    if (__CFNUseNWHTTPSProxies::useProxyOnce != -1) {
      dispatch_once(&__CFNUseNWHTTPSProxies::useProxyOnce, &__block_literal_global_16_5533);
    }
    if (!__CFNUseNWHTTPSProxies::useNWHTTPSProxy)
    {
      BOOL v5 = (char *)operator new(0x130uLL);
      *((void *)v5 + 1) = 0;
      *((void *)v5 + 2) = 0;
      *(void *)BOOL v5 = &unk_1ECFA6608;
      NetworkProxy::NetworkProxy((NetworkProxy *)(v5 + 24), a2);
      *((void *)v5 + 3) = &unk_1ECF9B118;
      *((void *)v5 + 16) = &unk_1ECF9B1C0;
      *(_OWORD *)(v5 + 136) = 0u;
      *(_OWORD *)(v5 + 152) = 0u;
      *(_OWORD *)(v5 + 168) = 0u;
      *(_OWORD *)(v5 + 184) = 0u;
      *(_OWORD *)(v5 + 200) = 0u;
      *((void *)v5 + 31) = 0;
      *((void *)v5 + 32) = 0;
      *((void *)v5 + 30) = 0;
      SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::SmartBlockWithArgs();
    }
  }
}

void sub_1842913B8(_Unwind_Exception *a1)
{
  int v4 = (std::__shared_weak_count *)v1[12].__vftable;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  shared_owners = (std::__shared_weak_count *)v1[11].__shared_owners_;
  if (shared_owners) {
    std::__shared_weak_count::__release_shared[abi:nn180100](shared_owners);
  }
  shared_weak_owners = (const void *)v1[10].__shared_weak_owners_;
  v1[10].__shared_weak_owners_ = 0;
  if (shared_weak_owners) {
    CFRelease(shared_weak_owners);
  }
  uint64_t v7 = (std::__shared_weak_count *)v1[10].__shared_owners_;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  long long v8 = (std::__shared_weak_count *)v1[8].__shared_weak_owners_;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  long long v9 = (std::__shared_weak_count *)v1[8].__vftable;
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  long long v10 = (std::__shared_weak_count *)v1[7].__shared_owners_;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  compression_status v11 = (std::__shared_weak_count *)v1[6].__shared_weak_owners_;
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  v12 = (std::__shared_weak_count *)v1[6].__vftable;
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  NetworkProxy::~NetworkProxy(v2);
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v13);
  _Unwind_Resume(a1);
}

void NetworkProxyContext::~NetworkProxyContext(NetworkProxyContext *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  double v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

uint64_t std::__shared_ptr_emplace<NetworkProxy>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<NetworkProxy>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6640;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<NetworkProxy>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6640;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<TunnelProxy<HTTPEngine>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<TunnelProxy<HTTPEngine>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6608;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<TunnelProxy<HTTPEngine>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6608;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ProxyConnectionEstablishment::SetProxies(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    BOOL v5 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    uint64_t v6 = "custom";
    uint64_t v7 = (uint64_t (*)())MEMORY[0x1E4F14B98];
  }
  else
  {
    if (ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::emptyProxyDictOnce != -1) {
      dispatch_once(&ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::emptyProxyDictOnce, &__block_literal_global_15454);
    }
    BOOL v5 = (void *)ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::emptyDict;
    uint64_t v6 = "empty";
    uint64_t v7 = ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::$_0::__invoke;
  }
  long long v8 = v7;
  if (a1)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    long long v9 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 134218498;
      uint64_t v12 = tcp_connection_id();
      __int16 v13 = 2048;
      uint64_t v14 = a1;
      __int16 v15 = 2080;
      size_t v16 = v6;
      _os_log_impl(&dword_184085000, v9, OS_LOG_TYPE_DEFAULT, "TCP Conn [%llu:%p] using %s proxy configuration", (uint8_t *)&v11, 0x20u);
    }
    tcp_connection_set_proxies();
  }
  if (a2)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    long long v10 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 136315138;
      uint64_t v12 = (uint64_t)v6;
      _os_log_impl(&dword_184085000, v10, OS_LOG_TYPE_DEFAULT, "Parameters using %s proxy configuration", (uint8_t *)&v11, 0xCu);
    }
    if (v5)
    {
      if (MEMORY[0x18531EBC0](v5) == MEMORY[0x1E4F14590] && !xpc_dictionary_get_count(v5)) {
        nw_parameters_set_no_proxy();
      }
      else {
        nw_parameters_set_proxy_configuration();
      }
      goto LABEL_22;
    }
    nw_parameters_set_no_proxy();
    nw_parameters_set_proxy_configuration();
  }
  else if (v5)
  {
LABEL_22:
    ((void (*)(void *))v8)(v5);
  }
}

void sub_184291834(_Unwind_Exception *exception_object)
{
  if (v1) {
    v2(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int attempt_count = nw_authentication_challenge_get_attempt_count();
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v13 = *(void *)(a1 + 32);
    buf[0] = 134218498;
    *(void *)&buf[1] = v13;
    __int16 v15 = 2112;
    uint64_t v16 = a2;
    __int16 v17 = 1024;
    int v18 = attempt_count;
    _os_log_debug_impl(&dword_184085000, v7, OS_LOG_TYPE_DEBUG, "Connection %llu: Received Proxy Challenge %@ %u", (uint8_t *)buf, 0x1Cu);
  }
  if (nw_authentication_challenge_copy_http_message())
  {
    nw_authentication_challenge_copy_protection_space();
    long long v8 = nw_authentication_protection_space_copy_endpoint();
    uint64_t parent_endpoint_domain = nw_endpoint_get_parent_endpoint_domain();
    if (!parent_endpoint_domain) {
      uint64_t parent_endpoint_domain = (uint64_t)nw_endpoint_get_hostname(v8);
    }
    nw_endpoint_get_port(v8);
    [NSString stringWithUTF8String:parent_endpoint_domain];
    operator new();
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  long long v10 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a1 + 32);
    buf[0] = 134218242;
    *(void *)&buf[1] = v11;
    __int16 v15 = 2112;
    uint64_t v16 = a2;
    _os_log_impl(&dword_184085000, v10, OS_LOG_TYPE_DEFAULT, "Connection %llu: Proxy Challenge %@ has no response", (uint8_t *)buf, 0x16u);
  }
  return (*(uint64_t (**)(uint64_t, void, void))(a3 + 16))(a3, 0, 0);
}

void sub_184291C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void (*a17)(char *), uint64_t a18, uint64_t a19, char a20,uint64_t a21,void (*a22)(char *),uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26)
{
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a26);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v27);
  std::__shared_weak_count::__release_shared[abi:nn180100](v27);
  a17(&a15);
  a22(&a20);
  CFRelease(v26);
  _Unwind_Resume(a1);
}

void ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke_3(uint64_t a1)
{
}

void ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke_2(uint64_t a1)
{
}

void ___ZN28ProxyConnectionEstablishment16configureProxiesEyPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0__block_invoke_3(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v6 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)allocator = 134218498;
    *(void *)&allocator[4] = v14;
    *(_WORD *)&allocator[12] = 2112;
    *(void *)&allocator[14] = a2;
    *(_WORD *)&allocator[22] = 1024;
    *(_DWORD *)uint64_t v19 = a3;
    _os_log_debug_impl(&dword_184085000, v6, OS_LOG_TYPE_DEBUG, "Connection %llu: Proxy Challenge Handler Complete proxyCred %@ cancel %d", allocator, 0x1Cu);
    if (!a2) {
      goto LABEL_26;
    }
  }
  else if (!a2)
  {
    goto LABEL_26;
  }
  uint64_t v7 = (const void *)nw_authentication_credential_create();
  if (v7)
  {
    CFStringRef Username = (const __CFString *)CFURLCredentialGetUsername(a2);
    long long v9 = (void *)MEMORY[0x1E4F1CF80];
    if (Username)
    {
      *(void *)allocator = *MEMORY[0x1E4F1CF80];
      *(void *)&allocator[8] = 1023;
      *(void *)&allocator[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)allocator, Username, v19, (uint64_t *)&allocator[8], 0x8000100u);
      nw_authentication_credential_set_username();
      CFStringRef Username = *(const __CFString **)&allocator[16];
      if (*(void *)&allocator[16])
      {
        if (v19 != *(UInt8 **)&allocator[16]) {
          CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
        }
      }
    }
    uint64_t v10 = URLCredential_PasswordBased::safelyCast(a2, (const _CFURLCredential *)Username);
    if (v10)
    {
      CFStringRef v11 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 128))(v10);
      if (v11)
      {
        *(void *)allocator = *v9;
        *(void *)&allocator[8] = 1023;
        *(void *)&allocator[16] = _CFStringGetOrCreateCString(*(const __CFAllocator **)allocator, v11, v19, (uint64_t *)&allocator[8], 0x8000100u);
        nw_authentication_credential_set_password();
        if (*(void *)&allocator[16] && v19 != *(UInt8 **)&allocator[16]) {
          CFAllocatorDeallocate(*(CFAllocatorRef *)allocator, *(void **)&allocator[16]);
        }
        char v12 = 0;
        goto LABEL_18;
      }
    }
    else
    {
      CFStringRef v11 = 0;
    }
    char v12 = 1;
LABEL_18:
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v13 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v17 = *(void *)(a1 + 40);
      *(_DWORD *)allocator = 134218498;
      *(void *)&allocator[4] = v17;
      *(_WORD *)&allocator[12] = 2112;
      *(void *)&allocator[14] = v7;
      *(_WORD *)&allocator[22] = 1024;
      *(_DWORD *)uint64_t v19 = a3;
      _os_log_debug_impl(&dword_184085000, v13, OS_LOG_TYPE_DEBUG, "Connection %llu: Proxy Challenge invoking completion with cred %@ cancel %d", allocator, 0x1Cu);
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    if ((v12 & 1) == 0) {
      CFRelease(v11);
    }
    CFRelease(v7);
    return;
  }
LABEL_26:
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  __int16 v15 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v16 = *(void *)(a1 + 40);
    *(_DWORD *)allocator = 134218240;
    *(void *)&allocator[4] = v16;
    *(_WORD *)&allocator[12] = 1024;
    *(_DWORD *)&allocator[14] = a3;
    _os_log_debug_impl(&dword_184085000, v15, OS_LOG_TYPE_DEBUG, "Connection %llu: Proxy Challenge invoking completion with no cred cancel %d", allocator, 0x12u);
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_184292058(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFAllocatorRef allocator, uint64_t a10, void *ptr)
{
  if (ptr)
  {
    if (v13 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }
  CFRelease(v12);
  CFRelease(v11);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BlockHolderVar<_CFURLCredential const*,BOOL> *,SmartBlockWithArgs<_CFURLCredential const*,BOOL>::Deleter,std::allocator<BlockHolderVar<_CFURLCredential const*,BOOL>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1 | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_initial && v5 != 0)
  {
    uint64_t v7 = (void *)(v1 + (v2 >> 1));
    if (v2) {
      (*(void (**)(void *, void, void))(*v7
    }
                                                       + BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_initial))(v7, 0, 0);
    else {
      ((void (*)(void *, void, void))BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_initial)(v7, 0, 0);
    }
  }
  _Block_release(*(const void **)v1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_pointer<BlockHolderVar<_CFURLCredential const*,BOOL> *,SmartBlockWithArgs<_CFURLCredential const*,BOOL>::Deleter,std::allocator<BlockHolderVar<_CFURLCredential const*,BOOL>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<_CFURLCredential const*,BOOL>::invoke_normal;
  a1[2] = 0;
  return (*(uint64_t (**)(void))(*a1 + 16))();
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_nw_parameters}*,Deleter_NWRelease<NSObject  {objcproto16OS_nw_parameters}*>,std::allocator<NSObject  {objcproto16OS_nw_parameters}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

xpc_object_t ___ZN28ProxyConnectionEstablishment10SetProxiesEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_PK14__CFDictionary_block_invoke()
{
  xpc_object_t result = xpc_dictionary_create(0, 0, 0);
  ProxyConnectionEstablishment::SetProxies(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,__CFDictionary const*)::emptyDict = (uint64_t)result;
  return result;
}

void GlueConnectionEstablishment::connectionEstablished(GlueConnectionEstablishment *this, CFStreamError a2)
{
}

void GlueConnectionEstablishment::connectionWaitingNotification()
{
}

void GlueConnectionEstablishment::postConnectConfiguration()
{
}

void GlueConnectionEstablishment::preConnectConfiguration()
{
}

void GlueConnectionEstablishment::needClientCert()
{
}

void GlueConnectionEstablishment::needServerTrust()
{
}

BOOL -[NSURLRequest _blockTrackers](NSURLRequest *self, SEL a2)
{
  return *(unsigned char *)([(NSURLRequest *)self _inner] + 172) != 0;
}

void sub_184294898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

__CFString *URLRequest::setTrackerContext(URLRequest *this, __CFString *cf)
{
  xpc_object_t result = this->fTrackerContext;
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      xpc_object_t result = (__CFString *)CFRetain(cf);
    }
    else {
      xpc_object_t result = 0;
    }
    this->fTrackerContext = result;
  }
  return result;
}

__CFString *URLRequest::setCookiePartitionIdentifier(URLRequest *this, __CFString *cf)
{
  xpc_object_t result = this->fCookiePartitionIdentifier;
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      xpc_object_t result = (__CFString *)CFRetain(cf);
    }
    else {
      xpc_object_t result = 0;
    }
    this->fCookiePartitionIdentifier = result;
  }
  return result;
}

void sub_1842955D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *), uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,CFTypeRef cf,CFTypeRef a23,char a24,uint64_t a25,void (*a26)(char *),uint64_t a27,uint64_t a28,char a29,uint64_t a30,void (*a31)(char *),uint64_t a32,uint64_t a33,char a34,uint64_t a35,void (*a36)(char *))
{
  if (cf) {
    CFRelease(cf);
  }
  if (a23) {
    CFRelease(a23);
  }
  a26(&a24);
  a31(&a29);
  a36(&a34);
  _Unwind_Resume(a1);
}

void sub_184295C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,void (*a23)(char *),uint64_t a24,uint64_t a25,char a26,uint64_t a27,void (*a28)(char *))
{
  a23(&a21);
  a28(&a26);
  (*(void (**)(uint64_t))(v28 - 128))(v28 - 144);
  _Unwind_Resume(a1);
}

void sub_184296324(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

id ___ZL18withHostsSPILockedU13block_pointerFvP12NSMutableSetP19NSMutableDictionaryE_block_invoke()
{
  withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::allowAnyHTTPCertificateHostSet = (uint64_t)objc_alloc_init(MEMORY[0x1E4F1CA80]);
  withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::allowSpecificHTTPCertificateHostDict = (uint64_t)objc_alloc_init(MEMORY[0x1E4F1CA60]);
  id result = objc_alloc_init(MEMORY[0x1E4FBA8A8]);
  withHostsSPILocked(void({block_pointer})(NSMutableSet *,NSMutableDictionary *))::gSyncObject = (uint64_t)result;
  return result;
}

void sub_184296684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__16081(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__16082(uint64_t a1)
{
}

void sub_184296824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void SSLDecoder::~SSLDecoder(SSLDecoder *this)
{
  SSLDecoder::~SSLDecoder(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  const void *v2;
  const void *v3;

  *(void *)this = &unk_1ECF9A900;
  uint64_t v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 3);
  if (v3) {
    CFRelease(v3);
  }
}

void SSLDecoder::processBytes(CFAllocatorRef *this, const __CFData **a2, UInt8 *bytes, size_t length, const char *a5)
{
  if (*a2)
  {
    CFIndex v10 = CFDataGetLength(*a2);
    Mutable = CFDataCreateMutable(this[1], v10 + length);
    CFDataSetLength(Mutable, v10 + length);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v44.location = 0;
    v44.length = v10;
    CFDataGetBytes(*a2, v44, MutableBytePtr);
    memcpy(&MutableBytePtr[v10], bytes, length);
    CFDataRef v13 = *a2;
    *a2 = 0;
    if (v13) {
      CFRelease(v13);
    }
    CFDataRef v14 = Mutable;
    if (!Mutable) {
      return;
    }
  }
  else
  {
    CFDataRef v14 = CFDataCreate(this[1], bytes, length);
    if (!v14) {
      return;
    }
  }
  BytePtr = CFDataGetBytePtr(v14);
  CFDataRef cf = v14;
  unint64_t v16 = (unint64_t)&BytePtr[CFDataGetLength(v14)];
  v40 = BytePtr;
  while ((unint64_t)BytePtr < v16)
  {
    uint64_t v17 = BytePtr + 5;
    if ((unint64_t)(BytePtr + 5) > v16) {
      break;
    }
    int v18 = *BytePtr;
    unsigned int v19 = *(unsigned __int16 *)(BytePtr + 1);
    unsigned int v20 = *(unsigned __int16 *)(BytePtr + 3);
    uint64_t v21 = __rev16(v20);
    uint64_t v22 = &v17[v21];
    if ((unint64_t)&v17[v21] > v16) {
      break;
    }
    CFMutableArrayRef v42 = CFArrayCreateMutable(this[1], 0, MEMORY[0x1E4F1D510]);
    AutoStringArray::addFormat((CFTypeRef *)&v42, @"BEGIN SSL RECORD DECODE: %s", a5);
    uint64_t v23 = bswap32(v19) >> 16;
    switch(v18)
    {
      case 20:
        AutoStringArray::addFormat((CFTypeRef *)&v42, @"%s @ %p, version %2.2x, length %d", "decodeChangeCiperSpec", BytePtr + 5, v23, v21);
        break;
      case 21:
        AutoStringArray::addFormat((CFTypeRef *)&v42, @"%s @ %p, version %2.2x, length %d", "decodeAlert", BytePtr + 5, v23, v21);
        int v24 = BytePtr[5];
        unsigned int v25 = BytePtr[6];
        uint64_t v26 = "UNKNOWN";
        if (v25 > 0x45)
        {
          if (BytePtr[6] > 0x59u)
          {
            switch(v25)
            {
              case 'Z':
                uint64_t v26 = "User cancelled\tfatal";
                break;
              case 'd':
                uint64_t v26 = "No renegotiation";
                break;
              case 'n':
                uint64_t v26 = "Unsupported extension";
                break;
            }
          }
          else
          {
            switch(v25)
            {
              case 'F':
                uint64_t v26 = "Protocol version";
                break;
              case 'G':
                uint64_t v26 = "Insufficient security";
                break;
              case 'P':
                uint64_t v26 = "Internal error\tfatal";
                break;
            }
          }
        }
        else
        {
          switch(BytePtr[6])
          {
            case 0x14u:
              uint64_t v26 = "Bad record MAC";
              break;
            case 0x15u:
              uint64_t v26 = "Decryption failed";
              break;
            case 0x16u:
              uint64_t v26 = "Record overflow";
              break;
            case 0x17u:
            case 0x18u:
            case 0x19u:
            case 0x1Au:
            case 0x1Bu:
            case 0x1Cu:
            case 0x1Du:
            case 0x1Fu:
            case 0x20u:
            case 0x21u:
            case 0x22u:
            case 0x23u:
            case 0x24u:
            case 0x25u:
            case 0x26u:
            case 0x27u:
            case 0x34u:
            case 0x35u:
            case 0x36u:
            case 0x37u:
            case 0x38u:
            case 0x39u:
            case 0x3Au:
            case 0x3Bu:
              break;
            case 0x1Eu:
              uint64_t v26 = "Decompression failure";
              break;
            case 0x28u:
              uint64_t v26 = "Handshake failure";
              break;
            case 0x29u:
              uint64_t v26 = "No certificate";
              break;
            case 0x2Au:
              uint64_t v26 = "Bad certificate";
              break;
            case 0x2Bu:
              uint64_t v26 = "Unsupported certificate";
              break;
            case 0x2Cu:
              uint64_t v26 = "Certificate revoked";
              break;
            case 0x2Du:
              uint64_t v26 = "Certificate expired";
              break;
            case 0x2Eu:
              uint64_t v26 = "Certificate unknown";
              break;
            case 0x2Fu:
              uint64_t v26 = "Illegal parameter";
              break;
            case 0x30u:
              uint64_t v26 = "Unknown CA";
              break;
            case 0x31u:
              uint64_t v26 = "Access denied";
              break;
            case 0x32u:
              uint64_t v26 = "Decode error";
              break;
            case 0x33u:
              uint64_t v26 = "Decrypt error";
              break;
            case 0x3Cu:
              uint64_t v26 = "Export restriction";
              break;
            default:
              if (BytePtr[6])
              {
                if (v25 == 10) {
                  uint64_t v26 = "Unexpected message";
                }
              }
              else
              {
                uint64_t v26 = "Close notify";
              }
              break;
          }
        }
        v32 = "UNKNOWN";
        if (v24 == 2) {
          v32 = "fatal";
        }
        BOOL v33 = v24 == 1;
        v34 = "warning";
        if (!v33) {
          v34 = v32;
        }
        AutoStringArray::addFormat((CFTypeRef *)&v42, @"Alert %s is %s", v26, v34);
        break;
      case 22:
        if (v20)
        {
          uint64_t v27 = 0;
          uint64_t v28 = v23;
          while (1)
          {
            AutoStringArray::addFormat((CFTypeRef *)&v42, @"%s [%d] @ %p, version %2.2x, length %d (0x%x)", "decodeHandshake", v27, v17, v28, v21, v21);
            uint64_t v29 = (unsigned __int8 *)(v17 + 4);
            if (v17 + 4 > v22)
            {
              AutoStringArray::addFormat((CFTypeRef *)&v42, @"## Only %ld bytes after header, need at least 4", v22 - v17);
              goto LABEL_64;
            }
            uint64_t v30 = *v17;
            uint64_t v31 = __rev16(*((unsigned __int16 *)v17 + 1));
            uint64_t v17 = &v29[v31];
            if (&v29[v31] > v22) {
              break;
            }
            if (v30 >= 0x15 || ((0x11F807u >> v30) & 1) == 0)
            {
              AutoStringArray::addFormat((CFTypeRef *)&v42, @"## Unknown msg %d (0x%x) - encrypted?", v30, v30);
              goto LABEL_64;
            }
            AutoStringArray::addFormat((CFTypeRef *)&v42, @"%s (%d, 0x%x), length %d (0x%x)", off_1E5256C38[v30], v30, v30, v31, v31);
            uint64_t v27 = (v27 + 1);
            if (v17 >= v22) {
              goto LABEL_64;
            }
          }
          AutoStringArray::addFormat((CFTypeRef *)&v42, @"## Message %d (0x%x) length %d (0x%x) invalid - encrypted?", v30, v30, v31, v31);
        }
        break;
      case 23:
        AutoStringArray::addFormat((CFTypeRef *)&v42, @"%s @ %p, version %2.2x, length %d (0x%x)", "decodeApplication", BytePtr + 5, v23, v21, v21);
        break;
      default:
        break;
    }
LABEL_64:
    AutoStringArray::addFormat((CFTypeRef *)&v42, @"END SSL RECORD DECODE: %s", a5);
    CFMutableArrayRef v35 = v42;
    (*(void (**)(CFAllocatorRef, char *, CFMutableArrayRef))(*(void *)this[4] + 24))(this[4], (char *)this + 40, v42);
    CFRelease(v35);
    BOOL v33 = v22 == BytePtr;
    BytePtr = v22;
    if (v33) {
      goto LABEL_68;
    }
  }
  uint64_t v22 = BytePtr;
LABEL_68:
  if (v22 == v40)
  {
    CFDataRef v38 = cf;
    CFDataRef v37 = (const __CFData *)CFRetain(cf);
    v36 = a2;
  }
  else
  {
    v36 = a2;
    if (v22 == (const UInt8 *)v16) {
      CFDataRef v37 = 0;
    }
    else {
      CFDataRef v37 = CFDataCreate(this[1], v22, v16 - (void)v22);
    }
    CFDataRef v38 = cf;
  }
  *v36 = v37;

  CFRelease(v38);
}

void sub_184296EE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf)
{
}

void ChunkedResponseDataCombiner::read(ResponseDataCombiner *this, uint64_t a2)
{
  if (*(uint64_t *)(a2 + 8) >= 1)
  {
    int v4 = 0;
    int v5 = (char *)this + 32896;
    uint64_t v6 = (void *)(a2 + 24);
    uint64_t v7 = (void *)((char *)this + 48);
    long long v8 = (void *)((char *)this + 104);
    while (1)
    {
      if (*(unsigned char *)(a2 + 41) || *(unsigned char *)(a2 + 40) || v4 || *v6) {
        return;
      }
      switch(*((_DWORD *)this + 10))
      {
        case 0:
          if (*((void *)this + 1) && *((void *)this + 2) < *((void *)this + 3))
          {
            ResponseDataCombiner::readHeaderData((uint64_t)this, a2);
            goto LABEL_39;
          }
          int v4 = 0;
          *((_DWORD *)this + 10) = 1;
          goto LABEL_42;
        case 1:
        case 2:
          if (ResponseDataCombiner::canRead(this))
          {
            uint64_t v9 = *((void *)this + 13);
            memset(v23, 0, sizeof(v23));
            *(void *)buf = v9;
            uint64_t v22 = 0x8000;
            ResponseDataCombiner::readBodyStreamData((uint64_t)this, (uint64_t)buf);
            uint64_t v10 = v23[0];
            if (!v23[0])
            {
              v5[1] = *((_DWORD *)this + 10) == 1;
              int v11 = 5;
              goto LABEL_34;
            }
            if (v23[0] == -1)
            {
              *(_OWORD *)uint64_t v6 = *(_OWORD *)&v23[1];
              *(unsigned char *)(a2 + 40) = 1;
              int v11 = 7;
LABEL_34:
              *((_DWORD *)this + 10) = v11;
              goto LABEL_39;
            }
            *((void *)this + 14) = 0;
            *((void *)this + 15) = v10;
            unsigned int v19 = (char *)*((void *)this + 6);
            if (*((_DWORD *)this + 10) == 1) {
              int v20 = snprintf(v19, 0x20uLL, "%X\r\n");
            }
            else {
              int v20 = snprintf(v19, 0x20uLL, "\r\n%X\r\n");
            }
            *((void *)this + 7) = 0;
            *((void *)this + 8) = v20;
            *((_DWORD *)this + 10) = 3;
            *int v5 = v23[3];
LABEL_39:
            int v4 = 0;
          }
          else
          {
            int v18 = (__CFReadStream *)*((void *)this + 4);
            if (!v18 || CFReadStreamGetStatus(v18) == kCFStreamStatusAtEnd)
            {
              int v4 = 0;
              v5[1] = *((_DWORD *)this + 10) == 1;
              goto LABEL_31;
            }
            int v4 = 1;
          }
LABEL_42:
          if (*(uint64_t *)(a2 + 8) <= 0) {
            return;
          }
          break;
        case 3:
          if (!ChunkedResponseDataCombiner::processBuffer(v7, a2)) {
            goto LABEL_39;
          }
          int v4 = 0;
          int v12 = 4;
          goto LABEL_41;
        case 4:
          if (!ChunkedResponseDataCombiner::processBuffer(v8, a2)) {
            goto LABEL_39;
          }
          int v4 = *v5;
          if (*v5)
          {
            int v4 = 0;
LABEL_31:
            int v12 = 5;
          }
          else
          {
            int v12 = 2;
          }
          goto LABEL_41;
        case 5:
          CFDataRef v13 = (char *)*((void *)this + 6);
          if (v5[1]) {
            int v14 = snprintf(v13, 0x20uLL, "%X\r\n");
          }
          else {
            int v14 = snprintf(v13, 0x20uLL, "\r\n%X\r\n");
          }
          int v4 = 0;
          uint64_t v15 = *((void *)this + 6);
          *((void *)this + 7) = 0;
          *((void *)this + 8) = v14 + 1;
          *(unsigned char *)(v15 + v14) = 13;
          uint64_t v16 = *((void *)this + 6);
          uint64_t v17 = *((void *)this + 8);
          *((void *)this + 8) = v17 + 1;
          *(unsigned char *)(v16 + v17) = 10;
          int v12 = 6;
          goto LABEL_41;
        case 6:
          if (!ChunkedResponseDataCombiner::processBuffer(v7, a2)) {
            goto LABEL_39;
          }
          int v4 = 0;
          *(unsigned char *)(a2 + 40) = 1;
          int v12 = 7;
LABEL_41:
          *((_DWORD *)this + 10) = v12;
          goto LABEL_42;
        default:
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Illegal state", buf, 2u);
          }
          goto LABEL_39;
      }
    }
  }
}

BOOL ChunkedResponseDataCombiner::processBuffer(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  int64_t v5 = a1[2] - v4;
  int64_t v6 = *(void *)(a2 + 8);
  if (v5 > v6)
  {
    *(unsigned char *)(a2 + 41) = 1;
    int64_t v5 = v6;
  }
  memcpy(*(void **)a2, (const void *)(*a1 + v4), v5);
  int64_t v7 = *(void *)(a2 + 8) - v5;
  *(void *)a2 += v5;
  *(void *)(a2 + 8) = v7;
  *(void *)(a2 + 16) += v5;
  uint64_t v8 = a1[2];
  int64_t v9 = a1[1] + v5;
  a1[1] = v9;
  return v9 == v8;
}

uint64_t ChunkedResponseDataCombiner::canRead(ChunkedResponseDataCombiner *this)
{
  return 1;
}

void ChunkedResponseDataCombiner::~ChunkedResponseDataCombiner(ChunkedResponseDataCombiner *this)
{
  ResponseDataCombiner::~ResponseDataCombiner(this);

  JUMPOUT(0x18531B6D0);
}

void PrivateAccessTokens::getPATAuthHeaders(uint64_t a1, const __CFArray *a2, const __CFData *a3, uint64_t a4, const __CFURL *a5, const __CFURL *a6, void *a7, int a8, char a9, char a10, void *a11, uint64_t *a12)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  id v92 = a7;
  id v94 = a11;
  gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v12);
  if (!objc_opt_class())
  {
    CFErrorRef v17 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"kCFErrorDomainCFNetwork", -1000, 0);
    uint64_t v18 = *a12;
    if (*a12)
    {
      unsigned int v19 = *(void (**)(void *, void, CFErrorRef))(v18 + 8);
      uint64_t v20 = *(void *)(v18 + 16);
      uint64_t v21 = (void *)(v18 + (v20 >> 1));
      if (v20) {
        unsigned int v19 = *(void (**)(void *, void, CFErrorRef))(*v21 + v19);
      }
      v19(v21, 0, v17);
    }
    goto LABEL_103;
  }
  if (v94)
  {
    __uint64_t v13 = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX) / 0x3B9ACA00;
    if (![v94 count])
    {
      uint64_t v16 = [NSNumber numberWithUnsignedLongLong:v13];
      [v94 addObject:v16];
      goto LABEL_10;
    }
    int v14 = [v94 objectAtIndexedSubscript:0];
    unint64_t v15 = v13 - [v14 unsignedLongLongValue];

    if (v15 >= 0x3D)
    {
      uint64_t v16 = [NSNumber numberWithUnsignedLongLong:v13];
      [v94 setObject:v16 atIndexedSubscript:0];
LABEL_10:

      goto LABEL_11;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    v70 = (id)CFNLog::logger;
    if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      *(void *)&buf[4] = a1;
      _os_log_error_impl(&dword_184085000, v70, OS_LOG_TYPE_ERROR, "%{public}@ too many PAT requests", buf, 0xCu);
    }

    CFErrorRef v17 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F289A0], -1013, 0);
    uint64_t v71 = *a12;
    if (*a12)
    {
      v72 = *(void (**)(void *, void, CFErrorRef))(v71 + 8);
      uint64_t v73 = *(void *)(v71 + 16);
      v74 = (void *)(v71 + (v73 >> 1));
      if (v73) {
        v72 = *(void (**)(void *, void, CFErrorRef))(*v74 + v72);
      }
      v72(v74, 0, v17);
    }
LABEL_103:
    if (v17) {
      CFRelease(v17);
    }
    goto LABEL_105;
  }
LABEL_11:
  CFIndex Count = CFArrayGetCount(a2);
  if (Count < 1)
  {
    v91 = 0;
    goto LABEL_90;
  }
  CFIndex v23 = 0;
  v91 = 0;
  v85 = 0;
  char v83 = 0;
  char v96 = 0;
  if (a6) {
    BOOL v24 = a10 == 0;
  }
  else {
    BOOL v24 = 1;
  }
  int v25 = !v24;
  int v84 = v25;
  v82 = (const void *)*MEMORY[0x1E4F1CFD0];
  do
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, v23);
    double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v27);
    CFDictionaryGetValue(ValueAtIndex, (const void *)objc_msgSend(*(id *)(v29 + 304), "challengeAttributeName", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge));
    uint64_t v30 = (PrivateAccessTokens *)objc_claimAutoreleasedReturnValue();
    v32 = v30;
    if (v30)
    {
      BOOL v33 = PrivateAccessTokens::decodeBase64URL(v30, v31);
      if (v33)
      {
        gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v34);
        v36 = (void *)[objc_alloc(*(Class *)(v35 + 304)) initWithData:v33];
        CFDataRef v37 = v36;
        if (!v36)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          log = (id)CFNLog::logger;
          if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543618;
            *(void *)&buf[4] = a1;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v32;
            _os_log_error_impl(&dword_184085000, log, OS_LOG_TYPE_ERROR, "%{public}@ PAT creating challenge failed %@", buf, 0x16u);
          }
          goto LABEL_68;
        }
        char v38 = [v36 typeRequiresRedemptionNonce];
        if (a8) {
          char v39 = v38;
        }
        else {
          char v39 = 0;
        }
        if (v39) {
          goto LABEL_69;
        }
        int v40 = [v37 typeHasAllowedOriginList];
        int v41 = a9 ? v40 : 1;
        if (!a10 && !v41) {
          goto LABEL_69;
        }
        log = CFURLCopyHostName(a5);
        CFMutableArrayRef v42 = [v37 originNames];
        uint64_t v43 = [v42 indexOfObject:log];

        if (v84)
        {
          CFRange v44 = (__CFString *)CFURLCopyHostName(a6);
          v45 = [v37 originNames];
          uint64_t v46 = [v45 indexOfObject:v44];

          if (v46 != 0x7FFFFFFFFFFFFFFFLL) {
            uint64_t v43 = v46;
          }
        }
        if (v43 == 0x7FFFFFFFFFFFFFFFLL)
        {
          if (([v37 typeRequiresOriginName] & 1) != 0
            || ([v37 originNames],
                v47 = objc_claimAutoreleasedReturnValue(),
                BOOL v48 = [v47 count] == 0,
                v47,
                !v48))
          {
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
            }
            v50 = (id)CFNLog::logger;
            if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138543618;
              *(void *)&buf[4] = a1;
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = log;
              _os_log_error_impl(&dword_184085000, v50, OS_LOG_TYPE_ERROR, "%{public}@ PAT origin verification failed %@", buf, 0x16u);
            }
LABEL_67:

LABEL_68:
LABEL_69:

            goto LABEL_70;
          }
        }
        else
        {
          v51 = [v37 originNames];
          uint64_t v52 = [v51 objectAtIndexedSubscript:v43];

          v91 = (void *)v52;
        }
        double v53 = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v49);
        CFDictionaryGetValue(ValueAtIndex, (const void *)objc_msgSend(*(id *)(v54 + 304), "tokenKeyAttributeName", v53));
        v55 = (PrivateAccessTokens *)objc_claimAutoreleasedReturnValue();
        v50 = v55;
        if (v55
          && (PrivateAccessTokens::decodeBase64URL(v55, v56),
              (v57 = objc_claimAutoreleasedReturnValue()) != 0))
        {
          double v59 = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v58);
          CFDictionaryGetValue(ValueAtIndex, (const void *)objc_msgSend(*(id *)(v60 + 304), "originNameKeyAttributeName", v59));
          v61 = (PrivateAccessTokens *)objc_claimAutoreleasedReturnValue();
          v64 = v61;
          if (v61)
          {
            v65 = PrivateAccessTokens::decodeBase64URL(v61, v62);
          }
          else
          {
            v65 = 0;
          }
          if (v85)
          {
            [v85 addSecondaryChallenge:v33 tokenKey:v57 originNameKey:v65];
          }
          else
          {
            gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(v63);
            v85 = (void *)[objc_alloc(*(Class *)(v66 + 312)) initWithChallenge:v33 tokenKey:v57 originNameKey:v65];
          }
          BOOL v67 = CFDictionaryGetValue(ValueAtIndex, @"kCFHTTPAuthenticationUsedQuotes") == v82;

          v83 |= v67;
        }
        else
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          v57 = (id)CFNLog::logger;
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138543618;
            *(void *)&buf[4] = a1;
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v50;
            _os_log_error_impl(&dword_184085000, v57, OS_LOG_TYPE_ERROR, "%{public}@ PAT parsing token key failed %@", buf, 0x16u);
          }
          char v96 = 1;
        }

        goto LABEL_67;
      }
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    BOOL v33 = (id)CFNLog::logger;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543618;
      *(void *)&buf[4] = a1;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v32;
      _os_log_error_impl(&dword_184085000, v33, OS_LOG_TYPE_ERROR, "%{public}@ PAT parsing challenge failed %@", buf, 0x16u);
    }
    char v96 = 1;
LABEL_70:

    ++v23;
  }
  while (Count != v23);
  v68 = v85;
  if (v85)
  {
    if (a3)
    {
      memset(buf, 0, sizeof(buf));
      v104.location = 0;
      v104.length = 32;
      CFDataGetBytes(a3, v104, buf);
      v101[0] = *(_OWORD *)buf;
      v101[1] = *(_OWORD *)&buf[16];
      [v85 setAuditToken:v101];
    }
    [v85 setBundleID:a4];
    [v85 setSelectedOrigin:v91];
    v98[0] = MEMORY[0x1E4F143A8];
    v98[1] = 3321888768;
    v98[2] = ___ZN19PrivateAccessTokens17getPATAuthHeadersEPK10__CFStringP9__CFArrayPK8__CFDataS2_PK7__CFURLSA_PU28objcproto17OS_dispatch_queue8NSObjecthhhP14NSMutableArrayIP8NSNumberE18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE_block_invoke;
    v98[3] = &__block_descriptor_49_ea8_32c57_ZTS18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE_e28_v24__0__NSData_8__NSError_16l;
    char v100 = v83 & 1;
    v69 = (std::__shared_weak_count *)a12[1];
    v98[4] = *a12;
    v99 = v69;
    if (v69) {
      atomic_fetch_add_explicit(&v69->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    [v85 fetchTokenWithQueue:v92 completionHandler:v98];
    if (v99) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v99);
    }
    goto LABEL_100;
  }
  if (v96)
  {
    CFErrorRef v75 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"kCFErrorDomainCFNetwork", -1, 0);
    uint64_t v76 = *a12;
    if (*a12)
    {
      v77 = *(void (**)(void *, void, CFErrorRef))(v76 + 8);
      uint64_t v78 = *(void *)(v76 + 16);
      v79 = (void *)(v76 + (v78 >> 1));
      if ((v78 & 1) == 0) {
        goto LABEL_96;
      }
      (*(void (**)(void *, void, CFErrorRef))(*v79 + v77))(v79, 0, v75);
    }
    goto LABEL_97;
  }
LABEL_90:
  CFErrorRef v75 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFErrorDomain)*MEMORY[0x1E4F289A0], -1013, 0);
  uint64_t v80 = *a12;
  if (*a12)
  {
    v77 = *(void (**)(void *, void, CFErrorRef))(v80 + 8);
    uint64_t v81 = *(void *)(v80 + 16);
    v79 = (void *)(v80 + (v81 >> 1));
    if (v81) {
      v77 = *(void (**)(void *, void, CFErrorRef))(*v79 + v77);
    }
LABEL_96:
    v77(v79, 0, v75);
  }
LABEL_97:
  if (v75) {
    CFRelease(v75);
  }
  v68 = 0;
LABEL_100:

LABEL_105:
}

void sub_184297DC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,void *a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  if (v35) {
    CFRelease(v35);
  }

  _Unwind_Resume(a1);
}

id PrivateAccessTokens::decodeBase64URL(PrivateAccessTokens *this, NSString *a2)
{
  uint64_t v2 = this;
  CFAllocatorRef v3 = [(PrivateAccessTokens *)v2 stringByReplacingOccurrencesOfString:@"_" withString:@"/"];

  uint64_t v4 = [v3 stringByReplacingOccurrencesOfString:@"-" withString:@"+"];

  int64_t v5 = (void *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBase64EncodedString:v4 options:1];

  return v5;
}

void sub_184297FEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN19PrivateAccessTokens17getPATAuthHeadersEPK10__CFStringP9__CFArrayPK8__CFDataS2_PK7__CFURLSA_PU28objcproto17OS_dispatch_queue8NSObjecthhhP14NSMutableArrayIP8NSNumberE18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE_block_invoke(uint64_t a1, void *a2, void *a3)
{
  v28[1] = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  int64_t v7 = v6;
  if (!v5 || v6)
  {
    uint64_t v23 = *(void *)(a1 + 32);
    if (v23)
    {
      BOOL v24 = *(void (**)(void *, void, void *))(v23 + 8);
      uint64_t v25 = *(void *)(v23 + 16);
      uint64_t v26 = (void *)(v23 + (v25 >> 1));
      if (v25) {
        BOOL v24 = *(void (**)(void *, void, void *))(*v26 + v24);
      }
      v24(v26, 0, v7);
    }
  }
  else
  {
    uint64_t v8 = [v5 base64EncodedStringWithOptions:0];
    int64_t v9 = [v8 stringByReplacingOccurrencesOfString:@"/" withString:@"_"];

    uint64_t v10 = [v9 stringByReplacingOccurrencesOfString:@"+" withString:@"-"];

    if (*(unsigned char *)(a1 + 48))
    {
      uint64_t v12 = [NSString stringWithFormat:@"\"%@\"", v10];

      uint64_t v10 = (void *)v12;
    }
    double v27 = @"Authorization";
    __uint64_t v13 = NSString;
    double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(v11);
    uint64_t v16 = objc_msgSend(*(id *)(v15 + 304), "httpAuthenticationScheme", Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge);
    CFErrorRef v17 = [v13 stringWithFormat:@"%@ token=%@", v16, v10];
    v28[0] = v17;
    uint64_t v18 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v28 forKeys:&v27 count:1];

    uint64_t v19 = *(void *)(a1 + 32);
    if (v19)
    {
      uint64_t v20 = *(void (**)(void *, void *, void))(v19 + 8);
      uint64_t v21 = *(void *)(v19 + 16);
      uint64_t v22 = (void *)(v19 + (v21 >> 1));
      if (v21) {
        uint64_t v20 = *(void (**)(void *, void *, void))(*v22 + v20);
      }
      v20(v22, v18, 0);
    }
  }
}

void sub_1842981FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c57_ZTS18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_ea8_32c57_ZTS18SmartBlockWithArgsIJPK14__CFDictionaryP9__CFErrorEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void HTTPServer::State::~State(HTTPServer::State *this)
{
  HTTPServer::State::~State(this);

  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECFA5CA8;
  CFRelease(*((CFTypeRef *)this + 11));
  CFRelease(*((CFTypeRef *)this + 10));
  CFRelease(*((CFTypeRef *)this + 9));
  *(void *)this = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
}

void non-virtual thunk to'HTTPServer::releaseSelf(HTTPServer *this)
{
}

CFTypeRef non-virtual thunk to'HTTPServer::retainSelf(HTTPServer *this)
{
  return CFRetain((char *)this - 24);
}

uint64_t non-virtual thunk to'HTTPServer::errorClient(uint64_t this, void *a2, __CFError *a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(void *, __CFError *))(this + 120);
  if (v3)
  {
    *(void *)(this + 120) = 0;
    if (a2) {
      return v3(a2, a3);
    }
  }
  return this;
}

uint64_t non-virtual thunk to'HTTPServer::invalidateClient(uint64_t this, void *a2)
{
  uint64_t v2 = *(uint64_t (**)(void *))(this + 112);
  if (v2)
  {
    *(void *)(this + 112) = 0;
    if (a2) {
      return v2(a2);
    }
  }
  return this;
}

void non-virtual thunk to'HTTPServer::signalled_onQueue(HTTPServer *this)
{
}

void HTTPServer::signalled_onQueue(HTTPServer *this)
{
  uint64_t v2 = (char *)this + 152;
  CFErrorRef v17 = (CFArrayRef *)((char *)this + 224);
  uint64_t v3 = HTTPServer::State::enumeratorForAndDrain((uint64_t)this + 152, (CFTypeRef *)this + 28);
  if (v3)
  {
    uint64_t v4 = (CFContainerEnumeratorBase *)v3;
    uint64_t v5 = *(void *)(v3 + 272);
    if (v5 < *(void *)(v3 + 8))
    {
      do
      {
        *((void *)v4 + 34) = v5 + 1;
        uint64_t v6 = *(void *)(*((void *)v4 + 2) + 8 * v5);
        if (v6)
        {
          if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
            dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
          }
          uint64_t v7 = v6 + 16;
        }
        else
        {
          uint64_t v7 = 0;
        }
        if (*((void *)this + 17)
          && ((unsigned int v8 = *((_DWORD *)this + 18), v8 < 2)
           || v8 == 2 && *((void *)this + 11) && *(_DWORD *)(*((void *)this + 12) + 40)))
        {
          pthread_mutex_lock((pthread_mutex_t *)((char *)this + 160));
          CFArrayAppendValue(*((CFMutableArrayRef *)this + 29), (const void *)(v7 - 16));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 160));
          (*(void (**)(void))(*(void *)(v7 + 8) + 72))();
          uint64_t v9 = *(void *)(v7 + 88);
          v19[0] = MEMORY[0x1E4F143A8];
          v19[1] = 3221225472;
          v19[2] = ___ZN10HTTPServer17signalled_onQueueEv_block_invoke;
          v19[3] = &unk_1E5256D30;
          v19[5] = this;
          v19[6] = v7;
          v19[4] = v9;
          HTTPServerBase::withClientAsync((void *)this + 1, (uint64_t)v19);
        }
        else
        {
          aBlock[0] = MEMORY[0x1E4F143A8];
          aBlock[1] = 3221225472;
          aBlock[2] = ___ZN20HTTPServerConnection7abandonEv_block_invoke;
          aBlock[3] = &__block_descriptor_40_e5_v8__0l;
          aBlock[4] = v7;
          HTTPServerBase::withWorkQueue((void *)(v7 + 8), aBlock);
        }
        uint64_t v5 = *((void *)v4 + 34);
      }
      while (v5 < *((void *)v4 + 1));
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v4);
    MEMORY[0x18531B6D0]();
  }
  uint64_t v10 = HTTPServer::State::enumeratorForAndDrain((uint64_t)v2, (CFTypeRef *)this + 30);
  if (v10)
  {
    double v11 = (CFContainerEnumeratorBase *)v10;
    uint64_t v12 = *(void *)(v10 + 272);
    if (v12 < *(void *)(v10 + 8))
    {
      do
      {
        *((void *)v11 + 34) = v12 + 1;
        uint64_t v13 = *(void *)(*((void *)v11 + 2) + 8 * v12);
        if (v13)
        {
          if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
            dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
          }
          v13 += 16;
        }
        if (*((void *)this + 18))
        {
          (*(void (**)(void))(*(void *)(v13 + 8) + 72))();
          uint64_t v14 = *(void *)(v13 + 88);
          v18[0] = MEMORY[0x1E4F143A8];
          v18[1] = 3221225472;
          v18[2] = ___ZN10HTTPServer17signalled_onQueueEv_block_invoke_3;
          v18[3] = &unk_1E5256D30;
          v18[5] = this;
          v18[6] = v13;
          v18[4] = v14;
          HTTPServerBase::withClientAsync((void *)this + 1, (uint64_t)v18);
        }
        uint64_t v12 = *((void *)v11 + 34);
      }
      while (v12 < *((void *)v11 + 1));
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v11);
    MEMORY[0x18531B6D0]();
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 160));
  if (CFArrayGetCount(*((CFArrayRef *)this + 30)) || CFArrayGetCount(*v17))
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 160));
  }
  else
  {
    CFIndex Count = CFArrayGetCount(*((CFArrayRef *)this + 29));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 160));
    if (!Count)
    {
      unsigned int v16 = *((_DWORD *)this + 18);
      if (v16 >= 2 && (v16 != 2 || !*((void *)this + 11) || !*(_DWORD *)(*((void *)this + 12) + 40))) {
        HTTPServerBase::deliverTerminalEvent_onQueue((HTTPServer *)((char *)this + 8));
      }
    }
  }
}

uint64_t HTTPServer::State::enumeratorForAndDrain(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v3 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  CFArrayRef v4 = (const __CFArray *)*a2;
  if (*a2)
  {
    CFAllocatorRef v5 = CFGetAllocator(*a2);
    CFArrayRef Copy = CFArrayCreateCopy(v5, v4);
    CFArrayRemoveAllValues((CFMutableArrayRef)*a2);
    pthread_mutex_unlock(v3);
    if (Copy)
    {
      if (CFArrayGetCount(Copy)) {
        operator new();
      }
      CFRelease(Copy);
    }
  }
  else
  {
    pthread_mutex_unlock(v3);
  }
  return 0;
}

void sub_184298844(_Unwind_Exception *a1)
{
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase(v1);
  MEMORY[0x18531B6D0]();
  _Unwind_Resume(a1);
}

void ___ZN10HTTPServer17signalled_onQueueEv_block_invoke(void *a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void (**)(uint64_t, uint64_t))(a1[5] + 136);
    if (v3) {
      v3(a2, a1[6] - 16);
    }
  }
  uint64_t v4 = a1[6];
  CFAllocatorRef v5 = a1[4];
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN10HTTPServer17signalled_onQueueEv_block_invoke_2;
  aBlock[3] = &__block_descriptor_40_e5_v8__0l;
  aBlock[4] = v4;
  HTTPServerBase::releaseOnCapturedQueue(v4 + 8, v5, aBlock);
}

void ___ZN10HTTPServer17signalled_onQueueEv_block_invoke_3(void *a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void (**)(uint64_t, uint64_t))(a1[5] + 144);
    if (v3) {
      v3(a2, a1[6] - 16);
    }
  }
  uint64_t v4 = a1[6] + 8;
  CFAllocatorRef v5 = a1[4];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN14HTTPServerBase22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  v6[3] = &unk_1E5257C58;
  v6[4] = 0;
  v6[5] = v4;
  dispatch_async(v5, v6);
}

uint64_t ___ZN10HTTPServer17signalled_onQueueEv_block_invoke_2(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  unsigned int v2 = *(_DWORD *)(result + 72);
  if (v2 >= 2)
  {
    if (v2 == 2)
    {
      if (!*(void *)(result + 88)) {
        return (*(uint64_t (**)(void))(*(void *)result + 104))();
      }
      if (*(_DWORD *)(*(void *)(result + 96) + 40)) {
        return result;
      }
    }
    else if (!*(void *)(result + 88))
    {
      return (*(uint64_t (**)(void))(*(void *)result + 104))();
    }
    if (*(_DWORD *)(*(void *)(result + 96) + 40)) {
      return result;
    }
    return (*(uint64_t (**)(void))(*(void *)result + 104))();
  }
  return result;
}

void non-virtual thunk to'HTTPServer::setProperty(HTTPServer *this, const __CFString *a2, const void *a3)
{
}

void HTTPServer::setProperty(HTTPServer *this, CFStringRef theString, const void *a3)
{
  int ExactString = _findExactString(theString, 9u);
  switch(ExactString)
  {
    case 486775229:
      uint64_t v9 = (const void *)*((void *)this + 34);
      *((void *)this + 34) = 0;
      if (v9) {
        CFRelease(v9);
      }
      if (a3) {
        CFTypeRef v10 = CFRetain(a3);
      }
      else {
        CFTypeRef v10 = 0;
      }
      *((void *)this + 34) = v10;
      break;
    case 485693872:
      double v11 = (const void *)*((void *)this + 31);
      *((void *)this + 31) = 0;
      if (v11) {
        CFRelease(v11);
      }
      if (a3)
      {
        CFAllocatorRef v12 = CFGetAllocator(a3);
        CFDictionaryRef Copy = CFDictionaryCreateCopy(v12, (CFDictionaryRef)a3);
      }
      else
      {
        CFDictionaryRef Copy = 0;
      }
      *((void *)this + 31) = Copy;
      break;
    case 471013613:
      uint64_t v7 = (const void *)*((void *)this + 33);
      *((void *)this + 33) = 0;
      if (v7) {
        CFRelease(v7);
      }
      if (a3) {
        CFTypeRef v8 = CFRetain(a3);
      }
      else {
        CFTypeRef v8 = 0;
      }
      *((void *)this + 33) = v8;
      break;
    default:
      HTTPServerBase::setProperty((HTTPServer *)((char *)this + 8), theString, a3);
      break;
  }
}

CFTypeRef non-virtual thunk to'HTTPServer::copyProperty(HTTPServer *this, const __CFString *a2)
{
  return HTTPServer::copyProperty((HTTPServer *)((char *)this - 8), a2);
}

CFTypeRef HTTPServer::copyProperty(HTTPServer *this, CFStringRef theString)
{
  int ExactString = _findExactString(theString, 9u);
  switch(ExactString)
  {
    case 471013613:
      CFAllocatorRef v5 = (CFTypeRef *)((char *)this + 264);
      goto LABEL_7;
    case 486775229:
      CFAllocatorRef v5 = (CFTypeRef *)((char *)this + 272);
LABEL_7:
      CFTypeRef result = *v5;
      if (*v5)
      {
        return CFRetain(result);
      }
      return result;
    case 485693872:
      CFAllocatorRef v5 = (CFTypeRef *)((char *)this + 248);
      goto LABEL_7;
  }

  return HTTPServerBase::copyProperty((HTTPServer *)((char *)this + 8), theString);
}

uint64_t HTTPServer::errorClient(uint64_t this, void *a2, __CFError *a3)
{
  uint64_t v3 = *(uint64_t (**)(void *, __CFError *))(this + 128);
  if (v3)
  {
    *(void *)(this + 128) = 0;
    if (a2) {
      return v3(a2, a3);
    }
  }
  return this;
}

uint64_t HTTPServer::invalidateClient(uint64_t this, void *a2)
{
  unsigned int v2 = *(uint64_t (**)(void *))(this + 120);
  if (v2)
  {
    *(void *)(this + 120) = 0;
    if (a2) {
      return v2(a2);
    }
  }
  return this;
}

uint64_t HTTPServer::setupTLSOnStreams(HTTPServer *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  uint64_t v6 = (*(uint64_t (**)(HTTPServer *, uint64_t))(*(void *)this + 64))(this, 0x1EC0A4760);
  if (v6)
  {
    CFDictionaryRef v7 = (const __CFDictionary *)v6;
    CFTypeRef v8 = CFGetAllocator((char *)this - 16);
    v37[0] = &unk_1ECFA5A28;
    if (v8) {
      CFTypeRef v8 = CFRetain(v8);
    }
    char v38 = 0;
    char v39 = 0;
    v37[1] = v8;
    MutableDict = AutoDict::getMutableDict((AutoDict *)v37);
    CFTypeRef v10 = (const void *)*MEMORY[0x1E4F1CFD0];
    if (*MEMORY[0x1E4F1CFD0]) {
      CFDictionarySetValue(MutableDict, &unk_1EC0A1628, (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    else {
      CFDictionaryRemoveValue(MutableDict, &unk_1EC0A1628);
    }
    CFAllocatorRef v12 = AutoDict::getMutableDict((AutoDict *)v37);
    uint64_t v13 = (const void *)*MEMORY[0x1E4F1CFC8];
    if (*MEMORY[0x1E4F1CFC8]) {
      CFDictionarySetValue(v12, &unk_1EC0A1778, (const void *)*MEMORY[0x1E4F1CFC8]);
    }
    else {
      CFDictionaryRemoveValue(v12, &unk_1EC0A1778);
    }
    CFTypeRef v11 = HTTPServer::copyServerTrustChain(this);
    if (v11)
    {
      uint64_t v14 = AutoDict::getMutableDict((AutoDict *)v37);
      if (v13) {
        CFDictionarySetValue(v14, &unk_1EC0A1778, v13);
      }
      else {
        CFDictionaryRemoveValue(v14, &unk_1EC0A1778);
      }
      uint64_t v15 = AutoDict::getMutableDict((AutoDict *)v37);
      CFDictionarySetValue(v15, &unk_1EC0A15B8, v11);
      CFRelease(v11);
      Value = (void *)CFDictionaryGetValue(v7, @"kCFHTTPServerStreamSSLSettings");
      CFErrorRef v17 = Value;
      if (Value)
      {
        CFContainerEnumeratorBase::setup((unint64_t)&v31, Value, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictKeyData);
        CFContainerEnumeratorBase::setup((unint64_t)&v34, v17, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
        uint64_t v18 = v35;
        if (v35 >= 1)
        {
          uint64_t v19 = 0;
          do
          {
            uint64_t v20 = *(const void **)(v33 + 8 * v19);
            uint64_t v21 = *(const void **)(v36 + 8 * v19);
            uint64_t v22 = AutoDict::getMutableDict((AutoDict *)v37);
            if (v21) {
              CFDictionarySetValue(v22, v20, v21);
            }
            else {
              CFDictionaryRemoveValue(v22, v20);
            }
            ++v19;
          }
          while (v18 != v19);
        }
        CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v34);
        CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v31);
      }
      EmptyDict = v39;
      if (!v39)
      {
        EmptyDict = v38;
        if (!v38) {
          EmptyDict = (const void *)AutoDict::getEmptyDict((AutoDict *)Value);
        }
      }
      BOOL v24 = (AutoDict *)CFReadStreamSetProperty(a2, @"kCFStreamPropertySSLSettings", EmptyDict);
      if (v24)
      {
        uint64_t v25 = v39;
        if (!v39)
        {
          uint64_t v25 = v38;
          if (!v38) {
            uint64_t v25 = (const void *)AutoDict::getEmptyDict(v24);
          }
        }
        CFTypeRef v11 = (CFTypeRef)CFWriteStreamSetProperty(a3, @"kCFStreamPropertySSLSettings", v25);
      }
      else
      {
        CFTypeRef v11 = 0;
      }
    }
    uint64_t v26 = CFDictionaryGetValue(v7, @"kCFHTTPServerRequireClientCertificate");
    double v27 = v26;
    if (!v26) {
      goto LABEL_49;
    }
    CFTypeID v28 = CFGetTypeID(v26);
    if (v28 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v31) = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v31, 2u);
    }
    if (v10 == v27)
    {
      AutoScalar::AutoScalar((AutoScalar *)&v31, (const __CFAllocator *)1);
      CFReadStreamSetProperty(a2, (CFStreamPropertyKey)&unk_1EC09FD70, propertyValue);
      uint64_t v31 = &unk_1ECF9A500;
      if (propertyValue) {
        CFRelease(propertyValue);
      }
      AutoScalar::AutoScalar((AutoScalar *)&v31, (const __CFAllocator *)1);
      CFWriteStreamSetProperty(a3, (CFStreamPropertyKey)&unk_1EC09FD70, propertyValue);
    }
    else
    {
      CFTypeID v29 = CFGetTypeID(v27);
      if (v29 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        LOWORD(v31) = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", (uint8_t *)&v31, 2u);
      }
      if (v13 != v27) {
        goto LABEL_49;
      }
      AutoScalar::AutoScalar((AutoScalar *)&v31, (const __CFAllocator *)2);
      CFReadStreamSetProperty(a2, (CFStreamPropertyKey)&unk_1EC09FD70, propertyValue);
      uint64_t v31 = &unk_1ECF9A500;
      if (propertyValue) {
        CFRelease(propertyValue);
      }
      AutoScalar::AutoScalar((AutoScalar *)&v31, (const __CFAllocator *)2);
      CFWriteStreamSetProperty(a3, (CFStreamPropertyKey)&unk_1EC09FD70, propertyValue);
    }
    uint64_t v31 = &unk_1ECF9A500;
    if (propertyValue) {
      CFRelease(propertyValue);
    }
LABEL_49:
    AutoDict::~AutoDict((AutoDict *)v37);
    CFRelease(v7);
    return (uint64_t)v11;
  }
  return 1;
}

void sub_184299128(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  AutoDict::~AutoDict((AutoDict *)(v10 - 120));
  _Unwind_Resume(a1);
}

CFTypeRef HTTPServer::copyServerTrustChain(HTTPServer *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 32);
  if (!result)
  {
    CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 31);
    if (!v3) {
      goto LABEL_26;
    }
    Value = CFDictionaryGetValue(v3, @"kCFHTTPServerServerTrustChain");
    if (!Value)
    {
      *((void *)this + 32) = 0;
      goto LABEL_7;
    }
    CFTypeRef result = CFRetain(Value);
    *((void *)this + 32) = result;
    if (!result)
    {
LABEL_7:
      CFAllocatorRef v5 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 31), @"kCFHTTPServerServerIdentity");
      if (v5)
      {
        uint64_t v6 = (void *)CFRetain(v5);
        if (v6) {
          goto LABEL_9;
        }
      }
      if (CFDictionaryGetValue(*((CFDictionaryRef *)this + 31), @"kCFHTTPServerAllowAnonymousServer") == (const void *)*MEMORY[0x1E4F1CFD0])
      {
        if (HTTPServer::copyServerTrustChain(void)::sOnce != -1) {
          dispatch_once(&HTTPServer::copyServerTrustChain(void)::sOnce, &__block_literal_global_6_16297);
        }
        if (HTTPServer::copyServerTrustChain(void)::sOnceIdentity)
        {
          uint64_t v6 = (void *)CFRetain((CFTypeRef)HTTPServer::copyServerTrustChain(void)::sOnceIdentity);
          if (v6)
          {
LABEL_9:
            CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
            Mutable = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
            CFArrayAppendValue(Mutable, v6);
            SecCertificateRef certificateRef = 0;
            if (!SecIdentityCopyCertificate((SecIdentityRef)v6, &certificateRef))
            {
              SecTrustRef trust = 0;
              CFAllocatorRef v9 = CFGetAllocator((char *)this - 16);
              Array = cfTypeCreateArray(v9, certificateRef, 0);
              SecPolicyRef BasicX509 = SecPolicyCreateBasicX509();
              if (!SecTrustCreateWithCertificates(Array, BasicX509, &trust))
              {
                if (SecTrustEvaluateWithError(trust, 0))
                {
                  CFArrayRef v12 = SecTrustCopyCertificateChain(trust);
                  if (v12)
                  {
                    CFArrayRef v13 = v12;
                    CFIndex Count = CFArrayGetCount(v12);
                    if (Count >= 2)
                    {
                      v18.length = Count - 1;
                      v18.location = 1;
                      CFArrayAppendArray(Mutable, v13, v18);
                    }
                    CFRelease(v13);
                  }
                }
                if (trust) {
                  CFRelease(trust);
                }
              }
              if (BasicX509) {
                CFRelease(BasicX509);
              }
              if (Array) {
                CFRelease(Array);
              }
              if (certificateRef) {
                CFRelease(certificateRef);
              }
            }
            *((void *)this + 32) = Mutable;
            CFRelease(v6);
          }
        }
      }
LABEL_26:
      CFTypeRef result = (CFTypeRef)*((void *)this + 32);
      if (!result) {
        return result;
      }
    }
  }

  return CFRetain(result);
}

void sub_1842993DC(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN10HTTPServer20copyServerTrustChainEv_block_invoke()
{
  uint64_t result = _CFHTTPServerCreateSelfSignedIdentity(@"CFNetwork Self Signed Certificate");
  HTTPServer::copyServerTrustChain(void)::sOnceIdentity = result;
  return result;
}

void HTTPServer::releaseSelf(HTTPServer *this)
{
}

CFTypeRef HTTPServer::retainSelf(HTTPServer *this)
{
  return CFRetain((char *)this - 16);
}

void HTTPServer::connectionClosed(uint64_t a1, const void *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 160);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 160));
  CFArrayRef v5 = *(const __CFArray **)(a1 + 232);
  v9.length = CFArrayGetCount(v5);
  v9.location = 0;
  CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v5, v9, a2);
  if (FirstIndexOfValue == -1)
  {
    pthread_mutex_unlock(v4);
  }
  else
  {
    CFIndex v7 = FirstIndexOfValue;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 240), a2);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 232), v7);
    pthread_mutex_unlock(v4);
    HTTPServerBase::signal((NSObject **)(a1 + 8));
  }
}

CFStringRef HTTPServer::copyDebugDesc(HTTPServer *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFStringRef v2 = CFObject::copyDebugDescHeader(this);
  CFStringRef v3 = HTTPServerBase::copyBaseDescription((HTTPServer *)((char *)this + 8));
  CFAllocatorRef v4 = CFGetAllocator((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 160));
  int Count = CFArrayGetCount(*((CFArrayRef *)this + 28));
  int v6 = CFArrayGetCount(*((CFArrayRef *)this + 29));
  int v7 = CFArrayGetCount(*((CFArrayRef *)this + 30));
  snprintf(__str, 0xFFuLL, "%d pending, %d outstanding, %d closed", Count, v6, v7);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 160));
  CFStringRef v8 = CFStringCreateWithFormat(v4, 0, @"%@ { queues=%s, %@ }", v2, __str, v3);
  if (v3) {
    CFRelease(v3);
  }
  if (v2) {
    CFRelease(v2);
  }
  return v8;
}

void ___ZN10HTTPServer5ClassEv_block_invoke()
{
}

void sub_18429965C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t HTTPServer::HTTPServer(uint64_t a1, const void *a2, NSObject *a3)
{
  *(void *)a1 = &unk_1ECFA5A48;
  HTTPServerBase::HTTPServerBase(a1 + 8, a2, a3);
  *(void *)a1 = &unk_1ECF9A738;
  *(void *)(a1 + 8) = &unk_1ECF9A7E0;
  *(void *)(a1 + 56) = &unk_1ECF9A848;
  *(void *)(a1 + 152) = &unk_1ECF9C6A8;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 160), 0);
  *(void *)(a1 + 152) = &unk_1ECFA5CA8;
  *(void *)(a1 + 2CFRelease((char *)this - 24) = CFArrayCreateMutable((CFAllocatorRef)a2, 0, MEMORY[0x1E4F1D510]);
  *(void *)(a1 + 232) = CFArrayCreateMutable((CFAllocatorRef)a2, 0, MEMORY[0x1E4F1D510]);
  *(void *)(a1 + 240) = CFArrayCreateMutable((CFAllocatorRef)a2, 0, MEMORY[0x1E4F1D510]);
  return a1;
}

void sub_1842997D0(_Unwind_Exception *a1)
{
  CFRelease(*(CFTypeRef *)(v2 + 232));
  CFRelease(*(CFTypeRef *)(v2 + 224));
  *CFArrayRef v5 = v3;
  pthread_mutex_destroy(v4);
  HTTPServerBase::~HTTPServerBase(v1);
  _Unwind_Resume(a1);
}

void HTTPServer::~HTTPServer(HTTPServer *this)
{
  *(void *)this = &unk_1ECF9A738;
  uint64_t v2 = (HTTPServer *)((char *)this + 8);
  *((void *)this + 1) = &unk_1ECF9A7E0;
  *((void *)this + 7) = &unk_1ECF9A848;
  uint64_t v3 = (const void *)*((void *)this + 31);
  if (v3) {
    CFRelease(v3);
  }
  CFAllocatorRef v4 = (const void *)*((void *)this + 32);
  if (v4) {
    CFRelease(v4);
  }
  HTTPServer::State::~State((HTTPServer *)((char *)this + 152));
  HTTPServerBase::~HTTPServerBase(v2);
}

void sub_1842998C8(_Unwind_Exception *a1)
{
  HTTPServer::State::~State((HTTPServer::State *)(v1 + 152));
  HTTPServerBase::~HTTPServerBase(v2);
  _Unwind_Resume(a1);
}

void HTTPServer::initialize(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  HTTPServerClientOwning::setServerClient(a1 + 8, a2, 0);
  uint64_t v5 = *a3;
  if (*a3 == 1)
  {
    long long v6 = *(_OWORD *)a3;
    long long v7 = *((_OWORD *)a3 + 1);
    *(void *)(a1 + 144) = a3[4];
    *(_OWORD *)(a1 + 112) = v6;
    *(_OWORD *)(a1 + 128) = v7;
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    int v8 = 134217984;
    uint64_t v9 = v5;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Unknown delegate version %ld", (uint8_t *)&v8, 0xCu);
  }
}

uint64_t HTTPServer::newConnectionWithStreams(NSObject **this, __CFReadStream *a2, __CFWriteStream *a3)
{
  long long v6 = this - 2;
  CFGetAllocator(this - 2);
  uint64_t result = ((uint64_t (*)(NSObject **, __CFReadStream *, __CFWriteStream *))(*this)[16].isa)(this, a2, a3);
  if (result)
  {
    if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
      dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
    }
    Instance = (_OWORD *)_CFRuntimeCreateInstance();
    uint64_t v9 = Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      uint64_t v9 = Instance + 1;
      Instance[18] = 0u;
      Instance[19] = 0u;
      Instance[16] = 0u;
      Instance[17] = 0u;
      Instance[14] = 0u;
      Instance[15] = 0u;
      Instance[12] = 0u;
      Instance[13] = 0u;
      Instance[10] = 0u;
      Instance[11] = 0u;
      Instance[8] = 0u;
      Instance[9] = 0u;
      Instance[6] = 0u;
      Instance[7] = 0u;
      Instance[4] = 0u;
      Instance[5] = 0u;
      Instance[2] = 0u;
      Instance[3] = 0u;
    }
    void *v9 = &unk_1ECFA5A48;
    CFAllocatorRef v10 = CFGetAllocator(v6);
    HTTPServerBase::HTTPServerBase((uint64_t)(v9 + 1), v10, this[11]);
    void *v9 = &unk_1ECFA1380;
    v9[1] = &unk_1ECFA1410;
    v9[7] = &unk_1ECFA1478;
    v9[35] = 0;
    v9[36] = 0;
    v9[20] = this;
    CFRetain(v6);
    if (a2) {
      uint64_t v11 = (__CFReadStream *)CFRetain(a2);
    }
    else {
      uint64_t v11 = 0;
    }
    v9[22] = v11;
    if (a3)
    {
      CFTypeRef v12 = CFRetain(a3);
      uint64_t v11 = (__CFReadStream *)v9[22];
    }
    else
    {
      CFTypeRef v12 = 0;
    }
    v9[23] = v12;
    clientContext.version = 0;
    clientContext.info = v9;
    clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
    clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
    CFReadStreamSetClient(v11, 0x1BuLL, (CFReadStreamClientCallBack)_readStreamCallback, &clientContext);
    CFWriteStreamSetClient((CFWriteStreamRef)v9[23], 0x1DuLL, (CFWriteStreamClientCallBack)_writeStreamCallback, &clientContext);
    unsigned int v13 = *((_DWORD *)this + 18);
    if (v13 < 2 || v13 == 2 && this[11] && LODWORD(this[12][5].isa))
    {
      pthread_mutex_lock((pthread_mutex_t *)(this + 20));
      CFArrayAppendValue((CFMutableArrayRef)this[28], v9 - 2);
      pthread_mutex_unlock((pthread_mutex_t *)(this + 20));
      HTTPServerBase::signal(this + 1);
    }
    else
    {
      clientContext.version = MEMORY[0x1E4F143A8];
      clientContext.info = (void *)3221225472;
      clientContext.retain = (void *(__cdecl *)(void *))___ZN20HTTPServerConnection7abandonEv_block_invoke;
      clientContext.release = (void (__cdecl *)(void *))&__block_descriptor_40_e5_v8__0l;
      clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))v9;
      HTTPServerBase::withWorkQueue(v9 + 1, &clientContext);
    }
    CFRelease(v9 - 2);
    return 1;
  }
  return result;
}

void sub_184299CBC(_Unwind_Exception *a1)
{
  HTTPServerBase::~HTTPServerBase(v1);
  _Unwind_Resume(a1);
}

void HTTPServer::newConnection(NSObject **this, int a2)
{
  CFWriteStreamRef v8 = 0;
  CFReadStreamRef stream = 0;
  CFAllocatorRef v4 = CFGetAllocator(this - 2);
  _CFStreamCreatePairWithNativeSocket(v4, a2, &stream, &v8);
  uint64_t v5 = (CFTypeRef *)MEMORY[0x1E4F1CFC8];
  long long v6 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
  if (stream)
  {
    CFReadStreamSetProperty(stream, @"kCFStreamPropertyAutoErrorOnSystemChange", (CFTypeRef)*MEMORY[0x1E4F1CFC8]);
    CFReadStreamSetProperty(stream, @"kCFStreamPropertyShouldCloseNativeSocket", *v6);
  }
  if (v8)
  {
    CFWriteStreamSetProperty(v8, @"kCFStreamPropertyAutoErrorOnSystemChange", *v5);
    CFWriteStreamSetProperty(v8, @"kCFStreamPropertyShouldCloseNativeSocket", *v6);
    long long v7 = stream;
    if (!stream || !v8) {
      goto LABEL_8;
    }
    if (HTTPServer::newConnectionWithStreams(this, stream, v8)) {
      goto LABEL_12;
    }
  }
  long long v7 = stream;
LABEL_8:
  if (v7) {
    CFReadStreamClose(v7);
  }
  if (v8) {
    CFWriteStreamClose(v8);
  }
LABEL_12:
  if (stream) {
    CFRelease(stream);
  }
  if (v8) {
    CFRelease(v8);
  }
}

void non-virtual thunk to'RequestBodyData::~RequestBodyData(RequestBodyData *this)
{
  RequestBodyData::~RequestBodyData((RequestBody *)((char *)this - 24));

  JUMPOUT(0x18531B6D0);
}

{
  RequestBodyData::~RequestBodyData((RequestBody *)((char *)this - 24));
}

void RequestBodyData::~RequestBodyData(RequestBody *this)
{
  *(void *)this = &unk_1ECF9D900;
  *((void *)this + 3) = &unk_1ECF9D970;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }

  RequestBody::~RequestBody(this);
}

{
  uint64_t vars8;

  RequestBodyData::~RequestBodyData(this);

  JUMPOUT(0x18531B6D0);
}

dispatch_data_t RequestBodyData::provideData(CFDataRef *this, unint64_t a2, BOOL *a3)
{
  unint64_t v6 = CFDataGetLength(this[14]) - (void)this[12];
  *a3 = v6 <= a2;
  v15[0] = 0;
  v15[1] = v15;
  v15[2] = 0x4012000000;
  v15[3] = __Block_byref_object_copy__6;
  v15[4] = __Block_byref_object_dispose__7;
  v15[5] = &unk_18441BEED;
  CFDataRef v7 = this[14];
  CFWriteStreamRef v8 = (std::__shared_weak_count *)this[15];
  v15[6] = v7;
  unsigned int v16 = v8;
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    CFDataRef v7 = this[14];
  }
  BytePtr = CFDataGetBytePtr(v7);
  if (v6 >= a2) {
    unint64_t v6 = a2;
  }
  CFAllocatorRef v10 = (char *)this[12] + (void)BytePtr;
  uint64_t v11 = this[6];
  destructor[0] = MEMORY[0x1E4F143A8];
  destructor[1] = 3221225472;
  destructor[2] = ___ZN15RequestBodyData11provideDataEmRb_block_invoke;
  destructor[3] = &unk_1E5257868;
  destructor[4] = v15;
  dispatch_data_t v12 = dispatch_data_create(v10, v6, v11, destructor);
  RequestBody::_onqueue_updateUploadStatus((RequestBody *)this, v6, *a3);
  _Block_object_dispose(v15, 8);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  return v12;
}

void sub_18429A004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22)
{
  if (a22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a22);
  }
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__6(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void ___ZN15RequestBodyData11provideDataEmRb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 56);
  *(void *)(v1 + 48) = 0;
  *(void *)(v1 + 56) = 0;
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

uint64_t RequestBodyData::canProvideData(RequestBodyData *this)
{
  return 1;
}

uint64_t RequestBodyData::errorEncountered(RequestBodyData *this)
{
  return 0;
}

CFIndex RequestBodyData::getExpectedLength(CFDataRef *this)
{
  return CFDataGetLength(this[14]);
}

void RequestBodyData::updateScheduling(RequestBody *this, const CoreSchedulingSet *a2)
{
}

void RequestBodyData::_provideRequestBodyFromData(RequestBodyData *this)
{
  if (*((void *)this + 10)
    && (*(unsigned int (**)(RequestBodyData *))(*(void *)this + 48))(this)
    && !*((unsigned char *)this + 104))
  {
    CFDataRef v2 = (const __CFData *)*((void *)this + 14);
    if (!v2) {
      __assert_rtn("_provideRequestBodyFromData", "HTTPRequestBody.cpp", 269, "_data");
    }
    if ((*((void *)this + 12) & 0x8000000000000000) != 0) {
      __assert_rtn("_provideRequestBodyFromData", "HTTPRequestBody.cpp", 270, "_totalBytesSent >= 0");
    }
    CFIndex Length = CFDataGetLength(v2);
    unint64_t v4 = *((void *)this + 11);
    unint64_t v5 = Length - *((void *)this + 12);
    if (v4 >= v5) {
      size_t v6 = Length - *((void *)this + 12);
    }
    else {
      size_t v6 = *((void *)this + 11);
    }
    BOOL v8 = v5 <= v4 || v6 == 0;
    if (v6)
    {
      uint64_t v20 = 0;
      uint64_t v21 = (std::__shared_weak_count *)&v20;
      uint64_t v22 = 0x4012000000;
      uint64_t v23 = __Block_byref_object_copy__6;
      BOOL v24 = __Block_byref_object_dispose__7;
      uint64_t v25 = &unk_18441BEED;
      CFDataRef v9 = (const __CFData *)*((void *)this + 14);
      CFAllocatorRef v10 = (std::__shared_weak_count *)*((void *)this + 15);
      CFDataRef v26 = v9;
      double v27 = v10;
      if (v10)
      {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        CFDataRef v9 = (const __CFData *)*((void *)this + 14);
      }
      uint64_t v11 = &CFDataGetBytePtr(v9)[*((void *)this + 12)];
      dispatch_data_t v12 = *((void *)this + 6);
      destructor[0] = MEMORY[0x1E4F143A8];
      destructor[1] = 3221225472;
      destructor[2] = ___ZN15RequestBodyData27_provideRequestBodyFromDataEv_block_invoke;
      destructor[3] = &unk_1E5257868;
      destructor[4] = &v20;
      unsigned int v13 = dispatch_data_create(v11, v6, v12, destructor);
      _Block_object_dispose(&v20, 8);
      if (v27) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v27);
      }
    }
    else
    {
      unsigned int v13 = 0;
    }
    (*(void (**)(void))(*((void *)this + 10) + 16))();
    RequestBody::_onqueue_updateUploadStatus((RequestBody *)this, v6, v8);
    if (v13) {
      dispatch_release(v13);
    }
    if (v8)
    {
      *((unsigned char *)this + 104) = 1;
    }
    else
    {
      std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v20, *((void *)this + 1), *((std::__shared_weak_count **)this + 2));
      uint64_t v15 = v20;
      uint64_t v14 = v21;
      if (v21)
      {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        if (v21) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v21);
        }
      }
      unsigned int v16 = *((void *)this + 6);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3321888768;
      block[2] = ___ZN15RequestBodyData27_provideRequestBodyFromDataEv_block_invoke_2;
      block[3] = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15RequestBodyDataEE_e5_v8__0l;
      block[4] = v15;
      CFRange v18 = v14;
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      dispatch_async(v16, block);
      if (v18) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v18);
      }
      if (v14) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v14);
      }
    }
  }
}

void sub_18429A3B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28)
{
  if (a28) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a28);
  }
  _Unwind_Resume(a1);
}

void ___ZN15RequestBodyData27_provideRequestBodyFromDataEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8);
  CFDataRef v2 = *(std::__shared_weak_count **)(v1 + 56);
  *(void *)(v1 + 48) = 0;
  *(void *)(v1 + 56) = 0;
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

uint64_t ___ZN15RequestBodyData27_provideRequestBodyFromDataEv_block_invoke_2(uint64_t a1)
{
  return RequestBodyData::_provideRequestBodyFromData(*(RequestBodyData **)(a1 + 32));
}

void __destroy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrI15RequestBodyDataEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrI15RequestBodyDataEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t RequestBodyData::copyProperty(RequestBodyData *this, const __CFString *a2)
{
  return 0;
}

void RequestBodyData::bodyStopProvidingData(RequestBodyData *this)
{
  uint64_t v1 = *((void *)this + 10);
  if (!v1) {
    __assert_rtn("bodyStopProvidingData", "HTTPRequestBody.cpp", 214, "_cb");
  }
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x3052000000;
  v4[3] = __Block_byref_object_copy__16337;
  v4[4] = __Block_byref_object_dispose__16338;
  v4[5] = v1;
  *((void *)this + 10) = 0;
  uint64_t v2 = *((void *)this + 6);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN15RequestBodyData21bodyStopProvidingDataEv_block_invoke;
  block[3] = &unk_1E5257868;
  block[4] = v4;
  dispatch_async(v2, block);
  _Block_object_dispose(v4, 8);
}

void __Block_byref_object_copy__16337(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__16338(uint64_t a1)
{
}

void ___ZN15RequestBodyData21bodyStopProvidingDataEv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = 0;
}

void RequestBodyData::bodyStartProvidingData(RequestBodyData *a1, void *aBlock)
{
  if (*((void *)a1 + 10)) {
    __assert_rtn("bodyStartProvidingData", "HTTPRequestBody.cpp", 201, "!_cb");
  }
  *((void *)a1 + 10) = _Block_copy(aBlock);

  RequestBodyData::_provideRequestBodyFromData(a1);
}

void non-virtual thunk to'RequestBodyStream::~RequestBodyStream(RequestBodyStream *this)
{
  RequestBodyStream::~RequestBodyStream((RequestBodyStream *)((char *)this - 24));

  JUMPOUT(0x18531B6D0);
}

{
  RequestBodyStream::~RequestBodyStream((RequestBodyStream *)((char *)this - 24));
}

uint64_t RequestBodyStream::copyProperty(RequestBodyStream *this, const __CFString *a2)
{
  uint64_t v7 = 0;
  BOOL v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  if (a2 && (uint64_t v2 = *((void *)this + 15)) != 0)
  {
    uint64_t v3 = *((void *)this + 17);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = ___ZN17RequestBodyStream12copyPropertyEPK10__CFString_block_invoke;
    v6[3] = &unk_1E5257A50;
    v6[4] = &v7;
    v6[5] = v2;
    void v6[6] = a2;
    (*(void (**)(uint64_t, void *))(*(void *)v3 + 104))(v3, v6);
    uint64_t v4 = v8[3];
  }
  else
  {
    uint64_t v4 = 0;
  }
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_18429A73C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

CFTypeRef ___ZN17RequestBodyStream12copyPropertyEPK10__CFString_block_invoke(uint64_t a1)
{
  CFTypeRef result = CFReadStreamCopyProperty(*(CFReadStreamRef *)(a1 + 40), *(CFStreamPropertyKey *)(a1 + 48));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = result;
  return result;
}

uint64_t RequestBodyData::RequestBodyData(uint64_t a1, uint64_t *a2, dispatch_object_t object, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = (void *)RequestBody::RequestBody(a1, object, a4, a5);
  *uint64_t v7 = &unk_1ECF9D900;
  v7[3] = &unk_1ECF9D970;
  v7[14] = 0;
  v7[15] = 0;
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (v9)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 120);
    *(void *)(a1 + 112) = v8;
    *(void *)(a1 + 120) = v9;
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    }
  }
  else
  {
    *(void *)(a1 + 112) = v8;
    *(void *)(a1 + 120) = 0;
  }
  return a1;
}

void HTTPServerBase::setProperty(HTTPServerBase *this, const __CFString *key, const void *value)
{
  Mutable = (__CFDictionary *)*((void *)this + 9);
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 7), 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    *((void *)this + 9) = Mutable;
  }

  CFDictionarySetValue(Mutable, key, value);
}

CFTypeRef HTTPServerBase::copyProperty(HTTPServerBase *this, const __CFString *a2)
{
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 9);
  if (!v2) {
    return 0;
  }
  Value = CFDictionaryGetValue(v2, a2);
  if (!Value) {
    return 0;
  }

  return CFRetain(Value);
}

uint64_t HTTPServerBase::HTTPServerBase(uint64_t a1, CFTypeRef cf, NSObject *a3)
{
  *(_OWORD *)(a1 + CFRelease((char *)this - 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)a1 = &unk_1ECF9CCF8;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = &unk_1ECF9CD60;
  if (cf) {
    CFTypeRef v5 = CFRetain(cf);
  }
  else {
    CFTypeRef v5 = 0;
  }
  *(void *)(a1 + 56) = v5;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 80) = a3;
  dispatch_retain(a3);
  *(void *)(a1 + 88) = CoreSchedulingSet::createEmpty(v6);
  *(_DWORD *)(a1 + 64) = 1;
  return a1;
}

void sub_18429A9E0(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void HTTPServerBase::~HTTPServerBase(HTTPServerBase *this)
{
  *(void *)this = &unk_1ECF9CCF8;
  *((void *)this + 6) = &unk_1ECF9CD60;
  HTTPServerClientOwning::setServerClient((uint64_t)this, 0, *((_DWORD **)this + 11));
  CFDictionaryRef v2 = (const void *)*((void *)this + 9);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((void *)this + 10);
  if (v3)
  {
    dispatch_release(v3);
    *((void *)this + 10) = 0;
  }
  uint64_t v4 = *((void *)this + 11);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
  }
  CFTypeRef v5 = (const void *)*((void *)this + 12);
  if (v5) {
    CFRelease(v5);
  }
  *((void *)this + 6) = &unk_1ECF9B550;
}

void sub_18429AADC(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void HTTPServerBase::schedule(uint64_t a1, NSObject *a2)
{
  if (*(int *)(a1 + 64) <= 2)
  {
    Empty = *(CFAllocatedReferenceCountedObject **)(a1 + 88);
    int v5 = *((_DWORD *)Empty + 10);
    if ((v5 - 1) < 2)
    {
      if (a2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "can't be both queue and runloop based", buf, 2u);
      }
      goto LABEL_16;
    }
    if (v5 == 3)
    {
      if (!a2)
      {
        uint64_t v7 = (CoreSchedulingSet *)(*(uint64_t (**)(void))(*(void *)Empty + 48))(*(void *)(a1 + 88));
        Empty = (CFAllocatedReferenceCountedObject *)CoreSchedulingSet::createEmpty(v7);
        goto LABEL_16;
      }
      if (*((NSObject **)Empty + 7) == a2)
      {
LABEL_16:
        *(void *)(a1 + 88) = Empty;
        *(_DWORD *)(a1 + 64) = 2;
        (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
        uint64_t v8 = *(NSObject **)(a1 + 80);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = ___ZN14HTTPServerBase8scheduleEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = a1;
        dispatch_async(v8, block);
        return;
      }
    }
    else
    {
      if (v5) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = a2 == 0;
      }
      if (v6) {
        goto LABEL_16;
      }
    }
    (*(void (**)(void))(*(void *)Empty + 48))(*(void *)(a1 + 88));
    Empty = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 96, 0);
    *(_OWORD *)Empty = 0u;
    *((_OWORD *)Empty + 1) = 0u;
    *((_OWORD *)Empty + 2) = 0u;
    *((_OWORD *)Empty + 3) = 0u;
    *((_OWORD *)Empty + 4) = 0u;
    *((_OWORD *)Empty + 5) = 0u;
    QCoreSchedulingSet::QCoreSchedulingSet(Empty, a2);
    goto LABEL_16;
  }
}

uint64_t ___ZN14HTTPServerBase8scheduleEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  (*(void (**)(uint64_t))(*(void *)v1 + 32))(v1);
  CFDictionaryRef v2 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 80);

  return v2(v1);
}

void HTTPServerBase::schedule(HTTPServerBase *this, __CFRunLoop *a2, const __CFString *a3)
{
  if (*((int *)this + 16) <= 2)
  {
    *((void *)this + 11) = (*(uint64_t (**)(void, __CFRunLoop *, const __CFString *))(**((void **)this + 11)
                                                                                                  + 56))(*((void *)this + 11), a2, a3);
    *((_DWORD *)this + CFRelease((char *)this - 16) = 2;
    (*(void (**)(HTTPServerBase *))(*(void *)this + 72))(this);
    uint64_t v4 = *((void *)this + 10);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZN14HTTPServerBase8scheduleEP11__CFRunLoopPK10__CFString_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_async(v4, block);
  }
}

uint64_t ___ZN14HTTPServerBase8scheduleEP11__CFRunLoopPK10__CFString_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  (*(void (**)(uint64_t))(*(void *)v1 + 32))(v1);
  CFDictionaryRef v2 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 80);

  return v2(v1);
}

void HTTPServerBase::signal(NSObject **this)
{
  if (this[10])
  {
    if (*((int *)this + 16) <= 4)
    {
      ((void (*)(NSObject **))(*this)[9].isa)(this);
      CFDictionaryRef v2 = this[10];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZN14HTTPServerBase6signalEv_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = this;
      dispatch_async(v2, block);
    }
  }
}

uint64_t ___ZN14HTTPServerBase6signalEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  (*(void (**)(uint64_t))(*(void *)v1 + 40))(v1);
  CFDictionaryRef v2 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 80);

  return v2(v1);
}

uint64_t HTTPServerBase::withClientAsync(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[11];
  if (v3 && *(_DWORD *)(v3 + 40))
  {
    (*(void (**)(void *))(*a1 + 72))(a1);
    uint64_t v5 = a1[11];
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    v8[2] = ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke;
    v8[3] = &unk_1E5257C58;
    v8[4] = a2;
    v8[5] = a1;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)v5 + 96))(v5, v8);
  }
  else
  {
    uint64_t v7 = *(uint64_t (**)(uint64_t, void))(a2 + 16);
    return v7(a2, 0);
  }
}

void ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke(uint64_t a1)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke_2;
  v4[3] = &unk_1E5256CE8;
  uint64_t v1 = *(void **)(a1 + 40);
  v4[4] = *(void *)(a1 + 32);
  HTTPServerClientOwning::withServerClient(v1, (uint64_t)v4);
  CFDictionaryRef v2 = v1[10];
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke_3;
  v3[3] = &__block_descriptor_40_e5_v8__0l;
  v3[4] = v1;
  dispatch_async(v2, v3);
}

uint64_t ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t ___ZN14HTTPServerBase15withClientAsyncEU13block_pointerFvPvE_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 80))();
}

void HTTPServerBase::becomeErrored_onQueue(HTTPServerBase *this, CFTypeRef cf)
{
  if (*((int *)this + 16) <= 3)
  {
    *((_DWORD *)this + CFRelease((char *)this - 16) = 4;
    if (cf) {
      CFTypeRef v3 = CFRetain(cf);
    }
    else {
      CFTypeRef v3 = 0;
    }
    *((void *)this + 12) = v3;
  }

  HTTPServerBase::signal((NSObject **)this);
}

void HTTPServerBase::deliverTerminalEvent_onQueue(HTTPServerBase *this)
{
  int v1 = *((_DWORD *)this + 16);
  if (v1 <= 4)
  {
    *((_DWORD *)this + CFRelease((char *)this - 16) = 5;
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = ___ZN14HTTPServerBase28deliverTerminalEvent_onQueueEv_block_invoke;
    v5[3] = &__block_descriptor_44_e9_v16__0_v8l;
    v5[4] = this;
    int v6 = v1;
    HTTPServerBase::withClientAsync(this, (uint64_t)v5);
    (*(void (**)(HTTPServerBase *))(*(void *)this + 72))(this);
    CFTypeRef v3 = *((void *)this + 10);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZN14HTTPServerBase28deliverTerminalEvent_onQueueEv_block_invoke_2;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_async(v3, block);
  }
}

void *___ZN14HTTPServerBase28deliverTerminalEvent_onQueueEv_block_invoke(void *result, uint64_t a2)
{
  if (a2)
  {
    CFDictionaryRef v2 = result;
    CFTypeRef result = (void *)result[4];
    int v3 = *((_DWORD *)v2 + 10);
    if (v3 == 4)
    {
      return (void *)(*(uint64_t (**)(void))(*result + 64))();
    }
    else if (v3 <= 3)
    {
      return (void *)(*(uint64_t (**)(void))(*result + 56))();
    }
  }
  return result;
}

uint64_t ___ZN14HTTPServerBase28deliverTerminalEvent_onQueueEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  (*(void (**)(uint64_t))(*(void *)v1 + 48))(v1);
  CFDictionaryRef v2 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 80);

  return v2(v1);
}

CFStringRef HTTPServerBase::copyBaseDescription(HTTPServerBase *this)
{
  uint64_t v1 = *((void *)this + 10);
  CFDictionaryRef v2 = "no";
  if (v1 && *(_DWORD *)(*((void *)this + 11) + 40)) {
    CFDictionaryRef v2 = "yes";
  }
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"valid=%s, ss=%@", v2, v1);
}

void HTTPServerBase::withWorkQueue(void *a1, void *aBlock)
{
  int v3 = _Block_copy(aBlock);
  (*(void (**)(void *))(*a1 + 72))(a1);
  uint64_t v4 = a1[10];
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN14HTTPServerBase13withWorkQueueEU13block_pointerFvvE_block_invoke;
  v5[3] = &unk_1E5257C58;
  v5[4] = v3;
  void v5[5] = a1;
  dispatch_async(v4, v5);
}

uint64_t ___ZN14HTTPServerBase13withWorkQueueEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  _Block_release(*(const void **)(a1 + 32));
  int v3 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 80);

  return v3(v2);
}

void HTTPServerBase::releaseOnCapturedQueue(uint64_t a1, NSObject *a2, void *aBlock)
{
  if (aBlock) {
    uint64_t v5 = _Block_copy(aBlock);
  }
  else {
    uint64_t v5 = 0;
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN14HTTPServerBase22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  v6[3] = &unk_1E5257C58;
  v6[4] = v5;
  v6[5] = a1;
  dispatch_async(a2, v6);
}

uint64_t ___ZN14HTTPServerBase22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v4 = a1 + 32;
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v4 + 8);
  if (v2)
  {
    (*(void (**)(void))(v2 + 16))();
    _Block_release(*(const void **)(a1 + 32));
  }
  uint64_t v5 = *(uint64_t (**)(uint64_t))(*(void *)v3 + 80);

  return v5(v3);
}

void HTTPServerConnection::RRQueue::~RRQueue(HTTPServerConnection::RRQueue *this)
{
  HTTPServerConnection::RRQueue::~RRQueue(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)this = &unk_1ECFA5E50;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    CFRelease((CFTypeRef)(v2 - 16));
  }
  CFAllocatorRef v3 = *((void *)this + 3);
  if (v3) {
    CFRelease((CFTypeRef)(v3 - 16));
  }
}

void HTTPServerConnection::PendingQueue::~PendingQueue(HTTPServerConnection::PendingQueue *this)
{
  *(void *)this = &unk_1ECFA5DF0;
  *((void *)this + 4) = 0;
  HTTPServerConnection::RRQueue::~RRQueue(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  *(void *)this = &unk_1ECFA5DF0;
  *((void *)this + 4) = 0;
  HTTPServerConnection::RRQueue::~RRQueue(this);
}

void HTTPServerConnection::ActiveResponseInfo::~ActiveResponseInfo(HTTPServerConnection::ActiveResponseInfo *this)
{
  HTTPServerConnection::ActiveResponseInfo::~ActiveResponseInfo(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  __CFReadStream *v2;
  HTTPServerRequest *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t vars8;

  *(void *)this = &unk_1ECFA5E30;
  uint64_t v2 = (__CFReadStream *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 4) = 0;
    if (*((unsigned char *)this + 40))
    {
      CFReadStreamSetClient(v2, 0, 0, 0);
      CFReadStreamClose(v2);
      *((unsigned char *)this + 40) = 0;
    }
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (HTTPServerRequest *)*((void *)this + 2);
  if (v3)
  {
    HTTPServerRequest::loseConnectionReferenceAndTerminateReads(v3);
    uint64_t v4 = *((void *)this + 2);
    if (v4)
    {
      CFRelease((CFTypeRef)(v4 - 16));
      *((void *)this + 2) = 0;
    }
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5)
  {
    CFRelease((CFTypeRef)(v5 - 16));
    *((void *)this + 3) = 0;
  }

  HTTPServerConnection::RRQueue::~RRQueue(this);
}

void sub_18429B8F0(_Unwind_Exception *a1)
{
  HTTPServerConnection::RRQueue::~RRQueue(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTPServerConnection::~HTTPServerConnection(HTTPServerConnection *this)
{
}

{
  HTTPServerConnection::~HTTPServerConnection((HTTPServerConnection *)((char *)this - 56));
}

{
  HTTPServerConnection::~HTTPServerConnection((HTTPServerConnection *)((char *)this - 8));
}

{
  HTTPServerConnection::~HTTPServerConnection((HTTPServerConnection *)((char *)this - 8));
}

void HTTPServerConnection::~HTTPServerConnection(HTTPServerConnection *this)
{
  *(void *)this = &unk_1ECFA1380;
  *((void *)this + 1) = &unk_1ECFA1410;
  *((void *)this + 7) = &unk_1ECFA1478;
  if (*((void *)this + 22))
  {
    uint64_t v1 = "fSocketReadStream == NULL";
    int v2 = 216;
    goto LABEL_6;
  }
  if (*((void *)this + 23))
  {
    uint64_t v1 = "fSocketWriteStream == NULL";
    int v2 = 217;
LABEL_6:
    __assert_rtn("~HTTPServerConnection", "HTTPServerConnection.cpp", v2, v1);
  }
  HTTPServerBase::~HTTPServerBase((HTTPServerConnection *)((char *)this + 8));
}

void sub_18429B9E0(_Unwind_Exception *a1)
{
  HTTPServerBase::~HTTPServerBase(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTPServerConnection::releaseSelf(HTTPServerConnection *this)
{
}

CFTypeRef non-virtual thunk to'HTTPServerConnection::retainSelf(HTTPServerConnection *this)
{
  return CFRetain((char *)this - 24);
}

uint64_t non-virtual thunk to'HTTPServerConnection::errorClient(uint64_t this, void *a2, __CFError *a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(void *, __CFError *))(this + 120);
  if (v3)
  {
    *(void *)(this + 120) = 0;
    return v3(a2, a3);
  }
  return this;
}

uint64_t non-virtual thunk to'HTTPServerConnection::invalidateClient(uint64_t this, void *a2)
{
  int v2 = *(uint64_t (**)(void *))(this + 112);
  if (v2)
  {
    *(void *)(this + 112) = 0;
    return v2(a2);
  }
  return this;
}

void non-virtual thunk to'HTTPServerConnection::canceled_onQueue(dispatch_queue_t *this)
{
}

void HTTPServerConnection::canceled_onQueue(dispatch_queue_t *this)
{
  HTTPServerConnection::closeStreamsAndCleanupRequests_onQueue(this);
  dispatch_queue_t v2 = this[20];
  if (v2)
  {
    (*((void (**)(dispatch_queue_t, char *))v2->isa + 7))(v2, (char *)this - 16);
    CFRelease(&this[20][-2]);
    this[20] = 0;
  }
}

void HTTPServerConnection::closeStreamsAndCleanupRequests_onQueue(dispatch_queue_t *this)
{
  if (this[22]) {
    HTTPServerConnection::closeReadSocketSide_onQueue(this);
  }
  if (this[23]) {
    HTTPServerConnection::closeWriteSocketSide_onQueue(this);
  }
  dispatch_queue_t v2 = this[33];
  if (v2)
  {
    (*((void (**)(dispatch_queue_t))v2->isa + 1))(v2);
    this[33] = 0;
  }
  CFAllocatorRef v3 = (HTTPServerRequest *)this[29];
  if (v3)
  {
    HTTPServerRequest::loseConnectionReferenceAndTerminateReads(v3);
    CFRelease(&this[29][-2]);
    this[29] = 0;
  }
  if ((this[30] || this[31]) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Should be all null requests and responses now", v4, 2u);
  }
}

void HTTPServerConnection::closeReadSocketSide_onQueue(dispatch_queue_t *this)
{
  if (this[22])
  {
    HTTPServerConnection::cleanupPendingRequests_onQueue(this);
    dispatch_queue_t v2 = (__CFReadStream *)this[22];
    this[22] = 0;
    CFAllocatorRef v3 = this[35];
    if (v3)
    {
      dispatch_assert_queue_V2(v3);
      MEMORY[0x185319F20](v2, 0);
      CFReadStreamSetClient(v2, 0, 0, 0);
      CFReadStreamClose(v2);
      if (v2) {
        CFRelease(v2);
      }
      this[35] = 0;
    }
    else
    {
      CFReadStreamSetClient(v2, 0, 0, 0);
      if (v2) {
        CFRetain(v2);
      }
      uint64_t v4 = +[NSURLConnection resourceLoaderRunLoop];
      uint64_t v5 = (const void *)*MEMORY[0x1E4F1D418];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZL19forciblyCloseStreamIP14__CFReadStreamEvT__block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v2;
      CFRunLoopPerformBlock(v4, v5, block);
      CFRunLoopWakeUp(v4);
      if (v2) {
        CFRelease(v2);
      }
    }
    HTTPServerConnection::unscheduleTimer((uint64_t)this);
    if (*((int *)this + 18) <= 2) {
      *((_DWORD *)this + 18) = 3;
    }
    HTTPServerBase::signal(this + 1);
  }
}

void HTTPServerConnection::closeWriteSocketSide_onQueue(dispatch_queue_t *this)
{
  if (this[23])
  {
    HTTPServerConnection::cleanupPendingResponses_onQueue(this);
    dispatch_queue_t v2 = (__CFWriteStream *)this[23];
    this[23] = 0;
    CFAllocatorRef v3 = this[36];
    if (v3)
    {
      dispatch_assert_queue_V2(v3);
      MEMORY[0x18531A970](v2, 0);
      CFWriteStreamSetClient(v2, 0, 0, 0);
      CFWriteStreamClose(v2);
      if (v2) {
        CFRelease(v2);
      }
      this[36] = 0;
    }
    else
    {
      CFWriteStreamSetClient(v2, 0, 0, 0);
      if (v2) {
        CFRetain(v2);
      }
      uint64_t v4 = +[NSURLConnection resourceLoaderRunLoop];
      uint64_t v5 = (const void *)*MEMORY[0x1E4F1D418];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZL19forciblyCloseStreamIP15__CFWriteStreamEvT__block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v2;
      CFRunLoopPerformBlock(v4, v5, block);
      CFRunLoopWakeUp(v4);
      if (v2) {
        CFRelease(v2);
      }
    }
    HTTPServerConnection::unscheduleTimer((uint64_t)this);
    if (*((int *)this + 18) <= 2) {
      *((_DWORD *)this + 18) = 3;
    }
    HTTPServerBase::signal(this + 1);
  }
}

void HTTPServerConnection::cleanupPendingResponses_onQueue(dispatch_queue_t *this)
{
  dispatch_assert_queue_V2(this[11]);
  dispatch_queue_t isa = this[30];
  if (isa)
  {
    this[30] = 0;
    CFAllocatorRef v3 = MEMORY[0x1E4F14500];
    do
    {
      uint64_t v4 = (uint64_t *)isa;
      dispatch_queue_t isa = (dispatch_queue_t)isa[4].isa;
      v4[4] = 0;
      uint64_t v5 = v4[2];
      if (!v5)
      {
        if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)uint64_t v8 = 0;
          _os_log_fault_impl(&dword_184085000, v3, OS_LOG_TYPE_FAULT, "need  a request at least in the pending queue", v8, 2u);
          uint64_t v5 = v4[2];
        }
        else
        {
          uint64_t v5 = 0;
        }
      }
      HTTPServerConnection::sendFailedResponse((uint64_t)this, v5, v4[3]);
      HTTPServerRequest::loseConnectionReferenceAndTerminateReads((HTTPServerRequest *)v4[2]);
      (*(void (**)(uint64_t *))(*v4 + 8))(v4);
    }
    while (isa);
  }
  dispatch_queue_t v6 = this[31];
  if (v6)
  {
    HTTPServerConnection::sendFailedResponse((uint64_t)this, (uint64_t)v6[2].isa, (uint64_t)v6[3].isa);
    dispatch_queue_t v7 = this[31];
    if (v7) {
      (*((void (**)(dispatch_queue_t))v7->isa + 1))(v7);
    }
    this[31] = 0;
  }
}

void ___ZL19forciblyCloseStreamIP15__CFWriteStreamEvT__block_invoke(uint64_t a1)
{
  if (CFWriteStreamGetStatus(*(CFWriteStreamRef *)(a1 + 32)) == kCFStreamStatusOpen)
  {
    CFWriteStreamClose(*(CFWriteStreamRef *)(a1 + 32));
    dispatch_queue_t v2 = *(const void **)(a1 + 32);
    if (v2)
    {
      CFRelease(v2);
    }
  }
  else
  {
    CFAllocatorRef v3 = *(void **)(a1 + 32);
    clientContext.version = 0;
    clientContext.info = v3;
    clientContext.retain = (void *(__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP15__CFWriteStreamEvT_EUb_ENUlPvE_8__invokeES3_;
    clientContext.release = (void (__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP15__CFWriteStreamEvT_EUb_ENUlPvE0_8__invokeES3_;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP15__CFWriteStreamEvT_EUb_ENUlPvE1_8__invokeES3_;
    CFWriteStreamSetClient((CFWriteStreamRef)v3, 9uLL, (CFWriteStreamClientCallBack)_ZZZL19forciblyCloseStreamIP15__CFWriteStreamEvT_EUb_ENUlS1_mPvE_8__invokeES1_mS3_, &clientContext);
    uint64_t v4 = *(__CFWriteStream **)(a1 + 32);
    Current = CFRunLoopGetCurrent();
    CFWriteStreamScheduleWithRunLoop(v4, Current, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
    CFWriteStreamOpen(*(CFWriteStreamRef *)(a1 + 32));
  }
}

uint64_t HTTPServerConnection::unscheduleTimer(uint64_t this)
{
  if (*(void *)(this + 296))
  {
    uint64_t v1 = this;
    dispatch_queue_t v2 = *(NSObject **)(this + 88);
    CFAllocatorRef v3 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 96, 0);
    *(_OWORD *)CFAllocatorRef v3 = 0u;
    *((_OWORD *)v3 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    *((_OWORD *)v3 + 5) = 0u;
    uint64_t v4 = QCoreSchedulingSet::QCoreSchedulingSet(v3, v2);
    uint64_t v5 = *(void *)(v1 + 296);
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    v8[2] = ___ZNK17CoreSchedulingSet15unscheduleTimerEP16__CFRunLoopTimer_block_invoke;
    v8[3] = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
    v8[4] = v5;
    CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)v4, v8);
    (*(void (**)(CFAllocatedReferenceCountedObject *))(*(void *)v3 + 48))(v3);
    CFRunLoopTimerInvalidate(*(CFRunLoopTimerRef *)(v1 + 296));
    dispatch_queue_t v6 = *(const void **)(v1 + 296);
    *(void *)(v1 + 296) = 0;
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(v1 + 192) = 0;
    dispatch_queue_t v7 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 120);
    return v7(v1);
  }
  return this;
}

void _ZZZL19forciblyCloseStreamIP15__CFWriteStreamEvT_EUb_ENUlS1_mPvE_8__invokeES1_mS3_(__CFWriteStream *a1)
{
  CFWriteStreamSetClient(a1, 0, 0, 0);
  Current = CFRunLoopGetCurrent();
  CFWriteStreamScheduleWithRunLoop(a1, Current, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
  CFWriteStreamClose(a1);
  if (a1)
  {
    CFRelease(a1);
  }
}

uint64_t HTTPServerConnection::sendFailedResponse(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(result + 72) == 5) {
    return result;
  }
  uint64_t v3 = result;
  if (a3)
  {
    uint64_t v4 = (const void *)(a3 - 16);
    uint64_t v5 = *(const void **)(a3 + 88);
    if (v5) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  if (a2) {
    uint64_t v5 = (const void *)(a2 - 16);
  }
  else {
    uint64_t v5 = 0;
  }
LABEL_9:
  if (*(void *)(result + 152))
  {
    (*(void (**)(uint64_t))(*(void *)(result + 8) + 72))(result + 8);
    uint64_t v6 = *(void *)(v3 + 88);
    if (v5) {
      CFRetain(v5);
    }
    if (v4) {
      CFRetain(v4);
    }
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    v7[2] = ___ZN20HTTPServerConnection18sendFailedResponseEP17HTTPServerRequestP18HTTPServerResponse_block_invoke;
    v7[3] = &unk_1E5256D58;
    v7[6] = v5;
    v7[7] = v4;
    v7[4] = v6;
    v7[5] = v3;
    return HTTPServerBase::withClientAsync((void *)(v3 + 8), (uint64_t)v7);
  }
  return result;
}

void ___ZN20HTTPServerConnection18sendFailedResponseEP17HTTPServerRequestP18HTTPServerResponse_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[5];
  if (a2)
  {
    uint64_t v4 = *(void (**)(uint64_t, void, void))(v3 + 152);
    if (v4) {
      v4(a2, a1[6], a1[7]);
    }
  }
  uint64_t v5 = a1[4];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN20HTTPServerConnection18sendFailedResponseEP17HTTPServerRequestP18HTTPServerResponse_block_invoke_2;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  long long v7 = *((_OWORD *)a1 + 3);
  HTTPServerBase::releaseOnCapturedQueue(v3 + 8, v5, v6);
}

void ___ZN20HTTPServerConnection18sendFailedResponseEP17HTTPServerRequestP18HTTPServerResponse_block_invoke_2(uint64_t a1)
{
  dispatch_queue_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3)
  {
    CFRelease(v3);
  }
}

void HTTPServerConnection::cleanupPendingRequests_onQueue(dispatch_queue_t *this)
{
  dispatch_assert_queue_V2(this[11]);
  dispatch_assert_queue_V2(this[11]);
  dispatch_queue_t v2 = this[31];
  if (!v2) {
    goto LABEL_12;
  }
  dispatch_queue_t isa = v2[2].isa;
  if (isa && (int)HTTPServerRequest::requestState(v2[2].isa) <= 2) {
    HTTPServerRequest::producerEOFEncountered(isa);
  }
  if (this[31])
  {
    for (dispatch_queue_t i = this[30]; i; dispatch_queue_t i = (dispatch_queue_t)i[4].isa)
    {
      uint64_t v5 = i[2].isa;
      if (v5 && (int)HTTPServerRequest::requestState(i[2].isa) <= 2) {
        HTTPServerRequest::producerEOFEncountered(v5);
      }
    }
  }
  else
  {
LABEL_12:
    HTTPServerConnection::checkPendingQueue(this);
  }
  uint64_t v6 = this[11];

  dispatch_assert_queue_V2(v6);
}

void ___ZL19forciblyCloseStreamIP14__CFReadStreamEvT__block_invoke(uint64_t a1)
{
  if (CFReadStreamGetStatus(*(CFReadStreamRef *)(a1 + 32)) == kCFStreamStatusOpen)
  {
    CFReadStreamClose(*(CFReadStreamRef *)(a1 + 32));
    dispatch_queue_t v2 = *(const void **)(a1 + 32);
    if (v2)
    {
      CFRelease(v2);
    }
  }
  else
  {
    uint64_t v3 = *(void **)(a1 + 32);
    clientContext.version = 0;
    clientContext.info = v3;
    clientContext.retain = (void *(__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP14__CFReadStreamEvT_EUb_ENUlPvE_8__invokeES3_;
    clientContext.release = (void (__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP14__CFReadStreamEvT_EUb_ENUlPvE0_8__invokeES3_;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))_ZZZL19forciblyCloseStreamIP14__CFReadStreamEvT_EUb_ENUlPvE1_8__invokeES3_;
    CFReadStreamSetClient((CFReadStreamRef)v3, 9uLL, (CFReadStreamClientCallBack)_ZZZL19forciblyCloseStreamIP14__CFReadStreamEvT_EUb_ENUlS1_mPvE_8__invokeES1_mS3_, &clientContext);
    uint64_t v4 = *(__CFReadStream **)(a1 + 32);
    Current = CFRunLoopGetCurrent();
    CFReadStreamScheduleWithRunLoop(v4, Current, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
    CFReadStreamOpen(*(CFReadStreamRef *)(a1 + 32));
  }
}

void _ZZZL19forciblyCloseStreamIP14__CFReadStreamEvT_EUb_ENUlS1_mPvE_8__invokeES1_mS3_(__CFReadStream *a1)
{
  CFReadStreamSetClient(a1, 0, 0, 0);
  Current = CFRunLoopGetCurrent();
  CFReadStreamScheduleWithRunLoop(a1, Current, (CFRunLoopMode)*MEMORY[0x1E4F1D418]);
  CFReadStreamClose(a1);
  if (a1)
  {
    CFRelease(a1);
  }
}

void HTTPServerConnection::checkPendingQueue(dispatch_queue_t *this)
{
  dispatch_assert_queue_V2(this[11]);
  dispatch_assert_queue_V2(this[11]);
  if (this[31]) {
    goto LABEL_2;
  }
  uint64_t v3 = this[30];
  if (!v3 || !v3[2] || !v3[3]) {
    goto LABEL_2;
  }
  uint64_t v4 = v3[4];
  v3[4] = 0;
  this[30] = v4;
  CFAllocatorRef v5 = CFGetAllocator(this - 2);
  uint64_t v6 = CFAllocatorAllocate(v5, 48, 0);
  *(_OWORD *)&v6->Class isa = 0u;
  *(_OWORD *)&v6[2].Class isa = 0u;
  *(_OWORD *)&v6[4].Class isa = 0u;
  uint64_t v8 = v3[2];
  uint64_t v7 = v3[3];
  CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)(v8 - 16));
  v6[2].Class isa = 0;
  v6[3].Class isa = 0;
  v6->Class isa = (Class)&unk_1ECFA5E30;
  v6[1].Class isa = v9;
  HTTPServerConnection::RRQueue::setRequest((uint64_t)v6, v8);
  HTTPServerConnection::RRQueue::setResponse((uint64_t)v6, v7);
  v6[4].Class isa = 0;
  LOBYTE(v6[5].isa) = 0;
  this[31] = v6;
  (*(void (**)(void *))(*v3 + 8))(v3);
  dispatch_queue_t v10 = this[31];
  dispatch_assert_queue_V2(this[11]);
  Class isa = v10[3].isa;
  if (!isa) {
    goto LABEL_16;
  }
  dispatch_data_t v12 = (const void *)*((void *)isa + 9);
  if (!v12)
  {
    v10[4].Class isa = 0;
    goto LABEL_16;
  }
  unsigned int v13 = (__CFReadStream *)CFRetain(v12);
  v10[4].Class isa = v13;
  if (!v13)
  {
LABEL_16:
    CFErrorRef v15 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"kCFHTTPServerErrorDomain", 1103, 0);
    unsigned int v16 = (__CFError *)CFAutorelease(v15);
    HTTPServerConnection::connectionError(this, v16);
    goto LABEL_2;
  }
  clientContext.version = 0;
  clientContext.info = this;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  CFReadStreamSetClient(v13, 0x1BuLL, (CFReadStreamClientCallBack)_readStreamCallback, &clientContext);
  MEMORY[0x185319F20](v10[4].isa, this[11]);
  if (!CFReadStreamOpen(v10[4].isa))
  {
    LOBYTE(v10[5].isa) = 0;
    CFErrorRef v17 = v10[4].isa;
    v10[4].Class isa = 0;
    CFReadStreamSetClient(v17, 0, 0, 0);
    if (v17) {
      CFRelease(v17);
    }
    goto LABEL_16;
  }
  LOBYTE(v10[5].isa) = 1;
  uint64_t v14 = (__CFWriteStream *)this[23];
  if (v14 && CFWriteStreamCanAcceptBytes(v14))
  {
    dispatch_assert_queue_V2(this[11]);
    HTTPServerBase::signal(this + 1);
  }
LABEL_2:
  dispatch_queue_t v2 = this[11];

  dispatch_assert_queue_V2(v2);
}

void sub_18429C898(_Unwind_Exception *a1)
{
  HTTPServerConnection::RRQueue::~RRQueue(v1);
  _Unwind_Resume(a1);
}

void HTTPServerConnection::connectionError(dispatch_queue_t *this, __CFError *a2)
{
  uint64_t v4 = (HTTPServerBase *)(this + 1);
  dispatch_assert_queue_V2(this[11]);
  HTTPServerBase::becomeErrored_onQueue(v4, a2);
  HTTPServerConnection::closeReadSocketSide_onQueue((HTTPServerConnection *)this);

  HTTPServerConnection::closeWriteSocketSide_onQueue(this);
}

void _readStreamCallback(__CFReadStream *a1, unint64_t a2, void *a3)
{
  uint64_t v3 = a3[11];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN20HTTPServerConnection27signal_connection_off_queueEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = a3;
  dispatch_async(v3, block);
}

void ___ZN20HTTPServerConnection27signal_connection_off_queueEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_queue_t v2 = (NSObject **)(v1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));

  HTTPServerBase::signal(v2);
}

void HTTPServerConnection::RRQueue::setRequest(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a2)
  {
    if (v2) {
      CFRelease((CFTypeRef)(v2 - 16));
    }
    *(void *)(a1 + CFRelease((char *)this - 16) = a2;
    if (a2)
    {
      CFRetain((CFTypeRef)(a2 - 16));
    }
  }
}

void HTTPServerConnection::RRQueue::setResponse(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2 != a2)
  {
    if (v2) {
      CFRelease((CFTypeRef)(v2 - 16));
    }
    *(void *)(a1 + CFRelease((char *)this - 24) = a2;
    if (a2)
    {
      CFRetain((CFTypeRef)(a2 - 16));
    }
  }
}

void non-virtual thunk to'HTTPServerConnection::signalled_onQueue(HTTPServerConnection *this, uint64_t a2, uint64_t a3)
{
}

void HTTPServerConnection::signalled_onQueue(HTTPServerConnection *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](this, a2, a3);
  uint64_t v129 = *MEMORY[0x1E4F143B8];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 88));
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 88));
  uint64_t v4 = *(__CFReadStream **)(v3 + 176);
  if (v4)
  {
    CFErrorRef v5 = CFReadStreamCopyError(v4);
    if (v5) {
      HTTPServerConnection::closeReadSocketSide_onQueue((dispatch_queue_t *)v3);
    }
  }
  else
  {
    CFErrorRef v5 = 0;
  }
  uint64_t v6 = *(__CFWriteStream **)(v3 + 184);
  if (v6)
  {
    CFErrorRef v7 = CFWriteStreamCopyError(v6);
    if (v7) {
      HTTPServerConnection::closeWriteSocketSide_onQueue((dispatch_queue_t *)v3);
    }
  }
  else
  {
    CFErrorRef v7 = 0;
  }
  uint64_t v8 = *(void *)(v3 + 248);
  if (v8 && (CFAllocatorRef v9 = *(__CFReadStream **)(v8 + 32)) != 0) {
    CFErrorRef v10 = CFReadStreamCopyError(v9);
  }
  else {
    CFErrorRef v10 = 0;
  }
  if (v7) {
    CFErrorRef v11 = v7;
  }
  else {
    CFErrorRef v11 = v10;
  }
  if (v5) {
    CFErrorRef v12 = v5;
  }
  else {
    CFErrorRef v12 = v11;
  }
  if (v12) {
    HTTPServerBase::becomeErrored_onQueue((HTTPServerBase *)(v3 + 8), v12);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (!*(void *)(v3 + 176))
  {
    v88 = *(__CFWriteStream **)(v3 + 184);
    if (v88)
    {
      if (CFWriteStreamCanAcceptBytes(v88))
      {
        uint64_t v89 = *(void *)(v3 + 248);
        if (!v89 || (uint64_t v90 = *(void *)(v89 + 24)) == 0 || *(unsigned char *)(v90 + 136))
        {
          uint64_t v91 = *(void *)(v3 + 240);
          if (!v91 || !*(void *)(v91 + 24)) {
            HTTPServerConnection::closeWriteSocketSide_onQueue((dispatch_queue_t *)v3);
          }
        }
      }
    }
  }
  if (*(void *)(v3 + 136))
  {
    unsigned int v13 = *(__CFReadStream **)(v3 + 176);
    if (v13)
    {
      if (CFReadStreamGetStatus(v13) == kCFStreamStatusAtEnd)
      {
        uint64_t v14 = *(void *)(v3 + 248);
        if (v14)
        {
          CFErrorRef v15 = *(HTTPServerRequest **)(v14 + 16);
          if (v15) {
            HTTPServerRequest::producerEOFEncountered(v15);
          }
        }
        HTTPServerConnection::closeReadSocketSide_onQueue((dispatch_queue_t *)v3);
      }
      unsigned int v16 = *(__CFReadStream **)(v3 + 176);
      if (v16)
      {
        if (CFReadStreamHasBytesAvailable(v16))
        {
          v127 = buffer;
          v128 = (const unsigned __int8 *)&v127;
          CFIndex v17 = CFReadStreamRead(*(CFReadStreamRef *)(v3 + 176), buffer, 36000);
          CFIndex v18 = v17;
          if (v17 < 0)
          {
            CFErrorRef v92 = CFReadStreamCopyError(*(CFReadStreamRef *)(v3 + 176));
            HTTPServerBase::becomeErrored_onQueue((HTTPServerBase *)(v3 + 8), v92);
            if (v92) {
              CFRelease(v92);
            }
          }
          else
          {
            if (v17)
            {
              HTTPServerConnection::touchTimerWatchdog((HTTPServerConnection *)v3);
              uint64_t v19 = v127;
              if (&v127[v18] > v128 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)v116 = 0;
                _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Can't seal more than we own!", v116, 2u);
                uint64_t v19 = v127;
              }
              v128 = &v19[v18];
              dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 88));
              if (v128 - v127 >= 1)
              {
                uint64_t v20 = (uint64_t *)(v3 + 240);
                CFDataRef cf = (void *)(v3 - 16);
                while (1)
                {
                  uint64_t v21 = *(void *)(v3 + 232);
                  if (!v21)
                  {
                    uint64_t v22 = *(void *)(v3 + 248);
                    if (v22
                      && (uint64_t v23 = *(HTTPServerRequest **)(v22 + 16)) != 0
                      && (int)HTTPServerRequest::requestState(v23) <= 2)
                    {
                      uint64_t v24 = *(void *)(v3 + 248);
                    }
                    else
                    {
                      uint64_t v24 = *v20;
                      if (!*v20) {
                        goto LABEL_55;
                      }
                      while (1)
                      {
                        uint64_t v25 = *(HTTPServerRequest **)(v24 + 16);
                        if (v25)
                        {
                          if ((int)HTTPServerRequest::requestState(v25) < 3) {
                            break;
                          }
                        }
                        uint64_t v24 = *(void *)(v24 + 32);
                        if (!v24) {
                          goto LABEL_55;
                        }
                      }
                    }
                    uint64_t v21 = *(void *)(v24 + 16);
                    if (!v21)
                    {
LABEL_55:
                      unsigned int v26 = *(_DWORD *)(v3 + 72);
                      if (v26 >= 2 && (v26 != 2 || !*(void *)(v3 + 88) || !*(_DWORD *)(*(void *)(v3 + 96) + 40)))
                      {
                        HTTPServerConnection::closeReadSocketSide_onQueue((dispatch_queue_t *)v3);
                        break;
                      }
                      CFGetAllocator(cf);
                      if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
                        dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_79_16410);
                      }
                      Instance = (_OWORD *)_CFRuntimeCreateInstance();
                      uint64_t v21 = (uint64_t)Instance;
                      if (Instance)
                      {
                        Instance[1] = 0u;
                        uint64_t v21 = (uint64_t)(Instance + 1);
                        Instance[14] = 0u;
                        Instance[15] = 0u;
                        Instance[12] = 0u;
                        Instance[13] = 0u;
                        Instance[10] = 0u;
                        Instance[11] = 0u;
                        Instance[8] = 0u;
                        Instance[9] = 0u;
                        Instance[6] = 0u;
                        Instance[7] = 0u;
                        Instance[4] = 0u;
                        Instance[5] = 0u;
                        Instance[2] = 0u;
                        Instance[3] = 0u;
                      }
                      HTTPServerRequest::HTTPServerRequest(v21, (NSObject **)cf);
                      *(void *)(v3 + 232) = v21;
                    }
                  }
                  switch(HTTPServerRequest::requestState((HTTPServerRequest *)v21))
                  {
                    case 0u:
                      uint64_t v28 = HTTPParser::parse(*(HTTPParser **)(v21 + 144), v127, v128 - v127);
                      int v29 = *(_DWORD *)(*(void *)(v21 + 144) + 36);
                      if (v29 == 3 || v28 < 0)
                      {
                        HTTPServerRequest::setRequestState(v21, 4);
                        goto LABEL_160;
                      }
                      uint64_t v30 = v128;
                      uint64_t v31 = &v127[v28];
                      v127 = (UInt8 *)v31;
                      if (v31 > v128 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Buffer overrun", buf, 2u);
                        uint64_t v31 = v127;
                        uint64_t v30 = v128;
                        int v29 = *(_DWORD *)(*(void *)(v21 + 144) + 36);
                      }
                      if (v30 == v31)
                      {
                        if (v29 < 2) {
                          goto LABEL_160;
                        }
                      }
                      else if (v29 <= 1 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "we have bytes pending, but the parse is not done?", buf, 2u);
                      }
                      v62 = *(CFDictionaryRef **)(v21 + 208);
                      CFAllocatorRef v63 = CFGetAllocator((CFTypeRef)(v21 - 16));
                      HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(buf, 0x11F1D2DBu);
                      CFStringRef v64 = HTTPHeaderDict::copyStringValue(v62, v63, (const HTTPHeaderKeyMixedValue *)buf);
                      *(void *)buf = &unk_1ECF9F718;
                      if (v124) {
                        CFRelease(v124);
                      }
                      if (v64)
                      {
                        uint64_t IntValue = CFStringGetIntValue(v64);
                      }
                      else
                      {
                        uint64_t v66 = *(CFDictionaryRef **)(v21 + 208);
                        CFAllocatorRef v67 = CFGetAllocator((CFTypeRef)(v21 - 16));
                        HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue(buf, 0x148233EDu);
                        CFStringRef v64 = HTTPHeaderDict::copyStringValue(v66, v67, (const HTTPHeaderKeyMixedValue *)buf);
                        *(void *)buf = &unk_1ECF9F718;
                        if (v124) {
                          CFRelease(v124);
                        }
                        if (!v64)
                        {
                          *(void *)(v21 + 168) = 0;
                          goto LABEL_159;
                        }
                        if (CFStringFind(v64, @"chunked", 1uLL).location == -1) {
                          uint64_t IntValue = 0;
                        }
                        else {
                          uint64_t IntValue = -1;
                        }
                      }
                      CFRelease(v64);
                      *(void *)(v21 + 168) = IntValue;
                      if (IntValue == -1)
                      {
                        HTTPServerRequest::setRequestState(v21, 2);
                        *(_DWORD *)(v21 + 184) = 0;
                        *(void *)(v21 + 192) = 0;
                        *(unsigned char *)(v21 + 200) = 0;
                        goto LABEL_157;
                      }
                      if (IntValue)
                      {
                        HTTPServerRequest::setRequestState(v21, 1);
LABEL_157:
                        CFAllocatorRef v68 = CFGetAllocator((CFTypeRef)(v21 - 16));
                        v69 = (char *)CFAllocatorAllocate(v68, 144, 0);
                        *((_OWORD *)v69 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
                        *((_OWORD *)v69 + 7) = 0u;
                        *((_OWORD *)v69 + 8) = 0u;
                        *((_OWORD *)v69 + 5) = 0u;
                        *((_OWORD *)v69 + 6) = 0u;
                        *((_OWORD *)v69 + 3) = 0u;
                        *((_OWORD *)v69 + 4) = 0u;
                        *((_OWORD *)v69 + 2) = 0u;
                        *(void *)v69 = &unk_1ECF9E138;
                        *((void *)v69 + HTTPServerConnection::canceled_onQueue(this - 1) = v68;
                        _CoreLockable::_CoreLockable((_CoreLockable *)(v69 + 16), 1);
                        *((void *)v69 + 2) = &unk_1ECF9B510;
                        pthread_cond_init((pthread_cond_t *)(v69 + 88), 0);
                        *(void *)v69 = &unk_1ECF9DF68;
                        *((void *)v69 + 2) = &unk_1ECF9DF88;
                        v70 = CFAllocatorAllocate(v68, 48, 0);
                        void *v70 = &unk_1ECF9C5B0;
                        v70[1] = v68;
                        v70[2] = v68;
                        v70[3] = 0;
                        v70[4] = 0;
                        v70[5] = 0;
                        *((void *)v69 + 17) = v70;
                        *(void *)(v21 + 152) = v69;
                        goto LABEL_160;
                      }
LABEL_159:
                      HTTPServerRequest::setRequestState(v21, 3);
LABEL_160:
                      uint64_t v71 = *(void *)(v21 + 152);
                      if (v71) {
                        pthread_mutex_lock((pthread_mutex_t *)(v71 + 24));
                      }
                      if (*(void *)(v21 + 176) == *(void *)(v21 + 168) && *(int *)(v21 + 160) <= 2)
                      {
                        *(_DWORD *)(v21 + 160) = 3;
                        uint64_t v72 = *(void *)(v21 + 152);
                        if (!v72)
                        {
                          *(_DWORD *)(v21 + 164) = 3;
                          goto LABEL_168;
                        }
                        pthread_cond_signal((pthread_cond_t *)(v72 + 88));
                      }
                      uint64_t v73 = *(void *)(v21 + 152);
                      *(_DWORD *)(v21 + 164) = *(_DWORD *)(v21 + 160);
                      if (v73) {
                        pthread_mutex_unlock((pthread_mutex_t *)(v73 + 24));
                      }
LABEL_168:
                      HTTPServerRequest::signalReadStreamBasedOnState((HTTPServerRequest *)v21);
                      if ((int)HTTPServerRequest::requestState((HTTPServerRequest *)v21) >= 4)
                      {
                        CFErrorRef v95 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"kCFHTTPServerErrorDomain", 1100, 0);
                        char v96 = (__CFError *)CFAutorelease(v95);
                        HTTPServerConnection::connectionError((dispatch_queue_t *)v3, v96);
                        if (v21 == *(void *)(v3 + 232)) {
                          HTTPServerConnection::closeStreamsAndCleanupRequests_onQueue((dispatch_queue_t *)v3);
                        }
                        goto LABEL_219;
                      }
                      if (v21 == *(void *)(v3 + 232)
                        && (int)HTTPServerRequest::requestState((HTTPServerRequest *)v21) >= 1)
                      {
                        *(void *)(v3 + 232) = 0;
                        CFAllocatorRef v78 = CFGetAllocator(cf);
                        v79 = CFAllocatorAllocate(v78, 40, 0);
                        v79[4] = 0;
                        *(_OWORD *)v79 = 0u;
                        *((_OWORD *)v79 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
                        uint64_t v80 = HTTPServerConnection::PendingQueue::PendingQueue(v79, v21);
                        uint64_t v81 = (void *)(v3 + 240);
                        do
                        {
                          v82 = v81;
                          uint64_t v83 = *v81;
                          uint64_t v81 = (void *)(*v81 + 32);
                        }
                        while (v83);
                        void *v82 = v80;
                        if (*(void *)(v3 + 136))
                        {
                          CFRetain((CFTypeRef)(v21 - 16));
                          uint64_t v84 = *(void *)(v21 + 232);
                          *(void *)v116 = MEMORY[0x1E4F143A8];
                          uint64_t v117 = 3221225472;
                          v118 = ___ZN20HTTPServerConnection31processAllIncomingBytes_onQueueEP21ConsumableStackBuffer_block_invoke;
                          v119 = &unk_1E5256D30;
                          uint64_t v121 = v3;
                          uint64_t v122 = v21;
                          uint64_t v120 = v84;
                          HTTPServerBase::withClientAsync((void *)(v3 + 8), (uint64_t)v116);
                        }
                        if ((int)HTTPServerRequest::requestState((HTTPServerRequest *)v21) >= 3 && *v82 == *v20) {
                          HTTPServerConnection::suspendTimeout((HTTPServerConnection *)v3);
                        }
                        CFRelease((CFTypeRef)(v21 - 16));
                        goto LABEL_193;
                      }
                      if (*v20)
                      {
                        int v74 = HTTPServerRequest::requestState((HTTPServerRequest *)v21);
                        uint64_t v75 = *(void *)(v3 + 248);
                        if (v74 >= 3)
                        {
                          if (v75) {
                            goto LABEL_188;
                          }
                          uint64_t v76 = *v20;
                          do
                          {
                            uint64_t v77 = v76;
                            uint64_t v76 = *(void *)(v76 + 32);
                          }
                          while (v76);
                          if (v21 == *(void *)(v77 + 16)) {
                            HTTPServerConnection::suspendTimeout((HTTPServerConnection *)v3);
                          }
                          goto LABEL_193;
                        }
                      }
                      else
                      {
                        uint64_t v75 = *(void *)(v3 + 248);
                      }
                      if (v75)
                      {
LABEL_188:
                        if (v21 == *(void *)(v75 + 16)
                          && (int)HTTPServerRequest::requestState((HTTPServerRequest *)v21) >= 3)
                        {
                          uint64_t v85 = *(void *)(v3 + 248);
                          uint64_t v86 = *(void *)(v85 + 24);
                          if (v86)
                          {
                            if (*(unsigned char *)(v86 + 136)
                              || (v87 = *(__CFReadStream **)(v85 + 32)) != 0
                              && CFReadStreamGetStatus(v87) == kCFStreamStatusAtEnd)
                            {
                              HTTPServerConnection::responseCompleted((HTTPServerConnection *)v3);
                            }
                          }
                        }
                      }
LABEL_193:
                      if (v128 - v127 <= 0) {
                        goto LABEL_219;
                      }
                      break;
                    case 1u:
                      v32 = v127;
                      uint64_t v34 = *(void *)(v21 + 168);
                      uint64_t v33 = *(void *)(v21 + 176);
                      uint64_t v35 = v128 - v127 + v33;
                      int64_t v36 = v34 - v33;
                      if (v35 <= v34) {
                        int64_t v37 = v128 - v127;
                      }
                      else {
                        int64_t v37 = v36;
                      }
                      uint64_t v38 = *(void *)(v21 + 152);
                      if (v38)
                      {
                        pthread_mutex_lock((pthread_mutex_t *)(v38 + 24));
                        v32 = v127;
                      }
                      HTTPServerRequest::appendToBodyDataLocked((HTTPServerRequest *)v21, v32, v37);
                      int64_t v39 = *(void *)(v21 + 176) + v37;
                      *(void *)(v21 + 176) = v39;
                      v127 += v37;
                      if (v127 > v128 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Buffer overrun", buf, 2u);
                        int64_t v39 = *(void *)(v21 + 176);
                      }
                      if (v39 == *(void *)(v21 + 168))
                      {
                        int v40 = 3;
                        *(_DWORD *)(v21 + 160) = 3;
                      }
                      else
                      {
                        int v40 = *(_DWORD *)(v21 + 160);
                      }
                      *(_DWORD *)(v21 + 164) = v40;
                      uint64_t v46 = *(void *)(v21 + 152);
                      if (v46) {
                        pthread_mutex_unlock((pthread_mutex_t *)(v46 + 24));
                      }
                      goto LABEL_160;
                    case 2u:
                      int v41 = v127;
                      CFMutableArrayRef v42 = v128;
                      uint64_t v43 = *(void *)(v21 + 152);
                      if (v43
                        || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
                        && (*(_WORD *)buf = 0,
                            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Must have a body data", buf, 2u), (uint64_t v43 = *(void *)(v21 + 152)) != 0))
                      {
                        pthread_mutex_lock((pthread_mutex_t *)(v43 + 24));
                      }
                      if (v42 - v41 < 1)
                      {
                        BOOL v48 = v41;
                      }
                      else
                      {
                        int v47 = 0;
                        BOOL v48 = v41;
                        while (2)
                        {
                          if (*(_DWORD *)(v21 + 160) == 2)
                          {
                            int v49 = *(_DWORD *)(v21 + 184);
                            switch(v49)
                            {
                              case 0:
                                __darwin_ct_rune_t v50 = *v48++;
                                int v51 = __tolower(v50);
                                if (v51 == 10) {
                                  goto LABEL_125;
                                }
                                if (v51 != 13)
                                {
                                  uint64_t v59 = 16 * *(void *)(v21 + 192);
                                  *(void *)(v21 + 192) = v59;
                                  unsigned int v60 = v51 - 48;
                                  if ((v51 - 48) >= 0xA)
                                  {
                                    if ((v51 - 97) > 5)
                                    {
                                      if ((v51 - 65) > 5) {
                                        goto LABEL_125;
                                      }
                                      unsigned int v60 = v51 - 55;
                                    }
                                    else
                                    {
                                      unsigned int v60 = v51 - 87;
                                    }
                                  }
                                  *(void *)(v21 + 192) = v59 + v60;
                                  goto LABEL_121;
                                }
                                *(_DWORD *)(v21 + 184) = 1;
                                goto LABEL_133;
                              case 1:
                                int v52 = *v48++;
                                if (v52 != 10) {
                                  goto LABEL_125;
                                }
                                int v53 = 2;
                                goto LABEL_114;
                              case 2:
                                int64_t v54 = *(void *)(v21 + 192);
                                if (!v54)
                                {
                                  *(unsigned char *)(v21 + 200) = 1;
LABEL_113:
                                  int v53 = 3;
LABEL_114:
                                  *(_DWORD *)(v21 + 184) = v53;
                                  goto LABEL_133;
                                }
                                if (v54 >= v42 - v48) {
                                  int64_t v55 = v42 - v48;
                                }
                                else {
                                  int64_t v55 = *(void *)(v21 + 192);
                                }
                                HTTPServerRequest::appendToBodyDataLocked((HTTPServerRequest *)v21, v48, v55);
                                v48 += v55;
                                int v47 = 1;
                                int64_t v56 = *(void *)(v21 + 192) - v55;
                                *(void *)(v21 + 192) = v56;
                                if (!v56) {
                                  goto LABEL_113;
                                }
LABEL_121:
                                int v49 = *(_DWORD *)(v21 + 184);
LABEL_122:
                                if (v49 == 5) {
                                  goto LABEL_128;
                                }
                                if (v49 == 6) {
                                  goto LABEL_126;
                                }
LABEL_133:
                                if (v48 >= v42) {
                                  break;
                                }
                                continue;
                              case 3:
                                int v57 = *v48++;
                                if (v57 != 13) {
                                  goto LABEL_125;
                                }
                                int v53 = 4;
                                goto LABEL_114;
                              case 4:
                                int v58 = *v48++;
                                if (v58 == 10)
                                {
                                  *(_DWORD *)(v21 + 184) = 5;
LABEL_128:
                                  if (!*(unsigned char *)(v21 + 200))
                                  {
                                    *(_DWORD *)(v21 + 184) = 0;
                                    *(void *)(v21 + 192) = 0;
                                    *(unsigned char *)(v21 + 200) = 0;
                                    goto LABEL_133;
                                  }
                                  *(_DWORD *)(v21 + 160) = 3;
                                  if (v47) {
                                    goto LABEL_130;
                                  }
                                }
                                else
                                {
LABEL_125:
                                  *(_DWORD *)(v21 + 184) = 6;
LABEL_126:
                                  *(_DWORD *)(v21 + 160) = 5;
                                  if (v47)
                                  {
LABEL_130:
                                    int v47 = 1;
                                    goto LABEL_133;
                                  }
                                }
                                pthread_cond_signal((pthread_cond_t *)(*(void *)(v21 + 152) + 88));
                                int v47 = 0;
                                goto LABEL_133;
                              default:
                                goto LABEL_122;
                            }
                          }
                          break;
                        }
                      }
                      *(_DWORD *)(v21 + 164) = *(_DWORD *)(v21 + 160);
                      uint64_t v61 = *(void *)(v21 + 152);
                      if (v61) {
                        pthread_mutex_unlock((pthread_mutex_t *)(v61 + 24));
                      }
                      v127 += v48 - v41;
                      if (v127 > v128 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        CFRange v44 = MEMORY[0x1E4F14500];
                        v45 = "Buffer overrun";
LABEL_141:
                        _os_log_fault_impl(&dword_184085000, v44, OS_LOG_TYPE_FAULT, v45, buf, 2u);
                      }
                      goto LABEL_160;
                    case 3u:
                      goto LABEL_160;
                    default:
                      if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)) {
                        goto LABEL_160;
                      }
                      *(_WORD *)buf = 0;
                      CFRange v44 = MEMORY[0x1E4F14500];
                      v45 = "Shouldn't get here like this";
                      goto LABEL_141;
                  }
                }
              }
LABEL_219:
              if (*(void *)(v3 + 176))
              {
                if ((unsigned int v97 = *(_DWORD *)(v3 + 72), v97 < 2)
                  || v97 == 2 && *(void *)(v3 + 88) && *(_DWORD *)(*(void *)(v3 + 96) + 40)
                  || v128 == v127
                  || (HTTPServerConnection::closeReadSocketSide_onQueue((dispatch_queue_t *)v3), *(void *)(v3 + 176)))
                {
                  if (!*(unsigned char *)(v3 + 168))
                  {
                    HTTPServerConnection::snapshotConnection(v3, v116);
                    if (*(uint64_t *)v116 >= 13 || (uint64_t v98 = *(void *)(v3 + 272)) != 0 && v117 >= v98)
                    {
                      *(unsigned char *)(v3 + 168) = 1;
                      if (*(void *)(v3 + 280)) {
                        MEMORY[0x185319F20](*(void *)(v3 + 176), 0);
                      }
                    }
                  }
                }
              }
              goto LABEL_232;
            }
            uint64_t v93 = *(void *)(v3 + 248);
            if (v93)
            {
              id v94 = *(HTTPServerRequest **)(v93 + 16);
              if (v94) {
                HTTPServerRequest::producerEOFEncountered(v94);
              }
            }
          }
          HTTPServerConnection::closeReadSocketSide_onQueue((dispatch_queue_t *)v3);
        }
      }
    }
LABEL_232:
    v99 = *(__CFWriteStream **)(v3 + 184);
    if (v99 && CFWriteStreamCanAcceptBytes(v99))
    {
      uint64_t v100 = *(void *)(v3 + 264);
      if (v100)
      {
        *(void *)(v3 + 264) = 0;
        HTTPServerConnection::performWritesAndBufferLeftovers((CFWriteStreamRef *)v3, *(const unsigned __int8 **)(v100 + 32), *(void *)(v100 + 24));
        (*(void (**)(uint64_t))(*(void *)v100 + 8))(v100);
      }
      else
      {
        uint64_t v109 = *(void *)(v3 + 248);
        if (v109)
        {
          v110 = *(__CFReadStream **)(v109 + 32);
          if (v110)
          {
            if (CFReadStreamHasBytesAvailable(v110))
            {
              CFIndex v111 = CFReadStreamRead(*(CFReadStreamRef *)(*(void *)(v3 + 248) + 32), buffer, 36000);
              v112 = *(__CFReadStream **)(*(void *)(v3 + 248) + 32);
              if (v111 < 0)
              {
                CFErrorRef v114 = CFReadStreamCopyError(v112);
                HTTPServerBase::becomeErrored_onQueue((HTTPServerBase *)(v3 + 8), v114);
                if (v114) {
                  CFRelease(v114);
                }
              }
              else
              {
                CFStreamStatus Status = CFReadStreamGetStatus(v112);
                if (v111) {
                  HTTPServerConnection::performWritesAndBufferLeftovers((CFWriteStreamRef *)v3, buffer, v111);
                }
                if (Status == kCFStreamStatusAtEnd && *(void *)(v3 + 248)) {
                  HTTPServerConnection::responseCompleted((HTTPServerConnection *)v3);
                }
              }
            }
          }
        }
      }
    }
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 88));
  v101 = *(__CFReadStream **)(v3 + 176);
  if (v101 && CFReadStreamGetStatus(v101) == kCFStreamStatusAtEnd) {
    HTTPServerConnection::cleanupPendingRequests_onQueue((dispatch_queue_t *)v3);
  }
  v102 = *(__CFWriteStream **)(v3 + 184);
  if (!v102 || CFWriteStreamGetStatus(v102) == kCFStreamStatusAtEnd)
  {
    HTTPServerConnection::cleanupPendingResponses_onQueue((dispatch_queue_t *)v3);
    if (*(int *)(v3 + 72) <= 2) {
      *(_DWORD *)(v3 + 72) = 3;
    }
    HTTPServerBase::signal((NSObject **)(v3 + 8));
    HTTPServerBase::deliverTerminalEvent_onQueue((HTTPServerBase *)(v3 + 8));
  }
  unsigned int v103 = *(_DWORD *)(v3 + 72);
  BOOL v104 = v103 >= 2 && (v103 != 2 || !*(void *)(v3 + 88) || !*(_DWORD *)(*(void *)(v3 + 96) + 40))
      || *(void *)(v3 + 136) == 0;
  if (!*(void *)(v3 + 248))
  {
    if (*(void *)(v3 + 240)) {
      BOOL v104 = 0;
    }
    if (v104) {
      goto LABEL_258;
    }
  }
  if (*(double *)(v3 + 192) != 0.0 && (*(unsigned char *)(v3 + 224) || CFAbsoluteTimeGetCurrent() > *(double *)(v3 + 192)))
  {
    CFErrorRef v105 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"kCFHTTPServerErrorDomain", 1104, 0);
    v106 = (__CFError *)CFAutorelease(v105);
    HTTPServerConnection::connectionError((dispatch_queue_t *)v3, v106);
LABEL_258:
    HTTPServerBase::deliverTerminalEvent_onQueue((HTTPServerBase *)(v3 + 8));
    goto LABEL_273;
  }
  if (*(unsigned char *)(v3 + 168)
    && *(void *)(v3 + 176)
    && (HTTPServerConnection::snapshotConnection(v3, buffer), *(uint64_t *)buffer <= 2)
    && (!*(void *)(v3 + 272) || v126 < *(void *)(v3 + 272) / 2))
  {
    *(unsigned char *)(v3 + 168) = 0;
    if (*(void *)(v3 + 280)) {
      MEMORY[0x185319F20](*(void *)(v3 + 176));
    }
    if (CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)(v3 + 176)))
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 88));
      HTTPServerBase::signal((NSObject **)(v3 + 8));
    }
  }
  else
  {
    unsigned int v107 = *(_DWORD *)(v3 + 72);
    if (v107 >= 2 && (v107 != 2 || !*(void *)(v3 + 88) || !*(_DWORD *)(*(void *)(v3 + 96) + 40)))
    {
      HTTPServerBase::deliverTerminalEvent_onQueue((HTTPServerBase *)(v3 + 8));
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 88));
    }
  }
LABEL_273:
  v108 = *(NSObject **)(v3 + 88);

  dispatch_assert_queue_V2(v108);
}

void sub_18429DBC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void HTTPServerConnection::snapshotConnection(uint64_t a1, void *a2)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 88));
  *a2 = 0;
  a2[1] = 0;
  uint64_t v4 = *(void *)(a1 + 240);
  if (v4)
  {
    uint64_t v5 = 0;
    do
    {
      ++v5;
      uint64_t v4 = *(void *)(v4 + 32);
    }
    while (v4);
    *a2 = v5;
  }
  uint64_t v6 = *(void *)(a1 + 248);
  if (v6)
  {
    CFErrorRef v7 = *(HTTPServerRequest **)(v6 + 16);
    if (v7)
    {
      if ((int)HTTPServerRequest::requestState(v7) <= 2) {
        a2[1] += HTTPServerRequest::remainingBodySize(*(HTTPServerRequest **)(*(void *)(a1 + 248) + 16));
      }
    }
  }
  uint64_t v8 = *(void *)(a1 + 240);
  if (v8)
  {
    CFAllocatorRef v9 = *(HTTPServerRequest **)(v8 + 16);
    if (v9)
    {
      if ((int)HTTPServerRequest::requestState(v9) <= 2) {
        a2[1] += HTTPServerRequest::remainingBodySize(*(HTTPServerRequest **)(*(void *)(a1 + 240) + 16));
      }
    }
  }
}

void HTTPServerConnection::performWritesAndBufferLeftovers(CFWriteStreamRef *this, const unsigned __int8 *a2, CFIndex a3)
{
  CFIndex v6 = CFWriteStreamWrite(this[23], a2, a3);
  CFErrorRef v7 = CFWriteStreamCopyError(this[23]);
  if (v6 < 0)
  {
    HTTPServerConnection::closeWriteSocketSide_onQueue((dispatch_queue_t *)this);
    HTTPServerBase::becomeErrored_onQueue((HTTPServerBase *)(this + 1), v7);
    if (!v7) {
      return;
    }
    goto LABEL_10;
  }
  if (!v6)
  {
    CFErrorRef v14 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"kCFHTTPServerErrorDomain", 1101, 0);
    CFErrorRef v15 = (__CFError *)CFAutorelease(v14);
    HTTPServerConnection::connectionError((dispatch_queue_t *)this, v15);
LABEL_9:
    if (!v7) {
      return;
    }
    goto LABEL_10;
  }
  HTTPServerConnection::touchTimerWatchdog((HTTPServerConnection *)this);
  BOOL v8 = a3 <= v6;
  uint64_t v9 = a3 - v6;
  if (v8) {
    goto LABEL_9;
  }
  CFAllocatorRef v10 = CFGetAllocator(this - 2);
  CFErrorRef v11 = CFAllocatorAllocate(v10, 32808, 0);
  bzero(v11 + 1, 0x8020uLL);
  CFErrorRef v12 = &a2[v6];
  *CFErrorRef v11 = &unk_1ECFA28D8;
  if (v9 >= 0x8000) {
    unsigned int v13 = CFAllocatorAllocate(v10, v9, 0);
  }
  else {
    unsigned int v13 = v11 + 5;
  }
  v11[1] = v10;
  v11[2] = v9;
  v11[3] = 0;
  v11[4] = v13;
  *CFErrorRef v11 = &unk_1ECFA5E10;
  memcpy(v13, v12, v9);
  v11[3] = v9;
  this[33] = (CFWriteStreamRef)v11;
  if (v7)
  {
LABEL_10:
    CFRelease(v7);
  }
}

void HTTPServerConnection::responseCompleted(HTTPServerConnection *this)
{
  uint64_t v2 = *((void *)this + 31);
  if (v2
    || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
    && (LOWORD(v10[0]) = 0,
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "fActivePair should not be NULL in HTTPServerConnection::responseCompleted", (uint8_t *)v10, 2u), (uint64_t v2 = *((void *)this + 31)) != 0))
  {
    if ((int)HTTPServerRequest::requestState(*(HTTPServerRequest **)(v2 + 16)) < 3) {
      return;
    }
    uint64_t v3 = (void *)*((void *)this + 31);
  }
  else
  {
    uint64_t v3 = 0;
  }
  *((void *)this + 3HTTPServerConnection::canceled_onQueue(this - 1) = 0;
  uint64_t v4 = (HTTPServerRequest *)v3[2];
  uint64_t v5 = v3[3];
  if (!v5)
  {
    CFIndex v6 = 0;
    goto LABEL_10;
  }
  CFIndex v6 = (const void *)(v5 - 16);
  CFErrorRef v7 = *(char **)(v5 + 88);
  if (!v7)
  {
LABEL_10:
    if (v4) {
      CFErrorRef v7 = (char *)v4 - 16;
    }
    else {
      CFErrorRef v7 = 0;
    }
  }
  if (*((void *)this + 18))
  {
    (*(void (**)(char *))(*((void *)this + 1) + 72))((char *)this + 8);
    uint64_t v8 = *((void *)this + 11);
    if (v7) {
      CFRetain(v7);
    }
    if (v6) {
      CFRetain(v6);
    }
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    v10[2] = ___ZN20HTTPServerConnection21sendResponseCompletedEP17HTTPServerRequestP18HTTPServerResponse_block_invoke;
    v10[3] = &unk_1E5256D58;
    void v10[6] = v7;
    v10[7] = v6;
    v10[4] = v8;
    v10[5] = this;
    HTTPServerBase::withClientAsync((void *)this + 1, (uint64_t)v10);
    uint64_t v4 = (HTTPServerRequest *)v3[2];
  }
  BOOL v9 = (int)HTTPServerRequest::requestState(v4) >= 3 && *(unsigned char *)(v3[3] + 105) == 0;
  (*(void (**)(void *))(*v3 + 8))(v3);
  if (v9)
  {
    HTTPServerConnection::checkPendingQueue((dispatch_queue_t *)this);
    if (!*((void *)this + 31)) {
      HTTPServerConnection::touchTimerIdle(this);
    }
  }
  else
  {
    if (*((int *)this + 18) <= 2) {
      *((_DWORD *)this + 18) = 3;
    }
    HTTPServerBase::signal((NSObject **)this + 1);
    HTTPServerConnection::checkPendingQueue((dispatch_queue_t *)this);
  }
}

void HTTPServerConnection::touchTimerIdle(HTTPServerConnection *this)
{
  if (*((uint64_t *)this + 26) < 1)
  {
    *((void *)this + CFRelease((char *)this - 24) = 0;
  }
  else
  {
    double Current = CFAbsoluteTimeGetCurrent();
    double v3 = Current + (double)*((uint64_t *)this + 26);
    *((double *)this + CFRelease((char *)this - 24) = v3;
    *((double *)this + 25) = Current;
    *((unsigned char *)this + 2CFRelease((char *)this - 24) = 0;
    uint64_t v4 = (__CFRunLoopTimer *)*((void *)this + 37);
    if (v4)
    {
      CFRunLoopTimerSetNextFireDate(v4, v3);
    }
  }
}

void ___ZN20HTTPServerConnection21sendResponseCompletedEP17HTTPServerRequestP18HTTPServerResponse_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[5];
  if (a2)
  {
    uint64_t v4 = *(void (**)(uint64_t, void, void))(v3 + 144);
    if (v4) {
      v4(a2, a1[6], a1[7]);
    }
  }
  uint64_t v5 = a1[4];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN20HTTPServerConnection21sendResponseCompletedEP17HTTPServerRequestP18HTTPServerResponse_block_invoke_2;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  long long v7 = *((_OWORD *)a1 + 3);
  HTTPServerBase::releaseOnCapturedQueue(v3 + 8, v5, v6);
}

void ___ZN20HTTPServerConnection21sendResponseCompletedEP17HTTPServerRequestP18HTTPServerResponse_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3)
  {
    CFRelease(v3);
  }
}

void HTTPServerConnection::touchTimerWatchdog(HTTPServerConnection *this)
{
  if (*((uint64_t *)this + 27) < 1)
  {
    *((void *)this + CFRelease((char *)this - 24) = 0;
  }
  else
  {
    double Current = CFAbsoluteTimeGetCurrent();
    double v3 = Current + (double)*((uint64_t *)this + 27);
    *((double *)this + CFRelease((char *)this - 24) = v3;
    *((double *)this + 25) = Current;
    *((unsigned char *)this + 2CFRelease((char *)this - 24) = 0;
    uint64_t v4 = (__CFRunLoopTimer *)*((void *)this + 37);
    if (v4)
    {
      CFRunLoopTimerSetNextFireDate(v4, v3);
    }
  }
}

void HTTPServerConnection::LeftoverBuffer::~LeftoverBuffer(HTTPServerConnection::LeftoverBuffer *this)
{
  CFAllocatorRef v2 = *(const __CFAllocator **)(CFBufferPossiblyOnStack<32768l>::~CFBufferPossiblyOnStack((uint64_t)this) + 8);

  CFAllocatorDeallocate(v2, this);
}

uint64_t CFBufferPossiblyOnStack<32768l>::~CFBufferPossiblyOnStack(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA28D8;
  CFAllocatorRef v2 = *(void **)(a1 + 32);
  if (v2 != (void *)(a1 + 40)) {
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 8), v2);
  }
  return a1;
}

void CFBufferPossiblyOnStack<32768l>::~CFBufferPossiblyOnStack(void *a1)
{
  CFAllocatorRef v2 = *(const __CFAllocator **)(CFBufferPossiblyOnStack<32768l>::~CFBufferPossiblyOnStack((uint64_t)a1) + 8);

  CFAllocatorDeallocate(v2, a1);
}

void *HTTPServerConnection::PendingQueue::PendingQueue(void *a1, uint64_t a2)
{
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)(a2 - 16));
  a1[2] = 0;
  a1[3] = 0;
  *a1 = &unk_1ECFA5DF0;
  a1[1] = v4;
  HTTPServerConnection::RRQueue::setRequest((uint64_t)a1, a2);
  a1[4] = 0;
  return a1;
}

void sub_18429E3C4(_Unwind_Exception *a1)
{
  HTTPServerConnection::RRQueue::~RRQueue(v1);
  _Unwind_Resume(a1);
}

void ___ZN20HTTPServerConnection31processAllIncomingBytes_onQueueEP21ConsumableStackBuffer_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2 && (double v3 = *(void (**)(uint64_t, uint64_t))(*(void *)(a1 + 40) + 136)) != 0) {
    v3(a2, *(void *)(a1 + 48) - 16);
  }
  else {
    HTTPServerRequest::loseConnectionReferenceAndTerminateReads(*(HTTPServerRequest **)(a1 + 48));
  }
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(NSObject **)(a1 + 32);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN17HTTPServerRequest22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
  v6[3] = &unk_1E5257C58;
  void v6[4] = 0;
  v6[5] = v4;
  dispatch_async(v5, v6);
}

void HTTPServerConnection::suspendTimeout(HTTPServerConnection *this)
{
  *((unsigned char *)this + 2CFRelease((char *)this - 24) = 0;
  CFAllocatorRef v2 = (__CFRunLoopTimer *)*((void *)this + 37);
  if (v2)
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFRunLoopTimerSetNextFireDate(v2, Current + 1.0e30);
  }
  *((void *)this + CFRelease((char *)this - 24) = 0;
}

void ___ZN17HTTPServerRequest22releaseOnCapturedQueueEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v4 = a1 + 32;
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v4 + 8);
  if (v2)
  {
    (*(void (**)(void))(v2 + 16))();
    _Block_release(*(const void **)(a1 + 32));
  }

  CFRelease((CFTypeRef)(v3 - 16));
}

void ___ZN9TCFObjectI17HTTPServerRequestE5ClassEv_block_invoke()
{
}

void sub_18429E584(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'HTTPServerConnection::scheduled_onQueue(HTTPServerConnection *this)
{
  return HTTPServerConnection::scheduled_onQueue((uint64_t)this - 8);
}

uint64_t HTTPServerConnection::scheduled_onQueue(uint64_t this)
{
  if (*(int *)(this + 72) <= 2)
  {
    uint64_t v1 = this;
    if (!*(void *)(this + 176)
      || *(void *)(this + 280)
      || (*(void *)(this + 280) = *(void *)(this + 88),
          MEMORY[0x185319F20](),
          this = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 96))(v1),
          *(int *)(v1 + 72) <= 2))
    {
      this = *(void *)(v1 + 184);
      if (!this
        || *(void *)(v1 + 288)
        || (*(void *)(v1 + 288) = *(void *)(v1 + 88),
            MEMORY[0x18531A970](),
            this = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 96))(v1),
            *(int *)(v1 + 72) <= 2))
      {
        if (!*(void *)(v1 + 296))
        {
          *(void *)(v1 + 208) = 0;
          CFNumberRef v2 = (const __CFNumber *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 160) + 64))(*(void *)(v1 + 160), 0x1EC0A4450);
          if (v2)
          {
            CFNumberRef v3 = v2;
            CFNumberGetValue(v2, kCFNumberCFIndexType, (void *)(v1 + 208));
            CFRelease(v3);
          }
          *(void *)(v1 + 2CFRelease((char *)this - 16) = 0;
          this = (*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 160) + 64))(*(void *)(v1 + 160), 0x1EC0A4798);
          if (this)
          {
            uint64_t v4 = (const void *)this;
            CFNumberGetValue((CFNumberRef)this, kCFNumberCFIndexType, (void *)(v1 + 216));
            CFRelease(v4);
          }
          if (*(uint64_t *)(v1 + 208) > 0 || *(uint64_t *)(v1 + 216) >= 1)
          {
            v12.version = 0;
            v12.info = (void *)v1;
            memset(&v12.retain, 0, 24);
            (*(void (**)(uint64_t))(*(void *)v1 + 112))(v1);
            CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)(v1 - 16));
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            *(void *)(v1 + 296) = CFRunLoopTimerCreate(v5, Current + 1.0e30, 1.0e30, 0, 0, (CFRunLoopTimerCallBack)_timerCallback, &v12);
            long long v7 = *(NSObject **)(v1 + 88);
            uint64_t v8 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 96, 0);
            *(_OWORD *)uint64_t v8 = 0u;
            *((_OWORD *)v8 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
            *((_OWORD *)v8 + 2) = 0u;
            *((_OWORD *)v8 + 3) = 0u;
            *((_OWORD *)v8 + 4) = 0u;
            *((_OWORD *)v8 + 5) = 0u;
            BOOL v9 = QCoreSchedulingSet::QCoreSchedulingSet(v8, v7);
            uint64_t v10 = *(void *)(v1 + 296);
            v13[0] = MEMORY[0x1E4F143A8];
            v13[1] = 3221225472;
            v13[2] = ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
            v13[3] = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
            v13[4] = v10;
            CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)v9, v13);
            (*(void (**)(CFAllocatedReferenceCountedObject *))(*(void *)v8 + 48))(v8);
            HTTPServerConnection::touchTimerIdle((HTTPServerConnection *)v1);
          }
        }
        uint64_t v11 = CoreSchedulingSet::copyRunloopEmulationSet((CoreSchedulingSet *)this);
        (*(void (**)(uint64_t, void *))(*(void *)v11 + 96))(v11, &__block_literal_global_10_16415);
        return (*(uint64_t (**)(uint64_t))(*(void *)v11 + 48))(v11);
      }
    }
  }
  return this;
}

void _timerCallback(__CFRunLoopTimer *a1, void *a2)
{
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZL14_timerCallbackP16__CFRunLoopTimerPv_block_invoke;
  aBlock[3] = &__block_descriptor_40_e5_v8__0l;
  aBlock[4] = a2;
  HTTPServerBase::withWorkQueue(a2 + 1, aBlock);
}

void ___ZL14_timerCallbackP16__CFRunLoopTimerPv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(unsigned char *)(v1 + 2CFRelease((char *)this - 24) = 1;
  CFNumberRef v2 = (NSObject **)(v1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));

  HTTPServerBase::signal(v2);
}

void non-virtual thunk to'HTTPServerConnection::setProperty(HTTPServerConnection *this, const __CFString *a2, const void *a3)
{
}

void HTTPServerConnection::setProperty(HTTPServerConnection *this, CFStringRef theString, const void *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int ExactString = _findExactString(theString, 9u);
  if (ExactString > 467892414)
  {
    if (ExactString != 470005982 && ExactString != 467892415)
    {
LABEL_12:
      HTTPServerBase::setProperty((HTTPServerConnection *)((char *)this + 8), theString, a3);
      return;
    }
  }
  else if (ExactString != 465852570)
  {
    if (ExactString == 466917548)
    {
      CFNumberGetValue((CFNumberRef)a3, kCFNumberCFIndexType, (char *)this + 272);
      return;
    }
    goto LABEL_12;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    int v7 = 138412290;
    CFStringRef v8 = theString;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Sorry, %@ isn't implemented yet", (uint8_t *)&v7, 0xCu);
  }
}

CFNumberRef non-virtual thunk to'HTTPServerConnection::copyProperty(HTTPServerConnection *this, const __CFString *a2)
{
  return HTTPServerConnection::copyProperty((HTTPServerConnection *)((char *)this - 8), a2);
}

CFNumberRef HTTPServerConnection::copyProperty(HTTPServerConnection *this, CFStringRef theString)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int ExactString = _findExactString(theString, 9u);
  if (ExactString > 467892414)
  {
    switch(ExactString)
    {
      case 467892415:
        uint64_t v9 = (__CFReadStream *)*((void *)this + 22);
        if (v9)
        {
          uint64_t v10 = (void *)CFReadStreamCopyProperty(v9, (CFStreamPropertyKey)&unk_1EC09FBB0);
          if (v10) {
            return (CFNumberRef)v10;
          }
          CFDataRef v11 = (const __CFData *)CFReadStreamCopyProperty(*((CFReadStreamRef *)this + 22), @"kCFStreamPropertySocketNativeHandle");
          if (v11)
          {
            CFDataRef v12 = v11;
            if (CFDataGetLength(v11) == 4)
            {
              int length_4 = 0;
              v23.location = 0;
              v23.socklen_t length = 4;
              CFDataGetBytes(v12, v23, (UInt8 *)&length_4);
              socklen_t length = 255;
              uint64_t v10 = 0;
              if (!getpeername(length_4, &v20, &length))
              {
                CFAllocatorRef v13 = CFGetAllocator((char *)this - 16);
                uint64_t v10 = CFDataCreate(v13, &v20.sa_len, length);
              }
            }
            else
            {
              uint64_t v10 = 0;
            }
            CFRelease(v12);
            return (CFNumberRef)v10;
          }
        }
        break;
      case 470005982:
        uint64_t v14 = *((void *)this + 20);
        if (v14)
        {
          return (CFNumberRef)CFRetain((CFTypeRef)(v14 - 16));
        }
        break;
      case 468981965:
        CFAllocatorRef v5 = (__CFReadStream *)*((void *)this + 22);
        if (v5)
        {
          CFStringRef v6 = @"kCFStreamPropertySSLPeerCertificates";
LABEL_24:
          return (CFNumberRef)CFReadStreamCopyProperty(v5, v6);
        }
        return 0;
      default:
        goto LABEL_27;
    }
    return 0;
  }
  if (ExactString == 465852570)
  {
    CFAllocatorRef v5 = (__CFReadStream *)*((void *)this + 22);
    if (v5)
    {
      CFStringRef v6 = @"kCFStreamPropertySSLPeerTrust";
      goto LABEL_24;
    }
    return 0;
  }
  if (ExactString == 466917548)
  {
    CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
    return CFNumberCreate(v7, kCFNumberCFIndexType, (char *)this + 272);
  }
LABEL_27:
  uint64_t v10 = (void *)HTTPServerBase::copyProperty((HTTPServerConnection *)((char *)this + 8), theString);
  if (v10) {
    return (CFNumberRef)v10;
  }
  uint64_t v15 = *((void *)this + 20);
  if (v15)
  {
    uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, CFStringRef))(*(void *)v15 + 64))(v15, theString);
    if (v10) {
      return (CFNumberRef)v10;
    }
  }
  unsigned int v16 = (__CFReadStream *)*((void *)this + 22);
  if (v16)
  {
    uint64_t v10 = (void *)CFReadStreamCopyProperty(v16, theString);
    if (v10) {
      return (CFNumberRef)v10;
    }
  }
  CFIndex v17 = (__CFWriteStream *)*((void *)this + 23);
  if (!v17) {
    return 0;
  }

  return (CFNumberRef)CFWriteStreamCopyProperty(v17, theString);
}

void HTTPServerConnection::releaseSelf(HTTPServerConnection *this)
{
}

CFTypeRef HTTPServerConnection::retainSelf(HTTPServerConnection *this)
{
  return CFRetain((char *)this - 16);
}

uint64_t HTTPServerConnection::errorClient(uint64_t this, void *a2, __CFError *a3)
{
  CFNumberRef v3 = *(uint64_t (**)(void *, __CFError *))(this + 128);
  if (v3)
  {
    *(void *)(this + 128) = 0;
    return v3(a2, a3);
  }
  return this;
}

uint64_t HTTPServerConnection::invalidateClient(uint64_t this, void *a2)
{
  CFNumberRef v2 = *(uint64_t (**)(void *))(this + 120);
  if (v2)
  {
    *(void *)(this + 120) = 0;
    return v2(a2);
  }
  return this;
}

CFStringRef HTTPServerConnection::copyDebugDesc(HTTPServerConnection *this)
{
  CFStringRef v2 = CFObject::copyDebugDescHeader(this);
  CFStringRef v3 = HTTPServerBase::copyBaseDescription((HTTPServerConnection *)((char *)this + 8));
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@", *((void *)this + 22));
  CFStringRef v6 = CFStringCreateWithFormat(v4, 0, @"%@", *((void *)this + 23));
  uint64_t v7 = *((void *)this + 31);
  if (v7) {
    uint64_t v7 = *(void *)(v7 + 32);
  }
  CFStringRef v8 = CFStringCreateWithFormat(v4, 0, @"%@", v7);
  CFAllocatorRef v9 = CFGetAllocator((char *)this - 16);
  CFStringRef v10 = CFStringCreateWithFormat(v9, 0, @"%@ { socket rs=%@, socket ws=%@, response rs=%@, %@ }", v2, v5, v6, v8, v3);
  if (v8) {
    CFRelease(v8);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v2) {
    CFRelease(v2);
  }
  return v10;
}

void ___ZN20HTTPServerConnection5ClassEv_block_invoke()
{
}

void sub_18429F064(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void _writeStreamCallback(__CFWriteStream *a1, unint64_t a2, void *a3)
{
  CFStringRef v3 = a3[11];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN20HTTPServerConnection27signal_connection_off_queueEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = a3;
  dispatch_async(v3, block);
}

uint64_t ___ZN20HTTPServerConnection7abandonEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 104))();
}

uint64_t HTTPServerReadStream::_streamImpl_SetProperty(HTTPServerReadStream *this, __CFReadStream *a2, const __CFString *a3, const void *a4)
{
  return 0;
}

uint64_t HTTPServerReadStream::_streamImpl_CopyProperty(HTTPServerReadStream *this, __CFReadStream *a2, const __CFString *a3)
{
  return 0;
}

uint64_t HTTPServerReadStream::_streamImpl_Close(HTTPServerReadStream *this, __CFReadStream *a2)
{
  uint64_t result = *((void *)this + 2);
  if (result)
  {
    *((unsigned char *)this + 25) = 1;
    (*(void (**)(uint64_t, __CFReadStream *))(*(void *)result + 40))(result, a2);
    uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 2) + 56))(*((void *)this + 2));
    *((void *)this + 2) = 0;
  }
  return result;
}

uint64_t HTTPServerReadStream::_streamImpl_CanRead(HTTPServerReadStream *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 24))();
}

uint64_t HTTPServerReadStream::_streamImpl_Read(HTTPServerReadStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  return (*(uint64_t (**)(void, unsigned __int8 *, uint64_t, CFStreamError *, unsigned __int8 *))(**((void **)this + 2) + 32))(*((void *)this + 2), a3, a4, a5, a6);
}

uint64_t HTTPServerReadStream::_streamImpl_OpenCompleted(HTTPServerReadStream *this, __CFReadStream *a2, CFStreamError *a3)
{
  return *((unsigned __int8 *)this + 24);
}

uint64_t HTTPServerReadStream::_streamImpl_Open(HTTPServerReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a4 = 0;
  *((unsigned char *)this + CFRelease((char *)this - 24) = 1;
  int v6 = (*(uint64_t (**)(void, CFStreamError *))(**((void **)this + 2) + 16))(*((void *)this + 2), a3);
  if (v6 == 1) {
    goto LABEL_4;
  }
  uint64_t v7 = 0;
  if (!v6)
  {
    *a4 = 1;
LABEL_4:
    a3->error = 0;
    a3->domain = 0;
    return 1;
  }
  return v7;
}

void HTTPServerReadStream::~HTTPServerReadStream(HTTPServerReadStream *this)
{
  HTTPServerReadStream::~HTTPServerReadStream(this);

  JUMPOUT(0x18531B6D0);
}

{
  uint64_t v2;

  *(void *)this = &unk_1ECFA1498;
  CFStringRef v2 = *((void *)this + 2);
  if (v2)
  {
    if (!*((unsigned char *)this + 25))
    {
      (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
      CFStringRef v2 = *((void *)this + 2);
    }
    (*(void (**)(uint64_t))(*(void *)v2 + 56))(v2);
    *((void *)this + 2) = 0;
  }
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = 0;
}

void sub_18429F398(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

uint64_t HTTPServerReadStream::HTTPServerReadStream(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1ECFA1498;
  *(void *)(a1 + 8) = a2;
  *(_WORD *)(a1 + CFRelease((char *)this - 24) = 0;
  *(void *)(a1 + CFRelease((char *)this - 16) = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 48))(a3);
  return a1;
}

void sub_18429F42C(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  v1[1] = 0;
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTPServerRequest::_subclass_release(HTTPServerRequest *this)
{
}

HTTPServerRequest *non-virtual thunk to'HTTPServerRequest::_subclass_retain(HTTPServerRequest *this)
{
  return this;
}

uint64_t non-virtual thunk to'HTTPServerRequest::closeUnderlyingStream(HTTPServerRequest *this)
{
  return HTTPServerRequest::closeUnderlyingStream((uint64_t)this - 120);
}

uint64_t HTTPServerRequest::closeUnderlyingStream(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 152);
  if (!v2)
  {
    *(_DWORD *)(this + 160) = 3;
    goto LABEL_8;
  }
  this = pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
  uint64_t v3 = *(void *)(v1 + 152);
  *(_DWORD *)(v1 + 160) = 3;
  if (!v3)
  {
LABEL_8:
    *(_DWORD *)(v1 + 164) = 3;
    return this;
  }
  this = pthread_cond_signal((pthread_cond_t *)(v3 + 88));
  uint64_t v4 = *(void *)(v1 + 152);
  *(_DWORD *)(v1 + 164) = *(_DWORD *)(v1 + 160);
  if (v4)
  {
    return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 24));
  }
  return this;
}

uint64_t non-virtual thunk to'HTTPServerRequest::readFromUnderlyingStream(HTTPServerRequest *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  return HTTPServerRequest::readFromUnderlyingStream((HTTPServerRequest *)((char *)this - 120), a2, a3, a4, a5);
}

uint64_t HTTPServerRequest::readFromUnderlyingStream(HTTPServerRequest *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  CFStringRef v8 = this;
  uint64_t v9 = *((void *)this + 19);
  if (v9
    || os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT)
    && (*(_WORD *)__darwin_ct_rune_t v50 = 0,
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "fBodyData must not be NULL - we shouldn't get a read event until we're readable", v50, 2u), (uint64_t v9 = *((void *)v8 + 19)) != 0))
  {
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 24));
  }
  *a5 = 0;
  int v10 = *((_DWORD *)v8 + 40);
  if (v10 > 3)
  {
    uint64_t v11 = -1;
    goto LABEL_22;
  }
  uint64_t v12 = *((void *)v8 + 19);
  CFAllocatorRef v13 = *(void **)(v12 + 136);
  uint64_t v14 = v13[5];
  if (v10 == 3 && !v14) {
    goto LABEL_8;
  }
  if (!v14)
  {
    pthread_cond_wait((pthread_cond_t *)(v12 + 88), (pthread_mutex_t *)(v12 + 24));
    CFAllocatorRef v13 = *(void **)(*((void *)v8 + 19) + 136);
    uint64_t v14 = v13[5];
    if (!v14)
    {
      if (*((int *)v8 + 40) <= 2)
      {
        uint64_t v11 = 0;
        *((_DWORD *)v8 + 40) = 5;
        goto LABEL_21;
      }
LABEL_8:
      uint64_t v11 = 0;
LABEL_21:
      *a5 = 1;
      int v10 = *((_DWORD *)v8 + 40);
      goto LABEL_22;
    }
  }
  CFRange v44 = a5;
  uint64_t v45 = v14;
  uint64_t v46 = a3;
  int v47 = (int *)v8;
  if (v14 >= a3) {
    uint64_t v11 = a3;
  }
  else {
    uint64_t v11 = v14;
  }
  unsigned int v16 = v13 + 3;
  uint64_t v15 = v13[3];
  if (v15) {
    BOOL v17 = v11 < 1;
  }
  else {
    BOOL v17 = 1;
  }
  if (!v17)
  {
    uint64_t v20 = 0;
    uint64_t v21 = &a2[v11];
    uint64_t v22 = v13 + 3;
    uint64_t v43 = v11;
    int v49 = &a2[v11];
    do
    {
      uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 24))(v15);
      if (v23 >= 1)
      {
        uint64_t v24 = v23 + v20;
        if (v11 >= v20 && v24 >= 1)
        {
          uint64_t v25 = v20 & ~(v20 >> 63);
          if (v11 >= v24) {
            uint64_t v26 = v23 + v20;
          }
          else {
            uint64_t v26 = v11;
          }
          uint64_t v27 = v25 - v20;
          size_t v28 = v26 - v25;
          int v29 = (void *)*v22;
          if ((v25 - v20 < 0 || v29[3] + v27 + v28 > v29[4])
            && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "out of bounds", buf, 2u);
          }
          memcpy(a2, (const void *)(v29[3] + v27), v28);
          uint64_t v30 = v29[3];
          if (v20 < 0)
          {
            size_t v31 = v27 + v28;
            uint64_t v32 = v29[4];
            if (v30 + v27 + v28 == v32)
            {
              v29[4] = v30 + v27;
            }
            else
            {
              size_t v48 = v32 - v30 - v31;
              CFAllocatorRef v33 = (const __CFAllocator *)v29[1];
              uint64_t v34 = (SegmentedData::PrivateAllocation *)CFAllocatorAllocate(v33, (v48 & 0xFFFFFFFFFFFFFFF0) + 64, 0);
              *(void *)uint64_t v34 = &unk_1ECFA5D08;
              *((void *)v34 + HTTPServerConnection::canceled_onQueue(this - 1) = v33;
              *((void *)v34 + 2) = 0;
              *((void *)v34 + 3) = (char *)v34 + 40;
              *((void *)v34 + 4) = (char *)v34 + v48 + 40;
              uint64_t v35 = (void *)SegmentedData::PrivateAllocation::ptr(v34);
              memcpy(v35, (const void *)(v29[3] + v31), v48);
              uint64_t v36 = v29[2];
              v29[4] = v29[3] + v27;
              *((void *)v34 + 2) = v36;
              v29[2] = v34;
              uint64_t v11 = v43;
            }
            unsigned int v16 = v13 + 3;
          }
          else
          {
            v29[3] = v30 + v28;
          }
          uint64_t v21 = v49;
          a2 += v28;
          v13[5] -= v28;
        }
        uint64_t v20 = v24;
      }
      uint64_t v37 = (*(uint64_t (**)(void))(*(void *)*v22 + 24))();
      uint64_t v38 = (void *)*v22;
      uint64_t v39 = *(void *)(*v22 + 16);
      if (v37)
      {
        if (!v39)
        {
          v13[4] = v38;
          uint64_t v38 = (void *)*v22;
        }
        uint64_t v22 = v38 + 2;
      }
      else
      {
        *uint64_t v22 = v39;
        v38[2] = 0;
        (*(void (**)(void *))(*v38 + 8))(v38);
        uint64_t v40 = *v16;
        if (*v16)
        {
          int v41 = (void *)v13[4];
        }
        else
        {
          int v41 = 0;
          v13[4] = 0;
        }
        if (v41 == v38)
        {
          v13[4] = v40;
          if (*(void *)(v40 + 16))
          {
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)int v51 = 0;
              _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "tail", v51, 2u);
            }
          }
        }
      }
      uint64_t v15 = *v22;
      if (*v22) {
        BOOL v42 = a2 >= v21;
      }
      else {
        BOOL v42 = 1;
      }
    }
    while (!v42);
  }
  CFStringRef v8 = (HTTPServerRequest *)v47;
  int v10 = v47[40];
  if (v45 <= v46)
  {
    a5 = v44;
    if (v10 == 3) {
      goto LABEL_21;
    }
  }
LABEL_22:
  *((_DWORD *)v8 + 4HTTPServerConnection::canceled_onQueue(this - 1) = v10;
  uint64_t v18 = *((void *)v8 + 19);
  if (v18) {
    pthread_mutex_unlock((pthread_mutex_t *)(v18 + 24));
  }
  HTTPServerRequest::signalReadStreamBasedOnState(v8);
  return v11;
}

uint64_t HTTPServerRequest::signalReadStreamBasedOnState(HTTPServerRequest *this)
{
  uint64_t v2 = *((void *)this + 19);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
  }
  uint64_t result = *((void *)this + 16);
  if (result)
  {
    uint64_t result = CFReadStreamGetStatus((CFReadStreamRef)result);
    if (result >= 2)
    {
      uint64_t v4 = *((void *)this + 17);
      if (v4)
      {
        uint64_t v5 = *((void *)this + 19);
        if (v5 && *(uint64_t *)(*(void *)(v5 + 136) + 40) > 0) {
          uint64_t v6 = 2;
        }
        else {
          uint64_t v6 = 16 * (*((_DWORD *)this + 40) == 3);
        }
        if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1)
        {
          uint64_t v10 = *((void *)this + 17);
          dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
          uint64_t v4 = v10;
        }
        uint64_t v7 = *(NSObject **)(v4 + 104);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = ___ZN20HTTPServerConnection27signal_connection_off_queueEv_block_invoke_16454;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = v4 + 16;
        dispatch_async(v7, block);
      }
      else
      {
        uint64_t v6 = 16 * (*((_DWORD *)this + 40) == 3);
      }
      uint64_t result = *((void *)this + 16);
      if (v6) {
        BOOL v8 = result == 0;
      }
      else {
        BOOL v8 = 1;
      }
      if (!v8) {
        uint64_t result = _CFReadStreamSignalEventDelayed();
      }
    }
  }
  *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = *((_DWORD *)this + 40);
  uint64_t v9 = *((void *)this + 19);
  if (v9) {
    return pthread_mutex_unlock((pthread_mutex_t *)(v9 + 24));
  }
  return result;
}

void ___ZN20HTTPServerConnection27signal_connection_off_queueEv_block_invoke_16454(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (NSObject **)(v1 + 8);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 88));

  HTTPServerBase::signal(v2);
}

BOOL non-virtual thunk to'HTTPServerRequest::canReadFromUnderlyingStream(HTTPServerRequest *this)
{
  return HTTPServerRequest::canReadFromUnderlyingStream((HTTPServerRequest *)((char *)this - 120));
}

BOOL HTTPServerRequest::canReadFromUnderlyingStream(HTTPServerRequest *this)
{
  uint64_t v2 = *((void *)this + 19);
  if (!v2) {
    goto LABEL_5;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
  uint64_t v3 = *((void *)this + 19);
  if (!*((void *)this + 17))
  {
    BOOL v4 = 0;
    BOOL result = 0;
    *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = *((_DWORD *)this + 40);
    if (!v3) {
      return result;
    }
    goto LABEL_7;
  }
  if (!v3)
  {
LABEL_5:
    BOOL result = 0;
    *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = *((_DWORD *)this + 40);
    return result;
  }
  BOOL v4 = *(void *)(*(void *)(v3 + 136) + 40) > 0;
  *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = *((_DWORD *)this + 40);
LABEL_7:
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 24));
  return v4;
}

uint64_t non-virtual thunk to'HTTPServerRequest::openUnderlyingStream(HTTPServerRequest *this, CFStreamError *a2)
{
  return 0;
}

void non-virtual thunk to'HTTPServerRequest::~HTTPServerRequest(HTTPServerRequest *this)
{
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 120));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 112));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 112));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 104));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 104));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 56));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 56));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 8));
}

{
  HTTPServerRequest::~HTTPServerRequest((HTTPServerRequest *)((char *)this - 8));
}

void HTTPServerRequest::~HTTPServerRequest(HTTPServerRequest *this)
{
  *(void *)this = &unk_1ECF9E950;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9E9E8;
  uint64_t v2 = (void **)((char *)this + 56);
  *((void *)this + 7) = &unk_1ECF9EA08;
  *((void *)this + 13) = &unk_1ECF9EA48;
  *((void *)this + 14) = &unk_1ECF9EA78;
  uint64_t v3 = (const void *)*((void *)this + 16);
  *((void *)this + 15) = &unk_1ECF9EA98;
  *((void *)this + CFRelease((char *)this - 16) = 0;
  if (v3) {
    CFRelease(v3);
  }
  CFRelease((CFTypeRef)(*((void *)this + 26) - 16));
  uint64_t v4 = *((void *)this + 19);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 18);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  dispatch_release(*((dispatch_object_t *)this + 29));
  if (*((void *)this + 17) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "fConnection should be null", v7, 2u);
  }
  *((void *)this + 27) = &unk_1ECF9F718;
  uint64_t v6 = (const void *)*((void *)this + 28);
  if (v6) {
    CFRelease(v6);
  }
  *((void *)this + 14) = &unk_1ECF9B550;
  HTTPRequestParserClient::~HTTPRequestParserClient(v2);
}

void sub_18429FDB4(_Unwind_Exception *a1)
{
  *(void *)(v2 + 2CFRelease((char *)this - 16) = &unk_1ECF9F718;
  uint64_t v5 = *(const void **)(v2 + 224);
  if (v5) {
    CFRelease(v5);
  }
  *uint64_t v3 = &unk_1ECF9B550;
  HTTPRequestParserClient::~HTTPRequestParserClient(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'HTTPServerRequest::parserAddHeader(HTTPServerRequest *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  return (*(uint64_t (**)(void))(*((void *)this - 6) + 24))();
}

uint64_t non-virtual thunk to'HTTPServerRequest::parserCompleteFirstLine(HTTPServerRequest *this, const unsigned __int8 *a2)
{
  return (*(uint64_t (**)(void))(*((void *)this - 6) + 16))();
}

uint64_t non-virtual thunk to'HTTPServerRequest::mutableHeaders(HTTPServerRequest *this)
{
  return *((void *)this + 19);
}

uint64_t non-virtual thunk to'HTTPServerRequest::mutableVersion(HTTPServerRequest *this)
{
  return (uint64_t)this + 160;
}

uint64_t HTTPServerRequest::parserAddHeader(HTTPServerRequest *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  return (*(uint64_t (**)(void))(*((void *)this + 7) + 24))();
}

uint64_t HTTPServerRequest::parserCompleteFirstLine(HTTPServerRequest *this, const unsigned __int8 *a2)
{
  return (*(uint64_t (**)(void))(*((void *)this + 7) + 16))();
}

uint64_t HTTPServerRequest::mutableHeaders(HTTPServerRequest *this)
{
  return *((void *)this + 26);
}

uint64_t HTTPServerRequest::mutableVersion(HTTPServerRequest *this)
{
  return (uint64_t)this + 216;
}

void HTTPServerRequest::_subclass_release(HTTPServerRequest *this)
{
}

uint64_t HTTPServerRequest::_subclass_retain(HTTPServerRequest *this)
{
  return (uint64_t)this + 120;
}

uint64_t HTTPServerRequest::openUnderlyingStream(HTTPServerRequest *this, CFStreamError *a2)
{
  return 0;
}

CFStringRef HTTPServerRequest::copyDebugDesc(HTTPServerRequest *this)
{
  CFStringRef v2 = CFObject::copyDebugDescHeader(this);
  int v3 = *((_DWORD *)this + 41);
  switch(v3)
  {
    case 0:
      CFAllocatorRef v4 = CFGetAllocator((char *)this - 16);
      CFStringRef v5 = CFStringCreateWithFormat(v4, 0, @"%@ { state %s }>", v2, "H");
      break;
    case 1:
      CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
      CFStringRef v5 = CFStringCreateWithFormat(v6, 0, @"%@ { state %s, expected total body length %ld  }>", v2, "B", *((void *)this + 21));
      break;
    case 2:
      CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
      uint64_t v8 = *((unsigned int *)this + 46);
      if (v8 > 6) {
        uint64_t v9 = "BAD";
      }
      else {
        uint64_t v9 = off_1E5256D98[v8];
      }
      CFStringRef v5 = CFStringCreateWithFormat(v7, 0, @"%@ { state %s, chunk state %s  }>", v2, "C", v9);
      break;
    case 3:
      CFAllocatorRef v10 = CFGetAllocator((char *)this - 16);
      CFStringRef v5 = CFStringCreateWithFormat(v10, 0, @"%@ { state %s - COMPLETED, expected body length %ld  }>", v2, "D", *((void *)this + 21));
      break;
    default:
      CFAllocatorRef v11 = CFGetAllocator((char *)this - 16);
      uint64_t v12 = "BAD";
      if ((v3 & 0xFFFFFFFE) == 4) {
        CFAllocatorRef v13 = "I";
      }
      else {
        CFAllocatorRef v13 = "BAD";
      }
      uint64_t v14 = *((unsigned int *)this + 46);
      if (v14 <= 6) {
        uint64_t v12 = off_1E5256D98[v14];
      }
      CFStringRef v5 = CFStringCreateWithFormat(v11, 0, @"%@ { state %s, chunk state %s - INVALID, expected body length %ld  }>", v2, v13, v12, *((void *)this + 21));
      break;
  }
  CFStringRef v15 = v5;
  if (v2) {
    CFRelease(v2);
  }
  return v15;
}

uint64_t ___ZN17HTTPServerRequestC2EP23_CFHTTPServerConnection_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  CFAllocatorRef v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 40), 32, 0);
  _OWORD *v4 = 0u;
  v4[1] = 0u;

  return HTTPServerReadStream::HTTPServerReadStream((uint64_t)v4, a2, v3 + 120);
}

uint64_t HTTPServerRequest::HTTPServerRequest(uint64_t a1, NSObject **cf)
{
  *(void *)a1 = &unk_1ECF9DFF0;
  *(void *)(a1 + 8) = &unk_1ECFA2318;
  *(_OWORD *)(a1 + CFRetain((char *)this - 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 48) = 0;
  CFAllocatorRef v4 = (HTTPRequestParserClient *)(a1 + 56);
  CFAllocatorRef v5 = CFGetAllocator(cf);
  HTTPRequestParserClient::HTTPRequestParserClient(v4, v5);
  *(void *)a1 = &unk_1ECF9E950;
  *(void *)(a1 + 8) = &unk_1ECF9E9E8;
  *(void *)(a1 + 56) = &unk_1ECF9EA08;
  *(void *)(a1 + 104) = &unk_1ECF9EA48;
  *(void *)(a1 + 112) = &unk_1ECF9EA78;
  *(void *)(a1 + 120) = &unk_1ECF9EA98;
  *(void *)(a1 + 2CFRetain((char *)this - 16) = &unk_1ECFA1E00;
  *(void *)(a1 + 2CFRelease((char *)this - 24) = 0;
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)(a1 - 16));
  *(void *)(a1 + 128) = CFReadStreamCreate();
  if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1) {
    dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_17041);
  }
  Instance = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    *((void *)Instance + 2) = 0;
    *((void *)Instance + 3) = 0;
    Instance = (HTTPHeaderDict *)((char *)Instance + 16);
  }
  HTTPHeaderDict::HTTPHeaderDict(Instance);
  *(void *)(a1 + 208) = v8;
  *(void *)(a1 + CFRetain((char *)this - 136) = CFRetain(cf);
  if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
  }
  uint64_t v9 = cf[13];
  *(void *)(a1 + 232) = v9;
  dispatch_retain(v9);
  *(_DWORD *)(a1 + 160) = 0;
  CFAllocatorRef v10 = CFAllocatorAllocate(v6, 592, 0);
  bzero((char *)v10 + 33, 0x20FuLL);
  *CFAllocatorRef v10 = &unk_1ECF9A6F8;
  v10[1] = v6;
  v10[2] = &unk_1ECF9A718;
  v10[3] = a1 + 104;
  *((unsigned char *)v10 + 32) = 0;
  v10[71] = 512;
  v10[70] = (char *)v10 + 44;
  *((_OWORD *)v10 + 36) = xmmword_1843D17A0;
  *(void *)(a1 + 144) = v10;
  *(void *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 168) = xmmword_1843D1820;
  return a1;
}

void sub_1842A045C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 2CFRetain((char *)this - 16) = &unk_1ECF9F718;
  CFAllocatorRef v5 = *(const void **)(v1 + 224);
  if (v5) {
    CFRelease(v5);
  }
  *uint64_t v3 = &unk_1ECF9B550;
  HTTPRequestParserClient::~HTTPRequestParserClient(v2);
  _Unwind_Resume(a1);
}

uint64_t HTTPServerRequest::setRequestState(uint64_t result, int a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 152);
  if (v4)
  {
    BOOL result = pthread_mutex_lock((pthread_mutex_t *)(v4 + 24));
    uint64_t v5 = *(void *)(v3 + 152);
    *(_DWORD *)(v3 + 160) = a2;
    *(_DWORD *)(v3 + 164) = a2;
    if (v5)
    {
      return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 24));
    }
  }
  else
  {
    *(_DWORD *)(result + 160) = a2;
    *(_DWORD *)(result + 164) = a2;
  }
  return result;
}

void HTTPServerRequest::appendToBodyDataLocked(HTTPServerRequest *this, const unsigned __int8 *a2, int64_t a3)
{
  if (!*((void *)this + 19) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFStringRef v15 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "habeas corpus ad subjiciendum", v15, 2u);
  }
  if (a3 >= 1)
  {
    uint64_t v6 = *((void *)this + 19);
    uint64_t v7 = *(void *)(v6 + 136);
    uint64_t v8 = *(void *)(v7 + 32);
    if (v8) {
      uint64_t v9 = (void *)(v8 + 16);
    }
    else {
      uint64_t v9 = (void *)(v7 + 24);
    }
    CFAllocatorRef v10 = *(const __CFAllocator **)(v7 + 8);
    CFAllocatorRef v11 = CFAllocatorAllocate(v10, (a3 & 0xFFFFFFFFFFFFFFF0) + 64, 0);
    *CFAllocatorRef v11 = &unk_1ECFA5D08;
    v11[1] = v10;
    v11[2] = 0;
    v11[3] = v11 + 5;
    v11[4] = (char *)v11 + a3 + 40;
    void *v9 = v11;
    *(void *)(v7 + 32) = v11;
    uint64_t v12 = *v9;
    CFAllocatorRef v13 = (void *)(*(uint64_t (**)(void))(*(void *)*v9 + 16))(*v9);
    memcpy(v13, a2, a3);
    uint64_t v14 = *(void *)(v6 + 136);
    *(void *)(v12 + 32) = *(void *)(v12 + 24) + a3;
    *(void *)(v14 + 40) += a3;
    pthread_cond_signal((pthread_cond_t *)(v6 + 88));
  }
}

uint64_t HTTPServerRequest::requestState(HTTPServerRequest *this)
{
  uint64_t v2 = *((void *)this + 19);
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
    uint64_t v3 = *((void *)this + 19);
    uint64_t v4 = *((unsigned int *)this + 40);
    *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = v4;
    if (v3) {
      pthread_mutex_unlock((pthread_mutex_t *)(v3 + 24));
    }
  }
  else
  {
    uint64_t v4 = *((unsigned int *)this + 40);
    *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = v4;
  }
  return v4;
}

uint64_t HTTPServerRequest::producerEOFEncountered(HTTPServerRequest *this)
{
  uint64_t v2 = *((void *)this + 19);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
  }
  int v3 = *((_DWORD *)this + 40);
  if ((v3 - 1) >= 2)
  {
    if (!v3)
    {
      int v3 = 4;
      *((_DWORD *)this + 40) = 4;
    }
  }
  else
  {
    *((_DWORD *)this + 40) = 3;
    uint64_t v4 = *((void *)this + 19);
    if (!v4)
    {
      *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = 3;
      goto LABEL_11;
    }
    pthread_cond_signal((pthread_cond_t *)(v4 + 88));
    int v3 = *((_DWORD *)this + 40);
  }
  uint64_t v5 = *((void *)this + 19);
  *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = v3;
  if (v5) {
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 24));
  }
LABEL_11:

  return HTTPServerRequest::signalReadStreamBasedOnState(this);
}

CFStringRef HTTPServerRequest::copyProperty(HTTPServerRequest *this, CFStringRef theString)
{
  int ExactString = _findExactString(theString, 9u);
  if (ExactString <= 476272944)
  {
    if (ExactString != 473159939)
    {
      if (ExactString == 474183955)
      {
        uint64_t v8 = (CFDictionaryRef *)*((void *)this + 26);
        uint64_t v9 = (char *)this - 16;
        CFAllocatorRef v10 = CFGetAllocator((char *)this - 16);
        CFDictionaryRef v11 = HTTPHeaderDict::copyAsOrdinaryDict(v8, v10);
        if (!v11)
        {
          CFAllocatorRef v25 = CFGetAllocator((char *)this - 16);
          return (CFStringRef)cfTypeCreateMutableDictionary(v25, @"kCFHTTPServerRequestHeaderValues", 0, @"kCFHTTPServerRequestHeaderOrder", 0, 0, 0);
        }
        CFDictionaryRef v12 = v11;
        uint64_t Count = CFDictionaryGetCount(v11);
        uint64_t v14 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
        CFDictionaryGetKeysAndValues(v12, v14, 0);
        if (Count >= 2)
        {
          uint64_t v15 = 1;
          while (1)
          {
            uint64_t v16 = (uint64_t)v14[v15];
            BOOL v17 = v16 >= (uint64_t)&gConstantCFStringValueTable[1911]
               && v16 < (uint64_t)&gConstantCFStringValueTable[2387];
            if (v17 && *(_DWORD *)(v16 + 32) == 311464718) {
              break;
            }
            if (Count == ++v15) {
              goto LABEL_45;
            }
          }
          uint64_t v27 = *v14;
          __CFWriteStream *v14 = (const void *)v16;
          v14[v15] = v27;
        }
LABEL_45:
        CFAllocatorRef v28 = CFGetAllocator(v12);
        CFArrayRef v29 = CFArrayCreate(v28, v14, Count, MEMORY[0x1E4F1D510]);
        free(v14);
        CFAllocatorRef v30 = CFGetAllocator(v9);
        MutableDictionary = cfTypeCreateMutableDictionary(v30, @"kCFHTTPServerRequestHeaderValues", v12, @"kCFHTTPServerRequestHeaderOrder", v29, 0, 0);
        if (v29) {
          CFRelease(v29);
        }
        CFDictionaryRef v24 = v12;
LABEL_48:
        CFRelease(v24);
        return (CFStringRef)MutableDictionary;
      }
      if (ExactString == 475265313)
      {
        if (!*((void *)this + 28)) {
          return 0;
        }
        CFGetAllocator((char *)this - 16);
        uint64_t v5 = (const void *)*((void *)this + 28);
        if (!v5) {
          return 0;
        }
        goto LABEL_18;
      }
LABEL_36:
      HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v31, theString);
      uint64_t v21 = (CFDictionaryRef *)*((void *)this + 26);
      CFAllocatorRef v22 = CFGetAllocator((char *)this - 16);
      MutableDictionary = (void *)HTTPHeaderDict::copyStringValue(v21, v22, (const HTTPHeaderKeyMixedValue *)&v31);
      size_t v31 = &unk_1ECF9F718;
      CFDictionaryRef v24 = v32;
      if (!v32) {
        return (CFStringRef)MutableDictionary;
      }
      goto LABEL_48;
    }
    uint64_t v6 = (const void *)*((void *)this + 17);
    if (v6)
    {
      if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
        dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
      }
      uint64_t v5 = v6;
      goto LABEL_18;
    }
    return 0;
  }
  if (ExactString == 476272945)
  {
    CFGetAllocator((char *)this - 16);
    uint64_t v5 = (const void *)*((void *)this + 10);
    if (!v5) {
      return 0;
    }
    goto LABEL_18;
  }
  if (ExactString != 477305151)
  {
    if (ExactString != 478345548) {
      goto LABEL_36;
    }
    uint64_t v5 = (const void *)HTTPRequestParserClient::requestURL((HTTPServerRequest *)((char *)this + 56));
    if (!v5) {
      return 0;
    }
LABEL_18:
    return (CFStringRef)CFRetain(v5);
  }
  uint64_t v18 = (const char *)*((void *)this + 11);
  if (v18)
  {
    size_t v19 = strlen(v18);
    CFAllocatorRef v20 = (const __CFAllocator *)*((void *)this + 8);
    return CFStringCreateWithBytes(v20, (const UInt8 *)v18, v19, 0x201u, 0);
  }
  else
  {
    if (!HTTPRequestParserClient::requestURL((HTTPServerRequest *)((char *)this + 56))) {
      return 0;
    }
    CFURLRef v26 = (const __CFURL *)*((void *)this + 12);
    return CFURLCopyPath(v26);
  }
}

void sub_1842A0AE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPServerRequest::remainingBodySize(HTTPServerRequest *this)
{
  uint64_t v2 = *((void *)this + 19);
  if (v2 && (pthread_mutex_lock((pthread_mutex_t *)(v2 + 24)), (uint64_t v3 = *((void *)this + 19)) != 0))
  {
    uint64_t v4 = *(void *)(*(void *)(v3 + 136) + 40);
    *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = *((_DWORD *)this + 40);
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 24));
  }
  else
  {
    uint64_t v4 = 0;
    *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = *((_DWORD *)this + 40);
  }
  return v4;
}

void HTTPServerRequest::loseConnectionReferenceAndTerminateReads(HTTPServerRequest *this)
{
  uint64_t v2 = *((void *)this + 19);
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 24));
    uint64_t v3 = *((void *)this + 19);
    if (v3) {
      pthread_cond_signal((pthread_cond_t *)(v3 + 88));
    }
  }
  uint64_t v4 = (const void *)*((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *((unsigned int *)this + 40);
  if (v5 <= 2)
  {
    LODWORD(v5) = dword_18430C0AC[v5];
    *((_DWORD *)this + 40) = v5;
  }
  uint64_t v6 = (const void *)*((void *)this + 16);
  *((void *)this + CFRetain((char *)this - 16) = 0;
  if (v6)
  {
    CFRelease(v6);
    LODWORD(v5) = *((_DWORD *)this + 40);
  }
  *((_DWORD *)this + 4HTTPServerConnection::canceled_onQueue(this - 1) = v5;
  uint64_t v7 = *((void *)this + 19);
  if (v7)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v7 + 24));
  }
}

void non-virtual thunk to'HTTPServerResponse::_subclass_release(HTTPServerResponse *this)
{
}

HTTPServerResponse *non-virtual thunk to'HTTPServerResponse::_subclass_retain(HTTPServerResponse *this)
{
  return this;
}

void non-virtual thunk to'HTTPServerResponse::closeUnderlyingStream(HTTPServerResponse *this)
{
}

void HTTPServerResponse::closeUnderlyingStream(HTTPServerResponse *this)
{
  uint64_t v2 = *((void *)this + 16);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + CFRetain((char *)this - 16) = 0;
  }
  uint64_t v3 = (const void *)*((void *)this + 14);
  if (v3)
  {
    uint64_t v4 = *((void *)this + 15);
    *((void *)this + 14) = 0;
    *((void *)this + 15) = 0;
    if (v4)
    {
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 3221225472;
      v5[2] = ___ZN18HTTPServerResponse21closeUnderlyingStreamEv_block_invoke;
      v5[3] = &__block_descriptor_40_e5_v8__0l;
      v5[4] = v3;
      (*(void (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, v5);
      (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
    }
    else
    {
      CFRelease(v3);
    }
  }
  *((unsigned char *)this + CFRetain((char *)this - 136) = 1;
}

void ___ZN18HTTPServerResponse21closeUnderlyingStreamEv_block_invoke(uint64_t a1)
{
  CFReadStreamSetClient(*(CFReadStreamRef *)(a1 + 32), 0, 0, 0);
  CFReadStreamClose(*(CFReadStreamRef *)(a1 + 32));
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t non-virtual thunk to'HTTPServerResponse::readFromUnderlyingStream(HTTPServerResponse *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  return HTTPServerResponse::readFromUnderlyingStream((HTTPServerResponse *)((char *)this - 64), a2, a3, a4, a5);
}

uint64_t HTTPServerResponse::readFromUnderlyingStream(HTTPServerResponse *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  uint64_t result = *((void *)this + 16);
  if (result)
  {
    memset(&v8[2], 0, 32);
    v8[0] = a2;
    v8[1] = a3;
    (*(void (**)(uint64_t, void *))(*(void *)result + 24))(result, v8);
    uint64_t result = v8[2];
    if (v8[2] > -2)
    {
      if (LOBYTE(v8[5])) {
        *a5 = 1;
      }
    }
    else if (a4)
    {
      *a4 = *(CFStreamError *)&v8[3];
    }
    if (BYTE1(v8[5]) | LOBYTE(v8[5]))
    {
      _CFReadStreamSignalEventDelayed();
      return v8[2];
    }
  }
  else
  {
    *a5 = 1;
  }
  return result;
}

uint64_t non-virtual thunk to'HTTPServerResponse::canReadFromUnderlyingStream(HTTPServerResponse *this)
{
  uint64_t result = *((void *)this + 8);
  if (result) {
    return (*(unsigned int (**)(uint64_t))(*(void *)result + 16))(result) != 0;
  }
  return result;
}

uint64_t non-virtual thunk to'HTTPServerResponse::openUnderlyingStream(HTTPServerResponse *this, CFStreamError *a2)
{
  return HTTPServerResponse::openUnderlyingStream((HTTPServerResponse *)((char *)this - 64), a2);
}

uint64_t HTTPServerResponse::openUnderlyingStream(HTTPServerResponse *this, CFStreamError *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  CFStringRef v4 = CFHTTPMessageCopyHeaderFieldValue(*((CFHTTPMessageRef *)this + 12), (CFStringRef)&unk_1EC0A20E0);
  if (v4)
  {
    CFRelease(v4);
  }
  else
  {
    CFStringRef v7 = CFHTTPMessageCopyHeaderFieldValue(*((CFHTTPMessageRef *)this + 12), @"Content-Type");
    if (!v7
      || (CFStringRef v8 = v7,
          v38.socklen_t length = CFStringGetLength(v7),
          v38.location = 0,
          int v9 = CFStringFindWithOptions(v8, @"multipart/x-mixed-replace", v38, 1uLL, 0),
          CFRelease(v8),
          !v9))
    {
      CFAllocatorRef v10 = (__CFReadStream *)*((void *)this + 14);
      if (v10)
      {
        CFStringRef v11 = (const __CFString *)CFReadStreamCopyProperty(v10, @"kCFStreamPropertyStreamLength");
        unsigned int valuePtr = -1;
        if (!v11) {
          goto LABEL_33;
        }
        CFStringRef v12 = v11;
        CFTypeID v13 = CFGetTypeID(v11);
        if (v13 == CFStringGetTypeID())
        {
          unsigned int valuePtr = CFStringGetIntValue(v12);
        }
        else if (v13 == CFNumberGetTypeID() && !CFNumberGetValue((CFNumberRef)v12, kCFNumberSInt32Type, &valuePtr))
        {
          unsigned int valuePtr = -1;
        }
        CFRelease(v12);
        if (valuePtr == -1)
        {
LABEL_33:
          CFStringRef v29 = CFHTTPMessageCopyHeaderFieldValue(*((CFHTTPMessageRef *)this + 12), (CFStringRef)&unk_1EC0A29D8);
          CFStringRef v30 = v29;
          if (v29)
          {
            v39.socklen_t length = CFStringGetLength(v29);
            v39.location = 0;
            if (!CFStringFindWithOptions(v30, @"chunked", v39, 1uLL, 0))
            {
              size_t v31 = (__CFHTTPMessage *)*((void *)this + 12);
              CFAllocatorRef v32 = CFGetAllocator((char *)this - 16);
              AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)&clientContext, v32, @"%@%@", v30, 0x1EC0A2CB0);
              CFHTTPMessageSetHeaderFieldValue(v31, (CFStringRef)&unk_1EC0A29D8, (CFStringRef)clientContext.info);
              AutoString::~AutoString((AutoString *)&clientContext);
            }
            CFRelease(v30);
          }
          else
          {
            CFHTTPMessageSetHeaderFieldValue(*((CFHTTPMessageRef *)this + 12), (CFStringRef)&unk_1EC0A29D8, @"chunked");
          }
          *((unsigned char *)this + 104) = 1;
        }
        else
        {
          uint64_t v27 = (__CFHTTPMessage *)*((void *)this + 12);
          CFAllocatorRef v28 = CFGetAllocator((char *)this - 16);
          AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)&clientContext, v28, @"%d", valuePtr);
          CFHTTPMessageSetHeaderFieldValue(v27, (CFStringRef)&unk_1EC0A20E0, (CFStringRef)clientContext.info);
          AutoString::~AutoString((AutoString *)&clientContext);
        }
      }
      else
      {
        CFDataRef v22 = CFHTTPMessageCopyBody(*((CFHTTPMessageRef *)this + 12));
        if (v22)
        {
          CFDataRef v23 = v22;
          CFDictionaryRef v24 = (__CFHTTPMessage *)*((void *)this + 12);
          CFAllocatorRef v25 = CFGetAllocator((char *)this - 16);
          CFIndex Length = CFDataGetLength(v23);
          AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)&clientContext, v25, @"%ld", Length);
          CFHTTPMessageSetHeaderFieldValue(v24, (CFStringRef)&unk_1EC0A20E0, (CFStringRef)clientContext.info);
          AutoString::~AutoString((AutoString *)&clientContext);
          CFRelease(v23);
        }
      }
    }
  }
  uint64_t v5 = (__CFHTTPMessage *)*((void *)this + 12);
  if (v5)
  {
    if (CFHTTPMessageGetResponseStatusCode(v5) == 100)
    {
      BOOL v6 = 0;
      goto LABEL_40;
    }
    uint64_t v5 = (__CFHTTPMessage *)*((void *)this + 12);
  }
  CFStringRef v14 = CFHTTPMessageCopyHeaderFieldValue(v5, @"Connection");
  int v15 = figureCloseKind(v14);
  if (v14) {
    CFRelease(v14);
  }
  if (v15)
  {
    BOOL v6 = v15 == 2;
    goto LABEL_40;
  }
  CFStringRef v16 = HTTPServerRequest::copyProperty(*((HTTPServerRequest **)this + 10), @"Connection");
  int v17 = figureCloseKind(v16);
  CFStringRef v18 = CFHTTPMessageCopyVersion(*((CFHTTPMessageRef *)this + 12));
  CFStringRef v19 = v18;
  if (!v18)
  {
    if (v17)
    {
      BOOL v6 = v17 == 2;
      goto LABEL_23;
    }
    BOOL v21 = 0;
LABEL_38:
    BOOL v6 = !v21;
    if (!v16) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  int CanonicalString = _findCanonicalString(v18, 8u);
  BOOL v21 = CanonicalString == 428939076;
  CFRelease(v19);
  if (!v17) {
    goto LABEL_38;
  }
  BOOL v6 = v17 == 2;
  if (CanonicalString != 428939076) {
LABEL_23:
  }
    CFHTTPMessageSetHeaderFieldValue(*((CFHTTPMessageRef *)this + 12), @"Connection", v16);
  if (v16) {
LABEL_39:
  }
    CFRelease(v16);
LABEL_40:
  *((unsigned char *)this + 105) = v6;
  if (!*((void *)this + 14)) {
    goto LABEL_43;
  }
  uint64_t v33 = (*(uint64_t (**)(HTTPServerResponse *))(*(void *)this + 104))(this);
  *((void *)this + 15) = v33;
  if (v33)
  {
    clientContext.version = 0;
    clientContext.info = this;
    clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
    clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
    CFReadStreamSetClient(*((CFReadStreamRef *)this + 14), 0x1AuLL, (CFReadStreamClientCallBack)HTTPServerResponse::_readStreamCallback, &clientContext);
    CoreSchedulingSet::_scheduleStream(*((void *)this + 15), *((void *)this + 14), MEMORY[0x1E4F1C268], MEMORY[0x1E4F1C260]);
    if (CFReadStreamOpen(*((CFReadStreamRef *)this + 14)))
    {
LABEL_43:
      if (*((unsigned char *)this + 104)) {
        operator new();
      }
      operator new();
    }
    if (a2) {
      *a2 = CFReadStreamGetError((CFReadStreamRef)*((void *)this + 14));
    }
  }
  else if (a2)
  {
    a2->domain = 1;
    a2->error = 22;
  }
  return 2;
}

void sub_1842A14E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

uint64_t HTTPServerResponse::_readStreamCallback(HTTPServerResponse *this, __CFReadStream *a2, unint64_t a3, void *a4)
{
  return _CFReadStreamSignalEventDelayed();
}

uint64_t figureCloseKind(CFStringRef theString)
{
  uint64_t v1 = (uint64_t)theString;
  if (theString)
  {
    int CanonicalString = _findCanonicalString(theString, 6u);
    if (CanonicalString == 372331669)
    {
      return 1;
    }
    else if (CanonicalString == 365999224)
    {
      return 2;
    }
    else
    {
      CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)v1, @", ");
      CFContainerEnumeratorBase::setup((unint64_t)v7, ArrayBySeparatingStrings, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
      uint64_t v10 = 0;
      if (ArrayBySeparatingStrings) {
        CFRelease(ArrayBySeparatingStrings);
      }
      while (1)
      {
        uint64_t v4 = v10;
        if (v10 >= v8)
        {
          CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v7);
          return 0;
        }
        ++v10;
        int v5 = _findCanonicalString(*(CFStringRef *)(v9 + 8 * v4), 6u);
        if (v5 == 365999224) {
          break;
        }
        if (v5 == 372331669)
        {
          uint64_t v1 = 1;
          goto LABEL_14;
        }
      }
      uint64_t v1 = 2;
LABEL_14:
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v7);
    }
  }
  return v1;
}

void sub_1842A16A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTPServerResponse::~HTTPServerResponse(HTTPServerResponse *this)
{
}

{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 64));
}

{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 56));
}

{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 56));
}

{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 8));
}

{
  HTTPServerResponse::~HTTPServerResponse((HTTPServerResponse *)((char *)this - 8));
}

void HTTPServerResponse::~HTTPServerResponse(HTTPServerResponse *this)
{
  *(void *)this = &unk_1ECF9F500;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9F580;
  *((void *)this + 7) = &unk_1ECF9F5A0;
  *((void *)this + 8) = &unk_1ECF9F5C0;
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    CFRelease((CFTypeRef)(v2 - 16));
    *((void *)this + 10) = 0;
  }
  uint64_t v3 = *((void *)this + 16);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    *((void *)this + CFRetain((char *)this - 16) = 0;
  }
  uint64_t v4 = (const void *)*((void *)this + 12);
  if (v4) {
    CFRelease(v4);
  }
  int v5 = (const void *)*((void *)this + 11);
  if (v5) {
    CFRelease(v5);
  }
  BOOL v6 = (const void *)*((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v6) {
    CFRelease(v6);
  }
  *((void *)this + 7) = &unk_1ECF9B550;
}

void sub_1842A17F0(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

CFAllocatedReferenceCountedObject *HTTPServerResponse::coreStreamCopySchedulingInfo(HTTPServerResponse *this)
{
  uint64_t v1 = *((void *)this + 10);
  if (v1 && (uint64_t v2 = *(void *)(v1 + 136)) != 0)
  {
    if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
      dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
    }
    uint64_t v3 = *(NSObject **)(v2 + 104);
    uint64_t v4 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 96, 0);
    *(_OWORD *)uint64_t v4 = 0u;
    *((_OWORD *)v4 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
    *((_OWORD *)v4 + 2) = 0u;
    *((_OWORD *)v4 + 3) = 0u;
    *((_OWORD *)v4 + 4) = 0u;
    *((_OWORD *)v4 + 5) = 0u;
    return QCoreSchedulingSet::QCoreSchedulingSet(v4, v3);
  }
  else
  {
    return (CFAllocatedReferenceCountedObject *)CoreSchedulingSet::createEmpty((CoreSchedulingSet *)this);
  }
}

void HTTPServerResponse::_subclass_release(HTTPServerResponse *this)
{
}

uint64_t HTTPServerResponse::_subclass_retain(HTTPServerResponse *this)
{
  return (uint64_t)this + 64;
}

uint64_t HTTPServerResponse::canReadFromUnderlyingStream(HTTPServerResponse *this)
{
  uint64_t result = *((void *)this + 16);
  if (result) {
    return (*(unsigned int (**)(uint64_t))(*(void *)result + 16))(result) != 0;
  }
  return result;
}

CFStringRef HTTPServerResponse::copyDebugDesc(HTTPServerResponse *this)
{
  CFStringRef v2 = CFObject::copyDebugDescHeader(this);
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  if (*((unsigned char *)this + 136)) {
    uint64_t v4 = "completed";
  }
  else {
    uint64_t v4 = "incomplete";
  }
  CFStringRef v5 = CFStringCreateWithFormat(v3, 0, @"%@ { %@ %s }>", v2, *((void *)this + 12), v4);
  if (v2) {
    CFRelease(v2);
  }
  return v5;
}

uint64_t ___ZN18HTTPServerResponseC2EP17HTTPServerRequest_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)(v3 - 16));
  CFStringRef v5 = CFAllocatorAllocate(v4, 32, 0);
  *CFStringRef v5 = 0u;
  v5[1] = 0u;

  return HTTPServerReadStream::HTTPServerReadStream((uint64_t)v5, a2, v3 + 64);
}

void HTTPServerResponse::HTTPServerResponse(HTTPServerResponse *this, HTTPServerRequest *a2)
{
  *((_OWORD *)this + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(void *)this = &unk_1ECF9F500;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9F580;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = &unk_1ECF9F5A0;
  *((void *)this + 8) = &unk_1ECF9F5C0;
  CFGetAllocator((char *)this - 16);
  *((void *)this + 9) = CFReadStreamCreate();
  *((void *)this + 10) = a2;
  CFRetain((char *)a2 - 16);
  *((unsigned char *)this + 104) = 0;
  *((unsigned char *)this + CFRetain((char *)this - 136) = 0;
}

void sub_1842A1B78(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void ResponseDataCombiner::read(void *a1, uint64_t a2)
{
  if (*(uint64_t *)(a2 + 8) < 1) {
    return;
  }
  if (a1[1])
  {
    if (a1[2] < a1[3])
    {
      ResponseDataCombiner::readHeaderData((uint64_t)a1, a2);
      if (*(uint64_t *)(a2 + 8) < 1) {
        return;
      }
    }
  }
  CFAllocatorRef v4 = (__CFReadStream *)a1[4];
  if (!v4) {
    goto LABEL_11;
  }
  if (!CFReadStreamHasBytesAvailable(v4))
  {
    if (a1[4])
    {
LABEL_12:
      *(unsigned char *)(a2 + 4HTTPServerConnection::canceled_onQueue(this - 1) = 1;
      return;
    }
LABEL_11:
    *(unsigned char *)(a2 + 40) = 1;
    goto LABEL_12;
  }

  ResponseDataCombiner::readBodyStreamData((uint64_t)a1, a2);
}

void ResponseDataCombiner::readHeaderData(uint64_t a1, uint64_t a2)
{
  v4.location = *(void *)(a1 + 16);
  CFStringRef v5 = (void *)(a1 + 16);
  if (*(void *)(a2 + 8) >= *(void *)(a1 + 24) - v4.location) {
    CFIndex v6 = *(void *)(a1 + 24) - v4.location;
  }
  else {
    CFIndex v6 = *(void *)(a2 + 8);
  }
  v4.socklen_t length = v6;
  CFDataGetBytes(*(CFDataRef *)(a1 + 8), v4, *(UInt8 **)a2);
  CFIndex v7 = *(void *)(a2 + 8) - v6;
  *(void *)a2 += v6;
  *(void *)(a2 + 8) = v7;
  *(void *)(a2 + 16) += v6;
  CFIndex v8 = v5[1];
  CFIndex v9 = *v5 + v6;
  *CFStringRef v5 = v9;
  if (v9 >= v8)
  {
    uint64_t v10 = *(const void **)(a1 + 8);
    *(void *)(a1 + 8) = 0;
    if (v10) {
      CFRelease(v10);
    }
    *CFStringRef v5 = 0;
    v5[1] = 0;
  }
  else
  {
    *(unsigned char *)(a2 + 4HTTPServerConnection::canceled_onQueue(this - 1) = 1;
  }
}

CFIndex ResponseDataCombiner::readBodyStreamData(uint64_t a1, uint64_t a2)
{
  CFIndex v4 = CFReadStreamRead(*(CFReadStreamRef *)(a1 + 32), *(UInt8 **)a2, *(void *)(a2 + 8));
  CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*(void *)(a1 + 32));
  CFIndex result = Error.domain;
  *(CFStreamError *)(a2 + CFRelease((char *)this - 24) = Error;
  if (v4)
  {
    if (v4 < 1) {
      return result;
    }
    CFIndex v7 = *(void *)(a2 + 8) - v4;
    *(void *)a2 += v4;
    *(void *)(a2 + 8) = v7;
    *(void *)(a2 + 16) += v4;
    CFIndex result = CFReadStreamGetStatus(*(CFReadStreamRef *)(a1 + 32));
    BOOL v8 = result == 5;
  }
  else
  {
    BOOL v8 = 1;
  }
  *(unsigned char *)(a2 + 40) = v8;
  return result;
}

uint64_t ResponseDataCombiner::canRead(ResponseDataCombiner *this)
{
  if (*((void *)this + 1) && *((void *)this + 2) < *((void *)this + 3)) {
    return 1;
  }
  uint64_t result = *((void *)this + 4);
  if (result) {
    return CFReadStreamHasBytesAvailable((CFReadStreamRef)result) != 0;
  }
  return result;
}

void ResponseDataCombiner::~ResponseDataCombiner(ResponseDataCombiner *this)
{
  ResponseDataCombiner::~ResponseDataCombiner(this);

  JUMPOUT(0x18531B6D0);
}

{
  const void *v2;

  *(void *)this = &unk_1ECFA18D0;
  CFStringRef v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 4) = 0;
  *(void *)this = &unk_1ECF9B550;
}

void sub_1842A1E58(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void ResponseDataCombiner::ResponseDataCombiner(ResponseDataCombiner *this, CFHTTPMessageRef message, __CFReadStream *a3)
{
  *(void *)this = &unk_1ECFA18D0;
  CFDataRef Length = CFHTTPMessageCopySerializedMessage(message);
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = Length;
  *((void *)this + 2) = 0;
  if (Length) {
    CFDataRef Length = (const __CFData *)CFDataGetLength(Length);
  }
  *((void *)this + 3) = Length;
  *((void *)this + 4) = a3;
}

void sub_1842A1ED8(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void *std::ifstream::~ifstream(void *a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA3F8];
  uint64_t v3 = *MEMORY[0x1E4FBA3F8];
  *a1 = *MEMORY[0x1E4FBA3F8];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x18531B520](a1 + 2);
  std::istream::~istream();
  MEMORY[0x18531B660](a1 + 53);
  return a1;
}

void CoreDiagMsg::logHex(CFMutableArrayRef *this, const char *a2, UInt8 *bytes, CFIndex length)
{
  CFIndex v6 = (__CFString *)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, length);
  CoreDiagMsg::_addPair(this, a2, v6);
  if (v6)
  {
    CFRelease(v6);
  }
}

void CoreDiagMsg::_addPair(CFMutableArrayRef *this, const char *a2, __CFString *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex v6 = off_1ECF9A530;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  CFStringRef v7 = CFStringCreateWithCString(v5, a2, 0x8000100u);
  CoreDiagMsg::_addPair(this, v7, a3);
  AutoString::~AutoString((AutoString *)&v6);
}

void sub_1842A20F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void CoreDiagMsg::_addPair(CFMutableArrayRef *this, const __CFString *a2, __CFString *a3)
{
  if (a2)
  {
    CFArrayAppendValue(this[3], a2);
    CFIndex v6 = this[2];
    if (a3) {
      CFStringRef v7 = a3;
    }
    else {
      CFStringRef v7 = @"(null)";
    }
    CFDictionarySetValue(v6, a2, v7);
  }
}

void CoreDiagMsg::logDict(CFMutableArrayRef *this, const char *a2, const __CFArray *a3, const __CFDictionary *a4)
{
  if (a3)
  {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a4);
    CFDictionarySetValue(MutableCopy, @"<< ORDER >>", a3);
    CoreDiagMsg::_addPair(this, a2, (__CFString *)MutableCopy);
    if (MutableCopy)
    {
      CFRelease(MutableCopy);
    }
  }
  else
  {
    CoreDiagMsg::_addPair(this, a2, (__CFString *)a4);
  }
}

void CoreDiagMsg::logFormat(CFMutableArrayRef *this, const char *a2, const __CFString *a3, ...)
{
  va_start(va, a3);
  CFAllocatorRef v5 = (__CFString *)CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a3, va);
  CoreDiagMsg::_addPair(this, a2, v5);
  if (v5) {
    CFRelease(v5);
  }
}

void CoreDiagMsg::logPair(CoreDiagMsg *this, const char *a2, __CFError *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v8 = off_1ECF9A530;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  CFStringRef v9 = CFStringCreateWithCString(v5, a2, 0x8000100u);
  if (a3)
  {
    if (__CFNCanLogSensitiveContent::onceToken != -1) {
      dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_38);
    }
    if (__CFNCanLogSensitiveContent::ok) {
      CFStringRef v6 = CFCopyDescription(a3);
    }
    else {
      CFStringRef v6 = (CFStringRef)objc_msgSend((id)-[__CFError redactedDescription](a3, "redactedDescription", v8), "copy");
    }
    CFStringRef v7 = (__CFString *)v6;
  }
  else
  {
    CFStringRef v7 = @"null";
  }
  (*(void (**)(CoreDiagMsg *, CFStringRef, __CFString *))(*(void *)this + 64))(this, v9, v7);
  if (a3 && v7) {
    CFRelease(v7);
  }
  AutoString::~AutoString((AutoString *)&v8);
}

void sub_1842A2408(_Unwind_Exception *exception_object)
{
}

void CoreDiagMsg::logPair(CoreDiagMsg *this, const char *a2, NSURLRequest *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v9 = off_1ECF9A530;
  CFStringRef v6 = CFStringCreateWithCString(v5, a2, 0x8000100u);
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  CFStringRef v10 = v6;
  if (a3)
  {
    CFStringRef v7 = [(NSURLRequest *)a3 _inner];
    uint64_t v8 = (__CFString *)(*(uint64_t (**)(void *))(*(void *)v7 + 24))(v7);
    CFStringRef v6 = v10;
  }
  else
  {
    uint64_t v8 = @"null";
  }
  (*(void (**)(CoreDiagMsg *, CFStringRef, __CFString *))(*(void *)this + 64))(this, v6, v8);
  if (a3 && v8) {
    CFRelease(v8);
  }
  AutoString::~AutoString((AutoString *)&v9);
}

void sub_1842A2550(_Unwind_Exception *exception_object)
{
}

void CoreDiagMsg::logPair(CoreDiagMsg *this, const char *a2, const __CFURL *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v8 = off_1ECF9A530;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  CFStringRef v9 = CFStringCreateWithCString(v5, a2, 0x8000100u);
  if (a3)
  {
    if (__CFNCanLogSensitiveContent::onceToken != -1) {
      dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_38);
    }
    if (__CFNCanLogSensitiveContent::ok || _CFURLIsFileURL()) {
      CFStringRef v6 = CFCopyDescription(a3);
    }
    else {
      CFStringRef v6 = CFStringCreateWithFormat(v5, 0, @"%@://%@/<redacted>", [(__CFURL *)a3 scheme], [(__CFURL *)a3 host], v8);
    }
    CFStringRef v7 = (__CFString *)v6;
  }
  else
  {
    CFStringRef v7 = @"null";
  }
  (*(void (**)(CoreDiagMsg *, CFStringRef, __CFString *))(*(void *)this + 64))(this, v9, v7);
  if (a3 && v7) {
    CFRelease(v7);
  }
  AutoString::~AutoString((AutoString *)&v8);
}

void sub_1842A26E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t CoreDiagMsg::initialize(CFMutableArrayRef *this, const char *a2, const CFAllocatedReferenceCountedObject *a3, ...)
{
  if (a3)
  {
    CFAllocatorRef v5 = (__CFString *)(*(uint64_t (**)(const CFAllocatedReferenceCountedObject *))(*(void *)a3 + 16))(a3);
    CoreDiagMsg::_addPair(this, a2, v5);
    if (v5) {
      CFRelease(v5);
    }
    return 1;
  }
  else
  {
    CFStringRef v7 = (uint64_t (*)(void))*((void *)*this + 2);
    return v7();
  }
}

uint64_t CoreDiagMsg::initialize(CFMutableArrayRef *this, const char *a2, const CFObject *a3, ...)
{
  if (a3)
  {
    CFAllocatorRef v5 = (__CFString *)(*(uint64_t (**)(const CFObject *))(*(void *)a3 + 32))(a3);
    CoreDiagMsg::_addPair(this, a2, v5);
    if (v5) {
      CFRelease(v5);
    }
    return 1;
  }
  else
  {
    CFStringRef v7 = (uint64_t (*)(void))*((void *)*this + 2);
    return v7();
  }
}

uint64_t CoreDiagMsg::initialize(CFMutableArrayRef *this, const char *a2, void *a3)
{
  return 1;
}

void CoreDiagMsg::~CoreDiagMsg(const __CFArray **this)
{
  CoreDiagMsg::~CoreDiagMsg(this);

  JUMPOUT(0x18531B6D0);
}

{
  __CFData *Mutable;
  NSObject *v3;
  CFArrayRef v4;
  CFArrayRef v5;
  uint8_t buf[4];
  const UInt8 *BytePtr;
  uint64_t v8;

  uint64_t v8 = *MEMORY[0x1E4F143B8];
  *this = (const __CFArray *)&unk_1ECF9AA08;
  if (CoreDiagMsg::~CoreDiagMsg()::onceToken != -1) {
    dispatch_once(&CoreDiagMsg::~CoreDiagMsg()::onceToken, &__block_literal_global_22_16596);
  }
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  mdPrintf(Mutable, 0, @"CFNetwork Diagnostics [%d:%d] %s {\n", *((unsigned int *)this + 2), *((unsigned int *)this + 22), (char *)this + 92);
  flattenDict0(Mutable, 0, this[3], this[2]);
  mdPrintf(Mutable, 0, @"} [%d:%d]\n", *((unsigned int *)this + 2), *((unsigned int *)this + 22));
  CFDataAppendBytes(Mutable, byte_18430C0B8, 1);
  uint64_t v3 = CoreDiagMsg::~CoreDiagMsg()::l;
  if (os_log_type_enabled((os_log_t)CoreDiagMsg::~CoreDiagMsg()::l, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    BytePtr = CFDataGetBytePtr(Mutable);
    _os_log_impl(&dword_184085000, v3, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  CFIndex v4 = this[3];
  if (v4) {
    CFRelease(v4);
  }
  CFAllocatorRef v5 = this[2];
  if (v5) {
    CFRelease(v5);
  }
}

CFIndex mdPrintf(CFMutableDataRef theData, uint64_t a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a2 >= 1)
  {
    uint64_t v6 = a2;
    do
    {
      CFDataAppendBytes(theData, (const UInt8 *)" ", 1);
      --v6;
    }
    while (v6);
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v8 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, format, va);
  if (format) {
    CFRelease(format);
  }
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(v7, v8, 0x8000100u, 0x2Eu);
  if (v8) {
    CFRelease(v8);
  }
  CFIndex Length = CFDataGetLength(ExternalRepresentation);
  BytePtr = CFDataGetBytePtr(ExternalRepresentation);
  CFDataAppendBytes(theData, BytePtr, Length);
  if (ExternalRepresentation) {
    CFRelease(ExternalRepresentation);
  }
  return Length + a2;
}

void flattenDict0(__CFData *a1, uint64_t a2, const __CFArray *a3, const __CFDictionary *a4)
{
  if (a3)
  {
    CFArrayRef Mutable = a3;
    CFRetain(a3);
  }
  else
  {
    Value = CFDictionaryGetValue(a4, @"<< ORDER >>");
    if (Value)
    {
      CFArrayRef Mutable = (const __CFArray *)CFRetain(Value);
    }
    else
    {
      CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      CFDictionaryApplyFunction(a4, (CFDictionaryApplierFunction)_fetchKeys, Mutable);
    }
  }
  CFContainerEnumeratorBase::setup((unint64_t)v42, Mutable, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
  uint64_t v45 = 0;
  if (v43 < 1)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    do
    {
      uint64_t v45 = v9 + 1;
      CFStringRef v11 = *(const __CFString **)(v44 + 8 * v9);
      if (!CFEqual(v11, @"<< ORDER >>"))
      {
        if (CFDictionaryGetValue(a4, v11))
        {
          CFIndex Length = CFStringGetLength(v11);
          if (Length > v10) {
            uint64_t v10 = Length;
          }
        }
      }
      uint64_t v9 = v45;
    }
    while (v45 < v43);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v42);
  CFArrayRef cf = Mutable;
  CFContainerEnumeratorBase::setup((unint64_t)v34, Mutable, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
  uint64_t v37 = 0;
  if (v35 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = v10 + a2;
    do
    {
      uint64_t v37 = v13 + 1;
      CFStringRef v15 = *(const __CFString **)(v36 + 8 * v13);
      CFArrayRef v16 = (const __CFArray *)CFDictionaryGetValue(a4, v15);
      CFArrayRef v17 = v16;
      if (v16)
      {
        CFTypeID v18 = CFGetTypeID(v16);
        if (v18 == CFStringGetTypeID())
        {
          CFStringRef v19 = (const __CFString *)v17;
        }
        else
        {
          CFTypeID TypeID = CFNullGetTypeID();
          CFStringRef v19 = @"null";
          if (v18 != TypeID)
          {
            if (v18 == CFArrayGetTypeID())
            {
              CFIndex v22 = CFStringGetLength(v15);
              CFIndex v23 = mdPrintf(a1, v14 - v22, @"%@: ", v15);
              CFIndex Count = CFArrayGetCount(v17);
              mdPrintf(a1, 0, @"array [%d] {\n", Count);
              CFContainerEnumeratorBase::setup((unint64_t)v42, v17, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
              uint64_t v45 = 0;
              if (v43 >= 1)
              {
                uint64_t v25 = 0;
                do
                {
                  uint64_t v45 = v25 + 1;
                  CFURLRef v26 = wrapStrings(*(const __CFString **)(v44 + 8 * v25), 1020 - v23);
                  CFContainerEnumeratorBase::setup((unint64_t)v38, v26, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
                  uint64_t v41 = 0;
                  while (1)
                  {
                    uint64_t v27 = v41;
                    if (v41 >= v39) {
                      break;
                    }
                    ++v41;
                    mdPrintf(a1, v23 + 4, @"%@\n", *(void *)(v40 + 8 * v27));
                  }
                  if (v26) {
                    CFRelease(v26);
                  }
                  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v38);
                  uint64_t v25 = v45;
                }
                while (v45 < v43);
              }
              mdPrintf(a1, v23, @"}\n");
              CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v42);
            }
            else if (v18 == CFDictionaryGetTypeID())
            {
              CFIndex v28 = CFStringGetLength(v15);
              CFIndex v29 = mdPrintf(a1, v14 - v28, @"%@: ", v15);
              CFIndex v30 = CFDictionaryGetCount(v17);
              mdPrintf(a1, 0, @"dict [%d] {\n", v30);
              flattenDict0(a1, v29 + 4, 0, v17);
              mdPrintf(a1, v29, @"}\n");
            }
            else if (v18 == CFDataGetTypeID())
            {
              addData(a1, a2, (uint64_t)v15, v17, v31);
            }
            else
            {
              CFStringRef v32 = CFCopyDescription(v17);
              addString(a1, a2, v10, v15, v32);
              if (v32) {
                CFRelease(v32);
              }
            }
            goto LABEL_23;
          }
        }
        addString(a1, a2, v10, v15, v19);
      }
      else
      {
        CFIndex v20 = CFStringGetLength(v15);
        mdPrintf(a1, v14 - v20, @"%@\n", v15);
      }
LABEL_23:
      uint64_t v13 = v37;
    }
    while (v37 < v35);
  }
  if (cf) {
    CFRelease(cf);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v34);
}

void sub_1842A3024(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void addString(__CFData *a1, uint64_t a2, uint64_t a3, CFStringRef theString, const __CFString *a5)
{
  CFIndex Length = CFStringGetLength(theString);
  CFIndex v11 = mdPrintf(a1, a3 + a2 - Length, @"%@: ", theString);
  uint64_t v12 = wrapStrings(a5, 1024 - v11);
  CFContainerEnumeratorBase::setup((unint64_t)v15, v12, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
  uint64_t v18 = 0;
  if (v16 < 1)
  {
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v18 = 1;
    uint64_t v13 = *v17;
  }
  mdPrintf(a1, 0, @"%@\n", v13);
  while (1)
  {
    uint64_t v14 = v18;
    if (v18 >= v16) {
      break;
    }
    ++v18;
    mdPrintf(a1, v11, @"%@\n", v17[v14]);
  }
  if (v12) {
    CFRelease(v12);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v15);
}

void sub_1842A31D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

__CFArray *wrapStrings(const __CFString *a1, uint64_t a2)
{
  if (a2 <= 40) {
    CFIndex v3 = 40;
  }
  else {
    CFIndex v3 = a2;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v4, a1, @"\n");
  CFArrayRef v7 = ArrayBySeparatingStrings;
  if (ArrayBySeparatingStrings && CFArrayGetCount(ArrayBySeparatingStrings) > 1)
  {
    CFContainerEnumeratorBase::setup((unint64_t)v10, v7, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t v9 = v13;
      if (v13 >= v11) {
        break;
      }
      ++v13;
      wrapStrings(Mutable, *(const __CFString **)(v12 + 8 * v9), v3);
    }
    CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v10);
    if (v7) {
      goto LABEL_7;
    }
  }
  else
  {
    wrapStrings(Mutable, a1, v3);
    if (v7) {
LABEL_7:
    }
      CFRelease(v7);
  }
  return Mutable;
}

void sub_1842A3310(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void addData(__CFData *a1, uint64_t a2, uint64_t a3, CFDataRef theData, const __CFData *a5)
{
  v39[0] = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v26 = a3;
  uint64_t v27 = a2;
  mdPrintf(a1, a2, @"%@ data [ %d ] bytes {\n", a3, Length);
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  BytePtr = CFDataGetBytePtr(theData);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x1E4F1D510]);
  CFMutableArrayRef v12 = Mutable;
  if (Length < 1) {
    goto LABEL_28;
  }
  uint64_t v13 = BytePtr;
  CFIndex v28 = &BytePtr[Length];
  uint64_t v14 = MEMORY[0x1E4F14390];
  CFIndex v29 = Mutable;
  do
  {
    CFIndex v15 = 0;
    int v16 = 0;
    CFArrayRef v17 = &__str[snprintf(__str, 0x400uLL, "%8.8x: ", v13 - BytePtr)];
    do
    {
      if (Length <= v15) {
        int v18 = snprintf(v17, (char *)v39 - v17, "  ");
      }
      else {
        int v18 = snprintf(v17, (char *)v39 - v17, "%c%c");
      }
      v17 += v18;
      if (v16 == 1)
      {
        int v16 = 0;
        v17 += snprintf(v17, (char *)v39 - v17, " ");
      }
      else
      {
        ++v16;
      }
      ++v15;
    }
    while (v15 != 16);
    CFIndex v19 = 0;
    CFIndex v20 = &v17[snprintf(v17, (char *)v39 - v17, "   ")];
    do
    {
      if (Length <= v19)
      {
        unsigned __int8 v23 = 32;
        uint64_t v21 = 32;
      }
      else
      {
        uint64_t v21 = v13[v19];
        if (v21 == 10 || v21 == 13)
        {
          unsigned __int8 v23 = 45;
          goto LABEL_22;
        }
        unsigned __int8 v23 = v13[v19];
        if ((char)v21 < 27)
        {
          unsigned __int8 v23 = 46;
          goto LABEL_22;
        }
      }
      if ((*(_DWORD *)(v14 + 4 * v21 + 60) & 0x40000) == 0) {
        unsigned __int8 v23 = 46;
      }
LABEL_22:
      v20 += snprintf(v20, (char *)v39 - v20, "%c", v23);
      ++v19;
    }
    while (v19 != 16);
    CFDataRef v31 = off_1ECF9A530;
    CFStringRef v32 = CFStringCreateWithCString(v10, __str, 0x8000100u);
    CFMutableArrayRef v12 = v29;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    CFArrayAppendValue(v29, v32);
    AutoString::~AutoString((AutoString *)&v31);
    if (Length < 17) {
      break;
    }
    v13 += 16;
    Length -= 16;
  }
  while (v13 < v28);
LABEL_28:
  if (v12) {
    CFTypeRef v24 = CFRetain(v12);
  }
  else {
    CFTypeRef v24 = 0;
  }
  CFRelease(v12);
  CFContainerEnumeratorBase::setup((unint64_t)__str, v24, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
  uint64_t v38 = 0;
  while (1)
  {
    uint64_t v25 = v38;
    if (v38 >= v36) {
      break;
    }
    ++v38;
    mdPrintf(a1, v27, @"%@ %@\n", v26, *(void *)(v37 + 8 * v25));
  }
  if (v24) {
    CFRelease(v24);
  }
  mdPrintf(a1, v27, @"%@ }\n", v26);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)__str);
}

void sub_1842A36CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef cf, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  CFRelease(v39);
  _Unwind_Resume(a1);
}

void wrapStrings(__CFArray *a1, const __CFString *a2, CFIndex a3)
{
  CFIndex Length = CFStringGetLength(a2);
  CFIndex v7 = Length - a3;
  if (Length <= a3)
  {
    CFArrayAppendValue(a1, a2);
  }
  else
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    v12.location = 0;
    v12.socklen_t length = a3;
    CFStringRef v9 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, v12);
    CFArrayAppendValue(a1, v9);
    if (v9) {
      CFRelease(v9);
    }
    v13.location = a3;
    v13.socklen_t length = v7;
    CFStringRef v10 = CFStringCreateWithSubstring(v8, a2, v13);
    wrapStrings(a1, v10, a3);
    if (v10)
    {
      CFRelease(v10);
    }
  }
}

void _fetchKeys(__CFString *a1, const void *a2, __CFArray *a3)
{
  CFTypeID v5 = CFGetTypeID(a1);
  if (v5 == CFStringGetTypeID())
  {
    uint64_t v6 = a3;
    CFIndex v7 = a1;
LABEL_8:
    CFArrayAppendValue(v6, v7);
    return;
  }
  CFStringRef v8 = CFCopyDescription(a1);
  if (!v8)
  {
    CFIndex v7 = @"Non-descript-key";
    uint64_t v6 = a3;
    goto LABEL_8;
  }
  CFStringRef v9 = v8;
  CFArrayAppendValue(a3, v8);

  CFRelease(v9);
}

os_log_t ___ZN11CoreDiagMsgD2Ev_block_invoke()
{
  os_log_t result = os_log_create("com.apple.CFNetwork", "Diagnostics");
  CoreDiagMsg::~CoreDiagMsg()::l = (uint64_t)result;
  return result;
}

void HTTPServerClientOwning::~HTTPServerClientOwning(HTTPServerClientOwning *this)
{
}

uint64_t HTTPServerClientOwning::setServerClient(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t result = *(void *)(a1 + 16);
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v6 = *(uint64_t (**)(uint64_t))(a1 + 32);
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + CFRelease((char *)this - 24) = 0u;
  if (v6)
  {
    if (a3 && a3[10])
    {
      v11[0] = MEMORY[0x1E4F143A8];
      v11[1] = 3221225472;
      v11[2] = ___ZN22HTTPServerClientOwning15setServerClientEPK22_CFHTTPServerClient_V0PK17CoreSchedulingSet_block_invoke;
      v11[3] = &__block_descriptor_48_e5_v8__0l;
      v11[4] = v6;
      v11[5] = result;
      uint64_t result = (*(uint64_t (**)(_DWORD *, void *))(*(void *)a3 + 96))(a3, v11);
    }
    else
    {
      uint64_t result = v6(result);
    }
  }
  if (a2)
  {
    uint64_t v7 = *a2;
    if (*a2)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 134217984;
        uint64_t v13 = v7;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Unknown delegate version %ld", buf, 0xCu);
      }
    }
    else
    {
      long long v8 = *(_OWORD *)a2;
      long long v9 = *((_OWORD *)a2 + 1);
      *(void *)(a1 + 40) = a2[4];
      *(_OWORD *)(a1 + 8) = v8;
      *(_OWORD *)(a1 + CFRelease((char *)this - 24) = v9;
    }
    uint64_t result = *(void *)(a1 + 16);
    CFStringRef v10 = *(uint64_t (**)(uint64_t))(a1 + 24);
    if (v10) {
      uint64_t result = v10(result);
    }
    *(void *)(a1 + CFRetain((char *)this - 16) = result;
  }
  return result;
}

uint64_t ___ZN22HTTPServerClientOwning15setServerClientEPK22_CFHTTPServerClient_V0PK17CoreSchedulingSet_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

uint64_t HTTPServerClientOwning::withServerClient(void *a1, uint64_t a2)
{
  if (a1[2] && (CFAllocatorRef v4 = (uint64_t (*)(void))a1[3]) != 0)
  {
    uint64_t v5 = v4(a1[2]);
    long long v8 = (uint64_t (*)(uint64_t))a1[4];
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v5);
    if (v8)
    {
      return v8(v5);
    }
  }
  else
  {
    uint64_t v7 = *(uint64_t (**)(uint64_t))(a2 + 16);
    return v7(a2);
  }
  return result;
}

uint64_t _CFHTTPServerGetTypeID()
{
  if (HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
  }
  return *(void *)(HTTPServer::Class(void)::sClass_OBJTYPE + 96);
}

uint64_t _CFHTTPServerCreateService(const void *a1, uint64_t *a2, uint64_t *a3, const __CFString *a4, const __CFString *a5, __int16 a6)
{
  uint64_t result = 0;
  if (a2 && a3)
  {
    uint64_t v13 = dispatch_queue_create("com.apple.httpserver.byname-nw", 0);
    if (HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
      dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
    }
    Instance = (_OWORD *)_CFRuntimeCreateInstance();
    uint64_t v15 = (uint64_t)Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      uint64_t v15 = (uint64_t)(Instance + 1);
      Instance[21] = 0u;
      Instance[22] = 0u;
      Instance[19] = 0u;
      Instance[20] = 0u;
      Instance[17] = 0u;
      Instance[18] = 0u;
      Instance[15] = 0u;
      Instance[16] = 0u;
      Instance[13] = 0u;
      Instance[14] = 0u;
      Instance[11] = 0u;
      Instance[12] = 0u;
      Instance[9] = 0u;
      Instance[10] = 0u;
      Instance[7] = 0u;
      Instance[8] = 0u;
      Instance[5] = 0u;
      Instance[6] = 0u;
      Instance[3] = 0u;
      Instance[4] = 0u;
      Instance[2] = 0u;
    }
    HTTPServer::HTTPServer(v15, a1, v13);
    *(void *)uint64_t v15 = &unk_1ECFA1510;
    *(void *)(v15 + 8) = &unk_1ECFA15D0;
    *(void *)(v15 + 56) = &unk_1ECFA1638;
    dispatch_release(v13);
    HTTPServer::initialize(v15, a2, a3);
    if (a4)
    {
      CFAllocatorRef v16 = CFGetAllocator(a4);
      CFStringRef Copy = CFStringCreateCopy(v16, a4);
    }
    else
    {
      CFStringRef Copy = 0;
    }
    *(void *)(v15 + 2CFRetain((char *)this - 80) = Copy;
    if (a5)
    {
      CFAllocatorRef v18 = CFGetAllocator(a5);
      CFStringRef v19 = CFStringCreateCopy(v18, a5);
    }
    else
    {
      CFStringRef v19 = 0;
    }
    *(void *)(v15 + 288) = v19;
    *(_WORD *)(v15 + 296) = a6;
    *(void *)(v15 + 304) = 0;
    *(unsigned char *)(v15 + 312) = 0;
    *(void *)(v15 + 320) = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 160))(v15);
    return v15 - 16;
  }
  return result;
}

uint64_t _CFHTTPServerCreateWithAcceptedSocket(const void *a1, uint64_t *a2, uint64_t *a3, int a4)
{
  uint64_t result = 0;
  if (a2 && a3 && a4 != -1)
  {
    long long v9 = dispatch_queue_create("com.apple.httpserver.bysocket", 0);
    if (HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
      dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
    }
    Instance = (_OWORD *)_CFRuntimeCreateInstance();
    uint64_t v11 = (uint64_t)Instance;
    if (Instance)
    {
      Instance[1] = 0u;
      uint64_t v11 = (uint64_t)(Instance + 1);
      Instance[17] = 0u;
      Instance[18] = 0u;
      Instance[15] = 0u;
      Instance[16] = 0u;
      Instance[13] = 0u;
      Instance[14] = 0u;
      Instance[11] = 0u;
      Instance[12] = 0u;
      Instance[9] = 0u;
      Instance[10] = 0u;
      Instance[7] = 0u;
      Instance[8] = 0u;
      Instance[5] = 0u;
      Instance[6] = 0u;
      Instance[3] = 0u;
      Instance[4] = 0u;
      Instance[2] = 0u;
    }
    HTTPServer::HTTPServer(v11, a1, v9);
    *(void *)uint64_t v11 = &unk_1ECFA1658;
    *(void *)(v11 + 8) = &unk_1ECFA1700;
    *(void *)(v11 + 56) = &unk_1ECFA1768;
    *(_DWORD *)(v11 + 2CFRetain((char *)this - 80) = -1;
    dispatch_release(v9);
    *(_DWORD *)(v11 + 2CFRetain((char *)this - 80) = a4;
    HTTPServer::initialize(v11, a2, a3);
    return v11 - 16;
  }
  return result;
}

void *_CFHTTPServerCreateWithStreams(const void *a1, uint64_t *a2, uint64_t *a3, const void *a4, const void *a5)
{
  uint64_t result = 0;
  if (a2)
  {
    if (a3)
    {
      uint64_t result = 0;
      if (a4)
      {
        if (a5)
        {
          uint64_t v11 = dispatch_queue_create("com.apple.httpserver.bystreams", 0);
          if (HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
            dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
          }
          uint64_t Instance = _CFRuntimeCreateInstance();
          uint64_t v13 = (void *)Instance;
          if (Instance)
          {
            *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
            uint64_t v13 = (void *)(Instance + 16);
            *(void *)(Instance + 304) = 0;
            *(_OWORD *)(Instance + 272) = 0u;
            *(_OWORD *)(Instance + 288) = 0u;
            *(_OWORD *)(Instance + 240) = 0u;
            *(_OWORD *)(Instance + 256) = 0u;
            *(_OWORD *)(Instance + 208) = 0u;
            *(_OWORD *)(Instance + 2CFRelease((char *)this - 24) = 0u;
            *(_OWORD *)(Instance + 176) = 0u;
            *(_OWORD *)(Instance + 192) = 0u;
            *(_OWORD *)(Instance + 144) = 0u;
            *(_OWORD *)(Instance + 160) = 0u;
            *(_OWORD *)(Instance + 112) = 0u;
            *(_OWORD *)(Instance + 128) = 0u;
            *(_OWORD *)(Instance + CFRetain((char *)this - 80) = 0u;
            *(_OWORD *)(Instance + 96) = 0u;
            *(_OWORD *)(Instance + 48) = 0u;
            *(_OWORD *)(Instance + 64) = 0u;
            *(_OWORD *)(Instance + 32) = 0u;
          }
          HTTPServer::HTTPServer((uint64_t)v13, a1, v11);
          void *v13 = &unk_1ECFA1CC8;
          v13[1] = &unk_1ECFA1D78;
          v13[7] = &unk_1ECFA1DE0;
          dispatch_release(v11);
          HTTPServer::initialize((uint64_t)v13, a2, a3);
          v13[35] = CFRetain(a4);
          v13[36] = CFRetain(a5);
          return v13 - 2;
        }
      }
    }
  }
  return result;
}

uint64_t _CFHTTPServerGetClient(uint64_t a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  if (HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___CFHTTPServerGetClient_block_invoke;
  v5[3] = &unk_1E5256E50;
  v5[4] = &v6;
  HTTPServerClientOwning::withServerClient((void *)(v2 + 8), (uint64_t)v5);
  if (a1 && HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
  }
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1842A41A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFHTTPServerSetProperty(uint64_t a1, CFTypeRef cf, CFTypeRef a3)
{
  if (!a1 || HTTPServer::Class(void)::sOnce_HTTPServer == -1)
  {
    if (!cf) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
  if (cf) {
LABEL_4:
  }
    CFRetain(cf);
LABEL_5:
  if (a3) {
    CFRetain(a3);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerSetProperty_block_invoke;
  v6[3] = &__block_descriptor_48_e9_v16__0_v8l;
  void v6[4] = cf;
  v6[5] = a3;
  withServerAsync(a1, (uint64_t)v6);
}

void withServerAsync(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
      dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
    }
    uint64_t v4 = a1 + 16;
  }
  else
  {
    uint64_t v4 = 0;
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZL13withBaseAsyncIP13_CFHTTPServer10HTTPServerEvT_U13block_pointerFvPT0_E_block_invoke;
  v5[3] = &unk_1E5257C58;
  v5[4] = a2;
  void v5[5] = v4;
  HTTPServerBase::withWorkQueue((void *)(v4 + 8), v5);
}

uint64_t ___ZL13withBaseAsyncIP13_CFHTTPServer10HTTPServerEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t _CFHTTPServerCopyProperty(uint64_t a1, CFStringRef theString)
{
  if (a1 && HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
  }
  if (_findExactString(theString, 9u) == 483596694)
  {
    uint64_t v4 = dispatch_semaphore_create(0);
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = ___CFHTTPServerCopyProperty_block_invoke;
    v12[3] = &unk_1E5256E98;
    v12[4] = v4;
    withServerAsync(a1, (uint64_t)v12);
    dispatch_semaphore_wait(v4, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v4);
  }
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2020000000;
  uint64_t v11 = 0;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = ___CFHTTPServerCopyProperty_block_invoke_2;
  v7[3] = &unk_1E5257A98;
  v7[4] = &v8;
  v7[5] = theString;
  if (HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZL16withBaseBlockingIP13_CFHTTPServer10HTTPServerEvT_U13block_pointerFvPT0_E_block_invoke;
  block[3] = &unk_1E5257C58;
  block[4] = v7;
  void block[5] = a1 + 16;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 104), block);
  uint64_t v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t ___ZL16withBaseBlockingIP13_CFHTTPServer10HTTPServerEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t _CFHTTPServerIsValid(uint64_t a1)
{
  if (a1 && HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
  }
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerIsValid_block_invoke;
  v4[3] = &unk_1E5256E50;
  v4[4] = &v5;
  if (HTTPServer::Class(void)::sOnce_HTTPServer != -1) {
    dispatch_once(&HTTPServer::Class(void)::sOnce_HTTPServer, &__block_literal_global_16314);
  }
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZL16withBaseBlockingIP13_CFHTTPServer10HTTPServerEvT_U13block_pointerFvPT0_E_block_invoke;
  block[3] = &unk_1E5257C58;
  block[4] = v4;
  void block[5] = a1 + 16;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 104), block);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void _CFHTTPServerInvalidate(uint64_t a1)
{
}

void _CFHTTPServerSetDispatchQueue(uint64_t a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerSetDispatchQueue_block_invoke;
  v4[3] = &unk_1E5256E98;
  v4[4] = cf;
  withServerAsync(a1, (uint64_t)v4);
}

void _CFHTTPServerScheduleWithRunLoopAndMode(uint64_t a1, CFTypeRef cf, CFTypeRef a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerScheduleWithRunLoopAndMode_block_invoke;
  v6[3] = &__block_descriptor_48_e9_v16__0_v8l;
  void v6[4] = cf;
  v6[5] = a3;
  withServerAsync(a1, (uint64_t)v6);
}

uint64_t _CFHTTPServerConnectionGetTypeID()
{
  if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
  }
  return *(void *)(HTTPServerConnection::Class(void)::sClass_OBJTYPE + 96);
}

void _CFHTTPServerConnectionSetClient(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerConnectionSetClient_block_invoke;
  v6[3] = &__block_descriptor_48_e350_v16__0__HTTPServerConnection_________CFHTTPServerClient_V0_q_v______________CFAllocator_i____CFDictionary____CoreSchedulingSet_____CFError___CFHTTPServerConnectionCallbacks_V1_q_____________HTTPServer_C____CFReadStream_____CFWriteStream_ddqqC__HTTPServerRequest___PendingQueue___ActiveResponseInfo_____CFData___LeftoverBuffer_q______CFRunLoopTimer__8l;
  void v6[4] = a2;
  v6[5] = a3;
  withConnectionBlocking(a1, (uint64_t)v6);
}

void withConnectionBlocking(uint64_t a1, uint64_t a2)
{
  if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZL16withBaseBlockingIP23_CFHTTPServerConnection20HTTPServerConnectionEvT_U13block_pointerFvPT0_E_block_invoke;
  v4[3] = &unk_1E5257C58;
  v4[4] = a2;
  void v4[5] = a1 + 16;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 104), v4);
}

uint64_t ___ZL16withBaseBlockingIP23_CFHTTPServerConnection20HTTPServerConnectionEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t _CFHTTPServerConnectionGetClient(uint64_t a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___CFHTTPServerConnectionGetClient_block_invoke;
  v5[3] = &unk_1E5256E50;
  v5[4] = &v6;
  HTTPServerClientOwning::withServerClient((void *)(v2 + 8), (uint64_t)v5);
  if (a1 && HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
  }
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1842A4E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFHTTPServerConnectionSetProperty(uint64_t a1, CFTypeRef cf, CFTypeRef a3)
{
  if (!a1 || HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection == -1)
  {
    if (!cf) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
  if (cf) {
LABEL_4:
  }
    CFRetain(cf);
LABEL_5:
  if (a3) {
    CFRetain(a3);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerConnectionSetProperty_block_invoke;
  v6[3] = &__block_descriptor_48_e350_v16__0__HTTPServerConnection_________CFHTTPServerClient_V0_q_v______________CFAllocator_i____CFDictionary____CoreSchedulingSet_____CFError___CFHTTPServerConnectionCallbacks_V1_q_____________HTTPServer_C____CFReadStream_____CFWriteStream_ddqqC__HTTPServerRequest___PendingQueue___ActiveResponseInfo_____CFData___LeftoverBuffer_q______CFRunLoopTimer__8l;
  void v6[4] = cf;
  v6[5] = a3;
  withConnectionAsync(a1, (uint64_t)v6);
}

void withConnectionAsync(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
      dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
    }
    uint64_t v4 = a1 + 16;
  }
  else
  {
    uint64_t v4 = 0;
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZL13withBaseAsyncIP23_CFHTTPServerConnection20HTTPServerConnectionEvT_U13block_pointerFvPT0_E_block_invoke;
  v5[3] = &unk_1E5257C58;
  v5[4] = a2;
  void v5[5] = v4;
  HTTPServerBase::withWorkQueue((void *)(v4 + 8), v5);
}

uint64_t ___ZL13withBaseAsyncIP23_CFHTTPServerConnection20HTTPServerConnectionEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t _CFHTTPServerConnectionCopyProperty(uint64_t a1, uint64_t a2)
{
  if (a1 && HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
  }
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerConnectionCopyProperty_block_invoke;
  v6[3] = &unk_1E5256EE0;
  void v6[4] = &v7;
  v6[5] = a2;
  withConnectionBlocking(a1, (uint64_t)v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t _CFHTTPServerConnectionIsValid(uint64_t a1)
{
  if (a1 && HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection != -1) {
    dispatch_once(&HTTPServerConnection::Class(void)::sOnce_HTTPServerConnection, &__block_literal_global_16431);
  }
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerConnectionIsValid_block_invoke;
  v4[3] = &unk_1E5256F08;
  v4[4] = &v5;
  withConnectionBlocking(a1, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void _CFHTTPServerConnectionInvalidate(uint64_t a1)
{
}

void _CFHTTPServerConnectionSetDispatchQueue(uint64_t a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerConnectionSetDispatchQueue_block_invoke;
  v4[3] = &unk_1E5256F50;
  v4[4] = cf;
  withConnectionAsync(a1, (uint64_t)v4);
}

void _CFHTTPServerConnectionScheduleWithRunLoopAndMode(uint64_t a1, CFTypeRef cf, CFTypeRef a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerConnectionScheduleWithRunLoopAndMode_block_invoke;
  v6[3] = &__block_descriptor_48_e350_v16__0__HTTPServerConnection_________CFHTTPServerClient_V0_q_v______________CFAllocator_i____CFDictionary____CoreSchedulingSet_____CFError___CFHTTPServerConnectionCallbacks_V1_q_____________HTTPServer_C____CFReadStream_____CFWriteStream_ddqqC__HTTPServerRequest___PendingQueue___ActiveResponseInfo_____CFData___LeftoverBuffer_q______CFRunLoopTimer__8l;
  void v6[4] = cf;
  v6[5] = a3;
  withConnectionAsync(a1, (uint64_t)v6);
}

uint64_t _CFHTTPServerRequestGetTypeID()
{
  if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_47_16721);
  }
  return *(void *)(TCFObject<HTTPServerRequest>::Class(void)::clazz + 96);
}

void ___ZN9TCFObjectI17HTTPServerRequestE5ClassEv_block_invoke_16724()
{
}

void sub_1842A55D0(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t _CFHTTPServerRequestCopyProperty(uint64_t a1, uint64_t a2)
{
  if (a1 && TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_47_16721);
  }
  uint64_t v7 = 0;
  char v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerRequestCopyProperty_block_invoke;
  v6[3] = &unk_1E5257A98;
  void v6[4] = &v7;
  v6[5] = a2;
  withRequestBlocking(a1, (uint64_t)v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1842A56D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void withRequestBlocking(uint64_t a1, uint64_t a2)
{
  if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_47_16721);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZL16withBaseBlockingIP20_CFHTTPServerRequest17HTTPServerRequestEvT_U13block_pointerFvPT0_E_block_invoke;
  v4[3] = &unk_1E5257C58;
  v4[4] = a2;
  void v4[5] = a1 + 16;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 248), v4);
}

uint64_t ___ZL16withBaseBlockingIP20_CFHTTPServerRequest17HTTPServerRequestEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t _CFHTTPServerRequestCreateResponseMessage(uint64_t a1, uint64_t a2)
{
  if (a1 && TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_47_16721);
  }
  uint64_t v7 = 0;
  char v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerRequestCreateResponseMessage_block_invoke;
  v6[3] = &unk_1E5257A98;
  void v6[4] = &v7;
  v6[5] = a2;
  withRequestBlocking(a1, (uint64_t)v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1842A58C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1842A5AA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void *_CFHTTPServerResponseCreateWithData(char *a1, __CFHTTPMessage *a2, const __CFData *a3)
{
  CFGetAllocator(a1);
  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_49_16726);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v7 = (HTTPServerResponse *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v7 = (HTTPServerResponse *)(Instance + 1);
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  if (a1)
  {
    if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
      dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_47_16721);
    }
    char v8 = (HTTPServerRequest *)(a1 + 16);
  }
  else
  {
    char v8 = 0;
  }
  HTTPServerResponse::HTTPServerResponse(v7, v8);
  if (!v7) {
    return 0;
  }
  uint64_t v9 = (void *)((char *)v7 - 16);
  CFAllocatorRef v10 = CFGetAllocator((char *)v7 - 16);
  CFStringRef Copy = CFHTTPMessageCreateCopy(v10, a2);
  *((void *)v7 + 12) = Copy;
  CFHTTPMessageSetBody(Copy, a3);
  return v9;
}

void ___ZN9TCFObjectI18HTTPServerResponseE5ClassEv_block_invoke()
{
}

void sub_1842A5C30(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t _CFHTTPServerRequestCopyBodyStream(uint64_t a1)
{
  if (a1 && TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_47_16721);
  }
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerRequestCopyBodyStream_block_invoke;
  v4[3] = &unk_1E5256E50;
  v4[4] = &v5;
  withRequestBlocking(a1, (uint64_t)v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1842A5D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFHTTPServerResponseGetTypeID()
{
  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_49_16726);
  }
  return *(void *)(TCFObject<HTTPServerResponse>::Class(void)::clazz + 96);
}

uint64_t _CFHTTPServerResponseCopyProperty(uint64_t a1, uint64_t a2)
{
  if (a1 && TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_49_16726);
  }
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___CFHTTPServerResponseCopyProperty_block_invoke;
  v6[3] = &unk_1E5257A98;
  void v6[4] = &v7;
  v6[5] = a2;
  withResponseBlocking(a1, (uint64_t)v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1842A5ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void withResponseBlocking(uint64_t a1, uint64_t a2)
{
  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_49_16726);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZL16withBaseBlockingIP21_CFHTTPServerResponse18HTTPServerResponseEvT_U13block_pointerFvPT0_E_block_invoke;
  v4[3] = &unk_1E5257C58;
  v4[4] = a2;
  void v4[5] = a1 + 16;
  dispatch_sync(*(dispatch_queue_t *)(*(void *)(a1 + 96) + 232), v4);
}

uint64_t ___ZL16withBaseBlockingIP21_CFHTTPServerResponse18HTTPServerResponseEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

void _CFHTTPServerRequestSetClient(uint64_t a1, uint64_t a2)
{
  if (a1 && TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_47_16721);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerRequestSetClient_block_invoke;
  v4[3] = &__block_descriptor_40_e9_v16__0_v8l;
  v4[4] = a2;
  withRequestBlocking(a1, (uint64_t)v4);
}

uint64_t _CFHTTPServerRequestGetClient(uint64_t a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_47_16721);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___CFHTTPServerRequestGetClient_block_invoke;
  v5[3] = &unk_1E5256E50;
  v5[4] = &v6;
  HTTPServerClientOwning::withServerClient((void *)(v2 + 8), (uint64_t)v5);
  if (a1 && TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_47_16721);
  }
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1842A6288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *_CFHTTPServerResponseCreateWithBodyStream(char *a1, __CFHTTPMessage *a2, const void *a3)
{
  CFGetAllocator(a1);
  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_49_16726);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v7 = (HTTPServerResponse *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v7 = (HTTPServerResponse *)(Instance + 1);
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  if (a1)
  {
    if (TCFObject<HTTPServerRequest>::Class(void)::sOnce != -1) {
      dispatch_once(&TCFObject<HTTPServerRequest>::Class(void)::sOnce, &__block_literal_global_47_16721);
    }
    uint64_t v8 = (HTTPServerRequest *)(a1 + 16);
  }
  else
  {
    uint64_t v8 = 0;
  }
  HTTPServerResponse::HTTPServerResponse(v7, v8);
  if (v7)
  {
    uint64_t v9 = (void *)((char *)v7 - 16);
    CFAllocatorRef v10 = CFGetAllocator((char *)v7 - 16);
    *((void *)v7 + 12) = CFHTTPMessageCreateCopy(v10, a2);
    if (*((void *)v7 + 14) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      v13[0] = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Already have a body stream", (uint8_t *)v13, 2u);
      if (a3) {
        goto LABEL_14;
      }
    }
    else if (a3)
    {
LABEL_14:
      CFTypeRef v11 = CFRetain(a3);
LABEL_18:
      *((void *)v7 + 14) = v11;
      return v9;
    }
    CFTypeRef v11 = 0;
    goto LABEL_18;
  }
  return 0;
}

void _CFHTTPServerResponseSetClient(uint64_t a1, uint64_t a2)
{
  if (a1 && TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_49_16726);
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___CFHTTPServerResponseSetClient_block_invoke;
  v4[3] = &__block_descriptor_40_e9_v16__0_v8l;
  v4[4] = a2;
  withResponseBlocking(a1, (uint64_t)v4);
}

uint64_t _CFHTTPServerResponseGetClient(uint64_t a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_49_16726);
  }
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0;
  }
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___CFHTTPServerResponseGetClient_block_invoke;
  v5[3] = &unk_1E5256E50;
  v5[4] = &v6;
  HTTPServerClientOwning::withServerClient((void *)(v2 + 8), (uint64_t)v5);
  if (a1 && TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_49_16726);
  }
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1842A665C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFHTTPServerResponseEnqueue(uint64_t a1)
{
  if (TCFObject<HTTPServerResponse>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<HTTPServerResponse>::Class(void)::sOnce, &__block_literal_global_49_16726);
  }
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZL13withBaseAsyncIP21_CFHTTPServerResponse18HTTPServerResponseEvT_U13block_pointerFvPT0_E_block_invoke;
  v2[3] = &unk_1E5257C58;
  v2[4] = &__block_literal_global_44;
  v2[5] = a1 + 16;
  dispatch_async(*(dispatch_queue_t *)(*(void *)(a1 + 96) + 232), v2);
}

uint64_t ___ZL13withBaseAsyncIP21_CFHTTPServerResponse18HTTPServerResponseEvT_U13block_pointerFvPT0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t _CFHTTPServerCreateSelfSignedIdentity(uint64_t a1)
{
  v25[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *MEMORY[0x1E4F3B740];
  uint64_t v3 = *MEMORY[0x1E4F3B708];
  v24[0] = *MEMORY[0x1E4F3B718];
  v24[1] = v3;
  v25[0] = v2;
  v25[1] = &unk_1ECFD1B60;
  uint64_t v4 = MEMORY[0x1E4F1CC28];
  uint64_t v5 = *MEMORY[0x1E4F3B788];
  v24[2] = *MEMORY[0x1E4F3B648];
  v24[3] = v5;
  v25[2] = MEMORY[0x1E4F1CC28];
  v25[3] = @"Anonymous Self Signed certificate";
  CFErrorRef error = 0;
  SecKeyRef v6 = SecKeyCreateRandomKey((CFDictionaryRef)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v25 forKeys:v24 count:4], &error);
  if (v6)
  {
    SecKeyRef v7 = v6;
    v21[0] = *MEMORY[0x1E4F3BBA8];
    v21[1] = @"Apple Inc.";
    uint64_t v22 = [MEMORY[0x1E4F1C978] arrayWithObjects:v21 count:2];
    v23[0] = [MEMORY[0x1E4F1C978] arrayWithObjects:&v22 count:1];
    v19[0] = *MEMORY[0x1E4F3BB98];
    v19[1] = a1;
    uint64_t v20 = [MEMORY[0x1E4F1C978] arrayWithObjects:v19 count:2];
    v23[1] = [MEMORY[0x1E4F1C978] arrayWithObjects:&v20 count:1];
    [MEMORY[0x1E4F1C978] arrayWithObjects:v23 count:2];
    uint64_t v8 = *MEMORY[0x1E4F3B970];
    v18[0] = &unk_1ECFD1B78;
    uint64_t v9 = *MEMORY[0x1E4F3B960];
    v17[0] = v8;
    v17[1] = v9;
    uint64_t v16 = *MEMORY[0x1E4F3B9D8];
    uint64_t v10 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v16 count:1];
    v17[2] = *MEMORY[0x1E4F3B948];
    v18[1] = v10;
    v18[2] = v4;
    [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v18 forKeys:v17 count:3];
    uint64_t SelfSignedCertificate = SecGenerateSelfSignedCertificate();
    if (SelfSignedCertificate)
    {
      CFRange v12 = (const void *)SelfSignedCertificate;
      uint64_t v13 = SecIdentityCreate();
      CFRelease(v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    CFRelease(v7);
  }
  else
  {
    uint64_t v13 = 0;
  }
  if (error) {
    CFRelease(error);
  }
  return v13;
}

uint64_t non-virtual thunk to'HTTPServerService::canceled_onQueue(uint64_t this)
{
  *(unsigned char *)(this + 305) = 0;
  return this;
}

void non-virtual thunk to'HTTPServerService::scheduled_onQueue(HTTPServerService *this)
{
}

void HTTPServerService::scheduled_onQueue(HTTPServerService *this)
{
  uint64_t v2 = (const void *)*((void *)this + 40);
  if (v2)
  {
    *((void *)this + 40) = 0;
    HTTPServerBase::becomeErrored_onQueue((HTTPServerService *)((char *)this + 8), v2);
    CFRelease(v2);
  }
  *((unsigned char *)this + 313) = 1;
}

void non-virtual thunk to'HTTPServerService::setProperty(HTTPServerService *this, const __CFString *a2, const void *a3)
{
}

void HTTPServerService::setProperty(HTTPServerService *this, CFStringRef theString, const void *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int ExactString = _findExactString(theString, 9u);
  if (ExactString <= 482597253)
  {
    if (ExactString == 464828551)
    {
      if (a3) {
        CFTypeRef v8 = CFRetain(a3);
      }
      else {
        CFTypeRef v8 = 0;
      }
      *((void *)this + 38) = v8;
      return;
    }
    int v7 = 472004858;
  }
  else
  {
    if (ExactString == 482597254)
    {
      *((unsigned char *)this + 312) = CFBooleanGetValue((CFBooleanRef)a3);
      return;
    }
    if (ExactString == 484645283) {
      goto LABEL_8;
    }
    int v7 = 483596694;
  }
  if (ExactString == v7)
  {
LABEL_8:
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      int v9 = 138412290;
      CFStringRef v10 = theString;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "sorry, setting %@ not yet implemented", (uint8_t *)&v9, 0xCu);
    }
    return;
  }

  HTTPServer::setProperty(this, theString, a3);
}

CFNumberRef non-virtual thunk to'HTTPServerService::copyProperty(HTTPServerService *this, const __CFString *a2)
{
  return HTTPServerService::copyProperty((HTTPServerService *)((char *)this - 8), a2);
}

CFNumberRef HTTPServerService::copyProperty(HTTPServerService *this, CFStringRef theString)
{
  int ExactString = _findExactString(theString, 9u);
  if (ExactString <= 482597253)
  {
    if (ExactString == 464828551)
    {
      CFNumberRef result = (CFNumberRef)*((void *)this + 38);
      if (!result) {
        return result;
      }
      goto LABEL_17;
    }
    if (ExactString == 472004858)
    {
      CFNumberRef result = (CFNumberRef)*((void *)this + 35);
      if (!result) {
        return result;
      }
      goto LABEL_17;
    }
LABEL_21:
    return (CFNumberRef)HTTPServer::copyProperty(this, theString);
  }
  if (ExactString != 482597254)
  {
    if (ExactString == 483596694)
    {
      int valuePtr = (*(uint64_t (**)(HTTPServerService *))(*(void *)this + 152))(this);
      CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
      return CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
    }
    if (ExactString == 484645283)
    {
      CFNumberRef result = (CFNumberRef)*((void *)this + 36);
      if (!result) {
        return result;
      }
      goto LABEL_17;
    }
    goto LABEL_21;
  }
  SecKeyRef v6 = (CFNumberRef *)MEMORY[0x1E4F1CFD0];
  if (!*((unsigned char *)this + 312)) {
    SecKeyRef v6 = (CFNumberRef *)MEMORY[0x1E4F1CFC8];
  }
  CFNumberRef result = *v6;
  if (*v6)
  {
LABEL_17:
    return (CFNumberRef)CFRetain(result);
  }
  return result;
}

uint64_t HTTPServerService::getPort(HTTPServerService *this)
{
  return *((unsigned __int16 *)this + 148);
}

uint64_t HTTPServerService::canceled_onQueue(uint64_t this)
{
  *(unsigned char *)(this + 313) = 0;
  return this;
}

CFStringRef HTTPServerService::copyDebugDesc(HTTPServerService *this)
{
  CFStringRef v2 = HTTPServer::copyDebugDesc(this);
  uint64_t v3 = (const void *)(*(uint64_t (**)(HTTPServerService *, uint64_t))(*(void *)this + 64))(this, 0x1EC0A46F0);
  uint64_t v4 = (const void *)(*(uint64_t (**)(HTTPServerService *, uint64_t))(*(void *)this + 64))(this, 0x1EC0A4488);
  uint64_t v5 = (const void *)(*(uint64_t (**)(HTTPServerService *, uint64_t))(*(void *)this + 64))(this, 0x1EC0A4728);
  CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
  CFStringRef v7 = CFStringCreateWithFormat(v6, 0, @"%@ { service name='%@', type='%@', port=%@> }", v2, v4, v5, v3);
  if (v5) {
    CFRelease(v5);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v2) {
    CFRelease(v2);
  }
  return v7;
}

void HTTPServerService::~HTTPServerService(HTTPServerService *this)
{
  *(void *)this = &unk_1ECF9EAE8;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9EBA0;
  *((void *)this + 7) = &unk_1ECF9EC08;
  CFStringRef v2 = (const void *)*((void *)this + 35);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 36);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 38);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 40);
  if (v5) {
    CFRelease(v5);
  }

  HTTPServer::~HTTPServer(this);
}

void sub_1842A71DC(_Unwind_Exception *a1)
{
  HTTPServer::~HTTPServer(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTPServerWithSocket::~HTTPServerWithSocket(HTTPServerWithSocket *this)
{
}

{
  HTTPServerWithSocket::~HTTPServerWithSocket((HTTPServerWithSocket *)((char *)this - 56));
}

{
  HTTPServerWithSocket::~HTTPServerWithSocket((HTTPServerWithSocket *)((char *)this - 8));
}

{
  HTTPServerWithSocket::~HTTPServerWithSocket((HTTPServerWithSocket *)((char *)this - 8));
}

void HTTPServerWithSocket::~HTTPServerWithSocket(HTTPServerWithSocket *this)
{
  *(void *)this = &unk_1ECFA1658;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA1700;
  *((void *)this + 7) = &unk_1ECFA1768;
  int v2 = *((_DWORD *)this + 70);
  if (v2 != -1)
  {
    close(v2);
    *((_DWORD *)this + 70) = -1;
  }

  HTTPServer::~HTTPServer(this);
}

void sub_1842A72A0(_Unwind_Exception *a1)
{
  HTTPServer::~HTTPServer(v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTPServerWithSocket::scheduled_onQueue(HTTPServerWithSocket *this)
{
}

CFNumberRef non-virtual thunk to'HTTPServerWithSocket::copyProperty(HTTPServerWithSocket *this, const __CFString *a2)
{
  return HTTPServerWithSocket::copyProperty((HTTPServerWithSocket *)((char *)this - 8), a2);
}

CFNumberRef HTTPServerWithSocket::copyProperty(HTTPServerWithSocket *this, CFStringRef theString)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (_findExactString(theString, 9u) == 483596694)
  {
    socklen_t v7 = 255;
    if (getsockname(*((_DWORD *)this + 70), &v8, &v7))
    {
      return 0;
    }
    else
    {
      unsigned int v6 = -1;
      if (v8.sa_family == 30 || v8.sa_family == 2) {
        unsigned int v6 = bswap32(*(unsigned __int16 *)v8.sa_data) >> 16;
      }
      CFAllocatorRef v5 = CFGetAllocator((char *)this - 16);
      return CFNumberCreate(v5, kCFNumberSInt32Type, &v6);
    }
  }
  else
  {
    return (CFNumberRef)HTTPServer::copyProperty(this, theString);
  }
}

void HTTPServerWithSocket::scheduled_onQueue(HTTPServerWithSocket *this)
{
}

intptr_t HTTPServerWithSocket::ensureServerExists(int a1, dispatch_semaphore_t dsema)
{
  return dispatch_semaphore_signal(dsema);
}

void HTTPServerWithSocket::connectionClosed(uint64_t a1, const void *a2)
{
  HTTPServer::connectionClosed(a1, a2);
  int v3 = *(_DWORD *)(a1 + 280);
  if (v3 != -1)
  {
    close(v3);
    *(_DWORD *)(a1 + 2CFRetain((char *)this - 80) = -1;
  }
  if (*(int *)(a1 + 72) <= 2) {
    *(_DWORD *)(a1 + 72) = 3;
  }

  HTTPServerBase::signal((NSObject **)(a1 + 8));
}

void CookieSifter::~CookieSifter(CookieSifter *this)
{
  CookieSifter::~CookieSifter(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  const void *v2;
  const void *v3;
  uint64_t v4;

  *(void *)this = &unk_1ECF9B4C8;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 4);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = 800;
  do
  {
    CookieSifter::Term::cleanCache((CookieSifter *)((char *)this + v4));
    v4 -= 40;
  }
  while (v4);
}

void sub_1842A7534(_Unwind_Exception *a1)
{
  uint64_t v3 = 800;
  do
  {
    CookieSifter::Term::cleanCache((CookieSifter::Term *)(v1 + v3));
    v3 -= 40;
  }
  while (v3);
  _Unwind_Resume(a1);
}

void CookieSifter::Term::cleanCache(CookieSifter::Term *this)
{
  int v2 = *((_DWORD *)this + 8);
  if (v2 == 3)
  {
    uint64_t v3 = *((void *)this + 2);
    if (v3) {
      MEMORY[0x18531B6D0](v3, 0x1000C40EEF2B9B0);
    }
  }
  else if (v2 == 2)
  {
    free(*((void **)this + 2));
  }
  *((_DWORD *)this + 8) = 0;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA03B0;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA03B0;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void ___ZN20HTTP3ConnectionCache17_timersInitializeEv_block_invoke(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        *(unsigned char *)(v5 + 96) = 0;
        HTTP3ConnectionCache::_connectionsRemoveIdle((CFDictionaryRef *)v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1842A7704(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN20HTTP3ConnectionCache15enableCellTimerEv_block_invoke(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        *(unsigned char *)(v5 + 96) = 0;
        HTTP3ConnectionCache::_connectionsRemoveIdle((CFDictionaryRef *)v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1842A777C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void HTTP3ConnectionCache::_connectionsRemoveIdle(CFDictionaryRef *this)
{
  __uint64_t v2 = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
  __uint64_t v3 = v2 - 1000000000 * *((int *)this + 14);
  __uint64_t v4 = v2 - 1000000000 * *((int *)this + 15);
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x4012000000;
  uint64_t v11 = __Block_byref_object_copy__16885;
  CFRange v12 = __Block_byref_object_dispose__16886;
  uint64_t v13 = &unk_18441BEED;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  uint64_t v14 = &unk_1ECFA03B0;
  CFTypeRef cf = CFDictionaryCreateMutable(v5, 0, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks, &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = ___ZN20HTTP3ConnectionCache22_connectionsRemoveIdleEv_block_invoke;
  context[3] = &unk_1E5256F78;
  context[5] = v3;
  context[6] = v4;
  context[4] = &v8;
  CFDictionaryApplyFunction(this[11], (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit, context);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN20HTTP3ConnectionCache22_connectionsRemoveIdleEv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e14_v24__0r_v8_v16l;
  void v6[4] = this;
  CFDictionaryApplyFunction((CFDictionaryRef)v9[7], (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit, v6);
  if (CFDictionaryGetCount(this[11])) {
    HTTP3ConnectionCache::_timersStart((HTTP3ConnectionCache *)this);
  }
  else {
    HTTP3ConnectionCache::_timersStop((HTTP3ConnectionCache *)this);
  }
  _Block_object_dispose(&v8, 8);
  uint64_t v14 = &unk_1ECFA03B0;
  CFRelease(cf);
}

void sub_1842A797C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,CFTypeRef cf)
{
}

CFMutableDictionaryRef __Block_byref_object_copy__16885(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = &unk_1ECFA03B0;
  CFAllocatorRef v4 = CFGetAllocator(*(CFTypeRef *)(a2 + 56));
  CFMutableDictionaryRef result = CFDictionaryCreateMutableCopy(v4, 0, *(CFDictionaryRef *)(a2 + 56));
  *(void *)(a1 + 56) = result;
  return result;
}

void __Block_byref_object_dispose__16886(uint64_t a1)
{
  *(void *)(a1 + 48) = &unk_1ECFA03B0;
  CFRelease(*(CFTypeRef *)(a1 + 56));
}

void ___ZN20HTTP3ConnectionCache22_connectionsRemoveIdleEv_block_invoke(void *a1, const void *a2, void *a3)
{
  uint64_t v3 = a3[3];
  CFAllocatorRef v4 = (std::__shared_weak_count *)a3[4];
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(v3 + 104);
  uint64_t v5 = *(void *)(v3 + 112);
  if (v6 == v5)
  {
LABEL_26:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[4] + 8) + 56), a2, a3);
    goto LABEL_27;
  }
  CFArrayRef v17 = a2;
  CFAllocatorRef v18 = a3;
  unint64_t v7 = a1[5];
  uint64_t v16 = a1;
  unint64_t v20 = a1[6];
  CFStringRef v19 = (const void *)*MEMORY[0x1E4F1CFD0];
  char v8 = 1;
  do
  {
    uint64_t v10 = *(HTTP3Connection **)v6;
    uint64_t v9 = *(std::__shared_weak_count **)(v6 + 8);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*((void *)v10 + 142) != *((void *)v10 + 143))
    {
LABEL_8:
      char v8 = 0;
      goto LABEL_9;
    }
    uint64_t v11 = *((void *)v10 + 126);
    if (v11
      && (CFRange v12 = (const void *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v11 + 216))(v11, &unk_1EC0A0B38),
          (uint64_t v13 = v12) != 0))
    {
      CFTypeID v14 = CFGetTypeID(v12);
      if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "pass kCFBooleanTrue or kCFBooleanFalse here", buf, 2u);
      }
      CFRelease(v13);
      unint64_t v15 = *((void *)v10 + 147);
      if (v7 != v20 && v19 == v13)
      {
        if (v15 > v20) {
          goto LABEL_8;
        }
        goto LABEL_24;
      }
    }
    else
    {
      unint64_t v15 = *((void *)v10 + 147);
    }
    if (v15 > v7) {
      goto LABEL_8;
    }
LABEL_24:
    HTTP3Connection::stop(v10, 0);
LABEL_9:
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v9);
    }
    v6 += 16;
  }
  while (v6 != v5);
  a3 = v18;
  a1 = v16;
  a2 = v17;
  if (v8) {
    goto LABEL_26;
  }
LABEL_27:
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void sub_1842A7C38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  CFTypeID v14 = v12;
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN20HTTP3ConnectionCache22_connectionsRemoveIdleEv_block_invoke_2(uint64_t a1, const HTTPConnectionCacheKey *a2, uint64_t a3)
{
  CFAllocatorRef v4 = *(HTTP3ConnectionCache **)(a1 + 32);
  uint64_t v5 = *(void *)(a3 + 24);
  uint64_t v6 = *(std::__shared_weak_count **)(a3 + 32);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HTTP3ConnectionCacheEntry::stopConnections(*(HTTP3ConnectionCacheEntry **)(v5 + 104), *(HTTP3ConnectionCacheEntry **)(v5 + 112), 0);
  HTTP3ConnectionCache::_entryRemove(v4, a2);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_1842A7D00(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<HTTP3ConnectionCacheEntry>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6BB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<HTTP3ConnectionCacheEntry>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6BB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t HTTP3ConnectionCacheEntryWrapper::hash(HTTP3ConnectionCacheEntryWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 5) + 32))();
}

uint64_t HTTP3ConnectionCacheEntryWrapper::equals(HTTP3ConnectionCacheEntryWrapper *this, const CFAllocatedReferenceCountedObject *a2)
{
  return 0;
}

CFStringRef HTTP3ConnectionCacheEntryWrapper::copyDebugDesc(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat(this[1], 0, @"HTTP3ConnectionCacheEntryWrapper<@%p> for HTTP3ConnectionCacheEntry<@%p>", this, this[3]);
}

void ___ZN20HTTP3ConnectionCache24_logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 24);
  CFAllocatorRef v4 = *(std::__shared_weak_count **)(a3 + 32);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(uint64_t **)(v3 + 104);
  for (dispatch_queue_t i = *(uint64_t **)(v3 + 112); v5 != i; v5 += 2)
  {
    uint64_t v8 = *v5;
    unint64_t v7 = (std::__shared_weak_count *)v5[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v12, *(void *)(v8 + 8), *(std::__shared_weak_count **)(v8 + 16));
    uint64_t v9 = *(NSObject **)(v8 + 1000);
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3321888768;
    v10[2] = ___ZN15HTTP3Connection22logConnectionAtAPSleepEv_block_invoke;
    v10[3] = &__block_descriptor_48_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e5_v8__0l;
    v10[4] = v12;
    uint64_t v11 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    dispatch_async(v9, v10);
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v13);
    }
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
  }
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void sub_1842A7F90(_Unwind_Exception *exception_object)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN20HTTP3ConnectionCache27_markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 24);
  CFAllocatorRef v4 = *(std::__shared_weak_count **)(a3 + 32);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(uint64_t **)(v3 + 104);
  for (dispatch_queue_t i = *(uint64_t **)(v3 + 112); v5 != i; v5 += 2)
  {
    uint64_t v8 = *v5;
    unint64_t v7 = (std::__shared_weak_count *)v5[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v12, *(void *)(v8 + 8), *(std::__shared_weak_count **)(v8 + 16));
    uint64_t v9 = *(NSObject **)(v8 + 1000);
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3321888768;
    v10[2] = ___ZN15HTTP3Connection26markReusedAfterAPSleepWakeEv_block_invoke;
    v10[3] = &__block_descriptor_48_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e5_v8__0l;
    v10[4] = v12;
    uint64_t v11 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    dispatch_async(v9, v10);
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v13);
    }
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
  }
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void sub_1842A8110(_Unwind_Exception *exception_object)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements(NetworkProxyAuthorizationElements *this)
{
  __uint64_t v2 = (char *)this - 24;
  NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements((NetworkProxyAuthorizationElements *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements((NetworkProxyAuthorizationElements *)((char *)this - 24));
}

void NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements(NetworkProxyAuthorizationElements *this)
{
  *(void *)this = &unk_1ECFA5378;
  *((void *)this + 3) = &unk_1ECFA53C0;
  __uint64_t v2 = (const void *)*((void *)this + 8);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 7);
  if (v3) {
    CFRelease(v3);
  }
  CFAllocatorRef v4 = (const void *)*((void *)this + 6);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *((void *)this + 5);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 48))(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v6) {
    CFRelease(v6);
  }
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  NetworkProxyAuthorizationElements::~NetworkProxyAuthorizationElements(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1842A8468(_Unwind_Exception *exception_object)
{
  CFAllocatorRef v4 = *(const void **)(v1 + 72);
  *(void *)(v1 + 72) = 0;
  if (v4) {
    CFRelease(v4);
  }
  void *v2 = &unk_1ECF9B550;
  _Unwind_Resume(exception_object);
}

CFStringRef NetworkProxyAuthorizationElements::copyDebugDesc(NetworkProxyAuthorizationElements *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    CFAllocatorRef v3 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
  }
  else {
    CFAllocatorRef v3 = 0;
  }
  CFStringRef v4 = CFStringCreateWithFormat(*((CFAllocatorRef *)this + 1), 0, @"<NetworkProxyAuthorizationElements %p>{cred=%@, protSpace=%@, challenge=%@ client=%@ <%@>}", this, v3, *((void *)this + 6), *((void *)this + 7), *((void *)this + 8), *((void *)this + 9));
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

void sub_1842A8544(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements(NetworkProxyAuthorizationElements *this, const __CFAllocator *a2, NetworkProxyCredential *a3, _CFURLProtectionSpace *a4, _CFURLAuthChallenge *a5, const __CFString *a6)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, a2);
  *uint64_t v11 = &unk_1ECFA5378;
  v11[3] = &unk_1ECFA53C0;
  v11[9] = 0;
  if (a3)
  {
    *((void *)this + 5) = a3;
    (*(void (**)(NetworkProxyCredential *))(*(void *)a3 + 40))(a3);
  }
  *((void *)this + 6) = a4;
  if (a4) {
    CFRetain(a4);
  }
  *((void *)this + 7) = a5;
  if (a5) {
    CFRetain(a5);
  }
  *((unsigned char *)this + 32) = 0;
  if (a6) {
    CFTypeRef v12 = CFRetain(a6);
  }
  else {
    CFTypeRef v12 = 0;
  }
  uint64_t v13 = (const void *)*((void *)this + 9);
  *((void *)this + 9) = v12;
  if (v13) {
    CFRelease(v13);
  }
}

void sub_1842A86A0(_Unwind_Exception *exception_object)
{
  CFStringRef v4 = *(const void **)(v1 + 72);
  *(void *)(v1 + 72) = 0;
  if (v4) {
    CFRelease(v4);
  }
  void *v2 = &unk_1ECF9B550;
  _Unwind_Resume(exception_object);
}

uint64_t NetworkProxyAuthorizationElements::setCredential(NetworkProxyAuthorizationElements *this, NetworkProxyCredential *a2)
{
  uint64_t result = *((void *)this + 5);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 48))(result);
    *((void *)this + 5) = 0;
  }
  if (a2)
  {
    *((void *)this + 5) = a2;
    uint64_t v5 = *(uint64_t (**)(NetworkProxyCredential *))(*(void *)a2 + 40);
    return v5(a2);
  }
  return result;
}

void NetworkProxyAuthorizationElements::setProtectionSpace(NetworkProxyAuthorizationElements *this, CFTypeRef cf)
{
  CFStringRef v4 = (const void *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v4) {
    CFRelease(v4);
  }
  if (cf) {
    *((void *)this + 6) = CFRetain(cf);
  }
}

void NetworkProxyAuthorizationElements::setChallenge(NetworkProxyAuthorizationElements *this, CFTypeRef cf)
{
  CFStringRef v4 = (const void *)*((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v4) {
    CFRelease(v4);
  }
  if (cf) {
    *((void *)this + 7) = CFRetain(cf);
  }
}

CFAllocatedReferenceCountedObject *CFNetworkProxyAuthorizationElementsCreateFromDictionary(uint64_t a1, const __CFDictionary *a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v4 = (CFAllocatedReferenceCountedObject *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 80, 0);
  *(_OWORD *)CFStringRef v4 = 0u;
  *((_OWORD *)v4 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(v4, v3);
  *uint64_t v5 = &unk_1ECFA5378;
  v5[3] = &unk_1ECFA53C0;
  v5[9] = 0;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a2, @"kNetworkProxyAuthorizationElementsKeyCredential");
  CFDictionaryRef v7 = Value;
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFDictionaryGetTypeID())
    {
      uint64_t v9 = CFAllocatorAllocate(v3, 56, 0);
      v9[6] = 0;
      *((_OWORD *)v9 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
      *((_OWORD *)v9 + 2) = 0u;
      *(_OWORD *)uint64_t v9 = 0u;
      NetworkProxyCredential::NetworkProxyCredential((NetworkProxyCredential *)v9, v3, v7);
      *((void *)v4 + 5) = v10;
    }
  }
  CFDictionaryRef v11 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"kNetworkProxyAuthorizationElementsKeyProtectionSpace");
  CFDictionaryRef v12 = v11;
  if (v11)
  {
    CFTypeID v13 = CFGetTypeID(v11);
    if (v13 == CFDictionaryGetTypeID())
    {
      if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
        dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
      *(_OWORD *)(Instance + CFRetain((char *)this - 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(void *)(Instance + CFRetain((char *)this - 16) = &unk_1ECF9F738;
      *(void *)(Instance + CFRelease((char *)this - 24) = &unk_1ECF9F790;
      *(void *)(Instance + 32) = &gConstantCFStringValueTable[3780];
      *(unsigned char *)(Instance + 96) = 0;
      *(unsigned char *)(Instance + 104) = 0;
      *(void *)(Instance + 112) = 1;
      int valuePtr = 0;
      CFNumberRef v14 = (const __CFNumber *)CFDictionaryGetValue(v12, @"kCFURLProtectionSpaceKeyPort");
      CFNumberRef v15 = v14;
      if (v14)
      {
        CFTypeID v16 = CFGetTypeID(v14);
        if (v16 == CFNumberGetTypeID()) {
          CFNumberGetValue(v15, kCFNumberSInt32Type, &valuePtr);
        }
      }
      CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(v12, @"kCFURLProtectionSpaceKeyServerType");
      CFNumberRef v18 = v17;
      if (v17)
      {
        CFTypeID v19 = CFGetTypeID(v17);
        if (v19 == CFNumberGetTypeID())
        {
          int v34 = 0;
          CFNumberGetValue(v18, kCFNumberSInt32Type, &v34);
        }
      }
      CFNumberRef v20 = (const __CFNumber *)CFDictionaryGetValue(v12, @"kCFURLProtectionSpaceKeyAuthenticationScheme");
      CFNumberRef v21 = v20;
      if (v20)
      {
        CFTypeID v22 = CFGetTypeID(v20);
        if (v22 == CFNumberGetTypeID())
        {
          int v33 = 0;
          CFNumberGetValue(v21, kCFNumberSInt32Type, &v33);
        }
      }
      CFRetain(&stru_1ECFAD558);
      operator new();
    }
  }
  *((void *)v4 + 7) = 0;
  *((unsigned char *)v4 + 32) = 0;
  unsigned __int8 v23 = CFDictionaryGetValue(a2, @"kNetworkProxyAuthorizationElementsKeyClientProcessName");
  CFTypeRef v24 = v23;
  if (v23)
  {
    CFTypeID v25 = CFGetTypeID(v23);
    if (v25 == CFStringGetTypeID())
    {
      *((void *)v4 + 8) = v24;
      CFRetain(v24);
    }
  }
  uint64_t v26 = CFDictionaryGetValue(a2, @"kNetworkProxyAuthorizationElementsKeyClientDescription");
  uint64_t v27 = v26;
  if (v26)
  {
    CFTypeID v28 = CFGetTypeID(v26);
    if (v28 == CFStringGetTypeID())
    {
      CFTypeRef v29 = CFRetain(v27);
      CFIndex v30 = (const void *)*((void *)v4 + 9);
      *((void *)v4 + 9) = v29;
      if (v30) {
        CFRelease(v30);
      }
    }
  }
  return v4;
}

void sub_1842A8D5C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  uint64_t v6 = *(const void **)(v1 + 72);
  *(void *)(v1 + 72) = 0;
  if (v6) {
    CFRelease(v6);
  }
  *CFAllocatorRef v3 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t CFNetworkProxyAuthorizationElementsRetain(uint64_t a1)
{
  return a1;
}

uint64_t CFNetworkProxyAuthorizationElementsRelease(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t CFNetworkProxyAuthorizationElementsCopyDebugDescription(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t CFNetworkProxyAuthorizationElementsGetCredential(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t CFNetworkProxyAuthorizationElementsGetProtectionSpace(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

BOOL CFNetworkProxyAuthorizationElementsIsViable(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  return v1 && *(_DWORD *)(v1 + 40) == 1;
}

BOOL CFNetworkProxyAuthorizationElementsIsUnviable(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  return v1 && *(_DWORD *)(v1 + 40) == 2;
}

uint64_t CFNetworkProxyAuthorizationElementsGetClientProcessName(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t CFNetworkProxyAuthorizationElementsGetClientDescription(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

void std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

BOOL XCookieStorage::equals(XCookieStorage *this, XCookieStorage *a2)
{
  return this == a2;
}

void NSXCookieStorage::NSXCookieStorage(NSXCookieStorage *this, NSHTTPCookieStorage *a2)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, (const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
  void *v4 = &unk_1ECF9DE60;
  *((void *)this + 3) = CFRetain(a2);
}

uint64_t CFXCookieStorage::ref(CFXCookieStorage *this)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled) {
    return 0;
  }
  else {
    return *((void *)this + 3);
  }
}

uint64_t CFXCookieStorage::getCookieAcceptPolicy(id *this)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (newCookieStorageEnabled(void)::enabled) {
    return [this[4] cookieAcceptPolicy];
  }
  CFAllocatorRef v3 = (char *)this[3];

  return CFHTTPCookieStorageGetCookieAcceptPolicy(v3);
}

void CFXCookieStorage::setExtraCookies(CFXCookieStorage *this, const __CFArray *a2)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (!newCookieStorageEnabled(void)::enabled)
  {
    uint64_t v4 = (void *)*((void *)this + 3);
    CFHTTPCookieStorageSetCookies(v4, a2, 0, 0);
  }
}

uint64_t CFXCookieStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (!newCookieStorageEnabled(void)::enabled)
  {
    uint64_t v6 = *(void *)(a1 + 24);
    if (a2)
    {
      CFHTTPCookieStorageDeleteAllCookies(*(char **)(a1 + 24));
      uint64_t v6 = *(void *)(a1 + 24);
      if (newCookieStorageEnabled(void)::onceToken != -1) {
        dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
      }
    }
    if (!newCookieStorageEnabled(void)::enabled)
    {
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
      }
      if (v6) {
        uint64_t v7 = v6 + 16;
      }
      else {
        uint64_t v7 = 0;
      }
      HTTPCookieStorage::syncStorageWithCompletion(v7, 1, 0);
    }
  }
  CFTypeID v8 = *(uint64_t (**)(uint64_t))(a3 + 16);

  return v8(a3);
}

void CFXCookieStorage::parseAndStoreCookiesForTask(id *this, const __CFArray *a2, NSURLSessionTask *a3)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  int v6 = newCookieStorageEnabled(void)::enabled;
  uint64_t v7 = [(NSURLSessionTask *)a3 currentRequest];
  uint64_t v8 = [(NSURLRequest *)v7 _inner];
  if (v6)
  {
    CFURLRef v9 = *(const __CFURL **)(v8 + 8);
    CFAllocatorRef v10 = CFGetAllocator(a2);
    CookiesWithCookieStrings = _createCookiesWithCookieStrings(v10, a2, v9, (uint64_t)[(NSURLSessionTask *)a3 _storagePartitionIdentifier], 1);
    [this[4] storeCookies:CookiesWithCookieStrings forTask:a3];
    if (CookiesWithCookieStrings)
    {
      CFRelease(CookiesWithCookieStrings);
    }
  }
  else
  {
    uint64_t v12 = *(void *)(v8 + 56);
    if (v12 && (CFTypeID v13 = *(char **)(v12 + 192)) != 0) {
      int CookieAcceptPolicy = CFHTTPCookieStorageGetCookieAcceptPolicy(v13);
    }
    else {
      int CookieAcceptPolicy = (*((uint64_t (**)(id *))*this + 12))(this);
    }
    int v15 = CookieAcceptPolicy;
    CFURLRef v16 = *(const __CFURL **)([(NSURLRequest *)v7 _inner] + 8);
    CFNumberRef v17 = *(const void **)([(NSURLRequest *)[(NSURLSessionTask *)a3 currentRequest] _inner]
                         + 32);
    CFAllocatorRef v18 = CFGetAllocator(a2);
    CFTypeID v19 = _createCookiesWithCookieStrings(v18, a2, v16, (uint64_t)[(NSURLSessionTask *)a3 _storagePartitionIdentifier], 1);
    PolicyPropertiesFromTask = getPolicyPropertiesFromTask(a3);
    if (v19)
    {
      CFDictionaryRef v21 = (const __CFDictionary *)PolicyPropertiesFromTask;
      if (CFArrayGetCount(v19) < 1) {
        goto LABEL_22;
      }
      CFTypeID v22 = [(NSURLSessionTask *)a3 _cookieTransformCallback];
      if (v22)
      {
        unsigned __int8 v23 = (__CFArray *)(id)v22[2](v22, v19);
        CFRelease(v19);
        CFTypeID v19 = v23;
      }
      HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v26, v16, v17, (uint64_t)[(NSURLSessionTask *)a3 _storagePartitionIdentifier], v15, 1, v21, [(NSURLRequest *)[(NSURLSessionTask *)a3 currentRequest] _allowOnlyPartitionedCookies]);
      CFTypeRef v24 = (char *)this[3];
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
      }
      CFTypeID v25 = v24 ? (HTTPCookieStorage *)(v24 + 16) : 0;
      HTTPCookieStorage::setCookiesWithPolicy(v25, v19, (const HTTPCookieStoragePolicy *)v26);
      HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v26);
      if (v19) {
LABEL_22:
      }
        CFRelease(v19);
    }
  }
}

void sub_1842A9498(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK16CFXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t NSXCookieStorage::getCookieAcceptPolicy(id *this)
{
  uint64_t v2 = (void *)MEMORY[0x18531D6D0]();
  uint64_t v3 = [this[3] cookieAcceptPolicy];
  return v3;
}

void NSXCookieStorage::setExtraCookies(id *this, const __CFArray *a2)
{
  uint64_t v4 = (void *)MEMORY[0x18531D6D0]();
  id v5 = +[NSHTTPCookie _cf2nsCookies:a2];
  [this[3] setCookies:v5 forURL:0 mainDocumentURL:0];
}

void NSXCookieStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v6 = (void *)MEMORY[0x18531D6D0]();
  if (a2)
  {
    uint64_t v7 = (void *)[*(id *)(a1 + 24) cookies];
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    uint64_t v8 = [v7 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)v13;
      do
      {
        uint64_t v11 = 0;
        do
        {
          if (*(void *)v13 != v10) {
            objc_enumerationMutation(v7);
          }
          [*(id *)(a1 + 24) deleteCookie:*(void *)(*((void *)&v12 + 1) + 8 * v11++)];
        }
        while (v9 != v11);
        uint64_t v9 = [v7 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }
      while (v9);
    }
  }
  [*(id *)(a1 + 24) _saveCookies];
  (*(void (**)(uint64_t))(a3 + 16))(a3);
}

void NSXCookieStorage::parseAndStoreCookiesForTask(id *this, const __CFArray *a2, NSURLSessionTask *a3)
{
  int v6 = (void *)MEMORY[0x18531D6D0]();
  CookiesWithCookieStrings = _createCookiesWithCookieStrings((const __CFAllocator *)*MEMORY[0x1E4F1CF80], a2, (const __CFURL *)[(NSURLSessionTask *)a3 currentRequest_URL], 0, 1);
  id v8 = +[NSHTTPCookie _cf2nsCookies:CookiesWithCookieStrings];
  if (CookiesWithCookieStrings) {
    CFRelease(CookiesWithCookieStrings);
  }
  [this[3] storeCookies:v8 forTask:a3];
}

void NSXCookieStorage::getCookiesForTask(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  id v8 = (void *)MEMORY[0x18531D6D0]();
  uint64_t v9 = *(void **)(a1 + 24);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZNK16NSXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke;
  v10[3] = &unk_1E5256FF0;
  char v11 = a3;
  v10[4] = a4;
  [v9 getCookiesForTask:a2 completionHandler:v10];
}

void ___ZNK16NSXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke(uint64_t a1, __CFArray *a2)
{
  uint64_t v2 = a2;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (!*(unsigned char *)(a1 + 40))
    {
      uint64_t v4 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", -[__CFArray count](a2, "count"));
      long long v10 = 0u;
      long long v11 = 0u;
      long long v12 = 0u;
      long long v13 = 0u;
      uint64_t v5 = [(__CFArray *)v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
      if (v5)
      {
        uint64_t v6 = v5;
        uint64_t v7 = *(void *)v11;
        do
        {
          for (uint64_t i = 0; i != v6; ++i)
          {
            if (*(void *)v11 != v7) {
              objc_enumerationMutation(v2);
            }
            uint64_t v9 = *(void **)(*((void *)&v10 + 1) + 8 * i);
            if (([v9 isSecure] & 1) == 0) {
              [v4 addObject:v9];
            }
          }
          uint64_t v6 = [(__CFArray *)v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
        }
        while (v6);
      }
      uint64_t v2 = (__CFArray *)v4;
    }
    uint64_t v2 = +[NSHTTPCookie _ns2cfCookies:v2];
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v2) {
    CFRelease(v2);
  }
}

void NSXCookieStorage::~NSXCookieStorage(NSXCookieStorage *this)
{
  *(void *)this = &unk_1ECF9DE60;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);

  CFAllocatorDeallocate(v3, this);
}

{
  const void *v1;

  *(void *)this = &unk_1ECF9DE60;
  uint64_t v1 = (const void *)*((void *)this + 3);
  if (v1) {
    CFRelease(v1);
  }
}

void EmptyXCookieStorage::ref(EmptyXCookieStorage *this)
{
}

uint64_t EmptyXCookieStorage::getCookieAcceptPolicy(EmptyXCookieStorage *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 96))();
  }
  else {
    return 1;
  }
}

uint64_t EmptyXCookieStorage::flushOrReset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    return (*(uint64_t (**)(void))(*(void *)v3 + 72))();
  }
  else {
    return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  }
}

uint64_t MemXCookieStorage::ref(MemXCookieStorage *this)
{
  return *((void *)this + 4);
}

uint64_t MemXCookieStorage::getCookieAcceptPolicy(char **this)
{
  return CFHTTPCookieStorageGetCookieAcceptPolicy(this[4]);
}

void MemXCookieStorage::setExtraCookies(MemXCookieStorage *this, const __CFArray *a2)
{
}

uint64_t MemXCookieStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  if (a2) {
    CFHTTPCookieStorageDeleteAllCookies(*(char **)(a1 + 32));
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (!newCookieStorageEnabled(void)::enabled)
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    if (v5) {
      uint64_t v6 = v5 + 16;
    }
    else {
      uint64_t v6 = 0;
    }
    HTTPCookieStorage::syncStorageWithCompletion(v6, 1, 0);
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t))(a3 + 16);

  return v7(a3);
}

void MemXCookieStorage::parseAndStoreCookiesForTask(CFTypeRef *this, const __CFArray *a2, NSURLSessionTask *a3)
{
  CFURLRef v6 = *(const __CFURL **)([(NSURLRequest *)[(NSURLSessionTask *)a3 currentRequest] _inner] + 8);
  uint64_t v7 = *(const void **)([(NSURLRequest *)[(NSURLSessionTask *)a3 currentRequest] _inner] + 32);
  CFAllocatorRef v8 = CFGetAllocator(this[4]);
  CookiesWithCookieStrings = _createCookiesWithCookieStrings(v8, a2, v6, 0, 1);
  PolicyPropertiesFromTask = getPolicyPropertiesFromTask(a3);
  if (CookiesWithCookieStrings)
  {
    CFDictionaryRef v11 = (const __CFDictionary *)PolicyPropertiesFromTask;
    if (CFArrayGetCount(CookiesWithCookieStrings) >= 1)
    {
      HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v14, v6, v7, (uint64_t)[(NSURLSessionTask *)a3 _storagePartitionIdentifier], [(NSURLSessionTask *)a3 _cookieAcceptPolicy], 1, v11, [(NSURLRequest *)[(NSURLSessionTask *)a3 currentRequest] _allowOnlyPartitionedCookies]);
      long long v12 = (char *)this[4];
      if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
        dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
      }
      if (v12) {
        long long v13 = (HTTPCookieStorage *)(v12 + 16);
      }
      else {
        long long v13 = 0;
      }
      HTTPCookieStorage::setCookiesWithPolicy(v13, CookiesWithCookieStrings, (const HTTPCookieStoragePolicy *)v14);
      HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v14);
    }
    CFRelease(CookiesWithCookieStrings);
  }
}

void sub_1842A9D40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void MemXCookieStorage::getCookiesForTask(void *a1, NSURLSessionTask *a2, const __CFURL *a3, uint64_t a4)
{
  if (a1[3])
  {
    CFAllocatorRef v8 = a2;
    (*(void (**)(void *))(*a1 + 40))(a1);
    uint64_t v9 = a1[3];
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    v10[2] = ___ZNK17MemXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke;
    v10[3] = &unk_1E5257040;
    void v10[5] = a4;
    void v10[6] = a1;
    char v11 = (char)a3;
    v10[4] = a2;
    (*(void (**)(uint64_t, NSURLSessionTask *, const __CFURL *, void *))(*(void *)v9 + 56))(v9, a2, a3, v10);
  }
  else
  {
    MemXCookieStorage::getCookiesForTask0((uint64_t)a1, a2, a3, 0, a4);
  }
}

void MemXCookieStorage::getCookiesForTask0(uint64_t a1, NSURLSessionTask *a2, const __CFURL *a3, const void *a4, uint64_t a5)
{
  long long v10 = [(NSURLSessionTask *)a2 currentRequest_URL];
  char v11 = [(NSURLSessionTask *)a2 currentRequest_mainDocumentURL];
  PolicyPropertiesFromTask = getPolicyPropertiesFromTask(a2);
  long long v13 = [(NSURLSessionConfiguration *)[(NSURLSessionTask *)a2 _effectiveConfiguration] HTTPCookieStorage];
  int CookieAcceptPolicy = [(NSURLSessionTask *)a2 _cookieAcceptPolicy];
  if ((objc_opt_respondsToSelector() & 1) != 0
    && [(NSHTTPCookieStorage *)v13 _overrideSessionCookieAcceptPolicy])
  {
    uint64_t v15 = *(void *)(a1 + 32);
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    CFURLRef v16 = *(PrivateHTTPCookieStorage **)(v15 + 32);
    if (v16) {
      int CookieAcceptPolicy = PrivateHTTPCookieStorage::getCookieAcceptPolicy(v16);
    }
    else {
      int CookieAcceptPolicy = 2;
    }
  }
  HTTPCookieStoragePolicy::HTTPCookieStoragePolicy((uint64_t)v29, v10, v11, (uint64_t)[(NSURLSessionTask *)a2 _storagePartitionIdentifier], CookieAcceptPolicy, 0, (const __CFDictionary *)PolicyPropertiesFromTask, [(NSURLRequest *)[(NSURLSessionTask *)a2 currentRequest] _allowOnlyPartitionedCookies]);
  uint64_t v17 = *(void *)(a1 + 32);
  if (v17)
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    CFAllocatorRef v18 = (HTTPCookieStorage *)(v17 + 16);
  }
  else
  {
    CFAllocatorRef v18 = 0;
  }
  CFArrayRef v19 = HTTPCookieStorage::copyCookiesForURLWithMainDocumentURL(v18, (const HTTPCookieStoragePolicy *)v29, a3);
  if (v19)
  {
    if (a4)
    {
      CFMutableArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D548]);
      CFContainerEnumeratorBase::setup((unint64_t)v25, a4, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
      uint64_t v28 = 0;
      while (1)
      {
        uint64_t v21 = v28;
        if (v28 >= v26) {
          break;
        }
        ++v28;
        CFSetAddValue(Mutable, *(const void **)(v27 + 8 * v21));
      }
      CFRelease(a4);
      CFContainerEnumeratorBase::setup((unint64_t)v23, v19, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
      uint64_t v24 = 0;
      while (1)
      {
        uint64_t v22 = v24;
        if (v24 >= v23[1]) {
          break;
        }
        ++v24;
        CFSetAddValue(Mutable, *(const void **)(v23[2] + 8 * v22));
      }
      CFRelease(v19);
      if (CFSetGetCount(Mutable) >= 1) {
        operator new[]();
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      (*(void (**)(uint64_t, void))(a5 + 16))(a5, 0);
      CFRelease(v19);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v23);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v25);
    }
    else
    {
      (*(void (**)(uint64_t, const __CFArray *))(a5 + 16))(a5, v19);
      CFRelease(v19);
    }
  }
  else
  {
    (*(void (**)(uint64_t, const void *))(a5 + 16))(a5, a4);
  }
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)v29);
}

void sub_1842AA1F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a9);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a44);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)(v44 - 192));
  _Unwind_Resume(a1);
}

uint64_t ___ZNK17MemXCookieStorage17getCookiesForTaskEP16NSURLSessionTaskhU13block_pointerFvPK9__CFArrayE_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v3 = *(void *)(a1 + 48);
  MemXCookieStorage::getCookiesForTask0(v3, *(NSURLSessionTask **)(a1 + 32), (const __CFURL *)*(unsigned __int8 *)(a1 + 56), a2, *(void *)(a1 + 40));

  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)v3 + 48);

  return v4(v3);
}

void MemXCookieStorage::~MemXCookieStorage(MemXCookieStorage *this)
{
  MemXCookieStorage::~MemXCookieStorage(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  uint64_t v2;
  const void *v3;

  *(void *)this = &unk_1ECF9ECB0;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 4);
  if (v3) {
    CFRelease(v3);
  }
}

CFStringRef HTTPHeaderDict::copyDebugDesc(HTTPHeaderDict *this)
{
  CFStringRef v2 = CFObject::copyDebugDescHeader(this);
  CFAllocatorRef v3 = (char *)this - 16;
  CFAllocatorRef v4 = CFGetAllocator((char *)this - 16);
  CFMutableDictionaryRef v5 = HTTPHeaderDict::copyAsOrdinaryDict((CFDictionaryRef *)this, v4);
  CFAllocatorRef v6 = CFGetAllocator(v3);
  CFStringRef v7 = CFStringCreateWithFormat(v6, 0, @"%@ { %@ }", v2, v5);
  if (v5) {
    CFRelease(v5);
  }
  if (v2) {
    CFRelease(v2);
  }
  return v7;
}

uint64_t visit(uint64_t result, CFTypeRef cf, uint64_t *a3)
{
  if (result)
  {
    if (cf)
    {
      uint64_t v4 = result;
      uint64_t v5 = *a3;
      CFTypeID v6 = CFGetTypeID(cf);
      uint64_t result = CFArrayGetTypeID();
      if (v6 == result)
      {
        uint64_t result = CFArrayGetCount((CFArrayRef)cf);
        if (result >= 1)
        {
          uint64_t v7 = result;
          for (CFIndex i = 0; i != v7; ++i)
          {
            CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, i);
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, const void *))(v5 + 16))(v5, v4, ValueAtIndex);
          }
        }
      }
    }
  }
  return result;
}

void sub_1842AA644(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1842AAFCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id webSocketLog(void)
{
  if (webSocketLog(void)::onceToken != -1) {
    dispatch_once(&webSocketLog(void)::onceToken, &__block_literal_global_17141);
  }
  v0 = (void *)webSocketLog(void)::logHandle;

  return v0;
}

void __destroy_helper_block_ea8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_ea8_32c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZL12webSocketLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.cfnetwork", "websocket");
  uint64_t v1 = (void *)webSocketLog(void)::logHandle;
  webSocketLog(void)::logHandle = (uint64_t)v0;
}

void sub_1842AB990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1842ABDEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Resume(a1);
}

void sub_1842AC09C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AC2AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AC3D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AC524(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AC614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  a9.super_class = (Class)__NSURLSessionWebSocketTask;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1842AC8C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AC9C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842ACBD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842ACCE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842ACE00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1842ACEEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AD044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1842AD30C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_1842AD4B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AD664(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AD730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1842AD834(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AD9C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_1842ADBF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1842ADD74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AE214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AE3B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1842AE500(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AE6AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  _Unwind_Resume(a1);
}

void sub_1842AE998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AEB20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842AEC4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1842AED30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1842AEEA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTPParser::~HTTPParser(HTTPParser *this)
{
  uint64_t v2 = (char *)this - 16;
  HTTPParser::~HTTPParser((HTTPParser *)((char *)this - 16));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  HTTPParser::~HTTPParser((HTTPParser *)((char *)this - 16));
}

char *HTTPParser::growBuffer(char *this)
{
  uint64_t v1 = *((void *)this + 71);
  if (v1 >= 1)
  {
    uint64_t v2 = this;
    size_t v3 = 2 * v1;
    uint64_t v4 = (char *)*((void *)this + 70);
    if (v4 == this + 44)
    {
      this = (char *)malloc_type_malloc(v3, 0x4FA712BFuLL);
      *((void *)v2 + 70) = this;
      if (this) {
        this = (char *)memcpy(this, v4, *((void *)v2 + 71));
      }
    }
    else
    {
      this = (char *)malloc_type_realloc(*((void **)this + 70), v3, 0x3E977CC1uLL);
      *((void *)v2 + 70) = this;
    }
    *((void *)v2 + 7HTTPServerConnection::canceled_onQueue(this - 1) = v3;
  }
  return this;
}

BOOL ConnectionEPTManager::_computeNewTarget(ConnectionEPTManager *this)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 2);
  uint64_t v2 = (void *)*((void *)this + 3);
  *((void *)this + 2) = 0;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  uint64_t v4 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v11;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(v2);
        }
        unint64_t v8 = [*(id *)(*((void *)&v10 + 1) + 8 * v7) _expectedProgressTarget];
        if (v8 && *((void *)this + 2) - 1 >= v8) {
          *((void *)this + 2) = v8;
        }
        ++v7;
      }
      while (v5 != v7);
      uint64_t v5 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v5);
  }
  return *((void *)this + 2) != v3;
}

uint64_t ConnectionEPTManager::taskTargetChanged(ConnectionEPTManager *this)
{
  uint64_t result = ConnectionEPTManager::_computeNewTarget(this);
  if (result)
  {
    uint64_t result = *((void *)this + 1);
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(result + 16);
      return v3();
    }
  }
  return result;
}

void sub_1842AF928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  AutoString::~AutoString((AutoString *)va);
  _Unwind_Resume(a1);
}

void sub_1842AFDE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void *copyNSCredentialDictForCFCredentialDict(const __CFDictionary *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)[(__CFDictionary *)a1 mutableCopy];
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v3 = objc_msgSend(v2, "allKeys", 0);
  uint64_t v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        unint64_t v8 = *(const void **)(*((void *)&v11 + 1) + 8 * i);
        id v9 = [[NSURLCredential alloc] _initWithCFURLCredential:CFDictionaryGetValue(a1, v8)];
        [v2 setObject:v9 forKey:v8];
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v5);
  }
  return v2;
}

HTTPHeaderDict *non-virtual thunk to'HTTPRequestMessage::mutableHeaders(HTTPRequestMessage *this)
{
  return HTTPMessage::mutableHeaders((HTTPRequestMessage *)((char *)this - 128));
}

uint64_t non-virtual thunk to'HTTPRequestMessage::mutableVersion(HTTPRequestMessage *this)
{
  return (uint64_t)this - 96;
}

void non-virtual thunk to'HTTPRequestMessage::~HTTPRequestMessage(HTTPRequestMessage *this)
{
}

{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 128));
}

{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 16));
}

{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 16));
}

{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 8));
}

{
  HTTPRequestMessage::~HTTPRequestMessage((HTTPRequestMessage *)((char *)this - 8));
}

uint64_t non-virtual thunk to'HTTPRequestMessage::parserAddHeader(HTTPRequestMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  return (*(uint64_t (**)(void))(*((void *)this + 14) + 24))();
}

uint64_t non-virtual thunk to'HTTPRequestMessage::parserCompleteFirstLine(HTTPRequestMessage *this, const unsigned __int8 *a2)
{
  return (*(uint64_t (**)(void))(*((void *)this + 14) + 16))();
}

uint64_t HTTPRequestMessage::mutableVersion(HTTPRequestMessage *this)
{
  return (uint64_t)this + 32;
}

uint64_t HTTPRequestMessage::parserCompleteFirstLine(HTTPRequestMessage *this, const unsigned __int8 *a2)
{
  return (*(uint64_t (**)(void))(*((void *)this + 16) + 16))();
}

uint64_t HTTPRequestMessage::parserAddHeader(HTTPRequestMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  return (*(uint64_t (**)(void))(*((void *)this + 16) + 24))();
}

CFStringRef HTTPRequestMessage::copyDebugSummary(HTTPRequestMessage *this)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 22) || *((void *)this + 19) && *((void *)this + 5))
  {
    uint64_t v2 = (char *)this - 16;
    CFGetAllocator((char *)this - 16);
    uint64_t v3 = (const void *)*((void *)this + 5);
    if (v3) {
      CFTypeRef v4 = CFRetain(v3);
    }
    else {
      CFTypeRef v4 = 0;
    }
    CFGetAllocator((char *)this - 16);
    uint64_t v6 = (const void *)*((void *)this + 19);
    if (v6) {
      CFTypeRef v7 = CFRetain(v6);
    }
    else {
      CFTypeRef v7 = 0;
    }
    unint64_t v8 = (HTTPRequestMessage *)((char *)this + 128);
    if (__CFNCanLogSensitiveContent::onceToken != -1) {
      dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_38);
    }
    int v9 = __CFNCanLogSensitiveContent::ok;
    CFAllocatorRef v10 = CFGetAllocator((char *)this - 16);
    if (v9)
    {
      CFAllocatorRef v11 = CFGetAllocator(v2);
      CFURLRef v12 = (const __CFURL *)HTTPRequestParserClient::requestURL(v8);
      URLPortion::URLPortion((URLPortion *)&allocator, v11, v12, 1);
      CFStringRef v13 = CFStringCreateWithFormat(v10, 0, @"%@ %s %@", v7, v19, v4);
      if (ptr != &v17) {
        CFAllocatorDeallocate(allocator, ptr);
      }
      if (!v4) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v14 = [(id)HTTPRequestParserClient::requestURL(v8) scheme];
      uint64_t v15 = [(id)HTTPRequestParserClient::requestURL(v8) host];
      CFStringRef v13 = CFStringCreateWithFormat(v10, 0, @"%@ %@://%@/<redacted>", v7, v14, v15);
      if (!v4)
      {
LABEL_22:
        if (v7) {
          CFRelease(v7);
        }
        return v13;
      }
    }
    CFRelease(v4);
    goto LABEL_22;
  }

  return (CFStringRef)CFRetain(@"not yet parsed");
}

void sub_1842B04B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const __CFAllocator *allocator, uint64_t a14)
{
  if ((uint64_t *)STACK[0x228] != &a14) {
    CFAllocatorDeallocate(allocator, (void *)STACK[0x228]);
  }
  _Unwind_Resume(a1);
}

CFStringRef HTTPRequestMessage::copyDebugDesc(HTTPRequestMessage *this)
{
  uint64_t v2 = (HTTPRequestMessage *)((char *)this + 128);
  uint64_t v3 = (char *)this - 16;
  CFGetAllocator((char *)this - 16);
  CFTypeRef v4 = (const void *)*((void *)this + 19);
  if (v4) {
    CFTypeRef v5 = CFRetain(v4);
  }
  else {
    CFTypeRef v5 = 0;
  }
  CFAllocatorRef v6 = CFGetAllocator(v3);
  uint64_t v7 = HTTPRequestParserClient::requestURL(v2);
  CFStringRef v8 = CFStringCreateWithFormat(v6, 0, @"<CFHTTPMessageRef %p(%p)> { %@ request, url %@ }", v3, this, v5, v7);
  if (v5) {
    CFRelease(v5);
  }
  return v8;
}

void HTTPResponseMessage::uninitFirstLine(HTTPResponseMessage *this)
{
  uint64_t v2 = (const void *)*((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 36);
  if (v3)
  {
    free(v3);
    *((void *)this + 36) = 0;
  }
  *((unsigned char *)this + 160) = 0;
}

void non-virtual thunk to'HTTPResponseMessage::~HTTPResponseMessage(HTTPResponseMessage *this)
{
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 16));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 8));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 8));
}

void HTTPResponseMessage::parserAddHeader(HTTPResponseMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  CFTypeRef v5 = (CFDictionaryRef *)HTTPMessage::mutableHeaders(this);

  HTTPHeaderDict::addValue(v5, a2, a3);
}

CFStringRef HTTPResponseMessage::copyDebugSummary(HTTPResponseMessage *this)
{
  uint64_t v1 = (char *)*((void *)this + 36);
  if (v1 || (uint64_t v1 = (char *)this + 160, *((unsigned char *)this + 160)))
  {
    CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
    return CFStringCreateWithFormat(v2, 0, @"%s", v1);
  }
  else
  {
    return (CFStringRef)CFRetain(@"not yet parsed");
  }
}

CFStringRef HTTPResponseMessage::copyDebugDesc(HTTPResponseMessage *this)
{
  if (*((void *)this + 36) || *((unsigned char *)this + 160))
  {
    if (*((void *)this + 16) != -1)
    {
      CFAllocatorRef v2 = "parsed";
LABEL_5:
      CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
      return CFStringCreateWithFormat(v3, 0, @"<CFHTTPMessageRef %p(%p)> { %s response, url = %@, status = %ld }", (char *)this - 16, this, v2, *((void *)this + 18), *((void *)this + 16));
    }
LABEL_16:
    CFAllocatorRef v11 = CFGetAllocator((char *)this - 16);
    return CFStringCreateWithFormat(v11, 0, @"<CFHTTPMessageRef %p(%p)> { incomplete response, url = %@ }", (char *)this - 16, this, *((void *)this + 18));
  }
  int v5 = *((_DWORD *)this + 32);
  if (v5 != 200 && v5 != -1)
  {
    if (*((void *)this + 16) != -1)
    {
      CFAllocatorRef v2 = "incomplete";
      goto LABEL_5;
    }
    goto LABEL_16;
  }
  CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
  uint64_t v9 = *((void *)this + 18);
  CFIndex Length = (const __CFData **)*((void *)this + 6);
  if (Length) {
    CFIndex Length = (const __CFData **)HTTPBodyData::getLength(Length, v7);
  }
  return CFStringCreateWithFormat(v8, 0, @"<CFHTTPMessageRef %p(%p)> { simple response, url = %@, body = %ld bytes }", (char *)this - 16, this, v9, Length);
}

void sub_1842B0A34(_Unwind_Exception *a1)
{
  CFAllocatorRef v8 = v6;

  _Unwind_Resume(a1);
}

void sub_1842B0D98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842B11C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1842B133C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  CFURLRef v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1842B1938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

void sub_1842B1A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842B1DE4(_Unwind_Exception *a1)
{
  int v5 = v3;

  _Unwind_Resume(a1);
}

void sub_1842B2080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1842B23C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1842B3690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  _Unwind_Resume(a1);
}

void sub_1842B3BAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842B3D5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842B3E08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842B3EE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842B3FA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t SegmentedData::PrivateAllocation::length(SegmentedData::PrivateAllocation *this)
{
  return *((void *)this + 4) - *((void *)this + 3);
}

uint64_t SegmentedData::PrivateAllocation::ptr(SegmentedData::PrivateAllocation *this)
{
  return *((void *)this + 3);
}

void SegmentedData::PrivateAllocation::~PrivateAllocation(CFAllocatorRef *this)
{
}

CFStringRef SegmentedData::copyDebugDesc(SegmentedData *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1)
  {
    uint64_t v2 = 0;
    do
    {
      ++v2;
      uint64_t v1 = *(void *)(v1 + 16);
    }
    while (v1);
  }
  else
  {
    uint64_t v2 = 0;
  }
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<SegmentedData@%p> { %ld bytes in %ld segments }", this, *((void *)this + 5), v2);
}

void SegmentedData::~SegmentedData(SegmentedData *this)
{
  SegmentedData::~SegmentedData(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  void *v2;
  void *v3;

  *(void *)this = &unk_1ECF9C5B0;
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    do
    {
      CFAllocatorRef v3 = (void *)v2[2];
      (*(void (**)(void *))(*v2 + 8))(v2);
      *((void *)this + 3) = v3;
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void non-virtual thunk to'SynchronizedData::~SynchronizedData(SynchronizedData *this)
{
  uint64_t v2 = (char *)this - 16;
  SynchronizedData::~SynchronizedData((SynchronizedData *)((char *)this - 16));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  SynchronizedData::~SynchronizedData((SynchronizedData *)((char *)this - 16));
}

void SynchronizedData::~SynchronizedData(SynchronizedData *this)
{
  *(void *)this = &unk_1ECF9DF68;
  uint64_t v1 = (SynchronizedData *)((char *)this + 16);
  *((void *)this + 2) = &unk_1ECF9DF88;
  uint64_t v2 = *((void *)this + 17);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  CoreCondLock::~CoreCondLock(v1);
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  SynchronizedData::~SynchronizedData(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void non-virtual thunk to'HSTSCache::~HSTSCache(HSTSCache *this)
{
}

{
  HSTSCache::~HSTSCache((HSTSCache *)((char *)this - 8));
}

CFStringRef HSTSCache::copyDebugDesc(HSTSCache *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<HSTSCache@%p> { %p }", this, *((void *)this + 6));
}

void _CFNetworkSetHSTSStoragePath(const void *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&HSTSPathOverrideLock);
  if (a1) {
    CFRetain(a1);
  }
  if (HSTSPathOverride) {
    CFRelease((CFTypeRef)HSTSPathOverride);
  }
  HSTSPathOverride = (uint64_t)a1;

  os_unfair_lock_unlock((os_unfair_lock_t)&HSTSPathOverrideLock);
}

void sub_1842B43AC(_Unwind_Exception *a1)
{
}

CFDictionaryRef ___ZNK9HSTSCache40copyInternalRepresentationOfHSTSPoliciesEv_block_invoke(CFDictionaryRef result)
{
  CFDictionaryRef v1 = *(const __CFDictionary **)(*((void *)result + 5) + 56);
  if (v1)
  {
    CFDictionaryRef v2 = result;
    uint64_t result = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1);
    *(void *)(*(void *)(*((void *)v2 + 4) + 8) + CFRelease((char *)this - 24) = result;
  }
  return result;
}

void HSTSCache::modifyHSTSStore(HSTSCache *this, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  if (a4) {
    CFRetain(a4);
  }
  CFAllocatorRef v8 = *((void *)this + 2);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN9HSTSCache15modifyHSTSStoreEPK10__CFStringPK14__CFDictionaryPK8__CFDate_block_invoke;
  v9[3] = &__block_descriptor_64_e5_v8__0l;
  v9[4] = this;
  v9[5] = cf;
  v9[6] = a3;
  v9[7] = a4;
  dispatch_sync(v8, v9);
}

void ___ZN9HSTSCache15modifyHSTSStoreEPK10__CFStringPK14__CFDictionaryPK8__CFDate_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  if (!*(unsigned char *)(v2 + 88) && *(unsigned char *)(v2 + 73))
  {
    uint64_t v6 = *(void *)(v2 + 80);
    uint64_t v7 = (uint64_t *)MEMORY[0x1E4F1CFC8];
    if (!v6)
    {
      if (*(void *)(v2 + 32))
      {
        uint64_t v6 = 0;
      }
      else
      {
        dispatch_source_t v27 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(v2 + 16));
        *(void *)(v2 + 32) = v27;
        if (!v27) {
          goto LABEL_37;
        }
        uint64_t v28 = v27;
        dispatch_time_t v29 = dispatch_time(0x8000000000000000, 5000000000);
        dispatch_source_set_timer(v28, v29, 0x12A05F200uLL, 0x3B9ACA00uLL);
        objc_initWeak(&location, (id)(v2 - 16));
        CFIndex v30 = *(NSObject **)(v2 + 32);
        v33[0] = MEMORY[0x1E4F143A8];
        v33[1] = 3221225472;
        v33[2] = ___ZN9HSTSCache24initPersistentStoreTimerEv_block_invoke;
        v33[3] = &unk_1E5258100;
        objc_copyWeak(&v34, &location);
        dispatch_source_set_event_handler(v30, v33);
        *(void *)(v2 + 40) = 1;
        objc_destroyWeak(&v34);
        objc_destroyWeak(&location);
        if (*(void *)(v2 + 32))
        {
          uint64_t v6 = *v7;
          *(void *)(v2 + CFRetain((char *)this - 80) = *v7;
        }
        else
        {
LABEL_37:
          *(unsigned char *)(v2 + 88) = 1;
          uint64_t v6 = *(void *)(v2 + 80);
        }
      }
    }
    if (v6 == *v7)
    {
      *(void *)(v2 + CFRetain((char *)this - 80) = *MEMORY[0x1E4F1CFD0];
      uint64_t v31 = *(void *)(v2 + 40) - 1;
      *(void *)(v2 + 40) = v31;
      if (!v31)
      {
        CFStringRef v32 = *(NSObject **)(v2 + 32);
        if (v32) {
          dispatch_resume(v32);
        }
      }
    }
  }
  CFAllocatorRef v3 = (const void *)a1[5];
  if (v3)
  {
    CFTypeRef v4 = (const void *)a1[6];
    int v5 = *(__CFDictionary **)(v2 + 56);
    if (v4)
    {
      CFDictionarySetValue(v5, v3, v4);
      goto LABEL_25;
    }
    CFDictionaryRemoveValue(v5, v3);
  }
  else if (a1[7])
  {
    CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(v2 + 56));
    if (Count >= 1)
    {
      CFIndex v9 = Count;
      size_t v10 = 8 * Count;
      CFAllocatorRef v11 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      CFURLRef v12 = (const void **)malloc_type_malloc(v10, 0x80040B8603338uLL);
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(v2 + 56), v11, v12);
      for (uint64_t i = 0; i != v9; ++i)
      {
        CFTypeID v14 = CFGetTypeID(v12[i]);
        if (v14 == CFDictionaryGetTypeID())
        {
          uint64_t v16 = a1[7];
          double TimeForKey = HSTSParser::getTimeForKey((HSTSParser *)v12[i], (const __CFDictionary *)@"Create Time", v15);
          if (TimeForKey >= MEMORY[0x185319AB0](v16)) {
            CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v2 + 56), v11[i]);
          }
        }
      }
      free(v12);
      free(v11);
    }
  }
  else
  {
    CFAllocatorRef v18 = CFGetAllocator((CFTypeRef)(v2 - 16));
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v18, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v20 = *(const void **)(v2 + 48);
    *(void *)(v2 + 48) = Mutable;
    if (v20) {
      CFRelease(v20);
    }
    CFAllocatorRef v21 = CFGetAllocator((CFTypeRef)(v2 - 16));
    CFMutableDictionaryRef v22 = CFDictionaryCreateMutable(v21, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    unsigned __int8 v23 = *(const void **)(v2 + 56);
    *(void *)(v2 + 56) = v22;
    if (v23)
    {
      CFRelease(v23);
      CFMutableDictionaryRef v22 = *(CFMutableDictionaryRef *)(v2 + 56);
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v2 + 48), @"com.apple.CFNetwork.defaultStorageSession", v22);
  }
  if (*(unsigned char *)(v2 + 73)) {
    HSTSCache::persistKnownHSTSHosts(v2);
  }
LABEL_25:
  uint64_t v24 = (const void *)a1[7];
  if (v24) {
    CFRelease(v24);
  }
  CFTypeID v25 = (const void *)a1[6];
  if (v25) {
    CFRelease(v25);
  }
  uint64_t v26 = (const void *)a1[5];
  if (v26)
  {
    CFRelease(v26);
  }
}

uint64_t HSTSCache::persistKnownHSTSHosts(uint64_t this)
{
  if (!*(unsigned char *)(this + 88))
  {
    uint64_t v1 = this;
    CFErrorRef error = 0;
    CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)(this - 16));
    CFPropertyListCreateData(v2, *(CFPropertyListRef *)(v1 + 48), kCFPropertyListBinaryFormat_v1_0, 0, &error);
    operator new();
  }
  return this;
}

void sub_1842B49B0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN9HSTSCache21persistKnownHSTSHostsEv_block_invoke(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  CFRetain((CFTypeRef)(v2 - 16));
  CFDataRef v3 = *(const __CFData **)(a1 + 40);
  CFTypeRef v4 = *(NSObject **)(v2 + 16);
  v23[0] = MEMORY[0x1E4F143A8];
  v23[1] = 3221225472;
  void v23[2] = ___ZN9HSTSCache21persistKnownHSTSHostsEv_block_invoke_2;
  v23[3] = &__block_descriptor_40_e8_v12__0C8l;
  void v23[4] = v2;
  if (!v3) {
    goto LABEL_30;
  }
  if (!*(unsigned char *)(v2 + 88))
  {
    if (!*(unsigned char *)(v2 + 72))
    {
      *(unsigned char *)(v2 + 72) = 1;
      CFURLRef v15 = *(const __CFURL **)(v2 + 64);
      if (v15)
      {
        CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v15);
        CFURLRef v18 = PathComponent;
        if (PathComponent)
        {
          CFStringRef v19 = CFURLCopyPath(PathComponent);
          if (v19)
          {
            MutableCFStringRef Copy = CFStringCreateMutableCopy(v16, 0, v19);
            CFStringRef v21 = MutableCopy;
            if (MutableCopy)
            {
              if (CFStringGetFileSystemRepresentation(MutableCopy, buffer, 1024)) {
                __BuildPath(buffer);
              }
              CFRelease(v21);
            }
            CFRelease(v19);
          }
          CFRelease(v18);
        }
      }
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v22 = *(void *)(v2 + 64);
      *(_DWORD *)buffer = 134218242;
      *(void *)&buffer[4] = v2;
      *(_WORD *)&buffer[12] = 2112;
      *(void *)&buffer[14] = v22;
      _os_log_debug_impl(&dword_184085000, v6, OS_LOG_TYPE_DEBUG, "HSTS storage %p path %@", buffer, 0x16u);
    }
    CFURLRef v7 = *(const __CFURL **)(v2 + 64);
    if (v7)
    {
      CFAllocatorRef v8 = CFGetAllocator(*(CFTypeRef *)(v2 + 64));
      CFIndex v9 = CFWriteStreamCreateWithFile((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7);
      size_t v10 = v9;
      if (v9)
      {
        if (CFWriteStreamOpen(v9))
        {
          CFIndex Length = CFDataGetLength(v3);
          BytePtr = CFDataGetBytePtr(v3);
          CFIndex v13 = CFWriteStreamWrite(v10, BytePtr, Length);
          if (v13 < 0) {
            CFErrorRef v14 = CFWriteStreamCopyError(v10);
          }
          else {
            CFErrorRef v14 = 0;
          }
          CFWriteStreamClose(v10);
          CFRelease(v10);
          if (v13 >= 0)
          {
            char v5 = 1;
            goto LABEL_31;
          }
        }
        else
        {
          CFErrorRef v14 = CFWriteStreamCopyError(v10);
          CFRelease(v10);
        }
      }
      else
      {
        CFErrorRef v14 = CFErrorCreate(v8, (CFErrorDomain)*MEMORY[0x1E4F1D158], 1, 0);
      }
      if (v14) {
        CFRelease(v14);
      }
    }
LABEL_30:
    char v5 = 0;
    *(unsigned char *)(v2 + 88) = 1;
    goto LABEL_31;
  }
  char v5 = 0;
LABEL_31:
  *(void *)buffer = MEMORY[0x1E4F143A8];
  *(void *)&UInt8 buffer[8] = 3221225472;
  *(void *)&buffer[16] = ___ZN9HSTSCache35persistKnownHSTSHostsWithCompletionEPK8__CFDataPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvhE_block_invoke;
  CFTypeID v25 = &unk_1E5257240;
  uint64_t v26 = v23;
  char v27 = v5;
  dispatch_async(v4, buffer);
  CFRelease((CFTypeRef)(v2 - 16));
}

void sub_1842B4D14(_Unwind_Exception *a1)
{
  CFRelease(v2);
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_40c36_ZTSNSt3__110shared_ptrIK8__CFDataEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c36_ZTSNSt3__110shared_ptrIK8__CFDataEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN9HSTSCache21persistKnownHSTSHostsEv_block_invoke_2(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!a2)
  {
    CFDataRef v3 = *(NSObject **)(v2 + 32);
    if (v3) {
      dispatch_source_cancel(v3);
    }
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t ___ZN9HSTSCache35persistKnownHSTSHostsWithCompletionEPK8__CFDataPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvhE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

id ___ZN9HSTSCache24initPersistentStoreTimerEv_block_invoke(uint64_t a1)
{
  id result = objc_loadWeak((id *)(a1 + 32));
  if (result)
  {
    id v2 = result;
    if (HSTSCache::Class(void)::sOnce_HSTSCache != -1) {
      dispatch_once(&HSTSCache::Class(void)::sOnce_HSTSCache, &__block_literal_global_2_17662);
    }
    return (id)HSTSCache::persistKnownHSTSHosts((uint64_t)v2 + 16);
  }
  return result;
}

CFDictionaryRef HSTSParser::createHSTSInfo(HSTSParser *this, const __CFAllocator *a2, CFAbsoluteTime a3, int a4, const void *a5, const __CFNumber *a6)
{
  int v8 = (int)a2;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(this, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFURLRef v12 = Mutable;
  CFIndex v13 = (const void **)MEMORY[0x1E4F1CFD0];
  if (a4) {
    CFDictionaryAddValue(Mutable, @"HSTS Host", (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  if (v8) {
    CFDictionaryAddValue(v12, @"Include Subdomains", *v13);
  }
  if (a5)
  {
    CFDictionaryAddValue(v12, @"Expiry", a5);
  }
  else
  {
    CFAbsoluteTime valuePtr = a3;
    if (a3 > 0.0)
    {
      double v14 = CFAbsoluteTimeGetCurrent() + a3;
      if (v14 > 1.79769313e308) {
        double v14 = 1.79769313e308;
      }
      CFAbsoluteTime valuePtr = v14;
    }
    CFNumberRef v15 = CFNumberCreate(this, kCFNumberDoubleType, &valuePtr);
    if (v15)
    {
      CFNumberRef v16 = v15;
      CFDictionaryAddValue(v12, @"Expiry", v15);
      CFRelease(v16);
    }
  }
  CFAbsoluteTime valuePtr = CFAbsoluteTimeGetCurrent();
  CFNumberRef v17 = CFNumberCreate(this, kCFNumberDoubleType, &valuePtr);
  if (v17)
  {
    CFNumberRef v18 = v17;
    CFDictionaryAddValue(v12, @"Create Time", v17);
    CFRelease(v18);
  }
  if (!v12) {
    return 0;
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy(this, v12);
  CFRelease(v12);
  return Copy;
}

double HSTSParser::getTimeForKey(HSTSParser *this, const __CFDictionary *a2, const __CFString *a3)
{
  unint64_t valuePtr = 0xBFF0000000000000;
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(this, a2);
  double v4 = -1.0;
  if (Value)
  {
    CFNumberRef v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
      return *(double *)&valuePtr;
    }
  }
  return v4;
}

void ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t CoreLogFileSink::sinkBytes(uint64_t this, CFDataRef theData)
{
  if (*(void *)(this + 272))
  {
    uint64_t v3 = this;
    BytePtr = CFDataGetBytePtr(theData);
    size_t Length = CFDataGetLength(theData);
    fwrite(BytePtr, Length, 1uLL, *(FILE **)(v3 + 272));
    CFTypeID v6 = *(FILE **)(v3 + 272);
    return fflush(v6);
  }
  return this;
}

void CoreLogFileSink::~CoreLogFileSink(CoreLogFileSink *this)
{
}

{
  FILE *v2;

  *(void *)this = &unk_1ECF9D178;
  id v2 = (FILE *)*((void *)this + 34);
  if (v2)
  {
    if (*((unsigned char *)this + 280)) {
      fclose(v2);
    }
  }
  *(void *)this = &unk_1ECF9AA90;
  abort();
}

{
  CoreLogFileSink::~CoreLogFileSink(this);
}

void CoreLogFileSink::CoreLogFileSink(CoreLogFileSink *this, __sFILE *a2)
{
  *(void *)this = &unk_1ECF9AA90;
  double v4 = (char *)this + 8;
  snprintf((char *)this + 8, 0x100uLL, "com.apple.CFNetwork.LogSink[%s]", "stderr");
  *((void *)this + 33) = dispatch_queue_create(v4, 0);
  *((void *)this + 34) = a2;
  *(void *)this = &unk_1ECF9D178;
  *((unsigned char *)this + 2CFRetain((char *)this - 80) = 0;
}

void non-virtual thunk to'DispatchHost::~DispatchHost(DispatchHost *this)
{
}

{
  DispatchHost::~DispatchHost((DispatchHost *)((char *)this - 8));
}

void DispatchHost::~DispatchHost(DispatchHost *this)
{
  *(void *)this = &unk_1ECF9B6D0;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9B740;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  id v2 = (char **)*((void *)this + 21);
  if (v2)
  {
    uint64_t v3 = v2[2];
    if (v3)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v3, *((const __CFArray **)this + 15));
      _CFTypeInvalidate(v2[2]);
      CFRelease(v2[2]);
      v2[2] = 0;
      (*((void (**)(char **))*v2 + 8))(v2);
      id v2 = (char **)*((void *)this + 21);
    }
    CFRelease(v2 - 2);
  }
  double v4 = *((void *)this + 18);
  if (v4) {
    dispatch_release(v4);
  }
  CFNumberRef v5 = *((void *)this + 19);
  if (v5) {
    dispatch_release(v5);
  }
  CFTypeID v6 = (const void *)*((void *)this + 20);
  if (v6) {
    CFRelease(v6);
  }
  CFURLRef v7 = (const void *)*((void *)this + 17);
  if (v7) {
    _Block_release(v7);
  }
  HostBase::unlock(this);

  HostBase::~HostBase(this);
}

void sub_1842B5434(_Unwind_Exception *a1)
{
  HostBase::~HostBase(v1);
  _Unwind_Resume(a1);
}

void DispatchHost::clientAttached(DispatchHost *this, int a2)
{
  if (!a2)
  {
    value[7] = v2;
    value[8] = v3;
    CFRetain((char *)this - 16);
    value[0] = MEMORY[0x1E4F143A8];
    value[1] = 3221225472;
    value[2] = ___ZN12DispatchHost14clientAttachedEh_block_invoke;
    value[3] = &__block_descriptor_40_e5_v8__0l;
    value[4] = this;
    HostBase::deferredUntilUnlocked((uint64_t)this, value);
  }
}

void ___ZN12DispatchHost14clientAttachedEh_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFRetain((CFTypeRef)(v2 - 16));
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 32));
  ++*(void *)(v2 + 16);
  uint64_t v3 = *(void (***)(void, void))(v2 + 136);
  *(void *)(v2 + CFRetain((char *)this - 136) = 0;
  HostBase::unlock((HostBase *)v2);
  if (v3)
  {
    v3[2](v3, 0);
    _Block_release(v3);
    CFRelease((CFTypeRef)(v2 - 16));
  }
  double v4 = (const void *)(*(void *)(a1 + 32) - 16);

  CFRelease(v4);
}

uint64_t DispatchHost::scheduleWithRunLoop(DispatchHost *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFTypeID v6 = (char *)this - 16;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  if (HostBase::scheduleWithRunLoop(this, a2, a3))
  {
    uint64_t v7 = *((void *)this + 21);
    if (v7)
    {
      int v8 = *(void **)(v7 + 16);
      if (v8) {
        _CFTypeScheduleOnRunLoop(v8, (uint64_t)a2, (uint64_t)a3);
      }
    }
    else
    {
      CFGetAllocator(v6);
      if (HostLookup::Class(void)::sOnce_HostLookup != -1) {
        dispatch_once(&HostLookup::Class(void)::sOnce_HostLookup, &__block_literal_global_10396);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
        Instance += 16;
        *(void *)(Instance + 48) = 0;
        *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
        *(_OWORD *)(Instance + 32) = 0u;
      }
      HostLookup_RunLoopSource::HostLookup_RunLoopSource((HostLookup_RunLoopSource *)Instance, @"hack");
      *CFAllocatorRef v11 = &unk_1ECF9C480;
      v11[1] = &unk_1ECF9C4E8;
      void v11[6] = this;
      *((void *)this + 2HTTPServerConnection::canceled_onQueue(this - 1) = v11;
      CFURLRef v12 = (void *)v11[2];
      if (v12) {
        _CFTypeScheduleOnMultipleRunLoops(v12, *((const __CFArray **)this + 15));
      }
    }
    CFArrayRef v13 = (const __CFArray *)*((void *)this + 20);
    if (v13 && CFArrayGetCount(v13) >= 1) {
      DispatchHost::signalKickerLocked(this);
    }
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
  }
  HostBase::unlock(this);
  return v9;
}

void DispatchHost::signalKickerLocked(DispatchHost *this)
{
  uint64_t v1 = *((void *)this + 21);
  if (v1)
  {
    CFArrayRef Copy = (const __CFArray *)*((void *)this + 15);
    if (Copy)
    {
      CFAllocatorRef v4 = CFGetAllocator(*((CFTypeRef *)this + 15));
      CFArrayRef Copy = CFArrayCreateCopy(v4, Copy);
      uint64_t v1 = *((void *)this + 21);
    }
    CFTypeRef v5 = *(CFTypeRef *)(v1 + 32);
    if (v5) {
      CFTypeRef v5 = CFRetain(v5);
    }
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = ___ZN12DispatchHost18signalKickerLockedEv_block_invoke;
    v6[3] = &__block_descriptor_48_e5_v8__0l;
    void v6[4] = v5;
    void v6[5] = Copy;
    HostBase::deferredUntilUnlocked((uint64_t)this, v6);
  }
}

void ___ZN12DispatchHost18signalKickerLockedEv_block_invoke(uint64_t a1)
{
  CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 32));
  uint64_t v2 = *(__CFRunLoopSource **)(a1 + 32);
  CFArrayRef v3 = *(const __CFArray **)(a1 + 40);
  if (v3)
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0; i < v5; i += 2)
      {
        CFDictionaryRef ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v3, i);
        if (CFRunLoopIsWaiting(ValueAtIndex))
        {
          CFStringRef v8 = CFRunLoopCopyCurrentMode(ValueAtIndex);
          if (v8)
          {
            CFStringRef v9 = v8;
            if (CFRunLoopContainsSource(ValueAtIndex, v2, v8)) {
              CFRunLoopWakeUp(ValueAtIndex);
            }
            CFRelease(v9);
          }
        }
      }
    }
    size_t v10 = *(const void **)(a1 + 40);
    if (v10) {
      CFRelease(v10);
    }
    uint64_t v2 = *(__CFRunLoopSource **)(a1 + 32);
  }
  if (v2)
  {
    CFRelease(v2);
  }
}

void non-virtual thunk to'RunLoopKicker::~RunLoopKicker(RunLoopKicker *this)
{
}

{
  HostLookup_RunLoopSource::~HostLookup_RunLoopSource((RunLoopKicker *)((char *)this - 8));
}

void RunLoopKicker::perform(RunLoopKicker *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (v1)
  {
    CFRetain((CFTypeRef)(v1 - 16));
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 32));
    ++*(void *)(v1 + 16);
    uint64_t v2 = *(const void **)(v1 + 160);
    *(void *)(v1 + 160) = 0;
    HostBase::unlock((HostBase *)v1);
    if (v2)
    {
      CFContainerEnumeratorBase::setup((unint64_t)v4, v2, MEMORY[0x1E4F1C1E0], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimArrayData);
      uint64_t v7 = 0;
      while (1)
      {
        uint64_t v3 = v7;
        if (v7 >= v5) {
          break;
        }
        ++v7;
        HostBase::invokeCallback((HostBase *)v1, *(const __CFString **)(v6 + 8 * v3));
      }
      CFRelease((CFTypeRef)(v1 - 16));
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v4);
      CFRelease(v2);
    }
  }
}

void sub_1842B598C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

CFTypeRef DispatchHost::startInfoResolution(DispatchHost *this, __CFString *a2, const __CFString *a3, const __CFDictionary *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (char *)this - 16;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 12), a2);
  dispatch_group_enter(*((dispatch_group_t *)this + 19));
  int ExactString = _findExactString(a2, 0xAu);
  if (!HostBase::calculateWantsLocked((uint64_t)this, ExactString, (CFIndex *)&v26))
  {
    CFAllocatorRef v12 = CFGetAllocator(v7);
    *(_OWORD *)&handle[1] = xmmword_1843D1830;
    CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v12, &handle[1]);
    goto LABEL_21;
  }
  if (ExactString <= 492009983)
  {
    if (ExactString != 487864780 && ExactString != 489863658 && ExactString != 490912245) {
      goto LABEL_27;
    }
    double v14 = v26;
    if (!v26) {
      goto LABEL_27;
    }
    CFNumberRef v15 = this;
    CFNumberRef v16 = (DispatchHost *)a2;
    goto LABEL_20;
  }
  if (ExactString <= 495032865)
  {
    if (ExactString == 492009984)
    {
      CFAllocatorRef v11 = &_kCFHostMasterAddressLookupString;
    }
    else
    {
      if (ExactString != 494017049) {
        goto LABEL_27;
      }
      CFAllocatorRef v11 = &kCFHostAddressesString;
    }
    CFNumberRef v16 = (DispatchHost *)*v11;
    double v14 = v26;
    CFNumberRef v15 = this;
LABEL_20:
    CFErrorWithStreamCFStreamError Error = HostLookup_Master::enqueueWithHost(v15, v16, v14, a3, v10);
    goto LABEL_21;
  }
  if (ExactString == 495032866)
  {
    CFDataGetBytePtr(theData);
    operator new();
  }
  if (ExactString != 496138793) {
    goto LABEL_27;
  }
  if (theData)
  {
    Reachability = HostLookup_Reachability::CreateReachability(theData, v9);
LABEL_17:
    CFErrorWithStreamCFStreamError Error = enqueueWithHost(this, Reachability);
    goto LABEL_21;
  }
  CFStringRef v19 = v26;
  if (!v26) {
    goto LABEL_27;
  }
  if (HostLookup_ReachabilityFixed::isDottedIP(v26, (const __CFString *)v9))
  {
    Reachability = HostLookup_Reachability::CreateReachability(v19, v20);
    goto LABEL_17;
  }
  CFErrorWithStreamCFStreamError Error = HostLookup_Reachability::enqueueWithHost((dispatch_queue_t *)this, v19, v21);
LABEL_21:
  CFTypeRef v18 = CFErrorWithStreamError;
  if (CFErrorWithStreamError)
  {
    dispatch_group_leave(*((dispatch_group_t *)this + 19));
    goto LABEL_33;
  }
  if (*((void *)this + 13)) {
    goto LABEL_32;
  }
LABEL_27:
  do
  {
    HostBase::unlock(this);
    dispatch_group_wait(*((dispatch_group_t *)this + 19), 0xFFFFFFFFFFFFFFFFLL);
    CFRetain(v7);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    ++*((void *)this + 2);
  }
  while (!CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2));
  CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2);
  CFTypeID v23 = CFGetTypeID(Value);
  if (v23 == CFErrorGetTypeID() && (uint64_t v24 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2)) != 0) {
    CFTypeRef v18 = CFRetain(v24);
  }
  else {
LABEL_32:
  }
    CFTypeRef v18 = 0;
LABEL_33:
  HostBase::unlock(this);
  return v18;
}

void sub_1842B5E30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFAllocatorRef allocator, uint64_t a14, void *ptr)
{
}

CFStringRef DispatchHost::copyDebugDesc(DispatchHost *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"DispatchHost<%p>", this);
}

dispatch_queue_t copyHostQueue(void)
{
  uint64_t v0 = copyHostQueue(void)::gQueueCreate;
  if (!(copyHostQueue(void)::gQueue | copyHostQueue(void)::gQueueCreate))
  {
    if (copyHostQueue(void)::sOnce != -1) {
      dispatch_once(&copyHostQueue(void)::sOnce, &__block_literal_global_17827);
    }
    uint64_t v0 = copyHostQueue(void)::gQueueCreate;
  }
  if (v0)
  {
    return dispatch_queue_create("com.apple.DispatchHost", 0);
  }
  else
  {
    dispatch_retain((dispatch_object_t)copyHostQueue(void)::gQueue);
    return (dispatch_queue_t)copyHostQueue(void)::gQueue;
  }
}

void ___ZL13copyHostQueuev_block_invoke()
{
  if (!(copyHostQueue(void)::gQueue | copyHostQueue(void)::gQueueCreate))
  {
    uint64_t v0 = getenv("CFNETWORK_HOST_QUEUE_KIND");
    if (v0)
    {
      int v1 = atoi(v0);
      if (v1 == 2)
      {
        dispatch_queue_t global_queue = dispatch_queue_create("com.apple.DispatchHost-Shared", 0);
        goto LABEL_8;
      }
      if (v1 == 1)
      {
        copyHostQueue(void)::gQueueCreate = MEMORY[0x1E4F147A0];
        return;
      }
    }
    dispatch_queue_t global_queue = dispatch_get_global_queue(0, 0);
LABEL_8:
    copyHostQueue(void)::gQueue = (uint64_t)global_queue;
  }
}

void DispatchHost::DispatchHost(DispatchHost *this, const __CFString *a2, const void *a3, ...)
{
  va_start(va, a3);
  HostBase::HostBase(this, 0);
  *uint64_t v6 = &unk_1ECF9B6D0;
  v6[1] = &unk_1ECF9B740;
  *((void *)this + 18) = copyHostQueue();
  *((void *)this + 19) = dispatch_group_create();
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  HostBase::setInfoLocked(this, a2, a3);
  HostBase::setInfoLocked(this, va);
  HostBase::unlock(this);
}

void sub_1842B60D4(_Unwind_Exception *a1)
{
  HostBase::~HostBase(v1);
  _Unwind_Resume(a1);
}

void DispatchHost::performCallback(DispatchHost *this, const __CFString *a2, const void *a3)
{
  uint64_t v6 = (char *)this - 16;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  if (a3)
  {
    uint64_t v7 = this;
    CFStringRef v8 = a2;
    CFDataRef v9 = a3;
  }
  else
  {
    CFDataRef v9 = (const void *)*MEMORY[0x1E4F1CFC8];
    uint64_t v7 = this;
    CFStringRef v8 = a2;
  }
  HostBase::setInfoLocked(v7, v8, v9);
  dispatch_group_leave(*((dispatch_group_t *)this + 19));
  if (*((void *)this + 13))
  {
    CFMutableDictionaryRef Mutable = (__CFArray *)*((void *)this + 20);
    if (!Mutable)
    {
      CFAllocatorRef v11 = CFGetAllocator(v6);
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v11, 0, MEMORY[0x1E4F1D510]);
      *((void *)this + 20) = Mutable;
      if (Mutable)
      {
        CFRetain(v6);
        CFMutableDictionaryRef Mutable = (__CFArray *)*((void *)this + 20);
      }
    }
    CFArrayAppendValue(Mutable, a2);
    if (*((void *)this + 21)) {
      DispatchHost::signalKickerLocked(this);
    }
  }

  HostBase::unlock(this);
}

NSObject *DispatchHost::createAndEnqueuePortSource(dispatch_queue_t *this, uintptr_t handle)
{
  int v2 = handle;
  id result = dispatch_source_create(MEMORY[0x1E4F14458], handle, 0, this[18]);
  if (result)
  {
    uint64_t v5 = result;
    CFRetain(this - 2);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 3221225472;
    handler[2] = ___ZN12DispatchHost26createAndEnqueuePortSourceEj_block_invoke;
    handler[3] = &unk_1E5258228;
    handler[4] = v5;
    dispatch_source_set_event_handler(v5, handler);
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = ___ZN12DispatchHost26createAndEnqueuePortSourceEj_block_invoke_2;
    v6[3] = &unk_1E5257280;
    int v7 = v2;
    void v6[4] = v5;
    void v6[5] = this;
    dispatch_source_set_cancel_handler(v5, v6);
    dispatch_resume(v5);
    return 1;
  }
  return result;
}

void ___ZN12DispatchHost26createAndEnqueuePortSourceEj_block_invoke(uint64_t a1)
{
}

void ___ZN12DispatchHost26createAndEnqueuePortSourceEj_block_invoke_2(uint64_t a1)
{
  mach_msg_return_t v6;
  uint64_t vars8;

  uint64_t v2 = *(void *)(a1 + 40);
  mach_port_name_t v3 = *(_DWORD *)(a1 + 48);
  for (mach_msg_size_t i = 0x2000; ; i *= 2)
  {
    uint64_t v5 = (mach_msg_header_t *)malloc_type_malloc(i, 0xA283135AuLL);
    uint64_t v6 = mach_msg(v5, 67108870, i, i, v3, 0, 0);
    if (v6 != 268451844) {
      break;
    }
    free(v5);
  }
  if (!v6) {
    getaddrinfo_async_handle_reply();
  }
  free(v5);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));

  CFRelease((CFTypeRef)(v2 - 16));
}

CFIndex HostBase::unscheduleFromRunLoop(HostBase *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  CFIndex v6 = _SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 15), a2, a3);
  HostBase::unlock(this);
  return v6;
}

void HostBase::unlock(HostBase *this)
{
  uint64_t v2 = *((void *)this + 2) - 1;
  *((void *)this + 2) = v2;
  if (v2)
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 32));
  }
  else
  {
    CFArrayRef v3 = (const __CFArray *)*((void *)this + 14);
    *((void *)this + 14) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 32));
    if (v3)
    {
      CFIndex Count = CFArrayGetCount(v3);
      if (Count >= 1)
      {
        CFIndex v5 = Count;
        for (CFIndex i = 0; i != v5; ++i)
        {
          CFDictionaryRef ValueAtIndex = (void (**)(void))CFArrayGetValueAtIndex(v3, i);
          ValueAtIndex[2]();
        }
      }
      CFRelease(v3);
    }
  }

  CFRelease((char *)this - 16);
}

uint64_t HostBase::scheduleWithRunLoop(HostBase *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  uint64_t v6 = _SchedulesAddRunLoopAndMode(*((const __CFArray **)this + 15), a2, a3);
  HostBase::unlock(this);
  return v6;
}

void HostBase::cancelInfoResolution(HostBase *this, const __CFString *a2)
{
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  HostBase::setInfoLocked(this, a2, (const void *)*MEMORY[0x1E4F1CFC8]);

  HostBase::unlock(this);
}

void HostBase::setInfoLocked(HostBase *this, const __CFString *a2, const void *a3)
{
  if (!CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2))
  {
    uint64_t v6 = (__CFDictionary *)*((void *)this + 12);
    CFDictionarySetValue(v6, a2, a3);
  }
}

void HostBase::HostBase(HostBase *this, const HostBase *a2)
{
  *(void *)this = &unk_1ECFA5A90;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA5B00;
  CFAllocatorRef v4 = (void *)((char *)this + 24);
  _CoreLockable::_CoreLockable((HostBase *)((char *)this + 24), 1);
  void *v4 = &unk_1ECF9B530;
  if (a2)
  {
    CFRetain((char *)a2 - 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 32));
    ++*((void *)a2 + 2);
    CFAllocatorRef v5 = CFGetAllocator((char *)this - 16);
    *((void *)this + 12) = CFDictionaryCreateMutableCopy(v5, 0, *((CFDictionaryRef *)a2 + 12));
    CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
    *((void *)this + 15) = CFArrayCreateMutableCopy(v6, 0, *((CFArrayRef *)a2 + 15));
    HostBase::unlock(a2);
  }
  else
  {
    CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
    *((void *)this + 12) = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
    *((void *)this + 15) = CFArrayCreateMutable(v8, 0, MEMORY[0x1E4F1D510]);
  }
  *((void *)this + CFRetain((char *)this - 16) = 0;
}

void sub_1842B676C(_Unwind_Exception *exception_object)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(exception_object);
}

void HostBase::~HostBase(HostBase *this)
{
  *(void *)this = &unk_1ECFA5A90;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA5B00;
  uint64_t v2 = *((void *)this + 13);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
    *((void *)this + 13) = 0;
  }
  CFArrayRef v3 = (const void *)*((void *)this + 12);
  if (v3) {
    CFRelease(v3);
  }
  CFAllocatorRef v4 = (const void *)*((void *)this + 16);
  if (v4) {
    CFRelease(v4);
  }
  CFAllocatorRef v5 = (const void *)*((void *)this + 15);
  if (v5) {
    CFRelease(v5);
  }
  CFAllocatorRef v6 = (const void *)*((void *)this + 14);
  if (v6) {
    CFRelease(v6);
  }
  *((void *)this + 3) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9B550;
}

void sub_1842B68CC(_Unwind_Exception *a1)
{
  *(void *)(v1 + CFRelease((char *)this - 24) = &unk_1ECF9C6A8;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 32));
  *(void *)(v1 + 8) = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void HostBase::setInfoLocked(HostBase *this, char *a2)
{
  CFAllocatorRef v8 = a2;
  CFDataRef v9 = (const __CFString **)a2;
  unint64_t v3 = -1;
  do
  {
    CFAllocatorRef v4 = v8;
    v8 += 8;
    ++v3;
  }
  while (*(void *)v4);
  if (v3 >= 2)
  {
    unint64_t v5 = (v3 >> 1) + 1;
    do
    {
      CFAllocatorRef v6 = v9;
      CFStringRef v7 = *v9;
      v9 += 2;
      HostBase::setInfoLocked(this, v7, v6[1]);
      --v5;
    }
    while (v5 > 1);
  }
}

void HostBase::invokeCallback(HostBase *this, const __CFString *a2)
{
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  ++*((void *)this + 2);
  uint64_t v4 = *((void *)this + 13);
  if (v4)
  {
    (*(void (**)(void))(*(void *)v4 + 24))(*((void *)this + 13));
    CFNumberRef Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 12), a2);
    CFTypeRef v6 = Value;
    if (Value)
    {
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFErrorGetTypeID()) {
        CFTypeRef v6 = CFRetain(v6);
      }
      else {
        CFTypeRef v6 = 0;
      }
    }
    HostBase::unlock(this);
    (*(void (**)(uint64_t, HostBase *, const __CFString *, CFTypeRef))(*(void *)v4 + 16))(v4, this, a2, v6);
    if (v6) {
      CFRelease(v6);
    }
    CFAllocatorRef v8 = *(void (**)(uint64_t))(*(void *)v4 + 32);
    v8(v4);
  }
  else
  {
    HostBase::unlock(this);
  }
}

uint64_t HostBase::setDelegate(HostBase *a1, uint64_t a2)
{
  CFRetain((char *)a1 - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 32));
  ++*((void *)a1 + 2);
  uint64_t v4 = *((void *)a1 + 13);
  if (v4 == a2)
  {
    uint64_t v6 = 0;
  }
  else
  {
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
    }
    *((void *)a1 + 13) = a2;
    if (a2)
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 24))(a2);
      uint64_t v5 = 1;
    }
    else
    {
      uint64_t v5 = 0;
    }
    (*(void (**)(HostBase *, uint64_t))(*(void *)a1 + 88))(a1, v5);
    uint64_t v6 = 1;
  }
  HostBase::unlock(a1);
  return v6;
}

void StubHostDelegate::StubHostDelegate(StubHostDelegate *this, const __CFAllocator *a2, CFHostClientContext *a3)
{
  *(void *)this = &unk_1ECF9DF00;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = a2;
  *((void *)this + 2) = &unk_1ECF9DF30;
  uint64_t v4 = (char *)this + 24;
  *((void *)this + 8) = 0;
  *((void *)this + 10) = 1;
  CFAllocatorCopyDescriptionCallBack copyDescription = a3->copyDescription;
  long long v6 = *(_OWORD *)&a3->retain;
  *(_OWORD *)((char *)this + CFRelease((char *)this - 24) = *(_OWORD *)&a3->version;
  *((void *)this + 7) = copyDescription;
  *(_OWORD *)((char *)this + 40) = v6;
  if (*((void *)this + 4))
  {
    CFTypeID v7 = (uint64_t (*)(void))*((void *)this + 5);
    if (v7) {
      *((void *)this + 4) = v7();
    }
  }
  *((void *)this + 8) = v4;
  *((void *)this + 9) = v4;
}

uint64_t non-virtual thunk to'StubHostDelegate::hostDelegateRelease(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 64) - 1;
  *(void *)(this + 64) = v1;
  if (!v1) {
    return (*(uint64_t (**)(void))(*(void *)(this - 16) + 8))();
  }
  return this;
}

uint64_t non-virtual thunk to'StubHostDelegate::hostDelegateRetain(uint64_t this)
{
  return this;
}

uint64_t non-virtual thunk to'ClassicHostDelegate::hostInfoCallback(ClassicHostDelegate *this, HostBase *a2, const __CFString *a3, __CFError *a4)
{
  return ClassicHostDelegate::hostInfoCallback((ClassicHostDelegate *)((char *)this - 16), a2, a3, a4);
}

uint64_t ClassicHostDelegate::hostInfoCallback(ClassicHostDelegate *this, HostBase *a2, const __CFString *a3, __CFError *a4)
{
  v14[0] = _CFStreamErrorFromCFError(a4);
  v14[1] = v7;
  CFAllocatorRef v8 = (uint64_t (*)(char *, uint64_t, void *, void))*((void *)this + 11);
  int ExactString = _findExactString(a3, 0xAu);
  if (ExactString == 495032866) {
    int v10 = 1;
  }
  else {
    int v10 = -1;
  }
  if (ExactString == 496138793) {
    unsigned int v11 = 2;
  }
  else {
    unsigned int v11 = v10;
  }
  if (ExactString == 494017049) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v11;
  }
  return v8((char *)a2 - 16, v12, v14, *(void *)(*((void *)this + 9) + 8));
}

void non-virtual thunk to'ClassicHostDelegate::~ClassicHostDelegate(ClassicHostDelegate *this)
{
  uint64_t v2 = (char *)this - 16;
  StubHostDelegate::~StubHostDelegate((ClassicHostDelegate *)((char *)this - 16));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  StubHostDelegate::~StubHostDelegate((ClassicHostDelegate *)((char *)this - 16));
}

void StubHostDelegate::~StubHostDelegate(StubHostDelegate *this)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ECF9DF00;
  *((void *)this + 2) = &unk_1ECF9DF30;
  if (!*((void *)this + 8) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    int v3 = 136315138;
    uint64_t v4 = "T *ClientContextHolderInfo<CFHostClientContext>::forget() [T = CFHostClientContext]";
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "%s called before remember", (uint8_t *)&v3, 0xCu);
  }
  if (*((void *)this + 4))
  {
    uint64_t v2 = (void (*)(void))*((void *)this + 6);
    if (v2) {
      v2();
    }
  }
  *((void *)this + 9) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + CFRelease((char *)this - 24) = 0u;
}

void *StubHostDelegate::hostDelegateRelease(void *this)
{
  uint64_t v1 = this[10] - 1;
  this[10] = v1;
  if (this)
  {
    if (!v1) {
      return (void *)(*(uint64_t (**)(void))(*this + 8))();
    }
  }
  return this;
}

uint64_t StubHostDelegate::hostDelegateRetain(uint64_t this)
{
  return this;
}

void ClassicHostDelegate::~ClassicHostDelegate(ClassicHostDelegate *this)
{
  StubHostDelegate::~StubHostDelegate(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

uint64_t non-virtual thunk to'NewerHostDelegate::hostInfoCallback(NewerHostDelegate *this, HostBase *a2, const __CFString *a3, __CFError *a4)
{
  return (*((uint64_t (**)(char *, const __CFString *, __CFError *, void))this + 9))((char *)a2 - 16, a3, a4, *(void *)(*((void *)this + 7) + 8));
}

void non-virtual thunk to'NewerHostDelegate::~NewerHostDelegate(NewerHostDelegate *this)
{
  uint64_t v2 = (char *)this - 16;
  StubHostDelegate::~StubHostDelegate((NewerHostDelegate *)((char *)this - 16));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 1);

  CFAllocatorDeallocate(v3, v2);
}

{
  StubHostDelegate::~StubHostDelegate((NewerHostDelegate *)((char *)this - 16));
}

uint64_t NewerHostDelegate::hostInfoCallback(NewerHostDelegate *this, HostBase *a2, const __CFString *a3, __CFError *a4)
{
  return (*((uint64_t (**)(char *, const __CFString *, __CFError *, void))this + 11))((char *)a2 - 16, a3, a4, *(void *)(*((void *)this + 9) + 8));
}

void NewerHostDelegate::~NewerHostDelegate(NewerHostDelegate *this)
{
  StubHostDelegate::~StubHostDelegate(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void HostBase::deferredUntilUnlocked(uint64_t a1, void *value)
{
  uint64_t v4 = *(__CFArray **)(a1 + 112);
  if (!v4)
  {
    CFArrayCallBacks v6 = *(CFArrayCallBacks *)byte_1ECFACBC8;
    CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)(a1 - 16));
    uint64_t v4 = CFArrayCreateMutable(v5, 0, &v6);
    *(void *)(a1 + 112) = v4;
  }
  CFArrayAppendValue(v4, value);
}

void _release_block(const __CFAllocator *a1, const void *aBlock)
{
}

void *_retain_block(const __CFAllocator *a1, const void *aBlock)
{
  return _Block_copy(aBlock);
}

void sub_1842B72C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

void sub_1842B77BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  ((void (*)(char *))a15)(&a13);
  CFAllocatorRef v67 = (uint64_t *)STACK[0x2C8];
  if (STACK[0x2C8] && v67 != &a66) {
    free(v67);
  }
  ((void (*)(char *))a20)(&a18);
  STACK[0x430] = a10;
  CFAllocatorRef v68 = (unint64_t *)STACK[0x548];
  if (STACK[0x548]) {
    BOOL v69 = v68 == &STACK[0x448];
  }
  else {
    BOOL v69 = 1;
  }
  if (!v69) {
    free(v68);
  }
  STACK[0x570] = a11;
  if (STACK[0x688] != a12) {
    free((void *)STACK[0x688]);
  }
  _Unwind_Resume(a1);
}

void sub_1842B7CF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void sub_1842B7FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1842B8220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1842B8CC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HTTPCookieStoragePolicy::~HTTPCookieStoragePolicy((HTTPCookieStoragePolicy *)va);
  _Unwind_Resume(a1);
}

void sub_1842B8F6C(_Unwind_Exception *exception_object)
{
  if (v1) {
    pthread_mutex_unlock((pthread_mutex_t *)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

void __logHARRequestBody_block_invoke(uint64_t a1)
{
  uint64_t v2 = [(id)HARRequestBody objectForKeyedSubscript:*(void *)(a1 + 32)];
  if (!v2)
  {
    uint64_t v4 = *(id *)(a1 + 40);
    goto LABEL_5;
  }
  data1 = v2;
  if (dispatch_data_get_size(v2) < HARBodySizeLimit)
  {
    dispatch_data_t concat = dispatch_data_create_concat(data1, *(dispatch_data_t *)(a1 + 40));

    uint64_t v4 = concat;
LABEL_5:
    data1a = v4;
    if (dispatch_data_get_size(v4) <= HARBodySizeLimit)
    {
      CFArrayCallBacks v6 = data1a;
    }
    else
    {
      dispatch_data_t subrange = dispatch_data_create_subrange(data1a, 0, HARBodySizeLimit);

      CFArrayCallBacks v6 = subrange;
    }
    data1 = v6;
    objc_msgSend((id)HARRequestBody, "setObject:forKeyedSubscript:");
  }
}

void sub_1842B9A58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t checkEntitlementForHARLogging(const __CFString *a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = SecTaskCreateFromSelf((CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  CFAllocatorRef v3 = v2;
  uint64_t v4 = (void *)MEMORY[0x1E4F1CC28];
  if (v2) {
    uint64_t v4 = (void *)SecTaskCopyValueForEntitlement(v2, a1, 0);
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFAllocatorRef v5 = (id)CFNLog::logger;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 138412546;
    CFStringRef v9 = a1;
    __int16 v10 = 1024;
    int v11 = [v4 BOOLValue];
    _os_log_impl(&dword_184085000, v5, OS_LOG_TYPE_DEFAULT, "Entitled for HAR logging %@ = %d", (uint8_t *)&v8, 0x12u);
  }

  if (v3) {
    CFRelease(v3);
  }
  uint64_t v6 = [v4 BOOLValue];

  return v6;
}

void sub_1842B9BB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL17readHARPreferencev_block_invoke_2()
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v0 = (id)CFNLog::logger;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFAllocatorRef v3 = 0;
    _os_log_impl(&dword_184085000, v0, OS_LOG_TYPE_DEFAULT, "Stopping HAR logging", v3, 2u);
  }

  HAREnabled = 0;
  [(id)HARRequestBody removeAllObjects];
  [(id)HARResponseBody removeAllObjects];
  uint64_t v1 = (void *)HARPathDenialList;
  HARPathDenialList = 0;

  uint64_t v2 = (void *)HARHostDenialList;
  HARHostDenialList = 0;
}

void ___ZL13initializeHARv_block_invoke()
{
  uint64_t v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v1 = dispatch_queue_create("com.apple.CFNetwork.HARLogging", v0);
  uint64_t v2 = (void *)HARQueue;
  HARQueue = (uint64_t)v1;

  os_log_t v3 = os_log_create("com.apple.CFNetwork", "HAR");
  uint64_t v4 = (void *)HARLog;
  HARLog = (uint64_t)v3;

  id v5 = objc_alloc_init(MEMORY[0x1E4F28C10]);
  uint64_t v6 = (void *)HARDateFormatter;
  HARDateFormatter = (uint64_t)v5;

  uint64_t v7 = [MEMORY[0x1E4F1CA20] localeWithLocaleIdentifier:@"en_US_POSIX"];
  [(id)HARDateFormatter setLocale:v7];

  [(id)HARDateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ss.SSSXXXXX"];
  uint64_t v8 = [MEMORY[0x1E4F1CA60] dictionary];
  CFStringRef v9 = (void *)HARRequestBody;
  HARRequestBody = v8;

  uint64_t v10 = [MEMORY[0x1E4F1CA60] dictionary];
  int v11 = (void *)HARResponseBody;
  HARResponseBody = v10;
}

void sub_1842B9DC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL43registerForDiagnosticExtensionNotificationsv_block_invoke()
{
  uint64_t v0 = (void *)MEMORY[0x18531D6D0]();
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  dispatch_queue_t v1 = (id)CFNLog::logger;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_debug_impl(&dword_184085000, v1, OS_LOG_TYPE_DEBUG, "Got a notification for com.apple.CFNetwork.har-capture-update", v2, 2u);
  }

  readHARPreference();
}

void __logHARResponseBody_block_invoke(uint64_t a1)
{
  uint64_t v2 = [(id)HARResponseBody objectForKeyedSubscript:*(void *)(a1 + 32)];
  if (!v2)
  {
    uint64_t v4 = *(id *)(a1 + 40);
    goto LABEL_5;
  }
  data1 = v2;
  if (dispatch_data_get_size(v2) < HARBodySizeLimit)
  {
    dispatch_data_t concat = dispatch_data_create_concat(data1, *(dispatch_data_t *)(a1 + 40));

    uint64_t v4 = concat;
LABEL_5:
    data1a = v4;
    if (dispatch_data_get_size(v4) <= HARBodySizeLimit)
    {
      uint64_t v6 = data1a;
    }
    else
    {
      dispatch_data_t subrange = dispatch_data_create_subrange(data1a, 0, HARBodySizeLimit);

      uint64_t v6 = subrange;
    }
    data1 = v6;
    objc_msgSend((id)HARResponseBody, "setObject:forKeyedSubscript:");
  }
}

void sub_1842B9F68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t __clearCachedHARResponseBody_block_invoke(uint64_t a1)
{
  return [(id)HARResponseBody setObject:0 forKeyedSubscript:*(void *)(a1 + 32)];
}

void __logHAREntry_block_invoke(uint64_t a1, const char *a2)
{
  buffer_ptr._localEndpoint = (OS_nw_endpoint *)*MEMORY[0x1E4F143B8];
  id Property = *(id *)(a1 + 32);
  if (Property) {
    id Property = objc_getProperty(Property, a2, 88, 1);
  }
  v235 = (id *)Property;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3 && (id v4 = *(id *)(v3 + 64)) != 0)
  {
    id v5 = v4;
    uint64_t v6 = v5;
  }
  else
  {
    uint64_t v7 = *(void **)(a1 + 32);
    if (v7) {
      uint64_t v7 = (void *)v7[7];
    }
    uint64_t v6 = v7;

    id v5 = 0;
  }

  uint64_t v8 = v6;
  CFStringRef v9 = v8;
  v236 = v8;
  if (__PAIR128__(HARHostDenialList, HARPathDenialList) != 0)
  {
    uint64_t v10 = [v8 URL];
    int v11 = [v10 path];

    uint64_t v12 = [v9 URL];
    CFArrayRef v13 = [v12 host];

    long long v256 = 0u;
    long long v257 = 0u;
    long long v254 = 0u;
    long long v255 = 0u;
    id v14 = (id)HARPathDenialList;
    uint64_t v15 = [v14 countByEnumeratingWithState:&v254 objects:&buffer_ptr count:16];
    if (v15)
    {
      uint64_t v16 = *(void *)v255;
      do
      {
        for (uint64_t i = 0; i != v15; ++i)
        {
          if (*(void *)v255 != v16) {
            objc_enumerationMutation(v14);
          }
          if ([v11 containsString:*(void *)(*((void *)&v254 + 1) + 8 * i)])
          {
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
            }
            int v51 = (id)CFNLog::logger;
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              v285 = v9;
              int v52 = "Path contains denial list entry for request {%@}";
              goto LABEL_73;
            }
LABEL_74:

            int64_t v56 = (void *)HARRequestBody;
            int v57 = *(void **)(a1 + 32);
            if (v57) {
              int v57 = (void *)v57[6];
            }
            int v58 = v57;
            [v56 setObject:0 forKeyedSubscript:v58];

            uint64_t v59 = (void *)HARResponseBody;
            unsigned int v60 = *(void **)(a1 + 32);
            if (v60) {
              unsigned int v60 = (void *)v60[6];
            }
            CFStringRef v21 = v60;
            [v59 setObject:0 forKeyedSubscript:v21];
            goto LABEL_281;
          }
        }
        uint64_t v15 = [v14 countByEnumeratingWithState:&v254 objects:&buffer_ptr count:16];
      }
      while (v15);
    }

    long long v252 = 0u;
    long long v253 = 0u;
    long long v250 = 0u;
    long long v251 = 0u;
    id v14 = (id)HARHostDenialList;
    uint64_t v18 = [v14 countByEnumeratingWithState:&v250 objects:&size_ptr count:16];
    if (!v18) {
      goto LABEL_26;
    }
    uint64_t v19 = *(void *)v251;
    while (1)
    {
      for (uint64_t j = 0; j != v18; ++j)
      {
        if (*(void *)v251 != v19) {
          objc_enumerationMutation(v14);
        }
        if ([v13 containsString:*(void *)(*((void *)&v250 + 1) + 8 * j)])
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
          }
          int v51 = (id)CFNLog::logger;
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v285 = v236;
            int v52 = "Host contains denial list entry for request {%@}";
LABEL_73:
            _os_log_impl(&dword_184085000, v51, OS_LOG_TYPE_DEFAULT, v52, buf, 0xCu);
          }
          goto LABEL_74;
        }
      }
      uint64_t v18 = [v14 countByEnumeratingWithState:&v250 objects:&size_ptr count:16];
      if (!v18)
      {
LABEL_26:

        CFStringRef v9 = v236;
        goto LABEL_28;
      }
    }
  }

LABEL_28:
  v212 = [v9 allHTTPHeaderFields];
  v241 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v212, "count"));
  long long v248 = 0u;
  long long v249 = 0u;
  long long v246 = 0u;
  long long v247 = 0u;
  CFStringRef v21 = v212;
  uint64_t v22 = [v21 countByEnumeratingWithState:&v246 objects:v280 count:16];
  if (v22)
  {
    uint64_t v23 = *(void *)v247;
    do
    {
      for (uint64_t k = 0; k != v22; ++k)
      {
        if (*(void *)v247 != v23) {
          objc_enumerationMutation(v21);
        }
        v279[0] = *(void *)(*((void *)&v246 + 1) + 8 * k);
        v278[0] = @"name";
        v278[1] = @"value";
        CFTypeID v25 = objc_msgSend(v21, "objectForKeyedSubscript:");
        v279[1] = v25;
        uint64_t v26 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v279 forKeys:v278 count:2];
        [v241 addObject:v26];
      }
      uint64_t v22 = [v21 countByEnumeratingWithState:&v246 objects:v280 count:16];
    }
    while (v22);
  }

  if (v236 && (char v27 = CFURLRequestCopyHTTPRequest(v236), (v28 = v27) != 0))
  {
    v230 = (__CFString *)CFHTTPMessageCopyVersion(v27);
    CFRelease(v28);
  }
  else
  {
    v230 = 0;
  }
  v237 = [MEMORY[0x1E4F1CA60] dictionaryWithCapacity:9];
  uint64_t v29 = [v236 HTTPMethod];
  CFIndex v30 = (void *)v29;
  if (v29) {
    uint64_t v31 = (__CFString *)v29;
  }
  else {
    uint64_t v31 = @"GET";
  }
  [v237 setObject:v31 forKeyedSubscript:@"method"];

  CFStringRef v32 = [v236 URL];
  uint64_t v33 = [v32 absoluteString];
  id v34 = (void *)v33;
  if (v33) {
    uint64_t v35 = (__CFString *)v33;
  }
  else {
    uint64_t v35 = &stru_1ECFAD558;
  }
  [v237 setObject:v35 forKeyedSubscript:@"url"];

  if (v230) {
    uint64_t v36 = v230;
  }
  else {
    uint64_t v36 = &stru_1ECFAD558;
  }
  [v237 setObject:v36 forKeyedSubscript:@"httpVersion"];
  [v237 setObject:MEMORY[0x1E4F1CBF0] forKeyedSubscript:@"cookies"];
  [v237 setObject:v241 forKeyedSubscript:@"headers"];
  [v237 setObject:MEMORY[0x1E4F1CBF0] forKeyedSubscript:@"queryString"];
  uint64_t v37 = *(void *)(a1 + 32);
  if (v37) {
    uint64_t v38 = *(void *)(v37 + 96);
  }
  else {
    uint64_t v38 = 0;
  }
  uint64_t v39 = [NSNumber numberWithLongLong:v38];
  [v237 setObject:v39 forKeyedSubscript:@"headersSize"];

  uint64_t v40 = *(void *)(a1 + 32);
  if (v40) {
    uint64_t v41 = *(void *)(v40 + 112);
  }
  else {
    uint64_t v41 = 0;
  }
  BOOL v42 = [NSNumber numberWithLongLong:v41];
  [v237 setObject:v42 forKeyedSubscript:@"bodySize"];

  uint64_t v43 = (void *)HARRequestBody;
  uint64_t v44 = *(void **)(a1 + 32);
  if (v44) {
    uint64_t v44 = (void *)v44[6];
  }
  uint64_t v45 = v44;
  data = [v43 objectForKeyedSubscript:v45];

  if (data)
  {
    uint64_t v46 = [MEMORY[0x1E4F1CA60] dictionaryWithCapacity:2];
    int v47 = [v21 objectForKeyedSubscript:@"Content-Type"];
    int v49 = v47;
    if (v47)
    {
      __darwin_ct_rune_t v50 = (id)URLResponse::copyMIMETypeFromContentHeader(v47, v48);
    }
    else
    {
      __darwin_ct_rune_t v50 = 0;
    }
    if (v50) {
      int v53 = v50;
    }
    else {
      int v53 = @"application/octet-stream";
    }
    [v46 setObject:v53 forKeyedSubscript:@"mimeType"];
    buffer_ptr.super.Class isa = 0;
    size_t size_ptr = 0;
    dispatch_data_t v239 = dispatch_data_create_map(data, (const void **)&buffer_ptr.super.isa, &size_ptr);
    if (!size_ptr) {
      goto LABEL_89;
    }
    size_t v54 = size_ptr - 1;
    int v55 = *((char *)buffer_ptr.super.isa + size_ptr - 1);
    if ((v55 & 0x80000000) == 0) {
      goto LABEL_89;
    }
    if ((v55 + 62) > 0x32u)
    {
      if (*((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) > 0xBFu) {
        goto LABEL_89;
      }
      size_t v54 = size_ptr - 2;
      unint64_t v61 = *((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 2);
      if ((v61 + 32) > 0x14u)
      {
        if ((char)v61 > -65
          || (size_t v54 = size_ptr - 3, v64 = *((unsigned char *)buffer_ptr.super.isa + size_ptr - 3),
                                  (v64 + 16) > 4u)
          || ((byte_18430C26C[v61 >> 4] >> (v64 & 7)) & 1) == 0)
        {
LABEL_89:
          id v65 = [NSString alloc];
          uint64_t v66 = (void *)[v65 initWithBytes:buffer_ptr.super.isa length:size_ptr encoding:4];
          if (v66)
          {
            [v46 setObject:v66 forKeyedSubscript:@"text"];
          }
          else
          {
            CFAllocatorRef v67 = [data base64EncodedStringWithOptions:0];
            [v46 setObject:v67 forKeyedSubscript:@"_textBase64"];
          }
          [v237 setObject:v46 forKeyedSubscript:@"postData"];
          CFAllocatorRef v68 = (void *)HARRequestBody;
          BOOL v69 = *(void **)(a1 + 32);
          if (v69) {
            BOOL v69 = (void *)v69[6];
          }
          v70 = v69;
          [v68 setObject:0 forKeyedSubscript:v70];

          goto LABEL_95;
        }
      }
      else
      {
        if (v61 > 0xEF)
        {
          v62 = (char *)&byte_18430C26C[(unint64_t)*((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) >> 4];
          LOBYTE(v63) = v61 & 7;
        }
        else
        {
          v62 = &a00000000000000[v61 & 0xF];
          int v63 = *((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) >> 5;
        }
        if (((*v62 >> v63) & 1) == 0) {
          goto LABEL_89;
        }
      }
    }
    size_t size_ptr = v54;
    goto LABEL_89;
  }
LABEL_95:
  uint64_t v71 = *(void **)(a1 + 32);
  if (v71) {
    uint64_t v71 = (void *)v71[10];
  }
  uint64_t v72 = v71;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    if (v72 && [v72 statusCode] != 304) {
      goto LABEL_108;
    }
  }
  else
  {

    uint64_t v72 = 0;
  }
  uint64_t v73 = *(void **)(a1 + 32);
  if (v73) {
    uint64_t v73 = (void *)v73[9];
  }
  int v74 = v73;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    uint64_t v76 = *(void **)(a1 + 32);
    if (v76) {
      uint64_t v76 = (void *)v76[9];
    }
    uint64_t v77 = v76;

    uint64_t v72 = v77;
    BOOL v220 = [v77 statusCode] == 304;
    goto LABEL_109;
  }
LABEL_108:
  BOOL v220 = 0;
LABEL_109:
  [v72 allHeaderFields];
  v211 = v233 = v72;
  v240 = objc_msgSend(MEMORY[0x1E4F1CA48], "arrayWithCapacity:", objc_msgSend(v211, "count"));
  long long v244 = 0u;
  long long v245 = 0u;
  long long v242 = 0u;
  long long v243 = 0u;
  id v78 = v211;
  uint64_t v79 = [v78 countByEnumeratingWithState:&v242 objects:v277 count:16];
  if (v79)
  {
    uint64_t v80 = *(void *)v243;
    do
    {
      for (uint64_t m = 0; m != v79; ++m)
      {
        if (*(void *)v243 != v80) {
          objc_enumerationMutation(v78);
        }
        v276[0] = *(void *)(*((void *)&v242 + 1) + 8 * m);
        v275[0] = @"name";
        v275[1] = @"value";
        v82 = objc_msgSend(v78, "objectForKeyedSubscript:");
        v276[1] = v82;
        uint64_t v83 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v276 forKeys:v275 count:2];
        [v240 addObject:v83];
      }
      uint64_t v79 = [v78 countByEnumeratingWithState:&v242 objects:v277 count:16];
    }
    while (v79);
  }

  v234 = [MEMORY[0x1E4F1CA60] dictionaryWithCapacity:4];
  uint64_t v84 = *(void *)(a1 + 32);
  if (v84) {
    uint64_t v85 = *(void *)(v84 + 128);
  }
  else {
    uint64_t v85 = 0;
  }
  uint64_t v86 = [NSNumber numberWithLongLong:v85];
  [v234 setObject:v86 forKeyedSubscript:@"size"];

  uint64_t v87 = [v233 MIMEType];
  v88 = (void *)v87;
  if (v87) {
    uint64_t v89 = (__CFString *)v87;
  }
  else {
    uint64_t v89 = @"application/octet-stream";
  }
  [v234 setObject:v89 forKeyedSubscript:@"mimeType"];

  uint64_t v90 = (void *)HARResponseBody;
  uint64_t v91 = *(void **)(a1 + 32);
  if (v91) {
    uint64_t v91 = (void *)v91[6];
  }
  CFErrorRef v92 = v91;
  v231 = [v90 objectForKeyedSubscript:v92];

  if (!v231) {
    goto LABEL_144;
  }
  buffer_ptr.super.Class isa = 0;
  size_t size_ptr = 0;
  dispatch_data_t v93 = dispatch_data_create_map(v231, (const void **)&buffer_ptr.super.isa, &size_ptr);
  if (size_ptr)
  {
    size_t v94 = size_ptr - 1;
    int v95 = *((char *)buffer_ptr.super.isa + size_ptr - 1);
    if (v95 < 0)
    {
      if ((v95 + 62) <= 0x32u) {
        goto LABEL_127;
      }
      if (*((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) > 0xBFu) {
        goto LABEL_138;
      }
      size_t v94 = size_ptr - 2;
      unint64_t v96 = *((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 2);
      if ((v96 + 32) <= 0x14u)
      {
        if (v96 > 0xEF)
        {
          unsigned int v97 = (char *)&byte_18430C26C[(unint64_t)*((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) >> 4];
          LOBYTE(v98) = v96 & 7;
        }
        else
        {
          unsigned int v97 = &a00000000000000[v96 & 0xF];
          int v98 = *((unsigned __int8 *)buffer_ptr.super.isa + size_ptr - 1) >> 5;
        }
        if (((*v97 >> v98) & 1) == 0) {
          goto LABEL_138;
        }
        goto LABEL_127;
      }
      if ((char)v96 <= -65)
      {
        size_t v94 = size_ptr - 3;
        char v99 = *((unsigned char *)buffer_ptr.super.isa + size_ptr - 3);
        if (v99 + 16) <= 4u && ((byte_18430C26C[v96 >> 4] >> (v99 & 7))) {
LABEL_127:
        }
          size_t size_ptr = v94;
      }
    }
  }
LABEL_138:
  id v100 = [NSString alloc];
  uint64_t v101 = [v100 initWithBytes:buffer_ptr.super.isa length:size_ptr encoding:4];
  v102 = (void *)v101;
  if (v101)
  {
    unsigned int v103 = @"text";
    BOOL v104 = (__CFString *)v101;
  }
  else
  {
    CFErrorRef v105 = [v231 base64EncodedStringWithOptions:0];
    [v234 setObject:v105 forKeyedSubscript:@"text"];

    unsigned int v103 = @"encoding";
    BOOL v104 = @"base64";
  }
  [v234 setObject:v104 forKeyedSubscript:v103];
  v106 = (void *)HARResponseBody;
  unsigned int v107 = *(void **)(a1 + 32);
  if (v107) {
    unsigned int v107 = (void *)v107[6];
  }
  v108 = v107;
  [v106 setObject:0 forKeyedSubscript:v108];

LABEL_144:
  if (!v233
    || ((uint64_t v109 = *(void *)([v233 _inner] + 88)) != 0
      ? (v110 = (__CFHTTPMessage *)(v109 - 16))
      : (v110 = 0),
        !v109))
  {
    v228 = 0;
    v229 = 0;
    goto LABEL_159;
  }
  CFIndex v111 = (id) CFHTTPMessageCopyResponseStatusLine(v110);
  uint64_t v112 = [(__CFString *)v111 UTF8String];
  uint64_t v113 = 0;
  uint64_t v114 = 0;
  while (*(unsigned char *)(v112 + v113) != 32)
  {
    if (!*(unsigned char *)(v112 + v113)) {
      goto LABEL_158;
    }
LABEL_155:
    ++v113;
  }
  if (v114 != 1)
  {
    uint64_t v114 = 1;
    goto LABEL_155;
  }
  ++v113;
LABEL_158:
  uint64_t v115 = [NSString stringWithUTF8String:v112 + v113];
  v229 = (__CFString *)CFHTTPMessageCopyVersion(v110);
  v228 = (__CFString *)v115;

LABEL_159:
  v273[0] = @"status";
  uint64_t v116 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(v233, "statusCode"));
  uint64_t v117 = (void *)v116;
  v118 = v228;
  if (!v228) {
    v118 = &stru_1ECFAD558;
  }
  v274[0] = v116;
  v274[1] = v118;
  v273[1] = @"statusText";
  v273[2] = @"httpVersion";
  v119 = v229;
  if (!v229) {
    v119 = &stru_1ECFAD558;
  }
  v274[2] = v119;
  v274[3] = MEMORY[0x1E4F1CBF0];
  v273[3] = @"cookies";
  v273[4] = @"headers";
  v274[4] = v240;
  v274[5] = v234;
  v273[5] = @"content";
  v273[6] = @"redirectURL";
  uint64_t v120 = [v78 objectForKeyedSubscript:@"Location"];
  uint64_t v121 = (void *)v120;
  if (v120) {
    uint64_t v122 = (__CFString *)v120;
  }
  else {
    uint64_t v122 = &stru_1ECFAD558;
  }
  v274[6] = v122;
  v273[7] = @"headersSize";
  uint64_t v123 = *(void *)(a1 + 32);
  if (v123) {
    uint64_t v124 = *(void *)(v123 + 120);
  }
  else {
    uint64_t v124 = 0;
  }
  v125 = [NSNumber numberWithLongLong:v124];
  v274[7] = v125;
  v273[8] = @"bodySize";
  uint64_t v126 = *(void *)(a1 + 32);
  if (v126) {
    uint64_t v127 = *(void *)(v126 + 136);
  }
  else {
    uint64_t v127 = 0;
  }
  v128 = [NSNumber numberWithLongLong:v127];
  v274[8] = v128;
  v227 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v274 forKeys:v273 count:9];

  memset(&buffer_ptr, 0, 32);
  connectionTimingFromMetrics(&buffer_ptr, v235);
  v260[0] = @"blocked";
  uint64_t v129 = *(void *)(a1 + 32);
  Class isa = 0;
  if (v129)
  {
    double v131 = *(double *)(v129 + 144);
    if (*(unsigned char *)(v129 + 9)) {
      Class isa = buffer_ptr.super.isa;
    }
    else {
      Class isa = *(Class *)(v129 + 176);
    }
  }
  else
  {
    double v131 = 0.0;
  }
  uint64_t v132 = HARTimeInterval(v131, *(double *)&isa);
  v133 = (void *)v132;
  uint64_t v266 = v132;
  v260[1] = @"dns";
  uint64_t v134 = *(void *)(a1 + 32);
  if (v134)
  {
    Class v135 = buffer_ptr.super.isa;
    if (*(unsigned char *)(v134 + 9))
    {
      uint64_t v132 = [NSNumber numberWithUnsignedInt:*(unsigned int *)&buffer_ptr._expensive];
      uint64_t v134 = *(void *)(a1 + 32);
      v267 = (void *)v132;
      v261 = @"connect";
      int v136 = 1;
      if (!v134)
      {
        int v224 = 1;
        v222 = (void *)v132;
        goto LABEL_289;
      }
    }
    else
    {
      int v136 = 0;
      v267 = &unk_1ECFD1B90;
      v261 = @"connect";
    }
    v222 = (void *)v132;
    int v224 = v136;
    if (*(unsigned char *)(v134 + 9))
    {
      uint64_t v137 = objc_msgSend(NSNumber, "numberWithUnsignedInt:", *(unsigned int *)&buffer_ptr._isUnlistedTracker, *(double *)&buffer_ptr.connectionLock._os_unfair_lock_opaque);
      uint64_t v134 = *(void *)(a1 + 32);
      v217 = (void *)v137;
      v268 = (void *)v137;
      v262 = @"send";
      int v138 = 1;
      if (!v134)
      {
        double v139 = 0.0;
        goto LABEL_290;
      }
    }
    else
    {
      int v138 = 0;
      v268 = &unk_1ECFD1B90;
      v262 = @"send";
    }
    double v139 = *(double *)(v134 + 176);
    double v140 = *(double *)(v134 + 184);
  }
  else
  {
    int v224 = 0;
    Class v135 = buffer_ptr.super.isa;
    v267 = &unk_1ECFD1B90;
    v261 = @"connect";
LABEL_289:
    int v138 = 0;
    v268 = &unk_1ECFD1B90;
    v262 = @"send";
    double v139 = 0.0;
LABEL_290:
    double v140 = 0.0;
  }
  v141 = HARTimeInterval(v139, v140);
  v269 = v141;
  v263 = @"wait";
  uint64_t v142 = *(void *)(a1 + 32);
  if (v142)
  {
    double v143 = *(double *)(v142 + 184);
    double v144 = *(double *)(v142 + 192);
  }
  else
  {
    double v143 = 0.0;
    double v144 = 0.0;
  }
  v145 = HARTimeInterval(v143, v144);
  v270 = v145;
  v264 = @"receive";
  uint64_t v146 = *(void *)(a1 + 32);
  if (v146)
  {
    double v147 = *(double *)(v146 + 192);
    double v148 = *(double *)(v146 + 200);
  }
  else
  {
    double v147 = 0.0;
    double v148 = 0.0;
  }
  v149 = HARTimeInterval(v147, v148);
  v271 = v149;
  v265 = @"ssl";
  uint64_t v150 = *(void *)(a1 + 32);
  if (v150)
  {
    int v151 = 0;
    v152 = &unk_1ECFD1B90;
    if (*(unsigned char *)(v150 + 9) && LOBYTE(buffer_ptr._negotiatedTLSProtocolVersion))
    {
      v152 = [NSNumber numberWithUnsignedInt:*(unsigned int *)&buffer_ptr._coalesced];
      int v151 = 1;
    }
  }
  else
  {
    int v151 = 0;
    v152 = &unk_1ECFD1B90;
  }
  v272 = v152;
  v226 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v266 forKeys:v260 count:7];
  if (v151) {

  }
  if (v138) {
  if (v224)
  }

  v153 = (double *)*(id *)(a1 + 32);
  id v154 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  if (v153)
  {
    if (*((unsigned char *)v153 + 9))
    {
      LODWORD(v155) = *(_DWORD *)&buffer_ptr._expensive;
      v156 = precisionPreservingInterval(*(double *)&v135, *(double *)&v135 + (double)v155 / 1000.0, v153[18]);
      if (v156) {
        [v154 setObject:v156 forKeyedSubscript:@"dns"];
      }

      if (*((unsigned char *)v153 + 9))
      {
        LODWORD(v157) = *(_DWORD *)&buffer_ptr._isUnlistedTracker;
        v158 = precisionPreservingInterval(*(double *)&buffer_ptr.connectionLock._os_unfair_lock_opaque, *(double *)&buffer_ptr.connectionLock._os_unfair_lock_opaque + (double)v157 / 1000.0, v153[18]);
        if (v158) {
          [v154 setObject:v158 forKeyedSubscript:@"connect"];
        }

        if (*((unsigned char *)v153 + 9) && LOBYTE(buffer_ptr._negotiatedTLSProtocolVersion))
        {
          LODWORD(v160) = *(_DWORD *)&buffer_ptr._coalesced;
          LODWORD(v159) = *(_DWORD *)&buffer_ptr._isUnlistedTracker;
          v161 = precisionPreservingInterval(*(double *)&buffer_ptr.connectionLock._os_unfair_lock_opaque + (double)v159 / 1000.0 - (double)v160 / 1000.0, *(double *)&buffer_ptr.connectionLock._os_unfair_lock_opaque + (double)v159 / 1000.0, v153[18]);
          [v154 setObject:v161 forKeyedSubscript:@"secureConnection"];
        }
      }
    }
    double v162 = v153[20];
    double v163 = v153[21];
    double v164 = v153[18];
  }
  else
  {
    double v163 = 0.0;
    double v162 = 0.0;
    double v164 = 0.0;
  }
  v165 = precisionPreservingInterval(v162, v163, v164);
  if (v165) {
    [v154 setObject:v165 forKeyedSubscript:@"cache"];
  }
  if (v153)
  {
    double v166 = v153[22];
    double v167 = v153[23];
    double v168 = v153[18];
  }
  else
  {
    double v167 = 0.0;
    double v166 = 0.0;
    double v168 = 0.0;
  }
  v169 = precisionPreservingInterval(v166, v167, v168);
  if (v169) {
    [v154 setObject:v169 forKeyedSubscript:@"send"];
  }
  if (v153)
  {
    double v170 = v153[24];
    double v171 = v153[25];
    double v172 = v153[18];
  }
  else
  {
    double v171 = 0.0;
    double v170 = 0.0;
    double v172 = 0.0;
  }
  v173 = precisionPreservingInterval(v170, v171, v172);
  if (v173) {
    [v154 setObject:v173 forKeyedSubscript:@"receive"];
  }
  v225 = [MEMORY[0x1E4F1C9E8] dictionaryWithDictionary:v154];

  if (v235 && (v174 = v235[18]) != 0)
  {
    endpoint = v174;
    if (nw_endpoint_get_type(v174) == nw_endpoint_type_address)
    {
      v175 = nw_endpoint_copy_address_string(endpoint);
      v223 = (__CFString *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v175, 0x600u, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
      goto LABEL_225;
    }
  }
  else
  {
    endpoint = 0;
  }
  v223 = 0;
LABEL_225:
  v258[0] = @"startedDateTime";
  uint64_t v176 = *(void *)(a1 + 32);
  if (v176) {
    double v177 = *(double *)(v176 + 144);
  }
  else {
    double v177 = 0.0;
  }
  v178 = (void *)HARDateFormatter;
  v215 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:v177];
  v214 = objc_msgSend(v178, "stringFromDate:");
  v259[0] = v214;
  v258[1] = @"time";
  uint64_t v179 = *(void *)(a1 + 32);
  if (v179)
  {
    double v180 = *(double *)(v179 + 144);
    double v181 = *(double *)(v179 + 152);
  }
  else
  {
    double v180 = 0.0;
    double v181 = 0.0;
  }
  uint64_t v182 = HARTimeInterval(v180, v181);
  v258[2] = @"request";
  v258[3] = @"response";
  v213 = (void *)v182;
  v259[1] = v182;
  v259[2] = v237;
  v259[3] = v227;
  v259[4] = MEMORY[0x1E4F1CC08];
  v258[4] = @"cache";
  v258[5] = @"timings";
  v259[5] = v226;
  v258[6] = @"_transactionUUID";
  v183 = *(void **)(a1 + 32);
  if (v183) {
    v183 = (void *)v183[6];
  }
  v218 = v183;
  v184 = [v218 UUIDString];
  v185 = v184;
  if (!v184)
  {
    v185 = [MEMORY[0x1E4F1CA98] null];
  }
  v259[6] = v185;
  v258[7] = @"_taskUUID";
  v186 = [*(id *)(a1 + 40) UUIDString];
  v187 = v186;
  if (!v186)
  {
    v187 = [MEMORY[0x1E4F1CA98] null];
  }
  v259[7] = v187;
  v259[8] = v225;
  v258[8] = @"_precisionPreservingTimings";
  v258[9] = @"serverIPAddress";
  v188 = &stru_1ECFAD558;
  if (v223) {
    v188 = v223;
  }
  v259[9] = v188;
  v258[10] = @"connection";
  v189 = v235;
  if (v235) {
    v189 = (id *)v235[9];
  }
  v190 = objc_msgSend(NSString, "stringWithFormat:", @"%llu", v189);
  v259[10] = v190;
  v258[11] = @"_fetchType";
  id v191 = *(id *)(a1 + 32);
  v192 = v191;
  if (v220)
  {
    v193 = @"Revalidated Cache";
    goto LABEL_248;
  }
  if (!v191) {
    goto LABEL_246;
  }
  if (*((unsigned char *)v191 + 10))
  {
    v193 = @"Server Push";
    goto LABEL_248;
  }
  id v194 = *((id *)v191 + 9);
  if (v194 && (BOOL v195 = v192[8] == 0, v194, v195)) {
    v193 = @"Local Cache";
  }
  else {
LABEL_246:
  }
    v193 = @"Network Load";
LABEL_248:

  v259[11] = v193;
  v258[12] = @"_sourceApplicationBundleIdentifier";
  v196 = *(void **)(a1 + 48);
  v197 = v196;
  if (!v196)
  {
    v197 = [MEMORY[0x1E4F1CA98] null];
  }
  v259[12] = v197;
  v221 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v259 forKeys:v258 count:13];
  if (!v196) {

  }
  if (!v186) {
  if (!v184)
  }

  id v219 = [MEMORY[0x1E4F28D90] dataWithJSONObject:v221 options:0 error:0];
  v198 = (unsigned char *)[v219 bytes];
  unint64_t v199 = [v219 length];
  if (v199 >= 0x7801)
  {
    while (2)
    {
      int v200 = (char)v198[30719];
      if ((v200 & 0x80000000) == 0) {
        break;
      }
      if ((v200 + 62) < 0x33u)
      {
        unsigned int v201 = 30719;
        goto LABEL_259;
      }
      if (v198[30719] <= 0xBFu)
      {
        unint64_t v203 = v198[30718];
        if ((v203 + 32) <= 0x14u)
        {
          BOOL v204 = v203 > 0xEF;
          v205 = (char *)&byte_18430C26C[(unint64_t)v198[30719] >> 4];
          char v206 = v203 & 7;
          v207 = &a00000000000000[v203 & 0xF];
          int v208 = v198[30719] >> 5;
          if (v204) {
            LOBYTE(v208) = v206;
          }
          else {
            v205 = v207;
          }
          if ((*v205 >> v208)) {
            unsigned int v201 = 30718;
          }
          else {
            unsigned int v201 = 30720;
          }
LABEL_259:
          v202 = (id)HARLog;
          if (os_log_type_enabled(v202, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(size_ptr) = 68157954;
            HIDWORD(size_ptr) = v201;
            __int16 v282 = 2082;
            v283 = v198;
            _os_log_impl(&dword_184085000, v202, OS_LOG_TYPE_DEFAULT, "<incomplete> %{public,xcode:data}.*s", (uint8_t *)&size_ptr, 0x12u);
          }

          v199 -= v201;
          v198 += v201;
          if (v199 <= 0x7800) {
            goto LABEL_278;
          }
          continue;
        }
        if ((char)v203 <= -65)
        {
          char v209 = v198[30717];
          if ((v209 + 16) <= 4u)
          {
            if ((byte_18430C26C[v203 >> 4] >> (v209 & 7))) {
              unsigned int v201 = 30717;
            }
            else {
              unsigned int v201 = 30720;
            }
            goto LABEL_259;
          }
        }
      }
      break;
    }
    unsigned int v201 = 30720;
    goto LABEL_259;
  }
LABEL_278:
  v210 = (id)HARLog;
  if (os_log_type_enabled(v210, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(size_ptr) = 68157954;
    HIDWORD(size_ptr) = v199;
    __int16 v282 = 2082;
    v283 = v198;
    _os_log_impl(&dword_184085000, v210, OS_LOG_TYPE_DEFAULT, "%{public,xcode:data}.*s", (uint8_t *)&size_ptr, 0x12u);
  }

LABEL_281:
}

void sub_1842BBA8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,uint64_t a33,uint64_t a34,void *a35,void *a36)
{
  _Unwind_Resume(a1);
}

id HARTimeInterval(double a1, double a2)
{
  id v4 = objc_msgSend(NSNumber, "numberWithInt:", (int)((a2 - a1) * 1000.0), v2);
  return v4;
}

id precisionPreservingInterval(double a1, double a2, double a3)
{
  uint64_t v6 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:2];
  uint64_t v7 = [NSNumber numberWithDouble:a1 - a3];
  [v6 setObject:v7 forKeyedSubscript:@"start"];

  uint64_t v8 = [NSNumber numberWithDouble:a2 - a3];
  [v6 setObject:v8 forKeyedSubscript:@"end"];

  CFStringRef v9 = [MEMORY[0x1E4F1C9E8] dictionaryWithDictionary:v6];

  return v9;
}

void sub_1842BC114(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id instrumentsTaskLog(void)
{
  if (instrumentsTaskLog(void)::onceToken != -1) {
    dispatch_once(&instrumentsTaskLog(void)::onceToken, &__block_literal_global_247);
  }
  uint64_t v0 = (void *)instrumentsTaskLog(void)::log;

  return v0;
}

void ___ZL18instrumentsTaskLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.CFNetwork.Instruments", "DynamicStackTracing");
  dispatch_queue_t v1 = (void *)instrumentsTaskLog(void)::log;
  instrumentsTaskLog(void)::log = (uint64_t)v0;
}

id instrumentsTransactionLog(void)
{
  if (instrumentsTransactionLog(void)::onceToken != -1) {
    dispatch_once(&instrumentsTransactionLog(void)::onceToken, &__block_literal_global_295);
  }
  os_log_t v0 = (void *)instrumentsTransactionLog(void)::log;

  return v0;
}

void ___ZL25instrumentsTransactionLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.CFNetwork.Instruments", "HTTP Transactions");
  dispatch_queue_t v1 = (void *)instrumentsTransactionLog(void)::log;
  instrumentsTransactionLog(void)::log = (uint64_t)v0;
}

void ___ZL17emptyJSONDictDatav_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28D90] dataWithJSONObject:MEMORY[0x1E4F1CC08] options:0 error:0];
  dispatch_queue_t v1 = (void *)emptyJSONDictData(void)::data;
  emptyJSONDictData(void)::data = v0;
}

void sub_1842BECA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1842BF04C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  objc_destroyWeak(v10);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void _onqueue_writeStreamEvent(__CFWriteStream *a1, uint64_t a2, void *a3)
{
  id v5 = [a3 workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZL25_onqueue_writeStreamEventP15__CFWriteStreammPv_block_invoke;
  v6[3] = &unk_1E5258250;
  void v6[4] = a3;
  void v6[5] = a2;
  dispatch_async(v5, v6);
}

void ___ZL25_onqueue_writeStreamEventP15__CFWriteStreammPv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void _onqueue_readStreamEvent(__CFReadStream *a1, uint64_t a2, void *a3)
{
  id v5 = [a3 workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZL24_onqueue_readStreamEventP14__CFReadStreammPv_block_invoke;
  v6[3] = &unk_1E5258250;
  void v6[4] = a3;
  void v6[5] = a2;
  dispatch_async(v5, v6);
}

void ___ZL24_onqueue_readStreamEventP14__CFReadStreammPv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1842C0AF8(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  MEMORY[0x18531B6D0](v1, 0x10A1C40B93A1745);
  _Unwind_Resume(a1);
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke_18611()
{
}

void sub_1842C0E04(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'TaskSocketStreamClient::ssPostHandshakesStreamsAvailable(void **this, __CFReadStream *a2, __CFWriteStream *a3)
{
}

void TaskSocketStreamClient::ssPostHandshakesStreamsAvailable(void **this, CFTypeRef cf, CFTypeRef a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN22TaskSocketStreamClient32ssPostHandshakesStreamsAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke;
  v6[3] = &__block_descriptor_48_e34_v16__0____NSCFURLLocalStreamTask_8l;
  void v6[4] = cf;
  void v6[5] = a3;
  TaskSocketStreamClient::withWorkQueue(this[2], (uint64_t)v6);
}

void ___ZN22TaskSocketStreamClient32ssPostHandshakesStreamsAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke(uint64_t a1, uint64_t a2)
{
  -[__NSCFURLLocalStreamTask _onqueue_readStream:writeStreamAvailable:](a2, *(void **)(a1 + 32), *(const void **)(a1 + 40));
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
    CFRelease(v3);
  }
  id v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    CFRelease(v4);
  }
}

void TaskSocketStreamClient::withWorkQueue(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v4 = [v3 workQueue];
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN22TaskSocketStreamClient13withWorkQueueEU13block_pointerFvP24__NSCFURLLocalStreamTaskE_block_invoke;
  v5[3] = &unk_1E5258028;
  v5[4] = v3;
  void v5[5] = a2;
  dispatch_async(v4, v5);
}

void ___ZN22TaskSocketStreamClient13withWorkQueueEU13block_pointerFvP24__NSCFURLLocalStreamTaskE_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  uint64_t v2 = *(void **)(a1 + 32);
}

void non-virtual thunk to'TaskSocketStreamClient::ssPostConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN22TaskSocketStreamClient26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
  v3[3] = &unk_1E5257460;
  v3[4] = a2;
  void v3[5] = a3;
  TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 8), (uint64_t)v3);
}

uint64_t ___ZN22TaskSocketStreamClient26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 40) + 16))();
  }
  return result;
}

void non-virtual thunk to'TaskSocketStreamClient::ssNeedClientCert(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void TaskSocketStreamClient::ssNeedClientCert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 24))
  {
    CFStringRef v6 = *(const __CFString **)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = ___ZN22HTTPProtocolSSLSupport40CreateClientCertChallengeWithHostAndPortEPK10__CFStringlPK9__CFArray_block_invoke;
    v11[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
    v11[4] = a2;
    Challenge = (const void *)createChallenge(7, v6, v5, (uint64_t)v11);
    id v8 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:Challenge sender:0];
    if (Challenge) {
      CFRelease(Challenge);
    }
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    v10[2] = ___ZN22TaskSocketStreamClient16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke;
    v10[3] = &unk_1E5257460;
    v10[4] = v8;
    void v10[5] = a3;
    TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 16), (uint64_t)v10);
  }
  else
  {
    CFStringRef v9 = *(void (**)(uint64_t, void))(a3 + 16);
    v9(a3, 0);
  }
}

uint64_t ___ZN22TaskSocketStreamClient16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke(uint64_t result, void *a2)
{
  if (a2)
  {
    id v4 = *(char **)(result + 32);
    uint64_t v3 = *(void *)(result + 40);
    if ([a2 state] < 2)
    {
      v6[0] = MEMORY[0x1E4F143A8];
      v6[1] = 3221225472;
      v6[2] = __70____NSCFURLLocalStreamTask__onqueue_needClientCert_completionHandler___block_invoke;
      v6[3] = &unk_1E52573F0;
      void v6[4] = a2;
      void v6[5] = v4;
      void v6[6] = v3;
      id result = -[__NSCFURLLocalStreamTask _onqueue_sendSessionChallenge:completionHandler:](a2, v4, v6);
      if ((result & 1) == 0) {
        return (*(uint64_t (**)(uint64_t, void))(v3 + 16))(v3, 0);
      }
    }
    else
    {
      uint64_t v5 = *(uint64_t (**)(uint64_t, void))(v3 + 16);
      return v5(v3, 0);
    }
  }
  return result;
}

void sub_1842C1ACC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)va);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'TaskSocketStreamClient::ssNeedServerTrust(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void TaskSocketStreamClient::ssNeedServerTrust(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 24))
  {
    CFStringRef v6 = *(const __CFString **)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = ___ZN22HTTPProtocolSSLSupport35CreateTrustChallengeWithHostAndPortEPK10__CFStringlP10__SecTrust_block_invoke;
    v11[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
    v11[4] = a2;
    Challenge = (const void *)createChallenge(8, v6, v5, (uint64_t)v11);
    id v8 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:Challenge sender:0];
    if (Challenge) {
      CFRelease(Challenge);
    }
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    v10[2] = ___ZN22TaskSocketStreamClient17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke;
    v10[3] = &unk_1E5257460;
    v10[4] = v8;
    void v10[5] = a3;
    TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 16), (uint64_t)v10);
  }
  else
  {
    CFStringRef v9 = *(void (**)(uint64_t, void))(a3 + 16);
    v9(a3, 0);
  }
}

uint64_t ___ZN22TaskSocketStreamClient17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke(uint64_t result, void *a2)
{
  if (a2)
  {
    id v4 = *(char **)(result + 32);
    uint64_t v3 = *(void *)(result + 40);
    if ([a2 state] < 2)
    {
      v6[0] = MEMORY[0x1E4F143A8];
      v6[1] = 3221225472;
      v6[2] = __71____NSCFURLLocalStreamTask__onqueue_needServerTrust_completionHandler___block_invoke;
      v6[3] = &unk_1E52573F0;
      void v6[4] = a2;
      void v6[5] = v4;
      void v6[6] = v3;
      id result = -[__NSCFURLLocalStreamTask _onqueue_sendSessionChallenge:completionHandler:](a2, v4, v6);
      if ((result & 1) == 0) {
        return (*(uint64_t (**)(uint64_t, void))(v3 + 16))(v3, 0);
      }
    }
    else
    {
      uint64_t v5 = *(uint64_t (**)(uint64_t, void))(v3 + 16);
      return v5(v3, 0);
    }
  }
  return result;
}

void non-virtual thunk to'TaskSocketStreamClient::ssPreConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN22TaskSocketStreamClient25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke;
  v3[3] = &unk_1E5257460;
  v3[4] = a2;
  void v3[5] = a3;
  TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 8), (uint64_t)v3);
}

uint64_t ___ZN22TaskSocketStreamClient25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 40) + 16))();
  }
  return result;
}

void non-virtual thunk to'TaskSocketStreamClient::ceRelease(id *this)
{
}

id non-virtual thunk to'TaskSocketStreamClient::ceRetain(id *this)
{
  return this[1];
}

void non-virtual thunk to'TaskSocketStreamClient::~TaskSocketStreamClient(TaskSocketStreamClient *this)
{
  TaskSocketStreamClient::~TaskSocketStreamClient((TaskSocketStreamClient *)((char *)this - 8));

  JUMPOUT(0x18531B6D0);
}

{
  TaskSocketStreamClient::~TaskSocketStreamClient((TaskSocketStreamClient *)((char *)this - 8));
}

void TaskSocketStreamClient::~TaskSocketStreamClient(TaskSocketStreamClient *this)
{
  *(void *)this = &unk_1ECFA2578;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA2600;

  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    CFRelease((CFTypeRef)(v2 - 16));
  }
  *(void *)this = &unk_1ECF9B550;
}

{
  uint64_t vars8;

  TaskSocketStreamClient::~TaskSocketStreamClient(this);

  JUMPOUT(0x18531B6D0);
}

void sub_1842C1FEC(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void TaskSocketStreamClient::ssPostConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN22TaskSocketStreamClient26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
  v3[3] = &unk_1E5257460;
  v3[4] = a2;
  void v3[5] = a3;
  TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 16), (uint64_t)v3);
}

void TaskSocketStreamClient::ssPreConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN22TaskSocketStreamClient25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke;
  v3[3] = &unk_1E5257460;
  v3[4] = a2;
  void v3[5] = a3;
  TaskSocketStreamClient::withWorkQueue(*(void **)(a1 + 16), (uint64_t)v3);
}

void TaskSocketStreamClient::ceRelease(id *this)
{
}

id TaskSocketStreamClient::ceRetain(id *this)
{
  return this[2];
}

void TaskSocketStreamClient::copySocketProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFStringRef v6 = [*(id *)(a1 + 16) workQueue];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN22TaskSocketStreamClient18copySocketPropertyEPK10__CFStringU13block_pointerFvPKvE_block_invoke;
  block[3] = &unk_1E5257CF8;
  void block[5] = a1;
  void block[6] = a2;
  block[4] = a3;
  dispatch_async(v6, block);
}

uint64_t ___ZN22TaskSocketStreamClient18copySocketPropertyEPK10__CFStringU13block_pointerFvPKvE_block_invoke(void *a1)
{
  (*(void (**)(void, void))(**(void **)(a1[5] + 24) + 224))(*(void *)(a1[5] + 24), a1[6]);
  uint64_t v2 = *(uint64_t (**)(void))(a1[4] + 16);

  return v2();
}

uint64_t TaskSocketStreamClient::endConnection(TaskSocketStreamClient *this)
{
  uint64_t result = *((void *)this + 3);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 176))(result, 0);
  }
  return result;
}

uint64_t TaskSocketStreamClient::beginConnection(TaskSocketStreamClient *this)
{
  uint64_t result = *((void *)this + 3);
  if (result)
  {
    (*(void (**)(uint64_t, char *))(*(void *)result + 176))(result, (char *)this + 8);
    uint64_t v3 = [*((id *)this + 2) _copySocketStreamProperties];
    if (v3)
    {
      id v4 = (const void *)v3;
      (*(void (**)(void, uint64_t))(**((void **)this + 3) + 208))(*((void *)this + 3), v3);
      CFRelease(v4);
    }
    uint64_t v5 = *(uint64_t (**)(void))(**((void **)this + 3) + 192);
    return v5();
  }
  return result;
}

void TaskSocketStreamClient::initialize(TaskSocketStreamClient *this, NSNetService *a2)
{
  uint64_t v2 = (CFMutableDictionaryRef *)*((void *)this + 3);
  if (a2) {
    a2 = (NSNetService *)a2->_netService;
  }
  SocketStream::initialize(v2, (__CFNetService *)a2);
}

uint64_t TaskSocketStreamClient::initialize(TaskSocketStreamClient *this, NSString *a2, uint64_t a3)
{
  *((void *)this + 4) = [(NSString *)a2 copy];
  *((void *)this + 5) = a3;
  uint64_t v5 = *(uint64_t (**)(void))(**((void **)this + 3) + 56);

  return v5();
}

void BaseSocketStreamClient::~BaseSocketStreamClient(BaseSocketStreamClient *this)
{
  this->var0 = (void **)&unk_1ECF9B550;
  JUMPOUT(0x18531B6D0);
}

{
  this->var0 = (void **)&unk_1ECF9B550;
}

void _onqueue_stFromDataTaskWriteCallback(__CFWriteStream *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = [a3 workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZL36_onqueue_stFromDataTaskWriteCallbackP15__CFWriteStreammPv_block_invoke;
  v6[3] = &unk_1E5258250;
  void v6[4] = a3;
  void v6[5] = a2;
  dispatch_async(v5, v6);
}

void ___ZL36_onqueue_stFromDataTaskWriteCallbackP15__CFWriteStreammPv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(CFStreamError **)(a1 + 32);
  if (!v1 || !v1[75].domain) {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (v1[48].error == 1) {
    v1[48].CFErrorRef error = 2;
  }
  switch(v2)
  {
    case 16:
      uint64_t v3 = 1208;
      goto LABEL_11;
    case 8:
      v1[76] = CFWriteStreamGetError((CFWriteStreamRef)v1[75].domain);
      break;
    case 4:
      uint64_t v3 = 1209;
LABEL_11:
      *((unsigned char *)&v1->domain + v3) = 1;
      break;
  }

  -[__NSCFURLLocalStreamTaskFromDataTask _onqueue_ioTickFromDataTaskConversion:]((uint64_t)v1, (uint64_t)"writeEvent");
}

void _onqueue_stFromDataTaskReadCallback(__CFReadStream *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = [a3 workQueue];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZL35_onqueue_stFromDataTaskReadCallbackP14__CFReadStreammPv_block_invoke;
  v6[3] = &unk_1E5258250;
  void v6[4] = a3;
  void v6[5] = a2;
  dispatch_async(v5, v6);
}

void ___ZL35_onqueue_stFromDataTaskReadCallbackP14__CFReadStreammPv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(CFStreamError **)(a1 + 32);
  if (!v1 || !v1[73].domain) {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (v1[48].error == 1) {
    v1[48].CFErrorRef error = 2;
  }
  switch(v2)
  {
    case 16:
      uint64_t v3 = 1176;
      goto LABEL_11;
    case 8:
      v1[74] = CFReadStreamGetError((CFReadStreamRef)v1[73].domain);
      break;
    case 2:
      uint64_t v3 = 1177;
LABEL_11:
      *((unsigned char *)&v1->domain + v3) = 1;
      break;
  }

  -[__NSCFURLLocalStreamTaskFromDataTask _onqueue_ioTickFromDataTaskConversion:]((uint64_t)v1, (uint64_t)"readevent");
}

uint64_t __NSCFClosedWriteStream::_streamImpl_Write(CFStreamError *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5)
{
  *a5 = this[1];
  return 0;
}

uint64_t __NSCFClosedWriteStream::_streamImpl_OpenCompleted(CFStreamError *this, __CFWriteStream *a2, CFStreamError *a3)
{
  *a3 = this[1];
  return 1;
}

uint64_t __NSCFClosedWriteStream::_streamImpl_Open(CFStreamError *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a3 = this[1];
  *a4 = 1;
  return 1;
}

void __NSCFClosedWriteStream::~__NSCFClosedWriteStream(__NSCFClosedWriteStream *this)
{
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = 0;
  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = 0;
}

void non-virtual thunk to'HTTPServerWithStreams::~HTTPServerWithStreams(HTTPServerWithStreams *this)
{
}

{
  HTTPServerWithStreams::~HTTPServerWithStreams((HTTPServerWithStreams *)((char *)this - 56));
}

{
  HTTPServerWithStreams::~HTTPServerWithStreams((HTTPServerWithStreams *)((char *)this - 8));
}

{
  HTTPServerWithStreams::~HTTPServerWithStreams((HTTPServerWithStreams *)((char *)this - 8));
}

void HTTPServerWithStreams::~HTTPServerWithStreams(HTTPServerWithStreams *this)
{
  *(void *)this = &unk_1ECFA1CC8;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA1D78;
  *((void *)this + 7) = &unk_1ECFA1DE0;
  uint64_t v2 = (const void *)*((void *)this + 35);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 36);
  if (v3) {
    CFRelease(v3);
  }

  HTTPServer::~HTTPServer(this);
}

void sub_1842C3C04(_Unwind_Exception *a1)
{
  HTTPServer::~HTTPServer(v1);
  _Unwind_Resume(a1);
}

uint64_t HTTPServerWithStreams::scheduled(HTTPServerWithStreams *this)
{
  return HTTPServer::newConnectionWithStreams((NSObject **)this, *((__CFReadStream **)this + 35), *((__CFWriteStream **)this + 36));
}

intptr_t HTTPServerWithStreams::ensureServerExists(int a1, dispatch_semaphore_t dsema)
{
  return dispatch_semaphore_signal(dsema);
}

CFStringRef HTTPServerWithStreams::copyDebugDesc(HTTPServerWithStreams *this)
{
  CFStringRef v2 = CFObject::copyDebugDescHeader(this);
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  CFStringRef v4 = CFStringCreateWithFormat(v3, 0, @"%@ { rs = %@, ws = %@ }", v2, *((void *)this + 35), *((void *)this + 36));
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

void XURLCache::createCFXURLCache(XURLCache *this, const _CFURLCache *a2, NSURLSession *a3)
{
  CFTypeID v5 = CFGetTypeID(this);
  if (v5 == CFURLCacheGetTypeID()) {
    operator new();
  }

  XURLCache::createNSXURLCache(this, a2, v6);
}

void sub_1842C3D44(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0xE1C406F2C477FLL);
  _Unwind_Resume(a1);
}

uint64_t NSXURLCache::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  if (a2) {
    [*(id *)(a1 + 8) removeAllCachedResponses];
  }
  CFStringRef v4 = *(uint64_t (**)(uint64_t))(a3 + 16);

  return v4(a3);
}

uint64_t NSXURLCache::getResponseForTask(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  uint64_t v10 = ___ZNK11NSXURLCache18getResponseForTaskEP16NSURLSessionTaskhU13block_pointerFvPK20_CFCachedURLResponseE_block_invoke;
  int v11 = &unk_1E52574C8;
  uint64_t v12 = a4;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v7 = *(void **)(a1 + 8);
  if (isKindOfClass) {
    return v10((uint64_t)v9, objc_msgSend(v7, "cachedResponseForRequest:", objc_msgSend(a2, "currentRequest")));
  }
  else {
    return [v7 getCachedResponseForDataTask:a2 completionHandler:v9];
  }
}

uint64_t ___ZNK11NSXURLCache18getResponseForTaskEP16NSURLSessionTaskhU13block_pointerFvPK20_CFCachedURLResponseE_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = [a2 _CFCachedURLResponse];
  CFStringRef v4 = *(uint64_t (**)(uint64_t, uint64_t))(v2 + 16);

  return v4(v2, v3);
}

void NSXURLCache::addCachedResponseForRequest(id *this, const _CFCachedURLResponse *a2, const _CFURLRequest *a3)
{
  id v5 = [[NSCachedURLResponse alloc] _initWithCFCachedURLResponse:a2];
  id v6 = [[NSURLRequest alloc] _initWithCFURLRequest:a3];
  [this[1] storeCachedResponse:v5 forRequest:v6];
}

void CFXURLCache::flushOrReset(uint64_t a1, int a2, void *a3)
{
  if (a2) {
    CFURLCacheRemoveAllCachedResponses(*(void **)(a1 + 8));
  }
  uint64_t v5 = *(void *)(a1 + 8);

  _CFURLCacheFlush(v5, a3);
}

__CFURLCache **CFXURLCache::addCachedResponseForRequest(CFXURLCache *this, const _CFCachedURLResponse *a2, _CFURLRequest *a3, uint64_t a4, const void *a5)
{
  return _CFURLCacheAddCachedResponseForRequestWithSession(*((__CFURLCache ***)this + 1), *((HTTPProtocol **)this + 2), a2, a3, a5);
}

void non-virtual thunk to'SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry(SHTTPConnectionCacheEntry *this)
{
  uint64_t v2 = (char *)this - 24;
  SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry((SHTTPConnectionCacheEntry *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry((SHTTPConnectionCacheEntry *)((char *)this - 24));
}

void SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry(SHTTPConnectionCacheEntry *this)
{
  *(void *)this = &unk_1ECFA32A0;
  *((void *)this + 3) = &unk_1ECFA3308;
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }
  CFAllocatorRef v3 = (CFArrayRef *)*((void *)this + 6);
  if (v3)
  {
    SUnauthConnectionArray::~SUnauthConnectionArray(v3);
    MEMORY[0x18531B6D0]();
  }
  CFStringRef v4 = (CFTypeRef *)*((void *)this + 7);
  if (v4)
  {
    CFRelease(*v4);
    MEMORY[0x18531B6D0](v4, 0x20C4093837F09);
  }
  uint64_t v5 = (CFTypeRef *)*((void *)this + 8);
  if (v5)
  {
    CFRelease(*v5);
    MEMORY[0x18531B6D0](v5, 0x20C4093837F09);
  }
  uint64_t v6 = *((void *)this + 9);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = (CFArrayRef *)*((void *)this + 10);
  if (v7)
  {
    SAuthConnectionArray::~SAuthConnectionArray(v7);
    MEMORY[0x18531B6D0]();
  }
  int v8 = *((_DWORD *)this + 52);
  if (v8 >= 1)
  {
    for (uint64_t i = 0; i < v8; *(void *)(v10 + 8 * i++) = 0)
    {
      uint64_t v10 = *((void *)this + 11);
      int v11 = *(CFTypeRef **)(v10 + 8 * i);
      if (v11)
      {
        CFRelease(*v11);
        MEMORY[0x18531B6D0](v11, 0x20C4093837F09);
        uint64_t v10 = *((void *)this + 11);
        int v8 = *((_DWORD *)this + 52);
      }
    }
  }
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), *((void **)this + 11));
  uint64_t v12 = (const void *)*((void *)this + 27);
  if (v12) {
    CFRelease(v12);
  }
  CFRelease(*((CFTypeRef *)this + 29));
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  SHTTPConnectionCacheEntry::~SHTTPConnectionCacheEntry(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1842C4278(_Unwind_Exception *a1)
{
  CFRelease(*(CFTypeRef *)(v1 + 232));
  *(void *)(v1 + CFRelease((char *)this - 24) = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void SUnauthConnectionArray::~SUnauthConnectionArray(CFArrayRef *this)
{
  CFArrayRef v2 = *this;
  v3.socklen_t length = CFArrayGetCount(*this);
  v3.id location = 0;
  CFArrayApplyFunction(v2, v3, (CFArrayApplierFunction)RetainableTypedArray<HTTPNetConnection *>::_invoke, &__block_literal_global_54);
  CFRelease(*this);
}

void sub_1842C4308(_Unwind_Exception *a1)
{
  CFRelease(*v1);
  _Unwind_Resume(a1);
}

void SAuthConnectionArray::~SAuthConnectionArray(CFArrayRef *this)
{
  CFArrayRef v2 = *this;
  v3.socklen_t length = CFArrayGetCount(*this);
  v3.id location = 0;
  CFArrayApplyFunction(v2, v3, (CFArrayApplierFunction)RetainableTypedArray<SNetConnectionAuthEntryThing *>::_invoke, &__block_literal_global_58);
  CFRelease(*this);
}

void sub_1842C437C(_Unwind_Exception *a1)
{
  CFRelease(*v1);
  _Unwind_Resume(a1);
}

uint64_t RetainableTypedArray<SNetConnectionAuthEntryThing *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void ___ZN20SAuthConnectionArrayD2Ev_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 96);
    if (v3) {
      pthread_mutex_lock((pthread_mutex_t *)(v3 + 8));
    }
    *(_WORD *)(v2 + 88) &= ~1u;
    NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v2);
    uint64_t v4 = *(void *)(v2 + 96);
    if (v4)
    {
      pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
    }
  }
}

uint64_t RetainableTypedArray<HTTPNetConnection *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t ___ZN22SUnauthConnectionArrayD2Ev_block_invoke(int a1, NetConnection *this)
{
  uint64_t v3 = *((void *)this + 12);
  if (v3) {
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 8));
  }
  *((_WORD *)this + 44) &= ~1u;
  uint64_t result = NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
  uint64_t v5 = *((void *)this + 12);
  if (v5)
  {
    return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  return result;
}

uint64_t SBaseTubeManager::getPendingTubeForProtocolWithKey(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  CFStringRef v9 = &v8;
  uint64_t v10 = 0x2020000000;
  uint64_t v11 = 0;
  (*(void (**)(CFArrayRef *__return_ptr))(*(void *)a1 + 72))(&theArray);
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = ___ZN16SBaseTubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke;
  context[3] = &unk_1E5257A98;
  context[4] = &v8;
  context[5] = a2;
  CFArrayRef v3 = theArray;
  v12.socklen_t length = CFArrayGetCount(theArray);
  v12.id location = 0;
  CFArrayApplyFunction(v3, v12, (CFArrayApplierFunction)RetainableTypedArray<STube *>::_invoke, context);
  CFRelease(theArray);
  uint64_t v4 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v4;
}

void sub_1842C45A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf)
{
  _Block_object_dispose((const void *)(v16 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN16SBaseTubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a2 + 120);
  if (result)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 64))(result);
    if (result == v5) {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = a2;
    }
  }
  return result;
}

uint64_t RetainableTypedArray<STube *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFMutableArrayRef SHTTPConnectionCacheEntry::pendingTubes@<X0>(CFTypeRef *this@<X0>, CFMutableArrayRef *a2@<X8>)
{
  CFAllocatorRef v4 = CFGetAllocator(this[29]);
  CFMutableArrayRef result = CFArrayCreateMutableCopy(v4, 0, (CFArrayRef)this[29]);
  *a2 = result;
  return result;
}

uint64_t SHTTPConnectionCacheEntry::getValidAwaitingTubeForKey(SHTTPConnectionCacheEntry *this, const HTTPConnectionCacheKey *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  uint64_t v2 = *((void *)this + 4);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN25SHTTPConnectionCacheEntry26getValidAwaitingTubeForKeyEPK22HTTPConnectionCacheKey_block_invoke;
  v5[3] = &unk_1E5257C30;
  v5[4] = &v6;
  void v5[5] = this;
  (*(void (**)(uint64_t, void *))(*(void *)v2 + 104))(v2, v5);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1842C475C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN25SHTTPConnectionCacheEntry26getValidAwaitingTubeForKeyEPK22HTTPConnectionCacheKey_block_invoke(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 40);
  uint64_t v3 = *(unsigned int *)(v2 + 208);
  if ((int)v3 < 1)
  {
    uint64_t v8 = 0;
  }
  else
  {
    do
    {
      CFAllocatorRef v4 = *(CFArrayRef **)(*(void *)(v2 + 88) + 8 * (v3 - 1));
      if (v4 && (CFMutableArrayRef result = CFArrayGetCount(*v4), result >= 1))
      {
        uint64_t v5 = result;
        uint64_t v6 = 1;
        do
        {
          CFMutableArrayRef result = (uint64_t)CFArrayGetValueAtIndex(*v4, v6 - 1);
          if (result
            && (uint64_t v7 = (void *)result,
                CFMutableArrayRef result = (*(uint64_t (**)(uint64_t))(*(void *)result + 112))(result),
                (result & 1) == 0))
          {
            uint64_t v8 = (void *)v7[3];
            if (v8)
            {
              CFMutableArrayRef result = (*(uint64_t (**)(void *))(*v7 + 96))(v7);
              if (result) {
                uint64_t v8 = v7;
              }
              else {
                uint64_t v8 = 0;
              }
            }
          }
          else
          {
            uint64_t v8 = 0;
          }
          if (v8) {
            break;
          }
          BOOL v9 = v6++ < v5;
        }
        while (v9);
      }
      else
      {
        uint64_t v8 = 0;
      }
      if (v8) {
        break;
      }
      BOOL v9 = v3-- <= 1;
    }
    while (!v9);
  }
  *(void *)(*(void *)(*(void *)(v1 + 32) + 8) + CFRelease((char *)this - 24) = v8;
  return result;
}

uint64_t SHTTPConnectionCacheEntry::newTubeReady(void *a1, uint64_t a2)
{
  (*(void (**)(void *))(*a1 + 40))(a1);
  (*(void (**)(uint64_t))(*(void *)a2 + 40))(a2);
  uint64_t v4 = a1[4];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN25SHTTPConnectionCacheEntry12newTubeReadyEP5STube13CFStreamError_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  void v6[4] = a1;
  void v6[5] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, v6);
}

uint64_t ___ZN25SHTTPConnectionCacheEntry12newTubeReadyEP5STube13CFStreamError_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(SHTTPConnectionCacheEntry **)(a1 + 32);
  SHTTPConnectionCacheEntry::ingestTube(v2, *(HTTPConnectionCacheKey ***)(a1 + 40));
  (*(void (**)(void))(**(void **)(a1 + 40) + 48))(*(void *)(a1 + 40));
  uint64_t v3 = *(uint64_t (**)(SHTTPConnectionCacheEntry *))(*(void *)v2 + 48);

  return v3(v2);
}

uint64_t SHTTPConnectionCacheEntry::ingestTube(SHTTPConnectionCacheEntry *this, HTTPConnectionCacheKey **a2)
{
  CFArrayRef v4 = (const __CFArray *)*((void *)this + 29);
  v19.socklen_t length = CFArrayGetCount(v4);
  v19.id location = 0;
  CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v19, a2);
  if (FirstIndexOfValue == -1)
  {
    if (!*((void *)this + 30))
    {
      int v17 = *((_DWORD *)a2 + 34);
      if (!*((unsigned char *)this + 248))
      {
        if (v17 != 1) {
          __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 816, "newTube->getType() == kSTubeTypeHTTP");
        }
        __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 817, "_neverDecrementedPlusOneForFirstTube");
      }
      if (v17 != 1) {
        __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 822, "newTube->getType() == kSTubeTypeHTTP");
      }
      __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 829, "_plusOneForFirstTube");
    }
    if (*((_DWORD *)a2 + 34) != 1) {
      __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 826, "newTube->getType() == kSTubeTypeHTTP");
    }
    *((void *)this + 30) = 0;
    *((unsigned char *)this + 248) = 0;
  }
  else
  {
    CFIndex v6 = FirstIndexOfValue;
    if (CFArrayGetValueAtIndex(*((CFArrayRef *)this + 29), FirstIndexOfValue) != a2) {
      __assert_rtn("ingestTube", "SHTTPConnectionCacheEntry.cpp", 834, "checkTube == newTube");
    }
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 29), v6);
  }
  if ((STube::isCanceled((STube *)a2) & 1) == 0)
  {
    uint64_t Waiter = STube::getWaiter((STube *)a2);
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)Waiter + 64))(Waiter);
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v8 + 176))(v8))
    {
      CFArrayRef v13 = a2[12];
      id v14 = (HTTPNetConnection_NoAuth *)CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 320, 0);
      *(_OWORD *)id v14 = 0u;
      *((_OWORD *)v14 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
      *((_OWORD *)v14 + 2) = 0u;
      *((_OWORD *)v14 + 3) = 0u;
      *((_OWORD *)v14 + 4) = 0u;
      *((_OWORD *)v14 + 5) = 0u;
      *((_OWORD *)v14 + 6) = 0u;
      *((_OWORD *)v14 + 7) = 0u;
      *((_OWORD *)v14 + 8) = 0u;
      *((_OWORD *)v14 + 9) = 0u;
      *((_OWORD *)v14 + 10) = 0u;
      *((_OWORD *)v14 + 1HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
      *((_OWORD *)v14 + 12) = 0u;
      *((_OWORD *)v14 + 13) = 0u;
      *((_OWORD *)v14 + 14) = 0u;
      *((_OWORD *)v14 + 15) = 0u;
      *((_OWORD *)v14 + CFRetain((char *)this - 16) = 0u;
      *((_OWORD *)v14 + 17) = 0u;
      *((_OWORD *)v14 + 18) = 0u;
      *((_OWORD *)v14 + 19) = 0u;
      HTTPNetConnection_NoAuth::HTTPNetConnection_NoAuth(v14, *((const __CFAllocator **)this + 1), v13);
      *(void *)(v15 + 304) = a2;
      (*((void (**)(HTTPConnectionCacheKey **))*a2 + 5))(a2);
      NetConnection::initialize(v14);
    }
  }
  uint64_t v9 = STube::getWaiter((STube *)a2);
  uint64_t v10 = STube::getWaiter((STube *)a2);
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 64))(v10);
  (*(void (**)(uint64_t, void))(*(void *)v9 + 56))(v9, 0);
  if (STube::isCanceled((STube *)a2)
    && !(*(unsigned int (**)(uint64_t))(*(void *)v11 + 176))(v11))
  {
    CFRange v12 = CFErrorCreate(*((CFAllocatorRef *)this + 1), @"kCFErrorDomainCFNetwork", -999, 0);
    URLProtocol::sendDidFail((URLProtocol *)(v11 - 176), v12);
    CFRelease(v12);
  }

  return SHTTPConnectionCacheEntry::connectionWasLost(this, 0);
}

CFAllocatedReferenceCountedObject *SHTTPConnectionCacheEnqueuedRequestInfo::SHTTPConnectionCacheEnqueuedRequestInfo(CFAllocatedReferenceCountedObject *a1, const __CFAllocator *a2, uint64_t a3, uint64_t a4, long long *a5)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(a1, a2);
  *(void *)uint64_t v9 = &unk_1ECFA5498;
  long long v10 = *a5;
  *(void *)(v9 + ++*(void *)(this + 64) = *((void *)a5 + 2);
  *(_OWORD *)(v9 + 48) = v10;
  *(void *)(v9 + CFRelease((char *)this - 24) = a3;
  (*(void (**)(uint64_t))(*(void *)a3 + 16))(a3);
  *((void *)a1 + 4) = a4;
  CFRetain((CFTypeRef)(a4 - 16));
  *((void *)a1 + 5) = 0;
  *((void *)a1 + 9) = 0;
  return a1;
}

void SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(SHTTPConnectionCacheEntry *this, SHTTPConnectionCacheEnqueuedRequestInfo *a2, _CFHTTPAuthentication **a3, CFHTTPAuthenticationRef *a4, _CFHTTPAuthentication **a5, CFHTTPAuthenticationRef *a6)
{
  uint64_t v12 = (*(uint64_t (**)(void))(**((void **)a2 + 3) + 32))(*((void *)a2 + 3));
  if ((*(unsigned int (**)(uint64_t))(*(void *)v12 + 88))(v12) == 2)
  {
    BOOL v13 = 1;
  }
  else
  {
    uint64_t v14 = (*(uint64_t (**)(void))(**((void **)a2 + 3) + 32))(*((void *)a2 + 3));
    BOOL v13 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 88))(v14) == 3;
  }
  uint64_t v15 = (CFArrayRef *)*((void *)this + 7);
  uint64_t v16 = *((void *)this + 9);
  int v17 = (const void *)(*(uint64_t (**)(void))(**((void **)a2 + 3) + 96))(*((void *)a2 + 3));
  SHTTPConnectionCacheEntry::findCachedAuthentication((uint64_t)a2, 1, v15, v16, v17, a3, a4);
  uint64_t v18 = (CFArrayRef *)*((void *)this + 8);
  uint64_t v19 = *((void *)this + 9);
  CFStringRef v20 = (const void *)(*(uint64_t (**)(void))(**((void **)a2 + 3) + 120))(*((void *)a2 + 3));
  SHTTPConnectionCacheEntry::findCachedAuthentication((uint64_t)a2, v13, v18, v19, v20, a5, a6);
  CFStringRef AuthSchemeStringFromChallenge = (const __CFString *)SHTTPConnectionCacheEnqueuedRequestInfo::getAuthSchemeStringFromChallenge(*((SHTTPConnectionCacheEnqueuedRequestInfo **)a2 + 3), 0);
  if (AuthSchemeStringFromChallenge) {
    BOOL v22 = CFStringCompare(AuthSchemeStringFromChallenge, @"Negotiate", 0x80uLL) == kCFCompareEqualTo;
  }
  else {
    BOOL v22 = 0;
  }
  if (a3) {
    BOOL v23 = a4 == 0;
  }
  else {
    BOOL v23 = 1;
  }
  int v24 = !v23;
  if (!v23 && !*a3 && ((*(uint64_t (**)(void))(**((void **)a2 + 3) + 96))(*((void *)a2 + 3)) || v22)) {
    SHTTPConnectionCacheEntry::createAuthAndMakeAvailable((CFMutableArrayRef **)this, (SHTTPConnectionCacheEnqueuedRequestInfo **)a2, 0, a3, (const _CFURLCredential **)a4);
  }
  if (a5) {
    BOOL v26 = v13;
  }
  else {
    BOOL v26 = 0;
  }
  if (a6
    && v26
    && !*a5
    && ((*(uint64_t (**)(void))(**((void **)a2 + 3) + 120))(*((void *)a2 + 3)) || v22))
  {
    SHTTPConnectionCacheEntry::createAuthAndMakeAvailable((CFMutableArrayRef **)this, (SHTTPConnectionCacheEnqueuedRequestInfo **)a2, 1, a5, (const _CFURLCredential **)a6);
  }
  if (v24)
  {
    CFHTTPAuthenticationRef v28 = *a3;
    if (*a3)
    {
      if (!*a4 && !v22)
      {
        *a3 = 0;
        CFRelease(v28);
      }
    }
    else if (!v22 && !*a4)
    {
      *a3 = 0;
    }
  }
  if (a5 && a6)
  {
    CFHTTPAuthenticationRef v29 = *a5;
    if (*a5)
    {
      if (!*a6 && !v22)
      {
        *a5 = 0;
        CFRelease(v29);
      }
    }
    else if (!v22 && !*a6)
    {
      *a5 = 0;
    }
  }
}

void SHTTPConnectionCacheEntry::applyCredentialsToRequest(SHTTPConnectionCacheEntry *this, __CFHTTPMessage *a2, const _CFURLCredential *a3, const _CFURLCredential *a4)
{
  CFAllocatorRef v7 = CFGetAllocator(this);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    uint64_t v9 = Mutable;
    uint64_t Username = CFURLCredentialGetUsername((uint64_t)a3);
    if (Username)
    {
      CFStringRef v12 = (const __CFString *)Username;
      if (CFHTTPAuthenticationRequiresAccountDomain(a2)
        && (CFAllocatorRef v13 = CFGetAllocator(v12),
            (CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v13, v12, @"\\"")) != 0))
      {
        CFArrayRef v15 = ArrayBySeparatingStrings;
        if (CFArrayGetCount(ArrayBySeparatingStrings) == 2)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v15, 0);
          CFDictionaryAddValue(v9, @"kCFHTTPAuthenticationAccountDomain", ValueAtIndex);
          int v17 = CFArrayGetValueAtIndex(v15, 1);
          uint64_t v18 = v9;
        }
        else
        {
          uint64_t v18 = v9;
          int v17 = v12;
        }
        CFDictionaryAddValue(v18, @"kCFHTTPAuthenticationUsername", v17);
        CFRelease(v15);
      }
      else
      {
        CFDictionaryAddValue(v9, @"kCFHTTPAuthenticationUsername", v12);
      }
    }
    uint64_t v19 = URLCredential_PasswordBased::safelyCast((uint64_t)a3, v11);
    if (v19)
    {
      CFStringRef v20 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v19 + 128))(v19);
      if (v20)
      {
        CFStringRef v21 = v20;
        CFDictionaryAddValue(v9, @"kCFHTTPAuthenticationPassword", v20);
        CFRelease(v21);
      }
    }
    BOOL v22 = (const void *)_CFURLCredentialCopyOAuthToken(a3);
    if (v22)
    {
      BOOL v23 = v22;
      CFDictionaryAddValue(v9, @"kCFHTTPAuthenticationOAuthToken", v22);
      CFRelease(v23);
    }
    int v24 = (const void *)_CFURLCredentialCopyOAuth1Account(a3);
    if (v24)
    {
      CFTypeID v25 = v24;
      CFDictionaryAddValue(v9, @"kCFHTTPAuthenticationOAuth1Account", v24);
      CFRelease(v25);
      int valuePtr = _CFURLCredentialGetOAuth1PID(a3);
      CFNumberRef v26 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
      if (v26)
      {
        CFNumberRef v27 = v26;
        CFDictionaryAddValue(v9, @"kCFHTTPAuthenticationOAuth1PID", v26);
        CFRelease(v27);
      }
    }
    CFHTTPMessageApplyCredentialDictionary(this, a2, v9, 0);
    CFRelease(v9);
  }
}

uint64_t SHTTPConnectionCacheEntry::dispatchConnectionToProtocol(SHTTPConnectionCacheEntry *this, HTTPNetConnection *a2, SHTTPConnectionCacheEnqueuedRequestInfo *a3, uint64_t a4)
{
  if (!*((unsigned char *)a3 + 65)) {
    *((unsigned char *)this + 40) &= ~0x10u;
  }
  *((_WORD *)a2 + 44) = *((_WORD *)a2 + 44) & 0xFFFB | (4 * (*((unsigned char *)a3 + 66) != 0));
  if ((*((unsigned char *)this + 40) & 8) != 0
    && ((*((unsigned char *)this + 40) & 0x10) == 0 || (*((unsigned char *)this + 40) & 0x60) == 0x20)
    && *((unsigned char *)a3 + 67))
  {
    CFAllocatorRef v7 = (os_unfair_lock_s *)*((void *)a3 + 4);
    if (v7) {
      BOOL v8 = HTTPMessage::hasHeaderField(v7, 0x1490F3F6u) == 0;
    }
    else {
      BOOL v8 = 1;
    }
  }
  else
  {
    BOOL v8 = 0;
  }
  NetConnection::setShouldPipeline(a2, v8);
  uint64_t v9 = (const void *)CFReadStreamCreate();
  uint64_t v10 = *((void *)a3 + 3);
  uint64_t InfoPointer = CFReadStreamGetInfoPointer();
  if (InfoPointer) {
    uint64_t v12 = InfoPointer + 16;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *((void *)a3 + 5);
  if (v13)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*(unsigned char *)(v13 + 40)) {
      uint64_t v14 = 0;
    }
    else {
      uint64_t v14 = v13 + 16;
    }
  }
  else
  {
    uint64_t v14 = *((void *)a3 + 4);
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v10 + 80))(v10, v12, v14, a4);
  if (v15) {
    *((_DWORD *)a2 + 58) = *((_DWORD *)a3 + 12);
  }
  CFRelease(v9);
  return v15;
}

uint64_t SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection(CFArrayRef **this, HTTPNetConnection *a2, unsigned int a3)
{
  uint64_t result = (*(uint64_t (**)(HTTPNetConnection *))(*(void *)a2 + 208))(a2);
  if (result)
  {
    for (CFIndex i = 0; ; ++i)
    {
      uint64_t result = CFArrayGetCount(*this[10]);
      if (i >= result) {
        break;
      }
      if (*((HTTPNetConnection **)CFArrayGetValueAtIndex(*this[10], i) + 3) == a2)
      {
        uint64_t result = (uint64_t)CFArrayGetValueAtIndex(*this[10], i);
        CFAllocatorRef v7 = (SNetConnectionAuthEntryThing *)result;
        goto LABEL_8;
      }
    }
  }
  CFAllocatorRef v7 = 0;
LABEL_8:
  uint64_t v8 = *((unsigned int *)this + 52);
  if ((int)v8 >= 1)
  {
    while (1)
    {
      if (*((_DWORD *)a2 + 58) < (int)v8 - 1)
      {
        uint64_t v9 = *((void *)a2 + 12);
        if (v9)
        {
          uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
          uint64_t v10 = *((void *)a2 + 12);
          uint64_t v11 = *((void *)a2 + 17);
          if (v10) {
            uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
          }
          if (v11)
          {
LABEL_14:
            int v12 = 0;
            goto LABEL_55;
          }
        }
        else if (*((void *)a2 + 17))
        {
          goto LABEL_14;
        }
      }
      uint64_t v13 = (CFArrayRef *)this[11][(v8 - 1)];
      if (v13)
      {
        CFIndex v14 = 0;
LABEL_18:
        int v12 = 0;
        while (1)
        {
LABEL_19:
          uint64_t result = CFArrayGetCount(*v13);
          if (v14 >= result || v12 != 0) {
            goto LABEL_46;
          }
          CFDictionaryRef ValueAtIndex = (SHTTPConnectionCacheEnqueuedRequestInfo *)CFArrayGetValueAtIndex(*v13, v14);
          if (!ValueAtIndex)
          {
            CFArrayRemoveValueAtIndex(*v13, v14);
            goto LABEL_18;
          }
          int v17 = ValueAtIndex;
          if (v7)
          {
            if (!SHTTPConnectionCacheEntry::doesConnAuthApply((SHTTPConnectionCacheEntry *)this, v7, ValueAtIndex))break; {
          }
            }
          CFTypeRef v27 = 0;
          CFTypeRef cf = 0;
          SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol((SHTTPConnectionCacheEntry *)this, v17, (_CFHTTPAuthentication **)&cf, (CFHTTPAuthenticationRef *)&v27, 0, 0);
          uint64_t v18 = (char *)cf;
          if (cf)
          {
            if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
              dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
            }
            unsigned int v19 = HTTPAuthentication::isConnectionBasedAuth((HTTPAuthentication *)(v18 + 16));
            if (cf) {
              CFRelease(cf);
            }
            if (v27) {
              CFRelease(v27);
            }
            if (v19 && ((*(uint64_t (**)(HTTPNetConnection *))(*(void *)a2 + 208))(a2) & 1) == 0) {
              break;
            }
          }
          else if (v27)
          {
            CFRelease(v27);
          }
          (*(void (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)v17 + 40))(v17);
          CFArrayRemoveValueAtIndex(*v13, v14);
          uint64_t v20 = *((void *)v17 + 3);
          if (v20 && !(*(unsigned int (**)(uint64_t))(*(void *)v20 + 176))(v20)) {
            int v12 = SHTTPConnectionCacheEntry::dispatchConnectionToProtocol((SHTTPConnectionCacheEntry *)this, a2, v17, a3);
          }
          else {
            int v12 = 0;
          }
          (*(void (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)v17 + 48))(v17);
        }
        int v12 = 0;
        ++v14;
        goto LABEL_19;
      }
      int v12 = 0;
LABEL_46:
      if (((_BYTE)this[5] & 4) != 0)
      {
        uint64_t v21 = *((unsigned int *)this + 52);
        if ((int)v21 < 1) {
          goto LABEL_54;
        }
        uint64_t v22 = v21 + 1;
        int v23 = v21 - 1;
        char v24 = 1;
        do
        {
          CFTypeID v25 = (CFArrayRef *)this[11][v23];
          if (v25)
          {
            uint64_t result = CFArrayGetCount(*v25);
            if (result > 0) {
              char v24 = 0;
            }
          }
          --v22;
          --v23;
        }
        while (v22 > 1);
        if (v24) {
LABEL_54:
        }
          SHTTPConnectionCacheEntry::removeAllConnections((SHTTPConnectionCacheEntry *)this);
      }
LABEL_55:
      if (v8 >= 2)
      {
        --v8;
        if (!v12) {
          continue;
        }
      }
      return result;
    }
  }
  return result;
}

uint64_t SHTTPConnectionCacheEntry::connectionWasLost(SHTTPConnectionCacheEntry *this, HTTPNetConnection *a2)
{
  (*(void (**)(SHTTPConnectionCacheEntry *))(*(void *)this + 40))(this);
  if (a2)
  {
    SHTTPConnectionCacheEntry::removeUnauthConnection(this, a2);
    if ((*((unsigned char *)this + 40) & 8) != 0
      && ((*((unsigned char *)this + 40) & 0x10) == 0 || (*((unsigned char *)this + 40) & 0x60) == 0x20))
    {
      uint64_t v4 = *((void *)a2 + 12);
      if (v4)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
        uint64_t v5 = *((void *)a2 + 12);
        uint64_t v6 = *((void *)a2 + 28);
        if (v5) {
          pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
        }
      }
      else
      {
        uint64_t v6 = *((void *)a2 + 28);
      }
      if (v6 <= 1 && (*(int (**)(HTTPNetConnection *))(*(void *)a2 + 104))(a2) >= 1) {
        *((unsigned char *)this + 40) |= 0x40u;
      }
    }
  }
  uint64_t v7 = *((unsigned int *)this + 52);
  if ((int)v7 >= 1)
  {
    int v8 = 0;
    int v9 = *((_DWORD *)this + 52);
    do
    {
      uint64_t v10 = *(CFArrayRef **)(*((void *)this + 11) + 8 * --v9);
      if (v10)
      {
        while (CFArrayGetCount(*v10) >= 1 && v8 == 0)
        {
          CFDictionaryRef ValueAtIndex = (SHTTPConnectionCacheEnqueuedRequestInfo *)CFArrayGetValueAtIndex(*v10, 0);
          int v8 = 0;
          if (ValueAtIndex)
          {
            uint64_t v13 = ValueAtIndex;
            (*(void (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)ValueAtIndex + 40))(ValueAtIndex);
            CFArrayRemoveValueAtIndex(*v10, 0);
            if ((*(unsigned int (**)(void *))(**((void **)v13 + 3) + 176))(*((void **)v13 + 3)))
            {
              int v8 = 0;
            }
            else
            {
              unsigned __int8 v25 = 0;
              char v24 = 0;
              int v14 = SHTTPConnectionCacheEntry::findOrCreateEmptyNetConnection(this, &v24, v13, &v25);
              uint64_t v15 = v24;
              if (v24)
              {
                if (v14 != 1) {
                  __assert_rtn("connectionWasLost", "SHTTPConnectionCacheEntry.cpp", 2306, "status == kSHTTPConnectionCacheEntryFoundExistingNetConnection");
                }
                int v8 = SHTTPConnectionCacheEntry::dispatchConnectionToProtocol(this, v24, v13, v25);
                (*(void (**)(HTTPNetConnection *))(*(void *)v15 + 48))(v15);
              }
              else
              {
                if (v14)
                {
                  if (v14 != 2) {
                    __assert_rtn("connectionWasLost", "SHTTPConnectionCacheEntry.cpp", 2314, "status == kSHTTPConnectionCacheEntryNewTubeCreated");
                  }
                }
                else
                {
                  CFArrayAppendValue(*v10, v13);
                }
                int v8 = 1;
              }
            }
            (*(void (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)v13 + 48))(v13);
          }
        }
      }
    }
    while (v7-- > 1);
  }
  if ((*((unsigned char *)this + 40) & 4) != 0)
  {
    uint64_t v17 = *((unsigned int *)this + 52);
    if ((int)v17 < 1) {
      goto LABEL_41;
    }
    uint64_t v18 = v17 + 1;
    unsigned int v19 = v17 - 1;
    char v20 = 1;
    do
    {
      uint64_t v21 = *(CFArrayRef **)(*((void *)this + 11) + 8 * v19);
      if (v21 && CFArrayGetCount(*v21) > 0) {
        char v20 = 0;
      }
      --v18;
      --v19;
    }
    while (v18 > 1);
    if (v20) {
LABEL_41:
    }
      SHTTPConnectionCacheEntry::removeAllConnections(this);
  }
  uint64_t v22 = *(uint64_t (**)(SHTTPConnectionCacheEntry *))(*(void *)this + 48);

  return v22(this);
}

CFIndex SHTTPConnectionCacheEntry::removeUnauthConnection(CFIndex this, HTTPNetConnection *a2)
{
  uint64_t v2 = *(CFArrayRef **)(this + 48);
  if (v2)
  {
    uint64_t v4 = (SHTTPConnectionCacheEntry *)this;
    CFArrayRef v5 = *v2;
    v17.socklen_t length = CFArrayGetCount(*v2);
    v17.id location = 0;
    this = CFArrayGetFirstIndexOfValue(v5, v17, a2);
    if (this != -1)
    {
      CFIndex v6 = this;
      if (a2) {
        (*(void (**)(HTTPNetConnection *))(*(void *)a2 + 40))(a2);
      }
      uint64_t v7 = (void (*)(void))*((void *)a2 + 26);
      if (v7) {
        v7(*((void *)a2 + 27));
      }
      *((void *)a2 + 27) = 0;
      *(_OWORD *)((char *)a2 + 184) = 0u;
      *(_OWORD *)((char *)a2 + 200) = 0u;
      *(_OWORD *)((char *)a2 + 168) = 0u;
      int v8 = (CFArrayRef *)*((void *)v4 + 6);
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*v8, v6);
      uint64_t v10 = (uint64_t)ValueAtIndex;
      uint64_t v11 = (char *)(ValueAtIndex + 21);
      int v12 = (void (*)(void))ValueAtIndex[26];
      if (v12) {
        v12(ValueAtIndex[27]);
      }
      *((void *)v11 + 6) = 0;
      *((_OWORD *)v11 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
      *((_OWORD *)v11 + 2) = 0u;
      *(_OWORD *)uint64_t v11 = 0u;
      uint64_t v13 = *(void *)(v10 + 96);
      if (v13) {
        pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
      }
      *(_WORD *)(v10 + 88) &= ~1u;
      NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v10);
      uint64_t v14 = *(void *)(v10 + 96);
      if (v14) {
        pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
      }
      CFArrayRemoveValueAtIndex(*v8, v6);
      SHTTPConnectionCacheEntry::connectionWasLost(v4, a2);
      uint64_t v15 = *(uint64_t (**)(HTTPNetConnection *))(*(void *)a2 + 48);
      return v15(a2);
    }
  }
  return this;
}

uint64_t SHTTPConnectionCacheEntry::findOrCreateEmptyNetConnection(SHTTPConnectionCacheEntry *this, HTTPNetConnection **a2, SHTTPConnectionCacheEnqueuedRequestInfo *a3, unsigned __int8 *a4)
{
  auth[0] = 0;
  CFTypeRef cf = 0;
  CFHTTPAuthenticationRef v136 = 0;
  CFTypeRef v134 = 0;
  uint64_t v7 = (*(uint64_t (**)(void))(**((void **)a3 + 3) + 32))(*((void *)a3 + 3));
  if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 88))(v7) == 2
    || (uint64_t v8 = (*(uint64_t (**)(void))(**((void **)a3 + 3) + 32))(*((void *)a3 + 3)),
        (*(unsigned int (**)(uint64_t))(*(void *)v8 + 88))(v8) == 3))
  {
    *((unsigned char *)this + 40) &= ~8u;
  }
  *a4 = 0;
  if (!*((void *)this + 10)) {
    goto LABEL_34;
  }
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  uint64_t v10 = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  for (CFIndex i = 0; i < CFArrayGetCount(**((CFArrayRef **)this + 10)); ++i)
  {
    CFDictionaryRef ValueAtIndex = (SNetConnectionAuthEntryThing *)CFArrayGetValueAtIndex(**((CFArrayRef **)this + 10), i);
    if (SHTTPConnectionCacheEntry::doesConnAuthApply(this, ValueAtIndex, a3))
    {
      uint64_t v13 = (void *)*((void *)ValueAtIndex + 3);
      if (v13)
      {
        (*(void (**)(void *))(*(void *)v13 + 40))(v13);
        if (NetConnection::willEnqueueRequests((NetConnection *)v13)
          && _isSocketOpenOnNetConnection((HTTPNetConnection *)v13))
        {
          CFArrayAppendValue(Mutable, v13);
          (*(void (**)(void *))(*(void *)v13 + 48))(v13);
          *a4 = 0;
        }
        else
        {
          CFArrayAppendValue(v10, v13);
          (*(void (**)(void *))(*(void *)v13 + 48))(v13);
        }
      }
    }
  }
  uint64_t context = MEMORY[0x1E4F143A8];
  uint64_t v138 = 3221225472;
  double v139 = ___ZN25SHTTPConnectionCacheEntry43findOrCreateEmptyAuthenticatedNetConnectionEP39SHTTPConnectionCacheEnqueuedRequestInfoPh_block_invoke;
  double v140 = &__block_descriptor_40_e9_v16__0_v8l;
  v141 = this;
  v143.socklen_t length = CFArrayGetCount(v10);
  v143.id location = 0;
  CFArrayApplyFunction(v10, v143, (CFArrayApplierFunction)RetainableTypedArray<HTTPNetConnection *>::_invoke, &context);
  CFIndex v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0xFFFFFFFFLL;
  while (CFArrayGetCount(Mutable) > v14)
  {
    CFRange v17 = (NetConnection *)CFArrayGetValueAtIndex(Mutable, v14);
    uint64_t v18 = v17;
    uint64_t v19 = *((void *)v17 + 12);
    if (v19)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v19 + 8));
      uint64_t v20 = *((void *)v18 + 12);
      uint64_t v21 = *((unsigned int *)v18 + 26);
      if (v20) {
        pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8));
      }
      if ((v16 & 0x80000000) != 0) {
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v21 = *((unsigned int *)v17 + 26);
      if ((v16 & 0x80000000) != 0) {
        goto LABEL_24;
      }
    }
    if ((int)v21 >= (int)v16)
    {
      uint64_t v18 = v15;
      uint64_t v21 = v16;
      goto LABEL_27;
    }
LABEL_24:
    if (v15) {
      (*(void (**)(NetConnection *))(*(void *)v15 + 48))(v15);
    }
    (*(void (**)(NetConnection *))(*(void *)v18 + 40))(v18);
LABEL_27:
    ++v14;
    uint64_t v15 = v18;
    uint64_t v16 = v21;
  }
  if (v15
    && (int)v16 > 0
    && (CFArrayGetCount(Mutable) < **((int **)this + 28)
     || (int)NetConnection::pendingRequestCount(v15) > 0
     || !SHTTPConnectionCacheEntry::canPipelineOnConnection(this, v15)))
  {
    (*(void (**)(NetConnection *))(*(void *)v15 + 48))(v15);
    uint64_t v15 = 0;
  }
  CFRelease(v10);
  CFRelease(Mutable);
  if (v15)
  {
    *a2 = v15;
    return 1;
  }
LABEL_34:
  SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, auth, (CFHTTPAuthenticationRef *)&cf, &v136, (CFHTTPAuthenticationRef *)&v134);
  uint64_t v22 = auth[0];
  if (!auth[0])
  {
LABEL_37:
    if (v136 && (v134 || CFHTTPAuthenticationRequiresOrderedRequests(v136))) {
      goto LABEL_40;
    }
    goto LABEL_68;
  }
  if (cf) {
    goto LABEL_41;
  }
  if (!CFHTTPAuthenticationRequiresOrderedRequests(auth[0])) {
    goto LABEL_37;
  }
LABEL_40:
  uint64_t v22 = auth[0];
  if (auth[0]) {
LABEL_41:
  }
    unsigned int v23 = _CFHTTPAuthenticationIsConnectionBasedAuth(v22);
  else {
    unsigned int v23 = 0;
  }
  if (!v136)
  {
    BOOL v24 = 0;
    if (!v23) {
      goto LABEL_46;
    }
    goto LABEL_48;
  }
  BOOL v24 = _CFHTTPAuthenticationIsConnectionBasedAuth(v136) != 0;
  if (v23) {
    goto LABEL_48;
  }
LABEL_46:
  if (v24)
  {
LABEL_48:
    if (auth[0] && (CFRetain(auth[0]), (unsigned __int8 v25 = auth[0]) != 0))
    {
      CFNumberRef v26 = (const _CFURLCredential *)(*(uint64_t (**)(void))(**((void **)a3 + 3) + 96))(*((void *)a3 + 3));
      CFDictionaryRef v28 = SHTTPConnectionCacheEntry::credentialDictionaryFromURLCredential(v25, v26, v27);
    }
    else
    {
      CFDictionaryRef v28 = 0;
      auth[0] = 0;
    }
    CFHTTPAuthenticationRef v29 = v136;
    if (v136)
    {
      CFIndex v30 = (const _CFURLCredential *)(*(uint64_t (**)(void))(**((void **)a3 + 3) + 120))(*((void *)a3 + 3));
      CFDictionaryRef v32 = SHTTPConnectionCacheEntry::credentialDictionaryFromURLCredential(v29, v30, v31);
    }
    else
    {
      CFDictionaryRef v32 = 0;
      CFHTTPAuthenticationRef v136 = 0;
    }
    *a4 = 1;
    uint64_t v33 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 376, 0);
    *uint64_t v33 = 0u;
    v33[1] = 0u;
    v33[2] = 0u;
    v33[3] = 0u;
    void v33[4] = 0u;
    v33[5] = 0u;
    v33[6] = 0u;
    v33[7] = 0u;
    v33[8] = 0u;
    v33[9] = 0u;
    v33[10] = 0u;
    v33[11] = 0u;
    v33[12] = 0u;
    v33[13] = 0u;
    v33[14] = 0u;
    v33[15] = 0u;
    v33[16] = 0u;
    v33[17] = 0u;
    v33[18] = 0u;
    v33[19] = 0u;
    v33[20] = 0u;
    v33[21] = 0u;
    v33[22] = 0u;
    *((void *)v33 + 46) = 0;
    CFAllocatorRef v34 = (const __CFAllocator *)*((void *)this + 1);
    uint64_t v35 = (HTTPConnectionCacheKey *)(*(uint64_t (**)(void))(**((void **)a3 + 3) + 32))(*((void *)a3 + 3));
    HTTPNetConnection::HTTPNetConnection((HTTPNetConnection *)v33, v34, v35);
    *(void *)uint64_t v33 = &unk_1ECFA3758;
    *((void *)v33 + 3) = &unk_1ECFA3890;
    *((unsigned char *)v33 + 344) = 0;
    *((void *)v33 + 46) = 0;
    CFHTTPAuthenticationRef v36 = auth[0];
    CFHTTPAuthenticationRef v37 = v136;
    if (auth[0]) {
      CFHTTPAuthenticationRef v36 = (CFHTTPAuthenticationRef)CFRetain(auth[0]);
    }
    *((void *)v33 + 39) = v36;
    if (v28)
    {
      CFAllocatorRef v38 = CFGetAllocator(v28);
      CFDictionaryRef Copy = CFDictionaryCreateCopy(v38, v28);
    }
    else
    {
      CFDictionaryRef Copy = 0;
    }
    *((void *)v33 + 40) = Copy;
    if (v37) {
      CFTypeRef v40 = CFRetain(v37);
    }
    else {
      CFTypeRef v40 = 0;
    }
    *((void *)v33 + 4HTTPServerConnection::canceled_onQueue(this - 1) = v40;
    if (v32)
    {
      CFAllocatorRef v41 = CFGetAllocator(v32);
      CFDictionaryRef v42 = CFDictionaryCreateCopy(v41, v32);
    }
    else
    {
      CFDictionaryRef v42 = 0;
    }
    *((void *)v33 + 42) = v42;
    NetConnection::initialize((NetConnection *)v33);
  }
LABEL_68:
  if (auth[0]) {
    CFRelease(auth[0]);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v136) {
    CFRelease(v136);
  }
  if (v134) {
    CFRelease(v134);
  }
  CFTypeRef cf = 0;
  CFHTTPAuthenticationRef v136 = 0;
  CFTypeRef v133 = 0;
  CFTypeRef v134 = 0;
  uint64_t v44 = (*(uint64_t (**)(void))(**((void **)a3 + 3) + 32))(*((void *)a3 + 3));
  if ((*(unsigned int (**)(uint64_t))(*(void *)v44 + 88))(v44) == 2)
  {
    *a4 = 0;
    goto LABEL_81;
  }
  uint64_t v45 = (*(uint64_t (**)(void))(**((void **)a3 + 3) + 32))(*((void *)a3 + 3));
  int v46 = (*(uint64_t (**)(uint64_t))(*(void *)v45 + 88))(v45);
  int v47 = 0;
  *a4 = 0;
  if (v46 == 3)
  {
LABEL_81:
    *((unsigned char *)this + 40) &= ~8u;
    int v47 = 1;
  }
  SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, &v136, (CFHTTPAuthenticationRef *)&v134, (_CFHTTPAuthentication **)&cf, (CFHTTPAuthenticationRef *)&v133);
  if (v136)
  {
    unsigned int v48 = _CFHTTPAuthenticationIsConnectionBasedAuth(v136);
    CFHTTPAuthenticationRef v49 = v136;
    CFHTTPAuthenticationRef v136 = 0;
    if (v49) {
      CFRelease(v49);
    }
  }
  else
  {
    unsigned int v48 = 0;
    CFHTTPAuthenticationRef v136 = 0;
  }
  CFTypeRef v50 = v134;
  CFTypeRef v134 = 0;
  if (v50) {
    CFRelease(v50);
  }
  if (!*((void *)this + 6)) {
    goto LABEL_136;
  }
  if ((*(uint64_t (**)(void))(**((void **)a3 + 3) + 96))(*((void *)a3 + 3)) && v48 && !v136)
  {
    int v51 = 0;
    CFHTTPAuthenticationRef v136 = 0;
    int v52 = 1;
    goto LABEL_140;
  }
  if (v47 && (*(uint64_t (**)(void))(**((void **)a3 + 3) + 120))(*((void *)a3 + 3)) && !cf) {
    goto LABEL_136;
  }
  CFIndex Count = CFArrayGetCount(**((CFArrayRef **)this + 6));
  if (Count < 1) {
    goto LABEL_136;
  }
  CFIndex v54 = Count;
  int v55 = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
  uint64_t v56 = 0;
  CFIndex v129 = 0;
  v130 = 0;
  CFIndex v57 = 0;
  uint64_t v58 = -1;
  while (2)
  {
    uint64_t v59 = (int *)CFArrayGetValueAtIndex(**((CFArrayRef **)this + 6), v57);
    if (!NetConnection::willEnqueueRequests((NetConnection *)v59)
      || !_isSocketOpenOnNetConnection((HTTPNetConnection *)v59))
    {
      CFArrayAppendValue(v55, v59);
      goto LABEL_106;
    }
    unsigned int v60 = (int *)*((void *)this + 28);
    if (v56 + *v60 > v60[4] || *((_DWORD *)a3 + 12) >= v60[5])
    {
      uint64_t v61 = *((void *)v59 + 12);
      if (v61)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v61 + 8));
        uint64_t v62 = *((void *)v59 + 12);
        int v63 = v59[26];
        if (v62) {
          pthread_mutex_unlock((pthread_mutex_t *)(v62 + 8));
        }
      }
      else
      {
        int v63 = v59[26];
      }
      if (v63 < 1 || *((_DWORD *)a3 + 12) <= v59[58])
      {
        if (v58 < 0 || v58 > v63)
        {
          if (v130) {
            (*(void (**)(HTTPNetConnection *))(*(void *)v130 + 48))(v130);
          }
          (*(void (**)(int *))(*(void *)v59 + 40))(v59);
          CFIndex v129 = v57;
          v130 = (HTTPNetConnection *)v59;
          uint64_t v58 = v63;
        }
LABEL_106:
        CFHTTPAuthenticationRef v64 = v136;
        CFHTTPAuthenticationRef v136 = 0;
        if (v64) {
          CFRelease(v64);
        }
        CFTypeRef v65 = v134;
        CFTypeRef v134 = 0;
        if (v65) {
          CFRelease(v65);
        }
        CFTypeRef v66 = cf;
        CFTypeRef cf = 0;
        if (v66) {
          CFRelease(v66);
        }
        CFTypeRef v67 = v133;
        CFTypeRef v133 = 0;
        if (v67) {
          CFRelease(v67);
        }
        SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, &v136, (CFHTTPAuthenticationRef *)&v134, (_CFHTTPAuthentication **)&cf, (CFHTTPAuthenticationRef *)&v133);
      }
    }
    ++v57;
    --v56;
    if (v54 != v57) {
      continue;
    }
    break;
  }
  auth[0] = (CFHTTPAuthenticationRef)MEMORY[0x1E4F143A8];
  auth[1] = (CFHTTPAuthenticationRef)3221225472;
  auth[2] = (CFHTTPAuthenticationRef)___ZN25SHTTPConnectionCacheEntry45findOrCreateEmptyUnauthenticatedNetConnectionEPP17HTTPNetConnectionP39SHTTPConnectionCacheEnqueuedRequestInfoPh_block_invoke;
  auth[3] = (CFHTTPAuthenticationRef)&__block_descriptor_40_e9_v16__0_v8l;
  auth[4] = this;
  v144.socklen_t length = CFArrayGetCount(v55);
  v144.id location = 0;
  CFArrayApplyFunction(v55, v144, (CFArrayApplierFunction)RetainableTypedArray<HTTPNetConnection *>::_invoke, auth);
  CFRelease(v55);
  int v51 = v130;
  if (!v130)
  {
LABEL_137:
    int v52 = 1;
    goto LABEL_138;
  }
  CFAllocatorRef v68 = (CFArrayRef *)*((void *)this + 6);
  if (!v68
    || (CFArrayRef v69 = *v68,
        v145.socklen_t length = CFArrayGetCount(*v68),
        v145.id location = 0,
        CFArrayGetFirstIndexOfValue(v69, v145, v130) == -1))
  {
LABEL_135:
    (*(void (**)(HTTPNetConnection *))(*(void *)v130 + 48))(v130);
LABEL_136:
    int v51 = 0;
    goto LABEL_137;
  }
  if (v58 < 1) {
    goto LABEL_210;
  }
  uint64_t v72 = (int *)*((void *)this + 28);
  CFIndex v73 = *v72;
  BOOL v74 = v73 <= v54;
  CFIndex v75 = v73 - v54;
  if (v74)
  {
    if ((int)NetConnection::pendingRequestCount(v130) > 0
      || !SHTTPConnectionCacheEntry::canPipelineOnConnection(this, v130))
    {
LABEL_212:
      (*(void (**)(HTTPNetConnection *))(*(void *)v130 + 48))(v130);
      int v51 = 0;
      int v52 = 0;
      goto LABEL_138;
    }
LABEL_210:
    v119 = (int *)*((void *)this + 28);
    if (*v119 - v129 > v119[4] || *((_DWORD *)a3 + 12) >= v119[5])
    {
      int v52 = 0;
      goto LABEL_214;
    }
    goto LABEL_212;
  }
  if (v75 > v72[4] || *((_DWORD *)a3 + 12) >= v72[5]) {
    goto LABEL_135;
  }
  int v52 = 1;
LABEL_214:
  uint64_t v120 = (const _CFURLCredential *)v134;
  if (v134)
  {
    v70 = v136;
    if (v136)
    {
      uint64_t v121 = (SHTTPConnectionCacheEntry *)*((void *)a3 + 5);
      if (!v121)
      {
        uint64_t v122 = *((void *)a3 + 4);
        if (v122)
        {
          *((void *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v122 - 16));
          CFRelease((CFTypeRef)(*((void *)a3 + 4) - 16));
          *((void *)a3 + 4) = 0;
          uint64_t v121 = (SHTTPConnectionCacheEntry *)*((void *)a3 + 5);
          v70 = v136;
          uint64_t v120 = (const _CFURLCredential *)v134;
        }
        else
        {
          uint64_t v121 = 0;
        }
      }
      SHTTPConnectionCacheEntry::applyCredentialsToRequest(v121, v70, v120, v71);
    }
  }
  if (v133 && cf)
  {
    uint64_t v123 = URLCredential_PasswordBased::safelyCast((uint64_t)v133, (const _CFURLCredential *)v70);
    if (v123) {
      CFStringRef v124 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v123 + 128))(v123);
    }
    else {
      CFStringRef v124 = 0;
    }
    v125 = (__CFHTTPMessage *)*((void *)a3 + 5);
    if (!v125)
    {
      uint64_t v126 = *((void *)a3 + 4);
      if (v126)
      {
        *((void *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v126 - 16));
        CFRelease((CFTypeRef)(*((void *)a3 + 4) - 16));
        *((void *)a3 + 4) = 0;
        v125 = (__CFHTTPMessage *)*((void *)a3 + 5);
      }
      else
      {
        v125 = 0;
      }
    }
    uint64_t v127 = (_CFHTTPAuthentication *)cf;
    CFStringRef Username = (const __CFString *)CFURLCredentialGetUsername((uint64_t)v133);
    CFHTTPMessageApplyCredentials(v125, v127, Username, v124, 0);
    if (v124) {
      CFRelease(v124);
    }
  }
LABEL_138:
  CFHTTPAuthenticationRef v76 = v136;
  CFHTTPAuthenticationRef v136 = 0;
  if (v76) {
    CFRelease(v76);
  }
LABEL_140:
  CFTypeRef v77 = v134;
  CFTypeRef v134 = 0;
  if (v77) {
    CFRelease(v77);
  }
  CFTypeRef v78 = cf;
  CFTypeRef cf = 0;
  if (v78) {
    CFRelease(v78);
  }
  CFTypeRef v79 = v133;
  CFTypeRef v133 = 0;
  if (v79) {
    CFRelease(v79);
  }
  if (!v52 || v51)
  {
    SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, &v136, (CFHTTPAuthenticationRef *)&v134, (_CFHTTPAuthentication **)&cf, (CFHTTPAuthenticationRef *)&v133);
    uint64_t v86 = v136;
    if (v136)
    {
      uint64_t v87 = (const _CFURLCredential *)v134;
      if (v134)
      {
        v88 = (SHTTPConnectionCacheEntry *)*((void *)a3 + 5);
        if (!v88)
        {
          uint64_t v89 = *((void *)a3 + 4);
          if (v89)
          {
            *((void *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v89 - 16));
            CFRelease((CFTypeRef)(*((void *)a3 + 4) - 16));
            *((void *)a3 + 4) = 0;
            v88 = (SHTTPConnectionCacheEntry *)*((void *)a3 + 5);
            uint64_t v86 = v136;
            uint64_t v87 = (const _CFURLCredential *)v134;
          }
          else
          {
            v88 = 0;
          }
        }
        SHTTPConnectionCacheEntry::applyCredentialsToRequest(v88, v86, v87, v85);
      }
    }
    unsigned int v94 = 0;
    if (!cf || !v133) {
      goto LABEL_196;
    }
    uint64_t v95 = URLCredential_PasswordBased::safelyCast((uint64_t)v133, (const _CFURLCredential *)v86);
    if (v95) {
      CFStringRef v96 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v95 + 128))(v95);
    }
    else {
      CFStringRef v96 = 0;
    }
    unsigned int v97 = (__CFHTTPMessage *)*((void *)a3 + 5);
    if (!v97)
    {
      uint64_t v98 = *((void *)a3 + 4);
      if (v98)
      {
        *((void *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v98 - 16));
        CFRelease((CFTypeRef)(*((void *)a3 + 4) - 16));
        *((void *)a3 + 4) = 0;
        unsigned int v97 = (__CFHTTPMessage *)*((void *)a3 + 5);
      }
      else
      {
        unsigned int v97 = 0;
      }
    }
    uint64_t v113 = (_CFHTTPAuthentication *)cf;
    CFStringRef v114 = (const __CFString *)CFURLCredentialGetUsername((uint64_t)v133);
    CFHTTPMessageApplyCredentials(v97, v113, v114, v96, 0);
    if (v96) {
      CFRelease(v96);
    }
LABEL_195:
    unsigned int v94 = 0;
    goto LABEL_196;
  }
  *a4 = 1;
  SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, &v136, (CFHTTPAuthenticationRef *)&v134, (_CFHTTPAuthentication **)&cf, (CFHTTPAuthenticationRef *)&v133);
  uint64_t v81 = v136;
  if (v136)
  {
    v82 = (const _CFURLCredential *)v134;
    if (v134)
    {
      uint64_t v83 = (SHTTPConnectionCacheEntry *)*((void *)a3 + 5);
      if (!v83)
      {
        uint64_t v84 = *((void *)a3 + 4);
        if (v84)
        {
          *((void *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v84 - 16));
          CFRelease((CFTypeRef)(*((void *)a3 + 4) - 16));
          *((void *)a3 + 4) = 0;
          uint64_t v83 = (SHTTPConnectionCacheEntry *)*((void *)a3 + 5);
          uint64_t v81 = v136;
          v82 = (const _CFURLCredential *)v134;
        }
        else
        {
          uint64_t v83 = 0;
        }
      }
      SHTTPConnectionCacheEntry::applyCredentialsToRequest(v83, v81, v82, v80);
    }
  }
  if (cf && v133)
  {
    uint64_t v90 = URLCredential_PasswordBased::safelyCast((uint64_t)v133, (const _CFURLCredential *)v81);
    if (v90) {
      CFStringRef v91 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v90 + 128))(v90);
    }
    else {
      CFStringRef v91 = 0;
    }
    CFErrorRef v92 = (__CFHTTPMessage *)*((void *)a3 + 5);
    if (!v92)
    {
      uint64_t v93 = *((void *)a3 + 4);
      if (v93)
      {
        *((void *)a3 + 5) = CFHTTPMessageCreateCopy(*((CFAllocatorRef *)a3 + 1), (CFHTTPMessageRef)(v93 - 16));
        CFRelease((CFTypeRef)(*((void *)a3 + 4) - 16));
        *((void *)a3 + 4) = 0;
        CFErrorRef v92 = (__CFHTTPMessage *)*((void *)a3 + 5);
      }
      else
      {
        CFErrorRef v92 = 0;
      }
    }
    char v99 = (_CFHTTPAuthentication *)cf;
    CFStringRef v100 = (const __CFString *)CFURLCredentialGetUsername((uint64_t)v133);
    CFHTTPMessageApplyCredentials(v92, v99, v100, v91, 0);
    if (v91) {
      CFRelease(v91);
    }
  }
  uint64_t v101 = (CFArrayRef *)*((void *)this + 6);
  if (v101) {
    CFIndex v102 = CFArrayGetCount(*v101);
  }
  else {
    CFIndex v102 = 0;
  }
  if (CFArrayGetCount(*((CFArrayRef *)this + 29)) + v102 + *((void *)this + 30) >= **((int **)this + 28)) {
    goto LABEL_195;
  }
  char v103 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a3 + 112))(a3);
  uint64_t v104 = *((void *)a3 + 3);
  if ((v103 & 1) != 0 || !v104)
  {
LABEL_189:
    uint64_t v106 = (*(uint64_t (**)(uint64_t))(*(void *)v104 + 32))(v104);
    uint64_t v107 = (*(uint64_t (**)(SHTTPConnectionCacheEntry *, uint64_t))(*(void *)this + 64))(this, v106);
    if (v107)
    {
      CFErrorRef v105 = (SBaseAwaitingTube *)v107;
      goto LABEL_191;
    }
    goto LABEL_195;
  }
  CFErrorRef v105 = a3;
  if (((*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a3 + 96))(a3) & 1) == 0)
  {
    uint64_t v104 = *((void *)a3 + 3);
    goto LABEL_189;
  }
LABEL_191:
  v108 = CFAllocatorAllocate(*((CFAllocatorRef *)this + 1), 248, 0);
  _OWORD *v108 = 0u;
  v108[1] = 0u;
  v108[2] = 0u;
  v108[3] = 0u;
  v108[4] = 0u;
  v108[5] = 0u;
  v108[6] = 0u;
  v108[7] = 0u;
  v108[8] = 0u;
  v108[9] = 0u;
  v108[10] = 0u;
  v108[11] = 0u;
  v108[12] = 0u;
  v108[13] = 0u;
  v108[14] = 0u;
  *((void *)v108 + 30) = 0;
  CFAllocatorRef v109 = (const __CFAllocator *)*((void *)this + 1);
  uint64_t v110 = (*(uint64_t (**)(void))(**((void **)a3 + 3) + 32))(*((void *)a3 + 3));
  STube::STube((uint64_t)v108, v109, v110, (uint64_t)this, *((void *)this + 4));
  uint64_t v111 = *((void *)v108 + 14);
  uint64_t context = MEMORY[0x1E4F143A8];
  uint64_t v138 = 3221225472;
  double v139 = ___ZN5STube24overrideAllowedProtocolsEm_block_invoke;
  double v140 = &__block_descriptor_48_e5_v8__0l;
  v141 = (SHTTPConnectionCacheEntry *)v108;
  uint64_t v142 = 1;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v111 + 104))(v111, &context);
  (*(void (**)(SBaseAwaitingTube *, _OWORD *))(*(void *)v105 + 56))(v105, v108);
  STube::initialize((STube *)v108, v105);
  CFArrayAppendValue(*((CFMutableArrayRef *)this + 29), v108);
  (*(void (**)(_OWORD *))(*(void *)v108 + 48))(v108);
  uint64_t v112 = *((void *)this + 4);
  uint64_t context = MEMORY[0x1E4F143A8];
  uint64_t v138 = 3221225472;
  double v139 = ___ZN25SHTTPConnectionCacheEntry47unenqueuePendingRequestMatchingStubAwaitingTubeEP17SBaseAwaitingTube_block_invoke;
  double v140 = &__block_descriptor_48_e5_v8__0l;
  v141 = this;
  uint64_t v142 = (uint64_t)v105;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v112 + 104))(v112, &context);
  unsigned int v94 = 2;
LABEL_196:
  CFHTTPAuthenticationRef v115 = v136;
  CFHTTPAuthenticationRef v136 = 0;
  if (v115) {
    CFRelease(v115);
  }
  CFTypeRef v116 = v134;
  CFTypeRef v134 = 0;
  if (v116) {
    CFRelease(v116);
  }
  CFTypeRef v117 = cf;
  CFTypeRef cf = 0;
  if (v117) {
    CFRelease(v117);
  }
  CFTypeRef v118 = v133;
  CFTypeRef v133 = 0;
  if (v118) {
    CFRelease(v118);
  }
  if (v51) {
    uint64_t result = 1;
  }
  else {
    uint64_t result = v94;
  }
  *a2 = v51;
  return result;
}

void sub_1842C7644(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void SHTTPConnectionCacheEntry::removeAllConnections(SHTTPConnectionCacheEntry *this)
{
}

void sub_1842C79F8(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

BOOL _isSocketOpenOnNetConnection(HTTPNetConnection *a1)
{
  uint64_t v2 = *((void *)a1 + 12);
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
    uint64_t v3 = *((void *)a1 + 12);
    int v4 = *((_DWORD *)a1 + 26);
    if (v3) {
      pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
    }
  }
  else
  {
    int v4 = *((_DWORD *)a1 + 26);
  }
  if (v4 > 0) {
    return 1;
  }
  uint64_t v7 = *((void *)a1 + 12);
  if (!v7)
  {
    uint64_t v9 = *((void *)a1 + 19);
    if (v9) {
      goto LABEL_12;
    }
    return 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 8));
  uint64_t v8 = *((void *)a1 + 12);
  uint64_t v9 = *((void *)a1 + 19);
  if (v8) {
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  }
  if (!v9) {
    return 0;
  }
LABEL_12:
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  ++*(void *)(v9 + 96);
  uint64_t v10 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 40) + 40))(*(void *)(v9 + 40), 0x1EC0A37A0);
  --*(void *)(v9 + 96);
  if (v10)
  {
    tcp_connection_release();
    return 1;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  ++*(void *)(v9 + 96);
  uint64_t v11 = (const void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 40) + 40))(*(void *)(v9 + 40), 0x1EC0A3538);
  --*(void *)(v9 + 96);
  if ((const void *)*MEMORY[0x1E4F1CFD0] == v11) {
    goto LABEL_31;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  ++*(void *)(v9 + 96);
  CFDataRef v12 = (const __CFData *)(*(uint64_t (**)(void, void *))(**(void **)(v9 + 40) + 40))(*(void *)(v9 + 40), &unk_1EC0A0F98);
  --*(void *)(v9 + 96);
  if (!v12)
  {
LABEL_31:
    BOOL v5 = 0;
  }
  else
  {
    CFDataRef v13 = v12;
    *(_DWORD *)buffer = 0;
    v21.id location = 0;
    v21.socklen_t length = 4;
    CFDataGetBytes(v12, v21, buffer);
    BOOL v5 = 0;
    if (!(*(_DWORD *)buffer >> 20))
    {
      size_t v14 = (((unint64_t)*(unsigned int *)buffer + 8) >> 3) + 7;
      uint64_t v15 = (fd_set *)malloc_type_malloc(v14, 0x37ECECFCuLL);
      uint64_t v16 = (fd_set *)malloc_type_malloc(v14, 0xF77AEB08uLL);
      v19.tv_sec = 0;
      *(void *)&v19.tv_usec = 0;
      bzero(v15, v14);
      bzero(v16, v14);
      int v17 = *(_DWORD *)buffer;
      if (__darwin_check_fd_set_overflow(*(int *)buffer, v15, 0)) {
        *(__int32_t *)((char *)v15->fds_bits + (((unint64_t)v17 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v17;
      }
      int v18 = *(_DWORD *)buffer;
      if (__darwin_check_fd_set_overflow(*(int *)buffer, v16, 0)) {
        *(__int32_t *)((char *)v16->fds_bits + (((unint64_t)v18 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v18;
      }
      BOOL v5 = select(*(_DWORD *)buffer + 1, v15, 0, v16, &v19) == 0;
      free(v15);
      free(v16);
    }
    CFRelease(v13);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v5;
}

uint64_t ___ZN25SHTTPConnectionCacheEntry45findOrCreateEmptyUnauthenticatedNetConnectionEPP17HTTPNetConnectionP39SHTTPConnectionCacheEnqueuedRequestInfoPh_block_invoke(uint64_t a1, HTTPNetConnection *a2)
{
  return SHTTPConnectionCacheEntry::removeUnauthConnection(*(SHTTPConnectionCacheEntry **)(a1 + 32), a2);
}

uint64_t SHTTPConnectionCacheEntry::canPipelineOnConnection(SHTTPConnectionCacheEntry *this, HTTPNetConnection *a2)
{
  if ((*((unsigned char *)this + 40) & 8) == 0
    || (*((unsigned char *)this + 40) & 0x10) != 0 && (*((unsigned char *)this + 40) & 0x60) != 0x20
    || (*((_WORD *)a2 + 44) & 2) == 0)
  {
    return 0;
  }
  int v5 = (*(uint64_t (**)(HTTPNetConnection *))(*(void *)a2 + 104))(a2);
  uint64_t v6 = *((void *)this + 28);
  __int16 v7 = *((_WORD *)a2 + 44);
  if (v5 >= *(_DWORD *)(v6 + 4))
  {
    uint64_t result = 0;
    __int16 v8 = v7 | 0x1000;
  }
  else
  {
    if ((*((_WORD *)a2 + 44) & 0x1000) == 0) {
      return 1;
    }
    if (v5 > *(_DWORD *)(v6 + 8)) {
      return 0;
    }
    __int16 v8 = v7 & 0xEFFF;
    uint64_t result = 1;
  }
  *((_WORD *)a2 + 44) = v8;
  return result;
}

void ___ZN25SHTTPConnectionCacheEntry47unenqueuePendingRequestMatchingStubAwaitingTubeEP17SBaseAwaitingTube_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(unsigned int *)(v1 + 208);
  if ((int)v2 >= 1)
  {
    while (1)
    {
      int v4 = *(CFArrayRef **)(*(void *)(v1 + 88) + 8 * (v2 - 1));
      if (v4)
      {
        CFIndex Count = CFArrayGetCount(*v4);
        if (Count >= 1) {
          break;
        }
      }
LABEL_7:
      if (v2-- <= 1) {
        return;
      }
    }
    CFIndex v6 = Count;
    CFIndex v7 = 0;
    while (*(const void **)(a1 + 40) != CFArrayGetValueAtIndex(*v4, v7))
    {
      if (v6 == ++v7) {
        goto LABEL_7;
      }
    }
    uint64_t v9 = *v4;
    CFArrayRemoveValueAtIndex(v9, v7);
  }
}

uint64_t SHTTPConnectionCacheEntry::doesConnAuthApply(SHTTPConnectionCacheEntry *this, SNetConnectionAuthEntryThing *a2, SHTTPConnectionCacheEnqueuedRequestInfo *a3)
{
  if ((*(unsigned int (**)(void))(**((void **)a3 + 3) + 48))(*((void *)a3 + 3)))
  {
    int v6 = 0;
    CFIndex v7 = 0;
    CFTypeRef cf = 0;
    CFIndex v30 = 0;
    __int16 v8 = (const __CFDictionary **)*((void *)a2 + 4);
    goto LABEL_8;
  }
  uint64_t v9 = (*(uint64_t (**)(void))(**((void **)a3 + 3) + 32))(*((void *)a3 + 3));
  if ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 88))(v9) == 2)
  {
    CFTypeRef cf = 0;
    CFIndex v30 = 0;
    __int16 v8 = (const __CFDictionary **)*((void *)a2 + 4);
LABEL_6:
    CFIndex v7 = (const __CFDictionary **)*((void *)a2 + 5);
    int v6 = 1;
    goto LABEL_8;
  }
  uint64_t v10 = (*(uint64_t (**)(void))(**((void **)a3 + 3) + 32))(*((void *)a3 + 3));
  int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 88))(v10);
  CFTypeRef cf = 0;
  CFIndex v30 = 0;
  __int16 v8 = (const __CFDictionary **)*((void *)a2 + 4);
  if (v11 == 3) {
    goto LABEL_6;
  }
  int v6 = 0;
  CFIndex v7 = 0;
LABEL_8:
  CFDataRef v12 = (_DWORD *)(*(uint64_t (**)(void))(**((void **)a3 + 3) + 96))(*((void *)a3 + 3));
  if (v12)
  {
    if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
      dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
    }
    BOOL v13 = v12[13] == 1;
    if (v8)
    {
      CFRetain(v8);
    }
    else
    {
      SHTTPConnectionCacheEntry::findCachedAuthenticationForProtocol(this, a3, &v30, (CFHTTPAuthenticationRef *)&cf, 0, 0);
      uint64_t v15 = (const __CFDictionary **)cf;
      __int16 v8 = (const __CFDictionary **)v30;
      if (!v30 || !cf)
      {
        if (v30)
        {
          CFRelease(v30);
          uint64_t v15 = (const __CFDictionary **)cf;
        }
        if (!v15) {
          return 0;
        }
        unsigned __int8 v25 = v15;
        goto LABEL_52;
      }
      CFDictionaryRef v16 = SHTTPConnectionCacheEntry::credentialDictionaryFromURLCredential(v30, (const _CFURLCredential *)cf, v14);
      uint64_t v17 = *((void *)a2 + 3);
      if (v17)
      {
        (*(void (**)(uint64_t, CFDictionaryRef, _CFHTTPAuthentication *))(*(void *)v17 + 96))(v17, v16, v30);
        (*(void (**)(uint64_t, CFTypeRef, _CFHTTPAuthentication *))(*(void *)v17 + 88))(v17, cf, v30);
      }
      if (v16) {
        CFRelease(v16);
      }
      CFRelease(cf);
    }
  }
  else
  {
    if (!v8) {
      goto LABEL_43;
    }
    CFRetain(v8);
    BOOL v13 = 0;
  }
  uint64_t v18 = *((void *)a3 + 5);
  if (v18)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    uint64_t v19 = v18 + 16;
    if (*(unsigned char *)(v18 + 40)) {
      uint64_t v19 = 0;
    }
  }
  else
  {
    uint64_t v19 = *((void *)a3 + 4);
  }
  if (!CFHTTPAuthenticationAppliesToRequest((CFHTTPAuthenticationRef)v8, (CFHTTPMessageRef)(v19 - 16))) {
    goto LABEL_51;
  }
  if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
    dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
  }
  if (HTTPAuthentication::isKerberosThePreferredAuthScheme(v8[19])) {
    char v20 = 1;
  }
  else {
    char v20 = v13;
  }
  if ((v20 & 1) == 0)
  {
    if (CFDictionaryGetValue(*(CFDictionaryRef *)(*((void *)this + 9) + 8), v8))
    {
      BOOL v13 = 0;
      goto LABEL_38;
    }
LABEL_51:
    unsigned __int8 v25 = v8;
LABEL_52:
    CFRelease(v25);
    return 0;
  }
LABEL_38:
  if (v12)
  {
    if (!v13)
    {
      CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*((void *)this + 9) + 8), v8);
      if (!Value || !CFEqual(v12, Value)) {
        goto LABEL_51;
      }
    }
  }
  int IsValid = CFHTTPAuthenticationIsValid((CFHTTPAuthenticationRef)v8, 0);
  CFRelease(v8);
  if (!IsValid) {
    return 0;
  }
LABEL_43:
  if (!v6) {
    return !v7;
  }
  if (!v7) {
    return !(*(uint64_t (**)(void))(**((void **)a3 + 3) + 120))(*((void *)a3 + 3));
  }
  uint64_t v23 = *((void *)a3 + 5);
  if (v23)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    uint64_t v24 = v23 + 16;
    if (*(unsigned char *)(v23 + 40)) {
      uint64_t v24 = 0;
    }
  }
  else
  {
    uint64_t v24 = *((void *)a3 + 4);
  }
  uint64_t result = CFHTTPAuthenticationAppliesToRequest((CFHTTPAuthenticationRef)v7, (CFHTTPMessageRef)(v24 - 16));
  if (result)
  {
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
    }
    if (HTTPAuthentication::isKerberosThePreferredAuthScheme(v7[19])
      || !(*(uint64_t (**)(void))(**((void **)a3 + 3) + 120))(*((void *)a3 + 3))
      || (uint64_t result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(*((void *)this + 9) + 8), v7)) != 0
      && (CFTypeRef v27 = (const void *)(*(uint64_t (**)(void))(**((void **)a3 + 3) + 120))(*((void *)a3 + 3)),
          CFDictionaryRef v28 = CFDictionaryGetValue(*(CFDictionaryRef *)(*((void *)this + 9) + 8), v7),
          uint64_t result = 0,
          v27)
      && v28
      && (uint64_t result = CFEqual(v27, v28), result))
    {
      uint64_t result = CFHTTPAuthenticationIsValid((CFHTTPAuthenticationRef)v7, 0);
      if (result) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t ___ZN25SHTTPConnectionCacheEntry43findOrCreateEmptyAuthenticatedNetConnectionEP39SHTTPConnectionCacheEnqueuedRequestInfoPh_block_invoke(uint64_t a1, HTTPNetConnection *a2)
{
  return SHTTPConnectionCacheEntry::removeAuthConnection(*(void *)(a1 + 32), a2);
}

CFDictionaryRef SHTTPConnectionCacheEntry::credentialDictionaryFromURLCredential(SHTTPConnectionCacheEntry *this, const _CFURLCredential *cf, const _CFURLCredential *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    return 0;
  }
  uint64_t v29 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)keys = 0u;
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)values = 0u;
  CFAllocatorRef v5 = CFGetAllocator(cf);
  uint64_t Username = CFURLCredentialGetUsername((uint64_t)cf);
  if (Username)
  {
    if (CFHTTPAuthenticationRequiresAccountDomain(this))
    {
      CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v5, (CFStringRef)Username, @"\\"");
      CFArrayRef v9 = ArrayBySeparatingStrings;
      if (ArrayBySeparatingStrings && CFArrayGetCount(ArrayBySeparatingStrings) == 2)
      {
        keys[0] = @"kCFHTTPAuthenticationAccountDomain";
        values[0] = (void *)CFArrayGetValueAtIndex(v9, 0);
        keys[1] = @"kCFHTTPAuthenticationUsername";
        values[1] = (void *)CFArrayGetValueAtIndex(v9, 1);
        uint64_t Username = 2;
        goto LABEL_11;
      }
    }
    else
    {
      CFArrayRef v9 = 0;
    }
    keys[0] = @"kCFHTTPAuthenticationUsername";
    values[0] = (void *)Username;
    uint64_t Username = 1;
  }
  else
  {
    CFArrayRef v9 = 0;
  }
LABEL_11:
  uint64_t v11 = URLCredential_PasswordBased::safelyCast((uint64_t)cf, v6);
  if (!v11)
  {
    BOOL v13 = 0;
    goto LABEL_15;
  }
  CFDataRef v12 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 128))(v11);
  BOOL v13 = v12;
  if (!v12)
  {
LABEL_15:
    char v14 = 1;
    goto LABEL_16;
  }
  char v14 = 0;
  values[Username] = v12;
  keys[Username++] = @"kCFHTTPAuthenticationPassword";
LABEL_16:
  uint64_t v15 = (void *)_CFURLCredentialCopyOAuthToken(cf);
  CFDictionaryRef v16 = v15;
  if (v15)
  {
    values[Username] = v15;
    keys[Username++] = @"kCFHTTPAuthenticationOAuthToken";
  }
  uint64_t v17 = (void *)_CFURLCredentialCopyOAuth1Account(cf);
  if (v17)
  {
    values[Username] = v17;
    keys[Username++] = @"kCFHTTPAuthenticationOAuth1Account";
    CFRelease(v17);
  }
  int valuePtr = _CFURLCredentialGetOAuth1PID(cf);
  if (valuePtr < 1)
  {
    CFNumberRef v19 = 0;
  }
  else
  {
    CFNumberRef v18 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v19 = v18;
    if (v18)
    {
      values[Username] = v18;
      keys[Username++] = @"kCFHTTPAuthenticationOAuth1PID";
    }
  }
  CFDictionaryRef v10 = CFDictionaryCreate(v5, (const void **)keys, (const void **)values, Username, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v9) {
    CFRelease(v9);
  }
  if ((v14 & 1) == 0) {
    CFRelease(v13);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v19) {
    CFRelease(v19);
  }
  return v10;
}

BOOL SNetConnectionAuthEntryThing::equals(SNetConnectionAuthEntryThing *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

void SNetConnectionAuthEntryThing::~SNetConnectionAuthEntryThing(SNetConnectionAuthEntryThing *this)
{
  SNetConnectionAuthEntryThing::~SNetConnectionAuthEntryThing(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  uint64_t v2;
  const void *v3;
  const void *v4;

  *(void *)this = &unk_1ECFA47F0;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 4);
  if (v3) {
    CFRelease(v3);
  }
  int v4 = (const void *)*((void *)this + 5);
  if (v4) {
    CFRelease(v4);
  }
}

uint64_t SHTTPConnectionCacheEntry::removeAuthConnection(uint64_t this, HTTPNetConnection *a2)
{
  uint64_t v2 = *(CFArrayRef **)(this + 80);
  if (v2)
  {
    uint64_t v4 = this;
    this = CFArrayGetCount(*v2);
    if (this >= 1)
    {
      uint64_t v5 = this;
      CFIndex v6 = 0;
      while (1)
      {
        this = (uint64_t)CFArrayGetValueAtIndex(**(CFArrayRef **)(v4 + 80), v6);
        if (this)
        {
          uint64_t v7 = this;
          if (*(HTTPNetConnection **)(this + 24) == a2) {
            break;
          }
        }
        if (v5 == ++v6) {
          return this;
        }
      }
      __int16 v8 = *(const void **)(this + 32);
      if (a2) {
        (*(void (**)(HTTPNetConnection *))(*(void *)a2 + 40))(a2);
      }
      if (v8) {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(void *)(v4 + 72) + 8), v8);
      }
      CFArrayRef v9 = *(const void **)(v7 + 40);
      if (v9) {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(void *)(v4 + 72) + 8), v9);
      }
      CFDictionaryRef v10 = (void (*)(void))*((void *)a2 + 26);
      if (v10) {
        v10(*((void *)a2 + 27));
      }
      *((void *)a2 + 27) = 0;
      *(_OWORD *)((char *)a2 + 184) = 0u;
      *(_OWORD *)((char *)a2 + 200) = 0u;
      *(_OWORD *)((char *)a2 + 168) = 0u;
      uint64_t v11 = *(CFArrayRef **)(v4 + 80);
      uint64_t v12 = *((void *)CFArrayGetValueAtIndex(*v11, v6) + 3);
      if (v12)
      {
        BOOL v13 = *(void (**)(void))(v12 + 208);
        if (v13) {
          v13(*(void *)(v12 + 216));
        }
        *(void *)(v12 + 2CFRetain((char *)this - 16) = 0;
        *(_OWORD *)(v12 + 184) = 0u;
        *(_OWORD *)(v12 + 200) = 0u;
        *(_OWORD *)(v12 + 168) = 0u;
        uint64_t v14 = *(void *)(v12 + 96);
        if (v14) {
          pthread_mutex_lock((pthread_mutex_t *)(v14 + 8));
        }
        *(_WORD *)(v12 + 88) &= ~1u;
        NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v12);
        uint64_t v15 = *(void *)(v12 + 96);
        if (v15) {
          pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8));
        }
      }
      CFArrayRemoveValueAtIndex(*v11, v6);
      SHTTPConnectionCacheEntry::removeAuthConnection((SHTTPConnectionCacheEntry *)v4, a2);
      SHTTPConnectionCacheEntry::connectionWasLost((SHTTPConnectionCacheEntry *)v4, a2);
      CFDictionaryRef v16 = *(uint64_t (**)(HTTPNetConnection *))(*(void *)a2 + 48);
      return v16(a2);
    }
  }
  return this;
}

_OWORD *___ZN25SHTTPConnectionCacheEntry28dispatchConnectionToProtocolEP17HTTPNetConnectionP39SHTTPConnectionCacheEnqueuedRequestInfoh_block_invoke(uint64_t a1, __CFReadStream *a2)
{
  uint64_t v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(*(void *)(a1 + 32) + 8), 184, 0);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  void v4[5] = 0u;
  void v4[6] = 0u;
  v4[7] = 0u;
  unsigned char v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((void *)v4 + 22) = 0;
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(v5 + 40);
  if (v6)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    uint64_t v7 = v6 + 16;
    if (*(unsigned char *)(v6 + 40)) {
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = *(void *)(v5 + 32);
  }
  HTTPNetStreamInfo::HTTPNetStreamInfo((HTTPNetStreamInfo *)v4, a2, (CFTypeRef)(v7 - 16), *(HTTPNetConnection **)(a1 + 48));
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 24);
  uint64_t v9 = *((void *)v4 + 15);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  *((void *)v4 + 15) = v8;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  }
  return v4;
}

void SHTTPConnectionCacheEntry::findCachedAuthentication(uint64_t a1, int a2, CFArrayRef *a3, uint64_t a4, const void *a5, CFHTTPAuthenticationRef *a6, CFHTTPAuthenticationRef *a7)
{
  uint64_t v13 = *(void *)(a1 + 40);
  if (v13)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    if (*(unsigned char *)(v13 + 40)) {
      uint64_t v14 = 0;
    }
    else {
      uint64_t v14 = v13 + 16;
    }
    if (!a2) {
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 32);
    if (!a2) {
      goto LABEL_22;
    }
  }
  if (!a3 || !a6 || !a7) {
    goto LABEL_22;
  }
  CFIndex Count = CFArrayGetCount(*a3);
  CFDictionaryRef v16 = a6;
  if (Count < 1) {
    goto LABEL_21;
  }
  CFIndex v17 = Count + 1;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (_CFHTTPAuthentication *)CFArrayGetValueAtIndex(*a3, v17 - 2);
    *a6 = ValueAtIndex;
    if (!CFHTTPAuthenticationIsValid(ValueAtIndex, 0))
    {
      CFArrayRemoveValueAtIndex(*a3, v17 - 2);
      goto LABEL_19;
    }
    if (CFHTTPAuthenticationAppliesToRequest(*a6, (CFHTTPMessageRef)(v14 - 16))) {
      break;
    }
LABEL_19:
    if ((unint64_t)--v17 <= 1)
    {
      CFDictionaryRef v16 = a6;
      goto LABEL_21;
    }
  }
  if (*a6)
  {
    CFNumberRef Value = (_CFHTTPAuthentication *)CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 8), *a6);
    *a7 = Value;
    if (a5)
    {
      if (*a6 && (!Value || !CFEqual(a5, Value)))
      {
        *a6 = 0;
        CFDictionaryRef v16 = a7;
LABEL_21:
        *CFDictionaryRef v16 = 0;
      }
    }
  }
LABEL_22:
  if (a6 && a7)
  {
    if (*a6 && *a7)
    {
      CFRetain(*a6);
      CFHTTPAuthenticationRef v19 = *a7;
      CFRetain(v19);
    }
    else
    {
      *a6 = 0;
      *a7 = 0;
    }
  }
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::getAuthSchemeStringFromChallenge(SHTTPConnectionCacheEnqueuedRequestInfo *this, int a2)
{
  uint64_t v2 = *(void *)this;
  if (a2) {
    uint64_t v3 = (*(uint64_t (**)(void))(v2 + 128))();
  }
  else {
    uint64_t v3 = (*(uint64_t (**)(void))(v2 + 104))();
  }
  uint64_t v4 = v3;
  if (!v3) {
    return 0;
  }
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  uint64_t v5 = *(void *)(v4 + 40);
  if (!v5) {
    return 0;
  }
  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
  }
  int v6 = *(_DWORD *)(v5 + 72);
  if (!v6) {
    return 0;
  }

  return URLProtectionSpace::stringForProtSpaceAuthScheme(v6);
}

const _CFURLCredential *SHTTPConnectionCacheEntry::createAuthAndMakeAvailable(CFMutableArrayRef **this, SHTTPConnectionCacheEnqueuedRequestInfo **a2, int a3, _CFHTTPAuthentication **a4, const _CFURLCredential **a5)
{
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef AuthSchemeStringFromChallenge = (const __CFString *)SHTTPConnectionCacheEnqueuedRequestInfo::getAuthSchemeStringFromChallenge(a2[3], a3);
  char v9 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 160))(a2[3]);
  uint64_t v10 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 200))(a2[3]);
  uint64_t v11 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 208))(a2[3]);
  uint64_t v12 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 216))(a2[3]);
  uint64_t v13 = *(void *)a2[3];
  CFStringRef v37 = (const __CFString *)v12;
  CFAllocatorRef v38 = (const void *)v11;
  uint64_t v14 = (const void *)v10;
  if (a3)
  {
    uint64_t v15 = (_DWORD *)(*(uint64_t (**)(void))(v13 + 120))();
    uint64_t v16 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 128))(a2[3]);
    uint64_t v17 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 136))(a2[3]);
  }
  else
  {
    uint64_t v15 = (_DWORD *)(*(uint64_t (**)(void))(v13 + 96))();
    uint64_t v16 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 104))(a2[3]);
    uint64_t v17 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 112))(a2[3]);
  }
  CFNumberRef v18 = (__CFHTTPMessage *)v17;
  if (!AuthSchemeStringFromChallenge
    || (CFComparisonResult v19 = CFStringCompare(AuthSchemeStringFromChallenge, @"Negotiate", 0x80uLL), !v16))
  {
    CFAllocatorRef v20 = allocator;
    CFRange v21 = v18;
    CFStringRef v22 = 0;
    char v23 = 1;
    long long v24 = 0;
    goto LABEL_12;
  }
  if (v19 == kCFCompareEqualTo)
  {
    CFStringRef v34 = (const __CFString *)(*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 224))(a2[3]);
    CFNumberRef v26 = (_CFHTTPAuthentication *)_CFHTTPAuthenticationCreateFromResponseInternal(allocator, v18, AuthSchemeStringFromChallenge, v9, v38, v37, v34, 0, 0, v36);
LABEL_14:
    *a4 = v26;
    if (v26) {
      goto LABEL_15;
    }
    goto LABEL_32;
  }
  if (CFStringCompare(AuthSchemeStringFromChallenge, @"X-MobileMe-AuthToken", 1uLL)
    && CFStringCompare(AuthSchemeStringFromChallenge, @"OAuth", 1uLL))
  {
    if (CFStringCompare(AuthSchemeStringFromChallenge, @"Negotiate", 1uLL) == kCFCompareEqualTo)
    {
      CFAllocatorRef v20 = allocator;
      CFRange v21 = v18;
      CFStringRef v22 = AuthSchemeStringFromChallenge;
      char v23 = v9;
      CFStringRef v25 = v37;
      long long v24 = v38;
      goto LABEL_13;
    }
    CFAllocatorRef v20 = allocator;
    CFRange v21 = v18;
    CFStringRef v22 = AuthSchemeStringFromChallenge;
    char v23 = v9;
    long long v24 = v14;
LABEL_12:
    CFStringRef v25 = 0;
LABEL_13:
    CFNumberRef v26 = (_CFHTTPAuthentication *)_CFHTTPAuthenticationCreateFromResponseInternal(v20, v21, v22, v23, v24, v25, 0, 0, 0, v36);
    goto LABEL_14;
  }
  uint64_t v30 = (_CFHTTPAuthentication *)_CFHTTPAuthenticationCreateFromResponseInternal(allocator, v18, AuthSchemeStringFromChallenge, v9, v14, 0, 0, 0, 0, v36);
  *a4 = v30;
  if (v30)
  {
    if ((*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 152))(a2[3]))
    {
      uint64_t v31 = *a4;
      if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1) {
        dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_9469);
      }
      if (v31) {
        CFDictionaryRef v32 = (_CFHTTPAuthentication *)((char *)v31 + 16);
      }
      else {
        CFDictionaryRef v32 = 0;
      }
      uint64_t v33 = (const void *)(*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 152))(a2[3]);
      HTTPAuthentication::setSecTrust(v32, v33);
    }
    CFNumberRef v26 = *a4;
    if (*a4)
    {
LABEL_15:
      if (a3)
      {
        uint64_t v27 = (*(uint64_t (**)(SHTTPConnectionCacheEnqueuedRequestInfo *))(*(void *)a2[3] + 32))(a2[3]);
        long long v28 = (SHTTPConnectionCacheEntry *)this;
        if ((*(unsigned int (**)(uint64_t))(*(void *)v27 + 88))(v27) == 3
          || _CFHTTPAuthenticationIsConnectionBasedAuth(*a4))
        {
LABEL_37:
          if (!*((void *)v28 + 9)) {
            operator new();
          }
          if (v15)
          {
            if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
              dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
            }
            if (v15[13] != 1) {
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(*((void *)v28 + 9) + 8), *a4, v15);
            }
            goto LABEL_43;
          }
LABEL_45:
          uint64_t result = 0;
          goto LABEL_46;
        }
        uint64_t v29 = this[8];
        if (!v29) {
          operator new();
        }
      }
      else
      {
        long long v28 = (SHTTPConnectionCacheEntry *)this;
        if (_CFHTTPAuthenticationIsConnectionBasedAuth(v26)) {
          goto LABEL_37;
        }
        uint64_t v29 = this[7];
        if (!v29) {
          operator new();
        }
      }
      CFArrayAppendValue(*v29, *a4);
      goto LABEL_37;
    }
  }
LABEL_32:
  if (!v15) {
    goto LABEL_45;
  }
LABEL_43:
  uint64_t result = (const _CFURLCredential *)CFRetain(v15);
LABEL_46:
  *a5 = result;
  return result;
}

void sub_1842C9390(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x20C4093837F09);
  _Unwind_Resume(a1);
}

void RetainableTypedDict<_CFHTTPAuthentication *,_CFURLCredential const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0230;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<_CFHTTPAuthentication *,_CFURLCredential const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0230;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

uint64_t SBaseAwaitingTube::hasBeenClaimed(SBaseAwaitingTube *this)
{
  return *((unsigned __int8 *)this + 20);
}

uint64_t SBaseAwaitingTube::markAsClaimed(uint64_t this)
{
  if (*(unsigned char *)(this + 20)) {
    __assert_rtn("markAsClaimed", "SAwaitingTube.h", 52, "!claimedByTube");
  }
  *(unsigned char *)(this + 20) = 1;
  return this;
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::isValid(SHTTPConnectionCacheEnqueuedRequestInfo *this)
{
  uint64_t result = *((void *)this + 3);
  if (result) {
    return (*(unsigned int (**)(uint64_t))(*(void *)result + 184))(result) != 0;
  }
  return result;
}

__n128 SHTTPConnectionCacheEnqueuedRequestInfo::getRequestToEnqueue(__n128 *a1, void *a2, unint64_t *a3, __n128 *a4)
{
  unint64_t v8 = a1[2].n128_u64[1];
  if (v8)
  {
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    unint64_t v9 = v8 + 16;
    if (*(unsigned char *)(v8 + 40)) {
      unint64_t v9 = 0;
    }
  }
  else
  {
    unint64_t v9 = a1[2].n128_u64[0];
  }
  *a3 = v9;
  *a2 = a1[1].n128_u64[1];
  __n128 result = a1[3];
  a4[1].n128_u64[0] = a1[4].n128_u64[0];
  *a4 = result;
  return result;
}

__n128 SHTTPConnectionCacheEnqueuedRequestInfo::getOptions@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = this[3];
  *a2 = result;
  a2[1].n128_u64[0] = this[4].n128_u64[0];
  return result;
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::getRequest(SHTTPConnectionCacheEnqueuedRequestInfo *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (!v1) {
    return *((void *)this + 4);
  }
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  if (*(unsigned char *)(v1 + 40)) {
    return 0;
  }
  else {
    return v1 + 16;
  }
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::getClient(SHTTPConnectionCacheEnqueuedRequestInfo *this)
{
  return *((void *)this + 3);
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::linkWithTube(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 72);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
    *(void *)(a1 + 72) = 0;
  }
  if (a2)
  {
    *(void *)(a1 + 72) = a2;
    (*(void (**)(uint64_t))(*(void *)a2 + 40))(a2);
  }
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    int v6 = *(uint64_t (**)(void))(*(void *)result + 56);
    return v6();
  }
  return result;
}

uint64_t SHTTPConnectionCacheEnqueuedRequestInfo::hash(SHTTPConnectionCacheEnqueuedRequestInfo *this)
{
  uint64_t v1 = *((void *)this + 3);
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 8))(*((void *)this + 4)) ^ v1;
}

BOOL SHTTPConnectionCacheEnqueuedRequestInfo::equals(SHTTPConnectionCacheEnqueuedRequestInfo *this, const CFAllocatedReferenceCountedObject *a2)
{
  if (this == a2) {
    return 1;
  }
  if (*((void *)this + 3) == *((void *)a2 + 3)) {
    return CFEqual((CFTypeRef)(*((void *)this + 4) - 16), (CFTypeRef)(*((void *)a2 + 4) - 16)) != 0;
  }
  return 0;
}

CFStringRef SHTTPConnectionCacheEnqueuedRequestInfo::copyDebugDesc(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat(this[1], 0, @"<%p client=%p, message=%@>", this, this[3], (char *)this[4] - 16);
}

void SHTTPConnectionCacheEnqueuedRequestInfo::~SHTTPConnectionCacheEnqueuedRequestInfo(SHTTPConnectionCacheEnqueuedRequestInfo *this)
{
  SHTTPConnectionCacheEnqueuedRequestInfo::~SHTTPConnectionCacheEnqueuedRequestInfo(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const void *v5;

  *(void *)this = &unk_1ECFA5498;
  uint64_t v2 = *((void *)this + 9);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    *((void *)this + 9) = 0;
  }
  CFAllocatorRef v3 = *((void *)this + 3);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    *((void *)this + 3) = 0;
  }
  uint64_t v4 = *((void *)this + 4);
  if (v4)
  {
    CFRelease((CFTypeRef)(v4 - 16));
    *((void *)this + 4) = 0;
  }
  uint64_t v5 = (const void *)*((void *)this + 5);
  if (v5)
  {
    *((void *)this + 5) = 0;
    CFRelease(v5);
  }
}

__CFString *SHTTPConnectionCacheEntry::copyDebugDesc(SHTTPConnectionCacheEntry *this)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  CFStringRef v4 = CFStringCreateWithFormat(v2, 0, @"<HTTPConnectionCacheEntry@%p>{\n", this);
  CFStringAppend(Mutable, v4);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (CFArrayRef *)*((void *)this + 6);
  if (v5)
  {
    CFIndex Count = CFArrayGetCount(*v5);
    CFStringRef v7 = CFStringCreateWithFormat(v2, 0, @"\tfUnAuthConns(%ld) = {\n", Count);
    CFStringAppend(Mutable, v7);
    if (v7) {
      CFRelease(v7);
    }
    for (CFIndex i = 0; CFArrayGetCount(**((CFArrayRef **)this + 6)) > i; ++i)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(**((CFArrayRef **)this + 6), i);
      CFStringRef v10 = CFStringCreateWithFormat(v2, 0, @"\t\t%d: %@ ,\n", i, ValueAtIndex);
      CFStringAppend(Mutable, v10);
      if (v10) {
        CFRelease(v10);
      }
    }
    CFStringAppend(Mutable, @"\t},\n");
  }
  uint64_t v11 = (CFArrayRef *)*((void *)this + 10);
  if (v11)
  {
    CFIndex v12 = CFArrayGetCount(*v11);
    CFStringRef v13 = CFStringCreateWithFormat(v2, 0, @"\tfAuthConns(%ld) = {\n", v12);
    CFStringAppend(Mutable, v13);
    if (v13) {
      CFRelease(v13);
    }
    for (CFIndex j = 0; CFArrayGetCount(**((CFArrayRef **)this + 10)) > j; ++j)
    {
      uint64_t v15 = CFArrayGetValueAtIndex(**((CFArrayRef **)this + 10), j);
      CFStringRef v16 = CFStringCreateWithFormat(v2, 0, @"\t\t%d: %@ ,\n", j, v15);
      CFStringAppend(Mutable, v16);
      if (v16) {
        CFRelease(v16);
      }
    }
    CFStringAppend(Mutable, @"\t},\n");
  }
  uint64_t v17 = *((unsigned int *)this + 52);
  if ((int)v17 >= 1)
  {
    do
    {
      CFNumberRef v18 = *(CFArrayRef **)(*((void *)this + 11) + 8 * (v17 - 1));
      if (v18)
      {
        CFIndex v19 = CFArrayGetCount(*v18);
        CFStringRef v20 = CFStringCreateWithFormat(v2, 0, @"\tfQueues[%d] (%ld) = {\n", v17 - 1, v19);
        CFStringAppend(Mutable, v20);
        if (v20) {
          CFRelease(v20);
        }
        for (CFIndex k = 0; CFArrayGetCount(*v18) > k; ++k)
        {
          CFStringRef v22 = CFArrayGetValueAtIndex(*v18, k);
          CFStringRef v23 = CFStringCreateWithFormat(v2, 0, @"\t\t%d: %p ,\n", k, v22);
          CFStringAppend(Mutable, v23);
          if (v23) {
            CFRelease(v23);
          }
        }
        CFStringAppend(Mutable, @"\t},\n");
      }
    }
    while (v17-- > 1);
  }
  CFStringAppend(Mutable, @"}\n");
  return Mutable;
}

CFIndex SHTTPConnectionCacheEntry::connectionActivity(SHTTPConnectionCacheEntry *this, NetConnection *a2, void *a3)
{
  return SHTTPConnectionCacheEntry::connectionActivity((CFIndex)a2, a2);
}

CFIndex SHTTPConnectionCacheEntry::connectionActivity(CFIndex this, HTTPNetConnection *a2)
{
  uint64_t v2 = *(unsigned int *)(this + 208);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = this;
    do
    {
      CFStringRef v4 = *(CFArrayRef **)(*(void *)(v3 + 88) + 8 * (v2 - 1));
      if (v4)
      {
        this = CFArrayGetCount(*v4);
        if (this >= 1)
        {
          unint64_t v5 = this + 1;
          do
          {
            CFDictionaryRef ValueAtIndex = (void **)CFArrayGetValueAtIndex(*v4, v5 - 2);
            this = (*(uint64_t (**)(void *))(*ValueAtIndex[3] + 192))(ValueAtIndex[3]);
            --v5;
          }
          while (v5 > 1);
        }
      }
    }
    while (v2-- > 1);
  }
  return this;
}

uint64_t SHTTPConnectionCacheEntry::connectionWasLost(SHTTPConnectionCacheEntry *this, NetConnection *a2, void *a3)
{
  return SHTTPConnectionCacheEntry::connectionWasLost(a2, this);
}

CFIndex SHTTPConnectionCacheEntry::connectionCompletedResponse(SHTTPConnectionCacheEntry *this, NetConnection *a2, void *a3)
{
  if (_isSocketOpenOnNetConnection(this))
  {
    char v5 = *((unsigned char *)a2 + 40);
    *((unsigned char *)a2 + 40) = v5 | 0x20;
    if ((v5 & 8) == 0
      || (v5 & 0x50) == 0x50
      || !SHTTPConnectionCacheEntry::canPipelineOnConnection(a2, this)
      || (CFIndex result = (*(uint64_t (**)(SHTTPConnectionCacheEntry *))(*(void *)this + 104))(this),
          !result))
    {
      return SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection((CFArrayRef **)a2, this, 0);
    }
  }
  else
  {
    return SHTTPConnectionCacheEntry::removeUnauthConnection((CFIndex)a2, this);
  }
  return result;
}

HTTPNetConnection *SHTTPConnectionCacheEntry::connectionCompletedRequest(HTTPNetConnection *this, NetConnection *a2, void *a3)
{
  if ((*((unsigned char *)a2 + 40) & 8) != 0)
  {
    CFStringRef v4 = this;
    if ((*((unsigned char *)a2 + 40) & 0x10) == 0 || (*((unsigned char *)a2 + 40) & 0x60) == 0x20)
    {
      this = (HTTPNetConnection *)SHTTPConnectionCacheEntry::canPipelineOnConnection(a2, this);
      if (this)
      {
        return (HTTPNetConnection *)SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection((CFArrayRef **)a2, v4, 0);
      }
    }
  }
  return this;
}

CFIndex SHTTPConnectionCacheEntry::authenticatedConnectionActivity(SHTTPConnectionCacheEntry *this, NetConnection *a2, void *a3)
{
  return SHTTPConnectionCacheEntry::connectionActivity((CFIndex)a2, a2);
}

uint64_t SHTTPConnectionCacheEntry::releaseCacheEntry(uint64_t this, const void *a2)
{
  if (this) {
    return (*(uint64_t (**)(void))(*(void *)this + 48))();
  }
  return this;
}

SHTTPConnectionCacheEntry *SHTTPConnectionCacheEntry::retainCacheEntry(SHTTPConnectionCacheEntry *this, const void *a2)
{
  if (this) {
    (*(void (**)(SHTTPConnectionCacheEntry *, const void *))(*(void *)this + 40))(this, a2);
  }
  return this;
}

uint64_t SHTTPConnectionCacheEntry::authenticatedConnectionWasLost(SHTTPConnectionCacheEntry *this, NetConnection *a2, void *a3)
{
  SHTTPConnectionCacheEntry::removeAuthConnection((uint64_t)a2, this);

  return SHTTPConnectionCacheEntry::connectionWasLost(a2, this);
}

uint64_t SHTTPConnectionCacheEntry::authenticatedConnectionCompletedResponse(SHTTPConnectionCacheEntry *this, CFArrayRef **a2, void *a3)
{
  if (_isSocketOpenOnNetConnection(this))
  {
    return SHTTPConnectionCacheEntry::notifyNextProtocolOfOpenConnection(a2, this, 0);
  }
  else
  {
    return SHTTPConnectionCacheEntry::removeAuthConnection((uint64_t)a2, this);
  }
}

CFIndex SHTTPConnectionCacheEntry::countConnections(SHTTPConnectionCacheEntry *this)
{
  CFIndex v2 = *((void *)this + 30) + CFArrayGetCount(*((CFArrayRef *)this + 29));
  uint64_t v3 = (CFArrayRef *)*((void *)this + 6);
  if (v3) {
    v2 += CFArrayGetCount(*v3);
  }
  CFStringRef v4 = (CFArrayRef *)*((void *)this + 10);
  if (v4) {
    v2 += CFArrayGetCount(*v4);
  }
  return v2;
}

void SHTTPConnectionCacheEntry::checkForPurgability(uint64_t a1, __CFArray **a2, double a3, double a4)
{
  if (a1)
  {
    CFAbsoluteTimeGetCurrent();
    if (CFAbsoluteTimeGetCurrent() >= *(double *)(a1 + 296))
    {
      if (a3 == a4) {
        goto LABEL_16;
      }
      uint64_t v8 = *(void *)(a1 + 96);
      if (v8)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v8 + 8));
        uint64_t v9 = *(void *)(a1 + 96);
        uint64_t v10 = *(void *)(a1 + 152);
        if (v9) {
          pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
        }
      }
      else
      {
        uint64_t v10 = *(void *)(a1 + 152);
      }
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
      }
      if (v10) {
        uint64_t v11 = v10 + 16;
      }
      else {
        uint64_t v11 = 0;
      }
      ++*(void *)(v11 + 80);
      CFIndex v12 = (const void *)(*(uint64_t (**)(void))(**(void **)(v11 + 24) + 40))(*(void *)(v11 + 24));
      CFStringRef v13 = v12;
      --*(void *)(v11 + 80);
      uint64_t v14 = (const void *)*MEMORY[0x1E4F1CFD0];
      if (v12) {
        CFRelease(v12);
      }
      if (v14 != v13) {
LABEL_16:
      }
        a4 = a3;
      if (a4 > NetConnection::getLastAccessTime((NetConnection *)a1)
        || !_isSocketOpenOnNetConnection((HTTPNetConnection *)a1))
      {
        uint64_t v15 = *a2;
        CFArrayAppendValue(v15, (const void *)a1);
      }
    }
  }
}

void SHTTPConnectionCacheEntry::purgeIdleConnections(SHTTPConnectionCacheEntry *this, double a2, double a3)
{
  int v6 = (CFArrayRef *)*((void *)this + 6);
  if (v6)
  {
    CFIndex Count = CFArrayGetCount(*v6);
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    for (CFIndex i = Mutable; ; SHTTPConnectionCacheEntry::checkForPurgability((uint64_t)ValueAtIndex, &i, a2, a3))
    {
      BOOL v9 = Count-- < 1;
      if (v9) {
        break;
      }
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(**((CFArrayRef **)this + 6), Count);
    }
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = ___ZN25SHTTPConnectionCacheEntry20purgeIdleConnectionsEdd_block_invoke;
    context[3] = &__block_descriptor_40_e9_v16__0_v8l;
    context[4] = this;
    v18.socklen_t length = CFArrayGetCount(Mutable);
    v18.id location = 0;
    CFArrayApplyFunction(Mutable, v18, (CFArrayApplierFunction)RetainableTypedArray<HTTPNetConnection *>::_invoke, context);
    CFRelease(Mutable);
  }
  uint64_t v11 = (CFArrayRef *)*((void *)this + 10);
  if (v11)
  {
    CFIndex v12 = CFArrayGetCount(*v11);
    CFStringRef v13 = CFArrayCreateMutable(*((CFAllocatorRef *)this + 1), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    for (CFIndex i = v13; ; SHTTPConnectionCacheEntry::checkForPurgability(v14[3], &i, a2, a3))
    {
      BOOL v9 = v12-- < 1;
      if (v9) {
        break;
      }
      uint64_t v14 = CFArrayGetValueAtIndex(**((CFArrayRef **)this + 10), v12);
    }
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = ___ZN25SHTTPConnectionCacheEntry20purgeIdleConnectionsEdd_block_invoke_2;
    v15[3] = &__block_descriptor_40_e9_v16__0_v8l;
    v15[4] = this;
    v19.socklen_t length = CFArrayGetCount(v13);
    v19.id location = 0;
    CFArrayApplyFunction(v13, v19, (CFArrayApplierFunction)RetainableTypedArray<HTTPNetConnection *>::_invoke, v15);
    CFRelease(v13);
  }
}

void sub_1842CA344(_Unwind_Exception *a1)
{
  CFRelease(v1);
  _Unwind_Resume(a1);
}

CFIndex ___ZN25SHTTPConnectionCacheEntry20purgeIdleConnectionsEdd_block_invoke(uint64_t a1, HTTPNetConnection *a2)
{
  return SHTTPConnectionCacheEntry::removeUnauthConnection(*(void *)(a1 + 32), a2);
}

uint64_t ___ZN25SHTTPConnectionCacheEntry20purgeIdleConnectionsEdd_block_invoke_2(uint64_t a1, HTTPNetConnection *a2)
{
  return SHTTPConnectionCacheEntry::removeAuthConnection(*(void *)(a1 + 32), a2);
}

CFIndex SHTTPConnectionCacheEntry::setHasBeenForgotten(CFIndex this)
{
  uint64_t v1 = (SHTTPConnectionCacheEntry *)this;
  *(unsigned char *)(this + 40) |= 4u;
  uint64_t v2 = *(unsigned int *)(this + 208);
  if ((int)v2 < 1) {
    goto LABEL_8;
  }
  uint64_t v3 = v2 + 1;
  unsigned int v4 = v2 - 1;
  char v5 = 1;
  do
  {
    int v6 = *(CFArrayRef **)(*((void *)v1 + 11) + 8 * v4);
    if (v6)
    {
      this = CFArrayGetCount(*v6);
      if (this > 0) {
        char v5 = 0;
      }
    }
    --v3;
    --v4;
  }
  while (v3 > 1);
  if (v5) {
LABEL_8:
  }
    SHTTPConnectionCacheEntry::removeAllConnections(v1);
  return this;
}

uint64_t ___ZN25SHTTPConnectionCacheEntry19setHasBeenForgottenEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 112);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZN5STube6cancelEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 104))(v2, v4);
}

uint64_t SHTTPConnectionCacheEntry::invalidateUnpurgeableConnections(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(CFArrayRef **)(this + 48);
  if (v2)
  {
    this = CFArrayGetCount(*v2);
    if (this >= 1)
    {
      unint64_t v3 = this + 1;
      do
      {
        this = (uint64_t)CFArrayGetValueAtIndex(**(CFArrayRef **)(v1 + 48), v3 - 2);
        if (this) {
          *(void *)(this + 296) = 0;
        }
        --v3;
      }
      while (v3 > 1);
    }
  }
  unsigned int v4 = *(CFArrayRef **)(v1 + 80);
  if (v4)
  {
    this = CFArrayGetCount(*v4);
    if (this >= 1)
    {
      unint64_t v5 = this + 1;
      do
      {
        this = (uint64_t)CFArrayGetValueAtIndex(**(CFArrayRef **)(v1 + 80), v5 - 2);
        uint64_t v6 = *(void *)(this + 24);
        if (v6) {
          *(void *)(v6 + 296) = 0;
        }
        --v5;
      }
      while (v5 > 1);
    }
  }
  return this;
}

uint64_t NetworkProxy::proxyResponseData(NetworkProxy *this)
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Proxy response data is not available", v2, 2u);
  }
  return 0;
}

uint64_t NetworkProxy::proxyResponse(NetworkProxy *this)
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Proxy response is not available", v2, 2u);
  }
  return 0;
}

void NetworkProxy::establishProxyConnection(uint64_t a1, uint64_t *a2)
{
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>(&v9, *(void *)(a1 + 8), *(std::__shared_weak_count **)(a1 + 16));
  uint64_t v3 = *a2;
  if (*a2)
  {
    uint64_t v4 = v9;
    unint64_t v5 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v6 = *(void (**)(void *, uint64_t *, void, void, void))(v3 + 8);
    uint64_t v7 = *(void *)(v3 + 16);
    uint64_t v8 = (void *)(v3 + (v7 >> 1));
    if (v7) {
      uint64_t v6 = *(void (**)(void *, uint64_t *, void, void, void))(*v8 + v6);
    }
    uint64_t v11 = v4;
    CFIndex v12 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v6(v8, &v11, 0, 0, 0);
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
    }
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    }
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
}

void sub_1842CA70C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a12);
  }
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NetworkProxy::setEndpointPort(uint64_t this, int a2)
{
  *(_DWORD *)(this + ++*(void *)(this + 64) = a2;
  return this;
}

void NetworkProxy::setEndpointHost(NetworkProxy *this, CFTypeRef cf)
{
}

uint64_t NetworkProxy::getType(NetworkProxy *this)
{
  return 2;
}

void NetworkProxy::copyURL(NetworkProxy *this@<X0>, CFURLRef *a2@<X8>)
{
  *a2 = 0;
  uint64_t v4 = (*(uint64_t (**)(NetworkProxy *))(*(void *)this + 24))(this);
  CFStringRef v5 = CFStringCreateWithFormat(0, 0, @"%@://%@:%d/", v4, *((void *)this + 3), *((unsigned int *)this + 10));
  if (v5)
  {
    *a2 = CFURLCreateWithString(0, v5, 0);
    CFRelease(v5);
  }
}

void sub_1842CA8A0(_Unwind_Exception *a1)
{
  CFRelease(v2);
  void *v1 = 0;
  _Unwind_Resume(a1);
}

CFTypeRef NetworkProxy::copyCONNECTEndpointProperties(NetworkProxy *this)
{
  CFDictionaryRef v1 = (const __CFDictionary *)*((void *)this + 11);
  if (!v1) {
    return 0;
  }
  CFNumberRef Value = CFDictionaryGetValue(v1, &unk_1EC0A5678);
  if (!Value) {
    return 0;
  }

  return CFRetain(Value);
}

CFTypeRef NetworkProxy::copyCONNECTProperties(NetworkProxy *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 11);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

__CFString *NetworkProxy::prettyType(NetworkProxy *this)
{
  return @"http";
}

CFStringRef NetworkProxy::copyDebugDesc(NetworkProxy *this)
{
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = *((void *)this + 9);
  uint64_t v4 = *((void *)this + 10);
  uint64_t v5 = *((unsigned int *)this + 10);
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)this + 24))();
  if (*((unsigned char *)this + 96)) {
    uint64_t v7 = "T";
  }
  else {
    uint64_t v7 = "F";
  }
  return CFStringCreateWithFormat(0, 0, @"<NetworkProxy %p>{host = %@, port=%d, user=%@, pass=%@, type=%@, CONNECTProperties=%@, transparent=%s}", this, v2, v5, v3, v4, v6, *((void *)this + 11), v7);
}

void NetworkProxy::NetworkProxy(NetworkProxy *this, const NetworkProxyContext *a2)
{
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1ECF9BE20;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 1HTTPServerConnection::canceled_onQueue(this - 1) = 0;
  (*(void (**)(CFTypeRef *__return_ptr))(**(void **)a2 + 24))(&cf);
  if (cf) {
    operator new();
  }
  CFTypeRef cf = 0;
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 4);
  *(_OWORD *)((char *)this + CFRelease((char *)this - 24) = 0u;
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    CFTypeRef v5 = cf;
    CFTypeRef cf = 0;
    if (v5) {
      CFRelease(v5);
    }
  }
  else
  {
    CFTypeRef cf = 0;
  }
  *((_DWORD *)this + 10) = (*(uint64_t (**)(void))(**(void **)a2 + 32))();
}

void sub_1842CAB54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  CFStringRef v13 = (const void *)v10[11];
  v10[11] = 0;
  if (v13) {
    CFRelease(v13);
  }
  uint64_t v14 = (const void *)v10[10];
  v10[10] = 0;
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = *v11;
  *uint64_t v11 = 0;
  if (v15) {
    CFRelease(v15);
  }
  CFStringRef v16 = (std::__shared_weak_count *)v10[7];
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  uint64_t v17 = (std::__shared_weak_count *)v10[4];
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
  }
  *uint64_t v10 = &unk_1ECF9B550;
  CFRange v18 = (std::__shared_weak_count *)v10[2];
  if (v18) {
    std::__shared_weak_count::__release_weak(v18);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'HTTPEngine::~HTTPEngine(HTTPEngine *this)
{
  HTTPEngine::~HTTPEngine((HTTPEngine *)((char *)this - 24));

  JUMPOUT(0x18531B6D0);
}

{
  HTTPEngine::~HTTPEngine((HTTPEngine *)((char *)this - 24));
}

uint64_t HTTPEngine::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (!v3) {
    return 0;
  }
  CFTypeRef v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 80);
  if (v7) {
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 32))(v7, a2);
  }
  else {
    uint64_t v8 = 0;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  return v8;
}

void sub_1842CACC0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void HTTPEngine::connErrorOccurred(CFStreamError *this, CFStreamError a2)
{
  if (!this[6].domain && !this[6].error) {
    this[6] = a2;
  }
  HTTPEngine::_cleanupConnection((HTTPEngine *)this, 0);
}

uint64_t HTTPEngine::HTTPEngineDelegate::alternatePathAvailable()
{
  return 0;
}

void std::__shared_ptr_emplace<ConnectionReadAggregator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6B48;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void std::__shared_ptr_emplace<ConnectionReadAggregator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ECFA6B48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void HTTPEngine::resetResponse(HTTPEngine *this)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v2 = (HTTPMessage *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v2 = (HTTPMessage *)(Instance + 1);
    Instance[18] = 0u;
    Instance[19] = 0u;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  HTTPMessage::HTTPMessage(v2, "httpresponse");
  *(void *)uint64_t v2 = &unk_1ECF9FD98;
  *((void *)v2 + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9FE08;
  *((void *)v2 + 2) = &unk_1ECF9FE28;
  *((_DWORD *)v2 + 32) = -1;
  *((void *)v2 + 17) = 0;
  *((_OWORD *)v2 + 10) = 0u;
  *((_OWORD *)v2 + 1HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
  *((_OWORD *)v2 + 12) = 0u;
  *((_OWORD *)v2 + 13) = 0u;
  *((_OWORD *)v2 + 14) = 0u;
  *((_OWORD *)v2 + 15) = 0u;
  *((_OWORD *)v2 + CFRetain((char *)this - 16) = 0u;
  *((_OWORD *)v2 + 17) = 0u;
  *((unsigned char *)v2 + 296) = 0;
  operator new();
}

void ___ZN10HTTPEngine12readResponseENSt3__110shared_ptrI18HTTPRequestMessageEEU13block_pointerFxvEU13block_pointerFvNS1_I19HTTPResponseMessageEE13CFStreamErrorEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectS8_bEU13block_pointerFvS7_E_block_invoke(uint64_t a1)
{
}

__n128 __Block_byref_object_copy__18998(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void HTTPEngine::_100ContinueProceed(HTTPEngine *this)
{
  if (*((void *)this + 18) == *((void *)this + 30))
  {
    HTTPEngine::_100ContinueTimerCancel(this);
    *((_DWORD *)this + 8) &= ~0x20u;
    HTTPEngine::_writeBodyStart(this);
  }
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_dispatch_data}*,HTTPEngine::_writeBodyPlain(NSObject  {objcproto16OS_dispatch_data}*,CFStreamError,BOOL)::$_0,std::allocator<NSObject  {objcproto16OS_dispatch_data}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void HTTPEngine::_chunkedWriteTrailer(HTTPEngine *this)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 32);
  if (v2)
  {
    CFDictionaryRef v3 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 32))(v2, 0x1EC09F718);
    CFDictionaryRef v4 = v3;
    if (v3)
    {
      if (CFDictionaryGetCount(v3) <= 0)
      {
        CFRelease(v4);
      }
      else
      {
        CFContainerEnumeratorBase::setup((unint64_t)&v16, v4, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictKeyData);
        CFContainerEnumeratorBase::setup((unint64_t)v17, v4, MEMORY[0x1E4F1C230], (uint64_t (*)(CFTypeRef, unint64_t))CFContainerEnumeratorBase::_claimDictObjData);
        if (v17[1] >= 1)
        {
          if (HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict != -1) {
            dispatch_once(&HTTPHeaderDict::Class(void)::sOnce_HTTPHeaderDict, &__block_literal_global_17041);
          }
          uint64_t Instance = _CFRuntimeCreateInstance();
          uint64_t v6 = (HTTPHeaderDict *)Instance;
          if (Instance)
          {
            *(void *)(Instance + CFRetain((char *)this - 16) = 0;
            *(void *)(Instance + CFRelease((char *)this - 24) = 0;
            uint64_t v6 = (HTTPHeaderDict *)(Instance + 16);
          }
          HTTPHeaderDict::HTTPHeaderDict(v6);
          operator new();
        }
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        CFStringRef v13 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          int buf = 138412290;
          *(void *)buf_4 = v4;
          _os_log_impl(&dword_184085000, v13, OS_LOG_TYPE_DEFAULT, "chunkedTrailer: FOUND trailer-dict: %@, but it is empty.", (uint8_t *)&buf, 0xCu);
        }
        CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v17);
        CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v16);
        CFRelease(v4);
      }
    }
  }
  dispatch_data_t v7 = dispatch_data_create("0\r\n\r\n", 5uLL, 0, 0);
  if (!v7) {
    __assert_rtn("_chunkedWriteTrailer", "HTTPEngine.cpp", 3067, "trailerData");
  }
  uint64_t v8 = v7;
  *((void *)this + 35) += 5;
  HTTPEngine::_updateBytesTransferred(this);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v9)
  {
    uint64_t v10 = std::__shared_weak_count::lock(v9);
    if (v10) {
      uint64_t v11 = *((void *)this + 5);
    }
    else {
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v10 = 0;
  }
  uint64_t v12 = *((void *)this + 7);
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3321888768;
  void v14[2] = ___ZN10HTTPEngine20_chunkedWriteTrailerEv_block_invoke;
  v14[3] = &__block_descriptor_64_e8_48c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e13_v24__0___qi_8l;
  v14[4] = this;
  v14[5] = 5;
  v14[6] = v11;
  uint64_t v15 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, NSObject *, void *))(*(void *)v12 + 48))(v12, v8, v14);
  dispatch_release(v8);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v15);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
}

void sub_1842CB614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFTypeRef cf,char a21)
{
  CFRelease(v23);
  std::default_delete<HTTPHeaderDict::Buffer>::operator()[abi:nn180100](v22);
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  }
  _Unwind_Resume(a1);
}

void std::default_delete<HTTPHeaderDict::Buffer>::operator()[abi:nn180100](const void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    CFRelease(v2);
  }

  JUMPOUT(0x18531B6D0);
}

void ___ZN10HTTPEngine20_chunkedWriteTrailerEv_block_invoke(void *a1, CFStreamError a2)
{
  uint64_t v2 = *(void *)&a2.error;
  if (a2.error)
  {
    CFDictionaryRef v4 = (HTTPEngine *)a1[4];
    *((void *)v4 + 35) -= a1[5];
    HTTPEngine::_updateBytesTransferred(v4);
    uint64_t v5 = 4294967292;
    a2.domain = 4;
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v6 = (HTTPEngine *)a1[6];

  *(void *)&a2.CFErrorRef error = v5 | v2 & 0xFFFFFFFF00000000;
  HTTPEngine::_writeBodyFinish(v6, a2);
}

void std::__shared_ptr_pointer<HTTPHeaderDict *,HTTPEngine::_chunkedWriteTrailer(void)::$_0,std::allocator<HTTPHeaderDict>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    CFRelease((CFTypeRef)(v1 - 16));
  }
}

void std::__shared_ptr_pointer<HTTPHeaderDict *,HTTPEngine::_chunkedWriteTrailer(void)::$_0,std::allocator<HTTPHeaderDict>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

void ___ZN10HTTPEngine26_chunkedWriteHeaderAndBodyEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke(uint64_t a1, CFIndex a2, uint64_t a3)
{
  uint64_t v6 = *(HTTPEngine **)(a1 + 32);
  --*((void *)v6 + 34);
  if (a3)
  {
    *((void *)v6 + 35) -= *(void *)(a1 + 40);
    HTTPEngine::_updateBytesTransferred(v6);
    uint64_t v7 = *((void *)v6 + 41);
    if (v7) {
      *(void *)(v7 + 112) -= *(void *)(a1 + 40);
    }
  }
  if (*(void *)(a1 + 56)) {
    *(void *)&v8.CFErrorRef error = *(void *)(a1 + 56);
  }
  else {
    *(void *)&v8.CFErrorRef error = a3;
  }
  if (v8.error)
  {
    if (*(void *)(a1 + 56)) {
      v8.domain = *(void *)(a1 + 48);
    }
    else {
      v8.domain = a2;
    }
    HTTPEngine::_writeBodyFinish(v6, v8);
  }
  else if (*(unsigned char *)(a1 + 80))
  {
    HTTPEngine::_chunkedWriteTrailer(v6);
  }
  else if (*((uint64_t *)v6 + 34) <= 1)
  {
    uint64_t v9 = *(HTTPEngine **)(a1 + 64);
    HTTPEngine::_writeBodyResume(v9);
  }
}

void __destroy_helper_block_e8_64c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 72);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_64c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  *(void *)(result + ++*(void *)(this + 64) = *(void *)(a2 + 64);
  *(void *)(result + 72) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_dispatch_data}*,HTTPEngine::_chunkedWriteHeaderAndBody(NSObject  {objcproto16OS_dispatch_data}*,CFStreamError,BOOL)::$_0,std::allocator<NSObject  {objcproto16OS_dispatch_data}>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(a1 + 24);
  if (v1) {
    dispatch_release(v1);
  }
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_dispatch_data}*,HTTPEngine::_chunkedWriteHeaderAndBody(NSObject  {objcproto16OS_dispatch_data}*,CFStreamError,BOOL)::$_0,std::allocator<NSObject  {objcproto16OS_dispatch_data}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

dispatch_data_t ___ZL13_enchunkulatePU27objcproto16OS_dispatch_data8NSObject_block_invoke()
{
  dispatch_data_t result = dispatch_data_create("\r\n", 2uLL, 0, 0);
  _enchunkulate(NSObject  {objcproto16OS_dispatch_data}*)::chunkTrailer = (uint64_t)result;
  return result;
}

uint64_t ___ZN10HTTPEngine21_getBodyIntelligentlyEU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorbE_block_invoke_40(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void HTTPEngine::_chunkedReadTrailer(HTTPEngine *this)
{
  if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v2 = (HTTPMessage *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v2 = (HTTPMessage *)(Instance + 1);
    Instance[18] = 0u;
    Instance[19] = 0u;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  HTTPMessage::HTTPMessage(v2, "httpresponse");
  *(void *)uint64_t v2 = &unk_1ECF9FD98;
  *((void *)v2 + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9FE08;
  *((void *)v2 + 2) = &unk_1ECF9FE28;
  *((_DWORD *)v2 + 32) = -1;
  *((void *)v2 + 17) = 0;
  *((_OWORD *)v2 + 10) = 0u;
  *((_OWORD *)v2 + 1HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
  *((_OWORD *)v2 + 12) = 0u;
  *((_OWORD *)v2 + 13) = 0u;
  *((_OWORD *)v2 + 14) = 0u;
  *((_OWORD *)v2 + 15) = 0u;
  *((_OWORD *)v2 + CFRetain((char *)this - 16) = 0u;
  *((_OWORD *)v2 + 17) = 0u;
  *((unsigned char *)v2 + 296) = 0;
  operator new();
}

void sub_1842CBC8C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void HTTPEngine::_chunkedParseHeader(HTTPEngine *this, CFStreamError a2)
{
  if (a2.error)
  {
    HTTPEngine::_readBodyFinish((uint64_t)this, 0, a2.domain, *(uint64_t *)&a2.error, 0);
    return;
  }
  int v3 = *((_DWORD *)this + 8);
  if ((v3 & 0x8000) != 0)
  {
    HTTPEngine::_chunkedReadTrailer(this);
  }
  CFDictionaryRef v4 = *((void *)this + 24);
  if (v4 && dispatch_data_get_size(*((dispatch_data_t *)this + 24)))
  {
    uint64_t v32 = 0;
    uint64_t v33 = &v32;
    uint64_t v34 = 0x2020000000;
    uint64_t v35 = 0;
    size_t size = dispatch_data_get_size(v4);
    uint64_t v31 = 0;
    unsigned __int8 v30 = 0;
    if ((v3 & 0x4000) != 0)
    {
      int64_t v10 = 0;
    }
    else
    {
      uint64_t v36 = 0;
      uint64_t v37 = (uint64_t)&v36;
      uint64_t v38 = 0x2020000000;
      LOBYTE(v39) = 1;
      applier[0] = MEMORY[0x1E4F143A8];
      applier[1] = 3221225472;
      applier[2] = ___ZN10HTTPEngine19_chunkedParseHeaderE13CFStreamError_block_invoke;
      applier[3] = &unk_1E5257620;
      applier[4] = &v36;
      applier[5] = &v32;
      dispatch_data_apply(v4, applier);
      if (v33[3] == size)
      {
        uint64_t v6 = -3;
        goto LABEL_11;
      }
      _Block_object_dispose(&v36, 8);
      int64_t v10 = v33[3];
      CFDictionaryRef v4 = *((void *)this + 24);
    }
    uint64_t v45 = 0;
    int v46 = &v45;
    uint64_t v47 = 0x2020000000;
    int64_t v48 = v10;
    int64_t v11 = dispatch_data_get_size(v4);
    if (v11 > v10)
    {
      dispatch_data_t subrange = dispatch_data_create_subrange(v4, v10, v11 - v10);
      v43[0] = 0;
      v43[1] = v43;
      v43[2] = 0x2020000000;
      char v44 = 1;
      uint64_t v36 = MEMORY[0x1E4F143A8];
      uint64_t v37 = 3221225472;
      uint64_t v38 = (uint64_t)___ZN10HTTPEngine31_chunkedParseHeader_parseDigitsElPl_block_invoke;
      uint64_t v39 = &unk_1E5257588;
      CFAllocatorRef v41 = &v45;
      CFDictionaryRef v42 = &v31;
      CFTypeRef v40 = v43;
      dispatch_data_apply(subrange, &v36);
      dispatch_release(subrange);
      int64_t v10 = v46[3];
      _Block_object_dispose(v43, 8);
    }
    _Block_object_dispose(&v45, 8);
    v33[3] = v10;
    if (v10 == size) {
      goto LABEL_34;
    }
    CFStringRef v13 = *((void *)this + 24);
    int64_t v14 = v10;
LABEL_38:
    uint64_t v15 = HTTPEngine::_chunkedParseHeader_skipLWS(v13, v14, &v30);
    uint64_t v16 = v33;
    v33[3] = v15;
    if (v15 == size)
    {
LABEL_34:
      uint64_t v31 = -3;
      goto LABEL_35;
    }
    int v17 = v30;
    while (v17 == 59)
    {
      int64_t v18 = v16[3] + 1;
      v16[3] = v18;
      int64_t v19 = HTTPEngine::_chunkedParseHeader_skipLWS(*((NSObject **)this + 24), v18, &v30);
      uint64_t v16 = v33;
      v33[3] = v19;
      if (v19 == size) {
        goto LABEL_34;
      }
      int v17 = v30;
      if (v30 == 10 || v30 == 13) {
        break;
      }
      int64_t v21 = HTTPEngine::_chunkedParseHeader_skipToken(*((NSObject **)this + 24), v19);
      v33[3] = v21;
      int64_t v22 = HTTPEngine::_chunkedParseHeader_skipLWS(*((NSObject **)this + 24), v21, &v30);
      uint64_t v16 = v33;
      v33[3] = v22;
      if (v22 == size) {
        goto LABEL_34;
      }
      int v17 = v30;
      if (v30 == 61)
      {
        uint64_t v23 = HTTPEngine::_chunkedParseHeader_skipLWS(*((NSObject **)this + 24), v22, &v30);
        v33[3] = v23;
        if (v23 == size) {
          goto LABEL_34;
        }
        size_t v24 = v23;
        CFStringRef v25 = *((void *)this + 24);
        if (v30 == 34) {
          uint64_t v26 = HTTPEngine::_chunkedParseHeader_skipQuotedString(v25, v24);
        }
        else {
          uint64_t v26 = HTTPEngine::_chunkedParseHeader_skipToken(v25, v24);
        }
        int64_t v14 = v26;
        v33[3] = v26;
        CFStringRef v13 = *((void *)this + 24);
        goto LABEL_38;
      }
    }
    if (v17 != 13)
    {
      uint64_t v7 = -1;
      uint64_t v31 = -1;
      goto LABEL_12;
    }
    if (v16[3] + 1 == size) {
      goto LABEL_34;
    }
    uint64_t v36 = 0;
    uint64_t v37 = (uint64_t)&v36;
    uint64_t v38 = 0x2020000000;
    LOBYTE(v39) = 0;
    uint64_t v27 = dispatch_data_create_subrange(*((dispatch_data_t *)this + 24), v16[3] + 1, 1uLL);
    v28[0] = MEMORY[0x1E4F143A8];
    v28[1] = 3221225472;
    void v28[2] = ___ZN10HTTPEngine19_chunkedParseHeaderE13CFStreamError_block_invoke_2;
    v28[3] = &unk_1E5257648;
    v28[4] = &v36;
    dispatch_data_apply(v27, v28);
    if (v27) {
      dispatch_release(v27);
    }
    if (*(unsigned char *)(v37 + 24) == 10)
    {
      uint64_t v6 = v31;
      if (v31 < 0) {
        uint64_t v6 = -1;
      }
      v33[3] += 2;
    }
    else
    {
      uint64_t v6 = -1;
    }
LABEL_11:
    uint64_t v31 = v6;
    _Block_object_dispose(&v36, 8);
    uint64_t v7 = v31;
LABEL_12:
    int v8 = *((_DWORD *)this + 8);
    if ((v8 & 0x4000) != 0 && v7 != -3)
    {
      v8 &= ~0x4000u;
      *((_DWORD *)this + 8) = v8;
    }
    if (v7 == -1)
    {
      HTTPEngine::_readBodyFinish((uint64_t)this, 0, 4, 0xFFFFFFFFLL, 0);
      goto LABEL_36;
    }
    if (v7 != -3)
    {
      *((void *)this + 22) = v7;
      *((void *)this + 23) = 0;
      if (!v7) {
        *((_DWORD *)this + 8) = v8 | 0x8000;
      }
      HTTPEngine::_readBufferConsume(this, v33[3]);
      uint64_t v9 = *((void *)this + 41);
      if (v9) {
        *(void *)(v9 + 136) += v33[3];
      }
      if ((*((unsigned char *)this + 33) & 0x80) != 0) {
        HTTPEngine::_chunkedReadTrailer(this);
      }
      HTTPEngine::_chunkedReadBody(this);
      goto LABEL_36;
    }
LABEL_35:
    HTTPEngine::_chunkedReadHeader(this);
LABEL_36:
    _Block_object_dispose(&v32, 8);
    return;
  }

  HTTPEngine::_chunkedReadHeader(this);
}

void sub_1842CC214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN10HTTPEngine16_chunkedReadBodyEv_block_invoke(uint64_t a1, dispatch_data_t data, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(HTTPEngine **)(a1 + 32);
  uint64_t v10 = *((void *)v9 + 41);
  if (data)
  {
    size_t size = dispatch_data_get_size(data);
    if (!v10) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  size_t size = 0;
  if (v10) {
LABEL_3:
  }
    *(void *)(v10 + 136) += size;
LABEL_4:

  HTTPEngine::_deliverBodyBytes(v9, (uint64_t)data, a3, a4, a5);
}

void HTTPEngine::_chunkedReadHeader(HTTPEngine *this)
{
  uint64_t v2 = *((void *)this + 24);
  if (v2) {
    size_t size = dispatch_data_get_size(v2);
  }
  else {
    size_t size = 0;
  }
  CFDictionaryRef v4 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5) {
      uint64_t v6 = *((void *)this + 5);
    }
    else {
      uint64_t v6 = 0;
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3321888768;
  v7[2] = ___ZN10HTTPEngine18_chunkedReadHeaderEv_block_invoke;
  v7[3] = &__block_descriptor_64_e8_48c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e16_v28__0___qi_8B24l;
  v7[4] = this;
  v7[5] = size;
  void v7[6] = v6;
  int v8 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HTTPEngine::_readBlob((uint64_t)this, 132000, (uint64_t)v7);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_1842CC3BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN10HTTPEngine19_chunkedParseHeaderE13CFStreamError_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5 = 0;
  while (v5 < a5)
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    if (!*(unsigned char *)(v6 + 24)) {
      break;
    }
    unsigned int v7 = *(unsigned __int8 *)(a4 + v5);
    BOOL v8 = v7 > 0x20;
    uint64_t v9 = (1 << v7) & 0x100002600;
    if (v8 || v9 == 0) {
      *(unsigned char *)(v6 + CFRelease((char *)this - 24) = 0;
    }
    else {
      ++v5;
    }
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v5;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t HTTPEngine::_chunkedParseHeader_skipLWS(NSObject *this, int64_t a2, unsigned __int8 *a3)
{
  int64_t v4 = a2;
  uint64_t v12 = 0;
  CFStringRef v13 = &v12;
  uint64_t v14 = 0x2020000000;
  int64_t v15 = a2;
  int64_t size = dispatch_data_get_size(this);
  if (size > v4)
  {
    dispatch_data_t subrange = dispatch_data_create_subrange(this, v4, size - v4);
    v10[0] = 0;
    v10[1] = v10;
    v10[2] = 0x2020000000;
    char v11 = 1;
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 3221225472;
    applier[2] = ___ZN10HTTPEngine27_chunkedParseHeader_skipLWSElPh_block_invoke;
    applier[3] = &unk_1E5257588;
    applier[5] = &v12;
    void applier[6] = a3;
    applier[4] = v10;
    dispatch_data_apply(subrange, applier);
    if (subrange) {
      dispatch_release(subrange);
    }
    int64_t v4 = v13[3];
    _Block_object_dispose(v10, 8);
  }
  _Block_object_dispose(&v12, 8);
  return v4;
}

uint64_t HTTPEngine::_chunkedParseHeader_skipToken(NSObject *this, int64_t a2)
{
  int64_t v2 = a2;
  uint64_t v10 = 0;
  char v11 = &v10;
  uint64_t v12 = 0x2020000000;
  int64_t v13 = a2;
  int64_t size = dispatch_data_get_size(this);
  if (size > v2)
  {
    dispatch_data_t subrange = dispatch_data_create_subrange(this, v2, size - v2);
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x2020000000;
    char v9 = 1;
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    v7[2] = ___ZN10HTTPEngine29_chunkedParseHeader_skipTokenEl_block_invoke;
    v7[3] = &unk_1E5257620;
    v7[4] = v8;
    v7[5] = &v10;
    dispatch_data_apply(subrange, v7);
    if (subrange) {
      dispatch_release(subrange);
    }
    int64_t v2 = v11[3];
    _Block_object_dispose(v8, 8);
  }
  _Block_object_dispose(&v10, 8);
  return v2;
}

uint64_t HTTPEngine::_chunkedParseHeader_skipQuotedString(NSObject *this, size_t a2)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000;
  int64_t v4 = a2 + 1;
  size_t v14 = a2 + 1;
  int64_t size = dispatch_data_get_size(this);
  if (v4 < size)
  {
    dispatch_data_t subrange = dispatch_data_create_subrange(this, a2, size - a2);
    v9[0] = 0;
    v9[1] = v9;
    void v9[2] = 0x2020000000;
    char v10 = 1;
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    v8[2] = ___ZN10HTTPEngine36_chunkedParseHeader_skipQuotedStringEl_block_invoke;
    void v8[3] = &unk_1E5257620;
    v8[4] = v9;
    void v8[5] = &v11;
    dispatch_data_apply(subrange, v8);
    if (subrange) {
      dispatch_release(subrange);
    }
    int64_t v4 = v12[3];
    _Block_object_dispose(v9, 8);
  }
  _Block_object_dispose(&v11, 8);
  return v4;
}

uint64_t ___ZN10HTTPEngine19_chunkedParseHeaderE13CFStreamError_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = *a4;
  return 0;
}

void HTTPEngine::_chunkedReadBody(HTTPEngine *this)
{
  v1[0] = MEMORY[0x1E4F143A8];
  v1[1] = 3221225472;
  v1[2] = ___ZN10HTTPEngine16_chunkedReadBodyEv_block_invoke;
  v1[3] = &__block_descriptor_40_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
  v1[4] = this;
  HTTPEngine::_getBodyIntelligently((uint64_t)this, (uint64_t)v1);
}

uint64_t ___ZN10HTTPEngine36_chunkedParseHeader_skipQuotedStringEl_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5 = 0;
  if (a5)
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    unsigned int v7 = *(unsigned __int8 *)(v6 + 24);
    while (1)
    {
      if (!v7) {
        goto LABEL_10;
      }
      int v8 = *(unsigned __int8 *)(a4 + v5);
      if (v8 == 92) {
        break;
      }
      if (v8 != 34) {
        goto LABEL_8;
      }
      ++v5;
      *(unsigned char *)(v6 + CFRelease((char *)this - 24) = 0;
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
      unsigned int v7 = *(unsigned __int8 *)(v6 + 24);
LABEL_9:
      v5 += v7;
      if (v5 >= a5) {
        goto LABEL_10;
      }
    }
    ++v5;
LABEL_8:
    unsigned int v7 = 1;
    goto LABEL_9;
  }
LABEL_10:
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v5;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t ___ZN10HTTPEngine29_chunkedParseHeader_skipTokenEl_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5 = 0;
  while (v5 < a5)
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    if (!*(unsigned char *)(v6 + 24)) {
      break;
    }
    if ((unsigned int v7 = *(unsigned __int8 *)(a4 + v5), v8 = v7 - 32, v7 < 0x20)
      || v7 == 127
      || ((v9 = v8 > 0x3D, uint64_t v10 = (1 << v8) & 0x38000001FC009305, !v9) ? (v11 = v10 == 0) : (v11 = 1),
          !v11 || v7 == 123 || v7 == 125))
    {
      *(unsigned char *)(v6 + CFRelease((char *)this - 24) = 0;
    }
    else
    {
      ++v5;
    }
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v5;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t ___ZN10HTTPEngine27_chunkedParseHeader_skipLWSElPh_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v5 = 0;
  while (v5 < a5)
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    if (!*(unsigned char *)(v6 + 24)) {
      break;
    }
    int v7 = *(unsigned __int8 *)(a4 + v5);
    if (v7 == 9 || v7 == 32)
    {
      ++v5;
    }
    else
    {
      *(unsigned char *)(v6 + CFRelease((char *)this - 24) = 0;
      **(unsigned char **)(a1 + 48) = v7;
    }
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v5;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t ___ZN10HTTPEngine31_chunkedParseHeader_parseDigitsElPl_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a5)
  {
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
      if (!*(unsigned char *)(v7 + 24)) {
        goto LABEL_15;
      }
      int v8 = *(unsigned __int8 *)(a4 + v6);
      if ((v8 - 48) <= 9) {
        break;
      }
      if ((v8 - 65) <= 5)
      {
        unsigned int v5 = v8 - 55;
        goto LABEL_11;
      }
      if ((v8 - 97) <= 5)
      {
        unsigned int v5 = v8 - 87;
        goto LABEL_11;
      }
      *(unsigned char *)(v7 + CFRelease((char *)this - 24) = 0;
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
        goto LABEL_11;
      }
LABEL_12:
      if (v6 >= a5) {
        goto LABEL_15;
      }
    }
    unsigned int v5 = v8 - 48;
LABEL_11:
    **(void **)(a1 + 48) = 16 * **(void **)(a1 + 48) + v5;
    ++v6;
    goto LABEL_12;
  }
  unint64_t v6 = 0;
LABEL_15:
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v6;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t ___ZN10HTTPEngine18_chunkedReadHeaderEv_block_invoke(uint64_t a1, CFIndex a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(NSObject **)(v6 + 192);
  if (v7)
  {
    size_t size = dispatch_data_get_size(*(dispatch_data_t *)(v6 + 192));
    uint64_t v9 = *(void *)(a1 + 40);
    if (size != v9 || v9 != 2)
    {
      if (size == v9) {
        goto LABEL_15;
      }
LABEL_9:
      unsigned int v12 = a3;
      goto LABEL_22;
    }
    __CFN_ConnectionMetrics buffer_ptr = 0;
    map = dispatch_data_create_map(v7, (const void **)&buffer_ptr, 0);
    if (!map) {
      __assert_rtn("_chunkedReadHeader_block_invoke", "HTTPEngine.cpp", 2731, "bufContainer");
    }
    if (*(unsigned char *)buffer_ptr == 13)
    {
      int v14 = *((unsigned __int8 *)buffer_ptr + 1);
      dispatch_release(map);
      if (v14 == 10)
      {
        *(void *)(v6 + 176) = 0;
        *(void *)(v6 + 184) = 0;
        *(_DWORD *)(v6 + 32) |= 0x8000u;
        LODWORD(v1HTTPServerConnection::canceled_onQueue(this - 1) = 1;
        goto LABEL_16;
      }
    }
    else
    {
      dispatch_release(map);
    }
LABEL_15:
    LODWORD(v1HTTPServerConnection::canceled_onQueue(this - 1) = 0;
    goto LABEL_16;
  }
  uint64_t v11 = *(void *)(a1 + 40);
  if (v11) {
    goto LABEL_9;
  }
LABEL_16:
  if (a3) {
    LODWORD(v1HTTPServerConnection::canceled_onQueue(this - 1) = 1;
  }
  BOOL v15 = v11 == 0;
  if (!v11) {
    a2 = 4;
  }
  unsigned int v12 = -1;
  if (!v15) {
    unsigned int v12 = a3;
  }
LABEL_22:
  v18.domain = a2;
  *(void *)&v18.CFErrorRef error = a3 & 0xFFFFFFFF00000000 | v12;
  return HTTPEngine::_chunkedParseHeader(*(HTTPEngine **)(a1 + 48), v18);
}

void HTTPEngine::_chunkedReadTrailerDoParse(uint64_t a1, HTTPBodyData ***a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v10 = *(NSObject **)(a1 + 192);
  if (!v10)
  {
    uint64_t v13 = 0xFFFFFFFFLL;
    uint64_t v14 = 4;
    if a4 == 57 || (a5) {
      goto LABEL_27;
    }
    if (a4) {
      goto LABEL_25;
    }
    uint64_t v26 = 0;
    uint64_t v27 = &v26;
    uint64_t v28 = 0x2020000000;
    uint64_t v29 = 0;
    goto LABEL_23;
  }
  size_t size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 192));
  if (a4 == 57) {
    char v12 = 1;
  }
  else {
    char v12 = a5;
  }
  if (!size && (v12 & 1) != 0)
  {
    uint64_t v13 = 0xFFFFFFFFLL;
    uint64_t v14 = 4;
LABEL_27:
    CFStreamError v18 = *a2;
    uint64_t v19 = (uint64_t)a2[1];
    v23[0] = v18;
    v23[1] = (HTTPBodyData **)v19;
    if (v19) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
    }
    HTTPEngine::_chunkedReadTrailerFinish((HTTPMessage **)a1, v23, v14, v13);
    goto LABEL_30;
  }
  if (size) {
    BOOL v15 = 1;
  }
  else {
    BOOL v15 = a4 == 0;
  }
  if (v15)
  {
    uint64_t v26 = 0;
    uint64_t v27 = &v26;
    uint64_t v28 = 0x2020000000;
    uint64_t v29 = 0;
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 3321888768;
    applier[2] = ___ZN10HTTPEngine26_chunkedReadTrailerDoParseENSt3__110shared_ptrI19HTTPResponseMessageEE13CFStreamErrorb_block_invoke;
    applier[3] = &unk_1ECFA8FF0;
    uint64_t v16 = (std::__shared_weak_count *)a2[1];
    applier[5] = *a2;
    CFStringRef v25 = v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    applier[4] = &v26;
    BOOL v17 = dispatch_data_apply(v10, applier);
    HTTPEngine::_readBufferConsume((HTTPEngine *)a1, v27[3]);
    if (v25) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v25);
    }
    if (v17)
    {
      a4 = 0;
      a3 = 0;
LABEL_24:
      _Block_object_dispose(&v26, 8);
      goto LABEL_25;
    }
LABEL_23:
    a3 = 4;
    a4 = 0xFFFFFFFFLL;
    goto LABEL_24;
  }
LABEL_25:
  if (a4)
  {
    uint64_t v14 = a3;
    uint64_t v13 = a4;
    goto LABEL_27;
  }
  uint64_t v20 = *a2;
  if ((*a2)[11])
  {
    uint64_t v19 = (uint64_t)a2[1];
    v22[0] = (uint64_t)v20;
    v22[1] = v19;
    if (v19) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
    }
    HTTPEngine::_chunkedReadTrailerDoRead((void *)a1, v22);
  }
  else
  {
    uint64_t v19 = (uint64_t)a2[1];
    v21[0] = v20;
    v21[1] = (HTTPBodyData **)v19;
    if (v19) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
    }
    HTTPEngine::_chunkedReadTrailerFinish((HTTPMessage **)a1, v21, a3, a4);
  }
LABEL_30:
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v19);
  }
}

void sub_1842CCD7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  }
  _Unwind_Resume(exception_object);
}

void HTTPEngine::_chunkedReadTrailerDoRead(void *a1, uint64_t *a2)
{
  if (a1[24]) {
    __assert_rtn("_chunkedReadTrailerDoRead", "HTTPEngine.cpp", 2813, "!_inData");
  }
  int64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    unsigned int v5 = std::__shared_weak_count::lock(v4);
    if (v5) {
      uint64_t v6 = a1[5];
    }
    else {
      uint64_t v6 = 0;
    }
  }
  else
  {
    uint64_t v6 = 0;
    unsigned int v5 = 0;
  }
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3321888768;
  v8[2] = ___ZN10HTTPEngine25_chunkedReadTrailerDoReadENSt3__110shared_ptrI19HTTPResponseMessageEE_block_invoke;
  void v8[3] = &__block_descriptor_64_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE48c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE_e16_v28__0___qi_8B24l;
  v8[4] = v6;
  uint64_t v9 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::__shared_weak_count *)a2[1];
  uint64_t v10 = *a2;
  uint64_t v11 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HTTPEngine::_readBlob((uint64_t)a1, 0x4000, (uint64_t)v8);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_1842CCEE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v16);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN10HTTPEngine25_chunkedReadTrailerDoReadENSt3__110shared_ptrI19HTTPResponseMessageEE_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a1[4];
  uint64_t v6 = (std::__shared_weak_count *)a1[7];
  v7[0] = a1[6];
  v7[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  HTTPEngine::_chunkedReadTrailerDoParse(v5, v7, a2, a3, a4);
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
}

void sub_1842CCF98(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE48c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(uint64_t a1)
{
  int64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE48c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

BOOL ___ZN10HTTPEngine26_chunkedReadTrailerDoParseENSt3__110shared_ptrI19HTTPResponseMessageEE13CFStreamErrorb_block_invoke(uint64_t a1, int a2, int a3, const char *a4, CFIndex a5)
{
  int appended = HTTPMessage::appendBytes(*(HTTPMessage **)(a1 + 40), a4, a5);
  if (appended) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += a5;
  }
  return appended != 0;
}

void HTTPEngine::_chunkedReadTrailerFinish(HTTPMessage **this, HTTPBodyData ***a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    HTTPEngine::_deliverBodyBytes((HTTPEngine *)this, 0, a3, a4, 0);
  }
  else
  {
    HTTPEngine::_readBufferCaptureBody((uint64_t)this, *a2);
    CFMutableDictionaryRef v8 = HTTPMessage::copyAllHeaderFields((HTTPMessage *)*a2);
    HTTPMessage::setTrailerFields(this[16], v8);
    HTTPEngine::_deliverBodyBytes((HTTPEngine *)this, 0, a3, a4 & 0xFFFFFFFF00000000, 1);
    if (v8)
    {
      CFRelease(v8);
    }
  }
}

void sub_1842CD158(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_40c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void HTTPEngine::suspendReads(HTTPEngine *this, int a2)
{
  int v3 = *((_DWORD *)this + 8);
  if (a2)
  {
    *((_DWORD *)this + 8) = v3 | 0x400;
  }
  else
  {
    *((_DWORD *)this + 8) = v3 & 0xFFFFFBFF;
    if ((v3 & 0x400) != 0)
    {
      if ((v3 & 0x800) != 0)
      {
        *((_DWORD *)this + 8) = v3 & 0xFFFFF3FF;
        int64_t v4 = (std::__shared_weak_count *)*((void *)this + 6);
        if (v4)
        {
          uint64_t v5 = std::__shared_weak_count::lock(v4);
          if (v5) {
            uint64_t v6 = *((void *)this + 5);
          }
          else {
            uint64_t v6 = 0;
          }
        }
        else
        {
          uint64_t v6 = 0;
          uint64_t v5 = 0;
        }
        uint64_t v7 = *((void *)this + 9);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3321888768;
        block[2] = ___ZN10HTTPEngine12suspendReadsEb_block_invoke;
        block[3] = &__block_descriptor_48_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
        block[4] = v6;
        BOOL v15 = v5;
        if (v5) {
          atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        dispatch_async(v7, block);
        if (v15) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v15);
        }
        if (v5) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v5);
        }
      }
      if ((v3 & 0x1000) != 0)
      {
        *((_DWORD *)this + 8) &= ~0x1000u;
        CFMutableDictionaryRef v8 = (std::__shared_weak_count *)*((void *)this + 6);
        if (v8)
        {
          uint64_t v9 = std::__shared_weak_count::lock(v8);
          if (v9) {
            uint64_t v10 = *((void *)this + 5);
          }
          else {
            uint64_t v10 = 0;
          }
        }
        else
        {
          uint64_t v10 = 0;
          uint64_t v9 = 0;
        }
        uint64_t v11 = *((void *)this + 9);
        v12[0] = MEMORY[0x1E4F143A8];
        v12[1] = 3321888768;
        v12[2] = ___ZN10HTTPEngine12suspendReadsEb_block_invoke_16;
        v12[3] = &__block_descriptor_48_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
        v12[4] = v10;
        uint64_t v13 = v9;
        if (v9) {
          atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        dispatch_async(v11, v12);
        if (v13) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v13);
        }
        if (v9) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v9);
        }
      }
    }
  }
}

void ___ZN10HTTPEngine12suspendReadsEb_block_invoke(uint64_t a1)
{
}

void ___ZN10HTTPEngine12suspendReadsEb_block_invoke_16(uint64_t a1)
{
}

void ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke(uint64_t a1)
{
}

void ___ZN10HTTPEngine12writeRequestENSt3__110shared_ptrI18HTTPRequestMessageEENS0_8weak_ptrINS_23HTTPRequestBodyDelegateEEEU13block_pointerFv13CFStreamErrorE_block_invoke_2(uint64_t a1)
{
}

void ___ZN10HTTPEngine22_100ContinueTimerStartEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(v1 + 48);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int64_t v4 = v3;
      uint64_t v5 = *(HTTPEngine **)(v1 + 40);
      if (v5)
      {
        if ((*((unsigned char *)v5 + 32) & 0x20) == 0) {
          __assert_rtn("_100ContinueTimerFired", "HTTPEngine.cpp", 3211, "false");
        }
        HTTPEngine::_100ContinueTimerCancel(v5);
        *((_DWORD *)v5 + 8) &= ~0x20u;
        HTTPEngine::_writeBodyStart(v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void sub_1842CD428(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void HTTPEngine::suspendWrites(HTTPEngine *this, int a2)
{
  int v3 = *((_DWORD *)this + 8);
  if (a2)
  {
    *((_DWORD *)this + 8) = v3 | 0x2000000;
  }
  else
  {
    *((_DWORD *)this + 8) = v3 & 0xFDFFFFFF;
    if ((~v3 & 0x6000000) == 0)
    {
      *((_DWORD *)this + 8) = v3 & 0xF9FFFFFF;
      int64_t v4 = (std::__shared_weak_count *)*((void *)this + 6);
      if (v4)
      {
        uint64_t v5 = std::__shared_weak_count::lock(v4);
        if (v5) {
          uint64_t v6 = *((void *)this + 5);
        }
        else {
          uint64_t v6 = 0;
        }
      }
      else
      {
        uint64_t v6 = 0;
        uint64_t v5 = 0;
      }
      uint64_t v7 = *((void *)this + 9);
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 3321888768;
      v8[2] = ___ZN10HTTPEngine13suspendWritesEb_block_invoke;
      void v8[3] = &__block_descriptor_48_e8_32c38_ZTSNSt3__110shared_ptrI10HTTPEngineEE_e5_v8__0l;
      v8[4] = v6;
      uint64_t v9 = v5;
      if (v5) {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      dispatch_async(v7, v8);
      if (v9) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v9);
      }
      if (v5) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v5);
      }
    }
  }
}

void ___ZN10HTTPEngine13suspendWritesEb_block_invoke(uint64_t a1)
{
}

void AuthBrokerAgentClient::cachedProxyCredentialForProtectionSpace(AuthBrokerAgentClient *this, _CFURLProtectionSpace *a2)
{
  *(void *)this = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&_LocalCredCacheLock);
  uint64_t LocalCredCache = _GetLocalCredCache();
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(LocalCredCache + 8), a2);
  uint64_t v6 = Value;
  if (Value) {
    (*(void (**)(const void *))(*(void *)Value + 40))(Value);
  }
  *(void *)this = v6;

  os_unfair_lock_unlock((os_unfair_lock_t)&_LocalCredCacheLock);
}

void sub_1842CD5D4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&_LocalCredCacheLock);
  void *v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t _GetLocalCredCache(void)
{
  if (!_LocalCredCache) {
    operator new();
  }
  return _LocalCredCache;
}

void sub_1842CD680(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void _AuthBrokerSetCachedCredential(_CFURLProtectionSpace *a1, NetworkProxyCredential *a2)
{
  os_unfair_lock_lock((os_unfair_lock_t)&_LocalCredCacheLock);
  uint64_t LocalCredCache = _GetLocalCredCache();
  if (a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(LocalCredCache + 8), a1, a2);
  }
  else {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(LocalCredCache + 8), a1);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&_LocalCredCacheLock);
}

void sub_1842CD718(_Unwind_Exception *a1)
{
}

char *AuthBrokerAgentClient::AuthBrokerIsAvailable(AuthBrokerAgentClient *this)
{
  if (_AuthBrokerGetServiceName(void)::onceToken != -1) {
    dispatch_once(&_AuthBrokerGetServiceName(void)::onceToken, &__block_literal_global_20281);
  }
  dispatch_data_t result = (char *)[(id)_AuthBrokerGetServiceName(void)::serviceName UTF8String];
  if (result) {
    return (char *)(__CFNIsMachServiceReachable(result) != 0);
  }
  return result;
}

void AuthBrokerAgentClient::FetchProxyCredentials(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 72);
  if (v1) {
    CFRetain(v1);
  }
  operator new();
}

void sub_1842CE01C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_8(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  int64_t v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v9 = *(void *)(a1 + 40);
    if (_AuthBrokerGetServiceName(void)::onceToken != -1)
    {
      uint64_t v10 = *(void *)(a1 + 40);
      dispatch_once(&_AuthBrokerGetServiceName(void)::onceToken, &__block_literal_global_20281);
      uint64_t v9 = v10;
    }
    *(_DWORD *)int buf = 138543874;
    uint64_t v12 = v9;
    __int16 v13 = 2112;
    uint64_t v14 = _AuthBrokerGetServiceName(void)::serviceName;
    __int16 v15 = 2112;
    uint64_t v16 = a2;
    _os_log_error_impl(&dword_184085000, v4, OS_LOG_TYPE_ERROR, "%{public}@ failed to connect to %@ XPC error %@", buf, 0x20u);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  if (v5)
  {
    uint64_t v6 = *(void (**)(void *, void))(v5 + 8);
    uint64_t v7 = *(void *)(v5 + 16);
    CFMutableDictionaryRef v8 = (void *)(v5 + (v7 >> 1));
    if (v7) {
      uint64_t v6 = *(void (**)(void *, void))(*v8 + v6);
    }
    v6(v8, 0);
  }
  [*(id *)(a1 + 32) invalidate];
}

void ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_10(uint64_t a1, const __CFData *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v18 = 0;
    CFErrorRef error = 0;
    uint64_t v14 = MEMORY[0x1E4F143A8];
    uint64_t v15 = 3221225472;
    uint64_t v16 = ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_2;
    uint64_t v17 = &__block_descriptor_40_e5_v8__0l;
    CFDictionaryRef v3 = (const __CFDictionary *)CFPropertyListCreateWithData(0, a2, 0, 0, &error);
    if (error)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      int64_t v4 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = *(void *)(a1 + 40);
        *(_DWORD *)int buf = 138543618;
        uint64_t v21 = v13;
        __int16 v22 = 2112;
        CFErrorRef v23 = error;
        _os_log_error_impl(&dword_184085000, v4, OS_LOG_TYPE_ERROR, "%{public}@ failed to deserialize data error %@", buf, 0x16u);
      }
      uint64_t v5 = 0;
    }
    else
    {
      uint64_t v5 = CFAllocatorAllocate(0, 56, 0);
      void v5[6] = 0;
      *((_OWORD *)v5 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
      *((_OWORD *)v5 + 2) = 0u;
      *(_OWORD *)uint64_t v5 = 0u;
      NetworkProxyCredential::NetworkProxyCredential((NetworkProxyCredential *)v5, 0, v3);
      uint64_t v6 = *(_CFURLProtectionSpace **)(a1 + 56);
      if (v6) {
        _AuthBrokerSetCachedCredential(v6, (NetworkProxyCredential *)v5);
      }
    }
    if (v3) {
      CFRelease(v3);
    }
    v16((uint64_t)&v14);
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  uint64_t v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 40);
    *(_DWORD *)int buf = 138543618;
    uint64_t v21 = v8;
    __int16 v22 = 2048;
    CFErrorRef v23 = (CFErrorRef)v5;
    _os_log_impl(&dword_184085000, v7, OS_LOG_TYPE_DEFAULT, "%{public}@ done fetching proxy credential %p", buf, 0x16u);
  }
  uint64_t v9 = *(void *)(a1 + 72);
  if (v9)
  {
    uint64_t v10 = *(void (**)(void *, void *))(v9 + 8);
    uint64_t v11 = *(void *)(v9 + 16);
    uint64_t v12 = (void *)(v9 + (v11 >> 1));
    if (v11) {
      uint64_t v10 = *(void (**)(void *, void *))(*v12 + v10);
    }
    v10(v12, v5);
  }
  if (v5) {
    (*(void (**)(void *))(*v5 + 48))(v5);
  }
  objc_msgSend(*(id *)(a1 + 32), "invalidate", v14, v15);
}

void sub_1842CE510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void (*a11)(uint64_t *))
{
  if (v11) {
    CFRelease(v11);
  }
  a11(&a9);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_40c39_ZTSNSt3__110shared_ptrIK10__CFStringEE56c49_ZTSNSt3__110shared_ptrI21_CFURLProtectionSpaceEE72c53_ZTS18SmartBlockWithArgsIJP22NetworkProxyCredentialEE(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  CFDictionaryRef v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  int64_t v4 = (std::__shared_weak_count *)a1[6];
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void *__copy_helper_block_e8_40c39_ZTSNSt3__110shared_ptrIK10__CFStringEE56c49_ZTSNSt3__110shared_ptrI21_CFURLProtectionSpaceEE72c53_ZTS18SmartBlockWithArgsIJP22NetworkProxyCredentialEE(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = a2[10];
  result[9] = a2[9];
  result[10] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN21AuthBrokerAgentClient21FetchProxyCredentialsEP33NetworkProxyAuthorizationElements18SmartBlockWithArgsIJP22NetworkProxyCredentialEE_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void __destroy_helper_block_e8_40c39_ZTSNSt3__110shared_ptrIK10__CFStringEE56c53_ZTS18SmartBlockWithArgsIJP22NetworkProxyCredentialEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_e8_40c39_ZTSNSt3__110shared_ptrIK10__CFStringEE56c53_ZTS18SmartBlockWithArgsIJP22NetworkProxyCredentialEE(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void CFNetworkReadStream::_readStreamClientCallBack(CFNetworkReadStream *this, __CFReadStream *a2)
{
}

uint64_t CFNetworkReadStream::_streamImpl_SetProperty(CFNetworkReadStream *this, __CFReadStream *a2, const __CFString *a3, const void *a4)
{
  return 0;
}

uint64_t CFNetworkReadStream::_streamImpl_CopyProperty(CFNetworkReadStream *this, __CFReadStream *a2, const __CFString *a3)
{
  return 0;
}

uint64_t CFNetworkReadStream::_streamImpl_CanRead(CFNetworkReadStream *this, __CFReadStream *a2)
{
  return 0;
}

uint64_t CFNetworkReadStream::_streamImpl_Read(CFNetworkReadStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  return -1;
}

uint64_t CFNetworkReadStream::_streamImpl_OpenCompleted(CFNetworkReadStream *this, __CFReadStream *a2, CFStreamError *a3)
{
  return 0;
}

uint64_t CFNetworkReadStream::_streamImpl_Open(CFNetworkReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a4 = 0;
  return 0;
}

CFStringRef CFNetworkReadStream::copyDescription(CFNetworkReadStream *this, CFTypeRef cf)
{
  CFAllocatorRef v3 = CFGetAllocator(cf);
  return CFStringCreateWithFormat(v3, 0, @"<CFNetworkReadStream@%p>", this);
}

void CFNetworkReadStream::~CFNetworkReadStream(CFNetworkReadStream *this)
{
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = 0;
  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECF9B550;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = 0;
}

uint64_t CFNetworkReadStream::httpStreamUnschedule(CFNetworkReadStream *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkReadStream *, __CFReadStream *, __CFRunLoop *))a4->isa
          + 11))(a4, this, a2, a3);
}

uint64_t CFNetworkReadStream::httpStreamSchedule(CFNetworkReadStream *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkReadStream *, __CFReadStream *, __CFRunLoop *))a4->isa
          + 10))(a4, this, a2, a3);
}

uint64_t CFNetworkReadStream::httpStreamSetProperty(CFNetworkReadStream *this, __CFReadStream *a2, const __CFString *a3, const void *a4, void *a5)
{
  return (*(uint64_t (**)(const void *, CFNetworkReadStream *, __CFReadStream *, const __CFString *))(*(void *)a4 + 72))(a4, this, a2, a3);
}

uint64_t CFNetworkReadStream::httpStreamCopyProperty(CFNetworkReadStream *this, __CFReadStream *a2, const __CFString *a3, void *a4)
{
  return (*((uint64_t (**)(const __CFString *, CFNetworkReadStream *, __CFReadStream *))a3->isa + 8))(a3, this, a2);
}

uint64_t CFNetworkReadStream::httpStreamClose(CFNetworkReadStream *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFReadStream *, CFNetworkReadStream *))(*(void *)a2 + 56))(a2, this);
}

uint64_t CFNetworkReadStream::httpStreamCanRead(CFNetworkReadStream *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFReadStream *, CFNetworkReadStream *))(*(void *)a2 + 48))(a2, this);
}

uint64_t CFNetworkReadStream::httpStreamRead(CFNetworkReadStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6, void *a7)
{
  if (a5) {
    LOBYTE(a5->domain) = 0;
  }
  return (*(uint64_t (**)(unsigned __int8 *, CFNetworkReadStream *, __CFReadStream *, unsigned __int8 *, uint64_t))(*(void *)a6 + 40))(a6, this, a2, a3, a4);
}

uint64_t CFNetworkReadStream::httpStreamOpenCompleted(CFNetworkReadStream *this, __CFReadStream *a2, CFStreamError *a3, void *a4)
{
  return (*(uint64_t (**)(CFStreamError *, CFNetworkReadStream *, __CFReadStream *))(a3->domain + 32))(a3, this, a2);
}

uint64_t CFNetworkReadStream::httpStreamOpen(CFNetworkReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(unsigned __int8 *, CFNetworkReadStream *, __CFReadStream *, CFStreamError *))(*(void *)a4 + 24))(a4, this, a2, a3);
}

uint64_t CFNetworkReadStream::httpStreamCopyDescription(CFNetworkReadStream *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(__CFReadStream *, CFNetworkReadStream *))(*(void *)a2 + 16))(a2, this);
}

void CFNetworkReadStream::httpStreamFinalize(CFNetworkReadStream *this, __CFReadStream *a2, void *a3)
{
  if (this) {
    CFAllocatorRef v4 = CFGetAllocator(this);
  }
  else {
    CFAllocatorRef v4 = 0;
  }
  (**(void (***)(__CFReadStream *))a2)(a2);

  CFAllocatorDeallocate(v4, a2);
}

uint64_t CFNetworkReadStream::_createStream(CFNetworkReadStream *this, uint64_t (**a2)(__CFReadStream *, CFNetworkReadStream *), void *a3)
{
  return a2[2]((__CFReadStream *)a2, this);
}

CFStringRef _CFNetworkReadStream_copyDesc(void *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"WHAT: %p", a1);
}

void _CFNetworkReadStream_release(CFTypeRef *a1)
{
}

CFTypeRef *_CFNetworkReadStream_retain(CFTypeRef *a1)
{
  return a1;
}

void CFNetworkReadStream::_readStreamClientCallBackCallBack(CFNetworkReadStream *this, __CFReadStream *a2, CFTypeRef *a3, void *a4)
{
  if (this && a3)
  {
    uint64_t v7 = (void *)MEMORY[0x18531D6D0]();
    CFRetain(a3[1]);
    (*((void (**)(CFTypeRef *, CFNetworkReadStream *, __CFReadStream *))*a3 + 12))(a3, this, a2);
    CFRelease(a3[1]);
  }
}

void non-virtual thunk to'BinaryCookieStorage::~BinaryCookieStorage(BinaryCookieStorage *this)
{
  uint64_t v2 = (char *)this - 24;
  DiskCookieStorage::~DiskCookieStorage((BinaryCookieStorage *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  DiskCookieStorage::~DiskCookieStorage((BinaryCookieStorage *)((char *)this - 24));
}

CFErrorRef BinaryCookieStorage::readCookiesFromStream(BinaryCookieStorage *this, CFReadStreamRef stream, MemoryCookies *a3, const __CFData **a4)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = (const __CFAllocator *)*((void *)this + 1);
  *a4 = 0;
  CFErrorRef Entirely = readEntirely(stream, buffer, 8);
  if (!Entirely)
  {
    if (*(_DWORD *)buffer != 1802465123) {
      return createParseError(v4, "bad signature");
    }
    if (!(bswap32(v9) >> 27)) {
      operator new[]();
    }
    return createParseError(v4, "bad count");
  }
  return Entirely;
}

void sub_1842CF0A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52)
{
  if (a52 && a52 != (void *)a11) {
    free(a52);
  }
  int v53 = (void *)STACK[0x298];
  if (STACK[0x298])
  {
    if (v53 != (void *)a12) {
      free(v53);
    }
  }
  _Unwind_Resume(a1);
}

CFErrorRef readEntirely(CFReadStreamRef stream, UInt8 *buffer, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  CFAllocatorRef v3 = buffer;
  uint64_t v5 = &buffer[a3];
  while (1)
  {
    CFIndex v6 = CFReadStreamRead(stream, v3, v5 - v3);
    if (!v6) {
      break;
    }
    if (v6 == -1)
    {
      return CFReadStreamCopyError(stream);
    }
    v3 += v6;
    if (v3 >= v5) {
      return 0;
    }
  }
  CFAllocatorRef v8 = CFGetAllocator(stream);

  return CFErrorCreate(v8, @"kCFErrorDomainCFNetwork", -4000, 0);
}

CFErrorRef createParseError(const __CFAllocator *a1, const char *a2)
{
  CFStringRef v3 = CFStringCreateWithCString(a1, a2, 0x8000100u);
  MutableDictionary = cfTypeCreateMutableDictionary(a1, *MEMORY[0x1E4F1D140], v3, 0, 0);
  CFRelease(v3);
  CFErrorRef v5 = CFErrorCreate(a1, @"kCFErrorDomainCFNetwork", -4000, MutableDictionary);
  CFRelease(MutableDictionary);
  return v5;
}

void BinaryCookieStorage::writeCookiesToStream(BinaryCookieStorage *this, const MemoryCookies *a2, __CFWriteStream *a3, const __CFData *a4)
{
}

void sub_1842CF61C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *))
{
}

void ___ZN19BinaryCookieStorage20writeCookiesToStreamEPK13MemoryCookiesP15__CFWriteStreamPK8__CFData_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

CFErrorRef writeEntirelyWithBuffer(CFWriteStreamRef stream, UInt8 *buffer, uint64_t a3, CFDataRef theData)
{
  CFAllocatorRef v4 = buffer;
  if (theData)
  {
    if (a3 >= 1)
    {
      uint64_t v7 = &buffer[a3];
      do
      {
        CFIndex v8 = v7 - v4;
        if (v7 - v4 >= 0x4000 - CFDataGetLength(theData)) {
          CFIndex v8 = 0x4000 - CFDataGetLength(theData);
        }
        CFDataAppendBytes(theData, v4, v8);
        if (CFDataGetLength(theData) == 0x4000)
        {
          BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
          CFErrorRef result = writeEntirely(stream, BytePtr, 0x4000);
          if (result) {
            return result;
          }
          CFDataSetLength(theData, 0);
        }
        v4 += v8;
      }
      while (v4 < v7);
    }
    return 0;
  }
  else
  {
    return writeEntirely(stream, buffer, a3);
  }
}

CFErrorRef writeEntirely(CFWriteStreamRef stream, UInt8 *buffer, uint64_t a3)
{
  if (a3 < 1) {
    return 0;
  }
  CFStringRef v3 = buffer;
  CFErrorRef v5 = &buffer[a3];
  while (1)
  {
    CFIndex v6 = CFWriteStreamWrite(stream, v3, v5 - v3);
    if (!v6) {
      break;
    }
    if (v6 == -1)
    {
      return CFWriteStreamCopyError(stream);
    }
    v3 += v6;
    if (v3 >= v5) {
      return 0;
    }
  }
  CFAllocatorRef v8 = CFGetAllocator(stream);

  return CFErrorCreate(v8, @"kCFErrorDomainCFNetwork", -4000, 0);
}

CFStringRef BinaryCookieStorage::copyDebugDescLocked(CFAllocatorRef *this)
{
  CFStringRef v2 = DiskCookieStorage::copyDebugDescLocked((DiskCookieStorage *)this);
  CFStringRef v3 = CFStringCreateWithFormat(this[1], 0, @"Binary{ %@ }", v2);
  if (v2) {
    CFRelease(v2);
  }
  return v3;
}

void BinaryCookieStorage::~BinaryCookieStorage(BinaryCookieStorage *this)
{
  DiskCookieStorage::~DiskCookieStorage(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void non-virtual thunk to'URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken(URLCredentialXMobileMeAuthToken *this)
{
}

{
  URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken((URLCredentialXMobileMeAuthToken *)((char *)this - 24));
}

{
  URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken((URLCredentialXMobileMeAuthToken *)((char *)this - 8));
}

{
  URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken((URLCredentialXMobileMeAuthToken *)((char *)this - 8));
}

void URLCredentialXMobileMeAuthToken::~URLCredentialXMobileMeAuthToken(URLCredentialXMobileMeAuthToken *this)
{
  *(void *)this = &unk_1ECFA5080;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA5128;
  *((void *)this + 3) = &unk_1ECFA5158;
  uint64_t v2 = (const void *)*((void *)this + 8);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 9);
  if (v3) {
    CFRelease(v3);
  }
  CFAllocatorRef v4 = (const void *)*((void *)this + 10);
  if (v4) {
    CFRelease(v4);
  }

  URLCredential::~URLCredential(this);
}

void sub_1842CF970(_Unwind_Exception *a1)
{
  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'URLCredentialXMobileMeAuthToken::serializeToPropertyList(URLCredentialXMobileMeAuthToken *this, SerializableArchive **a2)
{
  return 1;
}

uint64_t URLCredentialXMobileMeAuthToken::serializeToPropertyList(URLCredentialXMobileMeAuthToken *this, SerializableArchive **a2)
{
  URLCredential::serializeToPropertyList(this, a2);
  CFAllocatorRef v4 = (const void *)*((void *)this + 8);
  SerializableArchive::assertEmpty(*a2, @"realm");
  if (v4) {
    CFDictionarySetValue(*a2, @"realm", v4);
  }
  CFErrorRef v5 = (const void *)*((void *)this + 9);
  SerializableArchive::assertEmpty(*a2, @"appleid");
  if (v5) {
    CFDictionarySetValue(*a2, @"appleid", v5);
  }
  CFIndex v6 = (const void *)*((void *)this + 10);
  SerializableArchive::assertEmpty(*a2, @"password");
  if (v6) {
    CFDictionarySetValue(*a2, @"password", v6);
  }
  uint64_t v7 = (const void *)*((void *)this + 11);
  SerializableArchive::assertEmpty(*a2, @"valid");
  if (v7) {
    CFDictionarySetValue(*a2, @"valid", v7);
  }
  return 1;
}

BOOL non-virtual thunk to'URLCredentialXMobileMeAuthToken::initializeFromPropertyList(URLCredentialXMobileMeAuthToken *this, CFDictionaryRef *a2)
{
  return URLCredentialXMobileMeAuthToken::initializeFromPropertyList((URLCredentialXMobileMeAuthToken *)((char *)this - 8), a2);
}

BOOL URLCredentialXMobileMeAuthToken::initializeFromPropertyList(URLCredentialXMobileMeAuthToken *this, CFDictionaryRef *a2)
{
  BOOL result = URLCredential::initializeFromPropertyList(this, a2);
  if (result)
  {
    CFNumberRef Value = CFDictionaryGetValue(*a2, @"realm");
    if (Value) {
      CFNumberRef Value = CFRetain(Value);
    }
    *((void *)this + 8) = Value;
    CFIndex v6 = CFDictionaryGetValue(*a2, @"appleid");
    if (v6) {
      CFIndex v6 = CFRetain(v6);
    }
    *((void *)this + 9) = v6;
    uint64_t v7 = CFDictionaryGetValue(*a2, @"password");
    if (v7) {
      uint64_t v7 = CFRetain(v7);
    }
    *((void *)this + 10) = v7;
    CFAllocatorRef v8 = CFDictionaryGetValue(*a2, @"valid");
    if (v8) {
      CFAllocatorRef v8 = CFRetain(v8);
    }
    *((void *)this + 1HTTPServerConnection::canceled_onQueue(this - 1) = v8;
    return 1;
  }
  return result;
}

uint64_t URLCredentialXMobileMeAuthToken::isTokenValid(CFBooleanRef *this)
{
  return CFBooleanGetValue(this[11]);
}

BOOL URLCredentialXMobileMeAuthToken::containsPassword(URLCredentialXMobileMeAuthToken *this)
{
  return *((void *)this + 10) != 0;
}

CFTypeRef URLCredentialXMobileMeAuthToken::copyPassword(URLCredentialXMobileMeAuthToken *this)
{
  if (!*((void *)this + 10)) {
    return 0;
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(*((CFTypeRef *)this + 10))) {
    return 0;
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 10);
  if (!v3) {
    return 0;
  }

  return CFRetain(v3);
}

uint64_t URLCredentialXMobileMeAuthToken::getPassword(URLCredentialXMobileMeAuthToken *this)
{
  if (*((void *)this + 10) && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 10)))) {
    return *((void *)this + 10);
  }
  else {
    return 0;
  }
}

uint64_t URLCredentialXMobileMeAuthToken::getUserName(URLCredentialXMobileMeAuthToken *this)
{
  if (*((void *)this + 9) && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 9)))) {
    return *((void *)this + 9);
  }
  else {
    return 0;
  }
}

CFTypeRef URLCredentialXMobileMeAuthToken::copyStorageNameForCredentialType(URLCredentialXMobileMeAuthToken *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 9);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

CFHashCode URLCredentialXMobileMeAuthToken::calcHash(URLCredentialXMobileMeAuthToken *this, uint64_t a2)
{
  uint64_t v2 = a2;
  CFAllocatorRef v3 = (const void *)*((void *)this + 9);
  if (v3) {
    return CFHash(v3) ^ a2;
  }
  return v2;
}

uint64_t URLCredentialXMobileMeAuthToken::copy(const __CFString **this)
{
  CFGetAllocator(this - 2);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + ++*(void *)(this + 64) = 0u;
  *(_OWORD *)(Instance + ++*(void *)(this + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
  *(void *)(Instance + 32) = &gConstantCFStringValueTable[3773];
  *(_DWORD *)(Instance + 48) = 4;
  *(unsigned char *)(Instance + ++*(void *)(this + 64) = 0;
  *(void *)(Instance + 72) = 0;
  *(void *)(Instance + 56) = 0;
  *(void *)(Instance + CFRetain((char *)this - 16) = &unk_1ECFA5080;
  *(void *)(Instance + CFRelease((char *)this - 24) = &unk_1ECFA5128;
  *(void *)(Instance + 40) = &unk_1ECFA5158;
  URLCredentialXMobileMeAuthToken::initialize((URLCredentialXMobileMeAuthToken *)(Instance + 16), this[9], this[10], this[8]);
  return Instance;
}

uint64_t URLCredentialXMobileMeAuthToken::initialize(URLCredentialXMobileMeAuthToken *this, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  uint64_t result = 0;
  *((_DWORD *)this + 9) = 2;
  CFIndex v6 = (void *)MEMORY[0x1E4F1CFC8];
  if (a2 && a4)
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(a2)) {
      return 0;
    }
    CFTypeID v11 = CFStringGetTypeID();
    if (v11 != CFGetTypeID(a4)) {
      return 0;
    }
    CFAllocatorRef v12 = CFGetAllocator((char *)this - 16);
    *((void *)this + 9) = CFStringCreateCopy(v12, a2);
    CFAllocatorRef v13 = CFGetAllocator((char *)this - 16);
    *((void *)this + 8) = CFStringCreateCopy(v13, a4);
    if (a3 && (CFTypeID v14 = CFStringGetTypeID(), v14 == CFGetTypeID(a3)))
    {
      CFAllocatorRef v15 = CFGetAllocator((char *)this - 16);
      CFStringRef Copy = CFStringCreateCopy(v15, a3);
    }
    else
    {
      CFStringRef Copy = 0;
    }
    *((void *)this + 10) = Copy;
    uint64_t result = 1;
    CFIndex v6 = (void *)MEMORY[0x1E4F1CFD0];
  }
  *((void *)this + 1HTTPServerConnection::canceled_onQueue(this - 1) = *v6;
  return result;
}

CFStringRef URLCredentialXMobileMeAuthToken::copyDebugDesc(URLCredentialXMobileMeAuthToken *this)
{
  uint64_t v2 = (char *)this - 16;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, @"<CFURLCredential %p>{appleID = %@, password = %@ realuint64_t m = %@, persistence = %d}", v2, *((void *)this + 9), *((void *)this + 10), *((void *)this + 8), *((unsigned int *)this + 9));
}

uint64_t URLCredentialXMobileMeAuthToken::equals(CFTypeRef *this, CFTypeRef *a2)
{
  uint64_t result = URLCredential::equals((URLCredential *)this, (const CFObject *)a2);
  if (result)
  {
    if (CFEqual(this[9], a2[9])) {
      return 1;
    }
    uint64_t result = CFEqual(this[8], a2[8]);
    if (result) {
      return 1;
    }
  }
  return result;
}

void URLCredentialXMobileMeAuthToken::URLCredentialXMobileMeAuthToken(URLCredentialXMobileMeAuthToken *this)
{
  *((void *)this + 2) = (char *)&gConstantCFStringValueTable + 30184;
  *((_DWORD *)this + 8) = 4;
  *((unsigned char *)this + 48) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_1ECFA5080;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA5128;
  *((void *)this + 3) = &unk_1ECFA5158;
}

int *kCFNIE()
{
  {
    kCFNIE::sCFNIE = 65542;
    qword_1E8F7FF80 = (uint64_t)xx_CFHTTPConnectionAcceptsRequests;
    qword_1E8F7FF88 = (uint64_t)xx_CFHTTPConnectionCreate;
    qword_1E8F7FF90 = (uint64_t)xx_core_streamable_CFHTTPConnectionEnqueue;
    qword_1E8F7FF98 = (uint64_t)xx_CFHTTPConnectionLost;
    qword_1E8F7FFA0 = (uint64_t)xx_CFNetConnectionSetShouldPipeline;
    qword_1E8F7FFA8 = (uint64_t)xx_CFHTTPConnectionGetLastAccessTime;
    qword_1E8F7FFB0 = (uint64_t)xx_CFHTTPConnectionGetQueueDepth;
    qword_1E8F7FFB8 = (uint64_t)xx_CFURLProtocolCopySchedulingArray;
    qword_1E8F7FFC0 = (uint64_t)CFReadStreamCreateHTTPStream;
    qword_1E8F7FFC8 = (uint64_t)CFWriteStreamCreateHTTPStream;
    qword_1E8F7FFD0 = (uint64_t)__CFNetworkCopyProxiesForInterface;
    qword_1E8F7FFD8 = (uint64_t)xx_CFHSTSParserIndexOfFirstDotInDomainName;
    qword_1E8F7FFE0 = (uint64_t)xx_CFHSTSPolicyCreateWithProperties;
    qword_1E8F7FFE8 = (uint64_t)xx_CFHSTSPolicyHandleSTSHeader;
    qword_1E8F7FFF0 = (uint64_t)xx_CFHSTSPolicyIsKnownHSTSHost;
    qword_1E8F7FFF8 = (uint64_t)xx_CFHSTSPolicyIsKnownHSTSHostWithBytes;
    qword_1E8F80000 = (uint64_t)xx_createKerberosTicketForHostWithPassword;
    qword_1E8F80008 = (uint64_t)xx_destroyAllKerberosTickets;
    qword_1E8F80010 = (uint64_t)xx_listKerberosTickets;
    qword_1E8F80018 = (uint64_t)xx_createCFRULCredentialForKerberosTicketWithUUID;
    qword_1E8F80020 = (uint64_t)xx_equalType;
    qword_1E8F80028 = (uint64_t)xx_CFHSTSPolicyUpdateHSTSInfoForHost;
    qword_1E8F80030 = (uint64_t)xx_CFHSTSParserCreateHSTSInfo;
    qword_1E8F80038 = (uint64_t)xx_CFHSTSPolicyResetHostsSinceDate;
    qword_1E8F80040 = (uint64_t)xx_CFHTTPCookieStorageFlushCookieStores;
    qword_1E8F80048 = (uint64_t)_CFHTTPCookieStorageCopyCookiesSortedByFields;
    qword_1E8F80050 = (uint64_t)xx_CFHTTPCookieStorageRemoveObserver;
    qword_1E8F80058 = (uint64_t)xx_CFHTTPCookieStorageAddObserver;
    qword_1E8F80060 = (uint64_t)CFHTTPCookie_domainMatches;
    qword_1E8F80068 = (uint64_t)CFHTTPCookie_looksLikeIPAddress;
    qword_1E8F80070 = (uint64_t)_CookieStorageCreateInMemory;
    qword_1E8F80078 = (uint64_t)_CFURLCacheGetSharedCache;
    qword_1E8F80080 = (uint64_t)CFURLConnectionCopyPeerAddress;
    qword_1E8F80088 = (uint64_t)CFHTTPCookieGetVersion;
    qword_1E8F80090 = (uint64_t)CFHTTPCookieGetCreationTime;
    qword_1E8F80098 = (uint64_t)CFHTTPCookieCopyComment;
    qword_1E8F800A0 = (uint64_t)CFHTTPCookieCopyCommentURL;
    qword_1E8F800A8 = (uint64_t)CFHTTPCookieCopyPortArray;
    qword_1E8F800B0 = (uint64_t)CFHTTPCookieStorageSyncStorageNow;
    qword_1E8F800B8 = (uint64_t)CFURLDownloadUseCredential;
    qword_1E8F800C0 = (uint64_t)_CFGregorianDateCreateWithString;
    qword_1E8F800C8 = (uint64_t)_CFGregorianDateCreateWithBytes;
    qword_1E8F800D0 = (uint64_t)_CFStringCreateRFC2616DateStringWithGregorianDate;
    qword_1E8F800D8 = (uint64_t)_CFStringCreateRFC1123DateStringWithGregorianDate;
    qword_1E8F800E0 = (uint64_t)CFURLRequestIsIdempotent;
    qword_1E8F800E8 = (uint64_t)CFURLResponseCreateCopy;
    unk_1E8F800F0 = 0;
    qword_1E8F800F8 = (uint64_t)_CFHTTPMessageSetMultipleHeaderFields;
    qword_1E8F80100 = (uint64_t)CFURLResponseGetLastModifiedDate;
    qword_1E8F80108 = (uint64_t)_CFHostSetClientInfoCallback;
    unk_1E8F80110 = @"base";
    qword_1E8F80118 = @"persistent";
    unk_1E8F80120 = @"type";
    qword_1E8F80128 = @"binary";
    unk_1E8F80130 = @"url";
    qword_1E8F80138 = @"ident";
    unk_1E8F80140 = @"policy";
    qword_1E8F80148 = 0x1EC0A0550;
    unk_1E8F80150 = 0x1EC0A0CC0;
    qword_1E8F80158 = 0x1EC0A0048;
    unk_1E8F80160 = 0x1EC0A37D8;
    qword_1E8F80168 = 0x1EC0A3810;
    unk_1E8F80170 = 0x1EC09F4E8;
    qword_1E8F80178 = 0x1EC09F360;
    qword_1E8F80180 = 0x1EC0A3570;
    qword_1E8F80188 = 0x1EC0A3928;
    qword_1E8F80190 = 0x1EC0A5D40;
    qword_1E8F80198 = 0x1EC0A5D78;
    qword_1E8F801A0 = 0x1EC0A5CD0;
    qword_1E8F801A8 = 0x1EC0A5D08;
    qword_1E8F801B0 = 0x1EC0A12A8;
    qword_1E8F801B8 = (uint64_t)CFURLDownloadSetOriginatingURL;
    qword_1E8F801C0 = (uint64_t)_CFServerScheduleWithRunLoopAndMode;
    qword_1E8F801C8 = (uint64_t)CFURLCacheCurrentMemoryUsage;
    qword_1E8F801D0 = (uint64_t)CFURLDataDecoderCreateWithResponse;
    qword_1E8F801D8 = (uint64_t)CFURLDataDecoderDecodeData;
    qword_1E8F801E0 = (uint64_t)CFURLDataDecoderIsFinishedDecoding;
    qword_1E8F801E8 = (uint64_t)CFURLDataDecoderCreateWithContentEncoding;
    qword_1E8F801F0 = (uint64_t)_CFURLStorageSessionGetDefault;
    qword_1E8F801F8 = (uint64_t)CFURLDownloadCreateWithResumeInformation;
    qword_1E8F80200 = (uint64_t)CFURLDownloadCopyResumeInformation;
    qword_1E8F80208 = (uint64_t)CFURLDownloadSetDirectoryPath;
    qword_1E8F80210 = (uint64_t)older_spi_CFHTTPCookieStorageSetCookiesWithResponseHeaderFields;
    qword_1E8F80218 = (uint64_t)CFURLRequestGetPreventsIdleSystemSleep;
    qword_1E8F80220 = (uint64_t)CFURLRequestSetPreventsIdleSystemSleep;
    qword_1E8F80228 = (uint64_t)_xx_requestSetBoundInterfaceIdentifier;
    dword_1E8F80230 = -1060454374;
  }
  return &kCFNIE::sCFNIE;
}

__CFString *_xx_requestSetBoundInterfaceIdentifier(_CFURLRequest *a1, __CFString *a2)
{
  CFAllocatorRef v3 = (URLRequest *)[(_CFURLRequest *)a1 _inner];

  return URLRequest::setBoundInterfaceIdentifier(v3, a2);
}

uint64_t CFURLRequestGetPreventsIdleSystemSleep(const _CFURLRequest *a1)
{
  return 0;
}

CFTypeRef CFURLDownloadSetDirectoryPath(_CFURLDownload *a1, CFTypeRef cf)
{
  if (a1)
  {
    CFAllocatorRef v3 = a1;
    if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
      dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
    }
    a1 = (_CFURLDownload *)((char *)v3 + 16);
  }

  return URLDownload::setDirectoryURL((URLDownload *)a1, cf);
}

CFTypeRef URLDownload::setDirectoryURL(URLDownload *this, CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 27);
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *((void *)this + 27) = result;
  }
  return result;
}

CFDictionaryRef CFURLDownloadCopyResumeInformation(char *cf)
{
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  if (cf) {
    uint64_t v2 = (URLDownload *)(cf + 16);
  }
  else {
    uint64_t v2 = 0;
  }
  CFAllocatorRef v3 = CFGetAllocator(cf);

  return URLDownload::createResumeInformation(v2, v3);
}

void CFURLDownloadSetOriginatingURL(_CFURLDownload *a1, const __CFURL *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  if (a1) {
    CFAllocatorRef v4 = (char *)a1 + 16;
  }
  else {
    CFAllocatorRef v4 = 0;
  }
  if (!a2)
  {
    uint64_t v12 = *((void *)v4 + 28);
    unsigned int v9 = v4 + 224;
    if (!v12) {
      return;
    }
    CFURLRef v8 = 0;
LABEL_14:
    CFTypeRef v11 = 0;
    goto LABEL_15;
  }
  CFAllocatorRef v5 = CFGetAllocator(v4 - 16);
  URLPortion::URLPortion((URLPortion *)&allocator, v5, a2, 1);
  CFAllocatorRef v6 = CFGetAllocator(v4 - 16);
  size_t v7 = strlen(__s);
  CFURLRef v8 = CFURLCreateWithBytes(v6, (const UInt8 *)__s, v7, 0x201u, 0);
  if (ptr != &v14) {
    CFAllocatorDeallocate(allocator, ptr);
  }
  CFURLRef v10 = (const __CFURL *)*((void *)v4 + 28);
  unsigned int v9 = v4 + 224;
  if (v10 == v8) {
    goto LABEL_16;
  }
  if (!v8) {
    goto LABEL_14;
  }
  CFTypeRef v11 = CFRetain(v8);
LABEL_15:
  void *v9 = v11;
LABEL_16:
  if (v8) {
    CFRelease(v8);
  }
}

void sub_1842D0814(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const __CFAllocator *allocator, uint64_t a10)
{
  if ((uint64_t *)STACK[0x208] != &a10) {
    CFAllocatorDeallocate(allocator, (void *)STACK[0x208]);
  }
  _Unwind_Resume(a1);
}

double CFURLResponseGetLastModifiedDate(_CFURLResponse *a1)
{
  uint64_t v1 = (URLResponse *)[(_CFURLResponse *)a1 _inner];

  return URLResponse::getLastModifiedDate(v1);
}

uint64_t CFURLRequestIsIdempotent(_CFURLRequest *a1)
{
  uint64_t v1 = *(void *)([(_CFURLRequest *)a1 _inner] + 56);
  if (!v1) {
    return 1;
  }
  uint64_t result = *(void *)(v1 + 152);
  if (!result) {
    return result;
  }
  if (CFEqual((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2604])) {
    return 1;
  }
  uint64_t result = *(void *)(v1 + 152);
  if (result) {
    return CFEqual((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2611]);
  }
  uint64_t result = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT);
  if (result)
  {
    *(_WORD *)CFAllocatorRef v3 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "these should always be initialized now", v3, 2u);
    uint64_t result = *(void *)(v1 + 152);
    if (result) {
      return CFEqual((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2611]);
    }
  }
  return result;
}

void CFURLDownloadUseCredential(_CFURLDownload *a1, const _CFURLCredential *a2, CFTypeRef cf2)
{
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  if (a1) {
    CFAllocatorRef v6 = (URLDownload *)((char *)a1 + 16);
  }
  else {
    CFAllocatorRef v6 = 0;
  }

  URLDownload::useCredential(v6, a2, cf2);
}

void CFHTTPCookieStorageSyncStorageNow(OpaqueCFHTTPCookieStorage *a1)
{
  if (newCookieStorageEnabled(void)::onceToken != -1) {
    dispatch_once(&newCookieStorageEnabled(void)::onceToken, &__block_literal_global_1187);
  }
  if (!newCookieStorageEnabled(void)::enabled)
  {
    if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
      dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
    }
    if (a1) {
      uint64_t v2 = (char *)a1 + 16;
    }
    else {
      uint64_t v2 = 0;
    }
    HTTPCookieStorage::syncStorageWithCompletion((uint64_t)v2, 1, 0);
  }
}

CFStringRef CFHTTPCookieCopyCommentURL(OpaqueCFHTTPCookie *a1)
{
  uint64_t v2 = [(OpaqueCFHTTPCookie *)a1 _inner];
  CFAllocatorRef v3 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
  if (*v3 >= 0x28 && (v4 = v3[9], v4) && (uint64_t v5 = *v3, v5 > v4))
  {
    CFAllocatorRef v6 = (char *)v3 + v4;
    size_t v7 = (char *)v3 + v5;
    CFURLRef v8 = v6;
    while (*v8)
    {
      if (++v8 >= v7) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    CFAllocatorRef v6 = 0;
  }
  CFStringRef result = createCookieString(a1, v6);
  if (result)
  {
    CFStringRef v10 = result;
    CFAllocatorRef v11 = CFGetAllocator(a1);
    CFURLRef v12 = CFURLCreateWithString(v11, v10, 0);
    CFRelease(v10);
    return (CFStringRef)v12;
  }
  return result;
}

CFStringRef CFHTTPCookieCopyComment(OpaqueCFHTTPCookie *a1)
{
  uint64_t v2 = [(OpaqueCFHTTPCookie *)a1 _inner];
  CFAllocatorRef v3 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 16))(v2);
  if (*v3 >= 0x24 && (v4 = v3[8], v4) && (uint64_t v5 = *v3, v5 > v4))
  {
    CFAllocatorRef v6 = (char *)v3 + v4;
    size_t v7 = (char *)v3 + v5;
    CFURLRef v8 = v6;
    while (*v8)
    {
      if (++v8 >= v7) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    CFAllocatorRef v6 = 0;
  }

  return createCookieString(a1, v6);
}

double CFHTTPCookieGetCreationTime(OpaqueCFHTTPCookie *a1)
{
  uint64_t v1 = [(OpaqueCFHTTPCookie *)a1 _inner];
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
  if (*(_DWORD *)v2 >= 0x38u) {
    return floor(*(double *)(v2 + 48));
  }
  else {
    return 0.0;
  }
}

uint64_t CFHTTPCookieGetVersion(OpaqueCFHTTPCookie *a1)
{
  uint64_t v1 = [(OpaqueCFHTTPCookie *)a1 _inner];
  uint64_t v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
  if (*v2 >= 8u) {
    return v2[1];
  }
  else {
    return 0;
  }
}

uint64_t CFURLConnectionCopyPeerAddress(_CFURLConnection *a1)
{
  uint64_t v2 = (void *)MEMORY[0x18531D6D0]();
  if (TCFObject<URLConnection>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLConnection>::Class(void)::sOnce, &__block_literal_global_4_19174);
  }
  if (a1) {
    CFAllocatorRef v3 = (char *)a1 + 16;
  }
  else {
    CFAllocatorRef v3 = 0;
  }
  uint64_t v4 = (*(uint64_t (**)(char *))(*(void *)v3 + 160))(v3);
  return v4;
}

void ___ZN9TCFObjectI13URLConnectionE5ClassEv_block_invoke_19177()
{
}

void sub_1842D0D6C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

__CFArray *_CFHTTPCookieStorageCopyCookiesSortedByFields(OpaqueCFHTTPCookieStorage *a1, const __CFArray *a2)
{
  if (HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage != -1) {
    dispatch_once(&HTTPCookieStorage::Class(void)::sOnce_HTTPCookieStorage, &__block_literal_global_11813);
  }
  if (a1) {
    uint64_t v4 = (HTTPCookieStorage *)((char *)a1 + 16);
  }
  else {
    uint64_t v4 = 0;
  }

  return HTTPCookieStorage::copyCookiesMatching(v4, 0, 32, a2);
}

CFMutableArrayRef xx_CFURLProtocolCopySchedulingArray(_CFURLProtocol *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  if (TCFObject<URLProtocol>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<URLProtocol>::Class(void)::sOnce, &__block_literal_global_19179);
  }
  uint64_t v4 = *((void *)a1 + 5);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZL35xx_CFURLProtocolCopySchedulingArrayP14_CFURLProtocol_block_invoke;
  v6[3] = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  void v6[4] = Mutable;
  CoreSchedulingSet::applyBlock(v4, v6);
  return Mutable;
}

void ___ZL35xx_CFURLProtocolCopySchedulingArrayP14_CFURLProtocol_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), a2);
  uint64_t v5 = *(__CFArray **)(a1 + 32);

  CFArrayAppendValue(v5, a3);
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_19182()
{
}

void sub_1842D0F70(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t xx_CFHTTPConnectionGetQueueDepth(const __CFArray *a1)
{
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
  CFAllocatorRef v2 = ValueAtIndex;
  uint64_t v3 = ValueAtIndex[12];
  if (v3)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v3 + 8));
    uint64_t v4 = v2[12];
    int v5 = *((_DWORD *)v2 + 26);
    if (v4) {
      pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
    }
  }
  else
  {
    return *((int *)ValueAtIndex + 26);
  }
  return v5;
}

double xx_CFHTTPConnectionGetLastAccessTime(const __CFArray *a1)
{
  CFDictionaryRef ValueAtIndex = (NetConnection *)CFArrayGetValueAtIndex(a1, 0);

  return NetConnection::getLastAccessTime(ValueAtIndex);
}

void xx_CFNetConnectionSetShouldPipeline(const __CFArray *a1, int a2)
{
  CFDictionaryRef ValueAtIndex = (NetConnection *)CFArrayGetValueAtIndex(a1, 0);

  NetConnection::setShouldPipeline(ValueAtIndex, a2);
}

uint64_t xx_CFHTTPConnectionLost(const __CFArray *a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)CFArrayGetValueAtIndex(a1, 0) + 288);

  return v1();
}

uint64_t xx_core_streamable_CFHTTPConnectionEnqueue(const __CFArray *a1, __CFHTTPMessage *a2)
{
  CFArrayGetValueAtIndex(a1, 0);
  uint64_t v4 = 0;
  int v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  CFReadStreamCreate();
  uint64_t v2 = v5[3];
  _Block_object_dispose(&v4, 8);
  if (v2) {
    return *(void *)(v2 + 8);
  }
  else {
    return 0;
  }
}

void sub_1842D1178(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void xx_CFHTTPConnectionCreate(const __CFAllocator *a1, const __CFString *a2, int a3, int a4, const __CFDictionary *a5)
{
  CFStringRef v10 = CFAllocatorAllocate(a1, 152, 0);
  *CFStringRef v10 = 0u;
  v10[1] = 0u;
  v10[2] = 0u;
  void v10[3] = 0u;
  v10[4] = 0u;
  void v10[5] = 0u;
  void v10[6] = 0u;
  void v10[7] = 0u;
  unsigned char v10[8] = 0u;
  *((void *)v10 + 18) = 0;
  HTTPConnectionCacheKey::HTTPConnectionCacheKey((uint64_t)v10, a1, a2, a3, a4, a5, 0);
  CFAllocatorRef v11 = (HTTPNetConnection_NoAuth *)CFAllocatorAllocate(a1, 320, 0);
  *(_OWORD *)CFAllocatorRef v11 = 0u;
  *((_OWORD *)v11 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
  *((_OWORD *)v11 + 2) = 0u;
  *((_OWORD *)v11 + 3) = 0u;
  *((_OWORD *)v11 + 4) = 0u;
  *((_OWORD *)v11 + 5) = 0u;
  *((_OWORD *)v11 + 6) = 0u;
  *((_OWORD *)v11 + 7) = 0u;
  *((_OWORD *)v11 + 8) = 0u;
  *((_OWORD *)v11 + 9) = 0u;
  *((_OWORD *)v11 + 10) = 0u;
  *((_OWORD *)v11 + 1HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
  *((_OWORD *)v11 + 12) = 0u;
  *((_OWORD *)v11 + 13) = 0u;
  *((_OWORD *)v11 + 14) = 0u;
  *((_OWORD *)v11 + 15) = 0u;
  *((_OWORD *)v11 + CFRetain((char *)this - 16) = 0u;
  *((_OWORD *)v11 + 17) = 0u;
  *((_OWORD *)v11 + 18) = 0u;
  *((_OWORD *)v11 + 19) = 0u;
  HTTPNetConnection_NoAuth::HTTPNetConnection_NoAuth(v11, a1, (HTTPConnectionCacheKey *)v10);
  (*(void (**)(_OWORD *))(*(void *)v10 + 48))(v10);
  NetConnection::initialize(v11);
}

uint64_t _ncRelease(const __CFAllocator *a1, const void *a2)
{
  return (*(uint64_t (**)(const void *))(*(void *)a2 + 48))(a2);
}

const void *_ncRetain(const __CFAllocator *a1, const void *a2)
{
  return a2;
}

uint64_t xx_CFHTTPConnectionAcceptsRequests(const __CFArray *a1)
{
  CFDictionaryRef ValueAtIndex = (NetConnection *)CFArrayGetValueAtIndex(a1, 0);

  return NetConnection::willEnqueueRequests(ValueAtIndex);
}

void _NSURLConnectionWillSendRequestForAuthenticationChallenge(_CFURLConnection *a1, _CFURLAuthChallenge *a2, uint64_t a3)
{
}

uint64_t _NSURLConnectionNeedNewBodyStream(_CFURLConnection *a1, const _CFURLRequest *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZL33_NSURLConnectionNeedNewBodyStreamP16_CFURLConnectionPK13_CFURLRequestPKv_block_invoke;
  v5[3] = &unk_1E52577A8;
  v5[4] = &v6;
  void v5[5] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v5);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1842D2538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFTypeRef ___ZL33_NSURLConnectionNeedNewBodyStreamP16_CFURLConnectionPK13_CFURLRequestPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = [[NSURLRequest alloc] _initWithCFURLRequest:*(void *)(a1 + 40)];
  uint64_t v7 = (const void *)[a3 connection:a2 needNewBodyStream:v6];

  if (v7) {
    CFTypeRef result = CFRetain(v7);
  }
  else {
    CFTypeRef result = 0;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = result;
  return result;
}

uint64_t _NSURLConnectionCanRespondToProtectionSpace(_CFURLConnection *a1, _CFURLProtectionSpace *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  char v9 = 0;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZL43_NSURLConnectionCanRespondToProtectionSpaceP16_CFURLConnectionP21_CFURLProtectionSpacePKv_block_invoke;
  v5[3] = &unk_1E52577A8;
  v5[4] = &v6;
  void v5[5] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v5);
  uint64_t v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1842D2678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZL43_NSURLConnectionCanRespondToProtectionSpaceP16_CFURLConnectionP21_CFURLProtectionSpacePKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = [[NSURLProtectionSpace alloc] _initWithCFURLProtectionSpace:*(void *)(a1 + 40)];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = [a3 connection:a2 canAuthenticateAgainstProtectionSpace:v6];
}

uint64_t _NSURLConnectionShouldUseCredentialStorage(_CFURLConnection *a1, uint64_t a2)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 1;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZL42_NSURLConnectionShouldUseCredentialStorageP16_CFURLConnectionPKv_block_invoke;
  v4[3] = &unk_1E52577F0;
  v4[4] = &v5;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a2, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1842D27BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL42_NSURLConnectionShouldUseCredentialStorageP16_CFURLConnectionPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = [a3 connectionShouldUseCredentialStorage:a2];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = result;
  return result;
}

void _NSURLConnectionDidReceiveAuthenticationChallenge(_CFURLConnection *a1, _CFURLAuthChallenge *a2, uint64_t a3)
{
}

void _NSURLConnectionDidReceiveAuthenticationChallenge_noSelector(_CFURLConnection *a1, _CFURLAuthChallenge *a2, uint64_t a3)
{
  uint64_t v4 = -[NSURLConnectionInternalConnection _retainCFURLConnection](a3);
  if (v4)
  {
    uint64_t v5 = (const void *)v4;
    CFURLConnectionUseCredential(v4, 0, (uint64_t)a2);
    CFRelease(v5);
  }
}

void _NSURLConnectionDidSendBodyData(_CFURLConnection *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZL31_NSURLConnectionDidSendBodyDataP16_CFURLConnectionlllPKv_block_invoke;
  v5[3] = &__block_descriptor_56_e28_v24__0__NSURLConnection_8_16l;
  v5[4] = a2;
  void v5[5] = a3;
  void v5[6] = a4;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a5, (uint64_t)v5);
}

uint64_t ___ZL31_NSURLConnectionDidSendBodyDataP16_CFURLConnectionlllPKv_block_invoke(void *a1, uint64_t a2, void *a3)
{
  return [a3 connection:a2 didSendBodyData:a1[4] totalBytesWritten:a1[5] totalBytesExpectedToWrite:a1[6]];
}

const _CFCachedURLResponse *_NSURLConnectionWillCacheResponse(_CFURLConnection *a1, const _CFCachedURLResponse *a2, uint64_t a3)
{
  uint64_t v7 = 0;
  char v8 = &v7;
  uint64_t v9 = 0x2020000000;
  CFStringRef v10 = a2;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZL33_NSURLConnectionWillCacheResponseP16_CFURLConnectionPK20_CFCachedURLResponsePKv_block_invoke;
  v6[3] = &unk_1E52577A8;
  void v6[4] = &v7;
  void v6[5] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v6);
  uint64_t v4 = (const _CFCachedURLResponse *)v8[3];
  if (v4 == a2)
  {
    CFRetain(a2);
    uint64_t v4 = (const _CFCachedURLResponse *)v8[3];
  }
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1842D29C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZL33_NSURLConnectionWillCacheResponseP16_CFURLConnectionPK20_CFCachedURLResponsePKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v8 = [[NSCachedURLResponse alloc] _initWithCFCachedURLResponse:*(void *)(a1 + 40)];
  id v6 = (id)[a3 connection:a2 willCacheResponse:v8];
  if (v6 != v8)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = [v6 _CFCachedURLResponse];
    uint64_t v7 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    if (v7) {
      CFRetain(v7);
    }
  }
}

uint64_t _NSURLConnectionWillCacheResponse_noCache(_CFURLConnection *a1, const _CFCachedURLResponse *a2, const void *a3)
{
  return 0;
}

void _NSURLConnectionDidFail(_CFURLConnection *a1, __CFError *a2, uint64_t a3)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZL23_NSURLConnectionDidFailP16_CFURLConnectionP9__CFErrorPKv_block_invoke;
  v3[3] = &unk_1E5257778;
  v3[4] = a3;
  void v3[5] = a2;
  -[NSURLConnectionInternal _withConnectionAndDelegate:](a3, (uint64_t)v3);
}

uint64_t ___ZL23_NSURLConnectionDidFailP16_CFURLConnectionP9__CFErrorPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 40), "userInfo"), "objectForKey:", @"NSErrorFailingURLKey");
  if (!v6) {
    id v6 = *(void **)(*(void *)(a1 + 32) + 24);
  }
  uint64_t v7 = cfnTranslateCFError(*(__CFError **)(a1 + 40), v6);

  return [a3 connection:a2 didFailWithError:v7];
}

void _NSURLConnectionDidFinishLoading_Download(_CFURLConnection *a1, uint64_t a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZL41_NSURLConnectionDidFinishLoading_DownloadP16_CFURLConnectionPKv_block_invoke;
  v2[3] = &unk_1E5258408;
  v2[4] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a2, (uint64_t)v2);
}

uint64_t ___ZL41_NSURLConnectionDidFinishLoading_DownloadP16_CFURLConnectionPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = objc_msgSend(MEMORY[0x1E4F1CB10], "fileURLWithPath:isDirectory:", -[NSString stringByAppendingPathComponent:](NSTemporaryDirectory(), "stringByAppendingPathComponent:", *(void *)(*(void *)(a1 + 32) + 96)), 0);

  return [a3 connectionDidFinishDownloading:a2 destinationURL:v5];
}

void _NSURLConnectionDidFinishLoading(_CFURLConnection *a1, uint64_t a2)
{
}

uint64_t ___ZL32_NSURLConnectionDidFinishLoadingP16_CFURLConnectionPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return [a3 connectionDidFinishLoading:a2];
}

void _NSURLConnectionDidReceiveData_Download(_CFURLConnection *a1, const __CFData *a2, uint64_t a3, uint64_t a4)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZL39_NSURLConnectionDidReceiveData_DownloadP16_CFURLConnectionPK8__CFDatalPKv_block_invoke;
  v4[3] = &unk_1E5257778;
  v4[4] = a4;
  void v4[5] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a4, (uint64_t)v4);
}

uint64_t ___ZL39_NSURLConnectionDidReceiveData_DownloadP16_CFURLConnectionPK8__CFDatalPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 40));
  CFDataRef v7 = *(const __CFData **)(a1 + 40);
  *(void *)(*(void *)(a1 + 32) + 112) += Length;
  CFIndex v8 = CFDataGetLength(v7);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(v9 + 112);
  uint64_t v11 = *(void *)(v9 + 120);

  return [a3 connection:a2 didWriteData:v8 totalBytesWritten:v10 expectedTotalBytes:v11];
}

void _NSURLConnectionDidReceiveResponse_Download(_CFURLConnection *a1, _CFURLResponse *a2, void *a3)
{
  a3[15] = CFURLResponseGetExpectedContentLength(a2);
  a3[12] = URLResponse::copySuggestedFilename((URLResponse *)[(_CFURLResponse *)a2 _inner]);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZL34_NSURLConnectionDidReceiveResponseP16_CFURLConnectionP14_CFURLResponsePKv_block_invoke;
  v5[3] = &__block_descriptor_40_e28_v24__0__NSURLConnection_8_16l;
  v5[4] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:]((uint64_t)a3, (uint64_t)v5);
}

uint64_t ___ZL34_NSURLConnectionDidReceiveResponseP16_CFURLConnectionP14_CFURLResponsePKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = +[NSURLResponse _responseWithCFURLResponse:*(void *)(a1 + 32)];

  return [a3 connection:a2 didReceiveResponse:v5];
}

CFStringRef _NSURLConnectionDidReceiveResponse_Download_NoDelegate(_CFURLConnection *a1, _CFURLResponse *a2, void *a3)
{
  a3[15] = CFURLResponseGetExpectedContentLength(a2);
  CFStringRef result = URLResponse::copySuggestedFilename((URLResponse *)[(_CFURLResponse *)a2 _inner]);
  a3[12] = result;
  return result;
}

void _NSURLConnectionDidReceiveData(_CFURLConnection *a1, const __CFData *a2, uint64_t a3, uint64_t a4)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZL30_NSURLConnectionDidReceiveDataP16_CFURLConnectionPK8__CFDatalPKv_block_invoke;
  v4[3] = &__block_descriptor_40_e28_v24__0__NSURLConnection_8_16l;
  v4[4] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a4, (uint64_t)v4);
}

uint64_t ___ZL30_NSURLConnectionDidReceiveDataP16_CFURLConnectionPK8__CFDatalPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return [a3 connection:a2 didReceiveData:*(void *)(a1 + 32)];
}

void _NSURLConnectionDidReceiveData_LengthReceived(_CFURLConnection *a1, const __CFData *a2, uint64_t a3, uint64_t a4)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZL45_NSURLConnectionDidReceiveData_LengthReceivedP16_CFURLConnectionPK8__CFDatalPKv_block_invoke;
  v4[3] = &__block_descriptor_48_e28_v24__0__NSURLConnection_8_16l;
  v4[4] = a2;
  void v4[5] = a3;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a4, (uint64_t)v4);
}

uint64_t ___ZL45_NSURLConnectionDidReceiveData_LengthReceivedP16_CFURLConnectionPK8__CFDatalPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return [a3 connection:a2 didReceiveData:*(void *)(a1 + 32) lengthReceived:*(void *)(a1 + 40)];
}

void _NSURLConnectionDidReceiveDataArray(_CFURLConnection *a1, const __CFArray *a2, uint64_t a3)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZL35_NSURLConnectionDidReceiveDataArrayP16_CFURLConnectionPK9__CFArrayPKv_block_invoke;
  v3[3] = &__block_descriptor_40_e28_v24__0__NSURLConnection_8_16l;
  v3[4] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v3);
}

uint64_t ___ZL35_NSURLConnectionDidReceiveDataArrayP16_CFURLConnectionPK9__CFArrayPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return [a3 connection:a2 didReceiveDataArray:*(void *)(a1 + 32)];
}

void _NSURLConnectionDidReceiveResponse(_CFURLConnection *a1, _CFURLResponse *a2, uint64_t a3)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZL34_NSURLConnectionDidReceiveResponseP16_CFURLConnectionP14_CFURLResponsePKv_block_invoke;
  v3[3] = &__block_descriptor_40_e28_v24__0__NSURLConnection_8_16l;
  v3[4] = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v3);
}

void _NSURLConnectionConditionalRequirementsChanged(_CFURLConnection *a1, char a2, uint64_t a3)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZL46_NSURLConnectionConditionalRequirementsChangedP16_CFURLConnectionhPKv_block_invoke;
  v3[3] = &__block_descriptor_33_e28_v24__0__NSURLConnection_8_16l;
  char v4 = a2;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a3, (uint64_t)v3);
}

uint64_t ___ZL46_NSURLConnectionConditionalRequirementsChangedP16_CFURLConnectionhPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return [a3 connection:a2 conditionalRequirementsChanged:*(unsigned char *)(a1 + 32) != 0];
}

void _NSURLConnectionConnectionWaiting(_CFURLConnection *a1, uint64_t a2)
{
}

uint64_t ___ZL33_NSURLConnectionConnectionWaitingP16_CFURLConnectionPKv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return [a3 connectionWaiting:a2];
}

void _NSURLConnectionWillSendRequestForEstablishedConnection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZL55_NSURLConnectionWillSendRequestForEstablishedConnectionP16_CFURLConnectionPK13_CFURLRequestPK14__CFDictionaryU13block_pointerFvS3_EPKv_block_invoke;
  v5[3] = &unk_1E52576D0;
  void v5[5] = a2;
  void v5[6] = a3;
  v5[4] = a4;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a5, (uint64_t)v5);
}

uint64_t ___ZL55_NSURLConnectionWillSendRequestForEstablishedConnectionP16_CFURLConnectionPK13_CFURLRequestPK14__CFDictionaryU13block_pointerFvS3_EPKv_block_invoke(void *a1, uint64_t a2, void *a3)
{
  id v6 = [[NSURLRequest alloc] _initWithCFURLRequest:a1[5]];
  [a3 connection:a2 willSendRequestForEstablishedConnection:v6 properties:a1[6]];

  CFDataRef v7 = *(uint64_t (**)(void))(a1[4] + 16);

  return v7();
}

uint64_t _NSURLConnectionWillSendRequest(_CFURLConnection *a1, const _CFURLRequest *a2, _CFURLResponse *a3, uint64_t a4)
{
  uint64_t v7 = 0;
  CFIndex v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v10 = 0;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZL31_NSURLConnectionWillSendRequestP16_CFURLConnectionPK13_CFURLRequestP14_CFURLResponsePKv_block_invoke;
  v6[3] = &unk_1E52576A8;
  void v6[5] = a2;
  void v6[6] = a3;
  void v6[4] = &v7;
  -[NSURLConnectionInternal _withActiveConnectionAndDelegate:](a4, (uint64_t)v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1842D3308(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void ___ZL31_NSURLConnectionWillSendRequestP16_CFURLConnectionPK13_CFURLRequestP14_CFURLResponsePKv_block_invoke(void *a1, uint64_t a2, void *a3)
{
  id v9 = [[NSURLRequest alloc] _initWithCFURLRequest:a1[5]];
  if (a1[6]) {
    id v6 = +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:");
  }
  else {
    id v6 = 0;
  }
  uint64_t v7 = [a3 connection:a2 willSendRequest:v9 redirectResponse:v6];
  if ((id)v7 == v9) {
    uint64_t v7 = a1[5];
  }
  *(void *)(*(void *)(a1[4] + 8) + CFRelease((char *)this - 24) = v7;
  CFIndex v8 = *(const void **)(*(void *)(a1[4] + 8) + 24);
  if (v8) {
    CFRetain(v8);
  }
}

void _NSURLConnectionReleaseClient(uint64_t a1)
{
  if (a1)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = __66__NSURLConnectionInternal__withConnectionDisconnectFromConnection__block_invoke;
    v3[3] = &unk_1E5258408;
    void v3[4] = a1;
    uint64_t v2 = (void *)MEMORY[0x18531D6D0]();
    -[NSURLConnectionInternal _withConnectionAndDelegate:onlyActive:](a1, (uint64_t)v3, 0);
  }
}

void non-virtual thunk to'HTTPTransaction::~HTTPTransaction(HTTPTransaction *this)
{
  HTTPTransaction::~HTTPTransaction((HTTPTransaction *)((char *)this - 24));

  JUMPOUT(0x18531B6D0);
}

{
  HTTPTransaction::~HTTPTransaction((HTTPTransaction *)((char *)this - 24));
}

void HTTPTransaction::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 208);
  if (v2)
  {
    uint64_t v3 = (std::__shared_weak_count *)a2[1];
    uint64_t v6 = *a2;
    uint64_t v7 = v3;
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 272))(v2, &v6);
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v7);
    }
  }
  else
  {
    uint64_t v4 = *(void (**)(uint64_t, void))(*(void *)*a2 + 152);
    uint64_t v5 = *a2;
    v4(v5, 0);
  }
}

void sub_1842D358C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void HTTPTransaction::resetConnAuthState(HTTPTransaction *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = *((void *)this + 7);
      if (v4) {
        std::allocate_shared[abi:nn180100]<HTTPConnectionAuthenticator,std::allocator<HTTPConnectionAuthenticator>,std::weak_ptr<HTTPConnection> &,std::shared_ptr<HTTPEngine> &,void>((uint64_t)&v5, *(void *)(v4 + 40), *(void *)(v4 + 48), v4 + 64);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
  }
}

void sub_1842D3630(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void HTTPTransaction::connAuthState(HTTPTransaction *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v4 && (long long v5 = std::__shared_weak_count::lock(v4)) != 0)
  {
    uint64_t v6 = *((void *)this + 7);
    if (v6)
    {
      uint64_t v8 = *(void *)(v6 + 176);
      uint64_t v7 = *(void *)(v6 + 184);
      *a2 = v8;
      a2[1] = v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
    }
    else
    {
      *a2 = 0;
      a2[1] = 0;
    }
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

__n128 __Block_byref_object_copy__19344(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

void __Block_byref_object_dispose__19345(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void HTTPTransaction::setProxy(uint64_t a1, uint64_t *a2)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3321888768;
  long long v5 = ___ZN15HTTPTransaction8setProxyENSt3__110shared_ptrI12NetworkProxyEE_block_invoke;
  uint64_t v6 = &__block_descriptor_56_e8_40c40_ZTSNSt3__110shared_ptrI12NetworkProxyEE_e5_v8__0l;
  uint64_t v3 = *a2;
  uint64_t v2 = (std::__shared_weak_count *)a2[1];
  uint64_t v7 = a1;
  uint64_t v8 = v3;
  id v9 = v2;
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    v5(v4);
  }
  else
  {
    ___ZN15HTTPTransaction8setProxyENSt3__110shared_ptrI12NetworkProxyEE_block_invoke(v4);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
}

void sub_1842D3784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a16);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN15HTTPTransaction8setProxyENSt3__110shared_ptrI12NetworkProxyEE_block_invoke(void *a1)
{
  uint64_t v1 = a1[4];
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 144);
  *(void *)(v1 + CFRetain((char *)this - 136) = v2;
  *(void *)(v1 + 144) = v3;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void __destroy_helper_block_e8_40c40_ZTSNSt3__110shared_ptrI12NetworkProxyEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_40c40_ZTSNSt3__110shared_ptrI12NetworkProxyEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

CFTypeRef HTTPTransaction::copyTrust(HTTPTransaction *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *((void *)this + 7);
  if (v5 && (uint64_t v6 = *(HTTPEngine **)(v5 + 64)) != 0) {
    CFTypeRef v7 = HTTPEngine::copyProperty(v6, @"kCFStreamPropertySSLPeerTrust");
  }
  else {
    CFTypeRef v7 = 0;
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  return v7;
}

void sub_1842D3868(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTPTransaction16rawBytesReceivedEv_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + CFRelease((char *)this - 24) = *(void *)(*(void *)(result + 40) + 264);
  return result;
}

uint64_t ___ZN15HTTPTransaction12rawBytesSentEv_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + CFRelease((char *)this - 24) = *(void *)(*(void *)(result + 40) + 256);
  return result;
}

void HTTPTransaction::updateScheduling(HTTPTransaction *this, const CoreSchedulingSet *a2)
{
  if (a2) {
    (*(void (**)(const CoreSchedulingSet *))(*(void *)a2 + 40))(a2);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v4)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v4);
    if (v5) {
      uint64_t v6 = *((void *)this + 5);
    }
    else {
      uint64_t v6 = 0;
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3321888768;
  void v7[2] = ___ZN15HTTPTransaction16updateSchedulingEPK17CoreSchedulingSet_block_invoke;
  v7[3] = &__block_descriptor_56_e8_32c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE_e5_v8__0l;
  v7[4] = v6;
  uint64_t v8 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v9 = a2;
  ___ZN15HTTPTransaction16updateSchedulingEPK17CoreSchedulingSet_block_invoke((uint64_t)v7);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

void sub_1842D39AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a15);
  }
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN15HTTPTransaction16updateSchedulingEPK17CoreSchedulingSet_block_invoke(uint64_t a1)
{
  HTTPTransaction::_onqueue_updateScheduling(*(HTTPTransaction **)(a1 + 32), *(const CoreSchedulingSet **)(a1 + 48), 1);
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v3();
  }
  return result;
}

void __destroy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZN15HTTPTransaction25_onqueue_updateSchedulingEPK17CoreSchedulingSetb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  HTTPTransaction::_onqueue_invokeHandler(*(HTTPTransaction **)(a1 + 40));
  *(_WORD *)(v1 + 32) &= 0xFE7Fu;
}

void ___ZN15HTTPTransaction20closeAndClearHandlerEv_block_invoke(uint64_t a1)
{
}

uint64_t ___ZN15HTTPTransaction35_onqueue_scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *(unsigned char *)(*(void *)(a1 + 40) + 249) = 0;
  return result;
}

void __destroy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14__CFReadStreamEE56c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void *__copy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14__CFReadStreamEE56c43_ZTSNSt3__110shared_ptrI15HTTPTransactionEE(void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[8];
  result[7] = a2[7];
  result[8] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN15HTTPTransaction11setPropertyEN17MetaNetStreamInfo20ApplicablePropertiesEPKv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = MetaNetStreamInfo::applicableToPropertyName(*(_DWORD *)(a1 + 56));
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v2 + 208))(v2, v3, *(void *)(a1 + 48));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = result;
  return result;
}

uint64_t ___ZN15HTTPTransaction12copyPropertyEN17MetaNetStreamInfo20ApplicablePropertiesE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = MetaNetStreamInfo::applicableToPropertyName(*(_DWORD *)(a1 + 48));
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 200))(v2, v3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = result;
  return result;
}

uint64_t HTTPTransaction::copyProperty(HTTPTransaction *this, const __CFString *a2)
{
  return (*(uint64_t (**)(void, const __CFString *))(**((void **)this + 24) + 32))(*((void *)this + 24), a2);
}

void HTTPTransaction::errorOccurred(HTTPTransaction *this, CFStreamError a2)
{
  if ((*((_DWORD *)this + 20) & 0xFFFFFFFE) != 0xA)
  {
    HTTPTransaction::_onqueue_handleError(this, a2);
    HTTPTransaction::_onqueue_invokeHandler(this);
    if ((*((_WORD *)this + 16) & 4) == 0)
    {
      HTTPTransaction::_onqueue_closeAndCleanup(this);
    }
  }
}

void ___ZN15HTTPTransaction15startStallTimerEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 48);
  if (v3 && (uint64_t v4 = std::__shared_weak_count::lock(v3)) != 0)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)(v2 + 40);
    if (v6)
    {
      int valuePtr = 3;
      CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
      if (v7)
      {
        (*(void (**)(uint64_t, uint64_t, CFNumberRef))(*(void *)v6 + 208))(v6, 0x1EC09EFE0, v7);
        CFRelease(v7);
      }
    }
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  else
  {
    uint64_t v8 = *(NSObject **)(a1 + 32);
    dispatch_source_cancel(v8);
  }
}

void sub_1842D3E34(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'AwaitingTube::~AwaitingTube(AwaitingTube *this)
{
  uint64_t v2 = (char *)this - 24;
  AwaitingTube::~AwaitingTube((AwaitingTube *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  AwaitingTube::~AwaitingTube((AwaitingTube *)((char *)this - 24));
}

uint64_t _CFURLStorageSessionGetTypeID()
{
  if (StorageSession::Class(void)::sOnce_StorageSession != -1) {
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_19595);
  }
  return *(void *)(StorageSession::Class(void)::sClass_OBJTYPE + 96);
}

uint64_t _CFURLStorageSessionCreateWithData()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "This function should never be called", v1, 2u);
  }
  return 0;
}

char *_CFURLStorageSessionGetDefault(const __CFAllocator *a1)
{
  uint64_t result = (char *)_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault;
  if (!_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault)
  {
    uint64_t result = StorageSession::copyProcessDefault(0) - 16;
    _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault = (uint64_t)result;
  }
  return result;
}

char *_CFURLStorageSessionCopyProcessDefault(StorageSession *a1)
{
  return StorageSession::copyProcessDefault(a1) - 16;
}

CFTypeRef _CFURLStorageSessionCopyIdentifier(uint64_t a1, uint64_t a2)
{
  if (StorageSession::Class(void)::sOnce_StorageSession != -1) {
    dispatch_once(&StorageSession::Class(void)::sOnce_StorageSession, &__block_literal_global_19595);
  }
  uint64_t v3 = a2 + 16;
  if (!a2) {
    uint64_t v3 = 0;
  }
  CFTypeRef result = *(CFTypeRef *)(v3 + 72);
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

uint64_t Serializable::serializeToPropertyList(Serializable *this, SerializableArchive **a2)
{
  AutoScalar::AutoScalar((AutoScalar *)&v7, (const __CFAllocator *)3);
  CFTypeRef v4 = cf;
  SerializableArchive::assertEmpty(*a2, @"_version");
  if (v4) {
    CFDictionarySetValue(*a2, @"_version", v4);
  }
  CFNumberRef v7 = &unk_1ECF9A500;
  if (cf) {
    CFRelease(cf);
  }
  uint64_t v5 = (const void *)*((void *)this + 1);
  SerializableArchive::assertEmpty(*a2, @"_kind");
  if (v5) {
    CFDictionarySetValue(*a2, @"_kind", v5);
  }
  return 1;
}

void sub_1842D40D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

BOOL Serializable::initializeFromPropertyList(uint64_t a1, CFDictionaryRef *a2)
{
  if (!a2) {
    return 0;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*a2, @"_version");
  if (!Value) {
    return 0;
  }
  uint64_t valuePtr = 0;
  CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
  if (valuePtr != 3) {
    return 0;
  }
  uint64_t v5 = CFDictionaryGetValue(*a2, @"_kind");
  if (!v5) {
    return 0;
  }
  CFStringRef v6 = (const __CFString *)CFRetain(v5);
  if (!v6) {
    return 0;
  }
  CFStringRef v7 = v6;
  BOOL v8 = CFEqual(v6, *(CFStringRef *)(a1 + 8));
  CFRelease(v7);
  return v8;
}

void SerializableArchive::add(SerializableArchive **this, CFURLRef relativeURL, const __CFURL *a3)
{
  CFURLRef v4 = CFURLCopyAbsoluteURL(relativeURL);
  if (v4)
  {
    CFURLRef v5 = v4;
    CFStringRef v6 = CFURLGetString(v4);
    SerializableArchive::assertEmpty(*this, @"valu");
    if (v6) {
      CFDictionarySetValue(*this, @"valu", v6);
    }
    CFRelease(v5);
  }
}

CFURLRef DeserializableArchive::deserialize(const __CFString *this, CFURLRef *a2, const __CFURL **a3)
{
  CFAllocatorRef v5 = CFGetAllocator(this);
  CFURLRef result = CFURLCreateWithString(v5, this, 0);
  *a2 = result;
  return result;
}

void SerializableArchive::add(CFTypeRef *this, const __CFString *a2, __CFError *a3)
{
  if (a3)
  {
    CFAllocatorRef v6 = CFGetAllocator(*this);
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFURLRef v12 = Mutable;
    CFErrorDomain Domain = CFErrorGetDomain(a3);
    SerializableArchive::assertEmpty(Mutable, @"domain");
    if (Domain) {
      CFDictionarySetValue(Mutable, @"domain", Domain);
    }
    CFAllocatorRef Code = (const __CFAllocator *)CFErrorGetCode(a3);
    AutoScalar::AutoScalar((AutoScalar *)&v13, Code);
    CFTypeRef v10 = cf;
    SerializableArchive::assertEmpty(Mutable, @"code");
    if (v10) {
      CFDictionarySetValue(Mutable, @"code", v10);
    }
    CFAllocatorRef v13 = &unk_1ECF9A500;
    if (cf) {
      CFRelease(cf);
    }
    CFDictionaryRef v11 = CFErrorCopyUserInfo(a3);
    if (v11)
    {
      SerializableArchive::add((SerializableArchive *)&v12, @"userinfo", v11);
      CFRelease(v11);
    }
    SerializableArchive::assertEmpty((SerializableArchive *)*this, a2);
    CFDictionarySetValue((CFMutableDictionaryRef)*this, a2, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
}

void sub_1842D43D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  if (v12) {
    CFRelease(v12);
  }
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(SerializableArchive *this, const __CFString *a2, CFDictionaryRef theDict)
{
  if (theDict)
  {
    CFDictionaryGetCount(theDict);
    operator new[]();
  }
}

void sub_1842D45A0(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(CFTypeRef *this, __CFString *a2, const __CFArray *a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    CFIndex Count = CFArrayGetCount(a3);
    CFAllocatorRef v7 = CFGetAllocator(*this);
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    AutoScalar::AutoScalar((AutoScalar *)&v34, (const __CFAllocator *)Count);
    CFTypeRef v9 = cf;
    SerializableArchive::assertEmpty(Mutable, @"count");
    if (v9) {
      CFDictionarySetValue(Mutable, @"count", v9);
    }
    unsigned __int8 v30 = a2;
    uint64_t v34 = &unk_1ECF9A500;
    if (cf) {
      CFRelease(cf);
    }
    if (Count >= 1)
    {
      CFIndex v10 = 0;
      CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      while (1)
      {
        CFAllocatorRef v11 = CFGetAllocator(*this);
        AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)&v34, v11, @"ix%ld", v10);
        CFStringRef v12 = (const __CFString *)cf;
        CFDictionaryRef ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(a3, v10);
        uint64_t v14 = ValueAtIndex;
        if (!ValueAtIndex)
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)int buf = 0;
            _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Should be trying to serialize something thats nil", buf, 2u);
          }
          goto LABEL_32;
        }
        CFTypeID v15 = CFGetTypeID(ValueAtIndex);
        CFAllocatorRef v16 = CFGetAllocator(v14);
        uint64_t v17 = CFDictionaryCreateMutable(v16, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        uint64_t v32 = v17;
        if (CFBooleanGetTypeID() == v15) {
          break;
        }
        if (CFNumberGetTypeID() == v15)
        {
          int valuePtr = 1966083;
          *(void *)int buf = &unk_1ECF9A500;
          CFNumberRef v18 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
          *(void *)&uint8_t buf[8] = v18;
          SerializableArchive::assertEmpty(v17, @"kind");
          if (!v18) {
            goto LABEL_26;
          }
          goto LABEL_25;
        }
        if (CFStringGetTypeID() == v15)
        {
          int valuePtr = 2031619;
          *(void *)int buf = &unk_1ECF9A500;
          CFNumberRef v18 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
          *(void *)&uint8_t buf[8] = v18;
          SerializableArchive::assertEmpty(v17, @"kind");
          if (!v18) {
            goto LABEL_26;
          }
          goto LABEL_25;
        }
        if (CFDataGetTypeID() == v15)
        {
          int valuePtr = 2097155;
          *(void *)int buf = &unk_1ECF9A500;
          CFNumberRef v18 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
          *(void *)&uint8_t buf[8] = v18;
          SerializableArchive::assertEmpty(v17, @"kind");
          if (!v18) {
            goto LABEL_26;
          }
          goto LABEL_25;
        }
        if (CFDateGetTypeID() == v15)
        {
          int valuePtr = 2162691;
          *(void *)int buf = &unk_1ECF9A500;
          CFNumberRef v18 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
          *(void *)&uint8_t buf[8] = v18;
          SerializableArchive::assertEmpty(v17, @"kind");
          if (v18) {
            goto LABEL_25;
          }
LABEL_26:
          *(void *)int buf = &unk_1ECF9A500;
          if (*(void *)&buf[8]) {
            CFRelease(*(CFTypeRef *)&buf[8]);
          }
          SerializableArchive::assertEmpty(v17, @"valu");
          CFDictionarySetValue(v17, @"valu", v14);
          goto LABEL_29;
        }
        if (CFDictionaryGetTypeID() == v15)
        {
          int valuePtr = 2490371;
          *(void *)int buf = &unk_1ECF9A500;
          CFNumberRef v19 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
          *(void *)&uint8_t buf[8] = v19;
          SerializableArchive::assertEmpty(v17, @"kind");
          if (v19) {
            CFDictionarySetValue(v17, @"kind", v19);
          }
          *(void *)int buf = &unk_1ECF9A500;
          if (*(void *)&buf[8]) {
            CFRelease(*(CFTypeRef *)&buf[8]);
          }
          SerializableArchive::add((SerializableArchive *)&v32, @"valu", (CFDictionaryRef)v14);
        }
        else if (CFArrayGetTypeID() == v15)
        {
          int valuePtr = 2555907;
          *(void *)int buf = &unk_1ECF9A500;
          CFNumberRef v20 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
          *(void *)&uint8_t buf[8] = v20;
          SerializableArchive::assertEmpty(v17, @"kind");
          if (v20) {
            CFDictionarySetValue(v17, @"kind", v20);
          }
          *(void *)int buf = &unk_1ECF9A500;
          if (*(void *)&buf[8]) {
            CFRelease(*(CFTypeRef *)&buf[8]);
          }
          SerializableArchive::add((SerializableArchive *)&v32, @"valu", (const __CFArray *)v14);
        }
        else if (CFErrorGetTypeID() == v15)
        {
          int valuePtr = 2621443;
          *(void *)int buf = &unk_1ECF9A500;
          CFNumberRef v21 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
          *(void *)&uint8_t buf[8] = v21;
          SerializableArchive::assertEmpty(v17, @"kind");
          if (v21) {
            CFDictionarySetValue(v17, @"kind", v21);
          }
          *(void *)int buf = &unk_1ECF9A500;
          if (*(void *)&buf[8]) {
            CFRelease(*(CFTypeRef *)&buf[8]);
          }
          SerializableArchive::add((CFTypeRef *)&v32, @"valu", (__CFError *)v14);
        }
        else if (CFURLGetTypeID() == v15)
        {
          SerializableArchive::add(&v32, (const __CFString *)0x290003);
          SerializableArchive::add(&v32, (CFURLRef)v14, v22);
        }
        else
        {
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            SerializableArchive::add(&v32, (const __CFString *)0x2E0003);
            SerializableArchive::add(&v32, @"valu", v14);
          }
          else
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              SerializableArchive::add(&v32, (const __CFString *)0x2F0003);
              SerializableArchive::add((CFTypeRef *)&v32, v14, v23);
            }
            else if (SecAccessControlGetTypeID() == v15)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x390003);
              SerializableArchive::add((CFTypeRef *)&v32, v14, v24);
            }
            else if (SecTrustGetTypeID() == v15)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x3C0003);
              SerializableArchive::add((CFTypeRef *)&v32, @"valu", (__SecTrust *)v14);
            }
            else if (SecCertificateGetTypeID() == v15)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x3E0003);
              SerializableArchive::add(&v32, (SecCertificateRef)v14, v25);
            }
            else if (SecPolicyGetTypeID() == v15)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x3F0003);
              SerializableArchive::add(&v32, v14, v26);
            }
            else if (SecKeyGetTypeID() == v15)
            {
              SerializableArchive::add(&v32, (const __CFString *)0x400003);
              SerializableArchive::add(&v32, v27, v28);
            }
            else
            {
              if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
                dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
              }
              if (*(void *)(URLCredential::Class(void)::sClass_OBJTYPE + 96) == v15)
              {
                SerializableArchive::add(&v32, (const __CFString *)0x4E0003);
                SerializableArchive::add(&v32, @"valu", (const _CFURLCredential *)v14);
              }
              else
              {
                if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
                  dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
                }
                if (*(void *)(URLAuthChallenge::Class(void)::sClass_OBJTYPE + 96) == v15)
                {
                  SerializableArchive::add(&v32, (const __CFString *)0x4F0003);
                  SerializableArchive::add(&v32, v14, v29);
                }
                else
                {
                  if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
                    dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
                  }
                  if (*(void *)(URLProtectionSpace::Class(void)::sClass_OBJTYPE + 96) != v15)
                  {
                    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)int buf = 138412546;
                      *(void *)&uint8_t buf[4] = v12;
                      *(_WORD *)&buf[12] = 2112;
                      *(void *)&buf[14] = v14;
                      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Unable to serialize key %@ as object %@", buf, 0x16u);
                    }
                    goto LABEL_30;
                  }
                  SerializableArchive::add(&v32, (const __CFString *)0x500003);
                  SerializableArchive::add((SerializableArchive *)&v32, @"valu", (_CFURLProtectionSpace *)v14);
                }
              }
            }
          }
        }
LABEL_29:
        SerializableArchive::assertEmpty(Mutable, v12);
        CFDictionarySetValue(Mutable, v12, v17);
LABEL_30:
        if (v17) {
          CFRelease(v17);
        }
LABEL_32:
        AutoString::~AutoString((AutoString *)&v34);
        if (Count == ++v10) {
          goto LABEL_82;
        }
      }
      int valuePtr = 1900547;
      *(void *)int buf = &unk_1ECF9A500;
      CFNumberRef v18 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
      *(void *)&uint8_t buf[8] = v18;
      SerializableArchive::assertEmpty(v17, @"kind");
      if (!v18) {
        goto LABEL_26;
      }
LABEL_25:
      CFDictionarySetValue(v17, @"kind", v18);
      goto LABEL_26;
    }
LABEL_82:
    SerializableArchive::assertEmpty((SerializableArchive *)*this, v30);
    CFDictionarySetValue((CFMutableDictionaryRef)*this, v30, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
}

void sub_1842D4FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, CFTypeRef cf)
{
  *(void *)(v22 - 128) = v20;
  uint64_t v24 = *(const void **)(v22 - 120);
  if (v24) {
    CFRelease(v24);
  }
  if (v21) {
    CFRelease(v21);
  }
  AutoString::~AutoString((AutoString *)&a18);
  if (v19) {
    CFRelease(v19);
  }
  _Unwind_Resume(a1);
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2)
{
  AutoScalar::AutoScalar((AutoScalar *)&v4, (const __CFAllocator *)a2);
  CFTypeRef v3 = cf;
  SerializableArchive::assertEmpty(*this, @"kind");
  if (v3) {
    CFDictionarySetValue(*this, @"kind", v3);
  }
  CFURLRef v4 = &unk_1ECF9A500;
  if (cf) {
    CFRelease(cf);
  }
}

void sub_1842D5114(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2, void *cf)
{
  if (cf)
  {
    CFAllocatorRef v6 = CFGetAllocator(cf);
    CFDictionaryRef v7 = URLResponse::copyPropertyList((URLResponse *)[cf _inner], v6);
    SerializableArchive::assertEmpty(*this, a2);
    if (v7)
    {
      CFDictionarySetValue(*this, a2, v7);
      CFRelease(v7);
    }
  }
}

void SerializableArchive::add(CFTypeRef *this, __CFString *a2, NSURLRequest *a3)
{
  CFNumberRef v19 = 0;
  uint64_t v20 = 0;
  CFDictionaryRef theDict = 0;
  uint64_t v18 = 0;
  CFAllocatorRef v5 = CFGetAllocator(*this);
  if (a2) {
    URLRequest::createArchiveList((URLRequest *)[(__CFString *)a2 _inner], v5, (uint64_t *)&v20, (const void ***)&v19, &v18, &theDict);
  }
  else {
    uint64_t v18 = 22;
  }
  CFAllocatorRef v6 = CFGetAllocator(*this);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFAllocatorRef v16 = Mutable;
  CFAllocatorRef v8 = CFGetAllocator(*this);
  uint64_t v10 = v18;
  CFTypeRef v9 = v19;
  CFArrayRef v11 = CFArrayCreate(v8, (const void **)v19, v18, MEMORY[0x1E4F1D510]);
  AutoScalar::AutoScalar((AutoScalar *)&v21, (const __CFAllocator *)v20);
  CFTypeRef v12 = cf;
  SerializableArchive::assertEmpty(Mutable, @"version");
  if (v12) {
    CFDictionarySetValue(Mutable, @"version", v12);
  }
  CFNumberRef v21 = &unk_1ECF9A500;
  if (cf) {
    CFRelease(cf);
  }
  SerializableArchive::add((SerializableArchive *)&v16, @"objects", v11);
  if (v11) {
    CFRelease(v11);
  }
  CFDictionaryRef v13 = theDict;
  if (theDict)
  {
    SerializableArchive::add((SerializableArchive *)&v16, @"protocolProperties", theDict);
    CFRelease(v13);
  }
  SerializableArchive::assertEmpty((SerializableArchive *)*this, @"valu");
  CFDictionarySetValue((CFMutableDictionaryRef)*this, @"valu", Mutable);
  if (v10 >= 1)
  {
    do
    {
      uint64_t v14 = v9[v10 - 1];
      if (v14) {
        CFRelease(v14);
      }
      --v10;
    }
    while ((unint64_t)(v10 + 1) > 1);
  }
  CFAllocatorRef v15 = CFGetAllocator(*this);
  CFAllocatorDeallocate(v15, v9);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void sub_1842D53BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  if (v16) {
    CFRelease(v16);
  }
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(CFTypeRef *this, const __CFString *a2, __SecAccessControl *a3)
{
  CFAllocatorRef v4 = CFGetAllocator(*this);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFAllocatorRef v6 = (const void *)SecAccessControlCopyData();
  if (v6)
  {
    SerializableArchive::assertEmpty(Mutable, @"data");
    CFDictionarySetValue(Mutable, @"data", v6);
    CFRelease(v6);
  }
  SerializableArchive::assertEmpty((SerializableArchive *)*this, @"valu");
  CFDictionarySetValue((CFMutableDictionaryRef)*this, @"valu", Mutable);
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

void sub_1842D54E4(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(CFTypeRef *this, const __CFString *a2, __SecTrust *a3)
{
  if (a3)
  {
    CFAllocatorRef v6 = CFGetAllocator(*this);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFMutableDictionaryRef v10 = Mutable;
    SecTrustEvaluateWithError(a3, 0);
    CFTypeRef cf = 0;
    SecTrustCopyPolicies(a3, (CFArrayRef *)&cf);
    CFArrayRef v8 = SecTrustCopyCertificateChain(a3);
    if (cf)
    {
      SerializableArchive::add((SerializableArchive *)&v10, @"policies", (const __CFArray *)cf);
      if (cf) {
        CFRelease(cf);
      }
    }
    if (v8) {
      SerializableArchive::add((SerializableArchive *)&v10, @"certs", v8);
    }
    SerializableArchive::assertEmpty((SerializableArchive *)*this, a2);
    CFDictionarySetValue((CFMutableDictionaryRef)*this, a2, Mutable);
    if (v8) {
      CFRelease(v8);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
}

void sub_1842D55F8(_Unwind_Exception *a1)
{
  CFRelease(v2);
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(a1);
}

void SerializableArchive::add(SerializableArchive **this, SecCertificateRef certificate, __SecCertificate *a3)
{
  CFDataRef v4 = SecCertificateCopyData(certificate);
  if (v4)
  {
    CFDataRef v5 = v4;
    SerializableArchive::assertEmpty(*this, @"valu");
    CFDictionarySetValue(*this, @"valu", v5);
    CFRelease(v5);
  }
}

void SerializableArchive::add(SerializableArchive **this, void *cf, __SecPolicy *a3)
{
  CFAllocatorRef v5 = CFGetAllocator(cf);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef v8 = Mutable;
  CFDictionaryRef v7 = SecPolicyCopyProperties((SecPolicyRef)cf);
  if (v7)
  {
    SerializableArchive::add((SerializableArchive *)&v8, @"properties", v7);
    CFRelease(v7);
  }
  SerializableArchive::assertEmpty(*this, @"valu");
  CFDictionarySetValue(*this, @"valu", Mutable);
  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

void sub_1842D578C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2, __SecKey *a3)
{
  SerializableArchive::assertEmpty(*this, @"valu");
  CFDataRef v4 = *this;

  CFDictionarySetValue(v4, @"valu", @"key_not_serialized");
}

void SerializableArchive::add(SerializableArchive **this, const __CFString *a2, _CFURLAuthChallenge *a3)
{
  if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
    dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
  }
  SerializableArchive::assertEmpty(*this, @"valu");
  CFAllocatorRef v5 = CFGetAllocator(*this);
  CFTypeRef cf = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if ((*(unsigned int (**)(uint64_t *, CFTypeRef *))(a2->length + 24))(&a2->length, &cf)) {
    SerializableArchive::add((SerializableArchive *)this, @"valu", (CFDictionaryRef)cf);
  }
  if (cf) {
    CFRelease(cf);
  }
}

void sub_1842D58D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::deserialize(DeserializableArchive *this, CFErrorRef *a2, __CFError **a3)
{
  v13[1] = CFGetAllocator(this);
  CFDictionaryRef v5 = (const __CFDictionary *)CFRetain(this);
  v13[0] = v5;
  CFNumberRef Value = CFDictionaryGetValue(v5, @"domain");
  if (Value) {
    CFStringRef v7 = (const __CFString *)CFRetain(Value);
  }
  else {
    CFStringRef v7 = 0;
  }
  CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue(v5, @"code");
  if (v8)
  {
    CFDictionaryRef valuePtr = 0;
    CFNumberGetValue(v8, kCFNumberCFIndexType, &valuePtr);
    CFIndex v9 = (CFIndex)valuePtr;
  }
  else
  {
    CFIndex v9 = 0;
  }
  CFDictionaryRef valuePtr = 0;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  DeserializableArchive::decant((DeserializableArchive *)v13, @"userinfo", TypeID, (const void **)&valuePtr);
  CFDictionaryRef v11 = valuePtr;
  if (a2)
  {
    CFAllocatorRef v12 = CFGetAllocator(this);
    *a2 = CFErrorCreate(v12, v7, v9, v11);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v5) {
    CFRelease(v5);
  }
}

void sub_1842D59F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::decant(CFDictionaryRef *this, const __CFString *a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  *a4 = 0;
  CFStringRef v7 = (__CFString *)CFDictionaryGetValue(*this, a2);
  if (!v7) {
    return;
  }
  CFNumberRef v8 = v7;
  if (CFBooleanGetTypeID() == a3 && CFGetTypeID(v8) == a3
    || CFNumberGetTypeID() == a3 && CFGetTypeID(v8) == a3
    || CFStringGetTypeID() == a3 && CFGetTypeID(v8) == a3
    || CFDataGetTypeID() == a3 && CFGetTypeID(v8) == a3
    || CFDateGetTypeID() == a3 && CFGetTypeID(v8) == a3)
  {
    CFIndex v9 = (__CFError *)CFRetain(v8);
LABEL_13:
    *a4 = v9;
    return;
  }
  if (CFDictionaryGetTypeID() == a3)
  {
    *(void *)&valuePtr[8] = CFGetAllocator(v8);
    CFTypeRef v10 = CFRetain(v8);
    *(void *)CFDictionaryRef valuePtr = v10;
    *(void *)uint64_t v43 = 0;
    CFTypeID TypeID = CFArrayGetTypeID();
    DeserializableArchive::decant((DeserializableArchive *)valuePtr, @"keys", TypeID, (const void **)v43);
    CFArrayRef v12 = *(const __CFArray **)v43;
    *(void *)uint64_t v43 = 0;
    CFTypeID v13 = CFArrayGetTypeID();
    DeserializableArchive::decant((DeserializableArchive *)valuePtr, @"vals", v13, (const void **)v43);
    CFArrayRef v14 = *(const __CFArray **)v43;
    if (v12)
    {
      CFIndex Count = CFArrayGetCount(v12);
      if (v14)
      {
LABEL_18:
        CFIndex v16 = CFArrayGetCount(v14);
        goto LABEL_28;
      }
    }
    else
    {
      CFIndex Count = 0;
      if (*(void *)v43) {
        goto LABEL_18;
      }
    }
    CFIndex v16 = 0;
LABEL_28:
    if (Count == v16)
    {
      CFAllocatorRef v20 = CFGetAllocator(v8);
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v20, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v12, i);
          uint64_t v24 = CFArrayGetValueAtIndex(v14, i);
          CFDictionarySetValue(Mutable, ValueAtIndex, v24);
        }
      }
      *a4 = Mutable;
    }
    if (v12) {
      CFRelease(v12);
    }
    if (v14) {
      CFRelease(v14);
    }
    if (!v10) {
      return;
    }
LABEL_106:
    CFRelease(v10);
    return;
  }
  if (CFArrayGetTypeID() == a3)
  {
    CFGetAllocator(v8);
    CFTypeRef v10 = CFRetain(v8);
    CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v10, @"count");
    if (v17)
    {
      *(void *)CFDictionaryRef valuePtr = 0;
      CFNumberGetValue(v17, kCFNumberCFIndexType, valuePtr);
      uint64_t v18 = *(void *)valuePtr;
    }
    else
    {
      uint64_t v18 = 0;
    }
    CFAllocatorRef v26 = CFGetAllocator(v8);
    CFMutableArrayRef v27 = CFArrayCreateMutable(v26, 0, MEMORY[0x1E4F1D510]);
    if (v18 < 1)
    {
LABEL_105:
      *a4 = v27;
      if (!v10) {
        return;
      }
      goto LABEL_106;
    }
    uint64_t v28 = 0;
    uint64_t v29 = MEMORY[0x1E4F14500];
    while (1)
    {
      CFAllocatorRef v30 = CFGetAllocator(v8);
      AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)valuePtr, v30, @"ix%ld", v28);
      value = 0;
      uint64_t v31 = CFDictionaryGetValue((CFDictionaryRef)v10, *(const void **)&valuePtr[8]);
      uint64_t v32 = v31;
      if (v31) {
        break;
      }
LABEL_99:
      if (value)
      {
        CFArrayAppendValue(v27, value);
        if (value) {
          CFRelease(value);
        }
      }
      else if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t v43 = 134218242;
        *(void *)&v43[4] = v28;
        *(_WORD *)&v43[12] = 2112;
        *(void *)&v43[14] = v8;
        _os_log_fault_impl(&dword_184085000, v29, OS_LOG_TYPE_FAULT, "Deserialize error on index %ld of array %@", v43, 0x16u);
      }
      AutoString::~AutoString((AutoString *)valuePtr);
      if (v18 == ++v28) {
        goto LABEL_105;
      }
    }
    *(void *)&v43[8] = CFGetAllocator(v31);
    CFDictionaryRef v33 = (const __CFDictionary *)CFRetain(v32);
    *(void *)uint64_t v43 = v33;
    CFNumberRef v34 = (const __CFNumber *)CFDictionaryGetValue(v33, @"kind");
    if (v34)
    {
      *(void *)int buf = 0;
      CFNumberGetValue(v34, kCFNumberCFIndexType, buf);
      if (*(uint64_t *)buf <= 3014658)
      {
        if (*(uint64_t *)buf <= 2162690)
        {
          if (*(uint64_t *)buf > 2031618)
          {
            if (*(void *)buf == 2031619)
            {
              CFTypeID v35 = CFStringGetTypeID();
              goto LABEL_96;
            }
            if (*(void *)buf == 2097155)
            {
              CFTypeID v35 = CFDataGetTypeID();
              goto LABEL_96;
            }
          }
          else
          {
            if (*(void *)buf == 1900547)
            {
              CFTypeID v35 = CFBooleanGetTypeID();
              goto LABEL_96;
            }
            if (*(void *)buf == 1966083)
            {
              CFTypeID v35 = CFNumberGetTypeID();
              goto LABEL_96;
            }
          }
        }
        else if (*(uint64_t *)buf <= 2555906)
        {
          if (*(void *)buf == 2162691)
          {
            CFTypeID v35 = CFDateGetTypeID();
            goto LABEL_96;
          }
          if (*(void *)buf == 2490371)
          {
            CFTypeID v35 = CFDictionaryGetTypeID();
            goto LABEL_96;
          }
        }
        else
        {
          switch(*(void *)buf)
          {
            case 0x270003:
              CFTypeID v35 = CFArrayGetTypeID();
              goto LABEL_96;
            case 0x280003:
              CFTypeID v35 = CFErrorGetTypeID();
              goto LABEL_96;
            case 0x290003:
              CFTypeID v35 = CFURLGetTypeID();
              goto LABEL_96;
          }
        }
      }
      else if (*(uint64_t *)buf > 4128770)
      {
        if (*(uint64_t *)buf <= 5111810)
        {
          if (*(void *)buf == 4128771)
          {
            CFTypeID v35 = SecPolicyGetTypeID();
            goto LABEL_96;
          }
          if (*(void *)buf == 4194307)
          {
            CFTypeID v35 = SecKeyGetTypeID();
            goto LABEL_96;
          }
        }
        else if (*(void *)buf == 5111811 || *(void *)buf == 5177347 || *(void *)buf == 5242883)
        {
          *(void *)int buf = 0;
          DeserializableArchive::decant((const __CFAllocator **)v43, @"valu", (Serializable **)buf);
          if (*(void *)buf) {
            uint64_t v37 = (void *)(*(void *)buf - 24);
          }
          else {
            uint64_t v37 = 0;
          }
          value = v37;
LABEL_97:
          if (v33) {
            CFRelease(v33);
          }
          goto LABEL_99;
        }
      }
      else if (*(uint64_t *)buf <= 3735554)
      {
        if (*(void *)buf == 3014659 || *(void *)buf == 3080195)
        {
          uint64_t v36 = (objc_class *)objc_opt_class();
          DeserializableArchive::decantClass((CFDictionaryRef *)v43, @"valu", v36, (NSObject **)&value);
          goto LABEL_97;
        }
      }
      else
      {
        switch(*(void *)buf)
        {
          case 0x390003:
            CFTypeID v35 = SecAccessControlGetTypeID();
            goto LABEL_96;
          case 0x3C0003:
            CFTypeID v35 = SecTrustGetTypeID();
            goto LABEL_96;
          case 0x3E0003:
            CFTypeID v35 = SecCertificateGetTypeID();
LABEL_96:
            DeserializableArchive::decant((DeserializableArchive *)v43, @"valu", v35, (const void **)&value);
            goto LABEL_97;
        }
      }
    }
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 138412290;
      *(void *)&uint8_t buf[4] = v32;
      _os_log_fault_impl(&dword_184085000, v29, OS_LOG_TYPE_FAULT, "Unable to deserialize %@", buf, 0xCu);
    }
    goto LABEL_97;
  }
  if (CFErrorGetTypeID() == a3)
  {
    DeserializableArchive::deserialize((DeserializableArchive *)v8, a4, v19);
  }
  else if (CFURLGetTypeID() == a3)
  {
    DeserializableArchive::deserialize(v8, a4, v25);
  }
  else if (SecAccessControlGetTypeID() == a3)
  {
    DeserializableArchive::deserialize((DeserializableArchive *)v8, (uint64_t *)a4, v38);
  }
  else if (SecTrustGetTypeID() == a3)
  {
    DeserializableArchive::deserialize((DeserializableArchive *)v8, (CFTypeRef *)a4, v39);
  }
  else
  {
    if (SecCertificateGetTypeID() == a3)
    {
      CFAllocatorRef v40 = CFGetAllocator(v8);
      CFIndex v9 = SecCertificateCreateWithData(v40, (CFDataRef)v8);
      goto LABEL_13;
    }
    if (SecPolicyGetTypeID() == a3)
    {
      DeserializableArchive::deserialize((DeserializableArchive *)v8, a4, v41);
    }
    else if (SecKeyGetTypeID() == a3)
    {
      *a4 = 0;
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)CFDictionaryRef valuePtr = 138412546;
      *(void *)&valuePtr[4] = a2;
      *(_WORD *)&valuePtr[12] = 2048;
      *(void *)&valuePtr[14] = a3;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Unable to deserialize key %@ as type %lu - is there a specialization", valuePtr, 0x16u);
    }
  }
}

void sub_1842D6384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (v22) {
    CFRelease(v22);
  }
  AutoString::~AutoString((AutoString *)&a21);
  if (v21) {
    CFRelease(v21);
  }
  _Unwind_Resume(a1);
}

void DeserializableArchive::deserialize(DeserializableArchive *this, uint64_t *a2, __SecAccessControl **a3)
{
  CFGetAllocator(this);
  CFDictionaryRef v5 = (const __CFDictionary *)CFRetain(this);
  CFNumberRef Value = CFDictionaryGetValue(v5, @"data");
  if (Value)
  {
    CFTypeRef v7 = CFRetain(Value);
    if (v7)
    {
      CFGetAllocator(this);
      *a2 = SecAccessControlCreateFromData();
      CFRelease(v7);
    }
  }
  if (v5)
  {
    CFRelease(v5);
  }
}

void sub_1842D648C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::deserialize(DeserializableArchive *this, CFTypeRef *a2, __SecTrust **a3)
{
  v10[1] = CFGetAllocator(this);
  CFTypeRef v5 = CFRetain(this);
  v10[0] = v5;
  CFTypeRef certificates = 0;
  CFTypeID TypeID = CFArrayGetTypeID();
  DeserializableArchive::decant((DeserializableArchive *)v10, @"policies", TypeID, &certificates);
  CFTypeRef v7 = certificates;
  CFTypeRef certificates = 0;
  CFTypeID v8 = CFArrayGetTypeID();
  DeserializableArchive::decant((DeserializableArchive *)v10, @"certs", v8, &certificates);
  CFTypeRef v9 = certificates;
  if (SecTrustCreateWithCertificates(certificates, v7, (SecTrustRef *)a2))
  {
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = 0;
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v5) {
    CFRelease(v5);
  }
}

void sub_1842D6580(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::deserialize(DeserializableArchive *this, SecPolicyRef *a2, __SecPolicy **a3)
{
  v9[1] = CFGetAllocator(this);
  CFTypeRef v5 = CFRetain(this);
  v9[0] = v5;
  CFDictionaryRef theDict = 0;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  DeserializableArchive::decant((DeserializableArchive *)v9, @"properties", TypeID, (const void **)&theDict);
  CFDictionaryRef v7 = theDict;
  if (theDict)
  {
    CFNumberRef Value = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F3BC00]);
    if (Value) {
      *a2 = SecPolicyCreateWithProperties(Value, v7);
    }
    CFRelease(v7);
  }
  if (!*a2) {
    *a2 = SecPolicyCreateSSL(0, 0);
  }
  if (v5) {
    CFRelease(v5);
  }
}

void sub_1842D6660(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::decantClass(CFDictionaryRef *this, const __CFString *a2, objc_class *a3, NSObject **a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  *a4 = 0;
  CFNumberRef Value = CFDictionaryGetValue(*this, a2);
  if (Value)
  {
    CFTypeID v8 = Value;
    if ((objc_class *)objc_opt_class() == a3)
    {
      CFGetAllocator(v8);
      *a4 = _CFURLResponseCreateFromPropertyList((const __CFAllocator *)v8, v9);
    }
    else if ((objc_class *)objc_opt_class() == a3)
    {
      *(void *)&uint8_t buf[8] = CFGetAllocator(v8);
      CFDictionaryRef v10 = (const __CFDictionary *)CFRetain(v8);
      *(void *)int buf = v10;
      CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue(v10, @"version");
      if (v11)
      {
        CFArrayRef valuePtr = 0;
        CFNumberGetValue(v11, kCFNumberCFIndexType, &valuePtr);
      }
      CFArrayRef valuePtr = 0;
      CFTypeID TypeID = CFArrayGetTypeID();
      DeserializableArchive::decant((DeserializableArchive *)buf, @"objects", TypeID, (const void **)&valuePtr);
      CFArrayRef v13 = valuePtr;
      if (valuePtr)
      {
        CFArrayRef valuePtr = 0;
        CFTypeID v14 = CFDictionaryGetTypeID();
        DeserializableArchive::decant((DeserializableArchive *)buf, @"protocolProperties", v14, (const void **)&valuePtr);
        CFArrayGetCount(v13);
        operator new[]();
      }
      if (v10) {
        CFRelease(v10);
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 138412546;
      *(void *)&uint8_t buf[4] = a2;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = a3;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Unable to deserialize key %@ as class %@ - is there a specialization", buf, 0x16u);
    }
  }
}

void sub_1842D68D4(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void DeserializableArchive::decant(const __CFAllocator **this, const __CFString *a2, Serializable **a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  *(void *)CFTypeRef cf = 0;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  DeserializableArchive::decant((DeserializableArchive *)this, a2, TypeID, (const void **)cf);
  CFDictionaryRef v7 = *(const void **)cf;
  if (!*(void *)cf)
  {
    *a3 = 0;
    return;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)CFRetain(*(CFTypeRef *)cf);
  CFAllocatorRef v9 = this[1];
  CFNumberRef Value = CFDictionaryGetValue(v8, @"_kind");
  if (!Value || (CFStringRef v11 = (const __CFString *)CFRetain(Value), (v12 = v11) == 0))
  {
    uint64_t v17 = 0;
    goto LABEL_34;
  }
  int ExactString = _findExactString(v11, 0xDu);
  switch(ExactString)
  {
    case 564255894:
      CFAllocatorRef v15 = (char *)_CFURLAuthChallengeCreateFromArchive(v9, v8);
      if (v15)
      {
        if (URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge != -1) {
          dispatch_once(&URLAuthChallenge::Class(void)::sOnce_URLAuthChallenge, &__block_literal_global_10199);
        }
        CFIndex v16 = v15 + 16;
      }
      else
      {
        CFIndex v16 = 0;
      }
      break;
    case 565271710:
      uint64_t v18 = URLCredential::createFromPropertyList(v9, v8, v14);
      if (v18) {
        CFAllocatorRef v15 = (char *)v18 - 16;
      }
      else {
        CFAllocatorRef v15 = 0;
      }
      if (v18)
      {
        if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
          dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
        }
        CFIndex v16 = v15 + 16;
      }
      else
      {
        CFIndex v16 = 0;
      }
      break;
    case 566369444:
      CFAllocatorRef v15 = (char *)_CFURLProtectionSpaceCreateFromArchive(v9, v8);
      if (v15)
      {
        if (URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace != -1) {
          dispatch_once(&URLProtectionSpace::Class(void)::sOnce_URLProtectionSpace, &__block_literal_global_10309);
        }
        CFIndex v16 = v15 + 16;
      }
      else
      {
        CFIndex v16 = 0;
      }
      break;
    default:
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)CFTypeRef cf = 138412290;
        *(void *)&cf[4] = v12;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Don't know how to deserialize %@", cf, 0xCu);
      }
      uint64_t v17 = 0;
      goto LABEL_33;
  }
  CFRetain(v16 - 16);
  CFRelease(v15);
  if (v16) {
    uint64_t v17 = (Serializable *)(v16 + 8);
  }
  else {
    uint64_t v17 = 0;
  }
LABEL_33:
  CFRelease(v12);
LABEL_34:
  *a3 = v17;
  CFRelease(v7);
  if (v8) {
    CFRelease(v8);
  }
}

void sub_1842D6BA4(_Unwind_Exception *exception_object)
{
}

void HTTPBodyData::~HTTPBodyData(HTTPBodyData *this, const char *a2)
{
  *(void *)this = &unk_1ECF9B760;
  HTTPBodyData::becomeEmpty(this, a2);
}

const __CFData *HTTPBodyData::getLength(const __CFData **this, const char *a2)
{
  HTTPBodyData::logit((HTTPBodyData *)this, a2);
  CFDataRef result = this[2];
  if (result || (CFDataRef result = this[3]) != 0)
  {
    return (const __CFData *)CFDataGetLength(result);
  }
  return result;
}

void non-virtual thunk to'SAwaitingTube::~SAwaitingTube(SAwaitingTube *this)
{
  uint64_t v2 = (char *)this - 24;
  SAwaitingTube::~SAwaitingTube((SAwaitingTube *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  SAwaitingTube::~SAwaitingTube((SAwaitingTube *)((char *)this - 24));
}

void SAwaitingTube::~SAwaitingTube(SAwaitingTube *this)
{
  *(void *)this = &unk_1ECF9C508;
  *((void *)this + 3) = &unk_1ECF9C590;
  (*(void (**)(void))(**((void **)this + 4) + 48))(*((void *)this + 4));
  *((void *)this + 4) = 0;
  (*(void (**)(void))(**((void **)this + 6) + 24))(*((void *)this + 6));
  *((void *)this + 6) = 0;
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    *((void *)this + 10) = 0;
  }
  CFRelease((CFTypeRef)(*((void *)this + 5) - 16));
  *((void *)this + 5) = 0;
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  SAwaitingTube::~SAwaitingTube(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1842D6DB0(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

BOOL SAwaitingTube::isValid(SAwaitingTube *this)
{
  return (*(unsigned int (**)(void))(**((void **)this + 6) + 184))(*((void *)this + 6)) != 0;
}

void SAwaitingTube::getRequestToEnqueue(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  *a3 = *(void *)(a1 + 40);
  *a2 = *(void *)(a1 + 48);
  long long v4 = *(_OWORD *)(a1 + 56);
  *(void *)(a4 + CFRetain((char *)this - 16) = *(void *)(a1 + 72);
  *(_OWORD *)a4 = v4;
  *(CFAbsoluteTime *)(a1 + 96) = CFAbsoluteTimeGetCurrent();
}

__n128 SAwaitingTube::getOptions@<Q0>(SAwaitingTube *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = *(__n128 *)((char *)this + 56);
  *a2 = result;
  a2[1].n128_u64[0] = *((void *)this + 9);
  return result;
}

uint64_t SAwaitingTube::getRequest(SAwaitingTube *this)
{
  return *((void *)this + 5);
}

uint64_t SAwaitingTube::getClient(SAwaitingTube *this)
{
  return *((void *)this + 6);
}

uint64_t SAwaitingTube::linkWithTube(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 48))(v4);
    *(void *)(a1 + ++*(void *)(this + 80) = 0;
  }
  if (a2)
  {
    *(void *)(a1 + ++*(void *)(this + 80) = a2;
    (*(void (**)(uint64_t))(*(void *)a2 + 40))(a2);
  }
  CFTypeRef v5 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 56);

  return v5();
}

void non-virtual thunk to'StorageSession::~StorageSession(StorageSession *this)
{
}

{
  StorageSession::~StorageSession((StorageSession *)((char *)this - 8));
}

void StorageSession::~StorageSession(StorageSession *this)
{
  *(void *)this = &unk_1ECF9CFC8;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9D010;
  CFDictionaryRef v2 = (const __CFDictionary *)*((void *)this + 10);
  if (v2 && CFDictionaryGetValue(v2, @"kCFURLStorageSessionIsPrivate") == (const void *)*MEMORY[0x1E4F1CFD0])
  {
    CFAllocatorRef v3 = (char *)*((void *)this + 3);
    if (v3) {
      CFHTTPCookieStorageDeleteAllCookies(v3);
    }
    uint64_t v4 = (const void *)*((void *)this + 2);
    if (v4)
    {
      CFTypeRef v5 = CFRetain(v4);
      dispatch_queue_t global_queue = dispatch_get_global_queue(0, 0);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZN14StorageSessionD2Ev_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v5;
      dispatch_async(global_queue, block);
    }
    uint64_t v7 = *((void *)this + 5);
    if (v7) {
      _CFHSTSPolicyResetHSTSHostsSinceDate(v7, 0);
    }
  }
  CFDictionaryRef v8 = (const void *)*((void *)this + 2);
  if (v8) {
    CFRelease(v8);
  }
  CFAllocatorRef v9 = (const void *)*((void *)this + 3);
  if (v9) {
    CFRelease(v9);
  }
  CFDictionaryRef v10 = (const void *)*((void *)this + 4);
  if (v10) {
    CFRelease(v10);
  }
  CFStringRef v11 = (const void *)*((void *)this + 5);
  if (v11) {
    CFRelease(v11);
  }
  CFStringRef v12 = (const void *)*((void *)this + 9);
  if (v12) {
    CFRelease(v12);
  }
  CFArrayRef v13 = (const void *)*((void *)this + 10);
  if (v13) {
    CFRelease(v13);
  }
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9B550;
}

void sub_1842D7118(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void ___ZN14StorageSessionD2Ev_block_invoke(uint64_t a1)
{
  CFURLCacheRemoveAllCachedResponses(*(void **)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v4 = *(void *)(v2 + 16);
    CFAllocatorRef v3 = *(std::__shared_weak_count **)(v2 + 24);
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 56));
    *(unsigned char *)(v4 + 40) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 56));
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
    CFTypeRef v5 = *(const void **)(a1 + 32);
    if (v5)
    {
      CFRelease(v5);
    }
  }
}

void sub_1842D71D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  _Unwind_Resume(exception_object);
}

CFStringRef StorageSession::copyDebugDesc(const __CFDictionary **this)
{
  CFStringRef v2 = CFObject::copyDebugDescHeader((CFObject *)this);
  CFAllocatorRef v3 = CFGetAllocator(this - 2);
  BOOL v4 = *((unsigned char *)this + 56) != 0;
  CFDictionaryRef v5 = this[10];
  if (v5)
  {
    BOOL v7 = CFDictionaryGetValue(v5, @"kCFURLStorageSessionIsPrivate") == (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionaryRef v8 = this[10];
    if (v8)
    {
      CFAllocatorRef v6 = (const void *)*MEMORY[0x1E4F1CFD0];
      BOOL v9 = CFDictionaryGetValue(v8, @"kCFURLStorageSessionProcessSharing") == v6;
      goto LABEL_6;
    }
  }
  else
  {
    BOOL v7 = 0;
  }
  BOOL v9 = 0;
LABEL_6:
  CFStringRef v10 = CFStringCreateWithFormat(v3, 0, @"%@{ default: %d private: %d process-sharing: %d ident: %@, cache = %p, cookies = %p, auth = %p, hsts = %p }", v2, v4, v7, v9, this[9], this[2], this[3], this[4], this[5]);
  if (v2) {
    CFRelease(v2);
  }
  return v10;
}

CFTypeRef StorageSession::copyHSTSStorage(os_unfair_lock_s *this)
{
  CFStringRef v2 = this + 12;
  os_unfair_lock_lock(this + 12);
  if (!HIBYTE(this[13]._os_unfair_lock_opaque))
  {
    HIBYTE(this[13]._os_unfair_lock_opaque) = 1;
    if (!*(void *)&this[10]._os_unfair_lock_opaque)
    {
      CFDictionaryRef v3 = *(const __CFDictionary **)&this[20]._os_unfair_lock_opaque;
      if (v3 && CFDictionaryGetValue(v3, @"kCFURLStorageSessionIsPrivate") == (const void *)*MEMORY[0x1E4F1CFD0])
      {
        CFAllocatorRef v7 = CFGetAllocator(&this[-4]);
        CFDictionaryRef v5 = CFStringCreateWithFormat(v7, 0, @"%@-%ld", *(void *)&this[18]._os_unfair_lock_opaque, *(void *)&this[16]._os_unfair_lock_opaque);
        CFAllocatorRef v6 = (uint64_t *)MEMORY[0x1E4F1CFC8];
      }
      else
      {
        BOOL v4 = *(const void **)&this[18]._os_unfair_lock_opaque;
        if (v4) {
          CFDictionaryRef v5 = CFRetain(v4);
        }
        else {
          CFDictionaryRef v5 = 0;
        }
        CFAllocatorRef v6 = (uint64_t *)MEMORY[0x1E4F1CFD0];
      }
      uint64_t v8 = *v6;
      CFAllocatorRef v9 = CFGetAllocator(&this[-4]);
      MutableDictionary = cfTypeCreateMutableDictionary(v9, @"hsts_identifier", v5, @"hsts_persistent", v8, 0, 0);
      if (v5) {
        CFRelease(v5);
      }
      CFAllocatorRef v11 = CFGetAllocator(&this[-4]);
      *(void *)&this[10]._os_unfair_lock_opaque = _CFHSTSPolicyCreateWithProperties((uint64_t)v11, MutableDictionary);
      if (MutableDictionary) {
        CFRelease(MutableDictionary);
      }
    }
  }
  os_unfair_lock_unlock(v2);
  CFTypeRef result = *(CFTypeRef *)&this[10]._os_unfair_lock_opaque;
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

void ___ZL25ConnectionProtocolConnectP11nw_protocolS0__block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 32) + 384))(*(void *)(a1 + 32), a3);
  (*(void (**)(void))(**(void **)(a1 + 32) + 392))();
  (*(void (**)(void))(**(void **)(a1 + 32) + 352))();
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  CFAllocatorRef v7 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 256))(*(void *)(a1 + 32));
    int v9 = 134218242;
    uint64_t v10 = v8;
    __int16 v11 = 2112;
    uint64_t v12 = a5;
    _os_log_impl(&dword_184085000, v7, OS_LOG_TYPE_DEFAULT, "TIC Coalescing TCP Conn [%llu] may go into %@", (uint8_t *)&v9, 0x16u);
  }
}

uint64_t ___ZN18H2CoalescingEngine29findCoalescingConnectionEntryEP14__CFDictionaryPKS0_PK10__CFStringPK9__CFArrayU13block_pointerFvS6_S9_PK8__CFDataS6_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void TransportConnection::initialize(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 216);
  *(void *)(a1 + 208) = v3;
  *(void *)(a1 + 2CFRetain((char *)this - 16) = v2;
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
}

void ___ZN19TransportConnection13associateTaskEP16NSURLSessionTaskNS_20TaskAssociationEventEP24__CFN_TransactionMetrics_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    BOOL v4 = std::__shared_weak_count::lock(v3);
    if (v4)
    {
      CFDictionaryRef v5 = v4;
      uint64_t v6 = *(void *)(a1 + 32);
      if (v6)
      {
        CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongLongType, &valuePtr);
        (*(void (**)(uint64_t, uint64_t, CFNumberRef))(*(void *)v6 + 200))(v6, 0x1EC09EAA0, v7);
        if (v7) {
          CFRelease(v7);
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    }
  }
}

void sub_1842D7744(_Unwind_Exception *a1)
{
  if (v2) {
    CFRelease(v2);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void TransportConnection::rstConnectionDelegate(TransportConnection *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 21);
  *((void *)this + 20) = 0;
  *((void *)this + 2HTTPServerConnection::canceled_onQueue(this - 1) = 0;
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

void TransportConnection::setConnectionDelegate(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 168);
  *(void *)(a1 + 160) = v3;
  *(void *)(a1 + 168) = v2;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void TransportConnection::rstConnectionEstablishmentDelegate(TransportConnection *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 19);
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

void TransportConnection::setConnectionEstablishmentDelegate(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 152);
  *(void *)(a1 + 144) = v3;
  *(void *)(a1 + 152) = v2;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void std::__shared_ptr_pointer<NSObject  {objcproto17OS_dispatch_queue}*,Deleter_DispatchRelease<NSObject  {objcproto17OS_dispatch_queue}*>,std::allocator<NSObject  {objcproto17OS_dispatch_queue}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

CFStringRef TransportConnection::RefCountedWrapper::copyDebugDesc(TransportConnection::RefCountedWrapper *this)
{
  CFAllocatorRef v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0, @"Wrapping TransportConnection(%p)", *((void *)this + 1));
}

void ___ZN9TCFObjectIN19TransportConnection17RefCountedWrapperEE5ClassEv_block_invoke_19783()
{
}

void sub_1842D7910(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void sub_1842D7C80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1842D7EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1842D8034(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842D8150(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842D8260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1842D83B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842D84C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1842D8588(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t NetworkProxyConfiguration::connectionType(NetworkProxyConfiguration *this)
{
  return *((unsigned int *)this + 6);
}

uint64_t NetworkProxyConfiguration::port(NetworkProxyConfiguration *this)
{
  return __rev16(network_proxy_get_port());
}

void NetworkProxyConfiguration::host(CFStringRef *a1@<X8>)
{
  *a1 = 0;
  uint64_t v3 = (void *)network_proxy_copy_host();
  BOOL v4 = v3;
  if (v3)
  {
    string_ptr = xpc_string_get_string_ptr(v3);
    *a1 = CFStringCreateWithCString(0, string_ptr, 0x8000100u);
    xpc_release(v4);
  }
}

void sub_1842D8640(_Unwind_Exception *exception_object)
{
  void *v1 = 0;
  _Unwind_Resume(exception_object);
}

uint64_t std::__shared_ptr_pointer<NSObject  {objcproto16OS_network_proxy}*,void (*)(void *),std::allocator<NSObject  {objcproto16OS_network_proxy}>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_network_proxy}*,void (*)(void *),std::allocator<NSObject  {objcproto16OS_network_proxy}>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18531B6D0);
}

uint64_t estimatedPropertyListSize(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  if (objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass()))
  {
    return [a1 length];
  }
  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      return 8;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      return 8;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v12 = 0;
      uint64_t v13 = &v12;
      uint64_t v14 = 0x2020000000;
      uint64_t v15 = 0;
      v11[0] = MEMORY[0x1E4F143A8];
      v11[1] = 3221225472;
      v11[2] = __estimatedPropertyListSize_block_invoke;
      v11[3] = &unk_1E52578D0;
      v11[4] = &v12;
      [a1 enumerateKeysAndObjectsUsingBlock:v11];
      uint64_t v3 = v13[3];
      _Block_object_dispose(&v12, 8);
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0
        && (long long v9 = 0u,
            long long v10 = 0u,
            long long v7 = 0u,
            long long v8 = 0u,
            (uint64_t v4 = [a1 countByEnumeratingWithState:&v7 objects:v16 count:16]) != 0))
      {
        uint64_t v3 = 0;
        uint64_t v5 = *(void *)v8;
        do
        {
          for (uint64_t i = 0; i != v4; ++i)
          {
            if (*(void *)v8 != v5) {
              objc_enumerationMutation(a1);
            }
            v3 += estimatedPropertyListSize(*(void *)(*((void *)&v7 + 1) + 8 * i));
          }
          uint64_t v4 = [a1 countByEnumeratingWithState:&v7 objects:v16 count:16];
        }
        while (v4);
      }
      else
      {
        return 0;
      }
    }
    return v3;
  }
}

void sub_1842D8998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __estimatedPropertyListSize_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += estimatedPropertyListSize(a2);
  uint64_t result = estimatedPropertyListSize(a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += result;
  return result;
}

uint64_t CFNetworkDiagnosticLevel()
{
  if (DiagnosticLogging::userDiagnosticLevel(void)::onceToken != -1) {
    dispatch_once(&DiagnosticLogging::userDiagnosticLevel(void)::onceToken, &__block_literal_global_16571);
  }
  return DiagnosticLogging::userDiagnosticLevel(void)::sChecked;
}

void CoreReadStreamClient::coreStreamEventsAvailable(CoreReadStreamClient *this, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*((void *)this + 1) && CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
    if (!v2) {
      return;
    }
  }
  else if (!a2)
  {
    return;
  }
  uint64_t v4 = 1;
  do
  {
    if ((v4 & ~v2) == 0)
    {
      (*(void (**)(CoreReadStreamClient *, void, uint64_t))(*(void *)this + 56))(this, *((void *)this + 1), v4);
      v2 &= ~v4;
    }
    v4 *= 2;
  }
  while (v2);
}

void ___ZN14CoreReadStream5ClassEv_block_invoke()
{
}

void sub_1842D8B6C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_UpdateScheduling(CoreReadStreamFromCFReadStream *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  CoreSchedulingSet::_scheduleStream((uint64_t)a2, *((void *)this + 1), (void (*)(uint64_t, uint64_t))_CFStreamUnscheduleFromDispatchQueue, MEMORY[0x1E4F1C270]);
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = (void (*)(uint64_t, uint64_t))MEMORY[0x1E4F1C268];
  uint64_t v7 = MEMORY[0x1E4F1C260];

  CoreSchedulingSet::_scheduleStream((uint64_t)a3, v5, v6, v7);
}

void non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_readAsync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

void CoreReadStreamFromCFReadStream::_streamImpl_readAsync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  (*(void (**)(uint64_t))(*(void *)a4 + 40))(a4);
  CFRetain((CFTypeRef)(a1 - 16));
  dispatch_queue_t global_queue = dispatch_get_global_queue(0, 0);
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  void v10[2] = ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_readAsyncEllPK17CoreSchedulingSetU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke;
  void v10[3] = &unk_1E5257920;
  void v10[6] = a3;
  void v10[7] = a4;
  v10[4] = a5;
  void v10[5] = a1;
  dispatch_async(global_queue, v10);
}

void ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_readAsyncEllPK17CoreSchedulingSetU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = MEMORY[0x1F4188790](a1, a2, a3);
  uint64_t v4 = v3;
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(v3 + 40);
  if (*(void *)(v3 + 48) >= 0x8000uLL) {
    CFIndex v6 = 0x8000;
  }
  else {
    CFIndex v6 = *(void *)(v3 + 48);
  }
  size_t v7 = CFReadStreamRead(*(CFReadStreamRef *)(v5 + 128), buffer, v6);
  if ((v7 & 0x8000000000000000) != 0)
  {
    CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*(void *)(v5 + 128));
    size_t v8 = *(size_t *)&Error.error;
    CFIndex domain = Error.domain;
LABEL_9:
    dispatch_data_t v9 = 0;
    goto LABEL_10;
  }
  size_t v8 = v7;
  if (!v7)
  {
    CFIndex domain = 0;
    goto LABEL_9;
  }
  dispatch_data_t v9 = dispatch_data_create(buffer, v7, 0, 0);
  CFIndex domain = 0;
  size_t v8 = 0;
LABEL_10:
  uint64_t v12 = *(void *)(v4 + 56);
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  void v14[2] = ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_readAsyncEllPK17CoreSchedulingSetU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke_2;
  v14[3] = &unk_1E52578F8;
  uint64_t v13 = *(void *)(v4 + 32);
  v14[4] = v9;
  v14[5] = v13;
  v14[6] = domain;
  void v14[7] = v8;
  (*(void (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, v14);
  (*(void (**)(void))(**(void **)(v4 + 56) + 48))(*(void *)(v4 + 56));
  CFRelease((CFTypeRef)(v5 - 16));
}

void ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_readAsyncEllPK17CoreSchedulingSetU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke_2(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  uint64_t v2 = *(NSObject **)(a1 + 32);
  if (v2)
  {
    dispatch_release(v2);
  }
}

void non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_openAsync(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void CoreReadStreamFromCFReadStream::_streamImpl_openAsync(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t))(*(void *)a2 + 40))(a2);
  CFRetain((CFTypeRef)(a1 - 16));
  dispatch_queue_t global_queue = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_openAsyncEPK17CoreSchedulingSetU13block_pointerFv13CFStreamErrorE_block_invoke;
  block[3] = &unk_1E5257CF8;
  void block[5] = a1;
  void block[6] = a2;
  block[4] = a3;
  dispatch_async(global_queue, block);
}

void ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_openAsyncEPK17CoreSchedulingSetU13block_pointerFv13CFStreamErrorE_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (CFReadStreamOpen(*(CFReadStreamRef *)(v2 + 128)))
  {
    uint64_t v3 = 0;
    CFIndex domain = 0;
  }
  else
  {
    CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*(void *)(v2 + 128));
    uint64_t v3 = *(CFIndex *)&Error.error;
    CFIndex domain = Error.domain;
  }
  uint64_t v6 = a1[6];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_openAsyncEPK17CoreSchedulingSetU13block_pointerFv13CFStreamErrorE_block_invoke_2;
  v7[3] = &unk_1E5257CF8;
  v7[4] = a1[4];
  void v7[5] = domain;
  void v7[6] = v3;
  (*(void (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v7);
  (*(void (**)(void))(*(void *)a1[6] + 48))(a1[6]);
  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t ___ZN30CoreReadStreamFromCFReadStream21_streamImpl_openAsyncEPK17CoreSchedulingSetU13block_pointerFv13CFStreamErrorE_block_invoke_2(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[4] + 16))(a1[4], a1[5], a1[6]);
}

uint64_t non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_CanRead(CFReadStreamRef *this)
{
  return CFReadStreamHasBytesAvailable(this[1]);
}

CFIndex non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_Read(CFReadStreamRef *this, unsigned __int8 *a2, CFIndex a3, CFStreamError *a4, BOOL *a5)
{
  return CoreReadStreamFromCFReadStream::_streamImpl_Read(this - 15, a2, a3, a4, a5);
}

CFIndex CoreReadStreamFromCFReadStream::_streamImpl_Read(CFReadStreamRef *this, unsigned __int8 *a2, CFIndex a3, CFStreamError *a4, BOOL *a5)
{
  if (a4)
  {
    a4->CFIndex domain = 0;
    a4->CFErrorRef error = 0;
    if (!a5)
    {
      size_t v7 = this + 16;
      CFIndex v8 = CFReadStreamRead(this[16], a2, a3);
      if (CFReadStreamGetStatus(*v7) != kCFStreamStatusError)
      {
        a4->CFErrorRef error = 0;
        a4->CFIndex domain = 0;
        return v8;
      }
      char v9 = 1;
      goto LABEL_9;
    }
LABEL_6:
    *a5 = 0;
    size_t v7 = this + 16;
    CFIndex v8 = CFReadStreamRead(this[16], a2, a3);
    CFStreamStatus Status = CFReadStreamGetStatus(*v7);
    if (a4)
    {
      if (Status == kCFStreamStatusError)
      {
        char v9 = 0;
LABEL_9:
        if (*v7 && (__int16 v11 = CFReadStreamCopyError(*v7)) != 0)
        {
          uint64_t v12 = v11;
          CFIndex v13 = _CFStreamErrorFromCFError(v11);
          uint64_t v15 = v14;
          CFRelease(v12);
        }
        else
        {
          uint64_t v15 = 0;
          CFIndex v13 = 0;
        }
        a4->CFIndex domain = v13;
        *(void *)&a4->CFErrorRef error = v15;
        if (v9) {
          return v8;
        }
        CFStreamStatus Status = kCFStreamStatusError;
        goto LABEL_16;
      }
      a4->CFErrorRef error = 0;
      a4->CFIndex domain = 0;
    }
LABEL_16:
    *a5 = Status == kCFStreamStatusAtEnd;
    return v8;
  }
  if (a5) {
    goto LABEL_6;
  }
  uint64_t v17 = this[16];

  return CFReadStreamRead(v17, a2, a3);
}

void non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_Close(CoreReadStreamFromCFReadStream *this)
{
  if (*((unsigned char *)this + 16))
  {
    if (!*((unsigned char *)this + 17))
    {
      *((unsigned char *)this + 17) = 1;
      CFReadStreamClose(*((CFReadStreamRef *)this + 1));
    }
  }
}

BOOL non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_OpenCompleted(CFReadStreamRef *this, CFStreamError *a2)
{
  return CoreReadStreamFromCFReadStream::_streamImpl_OpenCompleted(this - 15, a2);
}

BOOL CoreReadStreamFromCFReadStream::_streamImpl_OpenCompleted(CFReadStreamRef *this, CFStreamError *a2)
{
  CFStreamStatus Status = CFReadStreamGetStatus(this[16]);
  uint64_t v5 = Status;
  if (a2)
  {
    if (Status == kCFStreamStatusError)
    {
      uint64_t v6 = this[16];
      if (v6 && (size_t v7 = CFReadStreamCopyError(v6)) != 0)
      {
        CFIndex v8 = v7;
        CFIndex v9 = _CFStreamErrorFromCFError(v7);
        uint64_t v11 = v10;
        CFRelease(v8);
      }
      else
      {
        uint64_t v11 = 0;
        CFIndex v9 = 0;
      }
      a2->CFIndex domain = v9;
      *(void *)&a2->CFErrorRef error = v11;
    }
    else
    {
      a2->CFIndex domain = 0;
      a2->CFErrorRef error = 0;
    }
  }
  return v5 > 1;
}

uint64_t non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_Open(CoreReadStreamFromCFReadStream *this, CFStreamError *a2, BOOL *a3)
{
  return CoreReadStreamFromCFReadStream::_streamImpl_Open((CoreReadStreamFromCFReadStream *)((char *)this - 120), (unint64_t)a2, a3);
}

uint64_t CoreReadStreamFromCFReadStream::_streamImpl_Open(CoreReadStreamFromCFReadStream *this, unint64_t a2, BOOL *a3)
{
  if (a2)
  {
    *(void *)a2 = 0;
    *(_DWORD *)(a2 + 8) = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  *((unsigned char *)this + CFRetain((char *)this - 136) = CFReadStreamOpen(*((CFReadStreamRef *)this + 16));
  if (a2 | (unint64_t)a3)
  {
    CFStreamStatus Status = CFReadStreamGetStatus(*((CFReadStreamRef *)this + 16));
    if (a3) {
      *a3 = Status > kCFStreamStatusOpening;
    }
    if (a2 && Status == kCFStreamStatusError)
    {
      size_t v7 = (__CFReadStream *)*((void *)this + 16);
      if (v7 && (CFIndex v8 = CFReadStreamCopyError(v7)) != 0)
      {
        CFIndex v9 = v8;
        CFIndex v10 = _CFStreamErrorFromCFError(v8);
        uint64_t v12 = v11;
        CFRelease(v9);
      }
      else
      {
        uint64_t v12 = 0;
        CFIndex v10 = 0;
      }
      *(void *)a2 = v10;
      *(void *)(a2 + 8) = v12;
    }
  }
  return *((unsigned __int8 *)this + 136);
}

CFTypeRef non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_CopyProperty(CFReadStreamRef *this, const __CFString *a2)
{
  return CFReadStreamCopyProperty(this[1], a2);
}

uint64_t non-virtual thunk to'CoreReadStreamFromCFReadStream::_streamImpl_SetProperty(CFReadStreamRef *this, const __CFString *a2, const void *a3)
{
  return CFReadStreamSetProperty(this[1], a2, a3);
}

void non-virtual thunk to'CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream(CoreReadStreamFromCFReadStream *this)
{
}

{
  CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream((CoreReadStreamFromCFReadStream *)((char *)this - 120));
}

{
  CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream((CoreReadStreamFromCFReadStream *)((char *)this - 8));
}

{
  CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream((CoreReadStreamFromCFReadStream *)((char *)this - 8));
}

void CoreReadStreamFromCFReadStream::~CoreReadStreamFromCFReadStream(CoreReadStreamFromCFReadStream *this)
{
  *(void *)this = &unk_1ECFA4C20;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA4CC8;
  uint64_t v2 = (const void *)*((void *)this + 16);
  *((void *)this + 15) = &unk_1ECFA4CE8;
  *((void *)this + CFRetain((char *)this - 16) = 0;
  if (v2) {
    CFRelease(v2);
  }
  *(void *)this = &unk_1ECF9F028;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9F090;
  *((void *)this + 15) = &unk_1ECF9F0B0;

  CoreStreamBase::~CoreStreamBase(this);
}

void sub_1842D94B8(_Unwind_Exception *a1)
{
  CoreReadStreamBase::~CoreReadStreamBase(v1);
  _Unwind_Resume(a1);
}

void CoreReadStreamBase::~CoreReadStreamBase(CoreReadStreamBase *this)
{
  *(void *)this = &unk_1ECF9F028;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9F090;
  *((void *)this + 15) = &unk_1ECF9F0B0;
  CoreStreamBase::~CoreStreamBase(this);
}

void CoreReadStreamFromCFReadStream::_streamImpl_UpdateScheduling(CoreReadStreamFromCFReadStream *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  CoreSchedulingSet::_scheduleStream((uint64_t)a2, *((void *)this + 16), (void (*)(uint64_t, uint64_t))_CFStreamUnscheduleFromDispatchQueue, MEMORY[0x1E4F1C270]);
  uint64_t v5 = *((void *)this + 16);
  uint64_t v6 = (void (*)(uint64_t, uint64_t))MEMORY[0x1E4F1C268];
  uint64_t v7 = MEMORY[0x1E4F1C260];

  CoreSchedulingSet::_scheduleStream((uint64_t)a3, v5, v6, v7);
}

void CoreReadStreamFromCFReadStream::_streamImpl_Close(CoreReadStreamFromCFReadStream *this)
{
  if (*((unsigned char *)this + 136))
  {
    if (!*((unsigned char *)this + 137))
    {
      *((unsigned char *)this + 137) = 1;
      CFReadStreamClose(*((CFReadStreamRef *)this + 16));
    }
  }
}

CFTypeRef CoreReadStreamFromCFReadStream::_streamImpl_CopyProperty(CFReadStreamRef *this, const __CFString *a2)
{
  return CFReadStreamCopyProperty(this[16], a2);
}

uint64_t CoreReadStreamFromCFReadStream::_streamImpl_SetProperty(CFReadStreamRef *this, const __CFString *a2, const void *a3)
{
  return CFReadStreamSetProperty(this[16], a2, a3);
}

uint64_t CoreReadStreamFromCFReadStream::_streamImpl_CanRead(CFReadStreamRef *this)
{
  return CFReadStreamHasBytesAvailable(this[16]);
}

CFReadStreamRef CoreReadStreamFromCFReadStream::streamSetClient(CFReadStreamRef *this, CFOptionFlags a2, CoreStreamClient *a3)
{
  if (a3)
  {
    clientContext.version = 0;
    clientContext.info = this;
    clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
    clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
    clientContext.CFAllocatorCopyDescriptionCallBack copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
    CFReadStreamSetClient(this[16], a2, (CFReadStreamClientCallBack)CoreReadStreamFromCFReadStream::_readStreamClientCallBack, &clientContext);
    return (CFReadStreamRef)CoreStreamBase::streamSetClient((uint64_t)this, a2, a3);
  }
  else
  {
    CFReadStreamSetClient(this[16], 0, 0, 0);
    CFReadStreamRef result = this[2];
    this[2] = 0;
    if (result)
    {
      uint64_t v7 = *(uint64_t (**)(void))(*(void *)result + 24);
      return (CFReadStreamRef)v7();
    }
  }
  return result;
}

void CoreReadStreamFromCFReadStream::_readStreamClientCallBack(CoreReadStreamFromCFReadStream *this, uint64_t a2, CoreStreamBase *a3, void *a4)
{
  if (a2 == 8)
  {
    if (this && (uint64_t v5 = CFReadStreamCopyError(this)) != 0)
    {
      uint64_t v6 = v5;
      CFIndex v7 = _CFStreamErrorFromCFError(v5);
      uint64_t v9 = v8;
      CFRelease(v6);
    }
    else
    {
      uint64_t v9 = 0;
      CFIndex v7 = 0;
    }
    CFIndex v10 = a3;
    a2 = 8;
    v11.CFIndex domain = v7;
    *(void *)&v11.CFErrorRef error = v9;
  }
  else
  {
    CFIndex v10 = a3;
    v11.CFIndex domain = 0;
    *(void *)&v11.CFErrorRef error = 0;
  }

  CoreStreamBase::_signalEvent(v10, a2, v11, 1);
}

void CoreReadStreamBase::CoreReadStreamBase(CoreReadStreamBase *this, const char *a2)
{
  *((_DWORD *)this + 26) = 0;
  *((void *)this + 3) = (char *)this + 120;
  *(void *)this = &unk_1ECF9F028;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9F090;
  *((void *)this + 15) = &unk_1ECF9F0B0;
}

uint64_t CoreReadStream::setClient(uint64_t a1, uint64_t a2, uint64_t a3, const CFStreamClientContext *a4)
{
  if (a3)
  {
    uint64_t v8 = a1 - 16;
    CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)(a1 - 16));
    CFIndex v10 = (char *)CFAllocatorAllocate(v9, 96, 0);
    *(_OWORD *)CFIndex v10 = 0u;
    *((_OWORD *)v10 + HTTPServerConnection::canceled_onQueue(this - 1) = 0u;
    *((_OWORD *)v10 + 2) = 0u;
    *((_OWORD *)v10 + 3) = 0u;
    *((_OWORD *)v10 + 5) = 0u;
    *((_OWORD *)v10 + 4) = 0u;
    CFStreamError v11 = v10 + 64;
    CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)(a1 - 16));
    ClassicStreamClient::ClassicStreamClient((ClassicStreamClient *)v10, v12, a4);
    *((void *)v10 + 9) = v8;
    *((void *)v10 + 10) = v8;
    *(void *)CFIndex v10 = &unk_1ECF9E158;
    *((void *)v10 + 8) = &unk_1ECF9E1C0;
    *((void *)v10 + 1HTTPServerConnection::canceled_onQueue(this - 1) = a3;
  }
  else
  {
    CFStreamError v11 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 56))(a1, a2, v11);
  if (v11)
  {
    uint64_t v14 = *(uint64_t (**)(char *))(*(void *)v11 + 24);
    return v14(v11);
  }
  return result;
}

uint64_t non-virtual thunk to'ClassicReadClient::coreStreamReadEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ClassicReadClient::coreStreamReadEvent((void *)(a1 - 64), a2, a3);
}

uint64_t ClassicReadClient::coreStreamReadEvent(void *a1, uint64_t a2, uint64_t a3)
{
  if (a2 && CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t v5 = a1[10];
  uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))a1[11];
  uint64_t v7 = a1[4];

  return v6(v5, a3, v7);
}

CFStringRef non-virtual thunk to'ClassicReadClient::coreStreamClientCopyDescription(ClassicReadClient *this)
{
  return ClassicStreamClient::clientCopyDescription((ClassicReadClient *)((char *)this - 64));
}

uint64_t non-virtual thunk to'ClassicReadClient::coreStreamClientRelease(ClassicReadClient *this)
{
  return (*(uint64_t (**)(void))(*((void *)this - 8) + 48))();
}

ClassicReadClient *non-virtual thunk to'ClassicReadClient::coreStreamClientRetain(ClassicReadClient *this)
{
  return this;
}

void non-virtual thunk to'ClassicReadClient::~ClassicReadClient(ClassicReadClient *this)
{
}

{
  void (*v1)(void);

  *(void *)this = &unk_1ECFA1220;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = 0;
  *((void *)this - 8) = &unk_1ECF9FA48;
  if (*((void *)this - 4))
  {
    uint64_t v1 = (void (*)(void))*((void *)this - 2);
    if (v1) {
      v1(*((void *)this - 4));
    }
  }
}

void ClassicReadClient::~ClassicReadClient(ClassicReadClient *this)
{
  *((void *)this + 8) = &unk_1ECFA1220;
  *((void *)this + 9) = 0;
  *(void *)this = &unk_1ECF9FA48;
  if (*((void *)this + 4))
  {
    uint64_t v2 = (void (*)(void))*((void *)this + 6);
    if (v2) {
      v2();
    }
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this + 1);

  CFAllocatorDeallocate(v3, this);
}

{
  void (*v1)(void);

  *((void *)this + 8) = &unk_1ECFA1220;
  *((void *)this + 9) = 0;
  *(void *)this = &unk_1ECF9FA48;
  if (*((void *)this + 4))
  {
    uint64_t v1 = (void (*)(void))*((void *)this + 6);
    if (v1) {
      v1();
    }
  }
}

uint64_t ClassicReadClient::coreStreamClientRelease(ClassicReadClient *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

char *ClassicReadClient::coreStreamClientRetain(ClassicReadClient *this)
{
  uint64_t v1 = (char *)this + 64;
  (*(void (**)(ClassicReadClient *))(*(void *)this + 40))(this);
  return v1;
}

BOOL ClassicReadClient::equals(ClassicReadClient *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

_OWORD *CoreReadStreamCreate(uint64_t a1, long long *a2, uint64_t a3)
{
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v7 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v7 = Instance + 1;
    Instance[15] = 0u;
    Instance[16] = 0u;
    Instance[13] = 0u;
    Instance[14] = 0u;
    Instance[11] = 0u;
    Instance[12] = 0u;
    Instance[9] = 0u;
    Instance[10] = 0u;
    Instance[7] = 0u;
    Instance[8] = 0u;
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
  }
  CoreReadStreamBase::CoreReadStreamBase((CoreReadStreamBase *)v7, v6);
  *(void *)uint64_t v7 = &unk_1ECFA3920;
  *((void *)v7 + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA39C0;
  *((void *)v7 + 15) = &unk_1ECFA39E0;
  long long v8 = *a2;
  long long v9 = a2[1];
  long long v10 = a2[2];
  *(_OWORD *)((char *)v7 + 184) = a2[3];
  *(_OWORD *)((char *)v7 + 168) = v10;
  *(_OWORD *)((char *)v7 + 152) = v9;
  *(_OWORD *)((char *)v7 + CFRetain((char *)this - 136) = v8;
  long long v11 = a2[4];
  long long v12 = a2[5];
  long long v13 = a2[6];
  *((void *)v7 + 3HTTPServerConnection::canceled_onQueue(this - 1) = *((void *)a2 + 14);
  *(_OWORD *)((char *)v7 + 232) = v13;
  *(_OWORD *)((char *)v7 + 2CFRetain((char *)this - 16) = v12;
  *(_OWORD *)((char *)v7 + 200) = v11;
  uint64_t v14 = (uint64_t (*)(_OWORD *, uint64_t))*((void *)v7 + 18);
  if (v14) {
    a3 = v14(v7 - 1, a3);
  }
  *((void *)v7 + CFRetain((char *)this - 16) = a3;
  return v7 - 1;
}

void sub_1842D9DA0(_Unwind_Exception *a1)
{
  CoreReadStreamBase::~CoreReadStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_deprecated_Unschedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 128);
  if (v3) {
    return v3(this - 136, a2, a3, *(void *)(this + 8));
  }
  return this;
}

uint64_t non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_deprecated_Schedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 120);
  if (v3) {
    return v3(this - 136, a2, a3, *(void *)(this + 8));
  }
  return this;
}

BOOL non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_CanRead(CoreReadStreamWithCallBacks *this)
{
  uint64_t v1 = (unsigned int (*)(char *, void))*((void *)this + 10);
  return v1 && v1((char *)this - 136, *((void *)this + 1)) != 0;
}

uint64_t non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_Read(CoreReadStreamWithCallBacks *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  if (a4)
  {
    a4->CFIndex domain = 0;
    a4->CFErrorRef error = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  uint64_t v5 = (uint64_t (*)(char *, unsigned __int8 *))*((void *)this + 8);
  if (v5) {
    return v5((char *)this - 136, a2);
  }
  else {
    return -1;
  }
}

uint64_t non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_Close(uint64_t this)
{
  uint64_t v1 = *(uint64_t (**)(uint64_t, void))(this + 88);
  if (v1) {
    return v1(this - 136, *(void *)(this + 8));
  }
  return this;
}

BOOL non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_OpenCompleted(CoreReadStreamWithCallBacks *this, CFStreamError *a2)
{
  if (a2)
  {
    a2->CFIndex domain = 0;
    a2->CFErrorRef error = 0;
  }
  uint64_t v2 = (unsigned int (*)(char *))*((void *)this + 7);
  return v2 && v2((char *)this - 136) != 0;
}

BOOL non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_Open(CoreReadStreamWithCallBacks *this, CFStreamError *a2, unsigned __int8 *a3)
{
  if (a2)
  {
    a2->CFIndex domain = 0;
    a2->CFErrorRef error = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  CFAllocatorRef v3 = (unsigned int (*)(char *))*((void *)this + 6);
  return v3 && v3((char *)this - 136) != 0;
}

uint64_t non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_RequestEvents(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t, void))(this + 112);
  if (v2) {
    return v2(this - 136, a2, *(void *)(this + 8));
  }
  return this;
}

uint64_t non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_CopyProperty(CoreReadStreamWithCallBacks *this, const __CFString *a2)
{
  uint64_t v2 = (uint64_t (*)(char *, const __CFString *, void))*((void *)this + 12);
  if (v2) {
    return v2((char *)this - 136, a2, *((void *)this + 1));
  }
  else {
    return 0;
  }
}

BOOL non-virtual thunk to'CoreReadStreamWithCallBacks::_streamImpl_SetProperty(CoreReadStreamWithCallBacks *this, const __CFString *a2, const void *a3)
{
  CFAllocatorRef v3 = (unsigned int (*)(char *, const __CFString *, const void *, void))*((void *)this + 13);
  return v3 && v3((char *)this - 136, a2, a3, *((void *)this + 1)) != 0;
}

void non-virtual thunk to'CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks(CoreReadStreamWithCallBacks *this)
{
}

{
  CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks((CoreReadStreamWithCallBacks *)((char *)this - 120));
}

{
  CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks((CoreReadStreamWithCallBacks *)((char *)this - 8));
}

{
  CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks((CoreReadStreamWithCallBacks *)((char *)this - 8));
}

void CoreReadStreamWithCallBacks::~CoreReadStreamWithCallBacks(CoreReadStreamWithCallBacks *this)
{
  *(void *)this = &unk_1ECFA3920;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA39C0;
  *((void *)this + 15) = &unk_1ECFA39E0;
  uint64_t v2 = (void (*)(char *, void))*((void *)this + 19);
  if (v2) {
    v2((char *)this - 16, *((void *)this + 16));
  }
  *(void *)this = &unk_1ECF9F028;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9F090;
  *((void *)this + 15) = &unk_1ECF9F0B0;

  CoreStreamBase::~CoreStreamBase(this);
}

void sub_1842DA090(_Unwind_Exception *a1)
{
  CoreReadStreamBase::~CoreReadStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_deprecated_Unschedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 248);
  if (v3) {
    return v3(this - 16, a2, a3, *(void *)(this + 128));
  }
  return this;
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_deprecated_Schedule(uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  CFAllocatorRef v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 240);
  if (v3) {
    return v3(this - 16, a2, a3, *(void *)(this + 128));
  }
  return this;
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_Close(uint64_t this)
{
  uint64_t v1 = *(uint64_t (**)(uint64_t, void))(this + 208);
  if (v1) {
    return v1(this - 16, *(void *)(this + 128));
  }
  return this;
}

BOOL CoreReadStreamWithCallBacks::_streamImpl_OpenCompleted(CoreReadStreamWithCallBacks *this, CFStreamError *a2)
{
  if (a2)
  {
    a2->CFIndex domain = 0;
    a2->CFErrorRef error = 0;
  }
  uint64_t v2 = (unsigned int (*)(char *))*((void *)this + 22);
  return v2 && v2((char *)this - 16) != 0;
}

BOOL CoreReadStreamWithCallBacks::_streamImpl_Open(CoreReadStreamWithCallBacks *this, CFStreamError *a2, unsigned __int8 *a3)
{
  if (a2)
  {
    a2->CFIndex domain = 0;
    a2->CFErrorRef error = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  CFAllocatorRef v3 = (unsigned int (*)(char *))*((void *)this + 21);
  return v3 && v3((char *)this - 16) != 0;
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_CopyProperty(CoreReadStreamWithCallBacks *this, const __CFString *a2)
{
  uint64_t v2 = (uint64_t (*)(char *, const __CFString *, void))*((void *)this + 27);
  if (v2) {
    return v2((char *)this - 16, a2, *((void *)this + 16));
  }
  else {
    return 0;
  }
}

BOOL CoreReadStreamWithCallBacks::_streamImpl_SetProperty(CoreReadStreamWithCallBacks *this, const __CFString *a2, const void *a3)
{
  CFAllocatorRef v3 = (unsigned int (*)(char *, const __CFString *, const void *, void))*((void *)this + 28);
  return v3 && v3((char *)this - 16, a2, a3, *((void *)this + 16)) != 0;
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_RequestEvents(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t, void))(this + 232);
  if (v2) {
    return v2(this - 16, a2, *(void *)(this + 128));
  }
  return this;
}

BOOL CoreReadStreamWithCallBacks::_streamImpl_CanRead(CoreReadStreamWithCallBacks *this)
{
  uint64_t v1 = (unsigned int (*)(char *, void))*((void *)this + 25);
  return v1 && v1((char *)this - 16, *((void *)this + 16)) != 0;
}

uint64_t CoreReadStreamWithCallBacks::_streamImpl_Read(CoreReadStreamWithCallBacks *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
  if (a4)
  {
    a4->CFIndex domain = 0;
    a4->CFErrorRef error = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  uint64_t v5 = (uint64_t (*)(char *, unsigned __int8 *))*((void *)this + 23);
  if (v5) {
    return v5((char *)this - 16, a2);
  }
  else {
    return -1;
  }
}

_OWORD *CoreReadStreamCreateWithCFReadStream(const __CFAllocator *a1, __CFReadStream *a2)
{
  if (!a2) {
    return 0;
  }
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v5 = (CoreReadStreamBase *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v5 = (CoreReadStreamBase *)(Instance + 1);
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }
  CoreReadStreamBase::CoreReadStreamBase(v5, v4);
  *(void *)uint64_t v5 = &unk_1ECFA4C20;
  *((void *)v5 + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA4CC8;
  *((void *)v5 + 15) = &unk_1ECFA4CE8;
  *((void *)v5 + CFRetain((char *)this - 16) = CFRetain(a2);
  *((_WORD *)v5 + 68) = 0;
  return (_OWORD *)((char *)v5 - 16);
}

void sub_1842DA3A4(_Unwind_Exception *a1)
{
  CoreReadStreamBase::~CoreReadStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFReadStreamCreateWithCoreStream(uint64_t a1, uint64_t a2)
{
  if (a2 && CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }

  return CFReadStreamCreate();
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_unschedule(int a1, __CFRunLoop *a2, const __CFString *a3, os_unfair_lock_s *this)
{
  return CoreStreamBase::_streamInterface_Deprecated_Unschedule(this, a2, a3);
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_schedule(int a1, __CFRunLoop *a2, const __CFString *a3, os_unfair_lock_s *this)
{
  return CoreStreamBase::_streamInterface_Deprecated_Schedule(this, a2, a3);
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_requestEvents(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a3 + 80))(a3);
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_setProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  ++*(void *)(a4 + 80);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a4 + 24) + 32))(*(void *)(a4 + 24));
  --*(void *)(a4 + 80);
  return result;
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_copyProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ++*(void *)(a3 + 80);
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a3 + 24) + 40))(*(void *)(a3 + 24));
  --*(void *)(a3 + 80);
  return result;
}

void CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_close(uint64_t a1, CoreStreamBase *a2)
{
  (*(void (**)(CoreStreamBase *, void, void))(*(void *)a2 + 56))(a2, 0, 0);

  CoreStreamBase::_streamInterface_Close(a2);
}

uint64_t CoreReadStreamCFStreamSupport::_stream_canRead(CoreReadStreamCFStreamSupport *this, __CFReadStream *a2, void *a3)
{
  uint64_t v4 = CoreStreamBase::_streamInterface_CanRead(a2);
  if (!v4)
  {
    uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(a2);
    if (Status == 5 || Status == 7) {
      CFReadStreamSignalEvent();
    }
  }
  return v4;
}

uint64_t CoreReadStreamCFStreamSupport::_stream_read(CoreReadStreamCFStreamSupport *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, CoreStreamBase *a6, void *a7)
{
  if (a4)
  {
    *(void *)a4 = 0;
    *(_DWORD *)(a4 + 8) = 0;
  }
  if (a5) {
    LOBYTE(a5->domain) = 0;
  }
  uint64_t v10 = CoreStreamBase::_streamInterface_Read(a6, (unsigned __int8 *)a2, (uint64_t)a3);
  uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(a6);
  if (Status == 5)
  {
    if (a5) {
      LOBYTE(a5->domain) = 1;
    }
  }
  else if (a4 && Status == 7)
  {
    *(_OWORD *)a4 = *(_OWORD *)((char *)a6 + 56);
  }
  return v10;
}

BOOL CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_openCompleted(int a1, uint64_t a2, CoreStreamBase *this)
{
  uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (a2)
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(void *)a2 = 0;
    if (Status == 7) {
      *(_OWORD *)a2 = *(_OWORD *)((char *)this + 56);
    }
  }
  return Status > 1;
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_open(int a1, uint64_t a2, unsigned char *a3, CoreStreamBase *this)
{
  if (a2)
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(void *)a2 = 0;
  }
  if (a3)
  {
    *a3 = 0;
    uint64_t v7 = CoreStreamBase::_streamInterface_Open(this);
    if (v7)
    {
      uint64_t v8 = v7;
      *a3 = (*(uint64_t (**)(char *, uint64_t))(*((void *)this + 15) + 64))((char *)this + 120, a2);
      return v8;
    }
    if (!a2) {
      return 0;
    }
LABEL_10:
    uint64_t v8 = 0;
    *(_OWORD *)a2 = *(_OWORD *)((char *)this + 56);
    return v8;
  }
  uint64_t v9 = CoreStreamBase::_streamInterface_Open(this);
  uint64_t v8 = v9;
  if (a2 && !v9) {
    goto LABEL_10;
  }
  return v8;
}

uint64_t CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_copyDescription(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
}

void CoreStreamCFStreamSupport<__CFReadStream *,CoreReadStream>::_stream_finalize(uint64_t a1, uint64_t a2)
{
}

__CFReadStream *CoreReadStreamCFStreamSupport::_stream_create_and_bump_refcount(CoreReadStreamCFStreamSupport *this, __CFReadStream *a2, void *a3)
{
  uint64_t v5 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  CFAllocatorRef v6 = CFGetAllocator(this);
  uint64_t v7 = CFAllocatorAllocate(v6, 56, 0);
  *uint64_t v7 = 0u;
  v7[1] = 0u;
  void v7[2] = 0u;
  *((void *)v7 + 6) = 0;
  CFAllocatorRef v8 = CFGetAllocator(this);
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)v7, v8);
  *(void *)uint64_t v7 = &unk_1ECFA48D0;
  *((void *)v7 + 3) = &unk_1ECFA4940;
  *((void *)v7 + 4) = v5;
  *((void *)v7 + 5) = this;
  *((void *)v7 + 6) = CFRetain(v5);
  (*(void (**)(__CFReadStream *, uint64_t, uint64_t))(*(void *)a2 + 56))(a2, -1, (uint64_t)v7 + 24);
  (*(void (**)(_OWORD *))(*(void *)v7 + 48))(v7);
  return a2;
}

void sub_1842DA8FC(_Unwind_Exception *a1)
{
  *(void *)(v1 + CFRelease((char *)this - 24) = &unk_1ECFA1220;
  *(void *)(v1 + 32) = 0;
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'CoreReadStreamCFStreamSupport::coreStreamReadEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CoreReadStreamCFStreamSupport::coreStreamReadEvent(a1 - 24, a2, a3);
}

uint64_t CoreReadStreamCFStreamSupport::coreStreamReadEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 48) && CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  if (a3 == 8 && CoreReadStream::Class(void)::sOnce_CoreReadStream != -1) {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_20142);
  }
  return CFReadStreamSignalEvent();
}

CFTypeRef non-virtual thunk to'CoreReadStreamCFStreamSupport::coreStreamClientCopyCFStreamRef(CoreReadStreamCFStreamSupport *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 2);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

CFStringRef non-virtual thunk to'CoreReadStreamCFStreamSupport::coreStreamClientCopyDescription(CoreReadStreamCFStreamSupport *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<read side %p to stream %p>", *((void *)this + 3), *((void *)this + 2));
}

uint64_t non-virtual thunk to'CoreReadStreamCFStreamSupport::coreStreamClientRelease(CoreReadStreamCFStreamSupport *this)
{
  return CoreReadStreamCFStreamSupport::coreStreamClientRelease((CoreReadStreamCFStreamSupport *)((char *)this - 24));
}

uint64_t CoreReadStreamCFStreamSupport::coreStreamClientRelease(CoreReadStreamCFStreamSupport *this)
{
  uint64_t v2 = (const void *)*((void *)this + 6);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(uint64_t (**)(CoreReadStreamCFStreamSupport *))(*(void *)this + 48);

  return v4(this);
}

uint64_t non-virtual thunk to'CoreReadStreamCFStreamSupport::coreStreamClientRetain(CoreReadStreamCFStreamSupport *this)
{
  return CoreReadStreamCFStreamSupport::coreStreamClientRetain((CoreReadStreamCFStreamSupport *)((char *)this - 24));
}

uint64_t CoreReadStreamCFStreamSupport::coreStreamClientRetain(CoreReadStreamCFStreamSupport *this)
{
  (*(void (**)(CoreReadStreamCFStreamSupport *))(*(void *)this + 40))(this);
  uint64_t v2 = (const void *)*((void *)this + 6);
  if (v2) {
    CFRetain(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRetain(v3);
  }
  return (uint64_t)this + 24;
}

void non-virtual thunk to'CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport(CoreReadStreamCFStreamSupport *this)
{
  uint64_t v2 = (char *)this - 24;
  CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport((CoreReadStreamCFStreamSupport *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport((CoreReadStreamCFStreamSupport *)((char *)this - 24));
}

void CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport(CoreReadStreamCFStreamSupport *this)
{
  *(void *)this = &unk_1ECFA48D0;
  *((void *)this + 3) = &unk_1ECFA4940;
  uint64_t v2 = (const void *)*((void *)this + 6);
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 3) = &unk_1ECFA1220;
  *((void *)this + 4) = 0;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  CoreReadStreamCFStreamSupport::~CoreReadStreamCFStreamSupport(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1842DABE0(_Unwind_Exception *a1)
{
  *(void *)(v1 + CFRelease((char *)this - 24) = &unk_1ECFA1220;
  *(void *)(v1 + 32) = 0;
  _Unwind_Resume(a1);
}

CFStringRef CoreReadStreamCFStreamSupport::coreStreamClientCopyDescription(CoreReadStreamCFStreamSupport *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<read side %p to stream %p>", *((void *)this + 6), *((void *)this + 5));
}

CFTypeRef CoreReadStreamCFStreamSupport::coreStreamClientCopyCFStreamRef(CoreReadStreamCFStreamSupport *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 5);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

BOOL CoreReadStreamCFStreamSupport::equals(CoreReadStreamCFStreamSupport *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

void _release_block(int a1, void *aBlock)
{
}

void *_retain_block(int a1, void *aBlock)
{
  return _Block_copy(aBlock);
}

void non-virtual thunk to'URLCredentialOAuth1::~URLCredentialOAuth1(URLCredentialOAuth1 *this)
{
}

{
  URLCredentialOAuth1::~URLCredentialOAuth1((URLCredentialOAuth1 *)((char *)this - 24));
}

{
  URLCredentialOAuth1::~URLCredentialOAuth1((URLCredentialOAuth1 *)((char *)this - 8));
}

{
  URLCredentialOAuth1::~URLCredentialOAuth1((URLCredentialOAuth1 *)((char *)this - 8));
}

void URLCredentialOAuth1::~URLCredentialOAuth1(URLCredentialOAuth1 *this)
{
  *(void *)this = &unk_1ECFA0D58;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA0E08;
  *((void *)this + 3) = &unk_1ECFA0E38;
  uint64_t v2 = *((void *)this + 9);
  if (v2) {
    CFRelease((CFTypeRef)(v2 - 16));
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 10);
  if (v3) {
    CFRelease(v3);
  }

  URLCredential::~URLCredential(this);
}

void sub_1842DAD70(_Unwind_Exception *a1)
{
  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t URLCredentialOAuth1::getPID(URLCredentialOAuth1 *this)
{
  return *((unsigned int *)this + 16);
}

CFTypeRef URLCredentialOAuth1::copyRealm(URLCredentialOAuth1 *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 10);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t URLCredentialOAuth1::getRealm(URLCredentialOAuth1 *this)
{
  return *((void *)this + 10);
}

uint64_t URLCredentialOAuth1::copyAccount(URLCredentialOAuth1 *this)
{
  uint64_t v1 = *((void *)this + 9);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1 - 16;
  CFRetain((CFTypeRef)(v1 - 16));
  return v2;
}

uint64_t URLCredentialOAuth1::getAccount(URLCredentialOAuth1 *this)
{
  return *((void *)this + 9) - 16;
}

void *URLCredentialOAuth1::getUserName(CFNAccount **this)
{
  return CFNAccount::username(this[9]);
}

void *URLCredentialOAuth1::copyStorageNameForCredentialType(URLCredentialOAuth1 *this)
{
  uint64_t v1 = (CFNAccount *)*((void *)this + 9);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = CFNAccount::username(v1);
  CFAllocatorRef v3 = v2;
  if (v2) {
    CFRetain(v2);
  }
  return v3;
}

CFHashCode URLCredentialOAuth1::calcHash(URLCredentialOAuth1 *this, uint64_t a2)
{
  CFAllocatorRef v3 = (CFNAccount *)*((void *)this + 9);
  if (v3)
  {
    uint64_t v4 = CFNAccount::username(v3);
    return CFHash(v4) ^ a2;
  }
  return a2;
}

uint64_t URLCredentialOAuth1::copy(URLCredentialOAuth1 *this)
{
  CFGetAllocator((char *)this - 16);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + ++*(void *)(this + 64) = 0u;
  *(_OWORD *)(Instance + ++*(void *)(this + 80) = 0u;
  *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
  *(void *)(Instance + 32) = &gConstantCFStringValueTable[3773];
  *(_DWORD *)(Instance + 48) = 7;
  *(unsigned char *)(Instance + ++*(void *)(this + 64) = 0;
  *(void *)(Instance + 72) = 0;
  *(void *)(Instance + 56) = 0;
  *(void *)(Instance + CFRetain((char *)this - 16) = &unk_1ECFA0D58;
  *(void *)(Instance + CFRelease((char *)this - 24) = &unk_1ECFA0E08;
  *(void *)(Instance + 40) = &unk_1ECFA0E38;
  *(_DWORD *)(Instance + ++*(void *)(this + 80) = 0;
  *(void *)(Instance + 88) = 0;
  *(void *)(Instance + 96) = 0;
  CFAllocatorRef v3 = *(objc_object **)(*((void *)this + 9) + 16);
  int v4 = (*(uint64_t (**)(URLCredentialOAuth1 *))(*(void *)this + 152))(this);
  URLCredentialOAuth1::initialize((URLCredentialOAuth1 *)(Instance + 16), v3, v4, *((const __CFString **)this + 10));
  return Instance;
}

uint64_t URLCredentialOAuth1::initialize(URLCredentialOAuth1 *this, objc_object *a2, int a3, const __CFString *a4)
{
  uint64_t result = 0;
  *((_DWORD *)this + 9) = 2;
  if (a3 && a2 && a4)
  {
    CFGetAllocator((char *)this - 16);
    if (TCFObject<CFNAccount>::Class(void)::sOnce != -1) {
      dispatch_once(&TCFObject<CFNAccount>::Class(void)::sOnce, &__block_literal_global_20221);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    Instance += 16;
    *(_OWORD *)(Instance + 32) = 0u;
    *(void *)uint64_t Instance = &unk_1ECF9A550;
    *(void *)(Instance + 8) = &unk_1ECF9A5A0;
    *(void *)(Instance + CFRetain((char *)this - 16) = 0;
    *(void *)(Instance + CFRelease((char *)this - 24) = 0;
    *(void *)(Instance + 32) = 0;
    *((void *)this + 9) = Instance;
    CFNAccount::initialize((CFNAccount *)Instance, a2);
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(a4))
    {
      CFAllocatorRef v11 = CFGetAllocator((char *)this - 16);
      *((void *)this + 10) = CFStringCreateCopy(v11, a4);
      uint64_t result = 1;
    }
    else
    {
      uint64_t result = 0;
    }
    *((_DWORD *)this + CFRetain((char *)this - 16) = a3;
  }
  return result;
}

void ___ZN9TCFObjectI10CFNAccountE5ClassEv_block_invoke_20224()
{
}

void sub_1842DB190(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

CFStringRef URLCredentialOAuth1::copyDebugDesc(URLCredentialOAuth1 *this)
{
  uint64_t v2 = (char *)this - 16;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, @"<CFURLCredential %p>{Account = %@, persistence = %d}", v2, *(void *)(*((void *)this + 9) + 16), *((unsigned int *)this + 9));
}

BOOL URLCredentialOAuth1::equals(CFNAccount **this, CFNAccount **a2)
{
  BOOL result = URLCredential::equals((URLCredential *)this, (const CFObject *)a2);
  if (result)
  {
    uint64_t v5 = CFNAccount::username(this[9]);
    CFAllocatorRef v6 = CFNAccount::username(a2[9]);
    return CFEqual(v5, v6) != 0;
  }
  return result;
}

void URLCredentialOAuth1::URLCredentialOAuth1(URLCredentialOAuth1 *this)
{
  *((void *)this + 2) = (char *)&gConstantCFStringValueTable + 30184;
  *((_DWORD *)this + 8) = 7;
  *((unsigned char *)this + 48) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_1ECFA0D58;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA0E08;
  *((void *)this + 3) = &unk_1ECFA0E38;
  *((_DWORD *)this + CFRetain((char *)this - 16) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
}

void non-virtual thunk to'HTTP2ConnectionCache::~HTTP2ConnectionCache(HTTP2ConnectionCache *this)
{
  uint64_t v2 = (char *)this - 32;
  HTTP2ConnectionCache::~HTTP2ConnectionCache((HTTP2ConnectionCache *)((char *)this - 32));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 3);

  CFAllocatorDeallocate(v3, v2);
}

{
  HTTP2ConnectionCache::~HTTP2ConnectionCache((HTTP2ConnectionCache *)((char *)this - 32));
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0350;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0350;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

uint64_t HTTP2ConnectionCache::markReusedAfterAPSleepWake(HTTP2ConnectionCache *this)
{
  (*(void (**)(HTTP2ConnectionCache *))(*(void *)this + 40))(this);
  (*(void (**)(void))(**((void **)this + 13) + 40))(*((void *)this + 13));
  uint64_t v2 = *((void *)this + 10);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN20HTTP2ConnectionCache26markReusedAfterAPSleepWakeEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 96))(v2, v4);
}

uint64_t ___ZN20HTTP2ConnectionCache26markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(v1 + 96), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::_visit, &__block_literal_global_10_20249);
  (*(void (**)(void))(**(void **)(v1 + 104) + 48))(*(void *)(v1 + 104));
  uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v2(v1);
}

void ___ZN20HTTP2ConnectionCache35_onqueue_markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef v3 = *(const __CFArray **)(a3 + 88);
  v4.socklen_t length = CFArrayGetCount(v3);
  v4.id location = 0;

  CFArrayApplyFunction(v3, v4, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, &__block_literal_global_14);
}

uint64_t HTTP2ConnectionCache::purgeIdleConnections(HTTP2ConnectionCache *this)
{
  (*(void (**)(HTTP2ConnectionCache *))(*(void *)this + 40))(this);
  (*(void (**)(void))(**((void **)this + 13) + 40))(*((void *)this + 13));
  uint64_t v2 = *((void *)this + 10);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN20HTTP2ConnectionCache20purgeIdleConnectionsEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 96))(v2, v4);
}

uint64_t ___ZN20HTTP2ConnectionCache20purgeIdleConnectionsEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(HTTP2ConnectionCache **)(a1 + 32);
  HTTP2ConnectionCache::_onqueue_removeIdleConnections(v1);
  (*(void (**)(void *))(**((void **)v1 + 13) + 48))(*((void **)v1 + 13));
  uint64_t v2 = *(uint64_t (**)(HTTP2ConnectionCache *))(*(void *)v1 + 48);

  return v2(v1);
}

uint64_t HTTP2ConnectionCache::logConnectionsAtAPSleep(HTTP2ConnectionCache *this)
{
  (*(void (**)(HTTP2ConnectionCache *))(*(void *)this + 40))(this);
  (*(void (**)(void))(**((void **)this + 13) + 40))(*((void *)this + 13));
  uint64_t v2 = *((void *)this + 10);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN20HTTP2ConnectionCache23logConnectionsAtAPSleepEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = this;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 96))(v2, v4);
}

uint64_t ___ZN20HTTP2ConnectionCache23logConnectionsAtAPSleepEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(v1 + 96), (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP2ConnectionCacheEntry *>::_visit, &__block_literal_global_20262);
  (*(void (**)(void))(**(void **)(v1 + 104) + 48))(*(void *)(v1 + 104));
  uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v2(v1);
}

void ___ZN20HTTP2ConnectionCache32_onqueue_logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef v3 = *(const __CFArray **)(a3 + 88);
  v4.socklen_t length = CFArrayGetCount(v3);
  v4.id location = 0;

  CFArrayApplyFunction(v3, v4, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, &__block_literal_global_16_7500);
}

void ___ZN20HTTP2ConnectionCache15initCacheTimersEv_block_invoke(uint64_t a1)
{
}

CFStringRef HTTP2ConnectionCache::copyDebugDesc(HTTP2ConnectionCache *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"HTTP2ConnectionCache<@%p>", this);
}

id ___Z25_AuthBrokerGetServiceNamev_block_invoke()
{
  uint64_t v0 = getenv("AUTHBROKER_SERVICE_NAME");
  if (v0) {
    uint64_t v1 = v0;
  }
  else {
    uint64_t v1 = "com.apple.cfnetwork.AuthBrokerAgent";
  }
  id result = (id)[NSString stringWithUTF8String:v1];
  _AuthBrokerGetServiceName(void)::serviceName = (uint64_t)result;
  return result;
}

void non-virtual thunk to'CFNAccountKerberos::~CFNAccountKerberos(CFNAccountKerberos *this)
{
}

{
  CFNAccountKerberos::~CFNAccountKerberos((CFNAccountKerberos *)((char *)this - 8));
}

void CFNAccountKerberos::~CFNAccountKerberos(CFNAccountKerberos *this)
{
  *(void *)this = &unk_1ECF9EE70;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECF9EEC0;
  uint64_t v2 = (const void *)*((void *)this + 7);
  if (v2) {
    CFRelease(v2);
  }

  CFNAccount::~CFNAccount(this);
}

void sub_1842DBA3C(_Unwind_Exception *a1)
{
  CFNAccount::~CFNAccount(v1);
  _Unwind_Resume(a1);
}

uint64_t CFNAccountKerberos::initialize(CFNAccountKerberos *this, objc_object *a2)
{
  if (!a2) {
    return 0;
  }
  *((void *)this + 2) = a2;
  *((unsigned char *)this + 48) = 0;
  return 1;
}

CFStringRef CFNAccountKerberos::copyDebugDesc(CFNAccountKerberos *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFNAccountKerberos@%p>", this);
}

void ___ZN18CFNAccountKerberos5ClassEv_block_invoke()
{
}

void sub_1842DBB2C(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t CFNAccountKerberos::kerberosCredential(CFNAccountKerberos *this, const __CFURL *a2)
{
  if (*((void *)this + 7)) {
    return *((void *)this + 7);
  }
  if (!*((void *)this + 4))
  {
    CFAllocatorRef v8 = (void *)*((void *)this + 3);
    if (v8) {
      goto LABEL_7;
    }
    uint64_t v10 = (void *)*((void *)this + 2);
    if (v10)
    {
      CFAllocatorRef v11 = (void *)[v10 credential];
      *((void *)this + 3) = v11;
      if (v11)
      {
        id v12 = v11;
        CFAllocatorRef v8 = (void *)*((void *)this + 3);
        if (v8)
        {
LABEL_7:
          uint64_t v9 = (const void *)[v8 token];
          *((void *)this + 4) = v9;
          if (!v9) {
            return *((void *)this + 7);
          }
          CFRetain(v9);
          if (!*((void *)this + 4)) {
            return *((void *)this + 7);
          }
          goto LABEL_3;
        }
      }
    }
    else
    {
      *((void *)this + 3) = 0;
    }
    *((void *)this + 4) = 0;
    return *((void *)this + 7);
  }
LABEL_3:
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  CFUUIDRef v4 = CFUUIDCreateFromString(v3, *((CFStringRef *)this + 4));
  if (v4)
  {
    CFUUIDRef v5 = v4;
    CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
    *((void *)this + 7) = _CFURLCredentialCreateForKerberosTicketWithUUID(v6, 0, 0, 0, v5);
    CFRelease(v5);
  }
  return *((void *)this + 7);
}

void non-virtual thunk to'STubeManager::~STubeManager(STubeManager *this)
{
  uint64_t v2 = (char *)this - 24;
  STubeManager::~STubeManager((STubeManager *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  STubeManager::~STubeManager((STubeManager *)((char *)this - 24));
}

void STubeManager::~STubeManager(STubeManager *this)
{
  *(void *)this = &unk_1ECF9BEC0;
  *((void *)this + 3) = &unk_1ECF9BF28;
  for (uint64_t i = 80; i != 104; i += 8)
  {
    uint64_t v3 = *(void *)((char *)this + i);
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
      *(void *)((char *)this + i) = 0;
    }
  }
  (*(void (**)(void))(**((void **)this + 4) + 48))(*((void *)this + 4));
  *((void *)this + 4) = 0;
  CFRelease(*((CFTypeRef *)this + 18));
  CFRelease(*((CFTypeRef *)this + 17));
  *((void *)this + 15) = &unk_1ECFA03D0;
  CFRelease(*((CFTypeRef *)this + 16));
  *((void *)this + 13) = &unk_1ECFA0330;
  CFRelease(*((CFTypeRef *)this + 14));
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  STubeManager::~STubeManager(this);
  uint64_t v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1842DBDB8(_Unwind_Exception *a1)
{
  CFRelease(*(CFTypeRef *)(v1 + 144));
  CFRelease(*(CFTypeRef *)(v1 + 136));
  *(void *)(v1 + 120) = &unk_1ECFA03D0;
  CFRelease(*(CFTypeRef *)(v1 + 128));
  *(void *)(v1 + 104) = &unk_1ECFA0330;
  CFRelease(*(CFTypeRef *)(v1 + 112));
  *(void *)(v1 + CFRelease((char *)this - 24) = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t STubeManager::getPendingTubeForProtocolWithKey(uint64_t a1, uint64_t a2, void *key)
{
  uint64_t v11 = 0;
  id v12 = &v11;
  uint64_t v13 = 0x2020000000;
  uint64_t v14 = 0;
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), key);
  if (Value)
  {
    uint64_t PendingTubeForProtocolWithKey = (*(uint64_t (**)(const void *, uint64_t, void *))(*(void *)Value + 104))(Value, a2, key);
    v12[3] = PendingTubeForProtocolWithKey;
    if (PendingTubeForProtocolWithKey) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t PendingTubeForProtocolWithKey = v12[3];
    if (PendingTubeForProtocolWithKey) {
      goto LABEL_7;
    }
  }
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  void v10[2] = ___ZN12STubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke;
  void v10[3] = &unk_1E52579E8;
  v10[4] = &v11;
  void v10[5] = a2;
  CFArrayRef v8 = *(const __CFArray **)(a1 + 136);
  v15.socklen_t length = CFArrayGetCount(v8);
  v15.id location = 0;
  CFArrayApplyFunction(v8, v15, (CFArrayApplierFunction)RetainableTypedArray<SAwaitingTube *>::_invoke, v10);
  uint64_t PendingTubeForProtocolWithKey = v12[3];
  if (!PendingTubeForProtocolWithKey)
  {
    uint64_t PendingTubeForProtocolWithKey = SBaseTubeManager::getPendingTubeForProtocolWithKey(a1, a2);
    v12[3] = PendingTubeForProtocolWithKey;
  }
LABEL_7:
  _Block_object_dispose(&v11, 8);
  return PendingTubeForProtocolWithKey;
}

void sub_1842DBFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12STubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1, void *a2)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a2 + 64))(a2);
  if (result == *(void *)(a1 + 40)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = a2[10];
  }
  return result;
}

uint64_t RetainableTypedArray<SAwaitingTube *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFMutableArrayRef STubeManager::pendingTubes@<X0>(CFTypeRef *this@<X0>, CFMutableArrayRef *a2@<X8>)
{
  CFAllocatorRef v4 = CFGetAllocator(this[18]);
  CFMutableArrayRef result = CFArrayCreateMutableCopy(v4, 0, (CFArrayRef)this[18]);
  *a2 = result;
  return result;
}

uint64_t STubeManager::getValidAwaitingTubeForKey(STubeManager *this, const HTTPConnectionCacheKey *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  uint64_t v2 = *((void *)this + 4);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN12STubeManager26getValidAwaitingTubeForKeyEPK22HTTPConnectionCacheKey_block_invoke;
  v5[3] = &unk_1E5257A50;
  v5[4] = &v6;
  void v5[5] = this;
  void v5[6] = a2;
  (*(void (**)(uint64_t, void *))(*(void *)v2 + 104))(v2, v5);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1842DC14C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void **___ZN12STubeManager26getValidAwaitingTubeForKeyEPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1)
{
  CFMutableArrayRef result = STubeManager::_onqueue_getValidAwaitingTubeForKey(*(CFArrayRef **)(a1 + 40), *(const HTTPConnectionCacheKey **)(a1 + 48));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = result;
  return result;
}

void **STubeManager::_onqueue_getValidAwaitingTubeForKey(CFArrayRef *this, const HTTPConnectionCacheKey *a2)
{
  CFIndex Count = CFArrayGetCount(this[17]);
  if (Count < 1) {
    return 0;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (void **)CFArrayGetValueAtIndex(this[17], v6);
    if ((*(unsigned int (**)(void *, const HTTPConnectionCacheKey *))(*ValueAtIndex[4] + 24))(ValueAtIndex[4], a2))
    {
      if (((unsigned int (*)(void **))(*ValueAtIndex)[12])(ValueAtIndex)
        && !((unsigned int (*)(void **))(*ValueAtIndex)[14])(ValueAtIndex))
      {
        break;
      }
    }
    if (v5 == ++v6) {
      return 0;
    }
  }
  return ValueAtIndex;
}

uint64_t STubeManager::newTubeReady(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (!a2) {
    __assert_rtn("newTubeReady", "STubeManager.cpp", 255, "FALSE");
  }
  if (!a2[12]) {
    __assert_rtn("newTubeReady", "STubeManager.cpp", 251, "FALSE");
  }
  (*(void (**)(void *))(*a2 + 40))(a2);
  (*(void (**)(void *))(*a1 + 40))(a1);
  uint64_t v8 = a1[4];
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  void v10[2] = ___ZN12STubeManager12newTubeReadyEP5STube13CFStreamError_block_invoke;
  void v10[3] = &__block_descriptor_64_e5_v8__0l;
  v10[4] = a1;
  void v10[5] = a2;
  void v10[6] = a3;
  void v10[7] = a4;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, v10);
}

uint64_t ___ZN12STubeManager12newTubeReadyEP5STube13CFStreamError_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = a1[5];
  if (v3)
  {
    uint64_t v4 = a1[6];
    uint64_t v5 = a1[7];
    (*(void (**)(void))(*(void *)v3 + 40))(a1[5]);
    CFArrayRef v6 = *(const __CFArray **)(v2 + 144);
    v56.socklen_t length = CFArrayGetCount(v6);
    v56.id location = 0;
    CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v6, v56, (const void *)v3);
    if (FirstIndexOfValue == -1)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
    }
    else
    {
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v2 + 144), FirstIndexOfValue);
      uint64_t Waiter = STube::getWaiter((STube *)v3);
      if (!Waiter) {
        __assert_rtn("_onqueue_newTubeReady", "STubeManager.cpp", 444, "firstWaiter != NULL");
      }
      uint64_t v9 = (const void *)Waiter;
      (*(void (**)(uint64_t))(*(void *)Waiter + 40))(Waiter);
      CFArrayRef v10 = *(const __CFArray **)(v2 + 136);
      v57.socklen_t length = CFArrayGetCount(v10);
      v57.id location = 0;
      CFIndex v11 = CFArrayGetFirstIndexOfValue(v10, v57, v9);
      if (v11 == -1) {
        __assert_rtn("_onqueue_newTubeReady", "STubeManager.cpp", 447, "i != -1");
      }
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v2 + 136), v11);
      id v12 = *(void **)(v3 + 96);
      uint64_t v47 = 0;
      uint64_t v48 = 0;
      long long v45 = 0x3F000000FFFFFFFFuLL;
      LODWORD(v46) = 0;
      if (v5 || STube::isCanceled((STube *)v3))
      {
        uint64_t v13 = (*(uint64_t (**)(const void *))(*(void *)v9 + 64))(v9);
        uint64_t v14 = v13;
        if (v5)
        {
          if (v4 == *MEMORY[0x1E4F1D430])
          {
            uint64_t context = 0;
            p_uint64_t context = (uint64_t)&context;
            uint64_t v36 = 0x2020000000;
            uint64_t v37 = 0;
            uint64_t v15 = *(void *)(v3 + 112);
            uint64_t v49 = MEMORY[0x1E4F143A8];
            uint64_t v50 = 3221225472;
            int v51 = ___ZN5STube18copySSLCertContextEv_block_invoke;
            int v52 = &unk_1E5257C30;
            int v53 = &context;
            CFIndex v54 = (const void *)v3;
            (*(void (**)(uint64_t, uint64_t *))(*(void *)v15 + 104))(v15, &v49);
            uint64_t v16 = *(const void **)(p_context + 24);
            _Block_object_dispose(&context, 8);
          }
          else
          {
            uint64_t v16 = 0;
          }
          if (v14) {
            uint64_t v18 = v14 - 176;
          }
          else {
            uint64_t v18 = 0;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t, const void *))(*(void *)v18 + 280))(v18, v4, v5, v16);
          if (v16) {
            CFRelease(v16);
          }
        }
        else
        {
          if (v13) {
            uint64_t v17 = v13 - 176;
          }
          else {
            uint64_t v17 = 0;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v17 + 280))(v17, 1, 89, 0);
        }
        uint64_t v48 = 0;
        (*(void (**)(const void *, void))(*(void *)v9 + 56))(v9, 0);
        uint64_t v19 = 0;
        int v33 = 1;
      }
      else
      {
        if (*(_DWORD *)(v3 + 136) != 1) {
          __assert_rtn("connectionCacheTypeForTubeType", "STubeManager.h", 124, "FALSE");
        }
        STubeManager::_onqueue_pairKeyWithConnectionCache(v2, v12);
        uint64_t v19 = *(void *)(v2 + 80);
        if (!v19) {
          __assert_rtn("_onqueue_newTubeReady", "STubeManager.cpp", 506, "connCache");
        }
        (*(void (**)(void, uint64_t))(*(void *)v19 + 96))(*(void *)(v2 + 80), v3);
        int v33 = 0;
      }
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(v2 + 8), 0, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 136));
      if (Count >= 1)
      {
        CFIndex v22 = 0;
        uint64_t v32 = v19;
        do
        {
          CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 136), v22);
          if ((*(unsigned int (**)(void, void *))(**((void **)ValueAtIndex + 4) + 24))(*((void *)ValueAtIndex + 4), v12)&& *((void *)ValueAtIndex + 10) == v3)
          {
            if ((*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 96))(ValueAtIndex))
            {
              if (!v33)
              {
                if (!v19) {
                  __assert_rtn("_onqueue_newTubeReady", "STubeManager.cpp", 564, "connCache != NULL");
                }
                (*(void (**)(const void *, uint64_t *, uint64_t *, long long *))(*(void *)ValueAtIndex + 88))(ValueAtIndex, &v48, &v47, &v45);
                (*(void (**)(const void *, void))(*(void *)ValueAtIndex + 56))(ValueAtIndex, 0);
                uint64_t v25 = *(void *)(v3 + 200);
                CFAllocatorRef v26 = *(std::__shared_weak_count **)(v3 + 208);
                if (v26)
                {
                  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
                  if (v25)
                  {
                    uint64_t v27 = v48;
                    uint64_t v43 = v25;
                    char v44 = v26;
                    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
                    goto LABEL_39;
                  }
                }
                else if (v25)
                {
                  uint64_t v27 = v48;
                  uint64_t v43 = *(void *)(v3 + 200);
                  char v44 = 0;
LABEL_39:
                  (*(void (**)(uint64_t, uint64_t *))(*(void *)v27 + 40))(v27, &v43);
                  if (v44) {
                    std::__shared_weak_count::__release_shared[abi:nn180100](v44);
                  }
                  uint64_t v28 = *(void *)(v3 + 96);
                  uint64_t v41 = v25;
                  CFDictionaryRef v42 = v26;
                  if (v26) {
                    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  (*(void (**)(uint64_t, uint64_t *))(*(void *)v28 + 56))(v28, &v41);
                  if (v42) {
                    std::__shared_weak_count::__release_shared[abi:nn180100](v42);
                  }
                }
                long long v39 = v45;
                uint64_t v40 = v46;
                uint64_t v19 = v32;
                (*(void (**)(uint64_t, uint64_t, uint64_t, long long *))(*(void *)v32 + 80))(v32, v48, v47, &v39);
                if (v26) {
                  std::__shared_weak_count::__release_shared[abi:nn180100](v26);
                }
                goto LABEL_27;
              }
              (*(void (**)(const void *, void))(*(void *)ValueAtIndex + 56))(ValueAtIndex, 0);
              (*(void (**)(const void *))(*(void *)ValueAtIndex + 40))(ValueAtIndex);
              (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
              uint64_t v24 = *(void *)(v2 + 32);
              uint64_t v49 = MEMORY[0x1E4F143A8];
              uint64_t v50 = 3221225472;
              int v51 = ___ZN12STubeManager21_onqueue_newTubeReadyEP5STube13CFStreamError_block_invoke;
              int v52 = &__block_descriptor_48_e5_v8__0l;
              int v53 = (uint64_t *)v2;
              CFIndex v54 = ValueAtIndex;
              (*(void (**)(uint64_t, uint64_t *))(*(void *)v24 + 96))(v24, &v49);
            }
            else
            {
              (*(void (**)(const void *, void))(*(void *)ValueAtIndex + 56))(ValueAtIndex, 0);
            }
          }
          else
          {
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
LABEL_27:
          ++v22;
        }
        while (Count != v22);
      }
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v2 + 136));
      uint64_t context = MEMORY[0x1E4F143A8];
      p_uint64_t context = 3221225472;
      uint64_t v36 = (uint64_t)___ZN12STubeManager21_onqueue_newTubeReadyEP5STube13CFStreamError_block_invoke_2;
      uint64_t v37 = &__block_descriptor_40_e163_v16__0__SAwaitingTube________CFAllocator_iB_____HTTPConnectionCacheKey___HTTPRequestMessage___MetaConnectionCacheClient__MetaConnectionOptions_ifQCCCC___STube_dd_8l;
      uint64_t v38 = v2;
      v58.socklen_t length = CFArrayGetCount(Mutable);
      v58.id location = 0;
      CFArrayApplyFunction(Mutable, v58, (CFArrayApplierFunction)RetainableTypedArray<SAwaitingTube *>::_invoke, &context);
      (*(void (**)(const void *))(*(void *)v9 + 48))(v9);
      (*(void (**)(uint64_t))(*(void *)v3 + 48))(v3);
      CFRelease(Mutable);
    }
  }
  uint64_t v29 = a1[5];
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 48))(v29);
  }
  CFAllocatorRef v30 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 48);

  return v30(v2);
}

void sub_1842DCCB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void STubeManager::_onqueue_pairKeyWithConnectionCache(uint64_t a1, void *key)
{
  uint64_t v4 = *(_OWORD **)(a1 + 80);
  if (!v4)
  {
    uint64_t v4 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 128, 0);
    _OWORD *v4 = 0u;
    v4[1] = 0u;
    v4[3] = 0u;
    v4[4] = 0u;
    void v4[5] = 0u;
    void v4[6] = 0u;
    v4[7] = 0u;
    void v4[2] = 0u;
    CFAllocatorRef v5 = *(const __CFAllocator **)(a1 + 8);
    MetaConnectionCache::MetaConnectionCache((MetaConnectionCache *)v4, v5);
    *CFArrayRef v6 = &unk_1ECFA19A8;
    *((void *)v4 + 4) = &unk_1ECFA1A68;
    *((void *)v4 + 6) = CFSetCreateMutable(v5, 0, &CFAllocatedReferenceCountedObject::skCFTypeSetCallBacks);
    long long v7 = *(_OWORD *)(a1 + 40);
    long long v8 = *(_OWORD *)(a1 + 56);
    *((void *)v4 + 1HTTPServerConnection::canceled_onQueue(this - 1) = *(void *)(a1 + 72);
    *(_OWORD *)((char *)v4 + 72) = v8;
    *(_OWORD *)((char *)v4 + 56) = v7;
    (*(void (**)(_OWORD *, void, uint64_t))(*(void *)v4 + 64))(v4, *(void *)(a1 + 32), a1);
    *(void *)(a1 + ++*(void *)(this + 80) = v4;
  }
  uint64_t v9 = *(__CFDictionary **)(a1 + 112);

  CFDictionarySetValue(v9, key, v4);
}

void sub_1842DCE54(_Unwind_Exception *a1)
{
  *(void *)(v1 + 32) = &unk_1ECF9B550;
  *(void *)uint64_t v1 = &unk_1ECF9FF58;

  _Unwind_Resume(a1);
}

uint64_t ___ZN12STubeManager21_onqueue_newTubeReadyEP5STube13CFStreamError_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(_OWORD **)(a1 + 40);
  uint64_t v4 = (*(uint64_t (**)(_OWORD *))(*(void *)v3 + 64))(v3);
  uint64_t v5 = (*(uint64_t (**)(_OWORD *))(*(void *)v3 + 72))(v3);
  (*(void (**)(long long *__return_ptr, _OWORD *))(*(void *)v3 + 80))(&v8, v3);
  STubeManager::_onqueue_enqueueRequestForProtocol(v2, v4, v5, &v8, v3);
  (*(void (**)(void))(**(void **)(a1 + 40) + 48))(*(void *)(a1 + 40));
  CFArrayRef v6 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 48);

  return v6(v2);
}

void ___ZN12STubeManager21_onqueue_newTubeReadyEP5STube13CFStreamError_block_invoke_2(uint64_t a1, const void *a2)
{
}

uint64_t STubeManager::_onqueue_enqueueRequestForProtocol(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, _OWORD *a5)
{
  CFArrayRef v10 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), v10);
  if (Value)
  {
    if (!a5)
    {
LABEL_4:
      long long v30 = *a4;
      uint64_t v31 = *((void *)a4 + 2);
      return (*(uint64_t (**)(const void *, uint64_t, uint64_t, long long *))(*(void *)Value + 80))(Value, a2, a3, &v30);
    }
LABEL_3:
    uint64_t v39 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0x3F000000FFFFFFFFLL;
    uint64_t v34 = 0;
    LODWORD(v35) = 0;
    (*(void (**)(_OWORD *, uint64_t *, uint64_t *, uint64_t *))(*(void *)a5 + 88))(a5, &v39, &v32, &v33);
    goto LABEL_4;
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 144))(a2))
  {
LABEL_6:
    STubeManager::_onqueue_pairKeyWithConnectionCache(a1, v10);
    uint64_t v13 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), v10);
    if (!v13) {
      __assert_rtn("_onqueue_enqueueRequestForProtocol", "STubeManager.cpp", 313, "connCache != NULL");
    }
    CFNumberRef Value = v13;
    (*(void (**)(const void *, void *))(*(void *)v13 + 72))(v13, v10);
    if (!a5) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  uint64_t v14 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  BOOL v15 = (*(unsigned int (**)(void *))(*v14 + 88))(v14) == 1
     || (*(unsigned int (**)(void *))(*v14 + 88))(v14) == 3;
  unint64_t v16 = v14[9];
  (*(void (**)(void *))(*v14 + 64))(v14);
  if (v15)
  {
    if (v16 == 1) {
      goto LABEL_6;
    }
  }
  else if (v16 < 2)
  {
    goto LABEL_6;
  }
  uint64_t v27 = a3;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 144));
  if (Count < 1)
  {
LABEL_22:
    CFDictionaryRef ValueAtIndex = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 248, 0);
    *CFDictionaryRef ValueAtIndex = 0u;
    ValueAtIndex[1] = 0u;
    ValueAtIndex[2] = 0u;
    ValueAtIndex[3] = 0u;
    ValueAtIndex[4] = 0u;
    ValueAtIndex[5] = 0u;
    ValueAtIndex[6] = 0u;
    ValueAtIndex[7] = 0u;
    ValueAtIndex[8] = 0u;
    ValueAtIndex[9] = 0u;
    ValueAtIndex[10] = 0u;
    ValueAtIndex[11] = 0u;
    ValueAtIndex[12] = 0u;
    ValueAtIndex[13] = 0u;
    ValueAtIndex[14] = 0u;
    *((void *)ValueAtIndex + 30) = 0;
    STube::STube((uint64_t)ValueAtIndex, *(const __CFAllocator **)(a1 + 8), (uint64_t)v10, a1, *(void *)(a1 + 32));
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 144), ValueAtIndex);
    (*(void (**)(_OWORD *))(*(void *)ValueAtIndex + 48))(ValueAtIndex);
    int v23 = 1;
  }
  else
  {
    CFIndex v18 = Count;
    CFIndex v19 = 0;
    while (1)
    {
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), v19);
      if ((*(unsigned int (**)(void, void *))(**((void **)ValueAtIndex + 12) + 24))(*((void *)ValueAtIndex + 12), v10))
      {
        uint64_t v39 = 0;
        uint64_t v40 = &v39;
        uint64_t v41 = 0x2020000000;
        char v42 = 0;
        uint64_t v21 = *((void *)ValueAtIndex + 14);
        uint64_t v33 = MEMORY[0x1E4F143A8];
        uint64_t v34 = 3221225472;
        CFTypeID v35 = ___ZN5STube16canAcceptWaitersEv_block_invoke;
        uint64_t v36 = &unk_1E5257C30;
        uint64_t v37 = &v39;
        uint64_t v38 = ValueAtIndex;
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v21 + 104))(v21, &v33);
        int v22 = *((unsigned __int8 *)v40 + 24);
        _Block_object_dispose(&v39, 8);
        if (v22) {
          break;
        }
      }
      if (v18 == ++v19) {
        goto LABEL_22;
      }
    }
    int v23 = 0;
  }
  if (!a5)
  {
    a5 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 8), 104, 0);
    *a5 = 0u;
    a5[1] = 0u;
    a5[2] = 0u;
    a5[3] = 0u;
    a5[4] = 0u;
    a5[5] = 0u;
    *((void *)a5 + 12) = 0;
    long long v28 = *a4;
    uint64_t v29 = *((void *)a4 + 2);
    CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)a5, *(const __CFAllocator **)(a1 + 8));
    *(void *)uint64_t v24 = &unk_1ECF9C508;
    *(void *)(v24 + CFRelease((char *)this - 24) = &unk_1ECF9C590;
    *(_OWORD *)(v24 + 56) = v28;
    *(void *)(v24 + 72) = v29;
    if (!v27) {
      __assert_rtn("SAwaitingTube", "SAwaitingTube.cpp", 16, "httpMessage");
    }
    *((void *)a5 + 5) = v27;
    CFRetain((CFTypeRef)(v27 - 16));
    *((void *)a5 + 6) = a2;
    (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
    uint64_t v25 = (*(uint64_t (**)(void))(**((void **)a5 + 6) + 32))(*((void *)a5 + 6));
    *((void *)a5 + 4) = v25;
    (*(void (**)(uint64_t))(*(void *)v25 + 40))(v25);
    *((void *)a5 + 10) = 0;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *((CFAbsoluteTime *)a5 + 1HTTPServerConnection::canceled_onQueue(this - 1) = Current;
    *((CFAbsoluteTime *)a5 + 12) = Current;
    (*(void (**)(_OWORD *, _OWORD *))(*(void *)a5 + 56))(a5, ValueAtIndex);
    if (!v23) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  (*(void (**)(_OWORD *, _OWORD *))(*(void *)a5 + 56))(a5, ValueAtIndex);
  (*(void (**)(_OWORD *))(*(void *)a5 + 40))(a5);
  if (v23) {
LABEL_26:
  }
    STube::initialize((STube *)ValueAtIndex, (SBaseAwaitingTube *)a5);
LABEL_27:
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 136), a5);
  return (*(uint64_t (**)(_OWORD *))(*(void *)a5 + 48))(a5);
}

void sub_1842DD648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t ___ZN12STubeManager24invalidateAllConnectionsEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 112);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN5STube6cancelEv_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  v4[4] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 104))(v2, v4);
}

uint64_t ___ZN12STubeManager38invalidateUnpurgeableConnectionsForKeyEPK22HTTPConnectionCacheKey_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 128))(a2, *(void *)(a1 + 32));
}

uint64_t ___ZN12STubeManager25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  long long v9 = *(_OWORD *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 72);
  STubeManager::_onqueue_enqueueRequestForProtocol(v3, v2, v4, &v9, 0);
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 48);
  if (v6) {
    CFRelease((CFTypeRef)(v6 - 16));
  }
  long long v7 = *(uint64_t (**)(uint64_t))(*(void *)v3 + 48);

  return v7(v3);
}

void CoreSchedulingSet::performSync(CoreSchedulingSet *this, uint64_t a2)
{
  int v4 = *((_DWORD *)this + 10);
  if ((v4 - 1) < 2)
  {
    if (!CoreSchedulingSet::currentlyInContext(this))
    {
      uint64_t v5 = dispatch_semaphore_create(0);
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 3221225472;
      void v9[2] = ___ZNK17CoreSchedulingSet11performSyncEU13block_pointerFvvE_block_invoke;
      void v9[3] = &unk_1E5258028;
      v9[4] = v5;
      v9[5] = a2;
      (*(void (**)(CoreSchedulingSet *, void *))(*(void *)this + 96))(this, v9);
      dispatch_semaphore_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v5);
      return;
    }
  }
  else
  {
    if (v4 != 3)
    {
      if (!v4) {
        abort();
      }
      return;
    }
    uint64_t v6 = *((void *)this + 7);
    if (v6 != dispatch_get_current_queue())
    {
      long long v7 = (os_unfair_lock_s *)((char *)this + 64);
      os_unfair_lock_lock(v7);
      (*(void (**)(uint64_t))(a2 + 16))(a2);
      os_unfair_lock_unlock(v7);
      return;
    }
  }
  long long v8 = *(void (**)(uint64_t))(a2 + 16);

  v8(a2);
}

BOOL CoreSchedulingSet::currentlyInContext(CoreSchedulingSet *this)
{
  int v2 = *((_DWORD *)this + 10);
  if ((v2 - 1) >= 2)
  {
    return v2 == 3 && dispatch_get_current_queue() == *((dispatch_queue_t *)this + 7);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2020000000;
    char v12 = 0;
    CFAbsoluteTime Current = CFRunLoopGetCurrent();
    int v4 = Current;
    if (!Current || (uint64_t v5 = CFRunLoopCopyCurrentMode(Current)) == 0)
    {
      if (*MEMORY[0x1E4F1D418]) {
        uint64_t v5 = CFRetain((CFTypeRef)*MEMORY[0x1E4F1D418]);
      }
      else {
        uint64_t v5 = 0;
      }
    }
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    v8[2] = ___ZNK17CoreSchedulingSet18currentlyInContextEv_block_invoke;
    void v8[3] = &unk_1E5257AE0;
    v8[4] = &v9;
    void v8[5] = v4;
    void v8[6] = v5;
    CoreSchedulingSet::applyBlock((uint64_t)this, v8);
    if (v5) {
      CFRelease(v5);
    }
    uint64_t v6 = *((unsigned __int8 *)v10 + 24);
    _Block_object_dispose(&v9, 8);
  }
  return v6;
}

void sub_1842DDB68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t ___ZNK17CoreSchedulingSet11performSyncEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  int v2 = *(NSObject **)(a1 + 32);

  return dispatch_semaphore_signal(v2);
}

uint64_t ___ZNK17CoreSchedulingSet18currentlyInContextEv_block_invoke(uint64_t result, uint64_t a2, CFTypeRef cf2)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24))
  {
    uint64_t v3 = result;
    if (*(void *)(result + 40) == a2)
    {
      if (cf2 && (CFMutableArrayRef result = *(void *)(result + 48)) != 0 && (CFMutableArrayRef result = CFEqual((CFTypeRef)result, cf2), result)
        || (CFTypeRef)*MEMORY[0x1E4F1D410] == cf2 && *(void *)(v3 + 48) && (CFMutableArrayRef result = _CFRunLoop01(), result))
      {
        *(unsigned char *)(*(void *)(*(void *)(v3 + 32) + 8) + CFRelease((char *)this - 24) = 1;
      }
    }
  }
  return result;
}

uint64_t _applyRunloopBlock(const __CFArray *a1, void *a2)
{
  CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
  uint64_t v5 = CFArrayGetValueAtIndex(a1, 1);
  uint64_t v6 = (uint64_t (*)(void *, const void *, const void *))a2[2];

  return v6(a2, ValueAtIndex, v5);
}

uint64_t CoreSchedulingSet::createDispatchTimer(CoreSchedulingSet *this)
{
  return 0;
}

uint64_t CoreSchedulingSet::copyWithUpdatesReleaseSelf(CoreSchedulingSet *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t isEqualTo = (*(uint64_t (**)(CoreSchedulingSet *))(*(void *)this + 88))(this);
  uint64_t v7 = isEqualTo;
  int v8 = *((_DWORD *)a3 + 10);
  if (v8)
  {
    int v9 = *(_DWORD *)(isEqualTo + 40);
    int v10 = v8 | (v9 << 16);
    if (v10 >= 0x20000)
    {
      if (v10 >= 196608)
      {
        if ((v10 - 196609) < 2)
        {
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)int buf = 0;
            uint64_t v20 = MEMORY[0x1E4F14500];
            uint64_t v21 = "was scheduled on a dispatch queue, but now want to be on a runloop?";
            uint32_t v22 = 2;
            goto LABEL_25;
          }
LABEL_39:
          uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 88))(v7);
LABEL_40:
          (*(void (**)(uint64_t))(*(void *)v7 + 48))(v7);
          uint64_t v7 = v19;
          goto LABEL_41;
        }
        if (v10 == 196611)
        {
          if (*(void *)(isEqualTo + 56) != *((void *)a3 + 7)) {
            goto LABEL_39;
          }
        }
        else if (v10 != 196608)
        {
          goto LABEL_21;
        }
      }
      else if (v10 != 0x20000)
      {
        if (v10 == 131073)
        {
          CFAllocatorRef v23 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          Array = (CoreSchedulingSet *)cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(void *)(isEqualTo + 72), *(void *)(isEqualTo + 80), 0);
          if (CFSetContainsValue(*(CFSetRef *)(v7 + 48), Array))
          {
            CFIndex Count = CFSetGetCount(*(CFSetRef *)(v7 + 48));
            MutableCFStringRef Copy = CFSetCreateMutableCopy(v23, Count, *(CFSetRef *)(v7 + 48));
            CFSetRemoveValue(MutableCopy, Array);
            CoreSchedulingSet::create((CoreSchedulingSet *)MutableCopy, v26);
            uint64_t v19 = v27;
            if (MutableCopy) {
              CFRelease(MutableCopy);
            }
LABEL_32:
            if (Array) {
              CFRelease(Array);
            }
            if (v19) {
              goto LABEL_40;
            }
            goto LABEL_39;
          }
LABEL_31:
          uint64_t v19 = 0;
          goto LABEL_32;
        }
        if (v10 != 131074)
        {
LABEL_21:
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v9;
            LOWORD(v53) = 1024;
            *(_DWORD *)((char *)&v53 + 2) = v8;
            uint64_t v20 = MEMORY[0x1E4F14500];
            uint64_t v21 = "Can't remove scheduling of type %d with type %d";
            uint32_t v22 = 14;
LABEL_25:
            _os_log_fault_impl(&dword_184085000, v20, OS_LOG_TYPE_FAULT, v21, buf, v22);
            goto LABEL_39;
          }
          goto LABEL_39;
        }
        uint64_t isEqualTo = CFEqual(*(CFTypeRef *)(isEqualTo + 48), *((CFTypeRef *)a3 + 6));
        if (!isEqualTo)
        {
          CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFSetRef v12 = *(const __CFSet **)(v7 + 48);
          CFSetRef v13 = (const __CFSet *)*((void *)a3 + 6);
          CFIndex v14 = CFSetGetCount(v12);
          Array = (CoreSchedulingSet *)CFSetCreateMutableCopy(v11, v14, v12);
          CFSetApplyFunction(v13, (CFSetApplierFunction)_subPair, Array);
          CoreSchedulingSet::create(Array, v16);
LABEL_17:
          uint64_t v19 = Empty;
          goto LABEL_32;
        }
      }
    }
    else
    {
      if (v10 < 0x10000)
      {
        if (v10 < 4) {
          goto LABEL_39;
        }
        goto LABEL_21;
      }
      if (v10 != 0x10000)
      {
        if (v10 != 65537)
        {
          if (v10 == 65538)
          {
            Array = (CoreSchedulingSet *)cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(void *)(isEqualTo + 72), *(void *)(isEqualTo + 80), 0);
            CFIndex v18 = (CoreSchedulingSet *)CFSetContainsValue(*((CFSetRef *)a3 + 6), Array);
            if (v18)
            {
              uint64_t Empty = CoreSchedulingSet::createEmpty(v18);
              goto LABEL_17;
            }
            goto LABEL_31;
          }
          goto LABEL_21;
        }
        uint64_t isEqualTo = CoreSchedulingSet::isEqualTo((CoreSchedulingSet *)isEqualTo, a3);
        if (!isEqualTo) {
          goto LABEL_39;
        }
      }
    }
    uint64_t v19 = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)isEqualTo);
    if (v19) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
LABEL_41:
  int v28 = *((_DWORD *)a2 + 10);
  if (v28)
  {
    int v29 = *(_DWORD *)(v7 + 40);
    int v30 = v28 | (v29 << 16);
    if (v30 <= 65537)
    {
      if (v30 < 0x10000)
      {
        if ((v30 - 1) >= 3)
        {
          if (v30)
          {
LABEL_70:
            if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 67109376;
              *(_DWORD *)&uint8_t buf[4] = v29;
              LOWORD(v53) = 1024;
              *(_DWORD *)((char *)&v53 + 2) = v28;
              _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Can't add scheduling of type %d with type %d", buf, 0xEu);
            }
          }
LABEL_79:
          uint64_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 88))(v7);
          goto LABEL_80;
        }
        goto LABEL_56;
      }
      if (v30 == 0x10000 || CoreSchedulingSet::isEqualTo((CoreSchedulingSet *)v7, a2)) {
        goto LABEL_79;
      }
      CFAllocatorRef v36 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      *(void *)int buf = cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(void *)(v7 + 72), *(void *)(v7 + 80), 0);
      int v53 = cfTypeCreateArray(v36, *((void *)a2 + 9), *((void *)a2 + 10), 0);
      uint64_t v37 = (CoreSchedulingSet *)CFSetCreate(v36, (const void **)buf, 2, MEMORY[0x1E4F1D548]);
      CoreSchedulingSet::create(v37, v38);
      uint64_t v33 = v39;
      if (v37) {
        CFRelease(v37);
      }
      if (*(void *)buf) {
        CFRelease(*(CFTypeRef *)buf);
      }
      uint64_t v40 = v53;
      if (!v53) {
        goto LABEL_78;
      }
      goto LABEL_77;
    }
    if (v30 > 131073)
    {
      if (v30 != 131074)
      {
        if (v30 == 196608) {
          goto LABEL_79;
        }
        if (v30 != 196611) {
          goto LABEL_70;
        }
LABEL_56:
        uint64_t v33 = (*(uint64_t (**)(const CoreSchedulingSet *))(*(void *)a2 + 88))(a2);
        goto LABEL_78;
      }
      if (CFEqual(*(CFTypeRef *)(v7 + 48), *((CFTypeRef *)a2 + 6))) {
        goto LABEL_79;
      }
      CFAllocatorRef v42 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFSetRef v43 = *(const __CFSet **)(v7 + 48);
      CFSetRef v44 = (const __CFSet *)*((void *)a2 + 6);
      CFIndex v45 = CFSetGetCount(v43);
      CFIndex v46 = CFSetGetCount(v44);
      uint64_t v32 = (CoreSchedulingSet *)CFSetCreateMutableCopy(v42, v46 + v45, v43);
      CFSetApplyFunction(v44, (CFSetApplierFunction)_unionPair, v32);
      CoreSchedulingSet::create(v32, v47);
    }
    else
    {
      if (v30 != 65538)
      {
        if (v30 == 0x20000) {
          goto LABEL_79;
        }
        if (v30 != 131073) {
          goto LABEL_70;
        }
        CFAllocatorRef v31 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        uint64_t v32 = (CoreSchedulingSet *)cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *((void *)a2 + 9), *((void *)a2 + 10), 0);
        uint64_t v33 = 0;
        if (CFSetContainsValue(*(CFSetRef *)(v7 + 48), v32)) {
          goto LABEL_75;
        }
        CFIndex v34 = CFSetGetCount(*(CFSetRef *)(v7 + 48)) + 1;
        CFSetRef v35 = *(const __CFSet **)(v7 + 48);
        goto LABEL_73;
      }
      CFAllocatorRef v31 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v32 = (CoreSchedulingSet *)cfTypeCreateArray((const __CFAllocator *)*MEMORY[0x1E4F1CF80], *(void *)(v7 + 72), *(void *)(v7 + 80), 0);
      if (!CFSetContainsValue(*((CFSetRef *)a2 + 6), v32))
      {
        CFIndex v34 = CFSetGetCount(*((CFSetRef *)a2 + 6)) + 1;
        CFSetRef v35 = (const __CFSet *)*((void *)a2 + 6);
LABEL_73:
        uint64_t v48 = CFSetCreateMutableCopy(v31, v34, v35);
        CFSetAddValue(v48, v32);
        CoreSchedulingSet::create((CoreSchedulingSet *)v48, v49);
        uint64_t v33 = v50;
        if (v48) {
          CFRelease(v48);
        }
        goto LABEL_75;
      }
      uint64_t v41 = (*(uint64_t (**)(const CoreSchedulingSet *))(*(void *)a2 + 88))(a2);
    }
    uint64_t v33 = v41;
LABEL_75:
    if (!v32) {
      goto LABEL_78;
    }
    uint64_t v40 = v32;
LABEL_77:
    CFRelease(v40);
LABEL_78:
    if (v33)
    {
LABEL_80:
      (*(void (**)(uint64_t))(*(void *)v7 + 48))(v7);
      uint64_t v7 = v33;
      goto LABEL_81;
    }
    goto LABEL_79;
  }
LABEL_81:
  (*(void (**)(CoreSchedulingSet *))(*(void *)this + 48))(this);
  return v7;
}

uint64_t CoreSchedulingSet::isEqualTo(CoreSchedulingSet *this, const CoreSchedulingSet *a2)
{
  if (this == a2) {
    return 1;
  }
  int v2 = *((_DWORD *)this + 10);
  if (v2 != *((_DWORD *)a2 + 10)) {
    return 0;
  }
  if (v2 == 3) {
    return *((void *)this + 7) == *((void *)a2 + 7);
  }
  if (v2 == 2)
  {
    int v4 = (const void *)*((void *)this + 6);
    uint64_t v5 = (const void *)*((void *)a2 + 6);
    return CFEqual(v4, v5);
  }
  if (v2 != 1) {
    return 1;
  }
  if (*((void *)this + 9) != *((void *)a2 + 9)) {
    return 0;
  }
  return CFEqual(*((CFTypeRef *)this + 10), *((CFTypeRef *)a2 + 10)) != 0;
}

void CoreSchedulingSet::create(CoreSchedulingSet *this, const __CFSet *a2)
{
  CFIndex Count = CFSetGetCount((CFSetRef)this);
  if (Count == 1)
  {
    values = 0;
    CFSetGetValues((CFSetRef)this, (const void **)&values);
    if (CFArrayGetCount((CFArrayRef)values) != 2 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "assertion failure", v6, 2u);
    }
    CoreSchedulingSet::create((CoreSchedulingSet *)values, v4);
  }
  else if (Count)
  {
    uint64_t v5 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 120, 0);
    *uint64_t v5 = 0u;
    v5[1] = 0u;
    v5[2] = 0u;
    v5[3] = 0u;
    v5[4] = 0u;
    void v5[5] = 0u;
    void v5[6] = 0u;
    *((void *)v5 + 14) = 0;
    RunLoopSchedulingSet::RunLoopSchedulingSet((RunLoopSchedulingSet *)v5, (const __CFSet *)this);
  }
  else
  {
    CoreSchedulingSet::createEmpty(0);
  }
}

void _unionPair(const void *value, CFMutableSetRef theSet)
{
}

_OWORD *CoreSchedulingSet::create(CoreSchedulingSet *this, const __CFArray *a2)
{
  CFIndex Count = CFArrayGetCount((CFArrayRef)this);
  if (Count == 2)
  {
    CFDictionaryRef ValueAtIndex = (CoreSchedulingSet *)CFArrayGetValueAtIndex((CFArrayRef)this, 0);
    CFStringRef v7 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)this, 1);
    return CoreSchedulingSet::create(ValueAtIndex, v7, v8);
  }
  else
  {
    uint64_t v4 = Count;
    if (Count)
    {
      if ((Count & 1) != 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)int buf = 0;
        _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "odd number in runloop/mode array", buf, 2u);
      }
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (v4 >= 0) {
        uint64_t v10 = v4;
      }
      else {
        uint64_t v10 = v4 + 1;
      }
      CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v10 >> 1, MEMORY[0x1E4F1D548]);
      if (v4 >= 1)
      {
        for (CFIndex i = 0; i < v4; CFIndex i = v15 + 1)
        {
          CFIndex v14 = CFArrayGetValueAtIndex((CFArrayRef)this, i);
          CFIndex v15 = i + 1;
          CFSetRef v16 = CFArrayGetValueAtIndex((CFArrayRef)this, v15);
          Array = cfTypeCreateArray(v9, v14, v16, 0);
          CFSetAddValue(Mutable, Array);
          if (Array) {
            CFRelease(Array);
          }
        }
      }
      CoreSchedulingSet::create((CoreSchedulingSet *)Mutable, v11);
      uint64_t v19 = v18;
      if (Mutable) {
        CFRelease(Mutable);
      }
      return (_OWORD *)v19;
    }
    else
    {
      return (_OWORD *)CoreSchedulingSet::createEmpty(0);
    }
  }
}

void RunLoopSchedulingSet::RunLoopSchedulingSet(RunLoopSchedulingSet *this, const __CFSet *a2)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject(this, (const __CFAllocator *)*MEMORY[0x1E4F1CF80]);
  *(_DWORD *)(v4 + 40) = 2;
  *(void *)uint64_t v4 = &unk_1ECFA1900;
  *(void *)(v4 + CFRelease((char *)this - 24) = &unk_1ECFA1988;
  *((void *)this + 6) = CFSetCreateCopy(*(CFAllocatorRef *)(v4 + 8), a2);
  *((unsigned char *)this + 1CFRetain((char *)this - 16) = 0;
}

void sub_1842DE828(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1ECF9E210;
  *(_DWORD *)(v1 + 40) = 0;
  *(void *)(v1 + CFRelease((char *)this - 24) = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void non-virtual thunk to'RunLoopSchedulingSet::~RunLoopSchedulingSet(RunLoopSchedulingSet *this)
{
  int v2 = (char *)this - 24;
  RunLoopSchedulingSet::~RunLoopSchedulingSet((RunLoopSchedulingSet *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  RunLoopSchedulingSet::~RunLoopSchedulingSet((RunLoopSchedulingSet *)((char *)this - 24));
}

void RunLoopSchedulingSet::~RunLoopSchedulingSet(RunLoopSchedulingSet *this)
{
  *(void *)this = &unk_1ECFA1900;
  *((void *)this + 3) = &unk_1ECFA1988;
  uint64_t v2 = *((void *)this + 13);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
    *((void *)this + 13) = 0;
  }
  if (*((_DWORD *)this + 10) == 2)
  {
    CFAllocatorRef v3 = (const void *)*((void *)this + 6);
    if (!v3) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  uint64_t v4 = (const void *)*((void *)this + 9);
  if (v4) {
    CFRelease(v4);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 10);
  if (v3) {
LABEL_9:
  }
    CFRelease(v3);
LABEL_10:
  *(void *)this = &unk_1ECF9E210;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  RunLoopSchedulingSet::~RunLoopSchedulingSet(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1842DE9A8(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1ECF9E210;
  *(_DWORD *)(v1 + 40) = 0;
  *(void *)(v1 + CFRelease((char *)this - 24) = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void RetainableTypedDict<__CFRunLoop *,CoreSchedulingSet const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0210;
  CFRelease(*(CFTypeRef *)(a1 + 8));

  JUMPOUT(0x18531B6D0);
}

uint64_t RetainableTypedDict<__CFRunLoop *,CoreSchedulingSet const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = &unk_1ECFA0210;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void non-virtual thunk to'RunloopBlockContext::~RunloopBlockContext(RunloopBlockContext *this)
{
  uint64_t v2 = (char *)this - 32;
  RunloopBlockContext::~RunloopBlockContext((RunloopBlockContext *)((char *)this - 32));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 3);

  CFAllocatorDeallocate(v3, v2);
}

{
  RunloopBlockContext::~RunloopBlockContext((RunloopBlockContext *)((char *)this - 32));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 24;
  RunloopBlockContext::~RunloopBlockContext((RunloopBlockContext *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  RunloopBlockContext::~RunloopBlockContext((RunloopBlockContext *)((char *)this - 24));
}

void RunloopBlockContext::~RunloopBlockContext(RunloopBlockContext *this)
{
  *(void *)this = &unk_1ECFA0450;
  *((void *)this + 3) = &unk_1ECFA04B0;
  *((void *)this + 4) = &unk_1ECFA04D0;
  RunLoopMultiplexer::unschedule(gMuxer, *((const void **)this + 6), (char *)this + 32);
  (*(void (**)(void))(**((void **)this + 6) + 48))(*((void *)this + 6));
  uint64_t v2 = (const void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 7) = 0;
    CFRelease(v2);
  }
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  RunloopBlockContext::~RunloopBlockContext(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1842DEBD0(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

BOOL RunloopBlockContext::equals(RunloopBlockContext *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

uint64_t RunLoopSchedulingSet::copyWithRemovalReleaseSelf(CoreSchedulingSet *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  if (*((_DWORD *)this + 10) == 1
    && *((CoreSchedulingSet **)this + 9) == a2
    && (CFStringRef v7 = (CoreSchedulingSet *)CFEqual(cf1, *((CFTypeRef *)this + 10)), v7))
  {
    uint64_t Empty = CoreSchedulingSet::createEmpty(v7);
    (*(void (**)(CoreSchedulingSet *))(*(void *)this + 48))(this);
    return Empty;
  }
  else
  {
    return CoreSchedulingSet::copyWithAdditionReleaseSelf(this, a2, cf1);
  }
}

uint64_t CoreSchedulingSet::copyWithAdditionReleaseSelf(CoreSchedulingSet *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  uint64_t v4 = CoreSchedulingSet::create(a2, cf1, cf1);
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1) {
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
  }
  uint64_t v5 = (*(uint64_t (**)(CoreSchedulingSet *, _OWORD *, uint64_t))(*(void *)this + 72))(this, v4, CoreSchedulingSet::getEmptySet(void)::sEmptySet);
  (*(void (**)(_OWORD *))(*(void *)v4 + 48))(v4);
  return v5;
}

void non-virtual thunk to'EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet(EmptyCoreSchedulingSet *this)
{
}

{
  EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet((EmptyCoreSchedulingSet *)((char *)this - 24));
}

void EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet(EmptyCoreSchedulingSet *this)
{
  *(void *)this = &unk_1ECFA2200;
  *((void *)this + 3) = &unk_1ECFA2288;
  fprintf((FILE *)*MEMORY[0x1E4F143C8], "empty scheduling set being deallocated %p\n", this);
  abort();
}

{
  EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet(this);
}

{
  EmptyCoreSchedulingSet::~EmptyCoreSchedulingSet(this);
}

void sub_1842DEEA0(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &unk_1ECF9E210;
  *(_DWORD *)(v1 + 40) = 0;
  *(void *)(v1 + CFRelease((char *)this - 24) = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void EmptyCoreSchedulingSet::performAsync()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v0 = 0;
    _os_log_fault_impl(&dword_184085000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "EMPTY SET INVOKED", v0, 2u);
  }
}

EmptyCoreSchedulingSet *EmptyCoreSchedulingSet::createCopy(EmptyCoreSchedulingSet *this)
{
  return this;
}

const CoreSchedulingSet *EmptyCoreSchedulingSet::copyWithUpdatesReleaseSelf(EmptyCoreSchedulingSet *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  return a2;
}

uint64_t EmptyCoreSchedulingSet::copyWithRemovalReleaseSelf(EmptyCoreSchedulingSet *this, __CFRunLoop *a2, const __CFString *a3)
{
  return (*(uint64_t (**)(void))(*(void *)this + 88))();
}

BOOL CoreSchedulingSet::equals(CoreSchedulingSet *this, const CoreSchedulingSet *a2)
{
  return CoreSchedulingSet::isEqualTo(this, a2) != 0;
}

CFStringRef CoreSchedulingSet::copyDebugDesc(CoreSchedulingSet *this)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  *(_OWORD *)__str = 0u;
  long long v14 = 0u;
  uint64_t v2 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  switch(*((_DWORD *)this + 10))
  {
    case 0:
      strcpy(__str, "not scheduled");
      break;
    case 1:
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFStringRef v4 = (const __CFString *)*((void *)this + 10);
      CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v10 = 1023;
      if (v4)
      {
        uint64_t v5 = _CFStringGetOrCreateCString(v3, v4, v12, &v10, 0x8000100u);
      }
      else
      {
        v12[0] = 0;
        uint64_t v10 = 0;
        uint64_t v5 = v12;
      }
      ptr = v5;
      snprintf(__str, 0x100uLL, "pair { %p, %s }", *((const void **)this + 9), (const char *)v5);
      if (ptr && v12 != ptr) {
        CFAllocatorDeallocate(allocator, ptr);
      }
      break;
    case 2:
      strcpy(__str, "multi scheduled");
      break;
    case 3:
      uint64_t v6 = *((void *)this + 7);
      label = dispatch_queue_get_label(v6);
      snprintf(__str, 0x100uLL, "queue %p %s", v6, label);
      break;
    default:
      return CFStringCreateWithFormat(*v2, 0, @"CoreSchedulingSet<%p> { %s }", this, __str);
  }
  return CFStringCreateWithFormat(*v2, 0, @"CoreSchedulingSet<%p> { %s }", this, __str);
}

CFStringRef _createWrappedStringWithFormat(CFStringRef format, ...)
{
  va_start(va, format);
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v2 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, format, va);
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v1, v2, @"\n");
  if (ArrayBySeparatingStrings)
  {
    CFArrayRef v4 = ArrayBySeparatingStrings;
    if (CFArrayGetCount(ArrayBySeparatingStrings) != 1)
    {
      CFRelease(v2);
      CFStringRef v2 = CFStringCreateByCombiningStrings(v1, v4, @" ");
    }
    CFRelease(v4);
  }
  return v2;
}

void _perform(atomic_ullong *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    CFStringRef v2 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = 138412290;
      CFArrayRef v4 = a1;
      _os_log_impl(&dword_184085000, v2, OS_LOG_TYPE_DEFAULT, "Unexpectedly performed: %@", (uint8_t *)&v3, 0xCu);
    }
    atomic_fetch_add_explicit(a1 + 5, 1uLL, memory_order_relaxed);
  }
}

void *_cancel(void *result, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v5 = result;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 138412290;
      CFStringRef v8 = v5;
      _os_log_impl(&dword_184085000, v6, OS_LOG_TYPE_DEFAULT, "Unexpectedly canceled: %@", buf, 0xCu);
    }
    -[__CFN_CoreSchedulingSetRunnable __SITUATIONAL_ABORT__:reason:](v5, (uint64_t)"source was canceled", (void *)[NSString stringWithFormat:@"cancel called for rl %p, mode %@", a2, a3]);
  }
  return result;
}

CoreSchedulingSet *RunLoopSchedulingSet::copyWithAdditionReleaseSelf(CoreSchedulingSet *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  if (*((_DWORD *)this + 10) == 1 && *((CoreSchedulingSet **)this + 9) == a2 && CFEqual(cf1, *((CFTypeRef *)this + 10))) {
    return this;
  }

  return (CoreSchedulingSet *)CoreSchedulingSet::copyWithAdditionReleaseSelf(this, a2, cf1);
}

CFStringRef RunLoopSchedulingSet::copyDebugDesc(CoreSchedulingSet *this)
{
  CFStringRef v2 = CoreSchedulingSet::copyDebugDesc(this);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = v2;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@ (%s)", v2, *((void *)this + 12));
  CFRelease(v3);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 13);
    if (v6)
    {
      CFStringRef v7 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
      CFStringRef v8 = _cfnAutoreleaseInDebug(v7);
      CFStringRef v9 = CFStringCreateWithFormat(v4, 0, @"%@ - PENDING %s", v5, v8);
      CFRelease(v5);
      return v9;
    }
  }
  return v5;
}

void _subPair(const void *value, CFMutableSetRef theSet)
{
}

uint64_t CoreSchedulingSet::copyWithRemovalReleaseSelf(CoreSchedulingSet *this, CoreSchedulingSet *a2, const __CFString *cf1)
{
  CFAllocatorRef v4 = CoreSchedulingSet::create(a2, cf1, cf1);
  if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1) {
    dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_20378);
  }
  uint64_t v5 = (*(uint64_t (**)(CoreSchedulingSet *, uint64_t, _OWORD *))(*(void *)this + 72))(this, CoreSchedulingSet::getEmptySet(void)::sEmptySet, v4);
  (*(void (**)(_OWORD *))(*(void *)v4 + 48))(v4);
  return v5;
}

void non-virtual thunk to'QCoreSchedulingSet::~QCoreSchedulingSet(QCoreSchedulingSet *this)
{
  CFStringRef v2 = (char *)this - 24;
  QCoreSchedulingSet::~QCoreSchedulingSet((QCoreSchedulingSet *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  QCoreSchedulingSet::~QCoreSchedulingSet((QCoreSchedulingSet *)((char *)this - 24));
}

void QCoreSchedulingSet::~QCoreSchedulingSet(QCoreSchedulingSet *this)
{
  *(void *)this = &unk_1ECF9F650;
  *((void *)this + 3) = &unk_1ECF9F6D8;
  dispatch_release(*((dispatch_object_t *)this + 7));
  *((void *)this + 7) = 0;
  *(void *)this = &unk_1ECF9E210;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  QCoreSchedulingSet::~QCoreSchedulingSet(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

QCoreSchedulingSet *QCoreSchedulingSet::createCopy(QCoreSchedulingSet *this)
{
  return this;
}

void ___ZNK17CoreSchedulingSet14scheduleSourceEP17__CFRunLoopSource_block_invoke(uint64_t a1, CFRunLoopRef rl, const __CFString *a3)
{
}

void CoreSchedulingSet::applyBlockWithPossibleEmulation(uint64_t a1, void *a2)
{
  int v3 = *(_DWORD *)(a1 + 40);
  if ((v3 - 1) >= 2)
  {
    if (v3 == 3)
    {
      uint64_t v5 = _coreSchedulingSet_RLM();
      uint64_t v6 = (void (*)(void *, uint64_t, uint64_t))a2[2];
      v6(a2, v5, v4);
    }
  }
  else
  {
    CoreSchedulingSet::applyBlock(a1, a2);
  }
}

void CoreSchedulingSet::scheduleTimer(CoreSchedulingSet *this, __CFRunLoopTimer *a2)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
  v2[3] = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v2[4] = a2;
  CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)this, v2);
}

void ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke(uint64_t a1, CFRunLoopRef rl, const __CFString *a3)
{
}

void ___ZNK17CoreSchedulingSet15unscheduleTimerEP16__CFRunLoopTimer_block_invoke(uint64_t a1, CFRunLoopRef rl, const __CFString *a3)
{
}

void _CFStreamUnscheduleFromDispatchQueue()
{
}

void RunLoopMultiplexer::~RunLoopMultiplexer(CFTypeRef *this)
{
  RunLoopMultiplexer::~RunLoopMultiplexer(this);

  JUMPOUT(0x18531B6D0);
}

{
  *this = &unk_1ECF9F6F8;
  CFRelease(this[3]);
  *this = &unk_1ECF9B550;
}

void sub_1842DFE04(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t coreSchedulingSetEqual(const void *a1, const void *a2)
{
  return (*(uint64_t (**)(const void *, const void *))(*(void *)a1 + 24))(a1, a2);
}

uint64_t coreSchedulingSetCopyDescription(const void *a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t coreSchedulingSetRelease(const __CFAllocator *a1, const void *a2)
{
  return (*(uint64_t (**)(const void *))(*(void *)a2 + 48))(a2);
}

CFStringRef MultiplexerSource::_copyDesc(MultiplexerSource *this, const void *a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CFMultiplexerSource %p>", this);
}

void *MultiplexerSource::Release(void *this, const void *a2)
{
  uint64_t v2 = this[6];
  BOOL v3 = __OFSUB__(v2, 1);
  uint64_t v4 = v2 - 1;
  this[6] = v4;
  if (this)
  {
    if ((v4 < 0) ^ v3 | (v4 == 0)) {
      return (void *)(*(uint64_t (**)(void))(*this + 8))();
    }
  }
  return this;
}

void MultiplexerSource::~MultiplexerSource(MultiplexerSource *this)
{
  MultiplexerSource::~MultiplexerSource(this);

  JUMPOUT(0x18531B6D0);
}

{
  const void *v2;
  const void *v3;
  const void *v4;
  __CFRunLoopSource *v5;
  const void *v6;

  *(void *)this = &unk_1ECF9ED30;
  uint64_t v2 = (const void *)*((void *)this + 10);
  if (v2) {
    CFRelease(v2);
  }
  BOOL v3 = (const void *)*((void *)this + 8);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 9);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (__CFRunLoopSource *)*((void *)this + 7);
  if (v5)
  {
    CFRunLoopSourceInvalidate(v5);
    uint64_t v6 = (const void *)*((void *)this + 7);
    if (v6) {
      CFRelease(v6);
    }
  }
  *(void *)this = &unk_1ECF9B550;
}

void sub_1842DFFF8(_Unwind_Exception *a1)
{
  void *v1 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void RunLoopMultiplexer::unschedule(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 8);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
  CFNumberRef Value = (os_unfair_lock_s *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    CFStringRef v8 = Value;
    CFStringRef v9 = Value + 2;
    os_unfair_lock_lock(Value + 2);
    CFSetRemoveValue(*(CFMutableSetRef *)&v8[20]._os_unfair_lock_opaque, a3);
    if (CFSetContainsValue(*(CFSetRef *)&v8[16]._os_unfair_lock_opaque, a3))
    {
      CFSetRemoveValue(*(CFMutableSetRef *)&v8[16]._os_unfair_lock_opaque, a3);
      CFArrayRef v10 = *(const __CFArray **)&v8[18]._os_unfair_lock_opaque;
      v17.socklen_t length = CFArrayGetCount(v10);
      v17.id location = 0;
      CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v10, v17, a3);
      if (FirstIndexOfValue != -1) {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)&v8[18]._os_unfair_lock_opaque, FirstIndexOfValue);
      }
    }
    if (CFSetGetCount(*(CFSetRef *)&v8[20]._os_unfair_lock_opaque))
    {
      os_unfair_lock_unlock(v9);
    }
    else
    {
      CFSetRef v12 = *(__CFRunLoopSource **)&v8[14]._os_unfair_lock_opaque;
      if (v12) {
        CFRunLoopSourceInvalidate(v12);
      }
      uint64_t v13 = *(void *)&v8[8]._os_unfair_lock_opaque;
      if (v13)
      {
        BYTE1(v8[6]._os_unfair_lock_opaque) = 1;
      }
      else
      {
        LOBYTE(v8[6]._os_unfair_lock_opaque) = 1;
        long long v14 = *(const void **)&v8[14]._os_unfair_lock_opaque;
        if (v14)
        {
          CFRelease(v14);
          *(void *)&v8[14]._os_unfair_lock_opaque = 0;
        }
      }
      os_unfair_lock_unlock(v9);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), a2);
      if (!v13)
      {
        uint64_t v15 = *(void *)&v8[12]._os_unfair_lock_opaque;
        *(void *)&v8[12]._os_unfair_lock_opaque = v15 - 1;
        if (v15 <= 1) {
          (*(void (**)(os_unfair_lock_s *))(*(void *)&v8->_os_unfair_lock_opaque + 8))(v8);
        }
      }
    }
  }

  os_unfair_lock_unlock(v6);
}

__n128 __Block_byref_object_copy__20540(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  return result;
}

void non-virtual thunk to'URLCredentialOAuth2::~URLCredentialOAuth2(URLCredentialOAuth2 *this)
{
}

{
  URLCredentialOAuth2::~URLCredentialOAuth2((URLCredentialOAuth2 *)((char *)this - 24));
}

{
  URLCredentialOAuth2::~URLCredentialOAuth2((URLCredentialOAuth2 *)((char *)this - 8));
}

{
  URLCredentialOAuth2::~URLCredentialOAuth2((URLCredentialOAuth2 *)((char *)this - 8));
}

void URLCredentialOAuth2::~URLCredentialOAuth2(URLCredentialOAuth2 *this)
{
  *(void *)this = &unk_1ECFA0E58;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA0EF0;
  *((void *)this + 3) = &unk_1ECFA0F20;
  uint64_t v2 = (const void *)*((void *)this + 8);
  if (v2) {
    CFRelease(v2);
  }
  BOOL v3 = (const void *)*((void *)this + 9);
  if (v3) {
    CFRelease(v3);
  }

  URLCredential::~URLCredential(this);
}

void sub_1842E0260(_Unwind_Exception *a1)
{
  URLCredential::~URLCredential(v1);
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'URLCredentialOAuth2::serializeToPropertyList(URLCredentialOAuth2 *this, SerializableArchive **a2)
{
  return 1;
}

uint64_t URLCredentialOAuth2::serializeToPropertyList(URLCredentialOAuth2 *this, SerializableArchive **a2)
{
  URLCredential::serializeToPropertyList(this, a2);
  uint64_t v4 = (const void *)*((void *)this + 8);
  SerializableArchive::assertEmpty(*a2, @"oauthtoken");
  if (v4) {
    CFDictionarySetValue(*a2, @"oauthtoken", v4);
  }
  return 1;
}

BOOL non-virtual thunk to'URLCredentialOAuth2::initializeFromPropertyList(URLCredentialOAuth2 *this, CFDictionaryRef *a2)
{
  return URLCredentialOAuth2::initializeFromPropertyList((URLCredentialOAuth2 *)((char *)this - 8), a2);
}

BOOL URLCredentialOAuth2::initializeFromPropertyList(URLCredentialOAuth2 *this, CFDictionaryRef *a2)
{
  BOOL result = URLCredential::initializeFromPropertyList(this, a2);
  if (result)
  {
    CFNumberRef Value = CFDictionaryGetValue(*a2, @"oauthtoken");
    if (Value) {
      CFNumberRef Value = CFRetain(Value);
    }
    *((void *)this + 8) = Value;
    return 1;
  }
  return result;
}

CFTypeRef URLCredentialOAuth2::copyOAuthToken(URLCredentialOAuth2 *this)
{
  if (!*((void *)this + 8)) {
    return 0;
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(*((CFTypeRef *)this + 8))) {
    return 0;
  }
  BOOL v3 = (const void *)*((void *)this + 8);
  if (!v3) {
    return 0;
  }

  return CFRetain(v3);
}

uint64_t URLCredentialOAuth2::getOAuthToken(URLCredentialOAuth2 *this)
{
  if (*((void *)this + 8) && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(*((CFTypeRef *)this + 8)))) {
    return *((void *)this + 8);
  }
  else {
    return 0;
  }
}

uint64_t URLCredentialOAuth2::getUserName(URLCredentialOAuth2 *this)
{
  return 0;
}

CFTypeRef URLCredentialOAuth2::copyStorageNameForCredentialType(URLCredentialOAuth2 *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 8);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

CFHashCode URLCredentialOAuth2::calcHash(URLCredentialOAuth2 *this, uint64_t a2)
{
  uint64_t v2 = a2;
  BOOL v3 = (const void *)*((void *)this + 8);
  if (v3) {
    return CFHash(v3) ^ a2;
  }
  return v2;
}

uint64_t URLCredentialOAuth2::copy(const __CFString **this)
{
  CFGetAllocator(this - 2);
  if (URLCredential::Class(void)::sOnce_URLCredential != -1) {
    dispatch_once(&URLCredential::Class(void)::sOnce_URLCredential, &__block_literal_global_10148);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *(_OWORD *)(Instance + ++*(void *)(this + 64) = 0u;
  *(_OWORD *)(Instance + ++*(void *)(this + 80) = 0u;
  *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
  *(void *)(Instance + 32) = &gConstantCFStringValueTable[3773];
  *(_DWORD *)(Instance + 48) = 6;
  *(unsigned char *)(Instance + ++*(void *)(this + 64) = 0;
  *(void *)(Instance + 72) = 0;
  *(void *)(Instance + ++*(void *)(this + 80) = 0;
  *(void *)(Instance + 56) = 0;
  *(void *)(Instance + CFRetain((char *)this - 16) = &unk_1ECFA0E58;
  *(void *)(Instance + CFRelease((char *)this - 24) = &unk_1ECFA0EF0;
  *(void *)(Instance + 40) = &unk_1ECFA0F20;
  *(void *)(Instance + 88) = 0;
  URLCredentialOAuth2::initialize((URLCredentialOAuth2 *)(Instance + 16), this[8], this[9]);
  return Instance;
}

uint64_t URLCredentialOAuth2::initialize(URLCredentialOAuth2 *this, const __CFString *a2, const __CFString *a3)
{
  uint64_t result = 0;
  *((_DWORD *)this + 9) = 2;
  if (a2 && a3)
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(a2) && (CFTypeID v8 = CFStringGetTypeID(), v8 == CFGetTypeID(a3)))
    {
      CFAllocatorRef v9 = CFGetAllocator((char *)this - 16);
      *((void *)this + 8) = CFStringCreateCopy(v9, a2);
      CFAllocatorRef v10 = CFGetAllocator((char *)this - 16);
      *((void *)this + 9) = CFStringCreateCopy(v10, a3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFStringRef URLCredentialOAuth2::copyDebugDesc(URLCredentialOAuth2 *this)
{
  uint64_t v2 = (char *)this - 16;
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v3, 0, @"<CFURLCredential %p>{OAuthToken = %@, persistence = %d}", v2, *((void *)this + 8), *((unsigned int *)this + 9));
}

BOOL URLCredentialOAuth2::equals(CFTypeRef *this, CFTypeRef *a2)
{
  BOOL result = URLCredential::equals((URLCredential *)this, (const CFObject *)a2);
  if (result) {
    return CFEqual(this[8], a2[8]) != 0;
  }
  return result;
}

void URLCredentialOAuth2::URLCredentialOAuth2(URLCredentialOAuth2 *this)
{
  *((void *)this + 2) = (char *)&gConstantCFStringValueTable + 30184;
  *((_DWORD *)this + 8) = 6;
  *((unsigned char *)this + 48) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_1ECFA0E58;
  *((void *)this + HTTPServerConnection::canceled_onQueue(this - 1) = &unk_1ECFA0EF0;
  *((void *)this + 3) = &unk_1ECFA0F20;
  *((void *)this + 9) = 0;
}

uint64_t CFURLDownloadCopyRequest(char *cf)
{
  if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
    dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
  }
  if (cf) {
    uint64_t v2 = cf + 16;
  }
  else {
    uint64_t v2 = 0;
  }
  CFGetAllocator(cf);
  CFAllocatorRef v3 = (void *)*((void *)v2 + 3);

  return [v3 copy];
}

void _NSURLDownloadDidFail(_CFURLDownload *a1, __CFError *a2, void *a3)
{
  if (a3 && *(unsigned char *)(a3[1] + 40))
  {
    uint64_t v5 = (void *)MEMORY[0x18531D6D0](a1);
    id v6 = *(id *)(a3[1] + 32);
    if (objc_opt_respondsToSelector())
    {
      CFStringRef v7 = cfnTranslateCFError(a2, (void *)[a3 url]);
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 3221225472;
      v8[2] = __29__NSURLDownload_sendDidFail___block_invoke;
      void v8[3] = &unk_1E5257FB0;
      v8[4] = a3;
      void v8[5] = v7;
      [a3 withDelegate:v8];
    }
  }
}

void _NSURLDownloadDidFinish(_CFURLDownload *a1, void *a2)
{
  if (a2 && *(unsigned char *)(a2[1] + 40))
  {
    CFAllocatorRef v3 = (void *)MEMORY[0x18531D6D0](a1);
    id v4 = *(id *)(a2[1] + 32);
    if (objc_opt_respondsToSelector())
    {
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 3221225472;
      v5[2] = __30__NSURLDownload_sendDidFinish__block_invoke;
      v5[3] = &unk_1E5258228;
      v5[4] = a2;
      [a2 withDelegate:v5];
    }
  }
}

void _NSURLDownloadDidCreateDestination(_CFURLDownload *a1, const __CFURL *a2, void *a3)
{
  if (a3 && *(unsigned char *)(a3[1] + 40))
  {
    uint64_t v5 = (void *)MEMORY[0x18531D6D0](a1);
    id v6 = *(id *)(a3[1] + 32);
    if (objc_opt_respondsToSelector())
    {
      CFStringRef v7 = CFURLCopyFileSystemPath(a2, kCFURLPOSIXPathStyle);
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 3221225472;
      v8[2] = __42__NSURLDownload_sendDidCreateDestination___block_invoke;
      void v8[3] = &unk_1E5258250;
      v8[4] = a3;
      void v8[5] = v7;
      [a3 withDelegate:v8];
      CFRelease(v7);
    }
  }
}

void _NSURLDownloadDecideDestinationWithSuggestedObjectName(_CFURLDownload *a1, const __CFString *a2, void *a3)
{
  if (a3 && *(unsigned char *)(a3[1] + 40))
  {
    uint64_t v5 = (void *)MEMORY[0x18531D6D0](a1);
    id v6 = *(id *)(a3[1] + 32);
    if (objc_opt_respondsToSelector())
    {
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3221225472;
      void v7[2] = __62__NSURLDownload_sendDecideDestinationWithSuggestedObjectName___block_invoke;
      v7[3] = &unk_1E5258250;
      v7[4] = a3;
      void v7[5] = a2;
      [a3 withDelegate:v7];
    }
  }
}

void *_NSURLDownloadShouldDecodeDataOfMIMEType(_CFURLDownload *a1, const __CFString *a2, void *a3)
{
  CFAllocatorRef v3 = a3;
  if (a3)
  {
    if (*(unsigned char *)(a3[1] + 40))
    {
      uint64_t v5 = (void *)MEMORY[0x18531D6D0](a1);
      id v6 = *(id *)(v3[1] + 32);
      uint64_t v9 = 0;
      CFAllocatorRef v10 = &v9;
      uint64_t v11 = 0x2020000000;
      char v12 = 1;
      if (objc_opt_respondsToSelector())
      {
        v8[0] = MEMORY[0x1E4F143A8];
        v8[1] = 3221225472;
        v8[2] = __48__NSURLDownload_sendShouldDecodeDataOfMIMEType___block_invoke;
        void v8[3] = &unk_1E5257BA0;
        v8[4] = v3;
        void v8[5] = &v9;
        void v8[6] = a2;
        [v3 withDelegate:v8];
      }
      CFAllocatorRef v3 = (void *)*((unsigned __int8 *)v10 + 24);
      _Block_object_dispose(&v9, 8);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

void sub_1842E15B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _NSURLDownloadDidReceiveData(_CFURLDownload *a1, uint64_t a2, void *a3)
{
  if (a3 && *(unsigned char *)(a3[1] + 40))
  {
    uint64_t v5 = (void *)MEMORY[0x18531D6D0](a1);
    id v6 = *(id *)(a3[1] + 32);
    if (objc_opt_respondsToSelector())
    {
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3221225472;
      void v7[2] = __36__NSURLDownload_sendDidReceiveData___block_invoke;
      v7[3] = &unk_1E5258250;
      v7[4] = a3;
      void v7[5] = a2;
      [a3 withDelegate:v7];
    }
  }
}

void _NSURLDownloadWillResumeWithResponse(_CFURLDownload *a1, _CFURLResponse *a2, uint64_t a3, void *a4)
{
  if (a4 && *(unsigned char *)(a4[1] + 40))
  {
    CFStringRef v7 = (void *)MEMORY[0x18531D6D0](a1);
    id v8 = *(id *)(a4[1] + 32);
    if (objc_opt_respondsToSelector())
    {
      id v9 = +[NSURLResponse _responseWithCFURLResponse:a2];
      v10[0] = MEMORY[0x1E4F143A8];
      v10[1] = 3221225472;
      void v10[2] = __57__NSURLDownload_sendWillResumeWithResponse_startingByte___block_invoke;
      void v10[3] = &unk_1E5257B78;
      v10[4] = a4;
      void v10[5] = v9;
      void v10[6] = a3;
      [a4 withDelegate:v10];
    }
  }
}

void _NSURLDownloadDidReceiveResponse(_CFURLDownload *a1, _CFURLResponse *a2, void *a3)
{
  if (a3 && *(unsigned char *)(a3[1] + 40))
  {
    uint64_t v5 = (void *)MEMORY[0x18531D6D0](a1);
    id v6 = *(id *)(a3[1] + 32);
    if (objc_opt_respondsToSelector())
    {
      id v7 = +[NSURLResponse _responseWithCFURLResponse:a2];
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 3221225472;
      v8[2] = __40__NSURLDownload_sendDidReceiveResponse___block_invoke;
      void v8[3] = &unk_1E5257FB0;
      v8[4] = a3;
      void v8[5] = v7;
      [a3 withDelegate:v8];
    }
  }
}

void _NSURLDownloadDidReceiveAuthenticationChallenge(_CFURLDownload *a1, _CFURLAuthChallenge *a2, void *a3)
{
  if (a3 && *(unsigned char *)(a3[1] + 40))
  {
    uint64_t v5 = (void *)MEMORY[0x18531D6D0](a1);
    id v6 = *(id *)(a3[1] + 32);
    if (objc_opt_respondsToSelector())
    {
      CFRetain(a2);
      *(void *)(a3[1] + CFRetain((char *)this - 16) = a2;
      CFMakeCollectable(a2);
      *(void *)(a3[1] + CFRelease((char *)this - 24) = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:a2 sender:a3];
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 3221225472;
      void v9[2] = __41__NSURLDownload_sendDidReceiveChallenge___block_invoke;
      void v9[3] = &unk_1E5258228;
      v9[4] = a3;
      [a3 withDelegate:v9];
    }
    else
    {
      uint64_t v7 = *(void *)(a3[1] + 8);
      if (URLDownload::Class(void)::sOnce_URLDownload != -1) {
        dispatch_once(&URLDownload::Class(void)::sOnce_URLDownload, &__block_literal_global_5409);
      }
      if (v7) {
        id v8 = (URLDownload *)(v7 + 16);
      }
      else {
        id v8 = 0;
      }
      URLDownload::useCredential(v8, 0, a2);
    }
  }
}

void *_NSURLDownloadWillSendRequest(_CFURLDownload *a1, const _CFURLRequest *a2, _CFURLResponse *a3, void *a4)
{
  id v4 = a4;
  if (a4)
  {
    if (*(unsigned char *)(a4[1] + 40))
    {
      uint64_t v7 = (void *)MEMORY[0x18531D6D0](a1);
      id v8 = *(id *)(v4[1] + 32);
      uint64_t v11 = 0;
      char v12 = &v11;
      uint64_t v13 = 0x2020000000;
      uint64_t v14 = 0;
      if (objc_opt_respondsToSelector())
      {
        v10[0] = MEMORY[0x1E4F143A8];
        v10[1] = 3221225472;
        void v10[2] = __54__NSURLDownload_sendWillSendRequest_redirectResponse___block_invoke;
        void v10[3] = &unk_1E5257B50;
        void v10[6] = a2;
        void v10[7] = a3;
        v10[4] = v4;
        void v10[5] = &v11;
        [v4 withDelegate:v10];
      }
      id v4 = (void *)v12[3];
      if (!v4)
      {
        v12[3] = (uint64_t)a2;
        CFRetain(a2);
        id v4 = (void *)v12[3];
      }
      _Block_object_dispose(&v11, 8);
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

void sub_1842E1C14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _NSURLDownloadDidStart(_CFURLDownload *a1, void *a2)
{
  if (a2 && *(unsigned char *)(a2[1] + 40))
  {
    id v4 = (void *)MEMORY[0x18531D6D0]();
    id v5 = *(id *)(a2[1] + 32);
    uint64_t v6 = a2[1];
    if (!*(void *)(v6 + 8)) {
      *(void *)(v6 + 8) = a1;
    }
    if (objc_opt_respondsToSelector())
    {
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 3221225472;
      v8[2] = __30__NSURLDownload_sendDidStart___block_invoke;
      void v8[3] = &unk_1E5258228;
      v8[4] = a2;
      [a2 withDelegate:v8];
    }
    if (objc_opt_respondsToSelector())
    {
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3221225472;
      void v7[2] = __30__NSURLDownload_sendDidStart___block_invoke_2;
      v7[3] = &unk_1E5258228;
      v7[4] = a2;
      [a2 withDelegate:v7];
    }
  }
}

void _NSURLDownloadReleaseClient(void *a1)
{
  uint64_t v2 = (void *)MEMORY[0x18531D6D0]();
  if (a1)
  {

    *(void *)(a1[1] + 32) = 0;
  }
  CFRelease(a1);
}

void IOLogger::~IOLogger(IOLogger *this)
{
  *(void *)this = &unk_1ECFA5B20;
  *((void *)this + 34) = 0;
  JUMPOUT(0x18531B6D0);
}

{
  *(void *)this = &unk_1ECFA5B20;
  *((void *)this + 34) = 0;
}

uint64_t DiagnoticIOLoggerDestination::logStructured(DiagnoticIOLoggerDestination *this, const LineInfo *a2, const __CFArray *a3)
{
  uint64_t result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_28_20783, 3);
  if (result)
  {
    uint64_t v6 = result;
    buffer = "Structured";
    if (a2 && a2[1].buffer) {
      buffer = a2[1].buffer;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void))(*(void *)result + 16))(result, buffer, 0);
    if (result)
    {
      (*(void (**)(uint64_t, const char *, const __CFArray *))(*(void *)v6 + 80))(v6, "logStruct", a3);
      id v8 = *(uint64_t (**)(uint64_t))(*(void *)v6 + 8);
      return v8(v6);
    }
  }
  return result;
}

uint64_t ___ZN28DiagnoticIOLoggerDestination13logStructuredEPKN12LogFormatter8LineInfoEPK9__CFArray_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + CFRelease((char *)this - 24) = "CFNetwork";
  *(void *)(a1 + 32) = 31;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

int *DiagnoticIOLoggerDestination::logData(DiagnoticIOLoggerDestination *this, const LineInfo *a2, const char *a3, const char *a4, const unsigned __int8 *a5, uint64_t a6)
{
  uint64_t result = (int *)DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_26_20790, 2);
  if (result)
  {
    uint64_t v11 = result;
    uint64_t result = (int *)(*(uint64_t (**)(int *, const char *, void))(*(void *)result + 16))(result, a3, 0);
    if (result)
    {
      if (v11[2] >= 3) {
        (*(void (**)(int *, const char *, const unsigned __int8 *, uint64_t))(*(void *)v11 + 112))(v11, a4, a5, a6);
      }
      char v12 = *(uint64_t (**)(int *))(*(void *)v11 + 8);
      return (int *)v12(v11);
    }
  }
  return result;
}

uint64_t ___ZN28DiagnoticIOLoggerDestination7logDataEPKN12LogFormatter8LineInfoEPKcS5_PKhl_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + CFRelease((char *)this - 24) = "CFNetwork";
  *(void *)(a1 + 32) = 24;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void DiagnoticIOLoggerDestination::~DiagnoticIOLoggerDestination(DiagnoticIOLoggerDestination *this)
{
}

uint64_t ___ZN8IOLogger11_initLoggerEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + CFRelease((char *)this - 24) = "CFNetwork";
  *(void *)(a1 + 32) = 85;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void CoreIOLoggerDestination::~CoreIOLoggerDestination(CoreIOLoggerDestination *this)
{
}

uint64_t IOLogger::logBytes(IOLogger *this, const char *a2, unsigned __int8 a3, const unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x80uLL, "%s (%d) | %c", a2, *((_DWORD *)this + 2), a3);
  char v8 = 1;
  uint64_t v9 = a5;
  do
  {
    if (v9 >= 144) {
      uint64_t v10 = 144;
    }
    else {
      uint64_t v10 = v9;
    }
    if (v8) {
      snprintf(v13, 0x100uLL, "%s %s %ld");
    }
    else {
      snprintf(v13, 0x100uLL, "%s %s continuation");
    }
    uint64_t result = (*(uint64_t (**)(void, char *, char *, char *, const unsigned __int8 *, uint64_t))(**((void **)this + 34) + 16))(*((void *)this + 34), (char *)this + 280, v13, __str, a4, v10);
    char v8 = 0;
    a4 += v10;
    BOOL v12 = v9 <= v10;
    v9 -= v10;
  }
  while (!v12);
  return result;
}

void IOLogger::logBytesSent(IOLogger *this, int a2, const unsigned __int8 *a3, uint64_t a4)
{
  if (!a2)
  {
    uint64_t v7 = "RAW-SEND";
    goto LABEL_7;
  }
  if (__CFNIsInDevelopmentEnvironment::onceToken != -1) {
    dispatch_once(&__CFNIsInDevelopmentEnvironment::onceToken, &__block_literal_global_30);
  }
  if (__CFNIsInDevelopmentEnvironment::ok)
  {
    uint64_t v7 = "SSL-SEND";
LABEL_7:
    IOLogger::logBytes(this, v7, 0x3Eu, a3, a4);
  }
}

void IOLogger::logBytesRead(IOLogger *this, int a2, const unsigned __int8 *a3, uint64_t a4)
{
  if (!a2)
  {
    uint64_t v7 = "RAW-READ";
    goto LABEL_7;
  }
  if (__CFNIsInDevelopmentEnvironment::onceToken != -1) {
    dispatch_once(&__CFNIsInDevelopmentEnvironment::onceToken, &__block_literal_global_30);
  }
  if (__CFNIsInDevelopmentEnvironment::ok)
  {
    uint64_t v7 = "SSL-READ";
LABEL_7:
    IOLogger::logBytes(this, v7, 0x3Cu, a3, a4);
  }
}

const char *IOLogger::addrToName(uint64_t a1, char *__str)
{
  int v4 = *(unsigned __int8 *)(a1 + 1);
  if (v4 == 30)
  {
    id v5 = (const void *)(a1 + 8);
  }
  else
  {
    if (v4 != 2) {
      return (const char *)snprintf(__str, 0x400uLL, "[error %d converting]");
    }
    id v5 = (const void *)(a1 + 4);
  }
  int v6 = *(unsigned __int16 *)(a1 + 2);
  uint64_t result = inet_ntop(v4, v5, __str, 0x400u);
  if (!result)
  {
    __error();
    return (const char *)snprintf(__str, 0x400uLL, "[error %d converting]");
  }
  if (v6)
  {
    size_t v8 = strlen(__str);
    return (const char *)snprintf(&__str[v8], 1024 - v8, ":%d");
  }
  return result;
}

void non-virtual thunk to'STube::~STube(STube *this)
{
  uint64_t v2 = (char *)this - 40;
  STube::~STube((STube *)((char *)this - 40));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 4);

  CFAllocatorDeallocate(v3, v2);
}

{
  STube::~STube((STube *)((char *)this - 40));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 32;
  STube::~STube((STube *)((char *)this - 32));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 3);

  CFAllocatorDeallocate(v3, v2);
}

{
  STube::~STube((STube *)((char *)this - 32));
}

{
  char *v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  uint64_t v2 = (char *)this - 24;
  STube::~STube((STube *)((char *)this - 24));
  CFAllocatorRef v3 = (const __CFAllocator *)*((void *)this - 2);

  CFAllocatorDeallocate(v3, v2);
}

{
  STube::~STube((STube *)((char *)this - 24));
}

void STube::~STube(STube *this)
{
  *(void *)this = &unk_1ECFA57E0;
  *((void *)this + 3) = &unk_1ECFA5898;
  uint64_t v2 = (STube *)((char *)this + 32);
  *((void *)this + 4) = &unk_1ECFA58B8;
  *((void *)this + 5) = &unk_1ECFA5960;
  CFAllocatorRef v3 = (const void *)*((void *)this + 28);
  if (v3)
  {
    _Block_release(v3);
    *((void *)this + 28) = 0;
  }
  int v4 = (const void *)*((void *)this + 27);
  if (v4)
  {
    _Block_release(v4);
    *((void *)this + 27) = 0;
  }
  id v5 = (const void *)*((void *)this + 24);
  *((void *)this + CFRelease((char *)this - 24) = 0;
  if (v5) {
    CFRelease(v5);
  }
  int v6 = (const void *)*((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v6) {
    CFRelease(v6);
  }
  char v7 = *((unsigned char *)this + 176);
  uint64_t v8 = *((void *)this + 14);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  v12[2] = ___ZN5STube14cleanupStreamsEb_block_invoke;
  v12[3] = &__block_descriptor_41_e5_v8__0l;
  v12[4] = this;
  char v13 = v7;
  (*(void (**)(uint64_t, void *))(*(void *)v8 + 104))(v8, v12);
  uint64_t v9 = *((void *)this + 15);
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 48))(v9);
    *((void *)this + 15) = 0;
  }
  (*(void (**)(void))(**((void **)this + 13) + 48))(*((void *)this + 13));
  *((void *)this + 13) = 0;
  (*(void (**)(void))(**((void **)this + 12) + 48))(*((void *)this + 12));
  *((void *)this + 12) = 0;
  (*(void (**)(void))(**((void **)this + 14) + 48))(*((void *)this + 14));
  *((void *)this + 14) = 0;
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
  uint64_t v11 = (const void *)*((void *)this + 21);
  *((void *)this + 2HTTPServerConnection::canceled_onQueue(this - 1) = 0;
  if (v11) {
    CFRelease(v11);
  }
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(v2);
  *((void *)this + 3) = &unk_1ECF9B550;
}

{
  uint64_t v2;
  CFAllocatorRef v3;
  uint64_t vars8;

  STube::~STube(this);
  CFAllocatorRef v3 = *(const __CFAllocator **)(v2 + 8);

  CFAllocatorDeallocate(v3, this);
}

void sub_1842E3AEC(_Unwind_Exception *a1)
{
  id v5 = *(std::__shared_weak_count **)(v1 + 208);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  int v6 = *(const void **)(v1 + 168);
  *(void *)(v1 + 168) = 0;
  if (v6) {
    CFRelease(v6);
  }
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(v2);
  *CFAllocatorRef v3 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

void ___ZN5STube14cleanupStreamsEb_block_invoke(uint64_t a1)
{
}

void STube::_onqueue_cleanupStreams(STube *this, int a2)
{
  int v4 = (__CFReadStream *)*((void *)this + 29);
  if (v4)
  {
    if (a2)
    {
      if (CFReadStreamGetStatus(v4) <= kCFStreamStatusOpening) {
        CFReadStreamOpen(*((CFReadStreamRef *)this + 29));
      }
      CFReadStreamClose(*((CFReadStreamRef *)this + 29));
      int v4 = (__CFReadStream *)*((void *)this + 29);
      *((void *)this + 29) = 0;
      if (!v4)
      {
        int v6 = (CFWriteStreamRef *)((char *)this + 240);
        CFWriteStreamRef v5 = (CFWriteStreamRef)*((void *)this + 30);
        if (!v5) {
          goto LABEL_15;
        }
        goto LABEL_12;
      }
    }
    else
    {
      *((void *)this + 29) = 0;
    }
    CFRelease(v4);
  }
  int v6 = (CFWriteStreamRef *)((char *)this + 240);
  CFWriteStreamRef v5 = (CFWriteStreamRef)*((void *)this + 30);
  if (!v5) {
    goto LABEL_19;
  }
  if ((a2 & 1) == 0)
  {
    *int v6 = 0;
LABEL_18:
    CFRelease(v5);
LABEL_19:
    uint64_t v8 = (uint64_t *)((char *)this + 128);
    uint64_t v7 = *((void *)this + 16);
    if (!v7) {
      return;
    }
    if (!a2) {
      goto LABEL_24;
    }
    goto LABEL_21;
  }
LABEL_12:
  if (CFWriteStreamGetStatus(v5) <= kCFStreamStatusOpening) {
    CFWriteStreamOpen(*v6);
  }
  CFWriteStreamClose(*v6);
  CFWriteStreamRef v5 = *v6;
  *int v6 = 0;
  if (v5) {
    goto LABEL_18;
  }
LABEL_15:
  uint64_t v8 = (uint64_t *)((char *)this + 128);
  uint64_t v7 = *((void *)this + 16);
  if (v7)
  {
LABEL_21:
    if (!*((unsigned char *)this + 177))
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 232))(v7);
      uint64_t v7 = *v8;
    }
    (*(void (**)(uint64_t, void))(*(void *)v7 + 176))(v7, 0);
    uint64_t v7 = *v8;
LABEL_24:
    CFRelease((CFTypeRef)(v7 - 16));
    *uint64_t v8 = 0;
  }
}

uint64_t non-virtual thunk to'STube::ssConnectionWaitingNotification(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 - 32;
  uint64_t v3 = *(void *)(a1 + 80);
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZN5STube31ssConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke;
  v5[3] = &__block_descriptor_48_e5_v8__0l;
  v5[4] = v2;
  void v5[5] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v3 + 96))(v3, v5);
}

uint64_t ___ZN5STube31ssConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = *(void *)(v1 + 120);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 96))(result);
    if (result)
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v1 + 120) + 64))(*(void *)(v1 + 120));
      if (result)
      {
        uint64_t v3 = *(uint64_t (**)(void))(*(void *)(result - 176) + 408);
        return v3();
      }
    }
  }
  return result;
}

uint64_t non-virtual thunk to'STube::ssPostHandshakesStreamsAvailable(STube *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return STube::ssPostHandshakesStreamsAvailable((STube *)((char *)this - 32), a2, a3);
}

uint64_t STube::ssPostHandshakesStreamsAvailable(STube *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  (*(void (**)(STube *))(*(void *)this + 40))(this);
  if (a2) {
    CFRetain(a2);
  }
  if (a3) {
    CFRetain(a3);
  }
  uint64_t v6 = *((void *)this + 14);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = ___ZN5STube32ssPostHandshakesStreamsAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke;
  void v8[3] = &__block_descriptor_56_e5_v8__0l;
  v8[4] = this;
  void v8[5] = a2;
  void v8[6] = a3;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v8);
}

uint64_t ___ZN5STube32ssPostHandshakesStreamsAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke(void *a1)
{
  uint64_t v1 = a1[4];
  *(void *)(v1 + 232) = a1[5];
  uint64_t v2 = (__CFWriteStream *)a1[6];
  *(void *)(v1 + 240) = v2;
  *(unsigned char *)(v1 + 177) = 1;
  if (v2 && (Error = CFWriteStreamGetError(v2), uint64_t v4 = *(void *)&Error.error, Error.error))
  {
    CFIndex domain = Error.domain;
    if (Error.domain == *MEMORY[0x1E4F1D430] && *(void *)(v1 + 232))
    {
      uint64_t v6 = *(const void **)(v1 + 168);
      *(void *)(v1 + 168) = 0;
      if (v6) {
        CFRelease(v6);
      }
      v17[0] = MEMORY[0x1E4F143A8];
      v17[1] = 3221225472;
      void v17[2] = ___ZN5STube27_onqueue_saveSSLCertContextEv_block_invoke;
      void v17[3] = &__block_descriptor_40_e22__v16__0____CFString__8l;
      v17[4] = v1;
      createSSLCertificateContext(&v18, (uint64_t)v17);
      uint64_t v7 = *(const void **)(v1 + 168);
      *(void *)(v1 + 168) = v18;
      if (v7) {
        CFRelease(v7);
      }
      if ((Error.error + 9850) <= 0x2B && ((1 << (LOBYTE(Error.error) + 122)) & 0xC7803E80081) != 0)
      {
        CFBooleanRef v8 = (const __CFBoolean *)CFReadStreamCopyProperty(*(CFReadStreamRef *)(v1 + 232), @"kCFStreamPropertyConnectionIsCellular");
        if (v8)
        {
          CFBooleanRef v9 = v8;
          if (!CFBooleanGetValue(v8)) {
            __CFNReportSSLSymptom(Error.domain, Error.error);
          }
          CFRelease(v9);
        }
        else
        {
          __CFNReportSSLSymptom(Error.domain, Error.error);
        }
      }
    }
    uint64_t v10 = (_DWORD *)(v1 + 160);
    if (*(_DWORD *)(v1 + 160) != 9) {
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v10 = (_DWORD *)(v1 + 160);
    if (*(_DWORD *)(v1 + 160) == 9)
    {
      uint64_t v4 = 89;
      CFIndex domain = 1;
      goto LABEL_26;
    }
    uint64_t v11 = *(void *)(v1 + 128);
    if (!v11 || !*(void *)(v1 + 232) || !*(void *)(v1 + 240))
    {
      uint64_t v4 = 57;
      CFIndex domain = 1;
LABEL_25:
      *uint64_t v10 = 10;
      goto LABEL_26;
    }
    *(_DWORD *)(v1 + 160) = 8;
    if (*(_DWORD *)(v1 + 136))
    {
      CFIndex domain = 0;
      uint64_t v4 = 0;
    }
    else
    {
      CFStringRef v14 = (const __CFString *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v11 + 224))(v11, 0x1EC09F910);
      if (v14)
      {
        CFStringRef v15 = v14;
        if (CFStringGetLength(v14))
        {
          if (CFStringCompare(v15, @"http/1.1", 1uLL) && CFStringCompare(v15, @"http/1.0", 1uLL))
          {
            CFIndex domain = 0;
            uint64_t v4 = 0;
          }
          else
          {
            CFIndex domain = 0;
            uint64_t v4 = 0;
            *(_DWORD *)(v1 + CFRetain((char *)this - 136) = 1;
          }
        }
        else
        {
          uint64_t v4 = 100;
          CFIndex domain = 1;
        }
        CFRelease(v15);
      }
      else
      {
        CFIndex domain = 1;
        if (*(void *)(*(void *)(v1 + 96) + 72)) {
          BOOL v16 = (*(void *)(*(void *)(v1 + 96) + 72) & 1) == 0;
        }
        else {
          BOOL v16 = 0;
        }
        if (v16)
        {
          uint64_t v4 = 100;
        }
        else
        {
          uint64_t v4 = 0;
          *(_DWORD *)(v1 + CFRetain((char *)this - 136) = 1;
          CFIndex domain = 0;
        }
      }
    }
  }
LABEL_26:
  v20.CFIndex domain = domain;
  *(void *)&v20.CFErrorRef error = v4;
  STube::_onqueue_notifyTubeManager((STube *)v1, v20);
  BOOL v12 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v12(v1);
}

void STube::_onqueue_notifyTubeManager(STube *this, CFStreamError a2)
{
  CFStreamError valuePtr = a2;
  uint64_t v3 = (CoreSchedulingSet *)*((void *)this + 14);
  if (!v3) {
    __assert_rtn("_onqueue_notifyTubeManager", "STube.cpp", 1069, "fSchedulingSet");
  }
  SInt32 error = a2.error;
  if (!CoreSchedulingSet::currentlyInContext(v3)) {
    __assert_rtn("_onqueue_notifyTubeManager", "STube.cpp", 1070, "fSchedulingSet->currentlyInContext()");
  }
  if (!*((unsigned char *)this + 164))
  {
    *((unsigned char *)this + 1++*(void *)(this + 64) = 1;
    if (nw_settings_get_signposts_enabled()) {
      kdebug_trace();
    }
    uint64_t v5 = *((void *)this + 16);
    if (v5) {
      (*(void (**)(uint64_t, void))(*(void *)v5 + 176))(v5, 0);
    }
    uint64_t v6 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (error) {
      CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (int *)&valuePtr);
    }
    else {
      CFErrorWithStreamCFStreamError Error = 0;
    }
    if (GlueTube::notifyOfTubeType)
    {
      CFBooleanRef v8 = @"Unknown";
      int v9 = *((_DWORD *)this + 34);
      if (v9 == 1) {
        CFBooleanRef v8 = @"kSTubeTypeHTTP";
      }
      if (v9) {
        uint64_t v10 = v8;
      }
      else {
        uint64_t v10 = @"kSTubeTypeNPN";
      }
      uint64_t v11 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 12) + 16))(*((void *)this + 12));
      uint64_t v12 = *((void *)this + 16);
      if (v12) {
        char v13 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 224))(v12, 0x1EC09F910);
      }
      else {
        char v13 = 0;
      }
      CFStringRef v14 = @"YES";
      if (!v13) {
        CFStringRef v14 = @"NO";
      }
      CFStringRef v15 = CFStringCreateWithFormat(*v6, 0, @"%@, ALPN supported %@, Tube type: %@", v11, v14, v10);
      (*(void (**)(uint64_t, CFStringRef, CFErrorRef))(GlueTube::notifyOfTubeType + 16))(GlueTube::notifyOfTubeType, v15, CFErrorWithStreamError);
      if (v15) {
        CFRelease(v15);
      }
      if (v13) {
        CFRelease(v13);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
    (*(void (**)(void, STube *, CFIndex, void))(**((void **)this + 13) + 56))(*((void *)this + 13), this, valuePtr.domain, *(void *)&valuePtr.error);
    if (CFErrorWithStreamError) {
      CFRelease(CFErrorWithStreamError);
    }
  }
}

void sub_1842E4460(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    CFRelease(v2);
    if (!v1) {
LABEL_4:
    }
      _Unwind_Resume(exception_object);
  }
  else if (!v1)
  {
    goto LABEL_4;
  }
  CFRelease(v1);
  goto LABEL_4;
}

void sub_1842E44C4()
{
  if (!v0) {
    JUMPOUT(0x1842E4488);
  }
  JUMPOUT(0x1842E4480);
}

CFTypeRef ___ZN5STube27_onqueue_saveSSLCertContextEv_block_invoke(uint64_t a1, const __CFString *a2)
{
  return CFReadStreamCopyProperty(*(CFReadStreamRef *)(*(void *)(a1 + 32) + 232), a2);
}

uint64_t non-virtual thunk to'STube::ssPostConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return STube::ssPostConnectConfiguration((void *)(a1 - 32), a2, a3);
}

uint64_t STube::ssPostConnectConfiguration(void *a1, uint64_t a2, uint64_t a3)
{
  tcp_connection_retain();
  (*(void (**)(void *))(*a1 + 40))(a1);
  uint64_t v6 = a1[14];
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = ___ZN5STube26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
  void v8[3] = &unk_1E5257DA8;
  void v8[5] = a3;
  void v8[6] = a1;
  v8[4] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v8);
}

uint64_t ___ZN5STube26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v1 = a1[6];
  if (*(_DWORD *)(v1 + 160) == 9)
  {
    (*(void (**)(void, void, void, uint64_t))(v2 + 16))(a1[5], 0, 0, 1);
  }
  else
  {
    uint64_t v3 = a1[4];
    *(_DWORD *)(v1 + 160) = 5;
    uint64_t v4 = (__CFHTTPMessage *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 128) + 224))(*(void *)(v1 + 128), 0x1EC0A5720);
    if (v4)
    {
      uint64_t v5 = v4;
      BOOL v6 = CFHTTPMessageGetResponseStatusCode(v4) != 200;
      (*(void (**)(uint64_t, void, void, BOOL))(v2 + 16))(v2, 0, 0, v6);
      CFRelease(v5);
    }
    else
    {
      (*(void (**)(uint64_t))(*(void *)v1 + 40))(v1);
      uint64_t v7 = *(void *)(v1 + 8);
      uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(v1 + 120) + 72))(*(void *)(v1 + 120));
      void v13[5] = v1;
      uint64_t v9 = *(void *)(v1 + 32);
      uint64_t v10 = *(void *)(v1 + 96);
      v13[0] = MEMORY[0x1E4F143A8];
      v13[1] = 3221225472;
      void v13[2] = ___ZN5STube33_onqueue_postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
      v13[3] = &unk_1E5257DD0;
      v13[4] = v2;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void *))(v9 + 144))(v1 + 32, v7, v3, v8 - 16, v10, v13);
    }
  }
  tcp_connection_release();
  uint64_t v11 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v11(v1);
}

void ___ZN5STube33_onqueue_postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke(uint64_t a1, void *a2, CFTypeRef cf)
{
  uint64_t v6 = *(void *)(a1 + 40);
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v7 = *(void *)(v6 + 112);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3321888768;
  void v9[2] = ___ZN5STube33_onqueue_postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke_2;
  void v9[3] = &unk_1ECFAA048;
  v9[4] = *(void *)(a1 + 32);
  void v9[5] = v6;
  uint64_t v8 = (std::__shared_weak_count *)a2[1];
  void v9[6] = *a2;
  uint64_t v10 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CFTypeRef v11 = cf;
  (*(void (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, v9);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v10);
  }
}

void sub_1842E48A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN5STube33_onqueue_postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke_2(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(int *)(v2 + 160) < 9)
  {
    uint64_t v4 = a1[6];
    uint64_t v5 = a1[7];
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v6 = *(std::__shared_weak_count **)(v2 + 208);
    *(void *)(v2 + 200) = v4;
    *(void *)(v2 + 208) = v5;
    if (v6)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
      uint64_t v4 = *(void *)(v2 + 200);
    }
    if (v4)
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v4 + 56))(v4) == 3)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(v2 + 8), 0, MEMORY[0x1E4F1D510]);
        if (Mutable)
        {
          uint64_t v8 = Mutable;
          CFStringRef v9 = CFStringCreateWithCString(*(CFAllocatorRef *)(v2 + 8), "http/1.1", 0x8000100u);
          CFArrayAppendValue(v8, v9);
          CFRelease(v9);
          CFStringRef v10 = CFStringCreateWithCString(*(CFAllocatorRef *)(v2 + 8), "http/1.0", 0x8000100u);
          CFArrayAppendValue(v8, v10);
          CFRelease(v10);
          (*(void (**)(void, uint64_t, __CFArray *))(**(void **)(v2 + 128) + 200))(*(void *)(v2 + 128), 0x1EC09F8D8, v8);
          CFRelease(v8);
        }
      }
    }
    uint64_t v3 = *(void (**)(void))(a1[4] + 16);
  }
  else
  {
    uint64_t v3 = *(void (**)(void))(a1[4] + 16);
  }
  v3();
  CFTypeRef v11 = (const void *)a1[8];
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 48);

  return v12(v2);
}

void __destroy_helper_block_e8_48c40_ZTSNSt3__110shared_ptrI12NetworkProxyEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

uint64_t __copy_helper_block_e8_48c40_ZTSNSt3__110shared_ptrI12NetworkProxyEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t non-virtual thunk to'STube::ssNeedClientCert(uint64_t a1, const void *a2, void *a3)
{
  return STube::ssNeedClientCert((void *)(a1 - 32), a2, a3);
}

uint64_t STube::ssNeedClientCert(void *a1, CFTypeRef cf, void *aBlock)
{
  if (a1[23]) {
    __assert_rtn("ssNeedClientCert", "STube.cpp", 1245, "!fSSLDistNames");
  }
  a1[23] = cf;
  if (cf) {
    CFRetain(cf);
  }
  a1[27] = _Block_copy(aBlock);
  (*(void (**)(void *))(*a1 + 40))(a1);
  uint64_t v5 = a1[14];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = ___ZN5STube16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke;
  v7[3] = &__block_descriptor_40_e5_v8__0l;
  v7[4] = a1;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v5 + 96))(v5, v7);
}

uint64_t ___ZN5STube16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(int *)(v1 + 160) < 9)
  {
    *(_DWORD *)(v1 + 160) = 7;
    uint64_t v2 = *(void *)(v1 + 120);
    if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 96))(v2))
    {
      uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(v1 + 120) + 64))(*(void *)(v1 + 120));
      if (v3) {
        uint64_t v4 = v3 - 176;
      }
      else {
        uint64_t v4 = 0;
      }
      if (v3) {
        uint64_t v5 = v4 + 112;
      }
      else {
        uint64_t v5 = 0;
      }
      (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      (*(void (**)(uint64_t))(*(void *)v1 + 40))(v1);
      (*(void (**)(uint64_t))(*(void *)v1 + 40))(v1);
      uint64_t v6 = *(void *)(v4 + 24);
      uint64_t v9 = MEMORY[0x1E4F143A8];
      uint64_t v10 = 3221225472;
      CFTypeRef v11 = ___ZN5STube23_onqueue_needClientCertEv_block_invoke;
      uint64_t v12 = &__block_descriptor_48_e5_v8__0l;
      uint64_t v13 = v1;
      uint64_t v14 = v5;
    }
    else
    {
      (*(void (**)(uint64_t))(*(void *)v1 + 40))(v1);
      uint64_t v6 = *(void *)(v1 + 112);
      uint64_t v9 = MEMORY[0x1E4F143A8];
      uint64_t v10 = 3221225472;
      CFTypeRef v11 = ___ZN5STube23_onqueue_needClientCertEv_block_invoke_3;
      uint64_t v12 = &__block_descriptor_40_e5_v8__0l;
      uint64_t v13 = v1;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 96))(v6, &v9);
  }
  else
  {
    STube::_onqueue_complete_needClientCert(*(STube **)(a1 + 32), 0);
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v7(v1);
}

void STube::_onqueue_complete_needClientCert(STube *this, const __CFArray *a2)
{
  uint64_t v3 = *((void *)this + 27);
  if (v3) {
    (*(void (**)(uint64_t, const __CFArray *))(v3 + 16))(v3, a2);
  }
  uint64_t v4 = (const void *)*((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 27);
  if (v5)
  {
    _Block_release(v5);
    *((void *)this + 27) = 0;
  }
}

uint64_t ___ZN5STube23_onqueue_needClientCertEv_block_invoke(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v4 = v3[23];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN5STube23_onqueue_needClientCertEv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e20_v16__0____CFArray__8l;
  void v6[4] = v3;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v2 + 48))(v2, v4, v6);
  (*(void (**)(void))(**(void **)(a1 + 40) + 24))(*(void *)(a1 + 40));
  return (*(uint64_t (**)(void *))(*v3 + 48))(v3);
}

uint64_t ___ZN5STube23_onqueue_needClientCertEv_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  STube::_onqueue_cancel(v1);
  uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v2(v1);
}

uint64_t STube::_onqueue_cancel(uint64_t this)
{
  if (*(_DWORD *)(this + 160) != 9)
  {
    uint64_t v1 = (STube *)this;
    *(_DWORD *)(this + 160) = 9;
    if (*(void *)(this + 224)) {
      STube::_onqueue_complete_needServerTrust(this);
    }
    if (*((void *)v1 + 27)) {
      STube::_onqueue_complete_needClientCert(v1, 0);
    }
    STube::_onqueue_cleanupStreams(v1, 1);
    (*(void (**)(STube *))(*(void *)v1 + 40))(v1);
    uint64_t v2 = *((void *)v1 + 14);
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZN5STube15_onqueue_cancelEv_block_invoke;
    v3[3] = &__block_descriptor_40_e5_v8__0l;
    void v3[4] = v1;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 96))(v2, v3);
  }
  return this;
}

void STube::_onqueue_complete_needServerTrust(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 224);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  uint64_t v3 = *(const void **)(a1 + 192);
  *(void *)(a1 + 192) = 0;
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 224);
  if (v4)
  {
    _Block_release(v4);
    *(void *)(a1 + 2CFRelease((char *)this - 24) = 0;
  }
}

uint64_t ___ZN5STube15_onqueue_cancelEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(STube **)(a1 + 32);
  v5.CFIndex domain = 1;
  *(void *)&v5.SInt32 error = 89;
  STube::_onqueue_notifyTubeManager(v1, v5);
  uint64_t v2 = *(uint64_t (**)(STube *))(*(void *)v1 + 48);

  return v2(v1);
}

uint64_t ___ZN5STube23_onqueue_needClientCertEv_block_invoke_2(uint64_t a1, const void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  (*(void (**)(void *))(*v3 + 40))(v3);
  if (a2) {
    CFRetain(a2);
  }
  uint64_t v4 = v3[14];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = ___ZN5STube24_complete_needClientCertEPK9__CFArray_block_invoke;
  v7[3] = &__block_descriptor_48_e5_v8__0l;
  v7[4] = v3;
  void v7[5] = a2;
  (*(void (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, v7);
  CFStreamError v5 = *(uint64_t (**)(void *))(*v3 + 48);

  return v5(v3);
}

uint64_t ___ZN5STube24_complete_needClientCertEPK9__CFArray_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(STube **)(a1 + 32);
  STube::_onqueue_complete_needClientCert(v2, *(const __CFArray **)(a1 + 40));
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(uint64_t (**)(STube *))(*(void *)v2 + 48);

  return v4(v2);
}

uint64_t non-virtual thunk to'STube::ssNeedServerTrust(uint64_t a1, const void *a2, void *a3)
{
  return STube::ssNeedServerTrust((void *)(a1 - 32), a2, a3);
}

uint64_t STube::ssNeedServerTrust(void *a1, CFTypeRef cf, void *aBlock)
{
  if (a1[24]) {
    __assert_rtn("ssNeedServerTrust", "STube.cpp", 1358, "!fSSLTrust");
  }
  a1[24] = cf;
  if (cf) {
    CFRetain(cf);
  }
  a1[28] = _Block_copy(aBlock);
  (*(void (**)(void *))(*a1 + 40))(a1);
  uint64_t v5 = a1[14];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = ___ZN5STube17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke;
  v7[3] = &__block_descriptor_40_e5_v8__0l;
  v7[4] = a1;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v5 + 96))(v5, v7);
}

uint64_t ___ZN5STube17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(int *)(v1 + 160) < 9)
  {
    *(_DWORD *)(v1 + 160) = 6;
    uint64_t v2 = *(void *)(v1 + 120);
    if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 96))(v2))
    {
      uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(v1 + 120) + 64))(*(void *)(v1 + 120));
      if (v3) {
        uint64_t v4 = v3 - 176;
      }
      else {
        uint64_t v4 = 0;
      }
      if (v3) {
        uint64_t v5 = v4 + 112;
      }
      else {
        uint64_t v5 = 0;
      }
      (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
      (*(void (**)(uint64_t))(*(void *)v1 + 40))(v1);
      (*(void (**)(uint64_t))(*(void *)v1 + 40))(v1);
      uint64_t v6 = *(void *)(v4 + 24);
      uint64_t v9 = MEMORY[0x1E4F143A8];
      uint64_t v10 = 3221225472;
      CFTypeRef v11 = ___ZN5STube24_onqueue_needServerTrustEv_block_invoke;
      uint64_t v12 = &__block_descriptor_48_e5_v8__0l;
      uint64_t v13 = v1;
      uint64_t v14 = v5;
    }
    else
    {
      (*(void (**)(uint64_t))(*(void *)v1 + 40))(v1);
      uint64_t v6 = *(void *)(v1 + 112);
      uint64_t v9 = MEMORY[0x1E4F143A8];
      uint64_t v10 = 3221225472;
      CFTypeRef v11 = ___ZN5STube24_onqueue_needServerTrustEv_block_invoke_3;
      uint64_t v12 = &__block_descriptor_40_e5_v8__0l;
      uint64_t v13 = v1;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 96))(v6, &v9);
  }
  else
  {
    STube::_onqueue_complete_needServerTrust(*(void *)(a1 + 32));
  }
  uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v7(v1);
}

uint64_t ___ZN5STube24_onqueue_needServerTrustEv_block_invoke(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v4 = v3[24];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN5STube24_onqueue_needServerTrustEv_block_invoke_2;
  v6[3] = &__block_descriptor_40_e8_v12__0i8l;
  void v6[4] = v3;
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v2 + 40))(v2, v4, v6);
  (*(void (**)(void))(**(void **)(a1 + 40) + 24))(*(void *)(a1 + 40));
  return (*(uint64_t (**)(void *))(*v3 + 48))(v3);
}

uint64_t ___ZN5STube24_onqueue_needServerTrustEv_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  STube::_onqueue_cancel(v1);
  uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v2(v1);
}

uint64_t ___ZN5STube24_onqueue_needServerTrustEv_block_invoke_2(uint64_t a1, int a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  (*(void (**)(void *))(*v3 + 40))(v3);
  uint64_t v4 = v3[14];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = ___ZN5STube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicy_block_invoke;
  v7[3] = &__block_descriptor_44_e5_v8__0l;
  v7[4] = v3;
  int v8 = a2;
  (*(void (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, v7);
  uint64_t v5 = *(uint64_t (**)(void *))(*v3 + 48);

  return v5(v3);
}

uint64_t ___ZN5STube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicy_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  STube::_onqueue_complete_needServerTrust(v1);
  uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)v1 + 48);

  return v2(v1);
}

uint64_t non-virtual thunk to'STube::ssPreConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return STube::ssPreConnectConfiguration((void *)(a1 - 32), a2, a3);
}

uint64_t STube::ssPreConnectConfiguration(void *a1, uint64_t a2, uint64_t a3)
{
  tcp_connection_retain();
  (*(void (**)(void *))(*a1 + 40))(a1);
  uint64_t v6 = a1[14];
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = ___ZN5STube25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke;
  void v8[3] = &unk_1E5257DA8;
  void v8[5] = a3;
  void v8[6] = a1;
  v8[4] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, v8);
}

uint64_t ___ZN5STube25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke(void *a1)
{
  uint64_t v2 = a1[6];
  if (*(int *)(v2 + 160) <= 3)
  {
    *(_DWORD *)(v2 + 160) = 4;
    uint64_t v3 = *(void *)(v2 + 120);
    if (v3)
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 96))(v3))
      {
        uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(v2 + 120) + 64))(*(void *)(v2 + 120));
        if (v4)
        {
          uint64_t v5 = v4;
          uint64_t v6 = tcp_connection_id();
          (*(void (**)(uint64_t, uint64_t, void, void, uint64_t, void))(*(void *)(v2 + 32) + 128))(v2 + 32, v6, a1[4], 0, [*(id *)(v5 - 88) cfURL], *(void *)(v5 + 432));
        }
      }
    }
  }
  (*(void (**)(void))(a1[5] + 16))();
  tcp_connection_release();
  uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 48);

  return v7(v2);
}

uint64_t non-virtual thunk to'STube::ceRelease(STube *this)
{
  return (*(uint64_t (**)(void))(*((void *)this - 4) + 48))();
}

uint64_t non-virtual thunk to'STube::ceRetain(STube *this)
{
  return (*(uint64_t (**)(void))(*((void *)this - 4) + 40))();
}

uint64_t STube::ssConnectionWaitingNotification(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 112);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN5STube31ssConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke;
  v4[3] = &__block_descriptor_48_e5_v8__0l;
  v4[4] = a1;
  void v4[5] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 96))(v2, v4);
}

uint64_t STube::ceRelease(STube *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 48))();
}

uint64_t STube::ceRetain(STube *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

uint64_t GlueTube::isCoalesced(GlueTube *this)
{
  return 0;
}

uint64_t STube::clientCanceled(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 112);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN5STube14clientCanceledEP25MetaConnectionCacheClient_block_invoke;
  v4[3] = &__block_descriptor_48_e5_v8__0l;
  v4[4] = a1;
  void v4[5] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 104))(v2, v4);
}

uint64_t ___ZN5STube14clientCanceledEP25MetaConnectionCacheClient_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t result = *(void *)(v2 + 120);
  if (result)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 64))(result);
    if (result == v4)
    {
      return STube::_onqueue_cancel(v2);
    }
  }
  return result;
}

uint64_t GlueTube::copyConnectionProperty(GlueTube *this, const __CFString *a2)
{
  return 0;
}

BOOL STube::setConnectionProperty(STube *this, const __CFString *a2, const void *a3)
{
  uint64_t v3 = *((void *)this + 16);
  if (v3) {
    (*(void (**)(void, const __CFString *, const void *))(*(void *)v3 + 200))(*((void *)this + 16), a2, a3);
  }
  return v3 != 0;
}

uint64_t STube::STube(uint64_t a1, const __CFAllocator *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFAllocatedReferenceCountedObject::CFAllocatedReferenceCountedObject((CFAllocatedReferenceCountedObject *)a1, a2);
  *(_OWORD *)(v9 + 76) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + ++*(void *)(this + 64) = 0u;
  *(void *)uint64_t v9 = &unk_1ECFA57E0;
  *(void *)(v9 + CFRelease((char *)this - 24) = &unk_1ECFA5898;
  *(void *)(v9 + 32) = &unk_1ECFA58B8;
  *(void *)(v9 + 40) = &unk_1ECFA5960;
  *(void *)(v9 + 168) = 0;
  *(void *)(v9 + 200) = 0;
  *(void *)(v9 + 208) = 0;
  if (!a3)
  {
    uint64_t v13 = "key";
    int v14 = 38;
    goto LABEL_12;
  }
  *(void *)(a1 + 96) = a3;
  (*(void (**)(uint64_t))(*(void *)a3 + 40))(a3);
  if (!a4)
  {
    uint64_t v13 = "manager";
    int v14 = 42;
    goto LABEL_12;
  }
  *(void *)(a1 + 104) = a4;
  (*(void (**)(uint64_t))(*(void *)a4 + 40))(a4);
  if (!a5)
  {
    uint64_t v13 = "schedulingSet";
    int v14 = 46;
LABEL_12:
    __assert_rtn("STube", "STube.cpp", v14, v13);
  }
  *(void *)(a1 + 112) = a5;
  (*(void (**)(uint64_t))(*(void *)a5 + 40))(a5);
  *(unsigned char *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 160) = 0;
  *(unsigned char *)(a1 + 1++*(void *)(this + 64) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 133) = 0;
  uint64_t v10 = *(const void **)(a1 + 168);
  *(void *)(a1 + 168) = 0;
  if (v10) {
    CFRelease(v10);
  }
  *(_WORD *)(a1 + 176) = 1;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  CFTypeRef v11 = *(std::__shared_weak_count **)(a1 + 208);
  *(void *)(a1 + 2CFRetain((char *)this - 16) = 0;
  *(void *)(a1 + 2CFRelease((char *)this - 24) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  return a1;
}

void sub_1842E60C4(_Unwind_Exception *a1)
{
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 208);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  uint64_t v6 = *(const void **)(v1 + 168);
  *(void *)(v1 + 168) = 0;
  if (v6) {
    CFRelease(v6);
  }
  ProxyConnectionEstablishment::~ProxyConnectionEstablishment(v2);
  *uint64_t v3 = &unk_1ECF9B550;
  _Unwind_Resume(a1);
}

uint64_t STube::initialize(STube *this, SBaseAwaitingTube *a2)
{
  if (nw_settings_get_signposts_enabled()) {
    kdebug_trace();
  }
  if (!a2) {
    __assert_rtn("initialize", "STube.cpp", 124, "waiter");
  }
  if ((*(unsigned int (**)(SBaseAwaitingTube *))(*(void *)a2 + 112))(a2)) {
    __assert_rtn("initialize", "STube.cpp", 125, "!waiter->hasBeenClaimed()");
  }
  *((void *)this + 15) = a2;
  (*(void (**)(SBaseAwaitingTube *))(*(void *)a2 + 40))(a2);
  (*(void (**)(void))(**((void **)this + 15) + 104))(*((void *)this + 15));
  if (*((_DWORD *)this + 40) != 9) {
    *((_DWORD *)this + 40) = 1;
  }
  (*(void (**)(STube *))(*(void *)this + 40))(this);
  uint64_t v4 = *((void *)this + 14);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN5STube10initializeEP17SBaseAwaitingTube_block_invoke;
  v6[3] = &__block_descriptor_40_e5_v8__0l;
  void v6[4] = this;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, v6);
}

uint64_t ___ZN5STube10initializeEP17SBaseAwaitingTube_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZN5STube10initializeEP17SBaseAwaitingTube_block_invoke_2;
  v3[3] = &__block_descriptor_40_e13_v24__0___qi_8l;
  void v3[4] = v1;
  if (*(void *)(v1 + 128)) {
    __assert_rtn("connect", "STube.cpp", 420, "fSocketStream == NULL");
  }
  if (*(_DWORD *)(v1 + 160) != 9) {
    *(_DWORD *)(v1 + 160) = 2;
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN5STube7connectEU13block_pointerFv13CFStreamErrorE_block_invoke;
  v4[3] = &unk_1E5257C58;
  v4[4] = v3;
  void v4[5] = v1;
  ___ZN5STube7connectEU13block_pointerFv13CFStreamErrorE_block_invoke((uint64_t)v4);
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 48))(v1);
}

void ___ZN5STube10initializeEP17SBaseAwaitingTube_block_invoke_2(uint64_t a1, CFStreamError a2)
{
  if (a2.error)
  {
    uint64_t v2 = *(STube **)(a1 + 32);
    if (*((_DWORD *)v2 + 40) != 9)
    {
      *((_DWORD *)v2 + 40) = 10;
      STube::_onqueue_notifyTubeManager(v2, a2);
    }
  }
}

void ___ZN5STube7connectEU13block_pointerFv13CFStreamErrorE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (TCFObject<SocketStream>::Class(void)::sOnce != -1) {
    dispatch_once(&TCFObject<SocketStream>::Class(void)::sOnce, &__block_literal_global_20895);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v5 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B8uLL);
  }
  else
  {
    uint64_t v5 = 0;
  }
  SocketStream::SocketStream(v5, v4);
  *(void *)(v2 + 128) = v5;
  int v6 = (*(uint64_t (**)(void))(*(void *)v5 + 56))();
  uint64_t v7 = *(void *)(v2 + 128);
  if (!v6)
  {
    CFRelease((CFTypeRef)(v7 - 16));
    *(void *)(v2 + 128) = 0;
    goto LABEL_12;
  }
  if (!v7)
  {
LABEL_12:
    STube::_onqueue_cleanupStreams((STube *)v2, 1);
    uint64_t v9 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    v9();
    return;
  }
  if ((*(unsigned int (**)(void))(**(void **)(v2 + 96) + 88))(*(void *)(v2 + 96)) == 1
    || (*(unsigned int (**)(void))(**(void **)(v2 + 96) + 88))(*(void *)(v2 + 96)) == 3)
  {
    BOOL v8 = 1;
    *(unsigned char *)(v2 + 140) = 1;
  }
  else
  {
    BOOL v8 = *(unsigned char *)(v2 + 140) != 0;
  }
  uint64_t v10 = *(void **)(v2 + 96);
  uint64_t v13 = *v10;
  CFTypeRef v11 = v10 + 9;
  uint64_t v12 = v13;
  if (*(unsigned char *)(v2 + 144)) {
    int v14 = (unint64_t *)(v2 + 152);
  }
  else {
    int v14 = v11;
  }
  unint64_t v15 = *v14;
  (*(void (**)(void))(v12 + 64))();
  if (!v8)
  {
    if (v15 > 1) {
      goto LABEL_12;
    }
LABEL_26:
    *(_DWORD *)(v2 + CFRetain((char *)this - 136) = 1;
    goto LABEL_27;
  }
  if (v15 == 1) {
    goto LABEL_26;
  }
  *(_DWORD *)(v2 + CFRetain((char *)this - 136) = 0;
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (!v15)
  {
    CFStringRef v24 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ",", 0x8000100u);
    CFStringRef v25 = CFStringCreateWithCString(v16, "http/1.1", 0x8000100u);
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v16, v25, v24);
    CFRelease(v25);
    CFRelease(v24);
    goto LABEL_31;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFArrayRef ArrayBySeparatingStrings = Mutable;
  if ((v15 & 1) == 0 || !Mutable)
  {
LABEL_31:
    if (ArrayBySeparatingStrings) {
      goto LABEL_32;
    }
    goto LABEL_12;
  }
  CFStringRef v19 = CFStringCreateWithCString(v16, "http/1.1", 0x8000100u);
  CFArrayAppendValue(ArrayBySeparatingStrings, v19);
  CFRelease(v19);
LABEL_32:
  if (!ArrayBySeparatingStrings || *(_DWORD *)(v2 + 136))
  {
    CFRelease(ArrayBySeparatingStrings);
  }
  else
  {
    int v26 = (*(uint64_t (**)(void, uint64_t, __CFArray *))(**(void **)(v2 + 128) + 200))(*(void *)(v2 + 128), 0x1EC09F8D8, ArrayBySeparatingStrings);
    CFRelease(ArrayBySeparatingStrings);
    if (!v26) {
      goto LABEL_12;
    }
  }
LABEL_27:
  v27[0] = MEMORY[0x1E4F143A8];
  v27[1] = 3221225472;
  v27[2] = ___ZN5STube7connectEU13block_pointerFv13CFStreamErrorE_block_invoke_2;
  v27[3] = &unk_1E5257C58;
  uint64_t v20 = *(void *)(a1 + 32);
  v27[4] = v20;
  v27[5] = v2;
  uint64_t v34 = 0;
  CFSetRef v35 = &v34;
  uint64_t v36 = 0x2020000000;
  CFMutableDictionaryRef v37 = 0;
  CFMutableDictionaryRef v37 = CFDictionaryCreateMutable(*(CFAllocatorRef *)(v2 + 8), 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue((CFMutableDictionaryRef)v35[3], &unk_1EC0A0390, (const void *)*MEMORY[0x1E4F1CFD0]);
  if ((*(uint64_t (**)(void))(**(void **)(v2 + 96) + 64))(*(void *)(v2 + 96)))
  {
    CFDictionaryRef v21 = (const __CFDictionary *)(*(uint64_t (**)(void))(**(void **)(v2 + 96) + 64))(*(void *)(v2 + 96));
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke;
    context[3] = &unk_1E5257C80;
    context[4] = &v34;
    CFDictionaryApplyFunction(v21, (CFDictionaryApplierFunction)_apply_block, context);
  }
  v31[0] = 0;
  v31[1] = v31;
  v31[2] = 0x2020000000;
  char v32 = 1;
  v30[0] = 0;
  v30[1] = v30;
  v30[2] = 0x2020000000;
  v30[3] = 0;
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_2;
  v29[3] = &unk_1E5257CD0;
  v29[6] = v30;
  v29[7] = &v34;
  v29[8] = v31;
  v29[9] = v2;
  v29[4] = v20;
  v29[5] = v27;
  uint64_t v22 = (*(uint64_t (**)(void))(**(void **)(v2 + 120) + 64))(*(void *)(v2 + 120));
  (*(void (**)(uint64_t))(*(void *)v22 + 16))(v22);
  (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  uint64_t v23 = *(void *)(v22 - 152);
  v28[0] = MEMORY[0x1E4F143A8];
  v28[1] = 3221225472;
  void v28[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_15;
  v28[3] = &unk_1E5257D20;
  v28[7] = v2;
  v28[8] = v22;
  void v28[5] = v31;
  v28[6] = v30;
  v28[4] = v29;
  (*(void (**)(uint64_t, void *))(*(void *)v23 + 96))(v23, v28);
  _Block_object_dispose(v30, 8);
  _Block_object_dispose(v31, 8);
  _Block_object_dispose(&v34, 8);
}

void sub_1842E6A8C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube7connectEU13block_pointerFv13CFStreamErrorE_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v2 + 160) != 9) {
    *(_DWORD *)(v2 + 160) = 3;
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(v2 + 128) + 192))(*(void *)(v2 + 128));
  if (!result)
  {
    STube::_onqueue_cleanupStreams((STube *)v2, 1);
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
    return v4();
  }
  return result;
}

void ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
}

void ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_2(void *a1)
{
  uint64_t v2 = a1[9];
  if (*(_DWORD *)(v2 + 160) != 9)
  {
    if (*(unsigned char *)(*(void *)(a1[8] + 8) + 24))
    {
      values = 0;
      p_values = &values;
      uint64_t v37 = 0x2020000000;
      BOOL v38 = 0;
      BOOL v7 = (*(unsigned int (**)(void))(**(void **)(v2 + 96) + 88))(*(void *)(v2 + 96)) == 1
        || (*(unsigned int (**)(void))(**(void **)(v2 + 96) + 88))(*(void *)(v2 + 96)) == 3;
      BOOL v38 = v7;
      CFDictionaryRef v8 = *(const __CFDictionary **)(*(void *)(a1[6] + 8) + 24);
      if (v8)
      {
        context[0] = MEMORY[0x1E4F143A8];
        context[1] = 3221225472;
        context[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_3;
        context[3] = &unk_1E5257CA8;
        uint64_t v9 = a1[7];
        context[4] = &values;
        void context[5] = v9;
        CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)_apply_block, context);
        uint64_t v10 = *(void *)(a1[6] + 8);
        CFTypeRef v11 = *(const void **)(v10 + 24);
        *(void *)(v10 + CFRelease((char *)this - 24) = 0;
        if (v11) {
          CFRelease(v11);
        }
      }
      if (*((unsigned char *)p_values + 24)) {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[7] + 8) + 24), &unk_1EC0A10B0, &unk_1EC0A13C0);
      }
      _Block_object_dispose(&values, 8);
      if (*(unsigned char *)(*(void *)(a1[8] + 8) + 24)) {
        (*(void (**)(void, void))(**(void **)(v2 + 128) + 208))(*(void *)(v2 + 128), *(void *)(*(void *)(a1[7] + 8) + 24));
      }
    }
    uint64_t v12 = *(void *)(a1[7] + 8);
    uint64_t v13 = *(const void **)(v12 + 24);
    *(void *)(v12 + CFRelease((char *)this - 24) = 0;
    if (v13) {
      CFRelease(v13);
    }
    if (!*(unsigned char *)(*(void *)(a1[8] + 8) + 24)
      || (*(unsigned int (**)(void))(**(void **)(v2 + 96) + 88))(*(void *)(v2 + 96)) != 3)
    {
      goto LABEL_57;
    }
    uint64_t v14 = *(void *)(v2 + 120);
    if (!v14 || !(*(uint64_t (**)(uint64_t))(*(void *)v14 + 72))(v14))
    {
LABEL_56:
      *(unsigned char *)(*(void *)(a1[8] + 8) + CFRelease((char *)this - 24) = 0;
LABEL_57:
      if (*(unsigned char *)(*(void *)(a1[8] + 8) + 24)
        && ((*(void (**)(void, uint64_t))(**(void **)(v2 + 128) + 176))(*(void *)(v2 + 128), v2 + 32),
            *(unsigned char *)(*(void *)(a1[8] + 8) + 24)))
      {
        (*(void (**)(void))(a1[5] + 16))();
      }
      else
      {
        STube::_onqueue_cleanupStreams((STube *)v2, 1);
        (*(void (**)(void))(a1[4] + 16))();
      }
      return;
    }
    uint64_t v15 = (*(uint64_t (**)(void))(**(void **)(v2 + 120) + 72))(*(void *)(v2 + 120));
    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
      dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
    }
    CFAllocatorRef v16 = *(_CFHTTPAuthentication **)(v15 + 80);
    if (!v16) {
      goto LABEL_57;
    }
    CFRange v17 = (__CFHTTPMessage *)(v15 - 16);
    CFDictionaryRef v18 = (const __CFDictionary *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 128) + 224))(*(void *)(v2 + 128), 0x1EC0A5678);
    CFDictionaryRef v19 = v18;
    if (v18)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v18, &unk_1EC0A5640);
      CFDictionaryRef v21 = Value;
      if (Value)
      {
        uint64_t v22 = CFDictionaryGetValue(Value, &unk_1EC0A2658);
        char v23 = 0;
        goto LABEL_33;
      }
    }
    else
    {
      CFDictionaryRef v21 = 0;
    }
    uint64_t v22 = 0;
    char v23 = 1;
LABEL_33:
    CFHTTPMessageRef Copy = CFHTTPMessageCreateCopy(*(CFAllocatorRef *)(v2 + 8), v17);
    _CFHTTPAuthenticationApplyHeaderToRequest(v16, Copy, (const void *)v2);
    if (v25)
    {
      values = 0;
      CFRelease(Copy);
      BOOL v26 = 0;
    }
    else
    {
      if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5973);
      }
      long long v27 = (__CFString *)HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Copy + 16), 0x1382736Bu);
      values = v27;
      CFRelease(Copy);
      if (!v27 || v22 && CFEqual(v22, v27))
      {
        BOOL v26 = 1;
      }
      else
      {
        CFAllocatorRef v28 = *(const __CFAllocator **)(v2 + 8);
        if (v23)
        {
          MutableCFHTTPMessageRef Copy = CFDictionaryCreate(*(CFAllocatorRef *)(v2 + 8), (const void **)&kCFHTTPHeaderProxyAuthorization, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          uint64_t v39 = MutableCopy;
        }
        else
        {
          CFIndex Count = CFDictionaryGetCount(v21);
          MutableCFHTTPMessageRef Copy = CFDictionaryCreateMutableCopy(v28, Count + 1, v21);
          uint64_t v39 = MutableCopy;
          CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, &unk_1EC0A2658, v27);
        }
        CFAllocatorRef v31 = *(const __CFAllocator **)(v2 + 8);
        if (v19)
        {
          CFIndex v32 = CFDictionaryGetCount(v19);
          uint64_t v33 = CFDictionaryCreateMutableCopy(v31, v32 + 1, v19);
          CFDictionarySetValue(v33, &unk_1EC0A5640, MutableCopy);
        }
        else
        {
          uint64_t v33 = CFDictionaryCreate(*(CFAllocatorRef *)(v2 + 8), (const void **)&kCFStreamPropertyCONNECTAdditionalHeaders, (const void **)&v39, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          MutableCFHTTPMessageRef Copy = v39;
        }
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        BOOL v26 = (*(uint64_t (**)(void, uint64_t, __CFDictionary *))(**(void **)(v2 + 128) + 200))(*(void *)(v2 + 128), 0x1EC0A5678, v33) != 0;
        if (v33) {
          CFRelease(v33);
        }
      }
    }
    if (v19) {
      CFRelease(v19);
    }
    if (values) {
      CFRelease(values);
    }
    if (v26) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  uint64_t v3 = *(void *)(a1[6] + 8);
  uint64_t v4 = *(const void **)(v3 + 24);
  *(void *)(v3 + CFRelease((char *)this - 24) = 0;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(void *)(a1[7] + 8);
  int v6 = *(const void **)(v5 + 24);
  *(void *)(v5 + CFRelease((char *)this - 24) = 0;
  if (v6)
  {
    CFRelease(v6);
  }
}

void sub_1842E71B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_15(void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if ((*(unsigned int (**)(void))(*(void *)a1[8] + 184))(a1[8]))
  {
    uint64_t v3 = a1[8];
    if (v3) {
      uint64_t v4 = (HTTPProtocol *)(v3 - 176);
    }
    else {
      uint64_t v4 = 0;
    }
    *(void *)(*(void *)(a1[6] + 8) + CFRelease((char *)this - 24) = HTTPProtocol::copyProtocolPropertiesForStream(v4);
  }
  else
  {
    *(unsigned char *)(*(void *)(a1[5] + 8) + CFRelease((char *)this - 24) = 0;
  }
  (*(void (**)(void *))(*v2 + 40))(v2);
  uint64_t v5 = v2[14];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  void v7[2] = ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_2_17;
  v7[3] = &unk_1E5257CF8;
  v7[4] = a1[4];
  void v7[5] = v2;
  void v7[6] = a1[8];
  (*(void (**)(uint64_t, void *))(*(void *)v5 + 96))(v5, v7);
  return (*(uint64_t (**)(void *))(*v2 + 48))(v2);
}

uint64_t ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_2_17(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  (*(void (**)(void))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48));
  uint64_t v3 = *(uint64_t (**)(uint64_t))(*(void *)v2 + 48);

  return v3(v2);
}

void ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_3(uint64_t a1, CFStringRef theString1, const void *a3)
{
  if (CFStringCompare(theString1, (CFStringRef)&unk_1EC0A10B0, 1uLL))
  {
    if (CFStringCompare(theString1, @"kCFStreamPropertySSLSettings", 1uLL) == kCFCompareEqualTo)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = 0;
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), @"kCFStreamPropertySSLSettings");
      if (Value)
      {
        CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, Value);
        operator new();
      }
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = 0;
  }
  BOOL v7 = *(__CFDictionary **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);

  CFDictionarySetValue(v7, theString1, a3);
}

void sub_1842E758C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a14);
  }
  std::__shared_weak_count::__release_shared[abi:nn180100](v14);
  _Unwind_Resume(a1);
}

void ___ZN5STube11prepStreamsEU13block_pointerFvvEU13block_pointerFv13CFStreamErrorE_block_invoke_4(uint64_t a1, const void *a2, const void *a3)
{
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke_20898()
{
}

void sub_1842E7620(_Unwind_Exception *a1)
{
  MEMORY[0x18531B6D0](v1, 0x10D0C40D425F453);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube24overrideAllowedProtocolsEm_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(int *)(v1 + 160) <= 1)
  {
    *(unsigned char *)(v1 + 144) = 1;
    *(void *)(v1 + 152) = *(void *)(result + 40);
  }
  return result;
}

uint64_t STube::getWaiter(STube *this)
{
  uint64_t v5 = 0;
  int v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  uint64_t v1 = *((void *)this + 14);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN5STube9getWaiterEv_block_invoke;
  v4[3] = &unk_1E5257C30;
  v4[4] = &v5;
  void v4[5] = this;
  (*(void (**)(uint64_t, void *))(*(void *)v1 + 104))(v1, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1842E7734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube9getWaiterEv_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 32) + 8) + CFRelease((char *)this - 24) = *(void *)(*(void *)(result + 40) + 120);
  return result;
}

CFTypeRef ___ZN5STube18copySSLCertContextEv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + CFRelease((char *)this - 24) = *(void *)(*(void *)(a1 + 40) + 168);
  CFTypeRef result = *(CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t ___ZN5STube6cancelEv_block_invoke(uint64_t a1)
{
  return STube::_onqueue_cancel(*(void *)(a1 + 32));
}

uint64_t STube::isCanceled(STube *this)
{
  uint64_t v5 = 0;
  int v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  uint64_t v1 = *((void *)this + 14);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  void v4[2] = ___ZN5STube10isCanceledEv_block_invoke;
  v4[3] = &unk_1E5257C30;
  v4[4] = &v5;
  void v4[5] = this;
  (*(void (**)(uint64_t, void *))(*(void *)v1 + 104))(v1, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1842E785C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN5STube10isCanceledEv_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + CFRelease((char *)this - 24) = *(_DWORD *)(*(void *)(result + 40) + 160) == 9;
  return result;
}

uint64_t ___ZN5STube16canAcceptWaitersEv_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + CFRelease((char *)this - 24) = *(_DWORD *)(*(void *)(result + 40) + 160) < 9;
  return result;
}

void *__CFTubeSetTubeTypeNotifier(void *aBlock)
{
  if (GlueTube::notifyOfTubeType) {
    _Block_release((const void *)GlueTube::notifyOfTubeType);
  }
  CFTypeRef result = _Block_copy(aBlock);
  GlueTube::notifyOfTubeType = (uint64_t)result;
  return result;
}

uint64_t __Block_byref_object_copy__20925(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + ++*(void *)(this + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + ++*(void *)(this + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__20926(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table(a1 + 48);
}

uint64_t ___Z34__HTTP2ServerPushMatchAcceptHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke(uint64_t a1, uint64_t *a2)
{
  char v2 = *((unsigned char *)a2 + 23);
  if (v2 >= 0) {
    uint64_t v3 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v3 = a2[1];
  }
  if (v2 >= 0) {
    uint64_t v4 = (char *)a2;
  }
  else {
    uint64_t v4 = (char *)*a2;
  }
  if (v3 >= 1)
  {
    unint64_t v7 = &v4[v3];
    size_t v8 = v3;
    uint64_t v9 = v4;
    do
    {
      uint64_t v10 = (char *)memchr(v9, 47, v8);
      if (!v10) {
        break;
      }
      if (*v10 == 47)
      {
        if (v10 != v7 && v10 - v4 != -1)
        {
          CFTypeRef v11 = v4;
          while (*v11 != 47)
          {
            ++v11;
            if (!--v3)
            {
              CFTypeRef v11 = v7;
              break;
            }
          }
          if (v11 == v7) {
            unint64_t v12 = -1;
          }
          else {
            unint64_t v12 = v11 - v4;
          }
          std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(v23, v4, &v4[v12], v12);
          uint64_t v13 = *((unsigned __int8 *)a2 + 23);
          if ((v13 & 0x80u) == 0) {
            uint64_t v14 = (char *)a2;
          }
          else {
            uint64_t v14 = (char *)*a2;
          }
          if ((v13 & 0x80u) != 0) {
            uint64_t v13 = a2[1];
          }
          std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(__p, &v14[v12 + 1], &v14[v13], v13 - (v12 + 1));
          unint64_t v15 = v24;
          int v16 = (char)v24;
          if ((v24 & 0x80u) != 0) {
            unint64_t v15 = (unint64_t)v23[1];
          }
          unsigned __int8 v17 = v22;
          if (v15)
          {
            if ((v22 & 0x80u) == 0 ? (void *)v22 : __p[1])
            {
              CFDictionaryRef v19 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(*(void *)(*(void *)(a1 + 32) + 8) + 48, (uint64_t)v23, (uint64_t)v23);
              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t *)v19 + 5, (uint64_t)__p, (uint64_t)__p);
            }
          }
          if ((v17 & 0x80) != 0) {
            operator delete(__p[0]);
          }
          if (v16 < 0) {
            operator delete(v23[0]);
          }
        }
        return 1;
      }
      uint64_t v9 = v10 + 1;
      size_t v8 = v7 - v9;
    }
    while (v7 - v9 >= 1);
  }
  return 1;
}

void sub_1842E7AEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (v18 < 0) {
    operator delete(__p);
  }
  if (v17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void split(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  while (1)
  {
    if (*(char *)(a1 + 23) < 0)
    {
      uint64_t v6 = *(unsigned __int8 **)a1;
      uint64_t v7 = *(void *)(a1 + 8);
    }
    else
    {
      uint64_t v6 = (unsigned __int8 *)a1;
      uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
    }
    uint64_t v8 = a2[23];
    if ((v8 & 0x80u) == 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(unsigned __int8 **)a2;
    }
    if ((v8 & 0x80u) != 0) {
      uint64_t v8 = *((void *)a2 + 1);
    }
    if (!v7 || v8 == 0) {
      break;
    }
    CFTypeRef v11 = &v6[v7];
    unint64_t v12 = v6;
LABEL_14:
    uint64_t v13 = v8;
    uint64_t v14 = v9;
    while (*v12 != *v14)
    {
      ++v14;
      if (!--v13)
      {
        if (++v12 == v11) {
          goto LABEL_33;
        }
        goto LABEL_14;
      }
    }
    if (v12 == v11) {
      break;
    }
    int64_t v15 = v12 - v6;
    if (v12 - v6 == -1) {
      break;
    }
    int v16 = (char *)a1;
    if ((*(unsigned char *)(a1 + 23) & 0x80) != 0) {
      int v16 = *(char **)a1;
    }
    std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(__p, v16, &v16[v15], v12 - v6);
    uint64_t v17 = *(void *)(a3 + 24);
    if (!v17)
    {
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
LABEL_37:
      unsigned __int8 v22 = (_Unwind_Exception *)std::__throw_bad_function_call[abi:nn180100]();
      if (SHIBYTE(v24) < 0) {
        operator delete(__p[0]);
      }
      _Unwind_Resume(v22);
    }
    char v18 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v17 + 48))(v17, __p);
    if (SHIBYTE(v24) < 0) {
      operator delete(__p[0]);
    }
    if ((v18 & 1) == 0) {
      return;
    }
    if (*(char *)(a1 + 23) < 0)
    {
      uint64_t v20 = *(unsigned __int8 **)a1;
      uint64_t v19 = *(void *)(a1 + 8);
    }
    else
    {
      uint64_t v19 = *(unsigned __int8 *)(a1 + 23);
      uint64_t v20 = (unsigned __int8 *)a1;
    }
    std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(__p, (char *)&v20[v15 + 1], (char *)&v20[v19], v19 - (v15 + 1));
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(_OWORD *)a1 = *(_OWORD *)__p;
    *(void *)(a1 + CFRetain((char *)this - 16) = v24;
  }
LABEL_33:
  uint64_t v21 = *(void *)(a3 + 24);
  if (!v21) {
    goto LABEL_37;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 48))(v21, a1);
}

void *std::__function::__value_func<BOOL ()(std::string const&)>::~__value_func[abi:nn180100](void *a1)
{
  char v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL ___Z34__HTTP2ServerPushMatchAcceptHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke_2(uint64_t a1, uint64_t *a2)
{
  char v2 = *((unsigned char *)a2 + 23);
  if (v2 >= 0) {
    uint64_t v3 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v3 = a2[1];
  }
  if (v2 >= 0) {
    uint64_t v4 = (char *)a2;
  }
  else {
    uint64_t v4 = (char *)*a2;
  }
  if (v3 < 1) {
    return 1;
  }
  uint64_t v7 = &v4[v3];
  size_t v8 = v3;
  uint64_t v9 = v4;
  while (1)
  {
    uint64_t v10 = (char *)memchr(v9, 47, v8);
    if (!v10) {
      return 1;
    }
    if (*v10 == 47) {
      break;
    }
    uint64_t v9 = v10 + 1;
    size_t v8 = v7 - v9;
    if (v7 - v9 < 1) {
      return 1;
    }
  }
  if (v10 == v7 || v10 - v4 == -1) {
    return 1;
  }
  CFTypeRef v11 = v4;
  while (*v11 != 47)
  {
    ++v11;
    if (!--v3)
    {
      CFTypeRef v11 = v7;
      break;
    }
  }
  if (v11 == v7) {
    unint64_t v12 = -1;
  }
  else {
    unint64_t v12 = v11 - v4;
  }
  std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(v40, v4, &v4[v12], v12);
  uint64_t v13 = *((unsigned __int8 *)a2 + 23);
  if ((v13 & 0x80u) == 0) {
    uint64_t v14 = (char *)a2;
  }
  else {
    uint64_t v14 = (char *)*a2;
  }
  if ((v13 & 0x80u) != 0) {
    uint64_t v13 = a2[1];
  }
  std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(__p, &v14[v12 + 1], &v14[v13], v13 - (v12 + 1));
  int v15 = (char)v41;
  if ((v41 & 0x80u) == 0) {
    unint64_t v16 = v41;
  }
  else {
    unint64_t v16 = (unint64_t)v40[1];
  }
  unsigned __int8 v17 = v39;
  if (!v16) {
    goto LABEL_54;
  }
  if (!((v39 & 0x80u) == 0 ? (void *)v39 : __p[1])) {
    goto LABEL_54;
  }
  uint64_t v19 = *(int8x8_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v20 = (v41 & 0x80u) == 0 ? (uint64_t *)v40 : (uint64_t *)v40[0];
  unint64_t v21 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v20, v16);
  int8x8_t v22 = v19[7];
  if (!*(void *)&v22) {
    goto LABEL_54;
  }
  unint64_t v23 = v21;
  uint64_t v24 = v19 + 6;
  uint8x8_t v25 = (uint8x8_t)vcnt_s8(v22);
  v25.i16[0] = vaddlv_u8(v25);
  unint64_t v26 = v25.u32[0];
  if (v25.u32[0] > 1uLL)
  {
    unint64_t v27 = v21;
    if (v21 >= *(void *)&v22) {
      unint64_t v27 = v21 % *(void *)&v22;
    }
  }
  else
  {
    unint64_t v27 = (*(void *)&v22 - 1) & v21;
  }
  CFAllocatorRef v28 = *(unsigned __int8 ***)(*(void *)v24 + 8 * v27);
  if (!v28 || (uint64_t v29 = *v28) == 0)
  {
LABEL_54:
    char v31 = 1;
    if ((v17 & 0x80) != 0) {
      goto LABEL_55;
    }
    goto LABEL_56;
  }
  while (1)
  {
    unint64_t v30 = *((void *)v29 + 1);
    if (v23 == v30) {
      break;
    }
    if (v26 > 1)
    {
      if (v30 >= *(void *)&v22) {
        v30 %= *(void *)&v22;
      }
    }
    else
    {
      v30 &= *(void *)&v22 - 1;
    }
    if (v30 != v27) {
      goto LABEL_54;
    }
LABEL_53:
    uint64_t v29 = *(unsigned __int8 **)v29;
    if (!v29) {
      goto LABEL_54;
    }
  }
  if (!std::equal_to<std::string>::operator()[abi:nn180100](v29 + 16, (unsigned __int8 *)v40)) {
    goto LABEL_53;
  }
  uint64_t v33 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v24, (uint64_t)v40, (uint64_t)v40);
  if (!std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>((void *)v33 + 5, (uint64_t)__p))
  {
    uint64_t v34 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(*(void *)(*(void *)(a1 + 32) + 8) + 48, (uint64_t)v40, (uint64_t)v40);
    std::string::basic_string[abi:nn180100]<0>(v36, "*");
    CFSetRef v35 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>((void *)v34 + 5, (uint64_t)v36);
    if (v37 < 0) {
      operator delete(v36[0]);
    }
    if (!v35) {
      goto LABEL_54;
    }
  }
  char v31 = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + CFRelease((char *)this - 24) = 1;
  if ((v17 & 0x80) != 0) {
LABEL_55:
  }
    operator delete(__p[0]);
LABEL_56:
  if (v15 < 0)
  {
    operator delete(v40[0]);
    return (v31 & 1) != 0;
  }
  return (v31 & 1) != 0;
}

void sub_1842E8064(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (v22 < 0) {
    operator delete(__p);
  }
  if (v21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table(uint64_t a1)
{
  char v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_set<std::string>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      char v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_set<std::string>>,0>(uint64_t a1)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
  {
    char v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(uint64_t a1)
{
  char v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      char v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void *std::string::__init_with_size[abi:nn180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(void *result, char *a2, char *a3, unint64_t a4)
{
  if (a4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  uint64_t v7 = result;
  if (a4 > 0x16)
  {
    uint64_t v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17) {
      uint64_t v8 = a4 | 7;
    }
    uint64_t v9 = v8 + 1;
    CFTypeRef result = operator new(v8 + 1);
    v7[1] = a4;
    void v7[2] = v9 | 0x8000000000000000;
    *uint64_t v7 = result;
    uint64_t v7 = result;
  }
  else
  {
    *((unsigned char *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    char v10 = *a2++;
    *(unsigned char *)uint64_t v7 = v10;
    uint64_t v7 = (void *)((char *)v7 + 1);
  }
  *(unsigned char *)uint64_t v7 = 0;
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    uint64_t v8 = (uint64_t *)a2;
  }
  else {
    uint64_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    int v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      for (CFIndex i = *v15; i; CFIndex i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
            return i;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }
  char v18 = (void *)(a1 + 16);
  uint64_t v19 = (char *)operator new(0x50uLL);
  v42[0] = v19;
  v42[1] = a1 + 16;
  char v43 = 0;
  *(void *)uint64_t v19 = 0;
  *((void *)v19 + HTTPServerConnection::canceled_onQueue(this - 1) = v11;
  uint64_t v20 = (std::string *)(v19 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v20, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v20->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((void *)v19 + 4) = *(void *)(a3 + 16);
  }
  *(_OWORD *)(v19 + 56) = 0u;
  *(_OWORD *)(v19 + 40) = 0u;
  *((_DWORD *)v19 + 18) = 1065353216;
  char v43 = 1;
  float v21 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v22 = *(float *)(a1 + 32);
  if (!v12 || (float)(v22 * (float)v12) < v21)
  {
    BOOL v23 = 1;
    if (v12 >= 3) {
      BOOL v23 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v12);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    else {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v12 = *(void *)(a1 + 8);
    if (*(void *)&prime > v12) {
      goto LABEL_39;
    }
    if (*(void *)&prime < v12)
    {
      unint64_t v33 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v12 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        unint64_t v33 = std::__next_prime(v33);
      }
      else
      {
        uint64_t v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2) {
          unint64_t v33 = v35;
        }
      }
      if (*(void *)&prime <= v33) {
        int8x8_t prime = (int8x8_t)v33;
      }
      if (*(void *)&prime >= v12)
      {
        unint64_t v12 = *(void *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v27 = operator new(8 * *(void *)&prime);
          CFAllocatorRef v28 = *(void **)a1;
          *(void *)a1 = v27;
          if (v28) {
            operator delete(v28);
          }
          uint64_t v29 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v29++) = 0;
          while (*(void *)&prime != v29);
          unint64_t v30 = (void *)*v18;
          if (*v18)
          {
            unint64_t v31 = v30[1];
            uint8x8_t v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(void *)&prime) {
                v31 %= *(void *)&prime;
              }
            }
            else
            {
              v31 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v3HTTPServerConnection::canceled_onQueue(this - 1) = v18;
            uint64_t v36 = (void *)*v30;
            if (*v30)
            {
              do
              {
                unint64_t v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(void *)&prime) {
                    v37 %= *(void *)&prime;
                  }
                }
                else
                {
                  v37 &= *(void *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v37))
                  {
                    *(void *)(*(void *)a1 + 8 * v37) = v30;
                    goto LABEL_64;
                  }
                  *unint64_t v30 = *v36;
                  void *v36 = **(void **)(*(void *)a1 + 8 * v37);
                  **(void **)(*(void *)a1 + 8 * v37) = v36;
                  uint64_t v36 = v30;
                }
                unint64_t v37 = v31;
LABEL_64:
                unint64_t v30 = v36;
                uint64_t v36 = (void *)*v36;
                unint64_t v31 = v37;
              }
              while (v36);
            }
          }
          unint64_t v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        unsigned __int8 v41 = *(void **)a1;
        *(void *)a1 = 0;
        if (v41) {
          operator delete(v41);
        }
        unint64_t v12 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  BOOL v38 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
  CFIndex i = (unsigned __int8 *)v42[0];
  if (v38)
  {
    *(void *)v42[0] = *v38;
LABEL_81:
    *BOOL v38 = i;
    goto LABEL_82;
  }
  *(void *)v42[0] = *(void *)(a1 + 16);
  *(void *)(a1 + CFRetain((char *)this - 16) = i;
  *(void *)(*(void *)a1 + 8 * v3) = v18;
  if (*(void *)i)
  {
    unint64_t v39 = *(void *)(*(void *)i + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v39 >= v12) {
        v39 %= v12;
      }
    }
    else
    {
      v39 &= v12 - 1;
    }
    BOOL v38 = (unsigned __int8 **)(*(void *)a1 + 8 * v39);
    goto LABEL_81;
  }
LABEL_82:
  v42[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)v42);
  return i;
}

void sub_1842E86B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(void *a1, uint64_t a2)
{
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    uint64_t v5 = (uint64_t *)a2;
  }
  else {
    uint64_t v5 = *(uint64_t **)a2;
  }
  if (v4 >= 0) {
    unint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v6 = *(void *)(a2 + 8);
  }
  unint64_t v7 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v5, v6);
  int8x8_t v8 = (int8x8_t)a1[1];
  if (!*(void *)&v8) {
    return 0;
  }
  unint64_t v9 = v7;
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v8);
  v10.i16[0] = vaddlv_u8(v10);
  unint64_t v11 = v10.u32[0];
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v12 = v7;
    if (v7 >= *(void *)&v8) {
      unint64_t v12 = v7 % *(void *)&v8;
    }
  }
  else
  {
    unint64_t v12 = (*(void *)&v8 - 1) & v7;
  }
  uint8x8_t v13 = *(unsigned __int8 ***)(*a1 + 8 * v12);
  if (!v13) {
    return 0;
  }
  for (CFIndex i = *v13; i; CFIndex i = *(unsigned __int8 **)i)
  {
    unint64_t v15 = *((void *)i + 1);
    if (v9 == v15)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
        return i;
      }
    }
    else
    {
      if (v11 > 1)
      {
        if (v15 >= *(void *)&v8) {
          v15 %= *(void *)&v8;
        }
      }
      else
      {
        v15 &= *(void *)&v8 - 1;
      }
      if (v15 != v12) {
        return 0;
      }
    }
  }
  return i;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unordered_set<std::string>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_set<std::string>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

uint64_t std::__function::__func<BOOL({block_pointer})(std::string const&),std::allocator<BOOL({block_pointer})(std::string const&)>,BOOL ()(std::string const&)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

void std::__function::__func<BOOL({block_pointer})(std::string const&),std::allocator<BOOL({block_pointer})(std::string const&)>,BOOL ()(std::string const&)>::destroy(uint64_t a1)
{
  char v2 = *(const void **)(a1 + 8);
  if (v2) {
    _Block_release(v2);
  }
  *(void *)(a1 + 8) = 0;
}

void *std::__function::__func<BOOL({block_pointer})(std::string const&),std::allocator<BOOL({block_pointer})(std::string const&)>,BOOL ()(std::string const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1ECFA5FD0;
  CFTypeRef result = *(void **)(a1 + 8);
  if (result) {
    CFTypeRef result = _Block_copy(result);
  }
  a2[1] = result;
  return result;
}

uint64_t std::__function::__func<BOOL({block_pointer})(std::string const&),std::allocator<BOOL({block_pointer})(std::string const&)>,BOOL ()(std::string const&)>::__clone()
{
  return 0;
}

void std::__function::__func<BOOL({block_pointer})(std::string const&),std::allocator<BOOL({block_pointer})(std::string const&)>,BOOL ()(std::string const&)>::~__func()
{
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    int8x8_t v8 = (uint64_t *)a2;
  }
  else {
    int8x8_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = a1[1];
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    unint64_t v15 = *(unsigned __int8 ***)(*a1 + 8 * v3);
    if (v15)
    {
      for (CFIndex i = *v15; i; CFIndex i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
            return;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }
  char v18 = operator new(0x28uLL);
  *char v18 = 0;
  v18[1] = v11;
  uint64_t v19 = (std::string *)(v18 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v18[4] = *(void *)(a3 + 16);
  }
  uint64_t v20 = a1 + 2;
  float v21 = (float)(unint64_t)(a1[3] + 1);
  float v22 = *((float *)a1 + 8);
  if (!v12 || (float)(v22 * (float)v12) < v21)
  {
    BOOL v23 = 1;
    if (v12 >= 3) {
      BOOL v23 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v12);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    else {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v12 = a1[1];
    if (*(void *)&prime > v12) {
      goto LABEL_39;
    }
    if (*(void *)&prime < v12)
    {
      unint64_t v33 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        unint64_t v33 = std::__next_prime(v33);
      }
      else
      {
        uint64_t v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2) {
          unint64_t v33 = v35;
        }
      }
      if (*(void *)&prime <= v33) {
        int8x8_t prime = (int8x8_t)v33;
      }
      if (*(void *)&prime >= v12)
      {
        unint64_t v12 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v27 = operator new(8 * *(void *)&prime);
          CFAllocatorRef v28 = (void *)*a1;
          *a1 = (uint64_t)v27;
          if (v28) {
            operator delete(v28);
          }
          uint64_t v29 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v29++) = 0;
          while (*(void *)&prime != v29);
          unint64_t v30 = (void *)*v20;
          if (*v20)
          {
            unint64_t v31 = v30[1];
            uint8x8_t v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(void *)&prime) {
                v31 %= *(void *)&prime;
              }
            }
            else
            {
              v31 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v3HTTPServerConnection::canceled_onQueue(this - 1) = v20;
            uint64_t v36 = (void *)*v30;
            if (*v30)
            {
              do
              {
                unint64_t v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(void *)&prime) {
                    v37 %= *(void *)&prime;
                  }
                }
                else
                {
                  v37 &= *(void *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*(void *)(*a1 + 8 * v37))
                  {
                    *(void *)(*a1 + 8 * v37) = v30;
                    goto LABEL_64;
                  }
                  *unint64_t v30 = *v36;
                  void *v36 = **(void **)(*a1 + 8 * v37);
                  **(void **)(*a1 + 8 * v37) = v36;
                  uint64_t v36 = v30;
                }
                unint64_t v37 = v31;
LABEL_64:
                unint64_t v30 = v36;
                uint64_t v36 = (void *)*v36;
                unint64_t v31 = v37;
              }
              while (v36);
            }
          }
          unint64_t v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        unsigned __int8 v41 = (void *)*a1;
        *a1 = 0;
        if (v41) {
          operator delete(v41);
        }
        unint64_t v12 = 0;
        a1[1] = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  uint64_t v38 = *a1;
  unint64_t v39 = *(void **)(*a1 + 8 * v3);
  if (v39)
  {
    *char v18 = *v39;
LABEL_81:
    *unint64_t v39 = v18;
    goto LABEL_82;
  }
  *char v18 = *v20;
  *uint64_t v20 = v18;
  *(void *)(v38 + 8 * v3) = v20;
  if (*v18)
  {
    unint64_t v40 = *(void *)(*v18 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v40 >= v12) {
        v40 %= v12;
      }
    }
    else
    {
      v40 &= v12 - 1;
    }
    unint64_t v39 = (void *)(*a1 + 8 * v40);
    goto LABEL_81;
  }
LABEL_82:
  ++a1[3];
}

void sub_1842E8D08(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100](0, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 39) < 0) {
      operator delete(__p[2]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t __Block_byref_object_copy__5(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  unint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + ++*(void *)(this + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + ++*(void *)(this + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *unint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__6(uint64_t a1)
{
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a1 + 48);
}

uint64_t ___Z42__HTTP2ServerPushMatchAcceptEncodingHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (v2) {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 48), a2, a2);
  }
  return 1;
}

uint64_t ___Z42__HTTP2ServerPushMatchAcceptEncodingHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (!v2) {
    return 1;
  }
  uint64_t result = (uint64_t)std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>((void *)(*(void *)(*(void *)(a1 + 32) + 8) + 48), a2);
  if (result) {
    return 1;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + CFRelease((char *)this - 24) = 0;
  return result;
}

void ___ZN21HTTP2ServerPushStream18_getExpirationTimeEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(void *a1, uint64_t a2)
{
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    uint64_t v5 = (uint64_t *)a2;
  }
  else {
    uint64_t v5 = *(uint64_t **)a2;
  }
  if (v4 >= 0) {
    unint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v6 = *(void *)(a2 + 8);
  }
  unint64_t v7 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v5, v6);
  int8x8_t v8 = (int8x8_t)a1[1];
  if (!*(void *)&v8) {
    return 0;
  }
  unint64_t v9 = v7;
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v8);
  v10.i16[0] = vaddlv_u8(v10);
  unint64_t v11 = v10.u32[0];
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v12 = v7;
    if (v7 >= *(void *)&v8) {
      unint64_t v12 = v7 % *(void *)&v8;
    }
  }
  else
  {
    unint64_t v12 = (*(void *)&v8 - 1) & v7;
  }
  uint8x8_t v13 = *(unsigned __int8 ***)(*a1 + 8 * v12);
  if (!v13) {
    return 0;
  }
  for (CFIndex i = *v13; i; CFIndex i = *(unsigned __int8 **)i)
  {
    unint64_t v15 = *((void *)i + 1);
    if (v15 == v9)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
        return i;
      }
    }
    else
    {
      if (v11 > 1)
      {
        if (v15 >= *(void *)&v8) {
          v15 %= *(void *)&v8;
        }
      }
      else
      {
        v15 &= *(void *)&v8 - 1;
      }
      if (v15 != v12) {
        return 0;
      }
    }
  }
  return i;
}

uint64_t std::string::basic_string[abi:nn180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    unint64_t v6 = operator new(v4 + 1);
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + CFRetain((char *)this - 16) = v5 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + CFRetain((char *)this - 16) = 0;
    *(void *)a1 = 0;
    *(unsigned char *)(a1 + 23) = a2;
  }
  return a1;
}

void ___ZN21HTTP2ServerPushStream18_getExpirationTimeEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void HTTP2ServerPushStream::_getFullURL(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (!v2)
  {
    std::string::basic_string[abi:nn180100]<0>(&__p, ":scheme");
    uint64_t v5 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(*(void *)a1, *(void *)(a1 + 8), (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    unint64_t v6 = ":443";
    if (v5)
    {
      unint64_t v7 = (unsigned int *)(v5 + 40);
      if ((v5[63] & 0x80u) == 0) {
        size_t v8 = v5[63];
      }
      else {
        size_t v8 = *((void *)v5 + 6);
      }
      p_p = &__p;
      std::string::basic_string[abi:nn180100]((uint64_t)&__p, v8 + 3);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if (v8)
      {
        if ((v5[63] & 0x80u) == 0) {
          uint8x8_t v10 = v5 + 40;
        }
        else {
          uint8x8_t v10 = (const void *)*((void *)v5 + 5);
        }
        memmove(p_p, v10, v8);
      }
      *(_DWORD *)((char *)&p_p->__r_.__value_.__l.__data_ + v8) = 3092282;
      if (*(char *)(a2 + 23) < 0) {
        operator delete(*(void **)a2);
      }
      *(std::string *)a2 = __p;
      int v11 = (char)v5[63];
      if (v11 < 0)
      {
        if (*((void *)v5 + 6) != 4) {
          goto LABEL_29;
        }
        unint64_t v7 = *(unsigned int **)v7;
      }
      else if (v11 != 4)
      {
        goto LABEL_29;
      }
      unsigned int v12 = bswap32(*v7);
      BOOL v13 = v12 >= 0x68747470;
      int v14 = v12 > 0x68747470;
      int v15 = !v13;
      if (v14 == v15) {
        unint64_t v6 = ":80";
      }
    }
LABEL_29:
    std::string::basic_string[abi:nn180100]<0>(&__p, ":authority");
    unint64_t v16 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(*(void *)a1, *(void *)(a1 + 8), (uint64_t)&__p);
    unint64_t v17 = v16;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if (!v17)
      {
LABEL_46:
        std::string::basic_string[abi:nn180100]<0>(&__p, ":path");
        uint64_t v20 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(*(void *)a1, *(void *)(a1 + 8), (uint64_t)&__p);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v20)
        {
          BOOL v23 = (const std::string::value_type *)*((void *)v20 + 5);
          float v22 = v20 + 40;
          float v21 = v23;
          int v24 = (char)v22[23];
          if (v24 >= 0) {
            unint64_t v25 = (const std::string::value_type *)v22;
          }
          else {
            unint64_t v25 = v21;
          }
          if (v24 >= 0) {
            std::string::size_type v26 = v22[23];
          }
          else {
            std::string::size_type v26 = *((void *)v22 + 1);
          }
          std::string::append((std::string *)a2, v25, v26);
        }
        return;
      }
    }
    else if (!v16)
    {
      goto LABEL_46;
    }
    if ((char)v17[63] < 0) {
      std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)v17 + 5), *((void *)v17 + 6));
    }
    else {
      std::string __p = *(std::string *)(v17 + 40);
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v18 = &__p;
    }
    else {
      char v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    std::string::append((std::string *)a2, (const std::string::value_type *)v18, size);
    if (std::string::find(&__p, 58, 0) == -1) {
      std::string::append((std::string *)a2, v6);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    goto LABEL_46;
  }
}

void sub_1842E92E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6 = *(char *)(a3 + 23);
  if (v6 >= 0) {
    unint64_t v7 = (uint64_t *)a3;
  }
  else {
    unint64_t v7 = *(uint64_t **)a3;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a3 + 8);
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  if (!a2) {
    return 0;
  }
  unint64_t v10 = v9;
  uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v11.i16[0] = vaddlv_u8(v11);
  unint64_t v12 = v11.u32[0];
  if (v11.u32[0] > 1uLL)
  {
    unint64_t v13 = v9;
    if (v9 >= a2) {
      unint64_t v13 = v9 % a2;
    }
  }
  else
  {
    unint64_t v13 = (a2 - 1) & v9;
  }
  int v14 = *(unsigned __int8 ***)(a1 + 8 * v13);
  if (!v14) {
    return 0;
  }
  for (CFIndex i = *v14; i; CFIndex i = *(unsigned __int8 **)i)
  {
    unint64_t v16 = *((void *)i + 1);
    if (v10 == v16)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a3)) {
        return i;
      }
    }
    else
    {
      if (v12 > 1)
      {
        if (v16 >= a2) {
          v16 %= a2;
        }
      }
      else
      {
        v16 &= a2 - 1;
      }
      if (v16 != v13) {
        return 0;
      }
    }
  }
  return i;
}

void HTTP2ServerPushStream::~HTTP2ServerPushStream(HTTP2ServerPushStream *this)
{
  if (*((char *)this + 247) < 0) {
    operator delete(*((void **)this + 28));
  }
  if (*((void *)this + 22))
  {
    std::vector<std::shared_ptr<HTTPConnectionCacheEntry::EnqueuedRequest>>::__clear[abi:nn180100]((uint64_t *)this + 22);
    operator delete(*((void **)this + 22));
  }
  uint64_t v2 = *((void *)this + 19);
  *((void *)this + 19) = 0;
  if (v2) {
    (*((void (**)(void))this + 20))();
  }
  unint64_t v3 = (void **)((char *)this + 120);
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:nn180100](&v3);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)this + 80);
  unint64_t v3 = (void **)((char *)this + 48);
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:nn180100](&v3);
  std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)this + 8);
}

uint64_t HTTP2ServerPushStream::_invokeCompletionHadlers(uint64_t a1, int a2)
{
  uint64_t v2 = (uint64_t *)(a1 + 176);
  unint64_t v3 = *(uint64_t **)(a1 + 176);
  *(_DWORD *)(a1 + 256) = a2;
  uint64_t v4 = *(uint64_t **)(a1 + 184);
  if (v3 == v4)
  {
    char v6 = 0;
  }
  else
  {
    char v6 = 0;
    do
    {
      uint64_t v7 = *v3;
      if (*v3)
      {
        unint64_t v8 = *(void *)(v7 + 8);
        uint64_t v9 = *(void *)(v7 + 16);
        BOOL v10 = !v9 || (*(void *)(v7 + 16) & 1 | v8) == 0;
        BOOL v11 = !v10;
        if ((uint64_t (*)())v8 != BlockHolderVar<BOOL>::invoke_reseted || v11)
        {
          unint64_t v13 = (void *)(v7 + (v9 >> 1));
          if (v9) {
            unint64_t v8 = *(void *)(*v13 + v8);
          }
          char v6 = 1;
          ((void (*)(void *, uint64_t))v8)(v13, 1);
          --*(_DWORD *)(*(void *)a1 + 16);
        }
      }
      v3 += 2;
    }
    while (v3 != v4);
  }
  std::vector<std::shared_ptr<HTTPConnectionCacheEntry::EnqueuedRequest>>::__clear[abi:nn180100](v2);
  return v6 & 1;
}

void std::vector<SmartBlockWithArgs<BOOL>>::push_back[abi:nn180100](char **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a1[1];
  unint64_t v6 = (unint64_t)a1[2];
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = *a1;
    uint64_t v10 = (v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      abort();
    }
    uint64_t v12 = v6 - (void)v9;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      if (v13 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      int v14 = (char *)operator new(16 * v13);
    }
    else
    {
      int v14 = 0;
    }
    int v15 = &v14[16 * v10];
    *(void *)int v15 = a2;
    *((void *)v15 + HTTPServerConnection::canceled_onQueue(this - 1) = a3;
    if (a3)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
      uint64_t v9 = *a1;
      uint64_t v7 = a1[1];
    }
    unint64_t v8 = v15 + 16;
    if (v7 == v9)
    {
      int64x2_t v17 = vdupq_n_s64((unint64_t)v7);
    }
    else
    {
      do
      {
        long long v16 = *((_OWORD *)v7 - 1);
        v7 -= 16;
        *((_OWORD *)v15 - HTTPServerConnection::canceled_onQueue(this - 1) = v16;
        v15 -= 16;
        *(void *)uint64_t v7 = 0;
        *((void *)v7 + HTTPServerConnection::canceled_onQueue(this - 1) = 0;
      }
      while (v7 != v9);
      int64x2_t v17 = *(int64x2_t *)a1;
    }
    *a1 = v15;
    a1[1] = v8;
    a1[2] = &v14[16 * v13];
    uint64_t v19 = (char *)v17.i64[1];
    char v18 = (char *)v17.i64[0];
    while (v19 != v18)
    {
      uint64_t v20 = (std::__shared_weak_count *)*((void *)v19 - 1);
      if (v20) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v20);
      }
      v19 -= 16;
    }
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *(void *)uint64_t v7 = a2;
    *((void *)v7 + HTTPServerConnection::canceled_onQueue(this - 1) = a3;
    if (a3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v8 = v7 + 16;
  }
  a1[1] = v8;
}

HTTP2ServerPushStream *std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](HTTP2ServerPushStream **a1, HTTP2ServerPushStream *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    HTTP2ServerPushStream::~HTTP2ServerPushStream(result);
    JUMPOUT(0x18531B6D0);
  }
  return result;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    unint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>(void *a1, int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  uint64_t v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (uint64_t result = *v5; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::__erase_unique<int>(uint64_t *a1, int a2)
{
  unint64_t v2 = a1[1];
  if (v2)
  {
    unint64_t v3 = a2;
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v5 = a2;
      if (v2 <= a2) {
        unint64_t v5 = a2 % v2;
      }
    }
    else
    {
      unint64_t v5 = (v2 - 1) & a2;
    }
    uint64_t v6 = *a1;
    unint64_t v7 = *(uint64_t ***)(*a1 + 8 * v5);
    if (v7)
    {
      unint64_t v8 = *v7;
      if (v8)
      {
        unint64_t v9 = v2 - 1;
        do
        {
          unint64_t v10 = v8[1];
          if (v10 == a2)
          {
            if (*((_DWORD *)v8 + 4) == a2)
            {
              if (v4.u32[0] > 1uLL)
              {
                if (v2 <= a2) {
                  unint64_t v3 = a2 % v2;
                }
              }
              else
              {
                unint64_t v3 = v9 & a2;
              }
              unint64_t v11 = *(uint64_t **)(v6 + 8 * v3);
              do
              {
                uint64_t v12 = v11;
                unint64_t v11 = (uint64_t *)*v11;
              }
              while (v11 != v8);
              if (v12 == a1 + 2) {
                goto LABEL_36;
              }
              unint64_t v13 = v12[1];
              if (v4.u32[0] > 1uLL)
              {
                if (v13 >= v2) {
                  v13 %= v2;
                }
              }
              else
              {
                v13 &= v9;
              }
              if (v13 != v3)
              {
LABEL_36:
                if (!*v8) {
                  goto LABEL_37;
                }
                unint64_t v14 = *(void *)(*v8 + 8);
                if (v4.u32[0] > 1uLL)
                {
                  if (v14 >= v2) {
                    v14 %= v2;
                  }
                }
                else
                {
                  v14 &= v9;
                }
                if (v14 != v3) {
LABEL_37:
                }
                  *(void *)(v6 + 8 * v3) = 0;
              }
              uint64_t v15 = *v8;
              if (*v8)
              {
                unint64_t v16 = *(void *)(v15 + 8);
                if (v4.u32[0] > 1uLL)
                {
                  if (v16 >= v2) {
                    v16 %= v2;
                  }
                }
                else
                {
                  v16 &= v9;
                }
                if (v16 != v3)
                {
                  *(void *)(*a1 + 8 * vCFRetain((char *)this - 16) = v12;
                  uint64_t v15 = *v8;
                }
              }
              uint64_t *v12 = v15;
              *unint64_t v8 = 0;
              --a1[3];
              operator delete(v8);
              return;
            }
          }
          else
          {
            if (v4.u32[0] > 1uLL)
            {
              if (v10 >= v2) {
                v10 %= v2;
              }
            }
            else
            {
              v10 &= v9;
            }
            if (v10 != v5) {
              return;
            }
          }
          unint64_t v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
    }
  }
}

void std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__erase_unique<std::reference_wrapper<HTTP2ServerPushStream const>>(void *a1, uint64_t *a2)
{
  unint64_t v3 = std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::find<std::reference_wrapper<HTTP2ServerPushStream const>>(a1, a2);
  if (v3)
  {
    int8x8_t v4 = (int8x8_t)a1[1];
    unint64_t v5 = v3[1];
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      if (v5 >= *(void *)&v4) {
        v5 %= *(void *)&v4;
      }
    }
    else
    {
      v5 &= *(void *)&v4 - 1;
    }
    unint64_t v7 = *(void **)(*a1 + 8 * v5);
    do
    {
      unint64_t v8 = v7;
      unint64_t v7 = (void *)*v7;
    }
    while (v7 != v3);
    if (v8 == a1 + 2) {
      goto LABEL_20;
    }
    unint64_t v9 = v8[1];
    if (v6.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v4) {
        v9 %= *(void *)&v4;
      }
    }
    else
    {
      v9 &= *(void *)&v4 - 1;
    }
    if (v9 != v5)
    {
LABEL_20:
      if (!*v3) {
        goto LABEL_21;
      }
      unint64_t v10 = *(void *)(*v3 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(void *)&v4) {
          v10 %= *(void *)&v4;
        }
      }
      else
      {
        v10 &= *(void *)&v4 - 1;
      }
      if (v10 != v5) {
LABEL_21:
      }
        *(void *)(*a1 + 8 * v5) = 0;
    }
    uint64_t v11 = *v3;
    if (*v3)
    {
      unint64_t v12 = *(void *)(v11 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v12 >= *(void *)&v4) {
          v12 %= *(void *)&v4;
        }
      }
      else
      {
        v12 &= *(void *)&v4 - 1;
      }
      if (v12 != v5)
      {
        *(void *)(*a1 + 8 * v12) = v8;
        uint64_t v11 = *v3;
      }
    }
    *unint64_t v8 = v11;
    *unint64_t v3 = 0;
    --a1[3];
    operator delete(v3);
  }
}

void *HTTP2ServerPush::_removeFromUrlToServerPushStreamsMap(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 88, a2, a2);
  uint8x8_t v6 = (char *)result[5];
  unint64_t v5 = (char *)result[6];
  if (v6 != v5)
  {
    unint64_t v7 = result;
    while (*(void *)v6 != a3)
    {
      v6 += 8;
      if (v6 == v5) {
        return result;
      }
    }
    int64_t v8 = v5 - (v6 + 8);
    if (v5 != v6 + 8) {
      uint64_t result = memmove(v6, v6 + 8, v5 - (v6 + 8));
    }
    void v7[6] = &v6[v8];
  }
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    int64_t v8 = (uint64_t *)a2;
  }
  else {
    int64_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    uint64_t v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      for (CFIndex i = *v15; i; CFIndex i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
            return i;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }
  char v18 = (void *)(a1 + 16);
  uint64_t v19 = operator new(0x40uLL);
  v42[0] = v19;
  v42[1] = a1 + 16;
  char v43 = 0;
  void *v19 = 0;
  v19[1] = v11;
  uint64_t v20 = (std::string *)(v19 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v20, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v20->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v19[4] = *(void *)(a3 + 16);
  }
  v19[5] = 0;
  v19[6] = 0;
  void v19[7] = 0;
  char v43 = 1;
  float v21 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v22 = *(float *)(a1 + 32);
  if (!v12 || (float)(v22 * (float)v12) < v21)
  {
    BOOL v23 = 1;
    if (v12 >= 3) {
      BOOL v23 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v12);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    else {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v12 = *(void *)(a1 + 8);
    if (*(void *)&prime > v12) {
      goto LABEL_39;
    }
    if (*(void *)&prime < v12)
    {
      unint64_t v33 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v12 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        unint64_t v33 = std::__next_prime(v33);
      }
      else
      {
        uint64_t v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2) {
          unint64_t v33 = v35;
        }
      }
      if (*(void *)&prime <= v33) {
        int8x8_t prime = (int8x8_t)v33;
      }
      if (*(void *)&prime >= v12)
      {
        unint64_t v12 = *(void *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v27 = operator new(8 * *(void *)&prime);
          CFAllocatorRef v28 = *(void **)a1;
          *(void *)a1 = v27;
          if (v28) {
            operator delete(v28);
          }
          uint64_t v29 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v29++) = 0;
          while (*(void *)&prime != v29);
          unint64_t v30 = (void *)*v18;
          if (*v18)
          {
            unint64_t v31 = v30[1];
            uint8x8_t v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(void *)&prime) {
                v31 %= *(void *)&prime;
              }
            }
            else
            {
              v31 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v3HTTPServerConnection::canceled_onQueue(this - 1) = v18;
            uint64_t v36 = (void *)*v30;
            if (*v30)
            {
              do
              {
                unint64_t v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(void *)&prime) {
                    v37 %= *(void *)&prime;
                  }
                }
                else
                {
                  v37 &= *(void *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v37))
                  {
                    *(void *)(*(void *)a1 + 8 * v37) = v30;
                    goto LABEL_64;
                  }
                  *unint64_t v30 = *v36;
                  void *v36 = **(void **)(*(void *)a1 + 8 * v37);
                  **(void **)(*(void *)a1 + 8 * v37) = v36;
                  uint64_t v36 = v30;
                }
                unint64_t v37 = v31;
LABEL_64:
                unint64_t v30 = v36;
                uint64_t v36 = (void *)*v36;
                unint64_t v31 = v37;
              }
              while (v36);
            }
          }
          unint64_t v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        unsigned __int8 v41 = *(void **)a1;
        *(void *)a1 = 0;
        if (v41) {
          operator delete(v41);
        }
        unint64_t v12 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  uint64_t v38 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
  CFIndex i = (unsigned __int8 *)v42[0];
  if (v38)
  {
    *(void *)v42[0] = *v38;
LABEL_81:
    *uint64_t v38 = i;
    goto LABEL_82;
  }
  *(void *)v42[0] = *(void *)(a1 + 16);
  *(void *)(a1 + CFRetain((char *)this - 16) = i;
  *(void *)(*(void *)a1 + 8 * v3) = v18;
  if (*(void *)i)
  {
    unint64_t v39 = *(void *)(*(void *)i + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v39 >= v12) {
        v39 %= v12;
      }
    }
    else
    {
      v39 &= v12 - 1;
    }
    uint64_t v38 = (unsigned __int8 **)(*(void *)a1 + 8 * v39);
    goto LABEL_81;
  }
LABEL_82:
  v42[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>>>>::reset[abi:nn180100]((uint64_t)v42);
  return i;
}

void sub_1842EA018(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

void *std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::find<std::reference_wrapper<HTTP2ServerPushStream const>>(void *a1, uint64_t *a2)
{
  unint64_t v4 = HTTP2ServerPushStream::Hasher::operator()(*a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  unint64_t v10 = *(void **)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  unint64_t v11 = (void *)*v10;
  if (*v10)
  {
    do
    {
      unint64_t v12 = v11[1];
      if (v12 == v6)
      {
        if (HTTP2ServerPushStream::operator==(v11[2], *a2)) {
          return v11;
        }
      }
      else
      {
        if (v8 > 1)
        {
          if (v12 >= *(void *)&v5) {
            v12 %= *(void *)&v5;
          }
        }
        else
        {
          v12 &= *(void *)&v5 - 1;
        }
        if (v12 != v9) {
          return 0;
        }
      }
      unint64_t v11 = (void *)*v11;
    }
    while (v11);
  }
  return v11;
}

unint64_t HTTP2ServerPushStream::Hasher::operator()(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 72)) {
    __assert_rtn("operator()", "HTTP2ServerPush.h", 45, "stream._promised_headers_complete");
  }
  std::string::basic_string[abi:nn180100]<0>(__p, ":path");
  unint64_t v2 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(*(void *)(a1 + 8), *(void *)(a1 + 16), (uint64_t)__p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  if (!v2) {
    __assert_rtn("operator()", "HTTP2ServerPush.h", 47, "found != stream._promised_headers.end()");
  }
  int8x8_t v5 = (uint64_t *)*((void *)v2 + 5);
  unint64_t v4 = v2 + 40;
  unint64_t v3 = v5;
  int v6 = (char)v4[23];
  if (v6 >= 0) {
    uint8x8_t v7 = (uint64_t *)v4;
  }
  else {
    uint8x8_t v7 = v3;
  }
  if (v6 >= 0) {
    unint64_t v8 = v4[23];
  }
  else {
    unint64_t v8 = *((void *)v4 + 1);
  }
  return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
}

uint64_t HTTP2ServerPushStream::operator==(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 72)) {
    BOOL v2 = *(unsigned char *)(a2 + 72) == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    __assert_rtn("operator==", "HTTP2ServerPush.h", 33, "_promised_headers_complete && other._promised_headers_complete");
  }
  if (*(unsigned char *)(a1 + 216)) {
    BOOL v3 = *(unsigned char *)(a2 + 216) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    __assert_rtn("operator==", "HTTP2ServerPush.h", 34, "_valid && other._valid");
  }
  if (*(void *)(a1 + 32) != *(void *)(a2 + 32)) {
    return 0;
  }
  unint64_t v4 = *(uint64_t **)(a1 + 24);
  if (!v4) {
    return 1;
  }
  uint64_t v5 = *(void *)(a2 + 8);
  unint64_t v6 = *(void *)(a2 + 16);
  do
  {
    uint8x8_t v7 = (const void **)(v4 + 2);
    uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(v5, v6, (uint64_t)(v4 + 2));
    if (!result) {
      break;
    }
    uint64_t v9 = result;
    uint64_t v10 = *((unsigned __int8 *)v4 + 39);
    if ((v10 & 0x80u) == 0) {
      uint64_t v11 = *((unsigned __int8 *)v4 + 39);
    }
    else {
      uint64_t v11 = v4[3];
    }
    uint64_t v12 = *(unsigned __int8 *)(result + 39);
    int v13 = (char)v12;
    if ((v12 & 0x80u) != 0) {
      uint64_t v12 = *(void *)(result + 24);
    }
    if (v11 != v12) {
      return 0;
    }
    if (v13 >= 0) {
      unint64_t v14 = (unsigned __int8 *)(result + 16);
    }
    else {
      unint64_t v14 = *(unsigned __int8 **)(result + 16);
    }
    if ((v10 & 0x80) != 0)
    {
      if (memcmp(*v7, v14, v4[3])) {
        return 0;
      }
    }
    else if (*((unsigned char *)v4 + 39))
    {
      while (*(unsigned __int8 *)v7 == *v14)
      {
        uint8x8_t v7 = (const void **)((char *)v7 + 1);
        ++v14;
        if (!--v10) {
          goto LABEL_28;
        }
      }
      return 0;
    }
LABEL_28:
    uint64_t v15 = *((unsigned __int8 *)v4 + 63);
    if ((v15 & 0x80u) == 0) {
      uint64_t v16 = *((unsigned __int8 *)v4 + 63);
    }
    else {
      uint64_t v16 = v4[6];
    }
    uint64_t v17 = *(unsigned __int8 *)(v9 + 63);
    int v18 = (char)v17;
    if ((v17 & 0x80u) != 0) {
      uint64_t v17 = *(void *)(v9 + 48);
    }
    if (v16 != v17) {
      return 0;
    }
    uint64_t v19 = (const void **)(v4 + 5);
    float v22 = *(unsigned __int8 **)(v9 + 40);
    float v21 = (unsigned __int8 *)(v9 + 40);
    uint64_t v20 = v22;
    if (v18 >= 0) {
      BOOL v23 = v21;
    }
    else {
      BOOL v23 = v20;
    }
    if ((v15 & 0x80) != 0)
    {
      if (memcmp(*v19, v23, v4[6])) {
        return 0;
      }
    }
    else if (*((unsigned char *)v4 + 63))
    {
      while (*(unsigned __int8 *)v19 == *v23)
      {
        uint64_t v19 = (const void **)((char *)v19 + 1);
        ++v23;
        if (!--v15) {
          goto LABEL_43;
        }
      }
      return 0;
    }
LABEL_43:
    unint64_t v4 = (uint64_t *)*v4;
    uint64_t result = 1;
  }
  while (v4);
  return result;
}

uint64_t ___ZN15HTTP2ServerPush9_makeRoomEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  BOOL v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + CFRelease((char *)this - 24) = "CFNetwork";
  *(void *)(a1 + 32) = 278;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = "none";
  return result;
}

void *HTTP2ServerPush::_removeStream(HTTP2ServerPush *this, int a2, int a3)
{
  unint64_t v6 = (uint64_t *)((char *)this + 48);
  uint64_t result = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((void *)this + 6, a2);
  if (!result) {
    return result;
  }
  uint64_t v8 = *((void *)result + 3);
  if (!v8) {
    return result;
  }
  CFAllocatorRef v28 = (HTTP2ServerPushStream *)*((void *)result + 3);
  uint64_t v10 = (HTTP2ServerPushStream **)*((void *)this + 3);
  uint64_t v9 = (HTTP2ServerPushStream **)*((void *)this + 4);
  if (v9 == v10) {
    goto LABEL_15;
  }
  unint64_t v11 = v9 - v10;
  int v12 = *(_DWORD *)(v8 + 172);
  while (1)
  {
    unint64_t v13 = v11 >> 1;
    unint64_t v14 = &v10[v11 >> 1];
    int v15 = *((_DWORD *)*v14 + 43);
    if (v15 >= v12) {
      break;
    }
    uint64_t v10 = v14 + 1;
    unint64_t v13 = v11 + ~v13;
LABEL_8:
    unint64_t v11 = v13;
    if (!v13) {
      goto LABEL_15;
    }
  }
  if (v12 < v15) {
    goto LABEL_8;
  }
  if (v11 >= 2)
  {
    do
    {
      unint64_t v16 = v13 >> 1;
      uint64_t v17 = &v10[v13 >> 1];
      uint64_t v19 = *v17;
      int v18 = v17 + 1;
      v13 += ~(v13 >> 1);
      if (*((_DWORD *)v19 + 43) < v12) {
        uint64_t v10 = v18;
      }
      else {
        unint64_t v13 = v16;
      }
    }
    while (v13);
  }
LABEL_15:
  CFAllocatorRef v28 = 0;
  uint64_t v20 = (uint64_t)*v10;
  if (*((_DWORD *)*v10 + 43) != a2) {
    __assert_rtn("_removeStream", "HTTP2ServerPush.cpp", 313, "(*bounds.first)->_stream_id == stream_id");
  }
  unint64_t v27 = *v10;
  float v21 = *(NSObject **)(v8 + 152);
  if (v21) {
    *((void *)this + 1) -= dispatch_data_get_size(v21);
  }
  if (*(unsigned char *)(v8 + 216) && a3 && *(unsigned char *)(v8 + 72))
  {
    std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__erase_unique<std::reference_wrapper<HTTP2ServerPushStream const>>((void *)this + 16, (uint64_t *)&v27);
    uint64_t v22 = (uint64_t)*v10 + 224;
    HTTP2ServerPushStream::_getFullURL((uint64_t)*v10 + 8, v22);
    HTTP2ServerPush::_removeFromUrlToServerPushStreamsMap((uint64_t)this, v22, v20);
    uint64_t v9 = (HTTP2ServerPushStream **)*((void *)this + 4);
  }
  BOOL v23 = v10 + 1;
  if (v10 + 1 != v9)
  {
    do
    {
      uint64_t v10 = v23;
      unint64_t v24 = v23 - 1;
      unint64_t v25 = *v23;
      *v23++ = 0;
      std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](v24, v25);
    }
    while (v23 != v9);
    uint64_t v9 = (HTTP2ServerPushStream **)*((void *)this + 4);
  }
  while (v9 != v10)
    std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](--v9, 0);
  *((void *)this + 4) = v10;
  std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::__erase_unique<int>(v6, a2);
  uint64_t result = v28;
  if (v28)
  {
    HTTP2ServerPushStream::~HTTP2ServerPushStream(v28);
    return (void *)MEMORY[0x18531B6D0](v26);
  }
  return result;
}

void sub_1842EA680(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100]((HTTP2ServerPushStream **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t HTTP2ServerPush::createNewForStreamId(HTTP2ServerPush *this, int a2, NSURLRequestCachePolicy a3, int a4)
{
  if (!a4) {
    goto LABEL_8;
  }
  int v6 = *((_DWORD *)this + 43);
  if (v6 <= a2)
  {
    if (v6 < a2)
    {
      do
      {
        std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((uint64_t)this + 176, v6, v6);
        std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((uint64_t)this + 216, v6, v6);
        ++v6;
      }
      while (a2 != v6);
    }
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((uint64_t)this + 216, a2, a2);
    *((_DWORD *)this + 43) = a2 + 1;
LABEL_8:
    operator new();
  }
  uint64_t result = std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>((uint64_t *)this + 22, a2);
  if (result) {
    goto LABEL_8;
  }
  return result;
}

void sub_1842EAF54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  BOOL v3 = va_arg(va1, HTTP2ServerPushStream *);
  std::__split_buffer<std::unique_ptr<HTTP2ServerPushStream>>::~__split_buffer((uint64_t)va1);
  std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100]((HTTP2ServerPushStream **)va, 0);
  _Unwind_Resume(a1);
}

void std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(uint64_t a1, int a2, int a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (CFIndex i = *v9; i; CFIndex i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  int v12 = operator new(0x18uLL);
  void *v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    *uint64_t v20 = v12;
    goto LABEL_39;
  }
  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + CFRetain((char *)this - 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_1842EB188(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>(uint64_t *a1, int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  unint64_t v3 = a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = a2;
    if (v2 <= a2) {
      unint64_t v5 = a2 % v2;
    }
  }
  else
  {
    unint64_t v5 = (v2 - 1) & a2;
  }
  uint64_t v6 = *a1;
  unint64_t v7 = *(void ***)(*a1 + 8 * v5);
  if (!v7) {
    return 0;
  }
  uint8x8_t v8 = (uint64_t *)*v7;
  if (!v8) {
    return 0;
  }
  unint64_t v9 = v2 - 1;
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == a2) {
      break;
    }
    if (v4.u32[0] > 1uLL)
    {
      if (v10 >= v2) {
        v10 %= v2;
      }
    }
    else
    {
      v10 &= v9;
    }
    if (v10 != v5) {
      return 0;
    }
LABEL_17:
    uint8x8_t v8 = (uint64_t *)*v8;
    if (!v8) {
      return 0;
    }
  }
  if (*((_DWORD *)v8 + 4) != a2) {
    goto LABEL_17;
  }
  if (v4.u32[0] > 1uLL)
  {
    if (v2 <= a2) {
      unint64_t v3 = a2 % v2;
    }
  }
  else
  {
    unint64_t v3 = v9 & a2;
  }
  int v12 = *(uint64_t **)(v6 + 8 * v3);
  do
  {
    float v13 = v12;
    int v12 = (uint64_t *)*v12;
  }
  while (v12 != v8);
  if (v13 == a1 + 2) {
    goto LABEL_37;
  }
  unint64_t v14 = v13[1];
  if (v4.u32[0] > 1uLL)
  {
    if (v14 >= v2) {
      v14 %= v2;
    }
  }
  else
  {
    v14 &= v9;
  }
  if (v14 != v3)
  {
LABEL_37:
    if (!*v8) {
      goto LABEL_38;
    }
    unint64_t v15 = *(void *)(*v8 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v15 >= v2) {
        v15 %= v2;
      }
    }
    else
    {
      v15 &= v9;
    }
    if (v15 != v3) {
LABEL_38:
    }
      *(void *)(v6 + 8 * v3) = 0;
  }
  uint64_t v16 = *v8;
  if (*v8)
  {
    unint64_t v17 = *(void *)(v16 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v17 >= v2) {
        v17 %= v2;
      }
    }
    else
    {
      v17 &= v9;
    }
    if (v17 != v3)
    {
      *(void *)(*a1 + 8 * v17) = v13;
      uint64_t v16 = *v8;
    }
  }
  uint64_t *v13 = v16;
  *uint8x8_t v8 = 0;
  --a1[3];
  operator delete(v8);
  return 1;
}

uint64_t std::__split_buffer<std::unique_ptr<HTTP2ServerPushStream>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + CFRetain((char *)this - 16) = i - 8;
    std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100]((HTTP2ServerPushStream **)(i - 8), 0);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void HTTP2ServerPush::addPromisedHeaderToStream(uint64_t a1, long long *a2, long long *a3, int a4)
{
  uint64_t v6 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((void *)(a1 + 48), a4);
  if (v6)
  {
    uint64_t v7 = v6[3];
    if (v7)
    {
      std::pair<std::string,std::string>::pair[abi:nn180100]<std::string&,std::string&,0>(&v8, a2, a3);
      std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::string>>(v7 + 8, (uint64_t)&v8, (uint64_t)&v8);
      if (v10 < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v8.__r_.__value_.__l.__data_);
      }
      if (DiagnosticLogging::userDiagnosticLevel(void)::onceToken != -1) {
        dispatch_once(&DiagnosticLogging::userDiagnosticLevel(void)::onceToken, &__block_literal_global_16571);
      }
      if (DiagnosticLogging::userDiagnosticLevel(void)::sChecked >= 2)
      {
        std::pair<std::string,std::string>::pair[abi:nn180100]<std::string&,std::string&,0>(&v8, a2, a3);
        std::vector<std::pair<std::string,std::string>>::emplace_back<std::pair<std::string,std::string>>((char **)(v7 + 48), (long long *)&v8);
        if (v10 < 0) {
          operator delete(__p);
        }
        if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v8.__r_.__value_.__l.__data_);
        }
      }
    }
  }
}

void sub_1842EB4C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

std::string *std::pair<std::string,std::string>::pair[abi:nn180100]<std::string&,std::string&,0>(std::string *this, long long *a2, long long *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  uint64_t v6 = this + 1;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v7 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return this;
}

void sub_1842EB554(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<std::string,std::string>>::emplace_back<std::pair<std::string,std::string>>(char **a1, long long *a2)
{
  unint64_t v4 = (unint64_t)a1[1];
  unint64_t v5 = (unint64_t)a1[2];
  if (v4 >= v5)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - (void)*a1) >> 4);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0x555555555555555) {
      abort();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)*a1) >> 4);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x555555555555555;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 > 0x555555555555555) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      float v13 = (char *)operator new(48 * v12);
    }
    else
    {
      float v13 = 0;
    }
    unint64_t v14 = &v13[48 * v9];
    *(_OWORD *)unint64_t v14 = *a2;
    *((void *)v14 + 2) = *((void *)a2 + 2);
    long long v15 = *(long long *)((char *)a2 + 24);
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    *(void *)a2 = 0;
    *((void *)a2 + HTTPServerConnection::canceled_onQueue(this - 1) = 0;
    *(_OWORD *)(v14 + CFRelease((char *)this - 24) = v15;
    *((void *)v14 + 5) = *((void *)a2 + 5);
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    unint64_t v17 = *a1;
    unint64_t v16 = (unint64_t)a1[1];
    if ((char *)v16 == *a1)
    {
      int64x2_t v21 = vdupq_n_s64(v16);
      size_t v18 = &v13[48 * v9];
    }
    else
    {
      size_t v18 = &v13[48 * v9];
      do
      {
        long long v19 = *(_OWORD *)(v16 - 48);
        *((void *)v18 - 4) = *(void *)(v16 - 32);
        *((_OWORD *)v18 - 3) = v19;
        *(void *)(v16 - 40) = 0;
        *(void *)(v16 - 32) = 0;
        *(void *)(v16 - 48) = 0;
        long long v20 = *(_OWORD *)(v16 - 24);
        *((void *)v18 - HTTPServerConnection::canceled_onQueue(this - 1) = *(void *)(v16 - 8);
        *(_OWORD *)(v18 - CFRelease((char *)this - 24) = v20;
        v18 -= 48;
        *(void *)(v16 - CFRetain((char *)this - 16) = 0;
        *(void *)(v16 - 8) = 0;
        *(void *)(v16 - CFRelease((char *)this - 24) = 0;
        v16 -= 48;
      }
      while ((char *)v16 != v17);
      int64x2_t v21 = *(int64x2_t *)a1;
    }
    std::string v8 = v14 + 48;
    *a1 = v18;
    a1[1] = v14 + 48;
    a1[2] = &v13[48 * v12];
    uint64_t v23 = v21.i64[1];
    uint64_t v22 = (void *)v21.i64[0];
    while ((void *)v23 != v22)
    {
      v23 -= 48;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(v23);
    }
    if (v22) {
      operator delete(v22);
    }
  }
  else
  {
    long long v6 = *a2;
    *(void *)(v4 + CFRetain((char *)this - 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v4 = v6;
    *((void *)a2 + HTTPServerConnection::canceled_onQueue(this - 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v7 = *(long long *)((char *)a2 + 24);
    *(void *)(v4 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(v4 + CFRelease((char *)this - 24) = v7;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    std::string v8 = (char *)(v4 + 48);
  }
  a1[1] = v8;
}

uint64_t *HTTP2ServerPush::endPromisedHeadersWithCheckTheCacheBlock(uint64_t *a1, int a2)
{
  int v2 = a2;
  v124[2] = *MEMORY[0x1E4F143B8];
  uint64_t result = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>(a1 + 6, a2);
  if (!result) {
    return result;
  }
  uint64_t v5 = result[3];
  if (!v5) {
    return 0;
  }
  *(unsigned char *)(v5 + 72) = 1;
  std::string::basic_string[abi:nn180100]<0>(&__p, ":method");
  long long v6 = (void *)(v5 + 8);
  long long v7 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>((void *)(v5 + 8), (uint64_t)&__p);
  std::string v8 = v7;
  if (SHIBYTE(v121) < 0)
  {
    operator delete(__p);
    if (!v8)
    {
LABEL_9:
      HTTP2ServerPush::_removeStream((HTTP2ServerPush *)a1, v2, 0);
      return 0;
    }
  }
  else if (!v7)
  {
    goto LABEL_9;
  }
  unint64_t v9 = (const std::string *)(v8 + 40);
  if (std::string::compare(v9, "GET") && std::string::compare(v9, "HEAD")) {
    goto LABEL_9;
  }
  uint64_t v10 = *(void *)(v5 + 248);
  BOOL v11 = v10 == 4 || v10 == 1;
  if (v10 != 1 && v10 != 4)
  {
    std::string::basic_string[abi:nn180100]<0>(&__p, "cache-control");
    float v13 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>((void *)(v5 + 8), (uint64_t)&__p);
    if (SHIBYTE(v121) < 0) {
      operator delete(__p);
    }
    if (v13)
    {
      if ((char)v13[63] < 0)
      {
        unint64_t v14 = (unsigned __int8 *)*((void *)v13 + 5);
        uint64_t v15 = *((void *)v13 + 6);
      }
      else
      {
        unint64_t v14 = v13 + 40;
        uint64_t v15 = v13[63];
      }
      if (v15 >= 9)
      {
        unint64_t v16 = &v14[v15];
        unint64_t v17 = v14;
        do
        {
          size_t v18 = (unsigned __int8 *)memchr(v17, 109, v15 - 8);
          if (!v18) {
            break;
          }
          if (*(void *)v18 == 0x3D6567612D78616DLL && v18[8] == 48)
          {
            if (v18 != v16 && v18 - v14 != -1) {
              BOOL v11 = 1;
            }
            break;
          }
          unint64_t v17 = v18 + 1;
          uint64_t v15 = v16 - v17;
        }
        while (v16 - v17 >= 9);
      }
      int8x8_t v20 = *(int8x8_t *)(v5 + 16);
      unint64_t v21 = *((void *)v13 + 1);
      uint8x8_t v22 = (uint8x8_t)vcnt_s8(v20);
      v22.i16[0] = vaddlv_u8(v22);
      if (v22.u32[0] > 1uLL)
      {
        if (v21 >= *(void *)&v20) {
          v21 %= *(void *)&v20;
        }
      }
      else
      {
        v21 &= *(void *)&v20 - 1;
      }
      uint64_t v23 = *(unsigned __int8 **)(*v6 + 8 * v21);
      do
      {
        unint64_t v24 = v23;
        uint64_t v23 = *(unsigned __int8 **)v23;
      }
      while (v23 != v13);
      if (v24 == (unsigned __int8 *)(v5 + 24)) {
        goto LABEL_54;
      }
      unint64_t v25 = *((void *)v24 + 1);
      if (v22.u32[0] > 1uLL)
      {
        if (v25 >= *(void *)&v20) {
          v25 %= *(void *)&v20;
        }
      }
      else
      {
        v25 &= *(void *)&v20 - 1;
      }
      if (v25 != v21)
      {
LABEL_54:
        if (!*(void *)v13) {
          goto LABEL_55;
        }
        unint64_t v26 = *(void *)(*(void *)v13 + 8);
        if (v22.u32[0] > 1uLL)
        {
          if (v26 >= *(void *)&v20) {
            v26 %= *(void *)&v20;
          }
        }
        else
        {
          v26 &= *(void *)&v20 - 1;
        }
        if (v26 != v21) {
LABEL_55:
        }
          *(void *)(*v6 + 8 * v2HTTPServerConnection::canceled_onQueue(this - 1) = 0;
      }
      uint64_t v27 = *(void *)v13;
      if (*(void *)v13)
      {
        unint64_t v28 = *(void *)(v27 + 8);
        if (v22.u32[0] > 1uLL)
        {
          if (v28 >= *(void *)&v20) {
            v28 %= *(void *)&v20;
          }
        }
        else
        {
          v28 &= *(void *)&v20 - 1;
        }
        if (v28 != v21)
        {
          *(void *)(*v6 + 8 * v28) = v24;
          uint64_t v27 = *(void *)v13;
        }
      }
      *(void *)unint64_t v24 = v27;
      *(void *)float v13 = 0;
      --*(void *)(v5 + 32);
      std::string __p = v13;
      uint64_t v120 = v5 + 24;
      LOBYTE(v12HTTPServerConnection::canceled_onQueue(this - 1) = 1;
      std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)&__p);
    }
  }
  uint64_t v29 = a1 + 16;
  std::string __p = (void *)v5;
  unint64_t v30 = std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::find<std::reference_wrapper<HTTP2ServerPushStream const>>(a1 + 16, (uint64_t *)&__p);
  if (!v30)
  {
    std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__emplace_unique_impl<HTTP2ServerPushStream&>(a1 + 16, v5);
    HTTP2ServerPushStream::_getFullURL(v5 + 8, v5 + 224);
    char v43 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a1 + 11), v5 + 224, v5 + 224);
    CFSetRef v44 = v43;
    CFIndex v46 = (uint64_t *)*((void *)v43 + 6);
    unint64_t v45 = *((void *)v43 + 7);
    if ((unint64_t)v46 < v45) {
      goto LABEL_174;
    }
    uint64_t v47 = *((void *)v43 + 5);
    uint64_t v48 = ((uint64_t)v46 - v47) >> 3;
    if ((unint64_t)(v48 + 1) >> 61) {
      abort();
    }
    uint64_t v49 = v45 - v47;
    uint64_t v50 = v49 >> 2;
    if (v49 >> 2 <= (unint64_t)(v48 + 1)) {
      uint64_t v50 = v48 + 1;
    }
    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v51 = v50;
    }
    if (v51) {
      unint64_t v51 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v51);
    }
    else {
      uint64_t v52 = 0;
    }
    CFTypeRef v65 = (uint64_t *)(v51 + 8 * v48);
    unint64_t v66 = v51 + 8 * v52;
    uint64_t *v65 = v5;
    CFTypeRef v67 = v65 + 1;
    CFArrayRef v69 = (char *)*((void *)v44 + 5);
    CFAllocatorRef v68 = (char *)*((void *)v44 + 6);
    if (v68 != v69)
    {
      do
      {
        uint64_t v70 = *((void *)v68 - 1);
        v68 -= 8;
        *--CFTypeRef v65 = v70;
      }
      while (v68 != v69);
LABEL_186:
      CFAllocatorRef v68 = (char *)*((void *)v44 + 5);
    }
LABEL_187:
    *((void *)v44 + 5) = v65;
    *((void *)v44 + 6) = v67;
    *((void *)v44 + 7) = v66;
    if (v68) {
      operator delete(v68);
    }
LABEL_189:
    *((void *)v44 + 6) = v67;
    return (uint64_t *)1;
  }
  uint64_t v31 = v30[2];
  int v32 = *(unsigned __int8 *)(v31 + 144);
  if (!*(unsigned char *)(v31 + 144)) {
    goto LABEL_168;
  }
  double v33 = *(double *)(v31 + 208);
  if (v33 != 0.0) {
    goto LABEL_167;
  }
  uint64_t v34 = (uint64_t)&v114;
  std::string::basic_string[abi:nn180100]<0>(&v114, ":status");
  BOOL v110 = v11;
  int v111 = v2;
  uint64_t v112 = (void *)(v5 + 8);
  uint64_t v35 = (void *)(v31 + 80);
  if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v36 = &v114;
  }
  else {
    uint64_t v36 = (std::string *)v114.__r_.__value_.__r.__words[0];
  }
  if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v114.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v114.__r_.__value_.__l.__size_;
  }
  unint64_t v38 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v36, size);
  unint64_t v39 = v38;
  unint64_t v40 = *(void *)(v31 + 88);
  uint64_t v113 = v31;
  if (v40)
  {
    uint8x8_t v41 = (uint8x8_t)vcnt_s8((int8x8_t)v40);
    v41.i16[0] = vaddlv_u8(v41);
    unint64_t v42 = v41.u32[0];
    if (v41.u32[0] > 1uLL)
    {
      uint64_t v34 = v38;
      if (v38 >= v40) {
        uint64_t v34 = v38 % v40;
      }
    }
    else
    {
      uint64_t v34 = (v40 - 1) & v38;
    }
    int v53 = *(void ***)(*v35 + 8 * v34);
    if (v53)
    {
      uint64_t v54 = (char *)*v53;
      if (*v53)
      {
        do
        {
          unint64_t v55 = *((void *)v54 + 1);
          if (v55 == v39)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v54 + 16, (unsigned __int8 *)&v114))
            {
              goto LABEL_126;
            }
          }
          else
          {
            if (v42 > 1)
            {
              if (v55 >= v40) {
                v55 %= v40;
              }
            }
            else
            {
              v55 &= v40 - 1;
            }
            if (v55 != v34) {
              break;
            }
          }
          uint64_t v54 = *(char **)v54;
        }
        while (v54);
      }
    }
    uint64_t v31 = v113;
  }
  uint64_t v54 = (char *)operator new(0x40uLL);
  uint64_t v56 = v31;
  CFRange v57 = (void *)(v31 + 96);
  std::string __p = v54;
  uint64_t v120 = (uint64_t)v57;
  *(void *)uint64_t v54 = 0;
  *((void *)v54 + HTTPServerConnection::canceled_onQueue(this - 1) = v39;
  std::string::size_type v58 = v114.__r_.__value_.__r.__words[2];
  *((_OWORD *)v54 + HTTPServerConnection::canceled_onQueue(this - 1) = *(_OWORD *)&v114.__r_.__value_.__l.__data_;
  memset(&v114, 0, sizeof(v114));
  *((void *)v54 + 4) = v58;
  *((void *)v54 + 5) = 0;
  *((void *)v54 + 6) = 0;
  *((void *)v54 + 7) = 0;
  LOBYTE(v12HTTPServerConnection::canceled_onQueue(this - 1) = 1;
  float v59 = (float)(unint64_t)(*(void *)(v56 + 104) + 1);
  float v60 = *(float *)(v56 + 112);
  if (!v40 || (float)(v60 * (float)v40) < v59)
  {
    BOOL v61 = 1;
    if (v40 >= 3) {
      BOOL v61 = (v40 & (v40 - 1)) != 0;
    }
    unint64_t v62 = v61 | (2 * v40);
    unint64_t v63 = vcvtps_u32_f32(v59 / v60);
    if (v62 <= v63) {
      size_t v64 = v63;
    }
    else {
      size_t v64 = v62;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>((uint64_t)v35, v64);
    unint64_t v40 = *(void *)(v113 + 88);
    if ((v40 & (v40 - 1)) != 0)
    {
      if (v39 >= v40) {
        uint64_t v34 = v39 % v40;
      }
      else {
        uint64_t v34 = v39;
      }
    }
    else
    {
      uint64_t v34 = (v40 - 1) & v39;
    }
  }
  uint64_t v71 = *(void **)(*v35 + 8 * v34);
  if (v71)
  {
    *(void *)uint64_t v54 = *v71;
    uint64_t v72 = v113;
  }
  else
  {
    *(void *)uint64_t v54 = *v57;
    void *v57 = v54;
    *(void *)(*v35 + 8 * v34) = v57;
    uint64_t v72 = v113;
    if (!*(void *)v54) {
      goto LABEL_125;
    }
    unint64_t v73 = *(void *)(*(void *)v54 + 8);
    if ((v40 & (v40 - 1)) != 0)
    {
      if (v73 >= v40) {
        v73 %= v40;
      }
    }
    else
    {
      v73 &= v40 - 1;
    }
    uint64_t v71 = (void *)(*v35 + 8 * v73);
  }
  *uint64_t v71 = v54;
LABEL_125:
  std::string __p = 0;
  ++*(void *)(v72 + 104);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)&__p);
LABEL_126:
  int v74 = std::stoi((const std::string *)(v54 + 40), 0, 10);
  Response = CFHTTPMessageCreateResponse((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v74, 0, @"HTTP/2.0");
  uint64_t v109 = v5;
  if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v114.__r_.__value_.__l.__data_);
  }
  uint64_t v76 = 0;
  CFTypeRef v77 = 0;
  char v78 = 0;
  std::string __p = (void *)MEMORY[0x1E4F143A8];
  uint64_t v120 = 3221225472;
  uint64_t v121 = ___ZN21HTTP2ServerPushStream18_getExpirationTimeEv_block_invoke;
  uint64_t v122 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v123 = Response;
  memset(&v118, 0, sizeof(v118));
  do
  {
    std::string::basic_string[abi:nn180100]<0>(&v114, off_1E5257EA0[v76]);
    CFTypeRef v79 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(v35, (uint64_t)&v114);
    uint64_t v80 = v79;
    if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v114.__r_.__value_.__l.__data_);
      if (!v80) {
        goto LABEL_157;
      }
    }
    else if (!v79)
    {
      goto LABEL_157;
    }
    if ((v80[39] & 0x80u) == 0) {
      size_t v81 = v80[39];
    }
    else {
      size_t v81 = *((void *)v80 + 3);
    }
    std::string::basic_string[abi:nn180100]((uint64_t)&v117, v81 + 2);
    if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      v82 = &v117;
    }
    else {
      v82 = (std::string *)v117.__r_.__value_.__r.__words[0];
    }
    if (v81)
    {
      if ((v80[39] & 0x80u) == 0) {
        uint64_t v83 = v80 + 16;
      }
      else {
        uint64_t v83 = (const void *)*((void *)v80 + 2);
      }
      memmove(v82, v83, v81);
    }
    strcpy((char *)v82 + v81, ": ");
    uint64_t v86 = (const std::string::value_type *)*((void *)v80 + 5);
    uint64_t v85 = v80 + 40;
    uint64_t v84 = v86;
    int v87 = (char)v85[23];
    if (v87 >= 0) {
      v88 = (const std::string::value_type *)v85;
    }
    else {
      v88 = v84;
    }
    if (v87 >= 0) {
      std::string::size_type v89 = v85[23];
    }
    else {
      std::string::size_type v89 = *((void *)v85 + 1);
    }
    uint64_t v90 = std::string::append(&v117, v88, v89);
    long long v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    v114.__r_.__value_.__r.__words[2] = v90->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v114.__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0;
    v90->__r_.__value_.__r.__words[2] = 0;
    v90->__r_.__value_.__r.__words[0] = 0;
    CFErrorRef v92 = std::string::append(&v114, "\r\n");
    std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
    v124[0] = v92->__r_.__value_.__l.__size_;
    *(void *)((char *)v124 + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    char v94 = HIBYTE(v92->__r_.__value_.__r.__words[2]);
    v92->__r_.__value_.__l.__size_ = 0;
    v92->__r_.__value_.__r.__words[2] = 0;
    v92->__r_.__value_.__r.__words[0] = 0;
    if (v78 < 0) {
      operator delete(v77);
    }
    v118.__r_.__value_.__r.__words[0] = v93;
    v118.__r_.__value_.__l.__size_ = v124[0];
    *(std::string::size_type *)((char *)&v118.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v124 + 7);
    *((unsigned char *)&v118.__r_.__value_.__s + 23) = v94;
    if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v114.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v117.__r_.__value_.__l.__data_);
    }
    CFTypeRef v77 = (void *)v93;
    char v78 = v94;
LABEL_157:
    ++v76;
  }
  while (v76 != 3);
  std::string::append(&v118, "\r\n");
  if ((v118.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v95 = &v118;
  }
  else {
    uint64_t v95 = (std::string *)v118.__r_.__value_.__r.__words[0];
  }
  if ((v118.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v96 = HIBYTE(v118.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v96 = v118.__r_.__value_.__l.__size_;
  }
  uint64_t appended = CFHTTPMessageAppendBytes(Response, (const UInt8 *)v95, v96);
  id v98 = CFURLResponseCreateWithHTTPResponse(appended, 0, (uint64_t)Response, 0);
  uint64_t v5 = v109;
  long long v6 = v112;
  BOOL v11 = v110;
  int v2 = v111;
  uint64_t v29 = a1 + 16;
  v114.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
  v114.__r_.__value_.__l.__size_ = 3221225472;
  v114.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN21HTTP2ServerPushStream18_getExpirationTimeEv_block_invoke_2;
  CFHTTPAuthenticationRef v115 = &__block_descriptor_40_e5_v8__0l;
  id v116 = v98;
  *(double *)(v113 + 208) = CFURLResponseGetExpirationTime(v98);
  ((void (*)(std::string *))v114.__r_.__value_.__r.__words[2])(&v114);
  if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v118.__r_.__value_.__l.__data_);
  }
  v121((uint64_t)&__p);
  double v33 = *(double *)(v113 + 208);
  uint64_t v31 = v113;
LABEL_167:
  int v32 = v33 < CFAbsoluteTimeGetCurrent();
LABEL_168:
  if ((v11 | v32))
  {
    if (*(void *)(v31 + 184) == *(void *)(v31 + 176))
    {
      HTTP2ServerPush::_removeStream((HTTP2ServerPush *)a1, *(_DWORD *)(v31 + 172), 1);
    }
    else
    {
      std::string __p = (void *)v31;
      std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__erase_unique<std::reference_wrapper<HTTP2ServerPushStream const>>(v29, (uint64_t *)&__p);
      HTTP2ServerPushStream::_getFullURL(v31 + 8, v31 + 224);
      HTTP2ServerPush::_removeFromUrlToServerPushStreamsMap((uint64_t)a1, v31 + 224, v31);
      *(unsigned char *)(v31 + 2CFRetain((char *)this - 16) = 0;
    }
    std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__emplace_unique_impl<HTTP2ServerPushStream&>(v29, v5);
    HTTP2ServerPushStream::_getFullURL((uint64_t)v6, v5 + 224);
    char v99 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::reference_wrapper<HTTP2ServerPushStream>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a1 + 11), v5 + 224, v5 + 224);
    CFSetRef v44 = v99;
    CFIndex v46 = (uint64_t *)*((void *)v99 + 6);
    unint64_t v100 = *((void *)v99 + 7);
    if ((unint64_t)v46 < v100)
    {
LABEL_174:
      *CFIndex v46 = v5;
      CFTypeRef v67 = v46 + 1;
      goto LABEL_189;
    }
    uint64_t v101 = *((void *)v99 + 5);
    uint64_t v102 = ((uint64_t)v46 - v101) >> 3;
    if ((unint64_t)(v102 + 1) >> 61) {
      abort();
    }
    uint64_t v103 = v100 - v101;
    uint64_t v104 = v103 >> 2;
    if (v103 >> 2 <= (unint64_t)(v102 + 1)) {
      uint64_t v104 = v102 + 1;
    }
    if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v105 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v105 = v104;
    }
    if (v105) {
      unint64_t v105 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v105);
    }
    else {
      uint64_t v106 = 0;
    }
    CFTypeRef v65 = (uint64_t *)(v105 + 8 * v102);
    unint64_t v66 = v105 + 8 * v106;
    uint64_t *v65 = v5;
    CFTypeRef v67 = v65 + 1;
    uint64_t v107 = (char *)*((void *)v44 + 5);
    CFAllocatorRef v68 = (char *)*((void *)v44 + 6);
    if (v68 != v107)
    {
      do
      {
        uint64_t v108 = *((void *)v68 - 1);
        v68 -= 8;
        *--CFTypeRef v65 = v108;
      }
      while (v68 != v107);
      goto LABEL_186;
    }
    goto LABEL_187;
  }
  HTTP2ServerPush::_removeStream((HTTP2ServerPush *)a1, v2, 0);
  return 0;
}

void sub_1842EC210(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,char a38,uint64_t a39,uint64_t a40)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__emplace_unique_impl<HTTP2ServerPushStream&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = operator new(0x18uLL);
  void *v4 = 0;
  v4[1] = 0;
  void v4[2] = a2;
  v4[1] = HTTP2ServerPushStream::Hasher::operator()(a2);
  unint64_t v5 = HTTP2ServerPushStream::Hasher::operator()(v4[2]);
  unint64_t v6 = v5;
  v4[1] = v5;
  unint64_t v7 = a1[1];
  if (!v7) {
    goto LABEL_17;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
  v8.i16[0] = vaddlv_u8(v8);
  unint64_t v9 = v8.u32[0];
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v10 = v5;
    if (v7 <= v5) {
      unint64_t v10 = v5 % v7;
    }
  }
  else
  {
    unint64_t v10 = (v7 - 1) & v5;
  }
  BOOL v11 = *(void **)(*a1 + 8 * v10);
  if (!v11 || (unint64_t v12 = (void *)*v11) == 0)
  {
LABEL_17:
    unint64_t v14 = a1 + 2;
    float v15 = (float)(unint64_t)(a1[3] + 1);
    float v16 = *((float *)a1 + 8);
    if (v7 && (float)(v16 * (float)v7) >= v15) {
      goto LABEL_19;
    }
    BOOL v20 = 1;
    if (v7 >= 3) {
      BOOL v20 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v7);
    unint64_t v22 = vcvtps_u32_f32(v15 / v16);
    if (v21 <= v22) {
      int8x8_t prime = (int8x8_t)v22;
    }
    else {
      int8x8_t prime = (int8x8_t)v21;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    int8x8_t v27 = (int8x8_t)a1[1];
    if (*(void *)&prime <= *(void *)&v27)
    {
      if (*(void *)&prime >= *(void *)&v27) {
        goto LABEL_19;
      }
      unint64_t v34 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (*(void *)&v27 < 3uLL || (uint8x8_t v35 = (uint8x8_t)vcnt_s8(v27), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
      {
        unint64_t v34 = std::__next_prime(v34);
      }
      else
      {
        uint64_t v36 = 1 << -(char)__clz(v34 - 1);
        if (v34 >= 2) {
          unint64_t v34 = v36;
        }
      }
      if (*(void *)&prime <= v34) {
        int8x8_t prime = (int8x8_t)v34;
      }
      if (*(void *)&prime >= *(void *)&v27) {
        goto LABEL_19;
      }
      if (!*(void *)&prime)
      {
        unint64_t v39 = (void *)*a1;
        *a1 = 0;
        if (v39) {
          operator delete(v39);
        }
        a1[1] = 0;
        goto LABEL_19;
      }
    }
    if (*(void *)&prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v28 = operator new(8 * *(void *)&prime);
    uint64_t v29 = (void *)*a1;
    *a1 = (uint64_t)v28;
    if (v29) {
      operator delete(v29);
    }
    uint64_t v30 = 0;
    a1[1] = (uint64_t)prime;
    do
      *(void *)(*a1 + 8 * v30++) = 0;
    while (*(void *)&prime != v30);
    uint64_t v31 = (void *)*v14;
    if (*v14)
    {
      unint64_t v32 = v31[1];
      uint8x8_t v33 = (uint8x8_t)vcnt_s8(prime);
      v33.i16[0] = vaddlv_u8(v33);
      if (v33.u32[0] > 1uLL)
      {
        if (v32 >= *(void *)&prime) {
          v32 %= *(void *)&prime;
        }
      }
      else
      {
        v32 &= *(void *)&prime - 1;
      }
      *(void *)(*a1 + 8 * v32) = v14;
      unint64_t v37 = (void *)*v31;
      if (*v31)
      {
        do
        {
          unint64_t v38 = v37[1];
          if (v33.u32[0] > 1uLL)
          {
            if (v38 >= *(void *)&prime) {
              v38 %= *(void *)&prime;
            }
          }
          else
          {
            v38 &= *(void *)&prime - 1;
          }
          if (v38 != v32)
          {
            if (!*(void *)(*a1 + 8 * v38))
            {
              *(void *)(*a1 + 8 * v38) = v31;
              goto LABEL_68;
            }
            *uint64_t v31 = *v37;
            *unint64_t v37 = **(void **)(*a1 + 8 * v38);
            **(void **)(*a1 + 8 * v38) = v37;
            unint64_t v37 = v31;
          }
          unint64_t v38 = v32;
LABEL_68:
          uint64_t v31 = v37;
          unint64_t v37 = (void *)*v37;
          unint64_t v32 = v38;
        }
        while (v37);
      }
    }
LABEL_19:
    int8x8_t v17 = (int8x8_t)a1[1];
    unint64_t v18 = v4[1];
    uint8x8_t v19 = (uint8x8_t)vcnt_s8(v17);
    v19.i16[0] = vaddlv_u8(v19);
    if (v19.u32[0] > 1uLL)
    {
      if (v18 >= *(void *)&v17) {
        v18 %= *(void *)&v17;
      }
    }
    else
    {
      v18 &= *(void *)&v17 - 1;
    }
    uint64_t v24 = *a1;
    unint64_t v25 = *(void **)(*a1 + 8 * v18);
    if (v25)
    {
      void *v4 = *v25;
    }
    else
    {
      void *v4 = *v14;
      void *v14 = v4;
      *(void *)(v24 + 8 * v18) = v14;
      if (!*v4)
      {
LABEL_56:
        ++a1[3];
        return;
      }
      unint64_t v26 = *(void *)(*v4 + 8);
      if (v19.u32[0] > 1uLL)
      {
        if (v26 >= *(void *)&v17) {
          v26 %= *(void *)&v17;
        }
      }
      else
      {
        v26 &= *(void *)&v17 - 1;
      }
      unint64_t v25 = (void *)(*a1 + 8 * v26);
    }
    void *v25 = v4;
    goto LABEL_56;
  }
  while (1)
  {
    unint64_t v13 = v12[1];
    if (v13 == v6) {
      break;
    }
    if (v9 > 1)
    {
      if (v13 >= v7) {
        v13 %= v7;
      }
    }
    else
    {
      v13 &= v7 - 1;
    }
    if (v13 != v10) {
      goto LABEL_17;
    }
LABEL_16:
    unint64_t v12 = (void *)*v12;
    if (!v12) {
      goto LABEL_17;
    }
  }
  if ((HTTP2ServerPushStream::operator==(v12[2], v4[2]) & 1) == 0) {
    goto LABEL_16;
  }

  operator delete(v4);
}

void sub_1842EC6D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    uint8x8_t v8 = (uint64_t *)a2;
  }
  else {
    uint8x8_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    float v15 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      float v16 = (char *)*v15;
      if (*v15)
      {
        do
        {
          unint64_t v17 = *((void *)v16 + 1);
          if (v17 == v11)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v16 + 16, (unsigned __int8 *)a2))
            {
              return v16;
            }
          }
          else
          {
            if (v14 > 1)
            {
              if (v17 >= v12) {
                v17 %= v12;
              }
            }
            else
            {
              v17 &= v12 - 1;
            }
            if (v17 != v3) {
              break;
            }
          }
          float v16 = *(char **)v16;
        }
        while (v16);
      }
    }
  }
  unint64_t v18 = (void *)(a1 + 16);
  float v16 = (char *)operator new(0x40uLL);
  v30[0] = v16;
  v30[1] = a1 + 16;
  char v31 = 0;
  *(void *)float v16 = 0;
  *((void *)v16 + HTTPServerConnection::canceled_onQueue(this - 1) = v11;
  uint8x8_t v19 = (std::string *)(v16 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((void *)v16 + 4) = *(void *)(a3 + 16);
  }
  *((void *)v16 + 5) = 0;
  *((void *)v16 + 6) = 0;
  *((void *)v16 + 7) = 0;
  char v31 = 1;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>(a1, v25);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  uint64_t v26 = *(void *)a1;
  int8x8_t v27 = *(void **)(*(void *)a1 + 8 * v3);
  if (v27)
  {
    *(void *)float v16 = *v27;
LABEL_47:
    *int8x8_t v27 = v16;
    goto LABEL_48;
  }
  *(void *)float v16 = *v18;
  *unint64_t v18 = v16;
  *(void *)(v26 + 8 * v3) = v18;
  if (*(void *)v16)
  {
    unint64_t v28 = *(void *)(*(void *)v16 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12) {
        v28 %= v12;
      }
    }
    else
    {
      v28 &= v12 - 1;
    }
    int8x8_t v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_47;
  }
LABEL_48:
  v30[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v30);
  return v16;
}

void sub_1842EC968(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HTTP2ServerPush::appendDataForStream(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  int v7 = a1 + 6;
  uint8x8_t v8 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>(a1 + 6, a3);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = v8[3];
  if (v9)
  {
    unint64_t v10 = *(NSObject **)a2;
    if (!*(void *)a2) {
      goto LABEL_28;
    }
    unint64_t v11 = a1[1];
    if (*a1 < v11)
    {
      uint64_t v12 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_20969, 2);
      if (v12)
      {
        uint64_t v13 = v12;
        if ((*(unsigned int (**)(uint64_t, const char *, void))(*(void *)v12 + 16))(v12, "h2 info server push", 0))
        {
          (*(void (**)(uint64_t, const char *, __CFString *))(*(void *)v13 + 72))(v13, "h2 psps", @"server push storage is full stored data size=%zu, max size=%zd");
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
      uint64_t v15 = a1[3];
      unint64_t v14 = (HTTP2ServerPushStream **)a1[4];
      while ((HTTP2ServerPushStream **)v15 != v14)
      {
        uint64_t v16 = *(void *)v15;
        if (*(unsigned char *)(*(void *)v15 + 168))
        {
          unint64_t v17 = *(NSObject **)(v16 + 152);
          if (v17) {
            a1[1] -= dispatch_data_get_size(v17);
          }
          std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::__erase_unique<int>(v7, *(_DWORD *)(v16 + 172));
          uint64_t v29 = v16;
          std::__hash_table<std::reference_wrapper<HTTP2ServerPushStream const>,HTTP2ServerPushStream::Hasher,HTTP2ServerPushStream::Predicate,std::allocator<std::reference_wrapper<HTTP2ServerPushStream const>>>::__erase_unique<std::reference_wrapper<HTTP2ServerPushStream const>>(a1 + 16, &v29);
          HTTP2ServerPushStream::_getFullURL(v16 + 8, v16 + 224);
          HTTP2ServerPush::_removeFromUrlToServerPushStreamsMap((uint64_t)a1, v16 + 224, v16);
          unint64_t v18 = (HTTP2ServerPushStream **)(v15 + 8);
          uint8x8_t v19 = (HTTP2ServerPushStream **)a1[4];
          if ((HTTP2ServerPushStream **)(v15 + 8) == v19)
          {
            unint64_t v14 = (HTTP2ServerPushStream **)v15;
          }
          else
          {
            do
            {
              unint64_t v14 = v18;
              float v20 = v18 - 1;
              float v21 = *v18;
              *v18++ = 0;
              std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](v20, v21);
            }
            while (v18 != v19);
            unint64_t v18 = (HTTP2ServerPushStream **)a1[4];
          }
          while (v18 != v14)
            std::unique_ptr<HTTP2ServerPushStream>::reset[abi:nn180100](--v18, 0);
          a1[4] = (uint64_t)v14;
          if (*a1 >= (unint64_t)a1[1]) {
            break;
          }
        }
        else
        {
          v15 += 8;
        }
      }
      unint64_t v10 = *(NSObject **)a2;
      if (!*(void *)a2) {
        goto LABEL_28;
      }
      unint64_t v11 = a1[1];
    }
    a1[1] = v11 + dispatch_data_get_size(v10);
    BOOL v22 = *(NSObject **)a2;
    if (!*(void *)a2)
    {
LABEL_28:
      *(unsigned char *)(v9 + 168) = a4;
      if (a4)
      {
        if (*(void *)(v9 + 184) != *(void *)(v9 + 176)) {
          HTTP2ServerPushStream::_invokeCompletionHadlers(v9, 0);
        }
        if (!*(unsigned char *)(v9 + 216)) {
          HTTP2ServerPush::_removeStream((HTTP2ServerPush *)a1, *(_DWORD *)(v9 + 172), 0);
        }
      }
      return v9;
    }
    unint64_t v23 = *(NSObject **)(v9 + 152);
    if (v23)
    {
      dispatch_data_t concat = dispatch_data_create_concat(v23, v22);
      uint64_t v25 = *(void *)(v9 + 152);
      *(void *)(v9 + 152) = concat;
      uint64_t v26 = HTTP2ServerPushStream::safe_data_deleter;
      if (!v25)
      {
LABEL_27:
        *(void *)(v9 + 160) = v26;
        goto LABEL_28;
      }
    }
    else
    {
      *(void *)a2 = 0;
      uint64_t v26 = *(void (**)(dispatch_object_t))(a2 + 8);
      uint64_t v28 = *(void *)(v9 + 152);
      *(void *)(v9 + 152) = v22;
      if (!v28) {
        goto LABEL_27;
      }
    }
    (*(void (**)(void))(v9 + 160))();
    goto LABEL_27;
  }
  return v9;
}

unsigned __int8 *HTTP2ServerPush::hasPromised(int8x8_t *a1, void *a2)
{
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  BOOL v61 = 0;
  unint64_t v62 = 0;
  uint64_t v63 = 0;
  HTTP2ServerPushStream::_getFullURL((uint64_t)a2, (uint64_t)&v61);
  if (v63 >= 0) {
    unint64_t v4 = (uint64_t *)&v61;
  }
  else {
    unint64_t v4 = (uint64_t *)v61;
  }
  if (v63 >= 0) {
    unint64_t v5 = HIBYTE(v63);
  }
  else {
    unint64_t v5 = v62;
  }
  unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v4, v5);
  int8x8_t v7 = a1[12];
  if (!*(void *)&v7) {
    goto LABEL_145;
  }
  unint64_t v8 = v6;
  uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
  v9.i16[0] = vaddlv_u8(v9);
  unint64_t v10 = v9.u32[0];
  if (v9.u32[0] > 1uLL)
  {
    unint64_t v11 = v6;
    if (v6 >= *(void *)&v7) {
      unint64_t v11 = v6 % *(void *)&v7;
    }
  }
  else
  {
    unint64_t v11 = (*(void *)&v7 - 1) & v6;
  }
  uint64_t v12 = *(unsigned __int8 ***)(*(void *)&a1[11] + 8 * v11);
  if (!v12) {
    goto LABEL_145;
  }
  uint64_t v13 = *v12;
  if (!*v12) {
    goto LABEL_146;
  }
  while (1)
  {
    unint64_t v14 = *((void *)v13 + 1);
    if (v8 == v14) {
      break;
    }
    if (v10 > 1)
    {
      if (v14 >= *(void *)&v7) {
        v14 %= *(void *)&v7;
      }
    }
    else
    {
      v14 &= *(void *)&v7 - 1;
    }
    if (v14 != v11) {
      goto LABEL_145;
    }
LABEL_22:
    uint64_t v13 = *(unsigned __int8 **)v13;
    if (!v13) {
      goto LABEL_146;
    }
  }
  if (!std::equal_to<std::string>::operator()[abi:nn180100](v13 + 16, (unsigned __int8 *)&v61)) {
    goto LABEL_22;
  }
  uint64_t v15 = (uint64_t *)*((void *)v13 + 5);
  float v59 = (uint64_t *)*((void *)v13 + 6);
  if (v15 == v59)
  {
LABEL_145:
    uint64_t v13 = 0;
    goto LABEL_146;
  }
  while (1)
  {
    float v60 = v15;
    uint64_t v13 = (unsigned __int8 *)*v15;
    int v16 = *(unsigned __int8 *)(*v15 + 216);
    int v17 = *(unsigned __int8 *)(*v15 + 72);
    BOOL v18 = !v16 || v17 == 0;
    if (!v18 && *((void *)v13 + 4)) {
      break;
    }
LABEL_143:
    uint64_t v13 = 0;
    uint64_t v15 = v60 + 1;
    if (v60 + 1 == v59) {
      goto LABEL_146;
    }
  }
  uint8x8_t v19 = (uint64_t *)*((void *)v13 + 3);
  if (v19)
  {
    while (2)
    {
      float v20 = v19 + 2;
      int v21 = *((unsigned __int8 *)v19 + 39);
      if (*((char *)v19 + 39) < 0)
      {
        uint64_t v23 = v19[3];
        if (v23 != 4)
        {
          if (v23 != 10) {
            goto LABEL_47;
          }
          BOOL v22 = *(_DWORD **)v20;
          goto LABEL_38;
        }
        int v27 = **(_DWORD **)v20;
      }
      else
      {
        if (v21 != 4)
        {
          BOOL v22 = v19 + 2;
          if (v21 != 10) {
            goto LABEL_47;
          }
LABEL_38:
          uint64_t v24 = *(void *)v22;
          int v25 = *((unsigned __int16 *)v22 + 4);
          if (v24 == 0x69726F687475613ALL && v25 == 31092) {
            goto LABEL_141;
          }
LABEL_47:
          uint64_t v28 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>(a2, (uint64_t)(v19 + 2));
          if (!v28) {
            goto LABEL_143;
          }
          uint64_t v29 = v28;
          uint64_t v30 = (std::string *)(v28 + 40);
          char v31 = (unsigned __int8 **)(v19 + 5);
          signed __int8 v32 = v28[63];
          if (v32 >= 0) {
            uint64_t v33 = v28[63];
          }
          else {
            uint64_t v33 = *((void *)v28 + 6);
          }
          uint64_t v34 = *((unsigned __int8 *)v19 + 63);
          int v35 = (char)v34;
          if ((v34 & 0x80u) != 0) {
            uint64_t v34 = v19[6];
          }
          if (v33 == v34)
          {
            if (v35 >= 0) {
              uint64_t v36 = (unsigned __int8 *)(v19 + 5);
            }
            else {
              uint64_t v36 = *v31;
            }
            if ((v28[63] & 0x80) != 0)
            {
              if (memcmp(v30->__r_.__value_.__l.__data_, v36, *((void *)v28 + 6))) {
                goto LABEL_64;
              }
            }
            else if (v28[63])
            {
              unint64_t v37 = v28 + 40;
              uint64_t v38 = v28[63];
              while (*v37 == *v36)
              {
                ++v37;
                ++v36;
                if (!--v38) {
                  goto LABEL_141;
                }
              }
              goto LABEL_64;
            }
LABEL_141:
            uint8x8_t v19 = (uint64_t *)*v19;
            if (!v19) {
              goto LABEL_146;
            }
            continue;
          }
LABEL_64:
          if ((v21 & 0x80) == 0)
          {
            unint64_t v39 = (int *)(v19 + 2);
            if (v21 != 6) {
              goto LABEL_74;
            }
LABEL_69:
            int v41 = *v39;
            int v42 = *((unsigned __int16 *)v39 + 2);
            if (v41 == 1701012321 && v42 == 29808)
            {
              if (v32 >= 0) {
                CFSetRef v44 = v30;
              }
              else {
                CFSetRef v44 = (std::string *)v30->__r_.__value_.__r.__words[0];
              }
              if (v33 >= 3)
              {
                unint64_t v45 = (char *)v44 + v33;
                CFIndex v46 = v44;
                do
                {
                  uint64_t v47 = (char *)memchr(v46, 42, v33 - 2);
                  if (!v47) {
                    break;
                  }
                  if (*(_WORD *)v47 == 12074 && v47[2] == 42)
                  {
                    if (v47 != v45 && v47 - (char *)v44 != -1) {
                      goto LABEL_141;
                    }
                    break;
                  }
                  CFIndex v46 = (std::string *)(v47 + 1);
                  uint64_t v33 = v45 - (char *)v46;
                }
                while (v45 - (char *)v46 >= 3);
              }
              uint64_t v88 = 0;
              std::string::size_type v89 = &v88;
              uint64_t v90 = 0x2020000000;
              char v91 = 0;
              uint64_t v79 = 0;
              uint64_t v80 = &v79;
              uint64_t v81 = 0x5812000000;
              v82 = __Block_byref_object_copy__20925;
              uint64_t v83 = __Block_byref_object_dispose__20926;
              long long v84 = 0u;
              long long v85 = 0u;
              uint64_t v86 = 0;
              int v87 = 1065353216;
              std::string::basic_string[abi:nn180100]<0>(__p, ",; \t");
              if ((char)v29[63] < 0) {
                std::string::__init_copy_ctor_external(&v76, *((const std::string::value_type **)v29 + 5), *((void *)v29 + 6));
              }
              else {
                std::string v76 = *v30;
              }
              aBlocCFIndex k = MEMORY[0x1E4F143A8];
              uint64_t v72 = 3221225472;
              unint64_t v73 = ___Z34__HTTP2ServerPushMatchAcceptHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke;
              int v74 = &unk_1E5257E58;
              CFIndex v75 = &v79;
              unsigned int v97 = 0;
              uint64_t v95 = &unk_1ECFA5FD0;
              std::string::size_type v96 = _Block_copy(&aBlock);
              unsigned int v97 = &v95;
              split((uint64_t)&v76, (unsigned __int8 *)__p, (uint64_t)&v95);
              std::__function::__value_func<BOOL ()(std::string const&)>::~__value_func[abi:nn180100](&v95);
              if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v76.__r_.__value_.__l.__data_);
              }
              if (*((char *)v19 + 63) < 0)
              {
                std::string::__init_copy_ctor_external(&v70, (const std::string::value_type *)v19[5], v19[6]);
              }
              else
              {
                *(_OWORD *)&v70.__r_.__value_.__l.__data_ = *(_OWORD *)v31;
                v70.__r_.__value_.__r.__words[2] = v19[7];
              }
              uint64_t v64 = MEMORY[0x1E4F143A8];
              uint64_t v65 = 3221225472;
              unint64_t v66 = ___Z34__HTTP2ServerPushMatchAcceptHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke_2;
              CFTypeRef v67 = &unk_1E5257E80;
              CFAllocatorRef v68 = &v79;
              CFArrayRef v69 = &v88;
              char v94 = 0;
              CFErrorRef v92 = &unk_1ECFA5FD0;
              std::string::size_type v93 = _Block_copy(&v64);
              char v94 = &v92;
              split((uint64_t)&v70, (unsigned __int8 *)__p, (uint64_t)&v92);
              std::__function::__value_func<BOOL ()(std::string const&)>::~__value_func[abi:nn180100](&v92);
              if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v70.__r_.__value_.__l.__data_);
              }
              int v49 = *((unsigned __int8 *)v89 + 24);
              if (v78 < 0) {
                operator delete(__p[0]);
              }
              _Block_object_dispose(&v79, 8);
              std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table((uint64_t)&v84 + 8);
              _Block_object_dispose(&v88, 8);
              if (v49) {
                goto LABEL_141;
              }
              int v21 = *((unsigned __int8 *)v19 + 39);
              if ((v21 & 0x80) != 0) {
                goto LABEL_104;
              }
LABEL_74:
              if (v21 != 15) {
                goto LABEL_143;
              }
            }
            else
            {
              if ((v21 & 0x80) == 0) {
                goto LABEL_74;
              }
LABEL_104:
              uint64_t v40 = v19[3];
LABEL_105:
              if (v40 != 15) {
                goto LABEL_143;
              }
              float v20 = *(_DWORD **)v20;
            }
            if (*(void *)v20 != 0x652D747065636361 || *(void *)((char *)v20 + 7) != 0x676E69646F636E65) {
              goto LABEL_143;
            }
            uint64_t v51 = v29[63];
            if ((v51 & 0x80u) == 0) {
              uint64_t v52 = v29[63];
            }
            else {
              uint64_t v52 = *((void *)v29 + 6);
            }
            uint64_t v53 = *((unsigned __int8 *)v19 + 63);
            int v54 = (char)v53;
            if ((v53 & 0x80u) != 0) {
              uint64_t v53 = v19[6];
            }
            if (v52 == v53)
            {
              if (v54 >= 0) {
                unint64_t v55 = (unsigned __int8 *)(v19 + 5);
              }
              else {
                unint64_t v55 = *v31;
              }
              if ((v51 & 0x80) != 0)
              {
                if (!memcmp(v30->__r_.__value_.__l.__data_, v55, *((void *)v29 + 6))) {
                  goto LABEL_141;
                }
              }
              else
              {
                if (!v29[63]) {
                  goto LABEL_141;
                }
                uint64_t v56 = v30;
                while (v56->__r_.__value_.__s.__data_[0] == *v55)
                {
                  uint64_t v56 = (std::string *)((char *)v56 + 1);
                  ++v55;
                  if (!--v51) {
                    goto LABEL_141;
                  }
                }
              }
            }
            uint64_t v88 = 0;
            std::string::size_type v89 = &v88;
            uint64_t v90 = 0x2020000000;
            char v91 = 1;
            uint64_t v79 = 0;
            uint64_t v80 = &v79;
            uint64_t v81 = 0x5812000000;
            v82 = __Block_byref_object_copy__5;
            uint64_t v83 = __Block_byref_object_dispose__6;
            long long v84 = 0u;
            long long v85 = 0u;
            uint64_t v86 = 0;
            int v87 = 1065353216;
            std::string::basic_string[abi:nn180100]<0>(__p, ", \t");
            if ((char)v29[63] < 0) {
              std::string::__init_copy_ctor_external(&v76, *((const std::string::value_type **)v29 + 5), *((void *)v29 + 6));
            }
            else {
              std::string v76 = *v30;
            }
            aBlocCFIndex k = MEMORY[0x1E4F143A8];
            uint64_t v72 = 3221225472;
            unint64_t v73 = ___Z42__HTTP2ServerPushMatchAcceptEncodingHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke;
            int v74 = &unk_1E5257E58;
            CFIndex v75 = &v79;
            unsigned int v97 = 0;
            uint64_t v95 = &unk_1ECFA5FD0;
            std::string::size_type v96 = _Block_copy(&aBlock);
            unsigned int v97 = &v95;
            split((uint64_t)&v76, (unsigned __int8 *)__p, (uint64_t)&v95);
            std::__function::__value_func<BOOL ()(std::string const&)>::~__value_func[abi:nn180100](&v95);
            if (SHIBYTE(v76.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v76.__r_.__value_.__l.__data_);
            }
            if (*((char *)v19 + 63) < 0)
            {
              std::string::__init_copy_ctor_external(&v70, (const std::string::value_type *)v19[5], v19[6]);
            }
            else
            {
              *(_OWORD *)&v70.__r_.__value_.__l.__data_ = *(_OWORD *)v31;
              v70.__r_.__value_.__r.__words[2] = v19[7];
            }
            uint64_t v64 = MEMORY[0x1E4F143A8];
            uint64_t v65 = 3221225472;
            unint64_t v66 = ___Z42__HTTP2ServerPushMatchAcceptEncodingHeaderRKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES7__block_invoke_2;
            CFTypeRef v67 = &unk_1E5257E80;
            CFAllocatorRef v68 = &v79;
            CFArrayRef v69 = &v88;
            char v94 = 0;
            CFErrorRef v92 = &unk_1ECFA5FD0;
            std::string::size_type v93 = _Block_copy(&v64);
            char v94 = &v92;
            split((uint64_t)&v70, (unsigned __int8 *)__p, (uint64_t)&v92);
            std::__function::__value_func<BOOL ()(std::string const&)>::~__value_func[abi:nn180100](&v92);
            if (SHIBYTE(v70.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v70.__r_.__value_.__l.__data_);
            }
            int v57 = *((unsigned __int8 *)v89 + 24);
            if (v78 < 0) {
              operator delete(__p[0]);
            }
            _Block_object_dispose(&v79, 8);
            std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v84 + 8);
            _Block_object_dispose(&v88, 8);
            if (!v57) {
              goto LABEL_143;
            }
            goto LABEL_141;
          }
          uint64_t v40 = v19[3];
          if (v40 == 6)
          {
            unint64_t v39 = *(int **)v20;
            goto LABEL_69;
          }
          goto LABEL_105;
        }
        int v27 = *v20;
      }
      break;
    }
    if (v27 != 1953722216) {
      goto LABEL_47;
    }
    goto LABEL_141;
  }
LABEL_146:
  if (SHIBYTE(v63) < 0) {
    operator delete(v61);
  }
  return v13;
}

void sub_1842ED5A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52,char a53)
{
  if (a52 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a53, 8);
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table(a16);
  _Block_object_dispose((const void *)(v53 - 232), 8);
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(a1);
}

void *HTTP2ServerPush::removeAsRefusedStream(HTTP2ServerPush *this, int a2)
{
  unint64_t v4 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((void *)this + 6, a2);
  if (v4)
  {
    uint64_t v5 = v4[3];
    if (v5) {
      HTTP2ServerPushStream::_invokeCompletionHadlers(v5, 7);
    }
  }

  return HTTP2ServerPush::_removeStream(this, a2, 1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>>>::operator()[abi:nn180100](char a1, void *__p)
{
  if (a1)
  {
    unint64_t v3 = (std::__shared_weak_count *)__p[4];
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t __Block_byref_object_copy__39(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  unint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + ++*(void *)(this + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + ++*(void *)(this + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *unint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__40(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table(a1 + 48);
}

void ___ZN15HTTP2ServerPush24getFramerForHTTP3RequestERK11HTTP3FieldsU13block_pointerFvNSt3__110shared_ptrI11HTTP3FramerEEbE_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3, size_t __len, unsigned int a5, unsigned int a6)
{
  v62[2] = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:nn180100](&__dst, (void *)(a2 + a3), __len);
  std::string::basic_string[abi:nn180100](&__p, (void *)(a2 + a5), a6);
  uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v12 = (void *)(v11 + 48);
  uint64_t v13 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::find<std::string>((void *)(v11 + 48), (uint64_t)&__dst);
  if (v13)
  {
    unint64_t v14 = v13;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      if (__dst.__r_.__value_.__l.__size_ == 6)
      {
        p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
LABEL_9:
        unsigned int v16 = 1668247403;
        unsigned int v17 = bswap32(p_dst->__r_.__value_.__l.__data_);
        if (v17 == 1668247403
          && (v17 = bswap32(WORD2(p_dst->__r_.__value_.__r.__words[0])) >> 16, unsigned int v16 = 26981, v17 == 26981))
        {
          int v18 = 0;
        }
        else if (v17 < v16)
        {
          int v18 = -1;
        }
        else
        {
          int v18 = 1;
        }
        if (v18) {
          uint8x8_t v19 = ", ";
        }
        else {
          uint8x8_t v19 = "; ";
        }
LABEL_19:
        std::string::basic_string[abi:nn180100]<0>(&v57, v19);
        if ((v14[63] & 0x80u) == 0) {
          size_t v20 = v14[63];
        }
        else {
          size_t v20 = *((void *)v14 + 6);
        }
        if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v57.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v57.__r_.__value_.__l.__size_;
        }
        BOOL v22 = &v61;
        std::string::basic_string[abi:nn180100]((uint64_t)&v61, size + v20);
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          BOOL v22 = (std::string *)v61.__r_.__value_.__r.__words[0];
        }
        if (v20)
        {
          if ((v14[63] & 0x80u) == 0) {
            uint64_t v23 = v14 + 40;
          }
          else {
            uint64_t v23 = (const void *)*((void *)v14 + 5);
          }
          memmove(v22, v23, v20);
        }
        if (size)
        {
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v24 = &v57;
          }
          else {
            uint64_t v24 = (std::string *)v57.__r_.__value_.__r.__words[0];
          }
          memmove((char *)v22 + v20, v24, size);
        }
        v22->__r_.__value_.__s.__data_[v20 + size] = 0;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v26 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v26 = __p.__r_.__value_.__l.__size_;
        }
        int v27 = std::string::append(&v61, (const std::string::value_type *)p_p, v26);
        std::string::size_type v28 = v27->__r_.__value_.__r.__words[0];
        v62[0] = v27->__r_.__value_.__l.__size_;
        *(void *)((char *)v62 + 7) = *(std::string::size_type *)((char *)&v27->__r_.__value_.__r.__words[1] + 7);
        char v29 = HIBYTE(v27->__r_.__value_.__r.__words[2]);
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        uint64_t v30 = std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(*(void *)(*(void *)(a1 + 32) + 8) + 48, (uint64_t)&__dst, (uint64_t)&__dst);
        char v31 = v30;
        if (v30[63] < 0) {
          operator delete(*((void **)v30 + 5));
        }
        uint64_t v32 = v62[0];
        *((void *)v31 + 5) = v28;
        *((void *)v31 + 6) = v32;
        *(void *)(v31 + 55) = *(void *)((char *)v62 + 7);
        v31[63] = v29;
        if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v61.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
        {
          uint64_t v33 = (void *)v57.__r_.__value_.__r.__words[0];
          goto LABEL_103;
        }
        goto LABEL_104;
      }
    }
    else if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) == 6)
    {
      p_dst = &__dst;
      goto LABEL_9;
    }
    uint8x8_t v19 = ", ";
    goto LABEL_19;
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v57, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v57 = __dst;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v58, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string v58 = __p;
  }
  long long v34 = *(_OWORD *)&v57.__r_.__value_.__l.__data_;
  int v56 = SHIBYTE(v57.__r_.__value_.__r.__words[2]);
  if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v35 = &v57;
  }
  else {
    int v35 = (std::string *)v57.__r_.__value_.__r.__words[0];
  }
  if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v36 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v36 = v57.__r_.__value_.__l.__size_;
  }
  unint64_t v37 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v35, v36);
  unint64_t v38 = v37;
  unint64_t v39 = *(void *)(v11 + 56);
  if (!v39) {
    goto LABEL_76;
  }
  uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v39);
  v40.i16[0] = vaddlv_u8(v40);
  unint64_t v41 = v40.u32[0];
  if (v40.u32[0] > 1uLL)
  {
    unint64_t v6 = v37;
    if (v37 >= v39) {
      unint64_t v6 = v37 % v39;
    }
  }
  else
  {
    unint64_t v6 = (v39 - 1) & v37;
  }
  int v42 = *(unsigned __int8 ***)(*v12 + 8 * v6);
  if (!v42 || (char v43 = *v42) == 0)
  {
LABEL_76:
    unint64_t v45 = (char *)operator new(0x40uLL);
    CFIndex v46 = (void *)(v11 + 64);
    v61.__r_.__value_.__r.__words[0] = (std::string::size_type)v45;
    v61.__r_.__value_.__l.__size_ = v11 + 64;
    v61.__r_.__value_.__s.__data_[16] = 0;
    uint64_t v47 = (std::string *)(v45 + 16);
    *(void *)unint64_t v45 = 0;
    *((void *)v45 + HTTPServerConnection::canceled_onQueue(this - 1) = v38;
    if (v56 < 0)
    {
      std::string::__init_copy_ctor_external(v47, (const std::string::value_type *)v34, *((std::string::size_type *)&v34 + 1));
    }
    else
    {
      *(_OWORD *)&v47->__r_.__value_.__l.__data_ = *(_OWORD *)&v57.__r_.__value_.__l.__data_;
      *((void *)v45 + 4) = *((void *)&v57.__r_.__value_.__l + 2);
    }
    *(std::string *)(v45 + 40) = v58;
    memset(&v58, 0, sizeof(v58));
    v61.__r_.__value_.__s.__data_[16] = 1;
    float v48 = (float)(unint64_t)(*(void *)(v11 + 72) + 1);
    float v49 = *(float *)(v11 + 80);
    if (!v39 || (float)(v49 * (float)v39) < v48)
    {
      BOOL v50 = 1;
      if (v39 >= 3) {
        BOOL v50 = (v39 & (v39 - 1)) != 0;
      }
      unint64_t v51 = v50 | (2 * v39);
      unint64_t v52 = vcvtps_u32_f32(v48 / v49);
      if (v51 <= v52) {
        size_t v53 = v52;
      }
      else {
        size_t v53 = v51;
      }
      std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>(v11 + 48, v53);
      unint64_t v39 = *(void *)(v11 + 56);
      if ((v39 & (v39 - 1)) != 0)
      {
        if (v38 >= v39) {
          unint64_t v6 = v38 % v39;
        }
        else {
          unint64_t v6 = v38;
        }
      }
      else
      {
        unint64_t v6 = (v39 - 1) & v38;
      }
    }
    int v54 = *(void **)(*v12 + 8 * v6);
    if (v54)
    {
      *(void *)unint64_t v45 = *v54;
    }
    else
    {
      *(void *)unint64_t v45 = *v46;
      *CFIndex v46 = v45;
      *(void *)(*v12 + 8 * v6) = v46;
      if (!*(void *)v45)
      {
LABEL_100:
        v61.__r_.__value_.__r.__words[0] = 0;
        ++*(void *)(v11 + 72);
        std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)&v61);
        goto LABEL_101;
      }
      unint64_t v55 = *(void *)(*(void *)v45 + 8);
      if ((v39 & (v39 - 1)) != 0)
      {
        if (v55 >= v39) {
          v55 %= v39;
        }
      }
      else
      {
        v55 &= v39 - 1;
      }
      int v54 = (void *)(*v12 + 8 * v55);
    }
    *int v54 = v45;
    goto LABEL_100;
  }
  while (1)
  {
    unint64_t v44 = *((void *)v43 + 1);
    if (v44 == v38) {
      break;
    }
    if (v41 > 1)
    {
      if (v44 >= v39) {
        v44 %= v39;
      }
    }
    else
    {
      v44 &= v39 - 1;
    }
    if (v44 != v6) {
      goto LABEL_76;
    }
LABEL_75:
    char v43 = *(unsigned __int8 **)v43;
    if (!v43) {
      goto LABEL_76;
    }
  }
  if (!std::equal_to<std::string>::operator()[abi:nn180100](v43 + 16, (unsigned __int8 *)&v57)) {
    goto LABEL_75;
  }
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v58.__r_.__value_.__l.__data_);
  }
LABEL_101:
  if (v56 < 0)
  {
    uint64_t v33 = (void *)v34;
LABEL_103:
    operator delete(v33);
  }
LABEL_104:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_1842EDD7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>>>::__erase_unique<int>(void *a1, int a2)
{
  unint64_t v3 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>(a1, a2);
  if (v3)
  {
    int8x8_t v4 = (int8x8_t)a1[1];
    unint64_t v5 = v3[1];
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      if (v5 >= *(void *)&v4) {
        v5 %= *(void *)&v4;
      }
    }
    else
    {
      v5 &= *(void *)&v4 - 1;
    }
    unint64_t v7 = *(uint64_t **)(*a1 + 8 * v5);
    do
    {
      unint64_t v8 = v7;
      unint64_t v7 = (uint64_t *)*v7;
    }
    while (v7 != v3);
    if (v8 == a1 + 2) {
      goto LABEL_20;
    }
    unint64_t v9 = v8[1];
    if (v6.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v4) {
        v9 %= *(void *)&v4;
      }
    }
    else
    {
      v9 &= *(void *)&v4 - 1;
    }
    if (v9 != v5)
    {
LABEL_20:
      if (!*v3) {
        goto LABEL_21;
      }
      unint64_t v10 = *(void *)(*v3 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(void *)&v4) {
          v10 %= *(void *)&v4;
        }
      }
      else
      {
        v10 &= *(void *)&v4 - 1;
      }
      if (v10 != v5) {
LABEL_21:
      }
        *(void *)(*a1 + 8 * v5) = 0;
    }
    uint64_t v11 = *v3;
    if (*v3)
    {
      unint64_t v12 = *(void *)(v11 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v12 >= *(void *)&v4) {
          v12 %= *(void *)&v4;
        }
      }
      else
      {
        v12 &= *(void *)&v4 - 1;
      }
      if (v12 != v5)
      {
        *(void *)(*a1 + 8 * v12) = v8;
        uint64_t v11 = *v3;
      }
    }
    *unint64_t v8 = v11;
    *unint64_t v3 = 0;
    --a1[3];
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>>>::operator()[abi:nn180100](1, v3);
  }
}

void ___ZN15HTTP2ServerPush24getFramerForHTTP3RequestERK11HTTP3FieldsU13block_pointerFvNSt3__110shared_ptrI11HTTP3FramerEEbE_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>((void *)(v2 + 256), *(_DWORD *)(a1 + 48));
  if (v3)
  {
    int8x8_t v4 = v3;
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v7 = v4[3];
    uint8x8_t v6 = (std::__shared_weak_count *)v4[4];
    uint64_t v10 = v7;
    uint64_t v11 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v8 = *(_DWORD *)(v2 + 168);
    if (v8 > 2147483597 || v8 - *(_DWORD *)(v2 + 172) + *(_DWORD *)(v2 + 200) + *(_DWORD *)(v2 + 72) > 49)
    {
      uint64_t v9 = 0;
    }
    else
    {
      *(_DWORD *)(v2 + 168) = v8 + 50;
      uint64_t v9 = 1;
    }
    (*(void (**)(uint64_t, uint64_t *, uint64_t))(v5 + 16))(v5, &v10, v9);
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v11);
    }
    std::__hash_table<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>>>::__erase_unique<int>((void *)(v2 + 256), *(_DWORD *)(a1 + 48));
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
  }
}

void sub_1842EE09C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:nn180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void __CFNReportRedirectSymptom(double a1)
{
  v19[19] = *MEMORY[0x1E4F143B8];
  gotLoadHelper_x8__symptom_framework_init(a1);
  if (*(void *)(v3 + 3312)) {
    BOOL v4 = v1 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    CFURLRef v5 = v2;
    CFStringRef v6 = CFURLCopyNetLocation(v1);
    CFStringRef v7 = CFURLCopyNetLocation(v5);
    CFStringRef v8 = v7;
    if (v6 && v7)
    {
      if (CFStringCompare(v6, v7, 1uLL))
      {
        v20.socklen_t length = CFStringGetLength(v8);
        v20.id location = 0;
        if (!CFStringFindWithOptions(v8, v6, v20, 1uLL, 0))
        {
          v19[0] = off_1ECF9A530;
          v19[1] = CFRetain(v6);
          void v19[2] = 0;
          v19[3] = 0;
          v18[0] = off_1ECF9A530;
          v18[1] = CFRetain(v8);
          v18[2] = 0;
          void v18[3] = 0;
          CString = (const char *)AutoString::getCString((AutoString *)v19);
          uint64_t v10 = AutoString::getCString((AutoString *)v18);
          if (CString)
          {
            unint64_t v12 = (const char *)v10;
            if (v10)
            {
              if (getSymptomHandle(void)::sInitSymptomFramework != -1) {
                dispatch_once(&getSymptomHandle(void)::sInitSymptomFramework, &__block_literal_global_21042);
              }
              symptom_new_delayInitStub(v11);
              getpid();
              symptom_set_qualifier_delayInitStub(v13);
              symptom_set_qualifier_delayInitStub(v14);
              strlen(CString);
              symptom_set_additional_digest_delayInitStub(v15);
              strlen(v12);
              symptom_set_additional_digest_delayInitStub(v16);
              symptom_send_delayInitStub(v17);
            }
          }
          AutoString::~AutoString((AutoString *)v18);
          AutoString::~AutoString((AutoString *)v19);
        }
      }
    }
    else if (!v6)
    {
      goto LABEL_17;
    }
    CFRelease(v6);
LABEL_17:
    if (v8) {
      CFRelease(v8);
    }
  }
}

void sub_1842EE2E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void ___ZL16getSymptomHandlev_block_invoke(double a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  gotLoadHelper_x8__symptom_framework_init(a1);
  if (*(void *)(v1 + 3312))
  {
    metricLog = (uint64_t)os_log_create("com.apple.symptomsd", "metricstream");
    if (configureLogQueue(void)::sInitLogQueue != -1) {
      dispatch_once(&configureLogQueue(void)::sInitLogQueue, &__block_literal_global_34_21046);
    }
    getSymptomHandle(void)::sSymptomReporter = symptom_framework_init_delayInitStub(v2);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    uint64_t v3 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      int v4 = 134217984;
      uint64_t v5 = getSymptomHandle(void)::sSymptomReporter;
      _os_log_debug_impl(&dword_184085000, v3, OS_LOG_TYPE_DEBUG, "Initialized symptom reporter %p", (uint8_t *)&v4, 0xCu);
    }
  }
}

dispatch_queue_t ___ZL17configureLogQueuev_block_invoke()
{
  uint64_t v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t result = dispatch_queue_create("metricstream_queue", v0);
  logQueue = (uint64_t)result;
  return result;
}

void __CFNReportSSLSymptom(uint64_t a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
  }
  int v4 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    int v13 = 134218240;
    uint64_t v14 = a1;
    __int16 v15 = 1024;
    int v16 = a2;
    _os_log_debug_impl(&dword_184085000, v4, OS_LOG_TYPE_DEBUG, "Sending SSL symptom [%ld:%d]", (uint8_t *)&v13, 0x12u);
  }
  double Helper_x8__symptom_framework_init = gotLoadHelper_x8__symptom_framework_init(v5);
  if (*(void *)(v7 + 3312))
  {
    ++__CFNReportSSLSymptom::sSSLSymptomsReported;
    if (getSymptomHandle(void)::sInitSymptomFramework != -1) {
      dispatch_once(&getSymptomHandle(void)::sInitSymptomFramework, &__block_literal_global_21042);
    }
    symptom_new_delayInitStub(Helper_x8__symptom_framework_init);
    symptom_set_qualifier_delayInitStub(v8);
    symptom_set_qualifier_delayInitStub(v9);
    symptom_set_qualifier_delayInitStub(v10);
    symptom_set_qualifier_delayInitStub(v11);
    symptom_send_delayInitStub(v12);
  }
}

void __CFNPopulateTransactionMetrics(void *a1, NSMutableDictionary *a2)
{
  int v4 = (void *)[objc_alloc(MEMORY[0x1E4F29128]) initWithUUIDBytes:a1 + 10];
  double v5 = (void *)[objc_alloc(MEMORY[0x1E4F29128]) initWithUUIDBytes:a1 + 8];
  if (v4 && ![(NSMutableDictionary *)a2 objectForKeyedSubscript:@"taskUUID"])
  {
    -[NSMutableDictionary setValue:forKey:](a2, "setValue:forKey:", [v4 UUIDString], @"taskUUID");
    if (!v5) {
      goto LABEL_7;
    }
  }
  else if (!v5)
  {
    goto LABEL_7;
  }
  if (![(NSMutableDictionary *)a2 objectForKeyedSubscript:@"activityUUID"]) {
    -[NSMutableDictionary setValue:forKey:](a2, "setValue:forKey:", [v5 UUIDString], @"activityUUID");
  }
LABEL_7:
  id v11 = (id)objc_msgSend((id)-[NSMutableDictionary objectForKey:](a2, "objectForKey:", @"transactionMetrics"), "mutableCopy");
  if (a1[7])
  {
    unint64_t v6 = 0;
    uint64_t v7 = (char *)(a1 + 19);
    do
    {
      if (v11 && [v11 count] > v6)
      {
        double v8 = (void *)[objc_alloc(MEMORY[0x1E4F29128]) initWithUUIDBytes:v7];
        double v9 = objc_msgSend((id)objc_msgSend(v11, "objectAtIndex:", v6), "mutableCopy");
        double v10 = v9;
        if (v8 && ![v9 objectForKey:@"connectionUUID"])
        {
          objc_msgSend(v10, "setValue:forKey:", objc_msgSend(v8, "UUIDString"), @"connectionUUID");
          [v11 replaceObjectAtIndex:v6 withObject:v10];
          [(NSMutableDictionary *)a2 setValue:v11 forKey:@"transactionMetrics"];
        }
      }
      ++v6;
      v7 += 120;
    }
    while (a1[7] > v6);
  }
}

void ___Z28__CFNReportMetricsToSymptomsPvm_block_invoke(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if ([MEMORY[0x1E4F28D90] isValidJSONObject:*(void *)(a1 + 32)])
  {
    uint64_t v7 = 0;
    uint64_t v2 = [MEMORY[0x1E4F28D90] dataWithJSONObject:*(void *)(a1 + 32) options:0 error:&v7];
    if (!v7)
    {
      uint64_t v3 = (void *)v2;
      if (v2)
      {
        int v4 = metricLog;
        if (os_log_type_enabled((os_log_t)metricLog, OS_LOG_TYPE_DEFAULT))
        {
          int v5 = [v3 length];
          uint64_t v6 = [v3 bytes];
          *(_DWORD *)int buf = 68157954;
          int v9 = v5;
          __int16 v10 = 2082;
          uint64_t v11 = v6;
          _os_log_impl(&dword_184085000, v4, OS_LOG_TYPE_DEFAULT, "%{public}.*s", buf, 0x12u);
        }
      }
    }
  }
}

void ___Z30__CFNReportNetworkScoreMetricsPvmPK10__CFStringjj_block_invoke(void *a1)
{
  id v17 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  [v17 setValue:@"HTTP_NETWORKSCORE_DATA" forKey:@"name"];
  [v17 setValue:a1[4] forKey:@"HTTP_NETWORKSCORE_DATA"];
  [v17 setValue:a1[5] forKey:@"BundleID"];
  id v2 = objc_alloc_init(MEMORY[0x1E4F28C10]);
  [v2 setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZZZZZ"];
  uint64_t v3 = objc_msgSend(v2, "stringFromDate:", objc_msgSend(MEMORY[0x1E4F1C9C8], "now"));

  [v17 setValue:v3 forKey:@"METRIC_DATE"];
  [(id)networkScoreMetrics addObject:v17];
  if ((unint64_t)[(id)networkScoreMetrics count] >= 2)
  {
    uint64_t v4 = a1[6];
    int v5 = (void *)logQueue;
    id v6 = (id)networkScoreMetrics;
    id v7 = v5;
    double v8 = v7;
    if (v4)
    {
      int v9 = *(void **)(v4 + 8);
      if (!v9)
      {
        id v10 = v7;
        uint64_t v11 = [objc_alloc(MEMORY[0x1E4F29268]) initWithMachServiceName:@"com.apple.networkscored" options:4096];
        uint64_t v12 = *(void **)(v4 + 8);
        *(void *)(v4 + 8) = v11;

        int v13 = [MEMORY[0x1E4F29280] interfaceWithProtocol:&unk_1ECFE96E8];
        [*(id *)(v4 + 8) setRemoteObjectInterface:v13];

        [*(id *)(v4 + 8) setInterruptionHandler:&__block_literal_global_8456];
        aBlocCFIndex k = MEMORY[0x1E4F143A8];
        uint64_t v19 = 3221225472;
        CFRange v20 = __48____NSCFNetworkScoreReporting_createConnection___block_invoke_4;
        int v21 = &unk_1E5258228;
        uint64_t v22 = v4;
        uint64_t v14 = _Block_copy(&aBlock);
        [*(id *)(v4 + 8) setInvalidationHandler:v14];
        [*(id *)(v4 + 8) _setQueue:v10];
        [*(id *)(v4 + 8) activate];

        int v9 = *(void **)(v4 + 8);
      }
      id v15 = v9;
      aBlocCFIndex k = MEMORY[0x1E4F143A8];
      uint64_t v19 = 3221225472;
      CFRange v20 = __49____NSCFNetworkScoreReporting_sendMetrics_queue___block_invoke;
      int v21 = &unk_1E5255010;
      uint64_t v22 = v4;
      int v16 = [v15 remoteObjectProxyWithErrorHandler:&aBlock];

      [v16 sendHTTPMetricsWithMetrics:v6];
    }

    [(id)networkScoreMetrics removeAllObjects];
  }
}

void sub_1842EEC14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL26setupNetworkScoreReportingv_block_invoke()
{
  networkScoreMetrics = (uint64_t)objc_alloc_init(MEMORY[0x1E4F1CA48]);
  setupNetworkScoreReporting(void)::networkScoreReporting = objc_alloc_init(__NSCFNetworkScoreReporting);
  if (configureLogQueue(void)::sInitLogQueue != -1)
  {
    dispatch_once(&configureLogQueue(void)::sInitLogQueue, &__block_literal_global_34_21046);
  }
}

void non-virtual thunk to'URLConnection::_irl_release(URLConnection *this)
{
}

URLConnection *non-virtual thunk to'URLConnection::_irl_retain(URLConnection *this)
{
  return this;
}

CFAllocatorRef non-virtual thunk to'URLConnection::_irl_allocator(URLConnection *this)
{
  return CFGetAllocator((char *)this - 24);
}

void URLConnection::_irl_release(URLConnection *this)
{
}

uint64_t URLConnection::_irl_retain(URLConnection *this)
{
  return (uint64_t)this + 8;
}

CFAllocatorRef URLConnection::_irl_allocator(URLConnection *this)
{
  return CFGetAllocator((char *)this - 16);
}

void sub_1842EFA50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842EFBDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842EFC70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842F04AC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1842F0F7C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1842F1068(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZL19__CopyHeadersStringP15__CFHTTPMessagePK10__CFString_block_invoke(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "compare:");
}

void CFURLCacheFS::asyncCacheDirectoryRemove(CFURLCacheFS *this, const char *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = strndup((const char *)this, 0x400uLL);
  if (v3)
  {
    uint64_t v4 = v3;
    dispatch_queue_t global_queue = dispatch_get_global_queue(-2, 0);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = ___ZNK12CFURLCacheFS25asyncCacheDirectoryRemoveEPKc_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = v4;
    dispatch_async(global_queue, block);
  }
  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    id v6 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      int v7 = *__error();
      *(_DWORD *)int buf = 136315394;
      id v10 = this;
      __int16 v11 = 1024;
      int v12 = v7;
      _os_log_error_impl(&dword_184085000, v6, OS_LOG_TYPE_ERROR, "asyncCacheDirectoryRemove - failed to duplicate target string for dir %s.  Errno=%{errno}d", buf, 0x12u);
    }
  }
}

void ___ZNK12CFURLCacheFS25asyncCacheDirectoryRemoveEPKc_block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (removefile(*(const char **)(a1 + 32), 0, 1u))
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
    }
    id v2 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = *(void *)(a1 + 32);
      int v4 = *__error();
      int v5 = 136315394;
      uint64_t v6 = v3;
      __int16 v7 = 1024;
      int v8 = v4;
      _os_log_error_impl(&dword_184085000, v2, OS_LOG_TYPE_ERROR, "asyncCacheDirectoryRemove - failed to remove old cache dir %s.  Errno=%{errno}d", (uint8_t *)&v5, 0x12u);
    }
  }
  free(*(void **)(a1 + 32));
}

void _CFURLCacheFSPurgeItemFromFileSystemStore(uint64_t a1, const char *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@/%s", *(void *)(a1 + 80), a2);
    if (v3)
    {
      CFStringRef v4 = v3;
      BOOL v10 = 0;
      int v5 = _ExtractCStringfromCFStringRef(v3, &v10);
      if (unlink(v5) == -1 && *__error() != 2)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
        }
        uint64_t v6 = CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          int v9 = *__error();
          *(_DWORD *)int buf = 136315394;
          int v12 = v5;
          __int16 v13 = 1024;
          int v14 = v9;
          _os_log_error_impl(&dword_184085000, v6, OS_LOG_TYPE_ERROR, "ERROR: purgeItemFromFileSystemStore - unlink of file %s failed Errno=%{errno}d.", buf, 0x12u);
        }
      }
      if (v5) {
        BOOL v7 = !v10;
      }
      else {
        BOOL v7 = 1;
      }
      if (!v7) {
        MEMORY[0x18531B6B0](v5, 0x1000C8077774924);
      }
      CFRelease(v4);
    }
    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_2_5509);
      }
      int v8 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136315138;
        int v12 = a2;
        _os_log_error_impl(&dword_184085000, v8, OS_LOG_TYPE_ERROR, "ERROR: purgeItemFromFileSystemStore - unable to create path to file %s.", buf, 0xCu);
      }
    }
  }
}

void sub_1842F4110(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

void sub_1842F42A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_1842F4300(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__22267(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + ++*(void *)(this + 64) = v3;
  return result;
}

void sub_1842F4400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1842F44CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842F46A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842F47B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842F48E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842F49CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842F4B38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842F4BF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1842F4CB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t xx_CFHSTSPolicyHandleSTSHeader(char *a1, const __CFString *a2, const __CFURL *a3)
{
  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1) {
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
  }
  if (a1) {
    uint64_t v6 = (HSTSPolicy *)(a1 + 16);
  }
  else {
    uint64_t v6 = 0;
  }

  return HSTSPolicy::handleSTSHeader(v6, a2, a3);
}

NSString *xx_CFHSTSPolicyIsKnownHSTSHost(char *a1, const __CFURL *a2)
{
  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1) {
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
  }
  if (a1) {
    CFStringRef v4 = (HSTSPolicy *)(a1 + 16);
  }
  else {
    CFStringRef v4 = 0;
  }
  if (!a2) {
    return 0;
  }
  __n128 result = (NSString *)[(__CFURL *)a2 host];
  if (result) {
    return (NSString *)HSTSPolicy::isKnownHSTSHost(v4, result, &v6);
  }
  return result;
}

uint64_t xx_CFHSTSPolicyIsKnownHSTSHostWithBytes(char *a1, unsigned __int8 *a2, CFIndex a3)
{
  if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy != -1) {
    dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_332);
  }
  if (a1) {
    unsigned __int8 v6 = (HSTSPolicy *)(a1 + 16);
  }
  else {
    unsigned __int8 v6 = 0;
  }
  return HSTSPolicy::isKnownHSTSHost(v6, a2, a3, &v8);
}

void xx_CFHSTSPolicyUpdateHSTSInfoForHost(void *a1, CFStringRef theString, const __CFDictionary *a3)
{
  CFIndex Length = CFStringGetLength(theString);
  CFStringCreateMutableCopy(0, Length, theString);
  operator new();
}

void sub_1842F53B8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

BOOL xx_createKerberosTicketForHostWithPassword(const char *a1, const char *a2, const char *a3, const char *a4, uint64_t a5, const char *a6, double a7)
{
  int v9 = 0;
  int SvcTicketForHostWithPassword = GetSvcTicketForHostWithPassword(a7, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)v10, (uint64_t)&v9, a5, (uint64_t)a6, 0);
  if (v9) {
    free(v9);
  }
  return SvcTicketForHostWithPassword == 0;
}

uint64_t xx_destroyAllKerberosTickets(double a1)
{
  return gss_iter_creds_delayInitStub(a1);
}

uint64_t xx_listKerberosTickets(double a1)
{
  return gss_iter_creds_delayInitStub(a1);
}

uint64_t xx_equalType(const _CFURLCredential *a1, const _CFURLCredential *a2)
{
  if (a1 && a2) {
    return CFEqual(a1, a2);
  }
  else {
    return 0;
  }
}

uint64_t SingleCookieParser_parse(CFAllocatorRef alloc, char **a2, __CFString **a3, const __CFURL *a4, const void *a5)
{
  CFAllocatorRef v5 = alloc;
  int v55 = 0;
  uint64_t v6 = 0;
  signed int v7 = 0u;
  __src = v65;
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  std::string v61 = 0;
  unint64_t v8 = 200;
  int v9 = (__int16 *)v66;
  BOOL v10 = v66;
  __int16 v11 = (__CFString **)v65;
  int v12 = -2;
  while (1)
  {
    *(_WORD *)BOOL v10 = v7;
    if (&v9[v8 - 1] <= (__int16 *)v10)
    {
      if (v8 >> 4 > 0x270
        || (2 * v8 >= 0x2710 ? (uint64_t v13 = 10000) : (uint64_t v13 = 2 * v8),
            (int v14 = (__int16 *)malloc_type_malloc(10 * v13 + 7, 0x309D3248uLL)) == 0))
      {
        LODWORD(v26) = 0;
        uint64_t v48 = 2;
        goto LABEL_91;
      }
      uint64_t v15 = v14;
      int v58 = v12;
      uint64_t v16 = v6;
      uint64_t v17 = (v10 - (char *)v9) >> 1;
      uint64_t v18 = v17 + 1;
      memcpy(v14, v9, 2 * (v17 + 1));
      int64_t v19 = v13;
      CFRange v20 = (char *)v15 + ((2 * v13 + 7) & 0xFFFFFFFFFFFFFFF8);
      memcpy(v20, __src, 8 * (v17 + 1));
      if (v9 != (__int16 *)v66) {
        free(v9);
      }
      BOOL v10 = (char *)&v15[v17];
      __int16 v11 = (__CFString **)&v20[8 * v18 - 8];
      if (v19 <= v18)
      {
        LODWORD(v26) = 0;
        uint64_t v48 = 1;
        int v9 = v15;
        LODWORD(v6) = v16;
        int v12 = v58;
        goto LABEL_91;
      }
      unint64_t v8 = v19;
      int v9 = v15;
      __src = v20;
      uint64_t v6 = v16;
      int v12 = v58;
    }
    unint64_t v59 = v8;
    if ((0x5CB97FD3274FFCuLL >> v7)) {
      break;
    }
    int v21 = yypact[v7];
    if (v12 == -2) {
      int v12 = CookieParser_lex((CFStringRef *)&v61, v5, a2);
    }
    if (v12 < 1)
    {
      uint64_t v6 = 0;
      int v12 = 0u;
    }
    else
    {
      uint64_t v6 = v12 > 0x10D ? 2 : yytranslate[v12];
    }
    uint64_t v22 = (v6 + v21);
    if (v22 > 0x67 || v6 != yycheck[v22]) {
      break;
    }
    signed int v23 = yytable[v22];
    if (!yytable[v22]) {
      goto LABEL_34;
    }
    if (v22 == 18)
    {
      LODWORD(v26) = 0;
      uint64_t v48 = 0;
      goto LABEL_91;
    }
    int v24 = v55 - 1;
    if (!v55) {
      int v24 = 0;
    }
    int v55 = v24;
    if (v12) {
      int v12 = -2;
    }
    else {
      int v12 = 0;
    }
    v11[1] = v61;
    ++v11;
    signed int v7 = v23;
LABEL_85:
    v10 += 2;
    unint64_t v8 = v59;
    CFAllocatorRef v5 = alloc;
  }
  if (((0x20008000009003uLL >> v7) & 1) == 0)
  {
    uint64_t v25 = yydefact[v7];
    uint64_t v26 = yyr2[v25];
    switch(v7)
    {
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 21:
      case 25:
      case 26:
      case 28:
      case 31:
      case 40:
      case 49:
      case 51:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124:
      case 125:
      case 126:
      case 127:
      case 128:
      case 129:
      case 130:
      case 131:
      case 132:
      case 133:
      case 134:
      case 135:
      case 136:
      case 137:
      case 138:
        int v27 = *v11;
        break;
      case 13:
      case 62:
      case 65:
      case 66:
      case 69:
      case 71:
        float v49 = v11;
        goto LABEL_105;
      case 14:
      case 61:
        CFMutableArrayRef Mutable = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
        int v27 = (__CFString *)Mutable;
        if (!*v11) {
          break;
        }
        CFArrayAppendValue(Mutable, *v11);
        goto LABEL_79;
      case 16:
        CFMutableArrayRef v30 = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E4F1D510]);
        goto LABEL_54;
      case 18:
      case 56:
      case 57:
      case 60:
      case 64:
      case 67:
      case 70:
      case 94:
      case 96:
      case 97:
        float v49 = v11 - 1;
LABEL_105:
        uint64_t v48 = 0;
        *a3 = *v49;
        goto LABEL_91;
      case 19:
      case 22:
      case 27:
      case 41:
        CFMutableArrayRef v30 = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
LABEL_54:
        int v27 = (__CFString *)v30;
        break;
      case 20:
      case 29:
        int v27 = @"=";
        break;
      case 23:
        int v27 = @",";
        break;
      case 24:
        Cookie = (__CFString *)_makeCookie(alloc, *(v11 - 2), &stru_1ECFAD558, (const __CFDictionary *)*v11, a4, a5);
        goto LABEL_65;
      case 30:
        std::string::size_type v36 = (__CFString *)CFStringCreateWithFormat(alloc, 0, @"=%@", *v11);
        goto LABEL_78;
      case 32:
      case 139:
      case 140:
        CFRelease(*v11);
        int v27 = (__CFString *)&unk_1EC0A1858;
        break;
      case 33:
      case 141:
      case 142:
      case 143:
      case 144:
      case 145:
      case 146:
        CFRelease(*v11);
        int v27 = (__CFString *)&unk_1EC0A1938;
        break;
      case 34:
        CFRelease(*v11);
        int v27 = (__CFString *)&unk_1EC0A1A18;
        break;
      case 35:
        CFRelease(*v11);
        int v27 = (__CFString *)&unk_1EC0A1AF8;
        break;
      case 36:
        CFRelease(*v11);
        int v27 = (__CFString *)&unk_1EC0A1BA0;
        break;
      case 37:
        CFRelease(*v11);
        int v27 = (__CFString *)&unk_1EC0A19E0;
        break;
      case 38:
        CFRelease(*v11);
        int v27 = (__CFString *)&unk_1EC0A1C80;
        break;
      case 42:
        *(void *)&values.year = 0;
        values.second = 0.0;
        *(void *)&values.year = *v11;
        *(void *)&values.second = &stru_1ECFAD558;
        std::string::size_type v36 = (__CFString *)CFArrayCreate(alloc, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
        goto LABEL_78;
      case 43:
        std::string::size_type v36 = (__CFString *)CFStringCreateWithFormat(alloc, 0, @",%@", *v11);
LABEL_78:
        int v27 = v36;
        goto LABEL_79;
      case 44:
        int v27 = (__CFString *)CFStringCreateWithFormat(alloc, 0, @"%@%@", *(v11 - 1), *v11);
        goto LABEL_74;
      case 45:
        int v27 = (__CFString *)_makeCookie(alloc, *(v11 - 3), *(v11 - 1), (const __CFDictionary *)*v11, a4, a5);
        CFRelease(*(v11 - 3));
LABEL_74:
        uint8x8_t v40 = *(v11 - 1);
        goto LABEL_75;
      case 46:
      case 48:
        *(void *)&values.year = 0;
        values.second = 0.0;
        *(void *)&values.year = *(v11 - 1);
        *(void *)&values.second = &stru_1ECFAD558;
        int v27 = (__CFString *)CFArrayCreate(alloc, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
        goto LABEL_56;
      case 47:
        uint64_t v32 = (__CFDictionary *)*v11;
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)*(v11 - 1), 0);
        long long v34 = CFArrayGetValueAtIndex((CFArrayRef)*(v11 - 1), 1);
        CFDictionaryAddValue(v32, ValueAtIndex, v34);
        int v27 = *v11;
LABEL_56:
        int v35 = *(v11 - 1);
        goto LABEL_80;
      case 50:
        *(void *)&values.year = 0;
        values.second = 0.0;
        CFTimeZoneRef tz = 0;
        unint64_t v62 = &unk_1EC0A1970;
        uint64_t v63 = &stru_1ECFAD558;
        _CFGregorianDateCreateWithString(alloc, *v11, (uint64_t)&values, (CFTypeRef *)&tz);
        if (!values.year) {
          goto LABEL_87;
        }
        CFAbsoluteTime AbsoluteTime = CFGregorianDateGetAbsoluteTime(values, tz);
        CFDateRef v38 = CFDateCreate(alloc, AbsoluteTime);
        if (tz) {
          CFRelease(tz);
        }
        if (v38)
        {
          char v39 = 0;
          CFDateRef v50 = v38;
          uint64_t v63 = (__CFString *)v38;
        }
        else
        {
LABEL_87:
          CFDateRef v50 = 0;
          char v39 = 1;
        }
        int v27 = (__CFString *)CFArrayCreate(alloc, (const void **)&v62, 2, MEMORY[0x1E4F1D510]);
        CFRelease(*(v11 - 2));
        CFRelease(*v11);
        if (v39) {
          break;
        }
        int v35 = (__CFString *)v50;
        goto LABEL_80;
      case 52:
        *(void *)&values.year = 0;
        values.second = 0.0;
        *(void *)&values.year = *(v11 - 2);
        *(void *)&values.second = *v11;
        Cookie = (__CFString *)CFArrayCreate(alloc, (const void **)&values, 2, MEMORY[0x1E4F1D510]);
        goto LABEL_65;
      case 54:
        Cookie = (__CFString *)CFStringCreateWithFormat(alloc, 0, @"%@, %@", *(v11 - 2), *v11);
LABEL_65:
        int v27 = Cookie;
        uint8x8_t v40 = *(v11 - 2);
LABEL_75:
        CFRelease(v40);
LABEL_79:
        int v35 = *v11;
LABEL_80:
        CFRelease(v35);
        break;
      default:
        int v27 = v11[1 - v26];
        break;
    }
    unint64_t v41 = &v11[-v26];
    v10 -= 2 * v26;
    v41[1] = v27;
    __int16 v11 = v41 + 1;
    uint64_t v42 = yyr1[v25] - 18;
    uint64_t v43 = (*(__int16 *)v10 + yypgoto[v42]);
    if (v43 <= 0x67 && *(unsigned __int16 *)v10 == (unsigned __int16)yycheck[v43]) {
      signed int v7 = yytable[v43];
    }
    else {
      signed int v7 = yydefgoto[v42];
    }
    goto LABEL_85;
  }
LABEL_34:
  if (v55 == 3)
  {
    if (v12 > 0)
    {
      yydestruct(v6, (CFTypeRef *)&v61);
      int v12 = -2;
      goto LABEL_39;
    }
    if (!v12)
    {
      LODWORD(v26) = 0;
      uint64_t v48 = 1;
      goto LABEL_94;
    }
  }
  while (1)
  {
LABEL_39:
    if (((0x5CB97FD3274FFCuLL >> v7) & 1) == 0 && ((0x2346802CD8B001uLL >> v7) & 1) != 0 && yypact[v7] == 65)
    {
      v11[1] = v61;
      ++v11;
      signed int v7 = 1u;
      int v55 = 3;
      goto LABEL_85;
    }
    if (v10 == (char *)v9) {
      break;
    }
    yydestruct(yystos[v7], (CFTypeRef *)v11--);
    signed int v28 = *((__int16 *)v10 - 1);
    v10 -= 2;
    signed int v7 = v28;
  }
  LODWORD(v26) = 0;
  uint64_t v48 = 1;
  BOOL v10 = (char *)v9;
LABEL_91:
  if (v12 != -2 && v12) {
    yydestruct(v6, (CFTypeRef *)&v61);
  }
LABEL_94:
  unint64_t v44 = (__int16 *)&v10[-2 * v26];
  if (v44 != v9)
  {
    unint64_t v45 = (CFTypeRef *)&v11[-v26];
    do
    {
      uint64_t v46 = *v44--;
      yydestruct(yystos[v46], v45--);
    }
    while (v44 != v9);
  }
  if (v9 != (__int16 *)v66) {
    free(v9);
  }
  return v48;
}

void yydestruct(int a1, CFTypeRef *a2)
{
  switch(a1)
  {
    case 4:
    case 5:
    case 6:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 27:
    case 28:
    case 29:
      if (*a2) {
        CFRelease(*a2);
      }
      break;
    default:
      return;
  }
}

void yydestruct_23502(int a1, CFTypeRef *a2)
{
  switch(a1)
  {
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 27:
    case 28:
    case 29:
      if (*a2) {
        CFRelease(*a2);
      }
      break;
    default:
      return;
  }
}

void qenc_hist_update_size(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 228) != a2)
  {
    if (!a2)
    {
      *(void *)(a1 + 2CFRetain((char *)this - 24) = 0;
      *(_DWORD *)(a1 + 232) = 0;
      return;
    }
    CFStringRef v4 = malloc_type_malloc(8 * (a2 + 1), 0x100004000313F17uLL);
    if (!v4) {
      return;
    }
    CFAllocatorRef v5 = v4;
    uint64_t v6 = *(FILE **)(a1 + 200);
    if (v6)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v6);
      fprintf(*(FILE **)(a1 + 200), "history size change from %u to %u", *(_DWORD *)(a1 + 228), a2);
      fputc(10, *(FILE **)(a1 + 200));
    }
    unsigned int v7 = *(_DWORD *)(a1 + 224);
    if (*(_DWORD *)(a1 + 232))
    {
      unsigned int v8 = v7 + 1;
      unsigned int v7 = *(_DWORD *)(a1 + 228);
      int v9 = v8 % v7;
    }
    else
    {
      int v9 = 0;
      if (!v7)
      {
        LODWORD(v10) = 0;
LABEL_15:
        unsigned int v13 = v10 % a2;
        *(_DWORD *)(a1 + 2CFRetain((char *)this - 24) = v13;
        *(_DWORD *)(a1 + 228) = a2;
        *(_DWORD *)(a1 + 232) = v13 == 0;
        free(*(void **)(a1 + 216));
        *(void *)(a1 + 2CFRetain((char *)this - 16) = v5;
        return;
      }
    }
    unint64_t v10 = 0;
    unsigned int v11 = v7 - 1;
    do
    {
      int v12 = v10;
      v5[v10] = *(void *)(*(void *)(a1 + 216) + 8 * ((v9 + v10) % *(_DWORD *)(a1 + 228)));
      ++v10;
    }
    while (v11 != v12 && v10 < a2);
    goto LABEL_15;
  }
}

void *lsqpack_enc_push_entry(uint64_t a1, int a2, int a3, const void *a4, unsigned int a5, const void *a6, unsigned int a7)
{
  unsigned int v8 = a6;
  v44[2] = *MEMORY[0x1E4F143B8];
  int v13 = *(_DWORD *)(a1 + 52);
  uint64_t v14 = 1 << v13;
  if (*(_DWORD *)(a1 + 48) >= (1 << v13) >> 1)
  {
    uint64_t v16 = malloc_type_malloc(32 * (1 << (v13 + 1)), 0xA004088793A40uLL);
    if (!v16) {
      return v16;
    }
    uint64_t v17 = 0;
    int v18 = (1 << (v13 + 1)) - 1;
    int64_t v19 = *(void **)(a1 + 72);
    unsigned int v8 = a6;
    do
    {
      CFRange v20 = &v16[4 * v17];
      int v21 = &v16[4 * (v14 + v17)];
      v44[0] = v20;
      v44[1] = v21;
      *CFRange v20 = 0;
      v20[1] = v20;
      void *v21 = 0;
      v21[1] = v21;
      v20[2] = 0;
      v20[3] = v20 + 2;
      void v21[2] = 0;
      v21[3] = v21 + 2;
      while (1)
      {
        uint64_t v22 = &v19[4 * v17];
        uint64_t v23 = *v22;
        if (!*v22) {
          break;
        }
        uint64_t v24 = *(void *)(v23 + 8);
        *uint64_t v22 = v24;
        if (!v24) {
          v22[1] = (uint64_t)v22;
        }
        unsigned int v25 = ((*(_DWORD *)(v23 + 44) & v18) >> v13) & 1;
        *(void *)(v23 + 8) = 0;
        uint64_t v26 = v44[v25];
        **(void **)(v26 + 8) = v23;
        *(void *)(v26 + 8) = v23 + 8;
        int64_t v19 = *(void **)(a1 + 72);
      }
      while (1)
      {
        CFMutableArrayRef v30 = (char *)&v19[4 * v17];
        uint64_t v33 = (uint64_t *)*((void *)v30 + 2);
        uint64_t v32 = (uint64_t *)(v30 + 16);
        char v31 = v33;
        if (!v33) {
          break;
        }
        uint64_t v27 = *v31;
        uint64_t *v32 = *v31;
        if (!v27) {
          v19[4 * v17 + 3] = v32;
        }
        unsigned int v28 = ((v31[5] & v18) >> v13) & 1;
        *char v31 = 0;
        uint64_t v29 = v44[v28];
        **(void **)(v29 + CFRetain((char *)this - 24) = v31;
        *(void *)(v29 + CFRetain((char *)this - 24) = v31;
        int64_t v19 = *(void **)(a1 + 72);
      }
      ++v17;
    }
    while (v17 != v14);
    free(v19);
    *(_DWORD *)(a1 + 52) = v13 + 1;
    *(void *)(a1 + 72) = v16;
  }
  long long v34 = malloc_type_malloc(a5 + (unint64_t)a7 + 56, 0x5A4B1079uLL);
  uint64_t v16 = v34;
  if (v34)
  {
    v34[10] = a3;
    v34[11] = a2;
    v34[12] = a5;
    v34[13] = a7;
    v34[7] = *(_DWORD *)(a1 + 16);
    char v34[8] = *(_DWORD *)(a1 + 32);
    int v35 = *(_DWORD *)a1 + 1;
    *(_DWORD *)a1 = v35;
    v34[6] = v35;
    std::string::size_type v36 = v34 + 14;
    memcpy(v34 + 14, a4, a5);
    memcpy((char *)v36 + a5, v8, a7);
    v16[2] = 0;
    **(void **)(a1 + ++*(void *)(this + 64) = v16;
    *(void *)(a1 + ++*(void *)(this + 64) = v16 + 2;
    int v37 = -1 << *(_DWORD *)(a1 + 52);
    uint64_t v38 = a3 & ~v37;
    *uint64_t v16 = 0;
    **(void **)(*(void *)(a1 + 72) + 32 * v38 + CFRetain((char *)this - 24) = v16;
    uint64_t v39 = *(void *)(a1 + 72);
    *(void *)(v39 + 32 * v38 + CFRetain((char *)this - 24) = v16;
    uint64_t v40 = a2 & ~v37;
    v16[1] = 0;
    **(void **)(v39 + 32 * v40 + 8) = v16;
    *(void *)(*(void *)(a1 + 72) + 32 * v40 + 8) = v16 + 1;
    *(_DWORD *)(a1 + 16) += a5 + a7 + 32;
    ++*(_DWORD *)(a1 + 48);
    unint64_t v41 = *(FILE **)(a1 + 200);
    if (v41)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v41);
        *((_DWORD *)v16 + 6),
        *((_DWORD *)v16 + 12),
        (const char *)v16 + 56,
        *((_DWORD *)v16 + 13),
        (const char *)v16 + *((unsigned int *)v16 + 12) + 56,
        *(_DWORD *)(a1 + 48),
        *(_DWORD *)(a1 + 16));
      fputc(10, *(FILE **)(a1 + 200));
    }
  }
  return v16;
}

uint64_t enc_proc_ici(uint64_t a1, unint64_t a2)
{
  CFStringRef v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got ICI instruction, count=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (!a2)
  {
    uint64_t v6 = *(FILE **)(a1 + 200);
    if (v6)
    {
      fwrite("qenc: info: ", 0xCuLL, 1uLL, v6);
      fwrite("ICI=0 is an error", 0x11uLL, 1uLL, *(FILE **)(a1 + 200));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  if (HIDWORD(a2))
  {
    CFAllocatorRef v5 = *(FILE **)(a1 + 200);
    if (v5)
    {
      fwrite("qenc: info: ", 0xCuLL, 1uLL, v5);
      fprintf(*(FILE **)(a1 + 200), "insertion count too high: %llu");
LABEL_12:
      fputc(10, *(FILE **)(a1 + 200));
      return 0xFFFFFFFFLL;
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = *(_DWORD *)(a1 + 8) + a2;
  if (v7 > *(_DWORD *)a1)
  {
    unsigned int v8 = *(FILE **)(a1 + 200);
    if (v8)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
      fprintf(*(FILE **)(a1 + 200), "ICI: max_acked %u is larger than number of inserts %u");
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  if (v7 <= *(_DWORD *)(a1 + 4))
  {
    unsigned int v11 = *(FILE **)(a1 + 200);
    if (v11)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v11);
      fprintf(*(FILE **)(a1 + 200), "duplicate ICI: %u", v7);
      fputc(10, *(FILE **)(a1 + 200));
    }
  }
  else
  {
    *(_DWORD *)(a1 + 4) = v7;
    *(_DWORD *)(a1 + 8) = v7;
    unint64_t v10 = *(FILE **)(a1 + 200);
    if (v10)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v10);
      fprintf(*(FILE **)(a1 + 200), "max acked ID is now %u", *(_DWORD *)(a1 + 4));
      fputc(10, *(FILE **)(a1 + 200));
    }
    qenc_update_risked_list(a1);
  }
  return 0;
}

uint64_t qenc_update_risked_list(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 112);
  if (v1)
  {
    uint64_t v2 = result;
    do
    {
      uint64_t v3 = *(void *)(v1 + 16);
      if (*(_DWORD *)(v1 + 60) <= *(_DWORD *)(v2 + 4)) {
        __n128 result = qenc_remove_from_risked_list(v2, (void *)v1);
      }
      uint64_t v1 = v3;
    }
    while (v3);
  }
  return result;
}

uint64_t qenc_remove_from_risked_list(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  if (*(void *)(result + 112))
  {
    uint64_t v3 = a2[2];
    CFStringRef v4 = (void *)a2[3];
    if (v3)
    {
      *(void *)(v3 + CFRetain((char *)this - 24) = v4;
      CFStringRef v4 = (void *)a2[3];
    }
    else
    {
      *(void *)(result + 120) = v4;
    }
    void *v4 = v3;
    CFAllocatorRef v5 = (void *)a2[4];
    if (v5 == a2)
    {
      int v8 = *(_DWORD *)(result + 40);
      if (!v8) {
        __assert_rtn("qenc_remove_from_risked_list", "lsqpack.c", 1174, "enc->qpe_cur_streams_at_risk > 0");
      }
      *(_DWORD *)(result + 40) = v8 - 1;
      int v9 = *(FILE **)(result + 200);
      if (v9)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v9);
        fprintf(*(FILE **)(v2 + 200), "streams at risk: %u", *(_DWORD *)(v2 + 40));
        unint64_t v10 = *(FILE **)(v2 + 200);
        return fputc(10, v10);
      }
    }
    else
    {
      uint64_t v6 = (void *)a2[4];
      do
      {
        unsigned int v7 = v6;
        uint64_t v6 = (void *)v6[4];
      }
      while (v6 != a2);
      v7[4] = v5;
      a2[4] = a2;
    }
  }
  else if (*(_DWORD *)(result + 40))
  {
    __assert_rtn("qenc_remove_from_risked_list", "lsqpack.c", 1168, "enc->qpe_cur_streams_at_risk == 0");
  }
  return result;
}

uint64_t enc_proc_header_ack(uint64_t a1, unint64_t a2)
{
  CFStringRef v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got Header Ack instruction, stream=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (!(a2 >> 62))
  {
    unint64_t v6 = a1 + 96;
    while (1)
    {
      unint64_t v6 = *(void *)v6;
      if (!v6) {
        break;
      }
      if (*(void *)(v6 + 40) == a2)
      {
        if (*(_DWORD *)(v6 + 60) > *(_DWORD *)(a1 + 4))
        {
          qenc_remove_from_risked_list(a1, (void *)v6);
          *(_DWORD *)(a1 + 4) = *(_DWORD *)(v6 + 60);
          qenc_update_risked_list(a1);
          unsigned int v7 = *(FILE **)(a1 + 200);
          if (v7)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
            fprintf(*(FILE **)(a1 + 200), "max acked ID is now %u", *(_DWORD *)(a1 + 4));
            fputc(10, *(FILE **)(a1 + 200));
          }
        }
        enc_free_hinfo(a1, v6);
        return 0;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t enc_proc_stream_cancel(uint64_t a1, unint64_t a2)
{
  CFStringRef v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got Cancel Stream instruction; stream=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (!(a2 >> 62))
  {
    unint64_t v7 = *(void *)(a1 + 96);
    if (v7)
    {
      int v8 = 0;
      do
      {
        unint64_t v9 = *(void *)v7;
        if (*(void *)(v7 + 40) == a2)
        {
          unint64_t v10 = *(FILE **)(a1 + 200);
          if (v10)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v10);
            fprintf(*(FILE **)(a1 + 200), "cancel header block for stream %llu, seqno %u", a2, *(_DWORD *)(v7 + 48));
            fputc(10, *(FILE **)(a1 + 200));
          }
          if (*(_DWORD *)(v7 + 60) > *(_DWORD *)(a1 + 4)) {
            qenc_remove_from_risked_list(a1, (void *)v7);
          }
          enc_free_hinfo(a1, v7);
          ++v8;
        }
        unint64_t v7 = v9;
      }
      while (v9);
    }
    else
    {
      int v8 = 0;
    }
    unsigned int v11 = *(FILE **)(a1 + 200);
    if (!v11) {
      return 0;
    }
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v11);
    fprintf(*(FILE **)(a1 + 200), "cancelled %u header block%.*s of stream %llu", v8, v8 != 1, "s", a2);
    uint64_t v6 = 0;
    goto LABEL_20;
  }
  CFAllocatorRef v5 = *(FILE **)(a1 + 200);
  if (v5)
  {
    fwrite("qenc: info: ", 0xCuLL, 1uLL, v5);
    fprintf(*(FILE **)(a1 + 200), "Invalid stream ID %llu in Cancel Stream", a2);
    uint64_t v6 = 0xFFFFFFFFLL;
LABEL_20:
    fputc(10, *(FILE **)(a1 + 200));
    return v6;
  }
  return 0xFFFFFFFFLL;
}

float lsqpack_dec_ratio(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 28);
  if (!v1) {
    return 0.0;
  }
  float v3 = (float)*(unsigned int *)(a1 + 24) / (float)v1;
  CFStringRef v4 = *(FILE **)(a1 + 48);
  if (v4)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 48), "bytes in: %u; bytes out: %u, ratio: %.3f",
      *(_DWORD *)(a1 + 28),
      *(_DWORD *)(a1 + 24),
      v3);
    fputc(10, *(FILE **)(a1 + 48));
  }
  return v3;
}

uint64_t lsqpack_huff_decode_full(unsigned char *a1, int a2, unsigned char *a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a4)
  {
    uint64_t v6 = a1;
    unint64_t v7 = a3;
    int v8 = &a3[(int)a4];
    switch(*(_DWORD *)a5)
    {
      case 0:
        *(_WORD *)(a5 + 4) = 256;
        uint64_t v6 = a1;
        unint64_t v7 = a3;
        goto LABEL_6;
      case 1:
        goto LABEL_6;
      case 2:
        goto LABEL_8;
      case 3:
        unsigned int v10 = *(unsigned __int8 *)(a5 + 4);
        uint64_t v6 = a1;
        unint64_t v7 = a3;
        break;
      default:
        goto LABEL_20;
    }
    while (1)
    {
      int v13 = (char *)&decode_tables + 48 * v10 + 3 * (*v6 & 0xF);
      char v14 = v13[1];
      if ((v14 & 4) != 0)
      {
LABEL_17:
        a4 = 0;
        uint64_t v9 = 3;
        return v9 | (a4 << 32);
      }
      char v15 = *v13;
      if ((v13[1] & 2) != 0)
      {
        *v7++ = v13[2];
        *(unsigned char *)(a5 + 4) = v15;
        *(unsigned char *)(a5 + 5) = v14 & 1;
      }
      else
      {
        *(unsigned char *)(a5 + 4) = v15;
        *(unsigned char *)(a5 + 5) = v14 & 1;
        if (!v7) {
          goto LABEL_17;
        }
      }
      ++v6;
LABEL_6:
      if (v6 == &a1[a2]) {
        break;
      }
      if (v7 == v8)
      {
        uint64_t v9 = 2;
        *(_DWORD *)a5 = 2;
        return v9 | (a4 << 32);
      }
LABEL_8:
      unsigned int v11 = (unsigned __int8 *)&decode_tables
          + 48 * *(unsigned __int8 *)(a5 + 4)
          + 3 * ((unint64_t)*v6 >> 4);
      unsigned __int8 v12 = v11[1];
      if ((v12 & 4) != 0) {
        goto LABEL_17;
      }
      unsigned int v10 = *v11;
      if ((v11[1] & 2) != 0)
      {
        *v7++ = v11[2];
        *(unsigned char *)(a5 + 4) = v10;
        *(unsigned char *)(a5 + 5) = v12 & 1;
      }
      else
      {
        *(unsigned char *)(a5 + 4) = v10;
        *(unsigned char *)(a5 + 5) = v12 & 1;
        if (!v7) {
          goto LABEL_17;
        }
      }
      if (v7 == v8)
      {
        *(_DWORD *)a5 = 3;
        goto LABEL_4;
      }
    }
LABEL_20:
    if (a6)
    {
      if (*(unsigned char *)(a5 + 5)) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = 3;
      }
    }
    else
    {
      uint64_t v9 = 1;
      *(_DWORD *)a5 = 1;
    }
    a4 = (v7 - a3);
  }
  else
  {
LABEL_4:
    uint64_t v9 = 2;
  }
  return v9 | (a4 << 32);
}

uint64_t header_out_begin_dynamic_nameref(unsigned int *a1, void *a2, unsigned int *a3, int a4)
{
  if (a2[10]) {
    __assert_rtn("header_out_begin_dynamic_nameref", "lsqpack.c", 3131, "!read_ctx->hbrc_out.xhdr");
  }
  uint64_t v8 = 4 * (*a1 & 1);
  uint64_t v9 = (*(uint64_t (**)(void, void, uint64_t))(*((void *)a1 + 5) + 8))(a2[4], 0, v8 + *a3);
  a2[10] = v9;
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = v9;
  *(unsigned char *)(v9 + 35) = v8;
  if (a4) {
    *(unsigned char *)(v9 + 33) |= 0x40u;
  }
  qdec_maybe_update_entry_hashes(*a1, a3);
  unsigned int v11 = a3[6];
  if (v11)
  {
    *(unsigned char *)(v10 + 33) |= 8u;
    *(_DWORD *)(v10 + 8) = a3[3];
    unsigned int v11 = a3[6];
  }
  if ((v11 & 4) != 0)
  {
    *(unsigned char *)(v10 + 33) |= 2u;
    *(unsigned char *)(v10 + 3HTTPServerConnection::canceled_onQueue(this - 1) = a3[5];
  }
  size_t v12 = *a3;
  *(_WORD *)(v10 + CFRetain((char *)this - 24) = v12;
  int v13 = (char *)(*(void *)v10 + *(int *)(v10 + 16));
  memcpy(v13, a3 + 7, v12);
  char v14 = &v13[*a3];
  if (v8)
  {
    *(_WORD *)char v14 = 8250;
    LOWORD(v14) = (_WORD)v14 + 2;
  }
  uint64_t result = 0;
  *(_DWORD *)(v10 + 20) = (unsigned __int16)((_WORD)v14 - *(_DWORD *)v10);
  a2[11] = 1;
  return result;
}

uint64_t header_out_grow_buf(uint64_t a1, uint64_t a2)
{
  CFStringRef v4 = (void *)(a2 + 80);
  uint64_t v3 = *(void *)(a2 + 80);
  if (!v3) {
    __assert_rtn("header_out_grow_buf", "lsqpack.c", 3291, "read_ctx->hbrc_out.xhdr");
  }
  if (*(_DWORD *)(a2 + 88)) {
    unsigned int v6 = *(_DWORD *)(v3 + 20) - *(_DWORD *)(v3 + 16) + *(_DWORD *)(a2 + 92);
  }
  else {
    unsigned int v6 = *(_DWORD *)(a2 + 92);
  }
  unsigned int v7 = *(unsigned __int16 *)(v3 + 26);
  BOOL v8 = v7 >= v6;
  unsigned int v9 = v7 - v6;
  if (!v8) {
    __assert_rtn("header_out_grow_buf", "lsqpack.c", 3303, "read_ctx->hbrc_out.xhdr->val_len >= off");
  }
  if (v9 <= 2) {
    unsigned int v9 = 2;
  }
  if ((v9 >> 1) + (unint64_t)*(unsigned __int16 *)(v3 + 26) >= 0xFFFF) {
    unint64_t v10 = 0xFFFFLL;
  }
  else {
    unint64_t v10 = (v9 >> 1) + (unint64_t)*(unsigned __int16 *)(v3 + 26);
  }
  uint64_t v11 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 8))(*(void *)(a2 + 32));
  *(void *)(a2 + ++*(void *)(this + 80) = v11;
  if (!v11) {
    return 0xFFFFFFFFLL;
  }
  if (v10 > *(unsigned __int16 *)(v11 + 26))
  {
    size_t v12 = *(FILE **)(a1 + 48);
    if (v12)
    {
      fwrite("qdec: info: ", 0xCuLL, 1uLL, v12);
      fprintf(*(FILE **)(a1 + 48), "allocated xhdr size (%zd) is smaller than requested (%zd)", *(unsigned __int16 *)(*v4 + 26), v10);
      fputc(10, *(FILE **)(a1 + 48));
    }
    void *v4 = 0;
    v4[1] = 0;
    return 0xFFFFFFFFLL;
  }
  return 0;
}

void __URLSESSION_CLIENT_API_MISUSE_INVALIDATED_SESSION__(NSString *a1)
{
}

void __URLSESSION_CLIENT_API_MISUSE_NIL_ARGUMENT__(NSString *a1)
{
}

uint64_t NSRequestConcreteImplementation(uint64_t a1, const char *a2, objc_class *a3)
{
  uint64_t v5 = objc_opt_class();
  unsigned int v6 = (void *)MEMORY[0x1E4F1CA00];
  uint64_t v7 = *MEMORY[0x1E4F1C3C8];
  Name = sel_getName(a2);
  if ((objc_class *)v5 == a3) {
    return objc_msgSend(v6, "raise:format:", v7, @"*** -%s cannot be sent to an abstract object of class %s: Create a concrete instance!", Name, class_getName(a3), v12);
  }
  unsigned int v9 = (objc_class *)objc_opt_class();
  unint64_t v10 = class_getName(v9);
  return objc_msgSend(v6, "raise:format:", v7, @"*** -%s only defined for abstract class.  Define -[%s %s]!", Name, v10, sel_getName(a2));
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x1F40C9718](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x1F40C9720](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1F40C9728](c, data, *(void *)&len);
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1F40C9730](data, *(void *)&len, md);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

SInt32 CFAbsoluteTimeGetDayOfWeek(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  return MEMORY[0x1F40D70B8](tz, at);
}

CFGregorianDate CFAbsoluteTimeGetGregorianDate(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  uint64_t v2 = MEMORY[0x1F40D70D8](tz, at);
  result.second = v3;
  result.year = v2;
  result.month = BYTE4(v2);
  result.day = BYTE5(v2);
  result.hour = BYTE6(v2);
  result.minute = HIBYTE(v2);
  return result;
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  return (void *)MEMORY[0x1F40D70E8](allocator, size, hint);
}

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  return (CFAllocatorRef)MEMORY[0x1F40D70F8](allocator, context);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  return (CFAllocatorRef)MEMORY[0x1F40D7110]();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

CFIndex CFArrayBSearchValues(CFArrayRef theArray, CFRange range, const void *value, CFComparatorFunction comparator, void *context)
{
  return MEMORY[0x1F40D7158](theArray, range.location, range.length, value, comparator, context);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D7160](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1F40D7170](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1F40D7178](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7198](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D71C8](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArrayReplaceValues(CFMutableArrayRef theArray, CFRange range, const void **newValues, CFIndex newCount)
{
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return (CFTypeRef)MEMORY[0x1F40D72D8](arg);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1F40D7420]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

CFURLRef CFBundleCopyExecutableURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1F40D7470](bundle);
}

uint64_t CFBundleCopyLocalizationForLocalizationInfo()
{
  return MEMORY[0x1F40D7488]();
}

CFStringRef CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return (CFStringRef)MEMORY[0x1F40D74A8](bundle, key, value, tableName);
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1F40D74D0](bundle, resourceName, resourceType, subDirName);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1F40D7538](bundleID);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1F40D7568](bundle);
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7578](bundle);
}

uint64_t CFBundleGetLocalizationInfoForLocalization()
{
  return MEMORY[0x1F40D7590]();
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1F40D7598]();
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1F40D75D0](bundle, key);
}

CFCharacterSetRef CFCharacterSetCreateInvertedSet(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7710](alloc, theSet);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7738](alloc, theString);
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7740](theSetIdentifier);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return MEMORY[0x1F40D7770](theSet, theChar);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1F40D77A8](cf);
}

uint64_t CFCopyHomeDirectoryURLForUser()
{
  return MEMORY[0x1F40D77B8]();
}

uint64_t CFCopySearchPathForDirectoriesInDomains()
{
  return MEMORY[0x1F40D77C0]();
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1F40D77F8](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7808](allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7810](allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1F40D7818](allocator, bytes, length, bytesDeallocator);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1F40D7858](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1F40D7860]();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1F40D7898](allocator, at);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  MEMORY[0x1F40D7928](theDate);
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1F40D7938]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7990](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1F40D7A18](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1F40D7A80](err);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7A90](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1F40D7A98](allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1F40D7AA8](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x1F40D7AB8](err);
}

CFTypeID CFErrorGetTypeID(void)
{
  return MEMORY[0x1F40D7AC0]();
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1F40D7B60](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFAbsoluteTime CFGregorianDateGetAbsoluteTime(CFGregorianDate gdate, CFTimeZoneRef tz)
{
  MEMORY[0x1F40D7B90](*(void *)&gdate.year, *(void *)&gdate.second, tz);
  return result;
}

Boolean CFGregorianDateIsValid(CFGregorianDate gdate, CFOptionFlags unitFlags)
{
  return MEMORY[0x1F40D7B98](*(void *)&gdate.year, *(void *)&gdate.second, unitFlags);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1F40D7BA0](cf);
}

CFLocaleRef CFLocaleGetSystem(void)
{
  return (CFLocaleRef)MEMORY[0x1F40D7C38]();
}

uint64_t CFLog()
{
  return MEMORY[0x1F40D7C50]();
}

CFRunLoopSourceRef CFMachPortCreateRunLoopSource(CFAllocatorRef allocator, CFMachPortRef port, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x1F40D7C60](allocator, port, order);
}

CFMachPortRef CFMachPortCreateWithPort(CFAllocatorRef allocator, mach_port_t portNum, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)MEMORY[0x1F40D7C68](allocator, *(void *)&portNum, callout, context, shouldFreeInfo);
}

CFTypeID CFMachPortGetTypeID(void)
{
  return MEMORY[0x1F40D7C80]();
}

void CFMachPortInvalidate(CFMachPortRef port)
{
}

CFTypeRef CFMakeCollectable(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D7CA0](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D08]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

void CFNotificationCenterRemoveEveryObserver(CFNotificationCenterRef center, const void *observer)
{
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1F40D7D68]();
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

Boolean CFPreferencesAppValueIsForced(CFStringRef key, CFStringRef applicationID)
{
  return MEMORY[0x1F40D7E98](key, applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7EA0](key, applicationID);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7ED0](key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE0](key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE8](key, applicationID, keyExistsAndHasValidFormat);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1F40D7F18](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F50](allocator, data, options, format, error);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F58](allocator, stream, streamLength, options, format, error);
}

Boolean CFPropertyListIsValid(CFPropertyListRef plist, CFPropertyListFormat format)
{
  return MEMORY[0x1F40D7F68](plist, format);
}

CFIndex CFPropertyListWrite(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return MEMORY[0x1F40D7F70](propertyList, stream, format, options, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

dispatch_queue_t CFReadStreamCopyDispatchQueue(CFReadStreamRef stream)
{
  return (dispatch_queue_t)MEMORY[0x1F40D7F90](stream);
}

CFErrorRef CFReadStreamCopyError(CFReadStreamRef stream)
{
  return (CFErrorRef)MEMORY[0x1F40D7F98](stream);
}

CFTypeRef CFReadStreamCopyProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1F40D7FA0](stream, propertyName);
}

uint64_t CFReadStreamCreate()
{
  return MEMORY[0x1F40D7FA8]();
}

CFReadStreamRef CFReadStreamCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFReadStreamRef)MEMORY[0x1F40D7FB0](alloc, bytes, length, bytesDeallocator);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1F40D7FC0](alloc, fileURL);
}

CFStreamError CFReadStreamGetError(CFReadStreamRef stream)
{
  CFIndex v1 = MEMORY[0x1F40D7FD0](stream);
  result.SInt32 error = v2;
  result.CFIndex domain = v1;
  return result;
}

uint64_t CFReadStreamGetInfoPointer()
{
  return MEMORY[0x1F40D7FD8]();
}

CFStreamStatus CFReadStreamGetStatus(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FE0](stream);
}

CFTypeID CFReadStreamGetTypeID(void)
{
  return MEMORY[0x1F40D7FE8]();
}

Boolean CFReadStreamHasBytesAvailable(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF0](stream);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF8](stream);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1F40D8000](stream, buffer, bufferLength);
}

void CFReadStreamScheduleWithRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
}

Boolean CFReadStreamSetClient(CFReadStreamRef stream, CFOptionFlags streamEvents, CFReadStreamClientCallBack clientCB, CFStreamClientContext *clientContext)
{
  return MEMORY[0x1F40D8010](stream, streamEvents, clientCB, clientContext);
}

void CFReadStreamSetDispatchQueue(CFReadStreamRef stream, dispatch_queue_t q)
{
}

Boolean CFReadStreamSetProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  return MEMORY[0x1F40D8020](stream, propertyName, propertyValue);
}

uint64_t CFReadStreamSignalEvent()
{
  return MEMORY[0x1F40D8028]();
}

void CFReadStreamUnscheduleFromRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
}

Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  return MEMORY[0x1F40D8088](rl, source, mode);
}

CFRunLoopMode CFRunLoopCopyCurrentMode(CFRunLoopRef rl)
{
  return (CFRunLoopMode)MEMORY[0x1F40D80A0](rl);
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1F40D80B0]();
}

Boolean CFRunLoopIsWaiting(CFRunLoopRef rl)
{
  return MEMORY[0x1F40D80D0](rl);
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return MEMORY[0x1F40D8128](mode, returnAfterSourceHandled, seconds);
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x1F40D8140](allocator, order, context);
}

void CFRunLoopSourceGetContext(CFRunLoopSourceRef source, CFRunLoopSourceContext *context)
{
}

CFTypeID CFRunLoopSourceGetTypeID(void)
{
  return MEMORY[0x1F40D8150]();
}

void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source)
{
}

Boolean CFRunLoopSourceIsValid(CFRunLoopSourceRef source)
{
  return MEMORY[0x1F40D8160](source);
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
}

void CFRunLoopStop(CFRunLoopRef rl)
{
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  return (CFRunLoopTimerRef)MEMORY[0x1F40D8180](allocator, flags, order, callout, context, fireDate, interval);
}

CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, void *block)
{
  return (CFRunLoopTimerRef)MEMORY[0x1F40D8188](allocator, flags, order, block, fireDate, interval);
}

CFTypeID CFRunLoopTimerGetTypeID(void)
{
  return MEMORY[0x1F40D81B8]();
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
}

Boolean CFRunLoopTimerIsValid(CFRunLoopTimerRef timer)
{
  return MEMORY[0x1F40D81C8](timer);
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1F40D81F8](theSet, value);
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  return (CFSetRef)MEMORY[0x1F40D8200](allocator, values, numValues, callBacks);
}

CFSetRef CFSetCreateCopy(CFAllocatorRef allocator, CFSetRef theSet)
{
  return (CFSetRef)MEMORY[0x1F40D8208](allocator, theSet);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8210](allocator, capacity, callBacks);
}

CFMutableSetRef CFSetCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFSetRef theSet)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8218](allocator, capacity, theSet);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1F40D8220](theSet);
}

CFTypeID CFSetGetTypeID(void)
{
  return MEMORY[0x1F40D8230]();
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
}

void CFSetRemoveAllValues(CFMutableSetRef theSet)
{
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
}

void CFShow(CFTypeRef obj)
{
}

CFDataRef CFSocketCopyAddress(CFSocketRef s)
{
  return (CFDataRef)MEMORY[0x1F40D8278](s);
}

CFDataRef CFSocketCopyPeerAddress(CFSocketRef s)
{
  return (CFDataRef)MEMORY[0x1F40D8280](s);
}

CFSocketRef CFSocketCreate(CFAllocatorRef allocator, SInt32 protocolFamily, SInt32 socketType, SInt32 protocol, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  return (CFSocketRef)MEMORY[0x1F40D8288](allocator, *(void *)&protocolFamily, *(void *)&socketType, *(void *)&protocol, callBackTypes, callout, context);
}

CFRunLoopSourceRef CFSocketCreateRunLoopSource(CFAllocatorRef allocator, CFSocketRef s, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x1F40D8290](allocator, s, order);
}

CFSocketRef CFSocketCreateWithNative(CFAllocatorRef allocator, CFSocketNativeHandle sock, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  return (CFSocketRef)MEMORY[0x1F40D8298](allocator, *(void *)&sock, callBackTypes, callout, context);
}

void CFSocketDisableCallBacks(CFSocketRef s, CFOptionFlags callBackTypes)
{
}

void CFSocketEnableCallBacks(CFSocketRef s, CFOptionFlags callBackTypes)
{
}

CFSocketNativeHandle CFSocketGetNative(CFSocketRef s)
{
  return MEMORY[0x1F40D82B0](s);
}

CFOptionFlags CFSocketGetSocketFlags(CFSocketRef s)
{
  return MEMORY[0x1F40D82B8](s);
}

CFTypeID CFSocketGetTypeID(void)
{
  return MEMORY[0x1F40D82C0]();
}

void CFSocketInvalidate(CFSocketRef s)
{
}

Boolean CFSocketIsValid(CFSocketRef s)
{
  return MEMORY[0x1F40D82D0](s);
}

CFSocketError CFSocketSetAddress(CFSocketRef s, CFDataRef address)
{
  return MEMORY[0x1F40D82D8](s, address);
}

void CFSocketSetSocketFlags(CFSocketRef s, CFOptionFlags flags)
{
}

void CFStreamCreateBoundPair(CFAllocatorRef alloc, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream, CFIndex transferBufferSize)
{
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8390](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

unint64_t CFStringConvertEncodingToNSStringEncoding(CFStringEncoding encoding)
{
  return MEMORY[0x1F40D83A8](*(void *)&encoding);
}

CFStringEncoding CFStringConvertNSStringEncodingToEncoding(unint64_t encoding)
{
  return MEMORY[0x1F40D83C0](encoding);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1F40D83D0](alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1F40D83E0](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return (CFDataRef)MEMORY[0x1F40D83F8](alloc, theString, *(void *)&encoding, lossByte);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8410](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8440](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8458](alloc, cStr, *(void *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1F40D8460](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  return (CFStringRef)MEMORY[0x1F40D8478](alloc, buffer);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1F40D8498](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithPascalString(CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D84A0](alloc, pStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x1F40D84C8](theString, stringToFind, compareOptions);
  result.socklen_t length = v4;
  result.id location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D84D0](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84D8](theString, theSet, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84E0](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1F40D8500](theString, range.location, range.length, *(void *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1F40D8528](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return (const UniChar *)MEMORY[0x1F40D8540](theString);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  MEMORY[0x1F40D8548](str);
  return result;
}

CFStringEncoding CFStringGetFastestEncoding(CFStringRef theString)
{
  return MEMORY[0x1F40D8550](theString);
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8558](string, buffer, maxBufLen);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1F40D8568](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8590](length, *(void *)&encoding);
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  return MEMORY[0x1F40D85A0](string);
}

Boolean CFStringGetPascalString(CFStringRef theString, StringPtr buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D85C0](theString, buffer, bufferSize, *(void *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1F40D8600](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1F40D8608](theString, suffix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
}

CFTimeZoneRef CFTimeZoneCopyDefault(void)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D86E8]();
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D86F8]();
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D8708](allocator, ti);
}

CFTimeInterval CFTimeZoneGetSecondsFromGMT(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  MEMORY[0x1F40D8718](tz, at);
  return result;
}

Boolean CFURLCanBeDecomposed(CFURLRef anURL)
{
  return MEMORY[0x1F40D8728](anURL);
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1F40D8740](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1F40D8758](anURL, pathStyle);
}

CFStringRef CFURLCopyHostName(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8768](anURL);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8770](url);
}

CFStringRef CFURLCopyNetLocation(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8778](anURL);
}

CFStringRef CFURLCopyPassword(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8788](anURL);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8790](anURL);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8798](url);
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  return MEMORY[0x1F40D87B0](url, key, propertyValueTypeRefPtr, error);
}

CFStringRef CFURLCopyResourceSpecifier(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87B8](anURL);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87C0](anURL);
}

CFStringRef CFURLCopyStrictPath(CFURLRef anURL, Boolean *isAbsolute)
{
  return (CFStringRef)MEMORY[0x1F40D87C8](anURL, isAbsolute);
}

CFStringRef CFURLCopyUserName(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87D0](anURL);
}

CFURLRef CFURLCreateAbsoluteURLWithBytes(CFAllocatorRef alloc, const UInt8 *relativeURLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL, Boolean useCompatibilityMode)
{
  return (CFURLRef)MEMORY[0x1F40D87D8](alloc, relativeURLBytes, length, *(void *)&encoding, baseURL, useCompatibilityMode);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D87F8](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1F40D8808](allocator, url);
}

CFURLRef CFURLCreateCopyDeletingPathExtension(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1F40D8810](allocator, url);
}

Boolean CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  return MEMORY[0x1F40D8828](alloc, url, resourceData, properties, desiredProperties, errorCode);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D8848](allocator, buffer, bufLen, isDirectory);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8870](allocator, originalString, charactersToLeaveUnescaped, legalURLCharactersToBeEscaped, *(void *)&encoding);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  return (CFStringRef)MEMORY[0x1F40D8878](allocator, originalString, charactersToLeaveEscaped);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapesUsingEncoding(CFAllocatorRef allocator, CFStringRef origString, CFStringRef charsToLeaveEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8880](allocator, origString, charsToLeaveEscaped, *(void *)&encoding);
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D8888](allocator, URLBytes, length, *(void *)&encoding, baseURL);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPathRelativeToBase(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88A8](allocator, filePath, pathStyle, isDirectory, baseURL);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88C0](allocator, URLString, baseURL);
}

CFURLRef CFURLGetBaseURL(CFURLRef anURL)
{
  return (CFURLRef)MEMORY[0x1F40D88F0](anURL);
}

CFRange CFURLGetByteRangeForComponent(CFURLRef url, CFURLComponentType component, CFRange *rangeIncludingSeparators)
{
  CFIndex v3 = MEMORY[0x1F40D88F8](url, component, rangeIncludingSeparators);
  result.socklen_t length = v4;
  result.id location = v3;
  return result;
}

CFIndex CFURLGetBytes(CFURLRef url, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1F40D8900](url, buffer, bufferLength);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

SInt32 CFURLGetPortNumber(CFURLRef anURL)
{
  return MEMORY[0x1F40D8910](anURL);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8918](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1F40D8928]();
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  return MEMORY[0x1F40D8938](anURL);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1F40D8988](alloc);
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  return (CFUUIDRef)MEMORY[0x1F40D8998](alloc, uuidStr);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1F40D89B0](alloc, uuid);
}

CFTypeID CFUUIDGetTypeID(void)
{
  return MEMORY[0x1F40D89D8]();
}

Boolean CFWriteStreamCanAcceptBytes(CFWriteStreamRef stream)
{
  return MEMORY[0x1F40D8A78](stream);
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
}

CFErrorRef CFWriteStreamCopyError(CFWriteStreamRef stream)
{
  return (CFErrorRef)MEMORY[0x1F40D8A88](stream);
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1F40D8A90](stream, propertyName);
}

uint64_t CFWriteStreamCreate()
{
  return MEMORY[0x1F40D8A98]();
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  return (CFWriteStreamRef)MEMORY[0x1F40D8AA0](alloc, bufferAllocator);
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)MEMORY[0x1F40D8AB0](alloc, fileURL);
}

CFStreamError CFWriteStreamGetError(CFWriteStreamRef stream)
{
  CFIndex v1 = MEMORY[0x1F40D8AB8](stream);
  result.SInt32 error = v2;
  result.CFIndex domain = v1;
  return result;
}

CFStreamStatus CFWriteStreamGetStatus(CFWriteStreamRef stream)
{
  return MEMORY[0x1F40D8AC0](stream);
}

CFTypeID CFWriteStreamGetTypeID(void)
{
  return MEMORY[0x1F40D8AC8]();
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x1F40D8AD0](stream);
}

void CFWriteStreamScheduleWithRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
}

Boolean CFWriteStreamSetClient(CFWriteStreamRef stream, CFOptionFlags streamEvents, CFWriteStreamClientCallBack clientCB, CFStreamClientContext *clientContext)
{
  return MEMORY[0x1F40D8AE0](stream, streamEvents, clientCB, clientContext);
}

void CFWriteStreamSetDispatchQueue(CFWriteStreamRef stream, dispatch_queue_t q)
{
}

Boolean CFWriteStreamSetProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  return MEMORY[0x1F40D8AF0](stream, propertyName, propertyValue);
}

uint64_t CFWriteStreamSignalEvent()
{
  return MEMORY[0x1F40D8AF8]();
}

void CFWriteStreamUnscheduleFromRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1F40D8B08](stream, buffer, bufferLength);
}

DNSServiceErrorType DNSServiceAddRecord(DNSServiceRef sdRef, DNSRecordRef *RecordRef, DNSServiceFlags flags, uint16_t rrtype, uint16_t rdlen, const void *rdata, uint32_t ttl)
{
  return MEMORY[0x1F40C97E0](sdRef, RecordRef, *(void *)&flags, rrtype, rdlen, rdata, *(void *)&ttl);
}

DNSServiceErrorType DNSServiceBrowse(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *regtype, const char *domain, DNSServiceBrowseReply callBack, void *context)
{
  return MEMORY[0x1F40C9808](sdRef, *(void *)&flags, *(void *)&interfaceIndex, regtype, domain, callBack, context);
}

DNSServiceErrorType DNSServiceConstructFullName(char *const fullName, const char *const service, const char *const regtype, const char *const domain)
{
  return MEMORY[0x1F40C9818](fullName, service, regtype, domain);
}

DNSServiceErrorType DNSServiceCreateConnection(DNSServiceRef *sdRef)
{
  return MEMORY[0x1F40C9820](sdRef);
}

DNSServiceErrorType DNSServiceEnumerateDomains(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, DNSServiceDomainEnumReply callBack, void *context)
{
  return MEMORY[0x1F40C9830](sdRef, *(void *)&flags, *(void *)&interfaceIndex, callBack, context);
}

DNSServiceErrorType DNSServiceProcessResult(DNSServiceRef sdRef)
{
  return MEMORY[0x1F40C9858](sdRef);
}

DNSServiceErrorType DNSServiceQueryRecord(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *fullname, uint16_t rrtype, uint16_t rrclass, DNSServiceQueryRecordReply callBack, void *context)
{
  return MEMORY[0x1F40C9860](sdRef, *(void *)&flags, *(void *)&interfaceIndex, fullname, rrtype, rrclass, callBack, context);
}

void DNSServiceRefDeallocate(DNSServiceRef sdRef)
{
}

dnssd_sock_t DNSServiceRefSockFD(DNSServiceRef sdRef)
{
  return MEMORY[0x1F40C9880](sdRef);
}

DNSServiceErrorType DNSServiceRegister(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *name, const char *regtype, const char *domain, const char *host, uint16_t port, uint16_t txtLen, const void *txtRecord, DNSServiceRegisterReply callBack, void *context)
{
  return MEMORY[0x1F40C9888](sdRef, *(void *)&flags, *(void *)&interfaceIndex, name, regtype, domain, host, port);
}

DNSServiceErrorType DNSServiceRemoveRecord(DNSServiceRef sdRef, DNSRecordRef RecordRef, DNSServiceFlags flags)
{
  return MEMORY[0x1F40C9898](sdRef, RecordRef, *(void *)&flags);
}

DNSServiceErrorType DNSServiceResolve(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *name, const char *regtype, const char *domain, DNSServiceResolveReply callBack, void *context)
{
  return MEMORY[0x1F40C98A0](sdRef, *(void *)&flags, *(void *)&interfaceIndex, name, regtype, domain, callBack, context);
}

DNSServiceErrorType DNSServiceUpdateRecord(DNSServiceRef sdRef, DNSRecordRef recordRef, DNSServiceFlags flags, uint16_t rdlen, const void *rdata, uint32_t ttl)
{
  return MEMORY[0x1F40C98C8](sdRef, recordRef, *(void *)&flags, rdlen, rdata, *(void *)&ttl);
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  return MEMORY[0x1F40E8678](*(void *)&kernelPort, notificationID);
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  return MEMORY[0x1F40E8778](notifier);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
}

IOReturn IOPMAssertionCreateWithProperties(CFDictionaryRef AssertionProperties, IOPMAssertionID *AssertionID)
{
  return MEMORY[0x1F40E8F88](AssertionProperties, AssertionID);
}

IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
{
  return MEMORY[0x1F40E8FA8](*(void *)&AssertionID);
}

IOReturn IOPMAssertionSetProperty(IOPMAssertionID theAssertion, CFStringRef theProperty, CFTypeRef theValue)
{
  return MEMORY[0x1F40E8FB8](*(void *)&theAssertion, theProperty, theValue);
}

io_connect_t IORegisterForSystemPower(void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  return MEMORY[0x1F40E9148](refcon, thePortRef, callback, notifier);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x1F40E9240](*(void *)&connect);
}

void NSLog(NSString *format, ...)
{
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x1F40E72C8]();
}

uint64_t NtlmCreateClientRequest()
{
  return MEMORY[0x1F40F67F8]();
}

uint64_t NtlmGeneratePasswordHashes()
{
  return MEMORY[0x1F40F6808]();
}

uint64_t NtlmGeneratorCreate()
{
  return MEMORY[0x1F40F6810]();
}

uint64_t NtlmGeneratorRelease()
{
  return MEMORY[0x1F40F6818]();
}

CFStringRef SCDynamicStoreCopyComputerName(SCDynamicStoreRef store, CFStringEncoding *nameEncoding)
{
  return (CFStringRef)MEMORY[0x1F4101D70](store, nameEncoding);
}

CFArrayRef SCDynamicStoreCopyKeyList(SCDynamicStoreRef store, CFStringRef pattern)
{
  return (CFArrayRef)MEMORY[0x1F4101D88](store, pattern);
}

CFDictionaryRef SCDynamicStoreCopyProxies(SCDynamicStoreRef store)
{
  return (CFDictionaryRef)MEMORY[0x1F4101DA0](store);
}

CFPropertyListRef SCDynamicStoreCopyValue(SCDynamicStoreRef store, CFStringRef key)
{
  return (CFPropertyListRef)MEMORY[0x1F4101DA8](store, key);
}

SCDynamicStoreRef SCDynamicStoreCreate(CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return (SCDynamicStoreRef)MEMORY[0x1F4101DB0](allocator, name, callout, context);
}

CFStringRef SCDynamicStoreKeyCreateNetworkGlobalEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef entity)
{
  return (CFStringRef)MEMORY[0x1F4101DD8](allocator, domain, entity);
}

CFStringRef SCDynamicStoreKeyCreateNetworkInterfaceEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef ifname, CFStringRef entity)
{
  return (CFStringRef)MEMORY[0x1F4101DE8](allocator, domain, ifname, entity);
}

CFStringRef SCDynamicStoreKeyCreateNetworkServiceEntity(CFAllocatorRef allocator, CFStringRef domain, CFStringRef serviceID, CFStringRef entity)
{
  return (CFStringRef)MEMORY[0x1F4101DF0](allocator, domain, serviceID, entity);
}

SCNetworkConnectionRef SCNetworkConnectionCreateWithServiceID(CFAllocatorRef allocator, CFStringRef serviceID, SCNetworkConnectionCallBack callout, SCNetworkConnectionContext *context)
{
  return (SCNetworkConnectionRef)MEMORY[0x1F4101E50](allocator, serviceID, callout, context);
}

SCNetworkConnectionStatus SCNetworkConnectionGetStatus(SCNetworkConnectionRef connection)
{
  return MEMORY[0x1F4101E58](connection);
}

CFTypeID SCNetworkConnectionGetTypeID(void)
{
  return MEMORY[0x1F4101E60]();
}

uint64_t SCNetworkProxiesCopyMatching()
{
  return MEMORY[0x1F4101ED8]();
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithAddress(CFAllocatorRef allocator, const sockaddr *address)
{
  return (SCNetworkReachabilityRef)MEMORY[0x1F4101EE8](allocator, address);
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithName(CFAllocatorRef allocator, const char *nodename)
{
  return (SCNetworkReachabilityRef)MEMORY[0x1F4101EF8](allocator, nodename);
}

Boolean SCNetworkReachabilityGetFlags(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags *flags)
{
  return MEMORY[0x1F4101F08](target, flags);
}

CFTypeID SCNetworkReachabilityGetTypeID(void)
{
  return MEMORY[0x1F4101F10]();
}

Boolean SCNetworkReachabilitySetCallback(SCNetworkReachabilityRef target, SCNetworkReachabilityCallBack callout, SCNetworkReachabilityContext *context)
{
  return MEMORY[0x1F4101F20](target, callout, context);
}

Boolean SCNetworkReachabilitySetDispatchQueue(SCNetworkReachabilityRef target, dispatch_queue_t queue)
{
  return MEMORY[0x1F4101F28](target, queue);
}

uint64_t SCNetworkSignatureCopyIdentifierForConnectedSocket()
{
  return MEMORY[0x1F4101FE0]();
}

OSStatus SSLClose(SSLContextRef context)
{
  return MEMORY[0x1F40F68B0](context);
}

CFTypeID SSLContextGetTypeID(void)
{
  return MEMORY[0x1F40F68B8]();
}

OSStatus SSLCopyDistinguishedNames(SSLContextRef context, CFArrayRef *names)
{
  return MEMORY[0x1F40F68C0](context, names);
}

OSStatus SSLCopyPeerTrust(SSLContextRef context, SecTrustRef *trust)
{
  return MEMORY[0x1F40F68C8](context, trust);
}

SSLContextRef SSLCreateContext(CFAllocatorRef alloc, SSLProtocolSide protocolSide, SSLConnectionType connectionType)
{
  return (SSLContextRef)MEMORY[0x1F40F68D0](alloc, *(void *)&protocolSide, *(void *)&connectionType);
}

uint64_t SSLGetCertificate()
{
  return MEMORY[0x1F40F68E0]();
}

OSStatus SSLGetClientCertificateState(SSLContextRef context, SSLClientCertificateState *clientState)
{
  return MEMORY[0x1F40F68E8](context, clientState);
}

uint64_t SSLGetClientSideAuthenticate()
{
  return MEMORY[0x1F40F68F0]();
}

OSStatus SSLGetNegotiatedCipher(SSLContextRef context, SSLCipherSuite *cipherSuite)
{
  return MEMORY[0x1F40F68F8](context, cipherSuite);
}

OSStatus SSLGetNegotiatedProtocolVersion(SSLContextRef context, SSLProtocol *protocol)
{
  return MEMORY[0x1F40F6900](context, protocol);
}

OSStatus SSLGetPeerDomainName(SSLContextRef context, char *peerName, size_t *peerNameLen)
{
  return MEMORY[0x1F40F6908](context, peerName, peerNameLen);
}

OSStatus SSLGetPeerDomainNameLength(SSLContextRef context, size_t *peerNameLen)
{
  return MEMORY[0x1F40F6910](context, peerNameLen);
}

OSStatus SSLGetPeerID(SSLContextRef context, const void **peerID, size_t *peerIDLen)
{
  return MEMORY[0x1F40F6918](context, peerID, peerIDLen);
}

OSStatus SSLGetProtocolVersionMax(SSLContextRef context, SSLProtocol *maxVersion)
{
  return MEMORY[0x1F40F6920](context, maxVersion);
}

OSStatus SSLGetProtocolVersionMin(SSLContextRef context, SSLProtocol *minVersion)
{
  return MEMORY[0x1F40F6928](context, minVersion);
}

OSStatus SSLGetSessionState(SSLContextRef context, SSLSessionState *state)
{
  return MEMORY[0x1F40F6930](context, state);
}

OSStatus SSLHandshake(SSLContextRef context)
{
  return MEMORY[0x1F40F6938](context);
}

uint64_t SSLProtocolFromVersionCodepoint()
{
  return MEMORY[0x1F40F6940]();
}

OSStatus SSLRead(SSLContextRef context, void *data, size_t dataLength, size_t *processed)
{
  return MEMORY[0x1F40F6948](context, data, dataLength, processed);
}

uint64_t SSLSetALPNData()
{
  return MEMORY[0x1F40F6950]();
}

uint64_t SSLSetALPNFunc()
{
  return MEMORY[0x1F40F6958]();
}

uint64_t SSLSetAllowAnonymousCiphers()
{
  return MEMORY[0x1F40F6960]();
}

OSStatus SSLSetCertificate(SSLContextRef context, CFArrayRef certRefs)
{
  return MEMORY[0x1F40F6968](context, certRefs);
}

OSStatus SSLSetClientSideAuthenticate(SSLContextRef context, SSLAuthenticate auth)
{
  return MEMORY[0x1F40F6970](context, *(void *)&auth);
}

OSStatus SSLSetConnection(SSLContextRef context, SSLConnectionRef connection)
{
  return MEMORY[0x1F40F6978](context, connection);
}

uint64_t SSLSetDHEEnabled()
{
  return MEMORY[0x1F40F6980]();
}

OSStatus SSLSetEnabledCiphers(SSLContextRef context, const SSLCipherSuite *ciphers, size_t numCiphers)
{
  return MEMORY[0x1F40F6988](context, ciphers, numCiphers);
}

OSStatus SSLSetIOFuncs(SSLContextRef context, SSLReadFunc readFunc, SSLWriteFunc writeFunc)
{
  return MEMORY[0x1F40F6990](context, readFunc, writeFunc);
}

uint64_t SSLSetNPNData()
{
  return MEMORY[0x1F40F69A0]();
}

uint64_t SSLSetNPNFunc()
{
  return MEMORY[0x1F40F69A8]();
}

uint64_t SSLSetPSKIdentity()
{
  return MEMORY[0x1F40F69B0]();
}

uint64_t SSLSetPSKSharedSecret()
{
  return MEMORY[0x1F40F69B8]();
}

OSStatus SSLSetPeerDomainName(SSLContextRef context, const char *peerName, size_t peerNameLen)
{
  return MEMORY[0x1F40F69C0](context, peerName, peerNameLen);
}

OSStatus SSLSetPeerID(SSLContextRef context, const void *peerID, size_t peerIDLen)
{
  return MEMORY[0x1F40F69C8](context, peerID, peerIDLen);
}

OSStatus SSLSetProtocolVersionMax(SSLContextRef context, SSLProtocol maxVersion)
{
  return MEMORY[0x1F40F69D0](context, *(void *)&maxVersion);
}

OSStatus SSLSetProtocolVersionMin(SSLContextRef context, SSLProtocol minVersion)
{
  return MEMORY[0x1F40F69D8](context, *(void *)&minVersion);
}

OSStatus SSLSetSessionConfig(SSLContextRef context, CFStringRef config)
{
  return MEMORY[0x1F40F69E0](context, config);
}

OSStatus SSLSetSessionOption(SSLContextRef context, SSLSessionOption option, Boolean value)
{
  return MEMORY[0x1F40F69E8](context, *(void *)&option, value);
}

OSStatus SSLWrite(SSLContextRef context, const void *data, size_t dataLength, size_t *processed)
{
  return MEMORY[0x1F40F69F0](context, data, dataLength, processed);
}

uint64_t SecAccessControlCopyData()
{
  return MEMORY[0x1F40F6A00]();
}

uint64_t SecAccessControlCreateFromData()
{
  return MEMORY[0x1F40F6A10]();
}

CFTypeID SecAccessControlGetTypeID(void)
{
  return MEMORY[0x1F40F6A40]();
}

OSStatus SecCertificateCopyCommonName(SecCertificateRef certificate, CFStringRef *commonName)
{
  return MEMORY[0x1F40F6AB8](certificate, commonName);
}

uint64_t SecCertificateCopyDNSNames()
{
  return MEMORY[0x1F40F6AC8]();
}

CFDataRef SecCertificateCopyData(SecCertificateRef certificate)
{
  return (CFDataRef)MEMORY[0x1F40F6AD0](certificate);
}

OSStatus SecCertificateCopyEmailAddresses(SecCertificateRef certificate, CFArrayRef *emailAddresses)
{
  return MEMORY[0x1F40F6AE0](certificate, emailAddresses);
}

uint64_t SecCertificateCopyIssuerSummary()
{
  return MEMORY[0x1F40F6B00]();
}

CFStringRef SecCertificateCopySubjectSummary(SecCertificateRef certificate)
{
  return (CFStringRef)MEMORY[0x1F40F6B68](certificate);
}

SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef allocator, CFDataRef data)
{
  return (SecCertificateRef)MEMORY[0x1F40F6B80](allocator, data);
}

uint64_t SecCertificateGetSignatureHashAlgorithm()
{
  return MEMORY[0x1F40F6BB0]();
}

CFTypeID SecCertificateGetTypeID(void)
{
  return MEMORY[0x1F40F6BB8]();
}

uint64_t SecGenerateSelfSignedCertificate()
{
  return MEMORY[0x1F40F6DB0]();
}

OSStatus SecIdentityCopyCertificate(SecIdentityRef identityRef, SecCertificateRef *certificateRef)
{
  return MEMORY[0x1F40F6DB8](identityRef, certificateRef);
}

uint64_t SecIdentityCreate()
{
  return MEMORY[0x1F40F6DC8]();
}

CFTypeID SecIdentityGetTypeID(void)
{
  return MEMORY[0x1F40F6DD0]();
}

SecKeyRef SecKeyCreateRandomKey(CFDictionaryRef parameters, CFErrorRef *error)
{
  return (SecKeyRef)MEMORY[0x1F40F6EE0](parameters, error);
}

uint64_t SecKeyGetAlgorithmId()
{
  return MEMORY[0x1F40F6F38]();
}

size_t SecKeyGetBlockSize(SecKeyRef key)
{
  return MEMORY[0x1F40F6F40](key);
}

CFTypeID SecKeyGetTypeID(void)
{
  return MEMORY[0x1F40F6F58]();
}

CFDictionaryRef SecPolicyCopyProperties(SecPolicyRef policyRef)
{
  return (CFDictionaryRef)MEMORY[0x1F40F6FC8](policyRef);
}

SecPolicyRef SecPolicyCreateBasicX509(void)
{
  return (SecPolicyRef)MEMORY[0x1F40F7048]();
}

SecPolicyRef SecPolicyCreateSSL(Boolean server, CFStringRef hostname)
{
  return (SecPolicyRef)MEMORY[0x1F40F7088](server, hostname);
}

SecPolicyRef SecPolicyCreateWithProperties(CFTypeRef policyIdentifier, CFDictionaryRef properties)
{
  return (SecPolicyRef)MEMORY[0x1F40F70A0](policyIdentifier, properties);
}

CFTypeID SecPolicyGetTypeID(void)
{
  return MEMORY[0x1F40F70C0]();
}

uint64_t SecPolicySetATSPinning()
{
  return MEMORY[0x1F40F70C8]();
}

uint64_t SecPolicySetSSLHostname()
{
  return MEMORY[0x1F40F70D0]();
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1F40F7138](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x1F40F7160](allocator);
}

CFArrayRef SecTrustCopyCertificateChain(SecTrustRef trust)
{
  return (CFArrayRef)MEMORY[0x1F40F7190](trust);
}

CFDataRef SecTrustCopyExceptions(SecTrustRef trust)
{
  return (CFDataRef)MEMORY[0x1F40F71A0](trust);
}

SecKeyRef SecTrustCopyKey(SecTrustRef trust)
{
  return (SecKeyRef)MEMORY[0x1F40F71B8](trust);
}

OSStatus SecTrustCopyPolicies(SecTrustRef trust, CFArrayRef *policies)
{
  return MEMORY[0x1F40F71C0](trust, policies);
}

CFArrayRef SecTrustCopyProperties(SecTrustRef trust)
{
  return (CFArrayRef)MEMORY[0x1F40F71C8](trust);
}

OSStatus SecTrustCreateWithCertificates(CFTypeRef certificates, CFTypeRef policies, SecTrustRef *trust)
{
  return MEMORY[0x1F40F71E0](certificates, policies, trust);
}

uint64_t SecTrustDeserialize()
{
  return MEMORY[0x1F40F71E8]();
}

OSStatus SecTrustEvaluate(SecTrustRef trust, SecTrustResultType *result)
{
  return MEMORY[0x1F40F71F0](trust, result);
}

uint64_t SecTrustEvaluateFastAsync()
{
  return MEMORY[0x1F40F7208]();
}

BOOL SecTrustEvaluateWithError(SecTrustRef trust, CFErrorRef *error)
{
  return MEMORY[0x1F40F7210](trust, error);
}

CFIndex SecTrustGetCertificateCount(SecTrustRef trust)
{
  return MEMORY[0x1F40F7228](trust);
}

CFTypeID SecTrustGetTypeID(void)
{
  return MEMORY[0x1F40F7238]();
}

uint64_t SecTrustReportNetworkingAnalytics()
{
  return MEMORY[0x1F40F7248]();
}

uint64_t SecTrustSerialize()
{
  return MEMORY[0x1F40F7250]();
}

BOOL SecTrustSetExceptions(SecTrustRef trust, CFDataRef exceptions)
{
  return MEMORY[0x1F40F7270](trust, exceptions);
}

uint64_t SecTrustSetPinningPolicyName()
{
  return MEMORY[0x1F40F7288]();
}

void TXTRecordCreate(TXTRecordRef *txtRecord, uint16_t bufferLen, void *buffer)
{
}

void TXTRecordDeallocate(TXTRecordRef *txtRecord)
{
}

const void *__cdecl TXTRecordGetBytesPtr(const TXTRecordRef *txtRecord)
{
  return (const void *)MEMORY[0x1F40C9A38](txtRecord);
}

uint16_t TXTRecordGetCount(uint16_t txtLen, const void *txtRecord)
{
  return MEMORY[0x1F40C9A40](txtLen, txtRecord);
}

DNSServiceErrorType TXTRecordGetItemAtIndex(uint16_t txtLen, const void *txtRecord, uint16_t itemIndex, uint16_t keyBufLen, char *key, uint8_t *valueLen, const void **value)
{
  return MEMORY[0x1F40C9A48](txtLen, txtRecord, itemIndex, keyBufLen, key, valueLen, value);
}

uint16_t TXTRecordGetLength(const TXTRecordRef *txtRecord)
{
  return MEMORY[0x1F40C9A50](txtRecord);
}

DNSServiceErrorType TXTRecordSetValue(TXTRecordRef *txtRecord, const char *key, uint8_t valueSize, const void *value)
{
  return MEMORY[0x1F40C9A68](txtRecord, key, valueSize, value);
}

CFStringRef UTTypeCopyPreferredTagWithClass(CFStringRef inUTI, CFStringRef inTagClass)
{
  return (CFStringRef)MEMORY[0x1F40DEE50](inUTI, inTagClass);
}

CFStringRef UTTypeCreatePreferredIdentifierForTag(CFStringRef inTagClass, CFStringRef inTag, CFStringRef inConformingToUTI)
{
  return (CFStringRef)MEMORY[0x1F40DEE60](inTagClass, inTag, inConformingToUTI);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFGetProgname()
{
  return MEMORY[0x1F40D8E00]();
}

uint64_t _CFReadStreamSignalEventDelayed()
{
  return MEMORY[0x1F40D9070]();
}

uint64_t _CFRunLoop01()
{
  return MEMORY[0x1F40D9088]();
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeGetClassWithTypeID()
{
  return MEMORY[0x1F40D90D8]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

uint64_t _CFURLCopyComponents()
{
  return MEMORY[0x1F40D9238]();
}

uint64_t _CFURLCopyPropertyListRepresentation()
{
  return MEMORY[0x1F40D9288]();
}

uint64_t _CFURLCreateFromComponents()
{
  return MEMORY[0x1F40D92D8]();
}

uint64_t _CFURLCreateFromPropertyListRepresentation()
{
  return MEMORY[0x1F40D92E0]();
}

uint64_t _CFURLGetEncoding()
{
  return MEMORY[0x1F40D9330]();
}

uint64_t _CFURLIsFileURL()
{
  return MEMORY[0x1F40D9348]();
}

uint64_t _CFWriteStreamCreateFromFileDescriptor()
{
  return MEMORY[0x1F40D93B0]();
}

uint64_t _CFWriteStreamSignalEventDelayed()
{
  return MEMORY[0x1F40D93D0]();
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return MEMORY[0x1F40D9438]();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return MEMORY[0x1F40D9450]();
}

uint64_t _NtlmCreateClientResponse()
{
  return MEMORY[0x1F40F72C8]();
}

uint64_t _SSLCopyPeerCertificates()
{
  return MEMORY[0x1F40F72E8]();
}

uint64_t _SSLGetDiffieHellmanParams()
{
  return MEMORY[0x1F40F72F8]();
}

uint64_t _SSLSetAllowsAnyRoot()
{
  return MEMORY[0x1F40F7308]();
}

uint64_t _SSLSetAllowsExpiredCerts()
{
  return MEMORY[0x1F40F7310]();
}

uint64_t _SSLSetAllowsExpiredRoots()
{
  return MEMORY[0x1F40F7318]();
}

uint64_t _SSLSetDiffieHellmanParams()
{
  return MEMORY[0x1F40F7320]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x1F417E380](this, __c, __pos);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return MEMORY[0x1F417E390](this, __s);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1F417E3A8]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5A0](this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E5B8](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E600](this, __pos, __s);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x1F417E730]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1F417E740]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1F417E748]();
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x1F417E7A0]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1F417E7C0]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E898]();
}

uint64_t std::ifstream::open()
{
  return MEMORY[0x1F417E930]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1F417E940]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1F417EA90](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

void std::__libcpp_verbose_abort(const char *__format, ...)
{
}

int std::stoi(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1F417EBE0](__str, __idx, *(void *)&__base);
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

uint64_t std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>()
{
  return MEMORY[0x1F417EC58]();
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1F417EE70](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x1F417EE78](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return (std::string *)MEMORY[0x1F417EE98](retstr, __val);
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

uint64_t __CFDataMtbl()
{
  return MEMORY[0x1F40D9568]();
}

uint64_t __CFSocketRead()
{
  return MEMORY[0x1F40D95A8]();
}

uint64_t __CFSocketSetSocketReadBufferAttrs()
{
  return MEMORY[0x1F40D95B0]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return MEMORY[0x1F40C9B68](*(void *)&a1, a2, *(void *)&a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1F40C9C18](*(void *)&a1, a2);
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9CF8](*(void *)&a1);
}

uint64_t _getaddrinfo_interface_async_call()
{
  return MEMORY[0x1F40C9F40]();
}

uint64_t _getnameinfo_interface_async_call()
{
  return MEMORY[0x1F40C9F48]();
}

uint64_t _os_crash()
{
  return MEMORY[0x1F40C9FA0]();
}

uint64_t _os_crash_msg()
{
  return MEMORY[0x1F40C9FA8]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x1F40C9FF8]();
}

uint64_t _os_nospin_lock_lock()
{
  return MEMORY[0x1F40CA010]();
}

uint64_t _os_nospin_lock_unlock()
{
  return MEMORY[0x1F40CA020]();
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _xpc_runtime_is_app_sandboxed()
{
  return MEMORY[0x1F40CA1D8]();
}

void abort(void)
{
}

int acl_free(void *obj_p)
{
  return MEMORY[0x1F40CA270](obj_p);
}

acl_t acl_get_link_np(const char *path_p, acl_type_t type)
{
  return (acl_t)MEMORY[0x1F40CA2A8](path_p, *(void *)&type);
}

char *__cdecl acl_to_text(acl_t acl, ssize_t *len_p)
{
  return (char *)MEMORY[0x1F40CA328](acl, len_p);
}

uint32_t arc4random(void)
{
  return MEMORY[0x1F40CA3A8]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1F40CA3C0](*(void *)&__upper_bound);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1F40CA440](a1, a2);
}

int atexit(void (*a1)(void))
{
  return MEMORY[0x1F40CA488](a1);
}

int atoi(const char *a1)
{
  return MEMORY[0x1F40CA4A8](a1);
}

uint64_t atol(const char *a1)
{
  return MEMORY[0x1F40CA4B8](a1);
}

void backtrace_image_offsets(void *const *array, image_offset *image_offsets, int size)
{
}

kern_return_t bootstrap_look_up(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1F40CA548](*(void *)&bp, service_name, sp);
}

void bzero(void *a1, size_t a2)
{
}

const char *__cdecl class_getName(Class cls)
{
  return (const char *)MEMORY[0x1F4181548](cls);
}

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
{
  return MEMORY[0x1F40CB3D8](*(void *)&__clock_id);
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

compression_status compression_stream_destroy(compression_stream *stream)
{
  return MEMORY[0x1F417F0C0](stream);
}

compression_status compression_stream_init(compression_stream *stream, compression_stream_operation operation, compression_algorithm algorithm)
{
  return MEMORY[0x1F417F0D0](stream, *(void *)&operation, *(void *)&algorithm);
}

compression_status compression_stream_process(compression_stream *stream, int flags)
{
  return MEMORY[0x1F417F0E0](stream, *(void *)&flags);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return MEMORY[0x1F40CB438](*(void *)&a1, a2, a3);
}

uint64_t container_system_group_path_for_identifier()
{
  return MEMORY[0x1F40CB7F8]();
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  return MEMORY[0x1F4182BC0](crc, buf, *(void *)&len);
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1F40CB910](a1, a2);
}

uint64_t dirstat_np()
{
  return MEMORY[0x1F40CB918]();
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1F40CB9C0](flags, block);
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1F40CB9C8](flags, *(void *)&qos_class, *(void *)&relative_priority, block);
}

uint64_t dispatch_block_create_with_voucher_and_qos_class()
{
  return MEMORY[0x1F40CB9D8]();
}

BOOL dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier)
{
  return MEMORY[0x1F40CBA00](data, applier);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x1F40CBA10](buffer, size, queue, destructor);
}

uint64_t dispatch_data_create_alloc()
{
  return MEMORY[0x1F40CBA18]();
}

dispatch_data_t dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2)
{
  return (dispatch_data_t)MEMORY[0x1F40CBA20](data1, data2);
}

dispatch_data_t dispatch_data_create_map(dispatch_data_t data, const void **buffer_ptr, size_t *size_ptr)
{
  return (dispatch_data_t)MEMORY[0x1F40CBA30](data, buffer_ptr, size_ptr);
}

dispatch_data_t dispatch_data_create_subrange(dispatch_data_t data, size_t offset, size_t length)
{
  return (dispatch_data_t)MEMORY[0x1F40CBA38](data, offset, length);
}

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return MEMORY[0x1F40CBA48](data);
}

dispatch_queue_t dispatch_get_current_queue(void)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBA58]();
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1F40CBA60](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1F40CBA88]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBAC0](group, timeout);
}

void dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier)
{
}

void dispatch_io_close(dispatch_io_t channel, dispatch_io_close_flags_t flags)
{
}

dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void *cleanup_handler)
{
  return (dispatch_io_t)MEMORY[0x1F40CBAD8](type, *(void *)&fd, queue, cleanup_handler);
}

dispatch_fd_t dispatch_io_get_descriptor(dispatch_io_t channel)
{
  return MEMORY[0x1F40CBAF0](channel);
}

void dispatch_io_set_low_water(dispatch_io_t channel, size_t low_water)
{
}

void dispatch_io_write(dispatch_io_t channel, off_t offset, dispatch_data_t data, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBA8](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBB8](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  return (const char *)MEMORY[0x1F40CBBD8](queue);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return MEMORY[0x1F40CBD40](when, delta);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

int dup(int a1)
{
  return MEMORY[0x1F40CBDF8](*(void *)&a1);
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1F40CBEC8]();
}

void exit(int a1)
{
}

int fchown(int a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x1F40CC038](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  return (FILE *)MEMORY[0x1F40CC070](*(void *)&a1, a2);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1F40CC0C8](a1);
}

int ffsctl(int a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x1F40CC0D8](*(void *)&a1, a2, a3, *(void *)&a4);
}

ssize_t fgetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1F40CC108](*(void *)&fd, name, value, size, *(void *)&position, *(void *)&options);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1F40CC1E8](*(void *)&a1, a2);
}

void free(void *a1)
{
}

void freeaddrinfo(addrinfo *a1)
{
}

void freeifaddrs(ifaddrs *a1)
{
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x1F40CC288](a1, a2, a3, *(void *)&a4);
}

int fsetxattr(int fd, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1F40CC2A8](*(void *)&fd, name, value, size, *(void *)&position, *(void *)&options);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return MEMORY[0x1F40CC348](a1, a2, a3, a4);
}

uint64_t getaddrinfo_async_handle_reply()
{
  return MEMORY[0x1F40CC350]();
}

uint64_t getaddrinfo_async_start()
{
  return MEMORY[0x1F40CC358]();
}

gid_t getegid(void)
{
  return MEMORY[0x1F40CC3A8]();
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1F40CC3B0](a1);
}

uid_t geteuid(void)
{
  return MEMORY[0x1F40CC3B8]();
}

gid_t getgid(void)
{
  return MEMORY[0x1F40CC3D0]();
}

hostent *__cdecl gethostbyname(const char *a1)
{
  return (hostent *)MEMORY[0x1F40CC3F8](a1);
}

int gethostname(char *a1, size_t a2)
{
  return MEMORY[0x1F40CC400](a1, a2);
}

int getifaddrs(ifaddrs **a1)
{
  return MEMORY[0x1F40CC410](a1);
}

int getnameinfo(const sockaddr *a1, socklen_t a2, char *a3, socklen_t a4, char *a5, socklen_t a6, int a7)
{
  return MEMORY[0x1F40CC450](a1, *(void *)&a2, a3, *(void *)&a4, a5, *(void *)&a6, *(void *)&a7);
}

uint64_t getnameinfo_async_start()
{
  return MEMORY[0x1F40CC460]();
}

int getpeername(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1F40CC488](*(void *)&a1, a2, a3);
}

pid_t getpid(void)
{
  return MEMORY[0x1F40CC4A0]();
}

protoent *__cdecl getprotobyname(const char *a1)
{
  return (protoent *)MEMORY[0x1F40CC4C8](a1);
}

int getrlimit(int a1, rlimit *a2)
{
  return MEMORY[0x1F40CC500](*(void *)&a1, a2);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1F40CC558](*(void *)&a1, a2, a3);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return MEMORY[0x1F40CC560](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1F40CC568](a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x1F40CC570]();
}

kern_return_t host_check_multiuser_mode(host_t host, uint32_t *multiuser_mode)
{
  return MEMORY[0x1F40CC5E8](*(void *)&host, multiuser_mode);
}

char *__cdecl if_indextoname(unsigned int a1, char *a2)
{
  return (char *)MEMORY[0x1F40CC648](*(void *)&a1, a2);
}

unsigned int if_nametoindex(const char *a1)
{
  return MEMORY[0x1F40CC650](a1);
}

in_addr_t inet_addr(const char *a1)
{
  return MEMORY[0x1F40CC660](a1);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return (const char *)MEMORY[0x1F40CC678](*(void *)&a1, a2, a3, *(void *)&a4);
}

int inet_pton(int a1, const char *a2, void *a3)
{
  return MEMORY[0x1F40CC680](*(void *)&a1, a2, a3);
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x1F4182CB0](strm, *(void *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x1F4182CB8](strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return MEMORY[0x1F4182CC8](strm, *(void *)&windowBits, version, *(void *)&stream_size);
}

int inflateInit_(z_streamp strm, const char *version, int stream_size)
{
  return MEMORY[0x1F4182CD8](strm, version, *(void *)&stream_size);
}

int ioctl(int a1, unint64_t a2, ...)
{
  return MEMORY[0x1F40CC690](*(void *)&a1, a2);
}

int issetugid(void)
{
  return MEMORY[0x1F40CC6C0]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1F40CC700]();
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1F40CC8F8](*(void *)&a1, a2, *(void *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CC900](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1F40CC910]();
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x1F40CC970](msg, *(void *)&option, *(void *)&send_size, *(void *)&rcv_size, *(void *)&rcv_name, *(void *)&timeout, *(void *)&notify);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1F40CC9B8](*(void *)&task, *(void *)&name);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1F40CCA60](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1F40CCDD0](a1, a2);
}

int mkpath_np(const char *path, mode_t omode)
{
  return MEMORY[0x1F40CCE00](path, omode);
}

int mkstemps(char *a1, int a2)
{
  return MEMORY[0x1F40CCE18](a1, *(void *)&a2);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1F40CCE40](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

long double modf(long double __x, long double *__y)
{
  MEMORY[0x1F40CCE48](__y, __x);
  return result;
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE88](a1, a2);
}

uint64_t ne_tracker_check_is_hostname_blocked()
{
  return MEMORY[0x1F40CCF80]();
}

uint64_t ne_tracker_copy_current_stacktrace()
{
  return MEMORY[0x1F40CCF88]();
}

uint64_t ne_tracker_should_save_stacktrace()
{
  return MEMORY[0x1F40CCFA0]();
}

uint64_t network_proxy_copy_host()
{
  return MEMORY[0x1F40F2840]();
}

uint64_t network_proxy_create_from_parameters()
{
  return MEMORY[0x1F40F2848]();
}

uint64_t network_proxy_get_port()
{
  return MEMORY[0x1F40F2850]();
}

uint64_t network_proxy_get_type()
{
  return MEMORY[0x1F40F2858]();
}

uint64_t network_proxy_is_transparent()
{
  return MEMORY[0x1F40F2860]();
}

uint64_t nghttp2_check_header_name()
{
  return MEMORY[0x1F417DE08]();
}

uint64_t nghttp2_check_header_value()
{
  return MEMORY[0x1F417DE10]();
}

uint64_t nghttp2_option_del()
{
  return MEMORY[0x1F417DE20]();
}

uint64_t nghttp2_option_new()
{
  return MEMORY[0x1F417DE28]();
}

uint64_t nghttp2_option_set_no_auto_window_update()
{
  return MEMORY[0x1F417DE30]();
}

uint64_t nghttp2_option_set_no_rfc9113_leading_and_trailing_ws_validation()
{
  return MEMORY[0x1F417DE50]();
}

uint64_t nghttp2_priority_spec_init()
{
  return MEMORY[0x1F417DE60]();
}

uint64_t nghttp2_session_callbacks_new()
{
  return MEMORY[0x1F417DE70]();
}

uint64_t nghttp2_session_callbacks_set_before_frame_send_callback()
{
  return MEMORY[0x1F417DE78]();
}

uint64_t nghttp2_session_callbacks_set_on_begin_headers_callback()
{
  return MEMORY[0x1F417DE88]();
}

uint64_t nghttp2_session_callbacks_set_on_data_chunk_recv_callback()
{
  return MEMORY[0x1F417DE90]();
}

uint64_t nghttp2_session_callbacks_set_on_frame_not_send_callback()
{
  return MEMORY[0x1F417DE98]();
}

uint64_t nghttp2_session_callbacks_set_on_frame_recv_callback()
{
  return MEMORY[0x1F417DEA0]();
}

uint64_t nghttp2_session_callbacks_set_on_frame_send_callback()
{
  return MEMORY[0x1F417DEA8]();
}

uint64_t nghttp2_session_callbacks_set_on_header_callback()
{
  return MEMORY[0x1F417DEB0]();
}

uint64_t nghttp2_session_callbacks_set_on_invalid_frame_recv_callback()
{
  return MEMORY[0x1F417DEB8]();
}

uint64_t nghttp2_session_callbacks_set_on_invalid_header_callback()
{
  return MEMORY[0x1F417DEC0]();
}

uint64_t nghttp2_session_callbacks_set_on_stream_close_callback()
{
  return MEMORY[0x1F417DEC8]();
}

uint64_t nghttp2_session_client_new2()
{
  return MEMORY[0x1F417DEE0]();
}

uint64_t nghttp2_session_consume_connection()
{
  return MEMORY[0x1F417DEE8]();
}

uint64_t nghttp2_session_del()
{
  return MEMORY[0x1F417DEF8]();
}

uint64_t nghttp2_session_get_local_window_size()
{
  return MEMORY[0x1F417DF00]();
}

uint64_t nghttp2_session_get_next_stream_id()
{
  return MEMORY[0x1F417DF08]();
}

uint64_t nghttp2_session_get_stream_user_data()
{
  return MEMORY[0x1F417DF20]();
}

uint64_t nghttp2_session_mem_recv()
{
  return MEMORY[0x1F417DF28]();
}

uint64_t nghttp2_session_mem_send()
{
  return MEMORY[0x1F417DF30]();
}

uint64_t nghttp2_session_resume_data()
{
  return MEMORY[0x1F417DF38]();
}

uint64_t nghttp2_session_set_next_stream_id()
{
  return MEMORY[0x1F417DF58]();
}

uint64_t nghttp2_session_set_stream_user_data()
{
  return MEMORY[0x1F417DF60]();
}

uint64_t nghttp2_session_terminate_session()
{
  return MEMORY[0x1F417DF68]();
}

uint64_t nghttp2_session_want_read()
{
  return MEMORY[0x1F417DF70]();
}

uint64_t nghttp2_session_want_write()
{
  return MEMORY[0x1F417DF78]();
}

uint64_t nghttp2_strerror()
{
  return MEMORY[0x1F417DF88]();
}

uint64_t nghttp2_submit_ping()
{
  return MEMORY[0x1F417DFA8]();
}

uint64_t nghttp2_submit_priority()
{
  return MEMORY[0x1F417DFB0]();
}

uint64_t nghttp2_submit_request()
{
  return MEMORY[0x1F417DFB8]();
}

uint64_t nghttp2_submit_rst_stream()
{
  return MEMORY[0x1F417DFC0]();
}

uint64_t nghttp2_submit_settings()
{
  return MEMORY[0x1F417DFC8]();
}

uint64_t nghttp2_submit_window_update()
{
  return MEMORY[0x1F417DFD0]();
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1F40CD028](*(void *)&token);
}

uint32_t notify_check(int token, int *check)
{
  return MEMORY[0x1F40CD038](*(void *)&token, check);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x1F40CD058](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1F40CD060](name, out_token, queue, handler);
}

uint64_t nw_activity_activate()
{
  return MEMORY[0x1F40F2870]();
}

uint64_t nw_activity_complete_with_reason()
{
  return MEMORY[0x1F40F2878]();
}

uint64_t nw_activity_create()
{
  return MEMORY[0x1F40F2898]();
}

uint64_t nw_activity_get_domain()
{
  return MEMORY[0x1F40F28B0]();
}

uint64_t nw_activity_get_label()
{
  return MEMORY[0x1F40F28B8]();
}

uint64_t nw_activity_get_token()
{
  return MEMORY[0x1F40F28C0]();
}

uint64_t nw_activity_is_selected_for_reporting()
{
  return MEMORY[0x1F40F28E0]();
}

uint64_t nw_activity_set_parent_activity()
{
  return MEMORY[0x1F40F28E8]();
}

uint64_t nw_activity_should_write_metric_stream_to_log()
{
  return MEMORY[0x1F40F28F8]();
}

nw_advertise_descriptor_t nw_advertise_descriptor_create_bonjour_service(const char *name, const char *type, const char *domain)
{
  return (nw_advertise_descriptor_t)MEMORY[0x1F40F2910](name, type, domain);
}

uint64_t nw_authentication_challenge_copy_http_message()
{
  return MEMORY[0x1F40F2960]();
}

uint64_t nw_authentication_challenge_copy_protection_space()
{
  return MEMORY[0x1F40F2968]();
}

uint64_t nw_authentication_challenge_get_attempt_count()
{
  return MEMORY[0x1F40F2970]();
}

uint64_t nw_authentication_credential_create()
{
  return MEMORY[0x1F40F2978]();
}

uint64_t nw_authentication_credential_set_password()
{
  return MEMORY[0x1F40F2980]();
}

uint64_t nw_authentication_credential_set_username()
{
  return MEMORY[0x1F40F2988]();
}

uint64_t nw_authentication_protection_space_copy_endpoint()
{
  return MEMORY[0x1F40F2990]();
}

uint64_t nw_connection_add_client_event()
{
  return MEMORY[0x1F40F2A40]();
}

uint64_t nw_connection_append_and_start_application_protocol()
{
  return MEMORY[0x1F40F2A48]();
}

uint64_t nw_connection_better_path_available()
{
  return MEMORY[0x1F40F2A58]();
}

void nw_connection_cancel(nw_connection_t connection)
{
}

uint64_t nw_connection_copy_connected_local_endpoint()
{
  return MEMORY[0x1F40F2A78]();
}

uint64_t nw_connection_copy_connected_path()
{
  return MEMORY[0x1F40F2A80]();
}

uint64_t nw_connection_copy_connected_remote_endpoint()
{
  return MEMORY[0x1F40F2A88]();
}

nw_path_t nw_connection_copy_current_path(nw_connection_t connection)
{
  return (nw_path_t)MEMORY[0x1F40F2A90](connection);
}

nw_endpoint_t nw_connection_copy_endpoint(nw_connection_t connection)
{
  return (nw_endpoint_t)MEMORY[0x1F40F2AA0](connection);
}

uint64_t nw_connection_copy_establishment_report_on_queue()
{
  return MEMORY[0x1F40F2AA8]();
}

uint64_t nw_connection_copy_failed_resolution_report()
{
  return MEMORY[0x1F40F2AB0]();
}

uint64_t nw_connection_copy_metadata()
{
  return MEMORY[0x1F40F2AB8]();
}

nw_protocol_metadata_t nw_connection_copy_protocol_metadata(nw_connection_t connection, nw_protocol_definition_t definition)
{
  return (nw_protocol_metadata_t)MEMORY[0x1F40F2AD0](connection, definition);
}

uint64_t nw_connection_copy_tcp_info()
{
  return MEMORY[0x1F40F2AD8]();
}

nw_connection_t nw_connection_create(nw_endpoint_t endpoint, nw_parameters_t parameters)
{
  return (nw_connection_t)MEMORY[0x1F40F2AE0](endpoint, parameters);
}

nw_data_transfer_report_t nw_connection_create_new_data_transfer_report(nw_connection_t connection)
{
  return (nw_data_transfer_report_t)MEMORY[0x1F40F2AF0](connection);
}

uint64_t nw_connection_decrement_estimated_bytes()
{
  return MEMORY[0x1F40F2B18]();
}

uint64_t nw_connection_failed_due_to_blocked_tracker()
{
  return MEMORY[0x1F40F2B28]();
}

uint64_t nw_connection_fillout_tcp_statistics()
{
  return MEMORY[0x1F40F2B30]();
}

void nw_connection_force_cancel(nw_connection_t connection)
{
}

uint64_t nw_connection_get_id()
{
  return MEMORY[0x1F40F2B48]();
}

uint64_t nw_connection_get_privacy_stance()
{
  return MEMORY[0x1F40F2B50]();
}

uint64_t nw_connection_get_uuid()
{
  return MEMORY[0x1F40F2B58]();
}

uint64_t nw_connection_increment_estimated_bytes()
{
  return MEMORY[0x1F40F2BB8]();
}

uint64_t nw_connection_is_unlisted_tracker()
{
  return MEMORY[0x1F40F2BC0]();
}

uint64_t nw_connection_modify_connected_protocol_stack()
{
  return MEMORY[0x1F40F2BC8]();
}

uint64_t nw_connection_multipath_copy_subflow_counts()
{
  return MEMORY[0x1F40F2BD0]();
}

uint64_t nw_connection_multipath_get_primary_subflow_interface_index()
{
  return MEMORY[0x1F40F2BD8]();
}

uint64_t nw_connection_multipath_get_subflow_count()
{
  return MEMORY[0x1F40F2BE0]();
}

void nw_connection_receive(nw_connection_t connection, uint32_t minimum_incomplete_length, uint32_t maximum_length, nw_connection_receive_completion_t completion)
{
}

void nw_connection_receive_message(nw_connection_t connection, nw_connection_receive_completion_t completion)
{
}

uint64_t nw_connection_receive_with_context()
{
  return MEMORY[0x1F40F2C10]();
}

uint64_t nw_connection_reset_expected_progress_target()
{
  return MEMORY[0x1F40F2C20]();
}

void nw_connection_restart(nw_connection_t connection)
{
}

void nw_connection_send(nw_connection_t connection, dispatch_data_t content, nw_content_context_t context, BOOL is_complete, nw_connection_send_completion_t completion)
{
}

uint64_t nw_connection_set_adaptive_read_handler()
{
  return MEMORY[0x1F40F2C40]();
}

uint64_t nw_connection_set_adaptive_write_handler()
{
  return MEMORY[0x1F40F2C48]();
}

uint64_t nw_connection_set_alternate_path_state_handler()
{
  return MEMORY[0x1F40F2C50]();
}

uint64_t nw_connection_set_event_handler()
{
  return MEMORY[0x1F40F2C60]();
}

uint64_t nw_connection_set_excessive_keepalive_handler()
{
  return MEMORY[0x1F40F2C68]();
}

uint64_t nw_connection_set_low_throughput_handler()
{
  return MEMORY[0x1F40F2C70]();
}

void nw_connection_set_queue(nw_connection_t connection, dispatch_queue_t queue)
{
}

uint64_t nw_connection_set_read_close_handler()
{
  return MEMORY[0x1F40F2C88]();
}

void nw_connection_set_state_changed_handler(nw_connection_t connection, nw_connection_state_changed_handler_t handler)
{
}

void nw_connection_set_viability_changed_handler(nw_connection_t connection, nw_connection_BOOLean_event_handler_t handler)
{
}

uint64_t nw_connection_set_write_close_handler()
{
  return MEMORY[0x1F40F2CA0]();
}

void nw_connection_start(nw_connection_t connection)
{
}

uint64_t nw_connection_used_fallback()
{
  return MEMORY[0x1F40F2CC8]();
}

uint64_t nw_connection_used_tfo()
{
  return MEMORY[0x1F40F2CD0]();
}

uint64_t nw_connection_uses_multipath()
{
  return MEMORY[0x1F40F2CD8]();
}

nw_protocol_metadata_t nw_content_context_copy_protocol_metadata(nw_content_context_t context, nw_protocol_definition_t protocol)
{
  return (nw_protocol_metadata_t)MEMORY[0x1F40F2CF0](context, protocol);
}

nw_content_context_t nw_content_context_create(const char *context_identifier)
{
  return (nw_content_context_t)MEMORY[0x1F40F2CF8](context_identifier);
}

BOOL nw_content_context_get_is_final(nw_content_context_t context)
{
  return MEMORY[0x1F40F2D10](context);
}

uint64_t nw_content_context_get_is_wake_packet()
{
  return MEMORY[0x1F40F2D18]();
}

void nw_content_context_set_is_final(nw_content_context_t context, BOOL is_final)
{
}

void nw_content_context_set_metadata_for_protocol(nw_content_context_t context, nw_protocol_metadata_t protocol_metadata)
{
}

uint64_t nw_context_activate()
{
  return MEMORY[0x1F40F2D48]();
}

uint64_t nw_context_add_proxy()
{
  return MEMORY[0x1F40F2D50]();
}

uint64_t nw_context_copy_implicit_context()
{
  return MEMORY[0x1F40F2D60]();
}

uint64_t nw_context_create()
{
  return MEMORY[0x1F40F2D70]();
}

uint64_t nw_context_get_identifier()
{
  return MEMORY[0x1F40F2D88]();
}

uint64_t nw_context_get_privacy_level()
{
  return MEMORY[0x1F40F2D90]();
}

uint64_t nw_context_set_isolate_protocol_cache()
{
  return MEMORY[0x1F40F2DA8]();
}

uint64_t nw_context_set_privacy_level()
{
  return MEMORY[0x1F40F2DC0]();
}

void nw_data_transfer_report_collect(nw_data_transfer_report_t report, dispatch_queue_t queue, nw_data_transfer_report_collect_block_t collect_block)
{
}

uint64_t nw_data_transfer_report_collect_on_nw_queue()
{
  return MEMORY[0x1F40F2DE0]();
}

uint64_t nw_data_transfer_report_copy_dictionary()
{
  return MEMORY[0x1F40F2DE8]();
}

uint64_t nw_data_transfer_report_create_from_dictionary()
{
  return MEMORY[0x1F40F2DF8]();
}

uint64_t nw_endpoint_add_alternative()
{
  return MEMORY[0x1F40F2E30]();
}

char *__cdecl nw_endpoint_copy_address_string(nw_endpoint_t endpoint)
{
  return (char *)MEMORY[0x1F40F2E38](endpoint);
}

uint64_t nw_endpoint_copy_proxy_original_endpoint()
{
  return MEMORY[0x1F40F2E78]();
}

uint64_t nw_endpoint_create_host_with_numeric_port()
{
  return MEMORY[0x1F40F2EB0]();
}

uint64_t nw_endpoint_enumerate_cnames()
{
  return MEMORY[0x1F40F2EC8]();
}

const sockaddr *__cdecl nw_endpoint_get_address(nw_endpoint_t endpoint)
{
  return (const sockaddr *)MEMORY[0x1F40F2ED0](endpoint);
}

uint64_t nw_endpoint_get_description()
{
  return MEMORY[0x1F40F2EF8]();
}

const char *__cdecl nw_endpoint_get_hostname(nw_endpoint_t endpoint)
{
  return (const char *)MEMORY[0x1F40F2F08](endpoint);
}

uint64_t nw_endpoint_get_parent_endpoint_domain()
{
  return MEMORY[0x1F40F2F18]();
}

uint16_t nw_endpoint_get_port(nw_endpoint_t endpoint)
{
  return MEMORY[0x1F40F2F20](endpoint);
}

nw_endpoint_type_t nw_endpoint_get_type(nw_endpoint_t endpoint)
{
  return MEMORY[0x1F40F2F38](endpoint);
}

uint64_t nw_endpoint_set_alternate_port()
{
  return MEMORY[0x1F40F2F40]();
}

CFErrorRef nw_error_copy_cf_error(nw_error_t error)
{
  return (CFErrorRef)MEMORY[0x1F40F2F50](error);
}

int nw_error_get_error_code(nw_error_t error)
{
  return MEMORY[0x1F40F2F60](error);
}

uint64_t nw_establishment_report_copy_dictionary()
{
  return MEMORY[0x1F40F2F70]();
}

nw_endpoint_t nw_establishment_report_copy_proxy_endpoint(nw_establishment_report_t report)
{
  return (nw_endpoint_t)MEMORY[0x1F40F2F78](report);
}

uint64_t nw_establishment_report_create_from_dictionary()
{
  return MEMORY[0x1F40F2F80]();
}

void nw_establishment_report_enumerate_protocols(nw_establishment_report_t report, nw_report_protocol_enumerator_t enumerate_block)
{
}

uint64_t nw_establishment_report_enumerate_proxied_next_hop_endpoints()
{
  return MEMORY[0x1F40F2F90]();
}

void nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t report, nw_report_resolution_report_enumerator_t enumerate_block)
{
}

uint64_t nw_establishment_report_get_attempt_started_after_milliseconds(nw_establishment_report_t report)
{
  return MEMORY[0x1F40F2FA8](report);
}

uint64_t nw_establishment_report_get_duration_milliseconds(nw_establishment_report_t report)
{
  return MEMORY[0x1F40F2FB0](report);
}

uint64_t nw_establishment_report_get_flow_started_after_milliseconds()
{
  return MEMORY[0x1F40F2FB8]();
}

uint64_t nw_establishment_report_get_resolution_started_after_milliseconds()
{
  return MEMORY[0x1F40F2FC0]();
}

BOOL nw_establishment_report_get_used_proxy(nw_establishment_report_t report)
{
  return MEMORY[0x1F40F2FC8](report);
}

uint64_t nw_interface_create_with_index()
{
  return MEMORY[0x1F40F3230]();
}

uint64_t nw_interface_create_with_name()
{
  return MEMORY[0x1F40F3238]();
}

const char *__cdecl nw_interface_get_name(nw_interface_t interface)
{
  return (const char *)MEMORY[0x1F40F3248](interface);
}

uint64_t nw_interface_get_subtype()
{
  return MEMORY[0x1F40F3260]();
}

nw_interface_type_t nw_interface_get_type(nw_interface_t interface)
{
  return MEMORY[0x1F40F3268](interface);
}

void nw_ip_options_set_local_address_preference(nw_protocol_options_t options, nw_ip_local_address_preference_t preference)
{
}

void nw_listener_cancel(nw_listener_t listener)
{
}

nw_listener_t nw_listener_create_with_port(const char *port, nw_parameters_t parameters)
{
  return (nw_listener_t)MEMORY[0x1F40F3330](port, parameters);
}

uint16_t nw_listener_get_port(nw_listener_t listener)
{
  return MEMORY[0x1F40F3338](listener);
}

void nw_listener_set_advertise_descriptor(nw_listener_t listener, nw_advertise_descriptor_t advertise_descriptor)
{
}

void nw_listener_set_new_connection_handler(nw_listener_t listener, nw_listener_new_connection_handler_t handler)
{
}

void nw_listener_set_queue(nw_listener_t listener, dispatch_queue_t queue)
{
}

void nw_listener_set_state_changed_handler(nw_listener_t listener, nw_listener_state_changed_handler_t handler)
{
}

void nw_listener_start(nw_listener_t listener)
{
}

uint64_t nw_parameters_add_protocol_stack_member()
{
  return MEMORY[0x1F40F33E0]();
}

uint64_t nw_parameters_add_proxy_options()
{
  return MEMORY[0x1F40F33E8]();
}

uint64_t nw_parameters_clear_proxy_options()
{
  return MEMORY[0x1F40F3400]();
}

nw_parameters_t nw_parameters_copy(nw_parameters_t parameters)
{
  return (nw_parameters_t)MEMORY[0x1F40F3408](parameters);
}

nw_protocol_stack_t nw_parameters_copy_default_protocol_stack(nw_parameters_t parameters)
{
  return (nw_protocol_stack_t)MEMORY[0x1F40F3418](parameters);
}

uint64_t nw_parameters_copy_preferred_netagent_domains()
{
  return MEMORY[0x1F40F3448]();
}

uint64_t nw_parameters_copy_preferred_netagent_types()
{
  return MEMORY[0x1F40F3450]();
}

uint64_t nw_parameters_copy_prohibited_interface_subtypes()
{
  return MEMORY[0x1F40F3458]();
}

uint64_t nw_parameters_copy_prohibited_interface_types()
{
  return MEMORY[0x1F40F3460]();
}

uint64_t nw_parameters_copy_protocol_value()
{
  return MEMORY[0x1F40F3470]();
}

nw_parameters_t nw_parameters_create(void)
{
  return (nw_parameters_t)MEMORY[0x1F40F3488]();
}

uint64_t nw_parameters_create_protocol_parameters()
{
  return MEMORY[0x1F40F34A8]();
}

uint64_t nw_parameters_create_quic_connection()
{
  return MEMORY[0x1F40F34C0]();
}

nw_parameters_t nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t configure_tls, nw_parameters_configure_protocol_block_t configure_tcp)
{
  return (nw_parameters_t)MEMORY[0x1F40F34D0](configure_tls, configure_tcp);
}

uint64_t nw_parameters_create_secure_tcp_or_quic_connection()
{
  return MEMORY[0x1F40F34D8]();
}

uint64_t nw_parameters_get_traffic_class()
{
  return MEMORY[0x1F40F3570]();
}

void nw_parameters_require_interface(nw_parameters_t parameters, nw_interface_t interface)
{
}

uint64_t nw_parameters_set_account_id()
{
  return MEMORY[0x1F40F35A0]();
}

uint64_t nw_parameters_set_allow_ultra_constrained()
{
  return MEMORY[0x1F40F35B0]();
}

uint64_t nw_parameters_set_attributed_bundle_identifier()
{
  return MEMORY[0x1F40F35B8]();
}

void nw_parameters_set_attribution(nw_parameters_t parameters, nw_parameters_attribution_t attribution)
{
}

uint64_t nw_parameters_set_context()
{
  return MEMORY[0x1F40F35E0]();
}

uint64_t nw_parameters_set_discretionary()
{
  return MEMORY[0x1F40F3600]();
}

uint64_t nw_parameters_set_effective_bundle_id()
{
  return MEMORY[0x1F40F3620]();
}

uint64_t nw_parameters_set_expected_workload()
{
  return MEMORY[0x1F40F3628]();
}

void nw_parameters_set_expired_dns_behavior(nw_parameters_t parameters, nw_parameters_expired_dns_behavior_t expired_dns_behavior)
{
}

uint64_t nw_parameters_set_https_proxy_over_tls()
{
  return MEMORY[0x1F40F3648]();
}

uint64_t nw_parameters_set_indefinite()
{
  return MEMORY[0x1F40F3660]();
}

uint64_t nw_parameters_set_initial_data_payload()
{
  return MEMORY[0x1F40F3668]();
}

uint64_t nw_parameters_set_metadata()
{
  return MEMORY[0x1F40F3690]();
}

void nw_parameters_set_multipath_service(nw_parameters_t parameters, nw_multipath_service_t multipath_service)
{
}

uint64_t nw_parameters_set_no_proxy()
{
  return MEMORY[0x1F40F36B0]();
}

void nw_parameters_set_prefer_no_proxy(nw_parameters_t parameters, BOOL prefer_no_proxy)
{
}

uint64_t nw_parameters_set_preferred_netagent_classes()
{
  return MEMORY[0x1F40F36D0]();
}

void nw_parameters_set_prohibit_constrained(nw_parameters_t parameters, BOOL prohibit_constrained)
{
}

void nw_parameters_set_prohibit_expensive(nw_parameters_t parameters, BOOL prohibit_expensive)
{
}

uint64_t nw_parameters_set_prohibited_interface_subtypes()
{
  return MEMORY[0x1F40F3708]();
}

uint64_t nw_parameters_set_prohibited_interface_types()
{
  return MEMORY[0x1F40F3710]();
}

uint64_t nw_parameters_set_protocol_value()
{
  return MEMORY[0x1F40F3720]();
}

uint64_t nw_parameters_set_proxy_configuration()
{
  return MEMORY[0x1F40F3728]();
}

uint64_t nw_parameters_set_required_netagent_classes()
{
  return MEMORY[0x1F40F3750]();
}

void nw_parameters_set_requires_dnssec_validation(nw_parameters_t parameters, BOOL requires_dnssec_validation)
{
}

void nw_parameters_set_reuse_local_address(nw_parameters_t parameters, BOOL reuse_local_address)
{
}

uint64_t nw_parameters_set_skip_stack_trace_capture()
{
  return MEMORY[0x1F40F3780]();
}

uint64_t nw_parameters_set_source_application()
{
  return MEMORY[0x1F40F3788]();
}

uint64_t nw_parameters_set_source_application_by_bundle_id()
{
  return MEMORY[0x1F40F3790]();
}

uint64_t nw_parameters_set_source_application_by_external_bundle_id()
{
  return MEMORY[0x1F40F3798]();
}

uint64_t nw_parameters_set_tracker_context()
{
  return MEMORY[0x1F40F37B0]();
}

uint64_t nw_parameters_set_url()
{
  return MEMORY[0x1F40F37C8]();
}

uint64_t nw_parameters_set_use_awdl()
{
  return MEMORY[0x1F40F37D0]();
}

uint64_t nw_path_copy_interface()
{
  return MEMORY[0x1F40F3828]();
}

uint64_t nw_path_copy_parameters()
{
  return MEMORY[0x1F40F3838]();
}

uint64_t nw_path_create_evaluator_for_endpoint()
{
  return MEMORY[0x1F40F3858]();
}

uint64_t nw_path_evaluator_copy_path()
{
  return MEMORY[0x1F40F3880]();
}

uint64_t nw_path_get_interface_index()
{
  return MEMORY[0x1F40F38E0]();
}

uint64_t nw_path_get_ipv4_network_signature()
{
  return MEMORY[0x1F40F38E8]();
}

uint64_t nw_path_get_ipv6_network_signature()
{
  return MEMORY[0x1F40F38F0]();
}

uint64_t nw_path_get_policy_id()
{
  return MEMORY[0x1F40F3918]();
}

uint64_t nw_path_get_reason()
{
  return MEMORY[0x1F40F3920]();
}

uint64_t nw_path_get_vpn_config_id()
{
  return MEMORY[0x1F40F3940]();
}

BOOL nw_path_is_constrained(nw_path_t path)
{
  return MEMORY[0x1F40F3960](path);
}

uint64_t nw_path_is_direct()
{
  return MEMORY[0x1F40F3968]();
}

BOOL nw_path_is_expensive(nw_path_t path)
{
  return MEMORY[0x1F40F3970](path);
}

uint64_t nw_path_is_local()
{
  return MEMORY[0x1F40F3980]();
}

uint64_t nw_path_is_per_app_vpn()
{
  return MEMORY[0x1F40F3988]();
}

uint64_t nw_path_uses_interface_subtype()
{
  return MEMORY[0x1F40F39F8]();
}

BOOL nw_path_uses_interface_type(nw_path_t path, nw_interface_type_t interface_type)
{
  return MEMORY[0x1F40F3A00](path, *(void *)&interface_type);
}

uint64_t nw_protocol_copy_quic_connection_definition()
{
  return MEMORY[0x1F40F3A28]();
}

nw_protocol_definition_t nw_protocol_copy_tcp_definition(void)
{
  return (nw_protocol_definition_t)MEMORY[0x1F40F3A50]();
}

nw_protocol_definition_t nw_protocol_copy_tls_definition(void)
{
  return (nw_protocol_definition_t)MEMORY[0x1F40F3A58]();
}

nw_protocol_definition_t nw_protocol_copy_ws_definition(void)
{
  return (nw_protocol_definition_t)MEMORY[0x1F40F3A60]();
}

BOOL nw_protocol_definition_is_equal(nw_protocol_definition_t definition1, nw_protocol_definition_t definition2)
{
  return MEMORY[0x1F40F3A88](definition1, definition2);
}

BOOL nw_protocol_metadata_is_tls(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x1F40F3AF0](metadata);
}

uint64_t nw_protocol_set_default_one_to_one_callbacks()
{
  return MEMORY[0x1F40F3B40]();
}

nw_protocol_options_t nw_protocol_stack_copy_internet_protocol(nw_protocol_stack_t stack)
{
  return (nw_protocol_options_t)MEMORY[0x1F40F3B58](stack);
}

uint64_t nw_protocols_are_equal()
{
  return MEMORY[0x1F40F3BE8]();
}

uint64_t nw_proxy_config_stack_requires_http_protocols()
{
  return MEMORY[0x1F40F3C20]();
}

uint64_t nw_proxy_copy_http_connect_definition()
{
  return MEMORY[0x1F40F3C28]();
}

uint64_t nw_proxy_create_options()
{
  return MEMORY[0x1F40F3C38]();
}

uint64_t nw_proxy_options_set_authentication_challenge_handler()
{
  return MEMORY[0x1F40F3C40]();
}

uint64_t nw_proxy_options_set_http_proxy_authorization_header()
{
  return MEMORY[0x1F40F3C48]();
}

uint64_t nw_queue_context_target_dispatch_queue()
{
  return MEMORY[0x1F40F3CA0]();
}

uint64_t nw_quic_connection_close_with_error()
{
  return MEMORY[0x1F40F3CD0]();
}

uint64_t nw_quic_connection_copy_sec_protocol_metadata()
{
  return MEMORY[0x1F40F3CD8]();
}

uint64_t nw_quic_connection_copy_sec_protocol_options()
{
  return MEMORY[0x1F40F3CE0]();
}

uint64_t nw_quic_connection_copy_stream_metadata()
{
  return MEMORY[0x1F40F3CE8]();
}

uint64_t nw_quic_connection_get_application_error()
{
  return MEMORY[0x1F40F3CF0]();
}

uint64_t nw_quic_connection_get_peer_idle_timeout()
{
  return MEMORY[0x1F40F3CF8]();
}

uint64_t nw_quic_connection_metadata_set_stream_options()
{
  return MEMORY[0x1F40F3D00]();
}

uint64_t nw_quic_connection_report_application_result()
{
  return MEMORY[0x1F40F3D08]();
}

uint64_t nw_quic_connection_set_enable_l4s()
{
  return MEMORY[0x1F40F3D18]();
}

uint64_t nw_quic_connection_set_idle_timeout()
{
  return MEMORY[0x1F40F3D28]();
}

uint64_t nw_quic_connection_set_initial_max_streams_bidirectional()
{
  return MEMORY[0x1F40F3D30]();
}

uint64_t nw_quic_connection_set_initial_max_streams_unidirectional()
{
  return MEMORY[0x1F40F3D38]();
}

uint64_t nw_quic_connection_set_keepalive()
{
  return MEMORY[0x1F40F3D40]();
}

uint64_t nw_quic_connection_set_keepalive_count()
{
  return MEMORY[0x1F40F3D48]();
}

uint64_t nw_quic_connection_set_max_streams_unidirectional()
{
  return MEMORY[0x1F40F3D58]();
}

uint64_t nw_quic_connection_set_max_streams_update_block()
{
  return MEMORY[0x1F40F3D60]();
}

uint64_t nw_quic_create_connection_metadata()
{
  return MEMORY[0x1F40F3D78]();
}

uint64_t nw_quic_create_stream_options()
{
  return MEMORY[0x1F40F3D88]();
}

uint64_t nw_quic_stream_get_application_error()
{
  return MEMORY[0x1F40F3DB8]();
}

uint64_t nw_quic_stream_get_id()
{
  return MEMORY[0x1F40F3DC0]();
}

uint64_t nw_quic_stream_set_application_error()
{
  return MEMORY[0x1F40F3DC8]();
}

void nw_release(void *obj)
{
}

uint64_t nw_resolution_report_get_milliseconds(nw_resolution_report_t resolution_report)
{
  return MEMORY[0x1F40F3E08](resolution_report);
}

nw_report_resolution_protocol_t nw_resolution_report_get_protocol(nw_resolution_report_t resolution_report)
{
  return MEMORY[0x1F40F3E10](resolution_report);
}

void *__cdecl nw_retain(void *obj)
{
  return (void *)MEMORY[0x1F40F3EA8](obj);
}

uint64_t nw_settings_get_networkscore_sampling_rate_denominator()
{
  return MEMORY[0x1F40F3EC0]();
}

uint64_t nw_settings_get_quic_enabled()
{
  return MEMORY[0x1F40F3EC8]();
}

uint64_t nw_settings_get_signposts_enabled()
{
  return MEMORY[0x1F40F3ED0]();
}

uint64_t nw_settings_networkscore_metrics_enabled()
{
  return MEMORY[0x1F40F3EE0]();
}

void nw_tcp_options_set_connection_timeout(nw_protocol_options_t options, uint32_t connection_timeout)
{
}

uint64_t nw_tcp_options_set_enable_background_traffic_management()
{
  return MEMORY[0x1F40F3F08]();
}

void nw_tcp_options_set_enable_fast_open(nw_protocol_options_t options, BOOL enable_fast_open)
{
}

uint64_t nw_tcp_options_set_enable_l4s()
{
  return MEMORY[0x1F40F3F20]();
}

void nw_tcp_options_set_no_delay(nw_protocol_options_t options, BOOL no_delay)
{
}

uint64_t nw_tcp_set_no_wake_from_sleep()
{
  return MEMORY[0x1F40F3F48]();
}

sec_protocol_metadata_t nw_tls_copy_sec_protocol_metadata(nw_protocol_metadata_t metadata)
{
  return (sec_protocol_metadata_t)MEMORY[0x1F40F3F50](metadata);
}

nw_protocol_options_t nw_tls_create_options(void)
{
  return (nw_protocol_options_t)MEMORY[0x1F40F3F60]();
}

nw_protocol_metadata_t nw_ws_create_metadata(nw_ws_opcode_t opcode)
{
  return (nw_protocol_metadata_t)MEMORY[0x1F40F3FA8](*(void *)&opcode);
}

nw_protocol_options_t nw_ws_create_options(nw_ws_version_t version)
{
  return (nw_protocol_options_t)MEMORY[0x1F40F3FB0](*(void *)&version);
}

nw_ws_close_code_t nw_ws_metadata_get_close_code(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x1F40F3FC0](metadata);
}

nw_ws_opcode_t nw_ws_metadata_get_opcode(nw_protocol_metadata_t metadata)
{
  return MEMORY[0x1F40F3FC8](metadata);
}

void nw_ws_metadata_set_close_code(nw_protocol_metadata_t metadata, nw_ws_close_code_t close_code)
{
}

void nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t metadata, dispatch_queue_t client_queue, nw_ws_pong_handler_t pong_handler)
{
}

void nw_ws_options_add_subprotocol(nw_protocol_options_t options, const char *subprotocol)
{
}

void nw_ws_options_set_auto_reply_ping(nw_protocol_options_t options, BOOL auto_reply_ping)
{
}

void nw_ws_options_set_maximum_message_size(nw_protocol_options_t options, size_t maximum_message_size)
{
}

uint64_t nw_ws_options_set_permessage_deflate()
{
  return MEMORY[0x1F40F4008]();
}

uint64_t nw_ws_options_set_prepend_data()
{
  return MEMORY[0x1F40F4010]();
}

void nw_ws_options_set_skip_handshake(nw_protocol_options_t options, BOOL skip_handshake)
{
}

uint64_t nw_ws_validate_server_response_with_protocol_options()
{
  return MEMORY[0x1F40F4040]();
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

id objc_allocWithZone(Class a1)
{
  return (id)MEMORY[0x1F4181640](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1F4181680](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_rethrow(void)
{
}

void objc_exception_throw(id exception)
{
}

id objc_getAssociatedObject(id object, const void *key)
{
  return (id)MEMORY[0x1F4181718](object, key);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1F4181748](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1F4181758](location, val);
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x1F4181778](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1F4181780](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F4181798](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1F41817C8]();
}

uint64_t self
{
  return MEMORY[0x1F41817D0]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1F41818B8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1F41818D0](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1F4181A18](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1F4181A28](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1F4181A30](obj);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x1F40CD0F0](a1, *(void *)&a2, *(void *)&a3, *(void *)&a4);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1F40CD550](log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return MEMORY[0x1F40CD560](log, ptr);
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_allows_internal_security_policies()
{
  return MEMORY[0x1F40CD630]();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1F40CD650]();
}

uint64_t os_variant_has_internal_ui()
{
  return MEMORY[0x1F40CD658]();
}

void perror(const char *a1)
{
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD918](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD930](a1);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1F40CD940](a1, *(void *)&a2);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x1F40CD980](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x1F40CD988](a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return MEMORY[0x1F40CD990](a1);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x1F40CD9A8](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1F40CD9B8](a1, a2, a3, a4);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x1F40CDA60](a1);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA78](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1F40CDA80](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA88](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA98](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1F40CDAA0](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1F40CDAA8](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1F40CDAC0](a1, *(void *)&a2);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1F40CDAC8](a1, a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1F40CDB30]();
}

int pthread_setschedparam(pthread_t a1, int a2, const sched_param *a3)
{
  return MEMORY[0x1F40CDB68](a1, *(void *)&a2, a3);
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x1F40CDBD8]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

uint64_t random(void)
{
  return MEMORY[0x1F40CDC18]();
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1F40CDC50](*(void *)&a1, a2, a3);
}

ssize_t recvfrom(int a1, void *a2, size_t a3, int a4, sockaddr *a5, socklen_t *a6)
{
  return MEMORY[0x1F40CDCC0](*(void *)&a1, a2, a3, *(void *)&a4, a5, a6);
}

int removefile(const char *path, removefile_state_t state, removefile_flags_t flags)
{
  return MEMORY[0x1F40CDD18](path, state, *(void *)&flags);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

uint64_t sandbox_check()
{
  return MEMORY[0x1F40CDDD0]();
}

uint64_t sandbox_check_by_audit_token()
{
  return MEMORY[0x1F40CDDD8]();
}

uint64_t sandbox_extension_consume()
{
  return MEMORY[0x1F40CDDF8]();
}

uint64_t sandbox_extension_issue_file()
{
  return MEMORY[0x1F40CDE00]();
}

uint64_t sandbox_extension_release()
{
  return MEMORY[0x1F40CDE50]();
}

SecCertificateRef sec_certificate_copy_ref(sec_certificate_t certificate)
{
  return (SecCertificateRef)MEMORY[0x1F40F7368](certificate);
}

SecIdentityRef sec_identity_copy_ref(sec_identity_t identity)
{
  return (SecIdentityRef)MEMORY[0x1F40F7388](identity);
}

sec_identity_t sec_identity_create_with_certificates(SecIdentityRef identity, CFArrayRef certificates)
{
  return (sec_identity_t)MEMORY[0x1F40F73A0](identity, certificates);
}

BOOL sec_protocol_metadata_access_distinguished_names(sec_protocol_metadata_t metadata, void *handler)
{
  return MEMORY[0x1F40F73D0](metadata, handler);
}

BOOL sec_protocol_metadata_access_peer_certificate_chain(sec_protocol_metadata_t metadata, void *handler)
{
  return MEMORY[0x1F40F73D8](metadata, handler);
}

uint64_t sec_protocol_metadata_access_sent_certificates()
{
  return MEMORY[0x1F40F73E0]();
}

BOOL sec_protocol_metadata_challenge_parameters_are_equal(sec_protocol_metadata_t metadataA, sec_protocol_metadata_t metadataB)
{
  return MEMORY[0x1F40F73E8](metadataA, metadataB);
}

uint64_t sec_protocol_metadata_copy_sec_identity()
{
  return MEMORY[0x1F40F7408]();
}

uint64_t sec_protocol_metadata_copy_sec_trust()
{
  return MEMORY[0x1F40F7410]();
}

SSLCipherSuite sec_protocol_metadata_get_negotiated_ciphersuite(sec_protocol_metadata_t metadata)
{
  return MEMORY[0x1F40F7420](metadata);
}

const char *__cdecl sec_protocol_metadata_get_negotiated_protocol(sec_protocol_metadata_t metadata)
{
  return (const char *)MEMORY[0x1F40F7428](metadata);
}

SSLProtocol sec_protocol_metadata_get_negotiated_protocol_version(sec_protocol_metadata_t metadata)
{
  return MEMORY[0x1F40F7430](metadata);
}

tls_ciphersuite_t sec_protocol_metadata_get_negotiated_tls_ciphersuite(sec_protocol_metadata_t metadata)
{
  return (unsigned __int16)MEMORY[0x1F40F7438](metadata);
}

tls_protocol_version_t sec_protocol_metadata_get_negotiated_tls_protocol_version(sec_protocol_metadata_t metadata)
{
  return (unsigned __int16)MEMORY[0x1F40F7440](metadata);
}

BOOL sec_protocol_metadata_peers_are_equal(sec_protocol_metadata_t metadataA, sec_protocol_metadata_t metadataB)
{
  return MEMORY[0x1F40F7450](metadataA, metadataB);
}

void sec_protocol_options_add_pre_shared_key(sec_protocol_options_t options, dispatch_data_t psk, dispatch_data_t psk_identity)
{
}

void sec_protocol_options_add_tls_ciphersuite(sec_protocol_options_t options, SSLCipherSuite ciphersuite)
{
}

void sec_protocol_options_add_tls_ciphersuite_group(sec_protocol_options_t options, SSLCiphersuiteGroup group)
{
}

uint64_t sec_protocol_options_add_transport_specific_application_protocol()
{
  return MEMORY[0x1F40F7488]();
}

tls_protocol_version_t sec_protocol_options_get_default_max_tls_protocol_version(void)
{
  return (unsigned __int16)MEMORY[0x1F40F74C0]();
}

tls_protocol_version_t sec_protocol_options_get_default_min_tls_protocol_version(void)
{
  return (unsigned __int16)MEMORY[0x1F40F74C8]();
}

void sec_protocol_options_set_challenge_block(sec_protocol_options_t options, sec_protocol_challenge_t challenge_block, dispatch_queue_t challenge_queue)
{
}

void sec_protocol_options_set_enable_encrypted_client_hello(sec_protocol_options_t options, BOOL enable_encrypted_client_hello)
{
}

void sec_protocol_options_set_local_identity(sec_protocol_options_t options, sec_identity_t identity)
{
}

void sec_protocol_options_set_peer_authentication_optional(sec_protocol_options_t options, BOOL peer_authentication_optional)
{
}

void sec_protocol_options_set_peer_authentication_required(sec_protocol_options_t options, BOOL peer_authentication_required)
{
}

void sec_protocol_options_set_tls_diffie_hellman_parameters(sec_protocol_options_t options, dispatch_data_t params)
{
}

void sec_protocol_options_set_tls_false_start_enabled(sec_protocol_options_t options, BOOL false_start_enabled)
{
}

void sec_protocol_options_set_tls_is_fallback_attempt(sec_protocol_options_t options, BOOL is_fallback_attempt)
{
}

void sec_protocol_options_set_tls_max_version(sec_protocol_options_t options, SSLProtocol version)
{
}

void sec_protocol_options_set_tls_min_version(sec_protocol_options_t options, SSLProtocol version)
{
}

void sec_protocol_options_set_tls_resumption_enabled(sec_protocol_options_t options, BOOL resumption_enabled)
{
}

void sec_protocol_options_set_tls_server_name(sec_protocol_options_t options, const char *server_name)
{
}

uint64_t sec_protocol_options_set_tls_sni_disabled()
{
  return MEMORY[0x1F40F7598]();
}

void sec_protocol_options_set_tls_tickets_enabled(sec_protocol_options_t options, BOOL tickets_enabled)
{
}

void sec_protocol_options_set_verify_block(sec_protocol_options_t options, sec_protocol_verify_t verify_block, dispatch_queue_t verify_block_queue)
{
}

void sec_release(void *obj)
{
}

void *__cdecl sec_retain(void *obj)
{
  return (void *)MEMORY[0x1F40F75B8](obj);
}

SecTrustRef sec_trust_copy_ref(sec_trust_t trust)
{
  return (SecTrustRef)MEMORY[0x1F40F75C0](trust);
}

const char *__cdecl sel_getName(SEL sel)
{
  return (const char *)MEMORY[0x1F4181B28](sel);
}

BOOL sel_isEqual(SEL lhs, SEL rhs)
{
  return MEMORY[0x1F4181B38](lhs, rhs);
}

SEL sel_registerName(const char *str)
{
  return (SEL)MEMORY[0x1F4181B48](str);
}

int select(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  return MEMORY[0x1F40CDED8](*(void *)&a1, a2, a3, a4, a5);
}

ssize_t sendto(int a1, const void *a2, size_t a3, int a4, const sockaddr *a5, socklen_t a6)
{
  return MEMORY[0x1F40CDF48](*(void *)&a1, a2, a3, *(void *)&a4, a5, *(void *)&a6);
}

int setrlimit(int a1, const rlimit *a2)
{
  return MEMORY[0x1F40CDFB8](*(void *)&a1, a2);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x1F40CDFC0](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, *(void *)&a5);
}

int setxattr(const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1F40CDFD8](path, name, value, size, *(void *)&position, *(void *)&options);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1F40CE078](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x1F40CE090](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int sqlite3_bind_blob(sqlite3_stmt *a1, int a2, const void *a3, int n, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1F4181F90](a1, *(void *)&a2, a3, *(void *)&n, a5);
}

int sqlite3_bind_int(sqlite3_stmt *a1, int a2, int a3)
{
  return MEMORY[0x1F4181FB0](a1, *(void *)&a2, *(void *)&a3);
}

int sqlite3_bind_int64(sqlite3_stmt *a1, int a2, sqlite3_int64 a3)
{
  return MEMORY[0x1F4181FB8](a1, *(void *)&a2, a3);
}

int sqlite3_bind_text(sqlite3_stmt *a1, int a2, const char *a3, int a4, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1F4181FE8](a1, *(void *)&a2, a3, *(void *)&a4, a5);
}

int sqlite3_busy_timeout(sqlite3 *a1, int ms)
{
  return MEMORY[0x1F4182048](a1, *(void *)&ms);
}

int sqlite3_close(sqlite3 *a1)
{
  return MEMORY[0x1F4182060](a1);
}

const void *__cdecl sqlite3_column_blob(sqlite3_stmt *a1, int iCol)
{
  return (const void *)MEMORY[0x1F4182070](a1, *(void *)&iCol);
}

int sqlite3_column_bytes(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1F4182078](a1, *(void *)&iCol);
}

int sqlite3_column_count(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1F4182088](pStmt);
}

int sqlite3_column_int(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1F41820A0](a1, *(void *)&iCol);
}

sqlite3_int64 sqlite3_column_int64(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1F41820A8](a1, *(void *)&iCol);
}

const unsigned __int8 *__cdecl sqlite3_column_text(sqlite3_stmt *a1, int iCol)
{
  return (const unsigned __int8 *)MEMORY[0x1F41820C8](a1, *(void *)&iCol);
}

int sqlite3_column_type(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1F41820D8](a1, *(void *)&iCol);
}

int sqlite3_db_config(sqlite3 *a1, int op, ...)
{
  return MEMORY[0x1F4182148](a1, *(void *)&op);
}

int sqlite3_errcode(sqlite3 *db)
{
  return MEMORY[0x1F4182190](db);
}

const char *__cdecl sqlite3_errmsg(sqlite3 *a1)
{
  return (const char *)MEMORY[0x1F4182198](a1);
}

int sqlite3_exec(sqlite3 *a1, const char *sql, int (__cdecl *callback)(void *, int, char **, char **), void *a4, char **errmsg)
{
  return MEMORY[0x1F41821A8](a1, sql, callback, a4, errmsg);
}

int sqlite3_file_control(sqlite3 *a1, const char *zDbName, int op, void *a4)
{
  return MEMORY[0x1F41821D0](a1, zDbName, *(void *)&op, a4);
}

int sqlite3_finalize(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1F41821D8](pStmt);
}

void sqlite3_free(void *a1)
{
}

sqlite3_int64 sqlite3_last_insert_rowid(sqlite3 *a1)
{
  return MEMORY[0x1F4182230](a1);
}

char *sqlite3_mprintf(const char *a1, ...)
{
  return (char *)MEMORY[0x1F4182258](a1);
}

int sqlite3_open(const char *filename, sqlite3 **ppDb)
{
  return MEMORY[0x1F4182278](filename, ppDb);
}

int sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs)
{
  return MEMORY[0x1F4182280](filename, ppDb, *(void *)&flags, zVfs);
}

int sqlite3_prepare(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return MEMORY[0x1F4182288](db, zSql, *(void *)&nByte, ppStmt, pzTail);
}

int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return MEMORY[0x1F4182290](db, zSql, *(void *)&nByte, ppStmt, pzTail);
}

int sqlite3_reset(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1F41822C0](pStmt);
}

int sqlite3_step(sqlite3_stmt *a1)
{
  return MEMORY[0x1F41823B0](a1);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CE0D0](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x1F40CE118](a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x1F40CE138](a1, a2);
}

char *__cdecl strcasestr(const char *__big, const char *__little)
{
  return (char *)MEMORY[0x1F40CE140](__big, __little);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE150](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1F40CE188](*(void *)&__errnum);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1A8](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1F40CE1D8](a1, a2, a3);
}

int strncasecmp_l(const char *a1, const char *a2, size_t a3, locale_t a4)
{
  return MEMORY[0x1F40CE1E0](a1, a2, a3, a4);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1F40CE1F8](__dst, __src, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return (char *)MEMORY[0x1F40CE200](__s1, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1F40CE208](__s1, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE230](__s, *(void *)&__c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1F40CE258](__s1, __s2);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2A0](__str, __endptr, *(void *)&__base);
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2C0](__str, __endptr, *(void *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2E0](__str, __endptr, *(void *)&__base);
}

unint64_t strtouq(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE308](__str, __endptr, *(void *)&__base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1F40CE3C0](a1, *(void *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1F40CE3D0](a1, a2, a3, a4, a5);
}

sysdir_search_path_enumeration_state sysdir_get_next_search_path_enumeration(sysdir_search_path_enumeration_state state, char *path)
{
  return MEMORY[0x1F40CE3E8](*(void *)&state, path);
}

uint64_t sysdir_start_search_path_enumeration_private()
{
  return MEMORY[0x1F40CE3F8]();
}

uint64_t tcp_connection_accept()
{
  return MEMORY[0x1F40F4048]();
}

uint64_t tcp_connection_add_event_adaptive_read_timeout()
{
  return MEMORY[0x1F40F4050]();
}

uint64_t tcp_connection_add_event_adaptive_write_timeout()
{
  return MEMORY[0x1F40F4058]();
}

uint64_t tcp_connection_add_event_excessive_keepalives()
{
  return MEMORY[0x1F40F4060]();
}

uint64_t tcp_connection_allow_client_socket_access()
{
  return MEMORY[0x1F40F4068]();
}

uint64_t tcp_connection_cancel()
{
  return MEMORY[0x1F40F4070]();
}

uint64_t tcp_connection_conditions_get_unmet_reason()
{
  return MEMORY[0x1F40F4078]();
}

uint64_t tcp_connection_conditions_met()
{
  return MEMORY[0x1F40F4080]();
}

uint64_t tcp_connection_copy_endpoint()
{
  return MEMORY[0x1F40F4088]();
}

uint64_t tcp_connection_copy_parameters()
{
  return MEMORY[0x1F40F4090]();
}

uint64_t tcp_connection_copy_proxy()
{
  return MEMORY[0x1F40F4098]();
}

uint64_t tcp_connection_copy_socket()
{
  return MEMORY[0x1F40F40A0]();
}

uint64_t tcp_connection_copy_tcp_info()
{
  return MEMORY[0x1F40F40A8]();
}

uint64_t tcp_connection_create()
{
  return MEMORY[0x1F40F40B0]();
}

uint64_t tcp_connection_create_with_connected_fd()
{
  return MEMORY[0x1F40F40B8]();
}

uint64_t tcp_connection_create_with_service()
{
  return MEMORY[0x1F40F40C0]();
}

uint64_t tcp_connection_create_with_sockaddr()
{
  return MEMORY[0x1F40F40C8]();
}

uint64_t tcp_connection_did_fallback()
{
  return MEMORY[0x1F40F40D0]();
}

uint64_t tcp_connection_get_connection_quality()
{
  return MEMORY[0x1F40F40E8]();
}

uint64_t tcp_connection_get_error()
{
  return MEMORY[0x1F40F40F0]();
}

uint64_t tcp_connection_get_hostname()
{
  return MEMORY[0x1F40F40F8]();
}

uint64_t tcp_connection_get_local()
{
  return MEMORY[0x1F40F4100]();
}

uint64_t tcp_connection_get_remote()
{
  return MEMORY[0x1F40F4108]();
}

uint64_t tcp_connection_get_socket()
{
  return MEMORY[0x1F40F4110]();
}

uint64_t tcp_connection_get_statistics()
{
  return MEMORY[0x1F40F4118]();
}

uint64_t tcp_connection_has_better_route()
{
  return MEMORY[0x1F40F4120]();
}

uint64_t tcp_connection_id()
{
  return MEMORY[0x1F40F4128]();
}

uint64_t tcp_connection_is_cellular()
{
  return MEMORY[0x1F40F4130]();
}

uint64_t tcp_connection_is_expensive()
{
  return MEMORY[0x1F40F4138]();
}

uint64_t tcp_connection_is_multipath()
{
  return MEMORY[0x1F40F4140]();
}

uint64_t tcp_connection_is_viable()
{
  return MEMORY[0x1F40F4148]();
}

uint64_t tcp_connection_log_event()
{
  return MEMORY[0x1F40F4150]();
}

uint64_t tcp_connection_multipath_copy_subflow_switch_counts()
{
  return MEMORY[0x1F40F4158]();
}

uint64_t tcp_connection_multipath_get_primary_subflow_ifindex()
{
  return MEMORY[0x1F40F4160]();
}

uint64_t tcp_connection_multipath_get_subflow_count()
{
  return MEMORY[0x1F40F4168]();
}

uint64_t tcp_connection_override_obscure()
{
  return MEMORY[0x1F40F4170]();
}

uint64_t tcp_connection_read()
{
  return MEMORY[0x1F40F4178]();
}

uint64_t tcp_connection_release()
{
  return MEMORY[0x1F40F4180]();
}

uint64_t tcp_connection_retain()
{
  return MEMORY[0x1F40F4188]();
}

uint64_t tcp_connection_retry()
{
  return MEMORY[0x1F40F4190]();
}

uint64_t tcp_connection_set_account_identifier()
{
  return MEMORY[0x1F40F4198]();
}

uint64_t tcp_connection_set_cancel_handler()
{
  return MEMORY[0x1F40F41A0]();
}

uint64_t tcp_connection_set_cellular_service()
{
  return MEMORY[0x1F40F41A8]();
}

uint64_t tcp_connection_set_connection_attempt_timeout()
{
  return MEMORY[0x1F40F41B0]();
}

uint64_t tcp_connection_set_connection_pool()
{
  return MEMORY[0x1F40F41B8]();
}

uint64_t tcp_connection_set_ecn_enabled()
{
  return MEMORY[0x1F40F41C0]();
}

uint64_t tcp_connection_set_event_handler()
{
  return MEMORY[0x1F40F41C8]();
}

uint64_t tcp_connection_set_extended_background_idle()
{
  return MEMORY[0x1F40F41D0]();
}

uint64_t tcp_connection_set_fallback_fast()
{
  return MEMORY[0x1F40F41D8]();
}

uint64_t tcp_connection_set_indefinite()
{
  return MEMORY[0x1F40F41E0]();
}

uint64_t tcp_connection_set_interface_by_name()
{
  return MEMORY[0x1F40F41E8]();
}

uint64_t tcp_connection_set_keepalive()
{
  return MEMORY[0x1F40F41F0]();
}

uint64_t tcp_connection_set_keepalive_offload()
{
  return MEMORY[0x1F40F41F8]();
}

uint64_t tcp_connection_set_minimum_throughput()
{
  return MEMORY[0x1F40F4200]();
}

uint64_t tcp_connection_set_no_cellular()
{
  return MEMORY[0x1F40F4208]();
}

uint64_t tcp_connection_set_no_expensive()
{
  return MEMORY[0x1F40F4210]();
}

uint64_t tcp_connection_set_no_fallback()
{
  return MEMORY[0x1F40F4218]();
}

uint64_t tcp_connection_set_opportunistic()
{
  return MEMORY[0x1F40F4220]();
}

uint64_t tcp_connection_set_persistent()
{
  return MEMORY[0x1F40F4228]();
}

uint64_t tcp_connection_set_proxies()
{
  return MEMORY[0x1F40F4230]();
}

uint64_t tcp_connection_set_receive_any_interface()
{
  return MEMORY[0x1F40F4238]();
}

uint64_t tcp_connection_set_source_application()
{
  return MEMORY[0x1F40F4240]();
}

uint64_t tcp_connection_set_source_application_by_bundle()
{
  return MEMORY[0x1F40F4248]();
}

uint64_t tcp_connection_set_traffic_class()
{
  return MEMORY[0x1F40F4250]();
}

uint64_t tcp_connection_set_url()
{
  return MEMORY[0x1F40F4258]();
}

uint64_t tcp_connection_set_usage_model()
{
  return MEMORY[0x1F40F4260]();
}

uint64_t tcp_connection_start()
{
  return MEMORY[0x1F40F4268]();
}

uint64_t tcp_connection_write()
{
  return MEMORY[0x1F40F4270]();
}

uint64_t tcp_listener_cancel()
{
  return MEMORY[0x1F40F4280]();
}

uint64_t tcp_listener_create()
{
  return MEMORY[0x1F40F4288]();
}

uint64_t tcp_listener_enable_coprocessor_interface()
{
  return MEMORY[0x1F40F4290]();
}

uint64_t tcp_listener_get_port()
{
  return MEMORY[0x1F40F4298]();
}

uint64_t tcp_listener_release()
{
  return MEMORY[0x1F40F42A0]();
}

uint64_t tcp_listener_set_accept_handler()
{
  return MEMORY[0x1F40F42B0]();
}

uint64_t tcp_listener_set_accept_handler_f()
{
  return MEMORY[0x1F40F42B8]();
}

uint64_t tcp_listener_set_error_handler()
{
  return MEMORY[0x1F40F42C0]();
}

uint64_t tcp_listener_set_error_handler_f()
{
  return MEMORY[0x1F40F42C8]();
}

uint64_t tcp_listener_set_interface()
{
  return MEMORY[0x1F40F42D0]();
}

uint64_t tcp_listener_set_port()
{
  return MEMORY[0x1F40F42D8]();
}

uint64_t tcp_listener_set_service()
{
  return MEMORY[0x1F40F42E0]();
}

uint64_t tcp_listener_start()
{
  return MEMORY[0x1F40F42E8]();
}

int32_t uidna_nameToASCII(const UIDNA *idna, const UChar *name, int32_t length, UChar *dest, int32_t capacity, UIDNAInfo *pInfo, UErrorCode *pErrorCode)
{
  return MEMORY[0x1F4180048](idna, name, *(void *)&length, dest, *(void *)&capacity, pInfo, pErrorCode);
}

UIDNA *__cdecl uidna_openUTS46(uint32_t options, UErrorCode *pErrorCode)
{
  return (UIDNA *)MEMORY[0x1F4180068](*(void *)&options, pErrorCode);
}

int unlink(const char *a1)
{
  return MEMORY[0x1F40CE5E0](a1);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
{
}

uint64_t voucher_copy()
{
  return MEMORY[0x1F40CE710]();
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1F40CE928](*(void *)&__fd, __buf, __nbyte);
}

uint64_t xpc_activity_should_be_data_budgeted()
{
  return MEMORY[0x1F40CE9D8]();
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return MEMORY[0x1F40CEA18](xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEA30](objects, count);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x1F40CEA58](xarray);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1F40CEAA8](xarray, index);
}

void xpc_array_set_string(xpc_object_t xarray, size_t index, const char *string)
{
}

void xpc_array_set_uint64(xpc_object_t xarray, size_t index, uint64_t value)
{
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBD0](name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return MEMORY[0x1F40CEE08](xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEE20](keys, values, count);
}

size_t xpc_dictionary_get_count(xpc_object_t xdict)
{
  return MEMORY[0x1F40CEE88](xdict);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x1F40CEE98](xdict, key, length);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEC8](xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1F40CEEF0](xdict, key);
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1F40CF148](object);
}

void xpc_release(xpc_object_t object)
{
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return (const char *)MEMORY[0x1F40CF2C8](xstring);
}

xpc_object_t xpc_uint64_create(uint64_t value)
{
  return (xpc_object_t)MEMORY[0x1F40CF320](value);
}

uint64_t xpc_uint64_get_value(xpc_object_t xuint)
{
  return MEMORY[0x1F40CF330](xuint);
}

uint64_t GSSCreateCredentialFromUUID_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E73C8]();
}

uint64_t gss_import_name_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E7428]();
}

uint64_t gss_aapl_initial_cred_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E73D0]();
}

uint64_t gss_release_name_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E7478]();
}

uint64_t gss_init_sec_context_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E7438]();
}

uint64_t gss_acquire_cred_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E73E8]();
}

uint64_t gss_release_buffer_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E7460]();
}

uint64_t gss_delete_sec_context_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E7400]();
}

uint64_t gss_release_cred_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E7468]();
}

uint64_t gss_destroy_cred_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E7410]();
}

uint64_t MKBUserTypeDeviceMode_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_MobileKeyBag)) {
    dlopenHelper_MobileKeyBag(a1);
  }
  return MEMORY[0x1F412FA18]();
}

uint64_t AnalyticsIsEventUsed_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreAnalytics)) {
    dlopenHelper_CoreAnalytics(a1);
  }
  return MEMORY[0x1F4113888]();
}

uint64_t AnalyticsSendEvent_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreAnalytics)) {
    dlopenHelper_CoreAnalytics(a1);
  }
  return MEMORY[0x1F41138A0]();
}

uint64_t appSSO_handleResponse_delayInitStub(double a1)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AppSSOCore)) {
    dlopenHelper_AppSSOCore(a1);
  }
  return MEMORY[0x1F4109020]();
}

uint64_t MKBDeviceUnlockedSinceBoot_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_MobileKeyBag)) {
    dlopenHelper_MobileKeyBag(a1);
  }
  return MEMORY[0x1F412F958]();
}

uint64_t AnalyticsSendEventLazy_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreAnalytics)) {
    dlopenHelper_CoreAnalytics(a1);
  }
  return MEMORY[0x1F41138B8]();
}

uint64_t _CTServerConnectionCreate_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreTelephony)) {
    dlopenHelper_CoreTelephony(a1);
  }
  return MEMORY[0x1F40DF0B8]();
}

uint64_t _CTServerConnectionCopyPacketContextInterfaceName_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreTelephony)) {
    dlopenHelper_CoreTelephony(a1);
  }
  return MEMORY[0x1F40DF080]();
}

uint64_t CGSizeCreateDictionaryRepresentation_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreGraphics)) {
    dlopenHelper_CoreGraphics(a1);
  }
  return MEMORY[0x1F40DB4D0]();
}

uint64_t entr_act_end_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_libenergytrace_dylib)) {
    dlopenHelper_libenergytrace_dylib(a1);
  }
  return MEMORY[0x1F417F608]();
}

uint64_t spd_client_checkout_socket_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_libsp_dylib)) {
    dlopenHelper_libsp_dylib(a1);
  }
  return MEMORY[0x1F4181EC0]();
}

uint64_t spd_client_destroy_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_libsp_dylib)) {
    dlopenHelper_libsp_dylib(a1);
  }
  return MEMORY[0x1F4181ED0]();
}

uint64_t entr_act_modify_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_libenergytrace_dylib)) {
    dlopenHelper_libenergytrace_dylib(a1);
  }
  return MEMORY[0x1F417F610]();
}

uint64_t spd_client_create_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_libsp_dylib)) {
    dlopenHelper_libsp_dylib(a1);
  }
  return MEMORY[0x1F4181EC8]();
}

uint64_t spd_client_checkin_socket_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_libsp_dylib)) {
    dlopenHelper_libsp_dylib(a1);
  }
  return MEMORY[0x1F4181EB8]();
}

uint64_t _CTServerConnectionCarrierSettingsCopyValue_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_CoreTelephony)) {
    dlopenHelper_CoreTelephony(a1);
  }
  return MEMORY[0x1F40DF000]();
}

uint64_t entr_shouldtrace_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_libenergytrace_dylib)) {
    dlopenHelper_libenergytrace_dylib(a1);
  }
  return MEMORY[0x1F417F620]();
}

uint64_t entr_act_begin_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_libenergytrace_dylib)) {
    dlopenHelper_libenergytrace_dylib(a1);
  }
  return MEMORY[0x1F417F600]();
}

uint64_t AOSAccountCreate_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AOSKit)) {
    dlopenHelper_AOSKit(a1);
  }
  return MEMORY[0x1F4105328]();
}

uint64_t _AOSAccountResolveAuthFailure_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AOSKit)) {
    dlopenHelper_AOSKit(a1);
  }
  return MEMORY[0x1F4105340]();
}

uint64_t AOSTransactionSuccessful_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AOSKit)) {
    dlopenHelper_AOSKit(a1);
  }
  return MEMORY[0x1F4105338]();
}

uint64_t AOSTransactionGetError_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AOSKit)) {
    dlopenHelper_AOSKit(a1);
  }
  return MEMORY[0x1F4105330]();
}

uint64_t AOSAccountCopyAuthInfo_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AOSKit)) {
    dlopenHelper_AOSKit(a1);
  }
  return MEMORY[0x1F4105320]();
}

uint64_t HeimCredSetImpersonateBundle_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_Heimdal)) {
    dlopenHelper_Heimdal(a1);
  }
  return MEMORY[0x1F4121780]();
}

uint64_t symptom_new_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_SymptomReporter)) {
    dlopenHelper_SymptomReporter(a1);
  }
  return MEMORY[0x1F415C9D8]();
}

uint64_t symptom_set_qualifier_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_SymptomReporter)) {
    dlopenHelper_SymptomReporter(a1);
  }
  return MEMORY[0x1F415CA20]();
}

uint64_t symptom_set_additional_qualifier_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_SymptomReporter)) {
    dlopenHelper_SymptomReporter(a1);
  }
  return MEMORY[0x1F415CA10]();
}

uint64_t symptom_send_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_SymptomReporter)) {
    dlopenHelper_SymptomReporter(a1);
  }
  return MEMORY[0x1F415C9E8]();
}

uint64_t CPCopyBundleIdentifierAndTeamFromAuditToken_delayInitStub(double a1)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AppSupport)) {
    dlopenHelper_AppSupport(a1);
  }
  return MEMORY[0x1F41092B8]();
}

uint64_t appSSO_willHandle_delayInitStub(double a1)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AppSSOCore)) {
    dlopenHelper_AppSSOCore(a1);
  }
  return MEMORY[0x1F4109030]();
}

uint64_t appSSO_handleResponseImpersonationCredential_delayInitStub(double a1)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AppSSOCore)) {
    dlopenHelper_AppSSOCore(a1);
  }
  return MEMORY[0x1F4109028]();
}

uint64_t MKBDeviceFormattedForContentProtection_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_MobileKeyBag)) {
    dlopenHelper_MobileKeyBag(a1);
  }
  return MEMORY[0x1F412F930]();
}

uint64_t CPCopyBundleIdentifierAndTeamFromSecTaskRef_delayInitStub(double a1)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AppSupport)) {
    dlopenHelper_AppSupport(a1);
  }
  return MEMORY[0x1F41092C8]();
}

uint64_t symptom_set_additional_digest_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_SymptomReporter)) {
    dlopenHelper_SymptomReporter(a1);
  }
  return MEMORY[0x1F415CA00]();
}

uint64_t symptom_framework_init_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_SymptomReporter)) {
    dlopenHelper_SymptomReporter(a1);
  }
  return MEMORY[0x1F415C9C8]();
}

uint64_t gss_iter_creds_delayInitStub(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    dlopenHelper_GSS(a1);
  }
  return MEMORY[0x1F40E7450]();
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_FTServices(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_AOSKit(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_Accounts(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_libenergytrace_dylib(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_GSS(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_RunningBoardServices(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_libsp_dylib(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_CoreGraphics(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_NetworkServiceProxy(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_CoreAnalytics(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_Heimdal(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_MobileKeyBag(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_DuetActivityScheduler(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_CoreTelephony(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_AppSupport(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_AppSSOCore(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_InternationalSupport(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_StreamingExtractor(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_AVFoundation(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_StreamingZip(double a1)
{
  return a1;
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> dlopenHelper_SymptomReporter(double a1)
{
  return a1;
}

void gotLoadHelper_x20__OBJC_CLASS___SZExtractor(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_StreamingZip)) {
    dlopenHelper_StreamingZip(a1);
  }
}

double gotLoadHelper_x8__OBJC_CLASS___STRemoteExtractor(double result)
{
  if (!atomic_load(&dlopenHelperFlag_StreamingExtractor)) {
    return dlopenHelper_StreamingExtractor(result);
  }
  return result;
}

double gotLoadHelper_x8__GSSCreateCredentialFromUUID(double result)
{
  if (!atomic_load(&dlopenHelperFlag_GSS)) {
    return dlopenHelper_GSS(result);
  }
  return result;
}

double gotLoadHelper_x8__kMKBDeviceModeKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_MobileKeyBag)) {
    return dlopenHelper_MobileKeyBag(result);
  }
  return result;
}

double gotLoadHelper_x8__kMKBUserTypeKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_MobileKeyBag)) {
    return dlopenHelper_MobileKeyBag(result);
  }
  return result;
}

double gotLoadHelper_x8__kMKBDeviceModeMultiUser(double result)
{
  if (!atomic_load(&dlopenHelperFlag_MobileKeyBag)) {
    return dlopenHelper_MobileKeyBag(result);
  }
  return result;
}

double gotLoadHelper_x8__kMKBUserTypeEphemeral(double result)
{
  if (!atomic_load(&dlopenHelperFlag_MobileKeyBag)) {
    return dlopenHelper_MobileKeyBag(result);
  }
  return result;
}

double gotLoadHelper_x8__InternationalSupportVersionNumber(double result)
{
  if (!atomic_load(&dlopenHelperFlag_InternationalSupport)) {
    return dlopenHelper_InternationalSupport(result);
  }
  return result;
}

void gotLoadHelper_x20__OBJC_CLASS___RBSAssertion(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_RunningBoardServices)) {
    dlopenHelper_RunningBoardServices(a1);
  }
}

void gotLoadHelper_x23__RBSAssertionErrorDomain(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_RunningBoardServices)) {
    dlopenHelper_RunningBoardServices(a1);
  }
}

double gotLoadHelper_x8__OBJC_CLASS___RBSProcessHandle(double result)
{
  if (!atomic_load(&dlopenHelperFlag_RunningBoardServices)) {
    return dlopenHelper_RunningBoardServices(result);
  }
  return result;
}

double gotLoadHelper_x8__RBSProcessTimeLimitationNone(double result)
{
  if (!atomic_load(&dlopenHelperFlag_RunningBoardServices)) {
    return dlopenHelper_RunningBoardServices(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___RBSDomainAttribute(double result)
{
  if (!atomic_load(&dlopenHelperFlag_RunningBoardServices)) {
    return dlopenHelper_RunningBoardServices(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___RBSAcquisitionCompletionAttribute(double result)
{
  if (!atomic_load(&dlopenHelperFlag_RunningBoardServices)) {
    return dlopenHelper_RunningBoardServices(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___RBSTarget(double result)
{
  if (!atomic_load(&dlopenHelperFlag_RunningBoardServices)) {
    return dlopenHelper_RunningBoardServices(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___RBSAssertion(double result)
{
  if (!atomic_load(&dlopenHelperFlag_RunningBoardServices)) {
    return dlopenHelper_RunningBoardServices(result);
  }
  return result;
}

double gotLoadHelper_x8__SOErrorDomain(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AppSSOCore)) {
    return dlopenHelper_AppSSOCore(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(double result)
{
  if (!atomic_load(&dlopenHelperFlag_NetworkServiceProxy)) {
    return dlopenHelper_NetworkServiceProxy(result);
  }
  return result;
}

double gotLoadHelper_x9__SOErrorDomain(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AppSSOCore)) {
    return dlopenHelper_AppSSOCore(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS____DASActivity(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS____DASScheduler(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8___CTServerConnectionCreate(double result)
{
  if (!atomic_load(&dlopenHelperFlag_CoreTelephony)) {
    return dlopenHelper_CoreTelephony(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___AVAssetDownloadSession(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AVFoundation)) {
    return dlopenHelper_AVFoundation(result);
  }
  return result;
}

void gotLoadHelper_x19__OBJC_CLASS___AVAssetDownloadSession(double a1)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AVFoundation)) {
    dlopenHelper_AVFoundation(a1);
  }
}

double gotLoadHelper_x8__OBJC_CLASS___AVAssetDownloadConfiguration(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AVFoundation)) {
    return dlopenHelper_AVFoundation(result);
  }
  return result;
}

void gotLoadHelper_x20__OBJC_CLASS___STRemoteExtractor(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_StreamingExtractor)) {
    dlopenHelper_StreamingExtractor(a1);
  }
}

void gotLoadHelper_x19__OBJC_CLASS___RBSProcessHandle(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_RunningBoardServices)) {
    dlopenHelper_RunningBoardServices(a1);
  }
}

double gotLoadHelper_x8__spd_client_create(double result)
{
  if (!atomic_load(&dlopenHelperFlag_libsp_dylib)) {
    return dlopenHelper_libsp_dylib(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___AVMediaSelection(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AVFoundation)) {
    return dlopenHelper_AVFoundation(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___AVURLAsset(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AVFoundation)) {
    return dlopenHelper_AVFoundation(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___AVAggregateAssetDownloadTask(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AVFoundation)) {
    return dlopenHelper_AVFoundation(result);
  }
  return result;
}

double gotLoadHelper_x8__kAOSAuthTrustInfoKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_AOSKit)) {
    return dlopenHelper_AOSKit(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___FTURLRequestMessage(double result)
{
  if (!atomic_load(&dlopenHelperFlag_FTServices)) {
    return dlopenHelper_FTServices(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenChallenge(double result)
{
  if (!atomic_load(&dlopenHelperFlag_NetworkServiceProxy)) {
    return dlopenHelper_NetworkServiceProxy(result);
  }
  return result;
}

void gotLoadHelper_x27__kAOSMMeAuthTokenKey(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_AOSKit)) {
    dlopenHelper_AOSKit(a1);
  }
}

double gotLoadHelper_x8__kAOSPersonIDKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_AOSKit)) {
    return dlopenHelper_AOSKit(result);
  }
  return result;
}

double gotLoadHelper_x8___DASSchedulingPriorityUserInitiated(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8___DASActivityDurationShort(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8___DASSchedulingPriorityUtility(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8___DASSchedulingPriorityUserInitiatedOvercommit(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

void gotLoadHelper_x22___DASActivityTransferSizeSmall(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    dlopenHelper_DuetActivityScheduler(a1);
  }
}

void gotLoadHelper_x23___DASActivityTransferSizeVerySmall(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    dlopenHelper_DuetActivityScheduler(a1);
  }
}

double gotLoadHelper_x8___DASActivityTransferSizeGigantic(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x10___DASActivityTransferSizeVeryLarge(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x12___DASActivityTransferSizeLarge(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x14___DASActivityTransferSizeModerate(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8___DASActivityTransferSizeVeryLarge(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8___DASActivityTransferSizeLarge(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8___DASActivityTransferSizeModerate(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8__kNWEndpointKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8__kNWParametersKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8___DASSchedulingPriorityMaintenance(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8___DASSchedulingPriorityBackground(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8___DASUpdateActivityCellTransferKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x9___DASUpdateActivityWifiTransferKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x9___DASUpdateActivityExpensiveTransferKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x10___DASUpdateActivityInexpensiveTransferKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x10___DASUpdateActivityUploadedBytesKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x11___DASUpdateActivityDownloadedBytesKey(double result)
{
  if (!atomic_load(&dlopenHelperFlag_DuetActivityScheduler)) {
    return dlopenHelper_DuetActivityScheduler(result);
  }
  return result;
}

double gotLoadHelper_x8__HeimCredSetImpersonateBundle(double result)
{
  if (!atomic_load(&dlopenHelperFlag_Heimdal)) {
    return dlopenHelper_Heimdal(result);
  }
  return result;
}

double gotLoadHelper_x8__symptom_framework_init(double result)
{
  if (!atomic_load(&dlopenHelperFlag_SymptomReporter)) {
    return dlopenHelper_SymptomReporter(result);
  }
  return result;
}

double gotLoadHelper_x8__CPCopyBundleIdentifierAndTeamFromAuditToken(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AppSupport)) {
    return dlopenHelper_AppSupport(result);
  }
  return result;
}

double gotLoadHelper_x8__OBJC_CLASS___FTMessageDelivery_DualMode(double result)
{
  if (!atomic_load(&dlopenHelperFlag_FTServices)) {
    return dlopenHelper_FTServices(result);
  }
  return result;
}

void gotLoadHelper_x21__OBJC_CLASS___ACOAuthSigner(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_Accounts)) {
    dlopenHelper_Accounts(a1);
  }
}

void gotLoadHelper_x21__OBJC_CLASS___AVAssetDownloadConfiguration(double a1)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AVFoundation)) {
    dlopenHelper_AVFoundation(a1);
  }
}

double gotLoadHelper_x8__OBJC_CLASS___ACAccountStore(double result)
{
  if (!atomic_load(&dlopenHelperFlag_Accounts)) {
    return dlopenHelper_Accounts(result);
  }
  return result;
}

double gotLoadHelper_x9__kMobileKeyBagLockStatusNotifyToken(double result)
{
  if (!atomic_load(&dlopenHelperFlag_MobileKeyBag)) {
    return dlopenHelper_MobileKeyBag(result);
  }
  return result;
}

double gotLoadHelper_x8__CPCopyBundleIdentifierAndTeamFromSecTaskRef(double result)
{
  if (!atomic_load((unsigned int *)&dlopenHelperFlag_AppSupport)) {
    return dlopenHelper_AppSupport(result);
  }
  return result;
}

void gotLoadHelper_x21__OBJC_CLASS___PrivacyProxyClient(double a1)
{
  if (!atomic_load(&dlopenHelperFlag_NetworkServiceProxy)) {
    dlopenHelper_NetworkServiceProxy(a1);
  }
}